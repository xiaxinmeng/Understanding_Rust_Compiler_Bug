{"sha": "ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU0NWEzMmRhZTI1M2Y3ZGFhOTY2NTczZWI4Y2I2NGIyY2Y3YmY1Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-11-08T18:33:42Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-11-08T18:33:42Z"}, "message": "Merge of the scalar-storage-order branch.\n\nFrom-SVN: r229965", "tree": {"sha": "cf927ff52a6d5ba28290472db09363fe67a835d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf927ff52a6d5ba28290472db09363fe67a835d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/comments", "author": null, "committer": null, "parents": [{"sha": "eb11eb157cf07500e2915da8a72f2f3a501cc5ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb11eb157cf07500e2915da8a72f2f3a501cc5ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb11eb157cf07500e2915da8a72f2f3a501cc5ae"}], "stats": {"total": 10493, "additions": 9969, "deletions": 524}, "files": [{"sha": "81664bf682652391f2144bc4b8ed7c3b2f8533c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1,3 +1,276 @@\n+2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/extend.texi (type attributes): Document scalar_storage_order.\n+\t(Structure-Packing Pragmas): Rename into...\n+\t(Structure-Layout Pragmas): ...this.  Document scalar_storage_order.\n+\t* doc/invoke.texi (C Dialect Options): Document -fsso-struct\n+\t(Warnings): Document -Wno-scalar-storage-order.\n+\t* flag-types.h (enum scalar_storage_order_kind): New enumeration.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Adjust calls to\n+\textract_bit_field and store_bit_field.\n+\t(initialize_argument_information): Adjust call to store_expr.\n+\t(load_register_parameters): Adjust call to extract_bit_field.\n+\t* expmed.c (check_reverse_storage_order_support): New function.\n+\t(check_reverse_float_storage_order_support): Likewise.\n+\t(flip_storage_order): Likewise.\n+\t(store_bit_field_1): Add REVERSE parameter.  Flip the storage order\n+\tof the value if it is true.  Pass REVERSE to recursive call after\n+\tadjusting the target offset.\n+\tDo not use extraction or movstrict instruction if REVERSE is true.\n+\tPass REVERSE to store_fixed_bit_field.\n+\t(store_bit_field): Add REVERSE parameter and pass to it to above.\n+\t(store_fixed_bit_field): Add REVERSE parameter and pass to it to\n+\tstore_split_bit_field and store_fixed_bit_field_1.\n+\t(store_fixed_bit_field_1):  Add REVERSE parameter.  Flip the storage\n+\torder of the value if it is true and adjust the target offset.\n+\t(store_split_bit_field): Add REVERSE parameter and pass it to\n+\tstore_fixed_bit_field.  Adjust the target offset if it is true.\n+\t(extract_bit_field_1): Add REVERSE parameter.  Flip the storage order\n+\tof the value if it is true.  Pass REVERSE to recursive call after\n+\tadjusting the target offset.\n+\tDo not use extraction or subreg instruction if REVERSE is true.\n+\tPass REVERSE to extract_fixed_bit_field.\n+\t(extract_bit_field): Add REVERSE parameter and pass to it to above.\n+\t(extract_fixed_bit_field): Add REVERSE parameter and pass to it to\n+\textract_split_bit_field and extract_fixed_bit_field_1.\n+\t(extract_fixed_bit_field_1): Add REVERSE parameter.  Flip the storage\n+\torder of the value if it is true and adjust the target offset.\n+\t(extract_split_bit_field): Add REVERSE parameter and pass it to\n+\textract_fixed_bit_field.  Adjust the target offset if it is true.\n+\t* expmed.h (flip_storage_order): Declare.\n+\t(store_bit_field): Adjust prototype.\n+\t(extract_bit_field): Likewise.\n+\t* expr.c (emit_group_load_1): Adjust calls to extract_bit_field.\n+\t(emit_group_store): Adjust call to store_bit_field.\n+\t(copy_blkmode_from_reg): Likewise.\n+\t(copy_blkmode_to_reg): Likewise.\n+\t(write_complex_part): Likewise.\n+\t(read_complex_part): Likewise.\n+\t(optimize_bitfield_assignment_op): Add REVERSE parameter.  Assert\n+\tthat it isn't true if the target is a register.\n+\t<PLUS_EXPR>: If it is, do not optimize unless bitsize is equal to 1,\n+\tand flip the storage order of the value.\n+\t<BIT_IOR_EXPR>: Flip the storage order of the value.\n+\t(get_bit_range): Adjust call to get_inner_reference.\n+\t(expand_assignment): Adjust calls to get_inner_reference, store_expr,\n+\toptimize_bitfield_assignment_op and store_field.  Handle MEM_EXPRs\n+\twith reverse storage order.\n+\t(store_expr_with_bounds): Add REVERSE parameter and pass it to\n+\trecursive calls and call to store_bit_field.  Force the value into a\n+\tregister if it is true and then flip the storage order of the value.\n+\t(store_expr): Add REVERSE parameter and pass it to above.\n+\t(categorize_ctor_elements_1): Adjust call to\n+\tinitializer_constant_valid_p.\n+\t(store_constructor_field): Add REVERSE parameter and pass it to\n+\trecursive calls and call to store_field.\n+\t(store_constructor): Add REVERSE parameter and pass it to calls to\n+\tstore_constructor_field and store_expr.  Set it to true for an\n+\taggregate type with TYPE_REVERSE_STORAGE_ORDER.\n+\t(store_field): Add REVERSE parameter and pass it to recursive calls\n+\tand calls to store_expr and store_bit_field.  Temporarily flip the\n+\tstorage order of the value with record type and integral mode and\n+\tadjust the shift if it is true.\n+\t(get_inner_reference): Add PREVERSEP parameter and set it to true\n+\tupon encoutering a reference with reverse storage order.\n+\t(expand_expr_addr_expr_1): Adjust call to get_inner_reference.\n+\t(expand_constructor): Adjust call to store_constructor.\n+\t(expand_expr_real_2) <CASE_CONVERT>: Pass TYPE_REVERSE_STORAGE_ORDER\n+\tof the union type to store_expr in the MEM case and assert that it\n+\tisn't set in the REG case.  Adjust call to store_field.\n+\t(expand_expr_real_1) <MEM_REF>: Handle reverse storage order.\n+\t<normal_inner_ref>: Add REVERSEP variable and adjust calls to\n+\tget_inner_reference and extract_bit_field. Temporarily flip the\n+\tstorage order of the value with record type and integral mode and\n+\tadjust the shift if it is true.  Flip the storage order of the value\n+\tat the end if it is true.\n+\t<VIEW_CONVERT_EXPR>: Add REVERSEP variable and adjust call to\n+\tget_inner_reference.  Do not fetch an inner reference if it is true.\n+\t* expr.h (store_expr_with_bounds): Ajust prototype.\n+\t(store_expr): Likewise.\n+\t* fold-const.c (make_bit_field_ref): Add REVERSEP parameter and set\n+\tREF_REVERSE_STORAGE_ORDER on the reference according to it.\n+\t(optimize_bit_field_compare): Deal with reverse storage order.\n+\tAdjust calls to get_inner_reference and make_bit_field_ref.\n+\t(decode_field_reference): Add PREVERSEP parameter and adjust call to\n+\tget_inner_reference.\n+\t(fold_truth_andor_1): Deal with reverse storage order.  Adjust calls\n+\tto decode_field_reference and make_bit_field_ref.\n+\t(fold_unary_loc) <CASE_CONVERT>: Adjust call to get_inner_reference.\n+\t<VIEW_CONVERT_EXPR>: Propagate the REF_REVERSE_STORAGE_ORDER flag.\n+\t(fold_comparison): Adjust call to get_inner_reference.\n+\t(split_address_to_core_and_offset): Adjust call to\n+\tget_inner_reference.\n+\t* gimple-expr.c (useless_type_conversion_p): Return false for array\n+\ttypes with different TYPE_REVERSE_STORAGE_ORDER flag.\n+\t* gimplify.c (gimplify_expr) <MEM_REF>: Propagate the\n+\tREF_REVERSE_STORAGE_ORDER flag.\n+\t* lto-streamer-out.c (hash_tree): Deal with\n+\tTYPE_REVERSE_STORAGE_ORDER.\n+\t* output.h (assemble_real): Adjust prototype.\n+\t* print-tree.c (print_node): Convey TYPE_REVERSE_STORAGE_ORDER.\n+\t* stor-layout.c (finish_record_layout): Propagate the\n+\tTYPE_REVERSE_STORAGE_ORDER flag to the variants.\n+\t* tree-core.h (TYPE_REVERSE_STORAGE_ORDER): Document.\n+\t(TYPE_SATURATING): Adjust.\n+\t(REF_REVERSE_STORAGE_ORDER): Document.\n+\t* tree-dfa.c (get_ref_base_and_extent): Add PREVERSE parameter and\n+\tset it to true upon encoutering a reference with reverse storage\n+\torder.\n+\t* tree-dfa.h (get_ref_base_and_extent): Adjust prototype.\n+\t* tree-inline.c (remap_gimple_op_r): Propagate the\n+\tREF_REVERSE_STORAGE_ORDER flag.\n+\t(copy_tree_body_r): Likewise.\n+\t* tree-outof-ssa.c (insert_value_copy_on_edge): Adjust call to\n+\tstore_expr.\n+\t* tree-streamer-in.c (unpack_ts_base_value_fields): Deal with\n+\tTYPE_REVERSE_STORAGE_ORDER and REF_REVERSE_STORAGE_ORDER.\n+\t* tree-streamer-out.c (pack_ts_base_value_fields): Likewise.\n+\t* tree.c (stabilize_reference) <BIT_FIELD_REF>: Propagate the\n+\tREF_REVERSE_STORAGE_ORDER flag.\n+\t(verify_type_variant): Deal with TYPE_REVERSE_STORAGE_ORDER.\n+\t(gimple_canonical_types_compatible_p): Likewise.\n+\t* tree.h (TYPE_REVERSE_STORAGE_ORDER): New flag.\n+\t(TYPE_SATURATING): Adjust.\n+\t(REF_REVERSE_STORAGE_ORDER): New flag.\n+\t(reverse_storage_order_for_component_p): New inline predicate.\n+ \t(storage_order_barrier_p): Likewise.\n+\t(get_inner_reference): Adjust prototype.\n+\t* varasm.c: Include expmed.h.\n+\t(assemble_variable_contents): Adjust call to output_constant.\n+\t(assemble_real): Add REVERSE parameter.  Flip the storage\n+\torder of the value if REVERSE is true.\n+\t(compare_constant) <CONSTRUCTOR>: Compare TYPE_REVERSE_STORAGE_ORDER.\n+\t(assemble_constant_contents): Adjust call to output_constant.\n+\t(output_constant_pool_2): Adjust call to assemble_real.\n+\t(initializer_constant_valid_p_1) <CONSTRUCTOR>: Deal with\n+\tTYPE_REVERSE_STORAGE_ORDER.\n+\t(initializer_constant_valid_p): Add REVERSE parameter.\n+\t(output_constant): Add REVERSE parameter.\n+\t<INTEGER_TYPE>: Flip the storage order of the value if REVERSE is true.\n+\t<REAL_TYPE>: Adjust call to assemble_real.\n+\t<COMPLEX_TYPE>: Pass it to recursive calls.\n+\t<ARRAY_TYPE>: Likewise.  Adjust call to output_constructor.\n+\t<RECORD_TYPE>: Likewise.  Adjust call to output_constructor.\n+\t(struct oc_local_state): Add REVERSE field.\n+\t(output_constructor_array_range): Adjust calls to output_constant.\n+\t(output_constructor_regular_field): Likewise.\n+\t(output_constructor_bitfield): Adjust call to output_constructor.\n+\tFlip the storage order of the value if REVERSE is true.\n+\t(output_constructor): Add REVERSE parameter.  Set it to true for an\n+\taggregate type with TYPE_REVERSE_STORAGE_ORDER.  Adjust call to\n+\toutput_constructor_bitfield.\n+\t* varasm.h (initializer_constant_valid_p): Default REVERSE to false.\n+\t* asan.c (instrument_derefs): Adjust call to get_inner_reference.\n+\t* builtins.c (get_object_alignment_2): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Adjust call to get_inner_reference\n+\tand get_ref_base_and_extent.\n+\t* dbxout.c (dbxout_expand_expr): Likewise.\n+\t* dwarf2out.c (add_var_loc_to_decl): Likewise.\n+\t(loc_list_for_address_of_addr_expr_of_indirect_ref): Likewise.\n+\t(loc_list_from_tree): Likewise.\n+\t(fortran_common): Likewise.\n+\t* gimple-fold.c (gimple_fold_builtin_memory_op): Adjust calls to\n+\tget_ref_base_and_extent.\n+\t(get_base_constructor): Likewise.\n+\t(fold_const_aggregate_ref_1): Likewise.\n+\t* gimple-laddress.c (pass_laddress::execute): Adjust call to\n+\tget_inner_reference.\n+\t* gimple-ssa-strength-reduction.c (slsr_process_ref): Adjust call to\n+\tget_inner_reference and bail out on reverse storage order.\n+\t* ifcvt.c (noce_emit_move_insn): Adjust calls to store_bit_field.\n+\t* ipa-cp.c (ipa_get_jf_ancestor_result): Adjust call to\n+\tbuild_ref_for_offset.\n+\t* ipa-polymorphic-call.c (set_by_invariant): Adjust call to\n+\tget_ref_base_and_extent.\n+\t(ipa_polymorphic_call_context): Likewise.\n+\t(extr_type_from_vtbl_ptr_store): Likewise.\n+\t(check_stmt_for_type_change): Likewise.\n+\t(get_dynamic_type): Likewise.\n+\t* ipa-prop.c (ipa_load_from_parm_agg_1): Adjust call to\n+\tget_ref_base_and_extent.\n+\t(compute_complex_assign_jump_func): Likewise.\n+\t(get_ancestor_addr_info): Likewise.\n+\t(compute_known_type_jump_func): Likewise.\n+\t(determine_known_aggregate_parts): Likewise.\n+\t(ipa_get_adjustment_candidate): Likewise.\n+\t(ipa_modify_call_arguments): Set REF_REVERSE_STORAGE_ORDER on\n+\tMEM_REF.\n+\t* ipa-prop.h (ipa_parm_adjustment): Add REVERSE field.\n+\t(build_ref_for_offset): Adjust prototype.\n+\t* simplify-rtx.c (delegitimize_mem_from_attrs): Adjust call to\n+\tget_inner_reference.\n+\t* tree-affine.c (tree_to_aff_combination): Adjust call to\n+\tget_inner_reference.\n+\t(get_inner_reference_aff): Likewise.\n+\t* tree-data-ref.c (split_constant_offset_1): Likewise.\n+\t(dr_analyze_innermost): Likewise.  Bail out if reverse storage order.\n+\t* tree-scalar-evolution.c (interpret_rhs_expr): Adjust call to\n+\tget_inner_reference.\n+\t* tree-sra.c (struct access): Add REVERSE and move WRITE around.\n+\t(dump_access): Print new fields.\n+\t(create_access): Adjust call to get_ref_base_and_extent and set the\n+\tREVERSE flag according to the result.\n+\t(completely_scalarize_record): Set the REVERSE flag.\n+\t(scalarize_elem): Add REVERSE parameter.\n+\t(build_access_from_expr_1): Preserve storage order barriers.\n+\t(build_accesses_from_assign): Likewise.\n+\t(build_ref_for_offset): Add REVERSE parameter and set the\n+\tREF_REVERSE_STORAGE_ORDER flag accordingly.\n+\t(build_ref_for_model): Adjust call to build_ref_for_offset and clear\n+\tthe REF_REVERSE_STORAGE_ORDER flag if there are components.\n+\t(analyze_access_subtree): Likewise.\n+\t(create_artificial_child_access): Set the REVERSE flag.\n+\t(get_access_for_expr): Adjust call to get_ref_base_and_extent.\n+\t(turn_representatives_into_adjustments): Propagate REVERSE flag.\n+\t(ipa_sra_check_caller): Adjust call to get_inner_reference.\n+\t* tree-ssa-alias.c (ao_ref_base): Adjust call to\n+\tget_ref_base_and_extent.\n+\t(aliasing_component_refs_p): Likewise.\n+\t(stmt_kills_ref_p_1): Likewise.\n+\t* tree-ssa-dce.c (mark_aliased_reaching_defs_necessary_1): Likewise.\n+\t* tree-ssa-loop-ivopts.c (may_be_nonaddressable_p) <MEM_REF>: New.\n+\tReturn true if reverse storage order.\n+\t<BIT_FIELD_REF>: Likewise.\n+\t<COMPONENT_REF>: Likewise.\n+\t<ARRAY_REF>: Likewise.\n+\t<ARRAY_RANGE_REF>: Likewise.\n+\t(split_address_cost): Likewise.  Bail out if reverse storage order.\n+\t* tree-ssa-math-opts.c (find_bswap_or_nop_load): Adjust call to\n+\tget_inner_reference.  Bail out if reverse storage order.\n+\t(bswap_replace): Adjust call to get_inner_reference.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1) <MEM_REF>: Set\n+\tthe REF_REVERSE_STORAGE_ORDER flag.\n+\t<BIT_FIELD_REF>: Likewise.\n+\t* tree-ssa-sccvn.c (vn_reference_eq): Return false on storage order\n+\tbarriers.\n+\t(copy_reference_ops_from_ref) <MEM_REF>: Set REVERSE field according\n+ \tto the REF_REVERSE_STORAGE_ORDER flag.\n+\t<BIT_FIELD_REF>: Likewise.\n+\t<VIEW_CONVERT_EXPR>: Set it for storage order barriers.\n+\t(contains_storage_order_barrier_p): New predicate.\n+\t(vn_reference_lookup_3): Adjust calls to get_ref_base_and_extent.\n+\tPunt on storage order barriers if necessary.\n+\t* tree-ssa-sccvn.h (struct vn_reference_op_struct): Add REVERSE.\n+\t* tree-ssa-structalias.c (get_constraint_for_component_ref): Adjust\n+\tcall to get_ref_base_and_extent.\n+\t(do_structure_copy): Likewise.\n+\t* tree-vect-data-refs.c (vect_check_gather): Adjust call to\n+\tget_inner_reference.\n+\t(vect_analyze_data_refs): Likewise.  Bail out if reverse storage\n+\torder.\n+\t* tsan.c (instrument_expr): Adjust call to get_inner_reference.\n+\t* ubsan.c (instrument_bool_enum_load): Likewise.\n+\t(instrument_object_size): Likewise.\n+\t* var-tracking.c (track_expr_p): Adjust call to\n+\tget_ref_base_and_extent\n+\t* config/mips/mips.c (r10k_safe_mem_expr_p): Adjust call to\n+\tget_inner_reference.\n+\t* config/s390/s390.c (s390_expand_atomic): Adjust call to\n+\tstore_bit_field.\n+\t* config/tilegx/tilegx.c (tilegx_expand_unaligned_load): Adjust call to\n+\textract_bit_field.\n+\t* config/tilepro/tilepro.c (tilepro_expand_unaligned_load): Likewise.\n+\n 2015-11-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.opt (mfix-at697f): Add final period."}, {"sha": "ca1cb618be688ae31725d1b736a7de4970588bfe", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1,3 +1,28 @@\n+2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (set_reverse_storage_order_on_pad_type):\n+\tDeclare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <discrete_type>: Set the\n+\tstorage order on the enclosing record for a packed array type.\n+\t<E_Array_Type>: Set the storage order.\n+\t<E_Array_Subtype>: Likewise.\n+\t<E_Record_Type>: Likewise.\n+\t<E_Record_Subtype>: Likewise.\n+\t(gnat_to_gnu_component_type): Set the reverse storage order on a\n+\tpadded type built for a non-bit-packed array.\n+\t(gnat_to_gnu_field): Likewise.\n+\t(components_to_record): Deal with TYPE_REVERSE_STORAGE_ORDER.\n+\t* gcc-interface/utils.c (make_packable_type): Likewise.\n+\t(pad_type_hasher::equal): Likewise.\n+\t(gnat_types_compatible_p): Likewise.\n+\t(unchecked_convert): Likewise.\n+\t(set_reverse_storage_order_on_pad_type): New public function.\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Adjust call to\n+\tget_inner_reference.\n+\t* gcc-interface/utils2.c (build_unary_op): Likewise.\n+\t(gnat_build_constructor): Deal with TYPE_REVERSE_STORAGE_ORDER.\n+\t(gnat_rewrite_reference): Propagate REF_REVERSE_STORAGE_ORDER.\n+\n 2015-11-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc-interface/utils.c: Don't undef DEF_BUILTIN."}, {"sha": "627eace9dd2751fa98b8819d29ef19f3a5acc7d4", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1805,6 +1805,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_ALIGN (gnu_type)\n \t    = align > 0 ? align : TYPE_ALIGN (gnu_field_type);\n \n+\t  /* Propagate the reverse storage order flag to the record type so\n+\t     that the required byte swapping is performed when retrieving the\n+\t     enclosed modular value.  */\n+\t  TYPE_REVERSE_STORAGE_ORDER (gnu_type)\n+\t    = Reverse_Storage_Order (Original_Array_Type (gnat_entity));\n+\n \t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \n \t  /* Don't declare the field as addressable since we won't be taking\n@@ -2152,8 +2158,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tfor (index = ndim - 1; index >= 0; index--)\n \t  {\n \t    tem = build_nonshared_array_type (tem, gnu_index_types[index]);\n-\t    if (Reverse_Storage_Order (gnat_entity) && !GNAT_Mode)\n-\t      sorry (\"non-default Scalar_Storage_Order\");\n+\t    if (index == ndim - 1)\n+\t      TYPE_REVERSE_STORAGE_ORDER (tem)\n+\t\t= Reverse_Storage_Order (gnat_entity);\n \t    TYPE_MULTI_ARRAY_P (tem) = (index > 0);\n \t    if (array_type_has_nonaliased_component (tem, gnat_entity))\n \t      TYPE_NONALIASED_COMPONENT (tem) = 1;\n@@ -2516,6 +2523,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      gnu_type = build_nonshared_array_type (gnu_type,\n \t\t\t\t\t\t     gnu_index_types[index]);\n+\t      if (index == ndim - 1)\n+\t\tTYPE_REVERSE_STORAGE_ORDER (gnu_type)\n+\t\t  = Reverse_Storage_Order (gnat_entity);\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n \t      if (array_type_has_nonaliased_component (gnu_type, gnat_entity))\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n@@ -2876,8 +2886,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type = make_node (tree_code_for_record_type (gnat_entity));\n \tTYPE_NAME (gnu_type) = gnu_entity_name;\n \tTYPE_PACKED (gnu_type) = (packed != 0) || has_rep;\n-\tif (Reverse_Storage_Order (gnat_entity) && !GNAT_Mode)\n-\t  sorry (\"non-default Scalar_Storage_Order\");\n+\tTYPE_REVERSE_STORAGE_ORDER (gnu_type)\n+\t  = Reverse_Storage_Order (gnat_entity);\n \tprocess_attributes (&gnu_type, &attr_list, true, gnat_entity);\n \n \tif (!definition)\n@@ -3287,6 +3297,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n \t      TYPE_PACKED (gnu_type) = TYPE_PACKED (gnu_base_type);\n+\t      TYPE_REVERSE_STORAGE_ORDER (gnu_type)\n+\t\t= Reverse_Storage_Order (gnat_entity);\n \t      process_attributes (&gnu_type, &attr_list, true, gnat_entity);\n \n \t      /* Set the size, alignment and alias set of the new type to\n@@ -3341,6 +3353,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\tTYPE_NAME (new_variant)\n \t\t\t  = concat_name (TYPE_NAME (gnu_type),\n \t\t\t\t\t IDENTIFIER_POINTER (suffix));\n+\t\t\tTYPE_REVERSE_STORAGE_ORDER (new_variant)\n+\t\t\t  = TYPE_REVERSE_STORAGE_ORDER (gnu_type);\n \t\t\tcopy_and_substitute_in_size (new_variant, old_variant,\n \t\t\t\t\t\t     gnu_subst_list);\n \t\t\tv->new_type = new_variant;\n@@ -5548,6 +5562,16 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \t\t\t  gnat_array);\n     }\n \n+  /* If the component type is a padded type made for a non-bit-packed array\n+     of scalars with reverse storage order, we need to propagate the reverse\n+     storage order to the padding type since it is the innermost enclosing\n+     aggregate type around the scalar.  */\n+  if (TYPE_IS_PADDING_P (gnu_type)\n+      && Reverse_Storage_Order (gnat_array)\n+      && !Is_Bit_Packed_Array (gnat_array)\n+      && Is_Scalar_Type (gnat_type))\n+    gnu_type = set_reverse_storage_order_on_pad_type (gnu_type);\n+\n   if (Has_Volatile_Components (gnat_array))\n     {\n       const int quals\n@@ -6718,6 +6742,15 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   else\n     gnu_pos = NULL_TREE;\n \n+  /* If the field's type is a padded type made for a scalar field of a record\n+     type with reverse storage order, we need to propagate the reverse storage\n+     order to the padding type since it is the innermost enclosing aggregate\n+     type around the scalar.  */\n+  if (TYPE_IS_PADDING_P (gnu_field_type)\n+      && TYPE_REVERSE_STORAGE_ORDER (gnu_record_type)\n+      && Is_Scalar_Type (gnat_field_type))\n+    gnu_field_type = set_reverse_storage_order_on_pad_type (gnu_field_type);\n+\n   gcc_assert (TREE_CODE (gnu_field_type) != RECORD_TYPE\n \t      || !TYPE_CONTAINS_TEMPLATE_P (gnu_field_type));\n \n@@ -7034,6 +7067,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  TYPE_NAME (gnu_union_type) = gnu_union_name;\n \t  TYPE_ALIGN (gnu_union_type) = 0;\n \t  TYPE_PACKED (gnu_union_type) = TYPE_PACKED (gnu_record_type);\n+\t  TYPE_REVERSE_STORAGE_ORDER (gnu_union_type)\n+\t    = TYPE_REVERSE_STORAGE_ORDER (gnu_record_type);\n \t}\n \n       /* If all the fields down to this level have a rep clause, find out\n@@ -7085,6 +7120,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t     record actually gets only the alignment required.  */\n \t  TYPE_ALIGN (gnu_variant_type) = TYPE_ALIGN (gnu_record_type);\n \t  TYPE_PACKED (gnu_variant_type) = TYPE_PACKED (gnu_record_type);\n+\t  TYPE_REVERSE_STORAGE_ORDER (gnu_variant_type)\n+\t    = TYPE_REVERSE_STORAGE_ORDER (gnu_record_type);\n \n \t  /* Similarly, if the outer record has a size specified and all\n \t     the fields have a rep clause, we can propagate the size.  */\n@@ -7177,6 +7214,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t     position at this level.  */\n \t\t  tree gnu_rep_type = make_node (RECORD_TYPE);\n \t\t  tree gnu_rep_part;\n+\t\t  TYPE_REVERSE_STORAGE_ORDER (gnu_rep_type)\n+\t\t    = TYPE_REVERSE_STORAGE_ORDER (gnu_variant_type);\n \t\t  finish_record_type (gnu_rep_type, NULL_TREE, 0, debug_info);\n \t\t  gnu_rep_part\n \t\t    = create_rep_part (gnu_rep_type, gnu_variant_type,\n@@ -7384,6 +7423,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \tgnu_field_list = gnu_rep_list;\n       else\n \t{\n+\t  TYPE_REVERSE_STORAGE_ORDER (gnu_rep_type)\n+\t    = TYPE_REVERSE_STORAGE_ORDER (gnu_record_type);\n \t  finish_record_type (gnu_rep_type, gnu_rep_list, 1, debug_info);\n \n \t  /* If FIRST_FREE_POS is nonzero, we need to ensure that the fields"}, {"sha": "d7a25662e809140acd646e4ea75d84e7ae106791", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -154,6 +154,9 @@ extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t    bool is_user_type, bool definition,\n \t\t\t    bool set_rm_size);\n \n+/* Return a copy of the padded TYPE but with reverse storage order.  */\n+extern tree set_reverse_storage_order_on_pad_type (tree type);\n+\n enum alias_set_op\n {\n   ALIAS_SET_COPY,"}, {"sha": "5c093fbf161c5598c5c578ce3616cdd3a2aef18a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -2172,7 +2172,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \ttree gnu_field_offset;\n \ttree gnu_inner;\n \tmachine_mode mode;\n-\tint unsignedp, volatilep;\n+\tint unsignedp, reversep, volatilep;\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \tgnu_prefix = remove_conversions (gnu_prefix, true);\n@@ -2194,7 +2194,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t\t  && TREE_CODE (gnu_prefix) == FIELD_DECL));\n \n \tget_inner_reference (gnu_prefix, &bitsize, &bitpos, &gnu_offset,\n-\t\t\t     &mode, &unsignedp, &volatilep, false);\n+\t\t\t     &mode, &unsignedp, &reversep, &volatilep, false);\n \n \tif (TREE_CODE (gnu_prefix) == COMPONENT_REF)\n \t  {"}, {"sha": "224dc002bdbba85af3bab15bc387cc79f828c544", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -957,6 +957,7 @@ make_packable_type (tree type, bool in_record)\n   TYPE_NAME (new_type) = TYPE_NAME (type);\n   TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n+  TYPE_REVERSE_STORAGE_ORDER (new_type) = TYPE_REVERSE_STORAGE_ORDER (type);\n   if (TREE_CODE (type) == RECORD_TYPE)\n     TYPE_PADDING_P (new_type) = TYPE_PADDING_P (type);\n \n@@ -1175,14 +1176,15 @@ pad_type_hasher::equal (pad_type_hash *t1, pad_type_hash *t2)\n   type1 = t1->type;\n   type2 = t2->type;\n \n-  /* We consider that the padded types are equivalent if they pad the same\n-     type and have the same size, alignment and RM size.  Taking the mode\n-     into account is redundant since it is determined by the others.  */\n+  /* We consider that the padded types are equivalent if they pad the same type\n+     and have the same size, alignment, RM size and storage order.  Taking the\n+     mode into account is redundant since it is determined by the others.  */\n   return\n     TREE_TYPE (TYPE_FIELDS (type1)) == TREE_TYPE (TYPE_FIELDS (type2))\n     && TYPE_SIZE (type1) == TYPE_SIZE (type2)\n     && TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n-    && TYPE_ADA_SIZE (type1) == TYPE_ADA_SIZE (type2);\n+    && TYPE_ADA_SIZE (type1) == TYPE_ADA_SIZE (type2)\n+    && TYPE_REVERSE_STORAGE_ORDER (type1) == TYPE_REVERSE_STORAGE_ORDER (type2);\n }\n \n /* Look up the padded TYPE in the hash table and return its canonical version\n@@ -1452,6 +1454,31 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \n   return record;\n }\n+\n+/* Return a copy of the padded TYPE but with reverse storage order.  */\n+\n+tree\n+set_reverse_storage_order_on_pad_type (tree type)\n+{\n+  tree field, canonical_pad_type;\n+\n+#ifdef ENABLE_CHECKING\n+  /* If the inner type is not scalar then the function does nothing.  */\n+  tree inner_type = TREE_TYPE (TYPE_FIELDS (type));\n+  gcc_assert (!AGGREGATE_TYPE_P (inner_type) && !VECTOR_TYPE_P (inner_type));\n+#endif\n+\n+  /* This is required for the canonicalization.  */\n+  gcc_assert (TREE_CONSTANT (TYPE_SIZE (type)));\n+\n+  field = copy_node (TYPE_FIELDS (type));\n+  type = copy_type (type);\n+  DECL_CONTEXT (field) = type;\n+  TYPE_FIELDS (type) = field;\n+  TYPE_REVERSE_STORAGE_ORDER (type) = 1;\n+  canonical_pad_type = lookup_and_insert_pad_type (type);\n+  return canonical_pad_type ? canonical_pad_type : type;\n+}\n \f\n /* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP.\n    If this is a multi-dimensional array type, do this recursively.\n@@ -3357,7 +3384,7 @@ gnat_types_compatible_p (tree t1, tree t2)\n     return 1;\n \n   /* Array types are also compatible if they are constrained and have the same\n-     domain(s) and the same component type.  */\n+     domain(s), the same component type and the same scalar storage order.  */\n   if (code == ARRAY_TYPE\n       && (TYPE_DOMAIN (t1) == TYPE_DOMAIN (t2)\n \t  || (TYPE_DOMAIN (t1)\n@@ -3368,7 +3395,8 @@ gnat_types_compatible_p (tree t1, tree t2)\n \t\t\t\t     TYPE_MAX_VALUE (TYPE_DOMAIN (t2)))))\n       && (TREE_TYPE (t1) == TREE_TYPE (t2)\n \t  || (TREE_CODE (TREE_TYPE (t1)) == ARRAY_TYPE\n-\t      && gnat_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))))\n+\t      && gnat_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))))\n+      && TYPE_REVERSE_STORAGE_ORDER (t1) == TYPE_REVERSE_STORAGE_ORDER (t2))\n     return 1;\n \n   return 0;\n@@ -4849,17 +4877,38 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n     }\n \n   /* If we are converting to an integral type whose precision is not equal\n-     to its size, first unchecked convert to a record type that contains an\n-     field of the given precision.  Then extract the field.  */\n+     to its size, first unchecked convert to a record type that contains a\n+     field of the given precision.  Then extract the result from the field.\n+\n+     There is a subtlety if the source type is an aggregate type with reverse\n+     storage order because its representation is not contiguous in the native\n+     storage order, i.e. a direct unchecked conversion to an integral type\n+     with N bits of precision cannot read the first N bits of the aggregate\n+     type.  To overcome it, we do an unchecked conversion to an integral type\n+     with reverse storage order and return the resulting value.  This also\n+     ensures that the result of the unchecked conversion doesn't depend on\n+     the endianness of the target machine, but only on the storage order of\n+     the aggregate type.\n+\n+     Finally, for the sake of consistency, we do the unchecked conversion\n+     to an integral type with reverse storage order as soon as the source\n+     type is an aggregate type with reverse storage order, even if there\n+     are no considerations of precision or size involved.  */\n   else if (INTEGRAL_TYPE_P (type)\n \t   && TYPE_RM_SIZE (type)\n-\t   && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n-\t\t\t\t     GET_MODE_BITSIZE (TYPE_MODE (type))))\n+\t   && (0 != compare_tree_int (TYPE_RM_SIZE (type),\n+\t\t\t\t      GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t       || (AGGREGATE_TYPE_P (etype)\n+\t\t   && TYPE_REVERSE_STORAGE_ORDER (etype))))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n       unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (type));\n       tree field_type, field;\n \n+      if (AGGREGATE_TYPE_P (etype))\n+\tTYPE_REVERSE_STORAGE_ORDER (rec_type)\n+\t  = TYPE_REVERSE_STORAGE_ORDER (etype);\n+\n       if (TYPE_UNSIGNED (type))\n \tfield_type = make_unsigned_type (prec);\n       else\n@@ -4878,18 +4927,27 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \n   /* Similarly if we are converting from an integral type whose precision is\n      not equal to its size, first copy into a field of the given precision\n-     and unchecked convert the record type.  */\n+     and unchecked convert the record type.\n+\n+     The same considerations as above apply if the target type is an aggregate\n+     type with reverse storage order and we also proceed similarly.  */\n   else if (INTEGRAL_TYPE_P (etype)\n \t   && TYPE_RM_SIZE (etype)\n-\t   && 0 != compare_tree_int (TYPE_RM_SIZE (etype),\n-\t\t\t\t     GET_MODE_BITSIZE (TYPE_MODE (etype))))\n+\t   && (0 != compare_tree_int (TYPE_RM_SIZE (etype),\n+\t\t\t\t      GET_MODE_BITSIZE (TYPE_MODE (etype)))\n+\t       || (AGGREGATE_TYPE_P (type)\n+\t\t   && TYPE_REVERSE_STORAGE_ORDER (type))))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n       unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (etype));\n       vec<constructor_elt, va_gc> *v;\n       vec_alloc (v, 1);\n       tree field_type, field;\n \n+      if (AGGREGATE_TYPE_P (type))\n+\tTYPE_REVERSE_STORAGE_ORDER (rec_type)\n+\t  = TYPE_REVERSE_STORAGE_ORDER (type);\n+\n       if (TYPE_UNSIGNED (etype))\n \tfield_type = make_unsigned_type (prec);\n       else"}, {"sha": "73a9b10d26f4b92a8fe19a918dbd0eb2492b38c1", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1408,11 +1408,11 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      HOST_WIDE_INT bitpos;\n \t      tree offset, inner;\n \t      machine_mode mode;\n-\t      int unsignedp, volatilep;\n+\t      int unsignedp, reversep, volatilep;\n \n \t      inner = get_inner_reference (operand, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t   &mode, &unsignedp, &volatilep,\n-\t\t\t\t\t   false);\n+\t\t\t\t\t   &mode, &unsignedp, &reversep,\n+\t\t\t\t\t   &volatilep, false);\n \n \t      /* If INNER is a padding type whose field has a self-referential\n \t\t size, convert to that inner type.  We know the offset is zero\n@@ -1916,7 +1916,9 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n \t  || (TREE_CODE (type) == RECORD_TYPE\n \t      && CONSTRUCTOR_BITFIELD_P (obj)\n \t      && !initializer_constant_valid_for_bitfield_p (val))\n-\t  || !initializer_constant_valid_p (val, TREE_TYPE (val)))\n+\t  || !initializer_constant_valid_p (val,\n+\t\t\t\t\t    TREE_TYPE (val),\n+\t\t\t\t\t    TYPE_REVERSE_STORAGE_ORDER (type)))\n \tallconstant = false;\n \n       if (!TREE_READONLY (val))\n@@ -2749,6 +2751,7 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, tree *init)\n \t\t       gnat_rewrite_reference (TREE_OPERAND (ref, 0), func,\n \t\t\t\t\t       data, init),\n \t\t       TREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2));\n+      REF_REVERSE_STORAGE_ORDER (result) = REF_REVERSE_STORAGE_ORDER (ref);\n       break;\n \n     case ARRAY_REF:"}, {"sha": "0df5e3234b5d7f3d6ebbef291fcffa0f93b85dc9", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1779,9 +1779,9 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   machine_mode mode;\n-  int volatilep = 0, unsignedp = 0;\n-  tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset,\n-\t\t\t\t    &mode, &unsignedp, &volatilep, false);\n+  int unsignedp, reversep, volatilep = 0;\n+  tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t    &unsignedp, &reversep, &volatilep, false);\n \n   if (TREE_CODE (t) == COMPONENT_REF\n       && DECL_BIT_FIELD_REPRESENTATIVE (TREE_OPERAND (t, 1)) != NULL_TREE)"}, {"sha": "85b251ae0922f6caadb33ec08696a477b563a990", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -252,14 +252,14 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   machine_mode mode;\n-  int unsignedp, volatilep;\n+  int unsignedp, reversep, volatilep;\n   unsigned int align = BITS_PER_UNIT;\n   bool known_alignment = false;\n \n   /* Get the innermost object and the constant (bitpos) and possibly\n      variable (offset) offset of the access.  */\n-  exp = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t     &mode, &unsignedp, &volatilep, true);\n+  exp = get_inner_reference (exp, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t     &unsignedp, &reversep, &volatilep, true);\n \n   /* Extract alignment information from the innermost object and\n      possibly adjust bitpos and offset.  */"}, {"sha": "f52b3e354c50f8fc3382c0415c213b18876e8a17", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1,3 +1,15 @@\n+2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-common.c (c_common_attributes): Add scalar_storage_order.\n+\t(handle_scalar_storage_order_attribute): New function.\n+\t* c-pragma.c (global_sso): New variable.\n+\t(maybe_apply_pragma_scalar_storage_order): New function.\n+\t(handle_pragma_scalar_storage_order): Likewise.\n+\t(init_pragma): Register scalar_storage_order.\n+\t* c-pragma.h (maybe_apply_pragma_scalar_storage_order): Declare.\n+\t* c.opt (Wscalar-storage-order): New warning.\n+\t(fsso-struct=): New option.\n+\n 2015-11-08  Martin Sebor  <msebor@redhat.com>\n \n \t* c.opt (Wplacement-new): Add a period to the end of a sentence."}, {"sha": "53c1d81c0c83c78d587de91bc4cf4955808ab4f3", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -339,6 +339,8 @@ static tree handle_no_reorder_attribute (tree *, tree, tree, int,\n static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n static tree handle_transparent_union_attribute (tree *, tree, tree,\n \t\t\t\t\t\tint, bool *);\n+static tree handle_scalar_storage_order_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t   int, bool *);\n static tree handle_constructor_attribute (tree *, tree, tree, int, bool *);\n static tree handle_destructor_attribute (tree *, tree, tree, int, bool *);\n static tree handle_mode_attribute (tree *, tree, tree, int, bool *);\n@@ -693,6 +695,8 @@ const struct attribute_spec c_common_attribute_table[] =\n   /* The same comments as for noreturn attributes apply to const ones.  */\n   { \"const\",                  0, 0, true,  false, false,\n \t\t\t      handle_const_attribute, false },\n+  { \"scalar_storage_order\",   1, 1, false, false, false,\n+\t\t\t      handle_scalar_storage_order_attribute, false },\n   { \"transparent_union\",      0, 0, false, false, false,\n \t\t\t      handle_transparent_union_attribute, false },\n   { \"constructor\",            0, 1, true,  false, false,\n@@ -7668,6 +7672,62 @@ handle_const_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   return NULL_TREE;\n }\n \n+/* Handle a \"scalar_storage_order\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_scalar_storage_order_attribute (tree *node, tree name, tree args,\n+\t\t\t\t       int flags, bool *no_add_attrs)\n+{\n+  tree id = TREE_VALUE (args);\n+  tree type;\n+\n+  if (TREE_CODE (*node) == TYPE_DECL\n+      && ! (flags & ATTR_FLAG_CXX11))\n+    node = &TREE_TYPE (*node);\n+  type = *node;\n+\n+  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+    {\n+      error (\"scalar_storage_order is not supported because endianness \"\n+\t    \"is not uniform\");\n+      return NULL_TREE;\n+    }\n+\n+  if (RECORD_OR_UNION_TYPE_P (type) && !c_dialect_cxx ())\n+    {\n+      bool reverse = false;\n+\n+      if (TREE_CODE (id) == STRING_CST\n+\t  && strcmp (TREE_STRING_POINTER (id), \"big-endian\") == 0)\n+\treverse = !BYTES_BIG_ENDIAN;\n+      else if (TREE_CODE (id) == STRING_CST\n+\t       && strcmp (TREE_STRING_POINTER (id), \"little-endian\") == 0)\n+\treverse = BYTES_BIG_ENDIAN;\n+      else\n+\t{\n+\t  error (\"scalar_storage_order argument must be one of \\\"big-endian\\\"\"\n+\t\t \" or \\\"little-endian\\\"\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t{\n+\t  if (reverse)\n+\t    /* A type variant isn't good enough, since we don't want a cast\n+\t       to such a type to be removed as a no-op.  */\n+\t    *node = type = build_duplicate_type (type);\n+\t}\n+\n+      TYPE_REVERSE_STORAGE_ORDER (type) = reverse;\n+      return NULL_TREE;\n+    }\n+\n+  warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"transparent_union\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n@@ -7680,7 +7740,6 @@ handle_transparent_union_attribute (tree *node, tree name,\n \n   *no_add_attrs = true;\n \n-\n   if (TREE_CODE (*node) == TYPE_DECL\n       && ! (flags & ATTR_FLAG_CXX11))\n     node = &TREE_TYPE (*node);\n@@ -7711,8 +7770,8 @@ handle_transparent_union_attribute (tree *node, tree name,\n \t  if (c_dialect_cxx ())\n \t    goto ignored;\n \n-\t  /* A type variant isn't good enough, since we don't a cast\n-\t     to such a type removed as a no-op.  */\n+\t  /* A type variant isn't good enough, since we don't want a cast\n+\t     to such a type to be removed as a no-op.  */\n \t  *node = type = build_duplicate_type (type);\n \t}\n "}, {"sha": "ffc5b33a4cd3b748caf1c695d9d3a6c8db768f6b", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -388,6 +388,51 @@ handle_pragma_weak (cpp_reader * ARG_UNUSED (dummy))\n     }\n }\n \n+static enum scalar_storage_order_kind global_sso;\n+\n+void\n+maybe_apply_pragma_scalar_storage_order (tree type)\n+{\n+  if (global_sso == SSO_NATIVE)\n+    return;\n+\n+  gcc_assert (RECORD_OR_UNION_TYPE_P (type));\n+\n+  if (lookup_attribute (\"scalar_storage_order\", TYPE_ATTRIBUTES (type)))\n+    return;\n+\n+  if (global_sso == SSO_BIG_ENDIAN)\n+    TYPE_REVERSE_STORAGE_ORDER (type) = !BYTES_BIG_ENDIAN;\n+  else if (global_sso == SSO_LITTLE_ENDIAN)\n+    TYPE_REVERSE_STORAGE_ORDER (type) = BYTES_BIG_ENDIAN;\n+  else\n+    gcc_unreachable ();\n+}\n+\n+static void\n+handle_pragma_scalar_storage_order (cpp_reader *ARG_UNUSED(dummy))\n+{\n+  const char *kind_string;\n+  enum cpp_ttype token;\n+  tree x;\n+\n+  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+    error (\"scalar_storage_order is not supported\");\n+\n+  token = pragma_lex (&x);\n+  if (token != CPP_NAME)\n+    GCC_BAD (\"missing [big-endian|little-endian|default] after %<#pragma scalar_storage_order%>\");\n+  kind_string = IDENTIFIER_POINTER (x);\n+  if (strcmp (kind_string, \"default\") == 0)\n+    global_sso = default_sso;\n+  else if (strcmp (kind_string, \"big\") == 0)\n+    global_sso = SSO_BIG_ENDIAN;\n+  else if (strcmp (kind_string, \"little\") == 0)\n+    global_sso = SSO_LITTLE_ENDIAN;\n+  else\n+    GCC_BAD (\"expected [big-endian|little-endian|default] after %<#pragma scalar_storage_order%>\");\n+}\n+\n /* GCC supports two #pragma directives for renaming the external\n    symbol associated with a declaration (DECL_ASSEMBLER_NAME), for\n    compatibility with the Solaris and VMS system headers.  GCC also\n@@ -1481,6 +1526,7 @@ init_pragma (void)\n   c_register_pragma (0, \"pack\", handle_pragma_pack);\n #endif\n   c_register_pragma (0, \"weak\", handle_pragma_weak);\n+\n   c_register_pragma (\"GCC\", \"visibility\", handle_pragma_visibility);\n \n   c_register_pragma (\"GCC\", \"diagnostic\", handle_pragma_diagnostic);\n@@ -1502,6 +1548,10 @@ init_pragma (void)\n   REGISTER_TARGET_PRAGMAS ();\n #endif\n \n+  global_sso = default_sso;\n+  c_register_pragma (0, \"scalar_storage_order\", \n+\t\t     handle_pragma_scalar_storage_order);\n+\n   /* Allow plugins to register their own pragmas. */\n   invoke_plugin_callbacks (PLUGIN_PRAGMAS, NULL);\n }"}, {"sha": "59231ce030ec98bf8de9e85ed07f41a379550c2d", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -227,6 +227,7 @@ extern void c_invoke_pragma_handler (unsigned int);\n extern void maybe_apply_pragma_weak (tree);\n extern void maybe_apply_pending_pragma_weaks (void);\n extern tree maybe_apply_renaming_pragma (tree, tree);\n+extern void maybe_apply_pragma_scalar_storage_order (tree);\n extern void add_to_renaming_pragma_list (tree, tree);\n \n extern enum cpp_ttype pragma_lex (tree *, location_t *loc = NULL);"}, {"sha": "aafd80207b1d9e52309455000069dbf70ba3718f", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -792,6 +792,10 @@ Wreturn-type\n C ObjC C++ ObjC++ Var(warn_return_type) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn whenever a function's return type defaults to \\\"int\\\" (C), or about inconsistent return types (C++).\n \n+Wscalar-storage-order\n+C ObjC C++ ObjC++ Init(1) Warning\n+Warn on suspicious constructs involving reverse scalar storage order.\n+\n Wselector\n ObjC ObjC++ Var(warn_selector) Warning\n Warn if a selector has multiple methods.\n@@ -1454,6 +1458,19 @@ Enable C++14 sized deallocation support.\n fsquangle\n C++ ObjC++ Ignore Warn(switch %qs is no longer supported)\n \n+fsso-struct=\n+C ObjC Joined Enum(sso_struct) Var(default_sso) Init(SSO_NATIVE)\n+-fsso-struct=[big-endian|little-endian]\tSet the default scalar storage order.\n+\n+Enum\n+Name(sso_struct) Type(enum scalar_storage_order_kind) UnknownError(unrecognized scalar storage order value %qs)\n+\n+EnumValue\n+Enum(sso_struct) String(big-endian) Value(SSO_BIG_ENDIAN)\n+\n+EnumValue\n+Enum(sso_struct) String(little-endian) Value(SSO_LITTLE_ENDIAN)\n+\n fstats\n C++ ObjC++ Var(flag_detailed_statistics)\n Display statistics accumulated during compilation."}, {"sha": "6fea3a996e9004819b85fad08cce50837303444e", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1,3 +1,14 @@\n+2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-decl.c (finish_struct): If the structure has reverse storage\n+\torder, rewrite the type of array fields with scalar component.  Call\n+\tmaybe_apply_pragma_scalar_storage_order on entry.\n+\t* c-typeck.c (build_unary_op) <ADDR_EXPR>: Remove left-overs.  Issue\n+\terrors on bit-fields and reverse SSO here and not...\n+\t(c_mark_addressable): ...here.\n+\t(output_init_element): Adjust call to initializer_constant_valid_p.\n+\t(c_build_qualified_type): Propagate TYPE_REVERSE_STORAGE_ORDER.\n+\n 2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-decl.c (warn_defaults_to): Update for change in signature"}, {"sha": "a3d8eada928e3509b7509199a51608a80cb26665", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -7724,6 +7724,8 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \n   TYPE_FIELDS (t) = fieldlist;\n \n+  maybe_apply_pragma_scalar_storage_order (t);\n+\n   layout_type (t);\n \n   if (TYPE_SIZE_UNIT (t)\n@@ -7732,27 +7734,45 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n       && !valid_constant_size_p (TYPE_SIZE_UNIT (t)))\n     error (\"type %qT is too large\", t);\n \n-  /* Give bit-fields their proper types.  */\n-  {\n-    tree *fieldlistp = &fieldlist;\n-    while (*fieldlistp)\n-      if (TREE_CODE (*fieldlistp) == FIELD_DECL && DECL_INITIAL (*fieldlistp)\n-\t  && TREE_TYPE (*fieldlistp) != error_mark_node)\n+  /* Give bit-fields their proper types and rewrite the type of array fields\n+     with scalar component if the enclosing type has reverse storage order.  */\n+  for (tree field = fieldlist; field; field = DECL_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) == FIELD_DECL\n+\t  && DECL_INITIAL (field)\n+\t  && TREE_TYPE (field) != error_mark_node)\n \t{\n \t  unsigned HOST_WIDE_INT width\n-\t    = tree_to_uhwi (DECL_INITIAL (*fieldlistp));\n-\t  tree type = TREE_TYPE (*fieldlistp);\n+\t    = tree_to_uhwi (DECL_INITIAL (field));\n+\t  tree type = TREE_TYPE (field);\n \t  if (width != TYPE_PRECISION (type))\n \t    {\n-\t      TREE_TYPE (*fieldlistp)\n+\t      TREE_TYPE (field)\n \t\t= c_build_bitfield_integer_type (width, TYPE_UNSIGNED (type));\n-\t      DECL_MODE (*fieldlistp) = TYPE_MODE (TREE_TYPE (*fieldlistp));\n+\t      DECL_MODE (field) = TYPE_MODE (TREE_TYPE (field));\n \t    }\n-\t  DECL_INITIAL (*fieldlistp) = 0;\n+\t  DECL_INITIAL (field) = 0;\n \t}\n-      else\n-\tfieldlistp = &DECL_CHAIN (*fieldlistp);\n-  }\n+      else if (TYPE_REVERSE_STORAGE_ORDER (t)\n+\t       && TREE_CODE (field) == FIELD_DECL\n+\t       && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)\n+\t{\n+\t  tree ftype = TREE_TYPE (field);\n+\t  tree ctype = strip_array_types (ftype);\n+\t  if (!RECORD_OR_UNION_TYPE_P (ctype) && TYPE_MODE (ctype) != QImode)\n+\t    {\n+\t      tree fmain_type = TYPE_MAIN_VARIANT (ftype);\n+\t      tree *typep = &fmain_type;\n+\t      do {\n+\t\t*typep = build_distinct_type_copy (*typep);\n+\t\tTYPE_REVERSE_STORAGE_ORDER (*typep) = 1;\n+\t\ttypep = &TREE_TYPE (*typep);\n+\t      } while (TREE_CODE (*typep) == ARRAY_TYPE);\n+\t      TREE_TYPE (field)\n+\t\t= c_build_qualified_type (fmain_type, TYPE_QUALS (ftype));\n+\t    }\n+\t}\n+    }\n \n   /* Now we have the truly final field list.\n      Store it in this type and in the variants.  */"}, {"sha": "2080db95ebc888a880e09b00f0e6e5a48fa62d49", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -4169,18 +4169,10 @@ build_unary_op (location_t location,\n \t  goto return_build_unary_op;\n \t}\n \n-      /* For &x[y], return x+y */\n-      if (TREE_CODE (arg) == ARRAY_REF)\n-\t{\n-\t  tree op0 = TREE_OPERAND (arg, 0);\n-\t  if (!c_mark_addressable (op0))\n-\t    return error_mark_node;\n-\t}\n-\n       /* Anything not already handled and not a true memory reference\n \t or a non-lvalue array is an error.  */\n-      else if (typecode != FUNCTION_TYPE && !flag\n-\t       && !lvalue_or_else (location, arg, lv_addressof))\n+      if (typecode != FUNCTION_TYPE && !flag\n+\t  && !lvalue_or_else (location, arg, lv_addressof))\n \treturn error_mark_node;\n \n       /* Move address operations inside C_MAYBE_CONST_EXPR to simplify\n@@ -4218,6 +4210,39 @@ build_unary_op (location_t location,\n \t  argtype = c_build_qualified_type (argtype, quals);\n \t}\n \n+      switch (TREE_CODE (arg))\n+\t{\n+\tcase COMPONENT_REF:\n+\t  if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n+\t    {\n+\t      error (\"cannot take address of bit-field %qD\",\n+\t\t     TREE_OPERAND (arg, 1));\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  /* ... fall through ...  */\n+\n+\tcase ARRAY_REF:\n+\t  if (TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_OPERAND (arg, 0))))\n+\t    {\n+\t      if (!AGGREGATE_TYPE_P (TREE_TYPE (arg))\n+\t\t  && !VECTOR_TYPE_P (TREE_TYPE (arg)))\n+\t\t{\n+\t\t  error (\"cannot take address of scalar with reverse storage \"\n+\t\t\t \"order\");\n+\t\t  return error_mark_node;\n+\t\t}\n+\n+\t      if (TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE\n+\t\t  && TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (arg)))\n+\t\twarning (OPT_Wscalar_storage_order, \"address of array with \"\n+\t\t\t\"reverse scalar storage order requested\");\n+\t    }\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n       if (!c_mark_addressable (arg))\n \treturn error_mark_node;\n \n@@ -4360,15 +4385,6 @@ c_mark_addressable (tree exp)\n     switch (TREE_CODE (x))\n       {\n       case COMPONENT_REF:\n-\tif (DECL_C_BIT_FIELD (TREE_OPERAND (x, 1)))\n-\t  {\n-\t    error\n-\t      (\"cannot take address of bit-field %qD\", TREE_OPERAND (x, 1));\n-\t    return false;\n-\t  }\n-\n-\t/* ... fall through ...  */\n-\n       case ADDR_EXPR:\n       case ARRAY_REF:\n       case REALPART_EXPR:\n@@ -8444,7 +8460,11 @@ output_init_element (location_t loc, tree value, tree origtype,\n     constructor_erroneous = 1;\n   else if (!TREE_CONSTANT (value))\n     constructor_constant = 0;\n-  else if (!initializer_constant_valid_p (value, TREE_TYPE (value))\n+  else if (!initializer_constant_valid_p (value,\n+\t\t\t\t\t  TREE_TYPE (value),\n+\t\t\t\t\t  AGGREGATE_TYPE_P (constructor_type)\n+\t\t\t\t\t  && TYPE_REVERSE_STORAGE_ORDER\n+\t\t\t\t\t     (constructor_type))\n \t   || ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t\t|| TREE_CODE (constructor_type) == UNION_TYPE)\n \t       && DECL_C_BIT_FIELD (field)\n@@ -13238,6 +13258,12 @@ c_build_qualified_type (tree type, int type_quals)\n                 = build_array_type (TYPE_CANONICAL (element_type),\n                                     domain? TYPE_CANONICAL (domain)\n                                           : NULL_TREE);\n+              if (TYPE_REVERSE_STORAGE_ORDER (type))\n+                {\n+                  unqualified_canon\n+                    = build_distinct_type_copy (unqualified_canon);\n+                  TYPE_REVERSE_STORAGE_ORDER (unqualified_canon) = 1;\n+                }\n               TYPE_CANONICAL (t)\n                 = c_build_qualified_type (unqualified_canon, type_quals);\n             }"}, {"sha": "b56556a9d0a21b7e8ee3a99354d355c4b55feee4", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1065,7 +1065,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \n \t    args[i].aligned_regs[j] = reg;\n \t    word = extract_bit_field (word, bitsize, 0, 1, NULL_RTX,\n-\t\t\t\t      word_mode, word_mode);\n+\t\t\t\t      word_mode, word_mode, false);\n \n \t    /* There is no need to restrict this code to loading items\n \t       in TYPE_ALIGN sized hunks.  The bitfield instructions can\n@@ -1082,7 +1082,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \n \t    bytes -= bitsize / BITS_PER_UNIT;\n \t    store_bit_field (reg, bitsize, endian_correction, 0, 0,\n-\t\t\t     word_mode, word);\n+\t\t\t     word_mode, word, false);\n \t  }\n       }\n }\n@@ -1363,7 +1363,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t      else\n \t\tcopy = assign_temp (type, 1, 0);\n \n-\t      store_expr (args[i].tree_value, copy, 0, false);\n+\t      store_expr (args[i].tree_value, copy, 0, false, false);\n \n \t      /* Just change the const function to pure and then let\n \t\t the next test clear the pure based on\n@@ -2084,8 +2084,8 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t  rtx dest = gen_rtx_REG (word_mode, REGNO (reg) + nregs - 1);\n \t\t  unsigned int bitoff = (nregs - 1) * BITS_PER_WORD;\n \t\t  unsigned int bitsize = size * BITS_PER_UNIT - bitoff;\n-\t\t  rtx x = extract_bit_field (mem, bitsize, bitoff, 1,\n-\t\t\t\t\t     dest, word_mode, word_mode);\n+\t\t  rtx x = extract_bit_field (mem, bitsize, bitoff, 1, dest,\n+\t\t\t\t\t     word_mode, word_mode, false);\n \t\t  if (BYTES_BIG_ENDIAN)\n \t\t    x = expand_shift (LSHIFT_EXPR, word_mode, x,\n \t\t\t\t      BITS_PER_WORD - bitsize, dest, 1);"}, {"sha": "ae893527a0f94b92c49321c78e3d99228434e319", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -4374,9 +4374,10 @@ expand_debug_expr (tree exp)\n \tmachine_mode mode1;\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n-\tint volatilep = 0;\n-\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t&mode1, &unsignedp, &volatilep, false);\n+\tint reversep, volatilep = 0;\n+\ttree tem\n+\t  = get_inner_reference (exp, &bitsize, &bitpos, &offset, &mode1,\n+\t\t\t\t &unsignedp, &reversep, &volatilep, false);\n \trtx orig_op0;\n \n \tif (bitsize == 0)\n@@ -4799,9 +4800,10 @@ expand_debug_expr (tree exp)\n \t  if (handled_component_p (TREE_OPERAND (exp, 0)))\n \t    {\n \t      HOST_WIDE_INT bitoffset, bitsize, maxsize;\n+\t      bool reverse;\n \t      tree decl\n-\t\t= get_ref_base_and_extent (TREE_OPERAND (exp, 0),\n-\t\t\t\t\t   &bitoffset, &bitsize, &maxsize);\n+\t\t= get_ref_base_and_extent (TREE_OPERAND (exp, 0), &bitoffset,\n+\t\t\t\t\t   &bitsize, &maxsize, &reverse);\n \t      if ((TREE_CODE (decl) == VAR_DECL\n \t\t   || TREE_CODE (decl) == PARM_DECL\n \t\t   || TREE_CODE (decl) == RESULT_DECL)"}, {"sha": "9d6283fe116b665f3e9c3541acf62de35a052ff4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -15705,10 +15705,10 @@ r10k_safe_mem_expr_p (tree expr, unsigned HOST_WIDE_INT offset)\n   HOST_WIDE_INT bitoffset, bitsize;\n   tree inner, var_offset;\n   machine_mode mode;\n-  int unsigned_p, volatile_p;\n+  int unsigned_p, reverse_p, volatile_p;\n \n   inner = get_inner_reference (expr, &bitsize, &bitoffset, &var_offset, &mode,\n-\t\t\t       &unsigned_p, &volatile_p, false);\n+\t\t\t       &unsigned_p, &reverse_p, &volatile_p, false);\n   if (!DECL_P (inner) || !DECL_SIZE_UNIT (inner) || var_offset)\n     return false;\n "}, {"sha": "5e3513a6b8954d16f50c3a914a789be740c8ae98", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -6426,7 +6426,7 @@ s390_expand_atomic (machine_mode mode, enum rtx_code code,\n     case SET:\n       if (ac.aligned && MEM_P (val))\n \tstore_bit_field (new_rtx, GET_MODE_BITSIZE (mode), 0,\n-\t\t\t 0, 0, SImode, val);\n+\t\t\t 0, 0, SImode, val, false);\n       else\n \t{\n \t  new_rtx = expand_simple_binop (SImode, AND, new_rtx, ac.modemaski,"}, {"sha": "4ef2ca9375efd576de73124e761db68697dc4cd3", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1962,7 +1962,7 @@ tilegx_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n \textract_bit_field (gen_lowpart (DImode, wide_result),\n \t\t\t   bitsize, bit_offset % BITS_PER_UNIT,\n \t\t\t   !sign, gen_lowpart (DImode, dest_reg),\n-\t\t\t   DImode, DImode);\n+\t\t\t   DImode, DImode, false);\n \n       if (extracted != dest_reg)\n \temit_move_insn (dest_reg, gen_lowpart (DImode, extracted));"}, {"sha": "4f95f6cb3b869a8f094fe5cf013253352c11e2cb", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1692,7 +1692,7 @@ tilepro_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n \textract_bit_field (gen_lowpart (SImode, wide_result),\n \t\t\t   bitsize, bit_offset % BITS_PER_UNIT,\n \t\t\t   !sign, gen_lowpart (SImode, dest_reg),\n-\t\t\t   SImode, SImode);\n+\t\t\t   SImode, SImode, false);\n \n       if (extracted != dest_reg)\n \temit_move_insn (dest_reg, gen_lowpart (SImode, extracted));"}, {"sha": "1b4a5eaeb6d843942690b32bac39e764181c0816", "filename": "gcc/dbxout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -2479,11 +2479,11 @@ dbxout_expand_expr (tree expr)\n \tmachine_mode mode;\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset, tem;\n-\tint volatilep = 0, unsignedp = 0;\n+\tint unsignedp, reversep, volatilep = 0;\n \trtx x;\n \n-\ttem = get_inner_reference (expr, &bitsize, &bitpos, &offset,\n-\t\t\t\t   &mode, &unsignedp, &volatilep, true);\n+\ttem = get_inner_reference (expr, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t   &unsignedp, &reversep, &volatilep, true);\n \n \tx = dbxout_expand_expr (tem);\n \tif (x == NULL || !MEM_P (x))"}, {"sha": "08d442018ebb8bdf173f16755af2cb59ca4fb3e1", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -6395,6 +6395,42 @@ of the structure or union is placed to minimize the memory required.  When\n attached to an @code{enum} definition, it indicates that the smallest\n integral type should be used.\n \n+@item scalar_storage_order (\"@var{endianness}\")\n+@cindex @code{scalar_storage_order} type attribute\n+When attached to a @code{union} or a @code{struct}, this attribute sets\n+the storage order, aka endianness, of the scalar fields of the type, as\n+well as the array fields whose component is scalar.  The supported\n+endianness are @code{big-endian} and @code{little-endian}.  The attribute\n+has no effects on fields which are themselves a @code{union}, a @code{struct}\n+or an array whose component is a @code{union} or a @code{struct}, and it is\n+possible to have fields with a different scalar storage order than the\n+enclosing type.\n+\n+This attribute is supported only for targets that use a uniform default\n+scalar storage order (fortunately, most of them), i.e. targets that store\n+the scalars either all in big-endian or all in little-endian.\n+\n+Additional restrictions are enforced for types with the reverse scalar\n+storage order with regard to the scalar storage order of the target:\n+\n+@itemize\n+@item Taking the address of a scalar field of a @code{union} or a\n+@code{struct} with reverse scalar storage order is not permitted and will\n+yield an error.\n+@item Taking the address of an array field, whose component is scalar, of\n+a @code{union} or a @code{struct} with reverse scalar storage order is\n+permitted but will yield a warning, unless @option{-Wno-scalar-storage-order}\n+is specified.\n+@item Taking the address of a @code{union} or a @code{struct} with reverse\n+scalar storage order is permitted.\n+@end itemize\n+\n+These restrictions exist because the storage order attribute is lost when\n+the address of a scalar or the address of an array with scalar component\n+is taken, so storing indirectly through this address will generally not work.\n+The second case is nevertheless allowed to be able to perform a block copy\n+from or to the array.\n+\n @item transparent_union\n @cindex @code{transparent_union} type attribute\n \n@@ -18432,7 +18468,7 @@ for further explanation.\n * Darwin Pragmas::\n * Solaris Pragmas::\n * Symbol-Renaming Pragmas::\n-* Structure-Packing Pragmas::\n+* Structure-Layout Pragmas::\n * Weak Pragmas::\n * Diagnostic Pragmas::\n * Visibility Pragmas::\n@@ -18708,8 +18744,8 @@ the name does not change.\n always the C-language name.\n @end enumerate\n \n-@node Structure-Packing Pragmas\n-@subsection Structure-Packing Pragmas\n+@node Structure-Layout Pragmas\n+@subsection Structure-Layout Pragmas\n \n For compatibility with Microsoft Windows compilers, GCC supports a\n set of @code{#pragma} directives that change the maximum alignment of\n@@ -18732,17 +18768,30 @@ multiple @code{#pragma pack(@var{n})} instances and finalized by a single\n @code{#pragma pack(pop)}.\n @end enumerate\n \n-Some targets, e.g.@: x86 and PowerPC, support the @code{ms_struct}\n-@code{#pragma} which lays out a structure as the documented\n-@code{__attribute__ ((ms_struct))}.\n+Some targets, e.g.@: x86 and PowerPC, support the @code{#pragma ms_struct}\n+directive which lays out structures and unions subsequently defined as the\n+documented @code{__attribute__ ((ms_struct))}.\n+\n @enumerate\n-@item @code{#pragma ms_struct on} turns on the layout for structures\n-declared.\n-@item @code{#pragma ms_struct off} turns off the layout for structures\n-declared.\n+@item @code{#pragma ms_struct on} turns on the Microsoft layout.\n+@item @code{#pragma ms_struct off} turns off the Microsoft layout.\n @item @code{#pragma ms_struct reset} goes back to the default layout.\n @end enumerate\n \n+Most targets also support the @code{#pragma scalar_storage_order} directive\n+which lays out structures and unions subsequently defined as the documented\n+@code{__attribute__ ((scalar_storage_order))}.\n+\n+@enumerate\n+@item @code{#pragma scalar_storage_order big-endian} sets the storage order\n+of the scalar fields to big-endian.\n+@item @code{#pragma scalar_storage_order little-endian} sets the storage order\n+of the scalar fields to little-endian.\n+@item @code{#pragma scalar_storage_order default} goes back to the endianness\n+that was in effect when compilation started (see also command-line option\n+@option{-fsso-struct=@var{endianness}} @pxref{C Dialect Options}).\n+@end enumerate\n+\n @node Weak Pragmas\n @subsection Weak Pragmas\n "}, {"sha": "dc9a4e73712d6373cad1a95544116eb65c565d7c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -169,10 +169,11 @@ in the following sections.\n -aux-info @var{filename} -fallow-parameterless-variadic-functions @gol\n -fno-asm  -fno-builtin  -fno-builtin-@var{function} @gol\n -fhosted  -ffreestanding -fopenacc -fopenmp -fopenmp-simd @gol\n--fms-extensions -fplan9-extensions -trigraphs -traditional -traditional-cpp @gol\n+-fms-extensions -fplan9-extensions -fsso-struct=@var{endianness}\n -fallow-single-precision  -fcond-mismatch -flax-vector-conversions @gol\n -fsigned-bitfields  -fsigned-char @gol\n--funsigned-bitfields  -funsigned-char}\n+-funsigned-bitfields  -funsigned-char @gol\n+-trigraphs -traditional -traditional-cpp}\n \n @item C++ Language Options\n @xref{C++ Dialect Options,,Options Controlling C++ Dialect}.\n@@ -278,6 +279,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wshift-overflow -Wshift-overflow=@var{n} @gol\n -Wshift-count-negative -Wshift-count-overflow -Wshift-negative-value @gol\n -Wsign-compare  -Wsign-conversion -Wfloat-conversion @gol\n+-Wno-scalar-storage-order @gol\n -Wsizeof-pointer-memaccess  -Wsizeof-array-argument @gol\n -Wstack-protector -Wstack-usage=@var{len} -Wstrict-aliasing @gol\n -Wstrict-aliasing=n @gol -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n@@ -2076,6 +2078,17 @@ These options control whether a bit-field is signed or unsigned, when the\n declaration does not use either @code{signed} or @code{unsigned}.  By\n default, such a bit-field is signed, because this is consistent: the\n basic integer types such as @code{int} are signed types.\n+\n+@item -fsso-struct=@var{endianness}\n+@opindex fsso-struct\n+Set the default scalar storage order of structures and unions to the\n+specified endianness.  The accepted values are @samp{big-endian} and\n+@samp{little-endian}.  If the option is not passed, the compiler uses\n+the native endianness of the target.  This option is not supported for C++.\n+\n+@strong{Warning:} the @option{-fsso-struct} switch causes GCC to generate\n+code that is not binary compatible with code generated without it if the\n+specified endianness is not the native endianness of the target.\n @end table\n \n @node C++ Dialect Options\n@@ -5113,6 +5126,11 @@ This includes conversions from real to integer, and from higher precision\n real to lower precision real values.  This option is also enabled by\n @option{-Wconversion}.\n \n+@item -Wno-scalar-storage-order\n+@opindex -Wno-scalar-storage-order\n+@opindex -Wscalar-storage-order\n+Do not warn on suspicious constructs involving reverse scalar storage order.\n+\n @item -Wsized-deallocation @r{(C++ and Objective-C++ only)}\n @opindex Wsized-deallocation\n @opindex Wno-sized-deallocation"}, {"sha": "6d02fe77d029479e361ab6ac879705efa03c0ad2", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -5273,9 +5273,10 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n \t      && TREE_CODE (TREE_OPERAND (realdecl, 0)) == ADDR_EXPR))\n \t{\n \t  HOST_WIDE_INT maxsize;\n-\t  tree innerdecl;\n-\t  innerdecl\n-\t    = get_ref_base_and_extent (realdecl, &bitpos, &bitsize, &maxsize);\n+\t  bool reverse;\n+\t  tree innerdecl\n+\t    = get_ref_base_and_extent (realdecl, &bitpos, &bitsize, &maxsize,\n+\t\t\t\t       &reverse);\n \t  if (!DECL_P (innerdecl)\n \t      || DECL_IGNORED_P (innerdecl)\n \t      || TREE_STATIC (innerdecl)\n@@ -14463,12 +14464,12 @@ loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev,\n   tree obj, offset;\n   HOST_WIDE_INT bitsize, bitpos, bytepos;\n   machine_mode mode;\n-  int unsignedp, volatilep = 0;\n+  int unsignedp, reversep, volatilep = 0;\n   dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n \n   obj = get_inner_reference (TREE_OPERAND (loc, 0),\n \t\t\t     &bitsize, &bitpos, &offset, &mode,\n-\t\t\t     &unsignedp, &volatilep, false);\n+\t\t\t     &unsignedp, &reversep, &volatilep, false);\n   STRIP_NOPS (obj);\n   if (bitpos % BITS_PER_UNIT)\n     {\n@@ -14797,10 +14798,10 @@ loc_list_from_tree (tree loc, int want_address,\n \ttree obj, offset;\n \tHOST_WIDE_INT bitsize, bitpos, bytepos;\n \tmachine_mode mode;\n-\tint unsignedp, volatilep = 0;\n+\tint unsignedp, reversep, volatilep = 0;\n \n \tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t   &unsignedp, &volatilep, false);\n+\t\t\t\t   &unsignedp, &reversep, &volatilep, false);\n \n \tgcc_assert (obj != loc);\n \n@@ -16102,7 +16103,7 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n   machine_mode mode;\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n-  int unsignedp, volatilep = 0;\n+  int unsignedp, reversep, volatilep = 0;\n \n   /* If the decl isn't a VAR_DECL, or if it isn't static, or if\n      it does not have a value (the offset into the common area), or if it\n@@ -16118,8 +16119,8 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n   if (TREE_CODE (val_expr) != COMPONENT_REF)\n     return NULL_TREE;\n \n-  cvar = get_inner_reference (val_expr, &bitsize, &bitpos, &offset,\n-\t\t\t      &mode, &unsignedp, &volatilep, true);\n+  cvar = get_inner_reference (val_expr, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t      &unsignedp, &reversep, &volatilep, true);\n \n   if (cvar == NULL_TREE\n       || TREE_CODE (cvar) != VAR_DECL"}, {"sha": "97a15130e4fefd2c11154abac51cce4dd1d5e109", "filename": "gcc/expmed.c", "status": "modified", "additions": 209, "deletions": 57, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -48,24 +48,24 @@ static void store_fixed_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   rtx);\n+\t\t\t\t   rtx, bool);\n static void store_fixed_bit_field_1 (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t     unsigned HOST_WIDE_INT,\n-\t\t\t\t     rtx);\n+\t\t\t\t     rtx, bool);\n static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   rtx);\n+\t\t\t\t   rtx, bool);\n static rtx extract_fixed_bit_field (machine_mode, rtx,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n-\t\t\t\t    unsigned HOST_WIDE_INT, rtx, int);\n+\t\t\t\t    unsigned HOST_WIDE_INT, rtx, int, bool);\n static rtx extract_fixed_bit_field_1 (machine_mode, rtx,\n \t\t\t\t      unsigned HOST_WIDE_INT,\n-\t\t\t\t      unsigned HOST_WIDE_INT, rtx, int);\n+\t\t\t\t      unsigned HOST_WIDE_INT, rtx, int, bool);\n static rtx lshift_value (machine_mode, unsigned HOST_WIDE_INT, int);\n static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t    unsigned HOST_WIDE_INT, int);\n+\t\t\t\t    unsigned HOST_WIDE_INT, int, bool);\n static void do_cmp_and_jump (rtx, rtx, enum rtx_code, machine_mode, rtx_code_label *);\n static rtx expand_smod_pow2 (machine_mode, rtx, HOST_WIDE_INT);\n static rtx expand_sdiv_pow2 (machine_mode, rtx, HOST_WIDE_INT);\n@@ -323,6 +323,94 @@ negate_rtx (machine_mode mode, rtx x)\n   return result;\n }\n \n+/* Whether reverse storage order is supported on the target.  */\n+static int reverse_storage_order_supported = -1;\n+\n+/* Check whether reverse storage order is supported on the target.  */\n+\n+static void\n+check_reverse_storage_order_support (void)\n+{\n+  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+    {\n+      reverse_storage_order_supported = 0;\n+      sorry (\"reverse scalar storage order\");\n+    }\n+  else\n+    reverse_storage_order_supported = 1;\n+}\n+\n+/* Whether reverse FP storage order is supported on the target.  */\n+static int reverse_float_storage_order_supported = -1;\n+\n+/* Check whether reverse FP storage order is supported on the target.  */\n+\n+static void\n+check_reverse_float_storage_order_support (void)\n+{\n+  if (FLOAT_WORDS_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+    {\n+      reverse_float_storage_order_supported = 0;\n+      sorry (\"reverse floating-point scalar storage order\");\n+    }\n+  else\n+    reverse_float_storage_order_supported = 1;\n+}\n+\n+/* Return an rtx representing value of X with reverse storage order.\n+   MODE is the intended mode of the result,\n+   useful if X is a CONST_INT.  */\n+\n+rtx\n+flip_storage_order (enum machine_mode mode, rtx x)\n+{\n+  enum machine_mode int_mode;\n+  rtx result;\n+\n+  if (mode == QImode)\n+    return x;\n+\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      rtx real = read_complex_part (x, false);\n+      rtx imag = read_complex_part (x, true);\n+\n+      real = flip_storage_order (GET_MODE_INNER (mode), real);\n+      imag = flip_storage_order (GET_MODE_INNER (mode), imag);\n+\n+      return gen_rtx_CONCAT (mode, real, imag);\n+    }\n+\n+  if (__builtin_expect (reverse_storage_order_supported < 0, 0))\n+    check_reverse_storage_order_support ();\n+\n+  if (SCALAR_INT_MODE_P (mode))\n+    int_mode = mode;\n+  else\n+    {\n+      if (FLOAT_MODE_P (mode)\n+\t  && __builtin_expect (reverse_float_storage_order_supported < 0, 0))\n+\tcheck_reverse_float_storage_order_support ();\n+\n+      int_mode = mode_for_size (GET_MODE_PRECISION (mode), MODE_INT, 0);\n+      if (int_mode == BLKmode)\n+\t{\n+\t  sorry (\"reverse storage order for %smode\", GET_MODE_NAME (mode));\n+\t  return x;\n+\t}\n+      x = gen_lowpart (int_mode, x);\n+    }\n+\n+  result = simplify_unary_operation (BSWAP, int_mode, x, int_mode);\n+  if (result == 0)\n+    result = expand_unop (int_mode, bswap_optab, x, NULL_RTX, 1);\n+\n+  if (int_mode != mode)\n+    result = gen_lowpart (mode, result);\n+\n+  return result;\n+}\n+\n /* Adjust bitfield memory MEM so that it points to the first unit of mode\n    MODE that contains a bitfield of size BITSIZE at bit position BITNUM.\n    If MODE is BLKmode, return a reference to every byte in the bitfield.\n@@ -626,7 +714,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   unsigned HOST_WIDE_INT bitregion_start,\n \t\t   unsigned HOST_WIDE_INT bitregion_end,\n \t\t   machine_mode fieldmode,\n-\t\t   rtx value, bool fallback_p)\n+\t\t   rtx value, bool reverse, bool fallback_p)\n {\n   rtx op0 = str_rtx;\n   rtx orig_value;\n@@ -642,7 +730,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       int outer_mode_size = GET_MODE_SIZE (GET_MODE (op0));\n       int byte_offset = 0;\n \n-      /* Paradoxical subregs need special handling on big endian machines.  */\n+      /* Paradoxical subregs need special handling on big-endian machines.  */\n       if (SUBREG_BYTE (op0) == 0 && inner_mode_size < outer_mode_size)\n \t{\n \t  int difference = inner_mode_size - outer_mode_size;\n@@ -704,6 +792,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  sub = simplify_gen_subreg (GET_MODE (op0), value, fieldmode, 0);\n \t  if (sub)\n \t    {\n+\t      if (reverse)\n+\t\tsub = flip_storage_order (GET_MODE (op0), sub);\n \t      emit_move_insn (op0, sub);\n \t      return true;\n \t    }\n@@ -714,6 +804,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t     bitnum / BITS_PER_UNIT);\n \t  if (sub)\n \t    {\n+\t      if (reverse)\n+\t\tvalue = flip_storage_order (fieldmode, value);\n \t      emit_move_insn (sub, value);\n \t      return true;\n \t    }\n@@ -726,6 +818,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (simple_mem_bitfield_p (op0, bitsize, bitnum, fieldmode))\n     {\n       op0 = adjust_bitfield_address (op0, fieldmode, bitnum / BITS_PER_UNIT);\n+      if (reverse)\n+\tvalue = flip_storage_order (fieldmode, value);\n       emit_move_insn (op0, value);\n       return true;\n     }\n@@ -752,6 +846,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      can be done with a movstrict instruction.  */\n \n   if (!MEM_P (op0)\n+      && !reverse\n       && lowpart_bit_field_p (bitnum, bitsize, GET_MODE (op0))\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n       && optab_handler (movstrict_optab, fieldmode) != CODE_FOR_nothing)\n@@ -795,7 +890,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t be less than full.\n \t However, only do that if the value is not BLKmode.  */\n \n-      unsigned int backwards = WORDS_BIG_ENDIAN && fieldmode != BLKmode;\n+      const bool backwards = WORDS_BIG_ENDIAN && fieldmode != BLKmode;\n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n       rtx_insn *last;\n@@ -818,7 +913,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t  ? GET_MODE_SIZE (fieldmode) / UNITS_PER_WORD\n \t\t\t\t  - i - 1\n \t\t\t\t  : i);\n-\t  unsigned int bit_offset = (backwards\n+\t  unsigned int bit_offset = (backwards ^ reverse\n \t\t\t\t     ? MAX ((int) bitsize - ((int) i + 1)\n \t\t\t\t\t    * BITS_PER_WORD,\n \t\t\t\t\t    0)\n@@ -828,7 +923,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    MIN (BITS_PER_WORD, bitsize - i * BITS_PER_WORD);\n \n \t  /* If the remaining chunk doesn't have full wordsize we have\n-\t     to make sure that for big endian machines the higher order\n+\t     to make sure that for big-endian machines the higher order\n \t     bits are used.  */\n \t  if (new_bitsize < BITS_PER_WORD && BYTES_BIG_ENDIAN && !backwards)\n \t    value_word = simplify_expand_binop (word_mode, lshr_optab,\n@@ -842,7 +937,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t  bitnum + bit_offset,\n \t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  word_mode,\n-\t\t\t\t  value_word, fallback_p))\n+\t\t\t\t  value_word, reverse, fallback_p))\n \t    {\n \t      delete_insns_since (last);\n \t      return false;\n@@ -878,7 +973,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    return false;\n \n \t  store_split_bit_field (op0, bitsize, bitnum, bitregion_start,\n-\t\t\t\t bitregion_end, value);\n+\t\t\t\t bitregion_end, value, reverse);\n \t  return true;\n \t}\n     }\n@@ -889,6 +984,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   extraction_insn insv;\n   if (!MEM_P (op0)\n+      && !reverse\n       && get_best_reg_extraction_insn (&insv, EP_insv,\n \t\t\t\t       GET_MODE_BITSIZE (GET_MODE (op0)),\n \t\t\t\t       fieldmode)\n@@ -897,7 +993,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a\n      cheap register alternative is available.  */\n-  if (MEM_P (op0))\n+  if (MEM_P (op0) && !reverse)\n     {\n       if (get_best_mem_extraction_insn (&insv, EP_insv, bitsize, bitnum,\n \t\t\t\t\tfieldmode)\n@@ -917,7 +1013,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  rtx tempreg = copy_to_reg (xop0);\n \t  if (store_bit_field_1 (tempreg, bitsize, bitpos,\n \t\t\t\t bitregion_start, bitregion_end,\n-\t\t\t\t fieldmode, orig_value, false))\n+\t\t\t\t fieldmode, orig_value, reverse, false))\n \t    {\n \t      emit_move_insn (xop0, tempreg);\n \t      return true;\n@@ -930,7 +1026,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     return false;\n \n   store_fixed_bit_field (op0, bitsize, bitnum, bitregion_start,\n-\t\t\t bitregion_end, value);\n+\t\t\t bitregion_end, value, reverse);\n   return true;\n }\n \n@@ -943,15 +1039,17 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n    These two fields are 0, if the C++ memory model does not apply,\n    or we are not interested in keeping track of bitfield regions.\n \n-   FIELDMODE is the machine-mode of the FIELD_DECL node for this field.  */\n+   FIELDMODE is the machine-mode of the FIELD_DECL node for this field.\n+\n+   If REVERSE is true, the store is to be done in reverse order.  */\n \n void\n store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t unsigned HOST_WIDE_INT bitnum,\n \t\t unsigned HOST_WIDE_INT bitregion_start,\n \t\t unsigned HOST_WIDE_INT bitregion_end,\n \t\t machine_mode fieldmode,\n-\t\t rtx value)\n+\t\t rtx value, bool reverse)\n {\n   /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n   if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, fieldmode,\n@@ -965,6 +1063,8 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  str_rtx = adjust_bitfield_address (str_rtx, fieldmode,\n \t\t\t\t\t     bitnum / BITS_PER_UNIT);\n+\t  if (reverse)\n+\t    value = flip_storage_order (fieldmode, value);\n \t  gcc_assert (bitnum % BITS_PER_UNIT == 0);\n \t  emit_move_insn (str_rtx, value);\n \t}\n@@ -977,7 +1077,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  gcc_assert (bitnum + bitsize <= GET_MODE_BITSIZE (fieldmode));\n \t  temp = copy_to_reg (str_rtx);\n \t  if (!store_bit_field_1 (temp, bitsize, bitnum, 0, 0,\n-\t\t\t\t  fieldmode, value, true))\n+\t\t\t\t  fieldmode, value, reverse, true))\n \t    gcc_unreachable ();\n \n \t  emit_move_insn (str_rtx, temp);\n@@ -1010,19 +1110,21 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   if (!store_bit_field_1 (str_rtx, bitsize, bitnum,\n \t\t\t  bitregion_start, bitregion_end,\n-\t\t\t  fieldmode, value, true))\n+\t\t\t  fieldmode, value, reverse, true))\n     gcc_unreachable ();\n }\n \f\n /* Use shifts and boolean operations to store VALUE into a bit field of\n-   width BITSIZE in OP0, starting at bit BITNUM.  */\n+   width BITSIZE in OP0, starting at bit BITNUM.\n+\n+   If REVERSE is true, the store is to be done in reverse order.  */\n \n static void\n store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t       unsigned HOST_WIDE_INT bitnum,\n \t\t       unsigned HOST_WIDE_INT bitregion_start,\n \t\t       unsigned HOST_WIDE_INT bitregion_end,\n-\t\t       rtx value)\n+\t\t       rtx value, bool reverse)\n {\n   /* There is a case not handled here:\n      a structure with a known alignment of just a halfword\n@@ -1045,14 +1147,14 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t  /* The only way this should occur is if the field spans word\n \t     boundaries.  */\n \t  store_split_bit_field (op0, bitsize, bitnum, bitregion_start,\n-\t\t\t\t bitregion_end, value);\n+\t\t\t\t bitregion_end, value, reverse);\n \t  return;\n \t}\n \n       op0 = narrow_bit_field_mem (op0, mode, bitsize, bitnum, &bitnum);\n     }\n \n-  store_fixed_bit_field_1 (op0, bitsize, bitnum, value);\n+  store_fixed_bit_field_1 (op0, bitsize, bitnum, value, reverse);\n }\n \n /* Helper function for store_fixed_bit_field, stores\n@@ -1061,7 +1163,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n static void\n store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t unsigned HOST_WIDE_INT bitnum,\n-\t\t\t rtx value)\n+\t\t\t rtx value, bool reverse)\n {\n   machine_mode mode;\n   rtx temp;\n@@ -1074,7 +1176,7 @@ store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n   /* Note that bitsize + bitnum can be greater than GET_MODE_BITSIZE (mode)\n      for invalid input, such as f5 from gcc.dg/pr48335-2.c.  */\n \n-  if (BYTES_BIG_ENDIAN)\n+  if (reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n     /* BITNUM is the distance between our msb\n        and that of the containing datum.\n        Convert it to the distance from the lsb.  */\n@@ -1120,6 +1222,9 @@ store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t      bitnum, NULL_RTX, 1);\n     }\n \n+  if (reverse)\n+    value = flip_storage_order (mode, value);\n+\n   /* Now clear the chosen bits in OP0,\n      except that if VALUE is -1 we need not bother.  */\n   /* We keep the intermediates in registers to allow CSE to combine\n@@ -1129,8 +1234,10 @@ store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \n   if (! all_one)\n     {\n-      temp = expand_binop (mode, and_optab, temp,\n-\t\t\t   mask_rtx (mode, bitnum, bitsize, 1),\n+      rtx mask = mask_rtx (mode, bitnum, bitsize, 1);\n+      if (reverse)\n+\tmask = flip_storage_order (mode, mask);\n+      temp = expand_binop (mode, and_optab, temp, mask,\n \t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       temp = force_reg (mode, temp);\n     }\n@@ -1158,17 +1265,18 @@ store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n    (within the word).\n    VALUE is the value to store.\n \n+   If REVERSE is true, the store is to be done in reverse order.\n+\n    This does not yet handle fields wider than BITS_PER_WORD.  */\n \n static void\n store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t       unsigned HOST_WIDE_INT bitpos,\n \t\t       unsigned HOST_WIDE_INT bitregion_start,\n \t\t       unsigned HOST_WIDE_INT bitregion_end,\n-\t\t       rtx value)\n+\t\t       rtx value, bool reverse)\n {\n-  unsigned int unit;\n-  unsigned int bitsdone = 0;\n+  unsigned int unit, total_bits, bitsdone = 0;\n \n   /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n      much at a time.  */\n@@ -1199,12 +1307,14 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t\t       : word_mode, value));\n     }\n \n+  total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n+\n   while (bitsdone < bitsize)\n     {\n       unsigned HOST_WIDE_INT thissize;\n-      rtx part, word;\n       unsigned HOST_WIDE_INT thispos;\n       unsigned HOST_WIDE_INT offset;\n+      rtx part, word;\n \n       offset = (bitpos + bitsdone) / unit;\n       thispos = (bitpos + bitsdone) % unit;\n@@ -1229,13 +1339,18 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       thissize = MIN (bitsize - bitsdone, BITS_PER_WORD);\n       thissize = MIN (thissize, unit - thispos);\n \n-      if (BYTES_BIG_ENDIAN)\n+      if (reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n \t{\n \t  /* Fetch successively less significant portions.  */\n \t  if (CONST_INT_P (value))\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n \t\t\t     >> (bitsize - bitsdone - thissize))\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n+          /* Likewise, but the source is little-endian.  */\n+          else if (reverse)\n+\t    part = extract_fixed_bit_field (word_mode, value, thissize,\n+\t\t\t\t\t    bitsize - bitsdone - thissize,\n+\t\t\t\t\t    NULL_RTX, 1, false);\n \t  else\n \t    {\n \t      int total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n@@ -1244,7 +1359,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t endianness compensation) to fetch the piece we want.  */\n \t      part = extract_fixed_bit_field (word_mode, value, thissize,\n \t\t\t\t\t      total_bits - bitsize + bitsdone,\n-\t\t\t\t\t      NULL_RTX, 1);\n+\t\t\t\t\t      NULL_RTX, 1, false);\n \t    }\n \t}\n       else\n@@ -1254,9 +1369,14 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n \t\t\t     >> bitsdone)\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n+\t  /* Likewise, but the source is big-endian.  */\n+          else if (reverse)\n+\t    part = extract_fixed_bit_field (word_mode, value, thissize,\n+\t\t\t\t\t    total_bits - bitsdone - thissize,\n+\t\t\t\t\t    NULL_RTX, 1, false);\n \t  else\n \t    part = extract_fixed_bit_field (word_mode, value, thissize,\n-\t\t\t\t\t    bitsdone, NULL_RTX, 1);\n+\t\t\t\t\t    bitsdone, NULL_RTX, 1, false);\n \t}\n \n       /* If OP0 is a register, then handle OFFSET here.\n@@ -1294,7 +1414,8 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t it is just an out-of-bounds access.  Ignore it.  */\n       if (word != const0_rtx)\n \tstore_fixed_bit_field (word, thissize, offset * unit + thispos,\n-\t\t\t       bitregion_start, bitregion_end, part);\n+\t\t\t       bitregion_start, bitregion_end, part,\n+\t\t\t       reverse);\n       bitsdone += thissize;\n     }\n }\n@@ -1419,7 +1540,7 @@ static rtx\n extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t     unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n \t\t     machine_mode mode, machine_mode tmode,\n-\t\t     bool fallback_p)\n+\t\t     bool reverse, bool fallback_p)\n {\n   rtx op0 = str_rtx;\n   machine_mode int_mode;\n@@ -1445,6 +1566,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && bitnum == 0\n       && bitsize == GET_MODE_BITSIZE (GET_MODE (op0)))\n     {\n+      if (reverse)\n+\top0 = flip_storage_order (mode, op0);\n       /* We're trying to extract a full register from itself.  */\n       return op0;\n     }\n@@ -1561,6 +1684,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      as the least significant bit of the value is the least significant\n      bit of either OP0 or a word of OP0.  */\n   if (!MEM_P (op0)\n+      && !reverse\n       && lowpart_bit_field_p (bitnum, bitsize, GET_MODE (op0))\n       && bitsize == GET_MODE_BITSIZE (mode1)\n       && TRULY_NOOP_TRUNCATION_MODES_P (mode1, GET_MODE (op0)))\n@@ -1576,6 +1700,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (simple_mem_bitfield_p (op0, bitsize, bitnum, mode1))\n     {\n       op0 = adjust_bitfield_address (op0, mode1, bitnum / BITS_PER_UNIT);\n+      if (reverse)\n+\top0 = flip_storage_order (mode1, op0);\n       return convert_extracted_bit_field (op0, mode, tmode, unsignedp);\n     }\n \n@@ -1588,7 +1714,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t This is because the most significant word is the one which may\n \t be less than full.  */\n \n-      unsigned int backwards = WORDS_BIG_ENDIAN;\n+      const bool backwards = WORDS_BIG_ENDIAN;\n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n       rtx_insn *last;\n@@ -1615,7 +1741,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t       ? GET_MODE_SIZE (GET_MODE (target)) / UNITS_PER_WORD - i - 1\n \t       : i);\n \t  /* Offset from start of field in OP0.  */\n-\t  unsigned int bit_offset = (backwards\n+\t  unsigned int bit_offset = (backwards ^ reverse\n \t\t\t\t     ? MAX ((int) bitsize - ((int) i + 1)\n \t\t\t\t\t    * BITS_PER_WORD,\n \t\t\t\t\t    0)\n@@ -1625,7 +1751,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    = extract_bit_field_1 (op0, MIN (BITS_PER_WORD,\n \t\t\t\t\t     bitsize - i * BITS_PER_WORD),\n \t\t\t\t   bitnum + bit_offset, 1, target_part,\n-\t\t\t\t   mode, word_mode, fallback_p);\n+\t\t\t\t   mode, word_mode, reverse, fallback_p);\n \n \t  gcc_assert (target_part);\n \t  if (!result_part)\n@@ -1675,7 +1801,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  if (!fallback_p)\n \t    return NULL_RTX;\n-\t  target = extract_split_bit_field (op0, bitsize, bitnum, unsignedp);\n+\t  target = extract_split_bit_field (op0, bitsize, bitnum, unsignedp,\n+\t\t\t\t\t    reverse);\n \t  return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n \t}\n     }\n@@ -1685,6 +1812,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   enum extraction_pattern pattern = unsignedp ? EP_extzv : EP_extv;\n   extraction_insn extv;\n   if (!MEM_P (op0)\n+      && !reverse\n       /* ??? We could limit the structure size to the part of OP0 that\n \t contains the field, with appropriate checks for endianness\n \t and TRULY_NOOP_TRUNCATION.  */\n@@ -1701,7 +1829,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a\n      cheap register alternative is available.  */\n-  if (MEM_P (op0))\n+  if (MEM_P (op0) & !reverse)\n     {\n       if (get_best_mem_extraction_insn (&extv, pattern, bitsize, bitnum,\n \t\t\t\t\ttmode))\n@@ -1726,7 +1854,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  xop0 = copy_to_reg (xop0);\n \t  rtx result = extract_bit_field_1 (xop0, bitsize, bitpos,\n \t\t\t\t\t    unsignedp, target,\n-\t\t\t\t\t    mode, tmode, false);\n+\t\t\t\t\t    mode, tmode, reverse, false);\n \t  if (result)\n \t    return result;\n \t  delete_insns_since (last);\n@@ -1744,9 +1872,21 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   /* Should probably push op0 out to memory and then do a load.  */\n   gcc_assert (int_mode != BLKmode);\n \n-  target = extract_fixed_bit_field (int_mode, op0, bitsize, bitnum,\n-\t\t\t\t    target, unsignedp);\n-  return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n+  target = extract_fixed_bit_field (int_mode, op0, bitsize, bitnum, target,\n+\t\t\t\t    unsignedp, reverse);\n+\n+  /* Complex values must be reversed piecewise, so we need to undo the global\n+     reversal, convert to the complex mode and reverse again.  */\n+  if (reverse && COMPLEX_MODE_P (tmode))\n+    {\n+      target = flip_storage_order (int_mode, target);\n+      target = convert_extracted_bit_field (target, mode, tmode, unsignedp);\n+      target = flip_storage_order (tmode, target);\n+    }\n+  else\n+    target = convert_extracted_bit_field (target, mode, tmode, unsignedp);\n+\n+  return target;\n }\n \n /* Generate code to extract a byte-field from STR_RTX\n@@ -1760,6 +1900,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n    TMODE is the mode the caller would like the value to have;\n    but the value may be returned with type MODE instead.\n \n+   If REVERSE is true, the extraction is to be done in reverse order.\n+\n    If a TARGET is specified and we can store in it at no extra cost,\n    we do so, and return TARGET.\n    Otherwise, we return a REG of mode TMODE or MODE, with TMODE preferred\n@@ -1768,7 +1910,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n rtx\n extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n-\t\t   machine_mode mode, machine_mode tmode)\n+\t\t   machine_mode mode, machine_mode tmode, bool reverse)\n {\n   machine_mode mode1;\n \n@@ -1790,6 +1932,8 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  rtx result = adjust_bitfield_address (str_rtx, mode1,\n \t\t\t\t\t\tbitnum / BITS_PER_UNIT);\n+\t  if (reverse)\n+\t    result = flip_storage_order (mode1, result);\n \t  gcc_assert (bitnum % BITS_PER_UNIT == 0);\n \t  return convert_extracted_bit_field (result, mode, tmode, unsignedp);\n \t}\n@@ -1801,13 +1945,15 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     }\n \n   return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,\n-\t\t\t      target, mode, tmode, true);\n+\t\t\t      target, mode, tmode, reverse, true);\n }\n \f\n /* Use shifts and boolean operations to extract a field of BITSIZE bits\n    from bit BITNUM of OP0.\n \n    UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).\n+   If REVERSE is true, the extraction is to be done in reverse order.\n+\n    If TARGET is nonzero, attempts to store the value there\n    and return TARGET, but this is not guaranteed.\n    If TARGET is not used, create a pseudo-reg of mode TMODE for the value.  */\n@@ -1816,7 +1962,7 @@ static rtx\n extract_fixed_bit_field (machine_mode tmode, rtx op0,\n \t\t\t unsigned HOST_WIDE_INT bitsize,\n \t\t\t unsigned HOST_WIDE_INT bitnum, rtx target,\n-\t\t\t int unsignedp)\n+\t\t\t int unsignedp, bool reverse)\n {\n   if (MEM_P (op0))\n     {\n@@ -1827,13 +1973,14 @@ extract_fixed_bit_field (machine_mode tmode, rtx op0,\n       if (mode == VOIDmode)\n \t/* The only way this should occur is if the field spans word\n \t   boundaries.  */\n-\treturn extract_split_bit_field (op0, bitsize, bitnum, unsignedp);\n+\treturn extract_split_bit_field (op0, bitsize, bitnum, unsignedp,\n+\t\t\t\t\treverse);\n \n       op0 = narrow_bit_field_mem (op0, mode, bitsize, bitnum, &bitnum);\n     }\n \n   return extract_fixed_bit_field_1 (tmode, op0, bitsize, bitnum,\n-\t\t\t\t    target, unsignedp);\n+\t\t\t\t    target, unsignedp, reverse);\n }\n \n /* Helper function for extract_fixed_bit_field, extracts\n@@ -1843,7 +1990,7 @@ static rtx\n extract_fixed_bit_field_1 (machine_mode tmode, rtx op0,\n \t\t\t   unsigned HOST_WIDE_INT bitsize,\n \t\t\t   unsigned HOST_WIDE_INT bitnum, rtx target,\n-\t\t\t   int unsignedp)\n+\t\t\t   int unsignedp, bool reverse)\n {\n   machine_mode mode = GET_MODE (op0);\n   gcc_assert (SCALAR_INT_MODE_P (mode));\n@@ -1852,13 +1999,15 @@ extract_fixed_bit_field_1 (machine_mode tmode, rtx op0,\n      for invalid input, such as extract equivalent of f5 from\n      gcc.dg/pr48335-2.c.  */\n \n-  if (BYTES_BIG_ENDIAN)\n+  if (reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n     /* BITNUM is the distance between our msb and that of OP0.\n        Convert it to the distance from the lsb.  */\n     bitnum = GET_MODE_BITSIZE (mode) - bitsize - bitnum;\n \n   /* Now BITNUM is always the distance between the field's lsb and that of OP0.\n      We have reduced the big-endian case to the little-endian case.  */\n+  if (reverse)\n+    op0 = flip_storage_order (mode, op0);\n \n   if (unsignedp)\n     {\n@@ -1930,11 +2079,14 @@ lshift_value (machine_mode mode, unsigned HOST_WIDE_INT value,\n \n    OP0 is the REG, SUBREG or MEM rtx for the first of the two words.\n    BITSIZE is the field width; BITPOS, position of its first bit, in the word.\n-   UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.  */\n+   UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.\n+\n+   If REVERSE is true, the extraction is to be done in reverse order.  */\n \n static rtx\n extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n-\t\t\t unsigned HOST_WIDE_INT bitpos, int unsignedp)\n+\t\t\t unsigned HOST_WIDE_INT bitpos, int unsignedp,\n+\t\t\t bool reverse)\n {\n   unsigned int unit;\n   unsigned int bitsdone = 0;\n@@ -1989,11 +2141,11 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t whose meaning is determined by BYTES_PER_UNIT.\n \t OFFSET is in UNITs, and UNIT is in bits.  */\n       part = extract_fixed_bit_field (word_mode, word, thissize,\n-\t\t\t\t      offset * unit + thispos, 0, 1);\n+\t\t\t\t      offset * unit + thispos, 0, 1, reverse);\n       bitsdone += thissize;\n \n       /* Shift this part into place for the result.  */\n-      if (BYTES_BIG_ENDIAN)\n+      if (reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n \t{\n \t  if (bitsize != bitsdone)\n \t    part = expand_shift (LSHIFT_EXPR, word_mode, part,"}, {"sha": "0a7afd2c3cf60805ca2800f3ae1f0f05f198a298", "filename": "gcc/expmed.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -676,6 +676,10 @@ extern rtx emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n    May emit insns.  */\n extern rtx negate_rtx (machine_mode, rtx);\n \n+/* Arguments MODE, RTX: return an rtx for the flipping of that value.\n+   May emit insns.  */\n+extern rtx flip_storage_order (enum machine_mode, rtx);\n+\n /* Expand a logical AND operation.  */\n extern rtx expand_and (machine_mode, rtx, rtx, rtx);\n \n@@ -707,10 +711,10 @@ extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,\n-\t\t\t     machine_mode, rtx);\n+\t\t\t     machine_mode, rtx, bool);\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n-\t\t\t      machine_mode, machine_mode);\n+\t\t\t      machine_mode, machine_mode, bool);\n extern rtx extract_low_bits (machine_mode, machine_mode, rtx);\n extern rtx expand_mult (machine_mode, rtx, rtx, rtx, int);\n extern rtx expand_mult_highpart_adjust (machine_mode, rtx, rtx, rtx, rtx, int);"}, {"sha": "050642daa4f8b21e48a832d274bb53e5d615731c", "filename": "gcc/expr.c", "status": "modified", "additions": 211, "deletions": 117, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -121,11 +121,11 @@ static rtx_insn *compress_float_constant (rtx, rtx);\n static rtx get_subtarget (rtx);\n static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t     HOST_WIDE_INT, machine_mode,\n-\t\t\t\t     tree, int, alias_set_type);\n-static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n+\t\t\t\t     tree, int, alias_set_type, bool);\n+static void store_constructor (tree, rtx, int, HOST_WIDE_INT, bool);\n static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\tmachine_mode, tree, alias_set_type, bool);\n+\t\t\tmachine_mode, tree, alias_set_type, bool, bool);\n \n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (const_tree, const_tree);\n \n@@ -1678,7 +1678,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t\t  && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n \t\t\t\t\t     (bytepos % slen0) * BITS_PER_UNIT,\n-\t\t\t\t\t     1, NULL_RTX, mode, mode);\n+\t\t\t\t\t     1, NULL_RTX, mode, mode, false);\n \t    }\n \t  else\n \t    {\n@@ -1688,7 +1688,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t      mem = assign_stack_temp (GET_MODE (src), slen);\n \t      emit_move_insn (mem, src);\n \t      tmps[i] = extract_bit_field (mem, bytelen * BITS_PER_UNIT,\n-\t\t\t\t\t   0, 1, NULL_RTX, mode, mode);\n+\t\t\t\t\t   0, 1, NULL_RTX, mode, mode, false);\n \t    }\n \t}\n       /* FIXME: A SIMD parallel will eventually lead to a subreg of a\n@@ -1731,7 +1731,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n       else\n \ttmps[i] = extract_bit_field (src, bytelen * BITS_PER_UNIT,\n \t\t\t\t     bytepos * BITS_PER_UNIT, 1, NULL_RTX,\n-\t\t\t\t     mode, mode);\n+\t\t\t\t     mode, mode, false);\n \n       if (shift)\n \ttmps[i] = expand_shift (LSHIFT_EXPR, mode, tmps[i],\n@@ -2039,7 +2039,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t  store_bit_field (dest,\n \t\t\t   adj_bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n \t\t\t   bytepos * BITS_PER_UNIT, ssize * BITS_PER_UNIT - 1,\n-\t\t\t   VOIDmode, tmps[i]);\n+\t\t\t   VOIDmode, tmps[i], false);\n \t}\n \n       /* Optimize the access just a bit.  */\n@@ -2052,7 +2052,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \n       else\n \tstore_bit_field (dest, bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n-\t\t\t 0, 0, mode, tmps[i]);\n+\t\t\t 0, 0, mode, tmps[i], false);\n     }\n \n   /* Copy from the pseudo into the (probable) hard reg.  */\n@@ -2182,7 +2182,9 @@ copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n       store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, 0, 0, copy_mode,\n \t\t       extract_bit_field (src, bitsize,\n \t\t\t\t\t  xbitpos % BITS_PER_WORD, 1,\n-\t\t\t\t\t  NULL_RTX, copy_mode, copy_mode));\n+\t\t\t\t\t  NULL_RTX, copy_mode, copy_mode,\n+\t\t\t\t\t  false),\n+\t\t       false);\n     }\n }\n \n@@ -2259,7 +2261,9 @@ copy_blkmode_to_reg (machine_mode mode, tree src)\n \t\t       0, 0, word_mode,\n \t\t       extract_bit_field (src_word, bitsize,\n \t\t\t\t\t  bitpos % BITS_PER_WORD, 1,\n-\t\t\t\t\t  NULL_RTX, word_mode, word_mode));\n+\t\t\t\t\t  NULL_RTX, word_mode, word_mode,\n+\t\t\t\t\t  false),\n+\t\t       false);\n     }\n \n   if (mode == BLKmode)\n@@ -3004,7 +3008,8 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n \tgcc_assert (MEM_P (cplx) && ibitsize < BITS_PER_WORD);\n     }\n \n-  store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, 0, 0, imode, val);\n+  store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, 0, 0, imode, val,\n+\t\t   false);\n }\n \n /* Extract one of the components of the complex value CPLX.  Extract the\n@@ -3067,7 +3072,7 @@ read_complex_part (rtx cplx, bool imag_p)\n     }\n \n   return extract_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0,\n-\t\t\t    true, NULL_RTX, imode, imode);\n+\t\t\t    true, NULL_RTX, imode, imode, false);\n }\n \f\n /* A subroutine of emit_move_insn_1.  Yet another lowpart generator.\n@@ -4457,7 +4462,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t unsigned HOST_WIDE_INT bitregion_start,\n \t\t\t\t unsigned HOST_WIDE_INT bitregion_end,\n \t\t\t\t machine_mode mode1, rtx str_rtx,\n-\t\t\t\t tree to, tree src)\n+\t\t\t\t tree to, tree src, bool reverse)\n {\n   machine_mode str_mode = GET_MODE (str_rtx);\n   unsigned int str_bitsize = GET_MODE_BITSIZE (str_mode);\n@@ -4530,6 +4535,8 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n     }\n   else if (!REG_P (str_rtx) && GET_CODE (str_rtx) != SUBREG)\n     return false;\n+  else\n+    gcc_assert (!reverse);\n \n   /* If the bit field covers the whole REG/MEM, store_field\n      will likely generate better code.  */\n@@ -4540,7 +4547,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n   if (bitpos + bitsize > str_bitsize)\n     return false;\n \n-  if (BYTES_BIG_ENDIAN)\n+  if (reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n     bitpos = str_bitsize - bitpos - bitsize;\n \n   switch (code)\n@@ -4553,7 +4560,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \t We might win by one instruction for the other bitfields\n \t too if insv/extv instructions aren't used, so that\n \t can be added later.  */\n-      if (bitpos + bitsize != str_bitsize\n+      if ((reverse || bitpos + bitsize != str_bitsize)\n \t  && (bitsize != 1 || TREE_CODE (op1) != INTEGER_CST))\n \tbreak;\n \n@@ -4571,13 +4578,17 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \t  set_mem_expr (str_rtx, 0);\n \t}\n \n-      binop = code == PLUS_EXPR ? add_optab : sub_optab;\n-      if (bitsize == 1 && bitpos + bitsize != str_bitsize)\n+      if (bitsize == 1 && (reverse || bitpos + bitsize != str_bitsize))\n \t{\n \t  value = expand_and (str_mode, value, const1_rtx, NULL);\n \t  binop = xor_optab;\n \t}\n+      else\n+\tbinop = code == PLUS_EXPR ? add_optab : sub_optab;\n+\n       value = expand_shift (LSHIFT_EXPR, str_mode, value, bitpos, NULL_RTX, 1);\n+      if (reverse)\n+\tvalue = flip_storage_order (str_mode, value);\n       result = expand_binop (str_mode, binop, str_rtx,\n \t\t\t     value, str_rtx, 1, OPTAB_WIDEN);\n       if (result != str_rtx)\n@@ -4610,6 +4621,8 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \t  value = expand_and (str_mode, value, mask, NULL_RTX);\n \t}\n       value = expand_shift (LSHIFT_EXPR, str_mode, value, bitpos, NULL_RTX, 1);\n+      if (reverse)\n+\tvalue = flip_storage_order (str_mode, value);\n       result = expand_binop (str_mode, binop, str_rtx,\n \t\t\t     value, str_rtx, 1, OPTAB_WIDEN);\n       if (result != str_rtx)\n@@ -4664,10 +4677,10 @@ get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n       machine_mode rmode;\n       HOST_WIDE_INT rbitsize, rbitpos;\n       tree roffset;\n-      int unsignedp;\n-      int volatilep = 0;\n+      int unsignedp, reversep, volatilep = 0;\n       get_inner_reference (TREE_OPERAND (exp, 0), &rbitsize, &rbitpos,\n-\t\t\t   &roffset, &rmode, &unsignedp, &volatilep, false);\n+\t\t\t   &roffset, &rmode, &unsignedp, &reversep,\n+\t\t\t   &volatilep, false);\n       if ((rbitpos % BITS_PER_UNIT) != 0)\n \t{\n \t  *bitstart = *bitend = 0;\n@@ -4783,6 +4796,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       reg = expand_expr (from, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n       reg = force_not_mem (reg);\n       mem = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+      if (TREE_CODE (to) == MEM_REF && REF_REVERSE_STORAGE_ORDER (to))\n+\treg = flip_storage_order (mode, reg);\n \n       if (icode != CODE_FOR_nothing)\n \t{\n@@ -4795,7 +4810,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  expand_insn (icode, 2, ops);\n \t}\n       else\n-\tstore_bit_field (mem, GET_MODE_BITSIZE (mode), 0, 0, 0, mode, reg);\n+\tstore_bit_field (mem, GET_MODE_BITSIZE (mode), 0, 0, 0, mode, reg,\n+\t\t\t false);\n       return;\n     }\n \n@@ -4806,21 +4822,21 @@ expand_assignment (tree to, tree from, bool nontemporal)\n      problem.  Same for (partially) storing into a non-memory object.  */\n   if (handled_component_p (to)\n       || (TREE_CODE (to) == MEM_REF\n-\t  && mem_ref_refers_to_non_mem_p (to))\n+\t  && (REF_REVERSE_STORAGE_ORDER (to)\n+\t      || mem_ref_refers_to_non_mem_p (to)))\n       || TREE_CODE (TREE_TYPE (to)) == ARRAY_TYPE)\n     {\n       machine_mode mode1;\n       HOST_WIDE_INT bitsize, bitpos;\n       unsigned HOST_WIDE_INT bitregion_start = 0;\n       unsigned HOST_WIDE_INT bitregion_end = 0;\n       tree offset;\n-      int unsignedp;\n-      int volatilep = 0;\n+      int unsignedp, reversep, volatilep = 0;\n       tree tem;\n \n       push_temp_slots ();\n       tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,\n-\t\t\t\t &unsignedp, &volatilep, true);\n+\t\t\t\t &unsignedp, &reversep, &volatilep, true);\n \n       /* Make sure bitpos is not negative, it can wreak havoc later.  */\n       if (bitpos < 0)\n@@ -4939,22 +4955,22 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  if (COMPLEX_MODE_P (TYPE_MODE (TREE_TYPE (from)))\n \t      && bitpos == 0\n \t      && bitsize == mode_bitsize)\n-\t    result = store_expr (from, to_rtx, false, nontemporal);\n+\t    result = store_expr (from, to_rtx, false, nontemporal, reversep);\n \t  else if (bitsize == mode_bitsize / 2\n \t\t   && (bitpos == 0 || bitpos == mode_bitsize / 2))\n \t    result = store_expr (from, XEXP (to_rtx, bitpos != 0), false,\n-\t\t\t\t nontemporal);\n+\t\t\t\t nontemporal, reversep);\n \t  else if (bitpos + bitsize <= mode_bitsize / 2)\n \t    result = store_field (XEXP (to_rtx, 0), bitsize, bitpos,\n \t\t\t\t  bitregion_start, bitregion_end,\n-\t\t\t\t  mode1, from,\n-\t\t\t\t  get_alias_set (to), nontemporal);\n+\t\t\t\t  mode1, from, get_alias_set (to),\n+\t\t\t\t  nontemporal, reversep);\n \t  else if (bitpos >= mode_bitsize / 2)\n \t    result = store_field (XEXP (to_rtx, 1), bitsize,\n \t\t\t\t  bitpos - mode_bitsize / 2,\n \t\t\t\t  bitregion_start, bitregion_end,\n-\t\t\t\t  mode1, from,\n-\t\t\t\t  get_alias_set (to), nontemporal);\n+\t\t\t\t  mode1, from, get_alias_set (to),\n+\t\t\t\t  nontemporal, reversep);\n \t  else if (bitpos == 0 && bitsize == mode_bitsize)\n \t    {\n \t      rtx from_rtx;\n@@ -4974,8 +4990,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t      write_complex_part (temp, XEXP (to_rtx, 1), true);\n \t      result = store_field (temp, bitsize, bitpos,\n \t\t\t\t    bitregion_start, bitregion_end,\n-\t\t\t\t    mode1, from,\n-\t\t\t\t    get_alias_set (to), nontemporal);\n+\t\t\t\t    mode1, from, get_alias_set (to),\n+\t\t\t\t    nontemporal, reversep);\n \t      emit_move_insn (XEXP (to_rtx, 0), read_complex_part (temp, false));\n \t      emit_move_insn (XEXP (to_rtx, 1), read_complex_part (temp, true));\n \t    }\n@@ -4994,14 +5010,14 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n \t  if (optimize_bitfield_assignment_op (bitsize, bitpos,\n \t\t\t\t\t       bitregion_start, bitregion_end,\n-\t\t\t\t\t       mode1,\n-\t\t\t\t\t       to_rtx, to, from))\n+\t\t\t\t\t       mode1, to_rtx, to, from,\n+\t\t\t\t\t       reversep))\n \t    result = NULL;\n \t  else\n \t    result = store_field (to_rtx, bitsize, bitpos,\n \t\t\t\t  bitregion_start, bitregion_end,\n-\t\t\t\t  mode1, from,\n-\t\t\t\t  get_alias_set (to), nontemporal);\n+\t\t\t\t  mode1, from, get_alias_set (to),\n+\t\t\t\t  nontemporal, reversep);\n \t}\n \n       if (result)\n@@ -5155,7 +5171,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   /* Compute FROM and store the value in the rtx we got.  */\n \n   push_temp_slots ();\n-  result = store_expr_with_bounds (from, to_rtx, 0, nontemporal, to);\n+  result = store_expr_with_bounds (from, to_rtx, 0, nontemporal, false, to);\n   preserve_temp_slots (result);\n   pop_temp_slots ();\n   return;\n@@ -5194,12 +5210,14 @@ emit_storent_insn (rtx to, rtx from)\n \n    If NONTEMPORAL is true, try using a nontemporal store instruction.\n \n+   If REVERSE is true, the store is to be done in reverse order.\n+\n    If BTARGET is not NULL then computed bounds of EXP are\n    associated with BTARGET.  */\n \n rtx\n store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n-\t\t\tbool nontemporal, tree btarget)\n+\t\t\tbool nontemporal, bool reverse, tree btarget)\n {\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n@@ -5221,7 +5239,8 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n \t\t   call_param_p ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n       return store_expr_with_bounds (TREE_OPERAND (exp, 1), target,\n-\t\t\t\t     call_param_p, nontemporal, btarget);\n+\t\t\t\t     call_param_p, nontemporal, reverse,\n+\t\t\t\t     btarget);\n     }\n   else if (TREE_CODE (exp) == COND_EXPR && GET_MODE (target) == BLKmode)\n     {\n@@ -5236,12 +5255,12 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1, -1);\n       store_expr_with_bounds (TREE_OPERAND (exp, 1), target, call_param_p,\n-\t\t\t      nontemporal, btarget);\n+\t\t\t      nontemporal, reverse, btarget);\n       emit_jump_insn (targetm.gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n       store_expr_with_bounds (TREE_OPERAND (exp, 2), target, call_param_p,\n-\t\t\t      nontemporal, btarget);\n+\t\t\t      nontemporal, reverse, btarget);\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n@@ -5380,9 +5399,9 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n       rtx tmp_target;\n \n   normal_expr:\n-      /* If we want to use a nontemporal store, force the value to\n-\t register first.  */\n-      tmp_target = nontemporal ? NULL_RTX : target;\n+      /* If we want to use a nontemporal or a reverse order store, force the\n+\t value into a register first.  */\n+      tmp_target = nontemporal || reverse ? NULL_RTX : target;\n       temp = expand_expr_real (exp, tmp_target, GET_MODE (target),\n \t\t\t       (call_param_p\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL),\n@@ -5457,7 +5476,7 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n \t      else\n \t\tstore_bit_field (target,\n \t\t\t\t INTVAL (expr_size (exp)) * BITS_PER_UNIT,\n-\t\t\t\t 0, 0, 0, GET_MODE (temp), temp);\n+\t\t\t\t 0, 0, 0, GET_MODE (temp), temp, reverse);\n \t    }\n \t  else\n \t    convert_move (target, temp, TYPE_UNSIGNED (TREE_TYPE (exp)));\n@@ -5556,6 +5575,8 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n \t;\n       else\n \t{\n+\t  if (reverse)\n+\t    temp = flip_storage_order (GET_MODE (target), temp);\n \t  temp = force_operand (temp, target);\n \t  if (temp != target)\n \t    emit_move_insn (target, temp);\n@@ -5567,9 +5588,11 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n \n /* Same as store_expr_with_bounds but ignoring bounds of EXP.  */\n rtx\n-store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n+store_expr (tree exp, rtx target, int call_param_p, bool nontemporal,\n+\t    bool reverse)\n {\n-  return store_expr_with_bounds (exp, target, call_param_p, nontemporal, NULL);\n+  return store_expr_with_bounds (exp, target, call_param_p, nontemporal,\n+\t\t\t\t reverse, NULL);\n }\n \f\n /* Return true if field F of structure TYPE is a flexible array.  */\n@@ -5789,8 +5812,12 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t    init_elts += mult * tc;\n \n \t    if (const_from_elts_p && const_p)\n-\t      const_p = initializer_constant_valid_p (value, elt_type)\n-\t\t\t!= NULL_TREE;\n+\t      const_p\n+\t\t= initializer_constant_valid_p (value,\n+\t\t\t\t\t\telt_type,\n+\t\t\t\t\t\tTYPE_REVERSE_STORAGE_ORDER\n+\t\t\t\t\t\t(TREE_TYPE (ctor)))\n+\t\t  != NULL_TREE;\n \t  }\n \t  break;\n \t}\n@@ -5895,6 +5922,7 @@ all_zeros_p (const_tree exp)\n    TARGET, BITSIZE, BITPOS, MODE, EXP are as for store_field.\n    CLEARED is as for store_constructor.\n    ALIAS_SET is the alias set to use for any stores.\n+   If REVERSE is true, the store is to be done in reverse order.\n \n    This provides a recursive shortcut back to store_constructor when it isn't\n    necessary to go through store_field.  This is so that we can pass through\n@@ -5904,7 +5932,8 @@ all_zeros_p (const_tree exp)\n static void\n store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n \t\t\t HOST_WIDE_INT bitpos, machine_mode mode,\n-\t\t\t tree exp, int cleared, alias_set_type alias_set)\n+\t\t\t tree exp, int cleared,\n+\t\t\t alias_set_type alias_set, bool reverse)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR\n       /* We can only call store_constructor recursively if the size and\n@@ -5933,10 +5962,12 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n \t  set_mem_alias_set (target, alias_set);\n \t}\n \n-      store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n+      store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT,\n+\t\t\t reverse);\n     }\n   else\n-    store_field (target, bitsize, bitpos, 0, 0, mode, exp, alias_set, false);\n+    store_field (target, bitsize, bitpos, 0, 0, mode, exp, alias_set, false,\n+\t\t reverse);\n }\n \n \n@@ -5962,10 +5993,12 @@ fields_length (const_tree type)\n    CLEARED is true if TARGET is known to have been zero'd.\n    SIZE is the number of bytes of TARGET we are allowed to modify: this\n    may not be the same as the size of EXP if we are assigning to a field\n-   which has been packed to exclude padding bits.  */\n+   which has been packed to exclude padding bits.\n+   If REVERSE is true, the store is to be done in reverse order.  */\n \n static void\n-store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n+store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n+\t\t   bool reverse)\n {\n   tree type = TREE_TYPE (exp);\n   HOST_WIDE_INT exp_size = int_size_in_bytes (type);\n@@ -5979,6 +6012,9 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \tunsigned HOST_WIDE_INT idx;\n \ttree field, value;\n \n+\t/* The storage order is specified for every aggregate type.  */\n+\treverse = TYPE_REVERSE_STORAGE_ORDER (type);\n+\n \t/* If size is zero or the target is already cleared, do nothing.  */\n \tif (size == 0 || cleared)\n \t  cleared = 1;\n@@ -6122,7 +6158,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t    store_constructor_field (to_rtx, bitsize, bitpos, mode,\n \t\t\t\t     value, cleared,\n-\t\t\t\t     get_alias_set (TREE_TYPE (field)));\n+\t\t\t\t     get_alias_set (TREE_TYPE (field)),\n+\t\t\t\t     reverse);\n \t  }\n \tbreak;\n       }\n@@ -6137,6 +6174,9 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \tHOST_WIDE_INT minelt = 0;\n \tHOST_WIDE_INT maxelt = 0;\n \n+\t/* The storage order is specified for every aggregate type.  */\n+\treverse = TYPE_REVERSE_STORAGE_ORDER (type);\n+\n \tdomain = TYPE_DOMAIN (type);\n \tconst_bounds_p = (TYPE_MIN_VALUE (domain)\n \t\t\t  && TYPE_MAX_VALUE (domain)\n@@ -6277,7 +6317,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t\t\tstore_constructor_field\n \t\t\t  (target, bitsize, bitpos, mode, value, cleared,\n-\t\t\t   get_alias_set (elttype));\n+\t\t\t   get_alias_set (elttype), reverse);\n \t\t      }\n \t\t  }\n \t\telse\n@@ -6292,7 +6332,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\tVAR_DECL, NULL_TREE, domain);\n \t\t    index_r = gen_reg_rtx (promote_decl_mode (index, NULL));\n \t\t    SET_DECL_RTL (index, index_r);\n-\t\t    store_expr (lo_index, index_r, 0, false);\n+\t\t    store_expr (lo_index, index_r, 0, false, reverse);\n \n \t\t    /* Build the head of the loop.  */\n \t\t    do_pending_stack_adjust ();\n@@ -6317,9 +6357,9 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    xtarget = adjust_address (xtarget, mode, 0);\n \t\t    if (TREE_CODE (value) == CONSTRUCTOR)\n \t\t      store_constructor (value, xtarget, cleared,\n-\t\t\t\t\t bitsize / BITS_PER_UNIT);\n+\t\t\t\t\t bitsize / BITS_PER_UNIT, reverse);\n \t\t    else\n-\t\t      store_expr (value, xtarget, 0, false);\n+\t\t      store_expr (value, xtarget, 0, false, reverse);\n \n \t\t    /* Generate a conditional jump to exit the loop.  */\n \t\t    exit_cond = build2 (LT_EXPR, integer_type_node,\n@@ -6362,7 +6402,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\t  expand_normal (position),\n \t\t\t\t\t  highest_pow2_factor (position));\n \t\txtarget = adjust_address (xtarget, mode, 0);\n-\t\tstore_expr (value, xtarget, 0, false);\n+\t\tstore_expr (value, xtarget, 0, false, reverse);\n \t      }\n \t    else\n \t      {\n@@ -6380,7 +6420,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    MEM_KEEP_ALIAS_SET_P (target) = 1;\n \t\t  }\n \t\tstore_constructor_field (target, bitsize, bitpos, mode, value,\n-\t\t\t\t\t cleared, get_alias_set (elttype));\n+\t\t\t\t\t cleared, get_alias_set (elttype),\n+\t\t\t\t\t reverse);\n \t      }\n \t  }\n \tbreak;\n@@ -6513,7 +6554,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t  : eltmode;\n \t\tbitpos = eltpos * elt_size;\n \t\tstore_constructor_field (target, bitsize, bitpos, value_mode,\n-\t\t\t\t\t value, cleared, alias);\n+\t\t\t\t\t value, cleared, alias, reverse);\n \t      }\n \t  }\n \n@@ -6546,14 +6587,16 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n    (in general) be different from that for TARGET, since TARGET is a\n    reference to the containing structure.\n \n-   If NONTEMPORAL is true, try generating a nontemporal store.  */\n+   If NONTEMPORAL is true, try generating a nontemporal store.\n+\n+   If REVERSE is true, the store is to be done in reverse order.  */\n \n static rtx\n store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t     unsigned HOST_WIDE_INT bitregion_start,\n \t     unsigned HOST_WIDE_INT bitregion_end,\n \t     machine_mode mode, tree exp,\n-\t     alias_set_type alias_set, bool nontemporal)\n+\t     alias_set_type alias_set, bool nontemporal,  bool reverse)\n {\n   if (TREE_CODE (exp) == ERROR_MARK)\n     return const0_rtx;\n@@ -6568,7 +6611,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       /* We're storing into a struct containing a single __complex.  */\n \n       gcc_assert (!bitpos);\n-      return store_expr (exp, target, 0, nontemporal);\n+      return store_expr (exp, target, 0, nontemporal, reverse);\n     }\n \n   /* If the structure is in a register or if the component\n@@ -6637,16 +6680,27 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \n       temp = expand_normal (exp);\n \n-      /* If BITSIZE is narrower than the size of the type of EXP\n-\t we will be narrowing TEMP.  Normally, what's wanted are the\n-\t low-order bits.  However, if EXP's type is a record and this is\n-\t big-endian machine, we want the upper BITSIZE bits.  */\n-      if (BYTES_BIG_ENDIAN && GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT\n-\t  && bitsize < (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (temp))\n-\t  && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n-\ttemp = expand_shift (RSHIFT_EXPR, GET_MODE (temp), temp,\n-\t\t\t     GET_MODE_BITSIZE (GET_MODE (temp)) - bitsize,\n-\t\t\t     NULL_RTX, 1);\n+      /* If the value has a record type and an integral mode then, if BITSIZE\n+\t is narrower than this mode and this is for big-endian data, we must\n+\t first put the value into the low-order bits.  Moreover, the field may\n+\t be not aligned on a byte boundary; in this case, if it has reverse\n+\t storage order, it needs to be accessed as a scalar field with reverse\n+\t storage order and we must first put the value into target order.  */\n+      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n+\t  && GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT)\n+\t{\n+\t  HOST_WIDE_INT size = GET_MODE_BITSIZE (GET_MODE (temp));\n+\n+\t  reverse = TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (exp));\n+\n+\t  if (reverse)\n+\t    temp = flip_storage_order (GET_MODE (temp), temp);\n+\n+\t  if (bitsize < size\n+\t      && reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n+\t    temp = expand_shift (RSHIFT_EXPR, GET_MODE (temp), temp,\n+\t\t\t\t size - bitsize, NULL_RTX, 1);\n+\t}\n \n       /* Unless MODE is VOIDmode or BLKmode, convert TEMP to MODE.  */\n       if (mode != VOIDmode && mode != BLKmode\n@@ -6706,15 +6760,15 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t      temp_target = gen_reg_rtx (mode);\n \t      temp_target\n \t        = extract_bit_field (temp, size * BITS_PER_UNIT, 0, 1,\n-\t\t\t\t     temp_target, mode, mode);\n+\t\t\t\t     temp_target, mode, mode, false);\n \t      temp = temp_target;\n \t    }\n \t}\n \n       /* Store the value in the bitfield.  */\n       store_bit_field (target, bitsize, bitpos,\n \t\t       bitregion_start, bitregion_end,\n-\t\t       mode, temp);\n+\t\t       mode, temp, reverse);\n \n       return const0_rtx;\n     }\n@@ -6734,11 +6788,11 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (TREE_CODE (exp) == CONSTRUCTOR && bitsize >= 0)\n \t{\n \t  gcc_assert (bitsize % BITS_PER_UNIT == 0);\n-\t  store_constructor (exp, to_rtx, 0, bitsize/BITS_PER_UNIT);\n+\t  store_constructor (exp, to_rtx, 0, bitsize / BITS_PER_UNIT, reverse);\n \t  return to_rtx;\n \t}\n \n-      return store_expr (exp, to_rtx, 0, nontemporal);\n+      return store_expr (exp, to_rtx, 0, nontemporal, reverse);\n     }\n }\n \f\n@@ -6747,7 +6801,8 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n    codes and find the ultimate containing object, which we return.\n \n    We set *PBITSIZE to the size in bits that we want, *PBITPOS to the\n-   bit position, and *PUNSIGNEDP to the signedness of the field.\n+   bit position, *PUNSIGNEDP to the signedness and *PREVERSEP to the\n+   storage order of the field.\n    If the position of the field is variable, we store a tree\n    giving the variable offset (in units) in *POFFSET.\n    This offset is in addition to the bit position.\n@@ -6781,16 +6836,16 @@ tree\n get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t\t     HOST_WIDE_INT *pbitpos, tree *poffset,\n \t\t     machine_mode *pmode, int *punsignedp,\n-\t\t     int *pvolatilep, bool keep_aligning)\n+\t\t     int *preversep, int *pvolatilep, bool keep_aligning)\n {\n   tree size_tree = 0;\n   machine_mode mode = VOIDmode;\n   bool blkmode_bitfield = false;\n   tree offset = size_zero_node;\n   offset_int bit_offset = 0;\n \n-  /* First get the mode, signedness, and size.  We do this from just the\n-     outermost expression.  */\n+  /* First get the mode, signedness, storage order and size.  We do this from\n+     just the outermost expression.  */\n   *pbitsize = -1;\n   if (TREE_CODE (exp) == COMPONENT_REF)\n     {\n@@ -6843,6 +6898,8 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t*pbitsize = tree_to_uhwi (size_tree);\n     }\n \n+  *preversep = reverse_storage_order_for_component_p (exp);\n+\n   /* Compute cumulative bit-offset for nested component-refs and array-refs,\n      and find the ultimate containing object.  */\n   while (1)\n@@ -7519,7 +7576,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, machine_mode tmode,\n   rtx result, subtarget;\n   tree inner, offset;\n   HOST_WIDE_INT bitsize, bitpos;\n-  int volatilep, unsignedp;\n+  int unsignedp, reversep, volatilep = 0;\n   machine_mode mode1;\n \n   /* If we are taking the address of a constant and are at the top level,\n@@ -7626,8 +7683,8 @@ expand_expr_addr_expr_1 (tree exp, rtx target, machine_mode tmode,\n \t handle \"aligning nodes\" here: we can just bypass them because\n \t they won't change the final object whose address will be returned\n \t (they actually exist only for that purpose).  */\n-      inner = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t   &mode1, &unsignedp, &volatilep, false);\n+      inner = get_inner_reference (exp, &bitsize, &bitpos, &offset, &mode1,\n+\t\t\t\t   &unsignedp, &reversep, &volatilep, false);\n       break;\n     }\n \n@@ -7811,7 +7868,7 @@ expand_constructor (tree exp, rtx target, enum expand_modifier modifier,\n       target = assign_temp (type, TREE_ADDRESSABLE (exp), 1);\n     }\n \n-  store_constructor (exp, target, 0, int_expr_size (exp));\n+  store_constructor (exp, target, 0, int_expr_size (exp), false);\n   return target;\n }\n \n@@ -8084,19 +8141,21 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t    store_expr (treeop0,\n \t\t\tadjust_address (target, TYPE_MODE (valtype), 0),\n \t\t\tmodifier == EXPAND_STACK_PARM,\n-\t\t\tfalse);\n+\t\t\tfalse, TYPE_REVERSE_STORAGE_ORDER (type));\n \n \t  else\n \t    {\n-\t      gcc_assert (REG_P (target));\n+\t      gcc_assert (REG_P (target)\n+\t\t\t  && !TYPE_REVERSE_STORAGE_ORDER (type));\n \n \t      /* Store this field into a union of the proper type.  */\n \t      store_field (target,\n \t\t\t   MIN ((int_size_in_bytes (TREE_TYPE\n \t\t\t\t\t\t    (treeop0))\n \t\t\t\t * BITS_PER_UNIT),\n \t\t\t\t(HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),\n-\t\t\t   0, 0, 0, TYPE_MODE (valtype), treeop0, 0, false);\n+\t\t\t   0, 0, 0, TYPE_MODE (valtype), treeop0, 0,\n+\t\t\t   false, false);\n \t    }\n \n \t  /* Return the entire union.  */\n@@ -9131,7 +9190,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n         int index = BYTES_BIG_ENDIAN ? GET_MODE_NUNITS (vec_mode) - 1 : 0;\n \tint bitsize = GET_MODE_UNIT_BITSIZE (vec_mode);\n         temp = extract_bit_field (temp, bitsize, bitsize * index, unsignedp,\n-\t\t\t\t  target, mode, mode);\n+\t\t\t\t  target, mode, mode, false);\n         gcc_assert (temp);\n         return temp;\n       }\n@@ -9287,14 +9346,14 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \tjumpifnot (treeop0, lab0, -1);\n \tstore_expr (treeop1, temp,\n \t\t    modifier == EXPAND_STACK_PARM,\n-\t\t    false);\n+\t\t    false, false);\n \n \temit_jump_insn (targetm.gen_jump (lab1));\n \temit_barrier ();\n \temit_label (lab0);\n \tstore_expr (treeop2, temp,\n \t\t    modifier == EXPAND_STACK_PARM,\n-\t\t    false);\n+\t\t    false, false);\n \n \temit_label (lab1);\n \tOK_DEFER_POP;\n@@ -9847,6 +9906,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \n     case MEM_REF:\n       {\n+\tconst bool reverse = REF_REVERSE_STORAGE_ORDER (exp);\n \taddr_space_t as\n \t  = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))));\n \tmachine_mode address_mode;\n@@ -9861,6 +9921,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    HOST_WIDE_INT offset = mem_ref_offset (exp).to_short_addr ();\n \t    base = TREE_OPERAND (base, 0);\n \t    if (offset == 0\n+\t        && !reverse\n \t\t&& tree_fits_uhwi_p (TYPE_SIZE (type))\n \t\t&& (GET_MODE_BITSIZE (DECL_MODE (base))\n \t\t    == tree_to_uhwi (TYPE_SIZE (type))))\n@@ -9870,13 +9931,14 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t      {\n \t\ttemp = assign_stack_temp (DECL_MODE (base),\n \t\t\t\t\t  GET_MODE_SIZE (DECL_MODE (base)));\n-\t\tstore_expr (base, temp, 0, false);\n+\t\tstore_expr (base, temp, 0, false, false);\n \t\ttemp = adjust_address (temp, BLKmode, offset);\n \t\tset_mem_size (temp, int_size_in_bytes (type));\n \t\treturn temp;\n \t      }\n \t    exp = build3 (BIT_FIELD_REF, type, base, TYPE_SIZE (type),\n \t\t\t  bitsize_int (offset * BITS_PER_UNIT));\n+\t    REF_REVERSE_STORAGE_ORDER (exp) = reverse;\n \t    return expand_expr (exp, target, tmode, modifier);\n \t  }\n \taddress_mode = targetm.addr_space.address_mode (as);\n@@ -9926,8 +9988,12 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\t\t\t0, TYPE_UNSIGNED (TREE_TYPE (exp)),\n \t\t\t\t\t(modifier == EXPAND_STACK_PARM\n \t\t\t\t\t ? NULL_RTX : target),\n-\t\t\t\t\tmode, mode);\n+\t\t\t\t\tmode, mode, false);\n \t  }\n+\tif (reverse\n+\t    && modifier != EXPAND_MEMORY\n+\t    && modifier != EXPAND_WRITE)\n+\t  temp = flip_storage_order (mode, temp);\n \treturn temp;\n       }\n \n@@ -10133,9 +10199,10 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tmachine_mode mode1, mode2;\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n-\tint volatilep = 0, must_force_mem;\n-\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t&mode1, &unsignedp, &volatilep, true);\n+\tint reversep, volatilep = 0, must_force_mem;\n+\ttree tem\n+\t  = get_inner_reference (exp, &bitsize, &bitpos, &offset, &mode1,\n+\t\t\t\t &unsignedp, &reversep, &volatilep, true);\n \trtx orig_op0, memloc;\n \tbool clear_mem_expr = false;\n \n@@ -10190,7 +10257,11 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t  {\n \t    if (bitpos == 0\n \t\t&& bitsize == GET_MODE_BITSIZE (GET_MODE (op0)))\n-\t      return op0;\n+\t      {\n+\t\tif (reversep)\n+\t\t  op0 = flip_storage_order (GET_MODE (op0), op0);\n+\t\treturn op0;\n+\t      }\n \t    if (bitpos == 0\n \t\t&& bitsize == GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0)))\n \t\t&& bitsize)\n@@ -10376,20 +10447,38 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    if (MEM_P (op0) && REG_P (XEXP (op0, 0)))\n \t      mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n+\t    /* If the result has a record type and the extraction is done in\n+\t       an integral mode, then the field may be not aligned on a byte\n+\t       boundary; in this case, if it has reverse storage order, it\n+\t       needs to be extracted as a scalar field with reverse storage\n+\t       order and put back into memory order afterwards.  */\n+\t    if (TREE_CODE (type) == RECORD_TYPE\n+\t\t&& GET_MODE_CLASS (ext_mode) == MODE_INT)\n+\t      reversep = TYPE_REVERSE_STORAGE_ORDER (type);\n+\n \t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,\n \t\t\t\t     (modifier == EXPAND_STACK_PARM\n \t\t\t\t      ? NULL_RTX : target),\n-\t\t\t\t     ext_mode, ext_mode);\n-\n-\t    /* If the result is a record type and BITSIZE is narrower than\n-\t       the mode of OP0, an integral mode, and this is a big endian\n-\t       machine, we must put the field into the high-order bits.  */\n-\t    if (TREE_CODE (type) == RECORD_TYPE && BYTES_BIG_ENDIAN\n-\t\t&& GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n-\t\t&& bitsize < (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (op0)))\n-\t      op0 = expand_shift (LSHIFT_EXPR, GET_MODE (op0), op0,\n-\t\t\t\t  GET_MODE_BITSIZE (GET_MODE (op0))\n-\t\t\t\t  - bitsize, op0, 1);\n+\t\t\t\t     ext_mode, ext_mode, reversep);\n+\n+\t    /* If the result has a record type and the mode of OP0 is an\n+\t       integral mode then, if BITSIZE is narrower than this mode\n+\t       and this is for big-endian data, we must put the field\n+\t       into the high-order bits.  And we must also put it back\n+\t       into memory order if it has been previously reversed.  */\n+\t    if (TREE_CODE (type) == RECORD_TYPE\n+\t\t&& GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT)\n+\t      {\n+\t\tHOST_WIDE_INT size = GET_MODE_BITSIZE (GET_MODE (op0));\n+\n+\t\tif (bitsize < size\n+\t\t    && reversep ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n+\t\t  op0 = expand_shift (LSHIFT_EXPR, GET_MODE (op0), op0,\n+\t\t\t\t      size - bitsize, op0, 1);\n+\n+\t\tif (reversep)\n+\t\t  op0 = flip_storage_order (GET_MODE (op0), op0);\n+\t      }\n \n \t    /* If the result type is BLKmode, store the data into a temporary\n \t       of the appropriate type, but with the mode corresponding to the\n@@ -10435,6 +10524,12 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t  set_mem_expr (op0, NULL_TREE);\n \n \tMEM_VOLATILE_P (op0) |= volatilep;\n+\n+        if (reversep\n+\t    && modifier != EXPAND_MEMORY\n+\t    && modifier != EXPAND_WRITE)\n+\t  op0 = flip_storage_order (mode1, op0);\n+\n \tif (mode == mode1 || mode1 == BLKmode || mode1 == tmode\n \t    || modifier == EXPAND_CONST_ADDRESS\n \t    || modifier == EXPAND_INITIALIZER)\n@@ -10498,17 +10593,16 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tmachine_mode mode1;\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n-\tint unsignedp;\n-\tint volatilep = 0;\n+\tint unsignedp, reversep, volatilep = 0;\n \ttree tem\n-\t  = get_inner_reference (treeop0, &bitsize, &bitpos,\n-\t\t\t\t &offset, &mode1, &unsignedp, &volatilep,\n-\t\t\t\t true);\n+\t  = get_inner_reference (treeop0, &bitsize, &bitpos, &offset, &mode1,\n+\t\t\t\t &unsignedp, &reversep, &volatilep, true);\n \trtx orig_op0;\n \n \t/* ??? We should work harder and deal with non-zero offsets.  */\n \tif (!offset\n \t    && (bitpos % BITS_PER_UNIT) == 0\n+\t    && !reversep\n \t    && bitsize >= 0\n \t    && compare_tree_int (TYPE_SIZE (type), bitsize) == 0)\n \t  {\n@@ -10582,7 +10676,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       else if (reduce_bit_field)\n \treturn extract_bit_field (op0, TYPE_PRECISION (type), 0,\n \t\t\t\t  TYPE_UNSIGNED (type), NULL_RTX,\n-\t\t\t\t  mode, mode);\n+\t\t\t\t  mode, mode, false);\n       /* As a last resort, spill op0 to memory, and reload it in a\n \t different mode.  */\n       else if (!MEM_P (op0))"}, {"sha": "33a35aa682038a654ff2875a7796bf80337aab04", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -212,6 +212,7 @@ extern rtx_insn *emit_move_complex_push (machine_mode, rtx, rtx);\n extern rtx_insn *emit_move_complex_parts (rtx, rtx);\n extern rtx read_complex_part (rtx, bool);\n extern void write_complex_part (rtx, rtx, bool);\n+extern rtx read_complex_part (rtx, bool);\n extern rtx emit_move_resolve_push (machine_mode, rtx);\n \n /* Push a block of length SIZE (perhaps variable)\n@@ -229,8 +230,8 @@ extern void expand_assignment (tree, tree, bool);\n    and storing the value into TARGET.\n    If SUGGEST_REG is nonzero, copy the value through a register\n    and return that register, if that is possible.  */\n-extern rtx store_expr_with_bounds (tree, rtx, int, bool, tree);\n-extern rtx store_expr (tree, rtx, int, bool);\n+extern rtx store_expr_with_bounds (tree, rtx, int, bool, bool, tree);\n+extern rtx store_expr (tree, rtx, int, bool, bool);\n \n /* Given an rtx that may include add and multiply operations,\n    generate them as insns and return a pseudo-reg containing the value."}, {"sha": "88a760c5d4e271849e62fde3e2504a6671646b30", "filename": "gcc/flag-types.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -165,7 +165,6 @@ enum stack_check_type\n \n /* Names for the different levels of -Wstrict-overflow=N.  The numeric\n    values here correspond to N.  */\n-\n enum warn_strict_overflow_code\n {\n   /* Overflow warning that should be issued with -Wall: a questionable\n@@ -195,6 +194,13 @@ enum fp_contract_mode {\n   FP_CONTRACT_FAST = 2\n };\n \n+/* Scalar storage order kind.  */\n+enum scalar_storage_order_kind {\n+  SSO_NATIVE = 0,\n+  SSO_BIG_ENDIAN,\n+  SSO_LITTLE_ENDIAN\n+};\n+\n /* Vectorizer cost-model.  */\n enum vect_cost_model {\n   VECT_COST_MODEL_UNLIMITED = 0,\n@@ -203,7 +209,6 @@ enum vect_cost_model {\n   VECT_COST_MODEL_DEFAULT = 3\n };\n \n-\n /* Different instrumentation modes.  */\n enum sanitize_code {\n   /* AddressSanitizer.  */"}, {"sha": "5e329015a43fefcdc0b5207437540984d76cc8a9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 79, "deletions": 53, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -114,12 +114,12 @@ static int operand_equal_for_comparison_p (tree, tree, tree);\n static int twoval_comparison_p (tree, tree *, tree *, int *);\n static tree eval_subst (location_t, tree, tree, tree, tree, tree);\n static tree make_bit_field_ref (location_t, tree, tree,\n-\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT, int);\n+\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT, int, int);\n static tree optimize_bit_field_compare (location_t, enum tree_code,\n \t\t\t\t\ttree, tree, tree);\n static tree decode_field_reference (location_t, tree, HOST_WIDE_INT *,\n \t\t\t\t    HOST_WIDE_INT *,\n-\t\t\t\t    machine_mode *, int *, int *,\n+\t\t\t\t    machine_mode *, int *, int *, int *,\n \t\t\t\t    tree *, tree *);\n static int simple_operand_p (const_tree);\n static bool simple_operand_p_2 (tree);\n@@ -3688,15 +3688,17 @@ distribute_real_division (location_t loc, enum tree_code code, tree type,\n }\n \f\n /* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER\n-   starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero.  */\n+   starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero\n+   and uses reverse storage order if REVERSEP is nonzero.  */\n \n static tree\n make_bit_field_ref (location_t loc, tree inner, tree type,\n-\t\t    HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos, int unsignedp)\n+\t\t    HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n+\t\t    int unsignedp, int reversep)\n {\n   tree result, bftype;\n \n-  if (bitpos == 0)\n+  if (bitpos == 0 && !reversep)\n     {\n       tree size = TYPE_SIZE (TREE_TYPE (inner));\n       if ((INTEGRAL_TYPE_P (TREE_TYPE (inner))\n@@ -3713,6 +3715,7 @@ make_bit_field_ref (location_t loc, tree inner, tree type,\n \n   result = build3_loc (loc, BIT_FIELD_REF, bftype, inner,\n \t\t       size_int (bitsize), bitsize_int (bitpos));\n+  REF_REVERSE_STORAGE_ORDER (result) = reversep;\n \n   if (bftype != type)\n     result = fold_convert_loc (loc, type, result);\n@@ -3750,6 +3753,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n   int const_p = TREE_CODE (rhs) == INTEGER_CST;\n   machine_mode lmode, rmode, nmode;\n   int lunsignedp, runsignedp;\n+  int lreversep, rreversep;\n   int lvolatilep = 0, rvolatilep = 0;\n   tree linner, rinner = NULL_TREE;\n   tree mask;\n@@ -3761,20 +3765,23 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n      do anything if the inner expression is a PLACEHOLDER_EXPR since we\n      then will no longer be able to replace it.  */\n   linner = get_inner_reference (lhs, &lbitsize, &lbitpos, &offset, &lmode,\n-\t\t\t\t&lunsignedp, &lvolatilep, false);\n+\t\t\t\t&lunsignedp, &lreversep, &lvolatilep, false);\n   if (linner == lhs || lbitsize == GET_MODE_BITSIZE (lmode) || lbitsize < 0\n       || offset != 0 || TREE_CODE (linner) == PLACEHOLDER_EXPR || lvolatilep)\n     return 0;\n \n- if (!const_p)\n+  if (const_p)\n+    rreversep = lreversep;\n+  else\n    {\n      /* If this is not a constant, we can only do something if bit positions,\n-\tsizes, and signedness are the same.  */\n-     rinner = get_inner_reference (rhs, &rbitsize, &rbitpos, &offset, &rmode,\n-\t\t\t\t   &runsignedp, &rvolatilep, false);\n+\tsizes, signedness and storage order are the same.  */\n+     rinner\n+       = get_inner_reference (rhs, &rbitsize, &rbitpos, &offset, &rmode,\n+\t\t\t      &runsignedp, &rreversep, &rvolatilep, false);\n \n      if (rinner == rhs || lbitpos != rbitpos || lbitsize != rbitsize\n-\t || lunsignedp != runsignedp || offset != 0\n+\t || lunsignedp != runsignedp || lreversep != rreversep || offset != 0\n \t || TREE_CODE (rinner) == PLACEHOLDER_EXPR || rvolatilep)\n        return 0;\n    }\n@@ -3802,7 +3809,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n   if (nbitsize == lbitsize)\n     return 0;\n \n-  if (BYTES_BIG_ENDIAN)\n+  if (lreversep ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n     lbitpos = nbitsize - lbitsize - lbitpos;\n \n   /* Make the mask to be used against the extracted field.  */\n@@ -3819,17 +3826,17 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n \t\t\t\t     make_bit_field_ref (loc, linner,\n \t\t\t\t\t\t\t unsigned_type,\n \t\t\t\t\t\t\t nbitsize, nbitpos,\n-\t\t\t\t\t\t\t 1),\n+\t\t\t\t\t\t\t 1, lreversep),\n \t\t\t\t     mask),\n \t\t\tfold_build2_loc (loc, BIT_AND_EXPR, unsigned_type,\n \t\t\t\t     make_bit_field_ref (loc, rinner,\n \t\t\t\t\t\t\t unsigned_type,\n \t\t\t\t\t\t\t nbitsize, nbitpos,\n-\t\t\t\t\t\t\t 1),\n+\t\t\t\t\t\t\t 1, rreversep),\n \t\t\t\t     mask));\n \n-  /* Otherwise, we are handling the constant case. See if the constant is too\n-     big for the field.  Warn and return a tree of for 0 (false) if so.  We do\n+  /* Otherwise, we are handling the constant case.  See if the constant is too\n+     big for the field.  Warn and return a tree for 0 (false) if so.  We do\n      this not only for its own sake, but to avoid having to test for this\n      error case below.  If we didn't, we might generate wrong code.\n \n@@ -3867,7 +3874,8 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n   /* Make a new bitfield reference, shift the constant over the\n      appropriate number of bits and mask it with the computed mask\n      (in case this was a signed field).  If we changed it, make a new one.  */\n-  lhs = make_bit_field_ref (loc, linner, unsigned_type, nbitsize, nbitpos, 1);\n+  lhs = make_bit_field_ref (loc, linner, unsigned_type, nbitsize, nbitpos, 1,\n+\t\t\t    lreversep);\n \n   rhs = const_binop (BIT_AND_EXPR,\n \t\t     const_binop (LSHIFT_EXPR,\n@@ -3895,6 +3903,8 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n \n    *PUNSIGNEDP is set to the signedness of the field.\n \n+   *PREVERSEP is set to the storage order of the field.\n+\n    *PMASK is set to the mask used.  This is either contained in a\n    BIT_AND_EXPR or derived from the width of the field.\n \n@@ -3906,7 +3916,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n static tree\n decode_field_reference (location_t loc, tree exp, HOST_WIDE_INT *pbitsize,\n \t\t\tHOST_WIDE_INT *pbitpos, machine_mode *pmode,\n-\t\t\tint *punsignedp, int *pvolatilep,\n+\t\t\tint *punsignedp, int *preversep, int *pvolatilep,\n \t\t\ttree *pmask, tree *pand_mask)\n {\n   tree outer_type = 0;\n@@ -3939,7 +3949,7 @@ decode_field_reference (location_t loc, tree exp, HOST_WIDE_INT *pbitsize,\n     }\n \n   inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,\n-\t\t\t       punsignedp, pvolatilep, false);\n+\t\t\t       punsignedp, preversep, pvolatilep, false);\n   if ((inner == exp && and_mask == 0)\n       || *pbitsize < 0 || offset != 0\n       || TREE_CODE (inner) == PLACEHOLDER_EXPR)\n@@ -5441,6 +5451,7 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n   HOST_WIDE_INT xll_bitpos, xlr_bitpos, xrl_bitpos, xrr_bitpos;\n   HOST_WIDE_INT lnbitsize, lnbitpos, rnbitsize, rnbitpos;\n   int ll_unsignedp, lr_unsignedp, rl_unsignedp, rr_unsignedp;\n+  int ll_reversep, lr_reversep, rl_reversep, rr_reversep;\n   machine_mode ll_mode, lr_mode, rl_mode, rr_mode;\n   machine_mode lnmode, rnmode;\n   tree ll_mask, lr_mask, rl_mask, rr_mask;\n@@ -5553,33 +5564,39 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n   volatilep = 0;\n   ll_inner = decode_field_reference (loc, ll_arg,\n \t\t\t\t     &ll_bitsize, &ll_bitpos, &ll_mode,\n-\t\t\t\t     &ll_unsignedp, &volatilep, &ll_mask,\n-\t\t\t\t     &ll_and_mask);\n+\t\t\t\t     &ll_unsignedp, &ll_reversep, &volatilep,\n+\t\t\t\t     &ll_mask, &ll_and_mask);\n   lr_inner = decode_field_reference (loc, lr_arg,\n \t\t\t\t     &lr_bitsize, &lr_bitpos, &lr_mode,\n-\t\t\t\t     &lr_unsignedp, &volatilep, &lr_mask,\n-\t\t\t\t     &lr_and_mask);\n+\t\t\t\t     &lr_unsignedp, &lr_reversep, &volatilep,\n+\t\t\t\t     &lr_mask, &lr_and_mask);\n   rl_inner = decode_field_reference (loc, rl_arg,\n \t\t\t\t     &rl_bitsize, &rl_bitpos, &rl_mode,\n-\t\t\t\t     &rl_unsignedp, &volatilep, &rl_mask,\n-\t\t\t\t     &rl_and_mask);\n+\t\t\t\t     &rl_unsignedp, &rl_reversep, &volatilep,\n+\t\t\t\t     &rl_mask, &rl_and_mask);\n   rr_inner = decode_field_reference (loc, rr_arg,\n \t\t\t\t     &rr_bitsize, &rr_bitpos, &rr_mode,\n-\t\t\t\t     &rr_unsignedp, &volatilep, &rr_mask,\n-\t\t\t\t     &rr_and_mask);\n+\t\t\t\t     &rr_unsignedp, &rr_reversep, &volatilep,\n+\t\t\t\t     &rr_mask, &rr_and_mask);\n \n   /* It must be true that the inner operation on the lhs of each\n      comparison must be the same if we are to be able to do anything.\n      Then see if we have constants.  If not, the same must be true for\n      the rhs's.  */\n-  if (volatilep || ll_inner == 0 || rl_inner == 0\n+  if (volatilep\n+      || ll_reversep != rl_reversep\n+      || ll_inner == 0 || rl_inner == 0\n       || ! operand_equal_p (ll_inner, rl_inner, 0))\n     return 0;\n \n   if (TREE_CODE (lr_arg) == INTEGER_CST\n       && TREE_CODE (rr_arg) == INTEGER_CST)\n-    l_const = lr_arg, r_const = rr_arg;\n-  else if (lr_inner == 0 || rr_inner == 0\n+    {\n+      l_const = lr_arg, r_const = rr_arg;\n+      lr_reversep = ll_reversep;\n+    }\n+  else if (lr_reversep != rr_reversep\n+\t   || lr_inner == 0 || rr_inner == 0\n \t   || ! operand_equal_p (lr_inner, rr_inner, 0))\n     return 0;\n   else\n@@ -5632,7 +5649,7 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n   lntype = lang_hooks.types.type_for_size (lnbitsize, 1);\n   xll_bitpos = ll_bitpos - lnbitpos, xrl_bitpos = rl_bitpos - lnbitpos;\n \n-  if (BYTES_BIG_ENDIAN)\n+  if (ll_reversep ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n     {\n       xll_bitpos = lnbitsize - xll_bitpos - ll_bitsize;\n       xrl_bitpos = lnbitsize - xrl_bitpos - rl_bitsize;\n@@ -5697,7 +5714,7 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n       rntype = lang_hooks.types.type_for_size (rnbitsize, 1);\n       xlr_bitpos = lr_bitpos - rnbitpos, xrr_bitpos = rr_bitpos - rnbitpos;\n \n-      if (BYTES_BIG_ENDIAN)\n+      if (lr_reversep ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n \t{\n \t  xlr_bitpos = rnbitsize - xlr_bitpos - lr_bitsize;\n \t  xrr_bitpos = rnbitsize - xrr_bitpos - rr_bitsize;\n@@ -5720,12 +5737,12 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n       if (lnbitsize == rnbitsize && xll_bitpos == xlr_bitpos)\n \t{\n \t  lhs = make_bit_field_ref (loc, ll_inner, lntype, lnbitsize, lnbitpos,\n-\t\t\t\t    ll_unsignedp || rl_unsignedp);\n+\t\t\t\t    ll_unsignedp || rl_unsignedp, ll_reversep);\n \t  if (! all_ones_mask_p (ll_mask, lnbitsize))\n \t    lhs = build2 (BIT_AND_EXPR, lntype, lhs, ll_mask);\n \n \t  rhs = make_bit_field_ref (loc, lr_inner, rntype, rnbitsize, rnbitpos,\n-\t\t\t\t    lr_unsignedp || rr_unsignedp);\n+\t\t\t\t    lr_unsignedp || rr_unsignedp, lr_reversep);\n \t  if (! all_ones_mask_p (lr_mask, rnbitsize))\n \t    rhs = build2 (BIT_AND_EXPR, rntype, rhs, lr_mask);\n \n@@ -5748,10 +5765,12 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n \n \t  lhs = make_bit_field_ref (loc, ll_inner, lntype,\n \t\t\t\t    ll_bitsize + rl_bitsize,\n-\t\t\t\t    MIN (ll_bitpos, rl_bitpos), ll_unsignedp);\n+\t\t\t\t    MIN (ll_bitpos, rl_bitpos),\n+\t\t\t\t    ll_unsignedp, ll_reversep);\n \t  rhs = make_bit_field_ref (loc, lr_inner, rntype,\n \t\t\t\t    lr_bitsize + rr_bitsize,\n-\t\t\t\t    MIN (lr_bitpos, rr_bitpos), lr_unsignedp);\n+\t\t\t\t    MIN (lr_bitpos, rr_bitpos),\n+\t\t\t\t    lr_unsignedp, lr_reversep);\n \n \t  ll_mask = const_binop (RSHIFT_EXPR, ll_mask,\n \t\t\t\t size_int (MIN (xll_bitpos, xrl_bitpos)));\n@@ -5814,7 +5833,7 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n      that field, perform the mask operation.  Then compare with the\n      merged constant.  */\n   result = make_bit_field_ref (loc, ll_inner, lntype, lnbitsize, lnbitpos,\n-\t\t\t       ll_unsignedp || rl_unsignedp);\n+\t\t\t       ll_unsignedp || rl_unsignedp, ll_reversep);\n \n   ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask);\n   if (! all_ones_mask_p (ll_mask, lnbitsize))\n@@ -7678,10 +7697,11 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t  HOST_WIDE_INT bitsize, bitpos;\n \t  tree offset;\n \t  machine_mode mode;\n-\t  int unsignedp, volatilep;\n-          tree base = TREE_OPERAND (op0, 0);\n-\t  base = get_inner_reference (base, &bitsize, &bitpos, &offset,\n-\t\t\t\t      &mode, &unsignedp, &volatilep, false);\n+\t  int unsignedp, reversep, volatilep;\n+\t  tree base\n+\t    = get_inner_reference (TREE_OPERAND (op0, 0), &bitsize, &bitpos,\n+\t\t\t\t   &offset, &mode, &unsignedp, &reversep,\n+\t\t\t\t   &volatilep, false);\n \t  /* If the reference was to a (constant) zero offset, we can use\n \t     the address of the base if it has the same base type\n \t     as the result type and the pointer type is unqualified.  */\n@@ -7817,8 +7837,12 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \n     case VIEW_CONVERT_EXPR:\n       if (TREE_CODE (op0) == MEM_REF)\n-\treturn fold_build2_loc (loc, MEM_REF, type,\n-\t\t\t\tTREE_OPERAND (op0, 0), TREE_OPERAND (op0, 1));\n+        {\n+\t  tem = fold_build2_loc (loc, MEM_REF, type,\n+\t\t\t\t TREE_OPERAND (op0, 0), TREE_OPERAND (op0, 1));\n+\t  REF_REVERSE_STORAGE_ORDER (tem) = REF_REVERSE_STORAGE_ORDER (op0);\n+\t  return tem;\n+\t}\n \n       return NULL_TREE;\n \n@@ -8335,7 +8359,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n       tree base0, base1, offset0 = NULL_TREE, offset1 = NULL_TREE;\n       HOST_WIDE_INT bitsize, bitpos0 = 0, bitpos1 = 0;\n       machine_mode mode;\n-      int volatilep, unsignedp;\n+      int volatilep, reversep, unsignedp;\n       bool indirect_base0 = false, indirect_base1 = false;\n \n       /* Get base and offset for the access.  Strip ADDR_EXPR for\n@@ -8345,9 +8369,10 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n       base0 = arg0;\n       if (TREE_CODE (arg0) == ADDR_EXPR)\n \t{\n-\t  base0 = get_inner_reference (TREE_OPERAND (arg0, 0),\n-\t\t\t\t       &bitsize, &bitpos0, &offset0, &mode,\n-\t\t\t\t       &unsignedp, &volatilep, false);\n+\t  base0\n+\t    = get_inner_reference (TREE_OPERAND (arg0, 0),\n+\t\t\t\t   &bitsize, &bitpos0, &offset0, &mode,\n+\t\t\t\t   &unsignedp, &reversep, &volatilep, false);\n \t  if (TREE_CODE (base0) == INDIRECT_REF)\n \t    base0 = TREE_OPERAND (base0, 0);\n \t  else\n@@ -8379,9 +8404,10 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n       base1 = arg1;\n       if (TREE_CODE (arg1) == ADDR_EXPR)\n \t{\n-\t  base1 = get_inner_reference (TREE_OPERAND (arg1, 0),\n-\t\t\t\t       &bitsize, &bitpos1, &offset1, &mode,\n-\t\t\t\t       &unsignedp, &volatilep, false);\n+\t  base1\n+\t    = get_inner_reference (TREE_OPERAND (arg1, 0),\n+\t\t\t\t   &bitsize, &bitpos1, &offset1, &mode,\n+\t\t\t\t   &unsignedp, &reversep, &volatilep, false);\n \t  if (TREE_CODE (base1) == INDIRECT_REF)\n \t    base1 = TREE_OPERAND (base1, 0);\n \t  else\n@@ -14311,15 +14337,15 @@ split_address_to_core_and_offset (tree exp,\n {\n   tree core;\n   machine_mode mode;\n-  int unsignedp, volatilep;\n+  int unsignedp, reversep, volatilep;\n   HOST_WIDE_INT bitsize;\n   location_t loc = EXPR_LOCATION (exp);\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n     {\n       core = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, pbitpos,\n-\t\t\t\t  poffset, &mode, &unsignedp, &volatilep,\n-\t\t\t\t  false);\n+\t\t\t\t  poffset, &mode, &unsignedp, &reversep,\n+\t\t\t\t  &volatilep, false);\n       core = build_fold_addr_expr_loc (loc, core);\n     }\n   else"}, {"sha": "e9c631d884d7faecebd63cefe4baa44ae19d72d5", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -152,14 +152,16 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   else if (TREE_CODE (inner_type) == ARRAY_TYPE\n \t   && TREE_CODE (outer_type) == ARRAY_TYPE)\n     {\n-      /* Preserve string attributes.  */\n+      /* Preserve various attributes.  */\n+      if (TYPE_REVERSE_STORAGE_ORDER (inner_type)\n+\t  != TYPE_REVERSE_STORAGE_ORDER (outer_type))\n+\treturn false;\n       if (TYPE_STRING_FLAG (inner_type) != TYPE_STRING_FLAG (outer_type))\n \treturn false;\n \n       /* Conversions from array types with unknown extent to\n \t array types with known extent are not useless.  */\n-      if (!TYPE_DOMAIN (inner_type)\n-\t  && TYPE_DOMAIN (outer_type))\n+      if (!TYPE_DOMAIN (inner_type) && TYPE_DOMAIN (outer_type))\n \treturn false;\n \n       /* Nor are conversions from array types with non-constant size to"}, {"sha": "fc095eb5bfcf4c7ae370732e578048573900864c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -782,13 +782,14 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t      HOST_WIDE_INT src_offset = 0, dest_offset = 0;\n \t      HOST_WIDE_INT size = -1;\n \t      HOST_WIDE_INT maxsize = -1;\n+\t      bool reverse;\n \n \t      srcvar = TREE_OPERAND (src, 0);\n \t      src_base = get_ref_base_and_extent (srcvar, &src_offset,\n-\t\t\t\t\t\t  &size, &maxsize);\n+\t\t\t\t\t\t  &size, &maxsize, &reverse);\n \t      destvar = TREE_OPERAND (dest, 0);\n \t      dest_base = get_ref_base_and_extent (destvar, &dest_offset,\n-\t\t\t\t\t\t   &size, &maxsize);\n+\t\t\t\t\t\t   &size, &maxsize, &reverse);\n \t      if (tree_fits_uhwi_p (len))\n \t\tmaxsize = tree_to_uhwi (len);\n \t      else\n@@ -5264,6 +5265,8 @@ get_base_constructor (tree base, HOST_WIDE_INT *bit_offset,\n \t\t      tree (*valueize)(tree))\n {\n   HOST_WIDE_INT bit_offset2, size, max_size;\n+  bool reverse;\n+\n   if (TREE_CODE (base) == MEM_REF)\n     {\n       if (!integer_zerop (TREE_OPERAND (base, 1)))\n@@ -5304,7 +5307,8 @@ get_base_constructor (tree base, HOST_WIDE_INT *bit_offset,\n \n     case ARRAY_REF:\n     case COMPONENT_REF:\n-      base = get_ref_base_and_extent (base, &bit_offset2, &size, &max_size);\n+      base = get_ref_base_and_extent (base, &bit_offset2, &size, &max_size,\n+\t\t\t\t      &reverse);\n       if (max_size == -1 || size != max_size)\n \treturn NULL_TREE;\n       *bit_offset +=  bit_offset2;\n@@ -5507,6 +5511,7 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n   tree ctor, idx, base;\n   HOST_WIDE_INT offset, size, max_size;\n   tree tem;\n+  bool reverse;\n \n   if (TREE_THIS_VOLATILE (t))\n     return NULL_TREE;\n@@ -5577,7 +5582,7 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n     case BIT_FIELD_REF:\n     case TARGET_MEM_REF:\n     case MEM_REF:\n-      base = get_ref_base_and_extent (t, &offset, &size, &max_size);\n+      base = get_ref_base_and_extent (t, &offset, &size, &max_size, &reverse);\n       ctor = get_base_constructor (base, &offset, valueize);\n \n       /* Empty constructor.  Always fold to 0.  */"}, {"sha": "c2826dff419223347cb32159a681c2c51700c47f", "filename": "gcc/gimple-laddress.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-laddress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-laddress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-laddress.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -102,10 +102,10 @@ pass_laddress::execute (function *fun)\n \t  HOST_WIDE_INT bitsize, bitpos;\n \t  tree base, offset;\n \t  machine_mode mode;\n-\t  int volatilep = 0, unsignedp = 0;\n+\t  int volatilep = 0, reversep, unsignedp = 0;\n \t  base = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize,\n \t\t\t\t      &bitpos, &offset, &mode, &unsignedp,\n-\t\t\t\t      &volatilep, false);\n+\t\t\t\t      &reversep, &volatilep, false);\n \t  gcc_assert (base != NULL_TREE && (bitpos % BITS_PER_UNIT) == 0);\n \t  if (offset != NULL_TREE)\n \t    {"}, {"sha": "ce32ad33e94bff884c17f3772415bae5f531c99d", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -972,7 +972,7 @@ slsr_process_ref (gimple *gs)\n   tree ref_expr, base, offset, type;\n   HOST_WIDE_INT bitsize, bitpos;\n   machine_mode mode;\n-  int unsignedp, volatilep;\n+  int unsignedp, reversep, volatilep;\n   slsr_cand_t c;\n \n   if (gimple_vdef (gs))\n@@ -987,7 +987,9 @@ slsr_process_ref (gimple *gs)\n     return;\n \n   base = get_inner_reference (ref_expr, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t      &unsignedp, &volatilep, false);\n+\t\t\t      &unsignedp, &reversep, &volatilep, false);\n+  if (reversep)\n+    return;\n   widest_int index = bitpos;\n \n   if (!restructure_reference (&base, &offset, &index, &type))"}, {"sha": "287e51e201657e4b5d0b806388d8638ec6da5569", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -6613,14 +6613,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  tree offset;\n \t\t  HOST_WIDE_INT bitsize, bitpos;\n \t\t  machine_mode mode;\n-\t\t  int unsignedp, volatilep = 0;\n+\t\t  int unsignedp, reversep, volatilep = 0;\n \t\t  tree base = OMP_CLAUSE_DECL (c);\n \t\t  while (TREE_CODE (base) == ARRAY_REF)\n \t\t    base = TREE_OPERAND (base, 0);\n \t\t  if (TREE_CODE (base) == INDIRECT_REF)\n \t\t    base = TREE_OPERAND (base, 0);\n \t\t  base = get_inner_reference (base, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t      &mode, &unsignedp,\n+\t\t\t\t\t      &mode, &unsignedp, &reversep,\n \t\t\t\t\t      &volatilep, false);\n \t\t  gcc_assert (base == decl\n \t\t\t      && (offset == NULL_TREE\n@@ -6730,7 +6730,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t    base = get_inner_reference (base, &bitsize2,\n \t\t\t\t\t\t\t&bitpos2, &offset2,\n \t\t\t\t\t\t\t&mode, &unsignedp,\n-\t\t\t\t\t\t\t&volatilep, false);\n+\t\t\t\t\t\t\t&reversep, &volatilep,\n+\t\t\t\t\t\t\tfalse);\n \t\t\t    if (base != decl)\n \t\t\t      break;\n \t\t\t    if (scp)\n@@ -9734,6 +9735,8 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t\t     TREE_OPERAND (*expr_p, 1));\n \t  if (tmp)\n \t    {\n+\t      REF_REVERSE_STORAGE_ORDER (tmp)\n+\t        = REF_REVERSE_STORAGE_ORDER (*expr_p);\n \t      *expr_p = tmp;\n \t      recalculate_side_effects (*expr_p);\n \t      ret = GS_OK;"}, {"sha": "fff62de02a03d65fe9378e0d98950eb9813a613c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -942,7 +942,7 @@ noce_emit_move_insn (rtx x, rtx y)\n \t\t}\n \n \t      gcc_assert (start < (MEM_P (op) ? BITS_PER_UNIT : BITS_PER_WORD));\n-\t      store_bit_field (op, size, start, 0, 0, GET_MODE (x), y);\n+\t      store_bit_field (op, size, start, 0, 0, GET_MODE (x), y, false);\n \t      return;\n \t    }\n \n@@ -997,7 +997,7 @@ noce_emit_move_insn (rtx x, rtx y)\n   outmode = GET_MODE (outer);\n   bitpos = SUBREG_BYTE (outer) * BITS_PER_UNIT;\n   store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos,\n-\t\t   0, 0, outmode, y);\n+\t\t   0, 0, outmode, y, false);\n }\n \n /* Return the CC reg if it is used in COND.  */"}, {"sha": "6ba2f1493f8610d03d2973cb5aaacadec21e2379", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1055,7 +1055,7 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n     {\n       tree t = TREE_OPERAND (input, 0);\n       t = build_ref_for_offset (EXPR_LOCATION (t), t,\n-\t\t\t\tipa_get_jf_ancestor_offset (jfunc),\n+\t\t\t\tipa_get_jf_ancestor_offset (jfunc), false,\n \t\t\t\tptr_type_node, NULL, false);\n       return build_fold_addr_expr (t);\n     }"}, {"sha": "a577ffab68dff59f815cefd80e7d1addf5fdb1a0", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -749,6 +749,7 @@ ipa_polymorphic_call_context::set_by_invariant (tree cst,\n \t\t\t\t\t\tHOST_WIDE_INT off)\n {\n   HOST_WIDE_INT offset2, size, max_size;\n+  bool reverse;\n   tree base;\n \n   invalid = false;\n@@ -759,7 +760,7 @@ ipa_polymorphic_call_context::set_by_invariant (tree cst,\n     return false;\n \n   cst = TREE_OPERAND (cst, 0);\n-  base = get_ref_base_and_extent (cst, &offset2, &size, &max_size);\n+  base = get_ref_base_and_extent (cst, &offset2, &size, &max_size, &reverse);\n   if (!DECL_P (base) || max_size == -1 || max_size != size)\n     return false;\n \n@@ -889,8 +890,10 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t{\n \t  HOST_WIDE_INT size, max_size;\n \t  HOST_WIDE_INT offset2;\n-\t  tree base = get_ref_base_and_extent (TREE_OPERAND (base_pointer, 0),\n-\t\t\t\t\t       &offset2, &size, &max_size);\n+\t  bool reverse;\n+\t  tree base\n+\t    = get_ref_base_and_extent (TREE_OPERAND (base_pointer, 0),\n+\t\t\t\t       &offset2, &size, &max_size, &reverse);\n \n \t  if (max_size != -1 && max_size == size)\n \t    combine_speculation_with (TYPE_MAIN_VARIANT (TREE_TYPE (base)),\n@@ -1158,6 +1161,7 @@ extr_type_from_vtbl_ptr_store (gimple *stmt, struct type_change_info *tci,\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree lhs, rhs, base;\n+  bool reverse;\n \n   if (!gimple_assign_single_p (stmt))\n     return NULL_TREE;\n@@ -1176,7 +1180,7 @@ extr_type_from_vtbl_ptr_store (gimple *stmt, struct type_change_info *tci,\n     ;\n   else\n     {\n-      base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n+      base = get_ref_base_and_extent (lhs, &offset, &size, &max_size, &reverse);\n       if (DECL_P (tci->instance))\n \t{\n \t  if (base != tci->instance)\n@@ -1365,6 +1369,7 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \ttree op = walk_ssa_copies (gimple_call_arg (stmt, 0));\n \ttree type = TYPE_METHOD_BASETYPE (TREE_TYPE (fn));\n \tHOST_WIDE_INT offset = 0, size, max_size;\n+\tbool reverse;\n \n \tif (dump_file)\n \t  {\n@@ -1375,8 +1380,8 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \t/* See if THIS parameter seems like instance pointer.  */\n \tif (TREE_CODE (op) == ADDR_EXPR)\n \t  {\n-\t    op = get_ref_base_and_extent (TREE_OPERAND (op, 0),\n-\t\t\t\t\t  &offset, &size, &max_size);\n+\t    op = get_ref_base_and_extent (TREE_OPERAND (op, 0), &offset,\n+\t\t\t\t\t  &size, &max_size, &reverse);\n \t    if (size != max_size || max_size == -1)\n \t      {\n                 tci->speculative = true;\n@@ -1534,6 +1539,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n     {\n       tree ref = gimple_call_fn (call);\n       HOST_WIDE_INT offset2, size, max_size;\n+      bool reverse;\n \n       if (TREE_CODE (ref) == OBJ_TYPE_REF)\n \t{\n@@ -1563,8 +1569,9 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \t\t  && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref)))\n \t\t{\n \t\t  tree ref_exp = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (ref));\n-\t\t  tree base_ref = get_ref_base_and_extent\n-\t\t\t\t   (ref_exp, &offset2, &size, &max_size);\n+\t\t  tree base_ref\n+\t\t    = get_ref_base_and_extent (ref_exp, &offset2, &size,\n+\t\t\t\t\t       &max_size, &reverse);\n \n \t\t  /* Finally verify that what we found looks like read from\n \t\t     OTR_OBJECT or from INSTANCE with offset OFFSET.  */"}, {"sha": "d15f0ebed5679e0de734a469f8b76d56799773fa", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -952,7 +952,9 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n {\n   int index;\n   HOST_WIDE_INT size, max_size;\n-  tree base = get_ref_base_and_extent (op, offset_p, &size, &max_size);\n+  bool reverse;\n+  tree base\n+    = get_ref_base_and_extent (op, offset_p, &size, &max_size, &reverse);\n \n   if (max_size == -1 || max_size != size || *offset_p < 0)\n     return false;\n@@ -1077,6 +1079,7 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree op1, tc_ssa, base, ssa;\n+  bool reverse;\n   int index;\n \n   op1 = gimple_assign_rhs1 (stmt);\n@@ -1124,7 +1127,7 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n   op1 = TREE_OPERAND (op1, 0);\n   if (TREE_CODE (TREE_TYPE (op1)) != RECORD_TYPE)\n     return;\n-  base = get_ref_base_and_extent (op1, &offset, &size, &max_size);\n+  base = get_ref_base_and_extent (op1, &offset, &size, &max_size, &reverse);\n   if (TREE_CODE (base) != MEM_REF\n       /* If this is a varying address, punt.  */\n       || max_size == -1\n@@ -1160,6 +1163,7 @@ get_ancestor_addr_info (gimple *assign, tree *obj_p, HOST_WIDE_INT *offset)\n {\n   HOST_WIDE_INT size, max_size;\n   tree expr, parm, obj;\n+  bool reverse;\n \n   if (!gimple_assign_single_p (assign))\n     return NULL_TREE;\n@@ -1169,7 +1173,7 @@ get_ancestor_addr_info (gimple *assign, tree *obj_p, HOST_WIDE_INT *offset)\n     return NULL_TREE;\n   expr = TREE_OPERAND (expr, 0);\n   obj = expr;\n-  expr = get_ref_base_and_extent (expr, offset, &size, &max_size);\n+  expr = get_ref_base_and_extent (expr, offset, &size, &max_size, &reverse);\n \n   if (TREE_CODE (expr) != MEM_REF\n       /* If this is a varying address, punt.  */\n@@ -1435,10 +1439,11 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n       else if (TREE_CODE (arg) == ADDR_EXPR)\n \t{\n \t  HOST_WIDE_INT arg_max_size;\n+\t  bool reverse;\n \n \t  arg = TREE_OPERAND (arg, 0);\n \t  arg_base = get_ref_base_and_extent (arg, &arg_offset, &arg_size,\n-\t\t\t\t\t  &arg_max_size);\n+\t\t\t\t\t      &arg_max_size, &reverse);\n \t  if (arg_max_size == -1\n \t      || arg_max_size != arg_size\n \t      || arg_offset < 0)\n@@ -1457,13 +1462,14 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n   else\n     {\n       HOST_WIDE_INT arg_max_size;\n+      bool reverse;\n \n       gcc_checking_assert (AGGREGATE_TYPE_P (TREE_TYPE (arg)));\n \n       by_ref = false;\n       check_ref = false;\n       arg_base = get_ref_base_and_extent (arg, &arg_offset, &arg_size,\n-\t\t\t\t\t  &arg_max_size);\n+\t\t\t\t\t  &arg_max_size, &reverse);\n       if (arg_max_size == -1\n \t  || arg_max_size != arg_size\n \t  || arg_offset < 0)\n@@ -1484,6 +1490,7 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n       gimple *stmt = gsi_stmt (gsi);\n       HOST_WIDE_INT lhs_offset, lhs_size, lhs_max_size;\n       tree lhs, rhs, lhs_base;\n+      bool reverse;\n \n       if (!stmt_may_clobber_ref_p_1 (stmt, &r))\n \tcontinue;\n@@ -1498,7 +1505,7 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n \tbreak;\n \n       lhs_base = get_ref_base_and_extent (lhs, &lhs_offset, &lhs_size,\n-\t\t\t\t\t  &lhs_max_size);\n+\t\t\t\t\t  &lhs_max_size, &reverse);\n       if (lhs_max_size == -1\n \t  || lhs_max_size != lhs_size)\n \tbreak;\n@@ -3968,6 +3975,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t      base = force_gimple_operand_gsi (&gsi, base,\n \t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n \t      expr = fold_build2_loc (loc, MEM_REF, type, base, off);\n+\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n \t      /* If expr is not a valid gimple call argument emit\n \t         a load into a temporary.  */\n \t      if (is_gimple_reg_type (TREE_TYPE (expr)))\n@@ -3987,6 +3995,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t  else\n \t    {\n \t      expr = fold_build2_loc (loc, MEM_REF, adj->type, base, off);\n+\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n \t      expr = build_fold_addr_expr (expr);\n \t      expr = force_gimple_operand_gsi (&gsi, expr,\n \t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n@@ -4091,7 +4100,10 @@ ipa_modify_expr (tree *expr, bool convert,\n \n   tree src;\n   if (cand->by_ref)\n-    src = build_simple_mem_ref (cand->new_decl);\n+    {\n+      src = build_simple_mem_ref (cand->new_decl);\n+      REF_REVERSE_STORAGE_ORDER (src) = cand->reverse;\n+    }\n   else\n     src = cand->new_decl;\n \n@@ -4158,7 +4170,9 @@ ipa_get_adjustment_candidate (tree **expr, bool *convert,\n     }\n \n   HOST_WIDE_INT offset, size, max_size;\n-  tree base = get_ref_base_and_extent (**expr, &offset, &size, &max_size);\n+  bool reverse;\n+  tree base\n+    = get_ref_base_and_extent (**expr, &offset, &size, &max_size, &reverse);\n   if (!base || size == -1 || max_size == -1)\n     return NULL;\n "}, {"sha": "b69ee8ab7459e11a6ceeb51dc9ef1a8158cead3d", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -737,6 +737,10 @@ struct ipa_parm_adjustment\n      or one about to be removed.  */\n   enum ipa_parm_op op;\n \n+  /* Storage order of the original parameter (for the cases when the new\n+     parameter is a component of an original one).  */\n+  unsigned reverse : 1;\n+\n   /* The parameter is to be passed by reference.  */\n   unsigned by_ref : 1;\n };\n@@ -774,7 +778,7 @@ ipa_parm_adjustment *ipa_get_adjustment_candidate (tree **, bool *,\n \n \n /* From tree-sra.c:  */\n-tree build_ref_for_offset (location_t, tree, HOST_WIDE_INT, tree,\n+tree build_ref_for_offset (location_t, tree, HOST_WIDE_INT, bool, tree,\n \t\t\t   gimple_stmt_iterator *, bool);\n \n /* In ipa-cp.c  */"}, {"sha": "3e087d1e124a34e1bd46f5c0d861d17de328f3e2", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -958,7 +958,8 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n     hstate.add_flag (TREE_PRIVATE (t));\n   if (TYPE_P (t))\n     {\n-      hstate.add_flag (TYPE_SATURATING (t));\n+      hstate.add_flag (AGGREGATE_TYPE_P (t)\n+\t\t       ? TYPE_REVERSE_STORAGE_ORDER (t) : TYPE_SATURATING (t));\n       hstate.add_flag (TYPE_ADDR_SPACE (t));\n     }\n   else if (code == SSA_NAME)"}, {"sha": "d254bee4685a71edab04d514111c0630686ebc50", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1,3 +1,7 @@\n+2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* lto.c (compare_tree_sccs_1): Deal with TYPE_REVERSE_STORAGE_ORDER.\n+\n 2015-11-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* lto-lang.c: Don't undef DEF_BUILTIN."}, {"sha": "5dcc4dcd851a25b3d89aae574eeba020b61629f7", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1021,7 +1021,10 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n   compare_values (TREE_DEPRECATED);\n   if (TYPE_P (t1))\n     {\n-      compare_values (TYPE_SATURATING);\n+      if (AGGREGATE_TYPE_P (t1))\n+\tcompare_values (TYPE_REVERSE_STORAGE_ORDER);\n+      else\n+\tcompare_values (TYPE_SATURATING);\n       compare_values (TYPE_ADDR_SPACE);\n     }\n   else if (code == SSA_NAME)"}, {"sha": "f9ff85886dbb9752de3125ef47db6be4e6ee30fb", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -278,10 +278,11 @@ extern section *get_named_text_section (tree, const char *, const char *);\n #define assemble_aligned_integer(SIZE, VALUE) \\\n   assemble_integer (VALUE, SIZE, (SIZE) * BITS_PER_UNIT, 1)\n \n-#ifdef REAL_VALUE_TYPE_SIZE\n-/* Assemble the floating-point constant D into an object of size MODE.  */\n-extern void assemble_real (REAL_VALUE_TYPE, machine_mode, unsigned);\n-#endif\n+/* Assemble the floating-point constant D into an object of size MODE.  ALIGN\n+   is the alignment of the constant in bits.  If REVERSE is true, D is output\n+   in reverse storage order.  */\n+extern void assemble_real (REAL_VALUE_TYPE, machine_mode, unsigned,\n+\t\t\t   bool = false);\n \n /* Write the address of the entity given by SYMBOL to SEC.  */\n extern void assemble_addr_to_section (rtx, section *);"}, {"sha": "1b584b87ea0ae64b8da87a6fd807cd34009a7616", "filename": "gcc/print-tree.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -565,6 +565,13 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (TYPE_NEEDS_CONSTRUCTING (node))\n \tfputs (\" needs-constructing\", file);\n \n+      if ((code == RECORD_TYPE\n+\t   || code == UNION_TYPE\n+\t   || code == QUAL_UNION_TYPE\n+\t   || code == ARRAY_TYPE)\n+\t  && TYPE_REVERSE_STORAGE_ORDER (node))\n+\tfputs (\" reverse-storage-order\", file);\n+\n       /* The transparent-union flag is used for different things in\n \t different nodes.  */\n       if ((code == UNION_TYPE || code == RECORD_TYPE)"}, {"sha": "17568baa8b05fb9059af6250dec45580de5debfd", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -301,10 +301,11 @@ delegitimize_mem_from_attrs (rtx x)\n \t  {\n \t    HOST_WIDE_INT bitsize, bitpos;\n \t    tree toffset;\n-\t    int unsignedp, volatilep = 0;\n+\t    int unsignedp, reversep, volatilep = 0;\n \n-\t    decl = get_inner_reference (decl, &bitsize, &bitpos, &toffset,\n-\t\t\t\t\t&mode, &unsignedp, &volatilep, false);\n+\t    decl\n+\t      = get_inner_reference (decl, &bitsize, &bitpos, &toffset, &mode,\n+\t\t\t\t     &unsignedp, &reversep, &volatilep, false);\n \t    if (bitsize != GET_MODE_BITSIZE (mode)\n \t\t|| (bitpos % BITS_PER_UNIT)\n \t\t|| (toffset && !tree_fits_shwi_p (toffset)))"}, {"sha": "fac38951b341070e0518d262363a88a5b1c14957", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -2035,11 +2035,16 @@ finish_record_layout (record_layout_info rli, int free_p)\n   /* Compute bitfield representatives.  */\n   finish_bitfield_layout (rli->t);\n \n-  /* Propagate TYPE_PACKED to variants.  With C++ templates,\n-     handle_packed_attribute is too early to do this.  */\n+  /* Propagate TYPE_PACKED and TYPE_REVERSE_STORAGE_ORDER to variants.\n+     With C++ templates, it is too early to do this when the attribute\n+     is being parsed.  */\n   for (variant = TYPE_NEXT_VARIANT (rli->t); variant;\n        variant = TYPE_NEXT_VARIANT (variant))\n-    TYPE_PACKED (variant) = TYPE_PACKED (rli->t);\n+    {\n+      TYPE_PACKED (variant) = TYPE_PACKED (rli->t);\n+      TYPE_REVERSE_STORAGE_ORDER (variant)\n+\t= TYPE_REVERSE_STORAGE_ORDER (rli->t);\n+    }\n \n   /* Lay out any static members.  This is done now because their type\n      may use the record's type.  */"}, {"sha": "816fc94630505f0e395c7edff8e0147bcacb6444", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1,3 +1,26 @@\n+2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/sso-1.c: New test.\n+\t* gcc.dg/sso-2.c: Likewise.\n+\t* gcc.dg/sso-3.c: Likewise.\n+\t* gcc.dg/sso-4.c: Likewise.\n+\t* gcc.dg/sso-5.c: Likewise.\n+\t* gcc.dg/sso-6.c: Likewise.\n+\t* gcc.dg/sso-7.c: Likewise.\n+\t* gcc.dg/sso-8.c: Likewise.\n+\t* gcc.dg/sso: New directory.\n+\t* gcc.target/i386/movbe-3.c: New test.\n+\t* gnat.dg/sso1.adb: Likewise.\n+\t* gnat.dg/sso2.ad[sb]: Likewise.\n+\t* gnat.dg/sso3.adb: Likewise.\n+\t* gnat.dg/sso4.adb: Likewise.\n+\t* gnat.dg/sso5.adb: Likewise.\n+\t* gnat.dg/sso6.adb: Likewise.\n+\t* gnat.dg/sso7.adb: Likewise.\n+\t* gnat.dg/specs/sso1.ads: Likewise.\n+\t* gnat.dg/specs/sso2.ads: Likewise.\n+\t* gnat.dg/sso: New directory.\n+\n 2015-11-08  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/68218"}, {"sha": "b2e11bd00d31c0e04c594632221748fddf073657", "filename": "gcc/testsuite/gcc.dg/sso-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-1.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,19 @@\n+/* Test support of scalar_storage_order attribute */\n+\n+/* { dg-do compile } */\n+\n+int i;\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) Rec\n+{\n+  int *p;\n+};\n+#else\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) Rec\n+{\n+  int *p;\n+};\n+#endif\n+\n+struct Rec r = { &i };  /* { dg-error \"element is not constant\" } */"}, {"sha": "0f7218c8012d92dc29c3b64ed1a35572cb68d107", "filename": "gcc/testsuite/gcc.dg/sso-2.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-2.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,94 @@\n+/* Test support of scalar_storage_order attribute */\n+\n+/* { dg-do compile } */\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) S1\n+{\n+  int i;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) S2\n+{\n+  int i;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"other\"))) S3 { int i; }; /* { dg-error \"must be one of .big-endian. or .little-endian.\" } */\n+\n+void incompatible_assign (struct S1 *s1, struct S2 *s2)\n+{\n+  *s1 = *s2; /* { dg-error \"(incompatible types|no match)\" } */\n+}\n+\n+int *addr1 (int which, struct S1 *s1, struct S2 *s2)\n+{\n+  return (which == 1 ? &s1->i : &s2->i); /* { dg-error \"address of scalar with reverse storage order\" } */\n+}\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) S4\n+{\n+  int a[4];\n+  struct S2 s2;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) S5\n+{\n+  int a[4];\n+  struct S1 s1;\n+};\n+\n+void *addr2 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)s4->a : (void *)s5->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr3 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)&s4->a : (void *)&s5->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr4 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)&s4->a[0] : (void *)&s5->a[0]); /* { dg-error \"address of scalar with reverse storage order\" } */\n+}\n+\n+void *addr5 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)&s4->s2 : (void *) &s5->s1); /* ok */\n+}\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) S6\n+{\n+  int a[4][2];\n+  struct S2 s2[2];\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) S7\n+{\n+  int a[4][2];\n+  struct S1 s1[2];\n+};\n+\n+void *addr6 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)s6->a : (void *)s7->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr7 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->a : (void *)&s7->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr8 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->a[0] : (void *)&s7->a[0]); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr9 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->a[0][0] : (void *)&s7->a[0][0]); /* { dg-error \"address of scalar with reverse storage order\" } */\n+}\n+\n+void *addr10 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->s2 : (void *)&s7->s1); /* ok */\n+}"}, {"sha": "c7877e8fafa15d9b0324c751a747f0cc275d0c84", "filename": "gcc/testsuite/gcc.dg/sso-3.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-3.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,94 @@\n+/* Test support of scalar_storage_order attribute */\n+\n+/* { dg-do compile } */\n+\n+struct S1\n+{\n+  int i;\n+} __attribute__((scalar_storage_order(\"big-endian\")));\n+\n+struct S2\n+{\n+  int i;\n+} __attribute__((scalar_storage_order(\"little-endian\")));\n+\n+struct S3 { int i; } __attribute__((scalar_storage_order(\"other\"))); /* { dg-error \"must be one of .big-endian. or .little-endian.\" } */\n+\n+void incompatible_assign (struct S1 *s1, struct S2 *s2)\n+{\n+  *s1 = *s2; /* { dg-error \"(incompatible types|no match)\" } */\n+}\n+\n+int *addr1 (int which, struct S1 *s1, struct S2 *s2)\n+{\n+  return (which == 1 ? &s1->i : &s2->i); /* { dg-error \"address of scalar with reverse storage order\" } */\n+}\n+\n+struct S4\n+{\n+  int a[4];\n+  struct S2 s2;\n+} __attribute__((scalar_storage_order(\"big-endian\")));\n+\n+struct S5\n+{\n+  int a[4];\n+  struct S1 s1;\n+} __attribute__((scalar_storage_order(\"little-endian\")));\n+\n+void *addr2 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)s4->a : (void *)s5->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr3 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)&s4->a : (void *)&s5->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr4 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)&s4->a[0] : (void *)&s5->a[0]); /* { dg-error \"address of scalar with reverse storage order\" } */\n+}\n+\n+void *addr5 (int which, struct S4 *s4, struct S5 *s5)\n+{\n+  return (which == 1 ? (void *)&s4->s2 : (void *) &s5->s1); /* ok */\n+}\n+\n+struct S6\n+{\n+  int a[4][2];\n+  struct S2 s2[2];\n+}  __attribute__((scalar_storage_order(\"big-endian\")));\n+\n+struct S7\n+{\n+  int a[4][2];\n+  struct S1 s1[2];\n+}  __attribute__((scalar_storage_order(\"little-endian\")));\n+\n+void *addr6 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)s6->a : (void *)s7->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr7 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->a : (void *)&s7->a); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr8 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->a[0] : (void *)&s7->a[0]); /* { dg-warning \"address of array with reverse scalar storage order\" } */\n+}\n+\n+void *addr9 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->a[0][0] : (void *)&s7->a[0][0]); /* { dg-error \"address of scalar with reverse storage order\" } */\n+}\n+\n+void *addr10 (int which, struct S6 *s6, struct S7 *s7)\n+{\n+  return (which == 1 ? (void *)&s6->s2 : (void *)&s7->s1); /* ok */\n+}"}, {"sha": "9eda11a46026a18fc0c236a5f39a826f0b55192b", "filename": "gcc/testsuite/gcc.dg/sso-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-4.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,20 @@\n+/* Test support of scalar_storage_order attribute */\n+\n+/* { dg-do compile } */\n+\n+struct S\n+{\n+  int i;\n+};\n+\n+typedef struct S __attribute__((scalar_storage_order(\"big-endian\"))) S1;\n+\n+typedef struct S __attribute__((scalar_storage_order(\"little-endian\"))) S2;\n+\n+typedef struct S __attribute__((scalar_storage_order(\"other\"))) S3; /* { dg-error \"must be one of .big-endian. or .little-endian.\" } */\n+\n+void incompatible_assign (struct S *s, S1 *s1, S2 *s2)\n+{\n+  *s = *s1, *s = *s2; /* { dg-error \"(incompatible types|no match)\" } */\n+  *s1 = *s2; /* { dg-error \"(incompatible types|no match)\" } */\n+}"}, {"sha": "8bbb38bf54b6995ece9cb3130e4a20fd4bfbcffa", "filename": "gcc/testsuite/gcc.dg/sso-5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-5.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,24 @@\n+/* Test support of scalar_storage_order attribute */\n+\n+/* { dg-do compile } */\n+\n+struct S3\n+{\n+  struct __attribute__((scalar_storage_order(\"big-endian\"))) S1\n+  {\n+    int i;\n+  } s1;\n+};\n+\n+struct S4\n+{\n+  struct __attribute__((scalar_storage_order(\"little-endian\"))) S2\n+  {\n+    int i;\n+  } s2;\n+};\n+\n+void incompatible_assign (struct S3 *s3, struct S4 *s4)\n+{\n+  s3->s1 = s4->s2; /* { dg-error \"(incompatible types|no match)\" } */\n+}"}, {"sha": "48759b41e528aaab3b8dbe9229e207e4d68f1a8a", "filename": "gcc/testsuite/gcc.dg/sso-6.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-6.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,72 @@\n+/* Test support of scalar_storage_order pragma */\n+\n+/* { dg-do run } */\n+\n+#pragma scalar_storage_order /* { dg-warning \"missing .big-endian.little-endian.default.\" } */\n+\n+#pragma scalar_storage_order big-endian\n+\n+struct S1\n+{\n+  int i;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) S2\n+{\n+  int i;\n+};\n+\n+#pragma scalar_storage_order little-endian\n+\n+struct S3\n+{\n+  int i;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) S4\n+{\n+  int i;\n+};\n+\n+#pragma scalar_storage_order default\n+\n+struct S5\n+{\n+  int i;\n+};\n+\n+#pragma scalar_storage_order other /* { dg-warning \"expected .big-endian.little-endian.default.\" } */\n+\n+struct S1 my_s1 = { 0x12345678 };\n+struct S2 my_s2 = { 0x12345678 };\n+struct S3 my_s3 = { 0x12345678 };\n+struct S4 my_s4 = { 0x12345678 };\n+struct S5 my_s5 = { 0x12345678 };\n+\n+unsigned char big_endian_pattern[4] = { 0x12, 0x34, 0x56, 0x78 };\n+unsigned char little_endian_pattern[4] = { 0x78, 0x56, 0x34, 0x12 };\n+\n+int main (void)\n+{\n+  if (__builtin_memcmp (&my_s1, &big_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  if (__builtin_memcmp (&my_s2, &little_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  if (__builtin_memcmp (&my_s3, &little_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  if (__builtin_memcmp (&my_s4, &big_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  if (__builtin_memcmp (&my_s5, &little_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+#else\n+  if (__builtin_memcmp (&my_s5, &big_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "b4d9d65c3919ba74573a818bbc41d8560f183b04", "filename": "gcc/testsuite/gcc.dg/sso-7.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-7.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+/* Test support of scalar_storage_order pragma */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-fsso-struct=big-endian\" } */\n+\n+struct S1\n+{\n+  int i;\n+};\n+\n+#pragma scalar_storage_order little-endian\n+\n+struct S2\n+{\n+  int i;\n+};\n+\n+#pragma scalar_storage_order default\n+\n+struct S3\n+{\n+  int i;\n+};\n+\n+struct S1 my_s1 = { 0x12345678 };\n+struct S2 my_s2 = { 0x12345678 };\n+struct S3 my_s3 = { 0x12345678 };\n+\n+unsigned char big_endian_pattern[4] = { 0x12, 0x34, 0x56, 0x78 };\n+unsigned char little_endian_pattern[4] = { 0x78, 0x56, 0x34, 0x12 };\n+\n+int main (void)\n+{\n+  if (__builtin_memcmp (&my_s1, &big_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  if (__builtin_memcmp (&my_s2, &little_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  if (__builtin_memcmp (&my_s3, &big_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "19388358ba1bdb0067da4a42295f44ffa6781b29", "filename": "gcc/testsuite/gcc.dg/sso-8.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-8.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+/* Test support of scalar_storage_order pragma */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-fsso-struct=little-endian\" } */\n+\n+struct S1\n+{\n+  int i;\n+};\n+\n+#pragma scalar_storage_order big-endian\n+\n+struct S2\n+{\n+  int i;\n+};\n+\n+#pragma scalar_storage_order default\n+\n+struct S3\n+{\n+  int i;\n+};\n+\n+struct S1 my_s1 = { 0x12345678 };\n+struct S2 my_s2 = { 0x12345678 };\n+struct S3 my_s3 = { 0x12345678 };\n+\n+unsigned char big_endian_pattern[4] = { 0x12, 0x34, 0x56, 0x78 };\n+unsigned char little_endian_pattern[4] = { 0x78, 0x56, 0x34, 0x12 };\n+\n+int main (void)\n+{\n+  if (__builtin_memcmp (&my_s1, &little_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  if (__builtin_memcmp (&my_s2, &big_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  if (__builtin_memcmp (&my_s3, &little_endian_pattern, 4) != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "0bcf59682f16c604c786fdc44a59e55a62aef36d", "filename": "gcc/testsuite/gcc.dg/sso/dump.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fdump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fdump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fdump.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,23 @@\n+void dump (void *p, unsigned int len)\n+{\n+  const char digits[17] = \"0123456789abcdef\";\n+  unsigned char *a = (unsigned char *)p;\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      putchar (' ');\n+      putchar (digits[a[i] / 16]);\n+      putchar (digits[a[i] % 16]);\n+    }\n+}\n+\n+void put (const char s[])\n+{\n+  fputs (s, stdout);\n+}\n+\n+void new_line (void)\n+{\n+  putchar ('\\n');\n+}"}, {"sha": "a4232908af139951f90f1166b5b1b01bcef1b29f", "filename": "gcc/testsuite/gcc.dg/sso/init1.h", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit1.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,12 @@\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  int I;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  int I;\n+};\n+\n+struct R1 My_R1 = { 0x12345678 };\n+struct R2 My_R2 = { 0x12345678 };"}, {"sha": "ee58972cfddca89fbeace170ebc8f099c94fe916", "filename": "gcc/testsuite/gcc.dg/sso/init13.h", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit13.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit13.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit13.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,15 @@\n+#define I (__extension__ 1.0iF)\n+#define Pi 3.1415927f\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  _Complex float F;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  _Complex float F;\n+};\n+\n+struct R1 My_R1 = { Pi - Pi * I };\n+struct R2 My_R2 = { Pi - Pi * I };"}, {"sha": "766aef68057b535f3774f3c5732939ead04f2cfb", "filename": "gcc/testsuite/gcc.dg/sso/init2.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit2.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,24 @@\n+struct __attribute__((scalar_storage_order(\"little-endian\"), packed)) R1\n+{\n+  unsigned S1 : 2;\n+  unsigned I  : 32;\n+  unsigned S2 : 2;\n+  unsigned A1 : 9;\n+  unsigned A2 : 9;\n+  unsigned A3 : 9;\n+  unsigned B  : 1;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"), packed)) R2\n+{\n+  unsigned S1 : 2;\n+  unsigned I  : 32;\n+  unsigned S2 : 2;\n+  unsigned A1 : 9;\n+  unsigned A2 : 9;\n+  unsigned A3 : 9;\n+  unsigned B  : 1;\n+};\n+\n+struct R1 My_R1 = { 2, 0x12345678, 1, 0xAB, 0xCD, 0xEF, 1 };\n+struct R2 My_R2 = { 2, 0x12345678, 1, 0xAB, 0xCD, 0xEF, 1 };"}, {"sha": "4d4ecd0f326b858e3cef5fb33ca4a4d9adffdf3c", "filename": "gcc/testsuite/gcc.dg/sso/init3.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit3.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,34 @@\n+struct __attribute__((scalar_storage_order(\"little-endian\"), packed)) Nested1\n+{\n+  unsigned C1 : 7;\n+  unsigned C2 : 7;\n+  unsigned C3 : 7;\n+  unsigned B  : 3;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"), packed)) R1\n+{\n+  unsigned S1 : 6;\n+  unsigned I  : 32;\n+  unsigned S2 : 2;\n+  struct Nested1 N;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"), packed)) Nested2\n+{\n+  unsigned C1 : 7;\n+  unsigned C2 : 7;\n+  unsigned C3 : 7;\n+  unsigned B  : 3;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"), packed)) R2\n+{\n+  unsigned S1 : 6;\n+  unsigned I  : 32;\n+  unsigned S2 : 2;\n+  struct Nested2 N;\n+};\n+\n+struct R1 My_R1 = { 2, 0x78ABCDEF, 1, { 0x12, 0x34, 0x56, 4 } };\n+struct R2 My_R2 = { 2, 0x78ABCDEF, 1, { 0x12, 0x34, 0x56, 4 } };"}, {"sha": "4cd9f17e65d3eeb0d9d28c0034e2441c36c9edcf", "filename": "gcc/testsuite/gcc.dg/sso/init4.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit4.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,14 @@\n+#define Pi 3.1415927f\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  float F;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  float F;\n+};\n+\n+struct R1 My_R1 = { Pi };\n+struct R2 My_R2 = { Pi };"}, {"sha": "04f5041232063b06918354dd2e3a88ad5a7f09e7", "filename": "gcc/testsuite/gcc.dg/sso/init5.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit5.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,14 @@\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  int I;\n+  int A[3];\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  int I;\n+  int A[3];\n+};\n+\n+struct R1 My_R1 = { 0x12345678, { 0xAB0012, 0xCD0034, 0xEF0056 } };\n+struct R2 My_R2 = { 0x12345678, { 0xAB0012, 0xCD0034, 0xEF0056 } };"}, {"sha": "4515aca8f3b4d58361d059451607bebbcca0997b", "filename": "gcc/testsuite/gcc.dg/sso/init6.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit6.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,24 @@\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) Nested1\n+{\n+  int A[3];\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  int I;\n+  struct Nested1 N;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) Nested2\n+{\n+  int A[3];\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  int I;\n+  struct Nested2 N;\n+};\n+\n+struct R1 My_R1 = { 0x12345678, { { 0xAB0012, 0xCD0034, 0xEF0056 } } };\n+struct R2 My_R2 = { 0x12345678, { { 0xAB0012, 0xCD0034, 0xEF0056 } } };"}, {"sha": "ac145ffcb5f4fca43658af3293af1e257bf337c4", "filename": "gcc/testsuite/gcc.dg/sso/init7.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit7.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,28 @@\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) Nested1\n+{\n+  int C1;\n+  int C2;\n+  int C3;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  int I;\n+  struct Nested1 N;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) Nested2\n+{\n+  int C1;\n+  int C2;\n+  int C3;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  int I;\n+  struct Nested2 N;\n+};\n+\n+struct R1 My_R1 = { 0x12345678, { 0xAB0012, 0xCD0034, 0xEF0056 } };\n+struct R2 My_R2 = { 0x12345678, { 0xAB0012, 0xCD0034, 0xEF0056 } };"}, {"sha": "a273a78e71866b42ff844f0bbc27b1386d293958", "filename": "gcc/testsuite/gcc.dg/sso/init8.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit8.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit8.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit8.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,28 @@\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) Nested1\n+{\n+  int C1;\n+  int C2;\n+  int C3;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  int I;\n+  struct Nested1 N;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) Nested2\n+{\n+  int C1;\n+  int C2;\n+  int C3;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  int I;\n+  struct Nested2 N;\n+};\n+\n+struct R1 My_R1 = { 0x12345678, { 0xAB0012, 0xCD0034, 0xEF0056 } };\n+struct R2 My_R2 = { 0x12345678, { 0xAB0012, 0xCD0034, 0xEF0056 } };"}, {"sha": "358d3869ddc96f65c88b8184ef989cb4418cb46e", "filename": "gcc/testsuite/gcc.dg/sso/init9.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Finit9.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,14 @@\n+#define Pi 3.14159265358979323846\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) R1\n+{\n+  double F;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) R2\n+{\n+  double F;\n+};\n+\n+struct R1 My_R1 = { Pi };\n+struct R2 My_R2 = { Pi };"}, {"sha": "ab6ac5ae4b2068d1631499662f976273b0cf0d64", "filename": "gcc/testsuite/gcc.dg/sso/p1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp1.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init1.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : 78 56 34 12\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 12 34 56 78\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78\\n\" } */\n+\n+  Local_R1.I = 0x12345678;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12\\n\" } */\n+\n+  Local_R2.I = 0x12345678;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78\\n\" } */\n+\n+  Local_R1.I = Local_R2.I;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12\\n\" } */\n+\n+  Local_R2.I = Local_R1.I;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "08ecf292e44aab6f9b6db235c6867d603e04a38d", "filename": "gcc/testsuite/gcc.dg/sso/p13.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp13.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init13.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : db 0f 49 40 db 0f 49 c0\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 40 49 0f db c0 49 0f db\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" } */\n+\n+  Local_R1.F = Pi - Pi * I;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" } */\n+\n+  Local_R2.F = Pi - Pi * I;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" } */\n+\n+  Local_R1.F = Local_R2.F;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" } */\n+\n+  Local_R2.F = Local_R1.F;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "6d605379c15d0249ff0bf9f2b66269444cdb5e45", "filename": "gcc/testsuite/gcc.dg/sso/p2.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp2.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init2.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : e2 59 d1 48 b4 aa d9 bb\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 84 8d 15 9e 15 5b 35 df\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" } */\n+\n+  Local_R1.S1 = 2;\n+  Local_R1.I  = 0x12345678;\n+  Local_R1.S2 = 1;\n+  Local_R1.A1 = 0xAB;\n+  Local_R1.A2 = 0xCD;\n+  Local_R1.A3 = 0xEF;\n+  Local_R1.B  = 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" } */\n+\n+  Local_R2.S1 = 2;\n+  Local_R2.I  = 0x12345678;\n+  Local_R2.S2 = 1;\n+  Local_R2.A1 = 0xAB;\n+  Local_R2.A2 = 0xCD;\n+  Local_R2.A3 = 0xEF;\n+  Local_R2.B  = 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" } */\n+\n+  Local_R1.S1 = Local_R2.S1;\n+  Local_R1.I  = Local_R2.I;\n+  Local_R1.S2 = Local_R2.S2;\n+  Local_R1.A1 = Local_R2.A1;\n+  Local_R1.A2 = Local_R2.A2;\n+  Local_R1.A3 = Local_R2.A3;\n+  Local_R1.B  = Local_R2.B;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" } */\n+\n+  Local_R2.S1 = Local_R1.S1;\n+  Local_R2.I  = Local_R1.I;\n+  Local_R2.S2 = Local_R1.S2;\n+  Local_R2.A1 = Local_R1.A1;\n+  Local_R2.A2 = Local_R1.A2;\n+  Local_R2.A3 = Local_R1.A3;\n+  Local_R2.B  = Local_R1.B;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "ce47dbd2443fbe733271a5dea5e7b763ad208f9c", "filename": "gcc/testsuite/gcc.dg/sso/p3.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp3.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init3.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  Local_R1.S1   = 2;\n+  Local_R1.I    = 0x78ABCDEF;\n+  Local_R1.S2   = 1;\n+  Local_R1.N.C1 = 0x12;\n+  Local_R1.N.C2 = 0x34;\n+  Local_R1.N.C3 = 0x56;\n+  Local_R1.N.B  = 4;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  Local_R2.S1   = 2;\n+  Local_R2.I    = 0x78ABCDEF;\n+  Local_R2.S2   = 1;\n+  Local_R2.N.C1 = 0x12;\n+  Local_R2.N.C2 = 0x34;\n+  Local_R2.N.C3 = 0x56;\n+  Local_R2.N.B  = 4;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  Local_R1.S1   = Local_R2.S1;\n+  Local_R1.I    = Local_R2.I;\n+  Local_R1.S2   = Local_R2.S2;\n+  Local_R1.N.C1 = Local_R2.N.C1;\n+  Local_R1.N.C2 = Local_R2.N.C2;\n+  Local_R1.N.C3 = Local_R2.N.C3;\n+  Local_R1.N.B  = Local_R2.N.B;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  Local_R2.S1   = Local_R1.S1;\n+  Local_R2.I    = Local_R1.I;\n+  Local_R2.S2   = Local_R1.S2;\n+  Local_R2.N.C1 = Local_R1.N.C1;\n+  Local_R2.N.C2 = Local_R1.N.C2;\n+  Local_R2.N.C3 = Local_R1.N.C3;\n+  Local_R2.N.B  = Local_R1.N.B;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "7d7224d9b30db0cfcfbedc0090dcd00cebf1fbf3", "filename": "gcc/testsuite/gcc.dg/sso/p4.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp4.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init4.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : db 0f 49 40\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 40 49 0f db\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db\\n\" } */\n+\n+  Local_R1.F = Pi;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40\\n\" } */\n+\n+  Local_R2.F = Pi;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db\\n\" } */\n+\n+  Local_R1.F = Local_R2.F;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40\\n\" } */\n+\n+  Local_R2.F = Local_R1.F;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "91bd6ba0a480f6c559e6f5a3fbb5817755180ef7", "filename": "gcc/testsuite/gcc.dg/sso/p5.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp5.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init5.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1.I    = 0x12345678;\n+  Local_R1.A[0] = 0xAB0012;\n+  Local_R1.A[1] = 0xCD0034;\n+  Local_R1.A[2] = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = 0x12345678;\n+  Local_R2.A[0] = 0xAB0012;\n+  Local_R2.A[1] = 0xCD0034;\n+  Local_R2.A[2] = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1.I    = Local_R2.I;\n+  Local_R1.A[0] = Local_R2.A[0];\n+  Local_R1.A[1] = Local_R2.A[1];\n+  Local_R1.A[2] = Local_R2.A[2];\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = Local_R1.I;\n+  Local_R2.A[0] = Local_R1.A[0];\n+  Local_R2.A[1] = Local_R1.A[1];\n+  Local_R2.A[2] = Local_R1.A[2];\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "8681c303c408f37584a4f90bd59aec65a131ef80", "filename": "gcc/testsuite/gcc.dg/sso/p6.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp6.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init6.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1.I      = 0x12345678;\n+  Local_R1.N.A[0] = 0xAB0012;\n+  Local_R1.N.A[1] = 0xCD0034;\n+  Local_R1.N.A[2] = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2.I      = 0x12345678;\n+  Local_R2.N.A[0] = 0xAB0012;\n+  Local_R2.N.A[1] = 0xCD0034;\n+  Local_R2.N.A[2] = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1.I      = Local_R2.I;\n+  Local_R1.N.A[0] = Local_R2.N.A[0];\n+  Local_R1.N.A[1] = Local_R2.N.A[1];\n+  Local_R1.N.A[2] = Local_R2.N.A[2];\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2.I      = Local_R1.I;\n+  Local_R2.N.A[0] = Local_R1.N.A[0];\n+  Local_R2.N.A[1] = Local_R1.N.A[1];\n+  Local_R2.N.A[2] = Local_R1.N.A[2];\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "e6bfa136574440469c920f743e7c0513e00ef04f", "filename": "gcc/testsuite/gcc.dg/sso/p7.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp7.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init7.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1.I    = 0x12345678;\n+  Local_R1.N.C1 = 0xAB0012;\n+  Local_R1.N.C2 = 0xCD0034;\n+  Local_R1.N.C3 = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = 0x12345678;\n+  Local_R2.N.C1 = 0xAB0012;\n+  Local_R2.N.C2 = 0xCD0034;\n+  Local_R2.N.C3 = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1.I    = Local_R2.I;\n+  Local_R1.N.C1 = Local_R2.N.C1;\n+  Local_R1.N.C2 = Local_R2.N.C2;\n+  Local_R1.N.C3 = Local_R2.N.C3;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = Local_R1.I;\n+  Local_R2.N.C1 = Local_R1.N.C1;\n+  Local_R2.N.C2 = Local_R1.N.C2;\n+  Local_R2.N.C3 = Local_R1.N.C3;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "d2e7bd1b95d0a63ce6a36a048d1226475f0ee47e", "filename": "gcc/testsuite/gcc.dg/sso/p8.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp8.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init8.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1.I    = 0x12345678;\n+  Local_R1.N.C1 = 0xAB0012;\n+  Local_R1.N.C2 = 0xCD0034;\n+  Local_R1.N.C3 = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2.I    = 0x12345678;\n+  Local_R2.N.C1 = 0xAB0012;\n+  Local_R2.N.C2 = 0xCD0034;\n+  Local_R2.N.C3 = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1.I    = Local_R2.I;\n+  Local_R1.N.C1 = Local_R2.N.C1;\n+  Local_R1.N.C2 = Local_R2.N.C2;\n+  Local_R1.N.C3 = Local_R2.N.C3;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2.I    = Local_R1.I;\n+  Local_R2.N.C1 = Local_R1.N.C1;\n+  Local_R2.N.C2 = Local_R1.N.C2;\n+  Local_R2.N.C3 = Local_R1.N.C3;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "c3bee117cdc8cfc3e9ecdc1c29a25bcf4a0eb451", "filename": "gcc/testsuite/gcc.dg/sso/p9.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fp9.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init9.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  put (\"My_R1    :\");\n+  dump (&My_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"My_R1    : 18 2d 44 54 fb 21 09 40\\n\" } */\n+\n+  put (\"My_R2    :\");\n+  dump (&My_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"My_R2    : 40 09 21 fb 54 44 2d 18\\n\" } */\n+\n+  Local_R1 = My_R1;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" } */\n+\n+  Local_R2 = My_R2;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" } */\n+\n+  Local_R1.F = Pi;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" } */\n+\n+  Local_R2.F = Pi;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" } */\n+\n+  Local_R1.F = Local_R2.F;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" } */\n+\n+  Local_R2.F = Local_R1.F;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "6da5a5f4533050ecbf5a4d0ebbdef3fb5b61a4ab", "filename": "gcc/testsuite/gcc.dg/sso/q1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq1.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init1.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : 78 56 34 12\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 12 34 56 78\\n\" } */\n+\n+  if (A1.I != B1.I) abort ();\n+\n+  if (A1.I != 0x12345678) abort ();\n+\n+  if (A2.I != B2.I) abort ();\n+\n+  if (A2.I != 0x12345678) abort ();\n+\n+  return 0;\n+}"}, {"sha": "ee34bb2289d047ce3b5a66c43b6c194ac20b8cdc", "filename": "gcc/testsuite/gcc.dg/sso/q13.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq13.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init13.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : db 0f 49 40 db 0f 49 c0\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : db 0f 49 40 db 0f 49 c0\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 40 49 0f db c0 49 0f db\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 40 49 0f db c0 49 0f db\\n\" } */\n+\n+  if (A1.F != B1.F) abort ();\n+\n+  if (A1.F != Pi - Pi * I) abort ();\n+\n+  if (A2.F != B2.F) abort ();\n+\n+  if (A2.F != Pi - Pi * I) abort ();\n+\n+  return 0;\n+}"}, {"sha": "9e1d1d27ff3c5c089f3b356130054e82e6e4c680", "filename": "gcc/testsuite/gcc.dg/sso/q2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq2.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init2.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : e2 59 d1 48 b4 aa d9 bb\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : e2 59 d1 48 b4 aa d9 bb\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 84 8d 15 9e 15 5b 35 df\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 84 8d 15 9e 15 5b 35 df\\n\" } */\n+\n+  if (A1.S1 != B1.S1) abort ();\n+\n+  if (A1.S1 != 2) abort ();\n+\n+  if (A2.S1 != B2.S1) abort ();\n+\n+  if (A2.S1 != 2) abort ();\n+\n+  if (A1.I != B1.I || A1.A1 != B1.A1) abort ();\n+\n+  if (A2.I != B2.I || A2.A1 != B2.A1) abort ();\n+\n+  return 0;\n+}"}, {"sha": "6e72d7efc450de1bbed3eb7c7d05231cecf330c5", "filename": "gcc/testsuite/gcc.dg/sso/q3.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq3.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init3.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  if (A1.S1 != B1.S1) abort ();\n+\n+  if (A1.S1 != 2) abort ();\n+\n+  if (A2.S1 != B2.S1) abort ();\n+\n+  if (A2.S1 != 2) abort ();\n+\n+  if (A1.I != B1.I || A1.N.C1 != B1.N.C1) abort ();\n+\n+  if (A2.I != B2.I || A2.N.C1 != B2.N.C1) abort ();\n+\n+  return 0;\n+}"}, {"sha": "6966c8f72117c6818cc22268358a551b2becdc7d", "filename": "gcc/testsuite/gcc.dg/sso/q4.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq4.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init4.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : db 0f 49 40\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : db 0f 49 40\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 40 49 0f db\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 40 49 0f db\\n\" } */\n+\n+  if (A1.F != B1.F) abort ();\n+\n+  if (A1.F != Pi) abort ();\n+\n+  if (A2.F != B2.F) abort ();\n+\n+  if (A2.F != Pi) abort ();\n+\n+  return 0;\n+}"}, {"sha": "03dfdb7c35c4e1d3b39f631a569e083269d484f6", "filename": "gcc/testsuite/gcc.dg/sso/q5.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq5.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init5.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  if (A1.I != B1.I || A1.A[0] != B1.A[0]) abort();\n+\n+  if (A2.I != B2.I || A2.A[0] != B2.A[0]) abort ();\n+\n+  return 0;\n+}"}, {"sha": "1292f6af7bd935fb81b053400ced49bc4e3691de", "filename": "gcc/testsuite/gcc.dg/sso/q6.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq6.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init6.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  if (A1.I != B1.I || A1.N.A[0] != B1.N.A[0]) abort();\n+\n+  if (A2.I != B2.I || A2.N.A[0] != B2.N.A[0]) abort ();\n+\n+  return 0;\n+}"}, {"sha": "c088f05a0c79697585b877de4306904eaeb8f337", "filename": "gcc/testsuite/gcc.dg/sso/q7.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq7.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init7.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  if (A1.I != B1.I || A1.N.C1 != B1.N.C1) abort();\n+\n+  if (A2.I != B2.I || A2.N.C1 != B2.N.C1) abort ();\n+\n+  return 0;\n+}"}, {"sha": "108afc1822f9e49b054f75ad3060c1eafedc03d5", "filename": "gcc/testsuite/gcc.dg/sso/q8.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq8.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init8.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  if (A1.I != B1.I || A1.N.C1 != B1.N.C1) abort();\n+\n+  if (A2.I != B2.I || A2.N.C1 != B2.N.C1) abort ();\n+\n+  return 0;\n+}"}, {"sha": "ac6c8dd7f8f4a83378508bf28c7a706affcf671c", "filename": "gcc/testsuite/gcc.dg/sso/q9.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fq9.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init9.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R1 B1 = My_R1;\n+\n+  struct R2 A2 = My_R2;\n+  struct R2 B2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 18 2d 44 54 fb 21 09 40\\n\" } */\n+\n+  put (\"B1 :\");\n+  dump (&B1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"B1 : 18 2d 44 54 fb 21 09 40\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 40 09 21 fb 54 44 2d 18\\n\" } */\n+\n+  put (\"B2 :\");\n+  dump (&B2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"B2 : 40 09 21 fb 54 44 2d 18\\n\" } */\n+\n+  if (A1.F != B1.F) abort ();\n+\n+  if (A1.F != Pi) abort ();\n+\n+  if (A2.F != B2.F) abort ();\n+\n+  if (A2.F != Pi) abort ();\n+\n+  return 0;\n+}"}, {"sha": "82b55bda73b52d347e152e1edeaf655b3cbb865a", "filename": "gcc/testsuite/gcc.dg/sso/r3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr3.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init3.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int Get_Elem1 (struct R1 R)\n+{\n+  struct R1 Tmp = R;\n+  return Tmp.I;\n+}\n+\n+void Set_Elem1 (struct R1 *R, int I)\n+{\n+  struct R1 Tmp = *R;\n+  Tmp.I = I;\n+  *R = Tmp;\n+}\n+\n+int Get_Elem2 (struct R2 R)\n+{\n+  struct R2 Tmp = R;\n+  return Tmp.I;\n+}\n+\n+void Set_Elem2 (struct R2 *R, int I)\n+{\n+  struct R2 Tmp = *R;\n+  Tmp.I = I;\n+  *R = Tmp;\n+}\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  if (Get_Elem1 (A1) != 0x78ABCDEF) abort ();\n+\n+  Set_Elem1 (&A1, 0xCD0034);\n+  if (Get_Elem1 (A1) != 0xCD0034) abort ();\n+\n+  if (Get_Elem2 (A2) != 0x78ABCDEF) abort ();\n+\n+  Set_Elem2 (&A2, 0xCD0034);\n+  if (Get_Elem2 (A2) != 0xCD0034) abort ();\n+\n+  return 0;\n+}"}, {"sha": "6911408eb31433876c2cd4b00d42d5b6e4578a48", "filename": "gcc/testsuite/gcc.dg/sso/r5.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr5.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init5.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int Get_Elem1 (struct R1 R)\n+{\n+  struct R1 Tmp = R;\n+  return Tmp.A[0];\n+}\n+\n+void Set_Elem1 (struct R1 *R, int I)\n+{\n+  struct R1 Tmp = *R;\n+  Tmp.A[0] = I;\n+  *R = Tmp;\n+}\n+\n+int Get_Elem2 (struct R2 R)\n+{\n+  struct R2 Tmp = R;\n+  return Tmp.A[0];\n+}\n+\n+void Set_Elem2 (struct R2 *R, int I)\n+{\n+  struct R2 Tmp = *R;\n+  Tmp.A[0] = I;\n+  *R = Tmp;\n+}\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  if (Get_Elem1 (A1) != 0xAB0012) abort ();\n+\n+  Set_Elem1 (&A1, 0xCD0034);\n+  if (Get_Elem1 (A1) != 0xCD0034) abort ();\n+\n+  if (Get_Elem2 (A2) != 0xAB0012) abort ();\n+\n+  Set_Elem2 (&A2, 0xCD0034);\n+  if (Get_Elem2 (A2) != 0xCD0034) abort ();\n+\n+  return 0;\n+}"}, {"sha": "904dd5c0ac3d96f380caedacf3e29a4ca4fb77b2", "filename": "gcc/testsuite/gcc.dg/sso/r6.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr6.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init6.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int Get_Elem1 (struct R1 R)\n+{\n+  struct R1 Tmp = R;\n+  return Tmp.N.A[0];\n+}\n+\n+void Set_Elem1 (struct R1 *R, int I)\n+{\n+  struct R1 Tmp = *R;\n+  Tmp.N.A[0] = I;\n+  *R = Tmp;\n+}\n+\n+int Get_Elem2 (struct R2 R)\n+{\n+  struct R2 Tmp = R;\n+  return Tmp.N.A[0];\n+}\n+\n+void Set_Elem2 (struct R2 *R, int I)\n+{\n+  struct R2 Tmp = *R;\n+  Tmp.N.A[0] = I;\n+  *R = Tmp;\n+}\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  if (Get_Elem1 (A1) != 0xAB0012) abort ();\n+\n+  Set_Elem1 (&A1, 0xCD0034);\n+  if (Get_Elem1 (A1) != 0xCD0034) abort ();\n+\n+  if (Get_Elem2 (A2) != 0xAB0012) abort ();\n+\n+  Set_Elem2 (&A2, 0xCD0034);\n+  if (Get_Elem2 (A2) != 0xCD0034) abort ();\n+\n+  return 0;\n+}"}, {"sha": "a6450eed8e3199bca912a79b77c64ea1211fbb75", "filename": "gcc/testsuite/gcc.dg/sso/r7.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr7.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init7.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int Get_Elem1 (struct R1 R)\n+{\n+  struct R1 Tmp = R;\n+  return Tmp.N.C1;\n+}\n+\n+void Set_Elem1 (struct R1 *R, int I)\n+{\n+  struct R1 Tmp = *R;\n+  Tmp.N.C1 = I;\n+  *R = Tmp;\n+}\n+\n+int Get_Elem2 (struct R2 R)\n+{\n+  struct R2 Tmp = R;\n+  return Tmp.N.C1;\n+}\n+\n+void Set_Elem2 (struct R2 *R, int I)\n+{\n+  struct R2 Tmp = *R;\n+  Tmp.N.C1 = I;\n+  *R = Tmp;\n+}\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  if (Get_Elem1 (A1) != 0xAB0012) abort ();\n+\n+  Set_Elem1 (&A1, 0xCD0034);\n+  if (Get_Elem1 (A1) != 0xCD0034) abort ();\n+\n+  if (Get_Elem2 (A2) != 0xAB0012) abort ();\n+\n+  Set_Elem2 (&A2, 0xCD0034);\n+  if (Get_Elem2 (A2) != 0xCD0034) abort ();\n+\n+  return 0;\n+}"}, {"sha": "448da504a7e3ce28c9b476faeba459cf1c82ed80", "filename": "gcc/testsuite/gcc.dg/sso/r8.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fr8.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init8.h\"\n+#include \"dump.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+void abort (void);\n+\n+int Get_Elem1 (struct R1 R)\n+{\n+  struct R1 Tmp = R;\n+  return Tmp.N.C1;\n+}\n+\n+void Set_Elem1 (struct R1 *R, int I)\n+{\n+  struct R1 Tmp = *R;\n+  Tmp.N.C1 = I;\n+  *R = Tmp;\n+}\n+\n+int Get_Elem2 (struct R2 R)\n+{\n+  struct R2 Tmp = R;\n+  return Tmp.N.C1;\n+}\n+\n+void Set_Elem2 (struct R2 *R, int I)\n+{\n+  struct R2 Tmp = *R;\n+  Tmp.N.C1 = I;\n+  *R = Tmp;\n+}\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  if (Get_Elem1 (A1) != 0xAB0012) abort ();\n+\n+  Set_Elem1 (&A1, 0xCD0034);\n+  if (Get_Elem1 (A1) != 0xCD0034) abort ();\n+\n+  if (Get_Elem2 (A2) != 0xAB0012) abort ();\n+\n+  Set_Elem2 (&A2, 0xCD0034);\n+  if (Get_Elem2 (A2) != 0xCD0034) abort ();\n+\n+  return 0;\n+}"}, {"sha": "33a07c169bc6b943ce7485acdda09db84a0d978b", "filename": "gcc/testsuite/gcc.dg/sso/s3.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs3.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init3.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  struct Nested1 N1;\n+  struct Nested2 N2;\n+\n+  unsigned C1;\n+  unsigned C2;\n+  unsigned C3;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  N1 = A1.N;\n+  C1 = N1.C1;\n+  C2 = N1.C2;\n+  C3 = N1.C3;\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 18\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 52\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 86\\n\" } */\n+\n+  N1.C1 = C1;\n+  N1.C2 = C2;\n+  N1.C3 = C3;\n+  A1.N = N1;\n+\n+  N2 = A2.N;\n+  C1 = N2.C1;\n+  C2 = N2.C2;\n+  C3 = N2.C3;\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 18\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 52\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 86\\n\" } */\n+\n+  N2.C1 = C1;\n+  N2.C2 = C2;\n+  N2.C3 = C3;\n+  A2.N = N2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "f7f63befc46074bf535de9f563f60a493abf8342", "filename": "gcc/testsuite/gcc.dg/sso/s5.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs5.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init5.h\"\n+#include \"dump.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wscalar-storage-order\"\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  struct __attribute__((scalar_storage_order(\"little-endian\"))) Nested1\n+  {\n+    int A[3];\n+  };\n+\n+  struct __attribute__((scalar_storage_order(\"big-endian\"))) Nested2\n+  {\n+    int A[3];\n+  };\n+\n+  struct Nested1 N1;\n+  struct Nested2 N2;\n+\n+  int C1;\n+  int C2;\n+  int C3;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  __builtin_memcpy (N1.A, A1.A, sizeof (int) * 3);\n+  C1 = N1.A[0];\n+  C2 = N1.A[1];\n+  C3 = N1.A[2];\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N1.A[0] = C1;\n+  N1.A[1] = C2;\n+  N1.A[2] = C3;\n+  __builtin_memcpy (A1.A, N1.A, sizeof (int) * 3);\n+\n+  __builtin_memcpy (N2.A, A2.A, sizeof (int) * 3);\n+  C1 = N2.A[0];\n+  C2 = N2.A[1];\n+  C3 = N2.A[2];\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N2.A[0] = C1;\n+  N2.A[1] = C2;\n+  N2.A[2] = C3;\n+  __builtin_memcpy (A2.A, N2.A, sizeof (int) * 3);\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "acd8e3d0d95ce5d88f33a027040a7b305fc92b51", "filename": "gcc/testsuite/gcc.dg/sso/s6.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs6.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init6.h\"\n+#include \"dump.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wscalar-storage-order\"\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  struct Nested1 N1;\n+  struct Nested2 N2;\n+\n+  int C1;\n+  int C2;\n+  int C3;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  __builtin_memcpy (N1.A, A1.N.A, sizeof (int) * 3);\n+  C1 = N1.A[0];\n+  C2 = N1.A[1];\n+  C3 = N1.A[2];\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N1.A[0] = C1;\n+  N1.A[1] = C2;\n+  N1.A[2] = C3;\n+  __builtin_memcpy (A1.N.A, N1.A, sizeof (int) * 3);\n+\n+  __builtin_memcpy (N2.A, A2.N.A, sizeof (int) * 3);\n+  C1 = N2.A[0];\n+  C2 = N2.A[1];\n+  C3 = N2.A[2];\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N2.A[0] = C1;\n+  N2.A[1] = C2;\n+  N2.A[2] = C3;\n+  __builtin_memcpy (A2.N.A, N2.A, sizeof (int) * 3);\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "88e074117daeec5167909379ac204913035f40fc", "filename": "gcc/testsuite/gcc.dg/sso/s7.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs7.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init7.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  struct Nested1 N1;\n+  struct Nested2 N2;\n+\n+  int C1;\n+  int C2;\n+  int C3;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  N1 = A1.N;\n+  C1 = N1.C1;\n+  C2 = N1.C2;\n+  C3 = N1.C3;\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N1.C1 = C1;\n+  N1.C2 = C2;\n+  N1.C3 = C3;\n+  A1.N = N1;\n+\n+  N2 = A2.N;\n+  C1 = N2.C1;\n+  C2 = N2.C2;\n+  C3 = N2.C3;\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N2.C1 = C1;\n+  N2.C2 = C2;\n+  N2.C3 = C3;\n+  A2.N = N2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "1154da3b7f461114a279bf46065ea702adfb4530", "filename": "gcc/testsuite/gcc.dg/sso/s8.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fs8.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init8.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 A1 = My_R1;\n+  struct R2 A2 = My_R2;\n+\n+  struct Nested1 N1;\n+  struct Nested2 N2;\n+\n+  int C1;\n+  int C2;\n+  int C3;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  N1 = A1.N;\n+  C1 = N1.C1;\n+  C2 = N1.C2;\n+  C3 = N1.C3;\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N1.C1 = C1;\n+  N1.C2 = C2;\n+  N1.C3 = C3;\n+  A1.N = N1;\n+\n+  N2 = A2.N;\n+  C1 = N2.C1;\n+  C2 = N2.C2;\n+  C3 = N2.C3;\n+\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 11206674\\n\" } */\n+\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  printf (\"C3 : %d\\n\", C3);\n+  /* { dg-output \"C3 : 15663190\\n\" } */\n+\n+  N2.C1 = C1;\n+  N2.C2 = C2;\n+  N2.C3 = C3;\n+  A2.N = N2;\n+\n+  put (\"A1 :\");\n+  dump (&A1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  put (\"A2 :\");\n+  dump (&A2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "ae185d0d77e3c9add95930821860a1a97461bc46", "filename": "gcc/testsuite/gcc.dg/sso/sso.exp", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fsso.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fsso.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fsso.exp?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,40 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+load_lib torture-options.exp\n+\n+# Initialize `dg'.\n+torture-init\n+dg-init\n+\n+set SSO_TORTURE_OPTIONS [list \\\n+\t{ -O0 } \\\n+\t{ -O1 -fno-inline } \\\n+\t{ -O2 } \\\n+\t{ -O3 -finline-functions } \\\n+\t{ -Os } \\\n+\t{ -Og -g } ]\n+\n+set-torture-options $SSO_TORTURE_OPTIONS\n+\n+# Main loop.\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] \"\" \"\"\n+\n+# All done.\n+dg-finish\n+torture-finish"}, {"sha": "6f7881ee0ed8fc7aefe33d57253838c56308954c", "filename": "gcc/testsuite/gcc.dg/sso/t1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft1.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init1.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.I = My_R1.I + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12\\n\" } */\n+\n+  Local_R2.I = My_R2.I + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79\\n\" } */\n+\n+  Local_R1.I = 0x12345678;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12\\n\" } */\n+\n+  Local_R2.I = 0x12345678;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78\\n\" } */\n+\n+  Local_R1.I = Local_R1.I + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12\\n\" } */\n+\n+  Local_R2.I = Local_R2.I + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "a0f434134490e0484f58a60ab3b2f9a51bb14db3", "filename": "gcc/testsuite/gcc.dg/sso/t13.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft13.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init13.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.F = My_R1.F + (1.0f + 1.0f * I);\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : ee 87 84 40 db 0f 09 c0\\n\" } */\n+\n+  Local_R2.F = My_R2.F + (1.0f + 1.0f * I);\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 84 87 ee c0 09 0f db\\n\" } */\n+\n+  Local_R1.F = Pi - Pi * I;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" } */\n+\n+  Local_R2.F = Pi - Pi * I;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" } */\n+\n+  Local_R1.F = Local_R1.F + (1.0f + 1.0f * I);\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : ee 87 84 40 db 0f 09 c0\\n\" } */\n+\n+  Local_R2.F = Local_R2.F + (1.0f + 1.0f * I);\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 84 87 ee c0 09 0f db\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "816363284dbc96188ddf5c295fe99905028d041e", "filename": "gcc/testsuite/gcc.dg/sso/t2.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft2.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init2.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.S1 = My_R1.S1 - 1;\n+  Local_R1.I  = My_R1.I + 1;\n+  Local_R1.S2 = My_R1.S2 - 1;\n+  Local_R1.A1 = My_R1.A1 % 16;\n+  Local_R1.A2 = My_R1.A2 % 16;\n+  Local_R1.A3 = My_R1.A3 % 16;\n+  Local_R1.B  = !My_R1.B;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : e5 59 d1 48 b0 a0 c1 03\\n\" } */\n+\n+  Local_R2.S1 = My_R2.S1 - 1;\n+  Local_R2.I  = My_R2.I + 1;\n+  Local_R2.S2 = My_R2.S2 - 1;\n+  Local_R2.A1 = My_R2.A1 % 16;\n+  Local_R2.A2 = My_R2.A2 % 16;\n+  Local_R2.A3 = My_R2.A3 % 16;\n+  Local_R2.B  = !My_R2.B;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 44 8d 15 9e 40 58 34 1e\\n\" } */\n+\n+  Local_R1.S1 = 2;\n+  Local_R1.I  = 0x12345678;\n+  Local_R1.S2 = 1;\n+  Local_R1.A1 = 0xAB;\n+  Local_R1.A2 = 0xCD;\n+  Local_R1.A3 = 0xEF;\n+  Local_R1.B  = 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" } */\n+\n+  Local_R2.S1 = 2;\n+  Local_R2.I  = 0x12345678;\n+  Local_R2.S2 = 1;\n+  Local_R2.A1 = 0xAB;\n+  Local_R2.A2 = 0xCD;\n+  Local_R2.A3 = 0xEF;\n+  Local_R2.B  = 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" } */\n+\n+  Local_R1.S1 = Local_R1.S1 - 1;\n+  Local_R1.I  = Local_R1.I + 1;\n+  Local_R1.S2 = Local_R1.S2 - 1;\n+  Local_R1.A1 = Local_R1.A1 % 16;\n+  Local_R1.A2 = Local_R1.A2 % 16;\n+  Local_R1.A3 = Local_R1.A3 % 16;\n+  Local_R1.B  = !Local_R1.B;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : e5 59 d1 48 b0 a0 c1 03\\n\" } */\n+\n+  Local_R2.S1 = Local_R2.S1 - 1;\n+  Local_R2.I  = Local_R2.I + 1;\n+  Local_R2.S2 = Local_R2.S2 - 1;\n+  Local_R2.A1 = Local_R2.A1 % 16;\n+  Local_R2.A2 = Local_R2.A2 % 16;\n+  Local_R2.A3 = Local_R2.A3 % 16;\n+  Local_R2.B  = !Local_R2.B;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 44 8d 15 9e 40 58 34 1e\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "e2f407047242d262f7e782e0b820cec18d97d7cc", "filename": "gcc/testsuite/gcc.dg/sso/t3.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft3.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init3.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.S1   = My_R1.S1 - 1;\n+  Local_R1.I    = My_R1.I + 1;\n+  Local_R1.S2   = My_R1.S2 - 1;\n+  Local_R1.N.C1 = My_R1.N.C1 % 16;\n+  Local_R1.N.C2 = My_R1.N.C2 % 16;\n+  Local_R1.N.C3 = My_R1.N.C3 % 16;\n+  Local_R1.N.B  = My_R1.N.B % 2;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 01 7c f3 2a 1e 02 82 01\\n\" } */\n+\n+  Local_R2.S1   = My_R2.S1 - 1;\n+  Local_R2.I    = My_R2.I + 1;\n+  Local_R2.S2   = My_R2.S2 - 1;\n+  Local_R2.N.C1 = My_R2.N.C1 % 16;\n+  Local_R2.N.C2 = My_R2.N.C2 % 16;\n+  Local_R2.N.C3 = My_R2.N.C3 % 16;\n+  Local_R2.N.B  = My_R2.N.B % 2;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 05 e2 af 37 c0 04 10 30\\n\" } */\n+\n+  Local_R1.S1   = 2;\n+  Local_R1.I    = 0x78ABCDEF;\n+  Local_R1.S2   = 1;\n+  Local_R1.N.C1 = 0x12;\n+  Local_R1.N.C2 = 0x34;\n+  Local_R1.N.C3 = 0x56;\n+  Local_R1.N.B  = 4;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : c2 7b f3 2a 5e 12 9a 95\\n\" } */\n+\n+  Local_R2.S1   = 2;\n+  Local_R2.I    = 0x78ABCDEF;\n+  Local_R2.S2   = 1;\n+  Local_R2.N.C1 = 0x12;\n+  Local_R2.N.C2 = 0x34;\n+  Local_R2.N.C3 = 0x56;\n+  Local_R2.N.B  = 4;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 09 e2 af 37 bd 24 d2 b4\\n\" } */\n+\n+  Local_R1.S1   = Local_R1.S1 - 1;\n+  Local_R1.I    = Local_R1.I + 1;\n+  Local_R1.S2   = Local_R1.S2 - 1;\n+  Local_R1.N.C1 = Local_R1.N.C1 % 16;\n+  Local_R1.N.C2 = Local_R1.N.C2 % 16;\n+  Local_R1.N.C3 = Local_R1.N.C3 % 16;\n+  Local_R1.N.B  = Local_R1.N.B % 2;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 01 7c f3 2a 1e 02 82 01\\n\" } */\n+\n+  Local_R2.S1   = Local_R2.S1 - 1;\n+  Local_R2.I    = Local_R2.I + 1;\n+  Local_R2.S2   = Local_R2.S2 - 1;\n+  Local_R2.N.C1 = Local_R2.N.C1 % 16;\n+  Local_R2.N.C2 = Local_R2.N.C2 % 16;\n+  Local_R2.N.C3 = Local_R2.N.C3 % 16;\n+  Local_R2.N.B  = Local_R2.N.B % 2;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 05 e2 af 37 c0 04 10 30\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "f5a7eb016275c6061345cbbb9ea084622bfae9bc", "filename": "gcc/testsuite/gcc.dg/sso/t4.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft4.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init4.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.F = My_R1.F + 1.0f;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : ee 87 84 40\\n\" } */\n+\n+  Local_R2.F = My_R2.F + 1.0f;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 84 87 ee\\n\" } */\n+\n+  Local_R1.F = Pi;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : db 0f 49 40\\n\" } */\n+\n+  Local_R2.F = Pi;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 49 0f db\\n\" } */\n+\n+  Local_R1.F = Local_R1.F + 1.0f;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : ee 87 84 40\\n\" } */\n+\n+  Local_R2.F = Local_R2.F + 1.0f;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 84 87 ee\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "7cefb203dd8a3db236485e691099dd212ed758e8", "filename": "gcc/testsuite/gcc.dg/sso/t5.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft5.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init5.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.I    = My_R1.I + 1;\n+  Local_R1.A[0] = My_R1.A[0] + 1;\n+  Local_R1.A[1] = My_R1.A[1] + 1;\n+  Local_R1.A[2] = My_R1.A[2] + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = My_R2.I + 1;\n+  Local_R2.A[0] = My_R2.A[0] + 1;\n+  Local_R2.A[1] = My_R2.A[1] + 1;\n+  Local_R2.A[2] = My_R2.A[2] + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  Local_R1.I    = 0x12345678;\n+  Local_R1.A[0] = 0xAB0012;\n+  Local_R1.A[1] = 0xCD0034;\n+  Local_R1.A[2] = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = 0x12345678;\n+  Local_R2.A[0] = 0xAB0012;\n+  Local_R2.A[1] = 0xCD0034;\n+  Local_R2.A[2] = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1.I    = Local_R1.I + 1;\n+  Local_R1.A[0] = Local_R1.A[0] + 1;\n+  Local_R1.A[1] = Local_R1.A[1] + 1;\n+  Local_R1.A[2] = Local_R1.A[2] + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = Local_R2.I + 1;\n+  Local_R2.A[0] = Local_R2.A[0] + 1;\n+  Local_R2.A[1] = Local_R2.A[1] + 1;\n+  Local_R2.A[2] = Local_R2.A[2] + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "8fb550b0ff12b5da8cd7aaf04ceaf19775298428", "filename": "gcc/testsuite/gcc.dg/sso/t6.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft6.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init6.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.I      = My_R1.I + 1;\n+  Local_R1.N.A[0] = My_R1.N.A[0] + 1;\n+  Local_R1.N.A[1] = My_R1.N.A[1] + 1;\n+  Local_R1.N.A[2] = My_R1.N.A[2] + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  Local_R2.I      = My_R2.I + 1;\n+  Local_R2.N.A[0] = My_R2.N.A[0] + 1;\n+  Local_R2.N.A[1] = My_R2.N.A[1] + 1;\n+  Local_R2.N.A[2] = My_R2.N.A[2] + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  Local_R1.I      = 0x12345678;\n+  Local_R1.N.A[0] = 0xAB0012;\n+  Local_R1.N.A[1] = 0xCD0034;\n+  Local_R1.N.A[2] = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2.I      = 0x12345678;\n+  Local_R2.N.A[0] = 0xAB0012;\n+  Local_R2.N.A[1] = 0xCD0034;\n+  Local_R2.N.A[2] = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1.I      = Local_R1.I + 1;\n+  Local_R1.N.A[0] = Local_R1.N.A[0] + 1;\n+  Local_R1.N.A[1] = Local_R1.N.A[1] + 1;\n+  Local_R1.N.A[2] = Local_R1.N.A[2] + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  Local_R2.I      = Local_R2.I + 1;\n+  Local_R2.N.A[0] = Local_R2.N.A[0] + 1;\n+  Local_R2.N.A[1] = Local_R2.N.A[1] + 1;\n+  Local_R2.N.A[2] = Local_R2.N.A[2] + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "59df566cd8018573277c5262d2e3d9eb033fc87a", "filename": "gcc/testsuite/gcc.dg/sso/t7.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft7.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init7.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.I    = My_R1.I + 1;\n+  Local_R1.N.C1 = My_R1.N.C1 + 1;\n+  Local_R1.N.C2 = My_R1.N.C2 + 1;\n+  Local_R1.N.C3 = My_R1.N.C3 + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = My_R2.I + 1;\n+  Local_R2.N.C1 = My_R2.N.C1 + 1;\n+  Local_R2.N.C2 = My_R2.N.C2 + 1;\n+  Local_R2.N.C3 = My_R2.N.C3 + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  Local_R1.I    = 0x12345678;\n+  Local_R1.N.C1 = 0xAB0012;\n+  Local_R1.N.C2 = 0xCD0034;\n+  Local_R1.N.C3 = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = 0x12345678;\n+  Local_R2.N.C1 = 0xAB0012;\n+  Local_R2.N.C2 = 0xCD0034;\n+  Local_R2.N.C3 = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R1.I    = Local_R1.I + 1;\n+  Local_R1.N.C1 = Local_R1.N.C1 + 1;\n+  Local_R1.N.C2 = Local_R1.N.C2 + 1;\n+  Local_R1.N.C3 = Local_R1.N.C3 + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = Local_R2.I + 1;\n+  Local_R2.N.C1 = Local_R2.N.C1 + 1;\n+  Local_R2.N.C2 = Local_R2.N.C2 + 1;\n+  Local_R2.N.C3 = Local_R2.N.C3 + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "28a0bf356403524911fc5d722ef9d805beaef67f", "filename": "gcc/testsuite/gcc.dg/sso/t8.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft8.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init8.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.I    = My_R1.I + 1;\n+  Local_R1.N.C1 = My_R1.N.C1 + 1;\n+  Local_R1.N.C2 = My_R1.N.C2 + 1;\n+  Local_R1.N.C3 = My_R1.N.C3 + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  Local_R2.I    = My_R2.I + 1;\n+  Local_R2.N.C1 = My_R2.N.C1 + 1;\n+  Local_R2.N.C2 = My_R2.N.C2 + 1;\n+  Local_R2.N.C3 = My_R2.N.C3 + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  Local_R1.I    = 0x12345678;\n+  Local_R1.N.C1 = 0xAB0012;\n+  Local_R1.N.C2 = 0xCD0034;\n+  Local_R1.N.C3 = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2.I    = 0x12345678;\n+  Local_R2.N.C1 = 0xAB0012;\n+  Local_R2.N.C2 = 0xCD0034;\n+  Local_R2.N.C3 = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R1.I    = Local_R1.I + 1;\n+  Local_R1.N.C1 = Local_R1.N.C1 + 1;\n+  Local_R1.N.C2 = Local_R1.N.C2 + 1;\n+  Local_R1.N.C3 = Local_R1.N.C3 + 1;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" } */\n+\n+  Local_R2.I    = Local_R2.I + 1;\n+  Local_R2.N.C1 = Local_R2.N.C1 + 1;\n+  Local_R2.N.C2 = Local_R2.N.C2 + 1;\n+  Local_R2.N.C3 = Local_R2.N.C3 + 1;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "1060bb43f3c68e87eb474629c4389404a41e945f", "filename": "gcc/testsuite/gcc.dg/sso/t9.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Ft9.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init9.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+\n+  Local_R1.F = My_R1.F + 1.0;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 8c 16 22 aa fd 90 10 40\\n\" } */\n+\n+  Local_R2.F = My_R2.F + 1.0;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 10 90 fd aa 22 16 8c\\n\" } */\n+\n+  Local_R1.F = Pi;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" } */\n+\n+  Local_R2.F = Pi;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" } */\n+\n+  Local_R1.F = Local_R1.F + 1.0;\n+\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 8c 16 22 aa fd 90 10 40\\n\" } */\n+\n+  Local_R2.F = Local_R2.F + 1.0;\n+\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 40 10 90 fd aa 22 16 8c\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "01ca8b58f138bf5d9c71f86b0521cd88d3b9ea0b", "filename": "gcc/testsuite/gcc.dg/sso/u5.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fu5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fu5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fu5.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init5.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+  int C1;\n+  int C2;\n+\n+  Local_R1.I    = 1;\n+  Local_R1.A[0] = 0xAB0012;\n+  Local_R1.A[1] = 0xCD0034;\n+  Local_R1.A[2] = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 01 00 00 00 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  Local_R2.I    = 1;\n+  Local_R2.A[0] = 0xAB0012;\n+  Local_R2.A[1] = 0xCD0034;\n+  Local_R2.A[2] = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 00 00 00 01 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  C1 = Local_R1.A[Local_R1.I];\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 13434932\\n\" } */\n+\n+  Local_R1.I++;\n+  C1 = Local_R1.A[Local_R1.I];\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 15663190\\n\" } */\n+\n+  C2 = Local_R2.A[Local_R2.I];\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  Local_R2.I++;\n+  C2 = Local_R2.A[Local_R2.I];\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 15663190\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "ae8172e1ffeee3adbb3aac5b0d94737ad450815c", "filename": "gcc/testsuite/gcc.dg/sso/u6.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fu6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fu6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fu6.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#include \"init6.h\"\n+#include \"dump.h\"\n+\n+int main (void)\n+{\n+  struct R1 Local_R1;\n+  struct R2 Local_R2;\n+  int C1;\n+  int C2;\n+\n+  Local_R1.I      = 1;\n+  Local_R1.N.A[0] = 0xAB0012;\n+  Local_R1.N.A[1] = 0xCD0034;\n+  Local_R1.N.A[2] = 0xEF0056;\n+  put (\"Local_R1 :\");\n+  dump (&Local_R1, sizeof (struct R1));\n+  new_line ();\n+  /* { dg-output \"Local_R1 : 01 00 00 00 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" } */\n+\n+  Local_R2.I      = 1;\n+  Local_R2.N.A[0] = 0xAB0012;\n+  Local_R2.N.A[1] = 0xCD0034;\n+  Local_R2.N.A[2] = 0xEF0056;\n+  put (\"Local_R2 :\");\n+  dump (&Local_R2, sizeof (struct R2));\n+  new_line ();\n+  /* { dg-output \"Local_R2 : 00 00 00 01 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" } */\n+\n+  C1 = Local_R1.N.A[Local_R1.I];\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 13434932\\n\" } */\n+\n+  Local_R1.I++;\n+  C1 = Local_R1.N.A[Local_R1.I];\n+  printf (\"C1 : %d\\n\", C1);\n+  /* { dg-output \"C1 : 15663190\\n\" } */\n+\n+  C2 = Local_R2.N.A[Local_R2.I];\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 13434932\\n\" } */\n+\n+  Local_R2.I++;\n+  C2 = Local_R2.N.A[Local_R2.I];\n+  printf (\"C2 : %d\\n\", C2);\n+  /* { dg-output \"C2 : 15663190\\n\" } */\n+\n+  return 0;\n+}"}, {"sha": "985bc1eb29e715d9ce6eb9c93de1415173890c19", "filename": "gcc/testsuite/gcc.target/i386/movbe-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmovbe-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmovbe-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmovbe-3.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mmovbe\" } */\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) S\n+{\n+  int i;\n+};\n+\n+int get (struct S *s)\n+{\n+  return s->i;\n+}\n+\n+void set (struct S *s, int i)\n+{\n+  s->i = i;\n+}\n+\n+/* { dg-final { scan-assembler-times \"movbe\\[ \\t\\]\" 2 } } */"}, {"sha": "48172a5a6b9a22da655297c12dad29a500927b5a", "filename": "gcc/testsuite/gnat.dg/specs/sso1.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsso1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsso1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsso1.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,19 @@\n+-- { dg-do compile }\n+\n+with System;\n+\n+package SSO1 is\n+\n+   type R is record  -- { dg-error \"inconsistent with bit order\" }\n+      B : Boolean;\n+   end record;\n+   for R'Bit_Order use System.Low_Order_First;\n+   for R'Scalar_Storage_Order use System.High_Order_First;  -- { dg-warning \"no component clause\" }\n+\n+   type RW is record\n+      B : Boolean;\n+   end record;\n+   for RW'Bit_Order use System.Low_Order_First;\n+   for RW'Scalar_Storage_Order use System.Low_Order_First;  -- { dg-warning \"no component clause\" }\n+\n+end SSO1;"}, {"sha": "328ca6461afcecd8c002ce3d3bee2607ed855f1b", "filename": "gcc/testsuite/gnat.dg/specs/sso2.ads", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsso2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsso2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsso2.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,26 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+with System;\n+\n+package SSO2 is\n+\n+  I : Integer;\n+\n+  type Rec1 is record\n+    A : System.Address;\n+  end record;\n+  for Rec1'Bit_Order use System.High_Order_First;\n+  for Rec1'Scalar_Storage_Order use System.High_Order_First;\n+\n+  R1 : Rec1 := (A => I'Address);\n+\n+  type Rec2 is record\n+    A : System.Address;\n+  end record;\n+  for Rec2'Bit_Order use System.Low_Order_First;\n+  for Rec2'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  R2 : Rec2 := (A => I'Address);\n+\n+end SSO2;"}, {"sha": "8cdb612d0a3d3f29f65ec0f5bd4b53d53c335f3e", "filename": "gcc/testsuite/gnat.dg/sso/conv1.adb", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fconv1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fconv1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fconv1.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,50 @@\n+-- { dg-do run }\n+\n+with System; use System;\n+with Ada.Text_IO; use Ada.Text_IO;\n+\n+procedure Conv1 is\n+   type Short is mod 2**16;\n+\n+   type R_L is record\n+      S : Short;\n+      C : Character;\n+   end record;\n+   for R_L'Bit_Order use Low_Order_First;\n+   for R_L'Scalar_Storage_Order use Low_Order_First;\n+   for R_L use record\n+      S at 0 range 0 .. 15;\n+      C at 2 range 0 .. 7;\n+   end record;\n+\n+   type R_H is new R_L;\n+   for R_H'Bit_Order use High_Order_First;\n+   for R_H'Scalar_Storage_Order use High_Order_First;\n+   for R_H use record\n+      S at 0 range 0 .. 15;\n+      C at 2 range 0 .. 7;\n+   end record;\n+\n+   procedure Dump (Name : String; S : Short; C : Character) is\n+   begin\n+      Put_Line (Name & \" = (S =>\" & S'Img & \", C => '\" & C & \"')\");\n+   end Dump;\n+\n+   X_L : R_L;\n+   X_H : R_H;\n+begin\n+   X_L.S := 12345;\n+   X_L.C := 'a';\n+   Dump (\"X_L\", X_L.S, X_L.C);\n+   -- { dg-output \"X_L = \\\\(S => 12345, C => 'a'\\\\)\\n\" }\n+\n+   X_H.S := 23456;\n+   X_H.C := 'b';\n+   Dump (\"X_H\", X_H.S, X_H.C);\n+   -- { dg-output \"X_H = \\\\(S => 23456, C => 'b'\\\\)\\n\" }\n+\n+   X_H := R_H (X_L);\n+   Dump (\"X_H\", X_H.S, X_H.C);\n+   -- { dg-output \"X_H = \\\\(S => 12345, C => 'a'\\\\)\\n\" }\n+\n+end;"}, {"sha": "4e1d0ff7e9de95158b3a453fdab15ab37c24b6a9", "filename": "gcc/testsuite/gnat.dg/sso/dump.adb", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fdump.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fdump.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fdump.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,17 @@\n+-- { dg-do compile }\n+\n+with Text_IO; use Text_IO;\n+\n+procedure Dump (A : System.Address; Len : Storage_Offset) is\n+\n+   Arr : Storage_Array (1 .. Len);\n+   for Arr'Address use A;\n+   pragma Import (Ada, Arr);\n+\n+   H : constant array (Storage_Element range 0 .. 15) of Character :=\n+         \"0123456789abcdef\";\n+begin\n+   for J in Arr'Range loop\n+      Put (' ' & H (Arr (J) / 16) & H (Arr (J) mod 16));\n+   end loop;\n+end;"}, {"sha": "ce6a7fa83e6a1f3f60344b1e3752829dc7155a30", "filename": "gcc/testsuite/gnat.dg/sso/dump.ads", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fdump.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fdump.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fdump.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,3 @@\n+with System.Storage_Elements; use System.Storage_Elements;\n+\n+procedure Dump (A : System.Address; Len : Storage_Offset);"}, {"sha": "16cb6e0193d1ba60540d4ecca936c184f8d66cda", "filename": "gcc/testsuite/gnat.dg/sso/init1.ads", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit1.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,26 @@\n+with System;\n+\n+package Init1 is\n+\n+  type R1 is record\n+    I : Integer;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    I at 0 range 0 .. 31;\n+  end record;\n+\n+  type R2 is record\n+    I : Integer;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    I at 0 range 0 .. 31;\n+  end record;\n+\n+  My_R1 : constant R1 := (I => 16#12345678#);\n+  My_R2 : constant R2 := (I => 16#12345678#);\n+\n+end Init1;"}, {"sha": "a32ec7eb38e9722e7a638381eba55f762f76aef4", "filename": "gcc/testsuite/gnat.dg/sso/init10.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit10.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,23 @@\n+with System;\n+\n+package Init10 is\n+\n+  type My_Integer is new Integer;\n+  for My_Integer'Alignment use 1;\n+\n+  type R1 is record\n+    I : My_Integer;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type R2 is record\n+    I : My_Integer;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+\n+  My_R1 : constant R1 := (I => 16#12345678#);\n+  My_R2 : constant R2 := (I => 16#12345678#);\n+\n+end Init10;"}, {"sha": "a3ca4117a2fbe7d6e4a2f12f4c9d0b0e63402128", "filename": "gcc/testsuite/gnat.dg/sso/init11.ads", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit11.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,34 @@\n+with System;\n+\n+package Init11 is\n+\n+  type My_Integer is new Integer;\n+  for My_Integer'Alignment use 1;\n+\n+  type Arr1 is array (1 .. 3) of My_Integer;\n+  for Arr1'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type R1 is record\n+    I : My_Integer;\n+    A : Arr1;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type Arr2 is array (1 .. 3) of My_Integer;\n+  for Arr2'Scalar_Storage_Order use System.High_Order_First;\n+\n+  type R2 is record\n+    I : My_Integer;\n+    A : Arr2;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+\n+  My_R1 : constant R1 := (I => 16#12345678#,\n+                          A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+  My_R2 : constant R2 := (I => 16#12345678#,\n+                          A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+end Init11;"}, {"sha": "c70794b9b6abccfba3cc4f782af5962411e6f968", "filename": "gcc/testsuite/gnat.dg/sso/init12.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit12.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,25 @@\n+with System;\n+\n+package Init12 is\n+\n+  type Arr1 is array (1 .. 3) of Integer;\n+  for Arr1'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type Arr11 is array (1 .. 2, 1 .. 2) of Integer;\n+  for Arr11'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type Arr2 is array (1 .. 3) of Integer;\n+  for Arr2'Scalar_Storage_Order use System.High_Order_First;\n+\n+  type Arr22 is array (1 .. 2, 1 .. 2) of Integer;\n+  for Arr22'Scalar_Storage_Order use System.High_Order_First;\n+\n+  My_A1   : constant Arr1   := (16#AB0012#, 16#CD0034#, 16#EF0056#);\n+  My_A11  : constant Arr11  := (1 => (16#AB0012#, 16#CD0034#),\n+                                2 => (16#AB0012#, 16#CD0034#));\n+\n+  My_A2   : constant Arr2   := (16#AB0012#, 16#CD0034#, 16#EF0056#);\n+  My_A22  : constant Arr22  := (1 => (16#AB0012#, 16#CD0034#),\n+                                2 => (16#AB0012#, 16#CD0034#));\n+\n+end Init12;"}, {"sha": "9cac9e9c5672b3353220f22570a41fd629f59a28", "filename": "gcc/testsuite/gnat.dg/sso/init13.ads", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit13.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,33 @@\n+with Ada.Numerics; use Ada.Numerics;\n+with System;\n+\n+package Init13 is\n+\n+  type Complex is record\n+    R : Float;\n+    I : Float;\n+  end record;\n+  pragma Complex_Representation (Complex);\n+\n+  type R1 is record\n+    F : Complex;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    F at 0 range 0 .. 63;\n+  end record;\n+\n+  type R2 is record\n+    F : Complex;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    F at 0 range 0 .. 63;\n+  end record;\n+\n+  My_R1 : constant R1 := (F => (Pi, -Pi));\n+  My_R2 : constant R2 := (F => (Pi, -Pi));\n+\n+end Init13;"}, {"sha": "48a1962b3bd762dcde48d210c61a003304a2830b", "filename": "gcc/testsuite/gnat.dg/sso/init2.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit2.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,69 @@\n+with System;\n+\n+package Init2 is\n+\n+  type Small is mod 2**2;\n+  for Small'Size use 2;\n+\n+  type Count is mod 2**9;\n+  for Count'Size use 9;\n+\n+  type Arr1 is array (1 .. 3) of Count;\n+  pragma Pack (Arr1);\n+  for Arr1'Size use 27;\n+  for Arr1'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type R1 is record\n+    S1 : Small;\n+    I  : Integer;\n+    S2 : Small;\n+    A  : Arr1;\n+    B  : Boolean;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    S1 at 0 range  0 ..  1;\n+    I  at 0 range  2 .. 33;\n+    S2 at 0 range 34 .. 35;\n+    A  at 0 range 36 .. 62;\n+    B  at 0 range 63 .. 63;\n+  end record;\n+  for R1'Size use 64;\n+\n+  type Arr2 is array (1 .. 3) of Count;\n+  pragma Pack (Arr2);\n+  for Arr2'Size use 27;\n+  for Arr2'Scalar_Storage_Order use System.High_Order_First;\n+\n+  type R2 is record\n+    S1 : Small;\n+    I  : Integer;\n+    S2 : Small;\n+    A  : Arr2;\n+    B  : Boolean;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    S1 at 0 range  0 ..  1;\n+    I  at 0 range  2 .. 33;\n+    S2 at 0 range 34 .. 35;\n+    A  at 0 range 36 .. 62;\n+    B  at 0 range 63 .. 63;\n+  end record;\n+  for R2'Size use 64;\n+\n+  My_R1 : constant R1 := (S1 => 2,\n+                          I  => 16#12345678#,\n+                          S2 => 1,\n+                          A  => (16#AB#, 16#CD#, 16#EF#),\n+                          B  => True);\n+\n+  My_R2 : constant R2 := (S1 => 2,\n+                          I  => 16#12345678#,\n+                          S2 => 1,\n+                          A  => (16#AB#, 16#CD#, 16#EF#),\n+                          B  => True);\n+\n+end Init2;"}, {"sha": "1dd8c56c1a2bab0f0d2beae9d6a3843b44cb741c", "filename": "gcc/testsuite/gnat.dg/sso/init3.ads", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit3.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,78 @@\n+with System;\n+\n+package Init3 is\n+\n+  type Small is mod 2**2;\n+  for Small'Size use 2;\n+\n+  type Count is mod 2**9;\n+  for Count'Size use 9;\n+\n+  type Nested1 is record\n+    C1 : Count;\n+    C2 : Count;\n+    C3 : Count;\n+  end record;\n+  pragma Pack (Nested1);\n+  for Nested1'Size use 27;\n+  for Nested1'Bit_Order use System.Low_Order_First;\n+  for Nested1'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type R1 is record\n+    S1 : Small;\n+    I  : Integer;\n+    S2 : Small;\n+    N  : Nested1;\n+    B  : Boolean;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    S1 at 0 range  0 ..  1;\n+    I  at 0 range  2 .. 33;\n+    S2 at 0 range 34 .. 35;\n+    N  at 0 range 36 .. 62;\n+    B  at 0 range 63 .. 63;\n+  end record;\n+  for R1'Size use 64;\n+\n+  type Nested2 is record\n+    C1 : Count;\n+    C2 : Count;\n+    C3 : Count;\n+  end record;\n+  pragma Pack (Nested2);\n+  for Nested2'Size use 27;\n+  for Nested2'Bit_Order use System.High_Order_First;\n+  for Nested2'Scalar_Storage_Order use System.High_Order_First;\n+  type R2 is record\n+    S1 : Small;\n+    I  : Integer;\n+    S2 : Small;\n+    N  : Nested2;\n+    B  : Boolean;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    S1 at 0 range  0 ..  1;\n+    I  at 0 range  2 .. 33;\n+    S2 at 0 range 34 .. 35;\n+    N  at 0 range 36 .. 62;\n+    B  at 0 range 63 .. 63;\n+  end record;\n+  for R2'Size use 64;\n+\n+  My_R1 : constant R1 := (S1 => 2,\n+                          I  => 16#12345678#,\n+                          S2 => 1,\n+                          N  => (16#AB#, 16#CD#, 16#EF#),\n+                          B  => True);\n+\n+  My_R2 : constant R2 := (S1 => 2,\n+                          I  => 16#12345678#,\n+                          S2 => 1,\n+                          N  => (16#AB#, 16#CD#, 16#EF#),\n+                          B  => True);\n+\n+end Init3;"}, {"sha": "f533a8e8514ff0b789595835d9302d0a25c151d4", "filename": "gcc/testsuite/gnat.dg/sso/init4.ads", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit4.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,27 @@\n+with Ada.Numerics; use Ada.Numerics;\n+with System;\n+\n+package Init4 is\n+\n+  type R1 is record\n+    F : Float;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    F at 0 range 0 .. 31;\n+  end record;\n+\n+  type R2 is record\n+    F : Float;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    F at 0 range 0 .. 31;\n+  end record;\n+\n+  My_R1 : constant R1 := (F => Pi);\n+  My_R2 : constant R2 := (F => Pi);\n+\n+end Init4;"}, {"sha": "3ea8d1162a016c172282934afdc344ba4cc7741b", "filename": "gcc/testsuite/gnat.dg/sso/init5.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit5.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,39 @@\n+with System;\n+\n+package Init5 is\n+\n+  type Arr1 is array (1 .. 3) of Integer;\n+  for Arr1'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type R1 is record\n+    I : Integer;\n+    A : Arr1;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    I at 0 range 0 .. 31;\n+    A at 4 range 0 .. 95;\n+  end record;\n+\n+  type Arr2 is array (1 .. 3) of Integer;\n+  for Arr2'Scalar_Storage_Order use System.High_Order_First;\n+\n+  type R2 is record\n+    I : Integer;\n+    A : Arr2;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    I at 0 range 0 .. 31;\n+    A at 4 range 0 .. 95;\n+  end record;\n+\n+  My_R1 : constant R1 := (I => 16#12345678#,\n+                          A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+  My_R2 : constant R2 := (I => 16#12345678#,\n+                          A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+end Init5;"}, {"sha": "81351c1267d124cd9436ed460a8c38b894f05c2e", "filename": "gcc/testsuite/gnat.dg/sso/init6.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit6.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,39 @@\n+with System;\n+\n+package Init6 is\n+\n+  type Arr1 is array (1 .. 3) of Integer;\n+  for Arr1'Scalar_Storage_Order use System.High_Order_First;\n+\n+  type R1 is record\n+    I : Integer;\n+    A : Arr1;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    I at 0 range 0 .. 31;\n+    A at 4 range 0 .. 95;\n+  end record;\n+\n+  type Arr2 is array (1 .. 3) of Integer;\n+  for Arr2'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  type R2 is record\n+    I : Integer;\n+    A : Arr2;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    I at 0 range 0 .. 31;\n+    A at 4 range 0 .. 95;\n+  end record;\n+\n+  My_R1 : constant R1 := (I => 16#12345678#,\n+                          A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+  My_R2 : constant R2 := (I => 16#12345678#,\n+                          A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+end Init6;"}, {"sha": "a7965250d98612d9bd70bd67db7381e121e6cf95", "filename": "gcc/testsuite/gnat.dg/sso/init7.ads", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit7.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,59 @@\n+with System;\n+\n+package Init7 is\n+\n+  type Nested1 is record\n+    C1 : Integer;\n+    C2 : Integer;\n+    C3 : Integer;\n+  end record;\n+  for Nested1'Bit_Order use System.Low_Order_First;\n+  for Nested1'Scalar_Storage_Order use System.Low_Order_First;\n+  for Nested1 use record\n+    C1 at 0 range 0 .. 31;\n+    C2 at 4 range 0 .. 31;\n+    C3 at 8 range 0 .. 31;\n+  end record;\n+\n+  type R1 is record\n+    I : Integer;\n+    N : Nested1;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    I at 0 range 0 .. 31;\n+    N at 4 range 0 .. 95;\n+  end record;\n+\n+  type Nested2 is record\n+    C1 : Integer;\n+    C2 : Integer;\n+    C3 : Integer;\n+  end record;\n+  for Nested2'Bit_Order use System.High_Order_First;\n+  for Nested2'Scalar_Storage_Order use System.High_Order_First;\n+  for Nested2 use record\n+    C1 at 0 range 0 .. 31;\n+    C2 at 4 range 0 .. 31;\n+    C3 at 8 range 0 .. 31;\n+  end record;\n+\n+  type R2 is record\n+    I : Integer;\n+    N : Nested2;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    I at 0 range 0 .. 31;\n+    N at 4 range 0 .. 95;\n+  end record;\n+\n+  My_R1 : constant R1 := (I => 16#12345678#,\n+                          N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+  My_R2 : constant R2 := (I => 16#12345678#,\n+                          N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+end Init7;"}, {"sha": "ce912f6e0a0ae23ab0306d3adf393952c84458ef", "filename": "gcc/testsuite/gnat.dg/sso/init8.ads", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit8.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,59 @@\n+with System;\n+\n+package Init8 is\n+\n+  type Nested1 is record\n+    C1 : Integer;\n+    C2 : Integer;\n+    C3 : Integer;\n+  end record;\n+  for Nested1'Bit_Order use System.High_Order_First;\n+  for Nested1'Scalar_Storage_Order use System.High_Order_First;\n+  for Nested1 use record\n+    C1 at 0 range 0 .. 31;\n+    C2 at 4 range 0 .. 31;\n+    C3 at 8 range 0 .. 31;\n+  end record;\n+\n+  type R1 is record\n+    I : Integer;\n+    N : Nested1;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    I at 0 range 0 .. 31;\n+    N at 4 range 0 .. 95;\n+  end record;\n+\n+  type Nested2 is record\n+    C1 : Integer;\n+    C2 : Integer;\n+    C3 : Integer;\n+  end record;\n+  for Nested2'Bit_Order use System.Low_Order_First;\n+  for Nested2'Scalar_Storage_Order use System.Low_Order_First;\n+  for Nested2 use record\n+    C1 at 0 range 0 .. 31;\n+    C2 at 4 range 0 .. 31;\n+    C3 at 8 range 0 .. 31;\n+  end record;\n+\n+  type R2 is record\n+    I : Integer;\n+    N : Nested2;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    I at 0 range 0 .. 31;\n+    N at 4 range 0 .. 95;\n+  end record;\n+\n+  My_R1 : constant R1 := (I => 16#12345678#,\n+                          N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+  My_R2 : constant R2 := (I => 16#12345678#,\n+                          N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+\n+end Init8;"}, {"sha": "b8d8c8bd7022fe920649b0d31ba026f3993113de", "filename": "gcc/testsuite/gnat.dg/sso/init9.ads", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Finit9.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,27 @@\n+with Ada.Numerics; use Ada.Numerics;\n+with System;\n+\n+package Init9 is\n+\n+  type R1 is record\n+    F : Long_Float;\n+  end record;\n+  for R1'Bit_Order use System.Low_Order_First;\n+  for R1'Scalar_Storage_Order use System.Low_Order_First;\n+  for R1 use record\n+    F at 0 range 0 .. 63;\n+  end record;\n+\n+  type R2 is record\n+    F : Long_Float;\n+  end record;\n+  for R2'Bit_Order use System.High_Order_First;\n+  for R2'Scalar_Storage_Order use System.High_Order_First;\n+  for R2 use record\n+    F at 0 range 0 .. 63;\n+  end record;\n+\n+  My_R1 : constant R1 := (F => Pi);\n+  My_R2 : constant R2 := (F => Pi);\n+\n+end Init9;"}, {"sha": "514fa7eeda34d41d3b1cc201f98c7de79471a33f", "filename": "gcc/testsuite/gnat.dg/sso/p1.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp1.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,62 @@\n+-- { dg-do run }\n+\n+with Init1; use Init1;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P1 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 78 56 34 12\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 12 34 56 78\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+\n+  Local_R1.I := 16#12345678#;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2.I := 16#12345678#;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+\n+  Local_R1.I := Local_R2.I;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2.I := Local_R1.I;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+end;"}, {"sha": "067a57ece317384efd0780907fdfa63e3db62253", "filename": "gcc/testsuite/gnat.dg/sso/p10.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp10.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,63 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+\n+with Init10; use Init10;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P10 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 78 56 34 12\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 12 34 56 78\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+\n+  Local_R1.I := 16#12345678#;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2.I := 16#12345678#;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+\n+  Local_R1.I := Local_R2.I;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2.I := Local_R1.I;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+end;"}, {"sha": "c6f6166473e4bfa2e1ae063c4d0c5170ba934bf0", "filename": "gcc/testsuite/gnat.dg/sso/p11.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp11.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init11; use Init11;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P11 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1.I    := Local_R2.I;\n+  Local_R1.A(1) := Local_R2.A(1);\n+  Local_R1.A(2) := Local_R2.A(2);\n+  Local_R1.A(3) := Local_R2.A(3);\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2.I    := Local_R1.I;\n+  Local_R2.A(1) := Local_R1.A(1);\n+  Local_R2.A(2) := Local_R1.A(2);\n+  Local_R2.A(3) := Local_R1.A(3);\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+end;"}, {"sha": "03e5e65e9f60294d491c592b9f4c67718b6644f4", "filename": "gcc/testsuite/gnat.dg/sso/p12.adb", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp12.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,122 @@\n+-- { dg-do run }\n+\n+with Init12; use Init12;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P12 is\n+\n+  Local_A1  : Arr1;\n+  Local_A11 : Arr11;\n+  Local_A2  : Arr2;\n+  Local_A22 : Arr22;\n+\n+begin\n+  Put (\"My_A1     :\");\n+  Dump (My_A1'Address, Arr1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_A1     : 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"My_A11    :\");\n+  Dump (My_A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_A11    : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Put (\"My_A2     :\");\n+  Dump (My_A2'Address, Arr2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_A2     : 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"My_A22    :\");\n+  Dump (My_A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_A22    : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+\n+  Local_A1 := My_A1;\n+  Put (\"Local_A1  :\");\n+  Dump (Local_A1'Address, Arr1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A1  : 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_A11 := My_A11;\n+  Put (\"Local_A11 :\");\n+  Dump (Local_A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Local_A2 := My_A2;\n+  Put (\"Local_A2  :\");\n+  Dump (Local_A2'Address, Arr2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A2  : 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_A22 := My_A22;\n+  Put (\"Local_A22 :\");\n+  Dump (Local_A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+\n+  Local_A1 := (16#AB0012#, 16#CD0034#, 16#EF0056#);\n+  Put (\"Local_A1  :\");\n+  Dump (Local_A1'Address, Arr1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A1  : 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_A11 := (1 => (16#AB0012#, 16#CD0034#),\n+                2 => (16#AB0012#, 16#CD0034#));\n+  Put (\"Local_A11 :\");\n+  Dump (Local_A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Local_A2 := (16#AB0012#, 16#CD0034#, 16#EF0056#);\n+  Put (\"Local_A2  :\");\n+  Dump (Local_A2'Address, Arr2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A2  : 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_A22 := (1 => (16#AB0012#, 16#CD0034#),\n+                2 => (16#AB0012#, 16#CD0034#));\n+  Put (\"Local_A22 :\");\n+  Dump (Local_A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+\n+  Local_A1(1) := Local_A2(1);\n+  Local_A1(2) := Local_A2(2);\n+  Local_A1(3) := Local_A2(3);\n+\n+  Put (\"Local_A1  :\");\n+  Dump (Local_A1'Address, Arr1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A1  : 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_A11(1,1) := Local_A22(1,1);\n+  Local_A11(1,2) := Local_A22(1,2);\n+  Local_A11(2,1) := Local_A22(2,1);\n+  Local_A11(2,2) := Local_A22(2,2);\n+\n+  Put (\"Local_A11 :\");\n+  Dump (Local_A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Local_A2(1) := Local_A1(1);\n+  Local_A2(2) := Local_A1(2);\n+  Local_A2(3) := Local_A1(3);\n+\n+  Put (\"Local_A2  :\");\n+  Dump (Local_A2'Address, Arr2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A2  : 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_A22(1,1) := Local_A11(1,1);\n+  Local_A22(1,2) := Local_A11(1,2);\n+  Local_A22(2,1) := Local_A11(2,1);\n+  Local_A22(2,2) := Local_A11(2,2);\n+\n+  Put (\"Local_A22 :\");\n+  Dump (Local_A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+end;"}, {"sha": "49db1114c68e3350fe880ac23dfb1d679e774e4e", "filename": "gcc/testsuite/gnat.dg/sso/p13.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp13.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,63 @@\n+-- { dg-do run }\n+\n+with Init13; use Init13;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P13 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : db 0f 49 40 db 0f 49 c0\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 40 49 0f db c0 49 0f db\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" }\n+\n+  Local_R1.F := (Pi, -Pi);\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" }\n+\n+  Local_R2.F := (Pi, -Pi);\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" }\n+\n+  Local_R1.F := Local_R2.F;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" }\n+\n+  Local_R2.F := Local_R1.F;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" }\n+end;"}, {"sha": "5312e0aac342a8ea4de0a556893a8feed15dd2e8", "filename": "gcc/testsuite/gnat.dg/sso/p2.adb", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp2.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,80 @@\n+-- { dg-do run }\n+\n+with Init2; use Init2;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P2 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               A  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               A  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1.S1   := Local_R2.S1;\n+  Local_R1.I    := Local_R2.I;\n+  Local_R1.S2   := Local_R2.S2;\n+  Local_R1.A(1) := Local_R2.A(1);\n+  Local_R1.A(2) := Local_R2.A(2);\n+  Local_R1.A(3) := Local_R2.A(3);\n+  Local_R1.B    := Local_R2.B;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2.S1   := Local_R1.S1;\n+  Local_R2.I    := Local_R1.I;\n+  Local_R2.S2   := Local_R1.S2;\n+  Local_R2.A(1) := Local_R1.A(1);\n+  Local_R2.A(2) := Local_R1.A(2);\n+  Local_R2.A(3) := Local_R1.A(3);\n+  Local_R2.B    := Local_R1.B;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+end;"}, {"sha": "c138f2416d9d4ad1b65ac0b0e3f301432eceba77", "filename": "gcc/testsuite/gnat.dg/sso/p3.adb", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp3.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,80 @@\n+-- { dg-do run }\n+\n+with Init3; use Init3;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P3 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               N  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               N  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1.S1   := Local_R2.S1;\n+  Local_R1.I    := Local_R2.I;\n+  Local_R1.S2   := Local_R2.S2;\n+  Local_R1.N.C1 := Local_R2.N.C1;\n+  Local_R1.N.C2 := Local_R2.N.C2;\n+  Local_R1.N.C3 := Local_R2.N.C3;\n+  Local_R1.B    := Local_R2.B;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2.S1   := Local_R1.S1;\n+  Local_R2.I    := Local_R1.I;\n+  Local_R2.S2   := Local_R1.S2;\n+  Local_R2.N.C1 := Local_R1.N.C1;\n+  Local_R2.N.C2 := Local_R1.N.C2;\n+  Local_R2.N.C3 := Local_R1.N.C3;\n+  Local_R2.B    := Local_R1.B;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+end;"}, {"sha": "a22c0449e08080439755f8b3ea9f56c2e7362c7a", "filename": "gcc/testsuite/gnat.dg/sso/p4.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp4.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,63 @@\n+-- { dg-do run }\n+\n+with Init4; use Init4;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P4 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : db 0f 49 40\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 40 49 0f db\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db\\n\" }\n+\n+  Local_R1.F := Pi;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40\\n\" }\n+\n+  Local_R2.F := Pi;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db\\n\" }\n+\n+  Local_R1.F := Local_R2.F;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40\\n\" }\n+\n+  Local_R2.F := Local_R1.F;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db\\n\" }\n+end;"}, {"sha": "6a692ae53644c7c8d906b0dfc6fff573ea42bdd6", "filename": "gcc/testsuite/gnat.dg/sso/p5.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp5.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init5; use Init5;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P5 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1.I    := Local_R2.I;\n+  Local_R1.A(1) := Local_R2.A(1);\n+  Local_R1.A(2) := Local_R2.A(2);\n+  Local_R1.A(3) := Local_R2.A(3);\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2.I    := Local_R1.I;\n+  Local_R2.A(1) := Local_R1.A(1);\n+  Local_R2.A(2) := Local_R1.A(2);\n+  Local_R2.A(3) := Local_R1.A(3);\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+end;"}, {"sha": "35c1b1a201e4c863339ce7827744d3f202f9aa78", "filename": "gcc/testsuite/gnat.dg/sso/p6.adb", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp6.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,61 @@\n+-- { dg-do run }\n+\n+with Init6; use Init6;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P6 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R1 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R2 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R1.I    := Local_R2.I;\n+  Local_R1.A(1) := Local_R2.A(1);\n+  Local_R1.A(2) := Local_R2.A(2);\n+  Local_R1.A(3) := Local_R2.A(3);\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R2.I    := Local_R1.I;\n+  Local_R2.A(1) := Local_R1.A(1);\n+  Local_R2.A(2) := Local_R1.A(2);\n+  Local_R2.A(3) := Local_R1.A(3);\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+end;"}, {"sha": "01354befbab1a4bca91b544ad10d99d15901d942", "filename": "gcc/testsuite/gnat.dg/sso/p7.adb", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp7.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,61 @@\n+-- { dg-do run }\n+\n+with Init7; use Init7;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P7 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R1 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R2 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R1.I    := Local_R2.I;\n+  Local_R1.N.C1 := Local_R2.N.C1;\n+  Local_R1.N.C2 := Local_R2.N.C2;\n+  Local_R1.N.C3 := Local_R2.N.C3;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R2.I    := Local_R1.I;\n+  Local_R2.N.C1 := Local_R1.N.C1;\n+  Local_R2.N.C2 := Local_R1.N.C2;\n+  Local_R2.N.C3 := Local_R1.N.C3;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+end;"}, {"sha": "e6f80e4029c65c1137cc6dcd64f69b99c963721c", "filename": "gcc/testsuite/gnat.dg/sso/p8.adb", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp8.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,61 @@\n+-- { dg-do run }\n+\n+with Init8; use Init8;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P8 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R1 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R2 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+  Local_R1.I    := Local_R2.I;\n+  Local_R1.N.C1 := Local_R2.N.C1;\n+  Local_R1.N.C2 := Local_R2.N.C2;\n+  Local_R1.N.C3 := Local_R2.N.C3;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+  Local_R2.I    := Local_R1.I;\n+  Local_R2.N.C1 := Local_R1.N.C1;\n+  Local_R2.N.C2 := Local_R1.N.C2;\n+  Local_R2.N.C3 := Local_R1.N.C3;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+end;"}, {"sha": "1aab12b604b9ac4bc4ca21242831f4b4be4e85c7", "filename": "gcc/testsuite/gnat.dg/sso/p9.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fp9.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,63 @@\n+-- { dg-do run }\n+\n+with Init9; use Init9;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure P9 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Put (\"My_R1    :\");\n+  Dump (My_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R1    : 18 2d 44 54 fb 21 09 40\\n\" }\n+\n+  Put (\"My_R2    :\");\n+  Dump (My_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"My_R2    : 40 09 21 fb 54 44 2d 18\\n\" }\n+\n+  Local_R1 := My_R1;\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" }\n+\n+  Local_R2 := My_R2;\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" }\n+\n+  Local_R1.F := Pi;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" }\n+\n+  Local_R2.F := Pi;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" }\n+\n+  Local_R1.F := Local_R2.F;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" }\n+\n+  Local_R2.F := Local_R1.F;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" }\n+end;"}, {"sha": "6c8303cf981af2d8816d85dbf0ac1665020b9580", "filename": "gcc/testsuite/gnat.dg/sso/q1.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq1.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,52 @@\n+-- { dg-do run }\n+\n+with Init1; use Init1;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q1 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 78 56 34 12\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 12 34 56 78\\n\" }\n+\n+  if A1.I /= B1.I then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.I /= 16#12345678# then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= 16#12345678# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "94d21522d0ddc937c8f0d3c4e49e3ca634dba988", "filename": "gcc/testsuite/gnat.dg/sso/q10.adb", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq10.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,53 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+\n+with Init10; use Init10;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q10 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 78 56 34 12\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 12 34 56 78\\n\" }\n+\n+  if A1.I /= B1.I then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.I /= 16#12345678# then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= 16#12345678# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "84951de3019bcf08dc8f4d50fa5bb2370820cbbb", "filename": "gcc/testsuite/gnat.dg/sso/q11.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq11.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init11; use Init11;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q11 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\"} \n+\n+  if A1.I /= B1.I or A1.A(1) /= B1.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I or A2.A(1) /= B2.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "2018582607f377a39c048e2019f255e0480ed445", "filename": "gcc/testsuite/gnat.dg/sso/q12.adb", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq12.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,43 @@\n+-- { dg-do run }\n+\n+with Init12; use Init12;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q12 is\n+\n+  A1  : Arr1  := My_A1;\n+  A11 : Arr11 := My_A11;\n+\n+  A2  : Arr2  := My_A2;\n+  A22 : Arr22 := My_A22;\n+\n+begin\n+  Put (\"A1  :\");\n+  Dump (A1'Address, Arr1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1  : 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A11 :\");\n+  Dump (A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Put (\"A2  :\");\n+  Dump (A2'Address, Arr2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2  : 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A22 :\");\n+  Dump (A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+\n+  if A1(1) /= A11(1,1) then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2(1) /= A22(1,1) then\n+    raise Program_Error;\n+  end if;\n+end;"}, {"sha": "e07530fb2aac34be49184d905d13d932552846c9", "filename": "gcc/testsuite/gnat.dg/sso/q13.adb", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq13.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,53 @@\n+-- { dg-do run }\n+\n+with Init13; use Init13;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q13 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : db 0f 49 40 db 0f 49 c0\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : db 0f 49 40 db 0f 49 c0\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 40 49 0f db c0 49 0f db\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 40 49 0f db c0 49 0f db\\n\" }\n+\n+  if A1.F /= B1.F then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.F /= (Pi, -Pi) then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.F /= B2.F then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.F /= (Pi, -Pi) then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "be11fe15294b7aaab04b81fd8152ceef27573181", "filename": "gcc/testsuite/gnat.dg/sso/q2.adb", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq2.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,60 @@\n+-- { dg-do run }\n+\n+with Init2; use Init2;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q2 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  if A1.S1 /= B1.S1 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.S1 /= 2 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.S1 /= B2.S1 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.S1 /= 2 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.I /= B1.I or A1.A(1) /= B1.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I or A2.A(1) /= B2.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "383a88b6125d7dae501ff0f789d22c2ac46c1189", "filename": "gcc/testsuite/gnat.dg/sso/q3.adb", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq3.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,60 @@\n+-- { dg-do run }\n+\n+with Init3; use Init3;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q3 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  if A1.S1 /= B1.S1 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.S1 /= 2 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.S1 /= B2.S1 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.S1 /= 2 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.I /= B1.I or A1.N.C1 /= B1.N.C1 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I or A2.N.C1 /= B2.N.C1 then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "0cef27de2193b919facc52f52ab2f8fcff8b538b", "filename": "gcc/testsuite/gnat.dg/sso/q4.adb", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq4.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,53 @@\n+-- { dg-do run }\n+\n+with Init4; use Init4;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q4 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : db 0f 49 40\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : db 0f 49 40\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 40 49 0f db\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 40 49 0f db\\n\" }\n+\n+  if A1.F /= B1.F then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.F /= Pi then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.F /= B2.F then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.F /= Pi then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "965d145f680860313959102ec9d670949b3dcd86", "filename": "gcc/testsuite/gnat.dg/sso/q5.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq5.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init5; use Init5;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q5 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\"} \n+\n+  if A1.I /= B1.I or A1.A(1) /= B1.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I or A2.A(1) /= B2.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "f90b32f623db5243d58222b355bc3b816bfdcfdb", "filename": "gcc/testsuite/gnat.dg/sso/q6.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq6.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init6; use Init6;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q6 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  if A1.I /= B1.I or A1.A(1) /= B1.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I or A2.A(1) /= B2.A(1) then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "72ab6106ad582e631be2daa3cd573cb92e7dbb13", "filename": "gcc/testsuite/gnat.dg/sso/q7.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq7.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init7; use Init7;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q7 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  if A1.I /= B1.I or A1.N.C1 /= B1.N.C1 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I or A2.N.C1 /= B2.N.C1 then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "7931179d6f17eb6a0f77d04cfe9d35f8482ca454", "filename": "gcc/testsuite/gnat.dg/sso/q8.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq8.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init8; use Init8;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q8 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  if A1.I /= B1.I or A1.N.C1 /= B1.N.C1 then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.I /= B2.I or A2.N.C1 /= B2.N.C1 then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "f5d4a559a426cfd5404cbc4b2a581964cc442be1", "filename": "gcc/testsuite/gnat.dg/sso/q9.adb", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fq9.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,53 @@\n+-- { dg-do run }\n+\n+with Init9; use Init9;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure Q9 is\n+\n+  A1 : R1 := My_R1;\n+  B1 : R1 := My_R1;\n+\n+  A2 : R2 := My_R2;\n+  B2 : R2 := My_R2;\n+\n+begin\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 18 2d 44 54 fb 21 09 40\\n\" }\n+\n+  Put (\"B1 :\");\n+  Dump (B1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B1 : 18 2d 44 54 fb 21 09 40\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 40 09 21 fb 54 44 2d 18\\n\" }\n+\n+  Put (\"B2 :\");\n+  Dump (B2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"B2 : 40 09 21 fb 54 44 2d 18\\n\" }\n+\n+  if A1.F /= B1.F then\n+    raise Program_Error;\n+  end if;\n+\n+  if A1.F /= Pi then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.F /= B2.F then\n+    raise Program_Error;\n+  end if;\n+\n+  if A2.F /= Pi then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "e472078c5c655c15864d9b4e2e8828039fc9eb29", "filename": "gcc/testsuite/gnat.dg/sso/r11.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr11.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init11; use Init11;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure R11 is\n+\n+  function Get_Elem (R : R1) return My_Integer is\n+    Tmp : R1 := R;\n+  begin\n+    return Tmp.A(1);\n+  end;\n+\n+  procedure Set_Elem (R : access R1; I : My_Integer) is\n+    Tmp : R1 := R.all;\n+  begin\n+    Tmp.A(1) := I;\n+    R.all := Tmp;\n+  end;\n+\n+  function Get_Elem (R : R2) return My_Integer is\n+    Tmp : R2 := R;\n+  begin\n+    return Tmp.A(1);\n+  end;\n+\n+  procedure Set_Elem (R : access R2; I : My_Integer) is\n+    Tmp : R2 := R.all;\n+  begin\n+    Tmp.A(1) := I;\n+    R.all := Tmp;\n+  end;\n+\n+  A1 : aliased R1 := My_R1;\n+  A2 : aliased R2 := My_R2;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  if Get_Elem (A1) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A1'Access, 16#CD0034#);\n+  if Get_Elem (A1) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A2) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A2'Access, 16#CD0034#);\n+  if Get_Elem (A2) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "b6e2cf76189015bc53796735e331e8ec87a5a1eb", "filename": "gcc/testsuite/gnat.dg/sso/r12.adb", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr12.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,123 @@\n+-- { dg-do run }\n+\n+with Init12; use Init12;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure R12 is\n+\n+  function Get_Elem (A : Arr1) return Integer is\n+    Tmp : Arr1 := A;\n+  begin\n+    return Tmp(1);\n+  end;\n+\n+  procedure Set_Elem (A : access Arr1; I : Integer) is\n+    Tmp : Arr1 := A.all;\n+  begin\n+    Tmp(1) := I;\n+    A.all := Tmp;\n+  end;\n+\n+  function Get_Elem (A : Arr11) return Integer is\n+    Tmp : Arr11 := A;\n+  begin\n+    return Tmp(1,1);\n+  end;\n+\n+  procedure Set_Elem (A : access Arr11; I : Integer) is\n+    Tmp : Arr11 := A.all;\n+  begin\n+    Tmp(1,1) := I;\n+    A.all := Tmp;\n+  end;\n+\n+  function Get_Elem (A : Arr2) return Integer is\n+    Tmp : Arr2 := A;\n+  begin\n+    return Tmp(1);\n+  end;\n+\n+  procedure Set_Elem (A : access Arr2; I : Integer) is\n+    Tmp : Arr2 := A.all;\n+  begin\n+    Tmp(1) := I;\n+    A.all := Tmp;\n+  end;\n+\n+  function Get_Elem (A : Arr22) return Integer is\n+    Tmp : Arr22 := A;\n+  begin\n+    return Tmp(1,1);\n+  end;\n+\n+  procedure Set_Elem (A : access Arr22; I : Integer) is\n+    Tmp : Arr22 := A.all;\n+  begin\n+    Tmp(1,1) := I;\n+    A.all := Tmp;\n+  end;\n+\n+  A1  : aliased Arr1  := My_A1;\n+  A11 : aliased Arr11 := My_A11;\n+\n+  A2  : aliased Arr2  := My_A2;\n+  A22 : aliased Arr22 := My_A22;\n+\n+begin\n+  Put (\"A1  :\");\n+  Dump (A1'Address, Arr1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1  : 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A11 :\");\n+  Dump (A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Put (\"A2  :\");\n+  Dump (A2'Address, Arr2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2  : 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A22 :\");\n+  Dump (A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+\n+  if Get_Elem (A1) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A1'Access, 16#CD0034#);\n+  if Get_Elem (A1) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A11) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A11'Access, 16#CD0034#);\n+  if Get_Elem (A11) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A2) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A2'Access, 16#CD0034#);\n+  if Get_Elem (A2) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A22) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A22'Access, 16#CD0034#);\n+  if Get_Elem (A22) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+end;"}, {"sha": "746109688c90ca9018265b8bcbdb59f8f2c14b50", "filename": "gcc/testsuite/gnat.dg/sso/r3.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr3.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init3; use Init3;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure R3 is\n+\n+  function Get_Elem (R : R1) return Integer is\n+    Tmp : R1 := R;\n+  begin\n+    return Tmp.I;\n+  end;\n+\n+  procedure Set_Elem (R : access R1; I : Integer) is\n+    Tmp : R1 := R.all;\n+  begin\n+    Tmp.I := I;\n+    R.all := Tmp;\n+  end;\n+\n+  function Get_Elem (R : R2) return Integer is\n+    Tmp : R2 := R;\n+  begin\n+    return Tmp.I;\n+  end;\n+\n+  procedure Set_Elem (R : access R2; I : Integer) is\n+    Tmp : R2 := R.all;\n+  begin\n+    Tmp.I := I;\n+    R.all := Tmp;\n+  end;\n+\n+  A1 : aliased R1 := My_R1;\n+  A2 : aliased R2 := My_R2;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  --  { dg-output \"A1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  if Get_Elem (A1) /= 16#12345678# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A1'Access, 16#CD0034#);\n+  if Get_Elem (A1) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A2) /= 16#12345678# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A2'Access, 16#CD0034#);\n+  if Get_Elem (A2) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "6dcb87f8b6e69719e7ff80d86eef992dedae1772", "filename": "gcc/testsuite/gnat.dg/sso/r5.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr5.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init5; use Init5;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure R5 is\n+\n+  function Get_Elem (R : R1) return Integer is\n+    Tmp : R1 := R;\n+  begin\n+    return Tmp.A(1);\n+  end;\n+\n+  procedure Set_Elem (R : access R1; I : Integer) is\n+    Tmp : R1 := R.all;\n+  begin\n+    Tmp.A(1) := I;\n+    R.all := Tmp;\n+  end;\n+\n+  function Get_Elem (R : R2) return Integer is\n+    Tmp : R2 := R;\n+  begin\n+    return Tmp.A(1);\n+  end;\n+\n+  procedure Set_Elem (R : access R2; I : Integer) is\n+    Tmp : R2 := R.all;\n+  begin\n+    Tmp.A(1) := I;\n+    R.all := Tmp;\n+  end;\n+\n+  A1 : aliased R1 := My_R1;\n+  A2 : aliased R2 := My_R2;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  if Get_Elem (A1) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A1'Access, 16#CD0034#);\n+  if Get_Elem (A1) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A2) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A2'Access, 16#CD0034#);\n+  if Get_Elem (A2) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "5ef59893552ed98f4a359feb041e45ef1890c89d", "filename": "gcc/testsuite/gnat.dg/sso/r6.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr6.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init6; use Init6;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure R6 is\n+\n+  function Get_Elem (R : R1) return Integer is\n+    Tmp : R1 := R;\n+  begin\n+    return Tmp.A(1);\n+  end;\n+\n+  procedure Set_Elem (R : access R1; I : Integer) is\n+    Tmp : R1 := R.all;\n+  begin\n+    Tmp.A(1) := I;\n+    R.all := Tmp;\n+  end;\n+\n+  function Get_Elem (R : R2) return Integer is\n+    Tmp : R2 := R;\n+  begin\n+    return Tmp.A(1);\n+  end;\n+\n+  procedure Set_Elem (R : access R2; I : Integer) is\n+    Tmp : R2 := R.all;\n+  begin\n+    Tmp.A(1) := I;\n+    R.all := Tmp;\n+  end;\n+\n+  A1 : aliased R1 := My_R1;\n+  A2 : aliased R2 := My_R2;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  if Get_Elem (A1) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A1'Access, 16#CD0034#);\n+  if Get_Elem (A1) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A2) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A2'Access, 16#CD0034#);\n+  if Get_Elem (A2) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "58a015beb157c5994e9001b01ebd28640d0b876c", "filename": "gcc/testsuite/gnat.dg/sso/r7.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr7.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init7; use Init7;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure R7 is\n+\n+  function Get_Elem (R : R1) return Integer is\n+    Tmp : R1 := R;\n+  begin\n+    return Tmp.N.C1;\n+  end;\n+\n+  procedure Set_Elem (R : access R1; I : Integer) is\n+    Tmp : R1 := R.all;\n+  begin\n+    Tmp.N.C1 := I;\n+    R.all := Tmp;\n+  end;\n+\n+  function Get_Elem (R : R2) return Integer is\n+    Tmp : R2 := R;\n+  begin\n+    return Tmp.N.C1;\n+  end;\n+\n+  procedure Set_Elem (R : access R2; I : Integer) is\n+    Tmp : R2 := R.all;\n+  begin\n+    Tmp.N.C1 := I;\n+    R.all := Tmp;\n+  end;\n+\n+  A1 : aliased R1 := My_R1;\n+  A2 : aliased R2 := My_R2;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  if Get_Elem (A1) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A1'Access, 16#CD0034#);\n+  if Get_Elem (A1) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A2) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A2'Access, 16#CD0034#);\n+  if Get_Elem (A2) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "cbb1d5b617df884d0c02a8cfa9450ebd82ca8198", "filename": "gcc/testsuite/gnat.dg/sso/r8.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fr8.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init8; use Init8;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure R8 is\n+\n+  function Get_Elem (R : R1) return Integer is\n+    Tmp : R1 := R;\n+  begin\n+    return Tmp.N.C1;\n+  end;\n+\n+  procedure Set_Elem (R : access R1; I : Integer) is\n+    Tmp : R1 := R.all;\n+  begin\n+    Tmp.N.C1 := I;\n+    R.all := Tmp;\n+  end;\n+\n+  function Get_Elem (R : R2) return Integer is\n+    Tmp : R2 := R;\n+  begin\n+    return Tmp.N.C1;\n+  end;\n+\n+  procedure Set_Elem (R : access R2; I : Integer) is\n+    Tmp : R2 := R.all;\n+  begin\n+    Tmp.N.C1 := I;\n+    R.all := Tmp;\n+  end;\n+\n+  A1 : aliased R1 := My_R1;\n+  A2 : aliased R2 := My_R2;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  if Get_Elem (A1) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A1'Access, 16#CD0034#);\n+  if Get_Elem (A1) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+  if Get_Elem (A2) /= 16#AB0012# then\n+    raise Program_Error;\n+  end if;\n+\n+  Set_Elem (A2'Access, 16#CD0034#);\n+  if Get_Elem (A2) /= 16#CD0034# then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "6fb715f8a01f7700ee5d6adc4c9700d2114c9979", "filename": "gcc/testsuite/gnat.dg/sso/s11.adb", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs11.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,78 @@\n+-- { dg-do run }\n+\n+with Init11; use Init11;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure S11 is\n+\n+  A1 : R1 := My_R1;\n+  A2 : R2 := My_R2;\n+\n+  AA1 : Arr1;\n+  AA2 : Arr2;\n+\n+  C1 : My_Integer;\n+  C2 : My_Integer;\n+  C3 : My_Integer;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  AA1 := A1.A;\n+  C1 := AA1(1);\n+  C2 := AA1(2);\n+  C3 := AA1(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  AA1(1) := C1;\n+  AA1(2) := C2;\n+  AA1(3) := C3;\n+  A1.A := AA1;\n+\n+  AA2 := A2.A;\n+  C1 := AA2(1);\n+  C2 := AA2(2);\n+  C3 := AA2(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  AA2(1) := C1;\n+  AA2(2) := C2;\n+  AA2(3) := C3;\n+  A2.A := AA2;\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+end;"}, {"sha": "1bc624e34684ee0db38548b6af14fb1161626396", "filename": "gcc/testsuite/gnat.dg/sso/s12.adb", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs12.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,77 @@\n+-- { dg-do run }\n+\n+with Init12; use Init12;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure S12 is\n+\n+  A11 : Arr11 := My_A11;\n+  A22 : Arr22 := My_A22;\n+\n+  A1 : Arr1;\n+  A2 : Arr2;\n+\n+  C1 : Integer;\n+  C2 : Integer;\n+  C3 : Integer;\n+\n+begin\n+  Put (\"A11 :\");\n+  Dump (A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Put (\"A22 :\");\n+  Dump (A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+\n+  A1 := (A11(1,1), A11(1,2), A11(2,1));\n+  C1 := A1(1);\n+  C2 := A1(2);\n+  C3 := A1(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 11206674\\n\" }\n+\n+  A1(1) := C1;\n+  A1(2) := C2;\n+  A1(3) := C3;\n+  A11(1,1) := A1(1); A11(1,2) := A1(2); A11(2,1) := A1(3);\n+\n+  A2 := (A22(1,1), A22(1,2), A22(2,1));\n+  C1 := A2(1);\n+  C2 := A2(2);\n+  C3 := A2(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 11206674\\n\" }\n+\n+  A2(1) := C1;\n+  A2(2) := C2;\n+  A2(3) := C3;\n+  A22(1,1) := A2(1); A22(1,2) := A2(2); A22(2,1) := A2(3);\n+\n+  Put (\"A11 :\");\n+  Dump (A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\n\" }\n+\n+  Put (\"A22 :\");\n+  Dump (A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+end;"}, {"sha": "833525d333e98fabc674d23c0882fef1d96bc980", "filename": "gcc/testsuite/gnat.dg/sso/s3.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs3.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,79 @@\n+-- { dg-do run }\n+\n+with Init3; use Init3;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure S3 is\n+\n+  A1 : R1 := My_R1;\n+  A2 : R2 := My_R2;\n+\n+  N1 : Nested1;\n+  N2 : Nested2;\n+\n+  C1 : Init3.Count;\n+  C2 : Init3.Count;\n+  C3 : Init3.Count;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  N1 := A1.N;\n+  C1 := N1.C1;\n+  C2 := N1.C2;\n+  C3 := N1.C3;\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 171\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 205\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 239\\n\" }\n+\n+  N1.C1 := C1;\n+  N1.C2 := C2;\n+  N1.C3 := C3;\n+  A1.N := N1;\n+\n+  N2 := A2.N;\n+  C1 := N2.C1;\n+  C2 := N2.C2;\n+  C3 := N2.C3;\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 171\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 205\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 239\\n\" }\n+\n+  N2.C1 := C1;\n+  N2.C2 := C2;\n+  N2.C3 := C3;\n+  A2.N := N2;\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+end;"}, {"sha": "dc3b30115376c3012cb8c320daa864d2107f5066", "filename": "gcc/testsuite/gnat.dg/sso/s5.adb", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs5.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,78 @@\n+-- { dg-do run }\n+\n+with Init5; use Init5;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure S5 is\n+\n+  A1 : R1 := My_R1;\n+  A2 : R2 := My_R2;\n+\n+  AA1 : Arr1;\n+  AA2 : Arr2;\n+\n+  C1 : Integer;\n+  C2 : Integer;\n+  C3 : Integer;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  AA1 := A1.A;\n+  C1 := AA1(1);\n+  C2 := AA1(2);\n+  C3 := AA1(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  AA1(1) := C1;\n+  AA1(2) := C2;\n+  AA1(3) := C3;\n+  A1.A := AA1;\n+\n+  AA2 := A2.A;\n+  C1 := AA2(1);\n+  C2 := AA2(2);\n+  C3 := AA2(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  AA2(1) := C1;\n+  AA2(2) := C2;\n+  AA2(3) := C3;\n+  A2.A := AA2;\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+end;"}, {"sha": "48d769b17957dd417eee05749ee15c0b28c03276", "filename": "gcc/testsuite/gnat.dg/sso/s6.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs6.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,79 @@\n+-- { dg-do run }\n+\n+with Init6; use Init6;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure S6 is\n+\n+  A1 : R1 := My_R1;\n+  A2 : R2 := My_R2;\n+\n+  AA1 : Arr1;\n+  AA2 : Arr2;\n+\n+  C1 : Integer;\n+  C2 : Integer;\n+  C3 : Integer;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  AA1 := A1.A;\n+  C1 := AA1(1);\n+  C2 := AA1(2);\n+  C3 := AA1(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  AA1(1) := C1;\n+  AA1(2) := C2;\n+  AA1(3) := C3;\n+  A1.A := AA1;\n+\n+  AA2 := A2.A;\n+  C1 := AA2(1);\n+  C2 := AA2(2);\n+  C3 := AA2(3);\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  AA2(1) := C1;\n+  AA2(2) := C2;\n+  AA2(3) := C3;\n+  A2.A := AA2;\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+end;"}, {"sha": "f4725d78c937d1a0c99b80b9ce3d415517409b15", "filename": "gcc/testsuite/gnat.dg/sso/s7.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs7.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,79 @@\n+-- { dg-do run }\n+\n+with Init7; use Init7;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure S7 is\n+\n+  A1 : R1 := My_R1;\n+  A2 : R2 := My_R2;\n+\n+  N1 : Nested1;\n+  N2 : Nested2;\n+\n+  C1 : Integer;\n+  C2 : Integer;\n+  C3 : Integer;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  N1 := A1.N;\n+  C1 := N1.C1;\n+  C2 := N1.C2;\n+  C3 := N1.C3;\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  N1.C1 := C1;\n+  N1.C2 := C2;\n+  N1.C3 := C3;\n+  A1.N := N1;\n+\n+  N2 := A2.N;\n+  C1 := N2.C1;\n+  C2 := N2.C2;\n+  C3 := N2.C3;\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  N2.C1 := C1;\n+  N2.C2 := C2;\n+  N2.C3 := C3;\n+  A2.N := N2;\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+end;"}, {"sha": "0545932f4e1f86c982f5eace22ce81c9b297849d", "filename": "gcc/testsuite/gnat.dg/sso/s8.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fs8.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,79 @@\n+-- { dg-do run }\n+\n+with Init8; use Init8;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure S8 is\n+\n+  A1 : R1 := My_R1;\n+  A2 : R2 := My_R2;\n+\n+  N1 : Nested1;\n+  N2 : Nested2;\n+\n+  C1 : Integer;\n+  C2 : Integer;\n+  C3 : Integer;\n+\n+begin\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  N1 := A1.N;\n+  C1 := N1.C1;\n+  C2 := N1.C2;\n+  C3 := N1.C3;\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  N1.C1 := C1;\n+  N1.C2 := C2;\n+  N1.C3 := C3;\n+  A1.N := N1;\n+\n+  N2 := A2.N;\n+  C1 := N2.C1;\n+  C2 := N2.C2;\n+  C3 := N2.C3;\n+\n+  Put_Line(\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Put_Line(\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+\n+  Put_Line(\"C3 :\" & C3'Img);\n+  -- { dg-output \"C3 : 15663190\\n\" }\n+\n+  N2.C1 := C1;\n+  N2.C2 := C2;\n+  N2.C3 := C3;\n+  A2.N := N2;\n+\n+  Put (\"A1 :\");\n+  Dump (A1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Put (\"A2 :\");\n+  Dump (A2'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"A2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+end;"}, {"sha": "ae8be2c60925fd98874f14e2ff7f01cd273750e8", "filename": "gcc/testsuite/gnat.dg/sso/sso.exp", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fsso.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fsso.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fsso.exp?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,40 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Load support procs.\n+load_lib gnat-dg.exp\n+load_lib torture-options.exp\n+\n+# Initialize `dg'.\n+torture-init\n+dg-init\n+\n+set SSO_TORTURE_OPTIONS [list \\\n+\t{ -O0 } \\\n+\t{ -O1 -fno-inline } \\\n+\t{ -O2 } \\\n+\t{ -O3 -finline-functions } \\\n+\t{ -Os } \\\n+\t{ -Og -g } ]\n+\n+set-torture-options $SSO_TORTURE_OPTIONS\n+\n+# Main loop.\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.adb]] \"\" \"\"\n+\n+# All done.\n+dg-finish\n+torture-finish"}, {"sha": "dd2894763634ab88008807c11e86a57807a09ad1", "filename": "gcc/testsuite/gnat.dg/sso/t1.adb", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft1.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,55 @@\n+-- { dg-do run }\n+\n+with Init1; use Init1;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T1 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.I := My_R1.I + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12\\n\" }\n+\n+  Local_R2.I := My_R2.I + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79\\n\" }\n+\n+  Local_R1.I := 16#12345678#;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2.I := 16#12345678#;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+\n+  Local_R1.I := Local_R1.I + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12\\n\" }\n+\n+  Local_R2.I := Local_R2.I + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79\\n\" }\n+\n+end;"}, {"sha": "152268a6edcd03b7c3c974ea593b27bc944f1143", "filename": "gcc/testsuite/gnat.dg/sso/t10.adb", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft10.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+\n+with Init10; use Init10;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T10 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.I := My_R1.I + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12\\n\" }\n+\n+  Local_R2.I := My_R2.I + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79\\n\" }\n+\n+  Local_R1.I := 16#12345678#;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12\\n\" }\n+\n+  Local_R2.I := 16#12345678#;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78\\n\" }\n+\n+  Local_R1.I := Local_R1.I + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12\\n\" }\n+\n+  Local_R2.I := Local_R2.I + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79\\n\" }\n+\n+end;"}, {"sha": "b0c3ff4dfa47156f75b95fff64234a36007a7b38", "filename": "gcc/testsuite/gnat.dg/sso/t11.adb", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft11.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,67 @@\n+-- { dg-do run }\n+\n+with Init11; use Init11;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T11 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.I    := My_R1.I + 1;\n+  Local_R1.A(1) := My_R1.A(1) + 1;\n+  Local_R1.A(2) := My_R1.A(2) + 1;\n+  Local_R1.A(3) := My_R1.A(3) + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R2.I    := My_R2.I + 1;\n+  Local_R2.A(1) := My_R2.A(1) + 1;\n+  Local_R2.A(2) := My_R2.A(2) + 1;\n+  Local_R2.A(3) := My_R2.A(3) + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+  Local_R1 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1.I    := Local_R1.I + 1;\n+  Local_R1.A(1) := Local_R1.A(1) + 1;\n+  Local_R1.A(2) := Local_R1.A(2) + 1;\n+  Local_R1.A(3) := Local_R1.A(3) + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R2.I    := Local_R2.I + 1;\n+  Local_R2.A(1) := Local_R2.A(1) + 1;\n+  Local_R2.A(2) := Local_R2.A(2) + 1;\n+  Local_R2.A(3) := Local_R2.A(3) + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+end;"}, {"sha": "b62046053ddde1d56473967cf69aa0fe85fb598b", "filename": "gcc/testsuite/gnat.dg/sso/t12.adb", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft12.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,66 @@\n+-- { dg-do run }\n+-- \n+with Init12; use Init12;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T12 is\n+\n+  Local_A11 : Arr11;\n+  Local_A22 : Arr22;\n+\n+begin\n+  Local_A11(1,1) := My_A11(1,1) + 1;\n+  Local_A11(1,2) := My_A11(1,2) + 1;\n+  Local_A11(2,1) := My_A11(2,1) + 1;\n+  Local_A11(2,2) := My_A11(2,2) + 1;\n+\n+  Put (\"Local_A11 :\");\n+  Dump (Local_A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A11 : 13 00 ab 00 35 00 cd 00 13 00 ab 00 35 00 cd 00\\n\" }\n+\n+  Local_A22(1,1) := My_A22(1,1) + 1;\n+  Local_A22(1,2) := My_A22(1,2) + 1;\n+  Local_A22(2,1) := My_A22(2,1) + 1;\n+  Local_A22(2,2) := My_A22(2,2) + 1;\n+\n+  Put (\"Local_A22 :\");\n+  Dump (Local_A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A22 : 00 ab 00 13 00 cd 00 35 00 ab 00 13 00 cd 00 35\\n\" }\n+\n+  Local_A11 := (1 => (16#AB0012#, 16#CD0034#),\n+                2 => (16#AB0012#, 16#CD0034#));\n+  Put (\"Local_A11 :\");\n+  Dump (Local_A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A11 : 12 00 ab 00 34 00 cd 00 12 00 ab 00 34 00 cd 00\\\\n\" }\n+\n+  Local_A22 := (1 => (16#AB0012#, 16#CD0034#),\n+                2 => (16#AB0012#, 16#CD0034#));\n+  Put (\"Local_A22 :\");\n+  Dump (Local_A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A22 : 00 ab 00 12 00 cd 00 34 00 ab 00 12 00 cd 00 34\\n\" }\n+\n+  Local_A11(1,1) := Local_A11(1,1) + 1;\n+  Local_A11(1,2) := Local_A11(1,2) + 1;\n+  Local_A11(2,1) := Local_A11(2,1) + 1;\n+  Local_A11(2,2) := Local_A11(2,2) + 1;\n+\n+  Put (\"Local_A11 :\");\n+  Dump (Local_A11'Address, Arr11'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A11 : 13 00 ab 00 35 00 cd 00 13 00 ab 00 35 00 cd 00\\n\" }\n+\n+  Local_A22(1,1) := Local_A22(1,1) + 1;\n+  Local_A22(1,2) := Local_A22(1,2) + 1;\n+  Local_A22(2,1) := Local_A22(2,1) + 1;\n+  Local_A22(2,2) := Local_A22(2,2) + 1;\n+\n+  Put (\"Local_A22 :\");\n+  Dump (Local_A22'Address, Arr22'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_A22 : 00 ab 00 13 00 cd 00 35 00 ab 00 13 00 cd 00 35\\n\" }\n+end;"}, {"sha": "e00371f7520474589b4c586468995c7e06be093d", "filename": "gcc/testsuite/gnat.dg/sso/t13.adb", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft13.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+-- { dg-do run }\n+\n+with Init13; use Init13;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T13 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.F := (My_R1.F.R + 1.0, My_R1.F.I + 1.0);\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : ee 87 84 40 db 0f 09 c0\\n\" }\n+\n+  Local_R2.F := (My_R2.F.R + 1.0, My_R2.F.I + 1.0);\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 84 87 ee c0 09 0f db\\n\" }\n+\n+  Local_R1.F := (Pi, -Pi);\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40 db 0f 49 c0\\n\" }\n+\n+  Local_R2.F := (Pi, -Pi);\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db c0 49 0f db\\n\" }\n+\n+  Local_R1.F := (Local_R1.F.R + 1.0, Local_R1.F.I + 1.0);\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : ee 87 84 40 db 0f 09 c0\\n\" }\n+\n+  Local_R2.F := (Local_R2.F.R + 1.0, Local_R2.F.I + 1.0);\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 84 87 ee c0 09 0f db\\n\" }\n+\n+end;"}, {"sha": "04ce7752133f7b3c429f44b9ec44d05b6c89d0a0", "filename": "gcc/testsuite/gnat.dg/sso/t2.adb", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft2.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,84 @@\n+-- { dg-do run }\n+\n+with Init2; use Init2;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T2 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.S1 := My_R1.S1 - 1;\n+  Local_R1.I := My_R1.I + 1;\n+  Local_R1.S2 := My_R1.S2 - 1;\n+  Local_R1.A(1) := My_R1.A(1) mod 16;\n+  Local_R1.A(2) := My_R1.A(2) mod 16;\n+  Local_R1.A(3) := My_R1.A(3) mod 16;\n+  Local_R1.B := not My_R1.B;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e5 59 d1 48 b0 a0 c1 03\\n\" }\n+\n+  Local_R2.S1 := My_R2.S1 - 1;\n+  Local_R2.I := My_R2.I + 1;\n+  Local_R2.S2 := My_R2.S2 - 1;\n+  Local_R2.A(1) := My_R2.A(1) mod 16;\n+  Local_R2.A(2) := My_R2.A(2) mod 16;\n+  Local_R2.A(3) := My_R2.A(3) mod 16;\n+  Local_R2.B := not My_R2.B;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 44 8d 15 9e 40 58 34 1e\\n\" }\n+\n+  Local_R1 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               A  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               A  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1.S1   := Local_R1.S1 - 1;\n+  Local_R1.I    := Local_R1.I + 1;\n+  Local_R1.S2   := Local_R1.S2 - 1;\n+  Local_R1.A(1) := Local_R1.A(1) mod 16;\n+  Local_R1.A(2) := Local_R1.A(2) mod 16;\n+  Local_R1.A(3) := Local_R1.A(3) mod 16;\n+  Local_R1.B    := not Local_R1.B;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e5 59 d1 48 b0 a0 c1 03\\n\" }\n+\n+  Local_R2.S1   := Local_R2.S1 - 1;\n+  Local_R2.I    := Local_R2.I + 1;\n+  Local_R2.S2   := Local_R2.S2 - 1;\n+  Local_R2.A(1) := Local_R2.A(1) mod 16;\n+  Local_R2.A(2) := Local_R2.A(2) mod 16;\n+  Local_R2.A(3) := Local_R2.A(3) mod 16;\n+  Local_R2.B    := not Local_R2.B;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 44 8d 15 9e 40 58 34 1e\\n\" }\n+end;"}, {"sha": "3ecbf6893b2f64a0b79a41e4a8013ad4f7e22d19", "filename": "gcc/testsuite/gnat.dg/sso/t3.adb", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft3.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,84 @@\n+-- { dg-do run }\n+\n+with Init3; use Init3;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T3 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.S1   := My_R1.S1 - 1;\n+  Local_R1.I    := My_R1.I + 1;\n+  Local_R1.S2   := My_R1.S2 - 1;\n+  Local_R1.N.C1 := My_R1.N.C1 mod 16;\n+  Local_R1.N.C2 := My_R1.N.C2 mod 16;\n+  Local_R1.N.C3 := My_R1.N.C3 mod 16;\n+  Local_R1.B    := not My_R1.B;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e5 59 d1 48 b0 a0 c1 03\\n\" }\n+\n+  Local_R2.S1   := My_R2.S1 - 1;\n+  Local_R2.I    := My_R2.I + 1;\n+  Local_R2.S2   := My_R2.S2 - 1;\n+  Local_R2.N.C1 := My_R2.N.C1 mod 16;\n+  Local_R2.N.C2 := My_R2.N.C2 mod 16;\n+  Local_R2.N.C3 := My_R2.N.C3 mod 16;\n+  Local_R2.B    := not My_R2.B;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 44 8d 15 9e 40 58 34 1e\\n\" }\n+\n+  Local_R1 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               N  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e2 59 d1 48 b4 aa d9 bb\\n\" }\n+\n+  Local_R2 := (S1 => 2,\n+               I  => 16#12345678#,\n+               S2 => 1,\n+               N  => (16#AB#, 16#CD#, 16#EF#),\n+               B  => True);\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 84 8d 15 9e 15 5b 35 df\\n\" }\n+\n+  Local_R1.S1   := Local_R1.S1 - 1;\n+  Local_R1.I    := Local_R1.I + 1;\n+  Local_R1.S2   := Local_R1.S2 - 1;\n+  Local_R1.N.C1 := Local_R1.N.C1 mod 16;\n+  Local_R1.N.C2 := Local_R1.N.C2 mod 16;\n+  Local_R1.N.C3 := Local_R1.N.C3 mod 16;\n+  Local_R1.B    := not Local_R1.B;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : e5 59 d1 48 b0 a0 c1 03\\n\" }\n+\n+  Local_R2.S1   := Local_R2.S1 - 1;\n+  Local_R2.I    := Local_R2.I + 1;\n+  Local_R2.S2   := Local_R2.S2 - 1;\n+  Local_R2.N.C1 := Local_R2.N.C1 mod 16;\n+  Local_R2.N.C2 := Local_R2.N.C2 mod 16;\n+  Local_R2.N.C3 := Local_R2.N.C3 mod 16;\n+  Local_R2.B    := not Local_R2.B;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 44 8d 15 9e 40 58 34 1e\\n\" }\n+end;"}, {"sha": "ecaee90b28ed01b24681ed6c53b6c093fe018a3b", "filename": "gcc/testsuite/gnat.dg/sso/t4.adb", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft4.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+-- { dg-do run }\n+\n+with Init4; use Init4;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T4 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.F := My_R1.F + 1.0;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : ee 87 84 40\\n\" }\n+\n+  Local_R2.F := My_R2.F + 1.0;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 84 87 ee\\n\" }\n+\n+  Local_R1.F := Pi;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : db 0f 49 40\\n\" }\n+\n+  Local_R2.F := Pi;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 49 0f db\\n\" }\n+\n+  Local_R1.F := Local_R1.F + 1.0;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : ee 87 84 40\\n\" }\n+\n+  Local_R2.F := Local_R2.F + 1.0;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 84 87 ee\\n\" }\n+\n+end;"}, {"sha": "c737bf3a50a7622436ca22da9cfefb67d3deacc3", "filename": "gcc/testsuite/gnat.dg/sso/t5.adb", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft5.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,67 @@\n+-- { dg-do run }\n+\n+with Init5; use Init5;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T5 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.I    := My_R1.I + 1;\n+  Local_R1.A(1) := My_R1.A(1) + 1;\n+  Local_R1.A(2) := My_R1.A(2) + 1;\n+  Local_R1.A(3) := My_R1.A(3) + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R2.I    := My_R2.I + 1;\n+  Local_R2.A(1) := My_R2.A(1) + 1;\n+  Local_R2.A(2) := My_R2.A(2) + 1;\n+  Local_R2.A(3) := My_R2.A(3) + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+  Local_R1 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1.I    := Local_R1.I + 1;\n+  Local_R1.A(1) := Local_R1.A(1) + 1;\n+  Local_R1.A(2) := Local_R1.A(2) + 1;\n+  Local_R1.A(3) := Local_R1.A(3) + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R2.I    := Local_R2.I + 1;\n+  Local_R2.A(1) := Local_R2.A(1) + 1;\n+  Local_R2.A(2) := Local_R2.A(2) + 1;\n+  Local_R2.A(3) := Local_R2.A(3) + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+end;"}, {"sha": "49661cb12153d471d1b0ea1905da3d4887ed0b14", "filename": "gcc/testsuite/gnat.dg/sso/t6.adb", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft6.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,67 @@\n+-- { dg-do run }\n+\n+with Init6; use Init6;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T6 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.I    := My_R1.I + 1;\n+  Local_R1.A(1) := My_R1.A(1) + 1;\n+  Local_R1.A(2) := My_R1.A(2) + 1;\n+  Local_R1.A(3) := My_R1.A(3) + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+  Local_R2.I    := My_R2.I + 1;\n+  Local_R2.A(1) := My_R2.A(1) + 1;\n+  Local_R2.A(2) := My_R2.A(2) + 1;\n+  Local_R2.A(3) := My_R2.A(3) + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R1 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R2 := (I => 16#12345678#,\n+               A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R1.I    := Local_R1.I + 1;\n+  Local_R1.A(1) := Local_R1.A(1) + 1;\n+  Local_R1.A(2) := Local_R1.A(2) + 1;\n+  Local_R1.A(3) := Local_R1.A(3) + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+  Local_R2.I    := Local_R2.I + 1;\n+  Local_R2.A(1) := Local_R2.A(1) + 1;\n+  Local_R2.A(2) := Local_R2.A(2) + 1;\n+  Local_R2.A(3) := Local_R2.A(3) + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+end;"}, {"sha": "da51bd535b4a6be0d41ea0a208ae887aefbecdf0", "filename": "gcc/testsuite/gnat.dg/sso/t7.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft7.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init7; use Init7;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T7 is\n+  Verbose : constant Boolean := False;\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.I    := My_R1.I + 1;\n+  Local_R1.N.C1 := My_R1.N.C1 + 1;\n+  Local_R1.N.C2 := My_R1.N.C2 + 1;\n+  Local_R1.N.C3 := My_R1.N.C3 + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R2.I    := My_R2.I + 1;\n+  Local_R2.N.C1 := My_R2.N.C1 + 1;\n+  Local_R2.N.C2 := My_R2.N.C2 + 1;\n+  Local_R2.N.C3 := My_R2.N.C3 + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+-- \n+  Local_R1 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R1.I    := Local_R1.I + 1;\n+  Local_R1.N.C1 := Local_R1.N.C1 + 1;\n+  Local_R1.N.C2 := Local_R1.N.C2 + 1;\n+  Local_R1.N.C3 := Local_R1.N.C3 + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R2.I    := Local_R2.I + 1;\n+  Local_R2.N.C1 := Local_R2.N.C1 + 1;\n+  Local_R2.N.C2 := Local_R2.N.C2 + 1;\n+  Local_R2.N.C3 := Local_R2.N.C3 + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+end;"}, {"sha": "a9976a6e69e1a65c624a2570e8a59cb437c62ee7", "filename": "gcc/testsuite/gnat.dg/sso/t8.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft8.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,68 @@\n+-- { dg-do run }\n+\n+with Init8; use Init8;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T8 is\n+  Verbose : constant Boolean := False;\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.I    := My_R1.I + 1;\n+  Local_R1.N.C1 := My_R1.N.C1 + 1;\n+  Local_R1.N.C2 := My_R1.N.C2 + 1;\n+  Local_R1.N.C3 := My_R1.N.C3 + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+  Local_R2.I    := My_R2.I + 1;\n+  Local_R2.N.C1 := My_R2.N.C1 + 1;\n+  Local_R2.N.C2 := My_R2.N.C2 + 1;\n+  Local_R2.N.C3 := My_R2.N.C3 + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+  Local_R1 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 78 56 34 12 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R2 := (I => 16#12345678#,\n+               N => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 78 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R1.I    := Local_R1.I + 1;\n+  Local_R1.N.C1 := Local_R1.N.C1 + 1;\n+  Local_R1.N.C2 := Local_R1.N.C2 + 1;\n+  Local_R1.N.C3 := Local_R1.N.C3 + 1;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 79 56 34 12 00 ab 00 13 00 cd 00 35 00 ef 00 57\\n\" }\n+\n+  Local_R2.I    := Local_R2.I + 1;\n+  Local_R2.N.C1 := Local_R2.N.C1 + 1;\n+  Local_R2.N.C2 := Local_R2.N.C2 + 1;\n+  Local_R2.N.C3 := Local_R2.N.C3 + 1;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 12 34 56 79 13 00 ab 00 35 00 cd 00 57 00 ef 00\\n\" }\n+\n+end;"}, {"sha": "e38cabc21d830c8f70fb5c33ff0a6628485b54f5", "filename": "gcc/testsuite/gnat.dg/sso/t9.adb", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Ft9.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,56 @@\n+-- { dg-do run }\n+\n+with Init9; use Init9;\n+with Ada.Numerics; use Ada.Numerics;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure T9 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+\n+begin\n+  Local_R1.F := My_R1.F + 1.0;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 8c 16 22 aa fd 90 10 40\\n\" }\n+\n+  Local_R2.F := My_R2.F + 1.0;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 10 90 fd aa 22 16 8c\\n\" }\n+\n+  Local_R1.F := Pi;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 18 2d 44 54 fb 21 09 40\\n\" }\n+\n+  Local_R2.F := Pi;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 09 21 fb 54 44 2d 18\\n\" }\n+\n+  Local_R1.F := Local_R1.F + 1.0;\n+\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 8c 16 22 aa fd 90 10 40\\n\" }\n+\n+  Local_R2.F := Local_R2.F + 1.0;\n+\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 40 10 90 fd aa 22 16 8c\\n\" }\n+\n+end;"}, {"sha": "9f7c770951d6705ffed5ba1d01625f6771bf83b6", "filename": "gcc/testsuite/gnat.dg/sso/u11.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu11.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init11; use Init11;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure U11 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+  C1 : My_Integer;\n+  C2 : My_Integer;\n+\n+begin\n+  Local_R1 := (I => 1, A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 01 00 00 00 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := (I => 1, A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 00 00 00 01 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  C1 := Local_R1.A (Integer(Local_R1.I));\n+  Put_Line (\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Local_R1.I := Local_R1.I + 1;  \n+  C1 := Local_R1.A (Integer(Local_R1.I));\n+  Put_Line (\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 13434932\\n\" }\n+\n+  C2 := Local_R2.A (Integer(Local_R2.I));\n+  Put_Line (\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 11206674\\n\" }\n+\n+  Local_R2.I := Local_R2.I + 1;  \n+  C2 := Local_R2.A (Integer(Local_R2.I));\n+  Put_Line (\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+end;"}, {"sha": "5d9d4ccbcebeadb7ea200fac11cb7266efb9c145", "filename": "gcc/testsuite/gnat.dg/sso/u5.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu5.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init5; use Init5;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure U5 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+  C1 : Integer;\n+  C2 : Integer;\n+\n+begin\n+  Local_R1 := (I => 1, A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 01 00 00 00 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  Local_R2 := (I => 1, A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 00 00 00 01 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  C1 := Local_R1.A (Local_R1.I);\n+  Put_Line (\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Local_R1.I := Local_R1.I + 1;  \n+  C1 := Local_R1.A (Local_R1.I);\n+  Put_Line (\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 13434932\\n\" }\n+\n+  C2 := Local_R2.A (Local_R2.I);\n+  Put_Line (\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 11206674\\n\" }\n+\n+  Local_R2.I := Local_R2.I + 1;  \n+  C2 := Local_R2.A (Local_R2.I);\n+  Put_Line (\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+end;"}, {"sha": "ca8a0d4ff5ffa0080fc69639603d8d327e36adf4", "filename": "gcc/testsuite/gnat.dg/sso/u6.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso%2Fu6.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+with Init6; use Init6;\n+with Text_IO; use Text_IO;\n+with Dump;\n+\n+procedure U6 is\n+\n+  Local_R1 : R1;\n+  Local_R2 : R2;\n+  C1 : Integer;\n+  C2 : Integer;\n+\n+begin\n+  Local_R1 := (I => 1, A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R1 :\");\n+  Dump (Local_R1'Address, R1'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R1 : 01 00 00 00 00 ab 00 12 00 cd 00 34 00 ef 00 56\\n\" }\n+\n+  Local_R2 := (I => 1, A => (16#AB0012#, 16#CD0034#, 16#EF0056#));\n+  Put (\"Local_R2 :\");\n+  Dump (Local_R2'Address, R2'Max_Size_In_Storage_Elements);\n+  New_Line;\n+  -- { dg-output \"Local_R2 : 00 00 00 01 12 00 ab 00 34 00 cd 00 56 00 ef 00\\n\" }\n+\n+  C1 := Local_R1.A (Local_R1.I);\n+  Put_Line (\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 11206674\\n\" }\n+\n+  Local_R1.I := Local_R1.I + 1;  \n+  C1 := Local_R1.A (Local_R1.I);\n+  Put_Line (\"C1 :\" & C1'Img);\n+  -- { dg-output \"C1 : 13434932\\n\" }\n+\n+  C2 := Local_R2.A (Local_R2.I);\n+  Put_Line (\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 11206674\\n\" }\n+\n+  Local_R2.I := Local_R2.I + 1;  \n+  C2 := Local_R2.A (Local_R2.I);\n+  Put_Line (\"C2 :\" & C2'Img);\n+  -- { dg-output \"C2 : 13434932\\n\" }\n+end;"}, {"sha": "1b2cd5f17073a59a9ef71213678dc17cd515faa1", "filename": "gcc/testsuite/gnat.dg/sso1.adb", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso1.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,77 @@\n+-- { dg-do run }\n+\n+with System;\n+with Ada.Unchecked_Conversion;\n+with Ada.Streams; use Ada.Streams;\n+with Ada.Text_IO;\n+\n+procedure SSO1 is\n+\n+   type Unsigned_Integer_4 is mod 2 ** 32;\n+   for Unsigned_Integer_4'Size use 32;\n+\n+   Default_Bit_Order_Pos : constant Natural := System.Bit_Order'Pos (System.Default_Bit_Order);\n+\n+   Opposite_Bit_Order_Pos : constant Natural := 1 - Default_Bit_Order_Pos;\n+\n+   Opposite_Bit_Order : constant System.Bit_Order := System.Bit_Order'Val (Opposite_Bit_Order_Pos);\n+\n+   type Rec is\n+      record\n+\t X, Y : Unsigned_Integer_4;\n+      end record;\n+   for Rec'Bit_Order use System.Default_Bit_Order;\n+   for Rec'Scalar_Storage_Order use System.Default_Bit_Order;\n+\n+   for Rec use\n+      record\n+\t X at 0 * 4 range 0 .. 31;\n+\t Y at 1 * 4 range 0 .. 31;\n+      end record;\n+   \n+   type Nested_Rec is\n+      record \n+\t I : Unsigned_Integer_4;\n+\t R : Rec;\n+\t J : Unsigned_Integer_4;\n+      end record;\n+   for Nested_Rec use\n+      record\n+\t I at 0 * 4 range 0 .. 31;\n+\t R at 1 * 4 range 0 .. 63;\n+\t J at 3 * 4 range 0 .. 31;\n+\t end record;\n+\n+   for Nested_Rec'Bit_Order use Opposite_Bit_Order;\n+   for Nested_Rec'Scalar_Storage_Order use Opposite_Bit_Order;\n+\n+   Nr : Nested_Rec \n+     := (I => 1,\n+\t R => (X => 1,\n+\t       Y => 1),\n+\t J => 1);\n+   \n+   subtype Nested_Rec_As_Stream is Ada.Streams.Stream_Element_Array (1 ..16);\n+\n+   function To_Stream is\n+     new Ada.Unchecked_Conversion (Nested_Rec, Nested_Rec_As_Stream);\n+\n+   Nr_Stream : constant Nested_Rec_As_Stream := To_Stream (Nr);\n+\n+   Expected : constant array (System.Bit_Order) of Nested_Rec_As_Stream :=\n+                (System.Low_Order_First =>\n+                   (0, 0, 0, 1,\n+                    1, 0, 0, 0,\n+                    1, 0, 0, 0,\n+                    0, 0, 0, 1),\n+                 System.High_Order_First =>\n+                   (1, 0, 0, 0,\n+                    0, 0, 0, 1,\n+                    0, 0, 0, 1,\n+                    1, 0, 0, 0));\n+\n+begin\n+   if Nr_Stream /= Expected (System.Default_Bit_Order) then\n+      raise Program_Error;\n+   end if;\n+end;"}, {"sha": "dc5b8cc56533dd384a91975993d598ebd59f33b5", "filename": "gcc/testsuite/gnat.dg/sso2.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso2.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,14 @@\n+-- { dg-do compile }\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body SSO2 is\n+\n+  function Conv is new Ada.Unchecked_Conversion (Arr1, Arr2);\n+\n+  procedure Proc (A1 : Arr1; A2 : out Arr2) is\n+  begin\n+     A2 := Conv (A1);\n+  end;\n+\n+end SSO2;"}, {"sha": "36d37bc92ae2c78b52fddb7ee996097d42810b1b", "filename": "gcc/testsuite/gnat.dg/sso2.ads", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso2.ads?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,13 @@\n+with System;\n+\n+package SSO2 is\n+\n+  type Arr1 is array (1 .. 4) of Character;\n+  for Arr1'Scalar_Storage_Order use System.High_Order_First;\n+\n+  type Arr2 is array (1 .. 4) of Character;\n+  for Arr2'Scalar_Storage_Order use System.Low_Order_First;\n+\n+  procedure Proc (A1 : Arr1; A2 : out Arr2);\n+\n+end SSO2;"}, {"sha": "d4b65697a1b96067d54ca2deead136bb8fa011de", "filename": "gcc/testsuite/gnat.dg/sso3.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso3.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,52 @@\n+-- { dg-do run }\n+\n+with System; use System;\n+\n+procedure SSO3 is\n+   Rev_SSO : constant Bit_Order\n+     := Bit_Order'Val (1 - Bit_Order'Pos (Default_Bit_Order));\n+\n+   type R (D : Integer) is record\n+      Common : Integer;\n+      case D is\n+         when 0 =>\n+            V1 : Integer;\n+         when others =>\n+            V2 : Integer;\n+      end case;\n+   end record;\n+\n+   for R use record\n+      D at 0 range 0 .. 31;\n+      V1 at 4 range 0 .. 31;\n+      V2 at 4 range 0 .. 31;\n+      Common at 8 range 0 .. 31;\n+   end record;\n+   for R'Scalar_Storage_Order use Rev_SSO;\n+   for R'Bit_Order use Rev_SSO;\n+\n+   procedure Check (Common, V : Integer; X : R) is\n+   begin\n+      if Common /= X.Common then\n+         raise Program_Error;\n+      end if;\n+\n+      case X.D is\n+         when 0 =>\n+            if V /= X.V1 then\n+               raise Program_Error;\n+            end if;\n+         when others =>\n+            if V /= X.V2 then\n+               raise Program_Error;\n+            end if;\n+      end case;\n+   end Check;\n+\n+   X0 : R := (D => 0,     Common => 1111, V1 => 1234);\n+   X1 : R := (D => 31337, Common => 2222, V2 => 5678);\n+\n+begin\n+   Check (1111, 1234, X0);\n+   Check (2222, 5678, X1);\n+end;"}, {"sha": "6a409e92a5f7e754917aa20c1f9ae1ffa9f63f28", "filename": "gcc/testsuite/gnat.dg/sso4.adb", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso4.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,55 @@\n+-- { dg-do run }\n+\n+with System;\n+\n+procedure SSO4 is\n+\n+   type Short_Int is mod 2**16;\n+\n+   type Rec1 is record\n+      F1 : Short_Int;\n+      F2 : Short_Int;\n+   end record;\n+   for Rec1 use record\n+      F1 at 0 range  0 .. 15;\n+      F2 at 0 range 16 .. 31;\n+   end record;\n+\n+   for Rec1'Bit_Order use System.High_Order_First;\n+   for Rec1'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec2 is record\n+      I1 : Integer;\n+      R1 : Rec1;\n+   end record;\n+   for Rec2 use record\n+      I1 at 0 range 0 .. 31; \n+      R1 at 4 range 0 .. 31;\n+   end record;\n+   for Rec2'Bit_Order use System.High_Order_First;\n+   for Rec2'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec3 is record\n+      Data : Rec1;\n+   end record;\n+   for Rec3 use record\n+      Data at 0 range  0 .. 31;\n+   end record;\n+   for Rec3'Bit_Order use System.High_Order_First;\n+   for Rec3'Scalar_Storage_Order use System.High_Order_First;\n+\n+   procedure Copy (Message : in Rec3) is\n+      Local : Rec2;\n+   begin\n+      Local := (I1 => 1, R1 => Message.Data);\n+      if Local.R1 /= Message.Data then\n+         raise Program_Error;\n+      end if;\n+   end;\n+\n+   Message : Rec3;\n+\n+begin\n+   Message := (Data => (2, 3));\n+   Copy(Message);\n+end;"}, {"sha": "b755846dfb048f2241c45cc0aac7598951e50741", "filename": "gcc/testsuite/gnat.dg/sso5.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso5.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,52 @@\n+-- { dg-do run }\n+\n+with System;\n+\n+procedure SSO5 is\n+\n+   type Short_Int is mod 2**16;\n+\n+   type Rec1 is record\n+      F1 : Short_Int;\n+      F2 : Short_Int;\n+   end record;\n+   for Rec1 use record\n+      F1 at 0 range  0 .. 15;\n+      F2 at 0 range 16 .. 31;\n+   end record;\n+   for Rec1'Bit_Order use System.High_Order_First;\n+   for Rec1'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec2 is record\n+      R1 : Rec1;\n+   end record;\n+   for Rec2 use record\n+      R1 at 0 range 1 .. 32;\n+   end record;\n+   for Rec2'Bit_Order use System.High_Order_First;\n+   for Rec2'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec3 is record\n+      Data : Rec1;\n+   end record;\n+   for Rec3 use record\n+      Data at 0 range 0 .. 31;\n+   end record;\n+   for Rec3'Bit_Order use System.High_Order_First;\n+   for Rec3'Scalar_Storage_Order use System.High_Order_First;\n+\n+   procedure Copy (Message : in Rec3) is\n+      Local : Rec2;\n+   begin\n+      Local := (R1 => Message.Data);\n+      if Local.R1 /= Message.Data then\n+         raise Program_Error;\n+      end if;\n+   end;\n+\n+   Message : Rec3;\n+\n+begin\n+   Message := (Data => (2, 3));\n+   Copy(Message);\n+end;"}, {"sha": "6d351a43ffd63b15ba8e35c167bd5bcaf5bd8ef8", "filename": "gcc/testsuite/gnat.dg/sso6.adb", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso6.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,54 @@\n+-- { dg-do run }\n+\n+with System;\n+\n+procedure SSO6 is\n+\n+   type Short_Int is mod 2**16;\n+\n+   type Rec1 is record\n+      F1 : Short_Int;\n+      F2 : Short_Int;\n+   end record;\n+   for Rec1 use record\n+      F1 at 0 range  0 .. 15;\n+      F2 at 0 range 16 .. 31;\n+   end record;\n+   for Rec1'Bit_Order use System.High_Order_First;\n+   for Rec1'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec2 is record\n+      I1 : Integer;\n+      R1 : Rec1;\n+   end record;\n+   for Rec2 use record\n+      I1 at 0 range 0 .. 31; \n+      R1 at 4 range 0 .. 31;\n+   end record;\n+   for Rec2'Bit_Order use System.High_Order_First;\n+   for Rec2'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec3 is record\n+      Data : Rec1;\n+   end record;\n+   for Rec3 use record\n+      Data at 0 range 1 .. 32;\n+   end record;\n+   for Rec3'Bit_Order use System.High_Order_First;\n+   for Rec3'Scalar_Storage_Order use System.High_Order_First;\n+\n+   procedure Copy (Message : in Rec3) is\n+      Local : Rec2;\n+   begin\n+      Local := (I1 => 1, R1 => Message.Data);\n+      if Local.R1 /= Message.Data then\n+         raise Program_Error;\n+      end if;\n+   end;\n+\n+   Message : Rec3;\n+\n+begin\n+   Message := (Data => (2, 3));\n+   Copy(Message);\n+end;"}, {"sha": "114373deecab470366aa5edadbf370dfc0cd629e", "filename": "gcc/testsuite/gnat.dg/sso7.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftestsuite%2Fgnat.dg%2Fsso7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso7.adb?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -0,0 +1,52 @@\n+-- { dg-do run }\n+\n+with System;\n+\n+procedure SSO7 is\n+\n+   type Short_Int is mod 2**16;\n+\n+   type Rec1 is record\n+      F1 : Short_Int;\n+      F2 : Short_Int;\n+   end record;\n+   for Rec1 use record\n+      F1 at 0 range  0 .. 15;\n+      F2 at 0 range 16 .. 31;\n+   end record;\n+   for Rec1'Bit_Order use System.High_Order_First;\n+   for Rec1'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec2 is record\n+      R1 : Rec1;\n+   end record;\n+   for Rec2 use record\n+      R1 at 0 range 0 .. 31;\n+   end record;\n+   for Rec2'Bit_Order use System.High_Order_First;\n+   for Rec2'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Rec3 is record\n+      Data : Rec1;\n+   end record;\n+   for Rec3 use record\n+      Data at 0 range 1 .. 32;\n+   end record;\n+   for Rec3'Bit_Order use System.High_Order_First;\n+   for Rec3'Scalar_Storage_Order use System.High_Order_First;\n+\n+   procedure Copy (Message : in Rec3) is\n+      Local : Rec2;\n+   begin\n+      Local := (R1 => Message.Data);\n+      if Local.R1 /= Message.Data then\n+         raise Program_Error;\n+      end if;\n+   end;\n+\n+   Message : Rec3;\n+\n+begin\n+   Message := (Data => (2, 3));\n+   Copy(Message);\n+end;"}, {"sha": "68d056cf1fce596860298c7938c6a4a878175101", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -260,7 +260,7 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n   tree cst, core, toffset;\n   HOST_WIDE_INT bitpos, bitsize;\n   machine_mode mode;\n-  int unsignedp, volatilep;\n+  int unsignedp, reversep, volatilep;\n \n   STRIP_NOPS (expr);\n \n@@ -317,8 +317,8 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n \t  return;\n \t}\n       core = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize, &bitpos,\n-\t\t\t\t  &toffset, &mode, &unsignedp, &volatilep,\n-\t\t\t\t  false);\n+\t\t\t\t  &toffset, &mode, &unsignedp, &reversep,\n+\t\t\t\t  &volatilep, false);\n       if (bitpos % BITS_PER_UNIT != 0)\n \tbreak;\n       aff_combination_const (comb, type, bitpos / BITS_PER_UNIT);\n@@ -885,10 +885,10 @@ get_inner_reference_aff (tree ref, aff_tree *addr, widest_int *size)\n   HOST_WIDE_INT bitsize, bitpos;\n   tree toff;\n   machine_mode mode;\n-  int uns, vol;\n+  int uns, rev, vol;\n   aff_tree tmp;\n   tree base = get_inner_reference (ref, &bitsize, &bitpos, &toff, &mode,\n-\t\t\t\t   &uns, &vol, false);\n+\t\t\t\t   &uns, &rev, &vol, false);\n   tree base_addr = build_fold_addr_expr (base);\n \n   /* ADDR = &BASE + TOFF + BITPOS / BITS_PER_UNIT.  */"}, {"sha": "d7b4ca4914a9e1591833567ab039bc3b7f054997", "filename": "gcc/tree-core.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1151,8 +1151,14 @@ struct GTY(()) tree_base {\n \n    saturating_flag:\n \n+       TYPE_REVERSE_STORAGE_ORDER in\n+           RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ARRAY_TYPE\n+\n        TYPE_SATURATING in\n-           all types\n+           other types\n+\n+       REF_REVERSE_STORAGE_ORDER in\n+           BIT_FIELD_REF, MEM_REF\n \n        VAR_DECL_IS_VIRTUAL_OPERAND in\n \t   VAR_DECL"}, {"sha": "74f7614ff93d0727a9f7db049b2954bca9b0480c", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -613,11 +613,12 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \ttree base, poffset;\n \tHOST_WIDE_INT pbitsize, pbitpos;\n \tmachine_mode pmode;\n-\tint punsignedp, pvolatilep;\n+\tint punsignedp, preversep, pvolatilep;\n \n \top0 = TREE_OPERAND (op0, 0);\n-\tbase = get_inner_reference (op0, &pbitsize, &pbitpos, &poffset,\n-\t\t\t\t    &pmode, &punsignedp, &pvolatilep, false);\n+\tbase\n+\t  = get_inner_reference (op0, &pbitsize, &pbitpos, &poffset, &pmode,\n+\t\t\t\t &punsignedp, &preversep, &pvolatilep, false);\n \n \tif (pbitpos % BITS_PER_UNIT != 0)\n \t  return false;\n@@ -761,16 +762,16 @@ dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n   HOST_WIDE_INT pbitsize, pbitpos;\n   tree base, poffset;\n   machine_mode pmode;\n-  int punsignedp, pvolatilep;\n+  int punsignedp, preversep, pvolatilep;\n   affine_iv base_iv, offset_iv;\n   tree init, dinit, step;\n   bool in_loop = (loop && loop->num);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"analyze_innermost: \");\n \n-  base = get_inner_reference (ref, &pbitsize, &pbitpos, &poffset,\n-\t\t\t      &pmode, &punsignedp, &pvolatilep, false);\n+  base = get_inner_reference (ref, &pbitsize, &pbitpos, &poffset, &pmode,\n+\t\t\t      &punsignedp, &preversep, &pvolatilep, false);\n   gcc_assert (base != NULL_TREE);\n \n   if (pbitpos % BITS_PER_UNIT != 0)\n@@ -780,6 +781,13 @@ dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n       return false;\n     }\n \n+  if (preversep)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"failed: reverse storage order.\\n\");\n+      return false;\n+    }\n+\n   if (TREE_CODE (base) == MEM_REF)\n     {\n       if (!integer_zerop (TREE_OPERAND (base, 1)))"}, {"sha": "bb5cd496126df5c2a038fcb6886a2e8372cee636", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -368,20 +368,23 @@ get_or_create_ssa_default_def (struct function *fn, tree var)\n    base variable.  The access range is delimited by bit positions *POFFSET and\n    *POFFSET + *PMAX_SIZE.  The access size is *PSIZE bits.  If either\n    *PSIZE or *PMAX_SIZE is -1, they could not be determined.  If *PSIZE\n-   and *PMAX_SIZE are equal, the access is non-variable.  */\n+   and *PMAX_SIZE are equal, the access is non-variable.  If *PREVERSE is\n+   true, the storage order of the reference is reversed.  */\n \n tree\n get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t\t HOST_WIDE_INT *psize,\n-\t\t\t HOST_WIDE_INT *pmax_size)\n+\t\t\t HOST_WIDE_INT *pmax_size,\n+\t\t\t bool *preverse)\n {\n   offset_int bitsize = -1;\n   offset_int maxsize;\n   tree size_tree = NULL_TREE;\n   offset_int bit_offset = 0;\n   bool seen_variable_array_ref = false;\n \n-  /* First get the final access size from just the outermost expression.  */\n+  /* First get the final access size and the storage order from just the\n+     outermost expression.  */\n   if (TREE_CODE (exp) == COMPONENT_REF)\n     size_tree = DECL_SIZE (TREE_OPERAND (exp, 1));\n   else if (TREE_CODE (exp) == BIT_FIELD_REF)\n@@ -398,6 +401,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n       && TREE_CODE (size_tree) == INTEGER_CST)\n     bitsize = wi::to_offset (size_tree);\n \n+  *preverse = reverse_storage_order_for_component_p (exp);\n+\n   /* Initially, maxsize is the same as the accessed element size.\n      In the following it will only grow (or become -1).  */\n   maxsize = bitsize;"}, {"sha": "3503398be84d9a82c36b75234fd3ba836d0ea826", "filename": "gcc/tree-dfa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-dfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-dfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -30,7 +30,7 @@ extern tree ssa_default_def (struct function *, tree);\n extern void set_ssa_default_def (struct function *, tree, tree);\n extern tree get_or_create_ssa_default_def (struct function *, tree);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n-\t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n+\t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *, bool *);\n extern tree get_addr_base_and_unit_offset_1 (tree, HOST_WIDE_INT *,\n \t\t\t\t\t     tree (*) (tree));\n extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);"}, {"sha": "17d97a8712e83284d6bf5d51179da3b0832837dc", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -952,6 +952,7 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t      && (!is_parm (TREE_OPERAND (old, 0))\n \t\t  || (!id->transform_parameter && is_parm (ptr))))\n \t    TREE_THIS_NOTRAP (*tp) = 1;\n+\t  REF_REVERSE_STORAGE_ORDER (*tp) = REF_REVERSE_STORAGE_ORDER (old);\n \t  *walk_subtrees = 0;\n \t  return NULL;\n \t}\n@@ -1209,6 +1210,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t      && (!is_parm (TREE_OPERAND (old, 0))\n \t\t  || (!id->transform_parameter && is_parm (ptr))))\n \t    TREE_THIS_NOTRAP (*tp) = 1;\n+\t  REF_REVERSE_STORAGE_ORDER (*tp) = REF_REVERSE_STORAGE_ORDER (old);\n \t  *walk_subtrees = 0;\n \t  return NULL;\n \t}"}, {"sha": "8800209d39b65d4a52dfd845477f91978e443da4", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -305,7 +305,7 @@ insert_value_copy_on_edge (edge e, int dest, tree src, source_location locus)\n   else if (src_mode == BLKmode)\n     {\n       x = dest_rtx;\n-      store_expr (src, x, 0, false);\n+      store_expr (src, x, 0, false, false);\n     }\n   else\n     x = expand_expr (src, dest_rtx, dest_mode, EXPAND_NORMAL);"}, {"sha": "e90aafb771cc5065126322e93a00ff3d0286ebb1", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1715,15 +1715,16 @@ interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n         {\n \t  machine_mode mode;\n \t  HOST_WIDE_INT bitsize, bitpos;\n-\t  int unsignedp;\n+\t  int unsignedp, reversep;\n \t  int volatilep = 0;\n \t  tree base, offset;\n \t  tree chrec3;\n \t  tree unitpos;\n \n \t  base = get_inner_reference (TREE_OPERAND (rhs1, 0),\n-\t\t\t\t      &bitsize, &bitpos, &offset,\n-\t\t\t\t      &mode, &unsignedp, &volatilep, false);\n+\t\t\t\t      &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t      &unsignedp, &reversep, &volatilep,\n+\t\t\t\t      false);\n \n \t  if (TREE_CODE (base) == MEM_REF)\n \t    {"}, {"sha": "a89630876c7b3805cb9540af75cf842d1090d951", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -179,12 +179,15 @@ struct access\n      when grp_to_be_replaced flag is set.  */\n   tree replacement_decl;\n \n-  /* Is this particular access write access? */\n-  unsigned write : 1;\n-\n   /* Is this access an access to a non-addressable field? */\n   unsigned non_addressable : 1;\n \n+  /* Is this access made in reverse storage order? */\n+  unsigned reverse : 1;\n+\n+  /* Is this particular access write access? */\n+  unsigned write : 1;\n+\n   /* Is this access currently in the work queue?  */\n   unsigned grp_queued : 1;\n \n@@ -423,6 +426,8 @@ dump_access (FILE *f, struct access *access, bool grp)\n   print_generic_expr (f, access->expr, 0);\n   fprintf (f, \", type = \");\n   print_generic_expr (f, access->type, 0);\n+  fprintf (f, \", non_addressable = %d, reverse = %d\",\n+\t   access->non_addressable, access->reverse);\n   if (grp)\n     fprintf (f, \", grp_read = %d, grp_write = %d, grp_assignment_read = %d, \"\n \t     \"grp_assignment_write = %d, grp_scalar_read = %d, \"\n@@ -839,9 +844,9 @@ create_access (tree expr, gimple *stmt, bool write)\n   struct access *access;\n   HOST_WIDE_INT offset, size, max_size;\n   tree base = expr;\n-  bool ptr, unscalarizable_region = false;\n+  bool reverse, ptr, unscalarizable_region = false;\n \n-  base = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n+  base = get_ref_base_and_extent (expr, &offset, &size, &max_size, &reverse);\n \n   if (sra_mode == SRA_MODE_EARLY_IPA\n       && TREE_CODE (base) == MEM_REF)\n@@ -895,6 +900,7 @@ create_access (tree expr, gimple *stmt, bool write)\n   access->write = write;\n   access->grp_unscalarizable_region = unscalarizable_region;\n   access->stmt = stmt;\n+  access->reverse = reverse;\n \n   if (TREE_CODE (expr) == COMPONENT_REF\n       && DECL_NONADDRESSABLE_P (TREE_OPERAND (expr, 1)))\n@@ -959,7 +965,7 @@ scalarizable_type_p (tree type)\n   }\n }\n \n-static void scalarize_elem (tree, HOST_WIDE_INT, HOST_WIDE_INT, tree, tree);\n+static void scalarize_elem (tree, HOST_WIDE_INT, HOST_WIDE_INT, bool, tree, tree);\n \n /* Create total_scalarization accesses for all scalar fields of a member\n    of type DECL_TYPE conforming to scalarizable_type_p.  BASE\n@@ -980,8 +986,9 @@ completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)\n \t    tree ft = TREE_TYPE (fld);\n \t    tree nref = build3 (COMPONENT_REF, ft, ref, fld, NULL_TREE);\n \n-\t    scalarize_elem (base, pos, tree_to_uhwi (DECL_SIZE (fld)), nref,\n-\t\t\t    ft);\n+\t    scalarize_elem (base, pos, tree_to_uhwi (DECL_SIZE (fld)),\n+\t\t\t    TYPE_REVERSE_STORAGE_ORDER (decl_type),\n+\t\t\t    nref, ft);\n \t  }\n       break;\n     case ARRAY_TYPE:\n@@ -1015,7 +1022,9 @@ completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)\n \t\t\t\t    ref,\n \t\t\t\t    wide_int_to_tree (domain, idx),\n \t\t\t\t    NULL_TREE, NULL_TREE);\n-\t\tscalarize_elem (base, el_off, el_size, nref, elemtype);\n+\t\tscalarize_elem (base, el_off, el_size,\n+\t\t\t\tTYPE_REVERSE_STORAGE_ORDER (decl_type),\n+\t\t\t\tnref, elemtype);\n \t\tel_off += el_size;\n \t      }\n \t  }\n@@ -1029,18 +1038,20 @@ completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)\n /* Create total_scalarization accesses for a member of type TYPE, which must\n    satisfy either is_gimple_reg_type or scalarizable_type_p.  BASE must be the\n    top-most VAR_DECL representing the variable; within that, POS and SIZE locate\n-   the member and REF must be the reference expression for it.  */\n+   the member, REVERSE gives its torage order. and REF must be the reference\n+   expression for it.  */\n \n static void\n-scalarize_elem (tree base, HOST_WIDE_INT pos, HOST_WIDE_INT size,\n-\t\t tree ref, tree type)\n+scalarize_elem (tree base, HOST_WIDE_INT pos, HOST_WIDE_INT size, bool reverse,\n+\t\ttree ref, tree type)\n {\n   if (is_gimple_reg_type (type))\n   {\n     struct access *access = create_access_1 (base, pos, size);\n     access->expr = ref;\n     access->type = type;\n     access->grp_total_scalarization = 1;\n+    access->reverse = reverse;\n     /* Accesses for intraprocedural SRA can have their stmt NULL.  */\n   }\n   else\n@@ -1116,7 +1127,7 @@ build_access_from_expr_1 (tree expr, gimple *stmt, bool write)\n      and not the result type.  Ada produces such statements.  We are also\n      capable of handling the topmost V_C_E but not any of those buried in other\n      handled components.  */\n-  if (TREE_CODE (expr) == VIEW_CONVERT_EXPR)\n+  if (TREE_CODE (expr) == VIEW_CONVERT_EXPR && !storage_order_barrier_p (expr))\n     expr = TREE_OPERAND (expr, 0);\n \n   if (contains_view_convert_expr_p (expr))\n@@ -1249,14 +1260,20 @@ build_accesses_from_assign (gimple *stmt)\n   lacc = build_access_from_expr_1 (lhs, stmt, true);\n \n   if (lacc)\n-    lacc->grp_assignment_write = 1;\n+    {\n+      lacc->grp_assignment_write = 1;\n+      if (storage_order_barrier_p (rhs))\n+\tlacc->grp_unscalarizable_region = 1;\n+    }\n \n   if (racc)\n     {\n       racc->grp_assignment_read = 1;\n       if (should_scalarize_away_bitmap && !gimple_has_volatile_ops (stmt)\n \t  && !is_gimple_reg_type (racc->type))\n \tbitmap_set_bit (should_scalarize_away_bitmap, DECL_UID (racc->base));\n+      if (storage_order_barrier_p (lhs))\n+\tracc->grp_unscalarizable_region = 1;\n     }\n \n   if (lacc && racc\n@@ -1564,17 +1581,15 @@ make_fancy_name (tree expr)\n }\n \n /* Construct a MEM_REF that would reference a part of aggregate BASE of type\n-   EXP_TYPE at the given OFFSET.  If BASE is something for which\n-   get_addr_base_and_unit_offset returns NULL, gsi must be non-NULL and is used\n-   to insert new statements either before or below the current one as specified\n-   by INSERT_AFTER.  This function is not capable of handling bitfields.\n-\n-   BASE must be either a declaration or a memory reference that has correct\n-   alignment ifformation embeded in it (e.g. a pre-existing one in SRA).  */\n+   EXP_TYPE at the given OFFSET and with storage order REVERSE.  If BASE is\n+   something for which get_addr_base_and_unit_offset returns NULL, gsi must\n+   be non-NULL and is used to insert new statements either before or below\n+   the current one as specified by INSERT_AFTER.  This function is not capable\n+   of handling bitfields.  */\n \n tree\n build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n-\t\t      tree exp_type, gimple_stmt_iterator *gsi,\n+\t\t      bool reverse, tree exp_type, gimple_stmt_iterator *gsi,\n \t\t      bool insert_after)\n {\n   tree prev_base = base;\n@@ -1631,6 +1646,7 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n     exp_type = build_aligned_type (exp_type, align);\n \n   mem_ref = fold_build2_loc (loc, MEM_REF, exp_type, base, off);\n+  REF_REVERSE_STORAGE_ORDER (mem_ref) = reverse;\n   if (TREE_THIS_VOLATILE (prev_base))\n     TREE_THIS_VOLATILE (mem_ref) = 1;\n   if (TREE_SIDE_EFFECTS (prev_base))\n@@ -1657,13 +1673,17 @@ build_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,\n \n       offset -= int_bit_position (fld);\n       exp_type = TREE_TYPE (TREE_OPERAND (model->expr, 0));\n-      t = build_ref_for_offset (loc, base, offset, exp_type, gsi, insert_after);\n+      t = build_ref_for_offset (loc, base, offset, model->reverse, exp_type,\n+\t\t\t\tgsi, insert_after);\n+      /* The flag will be set on the record type.  */\n+      REF_REVERSE_STORAGE_ORDER (t) = 0;\n       return fold_build3_loc (loc, COMPONENT_REF, TREE_TYPE (fld), t, fld,\n \t\t\t      NULL_TREE);\n     }\n   else\n-    return build_ref_for_offset (loc, base, offset, model->type,\n-\t\t\t\t gsi, insert_after);\n+    return\n+      build_ref_for_offset (loc, base, offset, model->reverse, model->type,\n+\t\t\t    gsi, insert_after);\n }\n \n /* Attempt to build a memory reference that we could but into a gimple\n@@ -2320,8 +2340,8 @@ analyze_access_subtree (struct access *root, struct access *parent,\n \t\t      && (root->size % BITS_PER_UNIT) == 0);\n \t  root->type = build_nonstandard_integer_type (root->size,\n \t\t\t\t\t\t       TYPE_UNSIGNED (rt));\n-\t  root->expr = build_ref_for_offset (UNKNOWN_LOCATION,\n-\t\t\t\t\t     root->base, root->offset,\n+\t  root->expr = build_ref_for_offset (UNKNOWN_LOCATION, root->base,\n+\t\t\t\t\t     root->offset, root->reverse,\n \t\t\t\t\t     root->type, NULL, false);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2445,6 +2465,7 @@ create_artificial_child_access (struct access *parent, struct access *model,\n   access->type = model->type;\n   access->grp_write = true;\n   access->grp_read = false;\n+  access->reverse = model->reverse;\n \n   child = &parent->first_child;\n   while (*child && (*child)->offset < new_offset)\n@@ -2829,14 +2850,15 @@ get_access_for_expr (tree expr)\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree base;\n+  bool reverse;\n \n   /* FIXME: This should not be necessary but Ada produces V_C_Es with a type of\n      a different size than the size of its argument and we need the latter\n      one.  */\n   if (TREE_CODE (expr) == VIEW_CONVERT_EXPR)\n     expr = TREE_OPERAND (expr, 0);\n \n-  base = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n+  base = get_ref_base_and_extent (expr, &offset, &size, &max_size, &reverse);\n   if (max_size == -1 || !DECL_P (base))\n     return NULL;\n \n@@ -4469,6 +4491,7 @@ turn_representatives_into_adjustments (vec<access_p> representatives,\n \t      adj.type = repr->type;\n \t      adj.alias_ptr_type = reference_alias_ptr_type (repr->expr);\n \t      adj.offset = repr->offset;\n+\t      adj.reverse = repr->reverse;\n \t      adj.by_ref = (POINTER_TYPE_P (TREE_TYPE (repr->base))\n \t\t\t    && (repr->grp_maybe_modified\n \t\t\t\t|| repr->grp_not_necessarilly_dereferenced));\n@@ -5099,9 +5122,9 @@ ipa_sra_check_caller (struct cgraph_node *node, void *data)\n \t  tree offset;\n \t  HOST_WIDE_INT bitsize, bitpos;\n \t  machine_mode mode;\n-\t  int unsignedp, volatilep = 0;\n+\t  int unsignedp, reversep, volatilep = 0;\n \t  get_inner_reference (arg, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t       &unsignedp, &volatilep, false);\n+\t\t\t       &unsignedp, &reversep, &volatilep, false);\n \t  if (bitpos % BITS_PER_UNIT)\n \t    {\n \t      iscc->bad_arg_alignment = true;"}, {"sha": "e1d9cda8fe8407f3ad07acfe37e28dee290dc7ad", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -541,10 +541,12 @@ ao_ref_init (ao_ref *r, tree ref)\n tree\n ao_ref_base (ao_ref *ref)\n {\n+  bool reverse;\n+\n   if (ref->base)\n     return ref->base;\n   ref->base = get_ref_base_and_extent (ref->ref, &ref->offset, &ref->size,\n-\t\t\t\t       &ref->max_size);\n+\t\t\t\t       &ref->max_size, &reverse);\n   return ref->base;\n }\n \n@@ -725,9 +727,10 @@ aliasing_component_refs_p (tree ref1,\n   else if (same_p == 1)\n     {\n       HOST_WIDE_INT offadj, sztmp, msztmp;\n-      get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp);\n+      bool reverse;\n+      get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n       offset2 -= offadj;\n-      get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp);\n+      get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp, &reverse);\n       offset1 -= offadj;\n       return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n     }\n@@ -743,9 +746,10 @@ aliasing_component_refs_p (tree ref1,\n   else if (same_p == 1)\n     {\n       HOST_WIDE_INT offadj, sztmp, msztmp;\n-      get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp);\n+      bool reverse;\n+      get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n       offset1 -= offadj;\n-      get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp);\n+      get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n       offset2 -= offadj;\n       return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n     }\n@@ -2281,7 +2285,9 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n       if (ref->max_size == -1)\n \treturn false;\n       HOST_WIDE_INT size, offset, max_size, ref_offset = ref->offset;\n-      tree base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n+      bool reverse;\n+      tree base\n+\t= get_ref_base_and_extent (lhs, &offset, &size, &max_size, &reverse);\n       /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n \t so base == ref->base does not always hold.  */\n       if (base != ref->base)"}, {"sha": "67f2603ab17c0e8364f623ad213b94f2f23adbca", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -474,8 +474,10 @@ mark_aliased_reaching_defs_necessary_1 (ao_ref *ref, tree vdef, void *data)\n     {\n       tree base, lhs = gimple_get_lhs (def_stmt);\n       HOST_WIDE_INT size, offset, max_size;\n+      bool reverse;\n       ao_ref_base (ref);\n-      base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n+      base\n+\t= get_ref_base_and_extent (lhs, &offset, &size, &max_size, &reverse);\n       /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n \t so base == refd->base does not always hold.  */\n       if (base == ref->base)"}, {"sha": "5ae5e72458be1eb01fb2b5332d3206d703dd0e13", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1983,10 +1983,27 @@ may_be_nonaddressable_p (tree expr)\n \t target, thus they are always addressable.  */\n       return false;\n \n+    case MEM_REF:\n+      /* Likewise for MEM_REFs, modulo the storage order.  */\n+      return REF_REVERSE_STORAGE_ORDER (expr);\n+\n+    case BIT_FIELD_REF:\n+      if (REF_REVERSE_STORAGE_ORDER (expr))\n+\treturn true;\n+      return may_be_nonaddressable_p (TREE_OPERAND (expr, 0));\n+\n     case COMPONENT_REF:\n+      if (TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+\treturn true;\n       return DECL_NONADDRESSABLE_P (TREE_OPERAND (expr, 1))\n \t     || may_be_nonaddressable_p (TREE_OPERAND (expr, 0));\n \n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      if (TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+\treturn true;\n+      return may_be_nonaddressable_p (TREE_OPERAND (expr, 0));\n+\n     case VIEW_CONVERT_EXPR:\n       /* This kind of view-conversions may wrap non-addressable objects\n \t and make them look addressable.  After some processing the\n@@ -1995,11 +2012,6 @@ may_be_nonaddressable_p (tree expr)\n       if (is_gimple_reg (TREE_OPERAND (expr, 0))\n \t  || !is_gimple_addressable (TREE_OPERAND (expr, 0)))\n \treturn true;\n-\n-      /* ... fall through ... */\n-\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n       return may_be_nonaddressable_p (TREE_OPERAND (expr, 0));\n \n     CASE_CONVERT:\n@@ -4306,13 +4318,14 @@ split_address_cost (struct ivopts_data *data,\n   HOST_WIDE_INT bitpos;\n   tree toffset;\n   machine_mode mode;\n-  int unsignedp, volatilep;\n+  int unsignedp, reversep, volatilep;\n \n   core = get_inner_reference (addr, &bitsize, &bitpos, &toffset, &mode,\n-\t\t\t      &unsignedp, &volatilep, false);\n+\t\t\t      &unsignedp, &reversep, &volatilep, false);\n \n   if (toffset != 0\n       || bitpos % BITS_PER_UNIT != 0\n+      || reversep\n       || TREE_CODE (core) != VAR_DECL)\n     {\n       *symbol_present = false;"}, {"sha": "6368ddf82660f9599d32773fcce8098e8388dbc8", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -2024,7 +2024,7 @@ find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n      offset from base to compare to other such leaf node.  */\n   HOST_WIDE_INT bitsize, bitpos;\n   machine_mode mode;\n-  int unsignedp, volatilep;\n+  int unsignedp, reversep, volatilep;\n   tree offset, base_addr;\n \n   /* Not prepared to handle PDP endian.  */\n@@ -2035,7 +2035,7 @@ find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n     return false;\n \n   base_addr = get_inner_reference (ref, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t   &unsignedp, &volatilep, false);\n+\t\t\t\t   &unsignedp, &reversep, &volatilep, false);\n \n   if (TREE_CODE (base_addr) == MEM_REF)\n     {\n@@ -2074,6 +2074,8 @@ find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n     return false;\n   if (bitsize % BITS_PER_UNIT)\n     return false;\n+  if (reversep)\n+    return false;\n \n   if (!init_symbolic_number (n, ref))\n     return false;\n@@ -2522,11 +2524,11 @@ bswap_replace (gimple *cur_stmt, gimple *src_stmt, tree fndecl,\n \t{\n \t  HOST_WIDE_INT bitsize, bitpos;\n \t  machine_mode mode;\n-\t  int unsignedp, volatilep;\n+\t  int unsignedp, reversep, volatilep;\n \t  tree offset;\n \n \t  get_inner_reference (src, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t       &unsignedp, &volatilep, false);\n+\t\t\t       &unsignedp, &reversep, &volatilep, false);\n \t  if (n->range < (unsigned HOST_WIDE_INT) bitsize)\n \t    {\n \t      load_offset = (bitsize - n->range) / BITS_PER_UNIT;"}, {"sha": "baafa34d40b08c8c7c8284a3cc37fce223adcfc2", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -2481,6 +2481,7 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \tgenop = build2 (MEM_REF, currop->type, baseop, offset);\n \tMR_DEPENDENCE_CLIQUE (genop) = currop->clique;\n \tMR_DEPENDENCE_BASE (genop) = currop->base;\n+\tREF_REVERSE_STORAGE_ORDER (genop) = currop->reverse;\n \treturn genop;\n       }\n \n@@ -2550,7 +2551,9 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t  return NULL_TREE;\n \ttree op1 = currop->op0;\n \ttree op2 = currop->op1;\n-\treturn fold_build3 (BIT_FIELD_REF, currop->type, genop0, op1, op2);\n+\ttree t = build3 (BIT_FIELD_REF, currop->type, genop0, op1, op2);\n+\tREF_REVERSE_STORAGE_ORDER (t) = currop->reverse;\n+\treturn fold (t);\n       }\n \n       /* For array ref vn_reference_op's, operand 1 of the array ref"}, {"sha": "9585f905438b5ff07dae1e4782fd93b3d052347d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -637,6 +637,9 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)\n \t{\n \t  if (vro1->opcode == MEM_REF)\n \t    deref1 = true;\n+\t  /* Do not look through a storage order barrier.  */\n+\t  else if (vro1->opcode == VIEW_CONVERT_EXPR && vro1->reverse)\n+\t    return false;\n \t  if (vro1->off == -1)\n \t    break;\n \t  off1 += vro1->off;\n@@ -645,6 +648,9 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)\n \t{\n \t  if (vro2->opcode == MEM_REF)\n \t    deref2 = true;\n+\t  /* Do not look through a storage order barrier.  */\n+\t  else if (vro2->opcode == VIEW_CONVERT_EXPR && vro2->reverse)\n+\t    return false;\n \t  if (vro2->off == -1)\n \t    break;\n \t  off2 += vro2->off;\n@@ -748,9 +754,10 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \t    temp.off = tree_to_shwi (TREE_OPERAND (ref, 1));\n \t  temp.clique = MR_DEPENDENCE_CLIQUE (ref);\n \t  temp.base = MR_DEPENDENCE_BASE (ref);\n+\t  temp.reverse = REF_REVERSE_STORAGE_ORDER (ref);\n \t  break;\n \tcase BIT_FIELD_REF:\n-\t  /* Record bits and position.  */\n+\t  /* Record bits, position and storage order.  */\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n \t  temp.op1 = TREE_OPERAND (ref, 2);\n \t  if (tree_fits_shwi_p (TREE_OPERAND (ref, 2)))\n@@ -759,6 +766,7 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \t      if (off % BITS_PER_UNIT == 0)\n \t\ttemp.off = off / BITS_PER_UNIT;\n \t    }\n+\t  temp.reverse = REF_REVERSE_STORAGE_ORDER (ref);\n \t  break;\n \tcase COMPONENT_REF:\n \t  /* The field decl is enough to unambiguously specify the field,\n@@ -855,8 +863,11 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \t     operand), so we don't have to put anything\n \t     for op* as it will be handled by the iteration  */\n \tcase REALPART_EXPR:\n+\t  temp.off = 0;\n+\t  break;\n \tcase VIEW_CONVERT_EXPR:\n \t  temp.off = 0;\n+\t  temp.reverse = storage_order_barrier_p (ref);\n \t  break;\n \tcase IMAGPART_EXPR:\n \t  /* This is only interesting for its constant offset.  */\n@@ -1365,6 +1376,21 @@ fully_constant_vn_reference_p (vn_reference_t ref)\n   return NULL_TREE;\n }\n \n+/* Return true if OPS contain a storage order barrier.  */\n+\n+static bool\n+contains_storage_order_barrier_p (vec<vn_reference_op_s> ops)\n+{\n+  vn_reference_op_t op;\n+  unsigned i;\n+\n+  FOR_EACH_VEC_ELT (ops, i, op)\n+    if (op->opcode == VIEW_CONVERT_EXPR && op->reverse)\n+      return true;\n+\n+  return false;\n+}\n+\n /* Transform any SSA_NAME's in a vector of vn_reference_op_s\n    structures into their value numbers.  This is done in-place, and\n    the vector passed in is returned.  *VALUEIZED_ANYTHING will specify\n@@ -1702,7 +1728,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n       tree ref2 = TREE_OPERAND (gimple_call_arg (def_stmt, 0), 0);\n       tree base2;\n       HOST_WIDE_INT offset2, size2, maxsize2;\n-      base2 = get_ref_base_and_extent (ref2, &offset2, &size2, &maxsize2);\n+      bool reverse;\n+      base2 = get_ref_base_and_extent (ref2, &offset2, &size2, &maxsize2,\n+\t\t\t\t       &reverse);\n       size2 = tree_to_uhwi (gimple_call_arg (def_stmt, 2)) * 8;\n       if ((unsigned HOST_WIDE_INT)size2 / 8\n \t  == tree_to_uhwi (gimple_call_arg (def_stmt, 2))\n@@ -1725,8 +1753,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n     {\n       tree base2;\n       HOST_WIDE_INT offset2, size2, maxsize2;\n+      bool reverse;\n       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n-\t\t\t\t       &offset2, &size2, &maxsize2);\n+\t\t\t\t       &offset2, &size2, &maxsize2, &reverse);\n       if (maxsize2 != -1\n \t  && operand_equal_p (base, base2, 0)\n \t  && offset2 <= offset\n@@ -1746,14 +1775,17 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t   && maxsize % BITS_PER_UNIT == 0\n \t   && offset % BITS_PER_UNIT == 0\n \t   && is_gimple_reg_type (vr->type)\n+\t   && !contains_storage_order_barrier_p (vr->operands)\n \t   && gimple_assign_single_p (def_stmt)\n \t   && is_gimple_min_invariant (gimple_assign_rhs1 (def_stmt)))\n     {\n       tree base2;\n       HOST_WIDE_INT offset2, size2, maxsize2;\n+      bool reverse;\n       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n-\t\t\t\t       &offset2, &size2, &maxsize2);\n-      if (maxsize2 != -1\n+\t\t\t\t       &offset2, &size2, &maxsize2, &reverse);\n+      if (!reverse\n+\t  && maxsize2 != -1\n \t  && maxsize2 == size2\n \t  && size2 % BITS_PER_UNIT == 0\n \t  && offset2 % BITS_PER_UNIT == 0\n@@ -1785,6 +1817,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n      to access pieces from.  */\n   else if (ref->size == maxsize\n \t   && is_gimple_reg_type (vr->type)\n+\t   && !contains_storage_order_barrier_p (vr->operands)\n \t   && gimple_assign_single_p (def_stmt)\n \t   && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n     {\n@@ -1797,10 +1830,13 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t{\n \t  tree base2;\n \t  HOST_WIDE_INT offset2, size2, maxsize2, off;\n+\t  bool reverse;\n \t  base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n-\t\t\t\t\t   &offset2, &size2, &maxsize2);\n+\t\t\t\t\t   &offset2, &size2, &maxsize2,\n+\t\t\t\t\t   &reverse);\n \t  off = offset - offset2;\n-\t  if (maxsize2 != -1\n+\t  if (!reverse\n+\t      && maxsize2 != -1\n \t      && maxsize2 == size2\n \t      && operand_equal_p (base, base2, 0)\n \t      && offset2 <= offset\n@@ -1849,7 +1885,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n     {\n       tree base2;\n       HOST_WIDE_INT maxsize2;\n-      int i, j;\n+      int i, j, k;\n       auto_vec<vn_reference_op_s> rhs;\n       vn_reference_op_t vro;\n       ao_ref r;\n@@ -1909,6 +1945,14 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n       if (j != -1)\n \treturn (void *)-1;\n \n+      /* Punt if the additional ops contain a storage order barrier.  */\n+      for (k = i; k >= 0; k--)\n+\t{\n+\t  vro = &vr->operands[k];\n+\t  if (vro->opcode == VIEW_CONVERT_EXPR && vro->reverse)\n+\t    return (void *)-1;\n+\t}\n+\n       /* Now re-write REF to be based on the rhs of the assignment.  */\n       copy_reference_ops_from_ref (gimple_assign_rhs1 (def_stmt), &rhs);\n \n@@ -1983,7 +2027,6 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n       vn_reference_op_s op;\n       HOST_WIDE_INT at;\n \n-\n       /* Only handle non-variable, addressable refs.  */\n       if (ref->size != maxsize\n \t  || offset % BITS_PER_UNIT != 0"}, {"sha": "bbdca65ce46b3573e291168354fed068754dc09c", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -92,6 +92,7 @@ typedef struct vn_reference_op_struct\n   tree op0;\n   tree op1;\n   tree op2;\n+  bool reverse;\n } vn_reference_op_s;\n typedef vn_reference_op_s *vn_reference_op_t;\n typedef const vn_reference_op_s *const_vn_reference_op_t;"}, {"sha": "f24ebeba815b1629d1b41e97b010488c9b173bfb", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -3168,6 +3168,7 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n   HOST_WIDE_INT bitsize = -1;\n   HOST_WIDE_INT bitmaxsize = -1;\n   HOST_WIDE_INT bitpos;\n+  bool reverse;\n   tree forzero;\n \n   /* Some people like to do cute things like take the address of\n@@ -3189,7 +3190,7 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n       return;\n     }\n \n-  t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize);\n+  t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize, &reverse);\n \n   /* Pretend to take the address of the base, we'll take care of\n      adding the required subset of sub-fields below.  */\n@@ -3615,9 +3616,12 @@ do_structure_copy (tree lhsop, tree rhsop)\n     {\n       HOST_WIDE_INT lhssize, lhsmaxsize, lhsoffset;\n       HOST_WIDE_INT rhssize, rhsmaxsize, rhsoffset;\n+      bool reverse;\n       unsigned k = 0;\n-      get_ref_base_and_extent (lhsop, &lhsoffset, &lhssize, &lhsmaxsize);\n-      get_ref_base_and_extent (rhsop, &rhsoffset, &rhssize, &rhsmaxsize);\n+      get_ref_base_and_extent (lhsop, &lhsoffset, &lhssize, &lhsmaxsize,\n+\t\t\t       &reverse);\n+      get_ref_base_and_extent (rhsop, &rhsoffset, &rhssize, &rhsmaxsize,\n+\t\t\t       &reverse);\n       for (j = 0; lhsc.iterate (j, &lhsp);)\n \t{\n \t  varinfo_t lhsv, rhsv;"}, {"sha": "7417eaf81e75e80b82cae27a045d2086634eb70f", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -136,9 +136,14 @@ unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n   TREE_DEPRECATED (expr) = (unsigned) bp_unpack_value (bp, 1);\n   if (TYPE_P (expr))\n     {\n-      TYPE_SATURATING (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      if (AGGREGATE_TYPE_P (expr))\n+\tTYPE_REVERSE_STORAGE_ORDER (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      else\n+\tTYPE_SATURATING (expr) = (unsigned) bp_unpack_value (bp, 1);\n       TYPE_ADDR_SPACE (expr) = (unsigned) bp_unpack_value (bp, 8);\n     }\n+  else if (TREE_CODE (expr) == BIT_FIELD_REF || TREE_CODE (expr) == MEM_REF)\n+    REF_REVERSE_STORAGE_ORDER (expr) = (unsigned) bp_unpack_value (bp, 1);\n   else if (TREE_CODE (expr) == SSA_NAME)\n     {\n       SSA_NAME_IS_DEFAULT_DEF (expr) = (unsigned) bp_unpack_value (bp, 1);"}, {"sha": "9ca02719a19db2a2d396193730ca6e9d10fea3c1", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -110,9 +110,14 @@ pack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n   bp_pack_value (bp, TREE_DEPRECATED (expr), 1);\n   if (TYPE_P (expr))\n     {\n-      bp_pack_value (bp, TYPE_SATURATING (expr), 1);\n+      if (AGGREGATE_TYPE_P (expr))\n+\tbp_pack_value (bp, TYPE_REVERSE_STORAGE_ORDER (expr), 1);\n+      else\n+\tbp_pack_value (bp, TYPE_SATURATING (expr), 1);\n       bp_pack_value (bp, TYPE_ADDR_SPACE (expr), 8);\n     }\n+  else if (TREE_CODE (expr) == BIT_FIELD_REF || TREE_CODE (expr) == MEM_REF)\n+    bp_pack_value (bp, REF_REVERSE_STORAGE_ORDER (expr), 1);\n   else if (TREE_CODE (expr) == SSA_NAME)\n     {\n       bp_pack_value (bp, SSA_NAME_IS_DEFAULT_DEF (expr), 1);"}, {"sha": "11bce795a5edf524f8f10f9e1d040c9453bcc2f6", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -3027,7 +3027,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n   tree offtype = NULL_TREE;\n   tree decl, base, off;\n   machine_mode pmode;\n-  int punsignedp, pvolatilep;\n+  int punsignedp, reversep, pvolatilep = 0;\n \n   base = DR_REF (dr);\n   /* For masked loads/stores, DR_REF (dr) is an artificial MEM_REF,\n@@ -3059,9 +3059,9 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n      vectorized.  The following code attempts to find such a preexistng\n      SSA_NAME OFF and put the loop invariants into a tree BASE\n      that can be gimplified before the loop.  */\n-  base = get_inner_reference (base, &pbitsize, &pbitpos, &off,\n-\t\t\t      &pmode, &punsignedp, &pvolatilep, false);\n-  gcc_assert (base != NULL_TREE && (pbitpos % BITS_PER_UNIT) == 0);\n+  base = get_inner_reference (base, &pbitsize, &pbitpos, &off, &pmode,\n+\t\t\t      &punsignedp, &reversep, &pvolatilep, false);\n+  gcc_assert (base && (pbitpos % BITS_PER_UNIT) == 0 && !reversep);\n \n   if (TREE_CODE (base) == MEM_REF)\n     {\n@@ -3515,7 +3515,7 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \t  HOST_WIDE_INT pbitsize, pbitpos;\n \t  tree poffset;\n \t  machine_mode pmode;\n-\t  int punsignedp, pvolatilep;\n+\t  int punsignedp, preversep, pvolatilep;\n \t  affine_iv base_iv, offset_iv;\n \t  tree dinit;\n \n@@ -3534,7 +3534,8 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \t    }\n \n \t  outer_base = get_inner_reference (inner_base, &pbitsize, &pbitpos,\n-\t\t          &poffset, &pmode, &punsignedp, &pvolatilep, false);\n+\t\t\t\t\t    &poffset, &pmode, &punsignedp,\n+\t\t\t\t\t    &preversep, &pvolatilep, false);\n \t  gcc_assert (outer_base != NULL_TREE);\n \n \t  if (pbitpos % BITS_PER_UNIT != 0)\n@@ -3545,6 +3546,14 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \t      return false;\n \t    }\n \n+\t  if (preversep)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"failed: reverse storage order.\\n\");\n+\t      return false;\n+\t    }\n+\n \t  outer_base = build_fold_addr_expr (outer_base);\n \t  if (!simple_iv (loop, loop_containing_stmt (stmt), outer_base,\n                           &base_iv, false))"}, {"sha": "ff414f7a62dc810b37c53da4a07b55bc971c28d7", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -4207,6 +4207,7 @@ stabilize_reference (tree ref)\n       result = build_nt (BIT_FIELD_REF,\n \t\t\t stabilize_reference (TREE_OPERAND (ref, 0)),\n \t\t\t TREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2));\n+      REF_REVERSE_STORAGE_ORDER (result) = REF_REVERSE_STORAGE_ORDER (ref);\n       break;\n \n     case ARRAY_REF:\n@@ -12943,7 +12944,10 @@ verify_type_variant (const_tree t, tree tv)\n   verify_variant_match (TYPE_PACKED);\n   if (TREE_CODE (t) == REFERENCE_TYPE)\n     verify_variant_match (TYPE_REF_IS_RVALUE);\n-  verify_variant_match (TYPE_SATURATING);\n+  if (AGGREGATE_TYPE_P (t))\n+    verify_variant_match (TYPE_REVERSE_STORAGE_ORDER);\n+  else\n+    verify_variant_match (TYPE_SATURATING);\n   /* FIXME: This check trigger during libstdc++ build.  */\n   if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t) && 0)\n     verify_variant_match (TYPE_FINAL_P);\n@@ -13265,6 +13269,7 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n       if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n \t\t\t\t\t\ttrust_type_canonical)\n \t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n+\t  || TYPE_REVERSE_STORAGE_ORDER (t1) != TYPE_REVERSE_STORAGE_ORDER (t2)\n \t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n \treturn false;\n       else\n@@ -13338,6 +13343,9 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n       {\n \ttree f1, f2;\n \n+\tif (TYPE_REVERSE_STORAGE_ORDER (t1) != TYPE_REVERSE_STORAGE_ORDER (t2))\n+\t  return false;\n+\n \t/* For aggregate types, all the fields must be the same.  */\n \tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n \t     f1 || f2;"}, {"sha": "e71eba43d50836e38407d829dcd0ec53224fce5c", "filename": "gcc/tree.h", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -905,8 +905,29 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define IDENTIFIER_TRANSPARENT_ALIAS(NODE) \\\n   (IDENTIFIER_NODE_CHECK (NODE)->base.deprecated_flag)\n \n-/* In fixed-point types, means a saturating type.  */\n-#define TYPE_SATURATING(NODE) (TYPE_CHECK (NODE)->base.u.bits.saturating_flag)\n+/* In an aggregate type, indicates that the scalar fields of the type are\n+   stored in reverse order from the target order.  This effectively\n+   toggles BYTES_BIG_ENDIAN and WORDS_BIG_ENDIAN within the type.  */\n+#define TYPE_REVERSE_STORAGE_ORDER(NODE) \\\n+  (TREE_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ARRAY_TYPE)->base.u.bits.saturating_flag)\n+\n+/* In a non-aggregate type, indicates a saturating type.  */\n+#define TYPE_SATURATING(NODE) \\\n+  (TREE_NOT_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ARRAY_TYPE)->base.u.bits.saturating_flag)\n+\n+/* In a BIT_FIELD_REF and MEM_REF, indicates that the reference is to a group\n+   of bits stored in reverse order from the target order.  This effectively\n+   toggles both BYTES_BIG_ENDIAN and WORDS_BIG_ENDIAN for the reference.\n+\n+   The overall strategy is to preserve the invariant that every scalar in\n+   memory is associated with a single storage order, i.e. all accesses to\n+   this scalar are done with the same storage order.  This invariant makes\n+   it possible to factor out the storage order in most transformations, as\n+   only the address and/or the value (in target order) matter for them.\n+   But, of course, the storage order must be preserved when the accesses\n+   themselves are rewritten or transformed.  */\n+#define REF_REVERSE_STORAGE_ORDER(NODE) \\\n+  (TREE_CHECK2 (NODE, BIT_FIELD_REF, MEM_REF)->base.u.bits.saturating_flag)\n \n /* These flags are available for each language front end to use internally.  */\n #define TREE_LANG_FLAG_0(NODE) \\\n@@ -4350,6 +4371,64 @@ handled_component_p (const_tree t)\n     }\n }\n \n+/* Return true T is a component with reverse storage order.  */\n+\n+static inline bool\n+reverse_storage_order_for_component_p (tree t)\n+{\n+  /* The storage order only applies to scalar components.  */\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (t)) || VECTOR_TYPE_P (TREE_TYPE (t)))\n+    return false;\n+\n+  if (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case ARRAY_REF:\n+    case COMPONENT_REF:\n+      /* ??? Fortran can take COMPONENT_REF of a void type.  */\n+      return !VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0)))\n+\t     && TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_OPERAND (t, 0)));\n+\n+    case BIT_FIELD_REF:\n+    case MEM_REF:\n+      return REF_REVERSE_STORAGE_ORDER (t);\n+\n+    case ARRAY_RANGE_REF:\n+    case VIEW_CONVERT_EXPR:\n+    default:\n+      return false;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return true if T is a storage order barrier, i.e. a VIEW_CONVERT_EXPR\n+   that can modify the storage order of objects.  Note that, even if the\n+   TYPE_REVERSE_STORAGE_ORDER flag is set on both the inner type and the\n+   outer type, a VIEW_CONVERT_EXPR can modify the storage order because\n+   it can change the partition of the aggregate object into scalars.  */\n+\n+static inline bool\n+storage_order_barrier_p (const_tree t)\n+{\n+  if (TREE_CODE (t) != VIEW_CONVERT_EXPR)\n+    return false;\n+\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n+      && TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (t)))\n+    return true;\n+\n+  tree op = TREE_OPERAND (t, 0);\n+\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (op))\n+      && TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (op)))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */\n \n@@ -5152,7 +5231,7 @@ extern bool complete_ctor_at_level_p (const_tree, HOST_WIDE_INT, const_tree);\n    the access position and size.  */\n extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t tree *, machine_mode *, int *, int *,\n-\t\t\t\t bool);\n+\t\t\t\t int *, bool);\n \n extern tree build_personality_function (const char *);\n "}, {"sha": "e3263f8538a6271fe9ed95faef6b4e97eca800a0", "filename": "gcc/tsan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -108,9 +108,9 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   machine_mode mode;\n-  int volatilep = 0, unsignedp = 0;\n-  base = get_inner_reference (expr, &bitsize, &bitpos, &offset,\n-\t\t\t      &mode, &unsignedp, &volatilep, false);\n+  int unsignedp, reversep, volatilep = 0;\n+  base = get_inner_reference (expr, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t      &unsignedp, &reversep, &volatilep, false);\n \n   /* No need to instrument accesses to decls that don't escape,\n      they can't escape to other threads then.  */"}, {"sha": "6fc6233c035edc3b0ada840daf817e6678c5c390", "filename": "gcc/ubsan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -1359,9 +1359,9 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   machine_mode mode;\n-  int volatilep = 0, unsignedp = 0;\n+  int volatilep = 0, reversep, unsignedp = 0;\n   tree base = get_inner_reference (rhs, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t   &unsignedp, &volatilep, false);\n+\t\t\t\t   &unsignedp, &reversep, &volatilep, false);\n   tree utype = build_nonstandard_integer_type (modebitsize, 1);\n \n   if ((TREE_CODE (base) == VAR_DECL && DECL_HARD_REGISTER (base))\n@@ -1779,9 +1779,9 @@ instrument_object_size (gimple_stmt_iterator *gsi, bool is_lhs)\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   machine_mode mode;\n-  int volatilep = 0, unsignedp = 0;\n+  int volatilep = 0, reversep, unsignedp = 0;\n   tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t    &unsignedp, &volatilep, false);\n+\t\t\t\t    &unsignedp, &reversep, &volatilep, false);\n \n   if (bitpos % BITS_PER_UNIT != 0\n       || bitsize != size_in_bytes * BITS_PER_UNIT)"}, {"sha": "388b5348e5b535eeadbb280e8e99c0bbaba79655", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -5058,9 +5058,10 @@ track_expr_p (tree expr, bool need_rtl)\n \t\t  && TREE_CODE (TREE_OPERAND (realdecl, 0)) == ADDR_EXPR))\n \t    {\n \t      HOST_WIDE_INT bitsize, bitpos, maxsize;\n+\t      bool reverse;\n \t      tree innerdecl\n \t\t= get_ref_base_and_extent (realdecl, &bitpos, &bitsize,\n-\t\t\t\t\t   &maxsize);\n+\t\t\t\t\t   &maxsize, &reverse);\n \t      if (!DECL_P (innerdecl)\n \t\t  || DECL_IGNORED_P (innerdecl)\n \t\t  /* Do not track declarations for parts of tracked parameters"}, {"sha": "ec6aabf3d8e110e3db2e74f6564305143bba9d78", "filename": "gcc/varasm.c", "status": "modified", "additions": 84, "deletions": 37, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"stmt.h\"\n #include \"expr.h\"\n+#include \"expmed.h\"\n #include \"output.h\"\n #include \"langhooks.h\"\n #include \"debug.h\"\n@@ -106,7 +107,7 @@ static int compare_constant (const tree, const tree);\n static void output_constant_def_contents (rtx);\n static void output_addressed_constants (tree);\n static unsigned HOST_WIDE_INT output_constant (tree, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t       unsigned int);\n+\t\t\t\t\t       unsigned int, bool);\n static void globalize_decl (tree);\n static bool decl_readonly_section_1 (enum section_category);\n #ifdef BSS_SECTION_ASM_OP\n@@ -2054,7 +2055,8 @@ assemble_variable_contents (tree decl, const char *name,\n \t/* Output the actual data.  */\n \toutput_constant (DECL_INITIAL (decl),\n \t\t\t tree_to_uhwi (DECL_SIZE_UNIT (decl)),\n-\t\t\t get_variable_align (decl));\n+\t\t\t get_variable_align (decl),\n+\t\t\t false);\n       else\n \t/* Leave space for it.  */\n \tassemble_zeros (tree_to_uhwi (DECL_SIZE_UNIT (decl)));\n@@ -2733,12 +2735,17 @@ assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n   return false;\n }\n \f\n+/* Assemble the floating-point constant D into an object of size MODE.  ALIGN\n+   is the alignment of the constant in bits.  If REVERSE is true, D is output\n+   in reverse storage order.  */\n+\n void\n-assemble_real (REAL_VALUE_TYPE d, machine_mode mode, unsigned int align)\n+assemble_real (REAL_VALUE_TYPE d, machine_mode mode, unsigned int align,\n+\t       bool reverse)\n {\n   long data[4] = {0, 0, 0, 0};\n-  int i;\n   int bitsize, nelts, nunits, units_per;\n+  rtx elt;\n \n   /* This is hairy.  We have a quantity of known size.  real_to_target\n      will put it into an array of *host* longs, 32 bits per element\n@@ -2760,15 +2767,24 @@ assemble_real (REAL_VALUE_TYPE d, machine_mode mode, unsigned int align)\n   real_to_target (data, &d, mode);\n \n   /* Put out the first word with the specified alignment.  */\n-  assemble_integer (GEN_INT (data[0]), MIN (nunits, units_per), align, 1);\n+  if (reverse)\n+    elt = flip_storage_order (SImode, gen_int_mode (data[nelts - 1], SImode));\n+  else\n+    elt = GEN_INT (data[0]);\n+  assemble_integer (elt, MIN (nunits, units_per), align, 1);\n   nunits -= units_per;\n \n   /* Subsequent words need only 32-bit alignment.  */\n   align = min_align (align, 32);\n \n-  for (i = 1; i < nelts; i++)\n+  for (int i = 1; i < nelts; i++)\n     {\n-      assemble_integer (GEN_INT (data[i]), MIN (nunits, units_per), align, 1);\n+      if (reverse)\n+\telt = flip_storage_order (SImode,\n+\t\t\t\t  gen_int_mode (data[nelts - 1 - i], SImode));\n+      else\n+\telt = GEN_INT (data[i]);\n+      assemble_integer (elt, MIN (nunits, units_per), align, 1);\n       nunits -= units_per;\n     }\n }\n@@ -3070,10 +3086,12 @@ compare_constant (const tree t1, const tree t2)\n \tif (typecode == ARRAY_TYPE)\n \t  {\n \t    HOST_WIDE_INT size_1 = int_size_in_bytes (TREE_TYPE (t1));\n-\t    /* For arrays, check that the sizes all match.  */\n+\t    /* For arrays, check that mode, size and storage order match.  */\n \t    if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2))\n \t\t|| size_1 == -1\n-\t\t|| size_1 != int_size_in_bytes (TREE_TYPE (t2)))\n+\t\t|| size_1 != int_size_in_bytes (TREE_TYPE (t2))\n+\t\t|| TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (t1))\n+\t\t   != TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (t2)))\n \t      return 0;\n \t  }\n \telse\n@@ -3357,7 +3375,7 @@ assemble_constant_contents (tree exp, const char *label, unsigned int align)\n   targetm.asm_out.declare_constant_name (asm_out_file, label, exp, size);\n \n   /* Output the value of EXP.  */\n-  output_constant (exp, size, align);\n+  output_constant (exp, size, align, false);\n \n   targetm.asm_out.decl_end ();\n }\n@@ -3788,7 +3806,7 @@ output_constant_pool_2 (machine_mode mode, rtx x, unsigned int align)\n     case MODE_DECIMAL_FLOAT:\n       {\n \tgcc_assert (CONST_DOUBLE_AS_FLOAT_P (x));\n-\tassemble_real (*CONST_DOUBLE_REAL_VALUE (x), mode, align);\n+\tassemble_real (*CONST_DOUBLE_REAL_VALUE (x), mode, align, false);\n \tbreak;\n       }\n \n@@ -4288,7 +4306,11 @@ initializer_constant_valid_p_1 (tree value, tree endtype, tree *cache)\n \t      tree reloc;\n \t      reloc = initializer_constant_valid_p_1 (elt, TREE_TYPE (elt),\n \t\t\t\t\t\t      NULL);\n-\t      if (!reloc)\n+\t      if (!reloc\n+\t\t  /* An absolute value is required with reverse SSO.  */\n+\t\t  || (reloc != null_pointer_node\n+\t\t      && TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (value))\n+\t\t      && !AGGREGATE_TYPE_P (TREE_TYPE (elt))))\n \t\t{\n \t\t  if (cache)\n \t\t    {\n@@ -4528,9 +4550,19 @@ initializer_constant_valid_p_1 (tree value, tree endtype, tree *cache)\n    therefore, we do not need to check for such things as\n    arithmetic-combinations of integers.  */\n tree\n-initializer_constant_valid_p (tree value, tree endtype)\n+initializer_constant_valid_p (tree value, tree endtype, bool reverse)\n {\n-  return initializer_constant_valid_p_1 (value, endtype, NULL);\n+  tree reloc = initializer_constant_valid_p_1 (value, endtype, NULL);\n+\n+  /* An absolute value is required with reverse storage order.  */\n+  if (reloc\n+      && reloc != null_pointer_node\n+      && reverse\n+      && !AGGREGATE_TYPE_P (endtype)\n+      && !VECTOR_TYPE_P (endtype))\n+    reloc = NULL_TREE;\n+\n+  return reloc;\n }\n \f\n /* Return true if VALUE is a valid constant-valued expression\n@@ -4580,8 +4612,8 @@ struct oc_outer_state {\n };\n \n static unsigned HOST_WIDE_INT\n-  output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int,\n-\t\t      oc_outer_state *);\n+output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int, bool,\n+\t\t    oc_outer_state *);\n \n /* Output assembler code for constant EXP, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n@@ -4603,13 +4635,17 @@ static unsigned HOST_WIDE_INT\n    for a structure constructor that wants to produce more than SIZE bytes.\n    But such constructors will never be generated for any possible input.\n \n-   ALIGN is the alignment of the data in bits.  */\n+   ALIGN is the alignment of the data in bits.\n+\n+   If REVERSE is true, EXP is output in reverse storage order.  */\n \n static unsigned HOST_WIDE_INT\n-output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n+output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align,\n+\t\t bool reverse)\n {\n   enum tree_code code;\n   unsigned HOST_WIDE_INT thissize;\n+  rtx cst;\n \n   if (size == 0 || flag_syntax_only)\n     return size;\n@@ -4704,31 +4740,34 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n     case FIXED_POINT_TYPE:\n     case POINTER_BOUNDS_TYPE:\n     case NULLPTR_TYPE:\n-      if (! assemble_integer (expand_expr (exp, NULL_RTX, VOIDmode,\n-\t\t\t\t\t   EXPAND_INITIALIZER),\n-\t\t\t      MIN (size, thissize), align, 0))\n+      cst = expand_expr (exp, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n+      if (reverse)\n+\tcst = flip_storage_order (TYPE_MODE (TREE_TYPE (exp)), cst);\n+      if (!assemble_integer (cst, MIN (size, thissize), align, 0))\n \terror (\"initializer for integer/fixed-point value is too complicated\");\n       break;\n \n     case REAL_TYPE:\n       if (TREE_CODE (exp) != REAL_CST)\n \terror (\"initializer for floating value is not a floating constant\");\n       else\n-\tassemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)), align);\n+\tassemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)),\n+\t\t       align, reverse);\n       break;\n \n     case COMPLEX_TYPE:\n-      output_constant (TREE_REALPART (exp), thissize / 2, align);\n+      output_constant (TREE_REALPART (exp), thissize / 2, align, reverse);\n       output_constant (TREE_IMAGPART (exp), thissize / 2,\n-\t\t       min_align (align, BITS_PER_UNIT * (thissize / 2)));\n+\t\t       min_align (align, BITS_PER_UNIT * (thissize / 2)),\n+\t\t       reverse);\n       break;\n \n     case ARRAY_TYPE:\n     case VECTOR_TYPE:\n       switch (TREE_CODE (exp))\n \t{\n \tcase CONSTRUCTOR:\n-\t  return output_constructor (exp, size, align, NULL);\n+\t  return output_constructor (exp, size, align, reverse, NULL);\n \tcase STRING_CST:\n \t  thissize\n \t    = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp), size);\n@@ -4739,11 +4778,13 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \t    machine_mode inner = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \t    unsigned int nalign = MIN (align, GET_MODE_ALIGNMENT (inner));\n \t    int elt_size = GET_MODE_SIZE (inner);\n-\t    output_constant (VECTOR_CST_ELT (exp, 0), elt_size, align);\n+\t    output_constant (VECTOR_CST_ELT (exp, 0), elt_size, align,\n+\t\t\t     reverse);\n \t    thissize = elt_size;\n \t    for (unsigned int i = 1; i < VECTOR_CST_NELTS (exp); i++)\n \t      {\n-\t\toutput_constant (VECTOR_CST_ELT (exp, i), elt_size, nalign);\n+\t\toutput_constant (VECTOR_CST_ELT (exp, i), elt_size, nalign,\n+\t\t\t\t reverse);\n \t\tthissize += elt_size;\n \t      }\n \t    break;\n@@ -4756,7 +4797,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n       gcc_assert (TREE_CODE (exp) == CONSTRUCTOR);\n-      return output_constructor (exp, size, align, NULL);\n+      return output_constructor (exp, size, align, reverse, NULL);\n \n     case ERROR_MARK:\n       return 0;\n@@ -4770,7 +4811,6 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \n   return size;\n }\n-\n \f\n /* Subroutine of output_constructor, used for computing the size of\n    arrays of unspecified length.  VAL must be a CONSTRUCTOR of an array\n@@ -4832,6 +4872,7 @@ struct oc_local_state {\n   int last_relative_index;    /* Implicit or explicit index of the last\n \t\t\t\t array element output within a bitfield.  */\n   bool byte_buffer_in_use;    /* Whether BYTE is in use.  */\n+  bool reverse;               /* Whether reverse storage order is in use.  */\n \n   /* Current element.  */\n   tree field;      /* Current field decl in a record.  */\n@@ -4864,7 +4905,8 @@ output_constructor_array_range (oc_local_state *local)\n       if (local->val == NULL_TREE)\n \tassemble_zeros (fieldsize);\n       else\n-\tfieldsize = output_constant (local->val, fieldsize, align2);\n+\tfieldsize\n+\t  = output_constant (local->val, fieldsize, align2, local->reverse);\n \n       /* Count its size.  */\n       local->total_bytes += fieldsize;\n@@ -4950,7 +4992,8 @@ output_constructor_regular_field (oc_local_state *local)\n   if (local->val == NULL_TREE)\n     assemble_zeros (fieldsize);\n   else\n-    fieldsize = output_constant (local->val, fieldsize, align2);\n+    fieldsize\n+      = output_constant (local->val, fieldsize, align2, local->reverse);\n \n   /* Count its size.  */\n   local->total_bytes += fieldsize;\n@@ -5048,7 +5091,7 @@ output_constructor_bitfield (oc_local_state *local, unsigned int bit_offset)\n       temp_state.bit_offset = next_offset % BITS_PER_UNIT;\n       temp_state.byte = local->byte;\n       local->total_bytes\n-\t  += output_constructor (local->val, 0, 0, &temp_state);\n+\t+= output_constructor (local->val, 0, 0, local->reverse, &temp_state);\n       local->byte = temp_state.byte;\n       return;\n     }\n@@ -5074,9 +5117,9 @@ output_constructor_bitfield (oc_local_state *local, unsigned int bit_offset)\n \n       /* Number of bits we can process at once (all part of the same byte).  */\n       this_time = MIN (end_offset - next_offset, BITS_PER_UNIT - next_bit);\n-      if (BYTES_BIG_ENDIAN)\n+      if (local->reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n \t{\n-\t  /* On big-endian machine, take the most significant bits (of the\n+\t  /* For big-endian data, take the most significant bits (of the\n \t     bits that are significant) first and put them into bytes from\n \t     the most significant end.  */\n \t  shift = end_offset - next_offset - this_time;\n@@ -5138,12 +5181,11 @@ output_constructor_bitfield (oc_local_state *local, unsigned int bit_offset)\n    caller output state of relevance in recursive invocations.  */\n \n static unsigned HOST_WIDE_INT\n-output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n-\t\t    unsigned int align, oc_outer_state *outer)\n+output_constructor (tree exp, unsigned HOST_WIDE_INT size, unsigned int align,\n+\t\t    bool reverse, oc_outer_state *outer)\n {\n   unsigned HOST_WIDE_INT cnt;\n   constructor_elt *ce;\n-\n   oc_local_state local;\n \n   /* Setup our local state to communicate with helpers.  */\n@@ -5160,6 +5202,11 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n   local.byte_buffer_in_use = outer != NULL;\n   local.byte = outer ? outer->byte : 0;\n   local.last_relative_index = -1;\n+  /* The storage order is specified for every aggregate type.  */\n+  if (AGGREGATE_TYPE_P (local.type))\n+    local.reverse = TYPE_REVERSE_STORAGE_ORDER (local.type);\n+  else\n+    local.reverse = reverse;\n \n   gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_UNIT);\n "}, {"sha": "8025e7c47ab68febb09298f1519f88b7833e4a00", "filename": "gcc/varasm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fvarasm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee45a32dae253f7daa966573eb8cb64b2cf7bf52/gcc%2Fvarasm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.h?ref=ee45a32dae253f7daa966573eb8cb64b2cf7bf52", "patch": "@@ -60,7 +60,7 @@ extern void assemble_alias (tree, tree);\n    We assume that VALUE has been folded as much as possible;\n    therefore, we do not need to check for such things as\n    arithmetic-combinations of integers.  */\n-extern tree initializer_constant_valid_p (tree, tree);\n+extern tree initializer_constant_valid_p (tree, tree, bool = false);\n \n /* Return true if VALUE is a valid constant-valued expression\n    for use in initializing a static bit-field; one that can be"}]}