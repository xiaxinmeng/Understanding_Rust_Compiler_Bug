{"sha": "fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ1ZDViOTRhMWEyYjc5ODcyNGZkN2Q5MmYzMDllY2FjOGMyZWIzNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-13T05:59:36Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-13T05:59:36Z"}, "message": "(output_init_element): Don't call default_conversion for a STRING_CST if type is directly suitable for it.\n\n(output_init_element): Don't call default_conversion\nfor a STRING_CST if type is directly suitable for it.\n(digest_init): Eliminate a lot of code that checks the variable\n'element', since element is always 0 in these code paths.\n\n(build_c_cast): For (void *) (FOO *) 0, return a nop_expr\nso it doesn't count as a null pointer constant.\n(convert_for_assignment, build_binary_op): Pedantically warn about\nthat case if looking for a null_pointer_constant.\n(build_conditional_expr): Likewise.\n\nFrom-SVN: r5150", "tree": {"sha": "697b2c1b5383b07e70aec42bf38da374ebf3920f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/697b2c1b5383b07e70aec42bf38da374ebf3920f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34/comments", "author": null, "committer": null, "parents": [{"sha": "1930a6180e9d24e5fe15304ca7da3cc0dbd87e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1930a6180e9d24e5fe15304ca7da3cc0dbd87e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1930a6180e9d24e5fe15304ca7da3cc0dbd87e18"}], "stats": {"total": 87, "additions": 33, "deletions": 54}, "files": [{"sha": "2088f00f8e6762310348a91567207f651ad2c2f6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 33, "deletions": 54, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=fd5d5b94a1a2b798724fd7d92f309ecac8c2eb34", "patch": "@@ -1,5 +1,5 @@\n /* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -2575,13 +2575,15 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t    ;\n \t  else if (TYPE_MAIN_VARIANT (tt0) == void_type_node)\n \t    {\n-\t      if (pedantic && !integer_zerop (op0)\n+\t      /* op0 != orig_op0 detects the case of something\n+\t\t whose value is 0 but which isn't a valid null ptr const.  */\n+\t      if (pedantic && (!integer_zerop (op0) || op0 != orig_op0)\n \t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n \t\tpedwarn (\"ANSI C forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else if (TYPE_MAIN_VARIANT (tt1) == void_type_node)\n \t    {\n-\t      if (pedantic && !integer_zerop (op1)\n+\t      if (pedantic && (!integer_zerop (op1) || op1 != orig_op1)\n \t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n \t\tpedwarn (\"ANSI C forbids comparison of `void *' with function pointer\");\n \t    }\n@@ -3619,6 +3621,7 @@ build_conditional_expr (ifexp, op1, op2)\n   register enum tree_code code1;\n   register enum tree_code code2;\n   register tree result_type = NULL;\n+  tree orig_op1 = op1, orig_op2 = op2;\n \n   /* If second operand is omitted, it is the same as the first one;\n      make sure it is calculated only once.  */\n@@ -3689,9 +3692,11 @@ build_conditional_expr (ifexp, op1, op2)\n     {\n       if (comp_target_types (type1, type2))\n \tresult_type = common_type (type1, type2);\n-      else if (integer_zerop (op1) && TREE_TYPE (type1) == void_type_node)\n+      else if (integer_zerop (op1) && TREE_TYPE (type1) == void_type_node\n+\t       && TREE_CODE (orig_op1) != NOP_EXPR)\n \tresult_type = qualify_type (type2, type1);\n-      else if (integer_zerop (op2) && TREE_TYPE (type2) == void_type_node)\n+      else if (integer_zerop (op2) && TREE_TYPE (type2) == void_type_node\n+\t       && TREE_CODE (orig_op2) != NOP_EXPR)\n \tresult_type = qualify_type (type1, type2);\n       else if (TYPE_MAIN_VARIANT (TREE_TYPE (type1)) == void_type_node)\n \t{\n@@ -3999,11 +4004,16 @@ build_c_cast (type, expr)\n \t}\n     }\n \n+  /* Pedantically, don't ley (void *) (FOO *) 0 be a null pointer constant.  */\n+  if (pedantic && TREE_CODE (value) == INTEGER_CST\n+      && TREE_CODE (expr) == INTEGER_CST\n+      && TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE)\n+    value = non_lvalue (value);\n+\n+  /* If pedantic, don't let a cast be an lvalue.  */\n   if (value == expr && pedantic)\n-    {\n-      /* If pedantic, don't let a cast be an lvalue.  */\n-      return non_lvalue (value);\n-    }\n+    value = non_lvalue (value);\n+\n   return value;\n }\n \f\n@@ -4309,7 +4319,9 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t   && TREE_CODE (ttr) == FUNCTION_TYPE)\n \t\t  ||\n \t\t  (TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t\t   && !integer_zerop (rhs)\n+\t\t   /* Check TREE_CODE to catch cases like (void *) (char *) 0\n+\t\t      which are not ANSI null ptr constants.  */\n+\t\t   && (!integer_zerop (rhs) || TREE_CODE (rhs) == NOP_EXPR)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n \t    warn_for_assignment (\"ANSI forbids %s between function pointer and `void *'\",\n \t\t\t\t get_spelling (errtype), funname, parmnum);\n@@ -4854,7 +4866,6 @@ digest_init (type, init, require_constant, constructor_constant)\n      int require_constant, constructor_constant;\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree element = 0;\n   tree inside_init = init;\n \n   if (init == error_mark_node)\n@@ -4877,23 +4888,20 @@ digest_init (type, init, require_constant, constructor_constant)\n \t   || typ1 == unsigned_char_type_node\n \t   || typ1 == unsigned_wchar_type_node\n \t   || typ1 == signed_wchar_type_node)\n-\t  && ((inside_init && TREE_CODE (inside_init) == STRING_CST)\n-\t      || (element && TREE_CODE (element) == STRING_CST)))\n+\t  && ((inside_init && TREE_CODE (inside_init) == STRING_CST)))\n \t{\n-\t  tree string = element ? element : inside_init;\n-\n-\t  if (TREE_TYPE (string) == type)\n-\t    return string;\n+\t  if (TREE_TYPE (inside_init) == type)\n+\t    return inside_init;\n \n-\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n+\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)))\n \t       != char_type_node)\n \t      && TYPE_PRECISION (typ1) == TYPE_PRECISION (char_type_node))\n \t    {\n \t      error_init (\"char-array%s initialized from wide string\",\n \t\t\t  \" `%s'\", NULL);\n \t      return error_mark_node;\n \t    }\n-\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n+\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)))\n \t       == char_type_node)\n \t      && TYPE_PRECISION (typ1) != TYPE_PRECISION (char_type_node))\n \t    {\n@@ -4902,7 +4910,7 @@ digest_init (type, init, require_constant, constructor_constant)\n \t      return error_mark_node;\n \t    }\n \n-\t  TREE_TYPE (string) = type;\n+\t  TREE_TYPE (inside_init) = type;\n \t  if (TYPE_DOMAIN (type) != 0\n \t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n \t    {\n@@ -4911,15 +4919,15 @@ digest_init (type, init, require_constant, constructor_constant)\n \t      /* Subtract 1 (or sizeof (wchar_t))\n \t\t because it's ok to ignore the terminating null char\n \t\t that is counted in the length of the constant.  */\n-\t      if (size < TREE_STRING_LENGTH (string)\n+\t      if (size < TREE_STRING_LENGTH (inside_init)\n \t\t  - (TYPE_PRECISION (typ1) != TYPE_PRECISION (char_type_node)\n \t\t     ? TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT\n \t\t     : 1))\n \t\tpedwarn_init (\n \t\t  \"initializer-string for array of chars%s is too long\",\n \t\t  \" `%s'\", NULL);\n \t    }\n-\t  return string;\n+\t  return inside_init;\n \t}\n     }\n \n@@ -4970,38 +4978,6 @@ digest_init (type, init, require_constant, constructor_constant)\n       return inside_init;\n     }\n \n-  if (element && (TREE_TYPE (element) == type\n-\t\t  || (code == ARRAY_TYPE && TREE_TYPE (element)\n-\t\t      && comptypes (TREE_TYPE (element), type))))\n-    {\n-      if (code == ARRAY_TYPE)\n-\t{\n-\t  error_init (\"array%s initialized from non-constant array expression\",\n-\t\t      \" `%s'\", NULL);\n-\t  return error_mark_node;\n-\t}\n-      if (pedantic && (code == RECORD_TYPE || code == UNION_TYPE))\n-\tpedwarn (\"single-expression nonscalar initializer has braces\");\n-      if (optimize && TREE_READONLY (element) && TREE_CODE (element) == VAR_DECL)\n-\telement = decl_constant_value (element);\n-\n-      if (require_constant && ! TREE_CONSTANT (element))\n-\t{\n-\t  error_init (\"initializer element%s is not constant\",\n-\t\t      \" for `%s'\", NULL);\n-\t  element = error_mark_node;\n-\t}\n-      else if (require_constant\n-\t       && initializer_constant_valid_p (element, TREE_TYPE (element)) == 0)\n-\t{\n-\t  error_init (\"initializer element%s is not computable at load time\",\n-\t\t      \" for `%s'\", NULL);\n-\t  element = error_mark_node;\n-\t}\n-\n-      return element;\n-    }\n-\n   /* Handle scalar types, including conversions.  */\n \n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n@@ -5747,6 +5723,9 @@ output_init_element (value, type, field, pending)\n \n   if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n       || (TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n+\t  && !(TREE_CODE (value) == STRING_CST\n+\t       && TREE_CODE (type) == ARRAY_TYPE\n+\t       && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)\n \t  && !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (value)),\n \t\t\t TYPE_MAIN_VARIANT (type))))\n     value = default_conversion (value);"}]}