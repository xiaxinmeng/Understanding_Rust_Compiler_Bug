{"sha": "5f3bc026061e59f2722ae17f2329d005e0f95559", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYzYmMwMjYwNjFlNTlmMjcyMmFlMTdmMjMyOWQwMDVlMGY5NTU1OQ==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@arm.com", "date": "2015-01-16T11:48:00Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2015-01-16T11:48:00Z"}, "message": "[AArch64] Enable CCMP support for AArch64, PR64015 resolved\n\ngcc/\n2015-01-16  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n\n\tPR target/64015\n\t* ccmp.c (expand_ccmp_next): New function.\n\t(expand_ccmp_expr_1, expand_ccmp_expr): Handle operand insn sequence\n\tand compare insn sequence.\n\t* config/aarch64/aarch64.c (aarch64_code_to_ccmode,\n\taarch64_gen_ccmp_first, aarch64_gen_ccmp_next): New functions.\n\t(TARGET_GEN_CCMP_FIRST, TARGET_GEN_CCMP_NEXT): New MICRO.\n\t* config/aarch64/aarch64.md (*ccmp_and): Changed to ccmp_and<mode>.\n\t(*ccmp_ior): Changed to ccmp_ior<mode>.\n\t(cmp<mode>): New pattern.\n\t* doc/tm.texi (TARGET_GEN_CCMP_FIRST, TARGET_GEN_CCMP_NEXT): Update\n\tparameters.\n\t* target.def (gen_ccmp_first, gen_ccmp_next): Update parameters.\n\ngcc/testsuite/\n2015-01-16  Zhenqiang Chen <zhenqiang.chen@arm.com>\n\n\t* gcc.dg/pr64015.c: New test.\n\nFrom-SVN: r219723", "tree": {"sha": "27ea8ad4328db1388fa321a414f446c2caef54ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27ea8ad4328db1388fa321a414f446c2caef54ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f3bc026061e59f2722ae17f2329d005e0f95559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3bc026061e59f2722ae17f2329d005e0f95559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f3bc026061e59f2722ae17f2329d005e0f95559", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3bc026061e59f2722ae17f2329d005e0f95559/comments", "author": null, "committer": null, "parents": [{"sha": "fe23ff4b1ad4bbb359643ca7004b6fdbc63d83df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe23ff4b1ad4bbb359643ca7004b6fdbc63d83df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe23ff4b1ad4bbb359643ca7004b6fdbc63d83df"}], "stats": {"total": 413, "additions": 335, "deletions": 78}, "files": [{"sha": "198e5e11a8cccdef9dc461f954741cfc6273f8b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -1,3 +1,19 @@\n+2015-01-16  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n+\n+\tPR target/64015\n+\t* ccmp.c (expand_ccmp_next): New function.\n+\t(expand_ccmp_expr_1, expand_ccmp_expr): Handle operand insn sequence\n+\tand compare insn sequence.\n+\t* config/aarch64/aarch64.c (aarch64_code_to_ccmode,\n+\taarch64_gen_ccmp_first, aarch64_gen_ccmp_next): New functions.\n+\t(TARGET_GEN_CCMP_FIRST, TARGET_GEN_CCMP_NEXT): New MICRO.\n+\t* config/aarch64/aarch64.md (*ccmp_and): Changed to ccmp_and<mode>.\n+\t(*ccmp_ior): Changed to ccmp_ior<mode>.\n+\t(cmp<mode>): New pattern.\n+\t* doc/tm.texi (TARGET_GEN_CCMP_FIRST, TARGET_GEN_CCMP_NEXT): Update\n+\tparameters.\n+\t* target.def (gen_ccmp_first, gen_ccmp_next): Update parameters.\n+\n 2015-01-16  Ilya Tocar  <ilya.tocar@intel.com>\n \n \t* config/i386/avx2intrin.h (_mm256_bslli_epi128,"}, {"sha": "903d5a865de1c19bdf23fd1897dea98574f65cef", "filename": "gcc/ccmp.c", "status": "modified", "additions": 65, "deletions": 58, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -92,7 +92,16 @@ along with GCC; see the file COPYING3.  If not see\n \n      * If the final result is not used in a COND_EXPR (checked by function\n        used_in_cond_stmt_p), it calls cstorecc4 pattern to store the CC to a\n-       general register.  */\n+       general register.\n+\n+   Since the operands of the later compares might clobber CC reg, we do not\n+   emit the insns during expand.  We keep the insn sequences in two seq\n+\n+     * prep_seq, which includes all the insns to prepare the operands.\n+     * gen_seq, which includes all the compare and conditional compares.\n+\n+   If all checks OK in expand_ccmp_expr, it emits insns in prep_seq, then\n+   insns in gen_seq.  */\n \n /* Check whether G is a potential conditional compare candidate.  */\n static bool\n@@ -172,6 +181,27 @@ used_in_cond_stmt_p (tree exp)\n   return expand_cond;\n }\n \n+/* PREV is the CC flag from precvious compares.  The function expands the\n+   next compare based on G which ops previous compare with CODE.\n+   PREP_SEQ returns all insns to prepare opearands for compare.\n+   GEN_SEQ returnss all compare insns.  */\n+static rtx\n+expand_ccmp_next (gimple g, enum tree_code code, rtx prev,\n+\t\t  rtx *prep_seq, rtx *gen_seq)\n+{\n+  enum rtx_code rcode;\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)));\n+\n+  gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);\n+\n+  rcode = get_rtx_code (gimple_assign_rhs_code (g), unsignedp);\n+\n+  return targetm.gen_ccmp_next (prep_seq, gen_seq, prev, rcode,\n+\t\t\t\tgimple_assign_rhs1 (g),\n+\t\t\t\tgimple_assign_rhs2 (g),\n+\t\t\t\tget_rtx_code (code, 0));\n+}\n+\n /* Expand conditional compare gimple G.  A typical CCMP sequence is like:\n \n      CC0 = CMP (a, b);\n@@ -180,9 +210,11 @@ used_in_cond_stmt_p (tree exp)\n      CCn = CCMP (NE (CCn-1, 0), CMP (...));\n \n    hook gen_ccmp_first is used to expand the first compare.\n-   hook gen_ccmp_next is used to expand the following CCMP.  */\n+   hook gen_ccmp_next is used to expand the following CCMP.\n+   PREP_SEQ returns all insns to prepare opearand.\n+   GEN_SEQ returns all compare insns.  */\n static rtx\n-expand_ccmp_expr_1 (gimple g)\n+expand_ccmp_expr_1 (gimple g, rtx *prep_seq, rtx *gen_seq)\n {\n   tree exp = gimple_assign_rhs_to_tree (g);\n   enum tree_code code = TREE_CODE (exp);\n@@ -199,52 +231,27 @@ expand_ccmp_expr_1 (gimple g)\n     {\n       if (TREE_CODE_CLASS (code1) == tcc_comparison)\n \t{\n-\t  int unsignedp0, unsignedp1;\n-\t  enum rtx_code rcode0, rcode1;\n-\t  rtx op0, op1, op2, op3, tmp;\n+\t  int unsignedp0;\n+\t  enum rtx_code rcode0;\n \n \t  unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs0)));\n \t  rcode0 = get_rtx_code (code0, unsignedp0);\n-\t  unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs1)));\n-\t  rcode1 = get_rtx_code (code1, unsignedp1);\n-\n-\t  expand_operands (gimple_assign_rhs1 (gs0),\n-\t\t\t   gimple_assign_rhs2 (gs0),\n-\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-\n-\t  /* Since the operands of GS1 might clobber CC reg, we expand the\n-\t     operands of GS1 before GEN_CCMP_FIRST.  */\n-\t  expand_operands (gimple_assign_rhs1 (gs1),\n-\t\t\t   gimple_assign_rhs2 (gs1),\n-\t\t\t   NULL_RTX, &op2, &op3, EXPAND_NORMAL);\n-\t  tmp = targetm.gen_ccmp_first (rcode0, op0, op1);\n+\n+\t  tmp = targetm.gen_ccmp_first (prep_seq, gen_seq, rcode0,\n+\t\t\t\t\tgimple_assign_rhs1 (gs0),\n+\t\t\t\t\tgimple_assign_rhs2 (gs0));\n \t  if (!tmp)\n \t    return NULL_RTX;\n \n-\t  return targetm.gen_ccmp_next (tmp, rcode1, op2, op3,\n-\t\t\t\t\tget_rtx_code (code, 0));\n+\t  return expand_ccmp_next (gs1, code, tmp, prep_seq, gen_seq);\n \t}\n       else\n \t{\n-  \t  rtx op0, op1;\n-\t  enum rtx_code rcode;\n-\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs0)));\n-\n-\t  rcode = get_rtx_code (gimple_assign_rhs_code (gs0), unsignedp);\n-\n-\t  /* Hoist the preparation operations above the entire\n-\t     conditional compare sequence.  */\n-\t  expand_operands (gimple_assign_rhs1 (gs0),\n-\t\t\t   gimple_assign_rhs2 (gs0),\n-\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-\n-\t  gcc_assert (code1 == BIT_AND_EXPR || code1 == BIT_IOR_EXPR);\n+\t  tmp = expand_ccmp_expr_1 (gs1, prep_seq, gen_seq);\n+\t  if (!tmp)\n+\t    return NULL_RTX;\n \n-\t  /* Note: We swap the order to make the recursive function work.  */\n-\t  tmp = expand_ccmp_expr_1 (gs1);\n-\t  if (tmp)\n-\t    return targetm.gen_ccmp_next (tmp, rcode, op0, op1,\n-\t\t\t\t\t  get_rtx_code (code, 0));\n+\t  return expand_ccmp_next (gs0, code, tmp, prep_seq, gen_seq);\n \t}\n     }\n   else\n@@ -254,21 +261,11 @@ expand_ccmp_expr_1 (gimple g)\n \n       if (TREE_CODE_CLASS (gimple_assign_rhs_code (gs1)) == tcc_comparison)\n \t{\n-  \t  rtx op0, op1;\n-\t  enum rtx_code rcode;\n-\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs1)));\n-\n-\t  rcode = get_rtx_code (gimple_assign_rhs_code (gs1), unsignedp);\n-\n-\t  /* Hoist the preparation operations above the entire\n-\t     conditional compare sequence.  */\n-\t  expand_operands (gimple_assign_rhs1 (gs1),\n-\t\t\t   gimple_assign_rhs2 (gs1),\n-\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-\t  tmp = expand_ccmp_expr_1 (gs0);\n-\t  if (tmp)\n-\t    return targetm.gen_ccmp_next (tmp, rcode, op0, op1,\n-\t\t\t\t\t  get_rtx_code (code, 0));\n+\t  tmp = expand_ccmp_expr_1 (gs0, prep_seq, gen_seq);\n+\t  if (!tmp)\n+\t    return NULL_RTX;\n+\n+\t  return expand_ccmp_next (gs1, code, tmp, prep_seq, gen_seq);\n \t}\n       else\n \t{\n@@ -288,23 +285,30 @@ expand_ccmp_expr (gimple g)\n {\n   rtx_insn *last;\n   rtx tmp;\n+  rtx prep_seq, gen_seq;\n+\n+  prep_seq = gen_seq = NULL_RTX;\n \n   if (!ccmp_candidate_p (g))\n     return NULL_RTX;\n \n   last = get_last_insn ();\n-  tmp = expand_ccmp_expr_1 (g);\n+  tmp = expand_ccmp_expr_1 (g, &prep_seq, &gen_seq);\n \n   if (tmp)\n     {\n       enum insn_code icode;\n       enum machine_mode cc_mode = CCmode;\n-\n       tree lhs = gimple_assign_lhs (g);\n+\n       /* TMP should be CC.  If it is used in a GIMPLE_COND, just return it.\n \t Note: Target needs to define \"cbranchcc4\".  */\n       if (used_in_cond_stmt_p (lhs))\n-\treturn tmp;\n+\t{\n+\t  emit_insn (prep_seq);\n+\t  emit_insn (gen_seq);\n+\t  return tmp;\n+\t}\n \n #ifdef SELECT_CC_MODE\n       cc_mode = SELECT_CC_MODE (NE, tmp, const0_rtx);\n@@ -314,9 +318,12 @@ expand_ccmp_expr (gimple g)\n       icode = optab_handler (cstore_optab, cc_mode);\n       if (icode != CODE_FOR_nothing)\n \t{\n-\t  tree lhs = gimple_assign_lhs (g);\n \t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n \t  rtx target = gen_reg_rtx (mode);\n+\n+\t  emit_insn (prep_seq);\n+\t  emit_insn (gen_seq);\n+\n \t  tmp = emit_cstore (target, icode, NE, cc_mode, cc_mode,\n \t\t\t     0, tmp, const0_rtx, 1, mode);\n \t  if (tmp)"}, {"sha": "f3cf6ed06432d2dad8da5e3387428a1f72004d05", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -10381,6 +10381,198 @@ aarch64_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n   return default_use_by_pieces_infrastructure_p (size, align, op, speed_p);\n }\n \n+static enum machine_mode\n+aarch64_code_to_ccmode (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case NE:\n+      return CC_DNEmode;\n+\n+    case EQ:\n+      return CC_DEQmode;\n+\n+    case LE:\n+      return CC_DLEmode;\n+\n+    case LT:\n+      return CC_DLTmode;\n+\n+    case GE:\n+      return CC_DGEmode;\n+\n+    case GT:\n+      return CC_DGTmode;\n+\n+    case LEU:\n+      return CC_DLEUmode;\n+\n+    case LTU:\n+      return CC_DLTUmode;\n+\n+    case GEU:\n+      return CC_DGEUmode;\n+\n+    case GTU:\n+      return CC_DGTUmode;\n+\n+    default:\n+      return CCmode;\n+    }\n+}\n+\n+static rtx\n+aarch64_gen_ccmp_first (rtx *prep_seq, rtx *gen_seq,\n+\t\t\tint code, tree treeop0, tree treeop1)\n+{\n+  enum machine_mode op_mode, cmp_mode, cc_mode;\n+  rtx op0, op1, cmp, target;\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (treeop0));\n+  enum insn_code icode;\n+  struct expand_operand ops[4];\n+\n+  cc_mode = aarch64_code_to_ccmode ((enum rtx_code) code);\n+  if (cc_mode == CCmode)\n+    return NULL_RTX;\n+\n+  start_sequence ();\n+  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\n+  op_mode = GET_MODE (op0);\n+  if (op_mode == VOIDmode)\n+    op_mode = GET_MODE (op1);\n+\n+  switch (op_mode)\n+    {\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+      cmp_mode = SImode;\n+      icode = CODE_FOR_cmpsi;\n+      break;\n+\n+    case DImode:\n+      cmp_mode = DImode;\n+      icode = CODE_FOR_cmpdi;\n+      break;\n+\n+    default:\n+      end_sequence ();\n+      return NULL_RTX;\n+    }\n+\n+  op0 = prepare_operand (icode, op0, 2, op_mode, cmp_mode, unsignedp);\n+  op1 = prepare_operand (icode, op1, 3, op_mode, cmp_mode, unsignedp);\n+  if (!op0 || !op1)\n+    {\n+      end_sequence ();\n+      return NULL_RTX;\n+    }\n+  *prep_seq = get_insns ();\n+  end_sequence ();\n+\n+  cmp = gen_rtx_fmt_ee ((enum rtx_code) code, cmp_mode, op0, op1);\n+  target = gen_rtx_REG (CCmode, CC_REGNUM);\n+\n+  create_output_operand (&ops[0], target, CCmode);\n+  create_fixed_operand (&ops[1], cmp);\n+  create_fixed_operand (&ops[2], op0);\n+  create_fixed_operand (&ops[3], op1);\n+\n+  start_sequence ();\n+  if (!maybe_expand_insn (icode, 4, ops))\n+    {\n+      end_sequence ();\n+      return NULL_RTX;\n+    }\n+  *gen_seq = get_insns ();\n+  end_sequence ();\n+\n+  return gen_rtx_REG (cc_mode, CC_REGNUM);\n+}\n+\n+static rtx\n+aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n+\t\t       tree treeop0, tree treeop1, int bit_code)\n+{\n+  rtx op0, op1, cmp0, cmp1, target;\n+  enum machine_mode op_mode, cmp_mode, cc_mode;\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (treeop0));\n+  enum insn_code icode = CODE_FOR_ccmp_andsi;\n+  struct expand_operand ops[6];\n+\n+  cc_mode = aarch64_code_to_ccmode ((enum rtx_code) cmp_code);\n+  if (cc_mode == CCmode)\n+    return NULL_RTX;\n+\n+  push_to_sequence ((rtx_insn*) *prep_seq);\n+  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\n+  op_mode = GET_MODE (op0);\n+  if (op_mode == VOIDmode)\n+    op_mode = GET_MODE (op1);\n+\n+  switch (op_mode)\n+    {\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+      cmp_mode = SImode;\n+      icode = (enum rtx_code) bit_code == AND ? CODE_FOR_ccmp_andsi\n+\t\t\t\t\t\t: CODE_FOR_ccmp_iorsi;\n+      break;\n+\n+    case DImode:\n+      cmp_mode = DImode;\n+      icode = (enum rtx_code) bit_code == AND ? CODE_FOR_ccmp_anddi\n+\t\t\t\t\t\t: CODE_FOR_ccmp_iordi;\n+      break;\n+\n+    default:\n+      end_sequence ();\n+      return NULL_RTX;\n+    }\n+\n+  op0 = prepare_operand (icode, op0, 2, op_mode, cmp_mode, unsignedp);\n+  op1 = prepare_operand (icode, op1, 3, op_mode, cmp_mode, unsignedp);\n+  if (!op0 || !op1)\n+    {\n+      end_sequence ();\n+      return NULL_RTX;\n+    }\n+  *prep_seq = get_insns ();\n+  end_sequence ();\n+\n+  target = gen_rtx_REG (cc_mode, CC_REGNUM);\n+  cmp1 = gen_rtx_fmt_ee ((enum rtx_code) cmp_code, cmp_mode, op0, op1);\n+  cmp0 = gen_rtx_fmt_ee (NE, cmp_mode, prev, const0_rtx);\n+\n+  create_fixed_operand (&ops[0], prev);\n+  create_fixed_operand (&ops[1], target);\n+  create_fixed_operand (&ops[2], op0);\n+  create_fixed_operand (&ops[3], op1);\n+  create_fixed_operand (&ops[4], cmp0);\n+  create_fixed_operand (&ops[5], cmp1);\n+\n+  push_to_sequence ((rtx_insn*) *gen_seq);\n+  if (!maybe_expand_insn (icode, 6, ops))\n+    {\n+      end_sequence ();\n+      return NULL_RTX;\n+    }\n+\n+  *gen_seq = get_insns ();\n+  end_sequence ();\n+\n+  return target;\n+}\n+\n+#undef TARGET_GEN_CCMP_FIRST\n+#define TARGET_GEN_CCMP_FIRST aarch64_gen_ccmp_first\n+\n+#undef TARGET_GEN_CCMP_NEXT\n+#define TARGET_GEN_CCMP_NEXT aarch64_gen_ccmp_next\n+\n /* Implement TARGET_SCHED_MACRO_FUSION_P.  Return true if target supports\n    instruction fusion of some sort.  */\n "}, {"sha": "c780e417d2827114e16fbfd3d298d4e5b59855b7", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -248,7 +248,7 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*ccmp_and\"\n+(define_insn \"ccmp_and<mode>\"\n   [(set (match_operand 1 \"ccmp_cc_register\" \"\")\n \t(compare\n \t (and:SI\n@@ -267,7 +267,7 @@\n   [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n )\n \n-(define_insn \"*ccmp_ior\"\n+(define_insn \"ccmp_ior<mode>\"\n   [(set (match_operand 1 \"ccmp_cc_register\" \"\")\n \t(compare\n \t (ior:SI\n@@ -286,6 +286,20 @@\n   [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n )\n \n+(define_expand \"cmp<mode>\"\n+  [(set (match_operand 0 \"cc_register\" \"\")\n+        (match_operator:CC 1 \"aarch64_comparison_operator\"\n+         [(match_operand:GPI 2 \"register_operand\" \"\")\n+          (match_operand:GPI 3 \"aarch64_plus_operand\" \"\")]))]\n+  \"\"\n+  {\n+    operands[1] = gen_rtx_fmt_ee (COMPARE,\n+\t\t\t\t  SELECT_CC_MODE (GET_CODE (operands[1]),\n+\t\t\t\t\t\t  operands[2], operands[3]),\n+\t\t\t\t  operands[2], operands[3]);\n+  }\n+)\n+\n (define_insn \"*condjump\"\n   [(set (pc) (if_then_else (match_operator 0 \"aarch64_comparison_operator\"\n \t\t\t    [(match_operand 1 \"cc_register\" \"\") (const_int 0)])"}, {"sha": "9c81fdb98d47acd30f890a2eeae1a000d444e024", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -11259,18 +11259,25 @@ This target hook is required only when the target has several different\n modes and they have different conditional execution capability, such as ARM.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_FIRST (int @var{code}, rtx @var{op0}, rtx @var{op1})\n-This function emits a comparison insn for the first of a sequence of\n- conditional comparisions.  It returns a comparison expression appropriate\n- for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.  @var{code} is\n+@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_FIRST (rtx *@var{prep_seq}, rtx *@var{gen_seq}, int @var{code}, tree @var{op0}, tree @var{op1})\n+This function prepares to emit a comparison insn for the first compare in a\n+ sequence of conditional comparisions.  It returns a appropriate @code{CC}\n+ for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to\n+ prepare the compare are saved in @var{prep_seq} and the compare insns are\n+ saved in @var{gen_seq}.  They will be emitted when all the compares in the\n+ the conditional comparision are generated without error.  @var{code} is\n  the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_NEXT (rtx @var{prev}, int @var{cmp_code}, rtx @var{op0}, rtx @var{op1}, int @var{bit_code})\n-This function emits a conditional comparison within a sequence of\n- conditional comparisons.  The @var{prev} expression is the result of a\n- prior call to @code{gen_ccmp_first} or @code{gen_ccmp_next}.  It may return\n- @code{NULL} if the combination of @var{prev} and this comparison is\n+@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_NEXT (rtx *@var{prep_seq}, rtx *@var{gen_seq}, rtx @var{prev}, int @var{cmp_code}, tree @var{op0}, tree @var{op1}, int @var{bit_code})\n+This function prepare to emit a conditional comparison within a sequence of\n+ conditional comparisons.  It returns a appropriate @code{CC} for passing to\n+ @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to prepare the\n+ compare are saved in @var{prep_seq} and the compare insns are saved in\n+ @var{gen_seq}.  They will be emitted when all the compares in the conditional\n+ comparision are generated without error.  The @var{prev} expression is the\n+ result of a prior call to @code{gen_ccmp_first} or @code{gen_ccmp_next}.  It\n+ may return @code{NULL} if the combination of @var{prev} and this comparison is\n  not supported, otherwise the result must be appropriate for passing to\n  @code{gen_ccmp_next} or @code{cbranch_optab}.  @var{code} is the\n  @code{rtx_code} of the compare for @var{op0} and @var{op1}.  @var{bit_code}"}, {"sha": "356f7c1c9a4934de6b69c54f0a616827e5523981", "filename": "gcc/target.def", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -2542,24 +2542,31 @@ modes and they have different conditional execution capability, such as ARM.\",\n \n DEFHOOK\n (gen_ccmp_first,\n- \"This function emits a comparison insn for the first of a sequence of\\n\\\n- conditional comparisions.  It returns a comparison expression appropriate\\n\\\n- for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.  @var{code} is\\n\\\n+ \"This function prepares to emit a comparison insn for the first compare in a\\n\\\n+ sequence of conditional comparisions.  It returns a appropriate @code{CC}\\n\\\n+ for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to\\n\\\n+ prepare the compare are saved in @var{prep_seq} and the compare insns are\\n\\\n+ saved in @var{gen_seq}.  They will be emitted when all the compares in the\\n\\\n+ the conditional comparision are generated without error.  @var{code} is\\n\\\n  the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\",\n- rtx, (int code, rtx op0, rtx op1),\n+ rtx, (rtx *prep_seq, rtx *gen_seq, int code, tree op0, tree op1),\n  NULL)\n \n DEFHOOK\n (gen_ccmp_next,\n- \"This function emits a conditional comparison within a sequence of\\n\\\n- conditional comparisons.  The @var{prev} expression is the result of a\\n\\\n- prior call to @code{gen_ccmp_first} or @code{gen_ccmp_next}.  It may return\\n\\\n- @code{NULL} if the combination of @var{prev} and this comparison is\\n\\\n+ \"This function prepare to emit a conditional comparison within a sequence of\\n\\\n+ conditional comparisons.  It returns a appropriate @code{CC} for passing to\\n\\\n+ @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to prepare the\\n\\\n+ compare are saved in @var{prep_seq} and the compare insns are saved in\\n\\\n+ @var{gen_seq}.  They will be emitted when all the compares in the conditional\\n\\\n+ comparision are generated without error.  The @var{prev} expression is the\\n\\\n+ result of a prior call to @code{gen_ccmp_first} or @code{gen_ccmp_next}.  It\\n\\\n+ may return @code{NULL} if the combination of @var{prev} and this comparison is\\n\\\n  not supported, otherwise the result must be appropriate for passing to\\n\\\n  @code{gen_ccmp_next} or @code{cbranch_optab}.  @var{code} is the\\n\\\n  @code{rtx_code} of the compare for @var{op0} and @var{op1}.  @var{bit_code}\\n\\\n  is @code{AND} or @code{IOR}, which is the op on the two compares.\",\n- rtx, (rtx prev, int cmp_code, rtx op0, rtx op1, int bit_code),\n+ rtx, (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code, tree op0, tree op1, int bit_code),\n  NULL)\n \n /* Return a new value for loop unroll size.  */"}, {"sha": "72c6283755c3e2cd9c9d014f10519db2dcbcc492", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -1,3 +1,7 @@\n+2015-01-16  Zhenqiang Chen <zhenqiang.chen@arm.com>\n+\n+\t* gcc.dg/pr64015.c: New test.\n+\n 2015-01-16  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \tPR ipa/64163"}, {"sha": "daf839351d7761f63caadfeb2d7d9bd4c93f487a", "filename": "gcc/testsuite/gcc.dg/pr64015.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64015.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3bc026061e59f2722ae17f2329d005e0f95559/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64015.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64015.c?ref=5f3bc026061e59f2722ae17f2329d005e0f95559", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 \" } */\n+\n+int\n+test (unsigned short a, unsigned char b)\n+{\n+  return a > 0xfff2 && b > 252;\n+}\n+\n+/* { dg-final { scan-assembler \"ccmp\" { target aarch64*-*-* } } } */"}]}