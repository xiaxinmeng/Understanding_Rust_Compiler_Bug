{"sha": "8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5ZmI5YmIzNThhZWFjNDhiY2EyMDk1YTQ1ZTAzMDZkNGE2YjdkYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-03-19T22:37:33Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-03-19T22:37:33Z"}, "message": "re PR target/65240 (ICE (insn does not satisfy its constraints) on powerpc64le-linux-gnu)\n\n[gcc]\n2015-03-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/65240\n\t* config/rs6000/predicates.md (easy_fp_constant): Remove special\n\t-ffast-math handling that kept non-0 constants live in the RTL\n\tuntil reload.  Remove logic testing the number of instructions it\n\ttook to create a constant in a GPR that was never used, due to a\n\ttest for soft-float earlier.\n\t(memory_fp_constant): Delete, no longer used.\n\n\t* config/rs6000/rs6000.md (mov<MODE>_hardfloat): Remove\n\talternatives for loading non-0 constants into GPRs for hard\n\tfloating point that is no longer needed due to changes in\n\teasy_fp_constant.  Add support for loading 0.0 into GPRs.\n\t(mov<mode>_hardfloat32): Likewise.\n\t(mov<mode>_hardfloat64): Likewise.\n\t(mov<mode>_64bit_dm): Likewise.\n\t(movtd_64bit_nodm): Likewise.\n\t(pre-reload move FP constant define_split): Delete define_split,\n\tsince it is no longer used.\n\t(extenddftf2_internal): Remove GHF constraints that are not valid\n\tfor extenddftf2.\n\n[gcc/testsuite]\n2015-03-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/65240\n\t* gcc/testsuite/g++.dg/pr65240.h: Add tests for PR 65240.\n\t* gcc/testsuite/g++.dg/pr65240-1.C: Likewise.\n\t* gcc/testsuite/g++.dg/pr65240-2.C: Likewise.\n\t* gcc/testsuite/g++.dg/pr65240-3.C: Likewise.\n\t* gcc/testsuite/g++.dg/pr65240-4.C: Likewise.\n\nFrom-SVN: r221524", "tree": {"sha": "5e637e4c0de219dabaa221d54e60d5940317137c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e637e4c0de219dabaa221d54e60d5940317137c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/comments", "author": null, "committer": null, "parents": [{"sha": "ef0006ebdb71de99e15aef9fd2a2d7c1830c6011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef0006ebdb71de99e15aef9fd2a2d7c1830c6011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef0006ebdb71de99e15aef9fd2a2d7c1830c6011"}], "stats": {"total": 5735, "additions": 5623, "deletions": 112}, "files": [{"sha": "ac23c4181ad3736bccee27b36642209bd8673b31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -1,3 +1,26 @@\n+2015-03-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/65240\n+\t* config/rs6000/predicates.md (easy_fp_constant): Remove special\n+\t-ffast-math handling that kept non-0 constants live in the RTL\n+\tuntil reload.  Remove logic testing the number of instructions it\n+\ttook to create a constant in a GPR that was never used, due to a\n+\ttest for soft-float earlier.\n+\t(memory_fp_constant): Delete, no longer used.\n+\n+\t* config/rs6000/rs6000.md (mov<MODE>_hardfloat): Remove\n+\talternatives for loading non-0 constants into GPRs for hard\n+\tfloating point that is no longer needed due to changes in\n+\teasy_fp_constant.  Add support for loading 0.0 into GPRs.\n+\t(mov<mode>_hardfloat32): Likewise.\n+\t(mov<mode>_hardfloat64): Likewise.\n+\t(mov<mode>_64bit_dm): Likewise.\n+\t(movtd_64bit_nodm): Likewise.\n+\t(pre-reload move FP constant define_split): Delete define_split,\n+\tsince it is no longer used.\n+\t(extenddftf2_internal): Remove GHF constraints that are not valid\n+\tfor extenddftf2.\n+\n 2015-03-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65380"}, {"sha": "6abb40b5cffaaa9370476763de37467953e1ce73", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 15, "deletions": 73, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -432,9 +432,6 @@\n (define_predicate \"easy_fp_constant\"\n   (match_code \"const_double\")\n {\n-  long k[4];\n-  REAL_VALUE_TYPE rv;\n-\n   if (GET_MODE (op) != mode\n       || (!SCALAR_FLOAT_MODE_P (mode) && mode != DImode))\n     return 0;\n@@ -446,8 +443,7 @@\n     return 1;\n \n   /* The constant 0.0 is easy under VSX.  */\n-  if ((mode == SFmode || mode == DFmode || mode == SDmode || mode == DDmode)\n-      && VECTOR_UNIT_VSX_P (DFmode) && op == CONST0_RTX (mode))\n+  if (TARGET_VSX && SCALAR_FLOAT_MODE_P (mode) && op == CONST0_RTX (mode))\n     return 1;\n \n   if (DECIMAL_FLOAT_MODE_P (mode))\n@@ -464,82 +460,28 @@\n     return 0;\n #endif\n \n+  /* If we have real FPRs, consider floating point constants hard (other than\n+     0.0 under VSX), so that the constant gets pushed to memory during the\n+     early RTL phases.  This has the advantage that double precision constants\n+     that can be represented in single precision without a loss of precision\n+     will use single precision loads.  */\n+\n   switch (mode)\n     {\n     case TFmode:\n-      if (TARGET_E500_DOUBLE)\n-\treturn 0;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n-\n-      return (num_insns_constant_wide ((HOST_WIDE_INT) k[0]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[2]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[3]) == 1);\n-\n     case DFmode:\n-      /* Force constants to memory before reload to utilize\n-\t compress_float_constant.\n-\t Avoid this when flag_unsafe_math_optimizations is enabled\n-\t because RDIV division to reciprocal optimization is not able\n-\t to regenerate the division.  */\n-      if (TARGET_E500_DOUBLE\n-          || (!reload_in_progress && !reload_completed\n-\t      && !flag_unsafe_math_optimizations))\n-        return 0;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n-\n-      return (num_insns_constant_wide ((HOST_WIDE_INT) k[0]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1);\n-\n     case SFmode:\n-      /* Force constants to memory before reload to utilize\n-\t compress_float_constant.\n-\t Avoid this when flag_unsafe_math_optimizations is enabled\n-\t because RDIV division to reciprocal optimization is not able\n-\t to regenerate the division.  */\n-      if (!reload_in_progress && !reload_completed\n-          && !flag_unsafe_math_optimizations)\n-\treturn 0;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_SINGLE (rv, k[0]);\n-\n-      return num_insns_constant_wide (k[0]) == 1;\n-\n-  case DImode:\n-    return (num_insns_constant (op, DImode) <= 2);\n-\n-  case SImode:\n-    return 1;\n-\n-  default:\n-    gcc_unreachable ();\n-  }\n-})\n+      return 0;\n \n-;; Return 1 if the operand must be loaded from memory.  This is used by a\n-;; define_split to insure constants get pushed to the constant pool before\n-;; reload.  If -ffast-math is used, easy_fp_constant will allow move insns to\n-;; have constants in order not interfere with reciprocal estimation.  However,\n-;; with -mupper-regs support, these constants must be moved to the constant\n-;; pool before register allocation.\n+    case DImode:\n+      return (num_insns_constant (op, DImode) <= 2);\n \n-(define_predicate \"memory_fp_constant\"\n-  (match_code \"const_double\")\n-{\n-  if (TARGET_VSX && op == CONST0_RTX (mode))\n-    return 0;\n+    case SImode:\n+      return 1;\n \n-  if (!TARGET_HARD_FLOAT || !TARGET_FPRS\n-      || (mode == SFmode && !TARGET_SINGLE_FLOAT)\n-      || (mode == DFmode && !TARGET_DOUBLE_FLOAT))\n-    return 0;\n-\t  \n-  return 1;\n+    default:\n+      gcc_unreachable ();\n+    }\n })\n \n ;; Return 1 if the operand is a CONST_VECTOR and can be loaded into a"}, {"sha": "aec696e385ad8dd5100247d96072d7d221860c6d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -8048,8 +8048,8 @@\n }\")\n \n (define_insn \"mov<mode>_hardfloat\"\n-  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,<f32_vsx>,<f32_vsx>,<f32_lr>,<f32_sm>,<f32_av>,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r\")\n-\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,<f32_vsx>,j,<f32_lm>,<f32_sr>,Z,<f32_av>,r,<f32_dm>,r,h,0,G,Fn\"))]\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,<f32_vsx>,<f32_vsx>,!r,<f32_lr>,<f32_sm>,<f32_av>,Z,?<f32_dm>,?r,*c*l,!r,*h\")\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,<f32_vsx>,j,j,<f32_lm>,<f32_sr>,Z,<f32_av>,r,<f32_dm>,r,h,0\"))]\n   \"(gpc_reg_operand (operands[0], <MODE>mode)\n    || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)\"\n@@ -8060,6 +8060,7 @@\n    fmr %0,%1\n    xxlor %x0,%x1,%x1\n    xxlxor %x0,%x0,%x0\n+   li %0,0\n    <f32_li>\n    <f32_si>\n    <f32_lv>\n@@ -8068,11 +8069,9 @@\n    mfvsrwz %0,%x1\n    mt%0 %1\n    mf%1 %0\n-   nop\n-   #\n-   #\"\n-  [(set_attr \"type\" \"*,load,store,fp,vecsimple,vecsimple,fpload,fpstore,fpload,fpstore,mftgpr,mffgpr,mtjmpr,mfjmpr,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8\")])\n+   nop\"\n+  [(set_attr \"type\" \"*,load,store,fp,vecsimple,vecsimple,integer,fpload,fpstore,fpload,fpstore,mftgpr,mffgpr,mtjmpr,mfjmpr,*\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"*mov<mode>_softfloat\"\n   [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=r,cl,r,r,m,r,r,r,r,*h\")\n@@ -8186,9 +8185,12 @@\n ;; since the D-form version of the memory instructions does not need a GPR for\n ;; reloading.\n \n+;; If we have FPR registers, rs6000_emit_move has moved all constants to memory,\n+;; except for 0.0 which can be created on VSX with an xor instruction.\n+\n (define_insn \"*mov<mode>_hardfloat32\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,Y,r,!r,!r,!r,!r\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,r,Y,r,G,H,F\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,j,r,Y,r\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -8203,11 +8205,9 @@\n    #\n    #\n    #\n-   #\n-   #\n    #\"\n-  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,vecsimple,vecsimple,store,load,two,fp,fp,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,8,8,8,8,12,16\")])\n+  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,vecsimple,vecsimple,two,store,load,two\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,8,8,8,8\")])\n \n (define_insn \"*mov<mode>_softfloat32\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n@@ -8225,8 +8225,8 @@\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*mov<mode>_hardfloat64\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,<f64_dm>\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,r,Y,r,r,h,0,G,H,F,wg,r,<f64_dm>,r\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r,*c*l,!r,*h,r,wg,r,<f64_dm>\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,j,r,Y,r,r,h,0,wg,r,<f64_dm>,r\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -8238,21 +8238,19 @@\n    stxsd%U0x %x1,%y0\n    xxlor %x0,%x1,%x1\n    xxlxor %x0,%x0,%x0\n+   li %0,0\n    std%U0%X0 %1,%0\n    ld%U1%X1 %0,%1\n    mr %0,%1\n    mt%0 %1\n    mf%1 %0\n    nop\n-   #\n-   #\n-   #\n    mftgpr %0,%1\n    mffgpr %0,%1\n    mfvsrd %0,%x1\n    mtvsrd %x0,%1\"\n-  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,vecsimple,vecsimple,store,load,*,mtjmpr,mfjmpr,*,*,*,*,mftgpr,mffgpr,mftgpr,mffgpr\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4,4,4\")])\n+  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,vecsimple,vecsimple,integer,store,load,*,mtjmpr,mfjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"*mov<mode>_softfloat64\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,cl,r,r,r,r,*h\")\n@@ -8289,7 +8287,7 @@\n \n (define_insn_and_split \"*mov<mode>_64bit_dm\"\n   [(set (match_operand:FMOVE128 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r,r,wm\")\n-\t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,j,r,jYGHF,r,wm,r\"))]\n+\t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,j,r,jY,r,wm,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64\n    && (<MODE>mode != TDmode || WORDS_BIG_ENDIAN)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n@@ -8302,7 +8300,7 @@\n \n (define_insn_and_split \"*movtd_64bit_nodm\"\n   [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r\")\n-\t(match_operand:TD 1 \"input_operand\" \"d,m,d,j,r,jYGHF,r\"))]\n+\t(match_operand:TD 1 \"input_operand\" \"d,m,d,j,r,jY,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64 && !WORDS_BIG_ENDIAN\n    && (gpc_reg_operand (operands[0], TDmode)\n        || gpc_reg_operand (operands[1], TDmode))\"\n@@ -8314,7 +8312,7 @@\n \n (define_insn_and_split \"*mov<mode>_32bit\"\n   [(set (match_operand:FMOVE128 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r\")\n-\t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,j,r,jYGHF,r\"))]\n+\t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,j,r,jY,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && !TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -8336,21 +8334,6 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n   [(set_attr \"length\" \"20,20,16\")])\n \n-;; If we are using -ffast-math, easy_fp_constant assumes all constants are\n-;; 'easy' in order to allow for reciprocal estimation.  Make sure the constant\n-;; is in the constant pool before reload occurs.  This simplifies accessing\n-;; scalars in the traditional Altivec registers.\n-\n-(define_split\n-  [(set (match_operand:SFDF 0 \"register_operand\" \"\")\n-\t(match_operand:SFDF 1 \"memory_fp_constant\" \"\"))]\n-  \"TARGET_<MODE>_FPR && flag_unsafe_math_optimizations\n-   && !reload_in_progress && !reload_completed && !lra_in_progress\"\n-  [(set (match_dup 0) (match_dup 2))]\n-{\n-  operands[2] = validize_mem (force_const_mem (<MODE>mode, operands[1]));\n-})\n-\n (define_expand \"extenddftf2\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:TF (match_operand:DF 1 \"input_operand\" \"\")))]\n@@ -8382,7 +8365,7 @@\n \n (define_insn_and_split \"*extenddftf2_internal\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=m,Y,d,&d,r\")\n-       (float_extend:TF (match_operand:DF 1 \"input_operand\" \"d,r,md,md,rmGHF\")))\n+       (float_extend:TF (match_operand:DF 1 \"input_operand\" \"d,r,md,md,rm\")))\n    (use (match_operand:DF 2 \"zero_reg_mem_operand\" \"d,r,m,d,n\"))]\n   \"!TARGET_IEEEQUAD\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT "}, {"sha": "3cf6e024f5b8420a076158e88d7f060f5cffe4a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -1,3 +1,12 @@\n+2015-03-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/65240\n+\t* gcc/testsuite/g++.dg/pr65240.h: Add tests for PR 65240.\n+\t* gcc/testsuite/g++.dg/pr65240-1.C: Likewise.\n+\t* gcc/testsuite/g++.dg/pr65240-2.C: Likewise.\n+\t* gcc/testsuite/g++.dg/pr65240-3.C: Likewise.\n+\t* gcc/testsuite/g++.dg/pr65240-4.C: Likewise.\n+\n 2015-03-19  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/63491"}, {"sha": "3282b8e5eef25da8543912b807c1ad1dea683400", "filename": "gcc/testsuite/g++.dg/pr65240-1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-1.C?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 -ffast-math -mcmodel=small -mno-fp-in-toc\" } */\n+\n+/* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */\n+\n+#include \"pr65240.h\""}, {"sha": "80cb82f82f510dde420b20ed37231a541b1e50f9", "filename": "gcc/testsuite/g++.dg/pr65240-2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-2.C?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 -ffast-math -mcmodel=small -mfp-in-toc\" } */\n+\n+/* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */\n+\n+#include \"pr65240.h\""}, {"sha": "57f0b801691840808253f4d69be5456c3da125b2", "filename": "gcc/testsuite/g++.dg/pr65240-3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-3.C?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 -ffast-math -mcmodel=medium\" } */\n+\n+/* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */\n+\n+#include \"pr65240.h\""}, {"sha": "b6a1007a84b1b511b6d16dfd6dcda5162856b2c1", "filename": "gcc/testsuite/g++.dg/pr65240-4.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240-4.C?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O3 -ffast-math\" } */\n+\n+/* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */\n+\n+#include \"pr65240.h\""}, {"sha": "6b9c8c0469ddd5d83d6c8bf3eca2a71a847e34be", "filename": "gcc/testsuite/g++.dg/pr65240.h", "status": "added", "additions": 5518, "deletions": 0, "changes": 5518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fb9bb358aeac48bca2095a45e0306d4a6b7db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65240.h?ref=8d9fb9bb358aeac48bca2095a45e0306d4a6b7db"}]}