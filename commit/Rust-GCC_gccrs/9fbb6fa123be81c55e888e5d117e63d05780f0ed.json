{"sha": "9fbb6fa123be81c55e888e5d117e63d05780f0ed", "node_id": "C_kwDOANBUbNoAKDlmYmI2ZmExMjNiZTgxYzU1ZTg4OGU1ZDExN2U2M2QwNTc4MGYwZWQ", "commit": {"author": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-10-19T04:06:35Z"}, "committer": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-10-20T02:58:20Z"}, "message": "tree-object-size: Make unknown a computation\n\nCompute the unknown size value as a function of the min/max bit of\nobject_size_type.  This transforms into a neat little branchless\nsequence on x86_64:\n\n\tmovl\t%edi, %eax\n\tsarl\t%eax\n\txorl\t$1, %eax\n\tnegl\t%eax\n\tcltq\n\nwhich should be faster than loading the value from memory.  A quick\nunscientific test using\n\n`time make check-gcc RUNTESTFLAGS=\"dg.exp=builtin*\"`\n\nshaves about half a second off execution time with this.  Also simplify\nimplementation of unknown_object_size.\n\ngcc/ChangeLog:\n\n\t* tree-object-size.c (unknown): Make into a function.  Adjust\n\tall uses.\n\t(unknown_object_size): Simplify implementation.\n\nSigned-off-by: Siddhesh Poyarekar <siddhesh@gotplt.org>", "tree": {"sha": "21192de96a3f53dd030f8955723ab079c615fd8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21192de96a3f53dd030f8955723ab079c615fd8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fbb6fa123be81c55e888e5d117e63d05780f0ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbb6fa123be81c55e888e5d117e63d05780f0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fbb6fa123be81c55e888e5d117e63d05780f0ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbb6fa123be81c55e888e5d117e63d05780f0ed/comments", "author": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c8d8c0be95e99dc0cba7f6fad2429243582119f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8d8c0be95e99dc0cba7f6fad2429243582119f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8d8c0be95e99dc0cba7f6fad2429243582119f"}], "stats": {"total": 100, "additions": 43, "deletions": 57}, "files": [{"sha": "4334e05ef70b77112f38dd0e75be56beab8e4154", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbb6fa123be81c55e888e5d117e63d05780f0ed/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbb6fa123be81c55e888e5d117e63d05780f0ed/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=9fbb6fa123be81c55e888e5d117e63d05780f0ed", "patch": "@@ -45,13 +45,6 @@ struct object_size_info\n   unsigned int *stack, *tos;\n };\n \n-static const unsigned HOST_WIDE_INT unknown[4] = {\n-  HOST_WIDE_INT_M1U,\n-  HOST_WIDE_INT_M1U,\n-  0,\n-  0\n-};\n-\n static tree compute_object_offset (const_tree, const_tree);\n static bool addr_object_size (struct object_size_info *,\n \t\t\t      const_tree, int, unsigned HOST_WIDE_INT *);\n@@ -82,6 +75,11 @@ static bitmap computed[4];\n /* Maximum value of offset we consider to be addition.  */\n static unsigned HOST_WIDE_INT offset_limit;\n \n+static inline unsigned HOST_WIDE_INT\n+unknown (int object_size_type)\n+{\n+  return ((unsigned HOST_WIDE_INT) -((object_size_type >> 1) ^ 1));\n+}\n \n /* Initialize OFFSET_LIMIT variable.  */\n static void\n@@ -204,7 +202,7 @@ decl_init_size (tree decl, bool min)\n \n /* Compute __builtin_object_size for PTR, which is a ADDR_EXPR.\n    OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n-   If unknown, return unknown[object_size_type].  */\n+   If unknown, return unknown (object_size_type).  */\n \n static bool\n addr_object_size (struct object_size_info *osi, const_tree ptr,\n@@ -216,7 +214,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \n   /* Set to unknown and overwrite just before returning if the size\n      could be determined.  */\n-  *psize = unknown[object_size_type];\n+  *psize = unknown (object_size_type);\n \n   pt_var = TREE_OPERAND (ptr, 0);\n   while (handled_component_p (pt_var))\n@@ -244,9 +242,9 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t\t\t    SSA_NAME_VERSION (var)))\n \t    sz = object_sizes[object_size_type][SSA_NAME_VERSION (var)];\n \t  else\n-\t    sz = unknown[object_size_type];\n+\t    sz = unknown (object_size_type);\n \t}\n-      if (sz != unknown[object_size_type])\n+      if (sz != unknown (object_size_type))\n \t{\n \t  offset_int mem_offset;\n \t  if (mem_ref_offset (pt_var).is_constant (&mem_offset))\n@@ -257,13 +255,13 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t      else if (wi::fits_uhwi_p (dsz))\n \t\tsz = dsz.to_uhwi ();\n \t      else\n-\t\tsz = unknown[object_size_type];\n+\t\tsz = unknown (object_size_type);\n \t    }\n \t  else\n-\t    sz = unknown[object_size_type];\n+\t    sz = unknown (object_size_type);\n \t}\n \n-      if (sz != unknown[object_size_type] && sz < offset_limit)\n+      if (sz != unknown (object_size_type) && sz < offset_limit)\n \tpt_var_size = size_int (sz);\n     }\n   else if (DECL_P (pt_var))\n@@ -445,7 +443,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n /* Compute __builtin_object_size for CALL, which is a GIMPLE_CALL.\n    Handles calls to functions declared with attribute alloc_size.\n    OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n-   If unknown, return unknown[object_size_type].  */\n+   If unknown, return unknown (object_size_type).  */\n \n static unsigned HOST_WIDE_INT\n alloc_object_size (const gcall *call, int object_size_type)\n@@ -459,7 +457,7 @@ alloc_object_size (const gcall *call, int object_size_type)\n     calltype = gimple_call_fntype (call);\n \n   if (!calltype)\n-    return unknown[object_size_type];\n+    return unknown (object_size_type);\n \n   /* Set to positions of alloc_size arguments.  */\n   int arg1 = -1, arg2 = -1;\n@@ -479,7 +477,7 @@ alloc_object_size (const gcall *call, int object_size_type)\n       || (arg2 >= 0\n \t  && (arg2 >= (int)gimple_call_num_args (call)\n \t      || TREE_CODE (gimple_call_arg (call, arg2)) != INTEGER_CST)))\n-    return unknown[object_size_type];\n+    return unknown (object_size_type);\n \n   tree bytes = NULL_TREE;\n   if (arg2 >= 0)\n@@ -492,7 +490,7 @@ alloc_object_size (const gcall *call, int object_size_type)\n   if (bytes && tree_fits_uhwi_p (bytes))\n     return tree_to_uhwi (bytes);\n \n-  return unknown[object_size_type];\n+  return unknown (object_size_type);\n }\n \n \n@@ -534,7 +532,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \n   /* Set to unknown and overwrite just before returning if the size\n      could be determined.  */\n-  *psize = unknown[object_size_type];\n+  *psize = unknown (object_size_type);\n \n   if (! offset_limit)\n     init_offset_limit ();\n@@ -674,7 +672,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \t{\n \t  EXECUTE_IF_SET_IN_BITMAP (osi.visited, 0, i, bi)\n \t    if (object_sizes[object_size_type][i]\n-\t\t!= unknown[object_size_type])\n+\t\t!= unknown (object_size_type))\n \t      {\n \t\tprint_generic_expr (dump_file, ssa_name (i),\n \t\t\t\t    dump_flags);\n@@ -692,7 +690,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n     }\n \n   *psize = object_sizes[object_size_type][SSA_NAME_VERSION (ptr)];\n-  return *psize != unknown[object_size_type];\n+  return *psize != unknown (object_size_type);\n }\n \n /* Compute object_sizes for PTR, defined to VALUE, which is not an SSA_NAME.  */\n@@ -705,7 +703,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n   unsigned HOST_WIDE_INT bytes;\n \n   gcc_assert (object_sizes[object_size_type][varno]\n-\t      != unknown[object_size_type]);\n+\t      != unknown (object_size_type));\n   gcc_assert (osi->pass == 0);\n \n   if (TREE_CODE (value) == WITH_SIZE_EXPR)\n@@ -718,7 +716,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n   if (TREE_CODE (value) == ADDR_EXPR)\n     addr_object_size (osi, value, object_size_type, &bytes);\n   else\n-    bytes = unknown[object_size_type];\n+    bytes = unknown (object_size_type);\n \n   if ((object_size_type & 2) == 0)\n     {\n@@ -745,7 +743,7 @@ call_object_size (struct object_size_info *osi, tree ptr, gcall *call)\n   gcc_assert (is_gimple_call (call));\n \n   gcc_assert (object_sizes[object_size_type][varno]\n-\t      != unknown[object_size_type]);\n+\t      != unknown (object_size_type));\n   gcc_assert (osi->pass == 0);\n \n   bytes = alloc_object_size (call, object_size_type);\n@@ -770,24 +768,12 @@ unknown_object_size (struct object_size_info *osi, tree ptr)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (ptr);\n-  unsigned HOST_WIDE_INT bytes;\n+  unsigned HOST_WIDE_INT bytes = unknown (object_size_type);\n \n-  gcc_assert (object_sizes[object_size_type][varno]\n-\t      != unknown[object_size_type]);\n-  gcc_assert (osi->pass == 0);\n+  gcc_checking_assert (object_sizes[object_size_type][varno] != bytes);\n+  gcc_checking_assert (osi->pass == 0);\n \n-  bytes = unknown[object_size_type];\n-\n-  if ((object_size_type & 2) == 0)\n-    {\n-      if (object_sizes[object_size_type][varno] < bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n-  else\n-    {\n-      if (object_sizes[object_size_type][varno] > bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n+  object_sizes[object_size_type][varno] = bytes;\n }\n \n \n@@ -802,19 +788,19 @@ merge_object_sizes (struct object_size_info *osi, tree dest, tree orig,\n   unsigned int varno = SSA_NAME_VERSION (dest);\n   unsigned HOST_WIDE_INT orig_bytes;\n \n-  if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n+  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n     return false;\n   if (offset >= offset_limit)\n     {\n-      object_sizes[object_size_type][varno] = unknown[object_size_type];\n+      object_sizes[object_size_type][varno] = unknown (object_size_type);\n       return false;\n     }\n \n   if (osi->pass == 0)\n     collect_object_sizes_for (osi, orig);\n \n   orig_bytes = object_sizes[object_size_type][SSA_NAME_VERSION (orig)];\n-  if (orig_bytes != unknown[object_size_type])\n+  if (orig_bytes != unknown (object_size_type))\n     orig_bytes = (offset > orig_bytes)\n \t\t ? HOST_WIDE_INT_0U : orig_bytes - offset;\n \n@@ -865,7 +851,7 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   else\n     gcc_unreachable ();\n \n-  if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n+  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n     return false;\n \n   /* Handle PTR + OFFSET here.  */\n@@ -874,7 +860,7 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n \t  || TREE_CODE (op0) == ADDR_EXPR))\n     {\n       if (! tree_fits_uhwi_p (op1))\n-\tbytes = unknown[object_size_type];\n+\tbytes = unknown (object_size_type);\n       else if (TREE_CODE (op0) == SSA_NAME)\n \treturn merge_object_sizes (osi, var, op0, tree_to_uhwi (op1));\n       else\n@@ -883,18 +869,18 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n \n           /* op0 will be ADDR_EXPR here.  */\n \t  addr_object_size (osi, op0, object_size_type, &bytes);\n-\t  if (bytes == unknown[object_size_type])\n+\t  if (bytes == unknown (object_size_type))\n \t    ;\n \t  else if (off > offset_limit)\n-\t    bytes = unknown[object_size_type];\n+\t    bytes = unknown (object_size_type);\n \t  else if (off > bytes)\n \t    bytes = 0;\n \t  else\n \t    bytes -= off;\n \t}\n     }\n   else\n-    bytes = unknown[object_size_type];\n+    bytes = unknown (object_size_type);\n \n   if ((object_size_type & 2) == 0)\n     {\n@@ -924,7 +910,7 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n \n   gcc_assert (gimple_assign_rhs_code (stmt) == COND_EXPR);\n \n-  if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n+  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n     return false;\n \n   then_ = gimple_assign_rhs2 (stmt);\n@@ -935,7 +921,7 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   else\n     expr_object_size (osi, var, then_);\n \n-  if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n+  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n     return reexamine;\n \n   if (TREE_CODE (else_) == SSA_NAME)\n@@ -956,9 +942,9 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n    object size is object size of the first operand minus the constant.\n    If the constant is bigger than the number of remaining bytes until the\n    end of the object, object size is 0, but if it is instead a pointer\n-   subtraction, object size is unknown[object_size_type].\n+   subtraction, object size is unknown (object_size_type).\n    To differentiate addition from subtraction, ADDR_EXPR returns\n-   unknown[object_size_type] for all objects bigger than half of the address\n+   unknown (object_size_type) for all objects bigger than half of the address\n    space, and constants less than half of the address space are considered\n    addition, while bigger constants subtraction.\n    For a memcpy like GIMPLE_CALL that always returns one of its arguments, the\n@@ -1030,7 +1016,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n               expr_object_size (osi, var, rhs);\n           }\n         else\n-          unknown_object_size (osi, var);\n+\t  unknown_object_size (osi, var);\n         break;\n       }\n \n@@ -1053,7 +1039,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \n     case GIMPLE_ASM:\n       /* Pointers defined by __asm__ statements can point anywhere.  */\n-      object_sizes[object_size_type][varno] = unknown[object_size_type];\n+      object_sizes[object_size_type][varno] = unknown (object_size_type);\n       break;\n \n     case GIMPLE_NOP:\n@@ -1062,7 +1048,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \texpr_object_size (osi, var, SSA_NAME_VAR (var));\n       else\n \t/* Uninitialized SSA names point nowhere.  */\n-\tobject_sizes[object_size_type][varno] = unknown[object_size_type];\n+\tobject_sizes[object_size_type][varno] = unknown (object_size_type);\n       break;\n \n     case GIMPLE_PHI:\n@@ -1074,7 +1060,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \t    tree rhs = gimple_phi_arg (stmt, i)->def;\n \n \t    if (object_sizes[object_size_type][varno]\n-\t\t== unknown[object_size_type])\n+\t\t== unknown (object_size_type))\n \t      break;\n \n \t    if (TREE_CODE (rhs) == SSA_NAME)\n@@ -1090,7 +1076,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n     }\n \n   if (! reexamine\n-      || object_sizes[object_size_type][varno] == unknown[object_size_type])\n+      || object_sizes[object_size_type][varno] == unknown (object_size_type))\n     {\n       bitmap_set_bit (computed[object_size_type], varno);\n       bitmap_clear_bit (osi->reexamine, varno);"}]}