{"sha": "4da41abf84cc6796aa8b3ae38402ff7544dfc8d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhNDFhYmY4NGNjNjc5NmFhOGIzYWUzODQwMmZmNzU0NGRmYzhkMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-11-24T15:01:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-11-24T15:01:32Z"}, "message": "re PR rtl-optimization/78437 (invalid sign-extend conversion in REE pass)\n\n\tPR rtl-optimization/78437\n\t* ree.c (get_uses): New function.\n\t(combine_reaching_defs): When a copy is needed, return false if any\n\treaching use of the source register reads it in a mode larger than\n\tthe mode it is set in and WORD_REGISTER_OPERATIONS is true.\n\nFrom-SVN: r242839", "tree": {"sha": "5af5792fbbe2403186385fd0151819ac9a1dc7e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5af5792fbbe2403186385fd0151819ac9a1dc7e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3/comments", "author": null, "committer": null, "parents": [{"sha": "0d56d3c17b709688ec817372311cde1cc445ae4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d56d3c17b709688ec817372311cde1cc445ae4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d56d3c17b709688ec817372311cde1cc445ae4b"}], "stats": {"total": 54, "additions": 54, "deletions": 0}, "files": [{"sha": "4e83a4810254ef7fddc48573a661ab98cf9055fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4da41abf84cc6796aa8b3ae38402ff7544dfc8d3", "patch": "@@ -1,3 +1,11 @@\n+2016-11-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/78437\n+\t* ree.c (get_uses): New function.\n+\t(combine_reaching_defs): When a copy is needed, return false if any\n+\treaching use of the source register reads it in a mode larger than\n+\tthe mode it is set in and WORD_REGISTER_OPERATIONS is true.\n+\n 2016-11-24  Martin Liska  <mliska@suse.cz>\n \n \t* gimple-pretty-print.c (dump_edge_probability): New function."}, {"sha": "a7a6526c98087c59c6883e2e0c481a99083c90ca", "filename": "gcc/ree.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da41abf84cc6796aa8b3ae38402ff7544dfc8d3/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=4da41abf84cc6796aa8b3ae38402ff7544dfc8d3", "patch": "@@ -499,6 +499,35 @@ get_defs (rtx_insn *insn, rtx reg, vec<rtx_insn *> *dest)\n   return ref_chain;\n }\n \n+/* Get all the reaching uses of an instruction.  The uses are desired for REG\n+   set in INSN.  Return use list or NULL if a use is missing or irregular.  */\n+\n+static struct df_link *\n+get_uses (rtx_insn *insn, rtx reg)\n+{\n+  df_ref def;\n+  struct df_link *ref_chain, *ref_link;\n+\n+  FOR_EACH_INSN_DEF (def, insn)\n+    if (REGNO (DF_REF_REG (def)) == REGNO (reg))\n+      break;\n+\n+  gcc_assert (def != NULL);\n+\n+  ref_chain = DF_REF_CHAIN (def);\n+\n+  for (ref_link = ref_chain; ref_link; ref_link = ref_link->next)\n+    {\n+      /* Problem getting some use for this instruction.  */\n+      if (ref_link->ref == NULL)\n+        return NULL;\n+      if (DF_REF_CLASS (ref_link->ref) != DF_REF_REGULAR)\n+\treturn NULL;\n+    }\n+\n+  return ref_chain;\n+}\n+\n /* Return true if INSN is\n      (SET (reg REGNO (def_reg)) (if_then_else (cond) (REG x1) (REG x2)))\n    and store x1 and x2 in REG_1 and REG_2.  */\n@@ -827,6 +856,23 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n       if (reg_overlap_mentioned_p (tmp_reg, SET_DEST (PATTERN (cand->insn))))\n \treturn false;\n \n+      /* On RISC machines we must make sure that changing the mode of SRC_REG\n+\t as destination register will not affect its reaching uses, which may\n+\t read its value in a larger mode because DEF_INSN implicitly sets it\n+\t in word mode.  */\n+      const unsigned int prec\n+\t= GET_MODE_PRECISION (GET_MODE (SET_DEST (*dest_sub_rtx)));\n+      if (WORD_REGISTER_OPERATIONS && prec < BITS_PER_WORD)\n+\t{\n+\t  struct df_link *uses = get_uses (def_insn, src_reg);\n+\t  if (!uses)\n+\t    return false;\n+\n+\t  for (df_link *use = uses; use; use = use->next)\n+\t    if (GET_MODE_PRECISION (GET_MODE (*DF_REF_LOC (use->ref))) > prec)\n+\t      return false;\n+\t}\n+\n       /* The destination register of the extension insn must not be\n \t used or set between the def_insn and cand->insn exclusive.  */\n       if (reg_used_between_p (SET_DEST (PATTERN (cand->insn)),"}]}