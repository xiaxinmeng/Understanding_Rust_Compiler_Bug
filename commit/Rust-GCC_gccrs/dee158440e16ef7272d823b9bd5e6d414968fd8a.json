{"sha": "dee158440e16ef7272d823b9bd5e6d414968fd8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlMTU4NDQwZTE2ZWY3MjcyZDgyM2I5YmQ1ZTZkNDE0OTY4ZmQ4YQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-07-02T10:55:32Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-07-02T10:55:32Z"}, "message": "toplev.c (default_tree_printer): Handle setting location with '+' flag.\n\n2005-07-02  Zack Weinberg  <zack@codesourcery.com>\n            Joseph S. Myers  <joseph@codesourcery.com>\n\n\t* toplev.c (default_tree_printer): Handle setting location with\n\t'+' flag.\n\t* c-objc.common.c (c_tree_printer): Likewise.\n\t* c-format.c (gcc_diag_flag_specs): Add '+'.\n\t(gcc_cdiag_char_table): Allow '+' flag for tree formats.\n\t(format_types_orig): Allow '+' flag for gcc_diag and gcc_cdiag\n\tformats.\n\t* c-common.c, c-decl.c, c-objc-common.c, c-pragma.c,\n\tconfig/arm/pe.c, config/i386/winnt.c, config/ia64/ia64.c,\n\tconfig/mcore/mcore.c, config/sh/symbian.c, config/sol2.c,\n\tconfig/v850/v850.c, function.c, stor-layout.c, toplev.c,\n\ttree-inline.c, tree-optimize.c, tree.c, varasm.c: Use '+' flag\n\tinstead of %J or %H.  Use 'q' flag for quoting.  Avoid '.' at end\n\tof diagnostics.  Use %q+D not %s for a decl.  Do not pass excess\n\tformat arguments where %J is used without %D.\n\ncp:\n\t* error.c (location_of): Add comment.\n\t(locate_error, cp_error_at, cp_warning_at, cp_pedwarn_at): Remove.\n\t* cp-tree.h (cp_error_at, cp_warning_at, cp_pedwarn_at): Remove.\n\t* call.c, class.c, decl.c, decl2.c, friend.c, init.c,\n\tname-lookup.c, parser.c, pt.c, search.c, semantics.c, typeck.c,\n\ttypeck2.c: Use '+' flag instead of %J, cp_error_at, cp_warning_at\n\tor cp_pedwarn_at.  Mark up some diagnostic strings with N_.\n\njava:\n\t* class.c, decl.c, expr.c: Use '+' flag instead of %J.  Use 'q'\n\tflag for quoting.\n\nobjc:\n\t* objc-act.c: Use '+' flag instead of %J.  Use 'q' flag for\n\tquoting.\n\ntestsuite:\n\t* gcc.dg/format/gcc_diag-1.c: Update.\n\nFrom-SVN: r101532", "tree": {"sha": "3bc7f52a01952579e89d69c80d985e655c418278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bc7f52a01952579e89d69c80d985e655c418278"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee158440e16ef7272d823b9bd5e6d414968fd8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee158440e16ef7272d823b9bd5e6d414968fd8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee158440e16ef7272d823b9bd5e6d414968fd8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee158440e16ef7272d823b9bd5e6d414968fd8a/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77008252819720c987f11b3dade670e2b3ba09b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77008252819720c987f11b3dade670e2b3ba09b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77008252819720c987f11b3dade670e2b3ba09b8"}], "stats": {"total": 1223, "additions": 551, "deletions": 672}, "files": [{"sha": "1d3952939777aac81d57deb6293ed5bb3bb4d2ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1,3 +1,22 @@\n+2005-07-02  Zack Weinberg  <zack@codesourcery.com>\n+            Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* toplev.c (default_tree_printer): Handle setting location with\n+\t'+' flag.\n+\t* c-objc.common.c (c_tree_printer): Likewise.\n+\t* c-format.c (gcc_diag_flag_specs): Add '+'.\n+\t(gcc_cdiag_char_table): Allow '+' flag for tree formats.\n+\t(format_types_orig): Allow '+' flag for gcc_diag and gcc_cdiag\n+\tformats.\n+\t* c-common.c, c-decl.c, c-objc-common.c, c-pragma.c,\n+\tconfig/arm/pe.c, config/i386/winnt.c, config/ia64/ia64.c,\n+\tconfig/mcore/mcore.c, config/sh/symbian.c, config/sol2.c,\n+\tconfig/v850/v850.c, function.c, stor-layout.c, toplev.c,\n+\ttree-inline.c, tree-optimize.c, tree.c, varasm.c: Use '+' flag\n+\tinstead of %J or %H.  Use 'q' flag for quoting.  Avoid '.' at end\n+\tof diagnostics.  Use %q+D not %s for a decl.  Do not pass excess\n+\tformat arguments where %J is used without %D.\n+\n 2005-07-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c (LINK_SSP_SPEC): Define."}, {"sha": "f3d4a281bdad14cbd4e8d8325f98d20ccbc88010", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -4559,16 +4559,16 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n \t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n \t    {\n-\t      error (\"%Jsection of %qD conflicts with previous declaration\",\n-\t\t     *node, *node);\n+\t      error (\"section of %q+D conflicts with previous declaration\",\n+\t\t     *node);\n \t      *no_add_attrs = true;\n \t    }\n \t  else\n \t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n \t}\n       else\n \t{\n-\t  error (\"%Jsection attribute not allowed for %qD\", *node, *node);\n+\t  error (\"section attribute not allowed for %q+D\", *node);\n \t  *no_add_attrs = true;\n \t}\n     }\n@@ -4642,7 +4642,7 @@ handle_aligned_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   else if (TREE_CODE (decl) != VAR_DECL\n \t   && TREE_CODE (decl) != FIELD_DECL)\n     {\n-      error (\"%Jalignment may not be specified for %qD\", decl, decl);\n+      error (\"alignment may not be specified for %q+D\", decl);\n       *no_add_attrs = true;\n     }\n   else\n@@ -4680,7 +4680,7 @@ handle_alias_attribute (tree *node, tree name, tree args,\n   if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n       || (TREE_CODE (decl) != FUNCTION_DECL && !DECL_EXTERNAL (decl)))\n     {\n-      error (\"%J%qD defined both normally and as an alias\", decl, decl);\n+      error (\"%q+D defined both normally and as an alias\", decl);\n       *no_add_attrs = true;\n     }\n "}, {"sha": "04d095c81c72638613be5177dc994f76138336ba", "filename": "gcc/c-decl.c", "status": "modified", "additions": 127, "deletions": 139, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -560,7 +560,7 @@ c_finish_incomplete_decl (tree decl)\n \t  && !DECL_EXTERNAL (decl)\n \t  && TYPE_DOMAIN (type) == 0)\n \t{\n-\t  warning (0, \"%Jarray %qD assumed to have one element\", decl, decl);\n+\t  warning (0, \"array %q+D assumed to have one element\", decl);\n \n \t  complete_array_type (&TREE_TYPE (decl), NULL_TREE, true);\n \n@@ -751,15 +751,15 @@ pop_scope (void)\n \t  /* Warnings for unused labels, errors for undefined labels.  */\n \t  if (TREE_USED (p) && !DECL_INITIAL (p))\n \t    {\n-\t      error (\"%Jlabel %qD used but not defined\", p, p);\n+\t      error (\"label %q+D used but not defined\", p);\n \t      DECL_INITIAL (p) = error_mark_node;\n \t    }\n \t  else if (!TREE_USED (p) && warn_unused_label)\n \t    {\n \t      if (DECL_INITIAL (p))\n-\t\twarning (0, \"%Jlabel %qD defined but not used\", p, p);\n+\t\twarning (0, \"label %q+D defined but not used\", p);\n \t      else\n-\t\twarning (0, \"%Jlabel %qD declared but not defined\", p, p);\n+\t\twarning (0, \"label %q+D declared but not defined\", p);\n \t    }\n \t  /* Labels go in BLOCK_VARS.  */\n \t  TREE_CHAIN (p) = BLOCK_VARS (block);\n@@ -794,7 +794,7 @@ pop_scope (void)\n \t  if (!DECL_EXTERNAL (p)\n \t      && DECL_INITIAL (p) == 0)\n \t    {\n-\t      error (\"%Jnested function %qD declared but never defined\", p, p);\n+\t      error (\"nested function %q+D declared but never defined\", p);\n \t      undef_nested_function = true;\n \t    }\n \t  goto common_symbol;\n@@ -807,12 +807,12 @@ pop_scope (void)\n \t      && !DECL_ARTIFICIAL (p)\n \t      && scope != file_scope\n \t      && scope != external_scope) \n-\t    warning (OPT_Wunused_variable, \"%Junused variable %qD\", p, p);\n+\t    warning (OPT_Wunused_variable, \"unused variable %q+D\", p);\n \n \t  if (b->inner_comp)\n \t    {\n-\t      error (\"%Jtype of array %qD completed incompatibly with\"\n-\t\t     \" implicit initialization\", p, p);\n+\t      error (\"type of array %q+D completed incompatibly with\"\n+\t\t     \" implicit initialization\", p);\n \t    }\n \n \t  /* Fall through.  */\n@@ -1087,24 +1087,24 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n \t agree on the number of arguments.  */\n       if (END_OF_ARGLIST (oldargtype))\n \t{\n-\t  error (\"%Jprototype for %qD declares more arguments \"\n-\t\t \"than previous old-style definition\", newdecl, newdecl);\n+\t  error (\"prototype for %q+D declares more arguments \"\n+\t\t \"than previous old-style definition\", newdecl);\n \t  return false;\n \t}\n       else if (END_OF_ARGLIST (newargtype))\n \t{\n-\t  error (\"%Jprototype for %qD declares fewer arguments \"\n-\t\t \"than previous old-style definition\", newdecl, newdecl);\n+\t  error (\"prototype for %q+D declares fewer arguments \"\n+\t\t \"than previous old-style definition\", newdecl);\n \t  return false;\n \t}\n \n       /* Type for passing arg must be consistent with that declared\n \t for the arg.  */\n       else if (!comptypes (oldargtype, newargtype))\n \t{\n-\t  error (\"%Jprototype for %qD declares argument %d\"\n+\t  error (\"prototype for %q+D declares argument %d\"\n \t\t \" with incompatible type\",\n-\t\t newdecl, newdecl, i);\n+\t\t newdecl, i);\n \t  return false;\n \t}\n \n@@ -1115,8 +1115,8 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n \n   /* If we get here, no errors were found, but do issue a warning\n      for this poor-style construct.  */\n-  warning (0, \"%Jprototype for %qD follows non-prototype definition\",\n-\t   newdecl, newdecl);\n+  warning (0, \"prototype for %q+D follows non-prototype definition\",\n+\t   newdecl);\n   return true;\n #undef END_OF_ARGLIST\n }\n@@ -1130,11 +1130,11 @@ locate_old_decl (tree decl, void (*diag)(const char *, ...) ATTRIBUTE_GCC_CDIAG(\n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl))\n     ;\n   else if (DECL_INITIAL (decl))\n-    diag (G_(\"%Jprevious definition of %qD was here\"), decl, decl);\n+    diag (G_(\"previous definition of %q+D was here\"), decl);\n   else if (C_DECL_IMPLICIT (decl))\n-    diag (G_(\"%Jprevious implicit declaration of %qD was here\"), decl, decl);\n+    diag (G_(\"previous implicit declaration of %q+D was here\"), decl);\n   else\n-    diag (G_(\"%Jprevious declaration of %qD was here\"), decl, decl);\n+    diag (G_(\"previous declaration of %q+D was here\"), decl);\n }\n \n /* Subroutine of duplicate_decls.  Compare NEWDECL to OLDDECL.\n@@ -1174,24 +1174,23 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    && DECL_BUILT_IN (olddecl)\n \t    && !C_DECL_DECLARED_BUILTIN (olddecl)))\n \t{\n-\t  error (\"%J%qD redeclared as different kind of symbol\",\n-\t\t newdecl, newdecl);\n+\t  error (\"%q+D redeclared as different kind of symbol\", newdecl);\n \t  locate_old_decl (olddecl, error);\n \t}\n       else if (TREE_PUBLIC (newdecl))\n-\twarning (0, \"%Jbuilt-in function %qD declared as non-function\",\n-\t\t newdecl, newdecl);\n+\twarning (0, \"built-in function %q+D declared as non-function\",\n+\t\t newdecl);\n       else\n-\twarning (OPT_Wshadow, \"%Jdeclaration of %qD shadows \"\n-\t\t \"a built-in function\", newdecl, newdecl);\n+\twarning (OPT_Wshadow, \"declaration of %q+D shadows \"\n+\t\t \"a built-in function\", newdecl);\n       return false;\n     }\n \n   /* Enumerators have no linkage, so may only be declared once in a\n      given scope.  */\n   if (TREE_CODE (olddecl) == CONST_DECL)\n     {\n-      error (\"%Jredeclaration of enumerator %qD\", newdecl, newdecl);\n+      error (\"redeclaration of enumerator %q+D\", newdecl);\n       locate_old_decl (olddecl, error);\n       return false;\n     }\n@@ -1212,8 +1211,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t      /* If types don't match for a built-in, throw away the\n \t\t built-in.  No point in calling locate_old_decl here, it\n \t\t won't print anything.  */\n-\t      warning (0, \"%Jconflicting types for built-in function %qD\",\n-\t\t       newdecl, newdecl);\n+\t      warning (0, \"conflicting types for built-in function %q+D\",\n+\t\t       newdecl);\n \t      return false;\n \t    }\n \t}\n@@ -1236,7 +1235,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t       && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n \t       && C_FUNCTION_IMPLICIT_INT (newdecl) && !DECL_INITIAL (olddecl))\n \t{\n-\t  pedwarn (\"%Jconflicting types for %qD\", newdecl, newdecl);\n+\t  pedwarn (\"conflicting types for %q+D\", newdecl);\n \t  /* Make sure we keep void as the return type.  */\n \t  TREE_TYPE (newdecl) = *newtypep = newtype = oldtype;\n \t  C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n@@ -1249,17 +1248,17 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t       && TYPE_MAIN_VARIANT (TREE_TYPE (oldtype)) == integer_type_node\n \t       && C_DECL_IMPLICIT (olddecl) && !DECL_INITIAL (olddecl))\n \t{\n-\t  pedwarn (\"%Jconflicting types for %qD\", newdecl, newdecl);\n+\t  pedwarn (\"conflicting types for %q+D\", newdecl);\n \t  /* Make sure we keep void as the return type.  */\n \t  TREE_TYPE (olddecl) = *oldtypep = oldtype = newtype;\n \t  pedwarned = true;\n \t}\n       else\n \t{\n \t  if (TYPE_QUALS (newtype) != TYPE_QUALS (oldtype))\n-\t    error (\"%J conflicting type qualifiers for %qD\", newdecl, newdecl);\n+\t    error (\"conflicting type qualifiers for %q+D\", newdecl);\n \t  else\n-\t    error (\"%Jconflicting types for %qD\", newdecl, newdecl);\n+\t    error (\"conflicting types for %q+D\", newdecl);\n \t  diagnose_arglist_conflict (newdecl, olddecl, newtype, oldtype);\n \t  locate_old_decl (olddecl, error);\n \t  return false;\n@@ -1274,7 +1273,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (DECL_IN_SYSTEM_HEADER (newdecl) || DECL_IN_SYSTEM_HEADER (olddecl))\n \treturn true;  /* Allow OLDDECL to continue in use.  */\n \n-      error (\"%Jredefinition of typedef %qD\", newdecl, newdecl);\n+      error (\"redefinition of typedef %q+D\", newdecl);\n       locate_old_decl (olddecl, error);\n       return false;\n     }\n@@ -1298,8 +1297,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t      || (DECL_INITIAL (newdecl)\n \t\t  && !TYPE_ARG_TYPES (TREE_TYPE (newdecl)))))\n \t{\n-\t  warning (OPT_Wshadow, \"%Jdeclaration of %qD shadows \"\n-\t\t   \"a built-in function\", newdecl, newdecl);\n+\t  warning (OPT_Wshadow, \"declaration of %q+D shadows \"\n+\t\t   \"a built-in function\", newdecl);\n \t  /* Discard the old built-in function.  */\n \t  return false;\n \t}\n@@ -1322,7 +1321,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t    && !DECL_EXTERN_INLINE (newdecl))\n \t\t  && same_translation_unit_p (newdecl, olddecl))\n \t\t{\n-\t\t  error (\"%Jredefinition of %qD\", newdecl, newdecl);\n+\t\t  error (\"redefinition of %q+D\", newdecl);\n \t\t  locate_old_decl (olddecl, error);\n \t\t  return false;\n \t\t}\n@@ -1357,8 +1356,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t  if (!DECL_IS_BUILTIN (olddecl)\n \t      && !DECL_EXTERN_INLINE (olddecl))\n \t    {\n-\t      error (\"%Jstatic declaration of %qD follows \"\n-\t\t     \"non-static declaration\", newdecl, newdecl);\n+\t      error (\"static declaration of %q+D follows \"\n+\t\t     \"non-static declaration\", newdecl);\n \t      locate_old_decl (olddecl, error);\n \t    }\n \t  return false;\n@@ -1367,15 +1366,15 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t{\n \t  if (DECL_CONTEXT (olddecl))\n \t    {\n-\t      error (\"%Jnon-static declaration of %qD follows \"\n-\t\t     \"static declaration\", newdecl, newdecl);\n+\t      error (\"non-static declaration of %q+D follows \"\n+\t\t     \"static declaration\", newdecl);\n \t      locate_old_decl (olddecl, error);\n \t      return false;\n \t    }\n \t  else if (warn_traditional)\n \t    {\n-\t      warning (OPT_Wtraditional, \"%Jnon-static declaration of %qD \"\n-\t\t       \"follows static declaration\", newdecl, newdecl);\n+\t      warning (OPT_Wtraditional, \"non-static declaration of %q+D \"\n+\t\t       \"follows static declaration\", newdecl);\n \t      warned = true;\n \t    }\n \t}\n@@ -1387,11 +1386,11 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))\n \t{\n \t  if (DECL_THREAD_LOCAL_P (newdecl))\n-\t    error (\"%Jthread-local declaration of %qD follows \"\n-\t\t   \"non-thread-local declaration\", newdecl, newdecl);\n+\t    error (\"thread-local declaration of %q+D follows \"\n+\t\t   \"non-thread-local declaration\", newdecl);\n \t  else\n-\t    error (\"%Jnon-thread-local declaration of %qD follows \"\n-\t\t   \"thread-local declaration\", newdecl, newdecl);\n+\t    error (\"non-thread-local declaration of %q+D follows \"\n+\t\t   \"thread-local declaration\", newdecl);\n \n \t  locate_old_decl (olddecl, error);\n \t  return false;\n@@ -1400,7 +1399,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       /* Multiple initialized definitions are not allowed (6.9p3,5).  */\n       if (DECL_INITIAL (newdecl) && DECL_INITIAL (olddecl))\n \t{\n-\t  error (\"%Jredefinition of %qD\", newdecl, newdecl);\n+\t  error (\"redefinition of %q+D\", newdecl);\n \t  locate_old_decl (olddecl, error);\n \t  return false;\n \t}\n@@ -1420,26 +1419,26 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    {\n \t      if (!DECL_FILE_SCOPE_P (olddecl))\n \t\t{\n-\t\t  error (\"%Jextern declaration of %qD follows \"\n-\t\t\t \"declaration with no linkage\", newdecl, newdecl);\n+\t\t  error (\"extern declaration of %q+D follows \"\n+\t\t\t \"declaration with no linkage\", newdecl);\n \t\t  locate_old_decl (olddecl, error);\n \t\t  return false;\n \t\t}\n \t      else if (warn_traditional)\n \t\t{\n-\t\t  warning (OPT_Wtraditional, \"%Jnon-static declaration of %qD \"\n-\t\t\t   \"follows static declaration\", newdecl, newdecl);\n+\t\t  warning (OPT_Wtraditional, \"non-static declaration of %q+D \"\n+\t\t\t   \"follows static declaration\", newdecl);\n \t\t  warned = true;\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (TREE_PUBLIC (newdecl))\n-\t\terror (\"%Jnon-static declaration of %qD follows \"\n-\t\t       \"static declaration\", newdecl, newdecl);\n+\t\terror (\"non-static declaration of %q+D follows \"\n+\t\t       \"static declaration\", newdecl);\n \t      else\n-\t\terror (\"%Jstatic declaration of %qD follows \"\n-\t\t       \"non-static declaration\", newdecl, newdecl);\n+\t\terror (\"static declaration of %q+D follows \"\n+\t\t       \"non-static declaration\", newdecl);\n \n \t      locate_old_decl (olddecl, error);\n \t      return false;\n@@ -1456,14 +1455,13 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    }\n \t  else if (DECL_EXTERNAL (olddecl))\n \t    {\n-\t      error (\"%Jdeclaration of %qD with no linkage follows \"\n-\t\t     \"extern declaration\", newdecl, newdecl);\n+\t      error (\"declaration of %q+D with no linkage follows \"\n+\t\t     \"extern declaration\", newdecl);\n \t      locate_old_decl (olddecl, error);\n \t    }\n \t  else\n \t    {\n-\t      error (\"%Jredeclaration of %qD with no linkage\",\n-\t\t     newdecl, newdecl);\n+\t      error (\"redeclaration of %q+D with no linkage\", newdecl);\n \t      locate_old_decl (olddecl, error);\n \t    }\n \n@@ -1476,8 +1474,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n   if (DECL_VISIBILITY_SPECIFIED (newdecl) && DECL_VISIBILITY_SPECIFIED (olddecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n-      warning (0, \"%Jredeclaration of %qD with different visibility \"\n-\t       \"(old visibility preserved)\", newdecl, newdecl);\n+      warning (0, \"redeclaration of %q+D with different visibility \"\n+\t       \"(old visibility preserved)\", newdecl);\n       warned = true;\n     }\n \n@@ -1487,15 +1485,15 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (DECL_DECLARED_INLINE_P (newdecl)\n \t  && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t{\n-\t  warning (OPT_Wattributes, \"%Jinline declaration of %qD follows \"\n-\t\t   \"declaration with attribute noinline\", newdecl, newdecl);\n+\t  warning (OPT_Wattributes, \"inline declaration of %qD follows \"\n+\t\t   \"declaration with attribute noinline\", newdecl);\n \t  warned = true;\n \t}\n       else if (DECL_DECLARED_INLINE_P (olddecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t{\n-\t  warning (OPT_Wattributes, \"%Jdeclaration of %qD with attribute \"\n-\t\t   \"noinline follows inline declaration \", newdecl, newdecl);\n+\t  warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n+\t\t   \"noinline follows inline declaration \", newdecl);\n \t  warned = true;\n \t}\n \n@@ -1509,14 +1507,12 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t{\n \t  if (TREE_USED (olddecl))\n \t    {\n-\t      warning (0, \"%J%qD declared inline after being called\",\n-\t\t       olddecl, olddecl);\n+\t      warning (0, \"%q+D declared inline after being called\", olddecl);\n \t      warned = true;\n \t    }\n \t  else if (DECL_INITIAL (olddecl))\n \t    {\n-\t      warning (0, \"%J%qD declared inline after its definition\",\n-\t\t       olddecl, olddecl);\n+\t      warning (0, \"%q+D declared inline after its definition\", olddecl);\n \t      warned = true;\n \t    }\n \t}\n@@ -1535,7 +1531,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (TREE_CODE (newdecl) == PARM_DECL\n \t  && (!TREE_ASM_WRITTEN (olddecl) || TREE_ASM_WRITTEN (newdecl)))\n \t{\n-\t  error (\"%Jredefinition of parameter %qD\", newdecl, newdecl);\n+\t  error (\"redefinition of parameter %q+D\", newdecl);\n \t  locate_old_decl (olddecl, error);\n \t  return false;\n \t}\n@@ -1559,8 +1555,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       && !(TREE_CODE (newdecl) == PARM_DECL\n \t   && TREE_ASM_WRITTEN (olddecl) && !TREE_ASM_WRITTEN (newdecl)))\n     {\n-      warning (OPT_Wredundant_decls, \"%Jredundant redeclaration of %qD\",\n-\t       newdecl, newdecl);\n+      warning (OPT_Wredundant_decls, \"redundant redeclaration of %q+D\",\n+\t       newdecl);\n       warned = true;\n     }\n \n@@ -1887,26 +1883,25 @@ warn_if_shadowing (tree new_decl)\n \n \tif (old_decl == error_mark_node)\n \t  {\n-\t    warning (0, \"%Jdeclaration of %qD shadows previous non-variable\",\n-\t\t     new_decl, new_decl);\n+\t    warning (0, \"declaration of %q+D shadows previous non-variable\",\n+\t\t     new_decl);\n \t    break;\n \t  }\n \telse if (TREE_CODE (old_decl) == PARM_DECL)\n-\t  warning (0, \"%Jdeclaration of %qD shadows a parameter\",\n-\t\t   new_decl, new_decl);\n+\t  warning (0, \"declaration of %q+D shadows a parameter\", new_decl);\n \telse if (DECL_FILE_SCOPE_P (old_decl))\n-\t  warning (0, \"%Jdeclaration of %qD shadows a global declaration\",\n-\t\t   new_decl, new_decl);\n+\t  warning (0, \"declaration of %q+D shadows a global declaration\",\n+\t\t   new_decl);\n \telse if (TREE_CODE (old_decl) == FUNCTION_DECL\n \t\t && DECL_BUILT_IN (old_decl))\n \t  {\n-\t    warning (0, \"%Jdeclaration of %qD shadows a built-in function\",\n-\t\t     new_decl, new_decl);\n+\t    warning (0, \"declaration of %q+D shadows a built-in function\",\n+\t\t     new_decl);\n \t    break;\n \t  }\n \telse\n-\t  warning (0, \"%Jdeclaration of %qD shadows a previous local\",\n-\t\t   new_decl, new_decl);\n+\t  warning (0, \"declaration of %q+D shadows a previous local\",\n+\t\t   new_decl);\n \n \twarning (0, \"%Jshadowed declaration is here\", old_decl);\n \n@@ -3086,7 +3081,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \n   if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n       && MAIN_NAME_P (DECL_NAME (decl)))\n-    warning (OPT_Wmain, \"%J%qD is usually a function\", decl, decl);\n+    warning (OPT_Wmain, \"%q+D is usually a function\", decl);\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n@@ -3207,8 +3202,8 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl)))\n-    warning (OPT_Wattributes, \"%Jinline function %qD given attribute noinline\",\n-\t     decl, decl);\n+    warning (OPT_Wattributes, \"inline function %q+D given attribute noinline\",\n+\t     decl);\n \n   /* Add this decl to the current scope.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n@@ -3279,12 +3274,12 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       switch (failure)\n \t{\n \tcase 1:\n-\t  error (\"%Jinitializer fails to determine size of %qD\", decl, decl);\n+\t  error (\"initializer fails to determine size of %q+D\", decl);\n \t  break;\n \n \tcase 2:\n \t  if (do_default)\n-\t    error (\"%Jarray size missing in %qD\", decl, decl);\n+\t    error (\"array size missing in %q+D\", decl);\n \t  /* If a `static' var's size isn't known,\n \t     make it extern as well as static, so it does not get\n \t     allocated.\n@@ -3296,7 +3291,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  break;\n \n \tcase 3:\n-\t  error (\"%Jzero or negative size array %qD\", decl, decl);\n+\t  error (\"zero or negative size array %q+D\", decl);\n \t  break;\n \n \tcase 0:\n@@ -3348,7 +3343,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t\t is an error.  */\n \t      : !DECL_EXTERNAL (decl)))\n \t {\n-\t   error (\"%Jstorage size of %qD isn%'t known\", decl, decl);\n+\t   error (\"storage size of %q+D isn%'t known\", decl);\n \t   TREE_TYPE (decl) = error_mark_node;\n \t }\n \n@@ -3358,7 +3353,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \t    constant_expression_warning (DECL_SIZE (decl));\n \t  else\n-\t    error (\"%Jstorage size of %qD isn%'t constant\", decl, decl);\n+\t    error (\"storage size of %q+D isn%'t constant\", decl);\n \t}\n \n       if (TREE_USED (type))\n@@ -3405,8 +3400,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t      && TREE_CODE (decl) == VAR_DECL\n \t      && !C_DECL_REGISTER (decl)\n \t      && !TREE_STATIC (decl))\n-\t    warning (0, \"%Jignoring asm-specifier for non-static local \"\n-\t\t     \"variable %qD\", decl, decl);\n+\t    warning (0, \"ignoring asm-specifier for non-static local \"\n+\t\t     \"variable %q+D\", decl);\n \t  else if (C_DECL_REGISTER (decl))\n \t    change_decl_assembler_name (decl, get_identifier (asmspec));\n \t  else\n@@ -4367,7 +4362,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n       decl_attributes (&decl, returned_attrs, 0);\n       if (declspecs->inline_p)\n-\tpedwarn (\"%Jtypedef %qD declared %<inline%>\", decl, decl);\n+\tpedwarn (\"typedef %q+D declared %<inline%>\", decl);\n       return decl;\n     }\n \n@@ -4482,7 +4477,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tDECL_ARG_TYPE (decl) = promoted_type;\n \tDECL_ARG_TYPE_AS_WRITTEN (decl) = type_as_written;\n \tif (declspecs->inline_p)\n-\t  pedwarn (\"%Jparameter %qD declared %<inline%>\", decl, decl);\n+\t  pedwarn (\"parameter %q+D declared %<inline%>\", decl);\n       }\n     else if (decl_context == FIELD)\n       {\n@@ -4636,7 +4631,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (declspecs->inline_p)\n-\t  pedwarn (\"%Jvariable %qD declared %<inline%>\", decl, decl);\n+\t  pedwarn (\"variable %q+D declared %<inline%>\", decl);\n \n \t/* At file scope, an initialized extern declaration may follow\n \t   a static declaration.  In that case, DECL_EXTERNAL will be\n@@ -4770,8 +4765,8 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \t      if (funcdef_flag)\n \t\t{\n \t\t  if (DECL_NAME (parm))\n-\t\t    error (\"%Jparameter %u (%qD) has incomplete type\",\n-\t\t\t   parm, parmno, parm);\n+\t\t    error (\"parameter %u (%q+D) has incomplete type\",\n+\t\t\t   parmno, parm);\n \t\t  else\n \t\t    error (\"%Jparameter %u has incomplete type\",\n \t\t\t   parm, parmno);\n@@ -4782,8 +4777,8 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \t      else if (VOID_TYPE_P (type))\n \t\t{\n \t\t  if (DECL_NAME (parm))\n-\t\t    warning (0, \"%Jparameter %u (%qD) has void type\",\n-\t\t\t     parm, parmno, parm);\n+\t\t    warning (0, \"parameter %u (%q+D) has void type\",\n+\t\t\t     parmno, parm);\n \t\t  else\n \t\t    warning (0, \"%Jparameter %u has void type\",\n \t\t\t     parm, parmno);\n@@ -4874,8 +4869,7 @@ get_parm_info (bool ellipsis)\n \n \t  /* Check for forward decls that never got their actual decl.  */\n \t  if (TREE_ASM_WRITTEN (decl))\n-\t    error (\"%Jparameter %qD has just a forward declaration\",\n-\t\t   decl, decl);\n+\t    error (\"parameter %q+D has just a forward declaration\", decl);\n \t  /* Check for (..., void, ...) and issue an error.  */\n \t  else if (VOID_TYPE_P (type) && !DECL_NAME (decl))\n \t    {\n@@ -5189,7 +5183,7 @@ detect_field_duplicates (tree fieldlist)\n \t    for (y = fieldlist; y != x; y = TREE_CHAIN (y))\n \t      if (DECL_NAME (y) == DECL_NAME (x))\n \t\t{\n-\t\t  error (\"%Jduplicate member %qD\", x, x);\n+\t\t  error (\"duplicate member %q+D\", x);\n \t\t  DECL_NAME (x) = NULL_TREE;\n \t\t}\n \t  }\n@@ -5205,7 +5199,7 @@ detect_field_duplicates (tree fieldlist)\n \t    slot = htab_find_slot (htab, y, INSERT);\n \t    if (*slot)\n \t      {\n-\t\terror (\"%Jduplicate member %qD\", x, x);\n+\t\terror (\"duplicate member %q+D\", x);\n \t\tDECL_NAME (x) = NULL_TREE;\n \t      }\n \t    *slot = y;\n@@ -5800,8 +5794,8 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   if (DECL_DECLARED_INLINE_P (decl1)\n       && DECL_UNINLINABLE (decl1)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl1)))\n-    warning (OPT_Wattributes, \"%Jinline function %qD given attribute noinline\",\n-\t     decl1, decl1);\n+    warning (OPT_Wattributes, \"inline function %q+D given attribute noinline\",\n+\t     decl1);\n \n   announce_function (decl1);\n \n@@ -5886,8 +5880,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t   && TREE_PUBLIC (decl1)\n \t   && !MAIN_NAME_P (DECL_NAME (decl1))\n \t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (OPT_Wmissing_prototypes, \"%Jno previous prototype for %qD\",\n-\t     decl1, decl1);\n+    warning (OPT_Wmissing_prototypes, \"no previous prototype for %q+D\", decl1);\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n   else if (warn_missing_prototypes\n@@ -5896,15 +5889,14 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t   && TREE_USED (old_decl)\n \t   && TYPE_ARG_TYPES (TREE_TYPE (old_decl)) == 0)\n     warning (OPT_Wmissing_prototypes,\n-\t     \"%J%qD was used with no prototype before its definition\",\n-\t     decl1, decl1);\n+\t     \"%q+D was used with no prototype before its definition\", decl1);\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n \t   && old_decl == 0\n \t   && !MAIN_NAME_P (DECL_NAME (decl1)))\n-    warning (OPT_Wmissing_declarations, \"%Jno previous declaration for %qD\",\n-\t     decl1, decl1);\n+    warning (OPT_Wmissing_declarations, \"no previous declaration for %q+D\",\n+\t     decl1);\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n@@ -5913,8 +5905,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t   && TREE_USED (old_decl)\n \t   && C_DECL_IMPLICIT (old_decl))\n     warning (OPT_Wmissing_declarations,\n-\t     \"%J%qD was used with no declaration before its definition\",\n-\t     decl1, decl1);\n+\t     \"%q+D was used with no declaration before its definition\", decl1);\n \n   /* This is a definition, not a reference.\n      So normally clear DECL_EXTERNAL.\n@@ -5946,7 +5937,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n \t  != integer_type_node)\n-\tpedwarn (\"%Jreturn type of %qD is not %<int%>\", decl1, decl1);\n+\tpedwarn (\"return type of %q+D is not %<int%>\", decl1);\n \n       for (args = TYPE_ARG_TYPES (TREE_TYPE (decl1)); args;\n \t   args = TREE_CHAIN (args))\n@@ -5961,26 +5952,25 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t    {\n \t    case 1:\n \t      if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-\t\tpedwarn (\"%Jfirst argument of %qD should be %<int%>\",\n-\t\t\t decl1, decl1);\n+\t\tpedwarn (\"first argument of %q+D should be %<int%>\", decl1);\n \t      break;\n \n \t    case 2:\n \t      if (TREE_CODE (type) != POINTER_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn (\"%Jsecond argument of %qD should be %<char **%>\",\n-                         decl1, decl1);\n+\t\tpedwarn (\"second argument of %q+D should be %<char **%>\",\n+                         decl1);\n \t      break;\n \n \t    case 3:\n \t      if (TREE_CODE (type) != POINTER_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn (\"%Jthird argument of %qD should probably be \"\n-                         \"%<char **%>\", decl1, decl1);\n+\t\tpedwarn (\"third argument of %q+D should probably be \"\n+                         \"%<char **%>\", decl1);\n \t      break;\n \t    }\n \t}\n@@ -5989,10 +5979,10 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t argument because it's only mentioned in an appendix of the\n \t standard.  */\n       if (argct > 0 && (argct < 2 || argct > 3))\n-\tpedwarn (\"%J%qD takes only zero or two arguments\", decl1, decl1);\n+\tpedwarn (\"%q+D takes only zero or two arguments\", decl1);\n \n       if (!TREE_PUBLIC (decl1))\n-\tpedwarn (\"%J%qD is normally a non-static function\", decl1, decl1);\n+\tpedwarn (\"%q+D is normally a non-static function\", decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -6124,20 +6114,20 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  decl = b->decl;\n \t  /* If we got something other than a PARM_DECL it is an error.  */\n \t  if (TREE_CODE (decl) != PARM_DECL)\n-\t    error (\"%J%qD declared as a non-parameter\", decl, decl);\n+\t    error (\"%q+D declared as a non-parameter\", decl);\n \t  /* If the declaration is already marked, we have a duplicate\n \t     name.  Complain and ignore the duplicate.  */\n \t  else if (DECL_WEAK (decl))\n \t    {\n-\t      error (\"%Jmultiple parameters named %qD\", decl, decl);\n+\t      error (\"multiple parameters named %q+D\", decl);\n \t      TREE_PURPOSE (parm) = 0;\n \t      continue;\n \t    }\n \t  /* If the declaration says \"void\", complain and turn it into\n \t     an int.  */\n \t  else if (VOID_TYPE_P (TREE_TYPE (decl)))\n \t    {\n-\t      error (\"%Jparameter %qD declared with void type\", decl, decl);\n+\t      error (\"parameter %q+D declared with void type\", decl);\n \t      TREE_TYPE (decl) = integer_type_node;\n \t      DECL_ARG_TYPE (decl) = integer_type_node;\n \t      layout_decl (decl, 0);\n@@ -6152,10 +6142,9 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  pushdecl (decl);\n \n \t  if (flag_isoc99)\n-\t    pedwarn (\"%Jtype of %qD defaults to %<int%>\", decl, decl);\n+\t    pedwarn (\"type of %q+D defaults to %<int%>\", decl);\n \t  else if (extra_warnings)\n-\t    warning (OPT_Wextra, \"%Jtype of %qD defaults to %<int%>\",\n-\t\t     decl, decl);\n+\t    warning (OPT_Wextra, \"type of %q+D defaults to %<int%>\", decl);\n \t}\n \n       TREE_PURPOSE (parm) = decl;\n@@ -6174,14 +6163,13 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n       if (TREE_TYPE (parm) != error_mark_node\n \t  && !COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t{\n-\t  error (\"%Jparameter %qD has incomplete type\", parm, parm);\n+\t  error (\"parameter %q+D has incomplete type\", parm);\n \t  TREE_TYPE (parm) = error_mark_node;\n \t}\n \n       if (!DECL_WEAK (parm))\n \t{\n-\t  error (\"%Jdeclaration for parameter %qD but no such parameter\",\n-\t\t parm, parm);\n+\t  error (\"declaration for parameter %q+D but no such parameter\", parm);\n \n \t  /* Pretend the parameter was not missing.\n \t     This gets us to a standard state and minimizes\n@@ -6466,7 +6454,7 @@ finish_function (void)\n \t  /* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned.\n \t     If warn_main is -1 (-Wno-main) we don't want to be warned.  */\n \t  if (!warn_main)\n-\t    pedwarn (\"%Jreturn type of %qD is not %<int%>\", fndecl, fndecl);\n+\t    pedwarn (\"return type of %q+D is not %<int%>\", fndecl);\n \t}\n       else\n \t{\n@@ -6642,11 +6630,11 @@ check_for_loop_decls (void)\n \t{\n \tcase VAR_DECL:\n \t  if (TREE_STATIC (decl))\n-\t    error (\"%Jdeclaration of static variable %qD in %<for%> loop \"\n-\t\t   \"initial declaration\", decl, decl);\n+\t    error (\"declaration of static variable %q+D in %<for%> loop \"\n+\t\t   \"initial declaration\", decl);\n \t  else if (DECL_EXTERNAL (decl))\n-\t    error (\"%Jdeclaration of %<extern%> variable %qD in %<for%> loop \"\n-\t\t   \"initial declaration\", decl, decl);\n+\t    error (\"declaration of %<extern%> variable %q+D in %<for%> loop \"\n+\t\t   \"initial declaration\", decl);\n \t  break;\n \n \tcase RECORD_TYPE:\n@@ -6662,8 +6650,8 @@ check_for_loop_decls (void)\n \t\t id);\n \t  break;\n \tdefault:\n-\t  error (\"%Jdeclaration of non-variable %qD in %<for%> loop \"\n-\t\t \"initial declaration\", decl, decl);\n+\t  error (\"declaration of non-variable %q+D in %<for%> loop \"\n+\t\t \"initial declaration\", decl);\n \t}\n     }\n }\n@@ -7519,7 +7507,7 @@ c_write_global_declarations_1 (tree globals)\n \t  && !TREE_PUBLIC (decl)\n \t  && C_DECL_USED (decl))\n \t{\n-\t  pedwarn (\"%J%qF used but never defined\", decl, decl);\n+\t  pedwarn (\"%q+F used but never defined\", decl);\n \t  TREE_NO_WARNING (decl) = 1;\n \t}\n     }"}, {"sha": "5c4bb67dcde6cb9d1942aa622b08fa340a5aff4d", "filename": "gcc/c-format.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -391,6 +391,7 @@ static const format_flag_pair gcc_diag_flag_pairs[] =\n \n static const format_flag_spec gcc_diag_flag_specs[] =\n {\n+  { '+',  0, 0, N_(\"'+' flag\"),        N_(\"the '+' printf flag\"),              STD_C89 },\n   { 'q',  0, 0, N_(\"'q' flag\"),        N_(\"the 'q' diagnostic flag\"),          STD_C89 },\n   { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n@@ -558,7 +559,7 @@ static const format_char_info gcc_cdiag_char_table[] =\n   { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"\",   NULL },\n+  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+\", \"\",   NULL },\n \n   { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n@@ -659,13 +660,13 @@ static const format_kind_info format_types_orig[] =\n     'w', 0, 'p', 0, 'L',\n     NULL, NULL\n   },\n-  { \"gcc_diag\",   gcc_diag_length_specs,  gcc_diag_char_table, \"q\", NULL, \n+  { \"gcc_diag\",   gcc_diag_length_specs,  gcc_diag_char_table, \"q+\", NULL, \n     gcc_diag_flag_specs, gcc_diag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n     NULL, &integer_type_node\n   },\n-  { \"gcc_cdiag\",   gcc_cdiag_length_specs,  gcc_cdiag_char_table, \"q\", NULL, \n+  { \"gcc_cdiag\",   gcc_cdiag_length_specs,  gcc_cdiag_char_table, \"q+\", NULL, \n     gcc_cdiag_flag_specs, gcc_cdiag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',"}, {"sha": "eb556b142e18a6f0d756a6d0940b2f63887148b2", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -78,8 +78,8 @@ c_cannot_inline_tree_fn (tree *fnp)\n       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL)\n     {\n       if (do_warning)\n-\twarning (0, \"%Jfunction %qF can never be inlined because it \"\n-\t\t \"is suppressed using -fno-inline\", fn, fn);\n+\twarning (0, \"function %q+F can never be inlined because it \"\n+\t\t \"is suppressed using -fno-inline\", fn);\n       goto cannot_inline;\n     }\n \n@@ -88,16 +88,16 @@ c_cannot_inline_tree_fn (tree *fnp)\n   if (!DECL_DECLARED_INLINE_P (fn) && !targetm.binds_local_p (fn))\n     {\n       if (do_warning)\n-\twarning (0, \"%Jfunction %qF can never be inlined because it might not \"\n-\t\t \"be bound within this unit of translation\", fn, fn);\n+\twarning (0, \"function %q+F can never be inlined because it might not \"\n+\t\t \"be bound within this unit of translation\", fn);\n       goto cannot_inline;\n     }\n \n   if (!function_attribute_inlinable_p (fn))\n     {\n       if (do_warning)\n-\twarning (0, \"%Jfunction %qF can never be inlined because it uses \"\n-\t\t \"attributes conflicting with inlining\", fn, fn);\n+\twarning (0, \"function %q+F can never be inlined because it uses \"\n+\t\t \"attributes conflicting with inlining\", fn);\n       goto cannot_inline;\n     }\n \n@@ -162,18 +162,20 @@ c_objc_common_init (void)\n    diagnostic machinery.  */\n static bool\n c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n-\t\tint precision, bool wide, bool plus, bool hash)\n+\t\tint precision, bool wide, bool set_locus, bool hash)\n {\n   tree t = va_arg (*text->args_ptr, tree);\n   tree name;\n   const char *n = \"({anonymous})\";\n   c_pretty_printer *cpp = (c_pretty_printer *) pp;\n   pp->padding = pp_none;\n \n-  /* FUTURE: %+x should set the locus.  */\n-  if (precision != 0 || wide || plus || hash)\n+  if (precision != 0 || wide || hash)\n     return false;\n \n+  if (set_locus && text->locus)\n+    *text->locus = DECL_SOURCE_LOCATION (t);\n+\n   switch (*spec)\n     {\n     case 'D':"}, {"sha": "7e028cbaa578bfe595079ba81d1de207a0d27112", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -259,8 +259,8 @@ apply_pragma_weak (tree decl, tree value)\n   if (SUPPORTS_WEAK && DECL_EXTERNAL (decl) && TREE_USED (decl)\n       && !DECL_WEAK (decl) /* Don't complain about a redundant #pragma.  */\n       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-    warning (0, \"%Japplying #pragma weak %qD after first use results \"\n-             \"in unspecified behavior\", decl, decl);\n+    warning (0, \"applying #pragma weak %q+D after first use results \"\n+             \"in unspecified behavior\", decl);\n \n   declare_weak (decl);\n }"}, {"sha": "f2f67d5a96f361971e1a334657019f6df0b9ed2d", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -162,7 +162,7 @@ arm_mark_dllimport (decl)\n       && !DECL_VIRTUAL_P (decl)\n       && DECL_INITIAL (decl))\n     {\n-      error (\"%Jinitialized variable '%D' is marked dllimport\", decl, decl);\n+      error (\"initialized variable %q+D is marked dllimport\", decl);\n       return;\n     }\n   /* Nor can they be static.  */\n@@ -171,7 +171,7 @@ arm_mark_dllimport (decl)\n       && !DECL_VIRTUAL_P (decl)\n       && 0 /*???*/)\n     {\n-      error (\"%Jstatic variable '%D' is marked dllimport\", decl, decl);\n+      error (\"static variable %q+D is marked dllimport\", decl);\n       return;\n     }\n "}, {"sha": "c1c605c6a1c54d7413692331ae87f5d0244b43e3", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -199,8 +199,8 @@ i386_pe_dllimport_p (tree decl)\n \t{\n \t   /* Don't warn about artificial methods.  */\n \t  if (!DECL_ARTIFICIAL (decl))\n-\t    warning (0, \"%Jfunction '%D' is defined after prior declaration \"\n-\t\t     \"as dllimport: attribute ignored\", decl, decl);\n+\t    warning (0, \"function %q+D is defined after prior declaration \"\n+\t\t     \"as dllimport: attribute ignored\", decl);\n \t  return 0;\n \t}\n \n@@ -210,8 +210,8 @@ i386_pe_dllimport_p (tree decl)\n       else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n         {\n \t  if (extra_warnings)\n-\t    warning (0, \"%Jinline function '%D' is declared as dllimport: \"\n-\t\t     \"attribute ignored.\", decl, decl);\n+\t    warning (0, \"inline function %q+D is declared as dllimport: \"\n+\t\t     \"attribute ignored\", decl);\n \t  return 0;\n \t}\n \n@@ -222,8 +222,8 @@ i386_pe_dllimport_p (tree decl)\n \t       && !DECL_EXTERNAL (decl) && context_imp)\n \t{\n \t  if (!DECL_VIRTUAL_P (decl))\n-            error (\"%Jdefinition of static data member '%D' of \"\n-\t\t   \"dllimport'd class.\", decl, decl);\n+            error (\"definition of static data member %q+D of \"\n+\t\t   \"dllimport'd class\", decl);\n \t  return 0;\n \t}\n \n@@ -279,8 +279,8 @@ i386_pe_mark_dllexport (tree decl)\n   oldname = XSTR (rtlname, 0);\n   if (i386_pe_dllimport_name_p (oldname))\n     {\n-      warning (0, \"%Jinconsistent dll linkage for '%D', dllexport assumed.\",\n-\t       decl, decl);\n+      warning (0, \"inconsistent dll linkage for %q+D, dllexport assumed\",\n+\t       decl);\n      /* Remove DLL_IMPORT_PREFIX.  */\n       oldname += strlen (DLL_IMPORT_PREFIX);\n       DECL_NON_ADDR_CONST_P (decl) = 0;\n@@ -463,12 +463,12 @@ i386_pe_encode_section_info (tree decl, rtx rtl, int first)\n \t We leave these alone for now.  */\n \n       if (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n-\twarning (0, \"%J'%D' defined locally after being \"\n-\t\t \"referenced with dllimport linkage\", decl, decl);\n+\twarning (0, \"%q+D defined locally after being \"\n+\t\t \"referenced with dllimport linkage\", decl);\n       else\n-\twarning (OPT_Wattributes, \"%J'%D' redeclared without dllimport \"\n+\twarning (OPT_Wattributes, \"%q+D redeclared without dllimport \"\n \t\t \"attribute after being referenced with dllimport linkage\",\n-\t\t decl, decl);\n+\t\t decl);\n     }\n }\n \n@@ -634,7 +634,7 @@ i386_pe_section_type_flags (tree decl, const char *name, int reloc)\n   else\n     {\n       if (decl && **slot != flags)\n-\terror (\"%J'%D' causes a section type conflict\", decl, decl);\n+\terror (\"%q+D causes a section type conflict\", decl);\n     }\n \n   return flags;"}, {"sha": "8f28e2080dfa6ba80227a2f8ebbdd9b2543be142", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -515,21 +515,21 @@ ia64_handle_model_attribute (tree *node, tree name, tree args,\n \t  && !TREE_STATIC (decl))\n \t{\n \t  error (\"%Jan address area attribute cannot be specified for \"\n-\t\t \"local variables\", decl, decl);\n+\t\t \"local variables\", decl);\n \t  *no_add_attrs = true;\n \t}\n       area = ia64_get_addr_area (decl);\n       if (area != ADDR_AREA_NORMAL && addr_area != area)\n \t{\n-\t  error (\"%Jaddress area of '%s' conflicts with previous \"\n-\t\t \"declaration\", decl, decl);\n+\t  error (\"address area of %q+D conflicts with previous \"\n+\t\t \"declaration\", decl);\n \t  *no_add_attrs = true;\n \t}\n       break;\n \n     case FUNCTION_DECL:\n       error (\"%Jaddress area attribute cannot be specified for functions\",\n-\t     decl, decl);\n+\t     decl);\n       *no_add_attrs = true;\n       break;\n "}, {"sha": "8237d45a03402aa33edb4f61bc392455dd2de041", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -2895,7 +2895,7 @@ mcore_mark_dllimport (tree decl)\n       && !DECL_VIRTUAL_P (decl)\n       && DECL_INITIAL (decl))\n     {\n-      error (\"%Jinitialized variable '%D' is marked dllimport\", decl, decl);\n+      error (\"initialized variable %q+D is marked dllimport\", decl);\n       return;\n     }\n   "}, {"sha": "456c23c71cd9ccafea7143887a1f697b42aff04d", "filename": "gcc/config/sh/symbian.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fsh%2Fsymbian.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fsh%2Fsymbian.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -144,9 +144,9 @@ sh_symbian_dllimport_p (tree decl)\n     {\n       /* Don't warn about artificial methods.  */\n       if (!DECL_ARTIFICIAL (decl))\n-\twarning (OPT_Wattributes, \"%H function '%D' is defined after prior \"\n+\twarning (OPT_Wattributes, \"function %q+D is defined after prior \"\n \t\t \"declaration as dllimport: attribute ignored\",\n-\t\t & DECL_SOURCE_LOCATION (decl), decl);\n+\t\t decl);\n       return false;\n     }\n \n@@ -156,9 +156,9 @@ sh_symbian_dllimport_p (tree decl)\n   else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n     {\n       if (extra_warnings)\n-\twarning (OPT_Wattributes, \"%Hinline function '%D' is declared as \"\n-\t\t \"dllimport: attribute ignored.\",\n-\t\t & DECL_SOURCE_LOCATION (decl), decl);\n+\twarning (OPT_Wattributes, \"inline function %q+D is declared as \"\n+\t\t \"dllimport: attribute ignored\",\n+\t\t decl);\n       return false;\n     }\n \n@@ -170,8 +170,8 @@ sh_symbian_dllimport_p (tree decl)\n \t   && !DECL_EXTERNAL (decl))\n     {\n       if (!DECL_VIRTUAL_P (decl))\n-\terror (\"%Hdefinition of static data member '%D' of dllimport'd class.\",\n-\t       & DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"definition of static data member %q+D of dllimport'd class\",\n+\t       decl);\n       return false;\n     }\n \n@@ -277,8 +277,8 @@ sh_symbian_mark_dllimport (tree decl)\n     {\n       /* Already done, but do a sanity check to prevent assembler errors.  */\n       if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n-\terror (\"%Hfailure in redeclaration of '%D': dllimport'd symbol lacks external linkage.\",\n-\t       &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"failure in redeclaration of %q+D: dllimport'd symbol lacks external linkage\",\n+\t       decl);\n     }\n   else\n     {\n@@ -323,8 +323,7 @@ sh_symbian_encode_section_info (tree decl, rtx rtl, int first)\n       tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n       rtx newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n \n-      warning (0, \"%H%s '%D' %s after being referenced with dllimport linkage.\",\n-\t       & DECL_SOURCE_LOCATION (decl),\n+      warning (0, \"%s %q+D %s after being referenced with dllimport linkage\",\n \t       TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\",\n \t       decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n \t       ? \"defined locally\" : \"redeclared without dllimport attribute\");\n@@ -427,8 +426,8 @@ sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n \t{\n \t  if (DECL_INITIAL (node))\n \t    {\n-\t      error (\"%Hvariable %qD definition is marked dllimport.\",\n-\t\t     & DECL_SOURCE_LOCATION (node), node);\n+\t      error (\"variable %q+D definition is marked dllimport\",\n+\t\t     node);\n \t      *no_add_attrs = true;\n \t    }\n \n@@ -502,8 +501,8 @@ sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n       && (   TREE_CODE (node) == VAR_DECL\n \t  || TREE_CODE (node) == FUNCTION_DECL))\n     {\n-      error (\"%Hexternal linkage required for symbol '%D' because of '%s' attribute.\",\n-\t       & DECL_SOURCE_LOCATION (node), node, IDENTIFIER_POINTER (name));\n+      error (\"external linkage required for symbol %q+D because of %qs attribute\",\n+\t     node, IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n "}, {"sha": "e3d3147cafe6a2e62ba24b26f4a6a20a9805df8f", "filename": "gcc/config/sol2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fsol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fsol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -51,8 +51,8 @@ solaris_insert_attributes (tree decl, tree *attributes)\n \t  {\n \t    if (lookup_attribute (\"aligned\", DECL_ATTRIBUTES (decl))\n \t\t|| lookup_attribute (\"aligned\", *attributes))\n-\t      warning (0, \"%Jignoring %<#pragma align%> for explicitly \"\n-\t\t       \"aligned %<%D%>\", decl, decl);\n+\t      warning (0, \"ignoring %<#pragma align%> for explicitly \"\n+\t\t       \"aligned %q+D\", decl);\n \t    else\n \t      *attributes = tree_cons (get_identifier (\"aligned\"), value,\n \t\t\t\t       *attributes);"}, {"sha": "efc83203c3a8a09e3c34a3fc312cb306256cfcc0", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -2138,7 +2138,7 @@ v850_handle_data_area_attribute (tree* node,\n       if (current_function_decl != NULL_TREE)\n \t{\n           error (\"%Jdata area attributes cannot be specified for \"\n-                 \"local variables\", decl, decl);\n+                 \"local variables\", decl);\n \t  *no_add_attrs = true;\n \t}\n \n@@ -2148,8 +2148,8 @@ v850_handle_data_area_attribute (tree* node,\n       area = v850_get_data_area (decl);\n       if (area != DATA_AREA_NORMAL && data_area != area)\n \t{\n-\t  error (\"%Jdata area of '%D' conflicts with previous declaration\",\n-                 decl, decl);\n+\t  error (\"data area of %q+D conflicts with previous declaration\",\n+                 decl);\n \t  *no_add_attrs = true;\n \t}\n       break;"}, {"sha": "530b0e41a9752e128b2940ce8ed602229ba3c870", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1,3 +1,14 @@\n+2005-07-02  Zack Weinberg  <zack@codesourcery.com>\n+            Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* error.c (location_of): Add comment.\n+\t(locate_error, cp_error_at, cp_warning_at, cp_pedwarn_at): Remove.\n+\t* cp-tree.h (cp_error_at, cp_warning_at, cp_pedwarn_at): Remove.\n+\t* call.c, class.c, decl.c, decl2.c, friend.c, init.c,\n+\tname-lookup.c, parser.c, pt.c, search.c, semantics.c, typeck.c,\n+\ttypeck2.c: Use '+' flag instead of %J, cp_error_at, cp_warning_at\n+\tor cp_pedwarn_at.  Mark up some diagnostic strings with N_.\n+\n 2005-06-30  Daniel Berlin  <dberlin@dberlin.org> \n \t\n \t* decl.c (require_complete_types_for_parms): Call relayout_decl"}, {"sha": "382d6ea8e8b89ec1037fe50949151071f2d08dc5", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -2388,9 +2388,9 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n   else if (TYPE_P (candidate->fn))\n     inform (\"%s %T <conversion>\", msgstr, candidate->fn);\n   else if (candidate->viable == -1)\n-    inform (\"%J%s %+#D <near match>\", candidate->fn, msgstr, candidate->fn);\n+    inform (\"%s %+#D <near match>\", msgstr, candidate->fn);\n   else\n-    inform (\"%J%s %+#D\", candidate->fn, msgstr, candidate->fn);\n+    inform (\"%s %+#D\", msgstr, candidate->fn);\n }\n \n static void\n@@ -4052,11 +4052,11 @@ enforce_access (tree basetype_path, tree decl)\n   if (!accessible_p (basetype_path, decl, true))\n     {\n       if (TREE_PRIVATE (decl))\n-\tcp_error_at (\"%q+#D is private\", decl);\n+\terror (\"%q+#D is private\", decl);\n       else if (TREE_PROTECTED (decl))\n-\tcp_error_at (\"%q+#D is protected\", decl);\n+\terror (\"%q+#D is protected\", decl);\n       else\n-\tcp_error_at (\"%q+#D is inaccessible\", decl);\n+\terror (\"%q+#D is inaccessible\", decl);\n       error (\"within this context\");\n       return false;\n     }"}, {"sha": "4af7412405a8a5f247997f3161493419a68f9b94", "filename": "gcc/cp/class.c", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1029,15 +1029,15 @@ add_method (tree type, tree method, tree using_decl)\n \t\t    /* Defer to the local function.  */\n \t\t    return;\n \t\t  if (DECL_CONTEXT (fn) == DECL_CONTEXT (method))\n-\t\t    cp_error_at (\"repeated using declaration %qD\", using_decl);\n+\t\t    error (\"repeated using declaration %q+D\", using_decl);\n \t\t  else\n-\t\t    cp_error_at (\"using declaration %qD conflicts with a previous using declaration\",\n-\t\t\t\t using_decl);\n+\t\t    error (\"using declaration %q+D conflicts with a previous using declaration\",\n+\t\t\t   using_decl);\n \t\t}\n \t      else\n \t\t{\n-\t\t  cp_error_at (\"%q#D cannot be overloaded\", method);\n-\t\t  cp_error_at (\"with %q#D\", fn);\n+\t\t  error (\"%q+#D cannot be overloaded\", method);\n+\t\t  error (\"with %q+#D\", fn);\n \t\t}\n \n \t      /* We don't call duplicate_decls here to merge the\n@@ -1092,8 +1092,8 @@ alter_access (tree t, tree fdecl, tree access)\n       if (TREE_VALUE (elem) != access)\n \t{\n \t  if (TREE_CODE (TREE_TYPE (fdecl)) == FUNCTION_DECL)\n-\t    cp_error_at (\"conflicting access specifications for method\"\n-\t\t\t \" %qD, ignored\", TREE_TYPE (fdecl));\n+\t    error (\"conflicting access specifications for method\"\n+\t\t   \" %q+D, ignored\", TREE_TYPE (fdecl));\n \t  else\n \t    error (\"conflicting access specifications for field %qE, ignored\",\n \t\t   DECL_NAME (fdecl));\n@@ -1156,16 +1156,16 @@ handle_using_decl (tree using_decl, tree t)\n \t   the same name already present in the current class.  */;\n       else\n \t{\n-\t  cp_error_at (\"%qD invalid in %q#T\", using_decl, t);\n-\t  cp_error_at (\"  because of local method %q#D with same name\",\n-\t\t       OVL_CURRENT (old_value));\n+\t  error (\"%q+D invalid in %q#T\", using_decl, t);\n+\t  error (\"  because of local method %q+#D with same name\",\n+\t\t OVL_CURRENT (old_value));\n \t  return;\n \t}\n     }\n   else if (!DECL_ARTIFICIAL (old_value))\n     {\n-      cp_error_at (\"%qD invalid in %q#T\", using_decl, t);\n-      cp_error_at (\"  because of local member %q#D with same name\", old_value);\n+      error (\"%q+D invalid in %q#T\", using_decl, t);\n+      error (\"  because of local member %q+#D with same name\", old_value);\n       return;\n     }\n \n@@ -2383,8 +2383,8 @@ warn_hidden (tree t)\n       while (base_fndecls)\n \t{\n \t  /* Here we know it is a hider, and no overrider exists.  */\n-\t  cp_warning_at (\"%qD was hidden\", TREE_VALUE (base_fndecls));\n-\t  cp_warning_at (\"  by %qD\", fns);\n+\t  warning (0, \"%q+D was hidden\", TREE_VALUE (base_fndecls));\n+\t  warning (0, \"  by %q+D\", fns);\n \t  base_fndecls = TREE_CHAIN (base_fndecls);\n \t}\n     }\n@@ -2425,18 +2425,15 @@ finish_struct_anon (tree t)\n \n \t      if (TREE_CODE (elt) != FIELD_DECL)\n \t\t{\n-\t\t  cp_pedwarn_at (\"%q#D invalid; an anonymous union can \"\n-\t\t\t\t \"only have non-static data members\",\n-\t\t\t\t elt);\n+\t\t  pedwarn (\"%q+#D invalid; an anonymous union can \"\n+\t\t\t   \"only have non-static data members\", elt);\n \t\t  continue;\n \t\t}\n \n \t      if (TREE_PRIVATE (elt))\n-\t\tcp_pedwarn_at (\"private member %q#D in anonymous union\",\n-\t\t\t       elt);\n+\t\tpedwarn (\"private member %q+#D in anonymous union\", elt);\n \t      else if (TREE_PROTECTED (elt))\n-\t\tcp_pedwarn_at (\"protected member %q#D in anonymous union\",\n-\t\t\t       elt);\n+\t\tpedwarn (\"protected member %q+#D in anonymous union\", elt);\n \n \t      TREE_PRIVATE (elt) = TREE_PRIVATE (field);\n \t      TREE_PROTECTED (elt) = TREE_PROTECTED (field);\n@@ -2602,7 +2599,7 @@ check_bitfield_decl (tree field)\n   if (DECL_INITIAL (field)\n       && ! INTEGRAL_TYPE_P (TREE_TYPE (field)))\n     {\n-      cp_error_at (\"bit-field %q#D with non-integral type\", field);\n+      error (\"bit-field %q+#D with non-integral type\", field);\n       w = error_mark_node;\n     }\n \n@@ -2619,24 +2616,23 @@ check_bitfield_decl (tree field)\n \n       if (TREE_CODE (w) != INTEGER_CST)\n \t{\n-\t  cp_error_at (\"bit-field %qD width not an integer constant\",\n-\t\t       field);\n+\t  error (\"bit-field %q+D width not an integer constant\", field);\n \t  w = error_mark_node;\n \t}\n       else if (tree_int_cst_sgn (w) < 0)\n \t{\n-\t  cp_error_at (\"negative width in bit-field %qD\", field);\n+\t  error (\"negative width in bit-field %q+D\", field);\n \t  w = error_mark_node;\n \t}\n       else if (integer_zerop (w) && DECL_NAME (field) != 0)\n \t{\n-\t  cp_error_at (\"zero width for bit-field %qD\", field);\n+\t  error (\"zero width for bit-field %q+D\", field);\n \t  w = error_mark_node;\n \t}\n       else if (compare_tree_int (w, TYPE_PRECISION (type)) > 0\n \t       && TREE_CODE (type) != ENUMERAL_TYPE\n \t       && TREE_CODE (type) != BOOLEAN_TYPE)\n-\tcp_warning_at (\"width of %qD exceeds its type\", field);\n+\twarning (0, \"width of %q+D exceeds its type\", field);\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n \t       && (0 > compare_tree_int (w,\n \t\t\t\t\t min_precision (TYPE_MIN_VALUE (type),\n@@ -2645,8 +2641,7 @@ check_bitfield_decl (tree field)\n \t\t\t\t\t     min_precision\n \t\t\t\t\t     (TYPE_MAX_VALUE (type),\n \t\t\t\t\t      TYPE_UNSIGNED (type)))))\n-\tcp_warning_at (\"%qD is too small to hold all values of %q#T\",\n-\t\t       field, type);\n+\twarning (0, \"%q+D is too small to hold all values of %q#T\", field, type);\n     }\n \n   /* Remove the bit-field width indicator so that the rest of the\n@@ -2705,14 +2700,13 @@ check_field_decl (tree field,\n       if (TREE_CODE (t) == UNION_TYPE)\n \t{\n \t  if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t    cp_error_at (\"member %q#D with constructor not allowed in union\",\n-\t\t\t field);\n+\t    error (\"member %q+#D with constructor not allowed in union\",\n+\t\t   field);\n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t    cp_error_at (\"member %q#D with destructor not allowed in union\",\n-\t\t\t field);\n+\t    error (\"member %q+#D with destructor not allowed in union\", field);\n \t  if (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n-\t    cp_error_at (\"member %q#D with copy assignment operator not allowed in union\",\n-\t\t\t field);\n+\t    error (\"member %q+#D with copy assignment operator not allowed in union\",\n+\t\t   field);\n \t}\n       else\n \t{\n@@ -2794,8 +2788,9 @@ check_field_decls (tree t, tree *access_decls,\n \t  if (TYPE_PACKED (t))\n \t    {\n \t      if (!pod_type_p (TREE_TYPE (x)) && !TYPE_PACKED (TREE_TYPE (x)))\n-\t\tcp_warning_at\n-\t\t  (\"ignoring packed attribute on unpacked non-POD field %q#D\",\n+\t\twarning\n+\t\t  (0,\n+\t\t   \"ignoring packed attribute on unpacked non-POD field %q+#D\",\n \t\t   x);\n \t      else\n \t\tDECL_PACKED (x) = 1;\n@@ -2855,33 +2850,33 @@ check_field_decls (tree t, tree *access_decls,\n \t     reference type, the program is ill-formed.  */\n \t  if (TREE_CODE (x) == VAR_DECL)\n \t    {\n-\t      cp_error_at (\"%qD may not be static because it is a member of a union\", x);\n+\t      error (\"%q+D may not be static because it is a member of a union\", x);\n \t      continue;\n \t    }\n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    {\n-\t      cp_error_at (\"%qD may not have reference type %qT because\"\n-\t\t\t   \" it is a member of a union\",\n-\t\t\t   x, type);\n+\t      error (\"%q+D may not have reference type %qT because\"\n+\t\t     \" it is a member of a union\",\n+\t\t     x, type);\n \t      continue;\n \t    }\n \t}\n \n       /* ``A local class cannot have static data members.'' ARM 9.4 */\n       if (current_function_decl && TREE_STATIC (x))\n-\tcp_error_at (\"field %qD in local class cannot be static\", x);\n+\terror (\"field %q+D in local class cannot be static\", x);\n \n       /* Perform error checking that did not get done in\n \t grokdeclarator.  */\n       if (TREE_CODE (type) == FUNCTION_TYPE)\n \t{\n-\t  cp_error_at (\"field %qD invalidly declared function type\", x);\n+\t  error (\"field %q+D invalidly declared function type\", x);\n \t  type = build_pointer_type (type);\n \t  TREE_TYPE (x) = type;\n \t}\n       else if (TREE_CODE (type) == METHOD_TYPE)\n \t{\n-\t  cp_error_at (\"field %qD invalidly declared method type\", x);\n+\t  error (\"field %q+D invalidly declared method type\", x);\n \t  type = build_pointer_type (type);\n \t  TREE_TYPE (x) = type;\n \t}\n@@ -2913,7 +2908,7 @@ check_field_decls (tree t, tree *access_decls,\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n \t      && extra_warnings)\n-\t    cp_warning_at (\"non-static reference %q#D in class without a constructor\", x);\n+\t    warning (0, \"non-static reference %q+#D in class without a constructor\", x);\n \t}\n \n       type = strip_array_types (type);\n@@ -2960,7 +2955,7 @@ check_field_decls (tree t, tree *access_decls,\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n \t      && extra_warnings)\n-\t    cp_warning_at (\"non-static const member %q#D in class without a constructor\", x);\n+\t    warning (0, \"non-static const member %q+#D in class without a constructor\", x);\n \t}\n       /* A field that is pseudo-const makes the structure likewise.  */\n       else if (CLASS_TYPE_P (type))\n@@ -2975,7 +2970,7 @@ check_field_decls (tree t, tree *access_decls,\n \t different name from the class iff the class has a\n \t user-defined constructor.  */\n       if (constructor_name_p (DECL_NAME (x), t) && TYPE_HAS_CONSTRUCTOR (t))\n-\tcp_pedwarn_at (\"field %q#D with same name as class\", x);\n+\tpedwarn (\"field %q+#D with same name as class\", x);\n \n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n \t If the type and width are valid, we'll also set DECL_BIT_FIELD.  */\n@@ -3644,7 +3639,7 @@ check_methods (tree t)\n     {\n       check_for_override (x, t);\n       if (DECL_PURE_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n-\tcp_error_at (\"initializer specified for non-virtual method %qD\", x);\n+\terror (\"initializer specified for non-virtual method %q+D\", x);\n       /* The name of the field is the original field name\n \t Save this in auxiliary field for later overloading.  */\n       if (DECL_VINDEX (x))\n@@ -4662,20 +4657,18 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  && !integer_zerop (size_binop (TRUNC_MOD_EXPR,\n \t\t\t\t\t DECL_FIELD_BIT_OFFSET (field),\n \t\t\t\t\t bitsize_unit_node)))\n-\tcp_warning_at (\"offset of %qD is not ABI-compliant and may \"\n-\t\t       \"change in a future version of GCC\",\n-\t\t       field);\n+\twarning (0, \"offset of %q+D is not ABI-compliant and may \"\n+\t\t \"change in a future version of GCC\", field);\n \n       /* G++ used to use DECL_FIELD_OFFSET as if it were the byte\n \t offset of the field.  */\n       if (warn_abi\n \t  && !tree_int_cst_equal (DECL_FIELD_OFFSET (field),\n \t\t\t\t  byte_position (field))\n \t  && contains_empty_class_p (TREE_TYPE (field)))\n-\tcp_warning_at (\"%qD contains empty classes which may cause base \"\n-\t\t       \"classes to be placed at different locations in a \"\n-\t\t       \"future version of GCC\",\n-\t\t       field);\n+\twarning (0, \"%q+D contains empty classes which may cause base \"\n+\t\t \"classes to be placed at different locations in a \"\n+\t\t \"future version of GCC\", field);\n \n       /* If we needed additional padding after this field, add it\n \t now.  */\n@@ -6249,9 +6242,8 @@ note_name_declared_in_class (tree name, tree decl)\n \t in its context and when re-evaluated in the completed scope of\n \t S.  */\n       error (\"declaration of %q#D\", decl);\n-      cp_error_at (\"changes meaning of %qD from %q+#D\",\n-\t\t   DECL_NAME (OVL_CURRENT (decl)),\n-\t\t   (tree) n->value);\n+      error (\"changes meaning of %qD from %q+#D\",\n+\t     DECL_NAME (OVL_CURRENT (decl)), (tree) n->value);\n     }\n }\n "}, {"sha": "2cef23460cff2d97803bc51274e5a1574646cb16", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -4375,8 +4375,4 @@ extern void cp_genericize\t\t\t(tree);\n #define ATTRIBUTE_GCC_CXXDIAG(m, n) ATTRIBUTE_NONNULL(m)\n #endif\n \n-extern void cp_error_at\t\t(const char *, ...) ATTRIBUTE_GCC_CXXDIAG(1, 2);\n-extern void cp_warning_at\t(const char *, ...) ATTRIBUTE_GCC_CXXDIAG(1, 2);\n-extern void cp_pedwarn_at\t(const char *, ...) ATTRIBUTE_GCC_CXXDIAG(1, 2);\n-\n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "6e1dad10867eccd9ab00210024e044506a482ee7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 62, "deletions": 72, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -352,7 +352,7 @@ pop_label (tree label, tree old_value)\n \t{\n \t  location_t location;\n \n-\t  cp_error_at (\"label %qD used but not defined\", label);\n+\t  error (\"label %q+D used but not defined\", label);\n #ifdef USE_MAPPED_LOCATION\n \t  location = input_location; /* FIXME want (input_filename, (line)0) */\n #else\n@@ -363,7 +363,7 @@ pop_label (tree label, tree old_value)\n \t  define_label (location, DECL_NAME (label));\n \t}\n       else if (warn_unused_label && !TREE_USED (label))\n-\tcp_warning_at (\"label %qD defined but not used\", label);\n+\twarning (0, \"label %q+D defined but not used\", label);\n     }\n \n   SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (label), old_value);\n@@ -557,7 +557,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t  && ! TREE_USED (decl)\n \t  && ! DECL_IN_SYSTEM_HEADER (decl)\n \t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n-\twarning (0, \"%Junused variable %qD\", decl, decl);\n+\twarning (0, \"unused variable %q+D\", decl);\n \n   /* Remove declarations for all the DECLs in this level.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n@@ -997,7 +997,7 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n   pedwarn (\"%qD was declared %<extern%> and later %<static%>\", newdecl);\n-  cp_pedwarn_at (\"previous declaration of %qD\", olddecl);\n+  pedwarn (\"previous declaration of %q+D\", olddecl);\n }\n \n /* If NEWDECL is a redeclaration of OLDDECL, merge the declarations.\n@@ -1045,19 +1045,19 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t       && DECL_UNINLINABLE (olddecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t{\n-\t  warning (OPT_Wattributes, \"%Jfunction %qD redeclared as inline\",\n-\t\t   newdecl, newdecl);\n-\t  warning (OPT_Wattributes, \"%Jprevious declaration of %qD \"\n-\t\t   \"with attribute noinline\", olddecl, olddecl);\n+\t  warning (OPT_Wattributes, \"function %q+D redeclared as inline\",\n+\t\t   newdecl);\n+\t  warning (OPT_Wattributes, \"previous declaration of %q+D \"\n+\t\t   \"with attribute noinline\", olddecl);\n \t}\n       else if (DECL_DECLARED_INLINE_P (olddecl)\n \t       && DECL_UNINLINABLE (newdecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t{\n-\t  warning (OPT_Wattributes, \"%Jfunction %qD redeclared with \"\n-\t\t   \"attribute noinline\", newdecl, newdecl);\n-\t  warning (OPT_Wattributes, \"%Jprevious declaration of %qD was inline\",\n-\t\t   olddecl, olddecl);\n+\t  warning (OPT_Wattributes, \"function %q+D redeclared with \"\n+\t\t   \"attribute noinline\", newdecl);\n+\t  warning (OPT_Wattributes, \"previous declaration of %q+D was inline\",\n+\t\t   olddecl);\n \t}\n     }\n \n@@ -1218,7 +1218,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n       error (\"%q#D redeclared as different kind of symbol\", newdecl);\n       if (TREE_CODE (olddecl) == TREE_LIST)\n \tolddecl = TREE_VALUE (olddecl);\n-      cp_error_at (\"previous declaration of %q#D\", olddecl);\n+      error (\"previous declaration of %q+#D\", olddecl);\n \n       return error_mark_node;\n     }\n@@ -1238,8 +1238,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n \t    {\n \t      error (\"declaration of template %q#D\", newdecl);\n-\t      cp_error_at (\"conflicts with previous declaration %q#D\",\n-\t\t\t   olddecl);\n+\t      error (\"conflicts with previous declaration %q+#D\", olddecl);\n \t    }\n \t  else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL\n \t\t   && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n@@ -1253,7 +1252,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t\t\t   TREE_TYPE (TREE_TYPE (olddecl))))\n \t    {\n \t      error (\"new declaration %q#D\", newdecl);\n-\t      cp_error_at (\"ambiguates old declaration %q#D\", olddecl);\n+\t      error (\"ambiguates old declaration %q+#D\", olddecl);\n \t    }\n \t  return NULL_TREE;\n \t}\n@@ -1263,22 +1262,21 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t    {\n \t      error (\"declaration of C function %q#D conflicts with\",\n \t\t     newdecl);\n-\t      cp_error_at (\"previous declaration %q#D here\", olddecl);\n+\t      error (\"previous declaration %q+#D here\", olddecl);\n \t    }\n \t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n \t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n \t    {\n \t      error (\"new declaration %q#D\", newdecl);\n-\t      cp_error_at (\"ambiguates old declaration %q#D\", olddecl);\n+\t      error (\"ambiguates old declaration %q+#D\", olddecl);\n \t    }\n \t  else\n \t    return NULL_TREE;\n \t}\n       else\n \t{\n \t  error (\"conflicting declaration %q#D\", newdecl);\n-\t  cp_error_at (\"%qD has a previous declaration as %q#D\",\n-\t\t       olddecl, olddecl);\n+\t  error (\"%q+D has a previous declaration as %q#D\", olddecl, olddecl);\n \t  return error_mark_node;\n \t}\n     }\n@@ -1331,7 +1329,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t declared as the name of any other entity in any global scope\n \t of the program.  */\n       error (\"declaration of namespace %qD conflicts with\", newdecl);\n-      cp_error_at (\"previous declaration of namespace %qD here\", olddecl);\n+      error (\"previous declaration of namespace %q+D here\", olddecl);\n       return error_mark_node;\n     }\n   else\n@@ -1341,10 +1339,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t{\n \t  error (errmsg, newdecl);\n \t  if (DECL_NAME (olddecl) != NULL_TREE)\n-\t    cp_error_at ((DECL_INITIAL (olddecl)\n-\t\t\t  && namespace_bindings_p ())\n-\t\t\t ? \"%q#D previously defined here\"\n-\t\t\t : \"%q#D previously declared here\", olddecl);\n+\t    error ((DECL_INITIAL (olddecl) && namespace_bindings_p ())\n+\t\t\t ? \"%q+#D previously defined here\"\n+\t\t\t : \"%q+#D previously declared here\", olddecl);\n \t  return error_mark_node;\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -1353,7 +1350,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t       && TYPE_ARG_TYPES (TREE_TYPE (newdecl)) != NULL_TREE)\n \t{\n \t  /* Prototype decl follows defn w/o prototype.  */\n-\t  cp_warning_at (\"prototype for %q#D\", newdecl);\n+\t  warning (0, \"prototype for %q+#D\", newdecl);\n \t  warning (0, \"%Jfollows non-prototype definition here\", olddecl);\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -1366,8 +1363,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t    SET_DECL_LANGUAGE (newdecl, DECL_LANGUAGE (olddecl));\n \t  else\n \t    {\n-\t      cp_error_at (\"previous declaration of %q#D with %qL linkage\",\n-\t\t\t   olddecl, DECL_LANGUAGE (olddecl));\n+\t      error (\"previous declaration of %q+#D with %qL linkage\",\n+\t\t     olddecl, DECL_LANGUAGE (olddecl));\n \t      error (\"conflicts with new declaration with %qL linkage\",\n \t\t     DECL_LANGUAGE (newdecl));\n \t    }\n@@ -1393,14 +1390,13 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t  {\n \t\t    pedwarn (\"default argument given for parameter %d of %q#D\",\n \t\t\t     i, newdecl);\n-\t\t    cp_pedwarn_at (\"after previous specification in %q#D\",\n-\t\t\t\t   olddecl);\n+\t\t    pedwarn (\"after previous specification in %q+#D\", olddecl);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    error (\"default argument given for parameter %d of %q#D\",\n \t\t\t   i, newdecl);\n-\t\t    cp_error_at (\"after previous specification in %q#D\",\n+\t\t    error (\"after previous specification in %q+#D\",\n \t\t\t\t olddecl);\n \t\t  }\n \t      }\n@@ -1463,7 +1459,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  && ! (DECL_FRIEND_P (newdecl) || DECL_FRIEND_P (olddecl)))\n \t{\n \t  warning (0, \"redundant redeclaration of %qD in same scope\", newdecl);\n-\t  cp_warning_at (\"previous declaration of %qD\", olddecl);\n+\t  warning (0, \"previous declaration of %q+D\", olddecl);\n \t}\n     }\n \n@@ -1558,7 +1554,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t    {\n \t      error (\"declaration of %qF throws different exceptions\",\n \t\t     newdecl);\n-\t      cp_error_at (\"than previous declaration %qF\", olddecl);\n+\t      error (\"than previous declaration %q+F\", olddecl);\n \t    }\n \t}\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n@@ -1798,8 +1794,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n       && DECL_VISIBILITY_SPECIFIED (newdecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n-      warning (OPT_Wattributes, \"%J%qD: visibility attribute ignored \"\n-\t       \"because it\", newdecl, newdecl);\n+      warning (OPT_Wattributes, \"%q+D: visibility attribute ignored \"\n+\t       \"because it\", newdecl);\n       warning (OPT_Wattributes, \"%Jconflicts with previous \"\n \t       \"declaration here\", olddecl);\n     }\n@@ -2151,11 +2147,9 @@ check_previous_goto_1 (tree decl,\n \t    }\n \n \t  if (problem > 1)\n-\t    cp_error_at (\"  crosses initialization of %q#D\",\n-\t\t\t new_decls);\n+\t    error (\"  crosses initialization of %q+#D\", new_decls);\n \t  else\n-\t    cp_pedwarn_at (\"  enters scope of non-POD %q#D\",\n-\t\t\t   new_decls);\n+\t    pedwarn (\"  enters scope of non-POD %q+#D\", new_decls);\n \t}\n \n       if (b == level)\n@@ -2253,7 +2247,7 @@ check_goto (tree decl)\n   if ((lab->in_try_scope || lab->in_catch_scope || lab->bad_decls)\n       && !identified)\n     {\n-      cp_pedwarn_at (\"jump to label %qD\", decl);\n+      pedwarn (\"jump to label %q+D\", decl);\n       pedwarn (\"  from here\");\n       identified = 1;\n     }\n@@ -2267,9 +2261,9 @@ check_goto (tree decl)\n \t/* Can't skip init of __exception_info.  */\n \terror (\"%J  enters catch block\", b);\n       else if (u > 1)\n-\tcp_error_at (\"  skips initialization of %q#D\", b);\n+\terror (\"  skips initialization of %q+#D\", b);\n       else\n-\tcp_pedwarn_at (\"  enters scope of non-POD %q#D\", b);\n+\tpedwarn (\"  enters scope of non-POD %q+#D\", b);\n     }\n \n   if (lab->in_try_scope)\n@@ -2677,7 +2671,7 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n \t  if (complain & tf_error)\n \t    {\n \t      error (\"template parameters do not match template\");\n-\t      cp_error_at (\"%qD declared here\", tmpl);\n+\t      error (\"%q+D declared here\", tmpl);\n \t    }\n \t  return error_mark_node;\n \t}\n@@ -3367,17 +3361,14 @@ fixup_anonymous_aggr (tree t)\n \t    if (CLASS_TYPE_P (type))\n \t      {\n \t\tif (TYPE_NEEDS_CONSTRUCTING (type))\n-\t\t  cp_error_at (\"member %q#D with constructor not allowed \"\n-\t\t\t       \"in anonymous aggregate\",\n-\t\t\t       field);\n+\t\t  error (\"member %q+#D with constructor not allowed \"\n+\t\t\t \"in anonymous aggregate\", field);\n \t\tif (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t\t  cp_error_at (\"member %q#D with destructor not allowed \"\n-\t\t\t       \"in anonymous aggregate\",\n-\t\t\t       field);\n+\t\t  error (\"member %q+#D with destructor not allowed \"\n+\t\t\t \"in anonymous aggregate\", field);\n \t\tif (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n-\t\t  cp_error_at (\"member %q#D with copy assignment operator \"\n-\t\t\t       \"not allowed in anonymous aggregate\",\n-\t\t\t       field);\n+\t\t  error (\"member %q+#D with copy assignment operator \"\n+\t\t\t \"not allowed in anonymous aggregate\", field);\n \t      }\n \t  }\n     }\n@@ -3503,10 +3494,9 @@ shadow_tag (cp_decl_specifier_seq *declspecs)\n \n   if (declspecs->attributes)\n     {\n-      cp_warning_at (\"attribute ignored in declaration of %q#T\", t);\n-      cp_warning_at (\"attribute for %q#T must follow the %qs keyword\",\n-\t\t     t,\n-\t\t     class_key_or_enum_as_string (t));\n+      warning (0, \"attribute ignored in declaration of %q+#T\", t);\n+      warning (0, \"attribute for %q+#T must follow the %qs keyword\",\n+\t       t, class_key_or_enum_as_string (t));\n \n     }\n \n@@ -3661,7 +3651,7 @@ start_decl (const cp_declarator *declarator,\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl)))\n-    warning (0, \"%Jinline function %qD given attribute noinline\", decl, decl);\n+    warning (0, \"inline function %q+D given attribute noinline\", decl);\n \n   if (context && COMPLETE_TYPE_P (complete_type (context)))\n     {\n@@ -4045,9 +4035,9 @@ maybe_commonize_var (tree decl)\n \t\t be merged.  */\n \t      TREE_PUBLIC (decl) = 0;\n \t      DECL_COMMON (decl) = 0;\n-\t      cp_warning_at (\"sorry: semantics of inline function static \"\n-\t\t\t     \"data %q#D are wrong (you'll wind up \"\n-\t\t\t     \"with multiple copies)\", decl);\n+\t      warning (0, \"sorry: semantics of inline function static \"\n+\t\t       \"data %q+#D are wrong (you'll wind up \"\n+\t\t       \"with multiple copies)\", decl);\n \t      warning (0, \"%J  you can work around this by removing \"\n \t\t       \"the initializer\",\n \t\t       decl);\n@@ -5446,13 +5436,13 @@ bad_specifiers (tree object,\n \t   \"%qD invalid in %s declaration\",\n \t   object, type);\n   if (friendp)\n-    cp_error_at (\"%qD declared as a friend\", object);\n+    error (\"%q+D declared as a friend\", object);\n   if (raises\n       && (TREE_CODE (object) == TYPE_DECL\n \t  || (!TYPE_PTRFN_P (TREE_TYPE (object))\n \t      && !TYPE_REFFN_P (TREE_TYPE (object))\n \t      && !TYPE_PTRMEMFUNC_P (TREE_TYPE (object)))))\n-    cp_error_at (\"%qD declared with an exception specification\", object);\n+    error (\"%q+D declared with an exception specification\", object);\n }\n \n /* CTYPE is class type, or null if non-class.\n@@ -5579,9 +5569,9 @@ grokfndecl (tree ctype,\n \t\t  pedwarn (\"non-local function %q#D uses anonymous type\",\n \t\t\t      decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    cp_pedwarn_at (\"%q#D does not refer to the unqualified \"\n-\t\t\t\t   \"type, so it is not used for linkage\",\n-\t\t\t\t   TYPE_NAME (t));\n+\t\t    pedwarn (\"%q+#D does not refer to the unqualified \"\n+\t\t\t     \"type, so it is not used for linkage\",\n+\t\t\t     TYPE_NAME (t));\n \t\t}\n \t    }\n \t  else\n@@ -5915,9 +5905,9 @@ grokvardecl (tree type,\n \t\t  warning (0, \"non-local variable %q#D uses anonymous type\",\n \t\t\t   decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    cp_warning_at (\"%q#D does not refer to the unqualified \"\n-\t\t\t\t   \"type, so it is not used for linkage\",\n-\t\t\t\t   TYPE_NAME (t));\n+\t\t    warning (0, \"%q+#D does not refer to the unqualified \"\n+\t\t\t     \"type, so it is not used for linkage\",\n+\t\t\t     TYPE_NAME (t));\n \t\t}\n \t    }\n \t  else\n@@ -9017,7 +9007,7 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \t   && tag_code != typename_type)\n     {\n       error (\"using typedef-name %qD after %qs\", decl, tag_name (tag_code));\n-      cp_error_at (\"%qD has a previous declaration here\", decl);\n+      error (\"%q+D has a previous declaration here\", decl);\n       return error_mark_node;\n     }\n   else if (TREE_CODE (type) != RECORD_TYPE\n@@ -9026,15 +9016,15 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \t   && tag_code != typename_type)\n     {\n       error (\"%qT referred to as %qs\", type, tag_name (tag_code));\n-      cp_error_at (\"%qT has a previous declaration here\", type);\n+      error (\"%q+T has a previous declaration here\", type);\n       return error_mark_node;\n     }\n   else if (TREE_CODE (type) != ENUMERAL_TYPE\n \t   && tag_code == enum_type\n \t   && tag_code != typename_type)\n     {\n       error (\"%qT referred to as enum\", type);\n-      cp_error_at (\"%qT has a previous declaration here\", type);\n+      error (\"%q+T has a previous declaration here\", type);\n       return error_mark_node;\n     }\n   else if (!allow_template_p\n@@ -9918,7 +9908,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   if (DECL_DECLARED_INLINE_P (decl1)\n       && lookup_attribute (\"noinline\", attrs))\n-    warning (0, \"%Jinline function %qD given attribute noinline\", decl1, decl1);\n+    warning (0, \"inline function %q+D given attribute noinline\", decl1);\n \n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl1))\n     /* This is a constructor, we must ensure that any default args"}, {"sha": "2abf30cadec8aa84ae82cd37aedf7edc678aaf76", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cgraph.h\"\n #include \"tree-inline.h\"\n #include \"c-pragma.h\"\n+#include \"intl.h\"\n \n extern cpp_reader *parse_in;\n \n@@ -690,12 +691,12 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t\tis_conv_op = false;\n \t    }\n \t  if (format)\n-\t    format = \"                %#D\";\n+\t    format = \"                %+#D\";\n \t  else if (fndecls)\n-\t    format = \"candidates are: %#D\";\n+\t    format = N_(\"candidates are: %+#D\");\n \t  else\n-\t    format = \"candidate is: %#D\";\n-\t  cp_error_at (format, fndecl);\n+\t    format = N_(\"candidate is: %+#D\");\n+\t  error (format, fndecl);\n \t}\n     }\n   else if (!COMPLETE_TYPE_P (ctype))\n@@ -1085,16 +1086,15 @@ build_anon_union_vars (tree type, tree object)\n \tcontinue;\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n-\t  cp_pedwarn_at (\"%q#D invalid; an anonymous union can only \"\n-\t\t\t \"have non-static data members\",\n-\t\t\t field);\n+\t  pedwarn (\"%q+#D invalid; an anonymous union can only \"\n+\t\t   \"have non-static data members\", field);\n \t  continue;\n \t}\n \n       if (TREE_PRIVATE (field))\n-\tcp_pedwarn_at (\"private member %q#D in anonymous union\", field);\n+\tpedwarn (\"private member %q+#D in anonymous union\", field);\n       else if (TREE_PROTECTED (field))\n-\tcp_pedwarn_at (\"protected member %q#D in anonymous union\", field);\n+\tpedwarn (\"protected member %q+#D in anonymous union\", field);\n \n       if (processing_template_decl)\n \tref = build_min_nt (COMPONENT_REF, object,\n@@ -3061,7 +3061,7 @@ cp_finish_file (void)\n \t     already verified there was a definition.  */\n \t  && !DECL_EXPLICIT_INSTANTIATION (decl))\n \t{\n-\t  cp_warning_at (\"inline function %qD used but never defined\", decl);\n+\t  warning (0, \"inline function %q+D used but never defined\", decl);\n \t  /* This symbol is effectively an \"extern\" declaration now.\n \t     This is not strictly necessary, but removes a duplicate\n \t     warning.  */\n@@ -3212,8 +3212,7 @@ check_default_args (tree x)\n \tsaw_def = true;\n       else if (saw_def)\n \t{\n-\t  cp_error_at (\"default argument missing for parameter %P of %q+#D\",\n-\t\t       i, x);\n+\t  error (\"default argument missing for parameter %P of %q+#D\", i, x);\n \t  break;\n \t}\n     }"}, {"sha": "6d80fc6b290461a620fc3c67aacf46744946d157", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 123, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -88,7 +88,6 @@ static void cp_print_error_function (diagnostic_context *, diagnostic_info *);\n \n static bool cp_printer (pretty_printer *, text_info *, const char *,\n \t\t\tint, bool, bool, bool);\n-static tree locate_error (const char *, va_list);\n static location_t location_of (tree);\n \n void\n@@ -1943,6 +1942,8 @@ lang_decl_name (tree decl, int v)\n   return pp_formatted_text (cxx_pp);\n }\n \n+/* Return the location of a tree passed to %+ formats.  */\n+\n static location_t\n location_of (tree t)\n {\n@@ -2311,125 +2312,3 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n #undef next_lang\n #undef next_int\n }\n-\n-/* These are temporary wrapper functions which handle the historic\n-   behavior of cp_*_at.  */\n-\n-static tree\n-locate_error (const char *gmsgid, va_list ap)\n-{\n-  tree here = 0, t;\n-  int plus = 0;\n-  const char *f;\n-\n-  for (f = gmsgid; *f; f++)\n-    {\n-      plus = 0;\n-      if (*f == '%')\n-\t{\n-\t  if (*++f == 'q')\n-\t    ++f;\t\t\t/* ignore quoting flag.  */\n-\n-\t  if (*f == '+')\n-\t    {\n-\t      ++f;\n-\t      plus = 1;\n-\t    }\n-\t  if (*f == '#')\n-\t    f++;\n-\n-\t  switch (*f)\n-\t    {\n-\t      /* Just ignore these possibilities.  */\n-\t    case '%':\t\t\t\t\t\tbreak;\n-\t    case 'P':\n-\t    case 'd':\t(void) va_arg (ap, int);\t\tbreak;\n-\t    case 's':\t(void) va_arg (ap, char *);\t\tbreak;\n-\t    case 'L':\t(void) va_arg (ap, enum languages);\tbreak;\n-\t    case 'C':\n-\t    case 'O':\n-\t    case 'Q':\t(void) va_arg (ap, enum tree_code);\tbreak;\n-\n-\t      /* These take a tree, which may be where the error is\n-\t\t located.  */\n-\t    case 'A':\n-\t    case 'D':\n-\t    case 'E':\n-\t    case 'F':\n-\t    case 'T':\n-\t    case 'V':\n-\t      t = va_arg (ap, tree);\n-\t      if (!here || plus)\n-\t\there = t;\n-\t      break;\n-\n-\t    default:\n-\t      errorcount = 0;  /* damn ICE suppression */\n-\t      internal_error (\"unexpected letter %qc in locate_error\\n\", *f);\n-\t    }\n-\t}\n-    }\n-\n-  if (here == 0)\n-    here = va_arg (ap, tree);\n-\n-  return here;\n-}\n-\n-\n-void\n-cp_error_at (const char *gmsgid, ...)\n-{\n-  tree here;\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, gmsgid);\n-  here = locate_error (gmsgid, ap);\n-  va_end (ap);\n-\n-  va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-\t\t       input_location, DK_ERROR);\n-  cp_diagnostic_starter (global_dc, &diagnostic);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-\t\t       location_of (here), DK_ERROR);\n-  report_diagnostic (&diagnostic);\n-  va_end (ap);\n-}\n-\n-void\n-cp_warning_at (const char *gmsgid, ...)\n-{\n-  tree here;\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, gmsgid);\n-  here = locate_error (gmsgid, ap);\n-  va_end (ap);\n-\n-  va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-\t\t       location_of (here), DK_WARNING);\n-  report_diagnostic (&diagnostic);\n-  va_end (ap);\n-}\n-\n-void\n-cp_pedwarn_at (const char *gmsgid, ...)\n-{\n-  tree here;\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, gmsgid);\n-  here = locate_error (gmsgid, ap);\n-  va_end (ap);\n-\n-  va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap,\n-\t\t       location_of (here), pedantic_error_kind());\n-  report_diagnostic (&diagnostic);\n-  va_end (ap);\n-}"}, {"sha": "4e1a2098221732fa7537a4cb828cd0d2b7bc2f1f", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -314,15 +314,15 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t\t{\n \t\t  error (\"%qT is not a member class template of %qT\",\n \t\t\t name, ctype);\n-\t\t  cp_error_at (\"%qD declared here\", decl);\n+\t\t  error (\"%q+D declared here\", decl);\n \t\t  return;\n \t\t}\n \t      if (!template_member_p && (TREE_CODE (decl) != TYPE_DECL\n \t\t\t\t\t || !CLASS_TYPE_P (TREE_TYPE (decl))))\n \t\t{\n \t\t  error (\"%qT is not a nested class of %qT\",\n \t\t\t name, ctype);\n-\t\t  cp_error_at (\"%qD declared here\", decl);\n+\t\t  error (\"%q+D declared here\", decl);\n \t\t  return;\n \t\t}\n "}, {"sha": "05491c44a2da8aa6e672f3df6730f778c02e396d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -522,13 +522,13 @@ sort_mem_initializers (tree t, tree mem_inits)\n       if (warn_reorder && !subobject_init)\n \t{\n \t  if (TREE_CODE (TREE_PURPOSE (next_subobject)) == FIELD_DECL)\n-\t    cp_warning_at (\"%qD will be initialized after\",\n-\t\t\t   TREE_PURPOSE (next_subobject));\n+\t    warning (0, \"%q+D will be initialized after\",\n+\t\t     TREE_PURPOSE (next_subobject));\n \t  else\n \t    warning (0, \"base %qT will be initialized after\",\n \t\t     TREE_PURPOSE (next_subobject));\n \t  if (TREE_CODE (subobject) == FIELD_DECL)\n-\t    cp_warning_at (\"  %q#D\", subobject);\n+\t    warning (0, \"  %q+#D\", subobject);\n \t  else\n \t    warning (0, \"  base %qT\", subobject);\n \t  warning (0, \"%J  when initialized here\", current_function_decl);"}, {"sha": "50a92ca2487f3036f39e8ee5b5c0fcdcf8418eb2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -505,7 +505,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n   else\n     {\n       error (\"declaration of %q#D\", decl);\n-      cp_error_at (\"conflicts with previous declaration %q#D\", bval);\n+      error (\"conflicts with previous declaration %q+#D\", bval);\n       ok = false;\n     }\n \n@@ -721,7 +721,7 @@ pushdecl (tree x)\n \t\t     [basic.start.main]\n \n \t\t     This function shall not be overloaded.  */\n-\t\t  cp_error_at (\"invalid redeclaration of %qD\", t);\n+\t\t  error (\"invalid redeclaration of %q+D\", t);\n \t\t  error (\"as %qD\", x);\n \t\t  /* We don't try to push this declaration since that\n \t\t     causes a crash.  */\n@@ -811,7 +811,7 @@ pushdecl (tree x)\n \t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n \t    {\n \t      pedwarn (\"type mismatch with previous external decl of %q#D\", x);\n-\t      cp_pedwarn_at (\"previous external decl of %q#D\", decl);\n+\t      pedwarn (\"previous external decl of %q+#D\", decl);\n \t    }\n \t}\n \n@@ -894,7 +894,7 @@ pushdecl (tree x)\n \t      else\n \t\t{\n \t\t  warning (0, \"extern declaration of %q#D doesn't match\", x);\n-\t\t  cp_warning_at (\"global declaration %q#D\", oldglobal);\n+\t\t  warning (0, \"global declaration %q+#D\", oldglobal);\n \t\t}\n \t    }\n \t  /* If we have a local external declaration,\n@@ -1092,9 +1092,9 @@ check_for_out_of_scope_variable (tree decl)\n       if (!DECL_ERROR_REPORTED (decl))\n \t{\n \t  warning (0, \"name lookup of %qD changed\", DECL_NAME (decl));\n-\t  cp_warning_at (\"  matches this %qD under ISO standard rules\",\n-\t\t\t shadowed);\n-\t  cp_warning_at (\"  matches this %qD under old rules\", decl);\n+\t  warning (0, \"  matches this %q+D under ISO standard rules\",\n+\t\t   shadowed);\n+\t  warning (0, \"  matches this %q+D under old rules\", decl);\n \t  DECL_ERROR_REPORTED (decl) = 1;\n \t}\n       return shadowed;\n@@ -1114,15 +1114,15 @@ check_for_out_of_scope_variable (tree decl)\n     {\n       error (\"name lookup of %qD changed for new ISO %<for%> scoping\",\n \t     DECL_NAME (decl));\n-      cp_error_at (\"  cannot use obsolete binding at %qD because \"\n-\t\t   \"it has a destructor\", decl);\n+      error (\"  cannot use obsolete binding at %q+D because \"\n+\t     \"it has a destructor\", decl);\n       return error_mark_node;\n     }\n   else\n     {\n       pedwarn (\"name lookup of %qD changed for new ISO %<for%> scoping\",\n \t       DECL_NAME (decl));\n-      cp_pedwarn_at (\"  using obsolete binding at %qD\", decl);\n+      pedwarn (\"  using obsolete binding at %q+D\", decl);\n     }\n \n   return decl;\n@@ -1895,7 +1895,7 @@ push_overloaded_decl (tree decl, int flags)\n \told = NULL_TREE;\n       else\n \t{\n-\t  cp_error_at (\"previous non-function declaration %q#D\", old);\n+\t  error (\"previous non-function declaration %q+#D\", old);\n \t  error (\"conflicts with function declaration %q#D\", decl);\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n \t}\n@@ -3386,9 +3386,9 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n \t      if (old->value != error_mark_node)\n \t\t{\n \t\t  error (\"use of %qD is ambiguous\", name);\n-\t\t  cp_error_at (\"  first declared as %q#D here\", old->value);\n+\t\t  error (\"  first declared as %q+#D here\", old->value);\n \t\t}\n-\t      cp_error_at (\"  also declared as %q#D here\", val);\n+\t      error (\"  also declared as %q+#D here\", val);\n \t    }\n \t  old->value = error_mark_node;\n \t}\n@@ -4165,8 +4165,8 @@ add_function (struct arg_lookup *k, tree fn)\n \t{\n \t  fn = f1; f1 = f2; f2 = fn;\n \t}\n-      cp_error_at (\"%qD is not a function,\", f1);\n-      cp_error_at (\"  conflict with %qD\", f2);\n+      error (\"%q+D is not a function,\", f1);\n+      error (\"  conflict with %q+D\", f2);\n       error (\"  in call to %qD\", k->name);\n       return true;\n     }"}, {"sha": "2d17cded7fad014a9bbf25c6cef7f469cf9084f3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -13058,7 +13058,7 @@ cp_parser_class_head (cp_parser* parser,\n   if (type != error_mark_node && COMPLETE_TYPE_P (type))\n     {\n       error (\"redefinition of %q#T\", type);\n-      cp_error_at (\"previous definition of %q#T\", type);\n+      error (\"previous definition of %q+#T\", type);\n       type = NULL_TREE;\n       goto done;\n     }"}, {"sha": "3b4c588ee302d4045b930ed70ee3d62856d9b8e5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -667,7 +667,7 @@ check_specialization_namespace (tree tmpl)\n   else\n     {\n       pedwarn (\"specialization of %qD in different namespace\", tmpl);\n-      cp_pedwarn_at (\"  from definition of %q#D\", tmpl);\n+      pedwarn (\"  from definition of %q+#D\", tmpl);\n       return false;\n     }\n }\n@@ -736,8 +736,8 @@ maybe_process_partial_specialization (tree type)\n \t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n \t    {\n \t      pedwarn (\"specializing %q#T in different namespace\", type);\n-\t      cp_pedwarn_at (\"  from definition of %q#D\",\n-\t\t\t     CLASSTYPE_TI_TEMPLATE (type));\n+\t      pedwarn (\"  from definition of %q+#D\",\n+\t\t       CLASSTYPE_TI_TEMPLATE (type));\n \t    }\n \n \t  /* Check for invalid specialization after instantiation:\n@@ -1284,7 +1284,7 @@ print_candidates (tree fns)\n       tree f;\n \n       for (f = TREE_VALUE (fn); f; f = OVL_NEXT (f))\n-\tcp_error_at (\"%s %+#D\", str, OVL_CURRENT (f));\n+\terror (\"%s %+#D\", str, OVL_CURRENT (f));\n       str = \"               \";\n     }\n }\n@@ -1533,17 +1533,16 @@ determine_specialization (tree template_id,\n \n   if (templates == NULL_TREE && candidates == NULL_TREE)\n     {\n-      cp_error_at (\"template-id %qD for %q+D does not match any template \"\n-\t\t   \"declaration\",\n-\t\t   template_id, decl);\n+      error (\"template-id %qD for %q+D does not match any template \"\n+\t     \"declaration\", template_id, decl);\n       return error_mark_node;\n     }\n   else if ((templates && TREE_CHAIN (templates))\n \t   || (candidates && TREE_CHAIN (candidates))\n \t   || (templates && candidates))\n     {\n-      cp_error_at (\"ambiguous template specialization %qD for %q+D\",\n-\t\t   template_id, decl);\n+      error (\"ambiguous template specialization %qD for %q+D\",\n+\t     template_id, decl);\n       chainon (candidates, templates);\n       print_candidates (candidates);\n       return error_mark_node;\n@@ -2197,8 +2196,8 @@ check_template_shadow (tree decl)\n       || TEMPLATE_PARMS_FOR_INLINE (current_template_parms))\n     return;\n \n-  cp_error_at (\"declaration of %q#D\", decl);\n-  cp_error_at (\" shadows template parm %q#D\", olddecl);\n+  error (\"declaration of %q+#D\", decl);\n+  error (\" shadows template parm %q+#D\", olddecl);\n }\n \n /* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,\n@@ -3219,7 +3218,7 @@ redeclare_class_template (tree type, tree parms)\n \n   if (TREE_VEC_LENGTH (parms) != TREE_VEC_LENGTH (tmpl_parms))\n     {\n-      cp_error_at (\"previous declaration %qD\", tmpl);\n+      error (\"previous declaration %q+D\", tmpl);\n       error (\"used %d template parameter(s) instead of %d\",\n \t     TREE_VEC_LENGTH (tmpl_parms),\n \t     TREE_VEC_LENGTH (parms));\n@@ -3239,7 +3238,7 @@ redeclare_class_template (tree type, tree parms)\n \t  || (TREE_CODE (tmpl_parm) != TYPE_DECL\n \t      && !same_type_p (TREE_TYPE (tmpl_parm), TREE_TYPE (parm))))\n \t{\n-\t  cp_error_at (\"template parameter %q#D\", tmpl_parm);\n+\t  error (\"template parameter %q+#D\", tmpl_parm);\n \t  error (\"redeclared here as %q#D\", parm);\n \t  return;\n \t}\n@@ -3960,7 +3959,7 @@ coerce_template_parms (tree parms,\n \t\t nargs, nparms);\n \n \t  if (in_decl)\n-\t    cp_error_at (\"provided for %qD\", in_decl);\n+\t    error (\"provided for %q+D\", in_decl);\n \t}\n \n       return error_mark_node;\n@@ -4347,7 +4346,7 @@ lookup_template_class (tree d1,\n \t{\n \t  error (\"non-template type %qT used as a template\", d1);\n \t  if (in_decl)\n-\t    cp_error_at (\"for template declaration %qD\", in_decl);\n+\t    error (\"for template declaration %q+D\", in_decl);\n \t}\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n@@ -5441,7 +5440,7 @@ instantiate_class_template (tree type)\n \t{\n \t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args))\n \t    {\n-\t      cp_error_at (\"%s %+#T\", str, TREE_TYPE (t));\n+\t      error (\"%s %+#T\", str, TREE_TYPE (t));\n \t      str = \"               \";\n \t    }\n \t}\n@@ -6547,7 +6546,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t\t\t\tcomplain, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (VOID_TYPE_P (type))\n-\t  cp_error_at (\"instantiation of %qD as type %qT\", r, type);\n+\t  error (\"instantiation of %q+D as type %qT\", r, type);\n       }\n       break;\n \n@@ -6723,7 +6722,7 @@ tsubst_arg_types (tree arg_types,\n \t{\n \t  error (\"invalid parameter type %qT\", type);\n \t  if (in_decl)\n-\t    cp_error_at (\"in declaration %qD\", in_decl);\n+\t    error (\"in declaration %q+D\", in_decl);\n \t}\n       return error_mark_node;\n     }\n@@ -11624,11 +11623,10 @@ instantiate_pending_templates (int retries)\n      to avoid infinite loop.  */\n   if (pending_templates && retries >= max_tinst_depth)\n     {\n-      cp_error_at (\"template instantiation depth exceeds maximum of %d\"\n-\t\t   \" (use -ftemplate-depth-NN to increase the maximum)\"\n-\t\t   \" instantiating %q+D, possibly from virtual table\"\n-\t\t   \" generation\",\n-\t\t   max_tinst_depth, TREE_VALUE (pending_templates));\n+      error (\"template instantiation depth exceeds maximum of %d\"\n+\t    \" instantiating %q+D, possibly from virtual table generation\"\n+\t    \" (use -ftemplate-depth-NN to increase the maximum)\",\n+\t    max_tinst_depth, TREE_VALUE (pending_templates));\n       return;\n     }\n "}, {"sha": "795e8c2e44f0dc2fdb0e992d0c3133bf2071bc31", "filename": "gcc/cp/search.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1839,9 +1839,9 @@ check_final_overrider (tree overrider, tree basefn)\n \t    fail = 2;\n \t  else\n \t    {\n-\t      cp_warning_at (\"deprecated covariant return type for %q#D\",\n+\t      warning (0, \"deprecated covariant return type for %q+#D\",\n \t\t\t     overrider);\n-\t      cp_warning_at (\"  overriding %q#D\", basefn);\n+\t      warning (0, \"  overriding %q+#D\", basefn);\n \t    }\n \t}\n       else\n@@ -1855,14 +1855,13 @@ check_final_overrider (tree overrider, tree basefn)\n     {\n       if (fail == 1)\n \t{\n-\t  cp_error_at (\"invalid covariant return type for %q#D\", overrider);\n-\t  cp_error_at (\"  overriding %q#D\", basefn);\n+\t  error (\"invalid covariant return type for %q+#D\", overrider);\n+\t  error (\"  overriding %q+#D\", basefn);\n \t}\n       else\n \t{\n-\t  cp_error_at (\"conflicting return type specified for %q#D\",\n-\t\t       overrider);\n-\t  cp_error_at (\"  overriding %q#D\", basefn);\n+\t  error (\"conflicting return type specified for %q+#D\", overrider);\n+\t  error (\"  overriding %q+#D\", basefn);\n \t}\n       DECL_INVALID_OVERRIDER_P (overrider) = 1;\n       return 0;\n@@ -1871,8 +1870,8 @@ check_final_overrider (tree overrider, tree basefn)\n   /* Check throw specifier is at least as strict.  */\n   if (!comp_except_specs (base_throw, over_throw, 0))\n     {\n-      cp_error_at (\"looser throw specifier for %q#F\", overrider);\n-      cp_error_at (\"  overriding %q#F\", basefn);\n+      error (\"looser throw specifier for %q+#F\", overrider);\n+      error (\"  overriding %q+#F\", basefn);\n       DECL_INVALID_OVERRIDER_P (overrider) = 1;\n       return 0;\n     }\n@@ -1965,8 +1964,8 @@ look_for_overrides_r (tree type, tree fndecl)\n \t{\n \t  /* A static member function cannot match an inherited\n \t     virtual member function.  */\n-\t  cp_error_at (\"%q#D cannot be declared\", fndecl);\n-\t  cp_error_at (\"  since %q#D declared in base class\", fn);\n+\t  error (\"%q+#D cannot be declared\", fndecl);\n+\t  error (\"  since %q+#D declared in base class\", fn);\n \t}\n       else\n \t{"}, {"sha": "3d99c5d7ff64a17f4ec5a450ab8b2d191e4f18ce", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1342,10 +1342,9 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n     {\n       if (current_function_decl\n \t  && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\tcp_error_at (\"invalid use of member %qD in static member function\",\n-\t\t     decl);\n+\terror (\"invalid use of member %q+D in static member function\", decl);\n       else\n-\tcp_error_at (\"invalid use of non-static data member %qD\", decl);\n+\terror (\"invalid use of non-static data member %q+D\", decl);\n       error (\"from this location\");\n \n       return error_mark_node;\n@@ -1384,7 +1383,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \n \t  if (!access_type)\n \t    {\n-\t      cp_error_at (\"object missing in reference to %qD\", decl);\n+\t      error (\"object missing in reference to %q+D\", decl);\n \t      error (\"from this location\");\n \t      return error_mark_node;\n \t    }\n@@ -2789,7 +2788,7 @@ finish_id_expression (tree id_expression,\n \t\t  error (TREE_CODE (decl) == VAR_DECL\n \t\t\t ? \"use of %<auto%> variable from containing function\"\n \t\t\t : \"use of parameter from containing function\");\n-\t\t  cp_error_at (\"  %q#D declared here\", decl);\n+\t\t  error (\"  %q+#D declared here\", decl);\n \t\t  return error_mark_node;\n \t\t}\n \t    }"}, {"sha": "c6989ee6832f4f1a4ea58c7f83a8ad10d6a70aae", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -2560,8 +2560,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      cp_error_at (\"too many arguments to %s %q+#D\", called_thing,\n-\t\t\t   fndecl);\n+\t      error (\"too many arguments to %s %q+#D\", called_thing, fndecl);\n \t      error (\"at this point in file\");\n \t    }\n \t  else\n@@ -2663,8 +2662,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      cp_error_at (\"too few arguments to %s %q+#D\",\n-\t\t\t   called_thing, fndecl);\n+\t      error (\"too few arguments to %s %q+#D\", called_thing, fndecl);\n \t      error (\"at this point in file\");\n \t    }\n \t  else\n@@ -6018,9 +6016,9 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n       if (fndecl)\n \t{\n \t  if (warningcount > savew)\n-\t    cp_warning_at (\"in passing argument %P of %q+D\", parmnum, fndecl);\n+\t    warning (0, \"in passing argument %P of %q+D\", parmnum, fndecl);\n \t  else if (errorcount > savee)\n-\t    cp_error_at (\"in passing argument %P of %q+D\", parmnum, fndecl);\n+\t    error (\"in passing argument %P of %q+D\", parmnum, fndecl);\n \t}\n       return rhs;\n     }\n@@ -6089,11 +6087,11 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \t   || TREE_PUBLIC (whats_returned)))\n     {\n       if (TREE_CODE (valtype) == REFERENCE_TYPE)\n-\tcp_warning_at (\"reference to local variable %qD returned\",\n-\t\t       whats_returned);\n+\twarning (0, \"reference to local variable %q+D returned\",\n+\t\t whats_returned);\n       else\n-\tcp_warning_at (\"address of local variable %qD returned\",\n-\t\t       whats_returned);\n+\twarning (0, \"address of local variable %q+D returned\",\n+\t\t whats_returned);\n       return;\n     }\n }"}, {"sha": "4244088501a6a971c69f17acf6557bb79778d15d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -214,7 +214,7 @@ complete_type_check_abstract (tree type)\n \n \t  /* Tweak input_location so that the diagnostic appears at the correct\n \t    location. Notice that this is only needed if the decl is an\n-\t    IDENTIFIER_NODE, otherwise cp_error_at.  */\n+\t    IDENTIFIER_NODE.  */\n \t  input_location = pat->locus;\n \t  abstract_virtuals_error (pat->decl, pat->type);\n \t  pat = pat->next;\n@@ -289,27 +289,24 @@ abstract_virtuals_error (tree decl, tree type)\n \treturn 0;\n \n       if (TREE_CODE (decl) == VAR_DECL)\n-\tcp_error_at (\"cannot declare variable %q+D to be of abstract \"\n-\t\t     \"type %qT\", decl, type);\n+\terror (\"cannot declare variable %q+D to be of abstract \"\n+\t       \"type %qT\", decl, type);\n       else if (TREE_CODE (decl) == PARM_DECL)\n-\tcp_error_at (\"cannot declare parameter %q+D to be of abstract \"\n-\t\t     \"type %qT\", decl, type);\n+\terror (\"cannot declare parameter %q+D to be of abstract type %qT\",\n+\t       decl, type);\n       else if (TREE_CODE (decl) == FIELD_DECL)\n-\tcp_error_at (\"cannot declare field %q+D to be of abstract \"\n-\t\t     \"type %qT\", decl, type);\n+\terror (\"cannot declare field %q+D to be of abstract type %qT\",\n+\t       decl, type);\n       else if (TREE_CODE (decl) == FUNCTION_DECL\n \t       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\tcp_error_at (\"invalid abstract return type for member function %q+#D\",\n-\t\t     decl);\n+\terror (\"invalid abstract return type for member function %q+#D\", decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcp_error_at (\"invalid abstract return type for function %q+#D\",\n-\t\t     decl);\n+\terror (\"invalid abstract return type for function %q+#D\", decl);\n       else if (TREE_CODE (decl) == IDENTIFIER_NODE)\n-\t/* Here we do not have location information, so use error instead\n-\t   of cp_error_at.  */\n+\t/* Here we do not have location information.  */\n \terror (\"invalid abstract type %qT for %qE\", type, decl);\n       else\n-\tcp_error_at (\"invalid abstract type for %q+D\", decl);\n+\terror (\"invalid abstract type for %q+D\", decl);\n     }\n   else\n     error (\"cannot allocate an object of abstract type %qT\", type);\n@@ -324,7 +321,7 @@ abstract_virtuals_error (tree decl, tree type)\n \t      \"within %qT:\", TYPE_MAIN_DECL (type), type);\n \n       for (ix = 0; VEC_iterate (tree, pure, ix, fn); ix++)\n-\tinform (\"%J\\t%#D\", fn, fn);\n+\tinform (\"\\t%+#D\", fn);\n       /* Now truncate the vector.  This leaves it non-null, so we know\n \t there are pure virtuals, but empty so we don't list them out\n \t again.  */\n@@ -348,23 +345,13 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n {\n   int decl = 0;\n   void (*p_msg) (const char *, ...) ATTRIBUTE_GCC_CXXDIAG(1,2);\n-  void (*p_msg_at) (const char *, ...) ATTRIBUTE_GCC_CXXDIAG(1,2);\n \n   if (diag_type == 1)\n-    {\n-      p_msg = warning0;\n-      p_msg_at = cp_warning_at;\n-    }\n+    p_msg = warning0;\n   else if (diag_type == 2)\n-    {\n-      p_msg = pedwarn;\n-      p_msg_at = cp_pedwarn_at;\n-    }\n+    p_msg = pedwarn;\n   else\n-    {\n-      p_msg = error;\n-      p_msg_at = cp_error_at;\n-    }\n+    p_msg = error;\n \n   /* Avoid duplicate error message.  */\n   if (TREE_CODE (type) == ERROR_MARK)\n@@ -374,7 +361,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n \t\t     || TREE_CODE (value) == PARM_DECL\n \t\t     || TREE_CODE (value) == FIELD_DECL))\n     {\n-      (*p_msg_at) (\"%qD has incomplete type\", value);\n+      p_msg (\"%q+D has incomplete type\", value);\n       decl = 1;\n     }\n  retry:\n@@ -386,15 +373,15 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       if (!decl)\n-\t(*p_msg) (\"invalid use of undefined type %q#T\", type);\n+\tp_msg (\"invalid use of undefined type %q#T\", type);\n       if (!TYPE_TEMPLATE_INFO (type))\n-\t(*p_msg_at) (\"forward declaration of %q#T\", type);\n+\tp_msg (\"forward declaration of %q+#T\", type);\n       else\n-\t(*p_msg_at) (\"declaration of %q#T\", type);\n+\tp_msg (\"declaration of %q+#T\", type);\n       break;\n \n     case VOID_TYPE:\n-      (*p_msg) (\"invalid use of %qT\", type);\n+      p_msg (\"invalid use of %qT\", type);\n       break;\n \n     case ARRAY_TYPE:\n@@ -403,28 +390,28 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n \t  type = TREE_TYPE (type);\n \t  goto retry;\n \t}\n-      (*p_msg) (\"invalid use of array with unspecified bounds\");\n+      p_msg (\"invalid use of array with unspecified bounds\");\n       break;\n \n     case OFFSET_TYPE:\n     bad_member:\n-      (*p_msg) (\"invalid use of member (did you forget the %<&%> ?)\");\n+      p_msg (\"invalid use of member (did you forget the %<&%> ?)\");\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      (*p_msg) (\"invalid use of template type parameter\");\n+      p_msg (\"invalid use of template type parameter\");\n       break;\n \n     case UNKNOWN_TYPE:\n       if (value && TREE_CODE (value) == COMPONENT_REF)\n \tgoto bad_member;\n       else if (value && TREE_CODE (value) == ADDR_EXPR)\n-\t(*p_msg) (\"address of overloaded function with no contextual \"\n-\t\t  \"type information\");\n+\tp_msg (\"address of overloaded function with no contextual \"\n+\t       \"type information\");\n       else if (value && TREE_CODE (value) == OVERLOAD)\n-\t(*p_msg) (\"overloaded function with no contextual type information\");\n+\tp_msg (\"overloaded function with no contextual type information\");\n       else\n-\t(*p_msg) (\"insufficient contextual information to determine type\");\n+\tp_msg (\"insufficient contextual information to determine type\");\n       break;\n \n     default:"}, {"sha": "92415cce178e53125e4d2be4e9ecd1e0195b7bcf", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -820,7 +820,7 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n       if (decl && size == -1\n \t  && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST)\n \t{\n-\t  error (\"%Jsize of variable %qD is too large\", decl, decl);\n+\t  error (\"size of variable %q+D is too large\", decl);\n \t  size = 1;\n \t}\n \n@@ -3451,9 +3451,9 @@ setjmp_vars_warning (tree block)\n \t  && DECL_RTL_SET_P (decl)\n \t  && REG_P (DECL_RTL (decl))\n \t  && regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-\twarning (0, \"%Jvariable %qD might be clobbered by %<longjmp%>\"\n+\twarning (0, \"variable %q+D might be clobbered by %<longjmp%>\"\n \t\t \" or %<vfork%>\",\n-\t\t decl, decl);\n+\t\t decl);\n     }\n \n   for (sub = BLOCK_SUBBLOCKS (block); sub; sub = TREE_CHAIN (sub))\n@@ -3472,8 +3472,8 @@ setjmp_args_warning (void)\n     if (DECL_RTL (decl) != 0\n \t&& REG_P (DECL_RTL (decl))\n \t&& regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-      warning (0, \"%Jargument %qD might be clobbered by %<longjmp%> or %<vfork%>\",\n-\t       decl, decl);\n+      warning (0, \"argument %q+D might be clobbered by %<longjmp%> or %<vfork%>\",\n+\t       decl);\n }\n \n \f\n@@ -4277,7 +4277,7 @@ do_warn_unused_parameter (tree fn)\n        decl; decl = TREE_CHAIN (decl))\n     if (!TREE_USED (decl) && TREE_CODE (decl) == PARM_DECL\n \t&& DECL_NAME (decl) && !DECL_ARTIFICIAL (decl))\n-      warning (0, \"%Junused parameter %qD\", decl, decl);\n+      warning (0, \"unused parameter %q+D\", decl);\n }\n \n static GTY(()) rtx initial_trampoline;"}, {"sha": "18edb05c43dcd193ecfb999e3e24629a039cb408", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1,3 +1,8 @@\n+2005-07-02  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* class.c, decl.c, expr.c: Use '+' flag instead of %J.  Use 'q'\n+\tflag for quoting.\n+\n 2005-07-01  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* parse.y (issue_warning_error_from_context): Call"}, {"sha": "eca8017898767b5bfb271c797812622f8e2b1902", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -2359,8 +2359,8 @@ layout_class_method (tree this_class, tree super_class,\n \t      && ! flag_indirect_dispatch\n \t      && !CLASS_FROM_SOURCE_P (this_class)\n \t      && ! DECL_ARTIFICIAL (super_method))\n-\t    error (\"%Jnon-static method '%D' overrides static method\",\n-                   method_decl, method_decl);\n+\t    error (\"non-static method %q+D overrides static method\",\n+                   method_decl);\n \t}\n       else if (this_class == object_type_node\n \t       && (METHOD_FINAL (method_decl)"}, {"sha": "ec8ff4e0f7ce9f0475aa606932cb291078ba0b0f", "filename": "gcc/java/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1310,7 +1310,7 @@ pushdecl (tree x)\n \t/* error_mark_node is 0 for a while during initialization!  */\n \t{\n \t  t = 0;\n-\t  error (\"%J'%D' used prior to declaration\", x, x);\n+\t  error (\"%q+D used prior to declaration\", x);\n \t}\n \n       /* If we're naming a hitherto-unnamed type, set its TYPE_NAME\n@@ -1682,12 +1682,12 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t  if (DECL_INITIAL (label) == 0)\n \t    {\n-\t      error (\"%Jlabel '%D' used but not defined\", label, label);\n+\t      error (\"label %q+D used but not defined\", label);\n \t      /* Avoid crashing later.  */\n \t      define_label (input_location, DECL_NAME (label));\n \t    }\n \t  else if (warn_unused[UNUSED_LABEL] && !TREE_USED (label))\n-\t    warning (0, \"%Jlabel '%D' defined but not used\", label, label);\n+\t    warning (0, \"label %q+D defined but not used\", label);\n \t  IDENTIFIER_LABEL_VALUE (DECL_NAME (label)) = 0;\n \n \t  /* Put the labels into the \"variables\" of the\n@@ -1815,8 +1815,8 @@ force_poplevels (int start_pc)\n   while (current_binding_level->start_pc > start_pc)\n     {\n       if (pedantic && current_binding_level->start_pc > start_pc)\n-\twarning (0, \"%JIn %D: overlapped variable and exception ranges at %d\",\n-                 current_function_decl, current_function_decl,\n+\twarning (0, \"In %+D: overlapped variable and exception ranges at %d\",\n+                 current_function_decl,\n \t\t current_binding_level->start_pc);\n       poplevel (1, 0, 0);\n     }\n@@ -1887,8 +1887,8 @@ give_name_to_locals (JCF *jcf)\n \t  tree decl = build_decl (VAR_DECL, name, type);\n \t  if (end_pc > DECL_CODE_LENGTH (current_function_decl))\n \t    {\n-\t      warning (0, \"%Jbad PC range for debug info for local '%D'\",\n-                       decl, decl);\n+\t      warning (0, \"bad PC range for debug info for local %q+D\",\n+                       decl);\n \t      end_pc = DECL_CODE_LENGTH (current_function_decl);\n \t    }\n "}, {"sha": "f3f4c84fdb3cf55d0fdaec351cbac92db3c13ce3", "filename": "gcc/java/expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -2730,22 +2730,22 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n       if (FIELD_FINAL (field_decl))\n \t{\n \t  if (DECL_CONTEXT (field_decl) != current_class)\n-            error (\"%Jassignment to final field '%D' not in field's class\",\n-                   field_decl, field_decl);\n+            error (\"assignment to final field %q+D not in field's class\",\n+                   field_decl);\n \t  else if (FIELD_STATIC (field_decl))\n \t    {\n \t      if (!DECL_CLINIT_P (current_function_decl))\n-\t\twarning (0, \"%Jassignment to final static field %qD not in \"\n+\t\twarning (0, \"assignment to final static field %q+D not in \"\n                          \"class initializer\",\n-                         field_decl, field_decl);\n+                         field_decl);\n \t    }\n \t  else\n \t    {\n \t      tree cfndecl_name = DECL_NAME (current_function_decl);\n \t      if (! DECL_CONSTRUCTOR_P (current_function_decl)\n \t\t  && !ID_FINIT_P (cfndecl_name))\n-                warning (0, \"%Jassignment to final field '%D' not in constructor\",\n-\t\t\t field_decl, field_decl);\n+                warning (0, \"assignment to final field %q+D not in constructor\",\n+\t\t\t field_decl);\n \t    }\n \t}\n       java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (field_ref),"}, {"sha": "18feb8d773cfbe6af927a7c814df078930c57217", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1,3 +1,8 @@\n+2005-07-02  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* objc-act.c: Use '+' flag instead of %J.  Use 'q' flag for\n+\tquoting.\n+\n 2005-06-30  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc-act.c (objc_build_volatilized_type): New function."}, {"sha": "9bd08842791c231e5b33d2fa0a34f7aecfca895d", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -2922,8 +2922,8 @@ objc_declare_class (tree ident_list)\n \t\t{\n \t\t  error (\"%qs redeclared as different kind of symbol\",\n \t\t\t IDENTIFIER_POINTER (ident));\n-\t\t  error (\"%Jprevious declaration of '%D'\",\n-\t\t\t record, record);\n+\t\t  error (\"previous declaration of %q+D\",\n+\t\t\t record);\n \t\t}\n \t    }\n \n@@ -4317,8 +4317,8 @@ encode_method_prototype (tree method_decl)\n       /* If a type size is not known, bail out.  */\n       if (sz < 0)\n \t{\n-\t  error (\"%Jtype '%D' does not have a known size\",\n-\t\t type, type);\n+\t  error (\"type %q+D does not have a known size\",\n+\t\t type);\n \t  /* Pretend that the encoding succeeded; the compilation will\n \t     fail nevertheless.  */\n \t  goto finish_encoding;\n@@ -7493,8 +7493,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n     {\n       error (\"%qs redeclared as different kind of symbol\",\n \t     IDENTIFIER_POINTER (class_name));\n-      error (\"%Jprevious declaration of '%D'\",\n-\t     decl, decl);\n+      error (\"previous declaration of %q+D\",\n+\t     decl);\n     }\n \n   if (code == CLASS_IMPLEMENTATION_TYPE)"}, {"sha": "a2d55a8a1eb1362328816818503b3eb3290d05cc", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -451,10 +451,10 @@ layout_decl (tree decl, unsigned int known_align)\n \t  int size_as_int = TREE_INT_CST_LOW (size);\n \n \t  if (compare_tree_int (size, size_as_int) == 0)\n-\t    warning (0, \"%Jsize of %qD is %d bytes\", decl, decl, size_as_int);\n+\t    warning (0, \"size of %q+D is %d bytes\", decl, size_as_int);\n \t  else\n-\t    warning (0, \"%Jsize of %qD is larger than %d bytes\",\n-                     decl, decl, larger_than_size);\n+\t    warning (0, \"size of %q+D is larger than %d bytes\",\n+                     decl, larger_than_size);\n \t}\n     }\n \n@@ -851,11 +851,11 @@ place_field (record_layout_info rli, tree field)\n \t  if (TYPE_ALIGN (type) > desired_align)\n \t    {\n \t      if (STRICT_ALIGNMENT)\n-\t\twarning (OPT_Wattributes, \"%Jpacked attribute causes \"\n-                         \"inefficient alignment for %qD\", field, field);\n+\t\twarning (OPT_Wattributes, \"packed attribute causes \"\n+                         \"inefficient alignment for %q+D\", field);\n \t      else\n-\t\twarning (OPT_Wattributes, \"%Jpacked attribute is \"\n-\t\t\t \"unnecessary for %qD\", field, field);\n+\t\twarning (OPT_Wattributes, \"packed attribute is \"\n+\t\t\t \"unnecessary for %q+D\", field);\n \t    }\n \t}\n       else\n@@ -869,7 +869,7 @@ place_field (record_layout_info rli, tree field)\n       /* No, we need to skip space before this field.\n \t Bump the cumulative size to multiple of field alignment.  */\n \n-      warning (OPT_Wpadded, \"%Jpadding struct to align %qD\", field, field);\n+      warning (OPT_Wpadded, \"padding struct to align %q+D\", field);\n \n       /* If the alignment is still within offset_align, just align\n \t the bit position.  */"}, {"sha": "65caac9e4e16e09bdaaa43ee3310862c504fbae2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1,3 +1,7 @@\n+2005-07-02  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/format/gcc_diag-1.c: Update.\n+\n 2005-07-01  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/22269"}, {"sha": "e7340063df08ecfe449e864cccaa83aed7d4c7b4", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-1.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -40,6 +40,9 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   diag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n   cdiag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n   cxxdiag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n+  diag (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n+  cdiag (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n+  cxxdiag (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n   diag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n   cdiag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n   cxxdiag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n@@ -65,6 +68,8 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   cxxdiag (\"%J\", t1);\n \n   cdiag (\"%D%F%T\", t1, t1, t1);\n+  cdiag (\"%+D%+F%+T\", t1, t1, t1);\n+  cdiag (\"%q+D%q+F%q+T\", t1, t1, t1);\n   cdiag (\"%D%D%D%D\", t1, t2, *t3, t4[5]);\n   cxxdiag (\"%A%D%E%F%T%V\", t1, t1, t1, t1, t1, t1);\n   cxxdiag (\"%D%D%D%D\", t1, t2, *t3, t4[5]);\n@@ -107,7 +112,7 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   diag (\"%D\", t1); /* { dg-warning \"format\" \"bogus tree\" } */\n   cdiag (\"%A\", t1); /* { dg-warning \"format\" \"bogus tree\" } */\n   cdiag (\"%#D\", t1); /* { dg-warning \"format\" \"bogus modifier\" } */\n-  cdiag (\"%+D\", t1); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cdiag (\"%+D\", t1);\n   cxxdiag (\"%C\"); /* { dg-warning \"format\" \"missing arg\" } */\n   cxxdiag (\"%C\", l); /* { dg-warning \"format\" \"wrong arg\" } */\n   cxxdiag (\"%C\", i, i); /* { dg-warning \"format\" \"extra arg\" } */"}, {"sha": "0b5278d710cf361d22f6ffbdb6fb7d44373f3c0d", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -823,10 +823,10 @@ check_global_declarations (tree *vec, int len)\n \t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n \t{\n \t  if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t    pedwarn (\"%J%qF used but never defined\", decl, decl);\n+\t    pedwarn (\"%q+F used but never defined\", decl);\n \t  else\n-\t    warning (0, \"%J%qF declared %<static%> but never defined\",\n-\t\t     decl, decl);\n+\t    warning (0, \"%q+F declared %<static%> but never defined\",\n+\t\t     decl);\n \t  /* This symbol is effectively an \"extern\" declaration now.  */\n \t  TREE_PUBLIC (decl) = 1;\n \t  assemble_external (decl);\n@@ -851,7 +851,7 @@ check_global_declarations (tree *vec, int len)\n \t  && ! (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n \t  /* Otherwise, ask the language.  */\n \t  && lang_hooks.decls.warn_unused_global (decl))\n-\twarning (0, \"%J%qD defined but not used\", decl, decl);\n+\twarning (0, \"%q+D defined but not used\", decl);\n \n       /* Avoid confusing the debug information machinery when there are\n \t errors.  */\n@@ -1356,12 +1356,12 @@ default_pch_valid_p (const void *data_p, size_t len)\n /* Default tree printer.   Handles declarations only.  */\n static bool\n default_tree_printer (pretty_printer * pp, text_info *text, const char *spec,\n-\t\t      int precision, bool wide, bool plus, bool hash)\n+\t\t      int precision, bool wide, bool set_locus, bool hash)\n {\n   tree t;\n \n   /* FUTURE: %+x should set the locus.  */\n-  if (precision != 0 || wide || plus || hash)\n+  if (precision != 0 || wide || hash)\n     return false;\n \n   switch (*spec)\n@@ -1381,6 +1381,9 @@ default_tree_printer (pretty_printer * pp, text_info *text, const char *spec,\n       return false;\n     }\n \n+  if (set_locus && text->locus)\n+    *text->locus = DECL_SOURCE_LOCATION (t);\n+\n   if (DECL_P (t))\n     {\n       const char *n = DECL_NAME (t)"}, {"sha": "fcaf2a60d4c233b93fd6b3639e088bc42a53b73d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -1321,7 +1321,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t  && !lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \t{\n \t  inline_forbidden_reason\n-\t    = G_(\"%Jfunction %qF can never be inlined because it uses \"\n+\t    = G_(\"function %q+F can never be inlined because it uses \"\n \t\t \"alloca (override using the always_inline attribute)\");\n \t  return node;\n \t}\n@@ -1333,7 +1333,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n       if (setjmp_call_p (t))\n \t{\n \t  inline_forbidden_reason\n-\t    = G_(\"%Jfunction %qF can never be inlined because it uses setjmp\");\n+\t    = G_(\"function %q+F can never be inlined because it uses setjmp\");\n \t  return node;\n \t}\n \n@@ -1347,7 +1347,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t  case BUILT_IN_NEXT_ARG:\n \t  case BUILT_IN_VA_END:\n \t    inline_forbidden_reason\n-\t      = G_(\"%Jfunction %qF can never be inlined because it \"\n+\t      = G_(\"function %q+F can never be inlined because it \"\n \t\t   \"uses variable argument lists\");\n \t    return node;\n \n@@ -1358,14 +1358,14 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t       function calling __builtin_longjmp to be inlined into the\n \t       function calling __builtin_setjmp, Things will Go Awry.  */\n \t    inline_forbidden_reason\n-\t      = G_(\"%Jfunction %qF can never be inlined because \"\n+\t      = G_(\"function %q+F can never be inlined because \"\n \t\t   \"it uses setjmp-longjmp exception handling\");\n \t    return node;\n \n \t  case BUILT_IN_NONLOCAL_GOTO:\n \t    /* Similarly.  */\n \t    inline_forbidden_reason\n-\t      = G_(\"%Jfunction %qF can never be inlined because \"\n+\t      = G_(\"function %q+F can never be inlined because \"\n \t\t   \"it uses non-local goto\");\n \t    return node;\n \n@@ -1376,7 +1376,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t       been inlined into.  Similarly __builtin_return would\n \t       return from the function the inline has been inlined into.  */\n \t    inline_forbidden_reason\n-\t      = G_(\"%Jfunction %qF can never be inlined because \"\n+\t      = G_(\"function %q+F can never be inlined because \"\n \t\t   \"it uses __builtin_return or __builtin_apply_args\");\n \t    return node;\n \n@@ -1395,7 +1395,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n       if (TREE_CODE (t) != LABEL_DECL)\n \t{\n \t  inline_forbidden_reason\n-\t    = G_(\"%Jfunction %qF can never be inlined \"\n+\t    = G_(\"function %q+F can never be inlined \"\n \t\t \"because it contains a computed goto\");\n \t  return node;\n \t}\n@@ -1409,7 +1409,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t     because we cannot remap the destination label used in the\n \t     function that is performing the non-local goto.  */\n \t  inline_forbidden_reason\n-\t    = G_(\"%Jfunction %qF can never be inlined \"\n+\t    = G_(\"function %q+F can never be inlined \"\n \t\t \"because it receives a non-local goto\");\n \t  return node;\n \t}\n@@ -1434,7 +1434,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \tif (variably_modified_type_p (TREE_TYPE (t), NULL))\n \t  {\n \t    inline_forbidden_reason\n-\t      = G_(\"%Jfunction %qF can never be inlined \"\n+\t      = G_(\"function %q+F can never be inlined \"\n \t\t   \"because it uses variable sized variables\");\n \t    return node;\n \t  }\n@@ -1529,9 +1529,9 @@ inlinable_function_p (tree fn)\n \t\t\t && !DECL_IN_SYSTEM_HEADER (fn));\n \n       if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n-\tsorry (inline_forbidden_reason, fn, fn);\n+\tsorry (inline_forbidden_reason, fn);\n       else if (do_warning)\n-\twarning (0, inline_forbidden_reason, fn, fn);\n+\twarning (0, inline_forbidden_reason, fn);\n \n       inlinable = false;\n     }\n@@ -1971,7 +1971,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n     {\n       if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \t{\n-\t  sorry (\"%Jinlining failed in call to %qF: %s\", fn, fn, reason);\n+\t  sorry (\"inlining failed in call to %q+F: %s\", fn, reason);\n \t  sorry (\"called from here\");\n \t}\n       else if (warn_inline && DECL_DECLARED_INLINE_P (fn)\n@@ -1981,8 +1981,8 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \t       /* Avoid warnings during early inline pass. */\n \t       && (!flag_unit_at_a_time || cgraph_global_info_ready))\n \t{\n-\t  warning (OPT_Winline, \"%Jinlining failed in call to %qF: %s\",\n-\t\t   fn, fn, reason);\n+\t  warning (OPT_Winline, \"inlining failed in call to %q+F: %s\",\n+\t\t   fn, reason);\n \t  warning (OPT_Winline, \"called from here\");\n \t}\n       goto egress;"}, {"sha": "b8a50c7596c771994faacd4f4d1e02807f725a34", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -970,11 +970,11 @@ tree_rest_of_compilation (tree fndecl)\n \t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));\n \n \t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n-\t    warning (0, \"%Jsize of return value of %qD is %u bytes\",\n-                     fndecl, fndecl, size_as_int);\n+\t    warning (0, \"size of return value of %q+D is %u bytes\",\n+                     fndecl, size_as_int);\n \t  else\n-\t    warning (0, \"%Jsize of return value of %qD is larger than %wd bytes\",\n-                     fndecl, fndecl, larger_than_size);\n+\t    warning (0, \"size of return value of %q+D is larger than %wd bytes\",\n+                     fndecl, larger_than_size);\n \t}\n     }\n "}, {"sha": "012bb6bdf013a5358e24b640699948f7b079a926", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -3368,16 +3368,16 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n       if (TREE_CODE (node) == FUNCTION_DECL  && DECL_INITIAL (node)\n           && !DECL_DECLARED_INLINE_P (node))\n \t{\n-\t  error (\"%Jfunction %qD definition is marked dllimport.\", node, node);\n+\t  error (\"function %q+D definition is marked dllimport.\", node);\n \t  *no_add_attrs = true;\n \t}\n \n       else if (TREE_CODE (node) == VAR_DECL)\n \t{\n \t  if (DECL_INITIAL (node))\n \t    {\n-\t      error (\"%Jvariable %qD definition is marked dllimport.\",\n-\t\t     node, node);\n+\t      error (\"variable %q+D definition is marked dllimport.\",\n+\t\t     node);\n \t      *no_add_attrs = true;\n \t    }\n \n@@ -3396,8 +3396,8 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n       && (TREE_CODE (node) == VAR_DECL\n \t  || TREE_CODE (node) == FUNCTION_DECL))\n     {\n-      error (\"%Jexternal linkage required for symbol %qD because of \"\n-\t     \"%qs attribute.\", node, node, IDENTIFIER_POINTER (name));\n+      error (\"external linkage required for symbol %q+D because of \"\n+\t     \"%qs attribute.\", node, IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n "}, {"sha": "2a11dd2ebb150d723d0544d284e7e1f669e5ea55", "filename": "gcc/varasm.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee158440e16ef7272d823b9bd5e6d414968fd8a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=dee158440e16ef7272d823b9bd5e6d414968fd8a", "patch": "@@ -464,7 +464,7 @@ named_section (tree decl, const char *name, int reloc)\n     {\n       flags = get_named_section_flags (name);\n       if ((flags & SECTION_OVERRIDE) == 0)\n-\terror (\"%J%D causes a section type conflict\", decl, decl);\n+\terror (\"%+D causes a section type conflict\", decl);\n     }\n \n   named_section_real (name, flags, decl);\n@@ -925,15 +925,15 @@ make_decl_rtl (tree decl)\n       reg_number = decode_reg_name (name);\n       /* First detect errors in declaring global registers.  */\n       if (reg_number == -1)\n-\terror (\"%Jregister name not specified for %qD\", decl, decl);\n+\terror (\"register name not specified for %q+D\", decl);\n       else if (reg_number < 0)\n-\terror (\"%Jinvalid register name for %qD\", decl, decl);\n+\terror (\"invalid register name for %q+D\", decl);\n       else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n-\terror (\"%Jdata type of %qD isn%'t suitable for a register\",\n-\t       decl, decl);\n+\terror (\"data type of %q+D isn%'t suitable for a register\",\n+\t       decl);\n       else if (! HARD_REGNO_MODE_OK (reg_number, TYPE_MODE (TREE_TYPE (decl))))\n-\terror (\"%Jregister specified for %qD isn%'t suitable for data type\",\n-               decl, decl);\n+\terror (\"register specified for %q+D isn%'t suitable for data type\",\n+               decl);\n       /* Now handle properly declared static register variables.  */\n       else\n \t{\n@@ -983,7 +983,7 @@ make_decl_rtl (tree decl)\n       {\n \treg_number = decode_reg_name (name);\n \tif (reg_number >= 0 || reg_number == -3)\n-\t  error (\"%Jregister name given for non-register variable %qD\", decl, decl);\n+\t  error (\"register name given for non-register variable %q+D\", decl);\n       }\n #endif\n   }\n@@ -1629,7 +1629,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n   if (!dont_output_data && DECL_SIZE (decl) == 0)\n     {\n-      error (\"%Jstorage size of %qD isn%'t known\", decl, decl);\n+      error (\"storage size of %q+D isn%'t known\", decl);\n       TREE_ASM_WRITTEN (decl) = 1;\n       return;\n     }\n@@ -1657,7 +1657,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   if (! dont_output_data\n       && ! host_integerp (DECL_SIZE_UNIT (decl), 1))\n     {\n-      error (\"%Jsize of variable %qD is too large\", decl, decl);\n+      error (\"size of variable %q+D is too large\", decl);\n       return;\n     }\n \n@@ -1680,8 +1680,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n      In particular, a.out format supports a maximum alignment of 4.  */\n   if (align > MAX_OFILE_ALIGNMENT)\n     {\n-      warning (0, \"%Jalignment of %qD is greater than maximum object \"\n-               \"file alignment.  Using %d\", decl, decl,\n+      warning (0, \"alignment of %q+D is greater than maximum object \"\n+               \"file alignment.  Using %d\", decl,\n \t       MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n       align = MAX_OFILE_ALIGNMENT;\n     }\n@@ -1744,8 +1744,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n #if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_DECL_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n       if ((unsigned HOST_WIDE_INT) DECL_ALIGN_UNIT (decl) > rounded)\n-\twarning (0, \"%Jrequested alignment for %qD is greater than \"\n-                 \"implemented alignment of %d\", decl, decl, rounded);\n+\twarning (0, \"requested alignment for %q+D is greater than \"\n+                 \"implemented alignment of %d\", decl, rounded);\n #endif\n \n       /* If the target cannot output uninitialized but not common global data\n@@ -4335,16 +4335,16 @@ merge_weak (tree newdecl, tree olddecl)\n \t declare_weak because the NEWDECL and OLDDECL was not yet\n \t been merged; therefore, TREE_ASM_WRITTEN was not set.  */\n       if (TREE_ASM_WRITTEN (olddecl))\n-\terror (\"%Jweak declaration of %qD must precede definition\",\n-\t       newdecl, newdecl);\n+\terror (\"weak declaration of %q+D must precede definition\",\n+\t       newdecl);\n \n       /* If we've already generated rtl referencing OLDDECL, we may\n \t have done so in a way that will not function properly with\n \t a weak symbol.  */\n       else if (TREE_USED (olddecl)\n \t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (olddecl)))\n-\twarning (0, \"%Jweak declaration of %qD after first use results \"\n-                 \"in unspecified behavior\", newdecl, newdecl);\n+\twarning (0, \"weak declaration of %q+D after first use results \"\n+                 \"in unspecified behavior\", newdecl);\n \n       if (SUPPORTS_WEAK)\n \t{\n@@ -4377,16 +4377,16 @@ void\n declare_weak (tree decl)\n {\n   if (! TREE_PUBLIC (decl))\n-    error (\"%Jweak declaration of %qD must be public\", decl, decl);\n+    error (\"weak declaration of %q+D must be public\", decl);\n   else if (TREE_CODE (decl) == FUNCTION_DECL && TREE_ASM_WRITTEN (decl))\n-    error (\"%Jweak declaration of %qD must precede definition\", decl, decl);\n+    error (\"weak declaration of %q+D must precede definition\", decl);\n   else if (SUPPORTS_WEAK)\n     {\n       if (! DECL_WEAK (decl))\n \tweak_decls = tree_cons (NULL, decl, weak_decls);\n     }\n   else\n-    warning (0, \"%Jweak declaration of %qD not supported\", decl, decl);\n+    warning (0, \"weak declaration of %q+D not supported\", decl);\n \n   mark_weak (decl);\n }\n@@ -4583,11 +4583,11 @@ finish_aliases_1 (void)\n \n       target_decl = find_decl_and_mark_needed (p->decl, p->target);\n       if (target_decl == NULL)\n-\terror (\"%J%qD aliased to undefined symbol %qE\",\n-\t       p->decl, p->decl, p->target);\n+\terror (\"%q+D aliased to undefined symbol %qE\",\n+\t       p->decl, p->target);\n       else if (DECL_EXTERNAL (target_decl))\n-\terror (\"%J%qD aliased to external symbol %qE\",\n-\t       p->decl, p->decl, p->target);\n+\terror (\"%q+D aliased to external symbol %qE\",\n+\t       p->decl, p->target);\n     }\n }\n "}]}