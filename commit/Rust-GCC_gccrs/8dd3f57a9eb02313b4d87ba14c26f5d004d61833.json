{"sha": "8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRkM2Y1N2E5ZWIwMjMxM2I0ZDg3YmExNGMyNmY1ZDAwNGQ2MTgzMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-13T20:49:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-13T20:49:57Z"}, "message": "Fix incorrect commit on previous change.\n\nFrom-SVN: r28706", "tree": {"sha": "40e5fde4f3314197c25bf2c6b3c470f46d090da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40e5fde4f3314197c25bf2c6b3c470f46d090da0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd3f57a9eb02313b4d87ba14c26f5d004d61833/comments", "author": null, "committer": null, "parents": [{"sha": "0a818f84ce73107a93940532da63c5f1738818e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a818f84ce73107a93940532da63c5f1738818e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a818f84ce73107a93940532da63c5f1738818e3"}], "stats": {"total": 107, "additions": 46, "deletions": 61}, "files": [{"sha": "37829332b358acdda82a9eb919c20f5cd4a90b17", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd3f57a9eb02313b4d87ba14c26f5d004d61833/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd3f57a9eb02313b4d87ba14c26f5d004d61833/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "patch": "@@ -6,6 +6,11 @@\n \ttree.c (init_cplus_unsave): New.\n \t(cplus_unsave_expr_now): New.\n \n+1999-08-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* pt.c (tsubst): Back out 1999-08-06 patch.  Use fold and\n+\tdecl_constant_value to simplify array bounds.\n+\n 1999-08-11  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* lang-options.h: Add -fms-extensions."}, {"sha": "6e491e10aec8e8edc58dff7257af75bb494d24be", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 41, "deletions": 61, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd3f57a9eb02313b4d87ba14c26f5d004d61833/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd3f57a9eb02313b4d87ba14c26f5d004d61833/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "patch": "@@ -2216,12 +2216,6 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n      in the template-parameter-list of the definition of a member of a\n      class template.  */\n \n-  if (TREE_CODE (DECL_REAL_CONTEXT (decl)) == FUNCTION_DECL)\n-    /* You can't have a function template declaration in a local\n-       scope, nor you can you define a member of a class template in a\n-       local scope.  */\n-    return;\n-\n   if (current_class_type\n       && !TYPE_BEING_DEFINED (current_class_type)\n       && DECL_LANG_SPECIFIC (decl)\n@@ -5063,22 +5057,9 @@ instantiate_class_template (type)\n \t}\n     }\n \n-  /* Create the typedef that indicates provides a way of referencing a\n-     class name within the scope of that class.  */\n-  build_self_reference ();\n-\n   /* Don't replace enum constants here.  */\n   for (t = TYPE_FIELDS (pattern); t; t = TREE_CHAIN (t))\n-    /* If this is the implicit self-reference typedef, skip it, as we\n-       have handled it above.  Note that the usual tsubst machinery\n-       doesn't work here, since the resulting declaration must have a\n-       different name than the one it was given originally.  */\n-    if (TREE_CODE (t) == TYPE_DECL \n-\t&& TREE_TYPE (t) == pattern\n-\t&& DECL_NAME (t) == constructor_name (t)\n-\t&& DECL_ARTIFICIAL (t))\n-      continue;\n-    else if (TREE_CODE (t) != CONST_DECL)\n+    if (TREE_CODE (t) != CONST_DECL)\n       {\n \ttree r;\n \n@@ -5897,24 +5878,18 @@ tsubst_decl (t, args, type, in_decl)\n       break;\n \n     case VAR_DECL:\n-    case TYPE_DECL:\n       {\n \ttree argvec;\n \ttree gen_tmpl;\n \ttree spec;\n \ttree tmpl;\n-\ttree ctx;\n-\n-\tif (!DECL_LANG_SPECIFIC (t) || !DECL_TEMPLATE_INFO (t))\n-\t  return t;\n-\n-\tif (TYPE_P (DECL_CONTEXT (t)))\n-\t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n-\t\t\t\t  /*complain=*/1,\n-\t\t\t\t  in_decl, /*entering_scope=*/1);\n-\telse\n-\t  /* Subsequent calls to pushdecl will fill this in.  */\n-\t  ctx = NULL_TREE;\n+\ttree ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n+\t\t\t\t     /*complain=*/1,\n+\t\t\t\t     in_decl, /*entering_scope=*/1);\n+\t\n+\t/* Nobody should be tsubst'ing into non-template variables.  */\n+\tmy_friendly_assert (DECL_LANG_SPECIFIC (t) \n+\t\t\t    && DECL_TEMPLATE_INFO (t) != NULL_TREE, 0);\n \n \t/* Check to see if we already have this specialization.  */\n \ttmpl = DECL_TI_TEMPLATE (t);\n@@ -5928,13 +5903,7 @@ tsubst_decl (t, args, type, in_decl)\n \t    break;\n \t  }\n \n-\t/* This declaration is going to have to be around for a while,\n-\t   so me make sure it is on a saveable obstack.  */\n-\tpush_obstacks_nochange ();\n-\tsaveable_allocation ();\n \tr = copy_node (t);\n-\tpop_obstacks ();\n-\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n \tDECL_CONTEXT (r) = ctx;\n@@ -5947,16 +5916,10 @@ tsubst_decl (t, args, type, in_decl)\n \tcopy_lang_decl (r);\n \tDECL_CLASS_CONTEXT (r) = DECL_CONTEXT (r);\n \n-\t/* Even if the original location is out of scope, the newly\n-\t   substituted one is not.  */\n-\tif (TREE_CODE (r) == VAR_DECL)\n-\t  DECL_DEAD_FOR_LOCAL (r) = 0;\n-\n \t/* A static data member declaration is always marked external\n \t   when it is declared in-class, even if an initializer is\n \t   present.  We mimic the non-template processing here.  */\n-\tif (ctx)\n-\t  DECL_EXTERNAL (r) = 1;\n+\tDECL_EXTERNAL (r) = 1;\n \n \tDECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \tSET_DECL_IMPLICIT_INSTANTIATION (r);\n@@ -5968,6 +5931,18 @@ tsubst_decl (t, args, type, in_decl)\n       }\n       break;\n \n+    case TYPE_DECL:\n+      if (t == TYPE_NAME (TREE_TYPE (t)))\n+\tr = TYPE_NAME (type);\n+      else\n+\t{\n+\t  r = copy_node (t);\n+\t  TREE_TYPE (r) = type;\n+\t  DECL_CONTEXT (r) = current_class_type;\n+\t  TREE_CHAIN (r) = NULL_TREE;\n+\t}\n+      break;\n+\n     default:\n       my_friendly_abort (0);\n     } \n@@ -6043,7 +6018,7 @@ tsubst_function_type (t, args, complain, in_decl)\n   tree arg_types;\n   tree fntype;\n \n-  /* The TYPE_CONEXT is not used for function/method types.  */\n+  /* The TYPE_CONTEXT is not used for function/method types.  */\n   my_friendly_assert (TYPE_CONTEXT (t) == NULL_TREE, 0);\n \n   /* Substitue the return type.  */\n@@ -6210,15 +6185,23 @@ tsubst (t, args, complain, in_decl)\n \tif (max == error_mark_node)\n \t  return error_mark_node;\n \n+\t/* See if we can reduce this expression to something simpler.  */\n+\tmax = maybe_fold_nontype_arg (max);\n+\tif (!processing_template_decl && TREE_READONLY_DECL_P (max))\n+\t  max = decl_constant_value (max);\n+\n \tif (processing_template_decl \n \t    /* When providing explicit arguments to a template\n \t       function, but leaving some arguments for subsequent\n \t       deduction, MAX may be template-dependent even if we're\n \t       not PROCESSING_TEMPLATE_DECL.  */\n \t    || TREE_CODE (max) != INTEGER_CST)\n \t  {\n-\t    return build_index_type (build_min\n-\t      (MINUS_EXPR, sizetype, max, integer_one_node));\n+\t    tree itype = make_node (INTEGER_TYPE);\n+\t    TYPE_MIN_VALUE (itype) = size_zero_node;\n+\t    TYPE_MAX_VALUE (itype) = build_min (MINUS_EXPR, sizetype, max,\n+\t\t\t\t\t\tinteger_one_node);\n+\t    return itype;\n \t  }\n \n \tif (integer_zerop (omax))\n@@ -7124,22 +7107,19 @@ tsubst_expr (t, args, complain, in_decl)\n     case DECL_STMT:\n       {\n \tint i = suspend_momentary ();\n-\ttree decl, init;\n+\ttree dcl, init;\n \n \tlineno = STMT_LINENO (t);\n \temit_line_note (input_filename, lineno);\n-\tdecl = DECL_STMT_DECL (t);\n-\tinit = DECL_INITIAL (decl);\n-\tdecl = tsubst (decl, args, complain, in_decl);\n-\tinit = tsubst_expr (init, args, complain, in_decl);\n-\tDECL_INITIAL (decl) = init;\n-\tmaybe_push_decl (decl);\n-\tif (TREE_CODE (decl) == VAR_DECL)\n-\t  DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n-\tstart_decl_1 (decl);\n-\tcp_finish_decl (decl, init, NULL_TREE, 0, 0);\n+\tdcl = start_decl\n+\t  (tsubst (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t   tsubst (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t   TREE_OPERAND (t, 2) != 0, NULL_TREE, NULL_TREE);\n+\tinit = tsubst_expr (TREE_OPERAND (t, 2), args, complain, in_decl);\n+\tcp_finish_decl\n+\t  (dcl, init, NULL_TREE, 1, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);\n \tresume_momentary (i);\n-\treturn decl;\n+\treturn dcl;\n       }\n \n     case FOR_STMT:"}]}