{"sha": "fa743e8cda25ba09a4731a3443df9e0e56e87581", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3NDNlOGNkYTI1YmEwOWE0NzMxYTM0NDNkZjllMGU1NmU4NzU4MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-20T12:26:02Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-20T12:26:02Z"}, "message": "tree.h: Include vec.h\n\n.:\t* tree.h: Include vec.h\n\t(DEF_VEC_P(tree)): New type.\n\t(BINFO_BASE_BINFOS, BINFO_N_BASE_BINFOS, BINFO_BASE_BINFO): Adjust.\n\t(BINFO_BASE_APPEND, BINFO_BASE_ITERATE): New.\n\t(BINFO_LANG_SLOT): Remove.\n\t(BINFO_SUBVTT_INDEX, BINFO_VPTR_INDEX, BINFO_PRIMARY_BASE_OF): New.\n\t(struct tree_binfo): Turn base_binfos into a trailing\n\tVEC(tree). Add vtt_subvtt, vtt_vptr, primary fields.\n\t(binfo_lang_slots): Remove.\n\t* tree.c (binfo_lang_slots): Remove.\n\t(make_tree_binfo_stat): Take a base binfo count, not a\n\tlang slot count.  Adjust.\n\t* Makefile.in (TREE_H): Add vec.h\n\t* alias.c (record_component_aliases): Adjust BINFO access.\n\t* dbxout.c (dbxout_type): Likewise.\n\t* dwarf2out.c (gen_member_die): Likewise.\n\t* sdbout.c (sdbout_one_type): Likewise.\n\t* tree-dump.c (deque_and_dump): Likewise.\n\t* config/i386/i386.c (classify_argument,\n\tcontains_128bit_aligned_vector_p): Likewise.\n\t* config/sh/symbian.c (symbian_export_vtable_and_rtti_p): Likewise.\n\t* doc/c-tree.texi (Classes): Update BINFO documentation.\ncp:\n\t* cp-tree.h (DEF_VEC_P(tree)): Remove here.\n\t(BINFO_SUBVTT_INDEX, BINFO_VPTR_INDEX, BINFO_PRIMARY_BASE_OF):\n\tMoved to common.\n\t(BINFO_LANG_SLOTS): Remove.\n\t* tree.c (copy_binfo): Adjust BINFO creation and accessors.\n\t* decl.c (xref_basetypes): Adjust BINFO creation and accessors.\n\t* class.c (check_bases): Adjust BINFO accessors.\n\t(determine_primary_base, finish_struct_bits,\n\tmaybe_warn_about_overly_private_class, warn_hidden,\n\twalk_subobject_offsets, propagate_binfo_offsets, end_of_class,\n\twarn_about_ambiguous_bases, get_vfield_name,\n\tdump_class_hierarchy_r, build_vtt_inits, accumulate_vtbl_inits,\n\tadd_vcall_offset_vtbl_entries_r): Likewise.\n\t* dump.c (cp_dump_tree): Likewise.\n\t* init.c (sort_mem_initializers, expand_member_init, build_delete,\n\tpush_base_cleanups): Likewise.\n\t* method.c (do_build_copy_constructor, do_build_assign_ref,\n\tsynthesize_exception_spec): Likewise.\n\tname-lookup.c (arg_assoc_class): Likewise.\n\t* pt.c (instantiate_class_template,\n\tget_template_base_recursive): Likewise.\n\t* rtti.c (get_pseudo_ti_init, get_pseudo_ti_desc): Likewise.\n\t* typeck2.c (process_init_constructor): Likewise.\n\t* search.c (lookup_base_r, dynamic_cast_base_recurse,\n\tdfs_access_in_type, dfs_walk_real, look_for_overrides,\n\ttypes_overlap_p, copied_binfo, original_binfo): Likewise.\n\t(binfo_for_vtable): Remove\njava:\n\t* class.c (add_interface_do): Remove.\n\t(set_super_info, interface_of_p, maybe_add_interface,\n\tadd_interface, make_class_data, layout_class,\n\tadd_miranda_methods): Adjust BINFO accessors and addition.\n\t* expr.c (can_widen_reference_to, lookup_field): Adjust BINFO\n\taccessors.\n\t* jcf-write.c (generate_classfile): Likewise.\n\t* parse.y (patch_anonymous_class, check_inner_circular_reference,\n\tcheck_circular_reference, java_complete_class,\n\tcheck_abstract_method_definitions,\n\tjava_check_abstract_method_definitions,\n\tcheck_interface_throws_clauses, java_check_abstract_methods,\n\tlookup_java_interface_method2,\n\tfind_applicable_accessible_methods_list): Adjust BINFO accessors\n\tand addition.\n\t* typeck.c (find_method_in_interfaces): Adjust BINFO accessors.\n\nFrom-SVN: r84949", "tree": {"sha": "d4f6d97c6ff518d744dc34b2b6c955e9348bb0b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f6d97c6ff518d744dc34b2b6c955e9348bb0b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa743e8cda25ba09a4731a3443df9e0e56e87581", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa743e8cda25ba09a4731a3443df9e0e56e87581", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa743e8cda25ba09a4731a3443df9e0e56e87581", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa743e8cda25ba09a4731a3443df9e0e56e87581/comments", "author": null, "committer": null, "parents": [{"sha": "35ae2ed81410448471c46f7757e6bc879d4de250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ae2ed81410448471c46f7757e6bc879d4de250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35ae2ed81410448471c46f7757e6bc879d4de250"}], "stats": {"total": 1230, "additions": 556, "deletions": 674}, "files": [{"sha": "c788fc6164cbf4b0bae57893b99a721b12b6c2ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -1,3 +1,28 @@\n+2004-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h: Include vec.h\n+\t(DEF_VEC_P(tree)): New type.\n+\t(BINFO_BASE_BINFOS, BINFO_N_BASE_BINFOS, BINFO_BASE_BINFO): Adjust.\n+\t(BINFO_BASE_APPEND, BINFO_BASE_ITERATE): New.\n+\t(BINFO_LANG_SLOT): Remove.\n+\t(BINFO_SUBVTT_INDEX, BINFO_VPTR_INDEX, BINFO_PRIMARY_BASE_OF): New.\n+\t(struct tree_binfo): Turn base_binfos into a trailing\n+\tVEC(tree). Add vtt_subvtt, vtt_vptr, primary fields.\n+\t(binfo_lang_slots): Remove.\n+\t* tree.c (binfo_lang_slots): Remove.\n+\t(make_tree_binfo_stat): Take a base binfo count, not a\n+\tlang slot count.  Adjust.\n+\t* Makefile.in (TREE_H): Add vec.h\n+\t* alias.c (record_component_aliases): Adjust BINFO access.\n+\t* dbxout.c (dbxout_type): Likewise.\n+\t* dwarf2out.c (gen_member_die): Likewise.\n+\t* sdbout.c (sdbout_one_type): Likewise.\n+\t* tree-dump.c (deque_and_dump): Likewise.\n+\t* config/i386/i386.c (classify_argument,\n+\tcontains_128bit_aligned_vector_p): Likewise.\n+\t* config/sh/symbian.c (symbian_export_vtable_and_rtti_p): Likewise.\n+\t* doc/c-tree.texi (Classes): Update BINFO documentation.\n+\n 2004-07-20  Steven Bosscher  <stevenb@suse.de>\n \n \t* c-common.h (check_case_value): Remove prototype."}, {"sha": "8706bae3c72d0801104c0506b66d69e11d1e643f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -686,7 +686,7 @@ RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H)\n RTL_H = $(RTL_BASE_H) genrtl.h input.h statistics.h\n PARAMS_H = params.h params.def\n TREE_H = tree.h tree.def $(MACHMODE_H) tree-check.h builtins.def \\\n-          input.h statistics.h\n+          input.h statistics.h vec.h\n BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h varray.h $(PARTITION_H) \\\n           hard-reg-set.h cfghooks.h\n COVERAGE_H = coverage.h gcov-io.h gcov-iov.h"}, {"sha": "7200fff8adb9288ca4bded05a9420d7aa54c956f", "filename": "gcc/alias.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -718,15 +718,15 @@ record_component_aliases (tree type)\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       /* Recursively record aliases for the base classes, if there are any.  */\n-      if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+      if (TYPE_BINFO (type))\n \t{\n \t  int i;\n-\t  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n-\t    {\n-\t      tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n-\t      record_alias_subset (superset,\n-\t\t\t\t   get_alias_set (BINFO_TYPE (binfo)));\n-\t    }\n+\t  tree binfo, base_binfo;\n+\t  \n+\t  for (binfo = TYPE_BINFO (type), i = 0;\n+\t       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t    record_alias_subset (superset,\n+\t\t\t\t get_alias_set (BINFO_TYPE (base_binfo)));\n \t}\n       for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL && ! DECL_NONADDRESSABLE_P (field))"}, {"sha": "95d0d527ff787967e736eb15fbafdfb4999ed5bc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -2103,18 +2103,17 @@ classify_argument (enum machine_mode mode, tree type,\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n \t  /* For classes first merge in the field of the subclasses.  */\n-\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+\t  if (TYPE_BINFO (type))\n \t    {\n-\t      tree bases = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n-\t      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\t      tree binfo, base_binfo;\n \t      int i;\n \n-\t      for (i = 0; i < n_bases; ++i)\n+\t      for (binfo = TYPE_BINFO (type), i = 0;\n+\t\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t\t{\n-\t\t   tree binfo = TREE_VEC_ELT (bases, i);\n \t\t   int num;\n-\t\t   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;\n-\t\t   tree type = BINFO_TYPE (binfo);\n+\t\t   int offset = tree_low_cst (BINFO_OFFSET (base_binfo), 0) * 8;\n+\t\t   tree type = BINFO_TYPE (base_binfo);\n \n \t\t   num = classify_argument (TYPE_MODE (type),\n \t\t\t\t\t    type, subclasses,\n@@ -2191,18 +2190,17 @@ classify_argument (enum machine_mode mode, tree type,\n \t       || TREE_CODE (type) == QUAL_UNION_TYPE)\n \t{\n \t  /* For classes first merge in the field of the subclasses.  */\n-\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+\t  if (TYPE_BINFO (type))\n \t    {\n-\t      tree bases = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n-\t      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\t      tree binfo, base_binfo;\n \t      int i;\n \n-\t      for (i = 0; i < n_bases; ++i)\n+\t      for (binfo = TYPE_BINFO (type), i = 0;\n+\t\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t\t{\n-\t\t   tree binfo = TREE_VEC_ELT (bases, i);\n \t\t   int num;\n-\t\t   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;\n-\t\t   tree type = BINFO_TYPE (binfo);\n+\t\t   int offset = tree_low_cst (BINFO_OFFSET (base_binfo), 0) * 8;\n+\t\t   tree type = BINFO_TYPE (base_binfo);\n \n \t\t   num = classify_argument (TYPE_MODE (type),\n \t\t\t\t\t    type, subclasses,\n@@ -2816,20 +2814,15 @@ contains_128bit_aligned_vector_p (tree type)\n \t{\n \t  tree field;\n \n-\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+\t  if (TYPE_BINFO (type))\n \t    {\n-\t      tree bases = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n-\t      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\t      tree binfo, base_binfo;\n \t      int i;\n \n-\t      for (i = 0; i < n_bases; ++i)\n-\t\t{\n-\t\t  tree binfo = TREE_VEC_ELT (bases, i);\n-\t\t  tree type = BINFO_TYPE (binfo);\n-\n-\t\t  if (contains_128bit_aligned_vector_p (type))\n-\t\t    return true;\n-\t\t}\n+\t      for (binfo = TYPE_BINFO (type), i = 0;\n+\t\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t\tif (contains_128bit_aligned_vector_p (BINFO_TYPE (base_binfo)))\n+\t\t  return true;\n \t    }\n \t  /* And now merge the fields of structure.  */\n \t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))"}, {"sha": "0469c54be4fd0d6b0068b5ed6f26eea0b780f5f9", "filename": "gcc/config/sh/symbian.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fconfig%2Fsh%2Fsymbian.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fconfig%2Fsh%2Fsymbian.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -618,9 +618,10 @@ symbian_export_vtable_and_rtti_p (tree ctype)\n   bool inline_ctor_dtor;\n   bool dllimport_ctor_dtor;\n   bool dllimport_member;\n-  tree binfos;\n+  tree binfo, base_binfo;\n   tree methods;\n   tree key;\n+  int i;\n   int len;\n \n   /* Make sure that we are examining a class...  */\n@@ -729,20 +730,9 @@ symbian_export_vtable_and_rtti_p (tree ctype)\n #endif\n \n   /* Now we must check and possibly export the base classes.  */\n-  binfos = BINFO_BASE_BINFOS (TYPE_BINFO (ctype));\n-  len = BINFO_N_BASE_BINFOS (TYPE_BINFO (ctype));\n-\n-  for (; len --;)\n-    {\n-      tree base_binfo;\n-      tree basetype;\n-\n-      /* Figure out which base we're looking at.  */\n-      base_binfo = TREE_VEC_ELT (binfos, len);\n-      basetype = TREE_TYPE (base_binfo);\n-\n-      symbian_possibly_export_base_class (basetype);\n-    }\n+  for (i = 0, binfo = TYPE_BINFO (ctype);\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    symbian_possibly_export_base_class (BINFO_TYPE (base_binfo));\n \n   return true;\n }"}, {"sha": "5ff48d0a3b8457949443af36a6bd0871637c707b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -1,3 +1,33 @@\n+2004-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (DEF_VEC_P(tree)): Remove here.\n+\t(BINFO_SUBVTT_INDEX, BINFO_VPTR_INDEX, BINFO_PRIMARY_BASE_OF):\n+\tMoved to common.\n+\t(BINFO_LANG_SLOTS): Remove.\n+\t* tree.c (copy_binfo): Adjust BINFO creation and accessors.\n+\t* decl.c (xref_basetypes): Adjust BINFO creation and accessors.\n+\t* class.c (check_bases): Adjust BINFO accessors.\n+\t(determine_primary_base, finish_struct_bits,\n+\tmaybe_warn_about_overly_private_class, warn_hidden,\n+\twalk_subobject_offsets, propagate_binfo_offsets, end_of_class,\n+\twarn_about_ambiguous_bases, get_vfield_name,\n+\tdump_class_hierarchy_r, build_vtt_inits, accumulate_vtbl_inits,\n+\tadd_vcall_offset_vtbl_entries_r): Likewise.\n+\t* dump.c (cp_dump_tree): Likewise.\n+\t* init.c (sort_mem_initializers, expand_member_init, build_delete,\n+\tpush_base_cleanups): Likewise.\n+\t* method.c (do_build_copy_constructor, do_build_assign_ref,\n+\tsynthesize_exception_spec): Likewise.\n+\tname-lookup.c (arg_assoc_class): Likewise.\n+\t* pt.c (instantiate_class_template,\n+\tget_template_base_recursive): Likewise.\n+\t* rtti.c (get_pseudo_ti_init, get_pseudo_ti_desc): Likewise.\n+\t* typeck2.c (process_init_constructor): Likewise.\n+\t* search.c (lookup_base_r, dynamic_cast_base_recurse,\n+\tdfs_access_in_type, dfs_walk_real, look_for_overrides,\n+\ttypes_overlap_p, copied_binfo, original_binfo): Likewise.\n+\t(binfo_for_vtable): Remove\n+\n 2004-07-20  Steven Bosscher  <stevenb@suse.de>\n \n \t* cp-tree.h (struct lang_decl_flags): Unify the template_info and"}, {"sha": "70374eb9e7bcd4c95c0b17f3592ede25a3aa50be", "filename": "gcc/cp/class.c", "status": "modified", "additions": 48, "deletions": 75, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -1130,23 +1130,17 @@ check_bases (tree t,\n              int* cant_have_const_ctor_p,\n              int* no_const_asn_ref_p)\n {\n-  int n_baseclasses;\n   int i;\n   int seen_non_virtual_nearly_empty_base_p;\n-  tree binfos;\n+  tree base_binfo;\n+  tree binfo;\n \n-  binfos = BINFO_BASE_BINFOS (TYPE_BINFO (t));\n-  n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   seen_non_virtual_nearly_empty_base_p = 0;\n \n-  for (i = 0; i < n_baseclasses; ++i) \n+  for (binfo = TYPE_BINFO (t), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      tree base_binfo;\n-      tree basetype;\n-\n-      /* Figure out what base we're looking at.  */\n-      base_binfo = TREE_VEC_ELT (binfos, i);\n-      basetype = TREE_TYPE (base_binfo);\n+      tree basetype = TREE_TYPE (base_binfo);\n \n       my_friendly_assert (COMPLETE_TYPE_P (basetype), 20040714);\n       \n@@ -1269,17 +1263,15 @@ determine_primary_base (tree t)\n   unsigned i, n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   tree type_binfo = TYPE_BINFO (t);\n   tree vbase_binfo;\n+  tree base_binfo;\n   VEC(tree) *vbases;\n \n   /* If there are no baseclasses, there is certainly no primary base.  */\n   if (n_baseclasses == 0)\n     return;\n \n-  type_binfo = TYPE_BINFO (t);\n-\n-  for (i = 0; i < n_baseclasses; i++)\n+  for (i = 0; BINFO_BASE_ITERATE (type_binfo, i, base_binfo); i++)\n     {\n-      tree base_binfo = BINFO_BASE_BINFO (type_binfo, i);\n       tree basetype = BINFO_TYPE (base_binfo);\n \n       if (TYPE_CONTAINS_VPTR_P (basetype))\n@@ -1325,12 +1317,12 @@ determine_primary_base (tree t)\n       /* See if this virtual base is an indirect primary base.  To be\n          so, it must be a primary base within the hierarchy of one of\n          our direct bases.  */\n-      for (j = 0; j != n_baseclasses; ++j) \n+      for (j = 0; BINFO_BASE_ITERATE (type_binfo, j, base_binfo); j++)\n \t{\n \t  unsigned k;\n \t  VEC (tree) *base_vbases;\n \t  tree base_vbase_binfo;\n-\t  tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), j));\n+\t  tree basetype = BINFO_TYPE (base_binfo);\n \t  \n \t  for (base_vbases = CLASSTYPE_VBASECLASSES (basetype), k = 0;\n \t       VEC_iterate (tree, base_vbases, k, base_vbase_binfo); k++)\n@@ -1407,7 +1399,6 @@ determine_primary_base (tree t)\n static void\n finish_struct_bits (tree t)\n {\n-  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   tree variants;\n   \n   /* Fix up variants (if any).  */\n@@ -1439,7 +1430,7 @@ finish_struct_bits (tree t)\n       TYPE_SIZE_UNIT (variants) = TYPE_SIZE_UNIT (t);\n     }\n \n-  if (n_baseclasses && TYPE_POLYMORPHIC_P (t))\n+  if (BINFO_N_BASE_BINFOS (TYPE_BINFO (t)) && TYPE_POLYMORPHIC_P (t))\n     /* For a class w/o baseclasses, `finish_struct' has set\n        CLASS_TYPE_ABSTRACT_VIRTUALS correctly (by definition).\n        Similarly for a class whose base classes do not have vtables.\n@@ -1537,10 +1528,10 @@ maybe_warn_about_overly_private_class (tree t)\n \t constructors/destructors we want to use the code below that\n \t issues error messages specifically referring to\n \t constructors/destructors.)  */\n-      int i;\n+      unsigned i;\n       tree binfo = TYPE_BINFO (t);\n       \n-      for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n+      for (i = 0; i != BINFO_N_BASE_BINFOS (binfo); i++)\n \tif (BINFO_BASE_ACCESS (binfo, i) != access_private_node)\n \t  {\n \t    has_nonprivate_method = 1;\n@@ -2370,6 +2361,8 @@ warn_hidden (tree t)\n       tree name;\n       tree fndecl;\n       tree base_fndecls;\n+      tree base_binfo;\n+      tree binfo;\n       int j;\n \n       /* All functions in this slot in the CLASSTYPE_METHOD_VEC will\n@@ -2379,9 +2372,10 @@ warn_hidden (tree t)\n       base_fndecls = NULL_TREE;\n       /* Iterate through all of the base classes looking for possibly\n \t hidden functions.  */\n-      for (j = 0; j < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); j++)\n+      for (binfo = TYPE_BINFO (t), j = 0;\n+\t   BINFO_BASE_ITERATE (binfo, j, base_binfo); j++)\n \t{\n-\t  tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), j));\n+\t  tree basetype = BINFO_TYPE (base_binfo);\n \t  base_fndecls = chainon (get_basefndecls (name, basetype),\n \t\t\t\t  base_fndecls);\n \t}\n@@ -3178,12 +3172,10 @@ walk_subobject_offsets (tree type,\n       /* Iterate through the direct base classes of TYPE.  */\n       if (!type_binfo)\n \ttype_binfo = TYPE_BINFO (type);\n-      for (i = 0; i < BINFO_N_BASE_BINFOS (type_binfo); ++i)\n+      for (i = 0; BINFO_BASE_ITERATE (type_binfo, i, binfo); i++)\n \t{\n \t  tree binfo_offset;\n \n-\t  binfo = BINFO_BASE_BINFO (type_binfo, i);\n-\n \t  if (abi_version_at_least (2) \n \t      && BINFO_VIRTUAL_P (binfo))\n \t    continue;\n@@ -4263,6 +4255,7 @@ propagate_binfo_offsets (tree binfo, tree offset)\n {\n   int i;\n   tree primary_binfo;\n+  tree base_binfo;\n \n   /* Update BINFO's offset.  */\n   BINFO_OFFSET (binfo)\n@@ -4279,10 +4272,8 @@ propagate_binfo_offsets (tree binfo, tree offset)\n   \n   /* Scan all of the bases, pushing the BINFO_OFFSET adjust\n      downwards.  */\n-  for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); ++i)\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n-      tree base_binfo = BINFO_BASE_BINFO (binfo, i);\n-      \n       /* Don't do the primary base twice.  */\n       if (base_binfo == primary_binfo)\n \tcontinue;\n@@ -4403,16 +4394,15 @@ end_of_class (tree t, int include_virtuals_p)\n   tree offset;\n   int i;\n \n-  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n+  for (binfo = TYPE_BINFO (t), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n-      binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n-\n       if (!include_virtuals_p\n-\t  && BINFO_VIRTUAL_P (binfo) \n-\t  && BINFO_PRIMARY_BASE_OF (binfo) != TYPE_BINFO (t))\n+\t  && BINFO_VIRTUAL_P (base_binfo) \n+\t  && BINFO_PRIMARY_BASE_OF (base_binfo) != TYPE_BINFO (t))\n \tcontinue;\n \n-      offset = end_of_base (binfo);\n+      offset = end_of_base (base_binfo);\n       if (INT_CST_LT_UNSIGNED (result, offset))\n \tresult = offset;\n     }\n@@ -4447,12 +4437,13 @@ warn_about_ambiguous_bases (tree t)\n   VEC (tree) *vbases;\n   tree basetype;\n   tree binfo;\n+  tree base_binfo;\n \n   /* Check direct bases.  */\n-  for (i = 0;\n-       i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n+  for (binfo = TYPE_BINFO (t), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n-      basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), i));\n+      basetype = BINFO_TYPE (base_binfo);\n \n       if (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n \twarning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n@@ -6142,7 +6133,7 @@ get_vfield_name (tree type)\n   char *buf;\n \n   for (binfo = TYPE_BINFO (type);\n-       BINFO_BASE_BINFOS (binfo);\n+       BINFO_N_BASE_BINFOS (binfo);\n        binfo = base_binfo)\n     {\n       base_binfo = BINFO_BASE_BINFO (binfo, 0);\n@@ -6231,11 +6222,13 @@ contains_empty_class_p (tree type)\n   if (CLASS_TYPE_P (type))\n     {\n       tree field;\n+      tree binfo;\n+      tree base_binfo;\n       int i;\n \n-      for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); ++i)\n-\tif (contains_empty_class_p\n-\t    (BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type), i))))\n+      for (binfo = TYPE_BINFO (type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+\tif (contains_empty_class_p (BINFO_TYPE (base_binfo)))\n \t  return true;\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL\n@@ -6401,7 +6394,8 @@ dump_class_hierarchy_r (FILE *stream,\n                         int indent)\n {\n   int indented = 0;\n-  tree base_binfos;\n+  tree base_binfo;\n+  int i;\n   \n   indented = maybe_indent_hierarchy (stream, indent, 0);\n   fprintf (stream, \"%s (0x%lx) \",\n@@ -6477,21 +6471,9 @@ dump_class_hierarchy_r (FILE *stream,\n       if (indented)\n \tfprintf (stream, \"\\n\");\n     }\n-  \n-  base_binfos = BINFO_BASE_BINFOS (binfo);\n-  if (base_binfos)\n-    {\n-      int ix, n;\n-\n-      n = TREE_VEC_LENGTH (base_binfos);\n-      for (ix = 0; ix != n; ix++)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (base_binfos, ix);\n \n-\t  igo = dump_class_hierarchy_r (stream, flags, base_binfo,\n-\t\t\t\t\tigo, indent + 2);\n-\t}\n-    }\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    igo = dump_class_hierarchy_r (stream, flags, base_binfo, igo, indent + 2);\n   \n   return igo;\n }\n@@ -6820,13 +6802,9 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   *index = size_binop (PLUS_EXPR, *index, TYPE_SIZE_UNIT (ptr_type_node));\n \t\t       \n   /* Recursively add the secondary VTTs for non-virtual bases.  */\n-  for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); ++i)\n-    {\n-      b = BINFO_BASE_BINFO (binfo, i);\n-      if (!BINFO_VIRTUAL_P (b))\n-\tinits = build_vtt_inits (BINFO_BASE_BINFO (binfo, i), t, \n-\t\t\t\t inits, index);\n-    }\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, b); ++i)\n+    if (!BINFO_VIRTUAL_P (b))\n+      inits = build_vtt_inits (BINFO_BASE_BINFO (binfo, i), t, inits, index);\n       \n   /* Add secondary virtual pointers for all subobjects of BINFO with\n      either virtual bases or reachable along a virtual path, except\n@@ -7058,6 +7036,7 @@ accumulate_vtbl_inits (tree binfo,\n                        tree inits)\n {\n   int i;\n+  tree base_binfo;\n   int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n \n   my_friendly_assert (same_type_p (BINFO_TYPE (binfo),\n@@ -7086,10 +7065,8 @@ accumulate_vtbl_inits (tree binfo,\n      secondary vtable lies from the primary vtable.  We can't use\n      dfs_walk here because we need to iterate through bases of BINFO\n      and RTTI_BINFO simultaneously.  */\n-  for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); ++i)\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n-      tree base_binfo = BINFO_BASE_BINFO (binfo, i);\n-      \n       /* Skip virtual bases.  */\n       if (BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;\n@@ -7562,6 +7539,7 @@ add_vcall_offset_vtbl_entries_r (tree binfo, vtbl_init_data* vid)\n {\n   int i;\n   tree primary_binfo;\n+  tree base_binfo;\n \n   /* Don't walk into virtual bases -- except, of course, for the\n      virtual base for which we are building vcall offsets.  Any\n@@ -7579,14 +7557,9 @@ add_vcall_offset_vtbl_entries_r (tree binfo, vtbl_init_data* vid)\n   add_vcall_offset_vtbl_entries_1 (binfo, vid);\n \n   /* Scan the non-primary bases of BINFO.  */\n-  for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); ++i) \n-    {\n-      tree base_binfo;\n-      \n-      base_binfo = BINFO_BASE_BINFO (binfo, i);\n-      if (base_binfo != primary_binfo)\n-\tadd_vcall_offset_vtbl_entries_r (base_binfo, vid);\n-    }\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+    if (base_binfo != primary_binfo)\n+      add_vcall_offset_vtbl_entries_r (base_binfo, vid);\n }\n \n /* Called from build_vcall_offset_vtbl_entries_r.  */"}, {"sha": "b3867bb57fb52e20182d2c2815102ae6d9bbdaf6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -937,8 +937,6 @@ struct lang_type_header GTY(())\n   BOOL_BITFIELD has_const_assign_ref : 1;\n };\n \n-DEF_VEC_P (tree);\n-\n /* This structure provides additional information above and beyond\n    what is provide in the ordinary tree_type.  In the past, we used it\n    for the types of class types, template parameters types, typename\n@@ -1397,24 +1395,6 @@ struct lang_type GTY(())\n #define BINFO_PRIMARY_P(NODE) \\\n   (BINFO_PRIMARY_BASE_OF (NODE) != NULL_TREE)\n \n-/* The index in the VTT where this subobject's sub-VTT can be found.\n-   NULL_TREE if there is no sub-VTT.  */\n-#define BINFO_SUBVTT_INDEX(NODE) BINFO_LANG_SLOT(NODE, 0)\n-\n-/* The index in the VTT where the vptr for this subobject can be\n-   found.  NULL_TREE if there is no secondary vptr in the VTT.  */\n-#define BINFO_VPTR_INDEX(NODE) BINFO_LANG_SLOT(NODE, 1)\n-\n-/* The binfo of which NODE is a primary base.  (This is different from\n-   BINFO_INHERITANCE_CHAIN for virtual base because a virtual base is\n-   sometimes a primary base for a class for which it is not an\n-   immediate base.)  */\n-#define BINFO_PRIMARY_BASE_OF(NODE) BINFO_LANG_SLOT(NODE, 2)\n-\n-/* C++ binfos have 3 additional entries.  */\n-\n-#define BINFO_LANG_SLOTS (3)\n-\n /* Nonzero if this binfo is for a dependent base - one that should not\n    be searched.  */\n #define BINFO_DEPENDENT_BASE_P(NODE) BINFO_FLAG_3 (NODE)"}, {"sha": "8dee86aff14b0f04c0daf916899bf513eaf76066", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -9032,7 +9032,7 @@ void\n xref_basetypes (tree ref, tree base_list)\n {\n   tree *basep;\n-  tree binfo;\n+  tree binfo, base_binfo;\n   unsigned max_vbases = 0; /* Maxium direct & indirect virtual bases. */\n   unsigned max_bases = 0;  /* Maxium direct bases.  */\n   int i;\n@@ -9079,14 +9079,13 @@ xref_basetypes (tree ref, tree base_list)\n   my_friendly_assert (!TYPE_BINFO (ref) || TYPE_SIZE (ref), 20040706);\n   my_friendly_assert (TYPE_MAIN_VARIANT (ref) == ref, 20040712);\n   \n-  binfo = make_tree_binfo (BINFO_LANG_SLOTS);\n+  binfo = make_tree_binfo (max_bases);\n   TYPE_BINFO (ref) = binfo;\n   BINFO_OFFSET (binfo) = size_zero_node;\n   BINFO_TYPE (binfo) = ref;\n   \n   if (max_bases)\n     {\n-      BINFO_BASE_BINFOS (binfo) = make_tree_vec (max_bases);\n       BINFO_BASE_ACCESSES (binfo) = make_tree_vec (max_bases);\n       /* An aggregate cannot have baseclasses.  */\n       CLASSTYPE_NON_AGGREGATE (ref) = 1;\n@@ -9118,13 +9117,11 @@ xref_basetypes (tree ref, tree base_list)\n \terror (\"Java class '%T' cannot have virtual bases\", ref);\n     }\n \n-  i = 0;\n   for (igo_prev = binfo; base_list; base_list = TREE_CHAIN (base_list))\n     {\n       tree access = TREE_PURPOSE (base_list);\n       int via_virtual = TREE_TYPE (base_list) != NULL_TREE;\n       tree basetype = TREE_VALUE (base_list);\n-      tree base_binfo = NULL_TREE;\n       \n       if (access == access_default_node)\n \taccess = default_access;\n@@ -9154,6 +9151,7 @@ xref_basetypes (tree ref, tree base_list)\n       if (TYPE_FOR_JAVA (basetype) && (current_lang_depth () == 0))\n \tTYPE_FOR_JAVA (ref) = 1;\n \n+      base_binfo = NULL_TREE;\n       if (CLASS_TYPE_P (basetype) && !dependent_type_p (basetype))\n \t{\n \t  base_binfo = TYPE_BINFO (basetype);\n@@ -9178,22 +9176,20 @@ xref_basetypes (tree ref, tree base_list)\n       if (!BINFO_INHERITANCE_CHAIN (base_binfo))\n \tBINFO_INHERITANCE_CHAIN (base_binfo) = binfo;\n \n-      TREE_VEC_ELT (BINFO_BASE_ACCESSES (binfo), i) = access;\n-      BINFO_BASE_BINFO (binfo, i) = base_binfo;\n-      i++;\n+      TREE_VEC_ELT (BINFO_BASE_ACCESSES (binfo),\n+\t\t    BINFO_N_BASE_BINFOS (binfo)) = access;\n+      BINFO_BASE_APPEND (binfo, base_binfo);\n     }\n \n   if (max_bases)\n-    {\n-      /* If any bases were invalid, we will have allocated too many\n-\t slots.  */\n-      TREE_VEC_LENGTH (BINFO_BASE_ACCESSES (binfo)) = i;\n-      TREE_VEC_LENGTH (BINFO_BASE_BINFOS (binfo)) = i;\n-    }\n+    /* If any bases were invalid, we will have allocated too many\n+       slots.  */\n+    TREE_VEC_LENGTH (BINFO_BASE_ACCESSES (binfo))\n+      = BINFO_N_BASE_BINFOS (binfo);\n   \n   /* Unmark all the types.  */\n-  for (i = 0; i != BINFO_N_BASE_BINFOS (binfo); i++)\n-    CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (BINFO_BASE_BINFO (binfo, i)));\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (base_binfo));\n   CLEAR_CLASSTYPE_MARKED (ref);\n }\n "}, {"sha": "ce136afb5bf4f3e7d95ec2bb2eb9c647362600f4", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -267,10 +267,12 @@ cp_dump_tree (void* dump_info, tree t)\n       if (!dump_flag (di, TDF_SLIM, t) && TYPE_BINFO (t))\n \t{\n \t  int i;\n+\t  tree binfo;\n+\t  tree base_binfo;\n \t  \n-\t  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n+\t  for (binfo = TYPE_BINFO (t), i = 0;\n+\t       BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n \t    {\n-\t      tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n \t      dump_child (\"base\", BINFO_TYPE (base_binfo));\n \t      if (BINFO_VIRTUAL_P (base_binfo)) \n \t\tdump_string (di, \"virtual\");"}, {"sha": "99df1b6f357f10a612f5659b93dac1cd1305c6df", "filename": "gcc/cp/init.c", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -457,7 +457,7 @@ static tree\n sort_mem_initializers (tree t, tree mem_inits)\n {\n   tree init;\n-  tree base;\n+  tree base, binfo, base_binfo;\n   tree sorted_inits;\n   tree next_subobject;\n   VEC (tree) *vbases;\n@@ -476,12 +476,11 @@ sort_mem_initializers (tree t, tree mem_inits)\n     sorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n   \n   /* Process the direct bases.  */\n-  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n-    {\n-      base = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n-      if (!BINFO_VIRTUAL_P (base))\n-\tsorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n-    }\n+  for (binfo = TYPE_BINFO (t), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+    if (!BINFO_VIRTUAL_P (base_binfo))\n+      sorted_inits = tree_cons (base_binfo, NULL_TREE, sorted_inits);\n+\n   /* Process the non-static data members.  */\n   sorted_inits = build_field_list (t, sorted_inits, &uses_unions_p);\n   /* Reverse the entire list of initializations, so that they are in\n@@ -983,14 +982,10 @@ expand_member_init (tree name)\n       virtual_binfo = NULL_TREE;\n \n       /* Look for a direct base.  */\n-      for (i = 0; i < BINFO_N_BASE_BINFOS (class_binfo); ++i)\n-\tif (same_type_p\n-\t    (basetype, BINFO_TYPE\n-\t     (BINFO_BASE_BINFO (TYPE_BINFO (current_class_type), i))))\n-\t  {\n-\t    direct_binfo = BINFO_BASE_BINFO (class_binfo, i);\n-\t    break;\n-\t  }\n+      for (i = 0; BINFO_BASE_ITERATE (class_binfo, i, direct_binfo); ++i)\n+\tif (same_type_p (basetype, BINFO_TYPE (direct_binfo)))\n+\t  break;\n+\n       /* Look for a virtual base -- unless the direct base is itself\n \t virtual.  */\n       if (!direct_binfo || !BINFO_VIRTUAL_P (direct_binfo))\n@@ -2858,8 +2853,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n void\n push_base_cleanups (void)\n {\n-  tree binfos, base_binfo;\n-  int i, n_baseclasses;\n+  tree binfo, base_binfo;\n+  int i;\n   tree member;\n   tree expr;\n   VEC (tree) *vbases;\n@@ -2892,13 +2887,10 @@ push_base_cleanups (void)\n \t}\n     }\n \n-  binfos = BINFO_BASE_BINFOS (TYPE_BINFO (current_class_type));\n-  n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (current_class_type));\n-\n   /* Take care of the remaining baseclasses.  */\n-  for (i = 0; i < n_baseclasses; i++)\n+  for (binfo = TYPE_BINFO (current_class_type), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n       if (TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))\n \t  || BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;"}, {"sha": "a28c90182c24d453b1059905b55f3caf787fc845", "filename": "gcc/cp/method.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -515,12 +515,10 @@ do_build_copy_constructor (tree fndecl)\n   else\n     {\n       tree fields = TYPE_FIELDS (current_class_type);\n-      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (current_class_type));\n-      tree binfos = BINFO_BASE_BINFOS (TYPE_BINFO (current_class_type));\n       tree member_init_list = NULL_TREE;\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n-      tree binfo;\n+      tree binfo, base_binfo;\n       VEC (tree) *vbases;\n \n       /* Initialize all the base-classes with the parameter converted\n@@ -539,17 +537,17 @@ do_build_copy_constructor (tree fndecl)\n \t\t\t member_init_list);\n \t}\n \n-      for (i = 0; i < n_bases; ++i)\n+      for (binfo = TYPE_BINFO (current_class_type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n-\t  tree binfo = TREE_VEC_ELT (binfos, i);\n-\t  if (BINFO_VIRTUAL_P (binfo))\n+\t  if (BINFO_VIRTUAL_P (base_binfo))\n \t    continue; \n \n \t  member_init_list \n-\t    = tree_cons (binfo,\n+\t    = tree_cons (base_binfo,\n \t\t\t build_tree_list (NULL_TREE,\n \t\t\t\t\t  build_base_path (PLUS_EXPR, parm,\n-\t\t\t\t\t\t\t   binfo, 1)),\n+\t\t\t\t\t\t\t   base_binfo, 1)),\n \t\t\t member_init_list);\n \t}\n \n@@ -617,26 +615,24 @@ do_build_assign_ref (tree fndecl)\n       tree fields;\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n+      tree binfo, base_binfo;\n \n       /* Assign to each of the direct base classes.  */\n-      for (i = 0;\n-\t   i < BINFO_N_BASE_BINFOS (TYPE_BINFO (current_class_type));\n-\t   ++i)\n+      for (binfo = TYPE_BINFO (current_class_type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n-\t  tree binfo;\n \t  tree converted_parm;\n \n-\t  binfo = BINFO_BASE_BINFO (TYPE_BINFO (current_class_type), i);\n \t  /* We must convert PARM directly to the base class\n \t     explicitly since the base class may be ambiguous.  */\n-\t  converted_parm = build_base_path (PLUS_EXPR, parm, binfo, 1);\n+\t  converted_parm = build_base_path (PLUS_EXPR, parm, base_binfo, 1);\n \t  /* Call the base class assignment operator.  */\n \t  finish_expr_stmt \n \t    (build_special_member_call (current_class_ref, \n \t\t\t\t\tansi_assopname (NOP_EXPR),\n \t\t\t\t\tbuild_tree_list (NULL_TREE, \n \t\t\t\t\t\t\t converted_parm),\n-\t\t\t\t\tbinfo,\n+\t\t\t\t\tbase_binfo,\n \t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL));\n \t}\n \n@@ -783,13 +779,13 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n {\n   tree raises = empty_except_spec;\n   tree fields = TYPE_FIELDS (type);\n-  int i, n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n-  tree binfos = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n+  tree binfo, base_binfo;\n+  int i;\n \n-  for (i = 0; i != n_bases; i++)\n+  for (binfo = TYPE_BINFO (type), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      tree base = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n-      tree fn = (*extractor) (base, client);\n+      tree fn = (*extractor) (BINFO_TYPE (base_binfo), client);\n       if (fn)\n         {\n           tree fn_raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));"}, {"sha": "ffb03eac64cc72ba6b087088aa9990ea02fb476b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -4400,11 +4400,15 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n     return true;\n \n   if (TYPE_BINFO (type))\n-    /* Process baseclasses.  */\n-    for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n-      if (arg_assoc_class\n-\t  (k, BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type), i))))\n-\treturn true;\n+    {\n+      /* Process baseclasses.  */\n+      tree binfo, base_binfo;\n+      \n+      for (binfo = TYPE_BINFO (type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\tif (arg_assoc_class (k, BINFO_TYPE (base_binfo)))\n+\t  return true;\n+    }\n   \n   /* Process friends.  */\n   for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; "}, {"sha": "76769ef00a11ac08c5f32f56027e8c4dce9ed221", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -5416,10 +5416,9 @@ instantiate_class_template (tree type)\n #endif\n \n   base_list = NULL_TREE;\n-  if (BINFO_BASE_BINFOS (pbinfo))\n+  if (BINFO_N_BASE_BINFOS (pbinfo))\n     {\n-      tree pbases = BINFO_BASE_BINFOS (pbinfo);\n-      tree paccesses = BINFO_BASE_ACCESSES (pbinfo);\n+      tree pbase_binfo;\n       tree context = TYPE_CONTEXT (type);\n       bool pop_p;\n       int i;\n@@ -5431,22 +5430,18 @@ instantiate_class_template (tree type)\n   \n       /* Substitute into each of the bases to determine the actual\n \t basetypes.  */\n-      for (i = 0; i < TREE_VEC_LENGTH (pbases); ++i)\n+      for (i = 0; BINFO_BASE_ITERATE (pbinfo, i, pbase_binfo); i++)\n \t{\n \t  tree base;\n-\t  tree access;\n-\t  tree pbase;\n-\n-\t  pbase = TREE_VEC_ELT (pbases, i);\n-\t  access = TREE_VEC_ELT (paccesses, i);\n+\t  tree access = BINFO_BASE_ACCESS (pbinfo, i);\n \n \t  /* Substitute to figure out the base class.  */\n-\t  base = tsubst (BINFO_TYPE (pbase), args, tf_error, NULL_TREE);\n+\t  base = tsubst (BINFO_TYPE (pbase_binfo), args, tf_error, NULL_TREE);\n \t  if (base == error_mark_node)\n \t    continue;\n \t  \n \t  base_list = tree_cons (access, base, base_list);\n-\t  if (BINFO_VIRTUAL_P (pbase))\n+\t  if (BINFO_VIRTUAL_P (pbase_binfo))\n \t    TREE_TYPE (base_list) = integer_type_node;\n \t}\n \n@@ -7421,6 +7416,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  if (ctx != DECL_CONTEXT (t))\n \t    return lookup_field (ctx, DECL_NAME (t), 0, false);\n \t}\n+      \n       return t;\n \n     case VAR_DECL:\n@@ -9366,8 +9362,8 @@ get_template_base_recursive (tree tparms,\n                              tree rval, \n                              int flags)\n {\n-  tree binfos;\n-  int i, n_baselinks;\n+  tree base_binfo;\n+  int i;\n   tree arg = BINFO_TYPE (arg_binfo);\n \n   if (!(flags & GTB_IGNORE_TYPE))\n@@ -9389,13 +9385,9 @@ get_template_base_recursive (tree tparms,\n \trval = r;\n     }\n \n-  binfos = BINFO_BASE_BINFOS (arg_binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n   /* Process base types.  */\n-  for (i = 0; i < n_baselinks; i++)\n+  for (i = 0; BINFO_BASE_ITERATE (arg_binfo, i, base_binfo); i++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n       int this_virtual;\n \n       /* Skip this base, if we've already seen it.  */"}, {"sha": "b1ae3dda80fbf7e884a84841eb801a3de480d422", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -1032,8 +1032,7 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n         }\n       else if (var_desc == si_class_desc_type_node)\n \t{\n-          tree base_binfos = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n-\t  tree base_binfo = TREE_VEC_ELT (base_binfos, 0);\n+          tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n \t  tree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t  tree base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n \t  \n@@ -1044,15 +1043,14 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n \t  int hint = class_hint_flags (type);\n \t  tree binfo = TYPE_BINFO (type);\n           int nbases = BINFO_N_BASE_BINFOS (binfo);\n-          tree base_binfos = BINFO_BASE_BINFOS (binfo);\n \t  tree base_accesses = BINFO_BASE_ACCESSES (binfo);\n           tree base_inits = NULL_TREE;\n           int ix;\n           \n           /* Generate the base information initializer.  */\n           for (ix = nbases; ix--;)\n             {\n-              tree base_binfo = TREE_VEC_ELT (base_binfos, ix);\n+              tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n               tree base_init = NULL_TREE;\n               int flags = 0;\n               tree tinfo;\n@@ -1192,10 +1190,9 @@ get_pseudo_ti_desc (tree type)\n       else\n \t{\n \t  tree binfo = TYPE_BINFO (type);\n-\t  tree base_binfos = BINFO_BASE_BINFOS (binfo);\n \t  tree base_accesses = BINFO_BASE_ACCESSES (binfo);\n-\t  tree base_binfo = TREE_VEC_ELT (base_binfos, 0);\n-\t  int num_bases = TREE_VEC_LENGTH (base_binfos);\n+\t  tree base_binfo = BINFO_BASE_BINFO (binfo, 0);\n+\t  int num_bases = BINFO_N_BASE_BINFOS (binfo);\n \t  \n \t  if (num_bases == 1\n \t      && TREE_VEC_ELT (base_accesses, 0) == access_public_node"}, {"sha": "364e8f26b779328f9f6d71a20d559f2dc48045a4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 40, "deletions": 97, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -97,7 +97,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n \t       tree *binfo_ptr)\n {\n   int i;\n-  tree bases, accesses;\n+  tree base_binfo;\n   base_kind found = bk_not_base;\n   \n   if (same_type_p (BINFO_TYPE (binfo), base))\n@@ -123,14 +123,8 @@ lookup_base_r (tree binfo, tree base, base_access access,\n       return found;\n     }\n   \n-  bases = BINFO_BASE_BINFOS (binfo);\n-  accesses = BINFO_BASE_ACCESSES (binfo);\n-  if (!bases)\n-    return bk_not_base;\n-  \n-  for (i = TREE_VEC_LENGTH (bases); i--;)\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (bases, i);\n       base_kind bk;\n \n       bk = lookup_base_r (base_binfo, base,\n@@ -290,8 +284,9 @@ static int\n dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n \t\t\t   tree *offset_ptr)\n {\n-  tree binfos, accesses;\n-  int i, n_baselinks;\n+  tree accesses;\n+  tree base_binfo;\n+  int i;\n   int worst = -2;\n   \n   if (BINFO_TYPE (binfo) == subtype)\n@@ -305,12 +300,9 @@ dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n         }\n     }\n   \n-  binfos = BINFO_BASE_BINFOS (binfo);\n   accesses = BINFO_BASE_ACCESSES (binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  for (i = 0; i < n_baselinks; i++)\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n       tree base_access = TREE_VEC_ELT (accesses, i);\n       int rval;\n       \n@@ -630,17 +622,13 @@ dfs_access_in_type (tree binfo, void *data)\n       if (!access)\n \t{\n \t  int i;\n-\t  int n_baselinks;\n-\t  tree binfos, accesses;\n+\t  tree base_binfo, accesses;\n \t  \n \t  /* Otherwise, scan our baseclasses, and pick the most favorable\n \t     access.  */\n-\t  binfos = BINFO_BASE_BINFOS (binfo);\n \t  accesses = BINFO_BASE_ACCESSES (binfo);\n-\t  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\t  for (i = 0; i < n_baselinks; ++i)\n+\t  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t    {\n-\t      tree base_binfo = TREE_VEC_ELT (binfos, i);\n \t      tree base_access = TREE_VEC_ELT (accesses, i);\n \t      access_kind base_access_now = BINFO_ACCESS (base_binfo);\n \n@@ -1601,6 +1589,8 @@ dfs_walk_real (tree binfo,\n \t       tree (*qfn) (tree, int, void *),\n \t       void *data)\n {\n+  int i;\n+  tree base_binfo;\n   tree rval = NULL_TREE;\n \n   /* Call the pre-order walking function.  */\n@@ -1612,25 +1602,17 @@ dfs_walk_real (tree binfo,\n     }\n \n   /* Process the basetypes.  */\n-  if (BINFO_BASE_BINFOS (binfo))\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      int i, n = TREE_VEC_LENGTH (BINFO_BASE_BINFOS (binfo));\n-      for (i = 0; i != n; i++)\n+      if (qfn)\n \t{\n-\t  tree base_binfo;\n-      \n-\t  if (qfn)\n-\t    base_binfo = (*qfn) (binfo, i, data);\n-\t  else\n-\t    base_binfo = BINFO_BASE_BINFO (binfo, i);\n-\t  \n-\t  if (base_binfo)\n-\t    {\n-\t      rval = dfs_walk_real (base_binfo, prefn, postfn, qfn, data);\n-\t      if (rval)\n-\t\treturn rval;\n-\t    }\n+\t  base_binfo = (*qfn) (binfo, i, data);\n+\t  if (!base_binfo)\n+\t    continue;\n \t}\n+      rval = dfs_walk_real (base_binfo, prefn, postfn, qfn, data);\n+      if (rval)\n+\treturn rval;\n     }\n \n   /* Call the post-order walking function.  */\n@@ -1761,14 +1743,13 @@ int\n look_for_overrides (tree type, tree fndecl)\n {\n   tree binfo = TYPE_BINFO (type);\n-  tree basebinfos = BINFO_BASE_BINFOS (binfo);\n-  int nbasebinfos = basebinfos ? TREE_VEC_LENGTH (basebinfos) : 0;\n+  tree base_binfo;\n   int ix;\n   int found = 0;\n \n-  for (ix = 0; ix != nbasebinfos; ix++)\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n     {\n-      tree basetype = BINFO_TYPE (TREE_VEC_ELT (basebinfos, ix));\n+      tree basetype = BINFO_TYPE (base_binfo);\n       \n       if (TYPE_POLYMORPHIC_P (basetype))\n         found += look_for_overrides_r (basetype, fndecl);\n@@ -2161,7 +2142,7 @@ dfs_check_overlap (tree empty_binfo, void *data)\n \t  oi->found_overlap = 1;\n \t  break;\n \t}\n-      else if (BINFO_BASE_BINFOS (binfo) == NULL_TREE)\n+      else if (!BINFO_N_BASE_BINFOS (binfo))\n \tbreak;\n     }\n \n@@ -2196,34 +2177,6 @@ types_overlap_p (tree empty_type, tree next_type)\n   return oi.found_overlap;\n }\n \n-/* Given a vtable VAR, determine which of the inherited classes the vtable\n-   inherits (in a loose sense) functions from.\n-\n-   FIXME: This does not work with the new ABI.  */\n-\n-tree\n-binfo_for_vtable (tree var)\n-{\n-  tree main_binfo = TYPE_BINFO (DECL_CONTEXT (var));\n-  tree binfos = BINFO_BASE_BINFOS (TYPE_BINFO (BINFO_TYPE (main_binfo)));\n-  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (BINFO_TYPE (main_binfo)));\n-  int i;\n-\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      if (base_binfo != NULL_TREE && BINFO_VTABLE (base_binfo) == var)\n-\treturn base_binfo;\n-    }\n-\n-  /* If no secondary base classes matched, return the primary base, if\n-     there is one.  */\n-  if (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (main_binfo)))\n-    return get_primary_binfo (main_binfo);\n-\n-  return main_binfo;\n-}\n-\n /* Returns the binfo of the first direct or indirect virtual base derived\n    from BINFO, or NULL if binfo is not via virtual.  */\n \n@@ -2275,22 +2228,17 @@ copied_binfo (tree binfo, tree here)\n     }\n   else if (BINFO_INHERITANCE_CHAIN (binfo))\n     {\n-      tree base_binfos;\n-      int ix, n;\n+      tree cbinfo;\n+      tree base_binfo;\n+      int ix;\n       \n-      base_binfos = copied_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n-      base_binfos = BINFO_BASE_BINFOS (base_binfos);\n-      n = TREE_VEC_LENGTH (base_binfos);\n-      for (ix = 0; ix != n; ix++)\n-\t{\n-\t  tree base = TREE_VEC_ELT (base_binfos, ix);\n-\t  \n-\t  if (BINFO_TYPE (base) == BINFO_TYPE (binfo))\n-\t    {\n-\t      result = base;\n-\t      break;\n-\t    }\n-\t}\n+      cbinfo = copied_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n+      for (ix = 0; BINFO_BASE_ITERATE (cbinfo, ix, base_binfo); ix++)\n+\tif (BINFO_TYPE (base_binfo) == BINFO_TYPE (binfo))\n+\t  {\n+\t    result = base_binfo;\n+\t    break;\n+\t  }\n     }\n   else\n     {\n@@ -2339,20 +2287,15 @@ original_binfo (tree binfo, tree here)\n       base_binfos = original_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n       if (base_binfos)\n \t{\n-\t  int ix, n;\n+\t  int ix;\n+\t  tree base_binfo;\n \t  \n-\t  base_binfos = BINFO_BASE_BINFOS (base_binfos);\n-\t  n = TREE_VEC_LENGTH (base_binfos);\n-\t  for (ix = 0; ix != n; ix++)\n-\t    {\n-\t      tree base = TREE_VEC_ELT (base_binfos, ix);\n-\t      \n-\t      if (BINFO_TYPE (base) == BINFO_TYPE (binfo))\n-\t\t{\n-\t\t  result = base;\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t  for (ix = 0; (base_binfo = BINFO_BASE_BINFO (base_binfos, ix)); ix++)\n+\t    if (BINFO_TYPE (base_binfo) == BINFO_TYPE (binfo))\n+\t      {\n+\t\tresult = base_binfo;\n+\t\tbreak;\n+\t      }\n \t}\n     }\n   "}, {"sha": "f005d7c4f7d61ccb8133bfabbd243b5851233180", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -597,7 +597,7 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n \treturn new_binfo;\n     }\n   \n-  new_binfo = make_tree_binfo (BINFO_LANG_SLOTS);\n+  new_binfo = make_tree_binfo (binfo ? BINFO_N_BASE_BINFOS (binfo) : 0);\n   BINFO_TYPE (new_binfo) = type;\n \n   /* Chain it into the inheritance graph.  */\n@@ -606,26 +606,21 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n   \n   if (binfo)\n     {\n-      int ix, n = BINFO_N_BASE_BINFOS (binfo);\n+      int ix;\n+      tree base_binfo;\n       \n       my_friendly_assert (!BINFO_DEPENDENT_BASE_P (binfo), 20040712);\n       my_friendly_assert (type == BINFO_TYPE (binfo), 20040714);\n   \n       BINFO_OFFSET (new_binfo) = BINFO_OFFSET (binfo);\n       BINFO_VIRTUALS (new_binfo) = BINFO_VIRTUALS (binfo);\n       \n-      /* Create a new base binfo vector.  */\n-      if (n)\n-\t{\n-\t  BINFO_BASE_BINFOS (new_binfo) = make_tree_vec (n);\n-          /* We do not need to copy the accesses, as they are read only.  */\n-\t  BINFO_BASE_ACCESSES (new_binfo) = BINFO_BASE_ACCESSES (binfo);\n-\t}\n+      /* We do not need to copy the accesses, as they are read only.  */\n+      BINFO_BASE_ACCESSES (new_binfo) = BINFO_BASE_ACCESSES (binfo);\n       \n       /* Recursively copy base binfos of BINFO.  */\n-      for (ix = 0; ix != n; ix++)\n+      for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n \t{\n-\t  tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n \t  tree new_base_binfo;\n \t  \n \t  my_friendly_assert (!BINFO_DEPENDENT_BASE_P (base_binfo), 20040713);\n@@ -635,7 +630,7 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n \t  \n \t  if (!BINFO_INHERITANCE_CHAIN (new_base_binfo))\n \t    BINFO_INHERITANCE_CHAIN (new_base_binfo) = new_binfo;\n-\t  BINFO_BASE_BINFO (new_binfo, ix) = new_base_binfo;\n+\t  BINFO_BASE_APPEND (new_binfo, new_base_binfo);\n \t}\n     }\n   else"}, {"sha": "53a5c186ff8fd13470fcf0ee8c74a9f6d766e77a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -954,7 +954,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t      return error_mark_node;\n \t    }\n \n-\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+\t  if (TYPE_BINFO (type) && BINFO_N_BASE_BINFOS (TYPE_BINFO (type)))\n \t    {\n \t      sorry (\"initializer list for object of class with base classes\");\n \t      return error_mark_node;"}, {"sha": "c888dd08875986cc3bb574f006a27b2cb9ce5967", "filename": "gcc/dbxout.c", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -1633,10 +1633,7 @@ dbxout_type (tree type, int full)\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       {\n-\tint i, n_baseclasses = 0;\n-\n-\tif (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n-\t  n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\ttree binfo = TYPE_BINFO (type);\n \n \t/* Output a structure type.  We must use the same test here as we\n \t   use in the DBX_NO_XREFS case above.  */\n@@ -1683,65 +1680,72 @@ dbxout_type (tree type, int full)\n \tCHARS (1);\n \tprint_wide_int (int_size_in_bytes (type));\n \n-\tif (use_gnu_debug_info_extensions)\n-\t  {\n-\t    if (n_baseclasses)\n-\t      {\n-\t\thave_used_extensions = 1;\n-\t\tfprintf (asmfile, \"!%d,\", n_baseclasses);\n-\t\tCHARS (8);\n-\t      }\n-\t  }\n-\tfor (i = 0; i < n_baseclasses; i++)\n+\tif (binfo)\n \t  {\n-\t    tree binfo = TYPE_BINFO (type);\n-\t    tree child = BINFO_BASE_BINFO (binfo, i);\n-\t    tree access = (BINFO_BASE_ACCESSES (binfo)\n-\t\t\t   ? BINFO_BASE_ACCESS (binfo, i) : access_public_node);\n-\n+\t    int i;\n+\t    tree child;\n+\t    \n \t    if (use_gnu_debug_info_extensions)\n \t      {\n-\t\thave_used_extensions = 1;\n-                putc (BINFO_VIRTUAL_P (child) ? '1' : '0', asmfile);\n-                putc (access == access_public_node ? '2' :\n-                      (access == access_protected_node ? '1' :'0'),\n-                      asmfile);\n-\t\tCHARS (2);\n-\t\tif (BINFO_VIRTUAL_P (child)\n-\t\t    && strcmp (lang_hooks.name, \"GNU C++\") == 0)\n-\t\t  /* For a virtual base, print the (negative) offset within\n-\t\t     the vtable where we must look to find the necessary\n-\t\t     adjustment.  */\n-\t\t  print_wide_int (tree_low_cst (BINFO_VPTR_FIELD (child), 0)\n-\t\t\t\t  * BITS_PER_UNIT);\n-\t\telse\n-\t\t  print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n-\t\t\t\t  * BITS_PER_UNIT);\n-\t\tputc (',', asmfile);\n-\t\tCHARS (1);\n-\t\tdbxout_type (BINFO_TYPE (child), 0);\n-\t\tputc (';', asmfile);\n-\t\tCHARS (1);\n+\t\tif (BINFO_N_BASE_BINFOS (binfo))\n+\t\t  {\n+\t\t    have_used_extensions = 1;\n+\t\t    fprintf (asmfile, \"!%d,\", BINFO_N_BASE_BINFOS (binfo));\n+\t\t    CHARS (8);\n+\t\t  }\n \t      }\n-\t    else\n+\t    for (i = 0; BINFO_BASE_ITERATE (binfo, i, child); i++)\n \t      {\n-\t\t/* Print out the base class information with fields\n-\t\t   which have the same names at the types they hold.  */\n-\t\tdbxout_type_name (BINFO_TYPE (child));\n-\t\tputc (':', asmfile);\n-\t\tCHARS (1);\n-\t\tdbxout_type (BINFO_TYPE (child), full);\n-\t\tputc (',', asmfile);\n-\t\tCHARS (1);\n-\t\tprint_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n-\t\t\t\t* BITS_PER_UNIT);\n-\t\tputc (',', asmfile);\n-\t\tCHARS (1);\n-\t\tprint_wide_int (tree_low_cst (TYPE_SIZE (BINFO_TYPE (child)),\n-\t\t\t\t\t      0)\n-\t\t\t\t* BITS_PER_UNIT);\n-\t\tputc (';', asmfile);\n-\t\tCHARS (1);\n+\t\ttree access = (BINFO_BASE_ACCESSES (binfo)\n+\t\t\t       ? BINFO_BASE_ACCESS (binfo, i)\n+\t\t\t       : access_public_node);\n+\n+\t\tif (use_gnu_debug_info_extensions)\n+\t\t  {\n+\t\t    have_used_extensions = 1;\n+\t\t    putc (BINFO_VIRTUAL_P (child) ? '1' : '0', asmfile);\n+\t\t    putc (access == access_public_node ? '2' :\n+\t\t\t  (access == access_protected_node ? '1' :'0'),\n+\t\t\t  asmfile);\n+\t\t    CHARS (2);\n+\t\t    if (BINFO_VIRTUAL_P (child)\n+\t\t\t&& strcmp (lang_hooks.name, \"GNU C++\") == 0)\n+\t\t      /* For a virtual base, print the (negative)\n+\t\t     \t offset within the vtable where we must look\n+\t\t     \t to find the necessary adjustment.  */\n+\t\t      print_wide_int\n+\t\t\t(tree_low_cst (BINFO_VPTR_FIELD (child), 0)\n+\t\t\t * BITS_PER_UNIT);\n+\t\t    else\n+\t\t      print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t\t      * BITS_PER_UNIT);\n+\t\t    putc (',', asmfile);\n+\t\t    CHARS (1);\n+\t\t    dbxout_type (BINFO_TYPE (child), 0);\n+\t\t    putc (';', asmfile);\n+\t\t    CHARS (1);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Print out the base class information with\n+\t\t       fields which have the same names at the types\n+\t\t       they hold.  */\n+\t\t    dbxout_type_name (BINFO_TYPE (child));\n+\t\t    putc (':', asmfile);\n+\t\t    CHARS (1);\n+\t\t    dbxout_type (BINFO_TYPE (child), full);\n+\t\t    putc (',', asmfile);\n+\t\t    CHARS (1);\n+\t\t    print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t\t    * BITS_PER_UNIT);\n+\t\t    putc (',', asmfile);\n+\t\t    CHARS (1);\n+\t\t    print_wide_int\n+\t\t      (tree_low_cst (TYPE_SIZE (BINFO_TYPE (child)), 0)\n+\t\t       * BITS_PER_UNIT);\n+\t\t    putc (';', asmfile);\n+\t\t    CHARS (1);\n+\t\t  }\n \t      }\n \t  }\n       }"}, {"sha": "f9509e44c6ef33fed1aa60c2d4a3c6338ad0cee8", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -747,32 +747,33 @@ list.  Implicitly declared functions (including default constructors,\n copy constructors, assignment operators, and destructors) will appear on\n this list as well.\n \n-@c under reconstruction 2004-07-01, FIXME:Nathan Sidwell\n-[Binfos are being redesigned, this information is in a state of flux.]\n Every class has an associated @dfn{binfo}, which can be obtained with\n @code{TYPE_BINFO}.  Binfos are used to represent base-classes.  The\n binfo given by @code{TYPE_BINFO} is the degenerate case, whereby every\n-class is considered to be its own base-class.  The base classes for a\n-particular binfo can be obtained with @code{BINFO_BASETYPES}.  These\n-base-classes are themselves binfos.  The class type associated with a\n-binfo is given by @code{BINFO_TYPE}.  It is always the case that\n-@code{BINFO_TYPE (TYPE_BINFO (x))} is the same type as @code{x}, up to\n-qualifiers.  However, it is not always the case that @code{TYPE_BINFO\n-(BINFO_TYPE (y))} is always the same binfo as @code{y}.  The reason is\n-that if @code{y} is a binfo representing a base-class @code{B} of a\n-derived class @code{D}, then @code{BINFO_TYPE (y)} will be @code{B},\n-and @code{TYPE_BINFO (BINFO_TYPE (y))} will be @code{B} as its own\n-base-class, rather than as a base-class of @code{D}.\n-\n-The @code{BINFO_BASETYPES} is a @code{TREE_VEC} (@pxref{Containers}).\n-Base types appear in left-to-right order in this vector.  You can tell\n-whether or @code{public}, @code{protected}, or @code{private}\n-inheritance was used by using the @code{TREE_VIA_PUBLIC},\n-@code{TREE_VIA_PROTECTED}, and @code{TREE_VIA_PRIVATE} macros.  Each of\n-these macros takes a @code{BINFO} and is true if and only if the\n-indicated kind of inheritance was used.  If @code{TREE_VIA_VIRTUAL}\n-holds of a binfo, then its @code{BINFO_TYPE} was inherited from\n-virtually.\n+class is considered to be its own base-class.  The base binfos for a\n+particular binfo are held in a vector, whose length is obtained with\n+@code{BINFO_N_BASE_BINFOS}.  The base binfos themselves are obtained\n+with @code{BINFO_BASE_BINFO} and @code{BINFO_BASE_ITERATE}.  To add a\n+new binfo, use @code{BINFO_BASE_APPEND}.  The vector of base binfos can\n+be obtained with @code{BINFO_BASE_BINFOS}, but normally you do not need\n+to use that.  The class type associated with a binfo is given by\n+@code{BINFO_TYPE}.  It is not always the case that @code{BINFO_TYPE\n+(TYPE_BINFO (x))}, because of typedefs and qualified types.  Neither is\n+it the case that @code{TYPE_BINFO (BINFO_TYPE (y))} is the same binfo as\n+@code{y}.  The reason is that if @code{y} is a binfo representing a\n+base-class @code{B} of a derived class @code{D}, then @code{BINFO_TYPE\n+(y)} will be @code{B}, and @code{TYPE_BINFO (BINFO_TYPE (y))} will be\n+@code{B} as its own base-class, rather than as a base-class of @code{D}.\n+\n+The access to a base type can be found with @code{BINFO_BASE_ACCESS}.\n+This will produce @code{access_public_node}, @code{access_private_node}\n+or @code{access_protected_node}.  If bases are always public,\n+@code{BINFO_BASE_ACCESSES} may be @code{NULL}.\n+\n+@code{BINFO_VIRTUAL_P} is used to specify whether the binfo is inherited\n+virtually or not.  The other flags, @code{BINFO_MARKED_P} and\n+@code{BINFO_FLAG_1} to @code{BINFO_FLAG_6} can be used for language\n+specific use.\n \n The following macros can be used on a tree node representing a class-type.\n "}, {"sha": "736f31cd4013b255a79bfc5254ddda0abf279b7c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -11891,15 +11891,14 @@ gen_member_die (tree type, dw_die_ref context_die)\n      the TREE node representing the appropriate (containing) type.  */\n \n   /* First output info about the base classes.  */\n-  if (binfo && BINFO_BASE_BINFOS (binfo))\n+  if (binfo)\n     {\n-      tree bases = BINFO_BASE_BINFOS (binfo);\n       tree accesses = BINFO_BASE_ACCESSES (binfo);\n-      int n_bases = TREE_VEC_LENGTH (bases);\n       int i;\n+      tree base;\n \n-      for (i = 0; i < n_bases; i++)\n-\tgen_inheritance_die (TREE_VEC_ELT (bases, i),\n+      for (i = 0; BINFO_BASE_ITERATE (binfo, i, base); i++)\n+\tgen_inheritance_die (base,\n \t\t\t     (accesses ? TREE_VEC_ELT (accesses, i)\n \t\t\t      : access_public_node), context_die);\n     }"}, {"sha": "b2322fdb95cb5c34455360a7f3eaf7e865847321", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -1,3 +1,22 @@\n+2004-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (add_interface_do): Remove.\n+\t(set_super_info, interface_of_p, maybe_add_interface,\n+\tadd_interface, make_class_data, layout_class,\n+\tadd_miranda_methods): Adjust BINFO accessors and addition.\n+\t* expr.c (can_widen_reference_to, lookup_field): Adjust BINFO\n+\taccessors.\n+\t* jcf-write.c (generate_classfile): Likewise.\n+\t* parse.y (patch_anonymous_class, check_inner_circular_reference,\n+\tcheck_circular_reference, java_complete_class,\n+\tcheck_abstract_method_definitions,\n+\tjava_check_abstract_method_definitions,\n+\tcheck_interface_throws_clauses, java_check_abstract_methods,\n+\tlookup_java_interface_method2,\n+\tfind_applicable_accessible_methods_list): Adjust BINFO accessors\n+\tand addition.\n+\t* typeck.c (find_method_in_interfaces): Adjust BINFO accessors.\n+\n 2004-07-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (max_builtin, min_builtin,"}, {"sha": "82ae8224c793d3dc7b42a50745510142ad55b9cd", "filename": "gcc/java/class.c", "status": "modified", "additions": 52, "deletions": 89, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -57,7 +57,6 @@ static tree make_field_value (tree);\n static tree get_dispatch_vector (tree);\n static tree get_dispatch_table (tree, tree);\n static int supers_all_compiled (tree type);\n-static void add_interface_do (tree, tree, int);\n static tree maybe_layout_super_class (tree, tree);\n static void add_miranda_methods (tree, tree);\n static int assume_compiled (const char *);\n@@ -476,16 +475,14 @@ set_super_info (int access_flags, tree this_class,\n   if (super_class)\n     total_supers++;\n \n-  TYPE_BINFO (this_class) = make_tree_binfo (0);\n+  TYPE_BINFO (this_class) = make_tree_binfo (total_supers);\n   TYPE_VFIELD (this_class) = TYPE_VFIELD (object_type_node);\n-  BINFO_BASE_BINFOS (TYPE_BINFO (this_class)) = make_tree_vec (total_supers);\n   if (super_class)\n     {\n       tree super_binfo = make_tree_binfo (0);\n       BINFO_TYPE (super_binfo) = super_class;\n       BINFO_OFFSET (super_binfo) = integer_zero_node;\n-      TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (this_class)), 0)\n-\t= super_binfo;\n+      BINFO_BASE_APPEND (TYPE_BINFO (this_class), super_binfo);\n       CLASS_HAS_SUPER_FLAG (TYPE_BINFO (this_class)) = 1;\n     }\n \n@@ -530,26 +527,23 @@ class_depth (tree clas)\n int\n interface_of_p (tree type1, tree type2)\n {\n-  int n, i;\n-  tree basetype_vec;\n+  int i;\n+  tree binfo, base_binfo;\n \n   if (! TYPE_BINFO (type2))\n     return 0;\n-  basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (type2));\n-  n = TREE_VEC_LENGTH (basetype_vec);\n-  for (i = 0; i < n; i++)\n-    {\n-      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n-      if (vec_elt && BINFO_TYPE (vec_elt) == type1)\n-\treturn 1;\n-    }\n-  for (i = 0; i < n; i++)\n-    {\n-      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n-      if (vec_elt && BINFO_TYPE (vec_elt) \n-\t  && interface_of_p (type1, BINFO_TYPE (vec_elt)))\n-\treturn 1;\n-    }\n+\n+  for (binfo = TYPE_BINFO (type2), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    if (BINFO_TYPE (base_binfo) == type1)\n+      return 1;\n+  \n+  for (binfo = TYPE_BINFO (type2), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++) /*  */\n+    if (BINFO_TYPE (base_binfo)\n+\t&& interface_of_p (type1, BINFO_TYPE (base_binfo)))\n+      return 1;\n+  \n   return 0;\n }\n \n@@ -636,40 +630,21 @@ common_enclosing_instance_p (tree type1, tree type2)\n   return 0;\n }\n \n-static void\n-add_interface_do (tree basetype_vec, tree interface_class, int i)\n-{\n-  tree interface_binfo = make_tree_binfo (0);\n-  BINFO_TYPE (interface_binfo) = interface_class;\n-  BINFO_OFFSET (interface_binfo) = integer_zero_node;\n-  BINFO_VPTR_FIELD (interface_binfo) = integer_zero_node;\n-  BINFO_VIRTUAL_P (interface_binfo) = 1;\n-  TREE_VEC_ELT (basetype_vec, i) = interface_binfo;\n-}\n-\n /* Add INTERFACE_CLASS to THIS_CLASS iff INTERFACE_CLASS can't be\n    found in THIS_CLASS. Returns NULL_TREE upon success, INTERFACE_CLASS\n    if attempt is made to add it twice. */\n \n tree\n maybe_add_interface (tree this_class, tree interface_class)\n {\n-  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (this_class));\n+  tree binfo, base_binfo;\n   int i;\n-  int n = TREE_VEC_LENGTH (basetype_vec);\n-  for (i = 0; ; i++)\n-    {\n-      if (i >= n)\n-\t{\n-\t  error (\"internal error - too many interface type\");\n-\t  return NULL_TREE;\n-\t}\n-      else if (TREE_VEC_ELT (basetype_vec, i) == NULL_TREE)\n-\tbreak;\n-      else if (BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i)) == interface_class)\n-\treturn interface_class;\n-    } \n-  add_interface_do (basetype_vec, interface_class, i);\n+\n+  for (binfo = TYPE_BINFO (this_class), i = 0;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    if (BINFO_TYPE (base_binfo) == interface_class)\n+      return interface_class;\n+  add_interface (this_class, interface_class);\n   return NULL_TREE;\n }\n \n@@ -678,20 +653,14 @@ maybe_add_interface (tree this_class, tree interface_class)\n void\n add_interface (tree this_class, tree interface_class)\n {\n-  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (this_class));\n-  int i;\n-  int n = TREE_VEC_LENGTH (basetype_vec);\n-  for (i = 0; ; i++)\n-    {\n-      if (i >= n)\n-\t{\n-\t  error (\"internal error - too many interface type\");\n-\t  return;\n-\t}\n-      else if (TREE_VEC_ELT (basetype_vec, i) == NULL_TREE)\n-\tbreak;\n-    }\n-  add_interface_do (basetype_vec, interface_class, i);\n+  tree interface_binfo = make_tree_binfo (0);\n+  \n+  BINFO_TYPE (interface_binfo) = interface_class;\n+  BINFO_OFFSET (interface_binfo) = integer_zero_node;\n+  BINFO_VPTR_FIELD (interface_binfo) = integer_zero_node;\n+  BINFO_VIRTUAL_P (interface_binfo) = 1;\n+  \n+  BINFO_BASE_APPEND (TYPE_BINFO (this_class), interface_binfo);\n }\n \n #if 0\n@@ -1666,9 +1635,10 @@ make_class_data (tree type)\n \t= build_prim_array_type (class_ptr_type, interface_len);\n       idecl = build_decl (VAR_DECL, mangled_classname (\"_IF_\", type),\n \t\t\t  interface_array_type);\n+      \n       for (i = interface_len;  i > 0; i--)\n \t{\n-\t  tree child = TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (type)), i);\n+\t  tree child = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n \t  tree iclass = BINFO_TYPE (child);\n \t  tree index;\n \t  if (! flag_indirect_dispatch\n@@ -2063,27 +2033,21 @@ layout_class (tree this_class)\n      of this itself.  */\n   if (!CLASS_FROM_SOURCE_P (this_class))\n     {\n-      tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (this_class));\n-\n-      if (basetype_vec)\n+      int i;\n+      \n+      for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (this_class)) - 1; i > 0; i--)\n \t{\n-\t  int n = TREE_VEC_LENGTH (basetype_vec) - 1;\n-\t  int i;\n-\t  for (i = n; i > 0; i--)\n+\t  tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (this_class), i);\n+\t  tree super_interface = BINFO_TYPE (binfo);\n+\t  tree maybe_super_interface \n+\t    = maybe_layout_super_class (super_interface, NULL_TREE);\n+\t  if (maybe_super_interface == NULL\n+\t      || TREE_CODE (TYPE_SIZE (maybe_super_interface)) == ERROR_MARK)\n \t    {\n-\t      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n-\t      tree super_interface = BINFO_TYPE (vec_elt);\n-\n-\t      tree maybe_super_interface \n-\t\t= maybe_layout_super_class (super_interface, NULL_TREE);\n-\t      if (maybe_super_interface == NULL\n-\t\t  || TREE_CODE (TYPE_SIZE (maybe_super_interface)) == ERROR_MARK)\n-\t\t{\n-\t\t  TYPE_SIZE (this_class) = error_mark_node;\n-\t\t  CLASS_BEING_LAIDOUT (this_class) = 0;\n-\t\t  class_list = TREE_CHAIN (class_list);\n-\t\t  return;\n-\t\t}\n+\t      TYPE_SIZE (this_class) = error_mark_node;\n+\t      CLASS_BEING_LAIDOUT (this_class) = 0;\n+\t      class_list = TREE_CHAIN (class_list);\n+\t      return;\n \t    }\n \t}\n     }\n@@ -2099,15 +2063,14 @@ layout_class (tree this_class)\n static void\n add_miranda_methods (tree base_class, tree search_class)\n {\n-  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (search_class));\n-  int i, n = TREE_VEC_LENGTH (basetype_vec);\n-  for (i = 1; i < n; ++i)\n+  tree binfo, base_binfo;\n+  int i;\n+  \n+  for (binfo = TYPE_BINFO (search_class), i = 1;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n       tree method_decl;\n-      tree elt = TREE_VEC_ELT (basetype_vec, i);\n-      if (elt == NULL_TREE)\n-\tbreak;\n-      elt = BINFO_TYPE (elt);\n+      tree elt = BINFO_TYPE (base_binfo);\n \n       /* Ensure that interface methods are seen in declared order.  */\n       layout_class_methods (elt);"}, {"sha": "228c1d16a4ad7c63edb8fc642f26a56e9e6ca392", "filename": "gcc/java/expr.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -426,15 +426,16 @@ can_widen_reference_to (tree source_type, tree target_type)\n \t    {\n \t      /* target_type is OK if source_type or source_type ancestors\n \t\t implement target_type. We handle multiple sub-interfaces  */\n+\t      tree binfo, base_binfo;\n+\t      int i;\n \n-\t      tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (source_type));\n-\t      int n = TREE_VEC_LENGTH (basetype_vec), i;\n-\t      for (i=0 ; i < n; i++)\n-\t        if (can_widen_reference_to \n-\t\t    (TREE_TYPE (TREE_VEC_ELT (basetype_vec, i)),\n-\t\t     target_type))\n+\t      for (binfo = TYPE_BINFO (source_type), i = 0;\n+\t\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t        if (can_widen_reference_to\n+\t\t    (BINFO_TYPE (base_binfo), target_type))\n \t\t  return 1;\n-\t      if (n == 0)\n+\t      \n+\t      if (!i)\n \t\treturn 0;\n \t    }\n \n@@ -1459,21 +1460,20 @@ lookup_field (tree *typep, tree name)\n     }\n   do\n     {\n-      tree field, basetype_vec;\n+      tree field, binfo, base_binfo;\n       tree save_field;\n-      int n, i;\n+      int i;\n \n       for (field = TYPE_FIELDS (*typep); field; field = TREE_CHAIN (field))\n \tif (DECL_NAME (field) == name)\n \t  return field;\n \n       /* Process implemented interfaces. */\n-      basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (*typep));\n-      n = TREE_VEC_LENGTH (basetype_vec);\n       save_field = NULL_TREE;\n-      for (i = 0; i < n; i++)\n+      for (binfo = TYPE_BINFO (*typep), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n-\t  tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n+\t  tree t = BINFO_TYPE (base_binfo);\n \t  if ((field = lookup_field (&t, name)))\n \t    {\n \t      if (save_field == field)"}, {"sha": "a73b7be83dc6d50072c1809a3e7dc1dac4153f9d", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -2963,15 +2963,15 @@ generate_classfile (tree clas, struct jcf_partial *state)\n     }\n   else\n     {\n-      tree basetypes = BINFO_BASE_BINFOS (TYPE_BINFO (clas));\n-      tree base = BINFO_TYPE (TREE_VEC_ELT (basetypes, 0));\n-      int j = find_class_constant (&state->cpool, base);\n+      tree binfo = TYPE_BINFO (clas);\n+      tree base_binfo = BINFO_BASE_BINFO (binfo, 0);\n+      int j = find_class_constant (&state->cpool, BINFO_TYPE (base_binfo));\n+      \n       PUT2 (j);  /* super_class */\n       PUT2 (total_supers - 1);  /* interfaces_count */\n-      for (i = 1;  i < total_supers;  i++)\n+      for (i = 1; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n-\t  base = BINFO_TYPE (TREE_VEC_ELT (basetypes, i));\n-\t  j = find_class_constant (&state->cpool, base);\n+\t  j = find_class_constant (&state->cpool, BINFO_TYPE (base_binfo));\n \t  PUT2 (j);\n \t}\n     }"}, {"sha": "2f41b1b4f3a033d81b87d10d0913e885d3bf233f", "filename": "gcc/java/parse.y", "status": "modified", "additions": 73, "deletions": 87, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -3879,16 +3879,24 @@ patch_anonymous_class (tree type_decl, tree class_decl, tree wfl)\n   /* If it's an interface, implement it */\n   if (CLASS_INTERFACE (type_decl))\n     {\n-      tree s_binfo;\n-      int length;\n-\n       if (parser_check_super_interface (type_decl, class_decl, wfl))\n \treturn;\n \n-      s_binfo = TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (class)), 0);\n-      length = TREE_VEC_LENGTH (BINFO_BASE_BINFOS (TYPE_BINFO (class)))+1;\n-      BINFO_BASE_BINFOS (TYPE_BINFO (class)) = make_tree_vec (length);\n-      TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (class)), 0) = s_binfo;\n+      if (VEC_space (tree, BINFO_BASE_BINFOS (binfo), 1))\n+\t{\n+\t   /* Extend the binfo - by reallocating and copying it. */\n+\t  tree new_binfo;\n+\t  tree base_binfo;\n+\t  int i;\n+\t  \n+\t  new_binfo = make_tree_binfo ((BINFO_N_BASE_BINFOS (binfo) + 1) * 2);\n+\t  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t    BINFO_BASE_APPEND (new_binfo, base_binfo);\n+\t  CLASS_HAS_SUPER_FLAG (new_binfo) = CLASS_HAS_SUPER_FLAG (binfo);\n+\t  BINFO_VTABLE (new_binfo) = BINFO_VTABLE (binfo);\n+\t  TYPE_BINFO (class) = new_binfo;\n+\t}\n+      \n       /* And add the interface */\n       parser_add_interface (class_decl, type_decl, wfl);\n     }\n@@ -3897,7 +3905,7 @@ patch_anonymous_class (tree type_decl, tree class_decl, tree wfl)\n     {\n       if (parser_check_super (type_decl, class_decl, wfl))\n \treturn;\n-      BINFO_TYPE (TREE_VEC_ELT (BINFO_BASE_BINFOS (binfo), 0)) = type;\n+      BINFO_TYPE (BINFO_BASE_BINFO (binfo, 0)) = type;\n     }\n }\n \n@@ -5213,23 +5221,18 @@ register_incomplete_type (int kind, tree wfl, tree decl, tree ptr)\n static tree\n check_inner_circular_reference (tree source, tree target)\n {\n-  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (source));\n+  tree base_binfo;\n   tree ctx, cl;\n   int i;\n \n-  if (!basetype_vec)\n-    return NULL_TREE;\n-\n-  for (i = 0; i < TREE_VEC_LENGTH (basetype_vec); i++)\n+  for (i = 0; BINFO_BASE_ITERATE (TYPE_BINFO (source), i, base_binfo); i++)\n     {\n       tree su;\n \n       /* We can end up with a NULL_TREE or an incomplete type here if\n \t we encountered previous type resolution errors. It's safe to\n \t simply ignore these cases.  */\n-      if (TREE_VEC_ELT (basetype_vec, i) == NULL_TREE)\n-\tcontinue;\n-      su = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n+      su = BINFO_TYPE (base_binfo);\n       if (INCOMPLETE_TYPE_P (su))\n \tcontinue;\n \n@@ -5259,10 +5262,10 @@ check_inner_circular_reference (tree source, tree target)\n static tree\n check_circular_reference (tree type)\n {\n-  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n+  tree base_binfo;\n   int i;\n \n-  if (!basetype_vec)\n+  if (!BINFO_N_BASE_BINFOS (TYPE_BINFO (type)))\n     return NULL_TREE;\n \n   if (! CLASS_INTERFACE (TYPE_NAME (type)))\n@@ -5272,12 +5275,11 @@ check_circular_reference (tree type)\n       return NULL_TREE;\n     }\n \n-  for (i = 0; i < TREE_VEC_LENGTH (basetype_vec); i++)\n+  for (i = 0; BINFO_BASE_ITERATE (TYPE_BINFO (type), i, base_binfo); i++)\n     {\n-      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n-      if (vec_elt && BINFO_TYPE (vec_elt) != object_type_node\n-\t  && interface_of_p (type, BINFO_TYPE (vec_elt)))\n-\treturn lookup_cl (TYPE_NAME (BINFO_TYPE (vec_elt)));\n+      if (BINFO_TYPE (base_binfo) != object_type_node\n+\t  && interface_of_p (type, BINFO_TYPE (base_binfo)))\n+\treturn lookup_cl (TYPE_NAME (BINFO_TYPE (base_binfo)));\n     }\n   return NULL_TREE;\n }\n@@ -5569,8 +5571,9 @@ java_complete_class (void)\n \t      /* Simply patch super */\n \t      if (parser_check_super (decl, JDEP_DECL (dep), JDEP_WFL (dep)))\n \t\tcontinue;\n-\t      BINFO_TYPE (TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO\n-\t        (TREE_TYPE (JDEP_DECL (dep)))), 0)) = TREE_TYPE (decl);\n+\t      BINFO_TYPE (BINFO_BASE_BINFO\n+\t\t\t  (TYPE_BINFO (TREE_TYPE (JDEP_DECL (dep))), 0))\n+\t\t= TREE_TYPE (decl);\n \t      break;\n \n \t    case JDEP_FIELD:\n@@ -6198,12 +6201,13 @@ check_abstract_method_definitions (int do_interface, tree class_decl,\n     {\n       /* Check for implemented interfaces. */\n       int i;\n-      tree vector = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n-      for (i = 1; ok && vector && i < TREE_VEC_LENGTH (vector); i++)\n-\t{\n-\t  tree super = BINFO_TYPE (TREE_VEC_ELT (vector, i));\n-\t  ok = check_abstract_method_definitions (1, class_decl, super);\n-\t}\n+      tree base_binfo;\n+      \n+      for (i = 1;\n+\t   ok && BINFO_BASE_ITERATE (TYPE_BINFO (type), i, base_binfo);\n+\t   i++)\n+\tok = check_abstract_method_definitions (1, class_decl,\n+\t\t\t\t\t\tBINFO_TYPE (base_binfo));\n     }\n \n   return ok;\n@@ -6216,7 +6220,7 @@ static void\n java_check_abstract_method_definitions (tree class_decl)\n {\n   tree class = TREE_TYPE (class_decl);\n-  tree super, vector;\n+  tree super, base_binfo;\n   int i;\n \n   if (CLASS_ABSTRACT (class_decl))\n@@ -6230,12 +6234,8 @@ java_check_abstract_method_definitions (tree class_decl)\n   } while (super != object_type_node);\n \n   /* Check for implemented interfaces. */\n-  vector = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n-  for (i = 1; i < TREE_VEC_LENGTH (vector); i++)\n-    {\n-      super = BINFO_TYPE (TREE_VEC_ELT (vector, i));\n-      check_abstract_method_definitions (1, class_decl, super);\n-    }\n+  for (i = 1; BINFO_BASE_ITERATE (TYPE_BINFO (class), i, base_binfo); i++)\n+    check_abstract_method_definitions (1, class_decl, BINFO_TYPE (base_binfo));\n }\n \n /* Check all the types method DECL uses and return 1 if all of them\n@@ -6493,8 +6493,6 @@ check_interface_throws_clauses (tree check_class_decl, tree class_decl)\n {\n   for (; class_decl != NULL_TREE; class_decl = CLASSTYPE_SUPER (class_decl))\n     {\n-      tree bases;\n-      int iface_len;\n       int i;\n \n       if (! CLASS_LOADED_P (class_decl))\n@@ -6505,11 +6503,10 @@ check_interface_throws_clauses (tree check_class_decl, tree class_decl)\n \t    load_class (class_decl, 1);\n \t}\n \n-      bases = BINFO_BASE_BINFOS (TYPE_BINFO (class_decl));\n-      iface_len = TREE_VEC_LENGTH (bases) - 1;\n-      for (i = iface_len; i > 0; --i)\n+      for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (class_decl)) - 1; i > 0; --i)\n \t{\n-\t  tree interface = BINFO_TYPE (TREE_VEC_ELT (bases, i));\n+\t  tree interface\n+\t    = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (class_decl), i));\n \t  tree iface_method;\n \n \t  for (iface_method = TYPE_METHODS (interface);\n@@ -6609,9 +6606,10 @@ check_throws_clauses (tree method, tree method_wfl, tree found)\n static void\n java_check_abstract_methods (tree interface_decl)\n {\n-  int i, n;\n-  tree method, basetype_vec, found;\n+  int i;\n+  tree method, found;\n   tree interface = TREE_TYPE (interface_decl);\n+  tree base_binfo;\n \n   for (method = TYPE_METHODS (interface); method; method = TREE_CHAIN (method))\n     {\n@@ -6637,16 +6635,11 @@ java_check_abstract_methods (tree interface_decl)\n     }\n \n   /* 4- Inherited methods can't differ by their returned types */\n-  if (!(basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (interface))))\n-    return;\n-  n = TREE_VEC_LENGTH (basetype_vec);\n-  for (i = 0; i < n; i++)\n+  for (i = 0; BINFO_BASE_ITERATE (TYPE_BINFO (interface), i, base_binfo); i++)\n     {\n       tree sub_interface_method, sub_interface;\n-      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n-      if (!vec_elt)\n-\tcontinue;\n-      sub_interface = BINFO_TYPE (vec_elt);\n+\n+      sub_interface = BINFO_TYPE (base_binfo);\n       for (sub_interface_method = TYPE_METHODS (sub_interface);\n \t   sub_interface_method;\n \t   sub_interface_method = TREE_CHAIN (sub_interface_method))\n@@ -6676,26 +6669,21 @@ java_check_abstract_methods (tree interface_decl)\n static tree\n lookup_java_interface_method2 (tree class, tree method_decl)\n {\n-  int i, n;\n-  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n+  int i;\n+  tree base_binfo;\n   tree to_return;\n \n-  if (!basetype_vec)\n-    return NULL_TREE;\n-\n-  n = TREE_VEC_LENGTH (basetype_vec);\n-  for (i = 0; i < n; i++)\n+  for (i = 0; BINFO_BASE_ITERATE (TYPE_BINFO (class), i, base_binfo); i++)\n     {\n-      tree vec_elt = TREE_VEC_ELT (basetype_vec, i), to_return;\n-      if ((BINFO_TYPE (vec_elt) != object_type_node)\n+      if ((BINFO_TYPE (base_binfo) != object_type_node)\n \t  && (to_return =\n-\t      lookup_java_method2 (BINFO_TYPE (vec_elt), method_decl, 1)))\n+\t      lookup_java_method2 (BINFO_TYPE (base_binfo), method_decl, 1)))\n \treturn to_return;\n     }\n-  for (i = 0; i < n; i++)\n+  for (i = 0; BINFO_BASE_ITERATE (TYPE_BINFO (class), i, base_binfo); i++)\n     {\n       to_return = lookup_java_interface_method2\n-\t(BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i)), method_decl);\n+\t(BINFO_TYPE (base_binfo), method_decl);\n       if (to_return)\n \treturn to_return;\n     }\n@@ -10984,6 +10972,8 @@ find_applicable_accessible_methods_list (int lc, tree class, tree name,\n   static htab_t searched_classes;\n   static int search_not_done = 0;\n   tree list = NULL_TREE, all_list = NULL_TREE;\n+  tree base_binfo;\n+  int i;\n \n   /* Check the hash table to determine if this class has been searched\n      already. */\n@@ -11011,16 +11001,13 @@ find_applicable_accessible_methods_list (int lc, tree class, tree name,\n   if (TREE_CODE (TYPE_NAME (class)) == TYPE_DECL\n       && CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n-      int i, n;\n-      tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n       search_applicable_methods_list (lc, TYPE_METHODS (class),\n \t\t\t\t      name, arglist, &list, &all_list);\n-      n = TREE_VEC_LENGTH (basetype_vec);\n-      for (i = 1; i < n; i++)\n+      for (i = 1; BINFO_BASE_ITERATE (TYPE_BINFO (class), i, base_binfo); i++)\n \t{\n-\t  tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n+\t  tree t = BINFO_TYPE (base_binfo);\n \t  tree rlist;\n-\n+\t  \n \t  rlist = find_applicable_accessible_methods_list (lc,  t, name,\n \t\t\t\t\t\t\t   arglist);\n \t  list = chainon (rlist, list);\n@@ -11044,21 +11031,20 @@ find_applicable_accessible_methods_list (int lc, tree class, tree name,\n \n       /* We must search all interfaces of this class */\n       if (!lc)\n-      {\n-\ttree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n-\tint n = TREE_VEC_LENGTH (basetype_vec), i;\n-\tfor (i = 1; i < n; i++)\n-\t  {\n-\t    tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n-\t    if (t != object_type_node)\n-\t      {\n-\t\ttree rlist\n-\t\t  = find_applicable_accessible_methods_list (lc, t,\n-\t\t\t\t\t\t\t     name, arglist);\n-\t\tlist = chainon (rlist, list);\n-\t      }\n-\t  }\n-      }\n+\t{\n+\t  for (i = 1;\n+\t       BINFO_BASE_ITERATE (TYPE_BINFO (class), i, base_binfo); i++)\n+\t    {\n+\t      tree t = BINFO_TYPE (base_binfo);\n+\t      if (t != object_type_node)\n+\t\t{\n+\t\t  tree rlist\n+\t\t    = find_applicable_accessible_methods_list (lc, t,\n+\t\t\t\t\t\t\t       name, arglist);\n+\t\t  list = chainon (rlist, list);\n+\t\t}\n+\t    }\n+\t}\n \n       /* Search superclass */\n       if (!lc && CLASSTYPE_SUPER (class) != NULL_TREE)"}, {"sha": "0e6e404a3620067353118740360e5d090c9b9d94", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -796,13 +796,12 @@ find_method_in_interfaces (tree searched_class, int flags, tree method_name,\n                            tree signature, tree (*signature_builder) (tree))\n {\n   int i;\n-  int interface_len = \n-    TREE_VEC_LENGTH (BINFO_BASE_BINFOS (TYPE_BINFO (searched_class))) - 1;\n+  tree binfo, base_binfo;\n \n-  for (i = interface_len; i > 0; i--)\n+  for (binfo = TYPE_BINFO (searched_class), i = 1;\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      tree child = BINFO_BASE_BINFO (TYPE_BINFO (searched_class), i);\n-      tree iclass = BINFO_TYPE (child);\n+      tree iclass = BINFO_TYPE (base_binfo);\n       tree method;\n \t  \n       /* If the superinterface hasn't been loaded yet, do so now.  */\n@@ -814,7 +813,7 @@ find_method_in_interfaces (tree searched_class, int flags, tree method_name,\n       /* First, we look in ICLASS.  If that doesn't work we'll\n \t recursively look through all its superinterfaces.  */\n       method = shallow_find_method (iclass, flags, method_name, \n-\t\t\t\t\t signature, signature_builder);      \n+\t\t\t\t    signature, signature_builder);      \n       if (method != NULL_TREE)\n \treturn method;\n   "}, {"sha": "ef254888f3515b81cf85af968b700568f723ecdb", "filename": "gcc/sdbout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -1109,7 +1109,6 @@ sdbout_one_type (tree type)\n \tint size = int_size_in_bytes (type);\n \tint member_scl = 0;\n \ttree tem;\n-\tint i, n_baseclasses = 0;\n \n \t/* Record the type tag, but not in its permanent place just yet.  */\n \tsdbout_record_type_name (type);\n@@ -1149,16 +1148,17 @@ sdbout_one_type (tree type)\n \t/* This is only relevant to aggregate types.  TYPE_BINFO is used\n \t   for other purposes in an ENUMERAL_TYPE, so we must exclude that\n \t   case.  */\n-\tif (TREE_CODE (type) != ENUMERAL_TYPE)\n+\tif (TREE_CODE (type) != ENUMERAL_TYPE && TYPE_BINFO (type))\n \t  {\n-\t    if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n-\t      n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n-\t    \n-\t    for (i = 0; i < n_baseclasses; i++)\n+\t    int i;\n+\t    tree binfo, child;\n+\n+\t    for (binfo = TYPE_BINFO (type), i = 0;\n+\t\t BINFO_BASE_ITERATE (binfo, i, child); i++)\n \t      {\n-\t\ttree child = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n \t\ttree child_type = BINFO_TYPE (child);\n \t\ttree child_type_name;\n+\t\t\n \t\tif (TYPE_NAME (child_type) == 0)\n \t\t  continue;\n \t\tif (TREE_CODE (TYPE_NAME (child_type)) == IDENTIFIER_NODE)"}, {"sha": "d17a8f827beda2107fc9c7ad0213e3a5ce7601eb", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -251,19 +251,17 @@ dequeue_and_dump (dump_info_p di)\n   if (dni->binfo_p)\n     {\n       unsigned ix;\n-      tree bases = BINFO_BASE_BINFOS (t);\n-      unsigned n_bases = bases ? TREE_VEC_LENGTH (bases): 0;\n+      tree base;\n       tree accesses = BINFO_BASE_ACCESSES (t);\n \n       dump_child (\"type\", BINFO_TYPE (t));\n \n       if (BINFO_VIRTUAL_P (t))\n \tdump_string (di, \"virt\");\n \n-      dump_int (di, \"bases\", n_bases);\n-      for (ix = 0; ix != n_bases; ix++)\n+      dump_int (di, \"bases\", BINFO_N_BASE_BINFOS (t));\n+      for (ix = 0; BINFO_BASE_ITERATE (t, ix, base); ix++)\n \t{\n-\t  tree base = TREE_VEC_ELT (bases, ix);\n \t  tree access = (accesses ? TREE_VEC_ELT (accesses, ix)\n \t\t\t : access_public_node);\n \t  const char *string = NULL;"}, {"sha": "b76b6288a5db86399724ecac88d25922eaaa4c2f", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -94,9 +94,6 @@ struct type_hash GTY(())\n   tree type;\n };\n \n-/* Additional language-dependent binfo slots.  */\n-unsigned binfo_lang_slots;\n-\n /* Initial size of the hash table (rounded to next prime).  */\n #define TYPE_HASH_INITIAL_SIZE 1000\n \n@@ -582,20 +579,11 @@ build_complex (tree type, tree real, tree imag)\n /* Build a BINFO with LEN language slots.  */\n \n tree\n-make_tree_binfo_stat (unsigned lang_slots MEM_STAT_DECL)\n+make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n {\n   tree t;\n-  static unsigned length;\n-  \n-  if (!length)\n-    {\n-      length = (offsetof (struct tree_binfo, lang_slots)\n-\t\t+ (sizeof (((struct tree_binfo *)0)->lang_slots[0])\n-\t\t   * lang_slots));\n-      binfo_lang_slots = lang_slots;\n-    }\n-  else if (binfo_lang_slots != lang_slots)\n-    abort ();\n+  size_t length = (offsetof (struct tree_binfo, base_binfos)\n+\t\t   + VEC_embedded_size (tree, base_binfos));\n   \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int) binfo_kind]++;\n@@ -604,9 +592,11 @@ make_tree_binfo_stat (unsigned lang_slots MEM_STAT_DECL)\n \n   t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n \n-  memset (t, 0, length);\n+  memset (t, 0, offsetof (struct tree_binfo, base_binfos));\n \n   TREE_SET_CODE (t, TREE_BINFO);\n+  \n+  VEC_embedded_init (tree, BINFO_BASE_BINFOS (t), base_binfos);\n \n   return t;\n }"}, {"sha": "32ede7256a7b02c4712ad88f2b96d09316eeb104", "filename": "gcc/tree.h", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa743e8cda25ba09a4731a3443df9e0e56e87581/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fa743e8cda25ba09a4731a3443df9e0e56e87581", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"machmode.h\"\n #include \"input.h\"\n #include \"statistics.h\"\n+#include \"vec.h\"\n \n /* Codes of tree nodes */\n \n@@ -74,6 +75,10 @@ extern const unsigned char tree_code_length[];\n /* Names of tree components.  */\n \n extern const char *const tree_code_name[];\n+\n+/* A vector of trees.  */\n+DEF_VEC_P(tree);\n+\n \f\n /* Classify which part of the compiler has defined a given builtin function.\n    Note that we assume below that this is no more than two bits.  */\n@@ -1641,20 +1646,19 @@ struct tree_type GTY(())\n \n    If this basetype describes type D as inherited in C, and if the\n    basetypes of D are E and F, then this vector contains binfos for\n-   inheritance of E and F by C.\n-\n-   ??? This could probably be done by just allocating the\n-   base types at the end of this TREE_VEC (instead of using\n-   another TREE_VEC).  This would simplify the calculation\n-   of how many basetypes a given type had.  */\n-#define BINFO_BASE_BINFOS(NODE) (TREE_BINFO_CHECK(NODE)->binfo.base_binfos)\n+   inheritance of E and F by C.  */\n+#define BINFO_BASE_BINFOS(NODE) (&TREE_BINFO_CHECK(NODE)->binfo.base_binfos)\n \n /* The number of basetypes for NODE.  */\n-#define BINFO_N_BASE_BINFOS(NODE) \\\n-  (BINFO_BASE_BINFOS (NODE) ? TREE_VEC_LENGTH (BINFO_BASE_BINFOS (NODE)) : 0)\n+#define BINFO_N_BASE_BINFOS(NODE) (VEC_length (tree, BINFO_BASE_BINFOS (NODE)))\n \n /* Accessor macro to get to the Nth base binfo of this binfo.  */\n-#define BINFO_BASE_BINFO(NODE,N) TREE_VEC_ELT (BINFO_BASE_BINFOS (NODE), (N))\n+#define BINFO_BASE_BINFO(NODE,N) \\\n+ (VEC_index (tree, BINFO_BASE_BINFOS (NODE), (N)))\n+#define BINFO_BASE_ITERATE(NODE,N,B) \\\n+ (VEC_iterate (tree, BINFO_BASE_BINFOS (NODE), (N), (B)))\n+#define BINFO_BASE_APPEND(NODE,T) \\\n+ (VEC_quick_push (tree, BINFO_BASE_BINFOS (NODE), (T)))\n \n /* For a BINFO record describing a virtual base class, i.e., one where\n    TREE_VIA_VIRTUAL is set, this field assists in locating the virtual\n@@ -1669,10 +1673,19 @@ struct tree_type GTY(())\n #define BINFO_BASE_ACCESSES(NODE) (TREE_BINFO_CHECK(NODE)->binfo.base_accesses)\n #define BINFO_BASE_ACCESS(NODE,N) TREE_VEC_ELT (BINFO_BASE_ACCESSES(NODE), (N))\n \n-/* Number of language independent elements in a binfo.  Languages may\n-   add additional trailing elements.  */\n+/* The index in the VTT where this subobject's sub-VTT can be found.\n+   NULL_TREE if there is no sub-VTT.  */\n+#define BINFO_SUBVTT_INDEX(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vtt_subvtt)\n \n-#define BINFO_LANG_SLOT(NODE,N) (TREE_BINFO_CHECK(NODE)->binfo.lang_slots[N])\n+/* The index in the VTT where the vptr for this subobject can be\n+   found.  NULL_TREE if there is no secondary vptr in the VTT.  */\n+#define BINFO_VPTR_INDEX(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vtt_vptr)\n+\n+/* The binfo of which NODE is a primary base.  (This is different from\n+   BINFO_INHERITANCE_CHAIN for virtual base because a virtual base is\n+   sometimes a primary base for a class for which it is not an\n+   immediate base.)  */\n+#define BINFO_PRIMARY_BASE_OF(NODE) (TREE_BINFO_CHECK(NODE)->binfo.primary)\n \n /* The BINFO_INHERITANCE_CHAIN points at the binfo for the base\n    inheriting this base for non-virtual bases. For virtual bases it\n@@ -1687,14 +1700,16 @@ struct tree_binfo GTY (())\n   tree offset;\n   tree vtable;\n   tree virtuals;\n-  tree base_binfos;\n   tree vptr_field;\n   tree base_accesses;\n   tree inheritance;\n \n-  tree GTY ((length (\"binfo_lang_slots\"))) lang_slots[1];\n+  tree vtt_subvtt;\n+  tree vtt_vptr;\n+  tree primary;\n+\n+  VEC(tree) base_binfos;\n };\n-extern GTY (()) unsigned binfo_lang_slots;\n \n \f\n /* Define fields and accessors for nodes representing declared names.  */"}]}