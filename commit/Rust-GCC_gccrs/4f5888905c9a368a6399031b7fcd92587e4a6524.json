{"sha": "4f5888905c9a368a6399031b7fcd92587e4a6524", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY1ODg4OTA1YzlhMzY4YTYzOTkwMzFiN2ZjZDkyNTg3ZTRhNjUyNA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-07-30T15:35:02Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-07-30T15:35:02Z"}, "message": "alias.c (mems_in_disjoint_alias_sets_p, [...]): Constify.\n\n\t* alias.c (mems_in_disjoint_alias_sets_p,\n\tfixed_scalar_and_varying_struct_p, aliases_everything_p,\n\tnonoverlapping_component_refs_p, nonoverlapping_memrefs_p,\n\twrite_dependence_p, mems_in_disjoint_alias_sets_p,\n\tread_dependence, true_dependence, canon_true_dependence,\n\tanti_dependence, output_dependence): Constify.\n\t* combine.c (extended_count): Likewise.\n\t* cse.c (cse_rtx_varies_p, hash_rtx, exp_equiv_p): Likewise.\n\t* cselib.c (get_value_hash, references_value_p,\n\tcselib_reg_set_mode, cselib_rtx_varies_p): Likewise.\n\t* cselib.h (cselib_reg_set_mode, references_value_p): Likewise.\n\t* emit-rtl.c (mem_expr_equal_p, active_insn_p): Likewise.\n\t* function.c (contains, prologue_epilogue_contains,\n\tsibcall_epilogue_contains): Likewise. \n\t* jump.c (simplejump_p, condjump_p, condjump_in_parallel_p,\n\tpc_set, any_uncondjump_p, any_condjump_p, onlyjump_p,\n\tonly_sets_cc0_p, sets_cc0_p, rtx_renumbered_equal_p, true_regnum,\n\treg_or_subregno): Likewise.\n\t* recog.c (asm_noperands): Likewise.\n\t* reload1.c (function_invariant_p): Likewise.\n\t* rtl.h (mem_expr_equal_p, active_insn_p, rtx_varies_p,\n\trtx_addr_varies_p, asm_noperands, exp_equiv_p, hash_rtx,\n\tcondjump_p, any_condjump_p, any_uncondjump_p, pc_set,\n\tsimplejump_p, onlyjump_p, only_sets_cc0_p, sets_cc0_p,\n\ttrue_regnum, reg_or_subregno, condjump_in_parallel_p,\n\textended_count, prologue_epilogue_contains,\n\tsibcall_epilogue_contains, function_invariant_p, true_dependence,\n\tcanon_true_dependence, read_dependence, anti_dependence,\n\toutput_dependence): Likewise.\n\t* rtlanal.c (rtx_varies_p, rtx_addr_varies_p): Likewise.\n\njava:\n\t* jcf-io.c (find_class): Fix -Wcast-qual warnings.\n\nFrom-SVN: r127063", "tree": {"sha": "7d7644025a2690438857f47c7879353d53ce1e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d7644025a2690438857f47c7879353d53ce1e19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f5888905c9a368a6399031b7fcd92587e4a6524", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f5888905c9a368a6399031b7fcd92587e4a6524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f5888905c9a368a6399031b7fcd92587e4a6524", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f5888905c9a368a6399031b7fcd92587e4a6524/comments", "author": null, "committer": null, "parents": [{"sha": "89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0"}], "stats": {"total": 238, "additions": 139, "deletions": 99}, "files": [{"sha": "aa6f96f67db7669612c914b93c23abcf51faf450", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -1,3 +1,36 @@\n+2007-07-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* alias.c (mems_in_disjoint_alias_sets_p,\n+\tfixed_scalar_and_varying_struct_p, aliases_everything_p,\n+\tnonoverlapping_component_refs_p, nonoverlapping_memrefs_p,\n+\twrite_dependence_p, mems_in_disjoint_alias_sets_p,\n+\tread_dependence, true_dependence, canon_true_dependence,\n+\tanti_dependence, output_dependence): Constify.\n+\t* combine.c (extended_count): Likewise.\n+\t* cse.c (cse_rtx_varies_p, hash_rtx, exp_equiv_p): Likewise.\n+\t* cselib.c (get_value_hash, references_value_p,\n+\tcselib_reg_set_mode, cselib_rtx_varies_p): Likewise.\n+\t* cselib.h (cselib_reg_set_mode, references_value_p): Likewise.\n+\t* emit-rtl.c (mem_expr_equal_p, active_insn_p): Likewise.\n+\t* function.c (contains, prologue_epilogue_contains,\n+\tsibcall_epilogue_contains): Likewise. \n+\t* jump.c (simplejump_p, condjump_p, condjump_in_parallel_p,\n+\tpc_set, any_uncondjump_p, any_condjump_p, onlyjump_p,\n+\tonly_sets_cc0_p, sets_cc0_p, rtx_renumbered_equal_p, true_regnum,\n+\treg_or_subregno): Likewise.\n+\t* recog.c (asm_noperands): Likewise.\n+\t* reload1.c (function_invariant_p): Likewise.\n+\t* rtl.h (mem_expr_equal_p, active_insn_p, rtx_varies_p,\n+\trtx_addr_varies_p, asm_noperands, exp_equiv_p, hash_rtx,\n+\tcondjump_p, any_condjump_p, any_uncondjump_p, pc_set,\n+\tsimplejump_p, onlyjump_p, only_sets_cc0_p, sets_cc0_p,\n+\ttrue_regnum, reg_or_subregno, condjump_in_parallel_p,\n+\textended_count, prologue_epilogue_contains,\n+\tsibcall_epilogue_contains, function_invariant_p, true_dependence,\n+\tcanon_true_dependence, read_dependence, anti_dependence,\n+\toutput_dependence): Likewise.\n+\t* rtlanal.c (rtx_varies_p, rtx_addr_varies_p): Likewise.\n+\n 2007-07-30  Julian Brown  <julian@codesourcery.com>\n \n \t* config/arm/neon.md (V_ext): New mode attribute."}, {"sha": "a87b4c85be8a599c54b70b2f1481c1e805ca5314", "filename": "gcc/alias.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -154,18 +154,18 @@ static void record_set (rtx, rtx, void *);\n static int base_alias_check (rtx, rtx, enum machine_mode,\n \t\t\t     enum machine_mode);\n static rtx find_base_value (rtx);\n-static int mems_in_disjoint_alias_sets_p (rtx, rtx);\n+static int mems_in_disjoint_alias_sets_p (const_rtx, const_rtx);\n static int insert_subset_children (splay_tree_node, void*);\n static tree find_base_decl (tree);\n static alias_set_entry get_alias_set_entry (HOST_WIDE_INT);\n-static rtx fixed_scalar_and_varying_struct_p (rtx, rtx, rtx, rtx,\n-\t\t\t\t\t      int (*) (rtx, int));\n-static int aliases_everything_p (rtx);\n-static bool nonoverlapping_component_refs_p (tree, tree);\n+static const_rtx fixed_scalar_and_varying_struct_p (const_rtx, const_rtx, rtx, rtx,\n+\t\t\t\t\t\t    bool (*) (const_rtx, bool));\n+static int aliases_everything_p (const_rtx);\n+static bool nonoverlapping_component_refs_p (const_tree, const_tree);\n static tree decl_for_component_ref (tree);\n static rtx adjust_offset_for_component_ref (tree, rtx);\n-static int nonoverlapping_memrefs_p (rtx, rtx);\n-static int write_dependence_p (rtx, rtx, int);\n+static int nonoverlapping_memrefs_p (const_rtx, const_rtx);\n+static int write_dependence_p (const_rtx, const_rtx, int);\n \n static void memory_modified_1 (rtx, rtx, void *);\n static void record_alias_subset (HOST_WIDE_INT, HOST_WIDE_INT);\n@@ -266,7 +266,7 @@ get_alias_set_entry (HOST_WIDE_INT alias_set)\n    the two MEMs cannot alias each other.  */\n \n static inline int\n-mems_in_disjoint_alias_sets_p (rtx mem1, rtx mem2)\n+mems_in_disjoint_alias_sets_p (const_rtx mem1, const_rtx mem2)\n {\n /* Perform a basic sanity check.  Namely, that there are no alias sets\n    if we're not using strict aliasing.  This helps to catch bugs\n@@ -1803,7 +1803,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n    only be a dependence here if both reads are volatile.  */\n \n int\n-read_dependence (rtx mem, rtx x)\n+read_dependence (const_rtx mem, const_rtx x)\n {\n   return MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem);\n }\n@@ -1816,10 +1816,10 @@ read_dependence (rtx mem, rtx x)\n    nonzero whenever variation is possible.\n    MEM1_ADDR and MEM2_ADDR are the addresses of MEM1 and MEM2.  */\n \n-static rtx\n-fixed_scalar_and_varying_struct_p (rtx mem1, rtx mem2, rtx mem1_addr,\n+static const_rtx\n+fixed_scalar_and_varying_struct_p (const_rtx mem1, const_rtx mem2, rtx mem1_addr,\n \t\t\t\t   rtx mem2_addr,\n-\t\t\t\t   int (*varies_p) (rtx, int))\n+\t\t\t\t   bool (*varies_p) (const_rtx, bool))\n {\n   if (! flag_strict_aliasing)\n     return NULL_RTX;\n@@ -1845,7 +1845,7 @@ fixed_scalar_and_varying_struct_p (rtx mem1, rtx mem2, rtx mem1_addr,\n    indicates that it might well alias *anything*.  */\n \n static int\n-aliases_everything_p (rtx mem)\n+aliases_everything_p (const_rtx mem)\n {\n   if (GET_CODE (XEXP (mem, 0)) == AND)\n     /* If the address is an AND, it's very hard to know at what it is\n@@ -1859,9 +1859,9 @@ aliases_everything_p (rtx mem)\n    overlap for any pair of objects.  */\n \n static bool\n-nonoverlapping_component_refs_p (tree x, tree y)\n+nonoverlapping_component_refs_p (const_tree x, const_tree y)\n {\n-  tree fieldx, fieldy, typex, typey, orig_y;\n+  const_tree fieldx, fieldy, typex, typey, orig_y;\n \n   do\n     {\n@@ -1959,7 +1959,7 @@ adjust_offset_for_component_ref (tree x, rtx offset)\n    X and Y and they do not overlap.  */\n \n static int\n-nonoverlapping_memrefs_p (rtx x, rtx y)\n+nonoverlapping_memrefs_p (const_rtx x, const_rtx y)\n {\n   tree exprx = MEM_EXPR (x), expry = MEM_EXPR (y);\n   rtx rtlx, rtly;\n@@ -2108,8 +2108,8 @@ nonoverlapping_memrefs_p (rtx x, rtx y)\n /* True dependence: X is read after store in MEM takes place.  */\n \n int\n-true_dependence (rtx mem, enum machine_mode mem_mode, rtx x,\n-\t\t int (*varies) (rtx, int))\n+true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n+\t\t bool (*varies) (const_rtx, bool))\n {\n   rtx x_addr, mem_addr;\n   rtx base;\n@@ -2185,8 +2185,8 @@ true_dependence (rtx mem, enum machine_mode mem_mode, rtx x,\n    this value prior to canonicalizing.  */\n \n int\n-canon_true_dependence (rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n-\t\t       rtx x, int (*varies) (rtx, int))\n+canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n+\t\t       const_rtx x, bool (*varies) (const_rtx, bool))\n {\n   rtx x_addr;\n \n@@ -2246,10 +2246,10 @@ canon_true_dependence (rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n    (or, if WRITEP is nonzero, a write to) MEM.  */\n \n static int\n-write_dependence_p (rtx mem, rtx x, int writep)\n+write_dependence_p (const_rtx mem, const_rtx x, int writep)\n {\n   rtx x_addr, mem_addr;\n-  rtx fixed_scalar;\n+  const_rtx fixed_scalar;\n   rtx base;\n \n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n@@ -2309,15 +2309,15 @@ write_dependence_p (rtx mem, rtx x, int writep)\n /* Anti dependence: X is written after read in MEM takes place.  */\n \n int\n-anti_dependence (rtx mem, rtx x)\n+anti_dependence (const_rtx mem, const_rtx x)\n {\n   return write_dependence_p (mem, x, /*writep=*/0);\n }\n \n /* Output dependence: X is written after store in MEM takes place.  */\n \n int\n-output_dependence (rtx mem, rtx x)\n+output_dependence (const_rtx mem, const_rtx x)\n {\n   return write_dependence_p (mem, x, /*writep=*/1);\n }"}, {"sha": "dab7453c9c47bfdb83963ef70856dae425d23d93", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -8748,7 +8748,7 @@ reg_num_sign_bit_copies_for_combine (const_rtx x, enum machine_mode mode,\n    implies that it must be called from a define_split.  */\n \n unsigned int\n-extended_count (rtx x, enum machine_mode mode, int unsignedp)\n+extended_count (const_rtx x, enum machine_mode mode, int unsignedp)\n {\n   if (nonzero_sign_valid == 0)\n     return 0;"}, {"sha": "6c2530ac612cfff76f348b2d60fc6fc27283f478", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -558,7 +558,7 @@ static struct table_elt *insert (rtx, struct table_elt *, unsigned,\n \t\t\t\t enum machine_mode);\n static void merge_equiv_classes (struct table_elt *, struct table_elt *);\n static void invalidate (rtx, enum machine_mode);\n-static int cse_rtx_varies_p (rtx, int);\n+static bool cse_rtx_varies_p (const_rtx, bool);\n static void remove_invalid_refs (unsigned int);\n static void remove_invalid_subreg_refs (unsigned int, unsigned int,\n \t\t\t\t\tenum machine_mode);\n@@ -2059,7 +2059,7 @@ hash_rtx_string (const char *ps)\n    is just (int) MEM plus the hash code of the address.  */\n \n unsigned\n-hash_rtx (rtx x, enum machine_mode mode, int *do_not_record_p,\n+hash_rtx (const_rtx x, enum machine_mode mode, int *do_not_record_p,\n \t  int *hash_arg_in_memory_p, bool have_reg_qty)\n {\n   int i, j;\n@@ -2373,7 +2373,7 @@ safe_hash (rtx x, enum machine_mode mode)\n    If FOR_GCSE is true, we compare X and Y for equivalence for GCSE.  */\n \n int\n-exp_equiv_p (rtx x, rtx y, int validate, bool for_gcse)\n+exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -2565,8 +2565,8 @@ exp_equiv_p (rtx x, rtx y, int validate, bool for_gcse)\n    executions of the program.  0 means X can be compared reliably\n    against certain constants or near-constants.  */\n \n-static int\n-cse_rtx_varies_p (rtx x, int from_alias)\n+static bool\n+cse_rtx_varies_p (const_rtx x, bool from_alias)\n {\n   /* We need not check for X and the equivalence class being of the same\n      mode because if X is equivalent to a constant in some mode, it"}, {"sha": "41f0da627db8a75802adb92e6b93ca585e1dc808", "filename": "gcc/cselib.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -265,7 +265,7 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n static hashval_t\n get_value_hash (const void *entry)\n {\n-  const cselib_val *v = (const cselib_val *) entry;\n+  const cselib_val *const v = (const cselib_val *) entry;\n   return v->value;\n }\n \n@@ -275,9 +275,9 @@ get_value_hash (const void *entry)\n    removed.  */\n \n int\n-references_value_p (rtx x, int only_useless)\n+references_value_p (const_rtx x, int only_useless)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  const enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n   int i, j;\n \n@@ -384,7 +384,7 @@ remove_useless_values (void)\n    VOIDmode.  */\n \n enum machine_mode\n-cselib_reg_set_mode (rtx x)\n+cselib_reg_set_mode (const_rtx x)\n {\n   if (!REG_P (x))\n     return GET_MODE (x);\n@@ -1354,8 +1354,8 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n    executions of the program.  0 means X can be compared reliably\n    against certain constants or near-constants.  */\n \n-static int\n-cselib_rtx_varies_p (rtx x ATTRIBUTE_UNUSED, int from_alias ATTRIBUTE_UNUSED)\n+static bool\n+cselib_rtx_varies_p (const_rtx x ATTRIBUTE_UNUSED, bool from_alias ATTRIBUTE_UNUSED)\n {\n   /* We actually don't need to verify very hard.  This is because\n      if X has actually changed, we invalidate the memory anyway,"}, {"sha": "0e4c6f211df33d20f45ad2faf77385ae8b7d597d", "filename": "gcc/cselib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -65,9 +65,9 @@ extern void cselib_init (bool record_memory);\n extern void cselib_clear_table (void);\n extern void cselib_finish (void);\n extern void cselib_process_insn (rtx);\n-extern enum machine_mode cselib_reg_set_mode (rtx);\n+extern enum machine_mode cselib_reg_set_mode (const_rtx);\n extern int rtx_equal_for_cselib_p (rtx, rtx);\n-extern int references_value_p (rtx, int);\n+extern int references_value_p (const_rtx, int);\n extern rtx cselib_expand_value_rtx (rtx, bitmap, int);\n extern rtx cselib_subst_to_values (rtx);\n extern void cselib_invalidate_rtx (rtx);"}, {"sha": "3c6bf725e1cf51c236806472cacffed1f1f2b8b0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -1425,7 +1425,7 @@ component_ref_for_mem_expr (tree ref)\n    and 0 otherwise.  */\n \n int\n-mem_expr_equal_p (tree expr1, tree expr2)\n+mem_expr_equal_p (const_tree expr1, const_tree expr2)\n {\n   if (expr1 == expr2)\n     return 1;\n@@ -2904,7 +2904,7 @@ last_call_insn (void)\n    same as next_real_insn.  */\n \n int\n-active_insn_p (rtx insn)\n+active_insn_p (const_rtx insn)\n {\n   return (CALL_P (insn) || JUMP_P (insn)\n \t  || (NONJUMP_INSN_P (insn)"}, {"sha": "592f95343b4f3d8aebd75a809b89d223718abd68", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -202,7 +202,7 @@ extern tree debug_find_var_in_block_tree (tree, tree);\n /* We always define `record_insns' even if it's not used so that we\n    can always export `prologue_epilogue_contains'.  */\n static void record_insns (rtx, VEC(int,heap) **) ATTRIBUTE_UNUSED;\n-static int contains (rtx, VEC(int,heap) **);\n+static int contains (const_rtx, VEC(int,heap) **);\n #ifdef HAVE_return\n static void emit_return_into_block (basic_block);\n #endif\n@@ -4601,7 +4601,7 @@ set_insn_locators (rtx insn, int loc)\n    be running after reorg, SEQUENCE rtl is possible.  */\n \n static int\n-contains (rtx insn, VEC(int,heap) **vec)\n+contains (const_rtx insn, VEC(int,heap) **vec)\n {\n   int i, j;\n \n@@ -4626,7 +4626,7 @@ contains (rtx insn, VEC(int,heap) **vec)\n }\n \n int\n-prologue_epilogue_contains (rtx insn)\n+prologue_epilogue_contains (const_rtx insn)\n {\n   if (contains (insn, &prologue))\n     return 1;\n@@ -4636,7 +4636,7 @@ prologue_epilogue_contains (rtx insn)\n }\n \n int\n-sibcall_epilogue_contains (rtx insn)\n+sibcall_epilogue_contains (const_rtx insn)\n {\n   if (sibcall_epilogue)\n     return contains (insn, &sibcall_epilogue);"}, {"sha": "46a597bc307741148d04126362997ed5be5577fd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -1,3 +1,7 @@\n+2007-07-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* jcf-io.c (find_class): Fix -Wcast-qual warnings.\n+\n 2007-07-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* lang.c (java_get_callee_fndecl): Constify."}, {"sha": "0c45dd1d39d2f0f444cead4d6d5439366231ed7a", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -541,14 +541,17 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n \n   /* Remember that this class could not be found so that we do not\n      have to look again.  */\n-  *htab_find_slot_with_hash (memoized_class_lookups, classname, hash, INSERT) \n-    = (void *) classname;\n+  *(const void **)htab_find_slot_with_hash (memoized_class_lookups,\n+\t\t\t\t\t    classname, hash, INSERT)\n+    = classname;\n \n   return NULL;\n  found:\n-  buffer = (char *) open_class (buffer, jcf, fd, dep_file);\n-  jcf->classname = xstrdup (classname);\n-  return buffer;\n+  {\n+    const char *const tmp = open_class (buffer, jcf, fd, dep_file);\n+    jcf->classname = xstrdup (classname);\n+    return tmp;\n+  }\n }\n \n void"}, {"sha": "d83b0a55f8fb58863c0779dbc053bd77e74316d2", "filename": "gcc/jump.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -654,7 +654,7 @@ comparison_dominates_p (enum rtx_code code1, enum rtx_code code2)\n /* Return 1 if INSN is an unconditional jump and nothing else.  */\n \n int\n-simplejump_p (rtx insn)\n+simplejump_p (const_rtx insn)\n {\n   return (JUMP_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SET\n@@ -669,9 +669,9 @@ simplejump_p (rtx insn)\n    branch and compare insns.  Use any_condjump_p instead whenever possible.  */\n \n int\n-condjump_p (rtx insn)\n+condjump_p (const_rtx insn)\n {\n-  rtx x = PATTERN (insn);\n+  const_rtx x = PATTERN (insn);\n \n   if (GET_CODE (x) != SET\n       || GET_CODE (SET_DEST (x)) != PC)\n@@ -697,9 +697,9 @@ condjump_p (rtx insn)\n    branch and compare insns.  Use any_condjump_p instead whenever possible.  */\n \n int\n-condjump_in_parallel_p (rtx insn)\n+condjump_in_parallel_p (const_rtx insn)\n {\n-  rtx x = PATTERN (insn);\n+  const_rtx x = PATTERN (insn);\n \n   if (GET_CODE (x) != PARALLEL)\n     return 0;\n@@ -728,7 +728,7 @@ condjump_in_parallel_p (rtx insn)\n /* Return set of PC, otherwise NULL.  */\n \n rtx\n-pc_set (rtx insn)\n+pc_set (const_rtx insn)\n {\n   rtx pat;\n   if (!JUMP_P (insn))\n@@ -749,9 +749,9 @@ pc_set (rtx insn)\n    possibly bundled inside a PARALLEL.  */\n \n int\n-any_uncondjump_p (rtx insn)\n+any_uncondjump_p (const_rtx insn)\n {\n-  rtx x = pc_set (insn);\n+  const_rtx x = pc_set (insn);\n   if (!x)\n     return 0;\n   if (GET_CODE (SET_SRC (x)) != LABEL_REF)\n@@ -769,9 +769,9 @@ any_uncondjump_p (rtx insn)\n    Note that unlike condjump_p it returns false for unconditional jumps.  */\n \n int\n-any_condjump_p (rtx insn)\n+any_condjump_p (const_rtx insn)\n {\n-  rtx x = pc_set (insn);\n+  const_rtx x = pc_set (insn);\n   enum rtx_code a, b;\n \n   if (!x)\n@@ -830,7 +830,7 @@ returnjump_p (rtx insn)\n    nothing more.  */\n \n int\n-onlyjump_p (rtx insn)\n+onlyjump_p (const_rtx insn)\n {\n   rtx set;\n \n@@ -854,7 +854,7 @@ onlyjump_p (rtx insn)\n    and has no side effects.  */\n \n int\n-only_sets_cc0_p (rtx x)\n+only_sets_cc0_p (const_rtx x)\n {\n   if (! x)\n     return 0;\n@@ -871,7 +871,7 @@ only_sets_cc0_p (rtx x)\n    but also does other things.  */\n \n int\n-sets_cc0_p (rtx x)\n+sets_cc0_p (const_rtx x)\n {\n   if (! x)\n     return 0;\n@@ -1422,7 +1422,7 @@ int\n rtx_renumbered_equal_p (rtx x, rtx y)\n {\n   int i;\n-  enum rtx_code code = GET_CODE (x);\n+  const enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n \n   if (x == y)\n@@ -1604,7 +1604,7 @@ rtx_renumbered_equal_p (rtx x, rtx y)\n    return -1.  Any rtx is valid for X.  */\n \n int\n-true_regnum (rtx x)\n+true_regnum (const_rtx x)\n {\n   if (REG_P (x))\n     {\n@@ -1629,7 +1629,7 @@ true_regnum (rtx x)\n \n /* Return regno of the register REG and handle subregs too.  */\n unsigned int\n-reg_or_subregno (rtx reg)\n+reg_or_subregno (const_rtx reg)\n {\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);"}, {"sha": "5692f4ef7e2512195361e737881202754b7fcac3", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -1279,7 +1279,7 @@ comparison_operator (rtx op, enum machine_mode mode)\n    Otherwise return -1.  */\n \n int\n-asm_noperands (rtx body)\n+asm_noperands (const_rtx body)\n {\n   switch (GET_CODE (body))\n     {"}, {"sha": "0c770b55073e0c6c2dccbb2b342ad3c2d9b11d03", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -5323,7 +5323,7 @@ free_for_value_p (int regno, enum machine_mode mode, int opnum,\n    memory.  */\n \n int\n-function_invariant_p (rtx x)\n+function_invariant_p (const_rtx x)\n {\n   if (CONSTANT_P (x))\n     return 1;"}, {"sha": "ed8d36da821b45e9cdee1b10a13e4883823af1fe", "filename": "gcc/rtl.h", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -1458,7 +1458,7 @@ extern rtx emit_copy_of_insn_after (rtx, rtx);\n extern void set_reg_attrs_from_mem (rtx, rtx);\n extern void set_mem_attrs_from_reg (rtx, rtx);\n extern void set_reg_attrs_for_parm (rtx, rtx);\n-extern int mem_expr_equal_p (tree, tree);\n+extern int mem_expr_equal_p (const_tree, const_tree);\n \n /* In rtl.c */\n extern rtx rtx_alloc_stat (RTX_CODE MEM_STAT_DECL);\n@@ -1582,7 +1582,7 @@ extern rtx prev_real_insn (rtx);\n extern rtx next_real_insn (rtx);\n extern rtx prev_active_insn (rtx);\n extern rtx next_active_insn (rtx);\n-extern int active_insn_p (rtx);\n+extern int active_insn_p (const_rtx);\n extern rtx prev_label (rtx);\n extern rtx next_label (rtx);\n extern rtx skip_consecutive_labels (rtx);\n@@ -1677,8 +1677,8 @@ typedef struct replace_label_data\n extern int rtx_addr_can_trap_p (const_rtx);\n extern bool nonzero_address_p (const_rtx);\n extern int rtx_unstable_p (const_rtx);\n-extern int rtx_varies_p (rtx, int);\n-extern int rtx_addr_varies_p (rtx, int);\n+extern bool rtx_varies_p (const_rtx, bool);\n+extern bool rtx_addr_varies_p (const_rtx, bool);\n extern HOST_WIDE_INT get_integer_term (const_rtx);\n extern rtx get_related_value (const_rtx);\n extern bool offset_within_block_p (const_rtx, HOST_WIDE_INT);\n@@ -1764,7 +1764,7 @@ rtx remove_list_elem (rtx, rtx *);\n extern void free_reg_info (void);\n \n /* recog.c */\n-extern int asm_noperands (rtx);\n+extern int asm_noperands (const_rtx);\n extern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,\n \t\t\t\t\tenum machine_mode *, location_t *);\n \n@@ -2001,26 +2001,26 @@ extern int rtx_to_tree_code (enum rtx_code);\n /* In cse.c */\n extern int delete_trivially_dead_insns (rtx, int);\n extern int cse_main (rtx, int);\n-extern int exp_equiv_p (rtx, rtx, int, bool);\n-extern unsigned hash_rtx (rtx x, enum machine_mode, int *, int *, bool);\n+extern int exp_equiv_p (const_rtx, const_rtx, int, bool);\n+extern unsigned hash_rtx (const_rtx x, enum machine_mode, int *, int *, bool);\n \n /* In jump.c */\n extern int comparison_dominates_p (enum rtx_code, enum rtx_code);\n-extern int condjump_p (rtx);\n-extern int any_condjump_p (rtx);\n-extern int any_uncondjump_p (rtx);\n-extern rtx pc_set (rtx);\n+extern int condjump_p (const_rtx);\n+extern int any_condjump_p (const_rtx);\n+extern int any_uncondjump_p (const_rtx);\n+extern rtx pc_set (const_rtx);\n extern rtx condjump_label (rtx);\n-extern int simplejump_p (rtx);\n+extern int simplejump_p (const_rtx);\n extern int returnjump_p (rtx);\n-extern int onlyjump_p (rtx);\n-extern int only_sets_cc0_p (rtx);\n-extern int sets_cc0_p (rtx);\n+extern int onlyjump_p (const_rtx);\n+extern int only_sets_cc0_p (const_rtx);\n+extern int sets_cc0_p (const_rtx);\n extern int invert_jump_1 (rtx, rtx);\n extern int invert_jump (rtx, rtx, int);\n extern int rtx_renumbered_equal_p (rtx, rtx);\n-extern int true_regnum (rtx);\n-extern unsigned int reg_or_subregno (rtx);\n+extern int true_regnum (const_rtx);\n+extern unsigned int reg_or_subregno (const_rtx);\n extern int redirect_jump_1 (rtx, rtx);\n extern void redirect_jump_2 (rtx, rtx, rtx, int, int);\n extern int redirect_jump (rtx, rtx, int);\n@@ -2030,7 +2030,7 @@ extern enum rtx_code reversed_comparison_code (rtx, rtx);\n extern enum rtx_code reversed_comparison_code_parts (enum rtx_code, rtx,\n \t\t\t\t\t\t     rtx, rtx);\n extern void delete_for_peephole (rtx, rtx);\n-extern int condjump_in_parallel_p (rtx);\n+extern int condjump_in_parallel_p (const_rtx);\n \n /* In emit-rtl.c.  */\n extern int max_reg_num (void);\n@@ -2078,7 +2078,7 @@ extern bool validate_subreg (enum machine_mode, enum machine_mode,\n \t\t\t     rtx, unsigned int);\n \n /* In combine.c  */\n-extern unsigned int extended_count (rtx, enum machine_mode, int);\n+extern unsigned int extended_count (const_rtx, enum machine_mode, int);\n extern rtx remove_death (unsigned int, rtx);\n extern void dump_combine_stats (FILE *);\n extern void dump_combine_total_stats (FILE *);\n@@ -2114,8 +2114,8 @@ extern void print_inline_rtx (FILE *, const_rtx, int);\n \n /* In function.c */\n extern void reposition_prologue_and_epilogue_notes (void);\n-extern int prologue_epilogue_contains (rtx);\n-extern int sibcall_epilogue_contains (rtx);\n+extern int prologue_epilogue_contains (const_rtx);\n+extern int sibcall_epilogue_contains (const_rtx);\n extern void mark_temp_addr_taken (rtx);\n extern void update_temp_slot_address (rtx, rtx);\n \n@@ -2178,7 +2178,7 @@ extern void dbr_schedule (rtx);\n extern void dump_local_alloc (FILE *);\n \n /* In reload1.c */\n-extern int function_invariant_p (rtx);\n+extern int function_invariant_p (const_rtx);\n \n /* In calls.c */\n enum libcall_type\n@@ -2218,13 +2218,13 @@ extern int read_rtx_lineno;\n \n /* In alias.c */\n extern rtx canon_rtx (rtx);\n-extern int true_dependence (rtx, enum machine_mode, rtx, int (*)(rtx, int));\n+extern int true_dependence (const_rtx, enum machine_mode, const_rtx, bool (*)(const_rtx, bool));\n extern rtx get_addr (rtx);\n-extern int canon_true_dependence (rtx, enum machine_mode, rtx, rtx,\n-\t\t\t\t  int (*)(rtx, int));\n-extern int read_dependence (rtx, rtx);\n-extern int anti_dependence (rtx, rtx);\n-extern int output_dependence (rtx, rtx);\n+extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,\n+\t\t\t\t  bool (*)(const_rtx, bool));\n+extern int read_dependence (const_rtx, const_rtx);\n+extern int anti_dependence (const_rtx, const_rtx);\n+extern int output_dependence (const_rtx, const_rtx);\n extern void init_alias_once (void);\n extern void init_alias_analysis (void);\n extern void end_alias_analysis (void);"}, {"sha": "e4f51873fa19979d23eb0abfef1d9dafc1abe7a1", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5888905c9a368a6399031b7fcd92587e4a6524/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4f5888905c9a368a6399031b7fcd92587e4a6524", "patch": "@@ -175,8 +175,8 @@ rtx_unstable_p (const_rtx x)\n    zero, we are slightly more conservative.\n    The frame pointer and the arg pointer are considered constant.  */\n \n-int\n-rtx_varies_p (rtx x, int for_alias)\n+bool\n+rtx_varies_p (const_rtx x, bool for_alias)\n {\n   RTX_CODE code;\n   int i;\n@@ -427,8 +427,8 @@ nonzero_address_p (const_rtx x)\n    FOR_ALIAS is nonzero if we are called from alias analysis; if it is\n    zero, we are slightly more conservative.  */\n \n-int\n-rtx_addr_varies_p (rtx x, int for_alias)\n+bool\n+rtx_addr_varies_p (const_rtx x, bool for_alias)\n {\n   enum rtx_code code;\n   int i;"}]}