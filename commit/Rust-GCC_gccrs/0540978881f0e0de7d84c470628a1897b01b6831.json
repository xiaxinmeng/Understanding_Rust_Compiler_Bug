{"sha": "0540978881f0e0de7d84c470628a1897b01b6831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU0MDk3ODg4MWYwZTBkZTdkODRjNDcwNjI4YTE4OTdiMDFiNjgzMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-11T17:52:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-11T17:52:11Z"}, "message": "Implement omp atomic load and store.\n\n\t* gimple-pretty-print.c (dump_gimple_omp_atomic_load): Dump needed.\n\t(dump_gimple_omp_atomic_store): Likewise.\n\t* optabs.c (can_atomic_exchange_p): New.\n\t* optabs.h (can_atomic_exchange_p): Declare.\n\t* omp-low.c (expand_omp_atomic_load): Implement.\n\t(expand_omp_atomic_store): Likewise.\n\t(expand_omp_atomic): Update for new arguments to load/store.\n\nFrom-SVN: r181296", "tree": {"sha": "1269946d9053f55f9328174653105f6943967e41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1269946d9053f55f9328174653105f6943967e41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0540978881f0e0de7d84c470628a1897b01b6831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0540978881f0e0de7d84c470628a1897b01b6831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0540978881f0e0de7d84c470628a1897b01b6831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0540978881f0e0de7d84c470628a1897b01b6831/comments", "author": null, "committer": null, "parents": [{"sha": "f05eec4a0d41f9b9b5ef0131407581c5edb6f79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f05eec4a0d41f9b9b5ef0131407581c5edb6f79c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f05eec4a0d41f9b9b5ef0131407581c5edb6f79c"}], "stats": {"total": 185, "additions": 160, "deletions": 25}, "files": [{"sha": "ef1453e3f628c4ce4a37f0b4fdf3abb0af6b8876", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0540978881f0e0de7d84c470628a1897b01b6831", "patch": "@@ -1,3 +1,13 @@\n+2011-11-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* gimple-pretty-print.c (dump_gimple_omp_atomic_load): Dump needed.\n+\t(dump_gimple_omp_atomic_store): Likewise.\n+\t* optabs.c (can_atomic_exchange_p): New.\n+\t* optabs.h (can_atomic_exchange_p): Declare.\n+\t* omp-low.c (expand_omp_atomic_load): Implement.\n+\t(expand_omp_atomic_store): Likewise.\n+\t(expand_omp_atomic): Update for new arguments to load/store.\n+\n 2011-11-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cprop.c: Adjust outdated comments throughout."}, {"sha": "f0e7c50e60e2794ac7e8b118d02b28f2ff43b774", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=0540978881f0e0de7d84c470628a1897b01b6831", "patch": "@@ -1768,6 +1768,8 @@ dump_gimple_omp_atomic_load (pretty_printer *buffer, gimple gs, int spc,\n   else\n     {\n       pp_string (buffer, \"#pragma omp atomic_load\");\n+      if (gimple_omp_atomic_need_value_p (gs))\n+\tpp_string (buffer, \" [needed]\");\n       newline_and_indent (buffer, spc + 2);\n       dump_generic_node (buffer, gimple_omp_atomic_load_lhs (gs),\n \t  \t\t spc, flags, false);\n@@ -1795,7 +1797,10 @@ dump_gimple_omp_atomic_store (pretty_printer *buffer, gimple gs, int spc,\n     }\n   else\n     {\n-      pp_string (buffer, \"#pragma omp atomic_store (\");\n+      pp_string (buffer, \"#pragma omp atomic_store \");\n+      if (gimple_omp_atomic_need_value_p (gs))\n+\tpp_string (buffer, \"[needed] \");\n+      pp_character (buffer, '(');\n       dump_generic_node (buffer, gimple_omp_atomic_store_val (gs),\n \t  \t\t spc, flags, false);\n       pp_character (buffer, ')');"}, {"sha": "a4bfb8413fe9ce151f61488ed8e3ae6d9859dd7a", "filename": "gcc/omp-low.c", "status": "modified", "additions": 121, "deletions": 24, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0540978881f0e0de7d84c470628a1897b01b6831", "patch": "@@ -4977,25 +4977,125 @@ expand_omp_synch (struct omp_region *region)\n    operation as a normal volatile load.  */\n \n static bool\n-expand_omp_atomic_load (basic_block load_bb, tree addr, tree loaded_val)\n+expand_omp_atomic_load (basic_block load_bb, tree addr,\n+\t\t\ttree loaded_val, int index)\n {\n-  /* FIXME */\n-  (void) load_bb;\n-  (void) addr;\n-  (void) loaded_val;\n-  return false;\n+  enum built_in_function tmpbase;\n+  gimple_stmt_iterator gsi;\n+  basic_block store_bb;\n+  location_t loc;\n+  gimple stmt;\n+  tree decl, call, type, itype;\n+\n+  gsi = gsi_last_bb (load_bb);\n+  stmt = gsi_stmt (gsi);\n+  gcc_assert (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_LOAD);\n+  loc = gimple_location (stmt);\n+\n+  /* ??? If the target does not implement atomic_load_optab[mode], and mode\n+     is smaller than word size, then expand_atomic_load assumes that the load\n+     is atomic.  We could avoid the builtin entirely in this case.  */\n+\n+  tmpbase = (enum built_in_function) (BUILT_IN_ATOMIC_LOAD_N + index + 1);\n+  decl = builtin_decl_explicit (tmpbase);\n+  if (decl == NULL_TREE)\n+    return false;\n+\n+  type = TREE_TYPE (loaded_val);\n+  itype = TREE_TYPE (TREE_TYPE (decl));\n+\n+  call = build_call_expr_loc (loc, decl, 2, addr,\n+\t\t\t      build_int_cst (NULL, MEMMODEL_RELAXED));\n+  if (!useless_type_conversion_p (type, itype))\n+    call = fold_build1_loc (loc, VIEW_CONVERT_EXPR, type, call);\n+  call = build2_loc (loc, MODIFY_EXPR, void_type_node, loaded_val, call);\n+\n+  force_gimple_operand_gsi (&gsi, call, true, NULL_TREE, true, GSI_SAME_STMT);\n+  gsi_remove (&gsi, true);\n+\n+  store_bb = single_succ (load_bb);\n+  gsi = gsi_last_bb (store_bb);\n+  gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_ATOMIC_STORE);\n+  gsi_remove (&gsi, true);\n+\n+  if (gimple_in_ssa_p (cfun))\n+    update_ssa (TODO_update_ssa_no_phi);\n+\n+  return true;\n }\n \n /* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n    operation as a normal volatile store.  */\n \n static bool\n-expand_omp_atomic_store (basic_block load_bb, tree addr)\n+expand_omp_atomic_store (basic_block load_bb, tree addr,\n+\t\t\t tree loaded_val, tree stored_val, int index)\n {\n-  /* FIXME */\n-  (void) load_bb;\n-  (void) addr;\n-  return false;\n+  enum built_in_function tmpbase;\n+  gimple_stmt_iterator gsi;\n+  basic_block store_bb = single_succ (load_bb);\n+  location_t loc;\n+  gimple stmt;\n+  tree decl, call, type, itype;\n+  enum machine_mode imode;\n+  bool exchange;\n+\n+  gsi = gsi_last_bb (load_bb);\n+  stmt = gsi_stmt (gsi);\n+  gcc_assert (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_LOAD);\n+\n+  /* If the load value is needed, then this isn't a store but an exchange.  */\n+  exchange = gimple_omp_atomic_need_value_p (stmt);\n+\n+  gsi = gsi_last_bb (store_bb);\n+  stmt = gsi_stmt (gsi);\n+  gcc_assert (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_STORE);\n+  loc = gimple_location (stmt);\n+\n+  /* ??? If the target does not implement atomic_store_optab[mode], and mode\n+     is smaller than word size, then expand_atomic_store assumes that the store\n+     is atomic.  We could avoid the builtin entirely in this case.  */\n+\n+  tmpbase = (exchange ? BUILT_IN_ATOMIC_EXCHANGE_N : BUILT_IN_ATOMIC_STORE_N);\n+  tmpbase = (enum built_in_function) ((int) tmpbase + index + 1);\n+  decl = builtin_decl_explicit (tmpbase);\n+  if (decl == NULL_TREE)\n+    return false;\n+\n+  type = TREE_TYPE (stored_val);\n+\n+  /* Dig out the type of the function's second argument.  */\n+  itype = TREE_TYPE (decl);\n+  itype = TYPE_ARG_TYPES (itype);\n+  itype = TREE_CHAIN (itype);\n+  itype = TREE_VALUE (itype);\n+  imode = TYPE_MODE (itype);\n+\n+  if (exchange && !can_atomic_exchange_p (imode, true))\n+    return false;\n+\n+  if (!useless_type_conversion_p (itype, type))\n+    stored_val = fold_build1_loc (loc, VIEW_CONVERT_EXPR, itype, stored_val);\n+  call = build_call_expr_loc (loc, decl, 3, addr, stored_val,\n+\t\t\t      build_int_cst (NULL, MEMMODEL_RELAXED));\n+  if (exchange)\n+    {\n+      if (!useless_type_conversion_p (type, itype))\n+\tcall = build1_loc (loc, VIEW_CONVERT_EXPR, type, call);\n+      call = build2_loc (loc, MODIFY_EXPR, void_type_node, loaded_val, call);\n+    }\n+\n+  force_gimple_operand_gsi (&gsi, call, true, NULL_TREE, true, GSI_SAME_STMT);\n+  gsi_remove (&gsi, true);\n+\n+  /* Remove the GIMPLE_OMP_ATOMIC_LOAD that we verified above.  */\n+  gsi = gsi_last_bb (load_bb);\n+  gsi_remove (&gsi, true);\n+\n+  if (gimple_in_ssa_p (cfun))\n+    update_ssa (TODO_update_ssa_no_phi);\n+\n+  return true;\n }\n \n /* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n@@ -5335,7 +5435,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n    loaded_val = *addr;\n \n    and replace\n-   GIMPLE_OMP_ATOMIC_ATORE (stored_val)  with\n+   GIMPLE_OMP_ATOMIC_STORE (stored_val)  with\n    *addr = stored_val;\n */\n \n@@ -5403,33 +5503,30 @@ expand_omp_atomic (struct omp_region *region)\n       /* __sync builtins require strict data alignment.  */\n       if (exact_log2 (align) >= index)\n \t{\n-\t  /* Atomic load.  FIXME: have some target hook signalize what loads\n-\t     are actually atomic?  */\n+\t  /* Atomic load.  */\n \t  if (loaded_val == stored_val\n \t      && (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT\n \t\t  || GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT)\n \t      && GET_MODE_BITSIZE (TYPE_MODE (type)) <= BITS_PER_WORD\n-\t      && expand_omp_atomic_load (load_bb, addr, loaded_val))\n+\t      && expand_omp_atomic_load (load_bb, addr, loaded_val, index))\n \t    return;\n \n-\t  /* Atomic store.  FIXME: have some target hook signalize what\n-\t     stores are actually atomic?  */\n+\t  /* Atomic store.  */\n \t  if ((GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT\n \t       || GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT)\n \t      && GET_MODE_BITSIZE (TYPE_MODE (type)) <= BITS_PER_WORD\n \t      && store_bb == single_succ (load_bb)\n \t      && first_stmt (store_bb) == store\n-\t      && expand_omp_atomic_store (load_bb, addr))\n+\t      && expand_omp_atomic_store (load_bb, addr, loaded_val,\n+\t\t\t\t\t  stored_val, index))\n \t    return;\n \n \t  /* When possible, use specialized atomic update functions.  */\n \t  if ((INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type))\n-\t      && store_bb == single_succ (load_bb))\n-\t    {\n-\t      if (expand_omp_atomic_fetch_op (load_bb, addr,\n-\t\t\t\t\t      loaded_val, stored_val, index))\n-\t\treturn;\n-\t    }\n+\t      && store_bb == single_succ (load_bb)\n+\t      && expand_omp_atomic_fetch_op (load_bb, addr,\n+\t\t\t\t\t     loaded_val, stored_val, index))\n+\t    return;\n \n \t  /* If we don't have specialized __sync builtins, try and implement\n \t     as a compare and swap loop.  */"}, {"sha": "171756be7ef82722ac86d5f86bcdf7a002e62757", "filename": "gcc/optabs.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0540978881f0e0de7d84c470628a1897b01b6831", "patch": "@@ -7236,6 +7236,26 @@ can_compare_and_swap_p (enum machine_mode mode, bool allow_libcall)\n   return false;\n }\n \n+/* Return true if an atomic exchange can be performed.  */\n+\n+bool\n+can_atomic_exchange_p (enum machine_mode mode, bool allow_libcall)\n+{\n+  enum insn_code icode;\n+\n+  /* Check for __atomic_exchange.  */\n+  icode = direct_optab_handler (atomic_exchange_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    return true;\n+\n+  /* Don't check __sync_test_and_set, as on some platforms that\n+     has reduced functionality.  Targets that really do support\n+     a proper exchange should simply be updated to the __atomics.  */\n+\n+  return can_compare_and_swap_p (mode, allow_libcall);\n+}\n+\n+\n /* Helper function to find the MODE_CC set in a sync_compare_and_swap\n    pattern.  */\n "}, {"sha": "654d2766f4095e04a243a1ca2f624244282a578f", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0540978881f0e0de7d84c470628a1897b01b6831/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=0540978881f0e0de7d84c470628a1897b01b6831", "patch": "@@ -971,6 +971,9 @@ enum insn_code can_float_p (enum machine_mode, enum machine_mode, int);\n /* Return true if there is an inline compare and swap pattern.  */\n extern bool can_compare_and_swap_p (enum machine_mode, bool);\n \n+/* Return true if there is an inline atomic exchange pattern.  */\n+extern bool can_atomic_exchange_p (enum machine_mode, bool);\n+\n /* Generate code for a compare and swap.  */\n extern bool expand_atomic_compare_and_swap (rtx *, rtx *, rtx, rtx, rtx, bool,\n \t\t\t\t\t    enum memmodel, enum memmodel);"}]}