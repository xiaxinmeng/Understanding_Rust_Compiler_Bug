{"sha": "a1402da35c57aa1c074bfc50b20a2a3135ff2987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE0MDJkYTM1YzU3YWExYzA3NGJmYzUwYjIwYTJhMzEzNWZmMjk4Nw==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2004-10-15T18:43:10Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2004-10-15T18:43:10Z"}, "message": "parse.y (parse_warning_context): Remove ATTRIBUTE_PRINTF_2 and rename parameter 'msg' to 'msgid' in function...\n\n\t* parse.y (parse_warning_context): Remove ATTRIBUTE_PRINTF_2 and\n\trename parameter 'msg' to 'msgid' in function declaration.\n\t(issue_warning_error_from_context): Likewise.\n\t(yyerror): Rename parameter 'msg' to 'msgid'.\n\t(all over): Use new quoting style for diagnostics.\n\n\t* check-init.c: Use %<, %> and %q for quoting in diagnostics,\n\tif possible, else convert `foo' to 'foo'.\n\t* class.c: Likewise.\n\t* decl.c: Likewise.\n\t* expr.c: Likewise.\n\t* jcf-io.c: Likewise.\n\t* jcf-parse.c: Likewise.\n\t* lang.c: Likewise.\n\t* lex.c: Likewise.\n\t* parse.h: Likewise.\n\nFrom-SVN: r89110", "tree": {"sha": "2a09c6df4e237628631d8886fb56b90f7e8897d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a09c6df4e237628631d8886fb56b90f7e8897d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1402da35c57aa1c074bfc50b20a2a3135ff2987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1402da35c57aa1c074bfc50b20a2a3135ff2987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1402da35c57aa1c074bfc50b20a2a3135ff2987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1402da35c57aa1c074bfc50b20a2a3135ff2987/comments", "author": null, "committer": null, "parents": [{"sha": "e68a07e8d547b03b769527365a40721d4d9298c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68a07e8d547b03b769527365a40721d4d9298c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68a07e8d547b03b769527365a40721d4d9298c6"}], "stats": {"total": 414, "additions": 219, "deletions": 195}, "files": [{"sha": "07d2c718a2e9a3f7b195a23daa51c8823ff9d5dd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -1,3 +1,24 @@\n+2004-10-16  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* check-init.c: Use %<, %> and %q for quoting in diagnostics,\n+\tif possible, else convert `foo' to 'foo'.\n+\t* class.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* jcf-io.c: Likewise.\n+\t* jcf-parse.c: Likewise.\n+\t* lang.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* parse.h: Likewise.\n+\n+2004-10-16  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* parse.y (parse_warning_context): Remove ATTRIBUTE_PRINTF_2 and\n+\trename parameter 'msg' to 'msgid' in function declaration.\n+\t(issue_warning_error_from_context): Likewise.\n+\t(yyerror): Rename parameter 'msg' to 'msgid'.\n+\t(all over): Use new quoting style for diagnostics.\n+\n 2004-10-15  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* boehm.c, builtins.c, java-except.h, jcf-io.c, jcf-path.c,"}, {"sha": "1a86c80e3640b64b631147fb0024abceb6f9a0b8", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -197,9 +197,9 @@ get_variable_decl (tree exp)\n static void\n final_assign_error (tree name)\n {\n-  static const char format[]\n-    = \"Can't reassign a value to the final variable `%s'\";\n-  parse_error_context (wfl, format, IDENTIFIER_POINTER (name));\n+  parse_error_context (wfl,\n+                       \"Can't reassign a value to the final variable %qs\",\n+                       IDENTIFIER_POINTER (name));\n }\n \n static void\n@@ -466,7 +466,7 @@ check_init (tree exp, words before)\n \t      && index >= 0 && ! ASSIGNED_P (before, index))\n \t    {\n \t      parse_error_context \n-\t\t(wfl, \"Variable `%s' may not have been initialized\",\n+\t\t(wfl, \"Variable %qs may not have been initialized\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (exp)));\n \t      /* Suppress further errors. */\n \t      DECL_BIT_INDEX (exp) = -2;\n@@ -482,7 +482,7 @@ check_init (tree exp, words before)\n \t  if (index >= 0 && ! ASSIGNED_P (before, index))\n \t    {\n \t      parse_error_context \n-\t\t(wfl, \"variable `%s' may not have been initialized\",\n+\t\t(wfl, \"variable %qs may not have been initialized\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (tmp)));\n \t      /* Suppress further errors. */\n \t      DECL_BIT_INDEX (tmp) = -2;\n@@ -965,7 +965,7 @@ check_for_initialization (tree body, tree mdecl)\n \t      if (index >= 0 && ! ASSIGNED_P (before, index))\n \t\t{\n \t\t  if (! is_finit_method)\n-\t\t    error (\"%Jfinal field `%D' may not have been initialized\",\n+\t\t    error (\"%Jfinal field %qD may not have been initialized\",\n                            decl, decl);\n \t\t}\n \t      else if (is_finit_method)"}, {"sha": "a6c5d4948676e0a864af4caa93d47120c4777742", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -2034,15 +2034,15 @@ layout_class (tree this_class)\n       char *report;\n       tree current;\n \n-      sprintf (buffer, \" with `%s'\",\n+      sprintf (buffer, \" with '%s'\",\n \t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class))));\n       obstack_grow (&temporary_obstack, buffer, strlen (buffer));\n \n       for (current = TREE_CHAIN (class_list); current; \n \t   current = TREE_CHAIN (current))\n \t{\n \t  tree decl = TYPE_NAME (TREE_PURPOSE (current));\n-\t  sprintf (buffer, \"\\n  which inherits from `%s' (%s:%d)\",\n+\t  sprintf (buffer, \"\\n  which inherits from '%s' (%s:%d)\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (decl)),\n \t\t   DECL_SOURCE_FILE (decl),\n \t\t   DECL_SOURCE_LINE (decl));"}, {"sha": "15308c3c15b1ec943fb8c78634c75eb378f3e43c", "filename": "gcc/java/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -1196,10 +1196,10 @@ pushdecl (tree x)\n \t      && chain_member (oldlocal, current_binding_level->level_chain->names))\n \t    {\n \t      if (TREE_CODE (oldlocal) == PARM_DECL)\n-\t\tpedwarn (\"declaration of `%s' shadows a parameter\",\n+\t\tpedwarn (\"declaration of %qs shadows a parameter\",\n \t\t\t IDENTIFIER_POINTER (name));\n \t      else\n-\t\tpedwarn (\"declaration of `%s' shadows a symbol from the parameter list\",\n+\t\tpedwarn (\"declaration of %qs shadows a symbol from the parameter list\",\n \t\t\t IDENTIFIER_POINTER (name));\n \t    }\n \n@@ -1221,12 +1221,12 @@ pushdecl (tree x)\n \t\t   but there is no way to tell it's not a definition.  */\n \t\t;\n \t      else if (oldlocal != 0 && TREE_CODE (oldlocal) == PARM_DECL)\n-\t\twarnstring = \"declaration of `%s' shadows a parameter\";\n+\t\twarnstring = \"declaration of %qs shadows a parameter\";\n \t      else if (oldlocal != 0)\n-\t\twarnstring = \"declaration of `%s' shadows previous local\";\n+\t\twarnstring = \"declaration of %qs shadows previous local\";\n \t      else if (IDENTIFIER_GLOBAL_VALUE (name) != 0\n \t\t       && IDENTIFIER_GLOBAL_VALUE (name) != error_mark_node)\n-\t\twarnstring = \"declaration of `%s' shadows global declaration\";\n+\t\twarnstring = \"declaration of %qs shadows global declaration\";\n \n \t      if (warnstring)\n \t\twarning (warnstring, IDENTIFIER_POINTER (name));"}, {"sha": "13727151967d24d75c4fdd9305a67b795722c1a6", "filename": "gcc/java/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -1486,7 +1486,7 @@ lookup_field (tree *typep, tree name)\n \t\t{\n \t\t  tree i1 = DECL_CONTEXT (save_field);\n \t\t  tree i2 = DECL_CONTEXT (field);\n-\t\t  error (\"reference `%s' is ambiguous: appears in interface `%s' and interface `%s'\",\n+\t\t  error (\"reference %qs is ambiguous: appears in interface %qs and interface %qs\",\n \t\t\t IDENTIFIER_POINTER (name),\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (i1))),\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (i2))));\n@@ -1514,7 +1514,7 @@ build_field_ref (tree self_value, tree self_class, tree name)\n   tree field_decl = lookup_field (&base_class, name);\n   if (field_decl == NULL_TREE)\n     {\n-      error (\"field `%s' not found\", IDENTIFIER_POINTER (name));\n+      error (\"field %qs not found\", IDENTIFIER_POINTER (name));\n       return error_mark_node;\n     }\n   if (self_value == NULL_TREE)\n@@ -2428,7 +2428,7 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n \t  else if (FIELD_STATIC (field_decl))\n \t    {\n \t      if (!DECL_CLINIT_P (current_function_decl))\n-\t\twarning (\"%Jassignment to final static field `%D' not in \"\n+\t\twarning (\"%Jassignment to final static field %qD not in \"\n                          \"class initializer\",\n                          field_decl, field_decl);\n \t    }"}, {"sha": "6a418abb559aa8299b1892f1e31a2c9829347723", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -532,7 +532,7 @@ find_class (const char *classname, int classname_length, JCF *jcf,\n   if (! java && ! class && java_buf.st_mtime > class_buf.st_mtime)\n     {\n       if (flag_newer)\n-\twarning (\"source file for class `%s' is newer than its matching class file.  Source file `%s' used instead\", classname, java_buffer);\n+\twarning (\"source file for class %qs is newer than its matching class file.  Source file %qs used instead\", classname, java_buffer);\n       class = -1;\n     }\n "}, {"sha": "46e096d1d68ff5aaf39895d0ca9c07f401dae7bb", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -726,7 +726,7 @@ jcf_parse (JCF* jcf)\n \t -fforce-classes-archive-check was specified. */\n       if (!jcf->right_zip\n \t  && (!flag_emit_class_files || flag_force_classes_archive_check))\n-\tfatal_error (\"the `java.lang.Object' that was found in `%s' didn't have the special zero-length `gnu.gcj.gcj-compiled' attribute.  This generally means that your classpath is incorrectly set.  Use `info gcj \\\"Input Options\\\"' to see the info page describing how to set the classpath\", jcf->filename);\n+\tfatal_error (\"the %<java.lang.Object%> that was found in %qs didn't have the special zero-length %<gnu.gcj.gcj-compiled%> attribute.  This generally means that your classpath is incorrectly set.  Use %<info gcj \\\"Input Options\\\"%> to see the info page describing how to set the classpath\", jcf->filename);\n     }\n   else\n     all_class_list = tree_cons (NULL_TREE,"}, {"sha": "39277accff105246e23c08748c81326a8b6b9ba7", "filename": "gcc/java/lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -526,7 +526,7 @@ java_print_error_function (diagnostic_context *context ATTRIBUTE_UNUSED,\n \tfprintf (stderr, \"%s: \", file);\n \n       last_error_function_context = DECL_CONTEXT (current_function_decl);\n-      fprintf (stderr, \"In class `%s':\\n\",\n+      fprintf (stderr, \"In class '%s':\\n\",\n \t       lang_printable_name (last_error_function_context, 0));\n     }\n   if (last_error_function != current_function_decl)\n@@ -539,7 +539,7 @@ java_print_error_function (diagnostic_context *context ATTRIBUTE_UNUSED,\n       else\n \t{\n \t  const char *name = lang_printable_name (current_function_decl, 2);\n-\t  fprintf (stderr, \"In %s `%s':\\n\",\n+\t  fprintf (stderr, \"In %s '%s':\\n\",\n \t\t   (DECL_CONSTRUCTOR_P (current_function_decl) ? \"constructor\"\n \t\t    : \"method\"),\n \t\t   name);"}, {"sha": "54df7badd22d907baf385dca17a132d9774a050f", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -253,7 +253,7 @@ java_new_lexer (FILE *finput, const char *encoding)\n     }\n \n   if (enc_error)\n-    fatal_error (\"unknown encoding: `%s'\\nThis might mean that your locale's encoding is not supported\\nby your system's iconv(3) implementation.  If you aren't trying\\nto use a particular encoding for your input file, try the\\n`--encoding=UTF-8' option\", encoding);\n+    fatal_error (\"unknown encoding: %qs\\nThis might mean that your locale's encoding is not supported\\nby your system's iconv(3) implementation.  If you aren't trying\\nto use a particular encoding for your input file, try the\\n%<--encoding=UTF-8%> option\", encoding);\n \n   return lex;\n }"}, {"sha": "eb749a5b7e615b5184b825cddb29cfa36db4481b", "filename": "gcc/java/parse.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -158,14 +158,14 @@ extern tree stabilize_reference (tree);\n   {                                                                          \\\n     if (flag_redundant && (cl) && ((flags) & (__modifier)))\t\t     \\\n       parse_warning_context (cl,                                             \\\n-     \"Discouraged redundant use of `%s' modifier in declaration of %s\",      \\\n+     \"Discouraged redundant use of %qs modifier in declaration of %s\",      \\\n \t\t\t     java_accstring_lookup (__modifier), arg);       \\\n   }\n #define OBSOLETE_MODIFIER_WARNING2(cl, flags, __modifier, arg1, arg2)        \\\n   {                                                                          \\\n     if (flag_redundant && (cl) && ((flags) & (__modifier)))\t\t     \\\n       parse_warning_context (cl,                                             \\\n-     \"Discouraged redundant use of `%s' modifier in declaration of %s `%s'\", \\\n+     \"Discouraged redundant use of %qs modifier in declaration of %s %qs\", \\\n \t\t\t     java_accstring_lookup (__modifier), arg1, arg2);\\\n   }\n \n@@ -349,32 +349,32 @@ enum {\n /* Standard error messages */\n #define ERROR_CANT_CONVERT_TO_BOOLEAN(OPERATOR, NODE, TYPE)\t\t\\\n   parse_error_context ((OPERATOR),\t\t\t\t\t\\\n-    \"Incompatible type for `%s'. Can't convert `%s' to boolean\",\t\\\n+    \"Incompatible type for %qs. Can't convert %qs to boolean\",\t\\\n     operator_string ((NODE)), lang_printable_name ((TYPE),0))\n \n #define ERROR_CANT_CONVERT_TO_NUMERIC(OPERATOR, NODE, TYPE)\t\t\\\n   parse_error_context ((OPERATOR),\t\t\t\t\t\\\n-      \"Incompatible type for `%s'. Can't convert `%s' to numeric type\",\t\\\n+      \"Incompatible type for %qs. Can't convert %qs to numeric type\",\t\\\n       operator_string ((NODE)), lang_printable_name ((TYPE), 0))\n \n #define ERROR_CAST_NEEDED_TO_INTEGRAL(OPERATOR, NODE, TYPE)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   tree _operator = (OPERATOR), _node = (NODE), _type = (TYPE);\t\t\\\n   if (JPRIMITIVE_TYPE_P (_type))\t\t\t\t\t\\\n     parse_error_context (_operator,\t\t\t\t\t\\\n-\"Incompatible type for `%s'. Explicit cast needed to convert `%s' to integral\",\\\n+\"Incompatible type for %qs. Explicit cast needed to convert %qs to integral\",\\\n \t\t\t operator_string(_node),\t\t\t\\\n \t\t\t lang_printable_name (_type, 0));\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     parse_error_context (_operator,\t\t\t\t\t\\\n-      \"Incompatible type for `%s'. Can't convert `%s' to integral\",\t\\\n+      \"Incompatible type for %qs. Can't convert %qs to integral\",\t\\\n \t\t\t operator_string(_node),\t\t\t\\\n \t\t\t lang_printable_name (_type, 0));\t\t\\\n } while (0)\n \n #define ERROR_VARIABLE_NOT_INITIALIZED(WFL, V)\t\t\t\\\n   parse_error_context\t\t\t\t\t\t\\\n-    ((WFL), \"Variable `%s' may not have been initialized\",\t\\\n+    ((WFL), \"Variable %qs may not have been initialized\",\t\\\n      IDENTIFIER_POINTER (V))\n \n /* Definition for loop handling. This is Java's own definition of a"}, {"sha": "9e050f65eeaf25e38cb57ae1bfa3688b31c5c36e", "filename": "gcc/java/parse.y", "status": "modified", "additions": 170, "deletions": 167, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1402da35c57aa1c074bfc50b20a2a3135ff2987/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=a1402da35c57aa1c074bfc50b20a2a3135ff2987", "patch": "@@ -97,14 +97,13 @@ static tree lookup_java_method2 (tree, tree, int);\n static tree method_header (int, tree, tree, tree);\n static void fix_method_argument_names (tree ,tree);\n static tree method_declarator (tree, tree);\n-static void parse_warning_context (tree cl, const char *msg, ...)\n-  ATTRIBUTE_PRINTF_2;\n+static void parse_warning_context (tree cl, const char *msgid, ...);\n #ifdef USE_MAPPED_LOCATION\n static void issue_warning_error_from_context\n-  (source_location, const char *msg, va_list *) ATTRIBUTE_PRINTF (2, 0);\n+  (source_location, const char *msgid, va_list *);\n #else\n-static void issue_warning_error_from_context (tree, const char *msg, va_list *)\n-  ATTRIBUTE_PRINTF (2, 0);\n+static void issue_warning_error_from_context\n+  (tree, const char *msgid, va_list *);\n #endif\n static void parse_ctor_invocation_error (void);\n static tree parse_jdk1_1_error (const char *);\n@@ -774,7 +773,7 @@ single_type_import_declaration:\n \t\t      tree err = find_name_in_single_imports (last_name);\n \t\t      if (err && err != name)\n \t\t\tparse_error_context\n-\t\t\t  ($2, \"Ambiguous class: `%s' and `%s'\",\n+\t\t\t  ($2, \"Ambiguous class: %qs and %qs\",\n \t\t\t   IDENTIFIER_POINTER (name),\n \t\t\t   IDENTIFIER_POINTER (err));\n \t\t      else\n@@ -840,7 +839,7 @@ modifiers:\n \t\t  int acc = (1 << $2);\n \t\t  if ($$ & acc)\n \t\t    parse_error_context\n-\t\t      (ctxp->modifier_ctx [$2], \"Modifier `%s' declared twice\",\n+\t\t      (ctxp->modifier_ctx [$2], \"Modifier %qs declared twice\",\n \t\t       java_accstring_lookup (acc));\n \t\t  else\n \t\t    {\n@@ -961,7 +960,7 @@ field_declaration:\n |\tmodifiers type variable_declarators SC_TK\n \t\t{\n \t\t  check_modifiers\n-\t\t    (\"Illegal modifier `%s' for field declaration\",\n+\t\t    (\"Illegal modifier %qs for field declaration\",\n \t\t     $1, FIELD_MODIFIERS);\n \t\t  check_modifiers_consistency ($1);\n \t\t  register_fields ($1, $2, $3);\n@@ -1136,7 +1135,7 @@ formal_parameter:\n final:\n \tmodifiers\n \t\t{\n-\t\t  check_modifiers (\"Illegal modifier `%s'. Only `final' was expected here\",\n+\t\t  check_modifiers (\"Illegal modifier %qs. Only %<final%> was expected here\",\n \t\t\t\t   $1, ACC_FINAL);\n \t\t  if ($1 != ACC_FINAL)\n \t\t    MODIFIER_WFL (FINAL_TK) = build_wfl_node (NULL_TREE);\n@@ -1178,13 +1177,13 @@ static_initializer:\n static:\t\t\t\t/* Test lval.sub_token here */\n \tmodifiers\n \t\t{\n-\t\t  check_modifiers (\"Illegal modifier `%s' for static initializer\", $1, ACC_STATIC);\n+\t\t  check_modifiers (\"Illegal modifier %qs for static initializer\", $1, ACC_STATIC);\n \t\t  /* Can't have a static initializer in an innerclass */\n \t\t  if ($1 | ACC_STATIC &&\n \t\t      GET_CPC_LIST () && !TOPLEVEL_CLASS_DECL_P (GET_CPC ()))\n \t\t    parse_error_context\n \t\t      (MODIFIER_WFL (STATIC_TK),\n-\t\t       \"Can't define static initializer in class `%s'. Static initializer can only be defined in top-level classes\",\n+\t\t       \"Can't define static initializer in class %qs. Static initializer can only be defined in top-level classes\",\n \t\t       IDENTIFIER_POINTER (DECL_NAME (GET_CPC ())));\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", $1));\n \t\t}\n@@ -1894,7 +1893,7 @@ synchronized:\n \tmodifiers\n \t\t{\n \t\t  check_modifiers (\n-             \"Illegal modifier `%s'. Only `synchronized' was expected here\",\n+             \"Illegal modifier %qs. Only %<synchronized%> was expected here\",\n \t\t\t\t   $1, ACC_SYNCHRONIZED);\n \t\t  if ($1 != ACC_SYNCHRONIZED)\n \t\t    MODIFIER_WFL (SYNCHRONIZED_TK) =\n@@ -3041,15 +3040,15 @@ parse_ctor_invocation_error (void)\n static tree\n parse_jdk1_1_error (const char *msg)\n {\n-  sorry (\": `%s' JDK1.1(TM) feature\", msg);\n+  sorry (\": %qs JDK1.1(TM) feature\", msg);\n   java_error_count++;\n   return build_java_empty_stmt ();\n }\n \n static int do_warning = 0;\n \n void\n-yyerror (const char *msg)\n+yyerror (const char *msgid)\n {\n #ifdef USE_MAPPED_LOCATION\n   static source_location elc;\n@@ -3084,13 +3083,13 @@ yyerror (const char *msg)\n       /* Do something to use the previous line if we're reaching the\n \t end of the file... */\n #ifdef VERBOSE_SKELETON\n-      printf (\"* Error detected (%s)\\n\", (msg ? msg : \"(null)\"));\n+      printf (\"* Error detected (%s)\\n\", (msgid ? msgid : \"(null)\"));\n #endif\n       return;\n     }\n \n   /* Ignore duplicate message on the same line. BTW, this is dubious. FIXME */\n-  if (!force_error && msg == prev_msg && prev_lineno == current_line)\n+  if (!force_error && msgid == prev_msg && prev_lineno == current_line)\n     return;\n \n   ctxp->java_error_flag = 0;\n@@ -3100,11 +3099,11 @@ yyerror (const char *msg)\n     java_error_count++;\n \n #if 0 /* FIXME */\n-  if (elc.col == 0 && msg && msg[1] == ';')\n+  if (elc.col == 0 && msgid && msgid[1] == ';')\n     elc = ctxp->prev_line_end;\n #endif\n \n-  prev_msg = msg;\n+  prev_msg = msgid;\n \n #ifdef USE_MAPPED_LOCATION\n   prev_lineno = current_line;\n@@ -3121,9 +3120,9 @@ yyerror (const char *msg)\n \t\t code_from_source, strlen (code_from_source));\n   remainder = obstack_finish (&temporary_obstack);\n   if (do_warning)\n-    warning (\"%s.\\n%s\", msg, remainder);\n+    warning (\"%s.\\n%s\", msgid, remainder);\n   else\n-    error (\"%s.\\n%s\", msg, remainder);\n+    error (\"%s.\\n%s\", msgid, remainder);\n \n   /* This allow us to cheaply avoid an extra 'Invalid expression\n      statement' error report when errors have been already reported on\n@@ -3314,7 +3313,7 @@ static int\n not_accessible_field_error (tree wfl, tree decl)\n {\n   parse_error_context \n-    (wfl, \"Can't access %s field `%s.%s' from `%s'\",\n+    (wfl, \"Can't access %s field %<%s.%s%> from %qs\",\n      accessibility_string (get_access_flags_from_decl (decl)),\n      GET_TYPE_NAME (DECL_CONTEXT (decl)),\n      IDENTIFIER_POINTER (DECL_NAME (decl)),\n@@ -3383,7 +3382,7 @@ accessibility_string (int flags)\n static void\n classitf_redefinition_error (const char *context, tree id, tree decl, tree cl)\n {\n-  parse_error_context (cl, \"%s `%s' already defined in %s:%d\",\n+  parse_error_context (cl, \"%s %qs already defined in %s:%d\",\n \t\t       context, IDENTIFIER_POINTER (id),\n \t\t       DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n   /* Here we should point out where its redefined. It's a unicode. FIXME */\n@@ -3401,7 +3400,7 @@ variable_redefinition_error (tree context, tree name, tree type, int line)\n     type_name = lang_printable_name (type, 0);\n \n   parse_error_context (context,\n-\t\t       \"Variable `%s' is already defined in this method and was declared `%s %s' at line %d\",\n+\t\t       \"Variable %qs is already defined in this method and was declared %<%s %s%> at line %d\",\n \t\t       IDENTIFIER_POINTER (name),\n \t\t       type_name, IDENTIFIER_POINTER (name), line);\n }\n@@ -3512,7 +3511,7 @@ static void\n parser_add_interface (tree class_decl, tree interface_decl, tree wfl)\n {\n   if (maybe_add_interface (TREE_TYPE (class_decl), TREE_TYPE (interface_decl)))\n-    parse_error_context (wfl, \"Interface `%s' repeated\",\n+    parse_error_context (wfl, \"Interface %qs repeated\",\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (interface_decl)));\n }\n \n@@ -3542,7 +3541,7 @@ check_class_interface_creation (int is_interface, int flags, tree raw_name,\n       && !CPC_INNER_P ())\n     {\n       parse_error_context\n-\t(cl, \"%s name `%s' clashes with imported type `%s'\",\n+\t(cl, \"%s name %qs clashes with imported type %qs\",\n \t (is_interface ? \"Interface\" : \"Class\"),\n \t IDENTIFIER_POINTER (raw_name), IDENTIFIER_POINTER (node));\n       return 1;\n@@ -3574,7 +3573,7 @@ check_class_interface_creation (int is_interface, int flags, tree raw_name,\n \t\t   f , IDENTIFIER_LENGTH (raw_name)) ||\n \t  f [IDENTIFIER_LENGTH (raw_name)] != '.')\n \tparse_error_context\n-\t  (cl, \"Public %s `%s' must be defined in a file called `%s.java'\",\n+\t  (cl, \"Public %s %qs must be defined in a file called %<%s.java%>\",\n \t\t\t     (is_interface ? \"interface\" : \"class\"),\n \t\t\t     IDENTIFIER_POINTER (qualified_name),\n \t\t\t     IDENTIFIER_POINTER (raw_name));\n@@ -3589,7 +3588,7 @@ check_class_interface_creation (int is_interface, int flags, tree raw_name,\n \t complaining a second time */\n       if (CPC_INNER_P () && !TOPLEVEL_CLASS_DECL_P (GET_CPC()))\n \t{\n-\t  parse_error_context (cl, \"Inner class `%s' can't be static. Static classes can only occur in interfaces and top-level classes\",\n+\t  parse_error_context (cl, \"Inner class %qs can't be static. Static classes can only occur in interfaces and top-level classes\",\n \t\t\t       IDENTIFIER_POINTER (qualified_name));\n \t  sca = ACC_STATIC;\n \t}\n@@ -3624,13 +3623,13 @@ check_class_interface_creation (int is_interface, int flags, tree raw_name,\n       else\n \tuaaf = INTERFACE_MODIFIERS;\n \n-      check_modifiers (\"Illegal modifier `%s' for interface declaration\",\n+      check_modifiers (\"Illegal modifier %qs for interface declaration\",\n \t\t       flags, uaaf);\n     }\n   else\n     check_modifiers ((current_function_decl ?\n-\t\t      \"Illegal modifier `%s' for local class declaration\" :\n-\t\t      \"Illegal modifier `%s' for class declaration\"),\n+\t\t      \"Illegal modifier %qs for local class declaration\" :\n+\t\t      \"Illegal modifier %qs for class declaration\"),\n \t\t     flags, uaaf|sca|icaf);\n   return 0;\n }\n@@ -3670,7 +3669,7 @@ check_inner_class_redefinition (tree raw_name, tree cl)\n     if (raw_name == GET_CPC_UN_NODE (scope_list))\n       {\n \tparse_error_context\n-\t  (cl, \"The class name `%s' is already defined in this scope. An inner class may not have the same simple name as any of its enclosing classes\",\n+\t  (cl, \"The class name %qs is already defined in this scope. An inner class may not have the same simple name as any of its enclosing classes\",\n \t   IDENTIFIER_POINTER (raw_name));\n \treturn 1;\n       }\n@@ -3997,7 +3996,7 @@ create_interface (int flags, tree id, tree super)\n   if ((flags & ACC_ABSTRACT) && flag_redundant)\n     parse_warning_context\n       (MODIFIER_WFL (ABSTRACT_TK),\n-       \"Redundant use of `abstract' modifier. Interface `%s' is implicitly abstract\", IDENTIFIER_POINTER (raw_name));\n+       \"Redundant use of %<abstract%> modifier. Interface %qs is implicitly abstract\", IDENTIFIER_POINTER (raw_name));\n \n   /* Create a new decl if DECL is NULL, otherwise fix it */\n   decl = maybe_create_class_interface_decl (decl, raw_name, q_name, id);\n@@ -4152,7 +4151,7 @@ create_class (int flags, tree id, tree super, tree interfaces)\n        - Public classes defined in the correct file */\n   if ((flags & ACC_ABSTRACT) && (flags & ACC_FINAL))\n     parse_error_context\n-      (id, \"Class `%s' can't be declared both abstract and final\",\n+      (id, \"Class %qs can't be declared both abstract and final\",\n        IDENTIFIER_POINTER (raw_name));\n \n   /* Create a new decl if DECL is NULL, otherwise fix it */\n@@ -4164,7 +4163,7 @@ create_class (int flags, tree id, tree super, tree interfaces)\n       /* java.lang.Object can't extend anything.  */\n       if (TREE_TYPE (IDENTIFIER_CLASS_VALUE (class_id)) == object_type_node)\n \t{\n-\t  parse_error_context (id, \"`java.lang.Object' can't extend anything\");\n+\t  parse_error_context (id, \"%<java.lang.Object%> can't extend anything\");\n \t  return NULL_TREE;\n \t}\n \n@@ -4406,7 +4405,7 @@ duplicate_declaration_error_p (tree new_field_name, tree new_type, tree cl)\n \t\t\t  IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl))) :\n \t\t\t  lang_printable_name (TREE_TYPE (decl), 1)));\n       parse_error_context\n-\t(cl , \"Duplicate variable declaration: `%s %s' was `%s %s' (%s:%d)\",\n+\t(cl, \"Duplicate variable declaration: %<%s %s%> was %<%s %s%> (%s:%d)\",\n \t t1, IDENTIFIER_POINTER (new_field_name),\n \t t2, IDENTIFIER_POINTER (DECL_NAME (decl)),\n \t DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n@@ -4446,7 +4445,7 @@ register_fields (int flags, tree type, tree variable_list)\n \t\t\t\t flags, ACC_STATIC, \"interface field(s)\");\n       OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (FINAL_TK),\n \t\t\t\t flags, ACC_FINAL, \"interface field(s)\");\n-      check_modifiers (\"Illegal interface member modifier `%s'\", flags,\n+      check_modifiers (\"Illegal interface member modifier %qs\", flags,\n \t\t       INTERFACE_FIELD_MODIFIERS);\n       flags |= (ACC_PUBLIC | ACC_STATIC | ACC_FINAL);\n     }\n@@ -4470,7 +4469,7 @@ register_fields (int flags, tree type, tree variable_list)\n       if ((flags & ACC_STATIC) && !TOPLEVEL_CLASS_TYPE_P (class_type)\n           && !(flags & ACC_FINAL))\n \tparse_error_context\n-          (cl, \"Field `%s' can't be static in inner class `%s' unless it is final\",\n+          (cl, \"Field %qs can't be static in inner class %qs unless it is final\",\n \t   IDENTIFIER_POINTER (EXPR_WFL_NODE (cl)),\n \t   lang_printable_name (class_type, 0));\n \n@@ -4715,21 +4714,22 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n       if (!CLASS_ABSTRACT (TYPE_NAME (this_class))\n \t  && !CLASS_INTERFACE (TYPE_NAME (this_class)))\n \tparse_error_context\n-\t  (id, \"Class `%s' must be declared abstract to define abstract method `%s'\",\n+\t  (id,\n+           \"Class %qs must be declared abstract to define abstract method %qs\",\n \t   IDENTIFIER_POINTER (DECL_NAME (GET_CPC ())),\n \t   IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n     }\n \n   /* A native method can't be strictfp.  */\n   if ((flags & ACC_NATIVE) && (flags & ACC_STRICT))\n-    parse_error_context (id, \"native method `%s' can't be strictfp\",\n+    parse_error_context (id, \"native method %qs can't be strictfp\",\n \t\t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n   /* No such thing as a transient or volatile method.  */\n   if ((flags & ACC_TRANSIENT))\n-    parse_error_context (id, \"method `%s' can't be transient\",\n+    parse_error_context (id, \"method %qs can't be transient\",\n \t\t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n   if ((flags & ACC_VOLATILE))\n-    parse_error_context (id, \"method `%s' can't be volatile\",\n+    parse_error_context (id, \"method %qs can't be volatile\",\n \t\t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n \n   /* Things to be checked when declaring a constructor */\n@@ -4779,7 +4779,7 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   if ((flags & ACC_STATIC) && !TOPLEVEL_CLASS_TYPE_P (this_class))\n     {\n       parse_error_context\n-\t(id, \"Method `%s' can't be static in inner class `%s'. Only members of interfaces and top-level classes can be static\",\n+\t(id, \"Method %qs can't be static in inner class %qs. Only members of interfaces and top-level classes can be static\",\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (id)),\n \t lang_printable_name (this_class, 0));\n     }\n@@ -4945,7 +4945,7 @@ finish_method_declaration (tree method_body)\n     {\n       tree name = DECL_NAME (current_function_decl);\n       parse_error_context (DECL_FUNCTION_WFL (current_function_decl),\n-\t\t\t   \"%s method `%s' can't have a body defined\",\n+\t\t\t   \"%s method %qs can't have a body defined\",\n \t\t\t   (METHOD_NATIVE (current_function_decl) ?\n \t\t\t    \"Native\" : \"Abstract\"),\n \t\t\t   IDENTIFIER_POINTER (name));\n@@ -4956,7 +4956,7 @@ finish_method_declaration (tree method_body)\n       tree name = DECL_NAME (current_function_decl);\n       parse_error_context\n \t(DECL_FUNCTION_WFL (current_function_decl),\n-\t \"Non native and non abstract method `%s' must have a body defined\",\n+\t \"Non native and non abstract method %qs must have a body defined\",\n \t IDENTIFIER_POINTER (name));\n       method_body = NULL_TREE;\n     }\n@@ -4993,7 +4993,7 @@ constructor_circularity_msg (tree from, tree to)\n {\n   static char string [4096];\n   char *t = xstrdup (lang_printable_name (from, 2));\n-  sprintf (string, \"`%s' invokes `%s'\", t, lang_printable_name (to, 2));\n+  sprintf (string, \"'%s' invokes '%s'\", t, lang_printable_name (to, 2));\n   free (t);\n   return string;\n }\n@@ -5027,7 +5027,7 @@ verify_constructor_circularity (tree meth, tree current)\n \t    }\n \t  t = xstrdup (lang_printable_name (meth, 2));\n \t  parse_error_context (TREE_PURPOSE (c),\n-\t\t\t       \"%s: recursive invocation of constructor `%s'\",\n+\t\t\t       \"%s: recursive invocation of constructor %qs\",\n \t\t\t       constructor_circularity_msg (current, meth), t);\n \t  free (t);\n \t  vcc_list = NULL_TREE;\n@@ -5057,15 +5057,15 @@ check_modifiers_consistency (int flags)\n   THIS_MODIFIER_ONLY (flags, ACC_PROTECTED, PROTECTED_TK, acc_count, cl);\n   if (acc_count > 1)\n     parse_error_context\n-      (cl, \"Inconsistent member declaration.  At most one of `public', `private', or `protected' may be specified\");\n+      (cl, \"Inconsistent member declaration.  At most one of %<public%>, %<private%>, or %<protected%> may be specified\");\n \n   acc_count = 0;\n   cl = NULL_TREE;\n   THIS_MODIFIER_ONLY (flags, ACC_FINAL, FINAL_TK, acc_count, cl);\n   THIS_MODIFIER_ONLY (flags, ACC_VOLATILE, VOLATILE_TK, acc_count, cl);\n   if (acc_count > 1)\n     parse_error_context (cl,\n-\t\t\t \"Inconsistent member declaration.  At most one of `final' or `volatile' may be specified\");\n+\t\t\t \"Inconsistent member declaration.  At most one of %<final%> or %<volatile%> may be specified\");\n }\n \n /* Check the methode header METH for abstract specifics features */\n@@ -5082,7 +5082,7 @@ check_abstract_method_header (tree meth)\n \t\t\t      ACC_PUBLIC, \"abstract method\",\n \t\t\t      IDENTIFIER_POINTER (DECL_NAME (meth)));\n \n-  check_modifiers (\"Illegal modifier `%s' for interface method\",\n+  check_modifiers (\"Illegal modifier %qs for interface method\",\n \t\t  flags, INTERFACE_METHOD_MODIFIERS);\n }\n \n@@ -5155,7 +5155,7 @@ method_declarator (tree id, tree list)\n \tif (TREE_PURPOSE (already) == name)\n \t  {\n \t    parse_error_context\n-\t      (wfl_name, \"Variable `%s' is used more than once in the argument list of method `%s'\",\n+\t      (wfl_name, \"Variable %qs is used more than once in the argument list of method %qs\",\n \t       IDENTIFIER_POINTER (name),\n \t       IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n \t    break;\n@@ -5239,7 +5239,7 @@ parser_check_super_interface (tree super_decl, tree this_decl, tree this_wfl)\n   if (!CLASS_INTERFACE (super_decl))\n     {\n       parse_error_context\n-\t(this_wfl, \"%s `%s' can't implement/extend %s `%s'\",\n+\t(this_wfl, \"%s %qs can't implement/extend %s %qs\",\n \t (CLASS_INTERFACE (TYPE_NAME (TREE_TYPE (this_decl))) ?\n \t  \"Interface\" : \"Class\"),\n \t IDENTIFIER_POINTER (DECL_NAME (this_decl)),\n@@ -5273,7 +5273,7 @@ parser_check_super (tree super_decl, tree this_decl, tree wfl)\n   if (TYPE_ARRAY_P (super_type) || CLASS_INTERFACE (TYPE_NAME (super_type)))\n     {\n       parse_error_context\n-\t(wfl, \"Class `%s' can't subclass %s `%s'\",\n+\t(wfl, \"Class %qs can't subclass %s %qs\",\n \t IDENTIFIER_POINTER (DECL_NAME (this_decl)),\n \t (CLASS_INTERFACE (TYPE_NAME (super_type)) ? \"interface\" : \"array\"),\n \t IDENTIFIER_POINTER (DECL_NAME (super_decl)));\n@@ -5753,7 +5753,7 @@ java_complete_class (void)\n \t\tDECL_USER_ALIGN (field_decl) = 0;\n \t\tlayout_decl (field_decl, 0);\n \t\tSOURCE_FRONTEND_DEBUG\n-\t\t  ((\"Completed field/var decl `%s' with `%s'\",\n+\t\t  ((\"Completed field/var decl '%s' with '%s'\",\n \t\t    IDENTIFIER_POINTER (DECL_NAME (field_decl)),\n \t\t    IDENTIFIER_POINTER (DECL_NAME (decl))));\n \t\tbreak;\n@@ -5771,8 +5771,8 @@ java_complete_class (void)\n \t\t      JDEP_APPLY_PATCH (dep, type);\n \t\t      SOURCE_FRONTEND_DEBUG\n \t\t\t(((JDEP_KIND (dep) == JDEP_METHOD_RETURN ?\n-\t\t\t   \"Completing fct `%s' with ret type `%s'\":\n-\t\t\t   \"Completing arg `%s' with type `%s'\"),\n+\t\t\t   \"Completing fct '%s' with ret type '%s'\":\n+\t\t\t   \"Completing arg '%s' with type '%s'\"),\n \t\t\t  IDENTIFIER_POINTER (EXPR_WFL_NODE\n \t\t\t\t\t      (JDEP_DECL_WFL (dep))),\n \t\t\t  IDENTIFIER_POINTER (DECL_NAME (decl))));\n@@ -5826,7 +5826,7 @@ java_complete_class (void)\n \t    case JDEP_EXCEPTION:\n \t      JDEP_APPLY_PATCH (dep, TREE_TYPE (decl));\n \t      SOURCE_FRONTEND_DEBUG\n-\t\t((\"Completing `%s' `throws' argument node\",\n+\t\t((\"Completing '%s' 'throws' argument node\",\n \t\t  IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))));\n \t      break;\n \n@@ -6179,46 +6179,46 @@ complete_class_report_errors (jdep *dep)\n     {\n     case JDEP_SUPER:\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Superclass `%s' of class `%s' not found\",\n+\t(JDEP_WFL (dep), \"Superclass %qs of class %qs not found\",\n \t purify_type_name (name),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_FIELD:\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Type `%s' not found in declaration of field `%s'\",\n+\t(JDEP_WFL (dep), \"Type %qs not found in declaration of field %qs\",\n \t purify_type_name (name),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_METHOD:\t\t/* Covers arguments */\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the argument `%s' of method `%s'\",\n+\t(JDEP_WFL (dep), \"Type %qs not found in the declaration of the argument %qs of method %qs\",\n \t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_MISC (dep))));\n       break;\n     case JDEP_METHOD_RETURN:\t/* Covers return type */\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the return type of method `%s'\",\n+\t(JDEP_WFL (dep), \"Type %qs not found in the declaration of the return type of method %qs\",\n \t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))));\n       break;\n     case JDEP_INTERFACE:\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Superinterface `%s' of %s `%s' not found\",\n+\t(JDEP_WFL (dep), \"Superinterface %qs of %s %qs not found\",\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n \t (CLASS_OR_INTERFACE (JDEP_DECL (dep), \"class\", \"interface\")),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_VARIABLE:\n       parse_error_context\n-\t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the local variable `%s'\",\n+\t(JDEP_WFL (dep), \"Type %qs not found in the declaration of the local variable %qs\",\n \t purify_type_name (IDENTIFIER_POINTER\n \t\t\t   (EXPR_WFL_NODE (JDEP_WFL (dep)))),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_EXCEPTION:\t/* As specified by `throws' */\n       parse_error_context\n-\t  (JDEP_WFL (dep), \"Class `%s' not found in `throws'\",\n+\t  (JDEP_WFL (dep), \"Class %qs not found in %<throws%>\",\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))));\n       break;\n     default:\n@@ -6275,7 +6275,7 @@ check_method_redefinition (tree class, tree method)\n \t  && !DECL_ARTIFICIAL (method))\n \t{\n \t  parse_error_context\n-\t    (DECL_FUNCTION_WFL (method), \"Duplicate %s declaration `%s'\",\n+\t    (DECL_FUNCTION_WFL (method), \"Duplicate %s declaration %qs\",\n \t     (DECL_CONSTRUCTOR_P (redef) ? \"constructor\" : \"method\"),\n \t     get_printable_method_name (redef));\n \t  return 1;\n@@ -6349,7 +6349,7 @@ check_abstract_method_definitions (int do_interface, tree class_decl,\n \n \t  parse_error_context\n \t    (lookup_cl (class_decl),\n-\t     \"Class `%s' doesn't define the abstract method `%s %s' from %s `%s'. This method must be defined or %s `%s' must be declared abstract\",\n+\t     \"Class %qs doesn't define the abstract method %<%s %s%> from %s %<%s%>. This method must be defined or %s %qs must be declared abstract\",\n \t     IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t     t, lang_printable_name (method, 2),\n \t     (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))) ?\n@@ -6505,7 +6505,7 @@ java_check_regular_methods (tree class_decl)\n \t{\n \t  if (!inherits_from_p (TREE_VALUE (mthrows), throwable_type_node))\n \t    parse_error_context\n-\t      (TREE_PURPOSE (mthrows), \"Class `%s' in `throws' clause must be a subclass of class `java.lang.Throwable'\",\n+\t      (TREE_PURPOSE (mthrows), \"Class %qs in %<throws%> clause must be a subclass of class %<java.lang.Throwable%>\",\n \t       IDENTIFIER_POINTER\n \t         (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))));\n \t}\n@@ -6528,7 +6528,7 @@ java_check_regular_methods (tree class_decl)\n \t{\n \t  char *t = xstrdup (lang_printable_name (class, 0));\n \t  parse_error_context\n-\t    (method_wfl, \"Method `%s' can't be static in inner class `%s'. Only members of interfaces and top-level classes can be static\",\n+\t    (method_wfl, \"Method %qs can't be static in inner class %qs. Only members of interfaces and top-level classes can be static\",\n \t     lang_printable_name (method, 2), t);\n \t  free (t);\n \t}\n@@ -6549,7 +6549,7 @@ java_check_regular_methods (tree class_decl)\n \t  && !METHOD_PUBLIC (method))\n \t{\n \t  tree found_decl = TYPE_NAME (DECL_CONTEXT (found));\n-\t  parse_error_context (method_wfl, \"Class `%s' must override `%s' with a public method in order to implement interface `%s'\",\n+\t  parse_error_context (method_wfl, \"Class %qs must override %qs with a public method in order to implement interface %qs\",\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t\t\t       lang_printable_name (method, 2),\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (found_decl)));\n@@ -6563,7 +6563,7 @@ java_check_regular_methods (tree class_decl)\n \t    (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 2));\n \t  parse_error_context\n \t    (method_wfl,\n-\t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n+\t     \"Method %qs was defined with return type %qs in class %qs\",\n \t     lang_printable_name (found, 2), t,\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -6580,7 +6580,7 @@ java_check_regular_methods (tree class_decl)\n \t    continue;\n \t  parse_error_context\n \t    (method_wfl,\n-\t     \"%s methods can't be overridden. Method `%s' is %s in class `%s'\",\n+\t     \"%s methods can't be overridden. Method %qs is %s in class %qs\",\n \t     (METHOD_FINAL (found) ? \"Final\" : \"Static\"),\n \t     lang_printable_name (found, 2),\n \t     (METHOD_FINAL (found) ? \"final\" : \"static\"),\n@@ -6594,7 +6594,7 @@ java_check_regular_methods (tree class_decl)\n \t{\n \t  parse_error_context\n \t    (method_wfl,\n-\t     \"Instance methods can't be overridden by a static method. Method `%s' is an instance method in class `%s'\",\n+\t     \"Instance methods can't be overridden by a static method. Method %qs is an instance method in class %qs\",\n \t     lang_printable_name (found, 2),\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -6617,7 +6617,7 @@ java_check_regular_methods (tree class_decl)\n \t{\n \t  parse_error_context\n \t    (method_wfl,\n-\t     \"Methods can't be overridden to be more private. Method `%s' is not %s in class `%s'\", lang_printable_name (method, 2),\n+\t     \"Methods can't be overridden to be more private. Method %qs is not %s in class %qs\", lang_printable_name (method, 2),\n \t     (METHOD_PUBLIC (method) ? \"public\" :\n \t      (METHOD_PRIVATE (method) ? \"private\" : \"protected\")),\n \t     IDENTIFIER_POINTER (DECL_NAME\n@@ -6758,7 +6758,7 @@ check_throws_clauses (tree method, tree method_wfl, tree found)\n       if (!fthrows)\n \t{\n \t  parse_error_context\n-\t    (method_wfl, \"Invalid checked exception class `%s' in `throws' clause.  The exception must be a subclass of an exception thrown by `%s' from class `%s'\",\n+\t    (method_wfl, \"Invalid checked exception class %qs in %<throws%> clause.  The exception must be a subclass of an exception thrown by %qs from class %qs\",\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))),\n \t     lang_printable_name (found, 2),\n \t     IDENTIFIER_POINTER\n@@ -6790,7 +6790,7 @@ java_check_abstract_methods (tree interface_decl)\n \t  t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 2));\n \t  parse_error_context\n \t    (DECL_FUNCTION_WFL (found),\n-\t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n+\t     \"Method %qs was defined with return type %qs in class %qs\",\n \t     lang_printable_name (found, 2), t,\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -6815,7 +6815,7 @@ java_check_abstract_methods (tree interface_decl)\n \t    {\n \t      parse_error_context\n \t\t(lookup_cl (sub_interface_method),\n-\t\t \"Interface `%s' inherits method `%s' from interface `%s'. This method is redefined with a different return type in interface `%s'\",\n+\t\t \"Interface %qs inherits method %qs from interface %qs. This method is redefined with a different return type in interface %qs\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))),\n \t\t lang_printable_name (found, 2),\n \t\t IDENTIFIER_POINTER\n@@ -6990,7 +6990,7 @@ process_imports (void)\n       if (!IDENTIFIER_CLASS_VALUE (to_be_found))\n \t{\n \t  parse_error_context (TREE_PURPOSE (import),\n-\t\t\t       \"Class or interface `%s' not found in import\",\n+\t\t\t       \"Class or interface %qs not found in import\",\n \t\t\t       original_name);\n \t  error_found = 1;\n \t}\n@@ -7146,12 +7146,12 @@ read_import_dir (tree wfl)\n       static int first = 1;\n       if (first)\n \t{\n-\t  error (\"Can't find default package `%s'. Check the CLASSPATH environment variable and the access to the archives\", package_name);\n+\t  error (\"Can't find default package %qs. Check the CLASSPATH environment variable and the access to the archives\", package_name);\n \t  java_error_count++;\n \t  first = 0;\n \t}\n       else\n-\tparse_error_context (wfl, \"Package `%s' not found in import\",\n+\tparse_error_context (wfl, \"Package %qs not found in import\",\n \t\t\t     package_name);\n       current_jcf = saved_jcf;\n       return;\n@@ -7248,7 +7248,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \t      seen_once++;\n \t      parse_error_context\n \t\t(location,\n-\t\t \"Type `%s' also potentially defined in package `%s'\",\n+\t\t \"Type %qs also potentially defined in package %qs\",\n \t\t IDENTIFIER_POINTER (TYPE_NAME (class_type)),\n \t\t IDENTIFIER_POINTER (package));\n \t    }\n@@ -7431,7 +7431,7 @@ check_pkg_class_access (tree class_name, tree cl, bool verbose, tree this_decl)\n       if (verbose)\n \tparse_error_context\n \t  (cl == NULL ? lookup_cl (this_decl): cl,\n-           \"Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed\",\n+           \"Can't access %s %qs. Only public classes and interfaces in other packages can be accessed\",\n \t   (CLASS_INTERFACE (TYPE_NAME (type)) ? \"interface\" : \"class\"),\n \t   IDENTIFIER_POINTER (class_name));\n       return 1;\n@@ -7469,7 +7469,7 @@ declare_local_variables (int modifier, tree type, tree vlist)\n \t{\n \t  parse_error_context\n \t    (ctxp->modifier_ctx [i],\n-\t     \"Only `final' is allowed as a local variables modifier\");\n+\t     \"Only %<final%> is allowed as a local variables modifier\");\n \t  return;\n \t}\n     }\n@@ -9023,7 +9023,7 @@ fix_constructors (tree mdecl)\n \t  DECL_NAME (mdecl) = DECL_NAME (sclass_decl);\n \t  parse_error_context\n \t    (lookup_cl (TYPE_NAME (class_type)),\n-\t     \"No constructor matching `%s' found in class `%s'\",\n+\t     \"No constructor matching %qs found in class %qs\",\n \t     lang_printable_name (mdecl, 2), n);\n \t  DECL_NAME (mdecl) = save;\n \t}\n@@ -9522,7 +9522,7 @@ resolve_expression_name (tree id, tree *orig)\n \t\t  && !enclosing_context_p (DECL_CONTEXT (decl), current_class))\n \t\t{\n \t\t  parse_error_context\n-\t\t    (id, \"Can't reference `%s' before the superclass constructor has been called\", IDENTIFIER_POINTER (name));\n+\t\t    (id, \"Can't reference %qs before the superclass constructor has been called\", IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n \n@@ -9576,12 +9576,12 @@ resolve_expression_name (tree id, tree *orig)\n   /* We've got an error here */\n   if (INNER_CLASS_TYPE_P (current_class))\n     parse_error_context (id,\n-\t\t\t \"Local variable `%s' can't be accessed from within the inner class `%s' unless it is declared final\",\n+\t\t\t \"Local variable %qs can't be accessed from within the inner class %qs unless it is declared final\",\n \t\t\t IDENTIFIER_POINTER (name),\n \t\t\t IDENTIFIER_POINTER (DECL_NAME\n \t\t\t\t\t     (TYPE_NAME (current_class))));\n   else\n-    parse_error_context (id, \"Undefined variable `%s'\",\n+    parse_error_context (id, \"Undefined variable %qs\",\n \t\t\t IDENTIFIER_POINTER (name));\n \n   return error_mark_node;\n@@ -9592,7 +9592,7 @@ static_ref_err (tree wfl, tree field_id, tree class_type)\n {\n   parse_error_context\n     (wfl,\n-     \"Can't make a static reference to nonstatic variable `%s' in class `%s'\",\n+     \"Can't make a static reference to nonstatic variable %qs in class %qs\",\n      IDENTIFIER_POINTER (field_id),\n      IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class_type))));\n }\n@@ -9798,7 +9798,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      && INNER_ENCLOSING_SCOPE_CHECK (type))\n \t    {\n \t      parse_error_context\n-\t\t(qual_wfl, \"No enclosing instance for inner class `%s' is in scope%s\",\n+\t\t(qual_wfl, \"No enclosing instance for inner class %qs is in scope%s\",\n \t\t lang_printable_name (type, 0),\n \t\t (!current_this ? \"\" :\n \t\t  \"; an explicit one must be provided when creating this inner class\"));\n@@ -9917,13 +9917,13 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t  if (!current_this)\n \t    {\n \t      parse_error_context\n-\t\t(wfl, \"Keyword `this' used outside allowed context\");\n+\t\t(wfl, \"Keyword %<this%> used outside allowed context\");\n \t      return 1;\n \t    }\n \t  if (ctxp->explicit_constructor_p\n \t      && type == current_class)\n \t    {\n-\t      parse_error_context (wfl, \"Can't reference `this' before the superclass constructor has been called\");\n+\t      parse_error_context (wfl, \"Can't reference %<this%> before the superclass constructor has been called\");\n \t      return 1;\n \t    }\n \t  /* We have to generate code for intermediate access */\n@@ -9939,7 +9939,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      if (!enclosing_context_p (type, current_class))\n \t\t{\n \t\t  char *p  = xstrdup (lang_printable_name (type, 0));\n-\t\t  parse_error_context (qual_wfl, \"Can't use variable `%s.this': type `%s' isn't an outer type of type `%s'\",\n+\t\t  parse_error_context (qual_wfl, \"Can't use variable %<%s.this%>: type %qs isn't an outer type of type %qs\",\n \t\t\t\t       p, p,\n \t\t\t\t       lang_printable_name (current_class, 0));\n \t\t  free (p);\n@@ -9972,7 +9972,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      || current_class == object_type_node)\n \t    {\n \t      parse_error_context\n-\t\t(wfl, \"Keyword `super' used outside allowed context\");\n+\t\t(wfl, \"Keyword %<super%> used outside allowed context\");\n \t      return 1;\n \t    }\n \t  /* Otherwise, treat SUPER as (SUPER_CLASS)THIS */\n@@ -10021,12 +10021,12 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      if (from_super || from_cast)\n \t\tparse_error_context\n \t\t  ((from_cast ? qual_wfl : wfl),\n-\t\t   \"No variable `%s' defined in class `%s'\",\n+\t\t   \"No variable %qs defined in class %qs\",\n \t\t   IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),\n \t\t   lang_printable_name (type, 0));\n \t      else\n \t\tparse_error_context\n-\t\t  (qual_wfl, \"Undefined variable or class name: `%s'\",\n+\t\t  (qual_wfl, \"Undefined variable or class name: %qs\",\n \t\t   IDENTIFIER_POINTER (name));\n \t      return 1;\n \t    }\n@@ -10044,7 +10044,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t  if(TREE_CHAIN (q)\n \t     && TREE_CODE (TREE_PURPOSE (TREE_CHAIN (q))) == NEW_CLASS_EXPR)\n \t    {\n-\t      parse_error_context (qual_wfl, \"Undefined variable `%s'\",\n+\t      parse_error_context (qual_wfl, \"Undefined variable %qs\",\n \t\t\t\t   IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n \t      return 1;\n \t    }\n@@ -10097,7 +10097,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t  else if (TREE_CODE (qual_wfl) == INTEGER_CST)\n \t    {\n \t      parse_error_context\n-\t\t(wfl, \"Can't use type `%s' as a qualifier\",\n+\t\t(wfl, \"Can't use type %qs as a qualifier\",\n \t\t lang_printable_name (TREE_TYPE (qual_wfl), 0));\n \t      return 1;\n \t    }\n@@ -10116,7 +10116,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      if (!from_type && !JREFERENCE_TYPE_P (type))\n \t\t{\n \t\t  parse_error_context\n-\t\t    (qual_wfl, \"Attempt to reference field `%s' in `%s %s'\",\n+\t\t    (qual_wfl, \"Attempt to reference field %qs in %<%s %s%>\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),\n \t\t     lang_printable_name (type, 0),\n \t\t     IDENTIFIER_POINTER (DECL_NAME (decl)));\n@@ -10147,7 +10147,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      if (field_decl == NULL_TREE)\n \t\t{\n \t\t  parse_error_context\n-\t\t    (qual_wfl, \"No variable `%s' defined in type `%s'\",\n+\t\t    (qual_wfl, \"No variable %qs defined in type %qs\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),\n \t\t     GET_TYPE_NAME (type));\n \t\t  return 1;\n@@ -10231,7 +10231,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      && TREE_CODE (TREE_PURPOSE (TREE_CHAIN (q))) == NEW_CLASS_EXPR\n \t      && !JREFERENCE_TYPE_P (type))\n \t    {\n-\t      parse_error_context (qual_wfl, \"Attempt to reference field `new' in a `%s'\",\n+\t      parse_error_context (qual_wfl, \"Attempt to reference field %<new%> in a %qs\",\n \t\t\t\t   lang_printable_name (type, 0));\n \t      return 1;\n \t    }\n@@ -10368,7 +10368,7 @@ check_deprecation (tree wfl, tree decl)\n \t  the = \"field\";\n \t  break;\n \tcase TYPE_DECL:\n-\t  parse_warning_context (wfl, \"The class `%s' has been deprecated\",\n+\t  parse_warning_context (wfl, \"The class %qs has been deprecated\",\n \t\t\t\t IDENTIFIER_POINTER (DECL_NAME (decl)));\n \t  return;\n \tdefault:\n@@ -10378,7 +10378,7 @@ check_deprecation (tree wfl, tree decl)\n          whole. */\n       if (! CLASS_DEPRECATED (TYPE_NAME (DECL_CONTEXT (decl))))\n \tparse_warning_context\n-\t  (wfl, \"The %s `%s' in class `%s' has been deprecated\",\n+\t  (wfl, \"The %s %qs in class %qs has been deprecated\",\n \t   the, lang_printable_name (decl, 0),\n \t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl)))));\n     }\n@@ -10495,7 +10495,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n         {\n \t  parse_error_context\n \t    (identifier_wfl,\n-\t     \"Can't invoke a method on primitive type `%s'\",\n+\t     \"Can't invoke a method on primitive type %qs\",\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n \t  PATCH_METHOD_RETURN_ERROR ();\n \t}\n@@ -10510,7 +10510,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t    {\n \t      parse_error_context\n \t\t(identifier_wfl,\n-\t\t\"Can't make static reference to method `%s' in interface `%s'\",\n+\t\t\"Can't make static reference to method %qs in interface %qs\",\n \t\t IDENTIFIER_POINTER (identifier),\n \t\t IDENTIFIER_POINTER (name));\n \t      PATCH_METHOD_RETURN_ERROR ();\n@@ -10520,7 +10520,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t      char *fct_name = xstrdup (lang_printable_name (list, 2));\n \t      parse_error_context\n \t\t(identifier_wfl,\n-\t\t \"Can't make static reference to method `%s %s' in class `%s'\",\n+\t\t \"Can't make static reference to method %<%s %s%> in class %qs\",\n \t\t lang_printable_name (TREE_TYPE (TREE_TYPE (list)), 0),\n \t\t fct_name, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n \t      free (fct_name);\n@@ -10573,7 +10573,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t      if (!class_to_search)\n \t\t{\n \t\t  parse_error_context\n-\t\t    (wfl, \"Class `%s' not found in type declaration\",\n+\t\t    (wfl, \"Class %qs not found in type declaration\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n \t\t  PATCH_METHOD_RETURN_ERROR ();\n \t\t}\n@@ -10585,7 +10585,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t\t  && TREE_CODE (patch) == NEW_CLASS_EXPR)\n \t\t{\n \t\t  parse_error_context\n-\t\t    (wfl, \"Class `%s' is an abstract class. It can't be instantiated\",\n+\t\t    (wfl, \"Class %qs is an abstract class. It can't be instantiated\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n \t\t  PATCH_METHOD_RETURN_ERROR ();\n \t\t}\n@@ -10615,7 +10615,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t\t  if (! INNER_CLASS_TYPE_P (class_to_search))\n \t\t    {\n \t\t      parse_error_context (wfl,\n-\t\t\t\t\t   \"No method named `%s' in scope\",\n+\t\t\t\t\t   \"No method named %qs in scope\",\n \t\t\t\t\t   IDENTIFIER_POINTER (name));\n \t\t      PATCH_METHOD_RETURN_ERROR ();\n \t\t    }\n@@ -10653,7 +10653,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t  && !DECL_INIT_P (current_function_decl))\n \t{\n \t  parse_error_context\n-\t    (wfl, \"No enclosing instance for inner class `%s' is in scope%s\",\n+\t    (wfl, \"No enclosing instance for inner class %qs is in scope%s\",\n \t     lang_printable_name (class_to_search, 0),\n \t     (!current_this ? \"\" :\n \t      \"; an explicit one must be provided when creating this inner class\"));\n@@ -10726,7 +10726,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n       const char *const what = (DECL_CONSTRUCTOR_P (list)\n \t\t\t\t? \"constructor\" : \"method\");\n       parse_error_context (wfl,\n-\t\t\t   \"Can't access %s %s `%s.%s' from `%s'\",\n+\t\t\t   \"Can't access %s %s %<%s.%s%> from %qs\",\n \t\t\t   access, what, klass, fct_name, refklass);\n       PATCH_METHOD_RETURN_ERROR ();\n     }\n@@ -10807,7 +10807,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n       && (!primary || primary == current_this)\n       && (TREE_CODE (patch) != NEW_CLASS_EXPR))\n     {\n-      parse_error_context (wfl, \"Can't reference `this' before the superclass constructor has been called\");\n+      parse_error_context (wfl, \"Can't reference %<this%> before the superclass constructor has been called\");\n       PATCH_METHOD_RETURN_ERROR ();\n     }\n   java_parser_context_restore_global ();\n@@ -10854,7 +10854,7 @@ check_for_static_method_reference (tree wfl, tree node, tree method,\n     {\n       char *fct_name = xstrdup (lang_printable_name (method, 0));\n       parse_error_context\n-\t(wfl, \"Can't make static reference to method `%s %s' in class `%s'\",\n+\t(wfl, \"Can't make static reference to method %<%s %s%> in class %qs\",\n \t lang_printable_name (TREE_TYPE (TREE_TYPE (method)), 0), fct_name,\n \t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (where))));\n       free (fct_name);\n@@ -11178,7 +11178,7 @@ lookup_method_invoke (int lc, tree cl, tree class, tree name, tree arg_list)\n \t  if (!cm || not_accessible_p (class, cm, NULL_TREE, 0))\n \t    continue;\n \t  sprintf\n-\t    (string, \"  `%s' in `%s'%s\",\n+\t    (string, \"  '%s' in '%s'%s\",\n \t     get_printable_method_name (cm),\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (cm)))),\n \t     (TREE_CHAIN (current) ? \"\\n\" : \"\"));\n@@ -11192,7 +11192,7 @@ lookup_method_invoke (int lc, tree cl, tree class, tree name, tree arg_list)\n   TYPE_ARG_TYPES (method) = atl;\n   signature = build_java_argument_signature (method);\n   dup = xstrdup (lang_printable_name (class, 0));\n-  parse_error_context (cl, \"Can't find %s `%s(%s)' in type `%s'%s\",\n+  parse_error_context (cl, \"Can't find %s %<%s(%s)%> in type %qs%s\",\n \t\t       (lc ? \"constructor\" : \"method\"),\n \t\t       (lc ? dup : IDENTIFIER_POINTER (name)),\n \t\t       IDENTIFIER_POINTER (signature), dup,\n@@ -11787,7 +11787,7 @@ java_complete_lhs (tree node)\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \t  parse_error_context\n \t    (wfl_operator,\n-\t     \"Incompatible type for case. Can't convert `%s' to `int'\",\n+\t     \"Incompatible type for case. Can't convert %qs to %<int%>\",\n \t     lang_printable_name (TREE_TYPE (cn), 0));\n \t  return error_mark_node;\n \t}\n@@ -11821,7 +11821,7 @@ java_complete_lhs (tree node)\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n #endif\n \t  parse_error_context (wfl_operator,\n-\t\t\t       \"Duplicate case label: `default'\");\n+\t\t\t       \"Duplicate case label: %<default%>\");\n \t  return error_mark_node;\n \t}\n       else\n@@ -12169,7 +12169,7 @@ java_complete_lhs (tree node)\n \t  if (JREFERENCE_TYPE_P (TREE_TYPE (lvalue))\n \t      && ! JSTRING_TYPE_P (TREE_TYPE (lvalue)))\n \t    parse_error_context (wfl_op2,\n-\t\t\t\t \"Incompatible type for `+='. Can't convert `%s' to `java.lang.String'\",\n+\t\t\t\t \"Incompatible type for %<+=%>. Can't convert %qs to %<java.lang.String%>\",\n \t\t\t\t lang_printable_name (TREE_TYPE (lvalue), 0));\n \n \t  /* 15.25.2.b: Left hand is an array access. FIXME */\n@@ -12340,12 +12340,12 @@ java_complete_lhs (tree node)\n \t  tree field = lookup_field_wrapper (TREE_OPERAND (node, 0), name);\n \t  if (field == NULL_TREE)\n \t    {\n-\t      error (\"missing static field `%s'\", IDENTIFIER_POINTER (name));\n+\t      error (\"missing static field %qs\", IDENTIFIER_POINTER (name));\n \t      return error_mark_node;\n \t    }\n \t  if (! FIELD_STATIC (field))\n \t    {\n-\t      error (\"not a static field `%s'\", IDENTIFIER_POINTER (name));\n+\t      error (\"not a static field %qs\", IDENTIFIER_POINTER (name));\n \t      return error_mark_node;\n \t    }\n \t  return field;\n@@ -12360,15 +12360,15 @@ java_complete_lhs (tree node)\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \t  parse_error_context (wfl_operator,\n-\t\t\t       \"Keyword `this' used outside allowed context\");\n+\t\t\t       \"Keyword %<this%> used outside allowed context\");\n \t  TREE_TYPE (node) = error_mark_node;\n \t  return error_mark_node;\n \t}\n       if (ctxp->explicit_constructor_p)\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \t  parse_error_context\n-\t    (wfl_operator, \"Can't reference `this' or `super' before the superclass constructor has been called\");\n+\t    (wfl_operator, \"Can't reference %<this%> or %<super%> before the superclass constructor has been called\");\n \t  TREE_TYPE (node) = error_mark_node;\n \t  return error_mark_node;\n \t}\n@@ -12862,17 +12862,17 @@ patch_assignment (tree node, tree wfl_op1)\n \t  if (COMPOUND_ASSIGN_P (TREE_OPERAND (node, 1)))\n \t    strcpy (operation, \"assignment\");\n \t  else if (is_return)\n-\t    strcpy (operation, \"`return'\");\n+\t    strcpy (operation, \"'return'\");\n \t  else\n-\t    strcpy (operation, \"`='\");\n+\t    strcpy (operation, \"'='\");\n \t}\n \n       if (!valid_cast_to_p (rhs_type, lhs_type))\n \tparse_error_context\n-\t  (wfl, \"Incompatible type for %s. Can't convert `%s' to `%s'\",\n+\t  (wfl, \"Incompatible type for %s. Can't convert %qs to %qs\",\n \t   operation, t1, t2);\n       else\n-\tparse_error_context (wfl, \"Incompatible type for %s. Explicit cast needed to convert `%s' to `%s'\",\n+\tparse_error_context (wfl, \"Incompatible type for %s. Explicit cast needed to convert %qs to %qs\",\n \t\t\t     operation, t1, t2);\n       free (t1); free (t2);\n       error_found = 1;\n@@ -13044,7 +13044,8 @@ try_builtin_assignconv (tree wfl_op1, tree lhs_type, tree rhs)\n         new_rhs = convert (lhs_type, rhs);\n       else if (wfl_op1)\t\t/* Might be called with a NULL */\n \tparse_warning_context\n-\t  (wfl_op1, \"Constant expression `%s' too wide for narrowing primitive conversion to `%s'\",\n+\t  (wfl_op1,\n+           \"Constant expression %qs too wide for narrowing primitive conversion to %qs\",\n \t   print_int_node (rhs), lang_printable_name (lhs_type, 0));\n       /* Reported a warning that will turn into an error further\n \t down, so we don't return */\n@@ -13482,7 +13483,9 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n \t      (TREE_CODE (op2) == INTEGER_CST &&\n \t       ! TREE_INT_CST_LOW (op2)  && ! TREE_INT_CST_HIGH (op2))))\n \t{\n-\t  parse_warning_context (wfl_operator, \"Evaluating this expression will result in an arithmetic exception being thrown\");\n+\t  parse_warning_context\n+            (wfl_operator,\n+             \"Evaluating this expression will result in an arithmetic exception being thrown\");\n \t  TREE_CONSTANT (node) = 0;\n \t  TREE_INVARIANT (node) = 0;\n \t}\n@@ -13564,12 +13567,12 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n \t    {\n \t      if (JNUMERIC_TYPE_P (op2_type))\n \t\tparse_error_context (wfl_operator,\n-\t\t\t\t     \"Incompatible type for `%s'. Explicit cast needed to convert shift distance from `%s' to integral\",\n+\t\t\t\t     \"Incompatible type for %qs. Explicit cast needed to convert shift distance from %qs to integral\",\n \t\t\t\t     operator_string (node),\n \t\t\t\t     lang_printable_name (op2_type, 0));\n \t      else\n \t\tparse_error_context (wfl_operator,\n-\t\t\t\t     \"Incompatible type for `%s'. Can't convert shift distance from `%s' to integral\",\n+\t\t\t\t     \"Incompatible type for %qs. Can't convert shift distance from %qs to integral\",\n \t\t\t\t     operator_string (node),\n \t\t\t\t     lang_printable_name (op2_type, 0));\n \t    }\n@@ -13645,7 +13648,7 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n \t{\n \t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n \t  parse_error_context\n-\t    (wfl_operator, \"Invalid argument `%s' for `instanceof'\",\n+\t    (wfl_operator, \"Invalid argument %qs for %<instanceof%>\",\n \t     lang_printable_name (op2_type, 0));\n \t  error_found = 1;\n \t}\n@@ -13672,7 +13675,7 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n \t  char *t1 = xstrdup (lang_printable_name (op1_type, 0));\n \t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n \t  parse_error_context\n-\t    (wfl_operator, \"Impossible for `%s' to be instance of `%s'\",\n+\t    (wfl_operator, \"Impossible for %qs to be instance of %qs\",\n \t     t1, lang_printable_name (op2_type, 0));\n \t  free (t1);\n \t  error_found = 1;\n@@ -13801,7 +13804,7 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n \t  t1 = xstrdup (lang_printable_name (op1_type, 0));\n \t  parse_error_context\n \t    (wfl_operator,\n-\t     \"Incompatible type for `%s'. Can't convert `%s' to `%s'\",\n+\t     \"Incompatible type for %qs. Can't convert %qs to %qs\",\n \t     operator_string (node), t1,\n \t     lang_printable_name (op2_type, 0));\n \t  free (t1);\n@@ -14282,7 +14285,7 @@ patch_unaryop (tree node, tree wfl_op)\n       if (!JNUMERIC_TYPE_P (op_type))\n \t{\n \t  parse_error_context\n-\t    (wfl_op, \"Invalid argument type `%s' to `%s'\",\n+\t    (wfl_op, \"Invalid argument type %qs to %qs\",\n \t     lang_printable_name (op_type, 0), operator_string (node));\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n@@ -14421,7 +14424,7 @@ resolve_type_during_patch (tree type)\n       if (!type_decl)\n \t{\n \t  parse_error_context (type,\n-\t\t\t       \"Class `%s' not found in type declaration\",\n+\t\t\t       \"Class %qs not found in type declaration\",\n \t\t\t       IDENTIFIER_POINTER (EXPR_WFL_NODE (type)));\n \t  return NULL_TREE;\n \t}\n@@ -14512,7 +14515,7 @@ patch_cast (tree node, tree wfl_op)\n \n   /* Any other casts are proven incorrect at compile time */\n   t1 = xstrdup (lang_printable_name (op_type, 0));\n-  parse_error_context (wfl_op, \"Invalid cast from `%s' to `%s'\",\n+  parse_error_context (wfl_op, \"Invalid cast from %qs to %qs\",\n \t\t       t1, lang_printable_name (cast_type, 0));\n   free (t1);\n   return error_mark_node;\n@@ -14559,7 +14562,7 @@ patch_array_ref (tree node)\n     {\n       parse_error_context\n \t(wfl_operator,\n-\t \"`[]' can only be applied to arrays. It can't be applied to `%s'\",\n+\t \"%<[]%> can only be applied to arrays. It can't be applied to %qs\",\n \t lang_printable_name (array_type, 0));\n       TREE_TYPE (node) = error_mark_node;\n       error_found = 1;\n@@ -14572,11 +14575,11 @@ patch_array_ref (tree node)\n     {\n       if (valid_cast_to_p (index_type, int_type_node))\n \tparse_error_context (wfl_operator,\n-   \"Incompatible type for `[]'. Explicit cast needed to convert `%s' to `int'\",\n+   \"Incompatible type for %<[]%>. Explicit cast needed to convert %qs to %<int%>\",\n \t\t\t     lang_printable_name (index_type, 0));\n       else\n \tparse_error_context (wfl_operator,\n-          \"Incompatible type for `[]'. Can't convert `%s' to `int'\",\n+          \"Incompatible type for %<[]%>. Can't convert %qs to %<int%>\",\n \t\t\t     lang_printable_name (index_type, 0));\n       TREE_TYPE (node) = error_mark_node;\n       error_found = 1;\n@@ -14647,7 +14650,7 @@ patch_newarray (tree node)\n \t{\n \t  parse_error_context\n \t    (TREE_PURPOSE (cdim),\n-\t     \"Incompatible type for dimension in array creation expression. %s convert `%s' to `int'\",\n+\t     \"Incompatible type for dimension in array creation expression. %s convert %qs to %<int%>\",\n \t     (valid_cast_to_p (TREE_TYPE (dim), int_type_node) ?\n \t      \"Explicit cast needed to\" : \"Can't\"),\n \t     lang_printable_name (TREE_TYPE (dim), 0));\n@@ -14763,7 +14766,7 @@ patch_new_array_init (tree type, tree node)\n   if (TREE_CODE (type) != POINTER_TYPE || ! TYPE_ARRAY_P (TREE_TYPE (type)))\n     {\n       parse_error_context (node,\n-\t\t\t   \"Invalid array initializer for non-array type `%s'\",\n+\t\t\t   \"Invalid array initializer for non-array type %qs\",\n \t\t\t   lang_printable_name (type, 1));\n       return error_mark_node;\n     }\n@@ -14850,7 +14853,7 @@ array_constructor_check_entry (tree type, tree entry)\n       if (!array_type_string)\n \tarray_type_string = xstrdup (lang_printable_name (type, 1));\n       parse_error_context\n-\t(wfl_operator, \"Incompatible type for array. %s convert `%s' to `%s'\",\n+\t(wfl_operator, \"Incompatible type for array. %s convert %qs to %qs\",\n \t msg, lang_printable_name (type_value, 1), array_type_string);\n       error_seen = 1;\n     }\n@@ -14919,24 +14922,24 @@ patch_return (tree node)\n     {\n       if (DECL_INSTINIT_P (current_function_decl))\n \tparse_error_context (wfl_operator,\n-\t\t\t     \"`return' inside instance initializer\");\n+\t\t\t     \"%<return%> inside instance initializer\");\n \n       else if (DECL_CLINIT_P (current_function_decl))\n \tparse_error_context (wfl_operator,\n-\t\t\t     \"`return' inside static initializer\");\n+\t\t\t     \"%<return%> inside static initializer\");\n \n       else if (!DECL_CONSTRUCTOR_P (meth))\n \t{\n \t  char *t = xstrdup (lang_printable_name (mtype, 0));\n \t  parse_error_context (wfl_operator,\n-\t\t\t       \"`return' with%s value from `%s %s'\",\n+\t\t\t       \"%<return%> with%s value from %<%s %s%>\",\n \t\t\t       (error_found == 1 ? \"\" : \"out\"),\n \t\t\t       t, lang_printable_name (meth, 2));\n \t  free (t);\n \t}\n       else\n \tparse_error_context (wfl_operator,\n-\t\t\t     \"`return' with value from constructor `%s'\",\n+\t\t\t     \"%<return%> with value from constructor %qs\",\n \t\t\t     lang_printable_name (meth, 2));\n       return error_mark_node;\n     }\n@@ -15001,7 +15004,7 @@ patch_if_else_statement (tree node)\n     {\n       parse_error_context\n \t(wfl_operator,\n-\t \"Incompatible type for `if'. Can't convert `%s' to `boolean'\",\n+\t \"Incompatible type for %<if%>. Can't convert %qs to %<boolean%>\",\n \t lang_printable_name (TREE_TYPE (expression), 0));\n       return error_mark_node;\n     }\n@@ -15034,12 +15037,12 @@ build_labeled_block (int location, tree label)\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = location;\n \t  parse_error_context (wfl_operator,\n-            \"Declaration of `%s' shadows a previous label declaration\",\n+            \"Declaration of %qs shadows a previous label declaration\",\n \t\t\t       IDENTIFIER_POINTER (label));\n \t  EXPR_WFL_LINECOL (wfl_operator) =\n \t    EXPR_WFL_LINECOL (IDENTIFIER_LOCAL_VALUE (label_name));\n \t  parse_error_context (wfl_operator,\n-            \"This is the location of the previous declaration of label `%s'\",\n+            \"This is the location of the previous declaration of label %qs\",\n \t\t\t       IDENTIFIER_POINTER (label));\n \t  java_error_count--;\n \t}\n@@ -15287,7 +15290,7 @@ patch_bc_statement (tree node)\n   /* Having an identifier here means that the target is unknown. */\n   if (bc_label != NULL_TREE && TREE_CODE (bc_label) == IDENTIFIER_NODE)\n     {\n-      parse_error_context (wfl_operator, \"No label definition found for `%s'\",\n+      parse_error_context (wfl_operator, \"No label definition found for %qs\",\n \t\t\t   IDENTIFIER_POINTER (bc_label));\n       return error_mark_node;\n     }\n@@ -15300,10 +15303,10 @@ patch_bc_statement (tree node)\n \t    {\n \t      if (bc_label == NULL_TREE)\n \t\tparse_error_context (wfl_operator,\n-\t\t\t\t     \"`continue' must be in loop\");\n+\t\t\t\t     \"%<continue%> must be in loop\");\n \t      else\n \t\tparse_error_context\n-\t\t  (wfl_operator, \"continue label `%s' does not name a loop\",\n+\t\t  (wfl_operator, \"continue label %qs does not name a loop\",\n \t\t   IDENTIFIER_POINTER (bc_label));\n \t      return error_mark_node;\n \t    }\n@@ -15324,7 +15327,7 @@ patch_bc_statement (tree node)\n \t  if (labeled_block == NULL_TREE)\n \t    {\n \t      parse_error_context (wfl_operator,\n-\t\t\t\t     \"`break' must be in loop or switch\");\n+\t\t\t\t     \"%<break%> must be in loop or switch\");\n \t      return error_mark_node;\n \t    }\n \t  target_stmt = LABELED_BLOCK_BODY (labeled_block);\n@@ -15365,7 +15368,7 @@ patch_exit_expr (tree node)\n     {\n       parse_error_context\n \t(wfl_operator,\n-    \"Incompatible type for loop conditional. Can't convert `%s' to `boolean'\",\n+    \"Incompatible type for loop conditional. Can't convert %qs to %<boolean%>\",\n \t lang_printable_name (TREE_TYPE (expression), 0));\n       return error_mark_node;\n     }\n@@ -15403,7 +15406,7 @@ patch_switch_statement (tree node)\n     {\n       EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n       parse_error_context (wfl_operator,\n-\t  \"Incompatible type for `switch'. Can't convert `%s' to `int'\",\n+\t  \"Incompatible type for %<switch%>. Can't convert %qs to %<int%>\",\n \t\t\t   lang_printable_name (se_type, 0));\n       /* This is what java_complete_tree will check */\n       TREE_OPERAND (node, 0) = error_mark_node;\n@@ -15434,8 +15437,8 @@ patch_switch_statement (tree node)\n \t\t= EXPR_WFL_LINECOL (TREE_PURPOSE (iter));\n \t      /* The case_label_list is in reverse order, so print the\n \t\t outer label first.  */\n-\t      parse_error_context (wfl_operator, \"duplicate case label: `\"\n-\t\t\t\t   HOST_WIDE_INT_PRINT_DEC \"'\", subval);\n+\t      parse_error_context (wfl_operator, \"duplicate case label: %<\"\n+\t\t\t\t   HOST_WIDE_INT_PRINT_DEC \"%>\", subval);\n \t      EXPR_WFL_LINECOL (wfl_operator)\n \t\t= EXPR_WFL_LINECOL (TREE_PURPOSE (subiter));\n \t      parse_error_context (wfl_operator, \"original label is here\");\n@@ -15655,7 +15658,7 @@ patch_try_statement (tree node)\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (current);\n \t  parse_error_context (wfl_operator,\n-\t\t\t       \"Can't catch class `%s'. Catch clause parameter type must be a subclass of class `java.lang.Throwable'\",\n+\t\t\t       \"Can't catch class %qs. Catch clause parameter type must be a subclass of class %<java.lang.Throwable%>\",\n \t\t\t       lang_printable_name (carg_type, 0));\n \t  error_found = 1;\n \t  continue;\n@@ -15679,7 +15682,7 @@ patch_try_statement (tree node)\n \t      EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (current);\n \t      parse_error_context\n \t\t(wfl_operator,\n-\t\t \"`catch' not reached because of the catch clause at line %d\",\n+\t\t \"%<catch%> not reached because of the catch clause at line %d\",\n \t\t EXPR_WFL_LINENO (sub_current));\n \t      unreachable = error_found = 1;\n \t      break;\n@@ -15746,7 +15749,7 @@ patch_synchronized_statement (tree node, tree wfl_op1)\n   if (!JREFERENCE_TYPE_P (TREE_TYPE (expr)))\n     {\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n-      parse_error_context (wfl_operator, \"Incompatible type for `synchronized'. Can't convert `%s' to `java.lang.Object'\",\n+      parse_error_context (wfl_operator, \"Incompatible type for %<synchronized%>. Can't convert %qs to %<java.lang.Object%>\",\n \t\t\t   lang_printable_name (TREE_TYPE (expr), 0));\n       return error_mark_node;\n     }\n@@ -15805,7 +15808,7 @@ patch_throw_statement (tree node, tree wfl_op1)\n     {\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n       parse_error_context (wfl_operator,\n-    \"Can't throw `%s'; it must be a subclass of class `java.lang.Throwable'\",\n+    \"Can't throw %qs; it must be a subclass of class %<java.lang.Throwable%>\",\n \t\t\t   lang_printable_name (type, 0));\n       /* If the thrown expression was a reference, we further the\n          compile-time check. */\n@@ -15834,7 +15837,7 @@ patch_throw_statement (tree node, tree wfl_op1)\n \tif (DECL_CONSTRUCTOR_P (current)\n \t    && !check_thrown_exceptions_do (TREE_TYPE (expr)))\n \t  {\n-\t    parse_error_context (wfl_operator, \"Checked exception `%s' can't be thrown in instance initializer (not all declared constructor are declaring it in their `throws' clause)\",\n+\t    parse_error_context (wfl_operator, \"Checked exception %qs can't be thrown in instance initializer (not all declared constructor are declaring it in their %<throws%> clause)\",\n \t\t\t\t lang_printable_name (TREE_TYPE (expr), 0));\n \t    return error_mark_node;\n \t  }\n@@ -15855,7 +15858,7 @@ patch_throw_statement (tree node, tree wfl_op1)\n \t only if there is something after the list of checked\n \t exception thrown by the current function (if any). */\n       if (IN_TRY_BLOCK_P ())\n-\tparse_error_context (wfl_operator, \"Checked exception `%s' can't be caught by any of the catch clause(s) of the surrounding `try' block\",\n+\tparse_error_context (wfl_operator, \"Checked exception %qs can't be caught by any of the catch clause(s) of the surrounding %<try%> block\",\n \t\t\t     lang_printable_name (type, 0));\n       /* If we have no surrounding try statement and the method doesn't have\n \t any throws, report it now. FIXME */\n@@ -15868,17 +15871,17 @@ patch_throw_statement (tree node, tree wfl_op1)\n \t{\n \t  if (DECL_CLINIT_P (current_function_decl))\n \t    parse_error_context (wfl_operator,\n-                   \"Checked exception `%s' can't be thrown in initializer\",\n+                   \"Checked exception %qs can't be thrown in initializer\",\n \t\t\t\t lang_printable_name (type, 0));\n \t  else\n \t    parse_error_context (wfl_operator,\n-                   \"Checked exception `%s' isn't thrown from a `try' block\",\n+                   \"Checked exception %qs isn't thrown from a %<try%> block\",\n \t\t\t\t lang_printable_name (type, 0));\n \t}\n       /* Otherwise, the current method doesn't have the appropriate\n          throws declaration */\n       else\n-\tparse_error_context (wfl_operator, \"Checked exception `%s' doesn't match any of current method's `throws' declaration(s)\",\n+\tparse_error_context (wfl_operator, \"Checked exception %qs doesn't match any of current method's %<throws%> declaration(s)\",\n \t\t\t     lang_printable_name (type, 0));\n       return error_mark_node;\n     }\n@@ -15933,12 +15936,12 @@ check_thrown_exceptions (\n #endif\n \tif (DECL_FINIT_P (current_function_decl))\n \t  parse_error_context\n-            (wfl_operator, \"Exception `%s' can't be thrown in initializer\",\n+            (wfl_operator, \"Exception %qs can't be thrown in initializer\",\n \t     lang_printable_name (TREE_VALUE (throws), 0));\n \telse\n \t  {\n \t    parse_error_context\n-\t      (wfl_operator, \"Exception `%s' must be caught, or it must be declared in the `throws' clause of `%s'\",\n+\t      (wfl_operator, \"Exception %qs must be caught, or it must be declared in the %<throws%> clause of %qs\",\n \t       lang_printable_name (TREE_VALUE (throws), 0),\n \t       (DECL_INIT_P (current_function_decl) ?\n \t\tIDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))) :\n@@ -16049,7 +16052,7 @@ patch_conditional_expr (tree node, tree wfl_cond, tree wfl_op1)\n     {\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_cond);\n       parse_error_context (wfl_operator,\n-               \"Incompatible type for `?:'. Can't convert `%s' to `boolean'\",\n+               \"Incompatible type for %<?:%>. Can't convert %qs to %<boolean%>\",\n \t\t\t   lang_printable_name (TREE_TYPE (cond), 0));\n       error_found = 1;\n     }\n@@ -16117,7 +16120,7 @@ patch_conditional_expr (tree node, tree wfl_cond, tree wfl_op1)\n       char *t = xstrdup (lang_printable_name (t1, 0));\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n       parse_error_context (wfl_operator,\n-\t\t \"Incompatible type for `?:'. Can't convert `%s' to `%s'\",\n+\t\t \"Incompatible type for %<?:%>. Can't convert %qs to %qs\",\n \t\t\t   t, lang_printable_name (t2, 0));\n       free (t);\n       error_found = 1;"}]}