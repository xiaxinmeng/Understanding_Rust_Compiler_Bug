{"sha": "60573ca25ab315e4825a035ef67d59a23e645b52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA1NzNjYTI1YWIzMTVlNDgyNWEwMzVlZjY3ZDU5YTIzZTY0NWI1Mg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:09:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:09:49Z"}, "message": "sem_type.adb (Add_One_Interp): If node is an indirect call...\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_type.adb (Add_One_Interp): If node is an indirect call, preserve\n\tsubprogram type to provide better diagnostics in case of ambiguity.\n\t(Covers): Handle coverage of formal and actual anonymous access types in\n\tthe context of generic instantiation.\n\t(Covers/Interface_Present_In_Ancestors): Use the base type to manage\n\tabstract interface types; this is required to handle concurrent types\n\twith discriminants and abstract interface types.\n\t(Covers): Include type coverage of both regular incomplete subtypes and\n\tincomplete subtypes of incomplete type visibles through a limited with\n\tclause.\n\nFrom-SVN: r118311", "tree": {"sha": "0009d8fedb88e155dcb2076f7b0cb2918c772ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0009d8fedb88e155dcb2076f7b0cb2918c772ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60573ca25ab315e4825a035ef67d59a23e645b52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60573ca25ab315e4825a035ef67d59a23e645b52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60573ca25ab315e4825a035ef67d59a23e645b52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60573ca25ab315e4825a035ef67d59a23e645b52/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29797f340dccaaa714e993426b925f23f94d362c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29797f340dccaaa714e993426b925f23f94d362c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29797f340dccaaa714e993426b925f23f94d362c"}], "stats": {"total": 140, "additions": 100, "deletions": 40}, "files": [{"sha": "a33a39702eca740b44651a7e7184c0387797d6fb", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 100, "deletions": 40, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60573ca25ab315e4825a035ef67d59a23e645b52/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60573ca25ab315e4825a035ef67d59a23e645b52/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=60573ca25ab315e4825a035ef67d59a23e645b52", "patch": "@@ -35,10 +35,11 @@ with Lib;      use Lib;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Output;   use Output;\n-with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch12; use Sem_Ch12;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Util; use Sem_Util;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n@@ -394,9 +395,9 @@ package body Sem_Type is\n          --  because otherwise we have a dummy between the two subprograms that\n          --  are in fact the same.\n \n-         if Present (DTC_Entity (Abstract_Interface_Alias (E)))\n-           and then Etype (DTC_Entity (Abstract_Interface_Alias (E)))\n-                      /= RTE (RE_Tag)\n+         if not Is_Ancestor\n+                  (Find_Dispatching_Type (Abstract_Interface_Alias (E)),\n+                   Find_Dispatching_Type (E))\n          then\n             Add_One_Interp (N, Abstract_Interface_Alias (E), T);\n          end if;\n@@ -447,6 +448,24 @@ package body Sem_Type is\n          then\n             Add_Entry (Entity (Name (N)), Etype (N));\n \n+         --  If this is an indirect call there will be no name associated\n+         --  with the previous entry. To make diagnostics clearer, save\n+         --  Subprogram_Type of first interpretation, so that the error will\n+         --  point to the anonymous access to subprogram, not to the result\n+         --  type of the call itself.\n+\n+         elsif (Nkind (N)) = N_Function_Call\n+           and then Nkind (Name (N)) = N_Explicit_Dereference\n+           and then Is_Overloaded (Name (N))\n+         then\n+            declare\n+               I  : Interp_Index;\n+               It : Interp;\n+            begin\n+               Get_First_Interp (Name (N), I, It);\n+               Add_Entry (It.Nam, Etype (N));\n+            end;\n+\n          else\n             --  Overloaded prefix in indexed or selected component,\n             --  or call whose name is an expression or another call.\n@@ -735,36 +754,45 @@ package body Sem_Type is\n         and then Is_Interface (Etype (T1))\n         and then Is_Tagged_Type (T2)\n       then\n-         if Interface_Present_In_Ancestor (Typ => T2,\n+         if Interface_Present_In_Ancestor (Typ   => T2,\n                                            Iface => Etype (T1))\n          then\n             return True;\n+         end if;\n+\n+         declare\n+            E    : Entity_Id;\n+            Elmt : Elmt_Id;\n \n-         elsif Present (Abstract_Interfaces (T2)) then\n+         begin\n+            if Is_Concurrent_Type (BT2) then\n+               E := Corresponding_Record_Type (BT2);\n+            else\n+               E := BT2;\n+            end if;\n \n             --  Ada 2005 (AI-251): A class-wide abstract interface type T1\n             --  covers an object T2 that implements a direct derivation of T1.\n+            --  Note: test for presence of E is defense against previous error.\n \n-            declare\n-               E : Elmt_Id := First_Elmt (Abstract_Interfaces (T2));\n-            begin\n-               while Present (E) loop\n-                  if Is_Ancestor (Etype (T1), Node (E)) then\n+            if Present (E)\n+              and then Present (Abstract_Interfaces (E))\n+            then\n+               Elmt := First_Elmt (Abstract_Interfaces (E));\n+               while Present (Elmt) loop\n+                  if Is_Ancestor (Etype (T1), Node (Elmt)) then\n                      return True;\n                   end if;\n \n-                  Next_Elmt (E);\n+                  Next_Elmt (Elmt);\n                end loop;\n-            end;\n+            end if;\n \n             --  We should also check the case in which T1 is an ancestor of\n             --  some implemented interface???\n \n             return False;\n-\n-         else\n-            return False;\n-         end if;\n+         end;\n \n       --  In a dispatching call the actual may be class-wide\n \n@@ -959,7 +987,7 @@ package body Sem_Type is\n          --  If the expected type is the non-limited view of a type, the\n          --  expression may have the limited view.\n \n-         if Ekind (T1) = E_Incomplete_Type then\n+         if Is_Incomplete_Type (T1) then\n             return Covers (Non_Limited_View (T1), T2);\n \n          elsif Ekind (T1) = E_Class_Wide_Type then\n@@ -975,7 +1003,7 @@ package body Sem_Type is\n          --  either type might have a limited view. Checks performed elsewhere\n          --  verify that the context type is the non-limited view.\n \n-         if Ekind (T2) = E_Incomplete_Type then\n+         if Is_Incomplete_Type (T2) then\n             return Covers (T1, Non_Limited_View (T2));\n \n          elsif Ekind (T2) = E_Class_Wide_Type then\n@@ -985,6 +1013,38 @@ package body Sem_Type is\n             return False;\n          end if;\n \n+      --  Ada 2005 (AI-412): Coverage for regular incomplete subtypes\n+\n+      elsif Ekind (T1) = E_Incomplete_Subtype then\n+         return Covers (Full_View (Etype (T1)), T2);\n+\n+      elsif Ekind (T2) = E_Incomplete_Subtype then\n+         return Covers (T1, Full_View (Etype (T2)));\n+\n+      --  Ada 2005 (AI-423): Coverage of formal anonymous access types\n+      --  and actual anonymous access types in the context of generic\n+      --  instantiation. We have the following situation:\n+\n+      --     generic\n+      --        type Formal is private;\n+      --        Formal_Obj : access Formal;  --  T1\n+      --     package G is ...\n+\n+      --     package P is\n+      --        type Actual is ...\n+      --        Actual_Obj : access Actual;  --  T2\n+      --        package Instance is new G (Formal     => Actual,\n+      --                                   Formal_Obj => Actual_Obj);\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Ekind (T1) = E_Anonymous_Access_Type\n+        and then Ekind (T2) = E_Anonymous_Access_Type\n+        and then Is_Generic_Type (Directly_Designated_Type (T1))\n+        and then Get_Instance_Of (Directly_Designated_Type (T1)) =\n+                   Directly_Designated_Type (T2)\n+      then\n+         return True;\n+\n       --  Otherwise it doesn't cover!\n \n       else\n@@ -1354,9 +1414,9 @@ package body Sem_Type is\n          --  operating in an earlier mode, in which case we discard the Ada\n          --  2005 entity, so that we get proper Ada 95 overload resolution.\n \n-         if Is_Ada_2005 (Nam1) then\n+         if Is_Ada_2005_Only (Nam1) then\n             return It2;\n-         elsif Is_Ada_2005 (Nam2) then\n+         elsif Is_Ada_2005_Only (Nam2) then\n             return It1;\n          end if;\n       end if;\n@@ -2050,12 +2110,12 @@ package body Sem_Type is\n       --  list of interfaces (available in the parent of the concurrent type)\n \n       if Is_Concurrent_Type (Target_Typ) then\n-         if Present (Interface_List (Parent (Target_Typ))) then\n+         if Present (Interface_List (Parent (Base_Type (Target_Typ)))) then\n             declare\n                AI : Node_Id;\n \n             begin\n-               AI := First (Interface_List (Parent (Target_Typ)));\n+               AI := First (Interface_List (Parent (Base_Type (Target_Typ))));\n                while Present (AI) loop\n                   if Etype (AI) = Iface then\n                      return True;\n@@ -2304,11 +2364,11 @@ package body Sem_Type is\n            and then Scope (It.Typ) /= Standard_Standard\n          then\n             Error_Msg_Sloc := Sloc (Parent (It.Typ));\n-            Error_Msg_NE (\"   & (inherited) declared#!\", Err, It.Nam);\n+            Error_Msg_NE (\"\\\\& (inherited) declared#!\", Err, It.Nam);\n \n          else\n             Error_Msg_Sloc := Sloc (It.Nam);\n-            Error_Msg_NE (\"   & declared#!\", Err, It.Nam);\n+            Error_Msg_NE (\"\\\\& declared#!\", Err, It.Nam);\n          end if;\n \n          Get_Next_Interp (Index, It);\n@@ -2792,6 +2852,21 @@ package body Sem_Type is\n       end if;\n    end Valid_Comparison_Arg;\n \n+   ----------------------\n+   -- Write_Interp_Ref --\n+   ----------------------\n+\n+   procedure Write_Interp_Ref (Map_Ptr : Int) is\n+   begin\n+      Write_Str (\" Node:  \");\n+      Write_Int (Int (Interp_Map.Table (Map_Ptr).Node));\n+      Write_Str (\" Index: \");\n+      Write_Int (Int (Interp_Map.Table (Map_Ptr).Index));\n+      Write_Str (\" Next:  \");\n+      Write_Int (Int (Interp_Map.Table (Map_Ptr).Next));\n+      Write_Eol;\n+   end Write_Interp_Ref;\n+\n    ---------------------\n    -- Write_Overloads --\n    ---------------------\n@@ -2832,19 +2907,4 @@ package body Sem_Type is\n       end if;\n    end Write_Overloads;\n \n-   ----------------------\n-   -- Write_Interp_Ref --\n-   ----------------------\n-\n-   procedure Write_Interp_Ref (Map_Ptr : Int) is\n-   begin\n-      Write_Str (\" Node:  \");\n-      Write_Int (Int (Interp_Map.Table (Map_Ptr).Node));\n-      Write_Str (\" Index: \");\n-      Write_Int (Int (Interp_Map.Table (Map_Ptr).Index));\n-      Write_Str (\" Next:  \");\n-      Write_Int (Int (Interp_Map.Table (Map_Ptr).Next));\n-      Write_Eol;\n-   end Write_Interp_Ref;\n-\n end Sem_Type;"}]}