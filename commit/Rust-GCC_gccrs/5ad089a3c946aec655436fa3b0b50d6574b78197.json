{"sha": "5ad089a3c946aec655436fa3b0b50d6574b78197", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkMDg5YTNjOTQ2YWVjNjU1NDM2ZmEzYjBiNTBkNjU3NGI3ODE5Nw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-07T17:12:01Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-07T21:31:01Z"}, "message": "Implement multi-bit aligned accessors for sparse bitmap.\n\nProvide set/get routines to allow sparse bitmaps to be treated as an array\nof multiple bit values. Only chunk sizes that are powers of 2 are supported.\n\n\t* bitmap.c (bitmap_set_aligned_chunk): New.\n\t(bitmap_get_aligned_chunk): New.\n\t(test_aligned_chunk): New.\n\t(bitmap_c_tests): Call test_aligned_chunk.\n\t* bitmap.h (bitmap_set_aligned_chunk, bitmap_get_aligned_chunk): New.", "tree": {"sha": "4f832709576103acddbc6dea927c4269611c2968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f832709576103acddbc6dea927c4269611c2968"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad089a3c946aec655436fa3b0b50d6574b78197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad089a3c946aec655436fa3b0b50d6574b78197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad089a3c946aec655436fa3b0b50d6574b78197", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad089a3c946aec655436fa3b0b50d6574b78197/comments", "author": null, "committer": null, "parents": [{"sha": "64735dc923e0a1a2e04c5313471d91ca8b954e9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64735dc923e0a1a2e04c5313471d91ca8b954e9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64735dc923e0a1a2e04c5313471d91ca8b954e9a"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "b915fdfbb54d9eb026aef9c0740c487daf07c934", "filename": "gcc/bitmap.c", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad089a3c946aec655436fa3b0b50d6574b78197/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad089a3c946aec655436fa3b0b50d6574b78197/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=5ad089a3c946aec655436fa3b0b50d6574b78197", "patch": "@@ -1004,6 +1004,83 @@ bitmap_bit_p (const_bitmap head, int bit)\n   return (ptr->bits[word_num] >> bit_num) & 1;\n }\n \f\n+/* Set CHUNK_SIZE bits at a time in bitmap HEAD.\n+   Store CHUNK_VALUE starting at bits CHUNK * chunk_size.\n+   This is the set routine for viewing bitmap as a multi-bit sparse array.  */\n+\n+void\n+bitmap_set_aligned_chunk (bitmap head, unsigned int chunk,\n+\t\t\t  unsigned int chunk_size, BITMAP_WORD chunk_value)\n+{\n+  // Ensure chunk size is a power of 2 and fits in BITMAP_WORD.\n+  gcc_checking_assert (pow2p_hwi (chunk_size));\n+  gcc_checking_assert (chunk_size < (sizeof (BITMAP_WORD) * CHAR_BIT));\n+\n+  // Ensure chunk_value is within range of chunk_size bits.\n+  BITMAP_WORD max_value = (1 << chunk_size) - 1;\n+  gcc_checking_assert (chunk_value <= max_value);\n+\n+  unsigned bit = chunk * chunk_size;\n+  unsigned indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+  bitmap_element *ptr;\n+  if (!head->tree_form)\n+    ptr = bitmap_list_find_element (head, indx);\n+  else\n+    ptr = bitmap_tree_find_element (head, indx);\n+  unsigned word_num = bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n+  unsigned bit_num  = bit % BITMAP_WORD_BITS;\n+  BITMAP_WORD bit_val = chunk_value << bit_num;\n+  BITMAP_WORD mask = ~(max_value << bit_num);\n+\n+  if (ptr != 0)\n+    {\n+      ptr->bits[word_num] &= mask;\n+      ptr->bits[word_num] |= bit_val;\n+      return;\n+    }\n+\n+  ptr = bitmap_element_allocate (head);\n+  ptr->indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+  ptr->bits[word_num] = bit_val;\n+  if (!head->tree_form)\n+    bitmap_list_link_element (head, ptr);\n+  else\n+    bitmap_tree_link_element (head, ptr);\n+}\n+\n+/* This is the get routine for viewing bitmap as a multi-bit sparse array.\n+   Return a set of CHUNK_SIZE consecutive bits from HEAD, starting at bit\n+   CHUNK * chunk_size.   */\n+\n+BITMAP_WORD\n+bitmap_get_aligned_chunk (const_bitmap head, unsigned int chunk,\n+\t\t\t  unsigned int chunk_size)\n+{\n+  // Ensure chunk size is a power of 2, fits in BITMAP_WORD and is in range.\n+  gcc_checking_assert (pow2p_hwi (chunk_size));\n+  gcc_checking_assert (chunk_size < (sizeof (BITMAP_WORD) * CHAR_BIT));\n+\n+  BITMAP_WORD max_value = (1 << chunk_size) - 1;\n+  unsigned bit = chunk * chunk_size;\n+  unsigned int indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+  const bitmap_element *ptr;\n+  unsigned bit_num;\n+  unsigned word_num;\n+\n+  if (!head->tree_form)\n+    ptr = bitmap_list_find_element (const_cast<bitmap> (head), indx);\n+  else\n+    ptr = bitmap_tree_find_element (const_cast<bitmap> (head), indx);\n+  if (ptr == 0)\n+    return 0;\n+\n+  bit_num = bit % BITMAP_WORD_BITS;\n+  word_num = bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n+\n+  // Return 4 bits.\n+  return (ptr->bits[word_num] >> bit_num) & max_value;\n+}\n+\f\n #if GCC_VERSION < 3400\n /* Table of number of set bits in a character, indexed by value of char.  */\n static const unsigned char popcount_table[] =\n@@ -2857,6 +2934,33 @@ test_bitmap_single_bit_set_p ()\n   ASSERT_EQ (1066, bitmap_first_set_bit (b));\n }\n \n+/* Verify accessing aligned bit chunks works as expected.  */\n+\n+static void\n+test_aligned_chunk (unsigned num_bits)\n+{\n+  bitmap b = bitmap_gc_alloc ();\n+  int limit = 2 ^ num_bits;\n+\n+  int index = 3;\n+  for (int x = 0; x < limit; x++)\n+    {\n+      bitmap_set_aligned_chunk (b, index, num_bits, (BITMAP_WORD) x);\n+      ASSERT_TRUE ((int) bitmap_get_aligned_chunk (b, index, num_bits) == x);\n+      ASSERT_TRUE ((int) bitmap_get_aligned_chunk (b, index + 1,\n+\t\t\t\t\t\t   num_bits) == 0);\n+      ASSERT_TRUE ((int) bitmap_get_aligned_chunk (b, index - 1,\n+\t\t\t\t\t\t   num_bits) == 0);\n+      index += 3;\n+    }\n+  index = 3;\n+  for (int x = 0; x < limit ; x++)\n+    {\n+      ASSERT_TRUE ((int) bitmap_get_aligned_chunk (b, index, num_bits) == x);\n+      index += 3;\n+    }\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -2867,6 +2971,10 @@ bitmap_c_tests ()\n   test_clear_bit_in_middle ();\n   test_copying ();\n   test_bitmap_single_bit_set_p ();\n+  /* Test 2, 4 and 8 bit aligned chunks.  */\n+  test_aligned_chunk (2);\n+  test_aligned_chunk (4);\n+  test_aligned_chunk (8);\n }\n \n } // namespace selftest"}, {"sha": "0846f79665ddf851fc5146d61bc87365c2f0ba77", "filename": "gcc/bitmap.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad089a3c946aec655436fa3b0b50d6574b78197/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad089a3c946aec655436fa3b0b50d6574b78197/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=5ad089a3c946aec655436fa3b0b50d6574b78197", "patch": "@@ -438,6 +438,13 @@ extern bool bitmap_set_bit (bitmap, int);\n /* Return true if a bit is set in a bitmap.  */\n extern int bitmap_bit_p (const_bitmap, int);\n \n+/* Set and get multiple bit values in a sparse bitmap.  This allows a bitmap to\n+   function as a sparse array of bit patterns where the patterns are\n+   multiples of power of 2. This is more efficient than performing this as\n+   multiple individual operations.  */\n+void bitmap_set_aligned_chunk (bitmap, unsigned int, unsigned int, BITMAP_WORD);\n+BITMAP_WORD bitmap_get_aligned_chunk (const_bitmap, unsigned int, unsigned int);\n+\n /* Debug functions to print a bitmap.  */\n extern void debug_bitmap (const_bitmap);\n extern void debug_bitmap_file (FILE *, const_bitmap);"}]}