{"sha": "d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg4ZTJjYjU0OTE0Y2Y4YWEwYWU2OGNhNzVkYzQ1MjM3YWNmY2VmMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-13T16:08:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-13T16:08:08Z"}, "message": "varasm: Reject soft frame or arg pointer registers for register vars [PR92469]\n\nThe following patch rejects frame, argp and retarg registers (unless they are equal\nto hard frame pointer registers or if they aren't eliminable) from local or global\nregister vars.\nThese are just internal implementation details eliminated later into hard\nframe pointer or stack pointer and using them as register variable leads\nto numerous ICEs.\n\n2020-12-13  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/92469\n\t* varasm.c (eliminable_regno_p): New function.\n\t(make_decl_rtl): Reject asm vars for frame and argp\n\tif they are different from hard frame pointer.\n\n\t* gcc.target/i386/pr92469.c: New test.\n\t* gcc.target/i386/pr79804.c: Adjust expected diagnostics.\n\t* gcc.target/i386/pr88178.c: Expect an error.", "tree": {"sha": "4bf7aac7518e05f8e01249158089a9b4b5b30a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bf7aac7518e05f8e01249158089a9b4b5b30a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b8a82f97dd48e153ce93b317c44254839e11461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8a82f97dd48e153ce93b317c44254839e11461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8a82f97dd48e153ce93b317c44254839e11461"}], "stats": {"total": 58, "additions": 54, "deletions": 4}, "files": [{"sha": "fcfcef751677dd3eccf60393febe7b710270ade2", "filename": "gcc/testsuite/gcc.target/i386/pr79804.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr79804.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr79804.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr79804.c?ref=d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "patch": "@@ -4,7 +4,7 @@\n \n void foo (void)\n {\n-  register int r19 asm (\"19\");\n+  register int r19 asm (\"19\");\t/* { dg-error \"register specified for 'r19' is an internal GCC implementation detail\" } */\n \n-  asm volatile (\"# %0\" : \"=r\"(r19));  /* { dg-error \"invalid use of register\" } */\n-}  /* { dg-error \"cannot be used in 'asm' here\" } */\n+  asm volatile (\"# %0\" : \"=r\"(r19));\n+}"}, {"sha": "622e1c2074cdf2affaec1c95c397aa43679d1e4e", "filename": "gcc/testsuite/gcc.target/i386/pr88178.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr88178.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr88178.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr88178.c?ref=d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "patch": "@@ -4,5 +4,5 @@\n \n void foo (void)\n {\n-  register int r19 asm (\"19\");\n+  register int r19 asm (\"19\");\t/* { dg-error \"register specified for 'r19' is an internal GCC implementation detail\" } */\n }"}, {"sha": "8cff36b5c378959c667e543b486c49d48f959502", "filename": "gcc/testsuite/gcc.target/i386/pr92469.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92469.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92469.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92469.c?ref=d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/92469 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0\" } */\n+\n+void\n+foo (void)\n+{ \n+  register int x asm (\"frame\");\t/* { dg-error \"register specified for 'x' is an internal GCC implementation detail\" } */\n+  int y = x;\n+}\n+\n+void\n+bar (void)\n+{ \n+  register int x asm (\"19\");\t/* { dg-error \"register specified for 'x' is an internal GCC implementation detail\" } */\n+  int y = x;\n+}\n+\n+void\n+baz (void)\n+{ \n+  register int x asm (\"argp\");\t/* { dg-error \"register specified for 'x' is an internal GCC implementation detail\" } */\n+  int y = x;\n+}"}, {"sha": "c5487a78b130eee8a210c48774284da8c2f2b8ed", "filename": "gcc/varasm.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88e2cb54914cf8aa0ae68ca75dc45237acfcef0/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d88e2cb54914cf8aa0ae68ca75dc45237acfcef0", "patch": "@@ -1371,6 +1371,23 @@ ultimate_transparent_alias_target (tree *alias)\n   return target;\n }\n \n+/* Return true if REGNUM is mentioned in ELIMINABLE_REGS as a from\n+   register number.  */\n+\n+static bool\n+eliminable_regno_p (int regnum)\n+{\n+  static const struct\n+  {\n+    const int from;\n+    const int to;\n+  } eliminables[] = ELIMINABLE_REGS;\n+  for (size_t i = 0; i < ARRAY_SIZE (eliminables); i++)\n+    if (regnum == eliminables[i].from)\n+      return true;\n+  return false;\n+}\n+\n /* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should\n    have static storage duration.  In other words, it should not be an\n    automatic variable, including PARM_DECLs.\n@@ -1473,6 +1490,15 @@ make_decl_rtl (tree decl)\n       else if (!targetm.hard_regno_mode_ok (reg_number, mode))\n \terror (\"register specified for %q+D isn%'t suitable for data type\",\n                decl);\n+      else if (reg_number != HARD_FRAME_POINTER_REGNUM\n+\t       && (reg_number == FRAME_POINTER_REGNUM\n+#ifdef RETURN_ADDRESS_POINTER_REGNUM\n+\t\t   || reg_number == RETURN_ADDRESS_POINTER_REGNUM\n+#endif\n+\t\t   || reg_number == ARG_POINTER_REGNUM)\n+\t       && eliminable_regno_p (reg_number))\n+\terror (\"register specified for %q+D is an internal GCC \"\n+\t       \"implementation detail\", decl);\n       /* Now handle properly declared static register variables.  */\n       else\n \t{"}]}