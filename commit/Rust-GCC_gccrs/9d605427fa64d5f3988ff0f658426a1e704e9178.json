{"sha": "9d605427fa64d5f3988ff0f658426a1e704e9178", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ2MDU0MjdmYTY0ZDVmMzk4OGZmMGY2NTg0MjZhMWU3MDRlOTE3OA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-03-24T13:53:43Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-03-24T13:53:43Z"}, "message": "S/390: Improve support of 128 bit vectors in GPRs\n\nThis patch improves the handling of 128 bit vectors residing in GPRs\nby adding more alternatives to the move pattern.\n\nRegression tested on s390x.\n\ngcc/ChangeLog:\n\n2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/constraints.md: Add comments.\n\t(jKK): Reject element sizes > 8 bytes.\n\t* config/s390/s390.c (s390_split_ok_p): Enable splitting also for\n\ts_operands.\n\t* config/s390/s390.md: Add the s_operand checks formerly in\n\ts390_split_ok_p to various splitters where they are still\n\trequired.\n\t* config/s390/vector.md (\"mov<mode>\" V_128): Add GPR alternatives\n\tfor 128 bit vectors.  Plus two splitters.\n\nFrom-SVN: r246445", "tree": {"sha": "64f82f05433ab392a1c3945b90fb5f938fdd94cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64f82f05433ab392a1c3945b90fb5f938fdd94cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d605427fa64d5f3988ff0f658426a1e704e9178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d605427fa64d5f3988ff0f658426a1e704e9178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d605427fa64d5f3988ff0f658426a1e704e9178", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d605427fa64d5f3988ff0f658426a1e704e9178/comments", "author": null, "committer": null, "parents": [{"sha": "285363a1bee051abdfa5bd4b3bd2c296c2fd6777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/285363a1bee051abdfa5bd4b3bd2c296c2fd6777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/285363a1bee051abdfa5bd4b3bd2c296c2fd6777"}], "stats": {"total": 93, "additions": 83, "deletions": 10}, "files": [{"sha": "ef736f5626e94ea3cdab837a9a1784ed92747ff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d605427fa64d5f3988ff0f658426a1e704e9178", "patch": "@@ -1,3 +1,15 @@\n+2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/constraints.md: Add comments.\n+\t(jKK): Reject element sizes > 8 bytes.\n+\t* config/s390/s390.c (s390_split_ok_p): Enable splitting also for\n+\ts_operands.\n+\t* config/s390/s390.md: Add the s_operand checks formerly in\n+\ts390_split_ok_p to various splitters where they are still\n+\trequired.\n+\t* config/s390/vector.md (\"mov<mode>\" V_128): Add GPR alternatives\n+\tfor 128 bit vectors.  Plus two splitters.\n+\n 2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md: Rename the cpu facilty vec to vx throughout"}, {"sha": "95c6a8f7ea0b2190cfe2112cb5ca59436c781f12", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=9d605427fa64d5f3988ff0f658426a1e704e9178", "patch": "@@ -410,20 +410,26 @@\n   \"All one bit scalar or vector constant\"\n   (match_test \"op == CONSTM1_RTX (GET_MODE (op))\"))\n \n+; vector generate mask operand - support for up to 64 bit elements\n (define_constraint \"jxx\"\n   \"@internal\"\n   (and (match_code \"const_vector\")\n        (match_test \"s390_contiguous_bitmask_vector_p (op, NULL, NULL)\")))\n \n+; vector generate byte mask operand - this is only supposed to deal\n+; with real vectors 128 bit values of being either 0 or -1 are handled\n+; with j00 and jm1\n (define_constraint \"jyy\"\n   \"@internal\"\n   (and (match_code \"const_vector\")\n        (match_test \"s390_bytemask_vector_p (op, NULL)\")))\n \n+; vector replicate immediate operand - support for up to 64 bit elements\n (define_constraint \"jKK\"\n   \"@internal\"\n-  (and (and (match_code \"const_vector\")\n-\t    (match_test \"const_vec_duplicate_p (op)\"))\n+  (and (and (and (match_code \"const_vector\")\n+\t\t (match_test \"const_vec_duplicate_p (op)\"))\n+\t    (match_test \"GET_MODE_UNIT_SIZE (GET_MODE (op)) <= 8\"))\n        (match_test \"satisfies_constraint_K (XVECEXP (op, 0, 0))\")))\n \n (define_constraint \"jm6\""}, {"sha": "f3cebd63ef93f5fc07b5bf80792c54098915c8d8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9d605427fa64d5f3988ff0f658426a1e704e9178", "patch": "@@ -2494,10 +2494,6 @@ s390_split_ok_p (rtx dst, rtx src, machine_mode mode, int first_subword)\n   if (FP_REG_P (src) || FP_REG_P (dst) || VECTOR_REG_P (src) || VECTOR_REG_P (dst))\n     return false;\n \n-  /* We don't need to split if operands are directly accessible.  */\n-  if (s_operand (src, mode) || s_operand (dst, mode))\n-    return false;\n-\n   /* Non-offsettable memory references cannot be split.  */\n   if ((GET_CODE (src) == MEM && !offsettable_memref_p (src))\n       || (GET_CODE (dst) == MEM && !offsettable_memref_p (dst)))"}, {"sha": "555a779d16e825d85e234818037bd9ac0bdf0df2", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=9d605427fa64d5f3988ff0f658426a1e704e9178", "patch": "@@ -1490,6 +1490,8 @@\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TI 1 \"general_operand\" \"\"))]\n   \"TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], TImode)\n+   && !s_operand (operands[1], TImode)\n    && s390_split_ok_p (operands[0], operands[1], TImode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1504,6 +1506,8 @@\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TI 1 \"general_operand\" \"\"))]\n   \"TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], TImode)\n+   && !s_operand (operands[1], TImode)\n    && s390_split_ok_p (operands[0], operands[1], TImode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1824,6 +1828,8 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"!TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], DImode)\n+   && !s_operand (operands[1], DImode)\n    && s390_split_ok_p (operands[0], operands[1], DImode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1838,6 +1844,8 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"!TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], DImode)\n+   && !s_operand (operands[1], DImode)\n    && s390_split_ok_p (operands[0], operands[1], DImode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -2364,6 +2372,8 @@\n   [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n   \"TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], <MODE>mode)\n+   && !s_operand (operands[1], <MODE>mode)\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -2378,6 +2388,8 @@\n   [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n   \"TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], <MODE>mode)\n+   && !s_operand (operands[1], <MODE>mode)\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -2532,6 +2544,8 @@\n   [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DD_DF 1 \"general_operand\" \"\"))]\n   \"!TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], <MODE>mode)\n+   && !s_operand (operands[1], <MODE>mode)\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -2546,6 +2560,8 @@\n   [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DD_DF 1 \"general_operand\" \"\"))]\n   \"!TARGET_ZARCH && reload_completed\n+   && !s_operand (operands[0], <MODE>mode)\n+   && !s_operand (operands[1], <MODE>mode)\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]"}, {"sha": "38905e86b099fbeff9d2d22b87af1942c54ea864", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d605427fa64d5f3988ff0f658426a1e704e9178/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=9d605427fa64d5f3988ff0f658426a1e704e9178", "patch": "@@ -144,11 +144,18 @@\n (include \"vx-builtins.md\")\n \n ; Full HW vector size moves\n+\n+; We don't use lm/stm for 128 bit moves since these are slower than\n+; splitting it into separate moves.\n+\n+; FIXME: More constants are possible by enabling jxx, jyy constraints\n+; for TImode (use double-int for the calculations)\n+\n ; vgmb, vgmh, vgmf, vgmg, vrepib, vrepih, vrepif, vrepig\n (define_insn \"mov<mode>\"\n-  [(set (match_operand:V_128 0 \"nonimmediate_operand\" \"=v,v,R,  v,  v,  v,  v,  v,v,d\")\n-\t(match_operand:V_128 1 \"general_operand\"      \" v,R,v,j00,jm1,jyy,jxx,jKK,d,v\"))]\n-  \"TARGET_VX\"\n+  [(set (match_operand:V_128 0 \"nonimmediate_operand\" \"=v,v,R,  v,  v,  v,  v,  v,v,*d,*d,?o\")\n+\t(match_operand:V_128 1 \"general_operand\"      \" v,R,v,j00,jm1,jyy,jxx,jKK,d, v,dT,*d\"))]\n+  \"\"\n   \"@\n    vlr\\t%v0,%v1\n    vl\\t%v0,%1\n@@ -159,9 +166,13 @@\n    vgm<bhfgq>\\t%v0,%s1,%e1\n    vrepi<bhfgq>\\t%v0,%h1\n    vlvgp\\t%v0,%1,%N1\n+   #\n+   #\n    #\"\n-  [(set_attr \"op_type\" \"VRR,VRX,VRX,VRI,VRI,VRI,VRI,VRI,VRR,*\")])\n+  [(set_attr \"cpu_facility\" \"vx,vx,vx,vx,vx,vx,vx,vx,vx,vx,*,*\")\n+   (set_attr \"op_type\"      \"VRR,VRX,VRX,VRI,VRI,VRI,VRI,VRI,VRR,*,*,*\")])\n \n+; VR -> GPR, no instruction so split it into 64 element sets.\n (define_split\n   [(set (match_operand:V_128 0 \"register_operand\" \"\")\n \t(match_operand:V_128 1 \"register_operand\" \"\"))]\n@@ -177,6 +188,38 @@\n   operands[3] = operand_subword (operands[0], 1, 0, <MODE>mode);\n })\n \n+; Split the 128 bit GPR move into two word mode moves\n+; s390_split_ok_p decides which part needs to be moved first.\n+\n+(define_split\n+  [(set (match_operand:V_128 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V_128 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 0)\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = operand_subword (operands[0], 0, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 1, 0, <MODE>mode);\n+  operands[4] = operand_subword (operands[1], 0, 0, <MODE>mode);\n+  operands[5] = operand_subword (operands[1], 1, 0, <MODE>mode);\n+})\n+\n+(define_split\n+  [(set (match_operand:V_128 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V_128 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 1)\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = operand_subword (operands[0], 1, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 0, 0, <MODE>mode);\n+  operands[4] = operand_subword (operands[1], 1, 0, <MODE>mode);\n+  operands[5] = operand_subword (operands[1], 0, 0, <MODE>mode);\n+})\n+\n+\n ; Moves for smaller vector modes.\n \n ; In these patterns only the vlr, vone, and vzero instructions write"}]}