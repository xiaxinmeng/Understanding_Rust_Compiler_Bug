{"sha": "ffd961fc053419bc1eb37792c18ec98e7c3bc364", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZkOTYxZmMwNTM0MTliYzFlYjM3NzkyYzE4ZWM5OGU3YzNiYzM2NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-08T07:57:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-08T08:04:06Z"}, "message": "PR tree-optimization/96344\n\nThe very recent addition of the if_to_switch pass has partially disabled\nthe optimization added back in June to optimize_range_tests_to_bit_test,\nas witnessed by the 3 new failures in the gnat.dg testsuite.  It turns out\nthat both tree-ssa-reassoc.c and tree-switch-conversion.c can turn things\ninto bit tests so the optimization is added to bit_test_cluster::emit too.\n\nThe patch also contains a secondary optimization, whereby the full bit-test\nsequence is sent to the folder before being gimplified in case there is only\none test, so that the optimal sequence (bt + jc on x86) can be emitted like\nwith optimize_range_tests_to_bit_test.\n\ngcc/ChangeLog:\n\tPR tree-optimization/96344\n\t* tree-switch-conversion.c (bit_test_cluster::emit): Compute the\n\trange only if an entry test is necessary.  Merge the entry test in\n\tthe bit test when possible.  Use PREC local variable consistently.\n\tWhen there is only one test, do a single gimplification at the end.", "tree": {"sha": "3b7ed2121bda01ce10f7f3366d7b0c9c9fa21865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b7ed2121bda01ce10f7f3366d7b0c9c9fa21865"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffd961fc053419bc1eb37792c18ec98e7c3bc364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd961fc053419bc1eb37792c18ec98e7c3bc364", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd961fc053419bc1eb37792c18ec98e7c3bc364", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd961fc053419bc1eb37792c18ec98e7c3bc364/comments", "author": null, "committer": null, "parents": [{"sha": "4aaf33718f09daf1cd2864b3db07faa2e44642ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aaf33718f09daf1cd2864b3db07faa2e44642ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aaf33718f09daf1cd2864b3db07faa2e44642ff"}], "stats": {"total": 60, "additions": 46, "deletions": 14}, "files": [{"sha": "989bd7710d1f84a0c5e2c45a8b1ba12e1b3528ef", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffd961fc053419bc1eb37792c18ec98e7c3bc364/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffd961fc053419bc1eb37792c18ec98e7c3bc364/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=ffd961fc053419bc1eb37792c18ec98e7c3bc364", "patch": "@@ -1511,7 +1511,6 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \n   tree minval = get_low ();\n   tree maxval = get_high ();\n-  tree range = int_const_binop (MINUS_EXPR, maxval, minval);\n   unsigned HOST_WIDE_INT bt_range = get_range (minval, maxval);\n \n   /* Go through all case labels, and collect the case labels, profile\n@@ -1550,11 +1549,38 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \n   qsort (test, count, sizeof (*test), case_bit_test::cmp);\n \n+  /* If every possible relative value of the index expression is a valid shift\n+     amount, then we can merge the entry test in the bit test.  */\n+  wide_int min, max;\n+  bool entry_test_needed;\n+  if (TREE_CODE (index_expr) == SSA_NAME\n+      && get_range_info (index_expr, &min, &max) == VR_RANGE\n+      && wi::leu_p (max - min, prec - 1))\n+    {\n+      wide_int iminval = wi::to_wide (minval);\n+      tree minval_type = TREE_TYPE (minval);\n+      if (wi::lt_p (min, iminval, TYPE_SIGN (minval_type)))\n+\t{\n+\t  minval = wide_int_to_tree (minval_type, min);\n+\t  for (i = 0; i < count; i++)\n+\t    test[i].mask = wi::lshift (test[i].mask, iminval - min);\n+\t}\n+      else if (wi::gt_p (min, iminval, TYPE_SIGN (minval_type)))\n+\t{\n+\t  minval = wide_int_to_tree (minval_type, min);\n+\t  for (i = 0; i < count; i++)\n+\t    test[i].mask = wi::lrshift (test[i].mask, min - iminval);\n+\t}\n+      maxval = wide_int_to_tree (minval_type, max);\n+      entry_test_needed = false;\n+    }\n+  else\n+    entry_test_needed = true;\n+\n   /* If all values are in the 0 .. BITS_PER_WORD-1 range, we can get rid of\n      the minval subtractions, but it might make the mask constants more\n      expensive.  So, compare the costs.  */\n-  if (compare_tree_int (minval, 0) > 0\n-      && compare_tree_int (maxval, GET_MODE_BITSIZE (word_mode)) < 0)\n+  if (compare_tree_int (minval, 0) > 0 && compare_tree_int (maxval, prec) < 0)\n     {\n       int cost_diff;\n       HOST_WIDE_INT m = tree_to_uhwi (minval);\n@@ -1577,7 +1603,6 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \t  for (i = 0; i < count; i++)\n \t    test[i].mask = wi::lshift (test[i].mask, m);\n \t  minval = build_zero_cst (TREE_TYPE (minval));\n-\t  range = maxval;\n \t}\n     }\n \n@@ -1593,8 +1618,9 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \t\t\t\t  /*simple=*/true, NULL_TREE,\n \t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n \n-  if (m_handles_entire_switch)\n+  if (m_handles_entire_switch && entry_test_needed)\n     {\n+      tree range = int_const_binop (MINUS_EXPR, maxval, minval);\n       /* if (idx > range) goto default */\n       range\n \t= force_gimple_operand_gsi (&gsi,\n@@ -1608,16 +1634,22 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n       gsi = gsi_last_bb (new_bb);\n     }\n \n-  /* csui = (1 << (word_mode) idx) */\n-  csui = make_ssa_name (word_type_node);\n   tmp = fold_build2 (LSHIFT_EXPR, word_type_node, word_mode_one,\n \t\t     fold_convert (word_type_node, idx));\n-  tmp = force_gimple_operand_gsi (&gsi, tmp,\n-\t\t\t\t  /*simple=*/false, NULL_TREE,\n-\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n-  shift_stmt = gimple_build_assign (csui, tmp);\n-  gsi_insert_before (&gsi, shift_stmt, GSI_SAME_STMT);\n-  update_stmt (shift_stmt);\n+\n+  /* csui = (1 << (word_mode) idx) */\n+  if (count > 1)\n+    {\n+      csui = make_ssa_name (word_type_node);\n+      tmp = force_gimple_operand_gsi (&gsi, tmp,\n+\t\t\t\t     /*simple=*/false, NULL_TREE,\n+\t\t\t\t     /*before=*/true, GSI_SAME_STMT);\n+      shift_stmt = gimple_build_assign (csui, tmp);\n+      gsi_insert_before (&gsi, shift_stmt, GSI_SAME_STMT);\n+      update_stmt (shift_stmt);\n+    }\n+  else\n+    csui = tmp;\n \n   profile_probability prob = profile_probability::always ();\n \n@@ -1630,10 +1662,10 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n       bt_range -= test[k].bits;\n       tmp = wide_int_to_tree (word_type_node, test[k].mask);\n       tmp = fold_build2 (BIT_AND_EXPR, word_type_node, csui, tmp);\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, word_mode_zero);\n       tmp = force_gimple_operand_gsi (&gsi, tmp,\n \t\t\t\t      /*simple=*/true, NULL_TREE,\n \t\t\t\t      /*before=*/true, GSI_SAME_STMT);\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, word_mode_zero);\n       basic_block new_bb\n \t= hoist_edge_and_branch_if_true (&gsi, tmp, test[k].target_bb, prob);\n       gsi = gsi_last_bb (new_bb);"}]}