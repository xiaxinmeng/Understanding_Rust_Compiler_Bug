{"sha": "d119f34c952f8718fdbabc63e2f369a16e92fa07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDExOWYzNGM5NTJmODcxOGZkYmFiYzYzZTJmMzY5YTE2ZTkyZmEwNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-20T05:25:16Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-20T05:27:48Z"}, "message": "New modref/ipa_modref optimization passes\n\n2020-09-19  David Cepelik  <d@dcepelik.cz>\n\t    Jan Hubicka  <hubicka@ucw.cz>\n\n\t* Makefile.in: Add ipa-modref.c and ipa-modref-tree.c.\n\t* alias.c: (reference_alias_ptr_type_1): Export.\n\t* alias.h (reference_alias_ptr_type_1): Declare.\n\t* common.opt (fipa-modref): New.\n\t* gengtype.c (open_base_files): Add ipa-modref-tree.h and ipa-modref.h\n\t* ipa-modref-tree.c: New file.\n\t* ipa-modref-tree.h: New file.\n\t* ipa-modref.c: New file.\n\t* ipa-modref.h: New file.\n\t* lto-section-in.c (lto_section_name): Add ipa_modref.\n\t* lto-streamer.h (enum lto_section_type): Add LTO_section_ipa_modref.\n\t* opts.c (default_options_table): Enable ipa-modref at -O1+.\n\t* params.opt (-param=modref-max-bases, -param=modref-max-refs,\n\t-param=modref-max-tests): New params.\n\t* passes.def: Schedule pass_modref and pass_ipa_modref.\n\t* timevar.def (TV_IPA_MODREF): New timevar.\n\t(TV_TREE_MODREF): New timevar.\n\t* tree-pass.h (make_pass_modref): Declare.\n\t(make_pass_ipa_modref): Declare.\n\t* tree-ssa-alias.c (dump_alias_stats): Include ipa-modref-tree.h\n\tand ipa-modref.h\n\t(alias_stats): Add modref_use_may_alias, modref_use_no_alias,\n\tmodref_clobber_may_alias, modref_clobber_no_alias, modref_tests.\n\t(dump_alias_stats): Dump new stats.\n\t(nonoverlapping_array_refs_p): Fix formating.\n\t(modref_may_conflict): New function.\n\t(ref_maybe_used_by_call_p_1): Use it.\n\t(call_may_clobber_ref_p_1): Use it.\n\t(call_may_clobber_ref_p): Update.\n\t(stmt_may_clobber_ref_p_1): Update.\n\t* tree-ssa-alias.h (call_may_clobber_ref_p_1): Update.", "tree": {"sha": "3f1a460afbcfeafd21f63e7d843251c5b07ea9e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f1a460afbcfeafd21f63e7d843251c5b07ea9e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d119f34c952f8718fdbabc63e2f369a16e92fa07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d119f34c952f8718fdbabc63e2f369a16e92fa07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d119f34c952f8718fdbabc63e2f369a16e92fa07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d119f34c952f8718fdbabc63e2f369a16e92fa07/comments", "author": null, "committer": null, "parents": [{"sha": "2fe5b7d1f66457c637b8bd2543a60a5faff34c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe5b7d1f66457c637b8bd2543a60a5faff34c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe5b7d1f66457c637b8bd2543a60a5faff34c40"}], "stats": {"total": 2124, "additions": 2108, "deletions": 16}, "files": [{"sha": "c710bad27b1743c1d1127db05092b7bc0d6013e3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -1419,6 +1419,8 @@ OBJS = \\\n \tipa-visibility.o \\\n \tipa-inline-analysis.o \\\n \tipa-inline-transform.o \\\n+\tipa-modref.o \\\n+\tipa-modref-tree.o \\\n \tipa-predicate.o \\\n \tipa-profile.o \\\n \tipa-prop.o \\\n@@ -2587,6 +2589,8 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-utils.h \\\n   $(srcdir)/ipa-param-manipulation.h $(srcdir)/ipa-sra.c $(srcdir)/dbxout.c \\\n+  $(srcdir)/ipa-modref.h $(srcdir)/ipa-modref.c \\\n+  $(srcdir)/ipa-modref-tree.h \\\n   $(srcdir)/signop.h \\\n   $(srcdir)/dwarf2out.h \\\n   $(srcdir)/dwarf2asm.c \\"}, {"sha": "1cb702be2ce3bc3a7c565b313bcd08217f11f761", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -737,7 +737,7 @@ get_deref_alias_set (tree t)\n    adjusted to point to the outermost component reference that\n    can be used for assigning an alias set.  */\n  \n-static tree\n+tree\n reference_alias_ptr_type_1 (tree *t)\n {\n   tree inner;"}, {"sha": "807af957f02c863b89117600ff1081a693ec74e5", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -36,6 +36,7 @@ extern int objects_must_conflict_p (tree, tree);\n extern int nonoverlapping_memrefs_p (const_rtx, const_rtx, bool);\n extern void dump_alias_stats_in_alias_c (FILE *s);\n tree reference_alias_ptr_type (tree);\n+tree reference_alias_ptr_type_1 (tree *);\n bool alias_ptr_types_compatible_p (tree, tree);\n int compare_base_decls (tree, tree);\n bool refs_same_for_tbaa_p (tree, tree);"}, {"sha": "b833b98dfb8d46550c25b4a1dcd243cd6c81f58e", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -1825,6 +1825,10 @@ fipa-bit-cp\n Common Report Var(flag_ipa_bit_cp) Optimization\n Perform interprocedural bitwise constant propagation.\n \n+fipa-modref\n+Common Report Var(flag_ipa_modref) Optimization\n+Perform interprocedural modref analysis\n+\n fipa-profile\n Common Report Var(flag_ipa_profile) Init(0) Optimization\n Perform interprocedural profile propagation."}, {"sha": "a59a8823f82a40cbefe30fdc875bf791182113ce", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -1726,7 +1726,7 @@ open_base_files (void)\n       \"except.h\", \"output.h\",  \"cfgloop.h\", \"target.h\", \"lto-streamer.h\",\n       \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"symbol-summary.h\",\n       \"ipa-prop.h\", \"ipa-fnsummary.h\", \"dwarf2out.h\", \"omp-general.h\",\n-      \"omp-offload.h\", NULL\n+      \"omp-offload.h\", \"ipa-modref-tree.h\", \"ipa-modref.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "e37dee67fa3b0a19f96a2d295e03bb0b6cc0920c", "filename": "gcc/ipa-modref-tree.c", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -0,0 +1,236 @@\n+/* Data structure for the modref pass.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Cepelik and Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+\n+static void\n+test_insert_search_collapse ()\n+{\n+  modref_base_node<alias_set_type> *base_node;\n+  modref_ref_node<alias_set_type> *ref_node;\n+\n+  modref_tree<alias_set_type> *t = new modref_tree<alias_set_type>(1, 2);\n+  ASSERT_FALSE (t->every_base);\n+\n+  /* Insert into an empty tree.  */\n+  t->insert (1, 2);\n+  ASSERT_NE (t->bases, NULL);\n+  ASSERT_EQ (t->bases->length (), 1);\n+  ASSERT_FALSE (t->every_base);\n+  ASSERT_EQ (t->search (2), NULL);\n+\n+  base_node = t->search (1);\n+  ASSERT_NE (base_node, NULL);\n+  ASSERT_EQ (base_node->base, 1);\n+  ASSERT_NE (base_node->refs, NULL);\n+  ASSERT_EQ (base_node->refs->length (), 1);\n+  ASSERT_EQ (base_node->search (1), NULL);\n+\n+  ref_node = base_node->search (2);\n+  ASSERT_NE (ref_node, NULL);\n+  ASSERT_EQ (ref_node->ref, 2);\n+\n+  /* Insert when base exists but ref does not.  */\n+  t->insert (1, 3);\n+  ASSERT_NE (t->bases, NULL);\n+  ASSERT_EQ (t->bases->length (), 1);\n+  ASSERT_EQ (t->search (1), base_node);\n+  ASSERT_EQ (t->search (2), NULL);\n+  ASSERT_NE (base_node->refs, NULL);\n+  ASSERT_EQ (base_node->refs->length (), 2);\n+\n+  ref_node = base_node->search (3);\n+  ASSERT_NE (ref_node, NULL);\n+\n+  /* Insert when base and ref exist, but access is not dominated by nor\n+     dominates other accesses.  */\n+  t->insert (1, 2);\n+  ASSERT_EQ (t->bases->length (), 1);\n+  ASSERT_EQ (t->search (1), base_node);\n+\n+  ref_node = base_node->search (2);\n+  ASSERT_NE (ref_node, NULL);\n+\n+  /* Insert when base and ref exist and access is dominated.  */\n+  t->insert (1, 2);\n+  ASSERT_EQ (t->search (1), base_node);\n+  ASSERT_EQ (base_node->search (2), ref_node);\n+\n+  /* Insert ref to trigger ref list collapse for base 1.  */\n+  t->insert (1, 4);\n+  ASSERT_EQ (t->search (1), base_node);\n+  ASSERT_EQ (base_node->refs, NULL);\n+  ASSERT_EQ (base_node->search (2), NULL);\n+  ASSERT_EQ (base_node->search (3), NULL);\n+  ASSERT_TRUE (base_node->every_ref);\n+\n+  /* Further inserts to collapsed ref list are ignored.  */\n+  t->insert (1, 5);\n+  ASSERT_EQ (t->search (1), base_node);\n+  ASSERT_EQ (base_node->refs, NULL);\n+  ASSERT_EQ (base_node->search (2), NULL);\n+  ASSERT_EQ (base_node->search (3), NULL);\n+  ASSERT_TRUE (base_node->every_ref);\n+\n+  /* Insert base to trigger base list collapse.  */\n+  t->insert (5, 6);\n+  ASSERT_TRUE (t->every_base);\n+  ASSERT_EQ (t->bases, NULL);\n+  ASSERT_EQ (t->search (1), NULL);\n+\n+  /* Further inserts to collapsed base list are ignored.  */\n+  t->insert (7, 8);\n+  ASSERT_TRUE (t->every_base);\n+  ASSERT_EQ (t->bases, NULL);\n+  ASSERT_EQ (t->search (1), NULL);\n+}\n+\n+static void\n+test_merge ()\n+{\n+  modref_tree<alias_set_type> *t1, *t2;\n+  modref_base_node<alias_set_type> *base_node;\n+\n+  t1 = new modref_tree<alias_set_type>(3, 4);\n+  t1->insert (1, 1);\n+  t1->insert (1, 2);\n+  t1->insert (1, 3);\n+  t1->insert (2, 1);\n+  t1->insert (3, 1);\n+\n+  t2 = new modref_tree<alias_set_type>(10, 10);\n+  t2->insert (1, 2);\n+  t2->insert (1, 3);\n+  t2->insert (1, 4);\n+  t2->insert (3, 2);\n+  t2->insert (3, 3);\n+  t2->insert (3, 4);\n+  t2->insert (3, 5);\n+\n+  t1->merge (t2);\n+\n+  ASSERT_FALSE (t1->every_base);\n+  ASSERT_NE (t1->bases, NULL);\n+  ASSERT_EQ (t1->bases->length (), 3);\n+\n+  base_node = t1->search (1);\n+  ASSERT_NE (base_node->refs, NULL);\n+  ASSERT_FALSE (base_node->every_ref);\n+  ASSERT_EQ (base_node->refs->length (), 4);\n+\n+  base_node = t1->search (2);\n+  ASSERT_NE (base_node->refs, NULL);\n+  ASSERT_FALSE (base_node->every_ref);\n+  ASSERT_EQ (base_node->refs->length (), 1);\n+\n+  base_node = t1->search (3);\n+  ASSERT_EQ (base_node->refs, NULL);\n+  ASSERT_TRUE (base_node->every_ref);\n+}\n+\n+\n+void\n+modref_tree_c_tests ()\n+{\n+  test_insert_search_collapse ();\n+  test_merge ();\n+}\n+\n+#endif\n+\n+void\n+gt_ggc_mx (modref_tree < int >*const &tt)\n+{\n+  if (tt->bases)\n+    {\n+      ggc_test_and_set_mark (tt->bases);\n+      gt_ggc_mx (tt->bases);\n+    }\n+}\n+\n+void\n+gt_ggc_mx (modref_tree < tree_node * >*const &tt)\n+{\n+  if (tt->bases)\n+    {\n+      ggc_test_and_set_mark (tt->bases);\n+      gt_ggc_mx (tt->bases);\n+    }\n+}\n+\n+void gt_pch_nx (modref_tree<int>* const&) {}\n+void gt_pch_nx (modref_tree<tree_node*>* const&) {}\n+void gt_pch_nx (modref_tree<int>* const&, gt_pointer_operator, void *) {}\n+void gt_pch_nx (modref_tree<tree_node*>* const&, gt_pointer_operator, void *) {}\n+\n+void gt_ggc_mx (modref_base_node<int>* &b)\n+{\n+  ggc_test_and_set_mark (b);\n+  if (b->refs)\n+    {\n+      ggc_test_and_set_mark (b->refs);\n+      gt_ggc_mx (b->refs);\n+    }\n+}\n+\n+void gt_ggc_mx (modref_base_node<tree_node*>* &b)\n+{\n+  ggc_test_and_set_mark (b);\n+  if (b->refs)\n+    {\n+      ggc_test_and_set_mark (b->refs);\n+      gt_ggc_mx (b->refs);\n+    }\n+  if (b->base)\n+    gt_ggc_mx (b->base);\n+}\n+\n+void gt_pch_nx (modref_base_node<int>*) {}\n+void gt_pch_nx (modref_base_node<tree_node*>*) {}\n+void gt_pch_nx (modref_base_node<int>*, gt_pointer_operator, void *) {}\n+void gt_pch_nx (modref_base_node<tree_node*>*, gt_pointer_operator, void *) {}\n+\n+void gt_ggc_mx (modref_ref_node<int>* &r)\n+{\n+  ggc_test_and_set_mark (r);\n+}\n+\n+void gt_ggc_mx (modref_ref_node<tree_node*>* &r)\n+{\n+  ggc_test_and_set_mark (r);\n+  if (r->ref)\n+    gt_ggc_mx (r->ref);\n+}\n+\n+void gt_pch_nx (modref_ref_node<int>* ) {}\n+void gt_pch_nx (modref_ref_node<tree_node*>*) {}\n+void gt_pch_nx (modref_ref_node<int>*, gt_pointer_operator, void *) {}\n+void gt_pch_nx (modref_ref_node<tree_node*>*, gt_pointer_operator, void *) {}\n+\n+"}, {"sha": "3bdd3058aa1d7d31a736306f42c09e43773951e8", "filename": "gcc/ipa-modref-tree.h", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -0,0 +1,253 @@\n+/* Data structure for the modref pass.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Cepelik and Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_MODREF_TREE_H\n+#define GCC_MODREF_TREE_H\n+\n+struct ipa_modref_summary;\n+\n+\n+template <typename T>\n+struct GTY((user)) modref_ref_node\n+{\n+  T ref;\n+\n+  modref_ref_node (T ref):\n+    ref (ref)\n+  {}\n+};\n+\n+/* Base of an access.  */\n+template <typename T>\n+struct GTY((user)) modref_base_node\n+{\n+  T base;\n+  vec <modref_ref_node <T> *, va_gc> *refs;\n+  bool every_ref;\n+\n+  modref_base_node (T base):\n+    base (base),\n+    refs (NULL),\n+    every_ref (false) {}\n+\n+  /* Search REF; return NULL if failed.  */\n+  modref_ref_node <T> *search (T ref)\n+  {\n+    size_t i;\n+    modref_ref_node <T> *n;\n+    FOR_EACH_VEC_SAFE_ELT (refs, i, n)\n+      if (n->ref == ref)\n+\treturn n;\n+    return NULL;\n+  }\n+\n+  /* Insert REF; collapse tree if there are more than MAX_REFS.  */\n+  modref_ref_node <T> *insert_ref (T ref, size_t max_refs)\n+  {\n+    modref_ref_node <T> *ref_node;\n+\n+    /* If the node is collapsed, don't do anything.  */\n+    if (every_ref)\n+      return NULL;\n+\n+    if (!ref)\n+      {\n+\tcollapse ();\n+\treturn NULL;\n+      }\n+\n+    /* Otherwise, insert a node for the ref of the access under the base.  */\n+    ref_node = search (ref);\n+    if (ref_node)\n+      return ref_node;\n+\n+    /* Collapse the node if too full already.  */\n+    if (refs && refs->length () >= max_refs)\n+      {\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"--param param=modref-max-refs limit reached\\n\");\n+\tcollapse ();\n+\treturn NULL;\n+      }\n+\n+    ref_node = new (ggc_alloc <modref_ref_node <T> > ())modref_ref_node <T>\n+\t\t\t\t\t\t\t\t (ref);\n+    vec_safe_push (refs, ref_node);\n+    return ref_node;\n+  }\n+\n+  void collapse ()\n+  {\n+    vec_free (refs);\n+    refs = NULL;\n+    every_ref = true;\n+  }\n+};\n+\n+/* Access tree for a single function.  */\n+template <typename T>\n+struct GTY((user)) modref_tree\n+{\n+  vec <modref_base_node <T> *, va_gc> *bases;\n+  size_t max_bases;\n+  size_t max_refs;\n+  bool every_base;\n+\n+  modref_tree (size_t max_bases, size_t max_refs):\n+    bases (NULL),\n+    max_bases (max_bases),\n+    max_refs (max_refs),\n+    every_base (false) {}\n+\n+  modref_base_node <T> *insert_base (T base)\n+  {\n+    modref_base_node <T> *base_node;\n+\n+    /* If the node is collapsed, don't do anything.  */\n+    if (every_base)\n+      return NULL;\n+\n+    /* Otherwise, insert a node for the base of the access into the tree.  */\n+    base_node = search (base);\n+    if (base_node)\n+      return base_node;\n+\n+    /* Collapse the node if too full already.  */\n+    if (bases && bases->length () >= max_bases)\n+      {\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"--param param=modref-max-bases limit reached\\n\");\n+\tcollapse ();\n+\treturn NULL;\n+      }\n+\n+    base_node = new (ggc_alloc <modref_base_node <T> > ())\n+\t\t\t modref_base_node <T> (base);\n+    vec_safe_push (bases, base_node);\n+    return base_node;\n+  }\n+\n+  /* Insert memory access to the tree.\t*/\n+  void insert (T base, T ref)\n+  {\n+    modref_base_node <T> *base_node;\n+\n+    base_node = insert_base (base);\n+\n+    if (!base && !ref)\n+      {\n+\tcollapse ();\n+\treturn;\n+      }\n+    if (!base_node)\n+      return;\n+    gcc_assert (search (base) != NULL);\n+\n+    base_node->insert_ref (ref, max_refs);\n+    if (!base && base_node->every_ref)\n+      {\n+\tcollapse ();\n+\treturn;\n+      }\n+  }\n+\n+  /* Merge OTHER into the tree.  */\n+  void merge (modref_tree <T> *other)\n+  {\n+    if (!other)\n+      return;\n+    if (other->every_base)\n+      {\n+\tcollapse ();\n+\treturn;\n+      }\n+\n+    size_t i, j;\n+    modref_base_node <T> *base_node, *my_base_node;\n+    modref_ref_node <T> *ref_node, *my_ref_node;\n+    FOR_EACH_VEC_SAFE_ELT (other->bases, i, base_node)\n+      {\n+\tmy_base_node = insert_base (base_node->base);\n+\tif (!my_base_node)\n+\t  continue;\n+\n+\tif (base_node->every_ref)\n+\t  {\n+\t    my_base_node->collapse ();\n+\t    continue;\n+\t  }\n+\n+\tFOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t  {\n+\t    my_ref_node = my_base_node->insert_ref (ref_node->ref, max_refs);\n+\t    if (!my_ref_node)\n+\t      continue;\n+\t  }\n+      }\n+  }\n+\n+  /* Search BASE in tree; return NULL if failed.  */\n+  modref_base_node <T> *search (T base)\n+  {\n+    size_t i;\n+    modref_base_node <T> *n;\n+    FOR_EACH_VEC_SAFE_ELT (bases, i, n)\n+      if (n->base == base)\n+\treturn n;\n+    return NULL;\n+  }\n+\n+  void collapse ()\n+  {\n+    vec_free (bases);\n+    bases = NULL;\n+    every_base = true;\n+  }\n+};\n+\n+void modref_c_tests ();\n+\n+void gt_ggc_mx (modref_tree <int>* const&);\n+void gt_ggc_mx (modref_tree <tree_node*>* const&);\n+void gt_pch_nx (modref_tree <int>* const&);\n+void gt_pch_nx (modref_tree <tree_node*>* const&);\n+void gt_pch_nx (modref_tree <int>* const&, gt_pointer_operator op, void *cookie);\n+void gt_pch_nx (modref_tree <tree_node*>* const&, gt_pointer_operator op,\n+\t\tvoid *cookie);\n+\n+void gt_ggc_mx (modref_base_node <int>*);\n+void gt_ggc_mx (modref_base_node <tree_node*>* &);\n+void gt_pch_nx (modref_base_node <int>* const&);\n+void gt_pch_nx (modref_base_node <tree_node*>* const&);\n+void gt_pch_nx (modref_base_node <int>* const&, gt_pointer_operator op,\n+\t\tvoid *cookie);\n+void gt_pch_nx (modref_base_node <tree_node*>* const&, gt_pointer_operator op,\n+\t\tvoid *cookie);\n+\n+void gt_ggc_mx (modref_ref_node <int>*);\n+void gt_ggc_mx (modref_ref_node <tree_node*>* &);\n+void gt_pch_nx (modref_ref_node <int>* const&);\n+void gt_pch_nx (modref_ref_node <tree_node*>* const&);\n+void gt_pch_nx (modref_ref_node <int>* const&, gt_pointer_operator op,\n+\t\tvoid *cookie);\n+void gt_pch_nx (modref_ref_node <tree_node*>* const&, gt_pointer_operator op,\n+\t\tvoid *cookie);\n+\n+#endif"}, {"sha": "f982ce94a758031f2fb6084bd4ae7d8489cb8bac", "filename": "gcc/ipa-modref.c", "status": "added", "additions": 1376, "deletions": 0, "changes": 1376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -0,0 +1,1376 @@\n+/* Search for references that a functions loads or stores.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Cepelik and Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Mod/ref pass records summary about loads and stores performed by the\n+   function.  This is later used by alias analysis to disambiguate memory\n+   accesses across function calls.  The summary has a form of decision tree and\n+   contains:\n+\n+    - base alias set\n+      and for each:\n+      - ref alias set\n+\n+   In future more information will be tracked.\n+\n+   This file contains a tree pass and an IPA pass.  Both performs the same\n+   analys however tree pass is executed during early and late optimization\n+   passes to propagate info downwards in the compilation order.  IPA pass\n+   propagates across the callgraph and is able to handle recursion and works on\n+   whole program during link-time analysis.\n+\n+   LTO mode differs from the local mode by not recroding alias sets but types\n+   that are translated to alias sets later.  This is necessary in order stream\n+   the information becaue the alias sets are rebuild at stream-in time and may\n+   not correspond to ones seen during analsis.  For this reason part of analysis\n+   is duplicated.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-pass.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-dfa.h\"\n+#include \"cgraph.h\"\n+#include \"ipa-utils.h\"\n+#include \"symbol-summary.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"gimple-walk.h\"\n+#include \"print-tree.h\"\n+#include \"tree-streamer.h\"\n+#include \"alias.h\"\n+#include \"calls.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n+\n+/* Class (from which there is one global instance) that holds modref summaries\n+   for all analyzed functions.  */\n+class GTY((user)) modref_summaries\n+  : public fast_function_summary <modref_summary *, va_gc>\n+{\n+public:\n+  modref_summaries (symbol_table *symtab)\n+      : fast_function_summary <modref_summary *, va_gc> (symtab) {}\n+  virtual void insert (cgraph_node *, modref_summary *state);\n+  virtual void duplicate (cgraph_node *src_node,\n+\t\t\t  cgraph_node *dst_node,\n+\t\t\t  modref_summary *src_data,\n+\t\t\t  modref_summary *dst_data);\n+  /* This flag controls whether newly inserted functions should be analyzed\n+     in IPA or normal mode.  Functions inserted betweehn IPA analysis and\n+     ipa-modref pass execution needs to be analyzed in IPA mode while all\n+     other insertions leads to normal analysis.  */\n+  bool ipa;\n+};\n+\n+/* Global variable holding all modref summaries.  */\n+static GTY(()) fast_function_summary <modref_summary *, va_gc> *summaries;\n+\n+/* Summary for a single function which this pass produces.  */\n+\n+modref_summary::modref_summary ()\n+  : loads (NULL), stores (NULL), loads_lto (NULL),\n+    stores_lto (NULL), finished (0)\n+{\n+}\n+\n+modref_summary::~modref_summary ()\n+{\n+  if (loads)\n+    ggc_delete (loads);\n+  if (stores)\n+    ggc_delete (stores);\n+  if (loads_lto)\n+    ggc_delete (loads_lto);\n+  if (stores_lto)\n+    ggc_delete (stores_lto);\n+}\n+\n+/* Dump records TT to OUT.  */\n+\n+static void\n+dump_records (modref_records *tt, FILE *out)\n+{\n+  fprintf (out, \"    Limits: %i bases, %i refs\\n\",\n+\t   (int)tt->max_bases, (int)tt->max_refs);\n+  if (tt->every_base)\n+    {\n+      fprintf (out, \"    Every base\\n\");\n+      return;\n+    }\n+  size_t i;\n+  modref_base_node <alias_set_type> *n;\n+  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, n)\n+    {\n+      fprintf (out, \"      Base %i: alias set %i\\n\", (int)i, n->base);\n+      if (n->every_ref)\n+\t{\n+\t  fprintf (out, \"      Every ref\\n\");\n+\t  continue;\n+\t}\n+      size_t j;\n+      modref_ref_node <alias_set_type> *r;\n+      FOR_EACH_VEC_SAFE_ELT (n->refs, j, r)\n+\t{\n+\t  fprintf (out, \"        Ref %i: alias set %i\\n\", (int)j, r->ref);\n+\t}\n+    }\n+}\n+\n+/* Dump records TT to OUT.  */\n+\n+static void\n+dump_lto_records (modref_records_lto *tt, FILE *out)\n+{\n+  fprintf (out, \"    Limits: %i bases, %i refs\\n\",\n+\t   (int)tt->max_bases, (int)tt->max_refs);\n+  if (tt->every_base)\n+    {\n+      fprintf (out, \"    Every base\\n\");\n+      return;\n+    }\n+  size_t i;\n+  modref_base_node <tree> *n;\n+  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, n)\n+    {\n+      fprintf (out, \"      Base %i:\", (int)i);\n+      print_generic_expr (dump_file, n->base);\n+      fprintf (out, \" (alias set %i)\\n\",\n+\t       get_alias_set (n->base));\n+      if (n->every_ref)\n+\t{\n+\t  fprintf (out, \"      Every ref\\n\");\n+\t  continue;\n+\t}\n+      size_t j;\n+      modref_ref_node <tree> *r;\n+      FOR_EACH_VEC_SAFE_ELT (n->refs, j, r)\n+\t{\n+\t  fprintf (out, \"        Ref %i:\", (int)j);\n+\t  print_generic_expr (dump_file, r->ref);\n+\t  fprintf (out, \" (alias set %i)\\n\",\n+\t\t   get_alias_set (r->ref));\n+\t}\n+    }\n+}\n+\n+/* Dump summary.  */\n+\n+void\n+modref_summary::dump (FILE *out)\n+{\n+  if (loads)\n+    {\n+      fprintf (out, \"  loads:\\n\");\n+      dump_records (loads, out);\n+    }\n+  if (stores)\n+    {\n+      fprintf (out, \"  stores:\\n\");\n+      dump_records (stores, out);\n+    }\n+  if (loads_lto)\n+    {\n+      fprintf (out, \"  LTO loads:\\n\");\n+      dump_lto_records (loads_lto, out);\n+    }\n+  if (stores_lto)\n+    {\n+      fprintf (out, \"  LTO stores:\\n\");\n+      dump_lto_records (stores_lto, out);\n+    }\n+}\n+\n+\n+/* Get function summary for FUNC if it exists, return NULL otherwise.  */\n+\n+modref_summary *\n+get_modref_function_summary (cgraph_node *func)\n+{\n+  /* Avoid creation of the summary too early (e.g. when front-end calls us).  */\n+  if (!summaries)\n+    return NULL;\n+\n+  /* A single function body may be represented by multiple symbols with\n+     different visibility.  For example, if FUNC is an interposable alias,\n+     we don't want to return anything, even if we have summary for the target\n+     function.  */\n+  enum availability avail;\n+  func = func->function_or_virtual_thunk_symbol\n+\t     (&avail, cgraph_node::get (current_function_decl));\n+  if (avail <= AVAIL_INTERPOSABLE)\n+    return NULL;\n+\n+  /* Attempt to get summary for FUNC.  If analysis of FUNC hasn't finished yet,\n+     don't return anything.  */\n+  modref_summary *r = summaries->get (func);\n+  if (r && r->finished)\n+    return r;\n+\n+  return NULL;\n+}\n+\n+/* Record access into the modref_records data structure.  */\n+\n+static void\n+record_access (modref_records *tt, ao_ref *ref)\n+{\n+  alias_set_type base_set = !flag_strict_aliasing ? 0\n+\t\t\t    : ao_ref_base_alias_set (ref);\n+  alias_set_type ref_set = !flag_strict_aliasing ? 0\n+\t\t\t    : (ao_ref_alias_set (ref));\n+  if (dump_file)\n+    {\n+       fprintf (dump_file, \"   - Recording base_set=%i ref_set=%i\\n\",\n+\t        base_set, ref_set);\n+    }\n+  tt->insert (base_set, ref_set);\n+}\n+\n+/* IPA version of record_access_tree.  */\n+\n+static void\n+record_access_lto (modref_records_lto *tt, ao_ref *ref)\n+{\n+  /* get_alias_set sometimes use different type to compute the alias set\n+     than TREE_TYPE (base).  Do same adjustments.  */\n+  tree base_type = NULL_TREE, ref_type = NULL_TREE;\n+  if (flag_strict_aliasing)\n+    {\n+      tree base;\n+\n+      base = ref->ref;\n+      while (handled_component_p (base))\n+\tbase = TREE_OPERAND (base, 0);\n+\n+      base_type = reference_alias_ptr_type_1 (&base);\n+\n+      if (!base_type)\n+\tbase_type = TREE_TYPE (base);\n+      else\n+\tbase_type = TYPE_REF_CAN_ALIAS_ALL (base_type)\n+\t\t    ? NULL_TREE : TREE_TYPE (base_type);\n+\n+      tree ref_expr = ref->ref;\n+      ref_type = reference_alias_ptr_type_1 (&ref_expr);\n+\n+      if (!ref_type)\n+\tref_type = TREE_TYPE (ref_expr);\n+      else\n+\tref_type = TYPE_REF_CAN_ALIAS_ALL (ref_type)\n+\t\t   ? NULL_TREE : TREE_TYPE (ref_type);\n+\n+      /* Sanity check that we are in sync with what get_alias_set does.  */\n+      gcc_checking_assert ((!base_type && !ao_ref_base_alias_set (ref))\n+\t\t\t   || get_alias_set (base_type)\n+\t\t\t      == ao_ref_base_alias_set (ref));\n+      gcc_checking_assert ((!ref_type && !ao_ref_alias_set (ref))\n+\t\t\t   || get_alias_set (ref_type)\n+\t\t\t      == ao_ref_alias_set (ref));\n+\n+      /* Do not bother to record types that have no meaningful alias set.\n+\t Also skip variably modified types since these go to local streams.  */\n+      if (base_type && (!get_alias_set (base_type)\n+\t\t\t|| variably_modified_type_p (base_type, NULL_TREE)))\n+\tbase_type = NULL_TREE;\n+      if (ref_type && (!get_alias_set (ref_type)\n+\t\t       || variably_modified_type_p (ref_type, NULL_TREE)))\n+\tref_type = NULL_TREE;\n+    }\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"   - Recording base type:\");\n+      print_generic_expr (dump_file, base_type);\n+      fprintf (dump_file, \" (alias set %i) ref type:\",\n+\t       base_type ? get_alias_set (base_type) : 0);\n+      print_generic_expr (dump_file, ref_type);\n+      fprintf (dump_file, \" (alias set %i)\\n\",\n+\t       ref_type ? get_alias_set (ref_type) : 0);\n+    }\n+\n+  tt->insert (base_type, ref_type);\n+}\n+\n+/* Returns true if and only if we should store the access to EXPR.\n+   Some accesses, e.g. loads from automatic variables, are not interesting.  */\n+\n+static bool\n+record_access_p (tree expr)\n+{\n+  /* Non-escaping memory is fine  */\n+  tree t = get_base_address (expr);\n+  if (t && (INDIRECT_REF_P (t)\n+\t    || TREE_CODE (t) == MEM_REF\n+\t    || TREE_CODE (t) == TARGET_MEM_REF)\n+\t&& TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n+\t&& !ptr_deref_may_alias_global_p (TREE_OPERAND (t, 0)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"   - Non-escaping memory, ignoring.\\n\");\n+      return false;\n+    }\n+\n+  /* Automatic variables are fine.  */\n+  if (DECL_P (t)\n+      && auto_var_in_fn_p (t, current_function_decl))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"   - Automatic variable, ignoring.\\n\");\n+      return false;\n+    }\n+\n+  /* Read-only variables are fine.  */\n+  if (DECL_P (t) && TREE_READONLY (t))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"   - Read-only variable, ignoring.\\n\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if ECF flags says that stores can be ignored.  */\n+\n+static bool\n+ignore_stores_p (tree caller, int flags)\n+{\n+  if (flags & ECF_PURE)\n+    return true;\n+  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n+      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n+    return true;\n+  return false;\n+}\n+\n+/* Analyze function call STMT in function F.  */\n+\n+static bool\n+analyze_call (modref_summary *cur_summary,\n+\t      gimple *stmt)\n+{\n+  /* Check flags on the function call.  In certain cases, analysis can be\n+     simplified.  */\n+  int flags = gimple_call_flags (stmt);\n+  if (flags & (ECF_CONST | ECF_NOVOPS))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \" - ECF_CONST | ECF_NOVOPS, ignoring all stores and all loads \"\n+\t\t \"except for args.\\n\");\n+      return true;\n+    }\n+\n+  /* Pure functions do not affect global memory.  Stores by functions which are\n+     noreturn and do not throw can safely be ignored.  */\n+  bool ignore_stores = ignore_stores_p (current_function_decl, flags);\n+\n+  /* Next, we try to get the callee's function declaration.  The goal is to\n+     merge their summary with ours.  */\n+  tree callee = gimple_call_fndecl (stmt);\n+\n+  /* Check if this is an indirect call.  */\n+  if (!callee)\n+    {\n+      /* If the indirect call does not write memory, our store summary is\n+\t unaffected, but we have to discard our loads summary (we don't know\n+\t anything about the loads that the called function performs).  */\n+      if (ignore_stores)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" - Indirect call which does not write memory, \"\n+\t\t    \"discarding loads.\\n\");\n+\t  if (cur_summary->loads)\n+\t    cur_summary->loads->collapse ();\n+\t  if (cur_summary->loads_lto)\n+\t    cur_summary->loads_lto->collapse ();\n+\t  return true;\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \" - Indirect call.\\n\");\n+      return false;\n+    }\n+\n+  struct cgraph_node *callee_node = cgraph_node::get_create (callee);\n+\n+  /* We can not safely optimize based on summary of calle if it does\n+     not always bind to current def: it is possible that memory load\n+     was optimized out earlier which may not happen in the interposed\n+     variant.  */\n+  if (!callee_node->binds_to_current_def_p ())\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" - May be interposed: collapsing loads.\\n\");\n+      if (cur_summary->loads)\n+\tcur_summary->loads->collapse ();\n+      if (cur_summary->loads_lto)\n+\tcur_summary->loads_lto->collapse ();\n+    }\n+\n+  /* If this is a recursive call, the target summary is the same as ours, so\n+     there's nothing to do.  */\n+  if (recursive_call_p (current_function_decl, callee))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" - Skipping recursive call.\\n\");\n+      return true;\n+    }\n+\n+  gcc_assert (callee_node != NULL);\n+\n+  /* Get the function symbol and its availability.  */\n+  enum availability avail;\n+  callee_node = callee_node->function_symbol (&avail);\n+  if (avail <= AVAIL_INTERPOSABLE)\n+    {\n+      /* Keep stores summary, but discard all loads for interposable function\n+\t symbols.  */\n+      if (ignore_stores)\n+\t{\n+\t  if (cur_summary->loads)\n+\t    cur_summary->loads->collapse ();\n+\t  if (cur_summary->loads_lto)\n+\t    cur_summary->loads_lto->collapse ();\n+\t  return true;\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \" - Function availability <= AVAIL_INTERPOSABLE.\\n\");\n+      return false;\n+    }\n+\n+  /* Get callee's modref summary.  As above, if there's no summary, we either\n+     have to give up or, if stores are ignored, we can just purge loads.  */\n+  modref_summary *callee_summary = summaries->get (callee_node);\n+  if (!callee_summary)\n+    {\n+      if (ignore_stores)\n+\t{\n+\t  if (cur_summary->loads)\n+\t    cur_summary->loads->collapse ();\n+\t  if (cur_summary->loads_lto)\n+\t    cur_summary->loads_lto->collapse ();\n+\t  return true;\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \" - No modref summary available for callee.\\n\");\n+      return false;\n+    }\n+\n+  /* Merge with callee's summary.  */\n+  if (cur_summary->loads)\n+    cur_summary->loads->merge (callee_summary->loads);\n+  if (cur_summary->loads_lto)\n+    cur_summary->loads_lto->merge (callee_summary->loads_lto);\n+  if (!ignore_stores)\n+    {\n+      if (cur_summary->stores)\n+\tcur_summary->stores->merge (callee_summary->stores);\n+      if (cur_summary->stores_lto)\n+\tcur_summary->stores_lto->merge (callee_summary->stores_lto);\n+    }\n+\n+  return true;\n+}\n+\n+/* Helper for analyze_stmt.  */\n+\n+static bool\n+analyze_load (gimple *, tree, tree op, void *data)\n+{\n+  modref_summary *summary = (modref_summary *)data;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \" - Analyzing load: \");\n+      print_generic_expr (dump_file, op);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (!record_access_p (op))\n+    return false;\n+\n+  ao_ref r;\n+  ao_ref_init (&r, op);\n+\n+  if (summary->loads)\n+    record_access (summary->loads, &r);\n+  if (summary->loads_lto)\n+    record_access_lto (summary->loads_lto, &r);\n+  return false;\n+}\n+\n+/* Helper for analyze_stmt.  */\n+\n+static bool\n+analyze_store (gimple *, tree, tree op, void *data)\n+{\n+  modref_summary *summary = (modref_summary *)data;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \" - Analyzing store: \");\n+      print_generic_expr (dump_file, op);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (!record_access_p (op))\n+    return false;\n+\n+  ao_ref r;\n+  ao_ref_init (&r, op);\n+\n+  if (summary->stores)\n+    record_access (((modref_summary *)data)->stores, &r);\n+  if (summary->stores_lto)\n+    record_access_lto (((modref_summary *)data)->stores_lto, &r);\n+  return false;\n+}\n+\n+/* Analyze statement STMT of function F.\n+   If IPA is true do not merge in side effects of calls.  */\n+\n+static bool\n+analyze_stmt (modref_summary *summary, gimple *stmt, bool ipa)\n+{\n+  /* Analyze all loads and stores in STMT.  */\n+  walk_stmt_load_store_ops (stmt, summary,\n+\t\t\t    analyze_load, analyze_store);\n+  /* or call analyze_load_ipa, analyze_store_ipa */\n+\n+  switch (gimple_code (stmt))\n+   {\n+   case GIMPLE_ASM:\n+     /* If the ASM statement does not read nor write memory, there's nothing\n+\tto do.  Otherwise just give up.  */\n+     if (!gimple_asm_clobbers_memory_p (as_a <gasm *> (stmt)))\n+       return true;\n+     if (dump_file)\n+       fprintf (dump_file, \" - Function contains GIMPLE_ASM statement \"\n+\t       \"which clobbers memory.\\n\");\n+     return false;\n+   case GIMPLE_CALL:\n+     if (!ipa)\n+       return analyze_call (summary, stmt);\n+     return true;\n+   default:\n+     /* Nothing to do for other types of statements.  */\n+     return true;\n+   }\n+}\n+\n+/* Analyze function F.  IPA indicates whether we're running in tree mode (false)\n+   or the IPA mode (true).  */\n+\n+static void\n+analyze_function (function *f, bool ipa)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"modref analyzing '%s' (ipa=%i)...\\n\",\n+\t     function_name (f), ipa);\n+\n+  /* Don't analyze this function if it's compiled with -fno-strict-aliasing.  */\n+  if (!flag_ipa_modref)\n+    return;\n+\n+  /* Initialize the summary.  */\n+  if (!summaries)\n+    summaries = new (ggc_alloc <modref_summaries> ())\n+\t\t     modref_summaries (symtab);\n+  else /* Remove existing summary if we are re-running the pass.  */\n+    summaries->remove (cgraph_node::get (f->decl));\n+\n+  ((modref_summaries *)summaries)->ipa = ipa;\n+\n+  modref_summary *summary = summaries->get_create (cgraph_node::get (f->decl));\n+\n+  /* Compute no-LTO summaries when local optimization is going to happen.  */\n+  bool nolto = (!ipa || ((!flag_lto || flag_fat_lto_objects) && !in_lto_p)\n+\t\t|| (in_lto_p && !flag_wpa\n+\t\t    && flag_incremental_link != INCREMENTAL_LINK_LTO));\n+\n+  /* Compute LTO when LTO streaming is going to happen.  */\n+  bool lto = ipa && ((flag_lto && !in_lto_p)\n+\t\t     || flag_wpa\n+\t\t     || flag_incremental_link == INCREMENTAL_LINK_LTO);\n+\n+  /* Create and initialize summary for F.\n+     Note that summaries may be already allocated from previous\n+     run of the pass.  */\n+  if (nolto)\n+    {\n+      gcc_assert (!summary->loads);\n+      summary->loads\n+\t = new (ggc_alloc <modref_tree<alias_set_type> > ())\n+\t\tmodref_records (param_modref_max_bases,\n+\t\t\t\tparam_modref_max_refs);\n+      gcc_assert (!summary->stores);\n+      summary->stores\n+\t = new (ggc_alloc <modref_tree<alias_set_type> > ())\n+\t\tmodref_records (param_modref_max_bases,\n+\t\t\t\tparam_modref_max_refs);\n+    }\n+  if (lto)\n+    {\n+      gcc_assert (!summary->loads_lto);\n+      summary->loads_lto\n+\t = new (ggc_alloc <modref_tree<tree> > ())\n+\t\tmodref_records_lto (param_modref_max_bases,\n+\t\t\t\t    param_modref_max_refs);\n+      gcc_assert (!summary->stores_lto);\n+      summary->stores_lto\n+\t = new (ggc_alloc <modref_tree<tree> > ())\n+\t\tmodref_records_lto (param_modref_max_bases,\n+\t\t\t\t    param_modref_max_refs);\n+    }\n+  summary->finished = false;\n+\n+  /* Analyze each statement in each basic block of the function.  If the\n+     statement cannot be analyzed (for any reason), the entire function cannot\n+     be analyzed by modref.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, f)\n+    {\n+      gimple_stmt_iterator si;\n+      for (si = gsi_after_labels (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  if (!analyze_stmt (summary, gsi_stmt (si), ipa))\n+\t    {\n+\t      cgraph_node *fnode = cgraph_node::get (current_function_decl);\n+\t      summaries->remove (fnode);\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \" - modref done with result: not tracked.\\n\");\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  if (!ipa)\n+    summary->finished = true;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \" - modref done with result: tracked.\\n\");\n+      summary->dump (dump_file);\n+    }\n+}\n+\n+/* Callback for generate_summary.  */\n+\n+static void\n+modref_generate (void)\n+{\n+  struct cgraph_node *node;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      function *f = DECL_STRUCT_FUNCTION (node->decl);\n+      if (!f)\n+\tcontinue;\n+      push_cfun (f);\n+      analyze_function (f, true);\n+      pop_cfun ();\n+    }\n+}\n+\n+/* Called when a new function is inserted to callgraph late.  */\n+\n+void\n+modref_summaries::insert (struct cgraph_node *node, modref_summary *)\n+{\n+  if (!DECL_STRUCT_FUNCTION (node->decl))\n+    return;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  analyze_function (DECL_STRUCT_FUNCTION (node->decl), ipa);\n+  pop_cfun ();\n+}\n+\n+/* Called when new clone is inserted to callgraph late.  */\n+\n+void\n+modref_summaries::duplicate (cgraph_node *, cgraph_node *,\n+\t\t\t     modref_summary *src_data,\n+\t\t\t     modref_summary *dst_data)\n+{\n+  dst_data->finished = src_data->finished;\n+  if (src_data->stores)\n+    {\n+      dst_data->stores = new (ggc_alloc <modref_tree<alias_set_type> > ())\n+\t\t\t      modref_records\n+\t\t\t\t (src_data->stores->max_bases,\n+\t\t\t\t  src_data->stores->max_refs);\n+      dst_data->stores->merge (src_data->stores);\n+    }\n+  if (src_data->loads)\n+    {\n+      dst_data->loads = new (ggc_alloc <modref_tree<alias_set_type> > ())\n+\t\t\t     modref_records\n+\t\t\t\t(src_data->loads->max_bases,\n+\t\t\t\t src_data->loads->max_refs);\n+      dst_data->loads->merge (src_data->loads);\n+    }\n+  if (src_data->stores_lto)\n+    {\n+      dst_data->stores_lto = new (ggc_alloc <modref_tree<tree> > ())\n+\t\t\t\t  modref_records_lto\n+\t\t\t\t    (src_data->stores_lto->max_bases,\n+\t\t\t\t     src_data->stores_lto->max_refs);\n+      dst_data->stores_lto->merge (src_data->stores_lto);\n+    }\n+  if (src_data->loads_lto)\n+    {\n+      dst_data->loads_lto = new (ggc_alloc <modref_tree<tree> > ())\n+\t\t\t\t  modref_records_lto\n+\t\t\t\t    (src_data->stores_lto->max_bases,\n+\t\t\t\t     src_data->stores_lto->max_refs);\n+      dst_data->loads_lto->merge (src_data->loads_lto);\n+    }\n+}\n+\n+namespace\n+{\n+/* Definition of the modref pass on GIMPLE.  */\n+const pass_data pass_data_modref = {\n+  GIMPLE_PASS,\n+  \"modref\",\n+  OPTGROUP_IPA,\n+  TV_TREE_MODREF,\n+  (PROP_cfg | PROP_ssa),\n+  0,\n+  0,\n+  0,\n+  0,\n+};\n+\n+class pass_modref : public gimple_opt_pass\n+{\n+  public:\n+    pass_modref (gcc::context *ctxt)\n+\t: gimple_opt_pass (pass_data_modref, ctxt) {}\n+\n+    ~pass_modref ()\n+      {\n+\tggc_delete (summaries);\n+\tsummaries = NULL;\n+      }\n+\n+    /* opt_pass methods: */\n+    opt_pass *clone ()\n+    {\n+      return new pass_modref (m_ctxt);\n+    }\n+    virtual bool gate (function *)\n+    {\n+      return flag_ipa_modref;\n+    }\n+    virtual unsigned int execute (function *);\n+};\n+\n+/* Encode TT to the output block OB using the summary streaming API.  */\n+\n+static void\n+write_modref_records (modref_records_lto *tt, struct output_block *ob)\n+{\n+  streamer_write_uhwi (ob, tt->max_bases);\n+  streamer_write_uhwi (ob, tt->max_refs);\n+\n+  streamer_write_uhwi (ob, tt->every_base);\n+  streamer_write_uhwi (ob, vec_safe_length (tt->bases));\n+  size_t i;\n+  modref_base_node <tree> *base_node;\n+  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, base_node)\n+    {\n+      stream_write_tree (ob, base_node->base, true);\n+\n+      streamer_write_uhwi (ob, base_node->every_ref);\n+      streamer_write_uhwi (ob, vec_safe_length (base_node->refs));\n+      size_t j;\n+      modref_ref_node <tree> *ref_node;\n+      FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t{\n+\t  stream_write_tree (ob, ref_node->ref, true);\n+\t}\n+    }\n+}\n+\n+/* Read a modref_tree from the input block IB using the data from DATA_IN.\n+   This assumes that the tree was encoded using write_modref_tree.\n+   Either nolto_ret or lto_ret is initialized by the tree depending whether\n+   LTO streaming is expcted or not.  */\n+\n+void\n+read_modref_records (lto_input_block *ib, struct data_in *data_in,\n+\t\t     modref_records **nolto_ret,\n+\t\t     modref_records_lto **lto_ret)\n+{\n+  size_t max_bases = streamer_read_uhwi (ib);\n+  size_t max_refs = streamer_read_uhwi (ib);\n+\n+  /* Decide whether we want to turn LTO data types to non-LTO (i.e. when\n+     LTO re-streaming is not going to happen).  */\n+  if (flag_wpa || flag_incremental_link == INCREMENTAL_LINK_LTO)\n+    *lto_ret = new (ggc_alloc <modref_records_lto> ()) modref_records_lto\n+\t\t\t      (max_bases, max_refs);\n+  else\n+    *nolto_ret = new (ggc_alloc <modref_records> ()) modref_records\n+\t\t\t      (max_bases, max_refs);\n+\n+  size_t every_base = streamer_read_uhwi (ib);\n+  size_t nbase = streamer_read_uhwi (ib);\n+\n+  gcc_assert (!every_base || nbase == 0);\n+  if (every_base)\n+    {\n+      if (*nolto_ret)\n+\t(*nolto_ret)->collapse ();\n+      if (*lto_ret)\n+\t(*lto_ret)->collapse ();\n+    }\n+  for (size_t i = 0; i < nbase; i++)\n+    {\n+      tree base_tree = stream_read_tree (ib, data_in);\n+      modref_base_node <alias_set_type> *nolto_base_node = NULL;\n+      modref_base_node <tree> *lto_base_node = NULL;\n+\n+      /* At stream in time we have LTO alias info.  Check if we streamed in\n+\t something obviously unnecessary.  Do not glob types by alias sets;\n+\t it is not 100% clear that ltrans types will get merged same way.\n+\t Types may get refined based on ODR type conflicts.  */\n+      if (base_tree && !get_alias_set (base_tree))\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Streamed in alias set 0 type \");\n+\t      print_generic_expr (dump_file, base_tree);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  base_tree = NULL;\n+\t}\n+\n+      if (*nolto_ret)\n+\tnolto_base_node = (*nolto_ret)->insert_base (base_tree\n+\t\t\t\t\t\t     ? get_alias_set (base_tree)\n+\t\t\t\t\t\t     : 0);\n+      if (*lto_ret)\n+\tlto_base_node = (*lto_ret)->insert_base (base_tree);\n+      size_t every_ref = streamer_read_uhwi (ib);\n+      size_t nref = streamer_read_uhwi (ib);\n+\n+      gcc_assert (!every_ref || nref == 0);\n+      if (every_ref)\n+\t{\n+\t  if (nolto_base_node)\n+\t    nolto_base_node->collapse ();\n+\t  if (lto_base_node)\n+\t    lto_base_node->collapse ();\n+\t}\n+      for (size_t j = 0; j < nref; j++)\n+\t{\n+\t  tree ref_tree = stream_read_tree (ib, data_in);\n+\n+\t  if (ref_tree && !get_alias_set (ref_tree))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Streamed in alias set 0 type \");\n+\t\t  print_generic_expr (dump_file, ref_tree);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      base_tree = NULL;\n+\t    }\n+\n+\t  if (nolto_base_node)\n+\t    nolto_base_node->insert_ref (ref_tree ? get_alias_set (ref_tree)\n+\t\t\t\t\t : 0, max_refs);\n+\t  if (lto_base_node)\n+\t    lto_base_node->insert_ref (ref_tree, max_refs);\n+\t}\n+    }\n+}\n+\n+/* Callback for write_summary.  */\n+\n+static void\n+modref_write ()\n+{\n+  struct output_block *ob = create_output_block (LTO_section_ipa_modref);\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n+  unsigned int count = 0;\n+  int i;\n+\n+  if (!summaries)\n+    {\n+      streamer_write_uhwi (ob, 0);\n+      streamer_write_char_stream (ob->main_stream, 0);\n+      produce_asm (ob, NULL);\n+      destroy_output_block (ob);\n+      return;\n+    }\n+\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n+    {\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n+\n+      if (cnode && cnode->definition && !cnode->alias\n+\t  && summaries->get (cnode))\n+\tcount++;\n+    }\n+  streamer_write_uhwi (ob, count);\n+\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n+    {\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n+\n+      if (cnode && cnode->definition && !cnode->alias)\n+\t{\n+\n+\t  modref_summary *r = summaries->get (cnode);\n+\n+\t  if (!r)\n+\t    continue;\n+\n+\t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, cnode));\n+\n+\t  streamer_write_uhwi (ob, r->loads_lto ? 1 : 0);\n+\t  streamer_write_uhwi (ob, r->stores_lto ? 1 : 0);\n+\t  if (r->loads_lto)\n+\t    write_modref_records (r->loads_lto, ob);\n+\t  if (r->stores_lto)\n+\t    write_modref_records (r->stores_lto, ob);\n+\t}\n+    }\n+  streamer_write_char_stream (ob->main_stream, 0);\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n+}\n+\n+static void\n+read_section (struct lto_file_decl_data *file_data, const char *data,\n+\t      size_t len)\n+{\n+  const struct lto_function_header *header\n+    = (const struct lto_function_header *) data;\n+  const int cfg_offset = sizeof (struct lto_function_header);\n+  const int main_offset = cfg_offset + header->cfg_size;\n+  const int string_offset = main_offset + header->main_size;\n+  struct data_in *data_in;\n+  unsigned int i;\n+  unsigned int f_count;\n+\n+  lto_input_block ib ((const char *) data + main_offset, header->main_size,\n+\t\t      file_data->mode_table);\n+\n+  data_in\n+    = lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\t  header->string_size, vNULL);\n+  f_count = streamer_read_uhwi (&ib);\n+  for (i = 0; i < f_count; i++)\n+    {\n+      struct cgraph_node *node;\n+      lto_symtab_encoder_t encoder;\n+\n+      unsigned int index = streamer_read_uhwi (&ib);\n+      encoder = file_data->symtab_node_encoder;\n+      node = dyn_cast <cgraph_node *> (lto_symtab_encoder_deref (encoder,\n+\t\t\t\t\t\t\t\tindex));\n+\n+      modref_summary *modref_sum = summaries->get_create (node);\n+      modref_sum->finished = false;\n+      int have_loads = streamer_read_uhwi (&ib);\n+      int have_stores = streamer_read_uhwi (&ib);\n+      gcc_assert (!modref_sum->loads_lto\n+\t\t  && !modref_sum->stores_lto\n+\t\t  && !modref_sum->loads\n+\t\t  && !modref_sum->stores);\n+      if (have_loads)\n+\t read_modref_records (&ib, data_in,\n+\t\t\t      &modref_sum->loads,\n+\t\t\t      &modref_sum->loads_lto);\n+      if (have_stores)\n+\t read_modref_records (&ib, data_in,\n+\t\t\t      &modref_sum->stores,\n+\t\t\t      &modref_sum->stores_lto);\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Read modref for %s\\n\",\n+\t\t   node->dump_name ());\n+\t  modref_sum->dump (dump_file);\n+\t}\n+      if (flag_ltrans)\n+\tmodref_sum->finished = true;\n+    }\n+\n+  lto_free_section_data (file_data, LTO_section_ipa_modref, NULL, data,\n+\t\t\t len);\n+  lto_data_in_delete (data_in);\n+}\n+\n+/* Callback for read_summary.  */\n+\n+static void\n+modref_read (void)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  if (!summaries)\n+    summaries = new (ggc_alloc <modref_summaries> ())\n+\t\t     modref_summaries (symtab);\n+  ((modref_summaries *)summaries)->ipa = true;\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      size_t len;\n+      const char *data = lto_get_summary_section_data (file_data,\n+\t\t\t\t\t\t       LTO_section_ipa_modref,\n+\t\t\t\t\t\t       &len);\n+      if (data)\n+\tread_section (file_data, data, len);\n+      else\n+\t/* Fatal error here.  We do not want to support compiling ltrans units\n+\t   with different version of compiler or different flags than the WPA\n+\t   unit, so this should never happen.  */\n+\tfatal_error (input_location,\n+\t\t     \"IPA modref summary is missing in input file\");\n+    }\n+}\n+\n+/* Definition of the modref IPA pass.  */\n+const pass_data pass_data_ipa_modref =\n+{\n+  IPA_PASS,           /* type */\n+  \"modref\",       /* name */\n+  OPTGROUP_IPA,       /* optinfo_flags */\n+  TV_IPA_MODREF, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_dump_symtab ), /* todo_flags_finish */\n+};\n+\n+class pass_ipa_modref : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_modref (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_modref, ctxt,\n+\t\t      modref_generate, /* generate_summary */\n+\t\t      modref_write,    /* write_summary */\n+\t\t      modref_read,     /* read_summary */\n+\t\t      modref_write,    /* write_optimization_summary */\n+\t\t      modref_read,     /* read_optimization_summary */\n+\t\t      NULL,            /* stmt_fixup */\n+\t\t      0,               /* function_transform_todo_flags_start */\n+\t\t      NULL,            /* function_transform */\n+\t\t      NULL)            /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass *clone () { return new pass_ipa_modref (m_ctxt); }\n+  virtual bool gate (function *)\n+  {\n+    return true;\n+  }\n+  virtual unsigned int execute (function *);\n+\n+};\n+\n+}\n+\n+unsigned int pass_modref::execute (function *f)\n+{\n+  /* If new function is being added during IPA, we can skip analysis.  */\n+  if (summaries && ((modref_summaries *)summaries)->ipa)\n+    return 0;\n+  analyze_function (f, false);\n+  return 0;\n+}\n+\n+gimple_opt_pass *\n+make_pass_modref (gcc::context *ctxt)\n+{\n+  return new pass_modref (ctxt);\n+}\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_modref (gcc::context *ctxt)\n+{\n+  return new pass_ipa_modref (ctxt);\n+}\n+\n+/* Skip edges from and to nodes without ipa_pure_const enabled.\n+   Ignore not available symbols.  */\n+\n+static bool\n+ignore_edge (struct cgraph_edge *e)\n+{\n+  enum availability avail;\n+  cgraph_node *callee = e->callee->function_or_virtual_thunk_symbol\n+\t\t\t  (&avail, e->caller);\n+\n+  return (avail <= AVAIL_INTERPOSABLE\n+\t  || !summaries->get (callee)\n+\t  || flags_from_decl_or_type (e->callee->decl)\n+\t     & (ECF_CONST | ECF_NOVOPS));\n+}\n+\n+/* Run the IPA pass.  This will take a function's summaries and calls and\n+   construct new summaries which represent a transitive closure.  So that\n+   summary of an analyzed function contains information about the loads and\n+   stores that the function or any function that it calls does.  */\n+\n+unsigned int pass_ipa_modref::execute (function *)\n+{\n+  if (!summaries)\n+    return 0;\n+\n+  struct cgraph_node **order = XCNEWVEC (struct cgraph_node *,\n+\t\t\t\t\t symtab->cgraph_count);\n+  int order_pos;\n+  order_pos = ipa_reduced_postorder (order, true, ignore_edge);\n+  int i;\n+\n+  /* Iterate over all strongly connected components in post-order.  */\n+  for (i = 0; i < order_pos; i++)\n+    {\n+      bool its_hopeless = false;\n+      modref_records *loads = NULL;\n+      modref_records *stores = NULL;\n+      modref_records_lto *loads_lto = NULL;\n+      modref_records_lto *stores_lto = NULL;\n+\n+      /* Get the component's representative.  That's just any node in the\n+\t component from which we can traverse the entire component.  */\n+      struct cgraph_node *component_node = order[i];\n+      cgraph_node *first = NULL;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Start of SCC component\\n\");\n+\n+      /* Walk the component.  CUR is the current node of the component that's\n+\t being processed.  */\n+      for (struct cgraph_node *cur = component_node; cur && !its_hopeless;\n+\t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n+\t{\n+\t  /* Merge in summaries from CUR.  */\n+\t  modref_summary *cur_summary = summaries->get (cur);\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Processing %s\\n\",\n+\t\t     cur->dump_name ());\n+\n+\t  /* We don't know anything about CUR, hence we cannot tell anything\n+\t     about the entire component.  */\n+\t  if (!cur_summary)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    No summary\\n\");\n+\t      its_hopeless = true;\n+\t      break;\n+\t    }\n+\n+\t  /* Summaries are all going to be same, pick first ones and merge\n+\t     everything in.  */\n+\t  if (!first)\n+\t    {\n+\t      first = cur;\n+\t      loads = cur_summary->loads;\n+\t      stores = cur_summary->stores;\n+\t      loads_lto = cur_summary->loads_lto;\n+\t      stores_lto = cur_summary->stores_lto;\n+\t    }\n+\t  for (cgraph_edge *e = cur->indirect_calls; e; e = e->next_callee)\n+\t    {\n+\t      if (e->indirect_info->ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+\t\tcontinue;\n+\t      if (ignore_stores_p (cur->decl, e->indirect_info->ecf_flags))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"    Indirect call: \"\n+\t\t\t     \"collapsing loads\\n\");\n+\t\t  if (loads)\n+\t\t    loads->collapse ();\n+\t\t  if (loads_lto)\n+\t\t    loads_lto->collapse ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"    Indirect call: giving up\\n\");\n+\t\t  its_hopeless = true;\n+\t\t}\n+\t    }\n+\n+\t  /* Walk every function that CUR calls and merge its summary.  */\n+\t  for (cgraph_edge *callee_edge = cur->callees; callee_edge;\n+\t       callee_edge = callee_edge->next_callee)\n+\t    {\n+\t      int flags = flags_from_decl_or_type (callee_edge->callee->decl);\n+\t      modref_summary *callee_summary;\n+\t      struct cgraph_node *callee;\n+\n+\t      if (flags & (ECF_CONST | ECF_NOVOPS))\n+\t\tcontinue;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    Call to %s\\n\",\n+\t\t\t cur->dump_name ());\n+\n+\t      /* We can not safely optimize based on summary of calle if it\n+\t\t does not always bind to current def: it is possible that\n+\t\t memory load was optimized out earlier which may not happen in\n+\t\t the interposed variant.  */\n+\t      if (!callee_edge->binds_to_current_def_p ())\n+\t\t{\n+\t\t  if (loads)\n+\t\t    loads->collapse ();\n+\t\t  if (loads_lto)\n+\t\t    loads_lto->collapse ();\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"      May not bind local;\"\n+\t\t\t     \" collapsing loads\\n\");\n+\t\t}\n+\n+\t      /* Get the callee and its summary.  */\n+\t      enum availability avail;\n+\t      callee = callee_edge->callee->function_or_virtual_thunk_symbol\n+\t\t\t (&avail, cur);\n+\n+\t      /* See if we can derive something from ECF flags.  Be careful on\n+\t\t not skipping calls within the SCC component:  we must merge\n+\t\t all their summaries.\n+\t\t If we switch to iterative dataflow that may be necessary\n+\t\t for future improvements this may go away.  */\n+\t      if (callee->aux\n+\t\t  && ((struct ipa_dfs_info *)cur->aux)->scc_no\n+\t\t     == ((struct ipa_dfs_info *)callee->aux)->scc_no)\n+\t\tflags = 0;\n+\n+\t      bool ignore_stores = ignore_stores_p (cur->decl, flags);\n+\n+\t      /* We don't know anything about CALLEE, hence we cannot tell\n+\t\t anything about the entire component.  */\n+\n+\t      if (avail <= AVAIL_INTERPOSABLE\n+\t\t  || !(callee_summary = summaries->get (callee)))\n+\t\t{\n+\t\t  if (!ignore_stores)\n+\t\t    {\n+\t\t      its_hopeless = true;\n+\t\t      if (dump_file && avail <= AVAIL_INTERPOSABLE)\n+\t\t\tfprintf (dump_file, \"      Call target interposable\"\n+\t\t\t\t \"or not available\\n\");\n+\t\t      else if (dump_file)\n+\t\t\tfprintf (dump_file, \"      No call target summary\\n\");\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (loads)\n+\t\t\tloads->collapse ();\n+\t\t      if (loads_lto)\n+\t\t\tloads_lto->collapse ();\n+\t\t      if (dump_file && avail <= AVAIL_INTERPOSABLE)\n+\t\t\tfprintf (dump_file, \"      Call target interposable\"\n+\t\t\t\t \"or not available; collapsing loads\\n\");\n+\t\t      else if (dump_file)\n+\t\t\tfprintf (dump_file, \"      No call target summary;\"\n+\t\t\t\t \" collapsing loads\\n\");\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Merge in callee's information.  */\n+\t      if (callee_summary->loads\n+\t\t  && callee_summary->loads != loads)\n+\t\tloads->merge (callee_summary->loads);\n+\t      if (callee_summary->stores\n+\t\t  && callee_summary->stores != stores)\n+\t\tstores->merge (callee_summary->stores);\n+\t      if (callee_summary->loads_lto\n+\t\t  && callee_summary->loads_lto != loads_lto)\n+\t\tloads_lto->merge (callee_summary->loads_lto);\n+\t      if (callee_summary->stores_lto\n+\t\t  && callee_summary->stores_lto != stores_lto)\n+\t\tstores_lto->merge (callee_summary->stores_lto);\n+\t    }\n+\t}\n+\n+\t/* At this time, ipa_loads and ipa_stores contain information\n+\t   about all loads and stores done by any of the component's nodes and\n+\t   all functions that any of the nodes calls.  We will now propagate\n+\t   this information to all nodes in the component.  Therefore, we will\n+\t   walk the component one more time to do it.  */\n+\tfor (struct cgraph_node *cur = component_node; cur;\n+\t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n+\t{\n+\t  modref_summary *cur_summary = summaries->get (cur);\n+\t  if (!cur_summary)\n+\t    {\n+\t      /* The function doesn't have a summary.  We must have noticed\n+\t\t that during the first pass and the hopeless flag must\n+\t\t therefore be set.  Skip the function.  */\n+\t      gcc_assert (its_hopeless);\n+\t    }\n+\t  else if (its_hopeless)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Cleared modref info for %s\\n\",\n+\t\t\t cur->dump_name ());\n+\t      summaries->remove (cur);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (cur == first)\n+\t\t;\n+\t      else\n+\t\t{\n+\t\t  if (loads)\n+\t\t    cur_summary->loads->merge (loads);\n+\t\t  if (stores)\n+\t\t    cur_summary->stores->merge (stores);\n+\t\t  if (loads_lto)\n+\t\t    cur_summary->loads_lto->merge (loads_lto);\n+\t\t  if (stores_lto)\n+\t\t    cur_summary->stores_lto->merge (stores_lto);\n+\t\t}\n+\t      cur_summary->finished = true;\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Propagated modref for %s%s%s\\n\",\n+\t\t\t   cur->dump_name (),\n+\t\t\t   TREE_READONLY (cur->decl) ? \" (const)\" : \"\",\n+\t\t\t   DECL_PURE_P (cur->decl) ? \" (pure)\" : \"\");\n+\t\t  cur_summary->dump (dump_file);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  ((modref_summaries *)summaries)->ipa = false;\n+  ipa_free_postorder_info ();\n+  return 0;\n+}\n+\n+#include \"gt-ipa-modref.h\""}, {"sha": "6f979200cc2c2195872f0a2d6ec41b50e27e2e80", "filename": "gcc/ipa-modref.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -0,0 +1,48 @@\n+/* Search for references that a functions loads or stores.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef IPA_MODREF_H\n+#define IPA_MODREF_H\n+\n+typedef modref_tree <alias_set_type> modref_records;\n+typedef modref_tree <tree> modref_records_lto;\n+\n+/* Single function summary.  */\n+\n+struct GTY(()) modref_summary\n+{\n+  /* Load and stores in function (transitively closed to all callees)  */\n+  modref_records *loads;\n+  modref_records *stores;\n+\n+  /* The same but using tree types rather than alias sets.  This is necessary\n+     to make the information streamable for LTO but is also more verbose\n+     and thus more likely to hit the limits.  */\n+  modref_records_lto *loads_lto;\n+  modref_records_lto *stores_lto;\n+  bool finished;\n+\n+  modref_summary ();\n+  ~modref_summary ();\n+  void dump (FILE *);\n+};\n+\n+modref_summary *get_modref_function_summary (cgraph_node *func);\n+\n+#endif"}, {"sha": "c12bc8a74b3ab0eeb421f8fb922cabbadffc6c87", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -56,6 +56,7 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"lto\",\n   \"ipa_sra\",\n   \"odr_types\",\n+  \"ipa_modref\",\n };\n \n /* Hooks so that the ipa passes can call into the lto front end to get"}, {"sha": "b465a5e9c18ca3f5fe46841d0495d482a58ba4e2", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -227,6 +227,7 @@ enum lto_section_type\n   LTO_section_lto,\n   LTO_section_ipa_sra,\n   LTO_section_odr_types,\n+  LTO_section_ipa_modref,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n "}, {"sha": "3c4a0b540b490abd99d0c00287bb970e355cd9e1", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -466,6 +466,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_finline_functions_called_once, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_fmove_loop_invariants, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_fssa_phiopt, NULL, 1 },\n+    { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_fipa_modref, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_ftree_bit_ccp, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_ftree_dse, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_ftree_pta, NULL, 1 },"}, {"sha": "1d864047ad2c6c179d59892b64e1d05a522ba61d", "filename": "gcc/params.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -872,6 +872,18 @@ Maximum size of a single store merging region in bytes.\n Common Joined UInteger Var(param_switch_conversion_branch_ratio) Init(8) IntegerRange(1, 65536) Param Optimization\n The maximum ratio between array size and switch branches for a switch conversion to take place.\n \n+-param=modref-max-bases=\n+Common Joined UInteger Var(param_modref_max_bases) Init(32)\n+Maximum number of bases stored in each modref tree.\n+\n+-param=modref-max-refs=\n+Common Joined UInteger Var(param_modref_max_refs) Init(16)\n+Maximum number of refs stored in each modref tree.\n+\n+-param=modref-max-tests=\n+Common Joined UInteger Var(param_modref_max_tests) Init(64)\n+Maximum number of tests perofmed by modref query\n+\n -param=tm-max-aggregate-size=\n Common Joined UInteger Var(param_tm_max_aggregate_size) Init(9) Param Optimization\n Size in bytes after which thread-local aggregates should be instrumented with the logging functions instead of save/restore pairs."}, {"sha": "f865bdc19acd0191c6e1aba4ec0d3ec4e84ac446", "filename": "gcc/passes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -91,6 +91,7 @@ along with GCC; see the file COPYING3.  If not see\n           NEXT_PASS (pass_dse);\n \t  NEXT_PASS (pass_cd_dce);\n \t  NEXT_PASS (pass_phiopt, true /* early_p */);\n+\t  NEXT_PASS (pass_modref);\n \t  NEXT_PASS (pass_tail_recursion);\n \t  NEXT_PASS (pass_convert_switch);\n \t  NEXT_PASS (pass_cleanup_eh);\n@@ -156,6 +157,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_ipa_fn_summary);\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_pure_const);\n+  NEXT_PASS (pass_ipa_modref);\n   NEXT_PASS (pass_ipa_free_fn_summary, false /* small_p */);\n   NEXT_PASS (pass_ipa_reference);\n   /* This pass needs to be scheduled after any IP code duplication.   */\n@@ -346,6 +348,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_late_warn_uninitialized);\n       NEXT_PASS (pass_uncprop);\n       NEXT_PASS (pass_local_pure_const);\n+      NEXT_PASS (pass_modref);\n   POP_INSERT_PASSES ()\n   NEXT_PASS (pass_all_optimizations_g);\n   PUSH_INSERT_PASSES_WITHIN (pass_all_optimizations_g)\n@@ -378,6 +381,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_late_warn_uninitialized);\n       NEXT_PASS (pass_uncprop);\n       NEXT_PASS (pass_local_pure_const);\n+      NEXT_PASS (pass_modref);\n   POP_INSERT_PASSES ()\n   NEXT_PASS (pass_tm_init);\n   PUSH_INSERT_PASSES_WITHIN (pass_tm_init)"}, {"sha": "08c21c04009eb7f5720b9bd32d1c5e4e930e3298", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -107,6 +107,7 @@ DEFTIMEVAR (TV_IPA_PTA               , \"ipa points-to\")\n DEFTIMEVAR (TV_IPA_SRA               , \"ipa SRA\")\n DEFTIMEVAR (TV_IPA_FREE_LANG_DATA    , \"ipa free lang data\")\n DEFTIMEVAR (TV_IPA_FREE_INLINE_SUMMARY, \"ipa free inline summary\")\n+DEFTIMEVAR (TV_IPA_MODREF\t     , \"ipa modref\")\n /* Time spent by constructing CFG.  */\n DEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n /* Time spent by cleaning up CFG.  */\n@@ -218,6 +219,7 @@ DEFTIMEVAR (TV_TREE_SINCOS           , \"gimple CSE sin/cos\")\n DEFTIMEVAR (TV_TREE_WIDEN_MUL        , \"gimple widening/fma detection\")\n DEFTIMEVAR (TV_TRANS_MEM             , \"transactional memory\")\n DEFTIMEVAR (TV_TREE_STRLEN           , \"tree strlen optimization\")\n+DEFTIMEVAR (TV_TREE_MODREF\t     , \"tree modref\")\n DEFTIMEVAR (TV_CGRAPH_VERIFY         , \"callgraph verifier\")\n DEFTIMEVAR (TV_DOM_FRONTIERS         , \"dominance frontiers\")\n DEFTIMEVAR (TV_DOMINANCE             , \"dominance computation\")"}, {"sha": "62e5b696cab7490621fb0a78833b8816554deaf2", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -477,6 +477,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_oacc_kernels (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_nonnull_compare (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_sprintf_length (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_walloca (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_modref (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_coroutine_lower_builtins (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_coroutine_early_expand_ifns (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_adjust_alignment (gcc::context *ctxt);\n@@ -517,6 +518,7 @@ extern ipa_opt_pass_d *make_pass_ipa_profile (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cdtor_merge (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_single_use (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_comdats (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_modref (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_materialize_all_clones (gcc::context *\n \t\t\t\t\t\t\t      ctxt);\n "}, {"sha": "be4d4462fc50395d3eb26b832ebf1d15571d665e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 160, "deletions": 13, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -38,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"ipa-reference.h\"\n #include \"varasm.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n \n /* Broad overview of how alias analysis on gimple works:\n \n@@ -107,6 +109,11 @@ static struct {\n   unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_may_alias;\n   unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_must_overlap;\n   unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_no_alias;\n+  unsigned HOST_WIDE_INT modref_use_may_alias;\n+  unsigned HOST_WIDE_INT modref_use_no_alias;\n+  unsigned HOST_WIDE_INT modref_clobber_may_alias;\n+  unsigned HOST_WIDE_INT modref_clobber_no_alias;\n+  unsigned HOST_WIDE_INT modref_tests;\n } alias_stats;\n \n void\n@@ -153,6 +160,24 @@ dump_alias_stats (FILE *s)\n \t   alias_stats.aliasing_component_refs_p_no_alias\n \t   + alias_stats.aliasing_component_refs_p_may_alias);\n   dump_alias_stats_in_alias_c (s);\n+  fprintf (s, \"\\nModref stats:\\n\");\n+  fprintf (s, \"  modref use: \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n+\t   alias_stats.modref_use_no_alias,\n+\t   alias_stats.modref_use_no_alias\n+\t   + alias_stats.modref_use_may_alias);\n+  fprintf (s, \"  modref clobber: \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n  \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" tbaa querries (%f per modref querry)\\n\",\n+\t   alias_stats.modref_clobber_no_alias,\n+\t   alias_stats.modref_clobber_no_alias\n+\t   + alias_stats.modref_clobber_may_alias,\n+\t   alias_stats.modref_tests,\n+\t   ((double)alias_stats.modref_tests)\n+\t   / (alias_stats.modref_clobber_no_alias\n+\t      + alias_stats.modref_clobber_may_alias));\n }\n \n \n@@ -1341,8 +1366,8 @@ nonoverlapping_array_refs_p (tree ref1, tree ref2)\n {\n   tree index1 = TREE_OPERAND (ref1, 1);\n   tree index2 = TREE_OPERAND (ref2, 1);\n-  tree low_bound1 = cheap_array_ref_low_bound(ref1);\n-  tree low_bound2 = cheap_array_ref_low_bound(ref2);\n+  tree low_bound1 = cheap_array_ref_low_bound (ref1);\n+  tree low_bound2 = cheap_array_ref_low_bound (ref2);\n \n   /* Handle zero offsets first: we do not need to match type size in this\n      case.  */\n@@ -2394,6 +2419,63 @@ refs_output_dependent_p (tree store1, tree store2)\n   return refs_may_alias_p_1 (&r1, &r2, false);\n }\n \n+/* Returns true if and only if REF may alias any access stored in TT.\n+   IF TBAA_P is true, use TBAA oracle.  */\n+\n+static bool\n+modref_may_conflict (modref_tree <alias_set_type> *tt, ao_ref *ref, bool tbaa_p)\n+{\n+  alias_set_type base_set, ref_set;\n+  modref_base_node <alias_set_type> *base_node;\n+  modref_ref_node <alias_set_type> *ref_node;\n+  size_t i, j;\n+\n+  if (tt->every_base)\n+    return true;\n+\n+  base_set = ao_ref_base_alias_set (ref);\n+\n+  ref_set = ao_ref_alias_set (ref);\n+\n+  int num_tests = 0, max_tests = param_modref_max_tests;\n+  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, base_node)\n+    {\n+      if (base_node->every_ref)\n+\treturn true;\n+\n+      if (!base_node->base)\n+\treturn true;\n+\n+      if (tbaa_p && flag_strict_aliasing)\n+\t{\n+\t  if (!alias_sets_conflict_p (base_set, base_node->base))\n+\t    continue;\n+\t  alias_stats.modref_tests++;\n+\t  num_tests++;\n+\t}\n+      else\n+\treturn true;\n+      if (num_tests >= max_tests)\n+\treturn true;\n+\n+      FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t{\n+\t  /* Do not repeat same test as before.  */\n+\t  if (ref_set == base_set && base_node->base == ref_node->ref)\n+\t    return true;\n+\t  if (!flag_strict_aliasing)\n+\t    return true;\n+\t  if (alias_sets_conflict_p (ref_set, ref_node->ref))\n+\t    return true;\n+\t  alias_stats.modref_tests++;\n+\t  num_tests++;\n+\t  if (num_tests >= max_tests)\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* If the call CALL may use the memory reference REF return true,\n    otherwise return false.  */\n \n@@ -2409,15 +2491,51 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n       && (flags & (ECF_CONST|ECF_NOVOPS)))\n     goto process_args;\n \n-  base = ao_ref_base (ref);\n-  if (!base)\n-    return true;\n-\n   /* A call that is not without side-effects might involve volatile\n      accesses and thus conflicts with all other volatile accesses.  */\n   if (ref->volatile_p)\n     return true;\n \n+  callee = gimple_call_fndecl (call);\n+\n+  if (!gimple_call_chain (call) && callee != NULL_TREE)\n+    {\n+      struct cgraph_node *node = cgraph_node::get (callee);\n+      /* We can not safely optimize based on summary of calle if it does\n+\t not always bind to current def: it is possible that memory load\n+\t was optimized out earlier and the interposed variant may not be\n+\t optimized this way.  */\n+      if (node && node->binds_to_current_def_p ())\n+\t{\n+\t  modref_summary *summary = get_modref_function_summary (node);\n+\t  if (summary)\n+\t    {\n+\t      if (!modref_may_conflict (summary->loads, ref, tbaa_p))\n+\t\t{\n+\t\t  alias_stats.modref_use_no_alias++;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"ipa-modref: in %s,\"\n+\t\t\t       \" call to %s does not use \",\n+\t\t\t       cgraph_node::get\n+\t\t\t\t   (current_function_decl)->dump_name (),\n+\t\t\t       node->dump_name ());\n+\t\t      print_generic_expr (dump_file, ref->ref);\n+\t\t      fprintf (dump_file, \" %i->%i\\n\",\n+\t\t\t       ao_ref_base_alias_set (ref),\n+\t\t\t       ao_ref_alias_set (ref));\n+\t\t    }\n+\t\t  goto process_args;\n+\t\t}\n+\t      alias_stats.modref_use_may_alias++;\n+\t    }\n+       }\n+    }\n+\n+  base = ao_ref_base (ref);\n+  if (!base)\n+    return true;\n+\n   /* If the reference is based on a decl that is not aliased the call\n      cannot possibly use it.  */\n   if (DECL_P (base)\n@@ -2426,8 +2544,6 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n       && !is_global_var (base))\n     goto process_args;\n \n-  callee = gimple_call_fndecl (call);\n-\n   /* Handle those builtin functions explicitly that do not act as\n      escape points.  See tree-ssa-structalias.c:find_func_aliases\n      for the list of builtins we might need to handle here.  */\n@@ -2781,7 +2897,7 @@ ref_maybe_used_by_stmt_p (gimple *stmt, tree ref, bool tbaa_p)\n    return true, otherwise return false.  */\n \n bool\n-call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n+call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n {\n   tree base;\n   tree callee;\n@@ -2808,6 +2924,39 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n \tbreak;\n       }\n \n+  callee = gimple_call_fndecl (call);\n+\n+  if (callee != NULL_TREE && !ref->volatile_p)\n+    {\n+      struct cgraph_node *node = cgraph_node::get (callee);\n+      if (node)\n+\t{\n+\t  modref_summary *summary = get_modref_function_summary (node);\n+\t  if (summary)\n+\t    {\n+\t      if (!modref_may_conflict (summary->stores, ref, tbaa_p))\n+\t\t{\n+\t\t  alias_stats.modref_clobber_no_alias++;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"ipa-modref: in %s, \"\n+\t\t\t       \"call to %s does not clobber \",\n+\t\t\t       cgraph_node::get\n+\t\t\t\t  (current_function_decl)->dump_name (),\n+\t\t\t       node->dump_name ());\n+\t\t      print_generic_expr (dump_file, ref->ref);\n+\t\t      fprintf (dump_file, \" %i->%i\\n\",\n+\t\t\t       ao_ref_base_alias_set (ref),\n+\t\t\t       ao_ref_alias_set (ref));\n+\t\t    }\n+\t\t  return false;\n+\t\t}\n+\t      alias_stats.modref_clobber_may_alias++;\n+\t  }\n+\t}\n+    }\n+\n   base = ao_ref_base (ref);\n   if (!base)\n     return true;\n@@ -2840,8 +2989,6 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n       && SSA_NAME_POINTS_TO_READONLY_MEMORY (TREE_OPERAND (base, 0)))\n     return false;\n \n-  callee = gimple_call_fndecl (call);\n-\n   /* Handle those builtin functions explicitly that do not act as\n      escape points.  See tree-ssa-structalias.c:find_func_aliases\n      for the list of builtins we might need to handle here.  */\n@@ -3083,7 +3230,7 @@ call_may_clobber_ref_p (gcall *call, tree ref)\n   bool res;\n   ao_ref r;\n   ao_ref_init (&r, ref);\n-  res = call_may_clobber_ref_p_1 (call, &r);\n+  res = call_may_clobber_ref_p_1 (call, &r, true);\n   if (res)\n     ++alias_stats.call_may_clobber_ref_p_may_alias;\n   else\n@@ -3110,7 +3257,7 @@ stmt_may_clobber_ref_p_1 (gimple *stmt, ao_ref *ref, bool tbaa_p)\n \t    return true;\n \t}\n \n-      return call_may_clobber_ref_p_1 (as_a <gcall *> (stmt), ref);\n+      return call_may_clobber_ref_p_1 (as_a <gcall *> (stmt), ref, tbaa_p);\n     }\n   else if (gimple_assign_single_p (stmt))\n     {"}, {"sha": "1dd02c0ea620fd18f9936a8094329b2daf0e5ac4", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d119f34c952f8718fdbabc63e2f369a16e92fa07/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=d119f34c952f8718fdbabc63e2f369a16e92fa07", "patch": "@@ -129,7 +129,7 @@ extern bool stmt_may_clobber_global_p (gimple *);\n extern bool stmt_may_clobber_ref_p (gimple *, tree, bool = true);\n extern bool stmt_may_clobber_ref_p_1 (gimple *, ao_ref *, bool = true);\n extern bool call_may_clobber_ref_p (gcall *, tree);\n-extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);\n+extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *, bool = true);\n extern bool stmt_kills_ref_p (gimple *, tree);\n extern bool stmt_kills_ref_p (gimple *, ao_ref *);\n enum translate_flags"}]}