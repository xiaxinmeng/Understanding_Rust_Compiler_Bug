{"sha": "60ba25bfc1c465184d34bae053b0d47161c20a76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBiYTI1YmZjMWM0NjUxODRkMzRiYWUwNTNiMGQ0NzE2MWMyMGE3Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-07-01T14:05:16Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-07-01T14:05:16Z"}, "message": "expr.c (expand_assignment): Optimize bitfld += cst for 1 bit bitfields as well.\n\n\t* expr.c (expand_assignment): Optimize bitfld += cst for 1 bit\n\tbitfields as well.  STRIP_NOPS from src operand and PLUS_EXPR's\n\tfirst operand.  Don't optimize if the bitfield is volatile.\n\nFrom-SVN: r83983", "tree": {"sha": "4232b562b11f7f83110e00bb7a62ba4367cbea08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4232b562b11f7f83110e00bb7a62ba4367cbea08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60ba25bfc1c465184d34bae053b0d47161c20a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60ba25bfc1c465184d34bae053b0d47161c20a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60ba25bfc1c465184d34bae053b0d47161c20a76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60ba25bfc1c465184d34bae053b0d47161c20a76/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd74419fb5fe0e4643f4383348755f87730a1c75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd74419fb5fe0e4643f4383348755f87730a1c75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd74419fb5fe0e4643f4383348755f87730a1c75"}], "stats": {"total": 62, "additions": 45, "deletions": 17}, "files": [{"sha": "c693f67f118371997a05f269bd8e93530c75cbbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60ba25bfc1c465184d34bae053b0d47161c20a76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60ba25bfc1c465184d34bae053b0d47161c20a76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60ba25bfc1c465184d34bae053b0d47161c20a76", "patch": "@@ -1,3 +1,9 @@\n+2004-07-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* expr.c (expand_assignment): Optimize bitfld += cst for 1 bit\n+\tbitfields as well.  STRIP_NOPS from src operand and PLUS_EXPR's\n+\tfirst operand.  Don't optimize if the bitfield is volatile.\n+\n 2004-07-01  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* c-pretty-print.c (pp_c_postfix_expression): Handle"}, {"sha": "83c98bf1972ae7d97431f8e9b46243bcc1fa1d85", "filename": "gcc/expr.c", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60ba25bfc1c465184d34bae053b0d47161c20a76/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60ba25bfc1c465184d34bae053b0d47161c20a76/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=60ba25bfc1c465184d34bae053b0d47161c20a76", "patch": "@@ -3858,46 +3858,66 @@ expand_assignment (tree to, tree from, int want_value)\n \t  MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n \t}\n \n-      if (mode1 == VOIDmode && !want_value\n-\t  && bitpos + bitsize <= BITS_PER_WORD\n-\t  && bitsize < BITS_PER_WORD\n-\t  && GET_MODE_BITSIZE (GET_MODE (to_rtx)) <= BITS_PER_WORD\n-\t  && !TREE_SIDE_EFFECTS (to)\n-\t  && TREE_CODE (TREE_TYPE (from)) == INTEGER_TYPE\n-\t  && TREE_CODE_CLASS (TREE_CODE (from)) == '2'\n-\t  && operand_equal_p (to, TREE_OPERAND (from, 0), 0))\n-\t{\n+      while (mode1 == VOIDmode && !want_value\n+\t     && bitpos + bitsize <= BITS_PER_WORD\n+\t     && bitsize < BITS_PER_WORD\n+\t     && GET_MODE_BITSIZE (GET_MODE (to_rtx)) <= BITS_PER_WORD\n+\t     && !TREE_SIDE_EFFECTS (to)\n+\t     && !TREE_THIS_VOLATILE (to))\n+\t{\n+\t  tree src, op0, op1;\n \t  rtx value;\n \t  HOST_WIDE_INT count = bitpos;\n+\t  optab binop;\n+\n+\t  src = from;\n+\t  STRIP_NOPS (src);\n+\t  if (TREE_CODE (TREE_TYPE (src)) != INTEGER_TYPE\n+\t      || TREE_CODE_CLASS (TREE_CODE (src)) != '2')\n+\t    break;\n+\n+\t  op0 = TREE_OPERAND (src, 0);\n+\t  op1 = TREE_OPERAND (src, 1);\n+\t  STRIP_NOPS (op0);\n+\n+\t  if (! operand_equal_p (to, op0, 0))\n+\t    break;\n \n \t  if (BYTES_BIG_ENDIAN)\n \t    count = GET_MODE_BITSIZE (GET_MODE (to_rtx)) - bitpos - bitsize;\n \n \t  /* Special case some bitfield op= exp.  */\n-\t  switch (TREE_CODE (from))\n+\t  switch (TREE_CODE (src))\n \t    {\n \t    case PLUS_EXPR:\n \t    case MINUS_EXPR:\n \t      if (count <= 0)\n \t        break;\n \n \t      /* For now, just optimize the case of the topmost bitfield\n-\t\t where we don't need to do any masking.\n+\t\t where we don't need to do any masking and also\n+\t\t 1 bit bitfields where xor can be used.\n \t\t We might win by one instruction for the other bitfields\n \t\t too if insv/extv instructions aren't used, so that\n \t\t can be added later.  */\n-\t      if (count + bitsize != GET_MODE_BITSIZE (GET_MODE (to_rtx)))\n+\t      if (count + bitsize != GET_MODE_BITSIZE (GET_MODE (to_rtx))\n+\t\t  && (bitsize != 1 || TREE_CODE (op1) != INTEGER_CST))\n \t\tbreak;\n-\t      value = expand_expr (TREE_OPERAND (from, 1), NULL_RTX,\n-\t\t\t\t   VOIDmode, 0);\n+\t      value = expand_expr (op1, NULL_RTX, VOIDmode, 0);\n \t      value = protect_from_queue (value, 0);\n \t      to_rtx = protect_from_queue (to_rtx, 1);\n+\t      binop = TREE_CODE (src) == PLUS_EXPR ? add_optab : sub_optab;\n+\t      if (bitsize == 1\n+\t\t  && count + bitsize != GET_MODE_BITSIZE (GET_MODE (to_rtx)))\n+\t\t{\n+\t\t  value = expand_and (GET_MODE (to_rtx), value, const1_rtx,\n+\t\t\t\t      NULL_RTX);\n+\t\t  binop = xor_optab;\n+\t\t}\n \t      value = expand_shift (LSHIFT_EXPR, GET_MODE (to_rtx),\n \t\t\t\t    value, build_int_2 (count, 0),\n \t\t\t\t    NULL_RTX, 1);\n-\t      result = expand_binop (GET_MODE (to_rtx),\n-\t\t\t\t     TREE_CODE (from) == PLUS_EXPR\n-\t\t\t\t     ? add_optab : sub_optab, to_rtx,\n+\t      result = expand_binop (GET_MODE (to_rtx), binop, to_rtx,\n \t\t\t\t     value, to_rtx, 1, OPTAB_WIDEN);\n \t      if (result != to_rtx)\n \t\temit_move_insn (to_rtx, result);\n@@ -3907,6 +3927,8 @@ expand_assignment (tree to, tree from, int want_value)\n \t    default:\n \t      break;\n \t    }\n+\n+\t  break;\n \t}\n \n       result = store_field (to_rtx, bitsize, bitpos, mode1, from,"}]}