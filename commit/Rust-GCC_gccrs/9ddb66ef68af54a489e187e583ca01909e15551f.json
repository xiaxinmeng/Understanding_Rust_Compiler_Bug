{"sha": "9ddb66ef68af54a489e187e583ca01909e15551f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRkYjY2ZWY2OGFmNTRhNDg5ZTE4N2U1ODNjYTAxOTA5ZTE1NTUxZg==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@spamcop.net", "date": "2010-01-16T00:36:34Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2010-01-16T00:36:34Z"}, "message": "tm.texi (TARGET_HELP): Fix return type.\n\n\t* doc/tm.texi (TARGET_HELP): Fix return type.\n\n\t(TARGET_PROMOTE_FUNCTION_MODE): Put 'enum machine_mode'\n\tin braces.  Fix argument types.\n\n\t(TARGET_LIBGCC_CMP_RETURN_MODE): Use prototype.\n\n\t(TARGET_LIBGCC_SHIFT_COUNT_MODE): Use prototype.\n\n\t(TARGET_MS_BITFIELD_LAYOUT_P): Fix argument type.\n\n\t(TARGET_DECIMAL_FLOAT_SUPPORTED_P): Don't put 'bool' in braces.\n\t(TARGET_FIXED_POINT_SUPPORTED_P): Likewise.\n\n\t(TARGET_MANGLE_TYPE): Fix argument types.\n\n\t(TARGET_IRA_COVER_CLASSES): Use prototype.\n\n\t(TARGET_BUILTIN_SETJMP_FRAME_VALUE): Fix return type.  Use prototype.\n\n\t(TARGET_CAN_ELIMINATE): Use identifiers for argument names.\n\n\t(TARGET_PROMOTE_PROTOTYPES): Fix argument type.\n\n\t(TARGET_MUST_PASS_IN_STACK): Fix argument type.\n\n\t(TARGET_CALLEE_COPIES): Fix argument types.\n\n\t(TARGET_SPLIT_COMPLEX_ARG): Fix argument type.\n\n\t(TARGET_GIMPLIFY_VA_ARG_EXPR): Fix argument types.\n\n\t(TARGET_FUNCTION_VALUE): Fix argument types.\n\n\t(TARGET_RETURN_IN_MSB): Fix argument type.\n\n\t(TARGET_RETURN_IN_MEMORY): Fix argument types.\n\n\t(TARGET_ASM_CAN_OUTPUT_MI_THUNK): Fix argument types.\n\n\t(TARGET_EXTRA_LIVE_ON_ENTRY): Fix argument type.\n\n\t(TARGET_STRICT_ARGUMENT_NAMING): Make literal in text\n\tagree with return type.\n\n\t(TARGET_PRETEND_OUTGOING_VARARGS_NAMED): Add Prototype.\n\nFrom-SVN: r155956", "tree": {"sha": "8c011a049ba6a733774946615634c8bc0206d185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c011a049ba6a733774946615634c8bc0206d185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ddb66ef68af54a489e187e583ca01909e15551f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddb66ef68af54a489e187e583ca01909e15551f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ddb66ef68af54a489e187e583ca01909e15551f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddb66ef68af54a489e187e583ca01909e15551f/comments", "author": null, "committer": null, "parents": [{"sha": "5e7bfbb8287e1978118e4e689d6b8d31e03f4f18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7bfbb8287e1978118e4e689d6b8d31e03f4f18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e7bfbb8287e1978118e4e689d6b8d31e03f4f18"}], "stats": {"total": 99, "additions": 74, "deletions": 25}, "files": [{"sha": "60407008a18e8a593524969c77ab5c33ebc94736", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ef68af54a489e187e583ca01909e15551f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ef68af54a489e187e583ca01909e15551f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ddb66ef68af54a489e187e583ca01909e15551f", "patch": "@@ -1,3 +1,52 @@\n+2010-01-15  Joern Rennecke  <amylaar@spamcop.net>\n+\n+\t* doc/tm.texi (TARGET_HELP): Fix return type.\n+\n+\t(TARGET_PROMOTE_FUNCTION_MODE): Put 'enum machine_mode'\n+\tin braces.  Fix argument types.\n+\n+\t(TARGET_LIBGCC_CMP_RETURN_MODE): Use prototype.\n+\n+\t(TARGET_LIBGCC_SHIFT_COUNT_MODE): Use prototype.\n+\n+\t(TARGET_MS_BITFIELD_LAYOUT_P): Fix argument type.\n+\n+\t(TARGET_DECIMAL_FLOAT_SUPPORTED_P): Don't put 'bool' in braces.\n+\t(TARGET_FIXED_POINT_SUPPORTED_P): Likewise.\n+\n+\t(TARGET_MANGLE_TYPE): Fix argument types.\n+\n+\t(TARGET_IRA_COVER_CLASSES): Use prototype.\n+\n+\t(TARGET_BUILTIN_SETJMP_FRAME_VALUE): Fix return type.  Use prototype.\n+\n+\t(TARGET_CAN_ELIMINATE): Use identifiers for argument names.\n+\n+\t(TARGET_PROMOTE_PROTOTYPES): Fix argument type.\n+\n+\t(TARGET_MUST_PASS_IN_STACK): Fix argument type.\n+\n+\t(TARGET_CALLEE_COPIES): Fix argument types.\n+\n+\t(TARGET_SPLIT_COMPLEX_ARG): Fix argument type.\n+\n+\t(TARGET_GIMPLIFY_VA_ARG_EXPR): Fix argument types.\n+\n+\t(TARGET_FUNCTION_VALUE): Fix argument types.\n+\n+\t(TARGET_RETURN_IN_MSB): Fix argument type.\n+\n+\t(TARGET_RETURN_IN_MEMORY): Fix argument types.\n+\n+\t(TARGET_ASM_CAN_OUTPUT_MI_THUNK): Fix argument types.\n+\n+\t(TARGET_EXTRA_LIVE_ON_ENTRY): Fix argument type.\n+\n+\t(TARGET_STRICT_ARGUMENT_NAMING): Make literal in text\n+\tagree with return type.\n+\n+\t(TARGET_PRETEND_OUTGOING_VARARGS_NAMED): Add Prototype.\n+\n 2010-01-15  Jing Yu  <jingyu@google.com>\n \n \tPR rtl-optimization/42691"}, {"sha": "9ab70276c48c3d09789a27613b31dab55df5dc6e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ef68af54a489e187e583ca01909e15551f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ef68af54a489e187e583ca01909e15551f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9ddb66ef68af54a489e187e583ca01909e15551f", "patch": "@@ -858,7 +858,7 @@ this macro!} The debugging options are not supposed to alter the\n generated code.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_HELP (void)\n+@deftypefn {Target Hook} void TARGET_HELP (void)\n This hook is called in response to the user invoking\n @option{--target-help} on the command line.  It gives the target a\n chance to display extra information on the target specific command\n@@ -1054,7 +1054,7 @@ sign-extend the result to 64 bits.  On such machines, set\n Do not define this macro if it would never modify @var{m}.\n @end defmac\n \n-@deftypefn {Target Hook} enum machine_mode TARGET_PROMOTE_FUNCTION_MODE (tree @var{type}, enum machine_mode @var{mode}, int *@var{punsignedp}, tree @var{funtype}, int @var{for_return})\n+@deftypefn {Target Hook} {enum machine_mode} TARGET_PROMOTE_FUNCTION_MODE (const_tree @var{type}, enum machine_mode @var{mode}, int *@var{punsignedp}, const_tree @var{funtype}, int @var{for_return})\n Like @code{PROMOTE_MODE}, but it is applied to outgoing function arguments or\n function return values.  The target hook should return the new mode\n and possibly change @code{*@var{punsignedp}} if the promotion should\n@@ -1409,14 +1409,14 @@ You would most commonly define this macro if the @code{allocate_stack}\n pattern needs to support both a 32- and a 64-bit mode.\n @end defmac\n \n-@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_CMP_RETURN_MODE ()\n+@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_CMP_RETURN_MODE (void)\n This target hook should return the mode to be used for the return value\n of compare instructions expanded to libgcc calls.  If not defined\n @code{word_mode} is returned which is the right choice for a majority of\n targets.\n @end deftypefn\n \n-@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_SHIFT_COUNT_MODE ()\n+@deftypefn {Target Hook} {enum machine_mode} TARGET_LIBGCC_SHIFT_COUNT_MODE (void)\n This target hook should return the mode to be used for the shift count operand\n of shift instructions expanded to libgcc calls.  If not defined\n @code{word_mode} is returned which is the right choice for a majority of\n@@ -1444,7 +1444,7 @@ floating-point arithmetic.\n The default definition of this macro returns false for all sizes.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_MS_BITFIELD_LAYOUT_P (tree @var{record_type})\n+@deftypefn {Target Hook} bool TARGET_MS_BITFIELD_LAYOUT_P (const_tree @var{record_type})\n This target hook returns @code{true} if bit-fields in the given\n @var{record_type} are to be laid out following the rules of Microsoft\n Visual C/C++, namely: (i) a bit-field won't share the same storage\n@@ -1472,11 +1472,11 @@ precedence for that field, but the alignment of the rest of the structure\n may affect its placement.\n @end deftypefn\n \n-@deftypefn {Target Hook} {bool} TARGET_DECIMAL_FLOAT_SUPPORTED_P (void)\n+@deftypefn {Target Hook} bool TARGET_DECIMAL_FLOAT_SUPPORTED_P (void)\n Returns true if the target supports decimal floating point.\n @end deftypefn\n \n-@deftypefn {Target Hook} {bool} TARGET_FIXED_POINT_SUPPORTED_P (void)\n+@deftypefn {Target Hook} bool TARGET_FIXED_POINT_SUPPORTED_P (void)\n Returns true if the target supports fixed-point arithmetic.\n @end deftypefn\n \n@@ -1494,7 +1494,7 @@ This hook allows the backend to perform additional instantiations on rtl\n that are not actually in any insns yet, but will be later.\n @end deftypefn\n \n-@deftypefn {Target Hook} {const char *} TARGET_MANGLE_TYPE (tree @var{type})\n+@deftypefn {Target Hook} {const char *} TARGET_MANGLE_TYPE (const_tree @var{type})\n If your target defines any fundamental types, or any types your target\n uses should be mangled differently from the default, define this hook\n to return the appropriate encoding for these types as part of a C++\n@@ -2922,7 +2922,7 @@ as below:\n @end smallexample\n @end defmac\n \n-@deftypefn {Target Hook} {const enum reg_class *} TARGET_IRA_COVER_CLASSES ()\n+@deftypefn {Target Hook} {const enum reg_class *} TARGET_IRA_COVER_CLASSES (void)\n Return an array of cover classes for the Integrated Register Allocator\n (@acronym{IRA}).  Cover classes are a set of non-intersecting register\n classes covering all hard registers used for register allocation\n@@ -3239,7 +3239,7 @@ before we can access arbitrary stack frames.  You will seldom need to\n define this macro.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_BUILTIN_SETJMP_FRAME_VALUE ()\n+@deftypefn {Target Hook} rtx TARGET_BUILTIN_SETJMP_FRAME_VALUE (void)\n This target hook should return an rtx that is used to store\n the address of the current frame into the built in @code{setjmp} buffer.\n The default value, @code{virtual_stack_vars_rtx}, is correct for most\n@@ -3841,10 +3841,10 @@ Note that the elimination of the argument pointer with the stack pointer is\n specified first since that is the preferred elimination.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_CAN_ELIMINATE (const int @var{from-reg}, const int @var{to-reg})\n+@deftypefn {Target Hook} bool TARGET_CAN_ELIMINATE (const int @var{from_reg}, const int @var{to_reg})\n This target hook should returns @code{true} if the compiler is allowed to\n-try to replace register number @var{from-reg} with register number\n-@var{to-reg}.  This target hook need only be defined if @code{ELIMINABLE_REGS}\n+try to replace register number @var{from_reg} with register number\n+@var{to_reg}.  This target hook need only be defined if @code{ELIMINABLE_REGS}\n is defined, and will usually be @code{true}, since most of the cases\n preventing register elimination are things that the compiler already\n knows about.\n@@ -3868,7 +3868,7 @@ The macros in this section control how arguments are passed\n on the stack.  See the following section for other macros that\n control passing certain arguments in registers.\n \n-@deftypefn {Target Hook} bool TARGET_PROMOTE_PROTOTYPES (tree @var{fntype})\n+@deftypefn {Target Hook} bool TARGET_PROMOTE_PROTOTYPES (const_tree @var{fntype})\n This target hook returns @code{true} if an argument declared in a\n prototype as an integral type smaller than @code{int} should actually be\n passed as an @code{int}.  In addition to avoiding errors in certain\n@@ -4083,7 +4083,7 @@ defined, the argument will be computed in the stack and then loaded into\n a register.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (enum machine_mode @var{mode}, tree @var{type})\n+@deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (enum machine_mode @var{mode}, const_tree @var{type})\n This target hook should return @code{true} if we should not pass @var{type}\n solely in registers.  The file @file{expr.h} defines a\n definition that is usually appropriate, refer to @file{expr.h} for additional\n@@ -4136,7 +4136,7 @@ The pointer is passed in whatever way is appropriate for passing a pointer\n to that type.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_CALLEE_COPIES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} bool TARGET_CALLEE_COPIES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n The function argument described by the parameters to this hook is\n known to be passed by reference.  The hook should return true if the\n function argument should be copied by the callee instead of copied\n@@ -4285,7 +4285,7 @@ used for this purpose since all function arguments are pushed on the\n stack.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_SPLIT_COMPLEX_ARG (tree @var{type})\n+@deftypefn {Target Hook} bool TARGET_SPLIT_COMPLEX_ARG (const_tree @var{type})\n This hook should return true if parameter of type @var{type} are passed\n as two scalar parameters.  By default, GCC will attempt to pack complex\n arguments into the target's word size.  Some ABIs require complex arguments\n@@ -4315,7 +4315,7 @@ type of @var{type}. If @var{type} is not a valid va_list type, it returns\n @code{NULL_TREE}.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree @var{valist}, tree @var{type}, tree *@var{pre_p}, tree *@var{post_p})\n+@deftypefn {Target Hook} tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree @var{valist}, tree @var{type}, gimple_seq *@var{pre_p}, gimple_seq *@var{post_p})\n This hook performs target-specific gimplification of\n @code{VA_ARG_EXPR}.  The first two parameters correspond to the\n arguments to @code{va_arg}; the latter two are as in\n@@ -4355,7 +4355,7 @@ must have move patterns for this mode.\n This section discusses the macros that control returning scalars as\n values---values that can fit in registers.\n \n-@deftypefn {Target Hook} rtx TARGET_FUNCTION_VALUE (tree @var{ret_type}, tree @var{fn_decl_or_type}, bool @var{outgoing})\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_VALUE (const_tree @var{ret_type}, const_tree @var{fn_decl_or_type}, bool @var{outgoing})\n \n Define this to return an RTX representing the place where a function\n returns or receives a value of data type @var{ret_type}, a tree node\n@@ -4469,7 +4469,7 @@ need more space than is implied by @code{FUNCTION_VALUE_REGNO_P} for\n saving and restoring an arbitrary return value.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_RETURN_IN_MSB (tree @var{type})\n+@deftypefn {Target Hook} bool TARGET_RETURN_IN_MSB (const_tree @var{type})\n This hook should return true if values of type @var{type} are returned\n at the most significant end of a register (in other words, if they are\n padded at the least significant end).  You can assume that @var{type}\n@@ -4499,7 +4499,7 @@ address}.\n This section describes how to control returning structure values in\n memory.\n \n-@deftypefn {Target Hook} bool TARGET_RETURN_IN_MEMORY (tree @var{type}, tree @var{fntype})\n+@deftypefn {Target Hook} bool TARGET_RETURN_IN_MEMORY (const_tree @var{type}, const_tree @var{fntype})\n This target hook should return a nonzero value to say to return the\n function value in memory, just as large structures are always returned.\n Here @var{type} will be the data type of the value, and @var{fntype}\n@@ -4840,7 +4840,7 @@ front end will generate a less efficient heavyweight thunk that calls\n not support varargs.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, tree @var{function})\n+@deftypefn {Target Hook} bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (const_tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, const_tree @var{function})\n A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would be able\n to output the assembler code for the thunk function specified by the\n arguments it is passed, and false otherwise.  In the latter case, the\n@@ -4906,7 +4906,7 @@ as the @code{sibcall} md pattern can not fail, or fall over to a\n may vary greatly between different architectures.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap *@var{regs})\n+@deftypefn {Target Hook} void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap @var{regs})\n Add any hard registers to @var{regs} that are live on entry to the\n function.  This hook only needs to be defined to provide registers that\n cannot be found by examination of FUNCTION_ARG_REGNO_P, the callee saved\n@@ -5087,10 +5087,10 @@ but @code{TARGET_PRETEND_OUTGOING_VARARGS_NAMED} returns @code{true},\n then all arguments are treated as named.  Otherwise, all named arguments\n except the last are treated as named.\n \n-You need not define this hook if it always returns zero.\n+You need not define this hook if it always returns @code{false}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n+@deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED (CUMULATIVE_ARGS *@var{ca})\n If you need to conditionally change ABIs so that one works with\n @code{TARGET_SETUP_INCOMING_VARARGS}, but the other works like neither\n @code{TARGET_SETUP_INCOMING_VARARGS} nor @code{TARGET_STRICT_ARGUMENT_NAMING} was"}]}