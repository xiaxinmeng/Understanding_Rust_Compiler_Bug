{"sha": "a4c6502a661a4d0a6e157e118c7be4178176f743", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRjNjUwMmE2NjFhNGQwYTZlMTU3ZTExOGM3YmU0MTc4MTc2Zjc0Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-02-22T13:34:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-22T13:34:33Z"}, "message": "cse.c (dump_class): New function.\n\n\t* cse.c (dump_class): New function.\n\t(invalidate_memory): Fix typo in comment.\n\t* function.c (temp_slot): Add an alias set field.\n\t(assign_stack_temp): Only reuse slots if they will have the\n\tsame alias set as before.\n\t(combine_temp_slots): Don't combine if -fstrict-aliasing;\n\tthat's unsafe.\n\t* rtl.c (copy_rtx): Copy all the flags (in particular,\n\tMEM_SCALAR_P).\n\nFrom-SVN: r25372", "tree": {"sha": "0b06b500febf846a9be290f5b44393399d824d50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b06b500febf846a9be290f5b44393399d824d50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4c6502a661a4d0a6e157e118c7be4178176f743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c6502a661a4d0a6e157e118c7be4178176f743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4c6502a661a4d0a6e157e118c7be4178176f743", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c6502a661a4d0a6e157e118c7be4178176f743/comments", "author": null, "committer": null, "parents": [{"sha": "44768aae76f6fe77bea11f4a0e5fcf24d65c8f8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44768aae76f6fe77bea11f4a0e5fcf24d65c8f8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44768aae76f6fe77bea11f4a0e5fcf24d65c8f8c"}], "stats": {"total": 95, "additions": 87, "deletions": 8}, "files": [{"sha": "321077fb4cb324f55d89426f03fb62b4f6084d17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4c6502a661a4d0a6e157e118c7be4178176f743", "patch": "@@ -1,3 +1,15 @@\n+Mon Feb 22 13:33:47 1999  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cse.c (dump_class): New function.\n+\t(invalidate_memory): Fix typo in comment.\n+\t* function.c (temp_slot): Add an alias set field.  \n+\t(assign_stack_temp): Only reuse slots if they will have the\n+\tsame alias set as before.\n+\t(combine_temp_slots): Don't combine if -fstrict-aliasing;\n+\tthat's unsafe.\n+\t* rtl.c (copy_rtx): Copy all the flags (in particular,\n+\tMEM_SCALAR_P).\n+\n Mon Feb 22 14:13:23 1999  Vladimir N. Makarov  <vmakarov@cygnus.com>\n \n \t* configure.in (i[34567]86-*-linux-gnu*,"}, {"sha": "7fa8116a6f63b3ff449a123a83fa0375e562962b", "filename": "gcc/cse.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=a4c6502a661a4d0a6e157e118c7be4178176f743", "patch": "@@ -663,9 +663,29 @@ static void cse_check_loop_start PROTO((rtx, rtx));\n static void cse_set_around_loop\tPROTO((rtx, rtx, rtx));\n static rtx cse_basic_block\tPROTO((rtx, rtx, struct branch_path *, int));\n static void count_reg_usage\tPROTO((rtx, int *, rtx, int));\n+static void dump_class          PROTO((struct table_elt*));\n \n extern int rtx_equal_function_value_matters;\n \f\n+/* Dump the expressions in the equivalence class indicated by CLASSP.\n+   This function is used only for debugging.  */\n+void\n+dump_class (classp)\n+     struct table_elt *classp;\n+{\n+  struct table_elt *elt;\n+\n+  fprintf (stderr, \"Equivalence chain for \");\n+  print_rtl (stderr, classp->exp);\n+  fprintf (stderr, \": \\n\");\n+  \n+  for (elt = classp->first_same_value; elt; elt = elt->next_same_value)\n+    {\n+      print_rtl (stderr, elt->exp);\n+      fprintf (stderr, \"\\n\");\n+    }\n+}\n+\n /* Return an estimate of the cost of computing rtx X.\n    One use is in cse, to decide which expression to keep in the hash table.\n    Another is in rtl generation, to pick the cheapest way to multiply.\n@@ -7821,7 +7841,7 @@ cse_insn (insn, libcall_insn)\n   prev_insn = insn;\n }\n \f\n-/* Remove from the ahsh table all expressions that reference memory.  */\n+/* Remove from the hash table all expressions that reference memory.  */\n static void\n invalidate_memory ()\n {"}, {"sha": "03d1e75c47a28afd7a421a92d3248f34ad119018", "filename": "gcc/function.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a4c6502a661a4d0a6e157e118c7be4178176f743", "patch": "@@ -394,6 +394,17 @@ struct temp_slot\n   int align;\n   /* The size, in units, of the slot.  */\n   HOST_WIDE_INT size;\n+  /* The alias set for the slot.  If the alias set is zero, we don't\n+     know anything about the alias set of the slot.  We must only\n+     reuse a slot if it is assigned an object of the same alias set.\n+     Otherwise, the rest of the compiler may assume that the new use\n+     of the slot cannot alias the old use of the slot, which is\n+     false.  If the slot has alias set zero, then we can't reuse the\n+     slot at all, since we have no idea what alias set may have been\n+     imposed on the memory.  For example, if the stack slot is the\n+     call frame for an inline functioned, we have no idea what alias\n+     sets will be assigned to various pieces of the call frame.  */\n+  int alias_set;\n   /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n   tree rtl_expr;\n   /* Non-zero if this temporary is currently in use.  */\n@@ -875,7 +886,9 @@ assign_outer_stack_local (mode, size, align, function)\n    with this flag.  KEEP is 2 if we allocate a longer term temporary,\n    whose lifetime is controlled by CLEANUP_POINT_EXPRs.  KEEP is 3\n    if we are to allocate something at an inner level to be treated as\n-   a variable in the block (e.g., a SAVE_EXPR).  */\n+   a variable in the block (e.g., a SAVE_EXPR).  \n+\n+   TYPE is the type that will be used for the stack slot.  */\n \n static rtx\n assign_stack_temp_for_type (mode, size, keep, type)\n@@ -885,13 +898,22 @@ assign_stack_temp_for_type (mode, size, keep, type)\n      tree type;\n {\n   int align;\n+  int alias_set;\n   struct temp_slot *p, *best_p = 0;\n \n   /* If SIZE is -1 it means that somebody tried to allocate a temporary\n      of a variable size.  */\n   if (size == -1)\n     abort ();\n \n+  /* If we know the alias set for the memory that will be used, use\n+     it.  If there's no TYPE, then we don't know anything about the\n+     alias set for the memory.  */\n+  if (type)\n+    alias_set = get_alias_set (type);\n+  else \n+    alias_set = 0;\n+\n   align = GET_MODE_ALIGNMENT (mode);\n   if (mode == BLKmode)\n     align = BIGGEST_ALIGNMENT;\n@@ -907,6 +929,8 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   for (p = temp_slots; p; p = p->next)\n     if (p->align >= align && p->size >= size && GET_MODE (p->slot) == mode\n \t&& ! p->in_use\n+\t&& (!flag_strict_aliasing\n+\t    || (alias_set && p->alias_set == alias_set))\n \t&& (best_p == 0 || best_p->size > p->size\n \t    || (best_p->size == p->size && best_p->align > p->align)))\n       {\n@@ -924,7 +948,11 @@ assign_stack_temp_for_type (mode, size, keep, type)\n       /* If there are enough aligned bytes left over, make them into a new\n \t temp_slot so that the extra bytes don't get wasted.  Do this only\n \t for BLKmode slots, so that we can be sure of the alignment.  */\n-      if (GET_MODE (best_p->slot) == BLKmode)\n+      if (GET_MODE (best_p->slot) == BLKmode\n+\t  /* We can't split slots if -fstrict-aliasing because the\n+\t     information about the alias set for the new slot will be\n+\t     lost.  */\n+\t  && !flag_strict_aliasing)\n \t{\n \t  int alignment = best_p->align / BITS_PER_UNIT;\n \t  HOST_WIDE_INT rounded_size = CEIL_ROUND (size, alignment);\n@@ -978,6 +1006,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n       p->slot = assign_stack_local (mode, size, align);\n \n       p->align = align;\n+      p->alias_set = alias_set;\n \n       /* The following slot size computation is necessary because we don't\n \t know the actual size of the temporary slot until assign_stack_local\n@@ -1103,6 +1132,11 @@ combine_temp_slots ()\n   struct temp_slot *prev_p, *prev_q;\n   int num_slots;\n \n+  /* We can't combine slots, because the information about which slot\n+     is in which alias set will be lost.  */\n+  if (flag_strict_aliasing)\n+    return;\n+\n   /* If there are a lot of temp slots, don't do anything unless \n      high levels of optimizaton.  */\n   if (! flag_expensive_optimizations)"}, {"sha": "b4d870d8cc37ae626c37002a1d00bef9161f1c5c", "filename": "gcc/rtl.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4c6502a661a4d0a6e157e118c7be4178176f743/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a4c6502a661a4d0a6e157e118c7be4178176f743", "patch": "@@ -319,11 +319,24 @@ copy_rtx (orig)\n     }\n \n   copy = rtx_alloc (code);\n-  PUT_MODE (copy, GET_MODE (orig));\n-  copy->in_struct = orig->in_struct;\n-  copy->volatil = orig->volatil;\n-  copy->unchanging = orig->unchanging;\n-  copy->integrated = orig->integrated;\n+\n+  /* Copy the various flags, and other information.  We assume that\n+     all fields need copying, and then clear the fields that should\n+     not be copied.  That is the sensible default behavior, and forces\n+     us to explicitly document why we are *not* copying a flag.  */\n+  bcopy (orig, copy, sizeof (struct rtx_def) - sizeof (rtunion));\n+\n+  /* We do not copy the USED flag, which is used as a mark bit during\n+     walks over the RTL.  */\n+  copy->used = 0;\n+\n+  /* We do not copy JUMP, CALL, or FRAME_RELATED for INSNs.  */\n+  if (GET_RTX_CLASS (code) == 'i')\n+    {\n+      copy->jump = 0;\n+      copy->call = 0;\n+      copy->frame_related = 0;\n+    }\n   \n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n "}]}