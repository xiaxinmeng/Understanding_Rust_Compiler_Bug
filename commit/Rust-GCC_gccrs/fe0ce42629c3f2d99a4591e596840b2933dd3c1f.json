{"sha": "fe0ce42629c3f2d99a4591e596840b2933dd3c1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUwY2U0MjYyOWMzZjJkOTlhNDU5MWU1OTY4NDBiMjkzM2RkM2MxZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@paru.cas.cz", "date": "1999-04-10T05:19:58Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-10T05:19:58Z"}, "message": "extend.texi (Assembler Instructions with C Expression Operands): Document the i386 floating point operands.\n\n        * extend.texi (Assembler Instructions with C Expression Operands):\n        Document the i386 floating point operands.\n\nFrom-SVN: r26334", "tree": {"sha": "fb7d55b1f5b99d4a512ab1470e25252614483428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb7d55b1f5b99d4a512ab1470e25252614483428"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe0ce42629c3f2d99a4591e596840b2933dd3c1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0ce42629c3f2d99a4591e596840b2933dd3c1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe0ce42629c3f2d99a4591e596840b2933dd3c1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0ce42629c3f2d99a4591e596840b2933dd3c1f/comments", "author": null, "committer": null, "parents": [{"sha": "28897609cf6cb2d02d5d627111b011500d1189a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28897609cf6cb2d02d5d627111b011500d1189a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28897609cf6cb2d02d5d627111b011500d1189a9"}], "stats": {"total": 95, "additions": 95, "deletions": 0}, "files": [{"sha": "fc06842aadc7a1569b3c75d9e0466b12ecacd552", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe0ce42629c3f2d99a4591e596840b2933dd3c1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe0ce42629c3f2d99a4591e596840b2933dd3c1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe0ce42629c3f2d99a4591e596840b2933dd3c1f", "patch": "@@ -1,3 +1,8 @@\n+Sat Apr 10 06:14:31 1999  Jan Hubicka  <hubicka@paru.cas.cz>\n+\n+\t* extend.texi (Assembler Instructions with C Expression Operands):\n+\tDocument the i386 floating point operands.\n+\n 1999-04-10  Mike Stump  <mrs@wrs.com>\n \n \t* configure.in (*-*-vxworks): Add vxWorks thread support for all"}, {"sha": "7b6a6bfa4cd3e23adffdf8257910ae18cc5e773a", "filename": "gcc/extend.texi", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe0ce42629c3f2d99a4591e596840b2933dd3c1f/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe0ce42629c3f2d99a4591e596840b2933dd3c1f/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=fe0ce42629c3f2d99a4591e596840b2933dd3c1f", "patch": "@@ -2579,6 +2579,96 @@ If you are writing a header file that should be includable in ANSI C\n programs, write @code{__asm__} instead of @code{asm}.  @xref{Alternate\n Keywords}.\n \n+@subsection i386 floating point asm operands\n+\n+There are several rules on the usage of stack-like regs in\n+asm_operands insns.  These rules apply only to the operands that are\n+stack-like regs:\n+\n+@enumerate\n+@item\n+Given a set of input regs that die in an asm_operands, it is\n+necessary to know which are implicitly popped by the asm, and\n+which must be explicitly popped by gcc.\n+\n+An input reg that is implicitly popped by the asm must be\n+explicitly clobbered, unless it is constrained to match an\n+output operand.\n+\n+@item\n+For any input reg that is implicitly popped by an asm, it is\n+necessary to know how to adjust the stack to compensate for the pop.\n+If any non-popped input is closer to the top of the reg-stack than\n+the implicitly popped reg, it would not be possible to know what the\n+stack looked like --- it's not clear how the rest of the stack ``slides\n+up''.\n+\n+All implicitly popped input regs must be closer to the top of\n+the reg-stack than any input that is not implicitly popped.\n+\n+It is possible that if an input dies in an insn, reload might\n+use the input reg for an output reload.  Consider this example:\n+\n+@example\n+asm (\"foo\" : \"=t\" (a) : \"f\" (b));\n+@end example\n+\n+This asm says that input B is not popped by the asm, and that\n+the asm pushes a result onto the reg-stack, ie, the stack is one\n+deeper after the asm than it was before.  But, it is possible that\n+reload will think that it can use the same reg for both the input and\n+the output, if input B dies in this insn.\n+\n+If any input operand uses the @code{f} constraint, all output reg\n+constraints must use the @code{&} earlyclobber.\n+\n+The asm above would be written as\n+\n+@example\n+asm (\"foo\" : \"=&t\" (a) : \"f\" (b));\n+@end example\n+\n+@item\n+Some operands need to be in particular places on the stack.  All\n+output operands fall in this category --- there is no other way to\n+know which regs the outputs appear in unless the user indicates\n+this in the constraints.\n+\n+Output operands must specifically indicate which reg an output\n+appears in after an asm.  @code{=f} is not allowed: the operand\n+constraints must select a class with a single reg.\n+\n+@item\n+Output operands may not be ``inserted'' between existing stack regs.\n+Since no 387 opcode uses a read/write operand, all output operands\n+are dead before the asm_operands, and are pushed by the asm_operands.\n+It makes no sense to push anywhere but the top of the reg-stack.\n+\n+Output operands must start at the top of the reg-stack: output\n+operands may not ``skip'' a reg.\n+\n+@item\n+Some asm statements may need extra stack space for internal\n+calculations.  This can be guaranteed by clobbering stack registers\n+unrelated to the inputs and outputs.\n+\n+@end enumerate\n+\n+Here are a couple of reasonable asms to want to write.  This asm\n+takes one input, which is internally popped, and produces two outputs.\n+\n+@example\n+asm (\"fsincos\" : \"=t\" (cos), \"=u\" (sin) : \"0\" (inp));\n+@end example\n+\n+This asm takes two inputs, which are popped by the @code{fyl2xp1} opcode,\n+and replaces them with one output.  The user must code the @code{st(1)}\n+clobber for reg-stack.c to know that @code{fyl2xp1} pops both inputs.\n+\n+@example\n+asm (\"fyl2xp1\" : \"=t\" (result) : \"0\" (x), \"u\" (y) : \"st(1)\");\n+@end example\n+\n @ifclear INTERNALS\n @c Show the details on constraints if they do not appear elsewhere in\n @c the manual"}]}