{"sha": "6df26b8f231266faea12111fff34af007b1b4177", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmMjZiOGYyMzEyNjZmYWVhMTIxMTFmZmYzNGFmMDA3YjFiNDE3Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-19T15:50:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-19T15:50:20Z"}, "message": "regclass.c (contains_reg_of_mode): Make global.\n\n\t* regclass.c (contains_reg_of_mode): Make global.\n\t(init_reg_sets): Remove contains_reg_of_mode; take into account\n\tCLASS_MAX_NREGS when looking for the proper mode.\n\t(dump_regclass): Dump only classes considered for the pseudo.\n\t(regclass): Use contains_reg_of_mode.\n\nFrom-SVN: r39891", "tree": {"sha": "1d7194a25d4ae8c2f3424adef4d94faa89cfe0f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d7194a25d4ae8c2f3424adef4d94faa89cfe0f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6df26b8f231266faea12111fff34af007b1b4177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df26b8f231266faea12111fff34af007b1b4177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df26b8f231266faea12111fff34af007b1b4177", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df26b8f231266faea12111fff34af007b1b4177/comments", "author": null, "committer": null, "parents": [{"sha": "4a88a060b73ab6126d466ee119b967201a12dca4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a88a060b73ab6126d466ee119b967201a12dca4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a88a060b73ab6126d466ee119b967201a12dca4"}], "stats": {"total": 42, "additions": 31, "deletions": 11}, "files": [{"sha": "da7acf7151645703756ef7d752ceee1b4b74e970", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df26b8f231266faea12111fff34af007b1b4177/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df26b8f231266faea12111fff34af007b1b4177/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6df26b8f231266faea12111fff34af007b1b4177", "patch": "@@ -1,3 +1,11 @@\n+Mon Feb 19 16:47:39 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* regclass.c (contains_reg_of_mode): Make global.\n+\t(init_reg_sets): Remove contains_reg_of_mode; take into account\n+\tCLASS_MAX_NREGS when looking for the proper mode.\n+\t(dump_regclass): Dump only classes considered for the pseudo.\n+\t(regclass): Use contains_reg_of_mode.\n+\n Mon Feb 19 16:45:42 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.c (do_spec_1): 'n' for printing notices."}, {"sha": "7986a1ee8828912cff1283fffe017bd37c8a25be", "filename": "gcc/regclass.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df26b8f231266faea12111fff34af007b1b4177/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df26b8f231266faea12111fff34af007b1b4177/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=6df26b8f231266faea12111fff34af007b1b4177", "patch": "@@ -174,6 +174,10 @@ const char * reg_names[] = REGISTER_NAMES;\n \n enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n \n+/* 1 if class does contain register of given mode.  */\n+\n+static char contains_reg_of_mode [N_REG_CLASSES] [MAX_MACHINE_MODE];\n+\n /* Maximum cost of moving from a register in one class to a register in\n    another class.  Based on REGISTER_MOVE_COST.  */\n \n@@ -288,7 +292,6 @@ init_reg_sets_1 ()\n {\n   register unsigned int i, j;\n   register unsigned int /* enum machine_mode */ m;\n-  char contains_reg_of_mode [N_REG_CLASSES] [MAX_MACHINE_MODE];\n   char allocatable_regs_of_mode [MAX_MACHINE_MODE];\n \n   /* This macro allows the fixed or call-used registers\n@@ -429,14 +432,15 @@ init_reg_sets_1 ()\n   memset (allocatable_regs_of_mode, 0, sizeof (allocatable_regs_of_mode));\n   for (m = 0; m < MAX_MACHINE_MODE; m++)\n     for (i = 0; i < N_REG_CLASSES; i++)\n-      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (!fixed_regs [j] && TEST_HARD_REG_BIT (reg_class_contents[i], j)\n-\t    && HARD_REGNO_MODE_OK (j, m))\n-\t   {\n-\t     contains_reg_of_mode [i][m] = 1;\n-\t     allocatable_regs_of_mode [m] = 1;\n-\t     break;\n-\t   }\n+      if (CLASS_MAX_NREGS (i, m) <= reg_class_size[i])\n+\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\t  if (!fixed_regs [j] && TEST_HARD_REG_BIT (reg_class_contents[i], j)\n+\t      && HARD_REGNO_MODE_OK (j, m))\n+\t     {\n+\t       contains_reg_of_mode [i][m] = 1;\n+\t       allocatable_regs_of_mode [m] = 1;\n+\t       break;\n+\t     }\n \n   /* Initialize the move cost table.  Find every subset of each class\n      and take the maximum cost of moving any subset to any other.  */\n@@ -860,6 +864,15 @@ dump_regclass (dump)\n \t{\n \t  fprintf (dump, \"  Register %i costs:\", i);\n \t  for (class = 0; class < N_REG_CLASSES; class++)\n+\t    if (contains_reg_of_mode [class][PSEUDO_REGNO_MODE (i)]\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\t\t&& (!in_inc_dec[i] || !forbidden_inc_dec_class[class])\n+#endif\n+#ifdef CLASS_CANNOT_CHANGE_MODE\n+\t\t&& (!REGNO_REG_SET_P (reg_changes_mode, i)\n+\t\t     || class_can_change_mode [class])\n+#endif\n+\t\t)\n \t    fprintf (dump, \" %s:%i\", reg_class_names[(int) class],\n \t\t     costs[i].cost[class]);\n \t  fprintf (dump, \" MEM:%i\\n\", costs[i].mem_cost);\n@@ -1224,8 +1237,7 @@ regclass (f, nregs, dump)\n \t    {\n \t      /* Ignore classes that are too small for this operand or\n \t\t invalid for a operand that was auto-incremented.  */\n-\t      if (CLASS_MAX_NREGS (class, PSEUDO_REGNO_MODE (i))\n-\t\t  > reg_class_size[class]\n+\t      if (!contains_reg_of_mode [class][PSEUDO_REGNO_MODE (i)]\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t\t  || (in_inc_dec[i] && forbidden_inc_dec_class[class])\n #endif"}]}