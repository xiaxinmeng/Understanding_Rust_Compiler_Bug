{"sha": "07a6e20be91fb7d10ade34cf5c8edb07efdc80ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdhNmUyMGJlOTFmYjdkMTBhZGUzNGNmNWM4ZWRiMDdlZmRjODBhZQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-27T22:09:02Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-27T22:09:02Z"}, "message": "stl_alloc.h: Deprecate all 'reallocate' memfns.\n\n2002-06-27  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/bits/stl_alloc.h:  Deprecate all 'reallocate' memfns.\n\t* docs/html/ext/howto.html:  Update allocator notes.\n\nFrom-SVN: r55044", "tree": {"sha": "d4bc2a1315ba9d97d61eae7add9079a2636a2727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4bc2a1315ba9d97d61eae7add9079a2636a2727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae/comments", "author": null, "committer": null, "parents": [{"sha": "5ce49b4b08490bb2dc9a8f669fcc145a344cd73d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce49b4b08490bb2dc9a8f669fcc145a344cd73d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ce49b4b08490bb2dc9a8f669fcc145a344cd73d"}], "stats": {"total": 515, "additions": 273, "deletions": 242}, "files": [{"sha": "39da71a4ae552735adcc663d91c71be1f04875c5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=07a6e20be91fb7d10ade34cf5c8edb07efdc80ae", "patch": "@@ -1,3 +1,8 @@\n+2002-06-27  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/bits/stl_alloc.h:  Deprecate all 'reallocate' memfns.\n+\t* docs/html/ext/howto.html:  Update allocator notes.\n+\n 2002-06-26  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* configure.in (INTERFACE): Remove."}, {"sha": "d5755c6cd678992833cc1c2e44c4b869670e2fd7", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=07a6e20be91fb7d10ade34cf5c8edb07efdc80ae", "patch": "@@ -37,7 +37,8 @@ <h1>Contents</h1>\n <ul>\n    <li><a href=\"#1\">Ropes and trees and hashes, oh my!</a>\n    <li><a href=\"#2\">Added members and types</a>\n-   <li><a href=\"#3\">Allocators</a>\n+   <li><a href=\"#3\">Allocators (versions 3.0, 3.1, 3.2)</a>\n+   <li><a href=\"#6\">Allocators (version 3.3)</a>\n    <li><a href=\"#4\">Compile-time checks</a>\n    <li><a href=\"#5\">LWG Issues</a>\n </ul>\n@@ -154,7 +155,7 @@ <h2><a name=\"2\">Added members and types</a></h2>\n    </p>\n \n <hr>\n-<h2><a name=\"3\">Allocators</a></h2>\n+<h2><a name=\"3\">Allocators (versions 3.0, 3.1, 3.2)</a></h2>\n    <p>Thread-safety, space efficiency, high speed, portability... this is a\n       mess.  Where to begin?\n    </p>\n@@ -220,17 +221,18 @@ <h3>Problems and Possibilities</h3>\n    </p>\n    <h3>Available allocators in namespace std</h3>\n    <p>First I'll describe the situation as it exists for the code which\n-      was released in GCC 3.1.  Then I'll\n-      describe the differences for 3.0.x, which will not change much in\n-      this respect.\n+      was released in GCC 3.1 and 3.2.  Then I'll describe the differences\n+      for 3.0.  The allocator classes also have source documentation,\n+      which is described <a href=\"../documentation.html#4\">here</a> (you\n+      will need to retrieve the maintainer-level docs, as almost none of\n+      these entities are in the ISO standard).\n    </p>\n    <p>As a general rule of thumb, users are not allowed to use names which\n       begin with an underscore.  This means that to be portable between\n       compilers, none of the following may be used in your program directly.\n       (If you decide to be unportable, then you're free do do what you want,\n       but it's not our fault if stuff breaks.)  They are presented here for\n-      information for maintainers and contributors in addition to users, but\n-      we will probably make them available for users in 3.2 somehow.\n+      information for maintainers and contributors in addition to users.\n    </p>\n    <p>These classes are always available:\n      <ul>\n@@ -301,7 +303,7 @@ <h3>A cannon to swat a fly:<code>  __USE_MALLOC</code></h3>\n      <li><code>__single_client_alloc</code> are all typedef'd to\n          <code>__malloc_alloc_template</code>.\n      <li><code>__default_alloc_template</code> is no longer available.\n-         At all.  Anywhere.  <!-- might change? -->\n+         At all.  Anywhere.\n      </ol>\n    </p>\n    <h3>Writing your own allocators</h3>\n@@ -359,7 +361,13 @@ <h3>3.0.x</h3>\n       can affect the 3.0.x allocators.  Do not use them.  Those macros have\n       been completely removed for 3.1.\n    </p>\n-   <p>More notes as we remember them...\n+   <p>Return <a href=\"#top\">to top of page</a> or\n+      <a href=\"../faq/index.html\">to the FAQ</a>.\n+   </p>\n+\n+<hr>\n+<h2><a name=\"6\">Allocators (version 3.3)</a></h2>\n+   <p>Changes are coming...\n    </p>\n    <p>Return <a href=\"#top\">to top of page</a> or\n       <a href=\"../faq/index.html\">to the FAQ</a>.\n@@ -540,6 +548,7 @@ <h2><a name=\"5\">LWG Issues</a></h2>\n    </dl></p>\n    <p>Return <a href=\"#top\">to top of page</a> or\n       <a href=\"../faq/index.html\">to the FAQ</a>.\n+   </p>\n \n \n <!-- ####################################################### -->"}, {"sha": "9030fcd942f97419e5295e321f1a5692b56b3fe2", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 250, "deletions": 233, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a6e20be91fb7d10ade34cf5c8edb07efdc80ae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=07a6e20be91fb7d10ade34cf5c8edb07efdc80ae", "patch": "@@ -74,6 +74,10 @@\n  *  into a \"standard\" one.\n  *  @endif\n  *\n+ *  @note The @c reallocate member functions have been deprecated for 3.2\n+ *        and will be removed in 3.3.  You must define @c _GLIBCPP_DEPRECATED\n+ *        to make this visible in 3.2; see c++config.h.\n+ *\n  *  The canonical description of these classes is in docs/html/ext/howto.html\n  *  or online at http://gcc.gnu.org/onlinedocs/libstdc++/ext/howto.html#3\n */\n@@ -101,7 +105,7 @@ namespace std\n     static void*\n     allocate(size_t __n)\n     { return ::operator new(__n); }\n-    \n+\n     static void\n     deallocate(void* __p, size_t)\n     { ::operator delete(__p); }\n@@ -122,36 +126,40 @@ namespace std\n     {\n     private:\n       static void* _S_oom_malloc(size_t);\n+#ifdef _GLIBCPP_DEPRECATED\n       static void* _S_oom_realloc(void*, size_t);\n+#endif\n       static void (* __malloc_alloc_oom_handler)();\n \n     public:\n       static void*\n       allocate(size_t __n)\n       {\n-\tvoid* __result = malloc(__n);\n-\tif (0 == __result) __result = _S_oom_malloc(__n);\n-\treturn __result;\n+        void* __result = malloc(__n);\n+        if (0 == __result) __result = _S_oom_malloc(__n);\n+        return __result;\n       }\n-      \n+\n       static void\n       deallocate(void* __p, size_t /* __n */)\n       { free(__p); }\n-      \n+\n+#ifdef _GLIBCPP_DEPRECATED\n       static void*\n       reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)\n       {\n-\tvoid* __result = realloc(__p, __new_sz);\n-\tif (0 == __result) \n-\t  __result = _S_oom_realloc(__p, __new_sz);\n-\treturn __result;\n+        void* __result = realloc(__p, __new_sz);\n+        if (0 == __result)\n+          __result = _S_oom_realloc(__p, __new_sz);\n+        return __result;\n       }\n+#endif\n \n       static void (* __set_malloc_handler(void (*__f)()))()\n       {\n-\tvoid (* __old)() = __malloc_alloc_oom_handler;\n-\t__malloc_alloc_oom_handler = __f;\n-\treturn(__old);\n+        void (* __old)() = __malloc_alloc_oom_handler;\n+        __malloc_alloc_oom_handler = __f;\n+        return(__old);\n       }\n     };\n \n@@ -161,42 +169,45 @@ namespace std\n \n   template<int __inst>\n     void*\n-    __malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)\n+    __malloc_alloc_template<__inst>::\n+    _S_oom_malloc(size_t __n)\n     {\n       void (* __my_malloc_handler)();\n       void* __result;\n-      \n+\n       for (;;)\n-\t{\n-\t  __my_malloc_handler = __malloc_alloc_oom_handler;\n-\t  if (0 == __my_malloc_handler)\n+        {\n+          __my_malloc_handler = __malloc_alloc_oom_handler;\n+          if (0 == __my_malloc_handler)\n           std::__throw_bad_alloc();\n-\t  (*__my_malloc_handler)();\n-\t  __result = malloc(__n);\n-\t  if (__result)\n-\t    return(__result);\n-\t}\n+          (*__my_malloc_handler)();\n+          __result = malloc(__n);\n+          if (__result)\n+            return(__result);\n+        }\n     }\n-  \n+\n+#ifdef _GLIBCPP_DEPRECATED\n   template<int __inst>\n-  void*\n-  __malloc_alloc_template<__inst>::\n-  _S_oom_realloc(void* __p, size_t __n)\n-  {\n-    void (* __my_malloc_handler)();\n-    void* __result;\n+    void*\n+    __malloc_alloc_template<__inst>::\n+    _S_oom_realloc(void* __p, size_t __n)\n+    {\n+      void (* __my_malloc_handler)();\n+      void* __result;\n \n-    for (;;)\n-      {\n-        __my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == __my_malloc_handler)\n-          std::__throw_bad_alloc();\n-        (*__my_malloc_handler)();\n-        __result = realloc(__p, __n);\n-        if (__result)\n-          return(__result);\n-      }\n-  }\n+      for (;;)\n+        {\n+          __my_malloc_handler = __malloc_alloc_oom_handler;\n+          if (0 == __my_malloc_handler)\n+            std::__throw_bad_alloc();\n+          (*__my_malloc_handler)();\n+          __result = realloc(__p, __n);\n+          if (__result)\n+            return(__result);\n+        }\n+    }\n+#endif\n \n \n   // Determines the underlying allocator choice for the node allocator.\n@@ -259,41 +270,43 @@ namespace std\n     private:\n       // Size of space used to store size.  Note that this must be\n       // large enough to preserve alignment.\n-      enum {_S_extra = 8};  \n+      enum {_S_extra = 8};\n \n     public:\n       static void*\n       allocate(size_t __n)\n       {\n-\tchar* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);\n-\t*(size_t*)__result = __n;\n-\treturn __result + (int) _S_extra;\n+        char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);\n+        *(size_t*)__result = __n;\n+        return __result + (int) _S_extra;\n       }\n-      \n+\n       static void\n       deallocate(void* __p, size_t __n)\n       {\n-\tchar* __real_p = (char*)__p - (int) _S_extra;\n-\tassert(*(size_t*)__real_p == __n);\n-\t_Alloc::deallocate(__real_p, __n + (int) _S_extra);\n+        char* __real_p = (char*)__p - (int) _S_extra;\n+        assert(*(size_t*)__real_p == __n);\n+        _Alloc::deallocate(__real_p, __n + (int) _S_extra);\n       }\n-      \n+\n+#ifdef _GLIBCPP_DEPRECATED\n       static void*\n       reallocate(void* __p, size_t __old_sz, size_t __new_sz)\n       {\n-\tchar* __real_p = (char*)__p - (int) _S_extra;\n-\tassert(*(size_t*)__real_p == __old_sz);\n-\tchar* __result = (char*)\n-\t  _Alloc::reallocate(__real_p, __old_sz + (int) _S_extra,\n-\t\t\t     __new_sz + (int) _S_extra);\n-\t*(size_t*)__result = __new_sz;\n-\treturn __result + (int) _S_extra;\n+        char* __real_p = (char*)__p - (int) _S_extra;\n+        assert(*(size_t*)__real_p == __old_sz);\n+        char* __result = (char*)\n+          _Alloc::reallocate(__real_p, __old_sz + (int) _S_extra,\n+                             __new_sz + (int) _S_extra);\n+        *(size_t*)__result = __new_sz;\n+        return __result + (int) _S_extra;\n       }\n+#endif\n     };\n-  \n-  \n+\n+\n #ifdef __USE_MALLOC\n-  \n+\n   typedef __mem_interface __alloc;\n   typedef __mem_interface __single_client_alloc;\n \n@@ -336,114 +349,116 @@ namespace std\n       enum {_ALIGN = 8};\n       enum {_MAX_BYTES = 128};\n       enum {_NFREELISTS = _MAX_BYTES / _ALIGN};\n-      \n+\n       union _Obj\n       {\n-\tunion _Obj* _M_free_list_link;\n-\tchar        _M_client_data[1];    // The client sees this.\n+        union _Obj* _M_free_list_link;\n+        char        _M_client_data[1];    // The client sees this.\n       };\n-      \n+\n       static _Obj* volatile         _S_free_list[_NFREELISTS];\n-      \n+\n       // Chunk allocation state.\n       static char*                  _S_start_free;\n       static char*                  _S_end_free;\n       static size_t                 _S_heap_size;\n-      \n+\n       static _STL_mutex_lock        _S_node_allocator_lock;\n-      \n+\n       static size_t\n       _S_round_up(size_t __bytes)\n       { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }\n-      \n+\n       static size_t\n       _S_freelist_index(size_t __bytes)\n       { return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); }\n-      \n+\n       // Returns an object of size __n, and optionally adds to size __n\n       // free list.\n       static void*\n       _S_refill(size_t __n);\n-      \n+\n       // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n       // if it is inconvenient to allocate the requested number.\n       static char*\n       _S_chunk_alloc(size_t __size, int& __nobjs);\n-      \n+\n       // It would be nice to use _STL_auto_lock here.  But we need a\n       // test whether threads are in use.\n       struct _Lock\n       {\n-\t_Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }\n-\t~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }\n+        _Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }\n+        ~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }\n       } __attribute__ ((__unused__));\n       friend struct _Lock;\n-      \n+\n     public:\n       // __n must be > 0\n       static void*\n       allocate(size_t __n)\n       {\n-\tvoid* __ret = 0;\n-\t\n-\tif (__n > (size_t) _MAX_BYTES)\n-\t  __ret = __mem_interface::allocate(__n);\n-\telse\n-\t  {\n-\t    _Obj* volatile* __my_free_list = _S_free_list \n-\t                                     + _S_freelist_index(__n);\n-\t    // Acquire the lock here with a constructor call.  This\n-\t    // ensures that it is released in exit or during stack\n-\t    // unwinding.\n-\t    _Lock __lock_instance;\n-\t    _Obj* __restrict__ __result = *__my_free_list;\n-\t    if (__result == 0)\n-\t      __ret = _S_refill(_S_round_up(__n));\n-\t    else\n-\t      {\n-\t\t*__my_free_list = __result -> _M_free_list_link;\n-\t\t__ret = __result;\n-\t      }\n-\t  }\n-\treturn __ret;\n+        void* __ret = 0;\n+\n+        if (__n > (size_t) _MAX_BYTES)\n+          __ret = __mem_interface::allocate(__n);\n+        else\n+          {\n+            _Obj* volatile* __my_free_list = _S_free_list\n+                                             + _S_freelist_index(__n);\n+            // Acquire the lock here with a constructor call.  This\n+            // ensures that it is released in exit or during stack\n+            // unwinding.\n+            _Lock __lock_instance;\n+            _Obj* __restrict__ __result = *__my_free_list;\n+            if (__result == 0)\n+              __ret = _S_refill(_S_round_up(__n));\n+            else\n+              {\n+                *__my_free_list = __result -> _M_free_list_link;\n+                __ret = __result;\n+              }\n+          }\n+        return __ret;\n       };\n-      \n+\n       // __p may not be 0\n       static void\n       deallocate(void* __p, size_t __n)\n       {\n-\tif (__n > (size_t) _MAX_BYTES)\n-\t  __mem_interface::deallocate(__p, __n);\n-\telse\n-\t  {\n-\t    _Obj* volatile*  __my_free_list = _S_free_list \n-\t      + _S_freelist_index(__n);\n-\t    _Obj* __q = (_Obj*)__p;\n-\t    \n-\t    // Acquire the lock here with a constructor call.  This\n-\t    // ensures that it is released in exit or during stack\n-\t    // unwinding.\n-\t    _Lock __lock_instance;\n-\t    __q -> _M_free_list_link = *__my_free_list;\n-\t    *__my_free_list = __q;\n-\t  }\n+        if (__n > (size_t) _MAX_BYTES)\n+          __mem_interface::deallocate(__p, __n);\n+        else\n+          {\n+            _Obj* volatile*  __my_free_list = _S_free_list\n+              + _S_freelist_index(__n);\n+            _Obj* __q = (_Obj*)__p;\n+\n+            // Acquire the lock here with a constructor call.  This\n+            // ensures that it is released in exit or during stack\n+            // unwinding.\n+            _Lock __lock_instance;\n+            __q -> _M_free_list_link = *__my_free_list;\n+            *__my_free_list = __q;\n+          }\n       }\n-      \n+\n+#ifdef _GLIBCPP_DEPRECATED\n       static void*\n       reallocate(void* __p, size_t __old_sz, size_t __new_sz);\n+#endif\n     };\n \n-  \n+\n   template<bool __threads, int __inst>\n     inline bool\n     operator==(const __default_alloc_template<__threads,__inst>&,\n-\t       const __default_alloc_template<__threads,__inst>&)\n+               const __default_alloc_template<__threads,__inst>&)\n     { return true; }\n \n   template<bool __threads, int __inst>\n     inline bool\n     operator!=(const __default_alloc_template<__threads,__inst>&,\n-\t       const __default_alloc_template<__threads,__inst>&)\n+               const __default_alloc_template<__threads,__inst>&)\n     { return false; }\n \n \n@@ -458,69 +473,69 @@ namespace std\n       char* __result;\n       size_t __total_bytes = __size * __nobjs;\n       size_t __bytes_left = _S_end_free - _S_start_free;\n-      \n+\n       if (__bytes_left >= __total_bytes)\n-\t{\n-\t  __result = _S_start_free;\n-\t  _S_start_free += __total_bytes;\n-\t  return(__result);\n-\t}\n+        {\n+          __result = _S_start_free;\n+          _S_start_free += __total_bytes;\n+          return(__result);\n+        }\n       else if (__bytes_left >= __size)\n-\t{\n-\t  __nobjs = (int)(__bytes_left/__size);\n-\t  __total_bytes = __size * __nobjs;\n-\t  __result = _S_start_free;\n-\t  _S_start_free += __total_bytes;\n-\t  return(__result);\n-\t}\n+        {\n+          __nobjs = (int)(__bytes_left/__size);\n+          __total_bytes = __size * __nobjs;\n+          __result = _S_start_free;\n+          _S_start_free += __total_bytes;\n+          return(__result);\n+        }\n       else\n-\t{\n-\t  size_t __bytes_to_get =\n-\t    2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n-\t  // Try to make use of the left-over piece.\n-\t  if (__bytes_left > 0)\n-\t    {\n-\t      _Obj* volatile* __my_free_list =\n-\t\t_S_free_list + _S_freelist_index(__bytes_left);\n-\t      \n-\t      ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n-\t      *__my_free_list = (_Obj*)_S_start_free;\n-\t    }\n-\t  _S_start_free = (char*) __mem_interface::allocate(__bytes_to_get);\n-\t  if (0 == _S_start_free)\n-\t    {\n-\t      size_t __i;\n-\t      _Obj* volatile* __my_free_list;\n-\t      _Obj* __p;\n-\t      // Try to make do with what we have.  That can't hurt.  We\n-\t      // do not try smaller requests, since that tends to result\n-\t      // in disaster on multi-process machines.\n-\t      __i = __size;\n-\t      for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN)\n-\t\t{\n-\t\t  __my_free_list = _S_free_list + _S_freelist_index(__i);\n-\t\t  __p = *__my_free_list;\n-\t\t  if (0 != __p)\n-\t\t    {\n-\t\t      *__my_free_list = __p -> _M_free_list_link;\n-\t\t      _S_start_free = (char*)__p;\n-\t\t      _S_end_free = _S_start_free + __i;\n-\t\t      return(_S_chunk_alloc(__size, __nobjs));\n-\t\t      // Any leftover piece will eventually make it to the\n-\t\t      // right free list.\n-\t\t    }\n-\t\t}\n-\t      _S_end_free = 0;        // In case of exception.\n-\t      _S_start_free = (char*)__mem_interface::allocate(__bytes_to_get);\n-\t      // This should either throw an exception or remedy the situation.\n-\t      // Thus we assume it succeeded.\n-\t    }\n-\t  _S_heap_size += __bytes_to_get;\n-\t  _S_end_free = _S_start_free + __bytes_to_get;\n-\t  return(_S_chunk_alloc(__size, __nobjs));\n-\t}\n+        {\n+          size_t __bytes_to_get =\n+            2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n+          // Try to make use of the left-over piece.\n+          if (__bytes_left > 0)\n+            {\n+              _Obj* volatile* __my_free_list =\n+                _S_free_list + _S_freelist_index(__bytes_left);\n+\n+              ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n+              *__my_free_list = (_Obj*)_S_start_free;\n+            }\n+          _S_start_free = (char*) __mem_interface::allocate(__bytes_to_get);\n+          if (0 == _S_start_free)\n+            {\n+              size_t __i;\n+              _Obj* volatile* __my_free_list;\n+              _Obj* __p;\n+              // Try to make do with what we have.  That can't hurt.  We\n+              // do not try smaller requests, since that tends to result\n+              // in disaster on multi-process machines.\n+              __i = __size;\n+              for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN)\n+                {\n+                  __my_free_list = _S_free_list + _S_freelist_index(__i);\n+                  __p = *__my_free_list;\n+                  if (0 != __p)\n+                    {\n+                      *__my_free_list = __p -> _M_free_list_link;\n+                      _S_start_free = (char*)__p;\n+                      _S_end_free = _S_start_free + __i;\n+                      return(_S_chunk_alloc(__size, __nobjs));\n+                      // Any leftover piece will eventually make it to the\n+                      // right free list.\n+                    }\n+                }\n+              _S_end_free = 0;        // In case of exception.\n+              _S_start_free = (char*)__mem_interface::allocate(__bytes_to_get);\n+              // This should either throw an exception or remedy the situation.\n+              // Thus we assume it succeeded.\n+            }\n+          _S_heap_size += __bytes_to_get;\n+          _S_end_free = _S_start_free + __bytes_to_get;\n+          return(_S_chunk_alloc(__size, __nobjs));\n+        }\n     }\n-  \n+\n \n   // Returns an object of size __n, and optionally adds to \"size\n   // __n\"'s free list.  We assume that __n is properly aligned.  We\n@@ -536,48 +551,50 @@ namespace std\n       _Obj* __current_obj;\n       _Obj* __next_obj;\n       int __i;\n-      \n+\n       if (1 == __nobjs)\n-\treturn(__chunk);\n+        return(__chunk);\n       __my_free_list = _S_free_list + _S_freelist_index(__n);\n-      \n+\n       // Build free list in chunk.\n       __result = (_Obj*)__chunk;\n       *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);\n       for (__i = 1; ; __i++)\n-\t{\n-\t  __current_obj = __next_obj;\n-\t  __next_obj = (_Obj*)((char*)__next_obj + __n);\n-\t  if (__nobjs - 1 == __i)\n-\t    {\n-\t      __current_obj -> _M_free_list_link = 0;\n-\t      break;\n-\t    }\n-\t  else\n-\t    __current_obj -> _M_free_list_link = __next_obj;\n-\t}\n+        {\n+          __current_obj = __next_obj;\n+          __next_obj = (_Obj*)((char*)__next_obj + __n);\n+          if (__nobjs - 1 == __i)\n+            {\n+              __current_obj -> _M_free_list_link = 0;\n+              break;\n+            }\n+          else\n+            __current_obj -> _M_free_list_link = __next_obj;\n+        }\n       return(__result);\n     }\n-  \n \n+\n+#ifdef _GLIBCPP_DEPRECATED\n   template<bool threads, int inst>\n     void*\n     __default_alloc_template<threads, inst>::\n     reallocate(void* __p, size_t __old_sz, size_t __new_sz)\n     {\n       void* __result;\n       size_t __copy_sz;\n-      \n+\n       if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES)\n-\treturn(realloc(__p, __new_sz));\n+        return(realloc(__p, __new_sz));\n       if (_S_round_up(__old_sz) == _S_round_up(__new_sz))\n-\treturn(__p);\n+        return(__p);\n       __result = allocate(__new_sz);\n       __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n       memcpy(__result, __p, __copy_sz);\n       deallocate(__p, __old_sz);\n       return(__result);\n     }\n+#endif\n \n   template<bool __threads, int __inst>\n     _STL_mutex_lock\n@@ -630,40 +647,40 @@ namespace std\n       typedef _Tp&       reference;\n       typedef const _Tp& const_reference;\n       typedef _Tp        value_type;\n-      \n-      template<typename _Tp1> \n-        struct rebind \n-\t{ typedef allocator<_Tp1> other; };\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef allocator<_Tp1> other; };\n \n       allocator() throw() {}\n       allocator(const allocator&) throw() {}\n-      template<typename _Tp1> \n+      template<typename _Tp1>\n         allocator(const allocator<_Tp1>&) throw() {}\n       ~allocator() throw() {}\n-      \n-      pointer \n+\n+      pointer\n       address(reference __x) const { return &__x; }\n \n-      const_pointer \n+      const_pointer\n       address(const_reference __x) const { return &__x; }\n-      \n+\n       // __n is permitted to be 0.  The C++ standard says nothing about what\n       // the return value is when __n == 0.\n       _Tp*\n       allocate(size_type __n, const void* = 0)\n       {\n-\treturn __n != 0 \n-\t  ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) : 0;\n+        return __n != 0\n+          ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) : 0;\n       }\n \n       // __p is not permitted to be a null pointer.\n       void\n       deallocate(pointer __p, size_type __n)\n       { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n-      \n+\n       size_type\n       max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n-      \n+\n       void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n       void destroy(pointer __p) { __p->~_Tp(); }\n     };\n@@ -677,12 +694,12 @@ namespace std\n       typedef void*       pointer;\n       typedef const void* const_pointer;\n       typedef void        value_type;\n-      \n-      template<typename _Tp1> \n-        struct rebind \n+\n+      template<typename _Tp1>\n+        struct rebind\n         { typedef allocator<_Tp1> other; };\n     };\n-  \n+\n \n   template<typename _T1, typename _T2>\n     inline bool\n@@ -710,18 +727,18 @@ namespace std\n     struct __allocator\n     {\n       _Alloc __underlying_alloc;\n-      \n+\n       typedef size_t    size_type;\n       typedef ptrdiff_t difference_type;\n       typedef _Tp*       pointer;\n       typedef const _Tp* const_pointer;\n       typedef _Tp&       reference;\n       typedef const _Tp& const_reference;\n       typedef _Tp        value_type;\n-      \n-      template<typename _Tp1> \n-        struct rebind \n-\t{ typedef __allocator<_Tp1, _Alloc> other; };\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef __allocator<_Tp1, _Alloc> other; };\n \n       __allocator() throw() {}\n       __allocator(const __allocator& __a) throw()\n@@ -733,10 +750,10 @@ namespace std\n \n       ~__allocator() throw() {}\n \n-      pointer \n+      pointer\n       address(reference __x) const { return &__x; }\n \n-      const_pointer \n+      const_pointer\n       address(const_reference __x) const { return &__x; }\n \n     // __n is permitted to be 0.\n@@ -756,10 +773,10 @@ namespace std\n     size_type\n     max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n \n-    void \n+    void\n     construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n \n-    void \n+    void\n     destroy(pointer __p) { __p->~_Tp(); }\n   };\n \n@@ -771,22 +788,22 @@ namespace std\n       typedef void*       pointer;\n       typedef const void* const_pointer;\n       typedef void        value_type;\n-      \n-      template<typename _Tp1> \n-        struct rebind \n-\t{ typedef __allocator<_Tp1, _Alloc> other; };\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef __allocator<_Tp1, _Alloc> other; };\n     };\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator==(const __allocator<_Tp,_Alloc>& __a1,\n-\t       const __allocator<_Tp,_Alloc>& __a2)\n+               const __allocator<_Tp,_Alloc>& __a2)\n     { return __a1.__underlying_alloc == __a2.__underlying_alloc; }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator!=(const __allocator<_Tp, _Alloc>& __a1, \n-\t       const __allocator<_Tp, _Alloc>& __a2)\n+    operator!=(const __allocator<_Tp, _Alloc>& __a1,\n+               const __allocator<_Tp, _Alloc>& __a2)\n     { return __a1.__underlying_alloc != __a2.__underlying_alloc; }\n \n \n@@ -797,14 +814,14 @@ namespace std\n    */\n   template<int inst>\n     inline bool\n-    operator==(const __malloc_alloc_template<inst>&, \n-\t       const __malloc_alloc_template<inst>&)\n+    operator==(const __malloc_alloc_template<inst>&,\n+               const __malloc_alloc_template<inst>&)\n     { return true; }\n \n   template<int __inst>\n     inline bool\n-    operator!=(const __malloc_alloc_template<__inst>&, \n-\t       const __malloc_alloc_template<__inst>&)\n+    operator!=(const __malloc_alloc_template<__inst>&,\n+               const __malloc_alloc_template<__inst>&)\n     { return false; }\n \n   template<typename _Alloc>\n@@ -863,7 +880,7 @@ namespace std\n       static const bool _S_instanceless = false;\n       typedef typename _Allocator::template rebind<_Tp>::other allocator_type;\n     };\n-  \n+\n   template<typename _Tp, typename _Allocator>\n     const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;\n \n@@ -913,7 +930,7 @@ namespace std\n   /// \"SGI\" style allocators.\n   template<typename _Tp, typename _Tp1, int __inst>\n     struct _Alloc_traits<_Tp,\n-\t\t\t __allocator<_Tp1, __malloc_alloc_template<__inst> > >\n+                         __allocator<_Tp1, __malloc_alloc_template<__inst> > >\n     {\n       static const bool _S_instanceless = true;\n       typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;\n@@ -953,4 +970,4 @@ namespace std\n #endif\n } // namespace std\n \n-#endif \n+#endif"}]}