{"sha": "0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJhMWIyZmYwZmUxZjNiZmQxM2NhNzJjZTA5NzM2ZDY1ZWQ0NWM2Yw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2002-07-24T07:53:36Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2002-07-24T07:53:36Z"}, "message": "rs6000-protos.h (mask_operand_wrap): Declare.\n\n\t* config/rs6000/rs6000-protos.h (mask_operand_wrap): Declare.\n\t(mask64_2_operand): Declare.\n\t(build_mask64_2_operands): Declare.\n\t(and64_2_operand): Declare.\n\t(extract_MB): Declare.\n\t(extract_ME): Declare.\n\t* config/rs6000/rs6000.c (mask64_operand): Allow all ones.  Remove\n\tCONST_DOUBLE code.\n\t(mask_operand_wrap): New insn predicate.\n\t(mask64_2_operand): Likewise.\n\t(and64_2_operand): Likewise.\n\t(build_mask64_2_operands): New function.\n\t(extract_MB): New function.\n\t(extract_ME): New function.\n\t(print_operand <case m,M>): Use extract_MB and extract_ME.\n\t(print_operand <case S>): Allow all ones.  Remove CONST_DOUBLE support.\n\t* config/rs6000/rs6000.h (EXTRA_CONSTRAINT): Add 't'.\n\t(PREDICATE_CODES): Add and64_2_operand, mask_operand_wrap and\n\tmask64_2_operand.  Remove CONST_DOUBLE from mask64_operand.\n\t* config/rs6000/rs6000.md (andsi3_internal3): New\n\t(andsi3_internal3+1): Enable split for powerpc64.\n\t(andsi3_internal3+2): New split.\n\t(andsi3_internal4): Renamed old andsi3_internal3.\n\t(andsi3_internal5): New.\n\t(andsi3_internal5+1): Enable split for powerpc64.\n\t(andsi3_internal5+2): New split.\n\t(andsi3_internal6, andsi3_internal7, andsi3_internal8): New.\n\t(anddi3): Handle 't' constraint.\n\t(anddi3+1): New split.\n\t(anddi3_internal2): Handle 't' constraint.\n\t(anddi3_internal2+1): New split.\n\t(anddi3_internal3): Handle 't' constraint.\n\t(anddi3_internal3+1): New split.\n\nFrom-SVN: r55701", "tree": {"sha": "c58a37939b81063b875e3b312c25c7611f592ae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c58a37939b81063b875e3b312c25c7611f592ae2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/comments", "author": null, "committer": null, "parents": [{"sha": "956301631b8951e9a759a86271e5c280c5f172fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956301631b8951e9a759a86271e5c280c5f172fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956301631b8951e9a759a86271e5c280c5f172fd"}], "stats": {"total": 748, "additions": 576, "deletions": 172}, "files": [{"sha": "540409a74d441fbd77638bd4ef47ac410adda60d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "patch": "@@ -1,3 +1,39 @@\n+2002-07-24  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000-protos.h (mask_operand_wrap): Declare.\n+\t(mask64_2_operand): Declare.\n+\t(build_mask64_2_operands): Declare.\n+\t(and64_2_operand): Declare.\n+\t(extract_MB): Declare.\n+\t(extract_ME): Declare.\n+\t* config/rs6000/rs6000.c (mask64_operand): Allow all ones.  Remove\n+\tCONST_DOUBLE code.\n+\t(mask_operand_wrap): New insn predicate.\n+\t(mask64_2_operand): Likewise.\n+\t(and64_2_operand): Likewise.\n+\t(build_mask64_2_operands): New function.\n+\t(extract_MB): New function.\n+\t(extract_ME): New function.\n+\t(print_operand <case m,M>): Use extract_MB and extract_ME.\n+\t(print_operand <case S>): Allow all ones.  Remove CONST_DOUBLE support.\n+\t* config/rs6000/rs6000.h (EXTRA_CONSTRAINT): Add 't'.\n+\t(PREDICATE_CODES): Add and64_2_operand, mask_operand_wrap and\n+\tmask64_2_operand.  Remove CONST_DOUBLE from mask64_operand.\n+\t* config/rs6000/rs6000.md (andsi3_internal3): New\n+\t(andsi3_internal3+1): Enable split for powerpc64.\n+\t(andsi3_internal3+2): New split.\n+\t(andsi3_internal4): Renamed old andsi3_internal3.\n+\t(andsi3_internal5): New.\n+\t(andsi3_internal5+1): Enable split for powerpc64.\n+\t(andsi3_internal5+2): New split.\n+\t(andsi3_internal6, andsi3_internal7, andsi3_internal8): New.\n+\t(anddi3): Handle 't' constraint.\n+\t(anddi3+1): New split.\n+\t(anddi3_internal2): Handle 't' constraint.\n+\t(anddi3_internal2+1): New split.\n+\t(anddi3_internal3): Handle 't' constraint.\n+\t(anddi3_internal3+1): New split.\n+\n 2002-07-24  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.md: Remove scratch reg on insns using"}, {"sha": "652cfb9f40ad1f2839d9448133e963a84c938e4c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "patch": "@@ -64,8 +64,12 @@ extern int non_add_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int non_logical_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int logical_operand PARAMS ((rtx, enum machine_mode));\n extern int mask_operand PARAMS ((rtx, enum machine_mode));\n+extern int mask_operand_wrap PARAMS ((rtx, enum machine_mode));\n extern int mask64_operand PARAMS ((rtx, enum machine_mode));\n+extern int mask64_2_operand PARAMS ((rtx, enum machine_mode));\n+extern void build_mask64_2_operands PARAMS ((rtx, rtx *));\n extern int and64_operand PARAMS ((rtx, enum machine_mode));\n+extern int and64_2_operand PARAMS ((rtx, enum machine_mode));\n extern int and_operand PARAMS ((rtx, enum machine_mode));\n extern int count_register_operand PARAMS ((rtx, enum machine_mode));\n extern int xer_operand PARAMS ((rtx, enum machine_mode));\n@@ -98,6 +102,8 @@ extern int addrs_ok_for_quad_peep PARAMS ((rtx, rtx));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t      enum machine_mode, rtx));\n extern int ccr_bit PARAMS ((rtx, int));\n+extern int extract_MB PARAMS ((rtx));\n+extern int extract_ME PARAMS ((rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern enum rtx_code rs6000_reverse_condition PARAMS ((enum machine_mode,"}, {"sha": "dbb1dee253dd9491ba483ea004ddce3b9ba4d26c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 260, "deletions": 147, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "patch": "@@ -1496,64 +1496,185 @@ mask_operand (op, mode)\n   return c == -lsb;\n }\n \n+/* Return 1 for the PowerPC64 rlwinm corner case.  */\n+\n+int\n+mask_operand_wrap (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  HOST_WIDE_INT c, lsb;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  c = INTVAL (op);\n+\n+  if ((c & 0x80000001) != 0x80000001)\n+    return 0;\n+\n+  c = ~c;\n+  if (c == 0)\n+    return 0;\n+\n+  lsb = c & -c;\n+  c = ~c;\n+  c &= -lsb;\n+  lsb = c & -c;\n+  return c == -lsb;\n+}\n+\n /* Return 1 if the operand is a constant that is a PowerPC64 mask.\n    It is if there are no more than one 1->0 or 0->1 transitions.\n-   Reject all ones and all zeros, since these should have been optimized\n-   away and confuse the making of MB and ME.  */\n+   Reject all zeros, since zero should have been optimized away and\n+   confuses the making of MB and ME.  */\n \n int\n mask64_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n       HOST_WIDE_INT c, lsb;\n \n-      /* We don't change the number of transitions by inverting,\n-\t so make sure we start with the LS bit zero.  */\n       c = INTVAL (op);\n-      if (c & 1)\n-\tc = ~c;\n \n-      /* Reject all zeros or all ones.  */\n+      /* Reject all zeros.  */\n       if (c == 0)\n \treturn 0;\n \n+      /* We don't change the number of transitions by inverting,\n+\t so make sure we start with the LS bit zero.  */\n+      if (c & 1)\n+\tc = ~c;\n+\n       /* Find the transition, and check that all bits above are 1's.  */\n       lsb = c & -c;\n       return c == -lsb;\n     }\n-  else if (GET_CODE (op) == CONST_DOUBLE\n-\t   && (mode == VOIDmode || mode == DImode))\n+  return 0;\n+}\n+\n+/* Like mask64_operand, but allow up to three transitions.  This\n+   predicate is used by insn patterns that generate two rldicl or\n+   rldicr machine insns.  */\n+\n+int\n+mask64_2_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n     {\n-      HOST_WIDE_INT low, high, lsb;\n+      HOST_WIDE_INT c, lsb;\n \n-      if (HOST_BITS_PER_WIDE_INT < 64)\n-\thigh = CONST_DOUBLE_HIGH (op);\n+      c = INTVAL (op);\n \n-      low = CONST_DOUBLE_LOW (op);\n-      if (low & 1)\n-\t{\n-\t  if (HOST_BITS_PER_WIDE_INT < 64)\n-\t    high = ~high;\n-\t  low = ~low;\n-\t}\n+      /* Disallow all zeros.  */\n+      if (c == 0)\n+\treturn 0;\n \n-      if (low == 0)\n-\t{\n-\t  if (HOST_BITS_PER_WIDE_INT >= 64 || high == 0)\n-\t    return 0;\n+      /* We don't change the number of transitions by inverting,\n+\t so make sure we start with the LS bit zero.  */\n+      if (c & 1)\n+\tc = ~c;\n \n-\t  lsb = high & -high;\n-\t  return high == -lsb;\n-\t}\n+      /* Find the first transition.  */\n+      lsb = c & -c;\n \n-      lsb = low & -low;\n-      return low == -lsb && (HOST_BITS_PER_WIDE_INT >= 64 || high == ~0);\n+      /* Invert to look for a second transition.  */\n+      c = ~c;\n+\n+      /* Erase first transition.  */\n+      c &= -lsb;\n+\n+      /* Find the second transition.  */\n+      lsb = c & -c;\n+\n+      /* Invert to look for a third transition.  */\n+      c = ~c;\n+\n+      /* Erase second transition.  */\n+      c &= -lsb;\n+\n+      /* Find the third transition (if any).  */\n+      lsb = c & -c;\n+\n+      /* Match if all the bits above are 1's (or c is zero).  */\n+      return c == -lsb;\n+    }\n+  return 0;\n+}\n+\n+/* Generates shifts and masks for a pair of rldicl or rldicr insns to\n+   implement ANDing by the mask IN.  */\n+void\n+build_mask64_2_operands (in, out)\n+     rtx in;\n+     rtx *out;\n+{\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  unsigned HOST_WIDE_INT c, lsb, m1, m2;\n+  int shift;\n+\n+  if (GET_CODE (in) != CONST_INT)\n+    abort ();\n+\n+  c = INTVAL (in);\n+  if (c & 1)\n+    {\n+      /* Assume c initially something like 0x00fff000000fffff.  The idea\n+\t is to rotate the word so that the middle ^^^^^^ group of zeros\n+\t is at the MS end and can be cleared with an rldicl mask.  We then\n+\t rotate back and clear off the MS    ^^ group of zeros with a\n+\t second rldicl.  */\n+      c = ~c;\t\t\t/*   c == 0xff000ffffff00000 */\n+      lsb = c & -c;\t\t/* lsb == 0x0000000000100000 */\n+      m1 = -lsb;\t\t/*  m1 == 0xfffffffffff00000 */\n+      c = ~c;\t\t\t/*   c == 0x00fff000000fffff */\n+      c &= -lsb;\t\t/*   c == 0x00fff00000000000 */\n+      lsb = c & -c;\t\t/* lsb == 0x0000100000000000 */\n+      c = ~c;\t\t\t/*   c == 0xff000fffffffffff */\n+      c &= -lsb;\t\t/*   c == 0xff00000000000000 */\n+      shift = 0;\n+      while ((lsb >>= 1) != 0)\n+\tshift++;\t\t/* shift == 44 on exit from loop */\n+      m1 <<= 64 - shift;\t/*  m1 == 0xffffff0000000000 */\n+      m1 = ~m1;\t\t\t/*  m1 == 0x000000ffffffffff */\n+      m2 = ~c;\t\t\t/*  m2 == 0x00ffffffffffffff */\n     }\n   else\n-    return 0;\n+    {\n+      /* Assume c initially something like 0xff000f0000000000.  The idea\n+\t is to rotate the word so that the     ^^^  middle group of zeros\n+\t is at the LS end and can be cleared with an rldicr mask.  We then\n+\t rotate back and clear off the LS group of ^^^^^^^^^^ zeros with\n+\t a second rldicr.  */\n+      lsb = c & -c;\t\t/* lsb == 0x0000010000000000 */\n+      m2 = -lsb;\t\t/*  m2 == 0xffffff0000000000 */\n+      c = ~c;\t\t\t/*   c == 0x00fff0ffffffffff */\n+      c &= -lsb;\t\t/*   c == 0x00fff00000000000 */\n+      lsb = c & -c;\t\t/* lsb == 0x0000100000000000 */\n+      c = ~c;\t\t\t/*   c == 0xff000fffffffffff */\n+      c &= -lsb;\t\t/*   c == 0xff00000000000000 */\n+      shift = 0;\n+      while ((lsb >>= 1) != 0)\n+\tshift++;\t\t/* shift == 44 on exit from loop */\n+      m1 = ~c;\t\t\t/*  m1 == 0x00ffffffffffffff */\n+      m1 >>= shift;\t\t/*  m1 == 0x0000000000000fff */\n+      m1 = ~m1;\t\t\t/*  m1 == 0xfffffffffffff000 */\n+    }\n+\n+  /* Note that when we only have two 0->1 and 1->0 transitions, one of the\n+     masks will be all 1's.  We are guaranteed more than one transition.  */\n+  out[0] = GEN_INT (64 - shift);\n+  out[1] = GEN_INT (m1);\n+  out[2] = GEN_INT (shift);\n+  out[3] = GEN_INT (m2);\n+#else\n+  abort ();\n+#endif\n }\n \n /* Return 1 if the operand is either a non-special register or a constant\n@@ -1570,6 +1691,20 @@ and64_operand (op, mode)\n   return (logical_operand (op, mode) || mask64_operand (op, mode));\n }\n \n+/* Like the above, but also match constants that can be implemented\n+   with two rldicl or rldicr insns.  */\n+\n+int\n+and64_2_operand (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis. */\n+    return gpc_reg_operand (op, mode) || mask64_2_operand (op, mode);\n+\n+  return logical_operand (op, mode) || mask64_2_operand (op, mode);\n+}\n+\n /* Return 1 if the operand is either a non-special register or a\n    constant that can be used as the operand of an RS/6000 logical AND insn.  */\n \n@@ -6056,6 +6191,83 @@ rs6000_init_machine_status ()\n   return ggc_alloc_cleared (sizeof (machine_function));\n }\n \f\n+/* These macros test for integers and extract the low-order bits.  */\n+#define INT_P(X)  \\\n+((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)\t\\\n+ && GET_MODE (X) == VOIDmode)\n+\n+#define INT_LOWPART(X) \\\n+  (GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))\n+\n+int\n+extract_MB (op)\n+     rtx op;\n+{\n+  int i;\n+  unsigned long val = INT_LOWPART (op);\n+\n+  /* If the high bit is zero, the value is the first 1 bit we find\n+     from the left.  */\n+  if ((val & 0x80000000) == 0)\n+    {\n+      if ((val & 0xffffffff) == 0)\n+\tabort ();\n+\n+      i = 1;\n+      while (((val <<= 1) & 0x80000000) == 0)\n+\t++i;\n+      return i;\n+    }\n+\n+  /* If the high bit is set and the low bit is not, or the mask is all\n+     1's, the value is zero.  */\n+  if ((val & 1) == 0 || (val & 0xffffffff) == 0xffffffff)\n+    return 0;\n+\n+  /* Otherwise we have a wrap-around mask.  Look for the first 0 bit\n+     from the right.  */\n+  i = 31;\n+  while (((val >>= 1) & 1) != 0)\n+    --i;\n+\n+  return i;\n+}\n+\n+int\n+extract_ME (op)\n+     rtx op;\n+{\n+  int i;\n+  unsigned long val = INT_LOWPART (op);\n+\n+  /* If the low bit is zero, the value is the first 1 bit we find from\n+     the right.  */\n+  if ((val & 1) == 0)\n+    {\n+      if ((val & 0xffffffff) == 0)\n+\tabort ();\n+\n+      i = 30;\n+      while (((val >>= 1) & 1) == 0)\n+\t--i;\n+\n+      return i;\n+    }\n+\n+  /* If the low bit is set and the high bit is not, or the mask is all\n+     1's, the value is 31.  */\n+  if ((val & 0x80000000) == 0 || (val & 0xffffffff) == 0xffffffff)\n+    return 31;\n+\n+  /* Otherwise we have a wrap-around mask.  Look for the first 0 bit\n+     from the left.  */\n+  i = 0;\n+  while (((val <<= 1) & 0x80000000) != 0)\n+    ++i;\n+\n+  return i;\n+}\n+\n /* Print an operand.  Recognize special options, documented below.  */\n \n #if TARGET_ELF\n@@ -6074,14 +6286,7 @@ print_operand (file, x, code)\n {\n   int i;\n   HOST_WIDE_INT val;\n-\n-  /* These macros test for integers and extract the low-order bits.  */\n-#define INT_P(X)  \\\n-((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)\t\\\n- && GET_MODE (X) == VOIDmode)\n-\n-#define INT_LOWPART(X) \\\n-  (GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))\n+  unsigned HOST_WIDE_INT uval;\n \n   switch (code)\n     {\n@@ -6297,70 +6502,15 @@ print_operand (file, x, code)\n       if (! mask_operand (x, SImode))\n \toutput_operand_lossage (\"invalid %%m value\");\n \n-      val = INT_LOWPART (x);\n-\n-      /* If the high bit is set and the low bit is not, the value is zero.\n-\t If the high bit is zero, the value is the first 1 bit we find from\n-\t the left.  */\n-      if ((val & 0x80000000) && ((val & 1) == 0))\n-\t{\n-\t  putc ('0', file);\n-\t  return;\n-\t}\n-      else if ((val & 0x80000000) == 0)\n-\t{\n-\t  for (i = 1; i < 32; i++)\n-\t    if ((val <<= 1) & 0x80000000)\n-\t      break;\n-\t  fprintf (file, \"%d\", i);\n-\t  return;\n-\t}\n-\t  \n-      /* Otherwise, look for the first 0 bit from the right.  The result is its\n-\t number plus 1. We know the low-order bit is one.  */\n-      for (i = 0; i < 32; i++)\n-\tif (((val >>= 1) & 1) == 0)\n-\t  break;\n-\n-      /* If we ended in ...01, i would be 0.  The correct value is 31, so\n-\t we want 31 - i.  */\n-      fprintf (file, \"%d\", 31 - i);\n+      fprintf (file, \"%d\", extract_MB (x));\n       return;\n \n     case 'M':\n       /* ME value for a mask operand.  */\n       if (! mask_operand (x, SImode))\n \toutput_operand_lossage (\"invalid %%M value\");\n \n-      val = INT_LOWPART (x);\n-\n-      /* If the low bit is set and the high bit is not, the value is 31.\n-\t If the low bit is zero, the value is the first 1 bit we find from\n-\t the right.  */\n-      if ((val & 1) && ((val & 0x80000000) == 0))\n-\t{\n-\t  fputs (\"31\", file);\n-\t  return;\n-\t}\n-      else if ((val & 1) == 0)\n-\t{\n-\t  for (i = 0; i < 32; i++)\n-\t    if ((val >>= 1) & 1)\n-\t      break;\n-\n-\t  /* If we had ....10, i would be 0.  The result should be\n-\t     30, so we need 30 - i.  */\n-\t  fprintf (file, \"%d\", 30 - i);\n-\t  return;\n-\t}\n-\t  \n-      /* Otherwise, look for the first 0 bit from the left.  The result is its\n-\t number minus 1. We know the high-order bit is one.  */\n-      for (i = 0; i < 32; i++)\n-\tif (((val <<= 1) & 0x80000000) == 0)\n-\t  break;\n-\n-      fprintf (file, \"%d\", i);\n+      fprintf (file, \"%d\", extract_ME (x));\n       return;\n \n       /* %n outputs the negative of its operand.  */\n@@ -6456,68 +6606,31 @@ print_operand (file, x, code)\n       return;\n \n     case 'S':\n-      /* PowerPC64 mask position.  All 0's and all 1's are excluded.\n+      /* PowerPC64 mask position.  All 0's is excluded.\n \t CONST_INT 32-bit mask is considered sign-extended so any\n \t transition must occur within the CONST_INT, not on the boundary.  */\n       if (! mask64_operand (x, DImode))\n \toutput_operand_lossage (\"invalid %%S value\");\n \n-      val = INT_LOWPART (x);\n+      uval = INT_LOWPART (x);\n \n-      if (val & 1)      /* Clear Left */\n+      if (uval & 1)\t/* Clear Left */\n \t{\n-\t  for (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)\n-\t    if (!((val >>= 1) & 1))\n-\t      break;\n-\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  if (GET_CODE (x) == CONST_DOUBLE && i == 32)\n-\t    {\n-\t      val = CONST_DOUBLE_HIGH (x);\n-\n-\t      if (val == 0)\n-\t\t--i;\n-\t      else\n-\t\tfor (i = 32; i < 64; i++)\n-\t\t  if (!((val >>= 1) & 1))\n-\t\t    break;\n-\t    }\n-#endif\n-\t/* i = index of last set bit from right\n-\t   mask begins at 63 - i from left */\n-\t  if (i > 63)\n-\t    output_operand_lossage (\"%%S computed all 1's mask\");\n-\n-\t  fprintf (file, \"%d\", 63 - i);\n-\t  return;\n+\t  uval &= ((unsigned HOST_WIDE_INT) 1 << 63 << 1) - 1;\n+\t  i = 64;\n \t}\n-      else\t/* Clear Right */\n+      else\t\t/* Clear Right */\n \t{\n-\t  for (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)\n-\t    if ((val >>= 1) & 1)\n-\t      break;\n-\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\tif (GET_CODE (x) == CONST_DOUBLE && i == 32)\n-\t  {\n-\t    val = CONST_DOUBLE_HIGH (x);\n-\n-\t    if (val == (HOST_WIDE_INT) -1)\n-\t      --i;\n-\t    else\n-\t      for (i = 32; i < 64; i++)\n-\t\tif ((val >>= 1) & 1)\n-\t\t  break;\n-\t  }\n-#endif\n-\t/* i = index of last clear bit from right\n-\t   mask ends at 62 - i from left */\n-\t  if (i > 62)\n-\t    output_operand_lossage (\"%%S computed all 0's mask\");\n-\n-\t  fprintf (file, \"%d\", 62 - i);\n-\t  return;\n+\t  uval = ~uval;\n+\t  uval &= ((unsigned HOST_WIDE_INT) 1 << 63 << 1) - 1;\n+\t  i = 63;\n \t}\n+      while (uval != 0)\n+\t--i, uval >>= 1;\n+      if (i < 0)\n+\tabort ();\n+      fprintf (file, \"%d\", i);\n+      return;\n \n     case 'T':\n       /* Print the symbolic name of a branch target register.  */"}, {"sha": "b63bb78649c8ddae1fd2eae87c1653cd8f211366", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "patch": "@@ -1178,7 +1178,8 @@ enum reg_class\n    'R' is for AIX TOC entries.\n    'S' is a constant that can be placed into a 64-bit mask operand\n    'T' is a constant that can be placed into a 32-bit mask operand\n-   'U' is for V.4 small data references.  */\n+   'U' is for V.4 small data references.\n+   't' is for AND masks that can be performed by two rldic{l,r} insns.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\\\n@@ -1187,6 +1188,10 @@ enum reg_class\n    : (C) == 'T' ? mask_operand (OP, SImode)\t\t\t\t\\\n    : (C) == 'U' ? (DEFAULT_ABI == ABI_V4\t\t\t\t\\\n \t\t   && small_data_operand (OP, GET_MODE (OP)))\t\t\\\n+   : (C) == 't' ? (mask64_2_operand (OP, DImode)\t\t\t\\\n+\t\t   && (fixed_regs[CR0_REGNO]\t\t\t\t\\\n+\t\t       || !logical_operand (OP, DImode))\t\t\\\n+\t\t   && !mask64_operand (OP, DImode))\t\t\t\\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -2749,10 +2754,13 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n   {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t   \\\n   {\"and64_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t   \\\n+  {\"and64_2_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n   {\"logical_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t   \\\n   {\"non_logical_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\t   \\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\t   \\\n-  {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t   \\\n+  {\"mask_operand_wrap\", {CONST_INT}},\t\t\t\t\t   \\\n+  {\"mask64_operand\", {CONST_INT}},\t\t\t\t\t   \\\n+  {\"mask64_2_operand\", {CONST_INT}},\t\t\t\t\t   \\\n   {\"count_register_operand\", {REG}},\t\t\t\t\t   \\\n   {\"xer_operand\", {REG}},\t\t\t\t\t\t   \\\n   {\"symbol_ref_operand\", {SYMBOL_REF}},\t\t\t\t\t   \\"}, {"sha": "5e2b58700988c8fdfaac562213ad6b02939404f3", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 264, "deletions": 23, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0ba1b2ff0fe1f3bfd13ca72ce09736d65ed45c6c", "patch": "@@ -2885,7 +2885,7 @@\n    {andiu.|andis.} %0,%1,%u2\")\n \n ;; Note to set cr's other than cr0 we do the and immediate and then\n-;; the test again -- this avoids a mcrf which on the higher end\n+;; the test again -- this avoids a mfcr which on the higher end\n ;; machines causes an execution serialization\n \n (define_insn \"*andsi3_internal2\"\n@@ -2908,14 +2908,34 @@\n   [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n    (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n \n+(define_insn \"*andsi3_internal3\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n+\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n+\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:SI 3 \"=r,r,r,r,r,r,r,r\"))\n+   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   #\n+   {andil.|andi.} %3,%1,%b2\n+   {andiu.|andis.} %3,%1,%u2\n+   {rlinm.|rlwinm.} %3,%1,0,%m2,%M2\n+   #\n+   #\n+   #\n+   #\"\n+  [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"8,4,4,4,8,8,8,8\")])\n+\n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"and_operand\" \"\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"\"))\n    (clobber (match_scratch:CC 4 \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n+  \"reload_completed\"\n   [(parallel [(set (match_dup 3)\n \t\t   (and:SI (match_dup 1)\n \t\t\t   (match_dup 2)))\n@@ -2925,7 +2945,27 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_insn \"*andsi3_internal3\"\n+;; We don't have a 32 bit \"and. rt,ra,rb\" for ppc64.  cr is set from the\n+;; whole 64 bit reg, and we don't know what is in the high 32 bits.\n+\n+(define_split\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"\")\n+\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:SI 3 \"\"))\n+   (clobber (match_scratch:CC 4 \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (and:SI (match_dup 1)\n+\t\t\t   (match_dup 2)))\n+\t      (clobber (match_dup 4))])\n+   (set (match_dup 0)\n+\t(compare:CC (match_dup 3)\n+\t\t    (const_int 0)))]\n+  \"\")\n+\n+(define_insn \"*andsi3_internal4\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n \t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n \t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n@@ -2947,6 +2987,28 @@\n   [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n    (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n \n+(define_insn \"*andsi3_internal5\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n+\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n+\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r\")\n+\t(and:SI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   #\n+   {andil.|andi.} %0,%1,%b2\n+   {andiu.|andis.} %0,%1,%u2\n+   {rlinm.|rlwinm.} %0,%1,0,%m2,%M2\n+   #\n+   #\n+   #\n+   #\"\n+  [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"8,4,4,4,8,8,8,8\")])\n+\n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n@@ -2956,7 +3018,7 @@\n \t(and:SI (match_dup 1)\n \t\t(match_dup 2)))\n    (clobber (match_scratch:CC 4 \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\"\n+  \"reload_completed\"\n   [(parallel [(set (match_dup 0)\n \t\t   (and:SI (match_dup 1)\n \t\t\t   (match_dup 2)))\n@@ -2966,6 +3028,104 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"\")\n+\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(and:SI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (clobber (match_scratch:CC 4 \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (and:SI (match_dup 1)\n+\t\t\t   (match_dup 2)))\n+\t      (clobber (match_dup 4))])\n+   (set (match_dup 3)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\")\n+\n+;; Handle the PowerPC64 rlwinm corner case\n+\n+(define_insn_and_split \"*andsi3_internal6\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"mask_operand_wrap\" \"i\")))]\n+  \"TARGET_POWERPC64\"\n+  \"#\"\n+  \"TARGET_POWERPC64\"\n+  [(set (match_dup 0)\n+\t(and:SI (rotate:SI (match_dup 1) (match_dup 3))\n+\t\t(match_dup 4)))\n+   (set (match_dup 0)\n+\t(rotate:SI (match_dup 0) (match_dup 5)))]\n+  \"\n+{\n+  int mb = extract_MB (operands[2]);\n+  int me = extract_ME (operands[2]);\n+  operands[3] = GEN_INT (me + 1);\n+  operands[5] = GEN_INT (32 - (me + 1));\n+  operands[4] = GEN_INT (~((HOST_WIDE_INT) -1 << (33 + me - mb)));\n+}\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*andsi3_internal7\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t    (match_operand:SI 1 \"mask_operand_wrap\" \"i,i\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:SI 3 \"=r,r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"#\"\n+  \"TARGET_POWERPC64\"\n+  [(parallel [(set (match_dup 2)\n+\t\t   (compare:CC (and:SI (rotate:SI (match_dup 0) (match_dup 4))\n+\t\t\t\t       (match_dup 5))\n+\t\t\t       (const_int 0)))\n+\t      (clobber (match_dup 3))])]\n+  \"\n+{\n+  int mb = extract_MB (operands[1]);\n+  int me = extract_ME (operands[1]);\n+  operands[4] = GEN_INT (me + 1);\n+  operands[5] = GEN_INT (~((HOST_WIDE_INT) -1 << (33 + me - mb)));\n+}\"\n+  [(set_attr \"type\" \"delayed_compare,compare\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_insn_and_split \"*andsi3_internal8\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,??y\")\n+\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t    (match_operand:SI 2 \"mask_operand_wrap\" \"i,i\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(and:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"#\"\n+  \"TARGET_POWERPC64\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (compare:CC (and:SI (rotate:SI (match_dup 1) (match_dup 4))\n+\t\t\t\t       (match_dup 5))\n+\t\t\t       (const_int 0)))\n+\t      (set (match_dup 0)\n+\t\t   (and:SI (rotate:SI (match_dup 1) (match_dup 4))\n+\t\t\t   (match_dup 5)))])\n+   (set (match_dup 0)\n+\t(rotate:SI (match_dup 0) (match_dup 6)))]\n+  \"\n+{\n+  int mb = extract_MB (operands[2]);\n+  int me = extract_ME (operands[2]);\n+  operands[4] = GEN_INT (me + 1);\n+  operands[6] = GEN_INT (32 - (me + 1));\n+  operands[5] = GEN_INT (~((HOST_WIDE_INT) -1 << (33 + me - mb)));\n+}\"\n+  [(set_attr \"type\" \"delayed_compare,compare\")\n+   (set_attr \"length\" \"8,12\")])\n+\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n@@ -7235,24 +7395,47 @@\n   \"\")\n \n (define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n-\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t(match_operand:DI 2 \"and64_operand\" \"?r,S,K,J\")))\n-   (clobber (match_scratch:CC 3 \"=X,X,x,x\"))]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n+\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n+\t\t(match_operand:DI 2 \"and64_2_operand\" \"?r,S,K,J,t\")))\n+   (clobber (match_scratch:CC 3 \"=X,X,x,x,X\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n    and %0,%1,%2\n    rldic%B2 %0,%1,0,%S2\n    andi. %0,%1,%b2\n-   andis. %0,%1,%u2\")\n+   andis. %0,%1,%u2\n+   #\"\n+  [(set_attr \"length\" \"4,4,4,4,8\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DI 2 \"mask64_2_operand\" \"\")))\n+   (clobber (match_scratch:CC 3 \"\"))]\n+  \"TARGET_POWERPC64\n+    && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n+    && !mask64_operand (operands[2], DImode)\"\n+  [(set (match_dup 0)\n+\t(and:DI (rotate:DI (match_dup 1)\n+\t\t\t   (match_dup 4))\n+\t\t(match_dup 5)))\n+   (set (match_dup 0)\n+\t(and:DI (rotate:DI (match_dup 0)\n+\t\t\t   (match_dup 6))\n+\t\t(match_dup 7)))]\n+  \"\n+{\n+  build_mask64_2_operands (operands[2], &operands[4]);\n+}\")\n \n (define_insn \"*anddi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,?y,?y,??y,??y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,\")\n-\t\t\t    (match_operand:DI 2 \"and64_operand\" \"r,S,K,J,r,S,K,J\"))\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,x,?y,?y,??y,??y,?y\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,K,J,t,r,S,K,J,t\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r,r,r,r,r,r,r\"))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,x,x\"))]\n+   (clobber (match_scratch:DI 3 \"=r,r,r,r,r,r,r,r,r,r\"))\n+   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,x,x,X\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n    and. %3,%1,%2\n@@ -7262,9 +7445,11 @@\n    #\n    #\n    #\n+   #\n+   #\n    #\"\n-  [(set_attr \"type\" \"compare,delayed_compare,compare,compare,compare,delayed_compare,compare,compare\")\n-   (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n+  [(set_attr \"type\" \"compare,delayed_compare,compare,compare,delayed_compare,compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"4,4,4,4,8,8,8,8,8,12\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n@@ -7283,14 +7468,39 @@\n                     (const_int 0)))]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"\")\n+        (compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+                            (match_operand:DI 2 \"mask64_2_operand\" \"\"))\n+                    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"\"))\n+   (clobber (match_scratch:CC 4 \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\n+    && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n+    && !mask64_operand (operands[2], DImode)\"\n+  [(set (match_dup 3)\n+\t(and:DI (rotate:DI (match_dup 1)\n+\t\t\t   (match_dup 5))\n+\t\t(match_dup 6)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (compare:CC (and:DI (rotate:DI (match_dup 3)\n+\t\t\t\t\t\t  (match_dup 7))\n+\t\t\t\t       (match_dup 8))\n+\t\t\t       (const_int 0)))\n+\t      (clobber (match_dup 3))])]\n+  \"\n+{\n+  build_mask64_2_operands (operands[2], &operands[5]);\n+}\")\n+\n (define_insn \"*anddi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,?y,?y,??y,??y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:DI 2 \"and64_operand\" \"r,S,K,J,r,S,K,J\"))\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,x,?y,?y,??y,??y,?y\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,K,J,t,r,S,K,J,t\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r\")\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r,r,r\")\n \t(and:DI (match_dup 1) (match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,x,x\"))]\n+   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,x,x,X\"))]\n   \"TARGET_POWERPC64\"\n   \"@\n    and. %0,%1,%2\n@@ -7300,9 +7510,11 @@\n    #\n    #\n    #\n+   #\n+   #\n    #\"\n-  [(set_attr \"type\" \"compare,delayed_compare,compare,compare,compare,delayed_compare,compare,compare\")\n-   (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n+  [(set_attr \"type\" \"compare,delayed_compare,compare,compare,delayed_compare,compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"4,4,4,4,8,8,8,8,8,12\")])\n \n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n@@ -7321,6 +7533,35 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"\")\n+        (compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+                            (match_operand:DI 2 \"mask64_2_operand\" \"\"))\n+                    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(and:DI (match_dup 1) (match_dup 2)))\n+   (clobber (match_scratch:CC 4 \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\n+    && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n+    && !mask64_operand (operands[2], DImode)\"\n+  [(set (match_dup 0)\n+\t(and:DI (rotate:DI (match_dup 1)\n+\t\t\t   (match_dup 5))\n+\t\t(match_dup 6)))\n+   (parallel [(set (match_dup 3)\n+\t\t   (compare:CC (and:DI (rotate:DI (match_dup 0)\n+\t\t\t\t\t\t  (match_dup 7))\n+\t\t\t\t       (match_dup 8))\n+\t\t\t       (const_int 0)))\n+\t      (set (match_dup 0)\n+\t\t   (and:DI (rotate:DI (match_dup 0)\n+\t\t\t\t      (match_dup 7))\n+\t\t\t   (match_dup 8)))])]\n+  \"\n+{\n+  build_mask64_2_operands (operands[2], &operands[5]);\n+}\")\n+\n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")"}]}