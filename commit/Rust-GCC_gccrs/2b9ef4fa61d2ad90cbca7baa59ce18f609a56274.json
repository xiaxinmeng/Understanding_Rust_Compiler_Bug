{"sha": "2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI5ZWY0ZmE2MWQyYWQ5MGNiY2E3YmFhNTljZTE4ZjYwOWE1NjI3NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-01T00:01:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-01T00:01:23Z"}, "message": "tree-gimple.c (right_assocify_expr): Kill\n\n        * tree-gimple.c (right_assocify_expr): Kill\n        (rationalize_compound_expr): Kill.\n        * tree-gimple.h: Likewise.\n        * tree-inline.c (expand_call_inline): Don't call it.\n\nFrom-SVN: r83940", "tree": {"sha": "15e0d7f1b9088b09a8c4a105e75791fa3a879647", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e0d7f1b9088b09a8c4a105e75791fa3a879647"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/comments", "author": null, "committer": null, "parents": [{"sha": "521d8de07f181a54b31b6660b5dc55c76f390ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/521d8de07f181a54b31b6660b5dc55c76f390ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/521d8de07f181a54b31b6660b5dc55c76f390ff8"}], "stats": {"total": 81, "additions": 5, "deletions": 76}, "files": [{"sha": "5ea91872bf59d5c46fafaa65b9b9e572c265b233", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "patch": "@@ -1,5 +1,10 @@\n 2004-06-30  Richard Henderson  <rth@redhat.com>\n \n+\t* tree-gimple.c (right_assocify_expr): Kill\n+\t(rationalize_compound_expr): Kill.\n+\t* tree-gimple.h: Likewise.\n+\t* tree-inline.c (expand_call_inline): Don't call it.\n+\n \t* function.h (struct function): Remove x_last_parm_insn,\n \tinl_last_parm_insn.\n \t(last_parm_insn): Remove."}, {"sha": "4d209ec8c8efae35a5ccb98a5d9902cc3fc73cdd", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "patch": "@@ -524,76 +524,6 @@ get_call_expr_in (tree t)\n   return NULL_TREE;\n }\n \n-\n-/* Given an _EXPR TOP, reorganize all of the nested _EXPRs with the same\n-   code so that they only appear as the second operand.  This should only\n-   be used for tree codes which are truly associative, such as\n-   COMPOUND_EXPR and TRUTH_ANDIF_EXPR.  Arithmetic is not associative\n-   enough, due to the limited precision of arithmetic data types.\n-\n-   This transformation is conservative; the operand 0 of a matching tree\n-   node will only change if it is also a matching node.  */\n-\n-tree\n-right_assocify_expr (tree top)\n-{\n-  tree *p = &top;\n-  enum tree_code code = TREE_CODE (*p);\n-  while (TREE_CODE (*p) == code)\n-    {\n-      tree cur = *p;\n-      tree lhs = TREE_OPERAND (cur, 0);\n-      if (TREE_CODE (lhs) == code)\n-\t{\n-\t  /* There's a left-recursion.  If we have ((a, (b, c)), d), we\n-\t     want to rearrange to (a, (b, (c, d))).  */\n-\t  tree *q;\n-\n-\t  /* Replace cur with the lhs; move (a, *) up.  */\n-\t  *p = lhs;\n-\n-\t  if (code == COMPOUND_EXPR)\n-\t    {\n-\t      /* We need to give (b, c) the type of c; previously lhs had\n-\t\t the type of b.  */\n-\t      TREE_TYPE (lhs) = TREE_TYPE (cur);\n-\t      if (TREE_SIDE_EFFECTS (cur))\n-\t\tTREE_SIDE_EFFECTS (lhs) = 1;\n-\t    }\n-\n-\t  /* Walk through the op1 chain from there until we find something\n-\t     with a different code.  In this case, c.  */\n-\t  for (q = &TREE_OPERAND (lhs, 1); TREE_CODE (*q) == code;\n-\t       q = &TREE_OPERAND (*q, 1))\n-\t    TREE_TYPE (*q) = TREE_TYPE (cur);\n-\n-\t  /* Change (*, d) into (c, d).  */\n-\t  TREE_OPERAND (cur, 0) = *q;\n-\n-\t  /* And plug it in where c used to be.  */\n-\t  *q = cur;\n-\t}\n-      else\n-\tp = &TREE_OPERAND (cur, 1);\n-    }\n-  return top;\n-}\n-\n-/* Normalize the statement TOP.  If it is a COMPOUND_EXPR, reorganize it so\n-   that we can traverse it without recursion.  If it is null, replace it\n-   with a nop.  */\n-\n-tree\n-rationalize_compound_expr (tree top)\n-{\n-  if (top == NULL_TREE)\n-    top = build_empty_stmt ();\n-  else if (TREE_CODE (top) == COMPOUND_EXPR)\n-    top = right_assocify_expr (top);\n-\n-  return top;\n-}\n-\n /* Given a memory reference expression, return the base address.  Note that,\n    in contrast with get_base_var, this will not recurse inside INDIRECT_REF\n    expressions.  Therefore, given the reference PTR->FIELD, this function"}, {"sha": "8fb22710516535ad8da0aab308e419df8bf047ac", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "patch": "@@ -33,8 +33,6 @@ extern tree get_initialized_tmp_var (tree, tree *, tree *);\n extern tree get_formal_tmp_var (tree, tree *);\n extern void declare_tmp_vars (tree, tree);\n \n-extern tree rationalize_compound_expr (tree);\n-extern tree right_assocify_expr (tree);\n extern void annotate_all_with_locus (tree *, location_t);\n \n /* Validation of GIMPLE expressions.  Note that these predicates only check"}, {"sha": "aa579c34186112edd378c75ec55bf3ebe152b350", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "patch": "@@ -1652,10 +1652,6 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n     {\n       tree save_decl;\n \n-      /* Keep the new trees in gimple form.  */\n-      BIND_EXPR_BODY (expr)\n-\t= rationalize_compound_expr (BIND_EXPR_BODY (expr));\n-\n       /* We want to create a new variable to hold the result of the inlined\n \t body.  This new variable needs to be added to the function which we\n \t are inlining into, thus the saving and restoring of"}]}