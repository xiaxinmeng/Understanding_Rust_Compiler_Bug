{"sha": "2dc902baa1388841096e16e660082a8e79fce17e", "node_id": "C_kwDOANBUbNoAKDJkYzkwMmJhYTEzODg4NDEwOTZlMTZlNjYwMDgyYThlNzlmY2UxN2U", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-07-29T15:21:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-04T14:48:36Z"}, "message": "Refactor all coercion type calls into a single coercion_site function\n\nIn order to fully support coercion sites we need a single place in order to\nimplement the logic. This refactors all the coercion calls to have a single\nTypeCheckBase::coercion_site(lhs, rhs, location). Eventually we will do\nsomething similar for unifications and casts so we can improve our\ndiagnostics.", "tree": {"sha": "dfa398113378b17e22b64b952399d4ca556a393c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfa398113378b17e22b64b952399d4ca556a393c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dc902baa1388841096e16e660082a8e79fce17e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dc902baa1388841096e16e660082a8e79fce17e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dc902baa1388841096e16e660082a8e79fce17e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dc902baa1388841096e16e660082a8e79fce17e/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffb419d6a46302126944066ef46bd0c9f590ee30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb419d6a46302126944066ef46bd0c9f590ee30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb419d6a46302126944066ef46bd0c9f590ee30"}], "stats": {"total": 533, "additions": 288, "deletions": 245}, "files": [{"sha": "ee8473f83c2a48deff03de59b2971e7b5baecf10", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -106,6 +106,7 @@ GRS_OBJS = \\\n     rust/rust-pub-restricted-visitor.o \\\n     rust/rust-privacy-reporter.o \\\n     rust/rust-tyty.o \\\n+    rust/rust-tyty-call.o \\\n     rust/rust-tyctx.o \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\"}, {"sha": "092b635bfa860d2b6e22d1811ec3c3b82cd96ab2", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -327,5 +327,12 @@ TypeCheckBase::parse_repr_options (const AST::AttrVec &attrs, Location locus)\n   return repr;\n }\n \n+TyTy::BaseType *\n+TypeCheckBase::coercion_site (TyTy::BaseType *lhs, TyTy::BaseType *rhs,\n+\t\t\t      Location)\n+{\n+  return lhs->coerce (rhs);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "9d53610151d0f816974aa234c23335f958c0eafb", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -39,6 +39,9 @@ class TypeCheckBase : public HIR::HIRFullVisitorBase\n \n   virtual ~TypeCheckBase () {}\n \n+  static TyTy::BaseType *coercion_site (TyTy::BaseType *lhs,\n+\t\t\t\t\tTyTy::BaseType *rhs, Location locus);\n+\n protected:\n   TypeCheckBase ()\n     : mappings (Analysis::Mappings::get ()), resolver (Resolver::get ()),"}, {"sha": "88545c6e5cb365b5720dc24c36690e5359ebdf6f", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -380,7 +380,7 @@ class TypeCheckExpr : public TypeCheckBase\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n-    lhs->coerce (rhs);\n+    coercion_site (lhs, rhs, expr.get_locus ());\n   }\n \n   void visit (HIR::CompoundAssignmentExpr &expr) override"}, {"sha": "11f4d6424296b56575ed82b802837fbe0e69053b", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -99,7 +99,7 @@ class TypeCheckStmt : public TypeCheckBase\n     if (specified_ty != nullptr && init_expr_ty != nullptr)\n       {\n \t// FIXME use this result and look at the regressions\n-\tspecified_ty->coerce (init_expr_ty);\n+\tcoercion_site (specified_ty, init_expr_ty, stmt.get_locus ());\n \tcontext->insert_type (stmt_pattern.get_pattern_mappings (),\n \t\t\t      specified_ty);\n       }"}, {"sha": "736bc5e78574b1568278cb15324820340e84065c", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -42,8 +42,8 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n     {\n       TyTy::BaseType *base_resolved\n \t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n-      struct_def\n-\t= (TyTy::ADTType *) struct_path_resolved->coerce (base_resolved);\n+      struct_def = static_cast<TyTy::ADTType *> (\n+\tstruct_path_resolved->coerce (base_resolved));\n       if (struct_def == nullptr)\n \t{\n \t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),\n@@ -221,7 +221,8 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n     }\n \n   TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n-  resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n+  resolved_field_value_expr\n+    = coercion_site (field_type->get_field_type (), value, field.get_locus ());\n   if (resolved_field_value_expr != nullptr)\n     {\n       fields_assigned.insert (field.field_name);\n@@ -250,7 +251,8 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n     }\n \n   TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n-  resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n+  resolved_field_value_expr\n+    = coercion_site (field_type->get_field_type (), value, field.get_locus ());\n   if (resolved_field_value_expr != nullptr)\n     {\n       fields_assigned.insert (field_name);\n@@ -284,7 +286,8 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n \t\t\t    field.get_locus ());\n   TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr);\n \n-  resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n+  resolved_field_value_expr\n+    = coercion_site (field_type->get_field_type (), value, field.get_locus ());\n   if (resolved_field_value_expr != nullptr)\n \n     {"}, {"sha": "416527e343645c21d573390fbd6ecf2e7ac30eb9", "filename": "gcc/rust/typecheck/rust-tyty-call.cc", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -0,0 +1,267 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+void\n+TypeCheckCallExpr::visit (ADTType &type)\n+{\n+  rust_assert (!variant.is_error ());\n+  if (variant.get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n+    {\n+      rust_error_at (\n+\tcall.get_locus (),\n+\t\"expected function, tuple struct or tuple variant, found struct %<%s%>\",\n+\ttype.get_name ().c_str ());\n+      return;\n+    }\n+\n+  if (call.num_params () != variant.num_fields ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) variant.num_fields ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      StructFieldType *field = variant.get_field_at_index (i);\n+      BaseType *field_tyty = field->get_field_type ();\n+\n+      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (arg->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"failed to resolve argument type\");\n+\t  return;\n+\t}\n+\n+      auto res = field_tyty->coerce (arg);\n+      if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  return;\n+\t}\n+\n+      delete res;\n+      i++;\n+    }\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.clone ();\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnType &type)\n+{\n+  type.monomorphize ();\n+  if (call.num_params () != type.num_params ())\n+    {\n+      if (type.is_varadic ())\n+\t{\n+\t  if (call.num_params () < type.num_params ())\n+\t    {\n+\t      rust_error_at (call.get_locus (),\n+\t\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t\t     (unsigned long) call.num_params (),\n+\t\t\t     (unsigned long) type.num_params ());\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rust_error_at (call.get_locus (),\n+\t\t\t \"unexpected number of arguments %lu expected %lu\",\n+\t\t\t (unsigned long) call.num_params (),\n+\t\t\t (unsigned long) type.num_params ());\n+\t  return;\n+\t}\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      // it might be a varadic function\n+      if (i < type.num_params ())\n+\t{\n+\t  auto fnparam = type.param_at (i);\n+\t  auto resolved_argument_type\n+\t    = fnparam.second->coerce (argument_expr_tyty);\n+\t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t    {\n+\t      rust_error_at (argument->get_locus (),\n+\t\t\t     \"Type Resolution failure on parameter\");\n+\t      return;\n+\t    }\n+\t}\n+\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n+\n+      i++;\n+    }\n+\n+  if (i < call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  type.monomorphize ();\n+  resolved = type.get_return_type ()->clone ();\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnPtr &type)\n+{\n+  if (call.num_params () != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      auto resolved_argument_type\n+\t= Resolver::TypeCheckBase::coercion_site (fnparam, argument_expr_tyty,\n+\t\t\t\t\t\t  argument->get_locus ());\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n+\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n+\n+      i++;\n+    }\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n+}\n+\n+// method call checker\n+\n+void\n+TypeCheckMethodCallExpr::visit (FnType &type)\n+{\n+  type.get_self_type ()->unify (adjusted_self);\n+\n+  // +1 for the receiver self\n+  size_t num_args_to_call = call.num_params () + 1;\n+  if (num_args_to_call != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 1;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      auto resolved_argument_type\n+\t= Resolver::TypeCheckBase::coercion_site (fnparam.second,\n+\t\t\t\t\t\t  argument_expr_tyty,\n+\t\t\t\t\t\t  argument->get_locus ());\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n+\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n+\n+      i++;\n+    }\n+\n+  if (i != num_args_to_call)\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  type.monomorphize ();\n+\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "daedfc3012c9842aae2b71e425bf1ecadf1cf140", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 0, "deletions": 238, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dc902baa1388841096e16e660082a8e79fce17e/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=2dc902baa1388841096e16e660082a8e79fce17e", "patch": "@@ -3205,243 +3205,5 @@ DynamicObjectType::get_object_items () const\n   return items;\n }\n \n-// rust-tyty-call.h\n-\n-void\n-TypeCheckCallExpr::visit (ADTType &type)\n-{\n-  rust_assert (!variant.is_error ());\n-  if (variant.get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n-    {\n-      rust_error_at (\n-\tcall.get_locus (),\n-\t\"expected function, tuple struct or tuple variant, found struct %<%s%>\",\n-\ttype.get_name ().c_str ());\n-      return;\n-    }\n-\n-  if (call.num_params () != variant.num_fields ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n-\t\t     (unsigned long) variant.num_fields ());\n-      return;\n-    }\n-\n-  size_t i = 0;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      StructFieldType *field = variant.get_field_at_index (i);\n-      BaseType *field_tyty = field->get_field_type ();\n-\n-      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (arg->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"failed to resolve argument type\");\n-\t  return;\n-\t}\n-\n-      auto res = field_tyty->coerce (arg);\n-      if (res->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  return;\n-\t}\n-\n-      delete res;\n-      i++;\n-    }\n-\n-  if (i != call.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  resolved = type.clone ();\n-}\n-\n-void\n-TypeCheckCallExpr::visit (FnType &type)\n-{\n-  type.monomorphize ();\n-  if (call.num_params () != type.num_params ())\n-    {\n-      if (type.is_varadic ())\n-\t{\n-\t  if (call.num_params () < type.num_params ())\n-\t    {\n-\t      rust_error_at (call.get_locus (),\n-\t\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t\t     (unsigned long) call.num_params (),\n-\t\t\t     (unsigned long) type.num_params ());\n-\t      return;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  rust_error_at (call.get_locus (),\n-\t\t\t \"unexpected number of arguments %lu expected %lu\",\n-\t\t\t (unsigned long) call.num_params (),\n-\t\t\t (unsigned long) type.num_params ());\n-\t  return;\n-\t}\n-    }\n-\n-  size_t i = 0;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      // it might be a varadic function\n-      if (i < type.num_params ())\n-\t{\n-\t  auto fnparam = type.param_at (i);\n-\t  auto resolved_argument_type\n-\t    = fnparam.second->coerce (argument_expr_tyty);\n-\t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n-\t    {\n-\t      rust_error_at (argument->get_locus (),\n-\t\t\t     \"Type Resolution failure on parameter\");\n-\t      return;\n-\t    }\n-\t}\n-\n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n-      i++;\n-    }\n-\n-  if (i < call.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  type.monomorphize ();\n-  resolved = type.get_return_type ()->clone ();\n-}\n-\n-void\n-TypeCheckCallExpr::visit (FnPtr &type)\n-{\n-  if (call.num_params () != type.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n-\t\t     (unsigned long) type.num_params ());\n-      return;\n-    }\n-\n-  size_t i = 0;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      auto fnparam = type.param_at (i);\n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n-      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"Type Resolution failure on parameter\");\n-\t  return;\n-\t}\n-\n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n-      i++;\n-    }\n-\n-  if (i != call.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  resolved = type.get_return_type ()->monomorphized_clone ();\n-}\n-\n-// method call checker\n-\n-void\n-TypeCheckMethodCallExpr::visit (FnType &type)\n-{\n-  type.get_self_type ()->unify (adjusted_self);\n-\n-  // +1 for the receiver self\n-  size_t num_args_to_call = call.num_params () + 1;\n-  if (num_args_to_call != type.num_params ())\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n-\t\t     (unsigned long) type.num_params ());\n-      return;\n-    }\n-\n-  size_t i = 1;\n-  for (auto &argument : call.get_arguments ())\n-    {\n-      auto fnparam = type.param_at (i);\n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      auto resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n-      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"Type Resolution failure on parameter\");\n-\t  return;\n-\t}\n-\n-      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n-\n-      i++;\n-    }\n-\n-  if (i != num_args_to_call)\n-    {\n-      rust_error_at (call.get_locus (),\n-\t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n-    }\n-\n-  type.monomorphize ();\n-\n-  resolved = type.get_return_type ()->monomorphized_clone ();\n-}\n-\n } // namespace TyTy\n } // namespace Rust"}]}