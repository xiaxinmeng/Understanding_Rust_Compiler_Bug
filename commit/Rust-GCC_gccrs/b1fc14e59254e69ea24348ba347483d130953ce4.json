{"sha": "b1fc14e59254e69ea24348ba347483d130953ce4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFmYzE0ZTU5MjU0ZTY5ZWEyNDM0OGJhMzQ3NDgzZDEzMDk1M2NlNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T18:57:22Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T18:57:22Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r566", "tree": {"sha": "58017497ea7fb27ccc0a443bd26f651728f2bd92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58017497ea7fb27ccc0a443bd26f651728f2bd92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1fc14e59254e69ea24348ba347483d130953ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1fc14e59254e69ea24348ba347483d130953ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1fc14e59254e69ea24348ba347483d130953ce4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1fc14e59254e69ea24348ba347483d130953ce4/comments", "author": null, "committer": null, "parents": [{"sha": "9b72fab4b724d273d7df2c94398adc1394ee52bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b72fab4b724d273d7df2c94398adc1394ee52bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b72fab4b724d273d7df2c94398adc1394ee52bb"}], "stats": {"total": 102, "additions": 72, "deletions": 30}, "files": [{"sha": "714ee53efbd387795b2c58d8233b9bed59627c4e", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 72, "deletions": 30, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fc14e59254e69ea24348ba347483d130953ce4/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fc14e59254e69ea24348ba347483d130953ce4/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=b1fc14e59254e69ea24348ba347483d130953ce4", "patch": "@@ -31,10 +31,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define ASM_SPEC \" %{pipe:-} %{fpic:-k} %{fPIC:-k}\"\n \n-/* Prevent error on `-dalign', `-sun4' and `-target sun4' options.  */\n-/* Also, make it easy to specify interesting optimization options.  */\n+/* Prevent error on `-sun4' and `-target sun4' options.  */\n+/* This used to translate -dalign to -malign, but that is no good\n+   because it can't turn off the usual meaning of making debugging dumps.  */\n \n-#define CC1_SPEC \"%{dalign:-malign} %{sun4:} %{target:}\"\n+#define CC1_SPEC \"%{sun4:} %{target:}\"\n \n #define PTRDIFF_TYPE \"int\"\n #define SIZE_TYPE \"int\"\n@@ -56,7 +57,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\\\n  (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"include\")\t\t\\\n   || !strcmp (STR, \"imacros\") || !strcmp (STR, \"target\")\t\\\n-  || !strcmp (STR, \"assert\"))\n+  || !strcmp (STR, \"assert\") || !strcmp (STR, \"aux-info\"))\n \n /* Names to predefine in the preprocessor for this target machine.  */\n \n@@ -85,9 +86,13 @@ extern int target_flags;\n    pc-relative range.  Useful with -fomit-frame-pointer.  */\n #define TARGET_TAIL_CALL (target_flags & 8)\n \n-/* Nonzero means that references to doublewords are guaranteed\n-   aligned...if not, its a bug in the users program!  */\n-#define TARGET_ALIGN (target_flags & 16)\n+/* Nonzero means that reference doublewords as if they were guaranteed\n+   to be aligned...if they aren't, too bad for the user!\n+   Like -fast in Sun cc.  */\n+#define TARGET_HOPE_ALIGN (target_flags & 16)\n+\n+/* Nonzero means that make sure all doubles are on 8-byte boundaries.  */\n+#define TARGET_FORCE_ALIGN (target_flags & 32)\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n@@ -101,8 +106,9 @@ extern int target_flags;\n     {\"epilogue\", 2},\t\t\\\n     {\"no-epilogue\", -2},\t\\\n     {\"tail-call\", 8},\t\t\\\n-    {\"align\", 16},\t\t\\\n-   { \"\", TARGET_DEFAULT}}\n+    {\"hope-align\", 16},\t\t\\\n+    {\"force-align\", 48},\t\\\n+    { \"\", TARGET_DEFAULT}}\n \n #define TARGET_DEFAULT 3\n \f\n@@ -639,7 +645,14 @@ extern char leaf_reg_backmap[];\n #define CUMULATIVE_ARGS int\n \n #define ROUND_ADVANCE(SIZE)\t\\\n-  ((SIZE + UNITS_PER_WORD - 1)/UNITS_PER_WORD)\n+  ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Round a register number up to a proper boundary for an arg of mode MODE.\n+   Note that we need an odd/even pair for a two-word arg,\n+   since that will become 8-byte aligned when stored in memory.  */\n+#define ROUND_REG(X, MODE) \t\t\t\t\t\\\n+ (TARGET_FORCE_ALIGN && GET_MODE_UNIT_SIZE ((MODE)) > 4\t\t\\\n+  ? ((X) + ! ((X) & 1)) : (X))\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -655,9 +668,10 @@ extern char leaf_reg_backmap[];\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\t\\\n-\t    ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n-\t    : ROUND_ADVANCE (int_size_in_bytes (TYPE))))\n+ ((CUM) = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n+\t   + ((MODE) != BLKmode\t\t\t\t\\\n+\t      ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n+\t      : ROUND_ADVANCE (int_size_in_bytes (TYPE)))))\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -677,19 +691,25 @@ extern char leaf_reg_backmap[];\n    is at least partially passed in a register unless its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n-((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n+(ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\t\\\n  && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n- && ((TYPE)==0 || (MODE) != BLKmode || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\\\n- ? gen_rtx (REG, (MODE), BASE_PASSING_ARG_REG (MODE) + (CUM)) : 0)\n+ && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n+     || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n+ ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n+\t    (BASE_PASSING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\t\\\n+ : 0)\n \n /* Define where a function finds its arguments.\n    This is different from FUNCTION_ARG because of register windows.  */\n \n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n+(ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\t\\\n  && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n- && ((MODE) != BLKmode || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\\\n- ? gen_rtx (REG, (MODE), BASE_INCOMING_ARG_REG (MODE) + (CUM)) : 0)\n+ && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n+     || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n+ ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n+\t    (BASE_INCOMING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\t\\\n+ : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -698,23 +718,40 @@ extern char leaf_reg_backmap[];\n    needs partial registers on the Sparc.  */\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n-  (((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n+  ((ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\\\n     && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n-    && ((TYPE)==0 || (MODE) != BLKmode || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\\\n-    && ((CUM)\t\t\t\t\t\t\t\t\\\n+    && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n+\t|| (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n+    && (ROUND_REG ((CUM), (MODE))\t\t\t\t\t\\\n \t+ ((MODE) == BLKmode\t\t\t\t\t\t\\\n \t   ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\t\\\n-\t   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))) - NPARM_REGS > 0)\t\t\\\n-   ? (NPARM_REGS - (CUM))\t\t\t\t\t\t\\\n+\t   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))) - NPARM_REGS > 0)\t\\\n+   ? (NPARM_REGS - ROUND_REG ((CUM), (MODE)))\t\t\t\t\\\n    : 0)\n \n /* The SPARC ABI stipulates passing struct arguments (of any size)\n    by invisible reference.  */\n-/* Must pass by reference if this is a structure/union type, and this is not\n-   target gnu or the address of this structure is needed somewhere.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n   (TYPE && (TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE (TYPE) == UNION_TYPE))\n \n+/* If defined, a C expression that gives the alignment boundary, in\n+   bits, of an argument with the specified mode and type.  If it is\n+   not defined,  `PARM_BOUNDARY' is used for all arguments.\n+\n+   This definition does nothing special unless TARGET_FORCE_ALIGN;\n+   in that case, it aligns each arg to the natural boundary.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\\\n+ (! TARGET_FORCE_ALIGN\t\t\t\t\t\t\\\n+  ? PARM_BOUNDARY\t\t\t\t\t\t\\\n+  : (((TYPE) != 0)\t\t\t\t\t\t\\\n+     ? (TYPE_ALIGN (TYPE) <= PARM_BOUNDARY\t\t\t\\\n+\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n+\t: TYPE_ALIGN (TYPE))\t\t\t\t\t\\\n+     : (GET_MODE_ALIGNMENT (MODE) <= PARM_BOUNDARY\t\t\\\n+\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n+\t: GET_MODE_ALIGNMENT (MODE))))\n+\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n@@ -1394,11 +1431,15 @@ extern struct rtx_def *legitimize_pic_address ();\n \n /* This is how to output an assembler line defining a `double' constant.  */\n \n+/* Assemblers (both gas 1.35 and as in 4.0.3)\n+   seem to treat -0.0 as if it were 0.0.\n+   They reject 99e9999, but accept inf.  */\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.double 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n-    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.double 0r%sinf\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n+    else if (REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n+\t     || REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunion { double d; long l[2];} t;\t\t\t\t\\\n \tt.d = (VALUE);\t\t\t\t\t\t\t\\\n@@ -1413,8 +1454,9 @@ extern struct rtx_def *legitimize_pic_address ();\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.single 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n-    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.single 0r%sinf\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n+    else if (REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n+\t     || REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunion { float f; long l;} t;\t\t\t\t\t\\\n \tt.f = (VALUE);\t\t\t\t\t\t\t\\"}]}