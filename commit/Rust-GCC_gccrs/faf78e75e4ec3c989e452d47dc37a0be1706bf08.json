{"sha": "faf78e75e4ec3c989e452d47dc37a0be1706bf08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFmNzhlNzVlNGVjM2M5ODllNDUyZDQ3ZGMzN2EwYmUxNzA2YmYwOA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-25T10:00:23Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-25T10:00:23Z"}, "message": "Merge branch 'master' of https://github.com/redbrain/gccrs", "tree": {"sha": "8cd4b2b11b9d7e259466fff9638c0057fcc52340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cd4b2b11b9d7e259466fff9638c0057fcc52340"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faf78e75e4ec3c989e452d47dc37a0be1706bf08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faf78e75e4ec3c989e452d47dc37a0be1706bf08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faf78e75e4ec3c989e452d47dc37a0be1706bf08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faf78e75e4ec3c989e452d47dc37a0be1706bf08/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "859720937474816d4d386664d56d80a9e840f06f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859720937474816d4d386664d56d80a9e840f06f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859720937474816d4d386664d56d80a9e840f06f"}, {"sha": "8d34ac3c1602d8506ae4b65d92075be86f5a6c9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d34ac3c1602d8506ae4b65d92075be86f5a6c9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d34ac3c1602d8506ae4b65d92075be86f5a6c9a"}], "stats": {"total": 1894, "additions": 1797, "deletions": 97}, "files": [{"sha": "97dc60310fddb9579c1d958234e36ce7e6157fed", "filename": ".github/workflows/ccpp.yml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/.github%2Fworkflows%2Fccpp.yml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/.github%2Fworkflows%2Fccpp.yml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fworkflows%2Fccpp.yml?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -44,5 +44,9 @@ jobs:\n     - name: Build\n       run: |\n            cd gccrs-build; \\\n-           make; \\\n+           make\n+\n+    - name: Test\n+      run: |\n+           cd gccrs-build; \\\n            make check-rust"}, {"sha": "1e1ec49e6a8fc387982493a4bae9cfa7947ce528", "filename": "README.md", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/README.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/README.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/README.md?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -3,10 +3,16 @@\n ![Docker Pulls](https://img.shields.io/docker/pulls/philberty/gccrs)\n [![project chat](https://img.shields.io/badge/zulip-join_chat-brightgreen.svg)](https://gcc-rust.zulipchat.com/)\n # GCC Rust\n+![GCC Rust](logo.png?raw=true \"GCC rust Logo\")\n \n-This is a full alternative implementaion of the Rust language ontop of GCC.\n-Please see the accompanying reporting repository: https://github.com/Rust-GCC/Reporting for\n-status reports from Philip Herron and tast tracking overviews.\n+This is a full alternative implementaion of the Rust language ontop of GCC which the goal\n+to become fully upstream with the GNU toolchain.\n+\n+The origin of this project was a community effort several years ago where Rust was still at version 0.9;\n+the language was subject to so much change that it became difficult for a community effort to play catch up.\n+Now that the language is in a stable state, it is a good time to create alternative compilers. The developers of\n+the project are keen \u201cRustaceans\u201d with a desire to give back to the Rust community and to learn what GCC is capable\n+of when it comes to a modern language.\n \n ## Development Enviroment\n \n@@ -38,7 +44,7 @@ Running the compiler itself without make install we can simply invoke the compil\n $ gdb --args ./gcc/rust1 test.rs -frust-dump-parse -Warray-bounds -dumpbase test.rs -mtune=generic -march=x86-64 -O0 -version -fdump-tree-gimple -o test.s -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib64\n ```\n \n-Invoking the compiler driver we need to:\n+To invoking the compiler driver (gccrs) we need to:\n \n ```\n $ make install\n@@ -68,6 +74,10 @@ There is a docker image hosted over on:\n \n https://hub.docker.com/repository/docker/philberty/gccrs\n \n+```\n+$ docker pull philberty/gccrs\n+```\n+\n Or you can build your own image:\n \n ```"}, {"sha": "78a0662223510bc101b1475b5cfa21cbc12eeb8b", "filename": "gcc/rust/ast/clone-test.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Fclone-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Fclone-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Fclone-test.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef CLONE_TEST_H\n #define CLONE_TEST_H\n // Potential fancy deep cloning test for use with unique_ptr"}, {"sha": "b01255ed648d596792e8b191ae4451726db9b2dd", "filename": "gcc/rust/ast/rust-ast-containers.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-ast-containers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-ast-containers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-containers.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_CONTAINERS_H\n #define RUST_AST_CONTAINERS_H\n // crappy redefined AST maybe. may move"}, {"sha": "8366f7897dc75a9ffd58afb0de3eb5b7e1427d63", "filename": "gcc/rust/ast/rust-ast-full.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-ast-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-ast-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_FULL_H\n #define RUST_AST_FULL_H\n // Use as a fast way of including all aspects of the AST (i.e. all headers)\n@@ -10,4 +28,4 @@\n #include \"rust-type.h\"\n #include \"rust-macro.h\"\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "a2b505bee51e1782b7bdca333e681544e0ddac46", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_VISITOR_H\n #define RUST_AST_VISITOR_H\n // Visitor base for AST"}, {"sha": "77d1d4d0cee7d32ee76bd2d0d450f31213d8c395", "filename": "gcc/rust/ast/rust-cond-compilation.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-cond-compilation.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_CONDCOMPILATION\n #define RUST_AST_CONDCOMPILATION\n // Conditional compilation-related AST stuff"}, {"sha": "4fb478544b9d960ae002777f52f05e2dedec27a3", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -552,6 +552,8 @@ class ComparisonExpr : public OperatorExpr\n     return right_expr;\n   }\n \n+  ExprType get_kind () { return expr_type; }\n+\n   /* TODO: implement via a function call to std::cmp::PartialEq::eq(&op1, &op2)\n    * maybe? */\n protected:\n@@ -630,6 +632,8 @@ class LazyBooleanExpr : public OperatorExpr\n     return right_expr;\n   }\n \n+  ExprType get_kind () { return expr_type; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -950,9 +954,15 @@ class ArrayElems\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n protected:\n+  ArrayElems () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n   // pure virtual clone implementation\n   virtual ArrayElems *clone_array_elems_impl () const = 0;\n+\n+  NodeId node_id;\n };\n \n // Value array elements\n@@ -964,7 +974,7 @@ class ArrayElemsValues : public ArrayElems\n \n public:\n   ArrayElemsValues (std::vector<std::unique_ptr<Expr> > elems)\n-    : values (std::move (elems))\n+    : ArrayElems (), values (std::move (elems))\n   {}\n \n   // copy constructor with vector clone\n@@ -1030,7 +1040,7 @@ class ArrayElemsCopied : public ArrayElems\n   // Constructor requires pointers for polymorphism\n   ArrayElemsCopied (std::unique_ptr<Expr> copied_elem,\n \t\t    std::unique_ptr<Expr> copy_amount)\n-    : elem_to_copy (std::move (copied_elem)),\n+    : ArrayElems (), elem_to_copy (std::move (copied_elem)),\n       num_copies (std::move (copy_amount))\n   {}\n \n@@ -1089,10 +1099,6 @@ class ArrayExpr : public ExprWithoutBlock\n   // TODO: find another way to store this to save memory?\n   bool marked_for_strip = false;\n \n-  // this is a reference to what the inferred type is based on\n-  // this init expression\n-  Type *inferredType;\n-\n public:\n   std::string as_string () const override;\n \n@@ -1157,9 +1163,6 @@ class ArrayExpr : public ExprWithoutBlock\n     return internal_elements;\n   }\n \n-  Type *get_inferred_type () { return inferredType; }\n-  void set_inferred_type (Type *type) { inferredType = type; }\n-\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "b0f495611aa8ca2d5c54b8e7e04187bc6798866f", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_MACRO_H\n #define RUST_AST_MACRO_H\n "}, {"sha": "d1be6f32df2e257d10ebc2f1bd8c2708f54316e1", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_PATH_H\n #define RUST_AST_PATH_H\n /* \"Path\" (identifier within namespaces, essentially) handling. Required include"}, {"sha": "79beebb059e37f2a1363ad825970b67155deea67", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_PATTERN_H\n #define RUST_AST_PATTERN_H\n "}, {"sha": "c2ce38704e9817a0030a602192ec775f63d0ae58", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_STATEMENT_H\n #define RUST_AST_STATEMENT_H\n "}, {"sha": "0dfeb075068a10e1aa7f6864c68e610120669165", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_TYPE_H\n #define RUST_AST_TYPE_H\n "}, {"sha": "3ba837c14ea83d3c2402f78395c27064b6579eb0", "filename": "gcc/rust/backend/cscope.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Fcscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Fcscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Fcscope.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #pragma once\n \n #include \"rust-system.h\""}, {"sha": "b17fb05cabde6e6881be91de73e5c9a0b46a785f", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -0,0 +1,112 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_BLOCK\n+#define RUST_COMPILE_BLOCK\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileBlock : public HIRCompileBase\n+{\n+public:\n+  static Bblock *compile (HIR::BlockExpr *expr, Context *ctx)\n+  {\n+    CompileBlock compiler (ctx);\n+    expr->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  ~CompileBlock () {}\n+\n+  void visit (HIR::BlockExpr &expr);\n+\n+private:\n+  CompileBlock (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+\n+  Bblock *translated;\n+};\n+\n+class CompileConditionalBlocks : public HIRCompileBase\n+{\n+public:\n+  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx)\n+  {\n+    CompileConditionalBlocks resolver (ctx);\n+    expr->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  ~CompileConditionalBlocks () {}\n+\n+  void visit (HIR::IfExpr &expr);\n+\n+  void visit (HIR::IfExprConseqElse &expr);\n+\n+  void visit (HIR::IfExprConseqIf &expr);\n+\n+private:\n+  CompileConditionalBlocks (Context *ctx)\n+    : HIRCompileBase (ctx), translated (nullptr)\n+  {}\n+\n+  Bstatement *translated;\n+};\n+\n+class CompileExprWithBlock : public HIRCompileBase\n+{\n+public:\n+  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx)\n+  {\n+    CompileExprWithBlock resolver (ctx);\n+    expr->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  ~CompileExprWithBlock () {}\n+\n+  void visit (HIR::IfExpr &expr)\n+  {\n+    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+  }\n+\n+  void visit (HIR::IfExprConseqElse &expr)\n+  {\n+    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+  }\n+\n+  void visit (HIR::IfExprConseqIf &expr)\n+  {\n+    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+  }\n+\n+private:\n+  CompileExprWithBlock (Context *ctx)\n+    : HIRCompileBase (ctx), translated (nullptr)\n+  {}\n+\n+  Bstatement *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_BLOCK"}, {"sha": "5736bf2978155ac5fa63576c4e9985a217ac591f", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -211,6 +211,19 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n \n+  void visit (TyTy::ArrayType &type) override\n+  {\n+    mpz_t ival;\n+    mpz_init_set_ui (ival, type.get_capacity ());\n+\n+    Btype *capacity_type = ctx->get_backend ()->integer_type (true, 32);\n+    Bexpression *length\n+      = ctx->get_backend ()->integer_constant_expression (capacity_type, ival);\n+\n+    Btype *element_type = TyTyResolveCompile::compile (ctx, type.get_type ());\n+    translated = ctx->get_backend ()->array_type (element_type, length);\n+  }\n+\n   void visit (TyTy::BoolType &type) override\n   {\n     ::Btype *compiled_type = nullptr;\n@@ -221,9 +234,6 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::IntType &type) override\n   {\n-    printf (\"type [%s] has ref: %u\\n\", type.as_string ().c_str (),\n-\t    type.get_ref ());\n-\n     ::Btype *compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n     rust_assert (ok);"}, {"sha": "5c3206ae744a38e4e56d1a5b4d38fdfc4123d90f", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-compile-base.h\"\n #include \"rust-compile-tyty.h\"\n #include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-block.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -168,6 +169,57 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (assignment);\n   }\n \n+  void visit (HIR::ArrayIndexExpr &expr)\n+  {\n+    Bexpression *array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n+    Bexpression *index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n+    translated\n+      = ctx->get_backend ()->array_index_expression (array, index,\n+\t\t\t\t\t\t     expr.get_locus ());\n+  }\n+\n+  void visit (HIR::ArrayExpr &expr)\n+  {\n+    TyTy::TyBase *tyty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &tyty))\n+      {\n+\trust_fatal_error (expr.get_locus (),\n+\t\t\t  \"did not resolve type for this array expr\");\n+\treturn;\n+      }\n+\n+    Btype *array_type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+    expr.get_internal_elements ()->accept_vis (*this);\n+    std::vector<unsigned long> indexes;\n+    for (size_t i = 0; i < constructor.size (); i++)\n+      indexes.push_back (i);\n+\n+    translated\n+      = ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n+\t\t\t\t\t\t\t   constructor,\n+\t\t\t\t\t\t\t   expr.get_locus ());\n+  }\n+\n+  void visit (HIR::ArrayElemsValues &elems)\n+  {\n+    elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n+      Bexpression *translated_expr = CompileExpr::Compile (e, ctx);\n+      constructor.push_back (translated_expr);\n+      return true;\n+    });\n+  }\n+\n+  void visit (HIR::ArrayElemsCopied &elems)\n+  {\n+    Bexpression *translated_expr\n+      = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n+\n+    for (size_t i = 0; i < elems.get_num_elements (); ++i)\n+      constructor.push_back (translated_expr);\n+  }\n+\n   void visit (HIR::ArithmeticOrLogicalExpr &expr)\n   {\n     Operator op;\n@@ -273,10 +325,36 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t\t expr.get_locus ());\n   }\n \n+  void visit (HIR::IfExpr &expr)\n+  {\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    ctx->add_statement (stmt);\n+  }\n+\n+  void visit (HIR::IfExprConseqElse &expr)\n+  {\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    ctx->add_statement (stmt);\n+  }\n+\n+  void visit (HIR::IfExprConseqIf &expr)\n+  {\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    ctx->add_statement (stmt);\n+  }\n+\n+  void visit (HIR::BlockExpr &expr)\n+  {\n+    auto code_block = CompileBlock::compile (&expr, ctx);\n+    auto block_stmt = ctx->get_backend ()->block_statement (code_block);\n+    ctx->add_statement (block_stmt);\n+  }\n+\n private:\n   CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n \n   Bexpression *translated;\n+  std::vector<Bexpression *> constructor;\n };\n \n } // namespace Compile"}, {"sha": "5f7decb7d3e49156a9c1452b1f8f25c02de415da", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -38,6 +38,18 @@ class CompileStmt : public HIRCompileBase\n \n   virtual ~CompileStmt () {}\n \n+  void visit (HIR::ExprStmtWithBlock &stmt)\n+  {\n+    ok = true;\n+    auto translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n+\n+    // these can be null\n+    if (translated == nullptr)\n+      return;\n+\n+    gcc_unreachable ();\n+  }\n+\n   void visit (HIR::ExprStmtWithoutBlock &stmt)\n   {\n     ok = true;"}, {"sha": "02fa3a0de10bd470c3d36ef563bfd6028cf0e2c3", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-compile.h\"\n #include \"rust-compile-item.h\"\n+#include \"rust-compile-expr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -43,5 +44,113 @@ CompileCrate::go ()\n     CompileItem::compile (it->get (), ctx);\n }\n \n+// rust-compile-block.h\n+\n+void\n+CompileBlock::visit (HIR::BlockExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bfunction *fndecl = fnctx.fndecl;\n+  Location start_location = expr.get_locus ();\n+  Location end_location = expr.get_closing_locus ();\n+  auto body_mappings = expr.get_mappings ();\n+\n+  Resolver::Rib *rib = nullptr;\n+  if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"failed to setup locals per block\");\n+      return;\n+    }\n+\n+  std::vector<Bvariable *> locals;\n+  rib->iterate_decls ([&] (NodeId n) mutable -> bool {\n+    Resolver::Definition d;\n+    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+    rust_assert (ok);\n+\n+    HIR::Stmt *decl = nullptr;\n+    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+    rust_assert (ok);\n+\n+    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+    locals.push_back (compiled);\n+\n+    return true;\n+  });\n+\n+  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  Bblock *new_block\n+    = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t  start_location, end_location);\n+  ctx->push_block (new_block);\n+\n+  expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+    CompileStmt::Compile (s, ctx);\n+    return true;\n+  });\n+\n+  ctx->pop_block ();\n+  translated = new_block;\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bfunction *fndecl = fnctx.fndecl;\n+  Bexpression *condition_expr\n+    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t NULL, expr.get_locus ());\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bfunction *fndecl = fnctx.fndecl;\n+  Bexpression *condition_expr\n+    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n+  Bblock *else_block = CompileBlock::compile (expr.get_else_block (), ctx);\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t else_block, expr.get_locus ());\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bfunction *fndecl = fnctx.fndecl;\n+  Bexpression *condition_expr\n+    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n+\n+  // else block\n+  std::vector<Bvariable *> locals;\n+  Location start_location = expr.get_conseq_if_expr ()->get_locus ();\n+  Location end_location = expr.get_conseq_if_expr ()->get_locus (); // FIXME\n+  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  Bblock *else_block\n+    = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t  start_location, end_location);\n+  ctx->push_block (else_block);\n+\n+  Bstatement *else_stmt_decl\n+    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx);\n+  ctx->add_statement (else_stmt_decl);\n+\n+  ctx->pop_block ();\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t else_block, expr.get_locus ());\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "956f89f171e6a7ef3c3e4650ed85dd9a69837134", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #include \"rust-macro-expand.h\"\n #include \"rust-ast-full.h\"\n // is full really required?"}, {"sha": "ef2fb4ef9bd6ffe1b64b683d33a9dbc6cf38a09b", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_MACRO_EXPAND_H\n #define RUST_MACRO_EXPAND_H\n "}, {"sha": "11f1ab8875ad414873acdf16604359b8512ba3cf", "filename": "gcc/rust/hir/rust-ast-lower-block.h", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -0,0 +1,132 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_BLOCK\n+#define RUST_AST_LOWER_BLOCK\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringBlock : public ASTLoweringBase\n+{\n+public:\n+  static HIR::BlockExpr *translate (AST::BlockExpr *expr)\n+  {\n+    ASTLoweringBlock resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (\n+\t  resolver.translated->get_mappings ().get_crate_num (),\n+\t  resolver.translated->get_mappings ().get_hirid (),\n+\t  resolver.translated);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  ~ASTLoweringBlock () {}\n+\n+  void visit (AST::BlockExpr &expr);\n+\n+private:\n+  ASTLoweringBlock () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::BlockExpr *translated;\n+};\n+\n+class ASTLoweringIfBlock : public ASTLoweringBase\n+{\n+public:\n+  static HIR::IfExpr *translate (AST::IfExpr *expr)\n+  {\n+    ASTLoweringIfBlock resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (\n+\t  resolver.translated->get_mappings ().get_crate_num (),\n+\t  resolver.translated->get_mappings ().get_hirid (),\n+\t  resolver.translated);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  ~ASTLoweringIfBlock () {}\n+\n+  void visit (AST::IfExpr &expr);\n+\n+  void visit (AST::IfExprConseqElse &expr);\n+\n+  void visit (AST::IfExprConseqIf &expr);\n+\n+private:\n+  ASTLoweringIfBlock () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::IfExpr *translated;\n+};\n+\n+class ASTLoweringExprWithBlock : public ASTLoweringBase\n+{\n+public:\n+  static HIR::ExprWithBlock *translate (AST::ExprWithBlock *expr)\n+  {\n+    ASTLoweringExprWithBlock resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (\n+\t  resolver.translated->get_mappings ().get_crate_num (),\n+\t  resolver.translated->get_mappings ().get_hirid (),\n+\t  resolver.translated);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  ~ASTLoweringExprWithBlock () {}\n+\n+  void visit (AST::IfExpr &expr)\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr);\n+  }\n+\n+  void visit (AST::IfExprConseqElse &expr)\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr);\n+  }\n+\n+  void visit (AST::IfExprConseqIf &expr)\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr);\n+  }\n+\n+private:\n+  ASTLoweringExprWithBlock () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::ExprWithBlock *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_BLOCK"}, {"sha": "a165eaf3c8a3a96451b96090b1722e7099246746", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 209, "deletions": 7, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -20,32 +20,91 @@\n #define RUST_AST_LOWER_EXPR\n \n #include \"rust-diagnostics.h\"\n-\n #include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-block.h\"\n \n namespace Rust {\n namespace HIR {\n \n+class ArrayCapacityConstant : public ASTLoweringBase\n+{\n+public:\n+  static bool fold (AST::Expr *expr, size_t *folded_result)\n+  {\n+    ArrayCapacityConstant folder;\n+    expr->accept_vis (folder);\n+    *folded_result = folder.result;\n+    return folder.ok;\n+  }\n+\n+  virtual ~ArrayCapacityConstant () {}\n+\n+  void visit (AST::LiteralExpr &expr)\n+  {\n+    switch (expr.get_lit_type ())\n+      {\n+\tcase AST::Literal::LitType::INT: {\n+\t  ok = true;\n+\t  std::stringstream ss (expr.as_string ());\n+\t  ss >> result;\n+\t}\n+\tbreak;\n+\n+      default:\n+\treturn;\n+      }\n+  }\n+\n+private:\n+  ArrayCapacityConstant () : ok (false), result (-1) {}\n+\n+  bool ok;\n+  size_t result;\n+}; // namespace Resolver\n+\n class ASTLoweringExpr : public ASTLoweringBase\n {\n public:\n   static HIR::Expr *translate (AST::Expr *expr)\n   {\n     ASTLoweringExpr resolver;\n     expr->accept_vis (resolver);\n-    if (resolver.translated != nullptr)\n+    if (resolver.translated == nullptr)\n       {\n-\tresolver.mappings->insert_hir_expr (\n-\t  resolver.translated->get_mappings ().get_crate_num (),\n-\t  resolver.translated->get_mappings ().get_hirid (),\n-\t  resolver.translated);\n+\trust_fatal_error (expr->get_locus_slow (), \"Failed to lower expr: [%s]\",\n+\t\t\t  expr->as_string ().c_str ());\n+\treturn nullptr;\n       }\n \n+    resolver.mappings->insert_hir_expr (\n+      resolver.translated->get_mappings ().get_crate_num (),\n+      resolver.translated->get_mappings ().get_hirid (), resolver.translated);\n+\n     return resolver.translated;\n   }\n \n   virtual ~ASTLoweringExpr () {}\n \n+  void visit (AST::IfExpr &expr)\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr);\n+  }\n+\n+  void visit (AST::IfExprConseqElse &expr)\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr);\n+  }\n+\n+  void visit (AST::IfExprConseqIf &expr)\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr);\n+  }\n+\n+  void visit (AST::BlockExpr &expr)\n+  {\n+    translated = ASTLoweringBlock::translate (&expr);\n+  }\n+\n   void visit (AST::PathInExpression &expr)\n   {\n     std::vector<HIR::PathExprSegment> path_segments;\n@@ -133,6 +192,78 @@ class ASTLoweringExpr : public ASTLoweringBase\n       = new HIR::IdentifierExpr (mapping, expr.as_string (), expr.get_locus ());\n   }\n \n+  void visit (AST::ArrayExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+    std::vector<HIR::Attribute> inner_attribs;\n+\n+    expr.get_array_elems ()->accept_vis (*this);\n+    rust_assert (translated_array_elems != nullptr);\n+    HIR::ArrayElems *elems = translated_array_elems;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ArrayExpr (mapping, std::unique_ptr<HIR::ArrayElems> (elems),\n+\t\t\t    inner_attribs, outer_attribs, expr.get_locus ());\n+  }\n+\n+  void visit (AST::ArrayIndexExpr &expr)\n+  {\n+    std::vector<Attribute> outer_attribs;\n+    HIR::Expr *array_expr\n+      = ASTLoweringExpr::translate (expr.get_array_expr ().get ());\n+    HIR::Expr *array_index_expr\n+      = ASTLoweringExpr::translate (expr.get_index_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ArrayIndexExpr (mapping,\n+\t\t\t\t std::unique_ptr<HIR::Expr> (array_expr),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (array_index_expr),\n+\t\t\t\t outer_attribs, expr.get_locus ());\n+  }\n+\n+  void visit (AST::ArrayElemsValues &elems)\n+  {\n+    std::vector<std::unique_ptr<HIR::Expr> > elements;\n+    elems.iterate ([&] (AST::Expr *elem) mutable -> bool {\n+      HIR::Expr *translated_elem = ASTLoweringExpr::translate (elem);\n+      elements.push_back (std::unique_ptr<HIR::Expr> (translated_elem));\n+      return true;\n+    });\n+\n+    translated_array_elems = new HIR::ArrayElemsValues (std::move (elements));\n+  }\n+\n+  void visit (AST::ArrayElemsCopied &elems)\n+  {\n+    HIR::Expr *element\n+      = ASTLoweringExpr::translate (elems.get_elem_to_copy ().get ());\n+    HIR::Expr *num_copies\n+      = ASTLoweringExpr::translate (elems.get_num_copies ().get ());\n+\n+    size_t folded;\n+    if (!ArrayCapacityConstant::fold (elems.get_num_copies ().get (), &folded))\n+      {\n+\trust_fatal_error (elems.get_num_copies ()->get_locus_slow (),\n+\t\t\t  \"failed to fold capacity constant\");\n+\treturn;\n+      }\n+\n+    translated_array_elems\n+      = new HIR::ArrayElemsCopied (std::unique_ptr<HIR::Expr> (element),\n+\t\t\t\t   std::unique_ptr<HIR::Expr> (num_copies),\n+\t\t\t\t   folded);\n+  }\n+\n   void visit (AST::LiteralExpr &expr)\n   {\n     HIR::Literal::LitType type = HIR::Literal::LitType::CHAR;\n@@ -230,10 +361,81 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t\t  kind, expr.get_locus ());\n   }\n \n+  void visit (AST::ComparisonExpr &expr)\n+  {\n+    HIR::ComparisonExpr::ExprType kind;\n+    switch (expr.get_kind ())\n+      {\n+      case AST::ComparisonExpr::ExprType::EQUAL:\n+\tkind = HIR::ComparisonExpr::ExprType::EQUAL;\n+\tbreak;\n+      case AST::ComparisonExpr::ExprType::NOT_EQUAL:\n+\tkind = HIR::ComparisonExpr::ExprType::NOT_EQUAL;\n+\tbreak;\n+      case AST::ComparisonExpr::ExprType::GREATER_THAN:\n+\tkind = HIR::ComparisonExpr::ExprType::GREATER_THAN;\n+\tbreak;\n+      case AST::ComparisonExpr::ExprType::LESS_THAN:\n+\tkind = HIR::ComparisonExpr::ExprType::LESS_THAN;\n+\tbreak;\n+      case AST::ComparisonExpr::ExprType::GREATER_OR_EQUAL:\n+\tkind = HIR::ComparisonExpr::ExprType::GREATER_OR_EQUAL;\n+\tbreak;\n+      case AST::ComparisonExpr::ExprType::LESS_OR_EQUAL:\n+\tkind = HIR::ComparisonExpr::ExprType::LESS_OR_EQUAL;\n+\tbreak;\n+      }\n+\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    rust_assert (lhs != nullptr);\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+    rust_assert (rhs != nullptr);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ComparisonExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (rhs), kind,\n+\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (AST::LazyBooleanExpr &expr)\n+  {\n+    HIR::LazyBooleanExpr::ExprType kind;\n+    switch (expr.get_kind ())\n+      {\n+      case AST::LazyBooleanExpr::ExprType::LOGICAL_AND:\n+\tkind = HIR::LazyBooleanExpr::ExprType::LOGICAL_AND;\n+\tbreak;\n+      case AST::LazyBooleanExpr::ExprType::LOGICAL_OR:\n+\tkind = HIR::LazyBooleanExpr::ExprType::LOGICAL_OR;\n+\tbreak;\n+      }\n+\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    rust_assert (lhs != nullptr);\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+    rust_assert (rhs != nullptr);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::LazyBooleanExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (rhs), kind,\n+\t\t\t\t  expr.get_locus ());\n+  }\n+\n private:\n-  ASTLoweringExpr () : translated (nullptr) {}\n+  ASTLoweringExpr () : translated (nullptr), translated_array_elems (nullptr) {}\n \n   HIR::Expr *translated;\n+  HIR::ArrayElems *translated_array_elems;\n };\n \n } // namespace HIR"}, {"sha": "f57ac8634881d1e45622511b2738e70b06002a48", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-ast-lower-type.h\"\n #include \"rust-ast-lower-stmt.h\"\n #include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-block.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -83,7 +84,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \n     std::unique_ptr<HIR::BlockExpr> function_body\n       = std::unique_ptr<HIR::BlockExpr> (\n-\ttranslate (function.get_definition ().get ()));\n+\tASTLoweringBlock::translate (function.get_definition ().get ()));\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n@@ -116,33 +117,6 @@ class ASTLoweringItem : public ASTLoweringBase\n     translated = fn;\n   }\n \n-  // Helpers\n-\n-  HIR::BlockExpr *translate (AST::BlockExpr *function_body)\n-  {\n-    std::vector<std::unique_ptr<HIR::Stmt> > block_stmts;\n-    std::unique_ptr<HIR::ExprWithoutBlock> block_expr;\n-    std::vector<HIR::Attribute> inner_attribs;\n-    std::vector<HIR::Attribute> outer_attribs;\n-\n-    function_body->iterate_stmts ([&] (AST::Stmt *s) mutable -> bool {\n-      auto translated_stmt = ASTLoweringStmt::translate (s);\n-      block_stmts.push_back (std::unique_ptr<HIR::Stmt> (translated_stmt));\n-      return true;\n-    });\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, function_body->get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    return new HIR::BlockExpr (mapping, std::move (block_stmts),\n-\t\t\t       std::move (block_expr),\n-\t\t\t       std::move (inner_attribs),\n-\t\t\t       std::move (outer_attribs),\n-\t\t\t       function_body->get_locus ());\n-  }\n-\n private:\n   ASTLoweringItem () : translated (nullptr) {}\n "}, {"sha": "f4ecd8ec2c1040f5fba2e4764d272314d880c891", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -23,6 +23,7 @@\n \n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-block.h\"\n #include \"rust-ast-lower-expr.h\"\n #include \"rust-ast-lower-pattern.h\"\n \n@@ -46,6 +47,24 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   virtual ~ASTLoweringStmt () {}\n \n+  void visit (AST::ExprStmtWithBlock &stmt)\n+  {\n+    HIR::ExprWithBlock *expr\n+      = ASTLoweringExprWithBlock::translate (stmt.get_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::ExprStmtWithBlock (mapping,\n+\t\t\t\t    std::unique_ptr<HIR::ExprWithBlock> (expr),\n+\t\t\t\t    stmt.get_locus ());\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       stmt.get_locus ());\n+    mappings->insert_hir_stmt (crate_num, mapping.get_hirid (), translated);\n+  }\n+\n   void visit (AST::ExprStmtWithoutBlock &stmt)\n   {\n     HIR::Expr *expr = ASTLoweringExpr::translate (stmt.get_expr ().get ());"}, {"sha": "2e14ad2b62bb7ec13bd51ae5b406c3d134eb5d39", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-ast-lower-base.h\"\n #include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-expr.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -77,6 +78,27 @@ class ASTLoweringType : public ASTLoweringBase\n \t\t\t       translated);\n   }\n \n+  void visit (AST::ArrayType &type)\n+  {\n+    HIR::Type *translated_type\n+      = ASTLoweringType::translate (type.get_elem_type ().get ());\n+    HIR::Expr *array_size\n+      = ASTLoweringExpr::translate (type.get_size_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::ArrayType (mapping,\n+\t\t\t    std::unique_ptr<HIR::Type> (translated_type),\n+\t\t\t    std::unique_ptr<HIR::Expr> (array_size),\n+\t\t\t    type.get_locus ());\n+    mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+  }\n+\n private:\n   ASTLoweringType () : translated (nullptr) {}\n "}, {"sha": "93288c37286dc26763391dc4643b5fcd37fe3753", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -18,6 +18,8 @@\n \n #include \"rust-ast-lower.h\"\n #include \"rust-ast-lower-item.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-block.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -58,5 +60,94 @@ ASTLowering::go ()\n \t\t     has_utf8bom, has_shebang);\n }\n \n+// rust-ast-lower-block.h\n+void\n+ASTLoweringBlock::visit (AST::BlockExpr &expr)\n+{\n+  std::vector<std::unique_ptr<HIR::Stmt> > block_stmts;\n+  std::unique_ptr<HIR::ExprWithoutBlock> block_expr;\n+  std::vector<HIR::Attribute> inner_attribs;\n+  std::vector<HIR::Attribute> outer_attribs;\n+\n+  expr.iterate_stmts ([&] (AST::Stmt *s) mutable -> bool {\n+    auto translated_stmt = ASTLoweringStmt::translate (s);\n+    block_stmts.push_back (std::unique_ptr<HIR::Stmt> (translated_stmt));\n+    return true;\n+  });\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::BlockExpr (mapping, std::move (block_stmts),\n+\t\t\t  std::move (block_expr), std::move (inner_attribs),\n+\t\t\t  std::move (outer_attribs), expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringIfBlock::visit (AST::IfExpr &expr)\n+{\n+  HIR::Expr *condition\n+    = ASTLoweringExpr::translate (expr.get_condition_expr ().get ());\n+  HIR::BlockExpr *block\n+    = ASTLoweringBlock::translate (expr.get_if_block ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::IfExpr (mapping, std::unique_ptr<HIR::Expr> (condition),\n+\t\t\t\tstd::unique_ptr<HIR::BlockExpr> (block),\n+\t\t\t\texpr.get_locus ());\n+}\n+\n+void\n+ASTLoweringIfBlock::visit (AST::IfExprConseqElse &expr)\n+{\n+  HIR::Expr *condition\n+    = ASTLoweringExpr::translate (expr.get_condition_expr ().get ());\n+  HIR::BlockExpr *if_block\n+    = ASTLoweringBlock::translate (expr.get_if_block ().get ());\n+  HIR::BlockExpr *else_block\n+    = ASTLoweringBlock::translate (expr.get_else_block ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::IfExprConseqElse (mapping,\n+\t\t\t\t std::unique_ptr<HIR::Expr> (condition),\n+\t\t\t\t std::unique_ptr<HIR::BlockExpr> (if_block),\n+\t\t\t\t std::unique_ptr<HIR::BlockExpr> (else_block),\n+\t\t\t\t expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringIfBlock::visit (AST::IfExprConseqIf &expr)\n+{\n+  HIR::Expr *condition\n+    = ASTLoweringExpr::translate (expr.get_condition_expr ().get ());\n+  HIR::BlockExpr *block\n+    = ASTLoweringBlock::translate (expr.get_if_block ().get ());\n+  HIR::IfExpr *conseq_if_expr\n+    = ASTLoweringIfBlock::translate (expr.get_conseq_if_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::IfExprConseqIf (mapping, std::unique_ptr<HIR::Expr> (condition),\n+\t\t\t       std::unique_ptr<HIR::BlockExpr> (block),\n+\t\t\t       std::unique_ptr<HIR::IfExpr> (conseq_if_expr),\n+\t\t\t       expr.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "1110f988dc7626e6d7eaf9315e6279b73bde88db", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -538,6 +538,8 @@ class ComparisonExpr : public OperatorExpr\n   Expr *get_lhs () { return main_or_left_expr.get (); }\n   Expr *get_rhs () { return right_expr.get (); }\n \n+  ExprType get_kind () { return expr_type; }\n+\n   /* TODO: implement via a function call to std::cmp::PartialEq::eq(&op1, &op2)\n    * maybe? */\n protected:\n@@ -910,6 +912,8 @@ class ArrayElems\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  virtual size_t get_num_elements () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual ArrayElems *clone_array_elems_impl () const = 0;\n@@ -953,7 +957,7 @@ class ArrayElemsValues : public ArrayElems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  size_t get_num_values () const { return values.size (); }\n+  size_t get_num_elements () const override { return values.size (); }\n \n   void iterate (std::function<bool (Expr *)> cb)\n   {\n@@ -976,28 +980,33 @@ class ArrayElemsCopied : public ArrayElems\n {\n   std::unique_ptr<Expr> elem_to_copy;\n   std::unique_ptr<Expr> num_copies;\n+  size_t folded_copy_amount;\n \n   // TODO: should this store location data?\n \n public:\n   // Constructor requires pointers for polymorphism\n   ArrayElemsCopied (std::unique_ptr<Expr> copied_elem,\n-\t\t    std::unique_ptr<Expr> copy_amount)\n+\t\t    std::unique_ptr<Expr> copy_amount,\n+\t\t    size_t folded_copy_amount)\n     : elem_to_copy (std::move (copied_elem)),\n-      num_copies (std::move (copy_amount))\n+      num_copies (std::move (copy_amount)),\n+      folded_copy_amount (folded_copy_amount)\n   {}\n \n   // Copy constructor required due to unique_ptr - uses custom clone\n   ArrayElemsCopied (ArrayElemsCopied const &other)\n     : elem_to_copy (other.elem_to_copy->clone_expr ()),\n-      num_copies (other.num_copies->clone_expr ())\n+      num_copies (other.num_copies->clone_expr ()),\n+      folded_copy_amount (other.folded_copy_amount)\n   {}\n \n   // Overloaded assignment operator for deep copying\n   ArrayElemsCopied &operator= (ArrayElemsCopied const &other)\n   {\n     elem_to_copy = other.elem_to_copy->clone_expr ();\n     num_copies = other.num_copies->clone_expr ();\n+    folded_copy_amount = other.folded_copy_amount;\n \n     return *this;\n   }\n@@ -1010,6 +1019,10 @@ class ArrayElemsCopied : public ArrayElems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  size_t get_num_elements () const override { return folded_copy_amount; }\n+\n+  Expr *get_elem_to_copy () { return elem_to_copy.get (); }\n+\n protected:\n   ArrayElemsCopied *clone_array_elems_impl () const override\n   {\n@@ -1025,10 +1038,6 @@ class ArrayExpr : public ExprWithoutBlock\n \n   Location locus;\n \n-  // this is a reference to what the inferred type is based on\n-  // this init expression\n-  Type *inferredType;\n-\n public:\n   std::string as_string () const override;\n \n@@ -1080,9 +1089,6 @@ class ArrayExpr : public ExprWithoutBlock\n \n   ArrayElems *get_internal_elements () { return internal_elements.get (); };\n \n-  Type *get_inferred_type () { return inferredType; }\n-  void set_inferred_type (Type *type) { inferredType = type; }\n-\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3647,6 +3653,8 @@ class IfExprConseqElse : public IfExpr\n \n   void vis_else_block (HIRVisitor &vis) { else_block->accept_vis (vis); }\n \n+  BlockExpr *get_else_block () { return else_block.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3715,6 +3723,8 @@ class IfExprConseqIf : public IfExpr\n     conseq_if_expr->accept_vis (vis);\n   }\n \n+  IfExpr *get_conseq_if_expr () { return conseq_if_expr.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "2e30b594413d02d7bf025bd2fe7866fe092e50b7", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -286,7 +286,7 @@ Visibility::as_string () const\n     case NONE:\n       return std::string (\"pub\");\n     case CRATE:\n-      return std::string (\"ub(crate)\");\n+      return std::string (\"pub(crate)\");\n     case SELF:\n       return std::string (\"pub(self)\");\n     case SUPER:"}, {"sha": "be4ff7da6851fff0c4ccffe2f3a28436e2994e82", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -192,13 +192,11 @@ class ExprStmtWithoutBlock : public ExprStmt\n // Statement containing an expression with a block\n class ExprStmtWithBlock : public ExprStmt\n {\n-public:\n   std::unique_ptr<ExprWithBlock> expr;\n \n+public:\n   std::string as_string () const override;\n \n-  std::vector<LetStmt *> locals;\n-\n   ExprStmtWithBlock (Analysis::NodeMapping mappings,\n \t\t     std::unique_ptr<ExprWithBlock> expr, Location locus)\n     : ExprStmt (std::move (mappings), locus), expr (std::move (expr))\n@@ -224,6 +222,8 @@ class ExprStmtWithBlock : public ExprStmt\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  ExprWithBlock *get_expr () { return expr.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "836f819bf95eb297ee100e9e99cec55316550796", "filename": "gcc/rust/lex/rust-codepoint.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-codepoint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-codepoint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-codepoint.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_CODEPOINT_H\n #define RUST_CODEPOINT_H\n "}, {"sha": "b97eea1590639745470f676bd8ded8cd878dbefd", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #include \"rust-lex.h\"\n \n #include \"rust-system.h\"      // for rust_assert and rust_unreachable"}, {"sha": "abaa71b8a1dfebbabd396df6ab45fda18e0e8727", "filename": "gcc/rust/lex/rust-token.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #include \"rust-token.h\"\n \n #include \"rust-diagnostics.h\" // for error_at"}, {"sha": "fab736a6b54694b0e230d4b1585dd78b810096c7", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_TOKEN_H\n #define RUST_TOKEN_H\n "}, {"sha": "cc89ad539b3cc158a1b51319bd0c8b738cd3d787", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,19 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n /* Template implementation for Rust::Parser. Previously in rust-parse.cc (before\n  * Parser was template). Separated from rust-parse.h for readability. */\n "}, {"sha": "62076ee93cc64de57becc56da6dbeff5a6f99eed", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,19 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n #include \"rust-parse.h\"\n #include \"rust-linemap.h\"\n #include \"rust-diagnostics.h\""}, {"sha": "2778ec7a920237e680f2dd91043298104f729d4a", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,19 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n #ifndef RUST_PARSE_H\n #define RUST_PARSE_H\n "}, {"sha": "d86866c0b87b75726c6b720bce9fb3e6b20cbe3f", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -95,6 +95,65 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::ComparisonExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::LazyBooleanExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::IfExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::IfExprConseqElse &expr)\n+  {\n+    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_else_block ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::IfExprConseqIf &expr)\n+  {\n+    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::BlockExpr &expr);\n+\n+  void visit (AST::ArrayElemsValues &elems)\n+  {\n+    elems.iterate ([&] (AST::Expr *elem) mutable -> bool {\n+      ResolveExpr::go (elem, elems.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n+  void visit (AST::ArrayExpr &expr)\n+  {\n+    expr.get_array_elems ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::ArrayIndexExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_array_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_index_expr ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::ArrayElemsCopied &elems)\n+  {\n+    ResolveExpr::go (elems.get_num_copies ().get (), elems.get_node_id ());\n+    ResolveExpr::go (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "87b3cf339cb47c9436a61fef49953acd506d9c92", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -39,6 +39,11 @@ class ResolveStmt : public ResolverBase\n \n   ~ResolveStmt () {}\n \n+  void visit (AST::ExprStmtWithBlock &stmt)\n+  {\n+    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());\n+  }\n+\n   void visit (AST::ExprStmtWithoutBlock &stmt)\n   {\n     ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());"}, {"sha": "9d408a92b1b2d649eb127e1141e0cbd5e97a95f6", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -42,7 +42,7 @@ class ResolveType : public ResolverBase\n \n   ~ResolveType () {}\n \n-  virtual void visit (AST::TypePath &path)\n+  void visit (AST::TypePath &path)\n   {\n     // this will need changed to handle mod/crate/use globs and look\n     // at the segments in granularity\n@@ -56,6 +56,11 @@ class ResolveType : public ResolverBase\n       }\n   }\n \n+  void visit (AST::ArrayType &type)\n+  {\n+    type.get_elem_type ()->accept_vis (*this);\n+  }\n+\n private:\n   ResolveType (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "8370a5b97e0b8958a96f5985cb4010865ac49f56", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -17,10 +17,11 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-ast-resolve.h\"\n-#include \"rust-ast-resolve-toplevel.h\"\n-#include \"rust-ast-resolve-item.h\"\n #include \"rust-ast-full.h\"\n #include \"rust-tyty.h\"\n+#include \"rust-ast-resolve-toplevel.h\"\n+#include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-resolve-expr.h\"\n \n #define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n   do                                                                           \\\n@@ -250,5 +251,25 @@ NameResolution::go (AST::Crate &crate)\n     ResolveItem::go (it->get ());\n }\n \n+// rust-ast-resolve-expr.h\n+\n+void\n+ResolveExpr::visit (AST::BlockExpr &expr)\n+{\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  expr.iterate_stmts ([&] (AST::Stmt *s) mutable -> bool {\n+    ResolveStmt::go (s, s->get_node_id ());\n+    return true;\n+  });\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "210eff3cd3060dea1f673d5693cbb18a7fa28447", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,10 +1,30 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_BACKEND_H\n #define RUST_BACKEND_H\n \n #include <gmp.h>\n #include <mpfr.h>\n #include <mpc.h>\n \n+#include \"rust-location.h\"\n+#include \"rust-linemap.h\"\n #include \"operator.h\"\n \n extern bool"}, {"sha": "7cca024d011a9e706efc6dacee3efb6f52179373", "filename": "gcc/rust/rust-buffered-queue.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-buffered-queue.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_BUFFERED_QUEUE_H\n #define RUST_BUFFERED_QUEUE_H\n "}, {"sha": "fc80303ff615e7cc1005024d2a22e74f7ada3977", "filename": "gcc/rust/rust-diagnostics.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n // rust-diagnostics.h -- interface to diagnostic reporting   -*- C++ -*-\n \n #ifndef RUST_DIAGNOSTICS_H"}, {"sha": "7553d74de23a89f131dd4e0d12fbf37fea2dde96", "filename": "gcc/rust/rust-gcc-diagnostics.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-gcc-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-gcc-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc-diagnostics.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n // rust-gcc-diagnostics.cc -- GCC implementation of rust diagnostics interface.\n \n #include \"rust-system.h\""}, {"sha": "c4ccbab4b6d84c4d8c985070df5a31820c5d3d3c", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\""}, {"sha": "caa838366300bc2f06aa6f4339f5ea02d4ffe9bf", "filename": "gcc/rust/rust-linemap.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n // rust-linemap.cc -- GCC implementation of Linemap.\n \n #include \"rust-linemap.h\""}, {"sha": "934576242d2c7fce1ba53436bd93d0444f09c4f2", "filename": "gcc/rust/rust-location.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-location.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n // rust-location.h -- GCC specific Location declaration.   -*- C++ -*-\n \n #ifndef RUST_LOCATION_H"}, {"sha": "345217f78118ad6eaf227edb8d19c7a2cdbc5c10", "filename": "gcc/rust/rust-object-export.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-object-export.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Frust-object-export.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_OBJECT_EXPORT_H\n #define RUST_OBJECT_EXPORT_H\n "}, {"sha": "116fab7f2fb864dff3339ab72eee74dd37d3baf3", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n+#include \"rust-tyty-resolver.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -179,10 +180,102 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = lhs->combine (rhs);\n   }\n \n+  void visit (HIR::ComparisonExpr &expr)\n+  {\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+    infered = lhs->combine (rhs);\n+    // FIXME this will need to turn into bool\n+  }\n+\n+  void visit (HIR::LazyBooleanExpr &expr)\n+  {\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+    infered = lhs->combine (rhs);\n+    // FIXME this will need to turn into bool\n+  }\n+\n+  void visit (HIR::IfExpr &expr)\n+  {\n+    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+    TypeCheckExpr::Resolve (expr.get_if_block ());\n+  }\n+\n+  void visit (HIR::IfExprConseqElse &expr)\n+  {\n+    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+    TypeCheckExpr::Resolve (expr.get_if_block ());\n+    TypeCheckExpr::Resolve (expr.get_else_block ());\n+  }\n+\n+  void visit (HIR::IfExprConseqIf &expr)\n+  {\n+    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+    TypeCheckExpr::Resolve (expr.get_if_block ());\n+    TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n+  }\n+\n+  void visit (HIR::BlockExpr &expr);\n+\n+  void visit (HIR::ArrayIndexExpr &expr)\n+  {\n+    // check the index\n+    TyTy::IntType size_ty (expr.get_index_expr ()->get_mappings ().get_hirid (),\n+\t\t\t   TyTy::IntType::I32);\n+    auto resolved\n+      = size_ty.combine (TypeCheckExpr::Resolve (expr.get_index_expr ()));\n+    context->insert_type (expr.get_index_expr ()->get_mappings ().get_hirid (),\n+\t\t\t  resolved);\n+\n+    expr.get_array_expr ()->accept_vis (*this);\n+    rust_assert (infered != nullptr);\n+\n+    // extract the element type out now from the base type\n+    infered = TyTyExtractorArray::ExtractElementTypeFromArray (infered);\n+  }\n+\n+  void visit (HIR::ArrayExpr &expr)\n+  {\n+    HIR::ArrayElems *elements = expr.get_internal_elements ();\n+    size_t num_elems = elements->get_num_elements ();\n+\n+    elements->accept_vis (*this);\n+    rust_assert (infered_array_elems != nullptr);\n+\n+    infered = new TyTy::ArrayType (expr.get_mappings ().get_hirid (), num_elems,\n+\t\t\t\t   infered_array_elems);\n+  }\n+\n+  void visit (HIR::ArrayElemsValues &elems)\n+  {\n+    std::vector<TyTy::TyBase *> types;\n+    elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n+      types.push_back (TypeCheckExpr::Resolve (e));\n+      return true;\n+    });\n+\n+    infered_array_elems = types[0];\n+    for (size_t i = 1; i < types.size (); i++)\n+      {\n+\tinfered_array_elems = infered_array_elems->combine (types.at (i));\n+      }\n+  }\n+\n+  void visit (HIR::ArrayElemsCopied &elems)\n+  {\n+    infered_array_elems = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n+  }\n+\n private:\n-  TypeCheckExpr () : TypeCheckBase (), infered (nullptr) {}\n+  TypeCheckExpr ()\n+    : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr)\n+  {}\n \n   TyTy::TyBase *infered;\n+  TyTy::TyBase *infered_array_elems;\n };\n \n } // namespace Resolver"}, {"sha": "dbf6583b4fc31708e04cefed8fafc95110308baf", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -36,6 +36,11 @@ class TypeCheckStmt : public TypeCheckBase\n     stmt->accept_vis (resolver);\n   }\n \n+  void visit (HIR::ExprStmtWithBlock &stmt)\n+  {\n+    TypeCheckExpr::Resolve (stmt.get_expr ());\n+  }\n+\n   void visit (HIR::ExprStmtWithoutBlock &stmt)\n   {\n     TypeCheckExpr::Resolve (stmt.get_expr ());\n@@ -54,8 +59,15 @@ class TypeCheckStmt : public TypeCheckBase\n     // let x:i32 = 123;\n     if (specified_ty != nullptr && init_expr_ty != nullptr)\n       {\n-\tcontext->insert_type (stmt.get_mappings ().get_hirid (),\n-\t\t\t      specified_ty->combine (init_expr_ty));\n+\tauto combined = specified_ty->combine (init_expr_ty);\n+\tif (combined == nullptr)\n+\t  {\n+\t    rust_fatal_error (stmt.get_locus (),\n+\t\t\t      \"failure in setting up let stmt type\");\n+\t    return;\n+\t  }\n+\n+\tcontext->insert_type (stmt.get_mappings ().get_hirid (), combined);\n       }\n     else\n       {"}, {"sha": "21d6c23267f4f1d563c382b7ce836fd502333cac", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -25,6 +25,42 @@\n namespace Rust {\n namespace Resolver {\n \n+class ArrayCapacityConstant : public TypeCheckBase\n+{\n+public:\n+  static bool fold (HIR::Expr *expr, size_t *folded_result)\n+  {\n+    ArrayCapacityConstant folder;\n+    expr->accept_vis (folder);\n+    *folded_result = folder.result;\n+    return folder.ok;\n+  }\n+\n+  virtual ~ArrayCapacityConstant () {}\n+\n+  void visit (HIR::LiteralExpr &expr)\n+  {\n+    switch (expr.get_lit_type ())\n+      {\n+\tcase HIR::Literal::LitType::INT: {\n+\t  ok = true;\n+\t  std::stringstream ss (expr.as_string ());\n+\t  ss >> result;\n+\t}\n+\tbreak;\n+\n+      default:\n+\treturn;\n+      }\n+  }\n+\n+private:\n+  ArrayCapacityConstant () : TypeCheckBase (), ok (false), result (-1) {}\n+\n+  bool ok;\n+  size_t result;\n+}; // namespace Resolver\n+\n class TypeCheckType : public TypeCheckBase\n {\n public:\n@@ -40,7 +76,7 @@ class TypeCheckType : public TypeCheckBase\n     return resolver.translated;\n   }\n \n-  virtual void visit (HIR::TypePath &path)\n+  void visit (HIR::TypePath &path)\n   {\n     // check if this is already defined or not\n     if (context->lookup_type (path.get_mappings ().get_hirid (), &translated))\n@@ -70,6 +106,21 @@ class TypeCheckType : public TypeCheckBase\n     gcc_unreachable ();\n   }\n \n+  void visit (HIR::ArrayType &type)\n+  {\n+    size_t capacity;\n+    if (!ArrayCapacityConstant::fold (type.get_size_expr (), &capacity))\n+      {\n+\trust_error_at (type.get_size_expr ()->get_locus_slow (),\n+\t\t       \"non-constant value\");\n+\treturn;\n+      }\n+\n+    TyTy::TyBase *base = TypeCheckType::Resolve (type.get_element_type ());\n+    translated\n+      = new TyTy::ArrayType (type.get_mappings ().get_hirid (), capacity, base);\n+  }\n+\n private:\n   TypeCheckType () : TypeCheckBase (), translated (nullptr) {}\n "}, {"sha": "79e0190a31d654a80dff1a3e1aff8b54f2c39b16", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -20,6 +20,7 @@\n #include \"rust-hir-full.h\"\n #include \"rust-hir-type-check-toplevel.h\"\n #include \"rust-hir-type-check-item.h\"\n+#include \"rust-hir-type-check-expr.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -34,5 +35,15 @@ TypeResolution::Resolve (HIR::Crate &crate)\n     TypeCheckItem::Resolve (it->get ());\n }\n \n+// RUST_HIR_TYPE_CHECK_EXPR\n+void\n+TypeCheckExpr::visit (HIR::BlockExpr &expr)\n+{\n+  expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+    TypeCheckStmt::Resolve (s);\n+    return true;\n+  });\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "2851a1ee26117b85f60a66e2b56f9e901b754be4", "filename": "gcc/rust/typecheck/rust-tyty-resolver.h", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-name-resolver.h\"\n #include \"rust-hir-type-check.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-tyty-visitor.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -63,9 +64,25 @@ class TyTyResolver\n \t  TyTy::TyBase *resolved = nullptr;\n \t  if (!context->lookup_type (hir_node_ref, &resolved))\n \t    {\n-\t      rust_fatal_error (mappings->lookup_location (hir_node_ref),\n-\t\t\t\t\"failed to lookup type for reference\");\n-\t      return false;\n+\t      // this could be an array/adt type\n+\t      Definition d;\n+\t      bool ok = resolver->lookup_definition (ref_node, &d);\n+\t      rust_assert (ok);\n+\n+\t      ok = mappings->lookup_node_to_hir (mappings->get_current_crate (),\n+\t\t\t\t\t\t d.parent, &hir_node_ref);\n+\t      rust_assert (ok);\n+\n+\t      printf (\"failed lets try [%u]\\n\", hir_node_ref);\n+\n+\t      if (!context->lookup_type (hir_node_ref, &resolved))\n+\t\t{\n+\t\t  rust_fatal_error (\n+\t\t    mappings->lookup_location (hir_node_ref),\n+\t\t    \"failed to lookup type for reference at node [%u]\",\n+\t\t    hir_node_ref);\n+\t\t  return false;\n+\t\t}\n \t    }\n \n \t  gathered_types.push_back (resolved);\n@@ -85,14 +102,25 @@ class TyTyResolver\n \t\t\t\t &resolved_type);\n       rust_assert (ok);\n \n+      if (!resolved_type->is_unit ())\n+\t{\n+\t  return true;\n+\t}\n+\n       auto resolved_tyty = resolved_type;\n       for (auto it : gathered_types)\n-\tresolved_tyty = resolved_tyty->combine (it);\n+\t{\n+\t  auto combined = resolved_tyty->combine (it);\n+\t  if (combined == nullptr)\n+\t    break;\n+\n+\t  resolved_tyty = combined;\n+\t}\n \n       // something is not inferred we need to look at all references now\n       if (resolved_tyty == nullptr || resolved_tyty->is_unit ())\n \t{\n-\t  rust_error_at (decl->get_locus_slow (), \"failed to resolve type\");\n+\t  rust_fatal_error (decl->get_locus_slow (), \"failed to resolve type\");\n \t  return false;\n \t}\n \n@@ -114,8 +142,28 @@ class TyTyResolver\n   TypeCheckContext *context;\n };\n \n-} // namespace Resolver\n+class TyTyExtractorArray : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::TyBase *ExtractElementTypeFromArray (TyTy::TyBase *base)\n+  {\n+    TyTyExtractorArray e;\n+    base->accept_vis (e);\n+    rust_assert (e.extracted != nullptr);\n+    return e.extracted;\n+  }\n+\n+  virtual ~TyTyExtractorArray () {}\n \n+  void visit (TyTy::ArrayType &type) override { extracted = type.get_type (); }\n+\n+private:\n+  TyTyExtractorArray () : extracted (nullptr) {}\n+\n+  TyTy::TyBase *extracted;\n+};\n+\n+} // namespace Resolver\n } // namespace Rust\n \n #endif // RUST_TYTY_RESOLVER"}, {"sha": "97ee8954263b1387bf5a9ba711418b8f56725dbf", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -60,6 +60,13 @@ class BaseRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (ArrayType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n   virtual void visit (BoolType &type) override\n   {\n     Location locus = mappings->lookup_location (type.get_ref ());\n@@ -181,6 +188,45 @@ class ParamRules : protected BaseRules\n   TyBase *resolved;\n };\n \n+class ArrayRules : protected BaseRules\n+{\n+public:\n+  ArrayRules (ArrayType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+\n+  ~ArrayRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (ArrayType &type) override\n+  {\n+    // check base type\n+    auto base_resolved = base->get_type ()->combine (type.get_type ());\n+    if (base_resolved == nullptr)\n+      return;\n+\n+    // need to check the base types and capacity\n+    if (type.get_capacity () != base->get_capacity ())\n+      {\n+\tLocation locus = mappings->lookup_location (type.get_ref ());\n+\trust_error_at (locus, \"mismatch in array capacity\");\n+\treturn;\n+      }\n+\n+    resolved\n+      = new ArrayType (type.get_ref (), type.get_capacity (), base_resolved);\n+  }\n+\n+private:\n+  ArrayType *base;\n+  TyBase *resolved;\n+};\n+\n class BoolRules : protected BaseRules\n {\n public:"}, {"sha": "427190ff0001cd658ed5064d22efdc5ebf3f34bf", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -31,6 +31,7 @@ class TyVisitor\n   virtual void visit (InferType &type) {}\n   virtual void visit (FnType &type) {}\n   virtual void visit (ParamType &type) {}\n+  virtual void visit (ArrayType &type) {}\n   virtual void visit (BoolType &type) {}\n   virtual void visit (IntType &type) {}\n   virtual void visit (UintType &type) {}"}, {"sha": "2023523ccddc5a558623c76922f8635df1f99fe6", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -109,6 +109,25 @@ ParamType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+void\n+ArrayType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ArrayType::as_string () const\n+{\n+  return \"[\" + type->as_string () + \":\" + std::to_string (capacity) + \"]\";\n+}\n+\n+TyBase *\n+ArrayType::combine (TyBase *other)\n+{\n+  ArrayRules r (this);\n+  return r.combine (other);\n+}\n+\n void\n BoolType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "b9dc268722c4f4cfdc74559800e0d6c15afbc25f", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -143,6 +143,28 @@ class FnType : public TyBase\n   TyBase *type;\n };\n \n+class ArrayType : public TyBase\n+{\n+public:\n+  ArrayType (HirId ref, size_t capacity, TyBase *type)\n+    : TyBase (ref, TypeKind::ARRAY), capacity (capacity), type (type)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  size_t get_capacity () const { return capacity; }\n+\n+  TyBase *get_type () { return type; }\n+\n+private:\n+  size_t capacity;\n+  TyBase *type;\n+};\n+\n class BoolType : public TyBase\n {\n public:"}, {"sha": "238689c37a3b61242883f062f65ff617204c270c", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -260,8 +260,6 @@ Mappings::lookup_hir_item (CrateNum crateNum, HirId id)\n void\n Mappings::insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr)\n {\n-  rust_assert (lookup_hir_expr (crateNum, id) == nullptr);\n-\n   hirExprMappings[crateNum][id] = expr;\n   nodeIdToHirMappings[crateNum][expr->get_mappings ().get_nodeid ()] = id;\n   insert_location (crateNum, id, expr->get_locus_slow ());"}, {"sha": "a3c85232c29453b789b513f5e24008346e2f9e50", "filename": "gcc/testsuite/rust.test/compilable/arrays2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays2.rs?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut array: [i32; 3] = [0; 3];\n+\n+    let a = array[0];\n+    let mut c;\n+    c = array[2];\n+}"}, {"sha": "8dd1c048b87679b2f05194fc071c6f58a04398a9", "filename": "gcc/testsuite/rust.test/compilable/arrays_index1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays_index1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays_index1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays_index1.rs?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let mut array: [i32; 3] = [0; 3];\n+\n+    let a = array[0];\n+    let x = 0;\n+    let mut c;\n+    c = array[x+1];\n+}"}, {"sha": "51ed74b27c2ce98f29ddea36f90af6e1d8e56f03", "filename": "gcc/testsuite/rust.test/compilable/impl_block.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859720937474816d4d386664d56d80a9e840f06f/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859720937474816d4d386664d56d80a9e840f06f/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block.rs?ref=859720937474816d4d386664d56d80a9e840f06f", "patch": "@@ -1,14 +0,0 @@\n-struct Foo {\n-    one: i32,\n-    two: i32,\n-}\n-\n-impl Foo {\n-    fn new(a: i32, b: i32) -> Foo {\n-        return Foo { one: a, two: b };\n-    }\n-}\n-\n-fn main() {\n-    let cake = Foo::new(3, 4);\n-}"}, {"sha": "3cb1ec58521470e85f13e7b402ce8cdb29a1ea31", "filename": "gcc/testsuite/rust.test/compilable/shadow1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fshadow1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fshadow1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fshadow1.rs?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let mut x = 5;\n+    let mut x;\n+    x = true;\n+}"}, {"sha": "8e123e2cbd52a06d934b8d2b1549a45d9ac2b241", "filename": "gcc/testsuite/rust.test/compilable/type_infer4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer4.rs?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let xs: [i32; 5] = [1, 2, 3, 4, 5];\n+    let xy = [6, 7, 8];\n+\n+    let a = xs[0];\n+    let b = xy[2];\n+    let mut c;\n+    c = xs[0];\n+}"}, {"sha": "18c5c58c78c95d3e2e086bbc5d74c2466d5a92ee", "filename": "gcc/testsuite/rust.test/fail_compilation/shadow1.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fshadow1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fshadow1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fshadow1.rs?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let mut x = 5;\n+    let mut x;\n+    x = true;\n+    x = x + 2;\n+}"}, {"sha": "e5b22ad646f87e9ad00427f891d2f93baaf83520", "filename": "logo.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf78e75e4ec3c989e452d47dc37a0be1706bf08/logo.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf78e75e4ec3c989e452d47dc37a0be1706bf08/logo.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/logo.png?ref=faf78e75e4ec3c989e452d47dc37a0be1706bf08"}]}