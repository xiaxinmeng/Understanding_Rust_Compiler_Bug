{"sha": "84f5e1b11f08c88e910689f2f530314260347ee3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRmNWUxYjExZjA4Yzg4ZTkxMDY4OWYyZjUzMDMxNDI2MDM0N2VlMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-01-24T21:16:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-01-24T21:16:28Z"}, "message": "re PR rtl-optimization/4382 (__builtin_{set,long}jmp with -O3 can crash the compiler)\n\n        PR optimization/4382\n        * tree-inline.c (find_builtin_longjmp_call_1): New.\n        (find_builtin_longjmp_call): New.\n        (inlinable_function_p): Use it.\n\nFrom-SVN: r61732", "tree": {"sha": "0ab1633992a620c31958f8f01d9cf11360a40f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ab1633992a620c31958f8f01d9cf11360a40f20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84f5e1b11f08c88e910689f2f530314260347ee3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84f5e1b11f08c88e910689f2f530314260347ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84f5e1b11f08c88e910689f2f530314260347ee3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84f5e1b11f08c88e910689f2f530314260347ee3/comments", "author": null, "committer": null, "parents": [{"sha": "09b2e78d66d7f45f96567754f81c441546b88b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b2e78d66d7f45f96567754f81c441546b88b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b2e78d66d7f45f96567754f81c441546b88b74"}], "stats": {"total": 48, "additions": 45, "deletions": 3}, "files": [{"sha": "1217bce6c853caa3bf97e7c1b144f721e1a17902", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f5e1b11f08c88e910689f2f530314260347ee3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f5e1b11f08c88e910689f2f530314260347ee3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84f5e1b11f08c88e910689f2f530314260347ee3", "patch": "@@ -1,3 +1,10 @@\n+2003-01-24  Richard Henderson  <rth@redhat.com>\n+\n+\tPR optimization/4382\n+\t* tree-inline.c (find_builtin_longjmp_call_1): New.\n+\t(find_builtin_longjmp_call): New.\n+\t(inlinable_function_p): Use it.\n+\n 2003-01-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* config/i386/i386-protos.h (function_arg_pass_by_reference): Declare."}, {"sha": "b095f121a873586ab174826ab0ad741fab7a4280", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f5e1b11f08c88e910689f2f530314260347ee3/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f5e1b11f08c88e910689f2f530314260347ee3/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=84f5e1b11f08c88e910689f2f530314260347ee3", "patch": "@@ -125,6 +125,8 @@ static tree add_stmt_to_compound PARAMS ((tree, tree, tree));\n #endif /* INLINER_FOR_JAVA */\n static tree find_alloca_call_1 PARAMS ((tree *, int *, void *));\n static tree find_alloca_call PARAMS ((tree));\n+static tree find_builtin_longjmp_call_1 PARAMS ((tree *, int *, void *));\n+static tree find_builtin_longjmp_call PARAMS ((tree));\n \n /* The approximate number of instructions per statement.  This number\n    need not be particularly accurate; it is used only to make\n@@ -873,7 +875,7 @@ tree_inlinable_function_p (fn)\n   return inlinable_function_p (fn, NULL);\n }\n \n-/* if *TP is possibly call to alloca, return nonzero.  */\n+/* If *TP is possibly call to alloca, return nonzero.  */\n static tree\n find_alloca_call_1 (tp, walk_subtrees, data)\n      tree *tp;\n@@ -885,15 +887,40 @@ find_alloca_call_1 (tp, walk_subtrees, data)\n   return NULL;\n }\n \n-/* Return subexpression representing possible alloca call,\n-   if any.  */\n+/* Return subexpression representing possible alloca call, if any.  */\n static tree\n find_alloca_call (exp)\n      tree exp;\n {\n   return walk_tree (&exp, find_alloca_call_1, NULL, NULL);\n }\n \n+static tree\n+find_builtin_longjmp_call_1 (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree exp = *tp, decl;\n+\n+  if (TREE_CODE (exp) == CALL_EXPR\n+      && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+      && (decl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n+\t  TREE_CODE (decl) == FUNCTION_DECL)\n+      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (decl) == BUILT_IN_LONGJMP)\n+    return decl;\n+\n+  return NULL;\n+}\n+\n+static tree\n+find_builtin_longjmp_call (exp)\n+     tree exp;\n+{\n+  return walk_tree (&exp, find_builtin_longjmp_call_1, NULL, NULL);\n+}\n+\n /* Returns nonzero if FN is a function that can be inlined into the\n    inlining context ID_.  If ID_ is NULL, check whether the function\n    can be inlined at all.  */\n@@ -934,6 +961,14 @@ inlinable_function_p (fn, id)\n   else if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n \t   && currfn_insns > MAX_INLINE_INSNS_SINGLE)\n     ;\n+  /* We can't inline functions that call __builtin_longjmp at all.\n+     The non-local goto machenery really requires the destination\n+     be in a different function.  If we allow the function calling\n+     __builtin_longjmp to be inlined into the function calling\n+     __builtin_setjmp, Things will Go Awry.  */\n+  /* ??? Need front end help to identify \"regular\" non-local goto.  */\n+  else if (find_builtin_longjmp_call (DECL_SAVED_TREE (fn)))\n+    ;\n   /* Refuse to inline alloca call unless user explicitly forced so as this may\n      change program's memory overhead drastically when the function using alloca\n      is called in loop.  In GCC present in SPEC2000 inlining into schedule_block"}]}