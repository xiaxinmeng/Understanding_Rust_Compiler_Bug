{"sha": "570a11fe5a60f3012f1c2548745de10fd96b787e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcwYTExZmU1YTYwZjMwMTJmMWMyNTQ4NzQ1ZGUxMGZkOTZiNzg3ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-09-10T09:21:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-09-10T09:21:25Z"}, "message": "ubsan.h (struct ubsan_mismatch_data): Removed.\n\n\t* ubsan.h (struct ubsan_mismatch_data): Removed.\n\t(ubsan_create_data): Remove MISMATCH argument, add LOCCNT argument.\n\t* ubsan.c (ubsan_source_location): For unknown locations,\n\tpass { NULL, 0, 0 } instead of { \"<unknown>\", x, y }.\n\t(ubsan_create_data): Remove MISMATCH argument, add LOCCNT argument.\n\tAllow more than one location and arbitrary extra arguments passed\n\tin ... instead of through MISMATCH pointer.\n\t(ubsan_instrument_unreachable, ubsan_expand_bounds_ifn,\n\tubsan_expand_null_ifn, ubsan_build_overflow_builtin,\n\tinstrument_bool_enum_load, ubsan_instrument_float_cast): Adjust\n\tcallers.\nc-family/\n\t* c-ubsan.c (ubsan_instrument_division, ubsan_instrument_shift,\n\tubsan_instrument_vla, ubsan_instrument_return): Adjust\n\tubsan_create_data callers.\n\t(ubsan_instrument_bounds): Don't emit UBSAN_BOUNDS at all if\n\tindex is constant or BIT_AND_EXPR with constant mask and is\n\tsmall enough for the bound.\n\t* c-gimplify.c (ubsan_walk_array_refs_r): For ADDR_EXPR of\n\tARRAY_REF, make sure the inner ARRAY_REF is not walked again.\n\nFrom-SVN: r215117", "tree": {"sha": "81f58ffd80e23ae4883c03986eb7fa04b5ae93a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81f58ffd80e23ae4883c03986eb7fa04b5ae93a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/570a11fe5a60f3012f1c2548745de10fd96b787e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570a11fe5a60f3012f1c2548745de10fd96b787e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/570a11fe5a60f3012f1c2548745de10fd96b787e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570a11fe5a60f3012f1c2548745de10fd96b787e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7be73c86287ab5b8c8121732d3ab6249415a429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7be73c86287ab5b8c8121732d3ab6249415a429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7be73c86287ab5b8c8121732d3ab6249415a429"}], "stats": {"total": 195, "additions": 124, "deletions": 71}, "files": [{"sha": "1749b280799ccfc2335873501a3b5ac83f213a59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=570a11fe5a60f3012f1c2548745de10fd96b787e", "patch": "@@ -1,3 +1,17 @@\n+2014-09-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* ubsan.h (struct ubsan_mismatch_data): Removed.\n+\t(ubsan_create_data): Remove MISMATCH argument, add LOCCNT argument.\n+\t* ubsan.c (ubsan_source_location): For unknown locations,\n+\tpass { NULL, 0, 0 } instead of { \"<unknown>\", x, y }.\n+\t(ubsan_create_data): Remove MISMATCH argument, add LOCCNT argument.\n+\tAllow more than one location and arbitrary extra arguments passed\n+\tin ... instead of through MISMATCH pointer.\n+\t(ubsan_instrument_unreachable, ubsan_expand_bounds_ifn,\n+\tubsan_expand_null_ifn, ubsan_build_overflow_builtin,\n+\tinstrument_bool_enum_load, ubsan_instrument_float_cast): Adjust\n+\tcallers.\n+\n 2014-09-10  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n \t    Anna Tikhonova  <anna.tikhonova@intel.com>"}, {"sha": "f24696db23be572a24b9df190edaa23344352684", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=570a11fe5a60f3012f1c2548745de10fd96b787e", "patch": "@@ -1,3 +1,14 @@\n+2014-09-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-ubsan.c (ubsan_instrument_division, ubsan_instrument_shift,\n+\tubsan_instrument_vla, ubsan_instrument_return): Adjust\n+\tubsan_create_data callers.\n+\t(ubsan_instrument_bounds): Don't emit UBSAN_BOUNDS at all if\n+\tindex is constant or BIT_AND_EXPR with constant mask and is\n+\tsmall enough for the bound.\n+\t* c-gimplify.c (ubsan_walk_array_refs_r): For ADDR_EXPR of\n+\tARRAY_REF, make sure the inner ARRAY_REF is not walked again.\n+\n 2014-09-09  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* c.opt: Add CppReason to various flags."}, {"sha": "2c08124d71c96d00ccb0e9801e57b377cd3fbdc2", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=570a11fe5a60f3012f1c2548745de10fd96b787e", "patch": "@@ -95,7 +95,20 @@ ubsan_walk_array_refs_r (tree *tp, int *walk_subtrees, void *data)\n     }\n   else if (TREE_CODE (*tp) == ADDR_EXPR\n \t   && TREE_CODE (TREE_OPERAND (*tp, 0)) == ARRAY_REF)\n-    ubsan_maybe_instrument_array_ref (&TREE_OPERAND (*tp, 0), true);\n+    {\n+      ubsan_maybe_instrument_array_ref (&TREE_OPERAND (*tp, 0), true);\n+      /* Make sure ubsan_maybe_instrument_array_ref is not called again\n+\t on the ARRAY_REF, the above call might not instrument anything\n+\t as the index might be constant or masked, so ensure it is not\n+\t walked again and walk its subtrees manually.  */\n+      tree aref = TREE_OPERAND (*tp, 0);\n+      pset->add (aref);\n+      *walk_subtrees = 0;\n+      walk_tree (&TREE_OPERAND (aref, 0), ubsan_walk_array_refs_r, pset, pset);\n+      walk_tree (&TREE_OPERAND (aref, 1), ubsan_walk_array_refs_r, pset, pset);\n+      walk_tree (&TREE_OPERAND (aref, 2), ubsan_walk_array_refs_r, pset, pset);\n+      walk_tree (&TREE_OPERAND (aref, 3), ubsan_walk_array_refs_r, pset, pset);\n+    }\n   else if (TREE_CODE (*tp) == ARRAY_REF)\n     ubsan_maybe_instrument_array_ref (tp, false);\n   return NULL_TREE;"}, {"sha": "3539c68dc8bc3902b9d8b88a93de5f1536a592d3", "filename": "gcc/c-family/c-ubsan.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fc-family%2Fc-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fc-family%2Fc-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.c?ref=570a11fe5a60f3012f1c2548745de10fd96b787e", "patch": "@@ -99,8 +99,9 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)\n     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n-      tree data = ubsan_create_data (\"__ubsan_overflow_data\", &loc, NULL,\n-\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n+      tree data = ubsan_create_data (\"__ubsan_overflow_data\", 1, &loc,\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE,\n+\t\t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n@@ -191,9 +192,10 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,\n     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n-      tree data = ubsan_create_data (\"__ubsan_shift_data\", &loc, NULL,\n+      tree data = ubsan_create_data (\"__ubsan_shift_data\", 1, &loc,\n \t\t\t\t     ubsan_type_descriptor (type0),\n-\t\t\t\t     ubsan_type_descriptor (type1), NULL_TREE);\n+\t\t\t\t     ubsan_type_descriptor (type1), NULL_TREE,\n+\t\t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n \n       enum built_in_function bcode\n@@ -222,8 +224,9 @@ ubsan_instrument_vla (location_t loc, tree size)\n     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n-      tree data = ubsan_create_data (\"__ubsan_vla_data\", &loc, NULL,\n-\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n+      tree data = ubsan_create_data (\"__ubsan_vla_data\", 1, &loc,\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE,\n+\t\t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n@@ -248,8 +251,8 @@ ubsan_instrument_return (location_t loc)\n      builtins.  Reinitialize them if needed.  */\n   initialize_sanitizer_builtins ();\n \n-  tree data = ubsan_create_data (\"__ubsan_missing_return_data\", &loc,\n-\t\t\t\t NULL, NULL_TREE);\n+  tree data = ubsan_create_data (\"__ubsan_missing_return_data\", 1, &loc,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n   tree t = builtin_decl_explicit (BUILT_IN_UBSAN_HANDLE_MISSING_RETURN);\n   return build_call_expr_loc (loc, t, 1, build_fold_addr_expr_loc (loc, data));\n }\n@@ -305,6 +308,19 @@ ubsan_instrument_bounds (location_t loc, tree array, tree *index,\n         return NULL_TREE;\n     }\n \n+  /* Don't emit instrumentation in the most common cases.  */\n+  tree idx = NULL_TREE;\n+  if (TREE_CODE (*index) == INTEGER_CST)\n+    idx = *index;\n+  else if (TREE_CODE (*index) == BIT_AND_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (*index, 1)) == INTEGER_CST)\n+    idx = TREE_OPERAND (*index, 1);\n+  if (idx\n+      && TREE_CODE (bound) == INTEGER_CST\n+      && tree_int_cst_sgn (idx) >= 0\n+      && tree_int_cst_le (idx, bound))\n+    return NULL_TREE;\n+\n   *index = save_expr (*index);\n   /* Create a \"(T *) 0\" tree node to describe the array type.  */\n   tree zero_with_type = build_int_cst (build_pointer_type (type), 0);"}, {"sha": "745ca80d413fc7b63f7c6e5ecf9d1d4151392825", "filename": "gcc/ubsan.c", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=570a11fe5a60f3012f1c2548745de10fd96b787e", "patch": "@@ -242,17 +242,24 @@ ubsan_source_location (location_t loc)\n   tree type = ubsan_source_location_type ();\n \n   xloc = expand_location (loc);\n+  tree str;\n   if (xloc.file == NULL)\n-    xloc.file = \"<unknown>\";\n-\n-  /* Fill in the values from LOC.  */\n-  size_t len = strlen (xloc.file);\n-  tree str = build_string (len + 1, xloc.file);\n-  TREE_TYPE (str) = build_array_type (char_type_node,\n-\t\t\t\t      build_index_type (size_int (len)));\n-  TREE_READONLY (str) = 1;\n-  TREE_STATIC (str) = 1;\n-  str = build_fold_addr_expr (str);\n+    {\n+      str = build_int_cst (ptr_type_node, 0);\n+      xloc.line = 0;\n+      xloc.column = 0;\n+    }\n+  else\n+    {\n+      /* Fill in the values from LOC.  */\n+      size_t len = strlen (xloc.file);\n+      str = build_string (len + 1, xloc.file);\n+      TREE_TYPE (str) = build_array_type (char_type_node,\n+\t\t\t\t\t  build_index_type (size_int (len)));\n+      TREE_READONLY (str) = 1;\n+      TREE_STATIC (str) = 1;\n+      str = build_fold_addr_expr (str);\n+    }\n   tree ctor = build_constructor_va (type, 3, NULL_TREE, str, NULL_TREE,\n \t\t\t\t    build_int_cst (unsigned_type_node,\n \t\t\t\t\t\t   xloc.line), NULL_TREE,\n@@ -451,20 +458,20 @@ ubsan_type_descriptor (tree type, enum ubsan_print_style pstyle)\n }\n \n /* Create a structure for the ubsan library.  NAME is a name of the new\n-   structure.  The arguments in ... are of __ubsan_type_descriptor type\n-   and there are at most two of them.  MISMATCH are data used by ubsan\n-   pointer checking.  */\n+   structure.  LOCCNT is number of locations, PLOC points to array of\n+   locations.  The arguments in ... are of __ubsan_type_descriptor type\n+   and there are at most two of them, followed by NULL_TREE, followed\n+   by optional extra arguments and another NULL_TREE.  */\n \n tree\n-ubsan_create_data (const char *name, const location_t *ploc,\n-\t\t   const struct ubsan_mismatch_data *mismatch, ...)\n+ubsan_create_data (const char *name, int loccnt, const location_t *ploc, ...)\n {\n   va_list args;\n   tree ret, t;\n-  tree fields[5];\n+  tree fields[6];\n   vec<tree, va_gc> *saved_args = NULL;\n   size_t i = 0;\n-  location_t loc = UNKNOWN_LOCATION;\n+  int j;\n \n   /* Firstly, create a pointer to type descriptor type.  */\n   tree td_type = ubsan_type_descriptor_type ();\n@@ -473,20 +480,22 @@ ubsan_create_data (const char *name, const location_t *ploc,\n \n   /* Create the structure type.  */\n   ret = make_node (RECORD_TYPE);\n-  if (ploc != NULL)\n+  for (j = 0; j < loccnt; j++)\n     {\n-      loc = LOCATION_LOCUS (*ploc);\n+      gcc_checking_assert (i < 2);\n       fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n \t\t\t      ubsan_source_location_type ());\n       DECL_CONTEXT (fields[i]) = ret;\n+      if (i)\n+\tDECL_CHAIN (fields[i - 1]) = fields[i];\n       i++;\n     }\n \n-  va_start (args, mismatch);\n+  va_start (args, ploc);\n   for (t = va_arg (args, tree); t != NULL_TREE;\n        i++, t = va_arg (args, tree))\n     {\n-      gcc_checking_assert (i < 3);\n+      gcc_checking_assert (i < 4);\n       /* Save the tree arguments for later use.  */\n       vec_safe_push (saved_args, t);\n       fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n@@ -495,23 +504,20 @@ ubsan_create_data (const char *name, const location_t *ploc,\n       if (i)\n \tDECL_CHAIN (fields[i - 1]) = fields[i];\n     }\n-  va_end (args);\n \n-  if (mismatch != NULL)\n+  for (t = va_arg (args, tree); t != NULL_TREE;\n+       i++, t = va_arg (args, tree))\n     {\n-      /* We have to add two more decls.  */\n-      fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n-\t\t\t      pointer_sized_int_node);\n-      DECL_CONTEXT (fields[i]) = ret;\n-      DECL_CHAIN (fields[i - 1]) = fields[i];\n-      i++;\n-\n+      gcc_checking_assert (i < 6);\n+      /* Save the tree arguments for later use.  */\n+      vec_safe_push (saved_args, t);\n       fields[i] = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n-\t\t\t      unsigned_char_type_node);\n+\t\t\t      TREE_TYPE (t));\n       DECL_CONTEXT (fields[i]) = ret;\n-      DECL_CHAIN (fields[i - 1]) = fields[i];\n-      i++;\n+      if (i)\n+\tDECL_CHAIN (fields[i - 1]) = fields[i];\n     }\n+  va_end (args);\n \n   TYPE_FIELDS (ret) = fields[0];\n   TYPE_NAME (ret) = get_identifier (name);\n@@ -534,8 +540,11 @@ ubsan_create_data (const char *name, const location_t *ploc,\n   tree ctor = build_constructor (ret, v);\n \n   /* If desirable, set the __ubsan_source_location element.  */\n-  if (ploc != NULL)\n-    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, ubsan_source_location (loc));\n+  for (j = 0; j < loccnt; j++)\n+    {\n+      location_t loc = LOCATION_LOCUS (ploc[j]);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, ubsan_source_location (loc));\n+    } \n \n   size_t nelts = vec_safe_length (saved_args);\n   for (i = 0; i < nelts; i++)\n@@ -544,13 +553,6 @@ ubsan_create_data (const char *name, const location_t *ploc,\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, t);\n     }\n \n-  if (mismatch != NULL)\n-    {\n-      /* Append the pointer data.  */\n-      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, mismatch->align);\n-      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, mismatch->ckind);\n-    }\n-\n   TREE_CONSTANT (ctor) = 1;\n   TREE_STATIC (ctor) = 1;\n   DECL_INITIAL (var) = ctor;\n@@ -569,7 +571,7 @@ ubsan_instrument_unreachable (location_t loc)\n     return build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n \n   initialize_sanitizer_builtins ();\n-  tree data = ubsan_create_data (\"__ubsan_unreachable_data\", &loc, NULL,\n+  tree data = ubsan_create_data (\"__ubsan_unreachable_data\", 1, &loc, NULL_TREE,\n \t\t\t\t NULL_TREE);\n   tree t = builtin_decl_explicit (BUILT_IN_UBSAN_HANDLE_BUILTIN_UNREACHABLE);\n   return build_call_expr_loc (loc, t, 1, build_fold_addr_expr_loc (loc, data));\n@@ -622,10 +624,10 @@ ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n   else\n     {\n       tree data\n-\t= ubsan_create_data (\"__ubsan_out_of_bounds_data\", &loc, NULL,\n+\t= ubsan_create_data (\"__ubsan_out_of_bounds_data\", 1, &loc,\n \t\t\t     ubsan_type_descriptor (type, UBSAN_PRINT_ARRAY),\n \t\t\t     ubsan_type_descriptor (orig_index_type),\n-\t\t\t     NULL_TREE);\n+\t\t\t     NULL_TREE, NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n@@ -735,12 +737,13 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n \t  ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH\n \t  : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT;\n       tree fn = builtin_decl_implicit (bcode);\n-      const struct ubsan_mismatch_data m\n-\t= { align, fold_convert (unsigned_char_type_node, ckind) };\n       tree data\n-\t= ubsan_create_data (\"__ubsan_null_data\", &loc, &m,\n+\t= ubsan_create_data (\"__ubsan_null_data\", 1, &loc,\n \t\t\t     ubsan_type_descriptor (TREE_TYPE (ckind),\n \t\t\t\t\t\t    UBSAN_PRINT_POINTER),\n+\t\t\t     NULL_TREE,\n+\t\t\t     align,\n+\t\t\t     fold_convert (unsigned_char_type_node, ckind),\n \t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       g = gimple_build_call (fn, 2, data,\n@@ -875,8 +878,9 @@ ubsan_build_overflow_builtin (tree_code code, location_t loc, tree lhstype,\n   if (flag_sanitize_undefined_trap_on_error)\n     return build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n \n-  tree data = ubsan_create_data (\"__ubsan_overflow_data\", &loc, NULL,\n-\t\t\t\t ubsan_type_descriptor (lhstype), NULL_TREE);\n+  tree data = ubsan_create_data (\"__ubsan_overflow_data\", 1, &loc,\n+\t\t\t\t ubsan_type_descriptor (lhstype), NULL_TREE,\n+\t\t\t\t NULL_TREE);\n   enum built_in_function fn_code;\n \n   switch (code)\n@@ -1069,8 +1073,9 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n     g = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n-      tree data = ubsan_create_data (\"__ubsan_invalid_value_data\", &loc, NULL,\n-\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n+      tree data = ubsan_create_data (\"__ubsan_invalid_value_data\", 1, &loc,\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE,\n+\t\t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n@@ -1189,9 +1194,10 @@ ubsan_instrument_float_cast (location_t loc, tree type, tree expr)\n   else\n     {\n       /* Create the __ubsan_handle_float_cast_overflow fn call.  */\n-      tree data = ubsan_create_data (\"__ubsan_float_cast_overflow_data\", NULL,\n+      tree data = ubsan_create_data (\"__ubsan_float_cast_overflow_data\", 0,\n \t\t\t\t     NULL, ubsan_type_descriptor (expr_type),\n-\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE,\n+\t\t\t\t     NULL_TREE);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n \t  ? BUILT_IN_UBSAN_HANDLE_FLOAT_CAST_OVERFLOW"}, {"sha": "cd269408cf2a4cfa1eb723bc9d010810cdd76de9", "filename": "gcc/ubsan.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a11fe5a60f3012f1c2548745de10fd96b787e/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=570a11fe5a60f3012f1c2548745de10fd96b787e", "patch": "@@ -38,17 +38,10 @@ enum ubsan_print_style {\n   UBSAN_PRINT_ARRAY\n };\n \n-/* An extra data used by ubsan pointer checking.  */\n-struct ubsan_mismatch_data {\n-  tree align;\n-  tree ckind;\n-};\n-\n extern bool ubsan_expand_bounds_ifn (gimple_stmt_iterator *);\n extern bool ubsan_expand_null_ifn (gimple_stmt_iterator *);\n extern tree ubsan_instrument_unreachable (location_t);\n-extern tree ubsan_create_data (const char *, const location_t *,\n-\t\t\t       const struct ubsan_mismatch_data *, ...);\n+extern tree ubsan_create_data (const char *, int, const location_t *, ...);\n extern tree ubsan_type_descriptor (tree, enum ubsan_print_style = UBSAN_PRINT_NORMAL);\n extern tree ubsan_encode_value (tree, bool = false);\n extern bool is_ubsan_builtin_p (tree);"}]}