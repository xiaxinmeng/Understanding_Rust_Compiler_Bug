{"sha": "107a4b414e840fdf9b4f407365bac4ad760d7ed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3YTRiNDE0ZTg0MGZkZjliNGY0MDczNjViYWM0YWQ3NjBkN2VkMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-26T17:55:32Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-26T17:55:32Z"}, "message": "mips.c (mips_legitimize_tls_address): Use gcc_unreachable.\n\n\t* config/mips/mips.c (mips_legitimize_tls_address): Use\n\tgcc_unreachable.\n\n\t* config/mmix/mmix.c (mmix_assemble_integer): Use gcc_assert.\n\t* config/mmix/crti.asm (_init): Reword comment to avoid 'abort'.\n\t* config/mmix/mmix.md (nonlocal_goto_receiver): Likewise.\n\n\t* config/sparc/sparc.h (enum reg_class): Reword comment to avoid\n\t'abort'.\n\nFrom-SVN: r98782", "tree": {"sha": "7963ec9a945ca6f124d5b9fd406789bb179d8b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7963ec9a945ca6f124d5b9fd406789bb179d8b20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/107a4b414e840fdf9b4f407365bac4ad760d7ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107a4b414e840fdf9b4f407365bac4ad760d7ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/107a4b414e840fdf9b4f407365bac4ad760d7ed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107a4b414e840fdf9b4f407365bac4ad760d7ed2/comments", "author": null, "committer": null, "parents": [{"sha": "db30731aa44d6975021de8b9838297d2e9603cf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db30731aa44d6975021de8b9838297d2e9603cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db30731aa44d6975021de8b9838297d2e9603cf3"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "6be43297069c13a2aa74cfadfe27f142b058c691", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=107a4b414e840fdf9b4f407365bac4ad760d7ed2", "patch": "@@ -1,3 +1,15 @@\n+2005-04-26  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/mips.mips.c (mips_legitimize_tls_address): Use\n+\tgcc_unreachable.\n+\n+\t* config/mmix/mmix.c (mmix_assemble_integer): Use gcc_assert.\n+\t* config/mmix/crti.asm (_init): Reword comment to avoid 'abort'.\n+\t* config/mmix/mmix.md (nonlocal_goto_receiver): Likewise.\n+\n+\t* config/sparc/sparc.h (enum reg_class): Reword comment to avoid\n+\t'abort'.\n+\n 2005-04-26  Jeff Law  <law@redhat.com>\n \n \t* tree-flow-inline.h (op_iter_next_must_and_may_def): New.\n@@ -12,7 +24,8 @@\n \n 2005-04-26  Andrew MacLeod  <amacleod@redhat.com>\n \n-\t* tree-cfg.c (bsi_replace): Delink immediate uses for the original stmt.\n+\t* tree-cfg.c (bsi_replace): Delink immediate uses for the original\n+\tstmt.\n \n 2005-04-26  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "84576b29fda87f594f07ded6306bffa7da262786", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=107a4b414e840fdf9b4f407365bac4ad760d7ed2", "patch": "@@ -1698,7 +1698,7 @@ mips_legitimize_tls_address (rtx loc)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return dest;"}, {"sha": "d00dcd59dae5574731c2f59169a655603c1ff758", "filename": "gcc/config/mmix/crti.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmmix%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmmix%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fcrti.asm?ref=107a4b414e840fdf9b4f407365bac4ad760d7ed2", "patch": "@@ -91,7 +91,7 @@ Main\tSETL\t$255,32\n % Provide the first part of _init and _fini.  Save the return address on the\n % register stack.  We eventually ignore the return address of these\n % PUSHJ:s, so it doesn't matter that whether .init and .fini code calls\n-% functions or where they store rJ.  We shouldn't get there, so abort\n+% functions or where they store rJ.  We shouldn't get there, so die\n % (TRAP Halt) if that happens.\n \n \t.section .init,\"ax\",@progbits"}, {"sha": "6990f452722c1257b85dbafb1db5e8824c8f5d6e", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=107a4b414e840fdf9b4f407365bac4ad760d7ed2", "patch": "@@ -1302,11 +1302,10 @@ mmix_assemble_integer (rtx x, unsigned int size, int aligned_p)\n \treturn true;\n \n       case 8:\n-\tif (GET_CODE (x) == CONST_DOUBLE)\n-\t  /* We don't get here anymore for CONST_DOUBLE, because DImode\n-\t     isn't expressed as CONST_DOUBLE, and DFmode is handled\n-\t     elsewhere.  */\n-\t  abort ();\n+\t/* We don't get here anymore for CONST_DOUBLE, because DImode\n+\t   isn't expressed as CONST_DOUBLE, and DFmode is handled\n+\t   elsewhere.  */\n+\tgcc_assert (GET_CODE (x) != CONST_DOUBLE);\n \tassemble_integer_with_op (\"\\tOCTA\\t\", x);\n \treturn true;\n       }"}, {"sha": "94a55782229230e068636a331a0643c5dcb5a3d4", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=107a4b414e840fdf9b4f407365bac4ad760d7ed2", "patch": "@@ -1216,7 +1216,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n ;; the frame-pointer would be located).\n ;; In the nonlocal goto receiver, we unwind the register stack by a series\n ;; of \"pop 0,0\" until rO equals the saved value.  (If it goes lower, we\n-;; should call abort.)\n+;; should die with a trap.)\n (define_expand \"nonlocal_goto_receiver\"\n   [(parallel [(unspec_volatile [(const_int 0)] 1)\n \t      (clobber (scratch:DI))"}, {"sha": "dbad1b913656dca4aa2fea78b01228333fa1ca5a", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107a4b414e840fdf9b4f407365bac4ad760d7ed2/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=107a4b414e840fdf9b4f407365bac4ad760d7ed2", "patch": "@@ -1008,11 +1008,12 @@ extern int sparc_mode_class[];\n    because reg_class_subunion[GENERAL_REGS][FP_REGS] will yield FP_REGS,\n    because FP_REGS > GENERAL_REGS.\n \n-   It is also important that one class contain all the general and all the\n-   fp regs.  Otherwise when spilling a DFmode reg, it may be from EXTRA_FP_REGS\n-   but find_reloads() may use class GENERAL_OR_FP_REGS. This will cause\n-   allocate_reload_reg() to bypass it causing an abort because the compiler\n-   thinks it doesn't have a spill reg when in fact it does.\n+   It is also important that one class contain all the general and all\n+   the fp regs.  Otherwise when spilling a DFmode reg, it may be from\n+   EXTRA_FP_REGS but find_reloads() may use class\n+   GENERAL_OR_FP_REGS. This will cause allocate_reload_reg() to die\n+   because the compiler thinks it doesn't have a spill reg when in\n+   fact it does.\n \n    v9 also has 4 floating point condition code registers.  Since we don't\n    have a class that is the union of FPCC_REGS with either of the others,"}]}