{"sha": "d83bb9f778da2a861a6aebd527b61ec6c495d494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgzYmI5Zjc3OGRhMmE4NjFhNmFlYmQ1MjdiNjFlYzZjNDk1ZDQ5NA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-01-05T10:00:24Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-01-05T10:00:24Z"}, "message": "* doc/cppinternals.texi: Update.\n\nFrom-SVN: r48562", "tree": {"sha": "33d6f71714df48199f7f7dfe3db71ae5ec33dd7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33d6f71714df48199f7f7dfe3db71ae5ec33dd7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d83bb9f778da2a861a6aebd527b61ec6c495d494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83bb9f778da2a861a6aebd527b61ec6c495d494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d83bb9f778da2a861a6aebd527b61ec6c495d494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83bb9f778da2a861a6aebd527b61ec6c495d494/comments", "author": null, "committer": null, "parents": [{"sha": "4fb535d7d7675dedf724d3a4dbb2e5c2b74d16fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb535d7d7675dedf724d3a4dbb2e5c2b74d16fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb535d7d7675dedf724d3a4dbb2e5c2b74d16fd"}], "stats": {"total": 156, "additions": 142, "deletions": 14}, "files": [{"sha": "ebcf344b53439a35139a99fc13ba847ae981a9d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d83bb9f778da2a861a6aebd527b61ec6c495d494/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d83bb9f778da2a861a6aebd527b61ec6c495d494/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d83bb9f778da2a861a6aebd527b61ec6c495d494", "patch": "@@ -1,3 +1,7 @@\n+2002-01-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* doc/cppinternals.texi: Update.\n+\n 2002-01-05  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* doc/invoke.texi (Option Summary) <MMIX Options>: Document"}, {"sha": "df036380cb22c179bec8b30dd72b0ca7f802046d", "filename": "gcc/doc/cppinternals.texi", "status": "modified", "additions": 138, "deletions": 14, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d83bb9f778da2a861a6aebd527b61ec6c495d494/gcc%2Fdoc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d83bb9f778da2a861a6aebd527b61ec6c495d494/gcc%2Fdoc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppinternals.texi?ref=d83bb9f778da2a861a6aebd527b61ec6c495d494", "patch": "@@ -16,7 +16,7 @@\n @ifinfo\n This file documents the internals of the GNU C Preprocessor.\n \n-Copyright 2000, 2001 Free Software Foundation, Inc.\n+Copyright 2000, 2001, 2002 Free Software Foundation, Inc.\n \n Permission is granted to make and distribute verbatim copies of\n this manual provided the copyright notice and this permission notice\n@@ -68,7 +68,7 @@ into another language, under the above conditions for modified versions.\n \n @node Top\n @top\n-@chapter Cpplib---the core of the GNU C Preprocessor\n+@chapter Cpplib---the GNU C Preprocessor\n \n The GNU C preprocessor in GCC 3.x has been completely rewritten.  It is\n now implemented as a library, @dfn{cpplib}, so it can be easily shared between\n@@ -469,26 +469,26 @@ enum stored in its hash node, so that directive lookup is also O(1).\n @unnumbered Macro Expansion Algorithm\n @cindex macro expansion\n \n-Macro expansion is a surprisingly tricky operation, fraught with nasty\n-corner cases and situations that render what you thought was a nifty\n-way to optimize the preprocessor's expansion algorithm wrong in quite\n-subtle ways.\n+Macro expansion is a tricky operation, fraught with nasty corner cases\n+and situations that render what you thought was a nifty way to\n+optimize the preprocessor's expansion algorithm wrong in quite subtle\n+ways.\n \n I strongly recommend you have a good grasp of how the C and C++\n standards require macros to be expanded before diving into this\n section, let alone the code!.  If you don't have a clear mental\n picture of how things like nested macro expansion, stringification and\n-token pasting are supposed to work, damage to you sanity can quickly\n+token pasting are supposed to work, damage to your sanity can quickly\n result.\n \n-@section Internal representation of Macros\n+@section Internal representation of macros\n @cindex macro representation (internal)\n \n The preprocessor stores macro expansions in tokenized form.  This\n saves repeated lexing passes during expansion, at the cost of a small\n increase in memory consumption on average.  The tokens are stored\n contiguously in memory, so a pointer to the first one and a token\n-count is all we need.\n+count is all you need to get the replacement list of a macro.\n \n If the macro is a function-like macro the preprocessor also stores its\n parameters, in the form of an ordered list of pointers to the hash\n@@ -502,13 +502,137 @@ the original parameters to the macro, both for dumping with e.g.,\n @option{-dD}, and to warn about non-trivial macro redefinitions when\n the parameter names have changed.\n \n-@section Nested object-like macros\n+@section Macro expansion overview\n+The preprocessor maintains a @dfn{context stack}, implemented as a\n+linked list of @code{cpp_context} structures, which together represent\n+the macro expansion state at any one time.  The @code{struct\n+cpp_reader} member variable @code{context} points to the current top\n+of this stack.  The top normally holds the unexpanded replacement list\n+of the innermost macro under expansion, except when cpplib is about to\n+pre-expand an argument, in which case it holds that argument's\n+unexpanded tokens.\n+\n+When there are no macros under expansion, cpplib is in @dfn{base\n+context}.  All contexts other than the base context contain a\n+contiguous list of tokens delimited by a starting and ending token.\n+When not in base context, cpplib obtains the next token from the list\n+of the top context.  If there are no tokens left in the list, it pops\n+that context off the stack, and subsequent ones if necessary, until an\n+unexhausted context is found or it returns to base context.  In base\n+context, cpplib reads tokens directly from the lexer.\n+\n+If it encounters an identifier that is both a macro and enabled for\n+expansion, cpplib prepares to push a new context for that macro on the\n+stack by calling the routine @code{enter_macro_context}.  When this\n+routine returns, the new context will contain the unexpanded tokens of\n+the replacement list of that macro.  In the case of function-like\n+macros, @code{enter_macro_context} also replaces any parameters in the\n+replacement list, stored as @code{CPP_MACRO_ARG} tokens, with the\n+appropriate macro argument.  If the standard requires that the\n+parameter be replaced with its expanded argument, the argument will\n+have been fully macro expanded first.\n+\n+@code{enter_macro_context} also handles special macros like\n+@code{__LINE__}.  Although these macros expand to a single token which\n+cannot contain any further macros, for reasons of token spacing\n+(@pxref{Token Spacing}) and simplicity of implementation, cpplib\n+handles these special macros by pushing a context containing just that\n+one token.\n+\n+The final thing that @code{enter_macro_context} does before returning\n+is to mark the macro disabled for expansion (except for special macros\n+like @code{__TIME__}).  The macro is re-enabled when its context is\n+later popped from the context stack, as described above.  This strict\n+ordering ensures that a macro is disabled whilst its expansion is\n+being scanned, but that it is @emph{not} disabled whilst any arguments\n+to it are being expanded.\n+\n+@section Scanning the replacement list for macros to expand\n+The C standard states that, after any parameters have been replaced\n+with their possibly-expanded arguments, the replacement list is\n+scanned for nested macros.  Further, any identifiers in the\n+replacement list that are not expanded during this scan are never\n+again eligible for expansion in the future, if the reason they were\n+not expanded is that the macro in question was disabled.\n+\n+Clearly this latter condition can only apply to tokens resulting from\n+argument pre-expansion.  Other tokens never have an opportunity to be\n+re-tested for expansion.  It is possible for identifiers that are\n+function-like macros to not expand initially but to expand during a\n+later scan.  This occurs when the identifier is the last token of an\n+argument (and therefore originally followed by a comma or a closing\n+parenthesis in its macro's argument list), and when it replaces its\n+parameter in the macro's replacement list, the subsequent token\n+happens to be an opening parenthesis (itself possibly the first token\n+of an argument).\n+\n+It is important to note that when cpplib reads the last token of a\n+given context, that context still remains on the stack.  Only when\n+looking for the @emph{next} token do we pop it off the stack and drop\n+to a lower context.  This makes backing up by one token easy, but more\n+importantly ensures that the macro corresponding to the current\n+context is still disabled when we are considering the last token of\n+its replacement list for expansion (or indeed expanding it).  As an\n+example, which illustrates many of the points above, consider\n \n-@c TODO\n-\n-@section Function-like macros\n+@smallexample\n+#define foo(x) bar x\n+foo(foo) (2)\n+@end smallexample\n \n-@c TODO\n+@noindent which fully expands to @samp{bar foo (2)}.  During pre-expansion\n+of the argument, @samp{foo} does not expand even though the macro is\n+enabled, since it has no following parenthesis [pre-expansion of an\n+argument only uses tokens from that argument; it cannot take tokens\n+from whatever follows the macro invocation].  This still leaves the\n+argument token @samp{foo} eligible for future expansion.  Then, when\n+re-scanning after argument replacement, the token @samp{foo} is\n+rejected for expansion, and marked ineligible for future expansion,\n+since the macro is now disabled.  It is disabled because the\n+replacement list @samp{bar foo} of the macro is still on the context\n+stack.\n+\n+If instead the algorithm looked for an opening parenthesis first and\n+then tested whether the macro were disabled it would be subtly wrong.\n+In the example above, the replacement list of @samp{foo} would be\n+popped in the process of finding the parenthesis, re-enabling\n+@samp{foo} and expanding it a second time.\n+\n+@section Looking for a function-like macro's opening parenthesis\n+Function-like macros only expand when immediately followed by a\n+parenthesis.  To do this cpplib needs to temporarily disable macros\n+and read the next token.  Unfortunately, because of spacing issues\n+(@pxref{Token Spacing}), there can be fake padding tokens in-between,\n+and if the next real token is not a parenthesis cpplib needs to be\n+able to back up that one token as well as retain the information in\n+any intervening padding tokens.\n+\n+Backing up more than one token when macros are involved is not\n+permitted by cpplib, because in general it might involve issues like\n+restoring popped contexts onto the context stack, which are too hard.\n+Instead, searching for the parenthesis is handled by a special\n+function, @code{funlike_invocation_p}, which remembers padding\n+information as it reads tokens.  If the next real token is not an\n+opening parenthesis, it backs up that one token, and then pushes an\n+extra context just containing the padding information if necessary.\n+\n+@section Marking tokens ineligible for future expansion\n+As discussed above, cpplib needs a way of marking tokens as\n+unexpandable.  Since the tokens cpplib handles are read-only once they\n+have been lexed, it instead makes a copy of the token and adds the\n+flag @code{NO_EXPAND} to the copy.\n+\n+For efficiency and to simplify memory management by avoiding having to\n+remember to free these tokens, they are allocated as temporary tokens\n+from the lexer's current token run (@pxref{Lexing a line}) using the\n+function @code{_cpp_temp_token}.  The tokens are then re-used once the\n+current line of tokens has been read in.\n+\n+This might sound unsafe.  However, tokens runs are not re-used at the\n+end of a line if it happens to be in the middle of a macro argument\n+list, and cpplib only wants to back-up more than one lexer token in\n+situations where no macro expansion is involved, so the optimization\n+is safe.\n \n @node Token Spacing\n @unnumbered Token Spacing"}]}