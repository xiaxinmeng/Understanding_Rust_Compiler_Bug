{"sha": "304a22ddf1f0ed3bae87d2e9e489eb449e763099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA0YTIyZGRmMWYwZWQzYmFlODdkMmU5ZTQ4OWViNDQ5ZTc2MzA5OQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@redhat.com", "date": "2001-01-25T00:02:49Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2001-01-25T00:02:49Z"}, "message": "reload1.c (reload_reg_free_for_value_p): New parameter start_regno.\n\n\t* reload1.c (reload_reg_free_for_value_p): New parameter start_regno.\n\tChanged all callers.  Take it into account when deciding if a\n\tpreviously loaded value matches.\n\nFrom-SVN: r39251", "tree": {"sha": "fe9e3e51d5e6270ef3f10cf3eba6d7b78d9d8116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe9e3e51d5e6270ef3f10cf3eba6d7b78d9d8116"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/304a22ddf1f0ed3bae87d2e9e489eb449e763099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304a22ddf1f0ed3bae87d2e9e489eb449e763099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/304a22ddf1f0ed3bae87d2e9e489eb449e763099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304a22ddf1f0ed3bae87d2e9e489eb449e763099/comments", "author": null, "committer": null, "parents": [{"sha": "0a28aef93e6edbd2a0858840e3856ce4e0b4037b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a28aef93e6edbd2a0858840e3856ce4e0b4037b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a28aef93e6edbd2a0858840e3856ce4e0b4037b"}], "stats": {"total": 37, "additions": 27, "deletions": 10}, "files": [{"sha": "297208f5101f1af60e56a0bc135775227a58b60f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304a22ddf1f0ed3bae87d2e9e489eb449e763099/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304a22ddf1f0ed3bae87d2e9e489eb449e763099/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=304a22ddf1f0ed3bae87d2e9e489eb449e763099", "patch": "@@ -1,3 +1,9 @@\n+Wed Jan 24 23:51:55 2001  J\"orn Rennecke <amylaar@redhat.com>\n+\n+\t* reload1.c (reload_reg_free_for_value_p): New parameter start_regno.\n+\tChanged all callers.  Take it into account when deciding if a\n+\tpreviously loaded value matches.\n+\n 2001-01-24  Richard Henderson  <rth@redhat.com>\n \n \t* reload.c (find_reloads_subreg_address): Fail the substitution"}, {"sha": "368cfb2d1395c175faaacd7f3808f18f9b5e460c", "filename": "gcc/reload1.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304a22ddf1f0ed3bae87d2e9e489eb449e763099/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304a22ddf1f0ed3bae87d2e9e489eb449e763099/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=304a22ddf1f0ed3bae87d2e9e489eb449e763099", "patch": "@@ -414,7 +414,8 @@ static void clear_reload_reg_in_use\tPARAMS ((unsigned int, int,\n \t\t\t\t\t\t enum machine_mode));\n static int reload_reg_free_p\t\tPARAMS ((unsigned int, int,\n \t\t\t\t\t\t enum reload_type));\n-static int reload_reg_free_for_value_p\tPARAMS ((int, int, enum reload_type,\n+static int reload_reg_free_for_value_p\tPARAMS ((int, int, int,\n+\t\t\t\t\t\t enum reload_type,\n \t\t\t\t\t\t rtx, rtx, int, int));\n static int free_for_value_p\t\tPARAMS ((int, enum machine_mode, int,\n \t\t\t\t\t\t enum reload_type, rtx, rtx,\n@@ -4725,12 +4726,14 @@ rtx reload_override_in[MAX_RELOADS];\n    or -1 if we did not need a register for this reload.  */\n int reload_spill_index[MAX_RELOADS];\n \n-/* Subroutine of free_for_value_p, used to check a single register.  */\n+/* Subroutine of free_for_value_p, used to check a single register.\n+   START_REGNO is the starting regno of the full reload register\n+   (possibly comprising multiple hard registers) that we are considering.  */\n \n static int\n-reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n-\t\t\t     ignore_address_reloads)\n-     int regno;\n+reload_reg_free_for_value_p (start_regno, regno, opnum, type, value, out,\n+\t\t\t     reloadnum, ignore_address_reloads)\n+     int start_regno, regno;\n      int opnum;\n      enum reload_type type;\n      rtx value, out;\n@@ -4823,7 +4826,14 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - (unsigned)1)\n \t  && i != reloadnum)\n \t{\n-\t  if (! rld[i].in || ! rtx_equal_p (rld[i].in, value)\n+\t  rtx other_input = rld[i].in;\n+\n+\t  /* If the other reload loads the same input value, that\n+\t     will not cause a conflict only if it's loading it into\n+\t     the same register.  */\n+\t  if (true_regnum (reg) != start_regno)\n+\t    other_input = NULL_RTX;\n+\t  if (! other_input || ! rtx_equal_p (other_input, value)\n \t      || rld[i].out || out)\n \t    {\n \t      int time2;\n@@ -4904,7 +4914,7 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\tcase RELOAD_OTHER:\n \t\t  /* If there is no conflict in the input part, handle this\n \t\t     like an output reload.  */\n-\t\t  if (! rld[i].in || rtx_equal_p (rld[i].in, value))\n+\t\t  if (! rld[i].in || rtx_equal_p (other_input, value))\n \t\t    {\n \t\t      time2 = MAX_RECOG_OPERANDS * 4 + 4;\n \t\t      /* Earlyclobbered outputs must conflict with inputs.  */\n@@ -4926,7 +4936,7 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t}\n \t      if ((time1 >= time2\n \t\t   && (! rld[i].in || rld[i].out\n-\t\t       || ! rtx_equal_p (rld[i].in, value)))\n+\t\t       || ! rtx_equal_p (other_input, value)))\n \t\t  || (out && rld[reloadnum].out_reg\n \t\t      && time2 >= MAX_RECOG_OPERANDS * 4 + 3))\n \t\treturn 0;\n@@ -4977,8 +4987,9 @@ free_for_value_p (regno, mode, opnum, type, value, out, reloadnum,\n {\n   int nregs = HARD_REGNO_NREGS (regno, mode);\n   while (nregs-- > 0)\n-    if (! reload_reg_free_for_value_p (regno + nregs, opnum, type, value, out,\n-\t\t\t\t       reloadnum, ignore_address_reloads))\n+    if (! reload_reg_free_for_value_p (regno, regno + nregs, opnum, type,\n+\t\t\t\t       value, out, reloadnum,\n+\t\t\t\t       ignore_address_reloads))\n       return 0;\n   return 1;\n }"}]}