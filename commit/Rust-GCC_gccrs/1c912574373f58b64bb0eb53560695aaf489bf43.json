{"sha": "1c912574373f58b64bb0eb53560695aaf489bf43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM5MTI1NzQzNzNmNThiNjRiYjBlYjUzNTYwNjk1YWFmNDg5YmY0Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T09:25:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T09:25:01Z"}, "message": "[multiple changes]\n\n2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* debug.adb (dA): Adjust comment.\n\t* gnat1drv.adb (Gnat1drv): Likewise.\n\t* opt.ads (List_Representation_Info_Extended): New variable.\n\t* repinfo.adb (List_Record_Info): Split implementation into...\n\t(Compute_Max_Length): ...this.\tRecurse on records if requested.\n\t(List_Record_Layout): Likewise.\n\t* switch-c.adb (Scan_Front_End_Switches) <'R'>: Use case\n\tstatement, accept '0' and set List_Representation_Info_Extended\n\ton 'e'.\n\t* usage.adb (Usage): Document new -gnatRe variant.\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case Default_Storage_Pool):\n\tDo not save the given entity in the global variable Default_Pool\n\tif the pragma appears within a generic unit.\n\n2017-09-08  Bob Duff  <duff@adacore.com>\n\n\t* errout.adb (Delete_Warning): Do not\n\tdecrement Warnings_Treated_As_Errors. This is called before\n\tWarnings_Treated_As_Errors has been incremented to account for\n\tthis warning. Decrementing it here can lead to negative values\n\tof Warnings_Treated_As_Errors, raising Constraint_Error in\n\tchecks-on builds, and causing the compiler to return an error\n\tcode in checks-off builds.\n\nFrom-SVN: r251873", "tree": {"sha": "6f82479287d91637a02665224896ab9043679ade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f82479287d91637a02665224896ab9043679ade"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c912574373f58b64bb0eb53560695aaf489bf43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c912574373f58b64bb0eb53560695aaf489bf43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c912574373f58b64bb0eb53560695aaf489bf43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c912574373f58b64bb0eb53560695aaf489bf43/comments", "author": null, "committer": null, "parents": [{"sha": "f0478a53cb286eeb251e891e93609a714da9724c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0478a53cb286eeb251e891e93609a714da9724c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0478a53cb286eeb251e891e93609a714da9724c"}], "stats": {"total": 481, "additions": 317, "deletions": 164}, "files": [{"sha": "53f380a29451929d2e1187c68737b9548a31bd73", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -1,3 +1,32 @@\n+2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* debug.adb (dA): Adjust comment.\n+\t* gnat1drv.adb (Gnat1drv): Likewise.\n+\t* opt.ads (List_Representation_Info_Extended): New variable.\n+\t* repinfo.adb (List_Record_Info): Split implementation into...\n+\t(Compute_Max_Length): ...this.\tRecurse on records if requested.\n+\t(List_Record_Layout): Likewise.\n+\t* switch-c.adb (Scan_Front_End_Switches) <'R'>: Use case\n+\tstatement, accept '0' and set List_Representation_Info_Extended\n+\ton 'e'.\n+\t* usage.adb (Usage): Document new -gnatRe variant.\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Default_Storage_Pool):\n+\tDo not save the given entity in the global variable Default_Pool\n+\tif the pragma appears within a generic unit.\n+\n+2017-09-08  Bob Duff  <duff@adacore.com>\n+\n+\t* errout.adb (Delete_Warning): Do not\n+\tdecrement Warnings_Treated_As_Errors. This is called before\n+\tWarnings_Treated_As_Errors has been incremented to account for\n+\tthis warning. Decrementing it here can lead to negative values\n+\tof Warnings_Treated_As_Errors, raising Constraint_Error in\n+\tchecks-on builds, and causing the compiler to return an error\n+\tcode in checks-off builds.\n+\n 2017-09-08  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_util.ads, sem_util.adb (Is_CCT_Instance): Only expect"}, {"sha": "3dbe1f9ae8732339afba929d2afe82c8ec6fe34b", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -357,7 +357,7 @@ package body Debug is\n    --       information for all internal type and object entities, as well\n    --       as all user defined type and object entities including private\n    --       and incomplete types. This debug switch also automatically sets\n-   --       the equivalent of -gnatR3m.\n+   --       the equivalent of -gnatRm.\n \n    --  dB   Output debug encodings for types and variants. See Exp_Dbug for\n    --       exact form of the generated output."}, {"sha": "a04df945be8ba2ada65d8e23e75e985f67991b92", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -1434,10 +1434,6 @@ package body Errout is\n             if Errors.Table (E).Info then\n                Warning_Info_Messages := Warning_Info_Messages - 1;\n             end if;\n-\n-            if Errors.Table (E).Warn_Err then\n-               Warnings_Treated_As_Errors := Warnings_Treated_As_Errors - 1;\n-            end if;\n          end if;\n       end Delete_Warning;\n "}, {"sha": "e6fc897de55fb5ba0269260ac33a1c7afc814ab3", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -540,7 +540,7 @@ procedure Gnat1drv is\n          Configurable_Run_Time_Mode := True;\n       end if;\n \n-      --  Set -gnatR3m mode if debug flag A set\n+      --  Set -gnatRm mode if debug flag A set\n \n       if Debug_Flag_AA then\n          Back_Annotate_Rep_Info := True;"}, {"sha": "aef84edcfaca798010679e1ed7312714bd1262d8", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -982,6 +982,11 @@ package Opt is\n    --  Set true by -gnatRm switch. Causes information on mechanisms to be\n    --  included in the representation output information.\n \n+   List_Representation_Info_Extended : Boolean := False;\n+   --  GNAT\n+   --  Set true by -gnatRe switch. Causes extended information for record types\n+   --  to be included in the representation output information.\n+\n    List_Preprocessing_Symbols : Boolean := False;\n    --  GNAT, GNATPREP\n    --  Set to True if symbols for preprocessing a source are to be listed"}, {"sha": "a6d60cbf1d368e88e721890939c92c40551b5cb9", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 263, "deletions": 149, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -854,212 +854,326 @@ package body Repinfo is\n    ----------------------\n \n    procedure List_Record_Info (Ent : Entity_Id; Bytes_Big_Endian : Boolean) is\n-      Comp  : Entity_Id;\n-      Cfbit : Uint;\n-      Sunit : Uint;\n \n-      Max_Name_Length : Natural;\n-      Max_Suni_Length : Natural;\n+      procedure Compute_Max_Length\n+        (Ent                : Entity_Id;\n+         Starting_Position  : Uint := Uint_0;\n+         Starting_First_Bit : Uint := Uint_0;\n+         Prefix_Length      : Natural := 0);\n+      --  Internal recursive procedure to compute the max length\n+\n+      procedure List_Record_Layout\n+        (Ent                : Entity_Id;\n+         Starting_Position  : Uint := Uint_0;\n+         Starting_First_Bit : Uint := Uint_0;\n+         Prefix             : String := \"\");\n+      --  Internal recursive procedure to display the layout\n+\n+      Max_Name_Length : Natural := 0;\n+      Max_Spos_Length : Natural := 0;\n+\n+      ------------------------\n+      -- Compute_Max_Length --\n+      ------------------------\n+\n+      procedure Compute_Max_Length\n+        (Ent                : Entity_Id;\n+         Starting_Position  : Uint := Uint_0;\n+         Starting_First_Bit : Uint := Uint_0;\n+         Prefix_Length      : Natural := 0)\n+      is\n+         Comp  : Entity_Id;\n \n-   begin\n-      Blank_Line;\n-      List_Type_Info (Ent);\n+      begin\n+         Comp := First_Component_Or_Discriminant (Ent);\n+         while Present (Comp) loop\n \n-      Write_Str (\"for \");\n-      List_Name (Ent);\n-      Write_Line (\" use record\");\n+            --  Skip discriminant in unchecked union (since it is not there!)\n \n-      --  First loop finds out max line length and max starting position\n-      --  length, for the purpose of lining things up nicely.\n+            if Ekind (Comp) = E_Discriminant\n+              and then Is_Unchecked_Union (Ent)\n+            then\n+               goto Continue;\n+            end if;\n \n-      Max_Name_Length := 0;\n-      Max_Suni_Length := 0;\n+            --  All other cases\n \n-      Comp := First_Component_Or_Discriminant (Ent);\n-      while Present (Comp) loop\n+            declare\n+               Ctyp : constant Entity_Id := Underlying_Type (Etype (Comp));\n+               Bofs : constant Uint      := Component_Bit_Offset (Comp);\n+               Npos : Uint;\n+               Fbit : Uint;\n+               Spos : Uint;\n+               Sbit : Uint;\n+               Name_Length : Natural;\n+            begin\n+               Get_Decoded_Name_String (Chars (Comp));\n+               Name_Length := Prefix_Length + Name_Len;\n \n-         --  Skip discriminant in unchecked union (since it is not there!)\n+               if Rep_Not_Constant (Bofs) then\n \n-         if Ekind (Comp) = E_Discriminant\n-           and then Is_Unchecked_Union (Ent)\n-         then\n-            null;\n+                  --  If the record is not packed, then we know that all fields\n+                  --  whose position is not specified have starting normalized\n+                  --  bit position of zero.\n \n-         --  All other cases\n+                  if Unknown_Normalized_First_Bit (Comp)\n+                    and then not Is_Packed (Ent)\n+                  then\n+                     Set_Normalized_First_Bit (Comp, Uint_0);\n+                  end if;\n \n-         else\n-            Get_Decoded_Name_String (Chars (Comp));\n-            Max_Name_Length := Natural'Max (Max_Name_Length, Name_Len);\n+                  UI_Image_Length := 2; -- For \"??\" marker\n+               else\n+                  Npos := Bofs / SSU;\n+                  Fbit := Bofs mod SSU;\n \n-            Cfbit := Component_Bit_Offset (Comp);\n+                  --  Complete annotation in case not done\n \n-            if Rep_Not_Constant (Cfbit) then\n+                  if Unknown_Normalized_First_Bit (Comp) then\n+                     Set_Normalized_Position  (Comp, Npos);\n+                     Set_Normalized_First_Bit (Comp, Fbit);\n+                  end if;\n \n-               --  If the record is not packed, then we know that all fields\n-               --  whose position is not specified have a starting normalized\n-               --  bit position of zero.\n+                  Spos := Starting_Position  + Npos;\n+                  Sbit := Starting_First_Bit + Fbit;\n+                  if Sbit >= SSU then\n+                     Spos := Spos + 1;\n+                     Sbit := Sbit - SSU;\n+                  end if;\n \n-               if Unknown_Normalized_First_Bit (Comp)\n-                 and then not Is_Packed (Ent)\n-               then\n-                  Set_Normalized_First_Bit (Comp, Uint_0);\n-               end if;\n+                  --  If extended information is requested, recurse fully into\n+                  --  record components, i.e. skip the outer level.\n \n-               UI_Image_Length := 2; -- For \"??\" marker\n-            else\n-               --  Complete annotation in case not done\n+                  if List_Representation_Info_Extended\n+                    and then Is_Record_Type (Ctyp)\n+                  then\n+                     Compute_Max_Length (Ctyp, Spos, Sbit, Name_Length + 1);\n+                     goto Continue;\n+                  end if;\n \n-               if Unknown_Normalized_First_Bit (Comp) then\n-                  Set_Normalized_Position (Comp, Cfbit / SSU);\n-                  Set_Normalized_First_Bit (Comp, Cfbit mod SSU);\n+                  UI_Image (Spos);\n                end if;\n \n-               Sunit := Cfbit / SSU;\n-               UI_Image (Sunit);\n-            end if;\n+               Max_Name_Length := Natural'Max (Max_Name_Length, Name_Length);\n+               Max_Spos_Length :=\n+                 Natural'Max (Max_Spos_Length, UI_Image_Length);\n+            end;\n \n-            Max_Suni_Length := Natural'Max (Max_Suni_Length, UI_Image_Length);\n-         end if;\n+         <<Continue>>\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n+      end Compute_Max_Length;\n \n-         Next_Component_Or_Discriminant (Comp);\n-      end loop;\n+      ------------------------\n+      -- List_Record_Layout --\n+      ------------------------\n \n-      --  Second loop does actual output based on those values\n+      procedure List_Record_Layout\n+        (Ent                : Entity_Id;\n+         Starting_Position  : Uint := Uint_0;\n+         Starting_First_Bit : Uint := Uint_0;\n+         Prefix             : String := \"\")\n+      is\n+         Comp  : Entity_Id;\n \n-      Comp := First_Component_Or_Discriminant (Ent);\n-      while Present (Comp) loop\n+      begin\n+         Comp := First_Component_Or_Discriminant (Ent);\n+         while Present (Comp) loop\n \n-         --  Skip discriminant in unchecked union (since it is not there!)\n+            --  Skip discriminant in unchecked union (since it is not there!)\n \n-         if Ekind (Comp) = E_Discriminant\n-           and then Is_Unchecked_Union (Ent)\n-         then\n-            goto Continue;\n-         end if;\n+            if Ekind (Comp) = E_Discriminant\n+              and then Is_Unchecked_Union (Ent)\n+            then\n+               goto Continue;\n+            end if;\n \n-         --  All other cases\n+            --  All other cases\n \n-         declare\n-            Esiz : constant Uint := Esize (Comp);\n-            Bofs : constant Uint := Component_Bit_Offset (Comp);\n-            Npos : constant Uint := Normalized_Position (Comp);\n-            Fbit : constant Uint := Normalized_First_Bit (Comp);\n-            Lbit : Uint;\n+            declare\n+               Ctyp : constant Entity_Id := Underlying_Type (Etype (Comp));\n+               Esiz : constant Uint      := Esize (Comp);\n+               Bofs : constant Uint      := Component_Bit_Offset (Comp);\n+               Npos : constant Uint      := Normalized_Position (Comp);\n+               Fbit : constant Uint      := Normalized_First_Bit (Comp);\n+               Spos : Uint;\n+               Sbit : Uint;\n+               Lbit : Uint;\n \n-         begin\n-            Write_Str (\"   \");\n-            Get_Decoded_Name_String (Chars (Comp));\n-            Set_Casing (Unit_Casing);\n-            Write_Str (Name_Buffer (1 .. Name_Len));\n+            begin\n+               Get_Decoded_Name_String (Chars (Comp));\n+               Set_Casing (Unit_Casing);\n \n-            for J in 1 .. Max_Name_Length - Name_Len loop\n-               Write_Char (' ');\n-            end loop;\n+               --  If extended information is requested, recurse fully into\n+               --  record components, i.e. skip the outer level.\n \n-            Write_Str (\" at \");\n+               if List_Representation_Info_Extended\n+                 and then Is_Record_Type (Ctyp)\n+                 and then Known_Static_Normalized_Position (Comp)\n+                 and then Known_Static_Normalized_First_Bit (Comp)\n+               then\n+                  Spos := Starting_Position  + Npos;\n+                  Sbit := Starting_First_Bit + Fbit;\n+                  if Sbit >= SSU then\n+                     Spos := Spos + 1;\n+                     Sbit := Sbit - SSU;\n+                  end if;\n+                  List_Record_Layout (Ctyp,\n+                    Spos, Sbit, Prefix & Name_Buffer (1 .. Name_Len) & \".\");\n+                  goto Continue;\n+               end if;\n \n-            if Known_Static_Normalized_Position (Comp) then\n-               UI_Image (Npos);\n-               Spaces (Max_Suni_Length - UI_Image_Length);\n-               Write_Str (UI_Image_Buffer (1 .. UI_Image_Length));\n+               Write_Str (\"   \");\n+               Write_Str (Prefix);\n+               Write_Str (Name_Buffer (1 .. Name_Len));\n \n-            elsif Known_Component_Bit_Offset (Comp)\n-              and then List_Representation_Info = 3\n-            then\n-               Spaces (Max_Suni_Length - 2);\n-               Write_Str (\"bit offset\");\n-               Write_Val (Bofs, Paren => True);\n-               Write_Str (\" size in bits = \");\n-               Write_Val (Esiz, Paren => True);\n-               Write_Eol;\n-               goto Continue;\n+               for J in 1 .. Max_Name_Length -  Prefix'Length - Name_Len loop\n+                  Write_Char (' ');\n+               end loop;\n \n-            elsif Known_Normalized_Position (Comp)\n-              and then List_Representation_Info = 3\n-            then\n-               Spaces (Max_Suni_Length - 2);\n-               Write_Val (Npos);\n+               Write_Str (\" at \");\n \n-            else\n-               --  For the packed case, we don't know the bit positions if we\n-               --  don't know the starting position.\n+               if Known_Static_Normalized_Position (Comp) then\n+                  Spos := Starting_Position  + Npos;\n+                  Sbit := Starting_First_Bit + Fbit;\n+                  if Sbit >= SSU then\n+                     Spos := Spos + 1;\n+                  end if;\n+                  UI_Image (Spos);\n+                  Spaces (Max_Spos_Length - UI_Image_Length);\n+                  Write_Str (UI_Image_Buffer (1 .. UI_Image_Length));\n \n-               if Is_Packed (Ent) then\n-                  Write_Line (\"?? range  ? .. ??;\");\n+               elsif Known_Component_Bit_Offset (Comp)\n+                 and then List_Representation_Info = 3\n+               then\n+                  Spaces (Max_Spos_Length - 2);\n+                  Write_Str (\"bit offset\");\n+                  if Starting_Position /= Uint_0\n+                    or else Starting_First_Bit /= Uint_0\n+                  then\n+                     Write_Char (' ');\n+                     UI_Write (Starting_Position * SSU + Starting_First_Bit);\n+                     Write_Str (\" +\");\n+                  end if;\n+                  Write_Val (Bofs, Paren => True);\n+                  Write_Str (\" size in bits = \");\n+                  Write_Val (Esiz, Paren => True);\n+                  Write_Eol;\n                   goto Continue;\n \n-               --  Otherwise we can continue\n+               elsif Known_Normalized_Position (Comp)\n+                 and then List_Representation_Info = 3\n+               then\n+                  Spaces (Max_Spos_Length - 2);\n+                  if Starting_Position /= Uint_0 then\n+                     Write_Char (' ');\n+                     UI_Write (Starting_Position);\n+                     Write_Str (\" +\");\n+                  end if;\n+                  Write_Val (Npos);\n \n                else\n-                  Write_Str (\"??\");\n-               end if;\n-            end if;\n+                  --  For the packed case, we don't know the bit positions if\n+                  --  we don't know the starting position.\n \n-            Write_Str (\" range  \");\n-            UI_Write (Fbit);\n-            Write_Str (\" .. \");\n+                  if Is_Packed (Ent) then\n+                     Write_Line (\"?? range  ? .. ??;\");\n+                     goto Continue;\n \n-            --  Allowing Uint_0 here is an annoying special case. Really this\n-            --  should be a fine Esize value but currently it means unknown,\n-            --  except that we know after gigi has back annotated that a size\n-            --  of zero is real, since otherwise gigi back annotates using\n-            --  No_Uint as the value to indicate unknown).\n+                  --  Otherwise we can continue\n \n-            if (Esize (Comp) = Uint_0 or else Known_Static_Esize (Comp))\n-              and then Known_Static_Normalized_First_Bit (Comp)\n-            then\n-               Lbit := Fbit + Esiz - 1;\n+                  else\n+                     Write_Str (\"??\");\n+                  end if;\n+               end if;\n \n-               if Lbit < 10 then\n-                  Write_Char (' ');\n+               Write_Str (\" range  \");\n+               Sbit := Starting_First_Bit + Fbit;\n+               if Sbit >= SSU then\n+                  Sbit := Sbit - SSU;\n                end if;\n+               UI_Write (Sbit);\n+               Write_Str (\" .. \");\n \n-               UI_Write (Lbit);\n+               --  Allowing Uint_0 here is an annoying special case. Really\n+               --  this should be a fine Esize value but currently it means\n+               --  unknown, except that we know after gigi has back annotated\n+               --  that a size  of zero is real, since otherwise gigi back\n+               --  annotates using No_Uint as the value to indicate unknown).\n \n-            --  The test for Esize (Comp) not Uint_0 here is an annoying\n-            --  special case. Officially a value of zero for Esize means\n-            --  unknown, but here we use the fact that we know that gigi\n-            --  annotates Esize with No_Uint, not Uint_0. Really everyone\n-            --  should use No_Uint???\n+               if (Esize (Comp) = Uint_0 or else Known_Static_Esize (Comp))\n+                 and then Known_Static_Normalized_First_Bit (Comp)\n+               then\n+                  Lbit := Sbit + Esiz - 1;\n \n-            elsif List_Representation_Info < 3\n-              or else (Esize (Comp) /= Uint_0 and then Unknown_Esize (Comp))\n-            then\n-               Write_Str (\"??\");\n+                  if Lbit < 10 then\n+                     Write_Char (' ');\n+                  end if;\n \n-            --  List_Representation >= 3 and Known_Esize (Comp)\n+                  UI_Write (Lbit);\n \n-            else\n-               Write_Val (Esiz, Paren => True);\n+               --  The test for Esize (Comp) not Uint_0 here is an annoying\n+               --  special case. Officially a value of zero for Esize means\n+               --  unknown, but here we use the fact that we know that gigi\n+               --  annotates Esize with No_Uint, not Uint_0. Really everyone\n+               --  should use No_Uint???\n \n-               --  If in front end layout mode, then dynamic size is stored\n-               --  in storage units, so renormalize for output\n+               elsif List_Representation_Info < 3\n+                 or else (Esize (Comp) /= Uint_0 and then Unknown_Esize (Comp))\n+               then\n+                  Write_Str (\"??\");\n \n-               if not Back_End_Layout then\n-                  Write_Str (\" * \");\n-                  Write_Int (SSU);\n-               end if;\n+               --  List_Representation >= 3 and Known_Esize (Comp)\n \n-               --  Add appropriate first bit offset\n+               else\n+                  Write_Val (Esiz, Paren => True);\n \n-               if Fbit = 0 then\n-                  Write_Str (\" - 1\");\n+                  --  If in front end layout mode, then dynamic size is stored\n+                  --  in storage units, so renormalize for output\n \n-               elsif Fbit = 1 then\n-                  null;\n+                  if not Back_End_Layout then\n+                     Write_Str (\" * \");\n+                     Write_Int (SSU);\n+                  end if;\n \n-               else\n-                  Write_Str (\" + \");\n-                  Write_Int (UI_To_Int (Fbit) - 1);\n+                  --  Add appropriate first bit offset\n+\n+                  if Sbit = 0 then\n+                     Write_Str (\" - 1\");\n+\n+                  elsif Sbit = 1 then\n+                     null;\n+\n+                  else\n+                     Write_Str (\" + \");\n+                     Write_Int (UI_To_Int (Sbit) - 1);\n+                  end if;\n                end if;\n-            end if;\n \n-            Write_Line (\";\");\n-         end;\n+               Write_Line (\";\");\n+            end;\n \n-      <<Continue>>\n-         Next_Component_Or_Discriminant (Comp);\n-      end loop;\n+         <<Continue>>\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n+      end List_Record_Layout;\n+\n+   begin\n+      Blank_Line;\n+      List_Type_Info (Ent);\n+\n+      Write_Str (\"for \");\n+      List_Name (Ent);\n+      Write_Line (\" use record\");\n+\n+      --  First find out max line length and max starting position\n+      --  length, for the purpose of lining things up nicely.\n+\n+      Compute_Max_Length (Ent);\n+\n+      --  Then do actual output based on those values\n+\n+      List_Record_Layout (Ent);\n \n       Write_Line (\"end record;\");\n "}, {"sha": "7bfb53e79c40ceb26c92b207d05f677f87b10ccf", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -14393,9 +14393,13 @@ package body Sem_Prag is\n \n                --  Record the pool name (or null). Freeze.Freeze_Entity for an\n                --  access type will use this information to set the appropriate\n-               --  attributes of the access type.\n+               --  attributes of the access type. If the pragma appears in a\n+               --  generic unit it is ignored, given that it may refer to a\n+               --  local entity.\n \n-               Default_Pool := Pool;\n+               if not Inside_A_Generic then\n+                  Default_Pool := Pool;\n+               end if;\n             end if;\n          end Default_Storage_Pool;\n "}, {"sha": "a087dd20558a7b780655670772898d1a166828da", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1143,19 +1143,24 @@ package body Switch.C is\n                while Ptr <= Max loop\n                   C := Switch_Chars (Ptr);\n \n-                  if C in '1' .. '3' then\n+                  case C is\n+\n+                  when '0' .. '3' =>\n                      List_Representation_Info :=\n                        Character'Pos (C) - Character'Pos ('0');\n \n-                  elsif Switch_Chars (Ptr) = 's' then\n+                  when 's' =>\n                      List_Representation_Info_To_File := True;\n \n-                  elsif Switch_Chars (Ptr) = 'm' then\n+                  when 'm' =>\n                      List_Representation_Info_Mechanisms := True;\n \n-                  else\n+                  when 'e' =>\n+                     List_Representation_Info_Extended := True;\n+\n+                  when others =>\n                      Bad_Switch (\"-gnatR\" & Switch_Chars (Ptr .. Max));\n-                  end if;\n+                  end case;\n \n                   Ptr := Ptr + 1;\n                end loop;"}, {"sha": "1c50c7d7c7f6eef7efee75cf488bdd6a7ec72e41", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c912574373f58b64bb0eb53560695aaf489bf43/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=1c912574373f58b64bb0eb53560695aaf489bf43", "patch": "@@ -392,7 +392,7 @@ begin\n \n    Write_Switch_Char (\"R?\");\n    Write_Line\n-     (\"List rep info (?=0/1/2/3/m for none/types/all/variable/mechanisms)\");\n+     (\"List rep info (?=0/1/2/3/e/m for none/types/all/symbolic/ext/mech)\");\n    Write_Switch_Char (\"R?s\");\n    Write_Line (\"List rep info to file.rep instead of standard output\");\n "}]}