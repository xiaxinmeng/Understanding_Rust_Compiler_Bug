{"sha": "e8b7a1372c940ebd8e6db448efeb6386d4c1c206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThiN2ExMzcyYzk0MGViZDhlNmRiNDQ4ZWZlYjYzODZkNGMxYzIwNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-18T17:03:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-18T17:03:59Z"}, "message": "mips.c (mips_expand_call): Use FAKE_CALL_REGNO.\n\ngcc/\n\t* config/mips/mips.c (mips_expand_call): Use FAKE_CALL_REGNO.\n\t(mips_avoid_hazard): Allow multiple sets for HAZARD_DELAY,\n\tand pick the first.\n\t* config/mips/mips.md (load_call<mode>): Don't make the unspec\n\tdepend on FAKE_CALL_REGNO.  Set FAKE_CALL_REGNO.\n\nFrom-SVN: r129449", "tree": {"sha": "629ac7ece722e175279e37850a6234c784b3968a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/629ac7ece722e175279e37850a6234c784b3968a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8b7a1372c940ebd8e6db448efeb6386d4c1c206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8b7a1372c940ebd8e6db448efeb6386d4c1c206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8b7a1372c940ebd8e6db448efeb6386d4c1c206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8b7a1372c940ebd8e6db448efeb6386d4c1c206/comments", "author": null, "committer": null, "parents": [{"sha": "e34537aa38200164919385f3b6cdf460790ed9d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e34537aa38200164919385f3b6cdf460790ed9d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e34537aa38200164919385f3b6cdf460790ed9d6"}], "stats": {"total": 75, "additions": 58, "deletions": 17}, "files": [{"sha": "956f4674d074d4c11059903477e5f73d10fec99d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8b7a1372c940ebd8e6db448efeb6386d4c1c206/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8b7a1372c940ebd8e6db448efeb6386d4c1c206/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8b7a1372c940ebd8e6db448efeb6386d4c1c206", "patch": "@@ -1,3 +1,11 @@\n+2007-10-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.c (mips_expand_call): Use FAKE_CALL_REGNO.\n+\t(mips_avoid_hazard): Allow multiple sets for HAZARD_DELAY,\n+\tand pick the first.\n+\t* config/mips/mips.md (load_call<mode>): Don't make the unspec\n+\tdepend on FAKE_CALL_REGNO.  Set FAKE_CALL_REGNO.\n+\n 2007-10-18  David Daney  <ddaney@avtrex.com>\n \n \t* config/mips/linux-unwind.h (mips_fallback_frame_state): Use new"}, {"sha": "befb1fe452b91e2a93ff17c3438506ff3e6dd0ad", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8b7a1372c940ebd8e6db448efeb6386d4c1c206/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8b7a1372c940ebd8e6db448efeb6386d4c1c206/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e8b7a1372c940ebd8e6db448efeb6386d4c1c206", "patch": "@@ -308,7 +308,7 @@ static int m16_check_op (rtx, int, int, int);\n static bool mips_rtx_costs (rtx, int, int, int *);\n static int mips_address_cost (rtx);\n static void mips_emit_compare (enum rtx_code *, rtx *, rtx *, bool);\n-static void mips_load_call_address (rtx, rtx, int);\n+static bool mips_load_call_address (rtx, rtx, int);\n static bool mips_function_ok_for_sibcall (tree, tree);\n static void mips_block_move_straight (rtx, rtx, HOST_WIDE_INT);\n static void mips_adjust_block_mem (rtx, HOST_WIDE_INT, rtx *, rtx *);\n@@ -4135,9 +4135,10 @@ mips_ok_for_lazy_binding_p (rtx x)\n }\n \n /* Load function address ADDR into register DEST.  SIBCALL_P is true\n-   if the address is needed for a sibling call.  */\n+   if the address is needed for a sibling call.  Return true if we\n+   used an explicit lazy-binding sequence.  */\n \n-static void\n+static bool\n mips_load_call_address (rtx dest, rtx addr, int sibcall_p)\n {\n   /* If we're generating PIC, and this call is to a global function,\n@@ -4157,9 +4158,13 @@ mips_load_call_address (rtx dest, rtx addr, int sibcall_p)\n \temit_insn (gen_load_callsi (dest, high, lo_sum_symbol));\n       else\n \temit_insn (gen_load_calldi (dest, high, lo_sum_symbol));\n+      return true;\n     }\n   else\n-    mips_emit_move (dest, addr);\n+    {\n+      mips_emit_move (dest, addr);\n+      return false;\n+    }\n }\n \n \n@@ -4174,12 +4179,14 @@ void\n mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n {\n   rtx orig_addr, pattern, insn;\n+  bool lazy_p;\n \n   orig_addr = addr;\n+  lazy_p = false;\n   if (!call_insn_operand (addr, VOIDmode))\n     {\n       addr = gen_reg_rtx (Pmode);\n-      mips_load_call_address (addr, orig_addr, sibcall_p);\n+      lazy_p = mips_load_call_address (addr, orig_addr, sibcall_p);\n     }\n \n   if (TARGET_MIPS16\n@@ -4210,9 +4217,15 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n \n   insn = emit_call_insn (pattern);\n \n-  /* Lazy-binding stubs require $gp to be valid on entry.  */\n-  if (mips_ok_for_lazy_binding_p (orig_addr))\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+  /* Lazy-binding stubs require $gp to be valid on entry.  We also pretend\n+     that they use FAKE_CALL_REGNO; see the load_call<mode> patterns for\n+     details.  */\n+  if (lazy_p)\n+    {\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn),\n+\t       gen_rtx_REG (Pmode, FAKE_CALL_REGNO));\n+    }\n }\n \n \n@@ -10748,7 +10761,7 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n \t\t   rtx *delayed_reg, rtx lo_reg)\n {\n   rtx pattern, set;\n-  int nops, ninsns;\n+  int nops, ninsns, hazard_set;\n \n   if (!INSN_P (insn))\n     return;\n@@ -10797,8 +10810,15 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n \tbreak;\n \n       case HAZARD_DELAY:\n-\tset = single_set (insn);\n-\tgcc_assert (set != 0);\n+\thazard_set = (int) get_attr_hazard_set (insn);\n+\tif (hazard_set == 0)\n+\t  set = single_set (insn);\n+\telse\n+\t  {\n+\t    gcc_assert (GET_CODE (PATTERN (insn)) == PARALLEL);\n+\t    set = XVECEXP (PATTERN (insn), 0, hazard_set - 1);\n+\t  }\n+\tgcc_assert (set && GET_CODE (set) == SET);\n \t*delayed_reg = SET_DEST (set);\n \tbreak;\n       }"}, {"sha": "53726e85261d76a8a2bc3de476a7adc3a1eda918", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8b7a1372c940ebd8e6db448efeb6386d4c1c206/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8b7a1372c940ebd8e6db448efeb6386d4c1c206/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e8b7a1372c940ebd8e6db448efeb6386d4c1c206", "patch": "@@ -438,6 +438,17 @@\n \t (const_string \"hilo\")]\n \t(const_string \"none\")))\n \n+;; Indicates which SET in an instruction pattern induces a hazard.\n+;; Only meaningful when \"hazard\" is not \"none\".  SINGLE means that\n+;; the pattern has only one set while the other values are indexes\n+;; into a PARALLEL vector.\n+;;\n+;; Hazardous instructions with multiple sets should generally put the\n+;; hazardous set first.  The only purpose of this attribute is to force\n+;; each multi-set pattern to explicitly assert that this condition holds.\n+(define_attr \"hazard_set\" \"single,0\"\n+  (const_string \"single\"))\n+\n ;; Is it a single instruction?\n (define_attr \"single_insn\" \"no,yes\"\n   (symbol_ref \"get_attr_length (insn) == (TARGET_MIPS16 ? 2 : 4)\"))\n@@ -5606,19 +5617,21 @@\n ;; we must not call it again.\n ;;\n ;; We represent this restriction using an imaginary fixed register that\n-;; acts like a GOT version number.  By making the register call-clobbered,\n-;; we tell the target-independent code that the address could be changed\n-;; by any call insn.\n+;; is set by the GOT load and used by the call.  By making this register\n+;; call-clobbered, and by making the GOT load the only way of setting\n+;; the register, we ensure that the load cannot be moved past a call.\n (define_insn \"load_call<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n \t(unspec:P [(match_operand:P 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:P 2 \"immediate_operand\" \"\")\n-\t\t   (reg:P FAKE_CALL_REGNO)]\n-\t\t  UNSPEC_LOAD_CALL))]\n+\t\t   (match_operand:P 2 \"immediate_operand\" \"\")]\n+\t\t  UNSPEC_LOAD_CALL))\n+   (set (reg:P FAKE_CALL_REGNO)\n+\t(unspec:P [(match_dup 2)] UNSPEC_LOAD_CALL))]\n   \"TARGET_USE_GOT\"\n   \"<load>\\t%0,%R2(%1)\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"hazard_set\" \"0\")\n    (set_attr \"length\" \"4\")])\n \n ;; Sibling calls.  All these patterns use jump instructions."}]}