{"sha": "11972f66cd1f76eec0f48acc0200af4b83723721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE5NzJmNjZjZDFmNzZlZWMwZjQ4YWNjMDIwMGFmNGI4MzcyMzcyMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-01-10T08:18:10Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-01-10T08:18:10Z"}, "message": "gcc.c (cpp_options): Set MD file name from output filename, if specified.\n\n        * gcc.c (cpp_options): Set MD file name from output\n        filename, if specified.\n        (suffix_subst): New static variable.\n        (do_spec): Clear it.\n        (do_spec_1, case '.'): Handle new `%.suffix' spec.\n        Clear it.\n        (give_switch): Handle suffix_subst.\n\nFrom-SVN: r38859", "tree": {"sha": "b958bae2dcc781e1119e1f01bd7f1599d9d04fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b958bae2dcc781e1119e1f01bd7f1599d9d04fae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11972f66cd1f76eec0f48acc0200af4b83723721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11972f66cd1f76eec0f48acc0200af4b83723721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11972f66cd1f76eec0f48acc0200af4b83723721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11972f66cd1f76eec0f48acc0200af4b83723721/comments", "author": null, "committer": null, "parents": [{"sha": "0a75e5c306359e717f9e070a7b41c29964c64a54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a75e5c306359e717f9e070a7b41c29964c64a54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a75e5c306359e717f9e070a7b41c29964c64a54"}], "stats": {"total": 57, "additions": 54, "deletions": 3}, "files": [{"sha": "080354db9b8cba2a8ac9e87c00b38d04811279fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11972f66cd1f76eec0f48acc0200af4b83723721/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11972f66cd1f76eec0f48acc0200af4b83723721/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11972f66cd1f76eec0f48acc0200af4b83723721", "patch": "@@ -1,3 +1,13 @@\n+2001-01-10  Nathan Sidwell  <nathan@codesourcery.com>\n+\t\n+        * gcc.c (cpp_options): Set MD file name from output\n+        filename, if specified.\n+        (suffix_subst): New static variable.\n+        (do_spec): Clear it.\n+        (do_spec_1, case '.'): Handle new `%.suffix' spec.\n+        Clear it.\n+        (give_switch): Handle suffix_subst.\n+\n 2001-01-10  Phil Edwards  <pme@sources.redhat.com>\n \n \t* invoke.texi:  Fix another typo."}, {"sha": "d003e25a498b4f895412da8a37667ad577a7529b", "filename": "gcc/gcc.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11972f66cd1f76eec0f48acc0200af4b83723721/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11972f66cd1f76eec0f48acc0200af4b83723721/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=11972f66cd1f76eec0f48acc0200af4b83723721", "patch": "@@ -318,6 +318,10 @@ or with constant text in a single argument.\n         of a temporary file, just like %u.  This temporary file is not\n         meant for communication between processes, but rather as a junk\n         disposal mechanism.\n+ %.SUFFIX\n+        substitutes .SUFFIX for the suffixes of a matched switch's args when\n+        it is subsequently output with %*. SUFFIX is terminated by the next\n+        space or %.\n  %d\tmarks the argument containing or following the %d as a\n \ttemporary file name, so that that file will be deleted if CC exits\n \tsuccessfully.  Unlike %g, this contributes no text to the argument.\n@@ -586,8 +590,8 @@ static const char *cpp_options =\n \"%{C:%{!E:%eGNU C does not support -C without using -E}}\\\n  %{std*} %{nostdinc*}\\\n  %{C} %{v} %{I*} %{P} %{$} %I\\\n- %{M} %{MM} %{MD:-M -MF %b.d} %{MMD:-MM -MF %b.d} %{MF} %{MG} %{MP} %{MQ} %{MT}\\\n- %{M|MD|MM|MMD:%{o*:-MQ %*}}\\\n+ %{MD:-M -MF %{!o: %b.d}%{o*:%.d%*}} %{MMD:-MM -MF %{!o: %b.d}%{o*:%.d%*}}\\\n+ %{M} %{MM} %{MF} %{MG} %{MP} %{MQ} %{MT} %{M|MD|MM|MMD:%{o*:-MQ %*}}\\\n  %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n  %{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\\\n  %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}}\\\n@@ -3853,6 +3857,10 @@ static int this_is_library_file;\n /* Nonzero means that the input of this command is coming from a pipe.  */\n static int input_from_pipe;\n \n+/* Nonnull means substitute this for any suffix when outputting a switches\n+   arguments. */\n+static const char *suffix_subst;\n+\n /* Process the spec SPEC and run the commands specified therein.\n    Returns 0 if the spec is successfully processed; -1 if failed.  */\n \n@@ -3868,6 +3876,7 @@ do_spec (spec)\n   this_is_output_file = 0;\n   this_is_library_file = 0;\n   input_from_pipe = 0;\n+  suffix_subst = NULL;\n \n   value = do_spec_1 (spec, 0, NULL_PTR);\n \n@@ -4622,6 +4631,17 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    obstack_1grow (&obstack, '%');\n \t    break;\n \n+         case '.':\n+\t   {\n+\t     unsigned len = 0;\n+\n+\t     while (p[len] && p[len] != ' ' && p[len] != '%')\n+\t       len++;\n+             suffix_subst = save_string (p - 1, len + 1);\n+             p += len;\n+           }\n+\t   break;\n+          \n \t  case '*':\n \t    if (soft_matched_part)\n \t      {\n@@ -4972,6 +4992,7 @@ handle_braces (p)\n \t\t    do_spec_1 (string, 0, &switches[i].part1[hard_match_len]);\n \t\t    /* Pass any arguments this switch has.  */\n \t\t    give_switch (i, 1, 1);\n+\t\t    suffix_subst = NULL;\n \t\t  }\n \n \t      /* We didn't match.  Try again.  */\n@@ -5179,9 +5200,29 @@ give_switch (switchnum, omit_first_word, include_blanks)\n       const char **p;\n       for (p = switches[switchnum].args; *p; p++)\n \t{\n+\t  const char *arg = *p;\n+\n \t  if (include_blanks)\n \t    do_spec_1 (\" \", 0, NULL_PTR);\n-\t  do_spec_1 (*p, 1, NULL_PTR);\n+\t  if (suffix_subst)\n+\t    {\n+\t      unsigned length = strlen (arg);\n+\n+\t      while (length-- && !IS_DIR_SEPARATOR (arg[length]))\n+\t\tif (arg[length] == '.')\n+\t\t  {\n+\t\t    ((char *)arg)[length] = 0;\n+\t\t    break;\n+\t\t  }\n+\t      do_spec_1 (arg, 1, NULL_PTR);\n+\t      if (!arg[length])\n+\t\t{\n+\t\t  ((char *)arg)[length] = '.';\n+\t\t  do_spec_1 (suffix_subst, 1, NULL_PTR);\n+\t\t}\n+\t    }\n+\t  else\n+\t    do_spec_1 (arg, 1, NULL_PTR);\n \t}\n     }\n "}]}