{"sha": "ff64a8c951995cb1214b4d2864a4bd553b60f249", "node_id": "C_kwDOANBUbNoAKGZmNjRhOGM5NTE5OTVjYjEyMTRiNGQyODY0YTRiZDU1M2I2MGYyNDk", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-07-01T17:53:34Z"}, "committer": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-07-01T21:33:13Z"}, "message": "c++: Minor cleanup in parser.cc\n\nThe code to determine whether a given token starts a module directive is\ncurrently repeated in 4 places in parser.cc. I am about to submit a patch\nthat needs to add it in a 5th place, so since the code is not completely\ntrivial (needing to check for 3 different token types), it seems worthwhile\nto factor this logic into its own function.\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (cp_token_is_module_directive): New function\n\trefactoring common code.\n\t(cp_parser_skip_to_closing_parenthesis_1): Use the new function.\n\t(cp_parser_skip_to_end_of_statement): Likewise.\n\t(cp_parser_skip_to_end_of_block_or_statement): Likewise.\n\t(cp_parser_declaration): Likewise.", "tree": {"sha": "6589f5a42a397e511767cbdc0b2c58eb08b7ea75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6589f5a42a397e511767cbdc0b2c58eb08b7ea75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff64a8c951995cb1214b4d2864a4bd553b60f249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff64a8c951995cb1214b4d2864a4bd553b60f249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff64a8c951995cb1214b4d2864a4bd553b60f249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff64a8c951995cb1214b4d2864a4bd553b60f249/comments", "author": null, "committer": null, "parents": [{"sha": "1f76941c09f6f62f4cbf7a9f531ec95268dd2c0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f76941c09f6f62f4cbf7a9f531ec95268dd2c0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f76941c09f6f62f4cbf7a9f531ec95268dd2c0a"}], "stats": {"total": 26, "additions": 14, "deletions": 12}, "files": [{"sha": "6b3763bca5369aa86d541f96f6c3c80add3b2af2", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff64a8c951995cb1214b4d2864a4bd553b60f249/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff64a8c951995cb1214b4d2864a4bd553b60f249/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=ff64a8c951995cb1214b4d2864a4bd553b60f249", "patch": "@@ -629,6 +629,16 @@ cp_lexer_alloc (void)\n   return lexer;\n }\n \n+/* Return TRUE if token is the start of a module declaration that will be\n+   terminated by a CPP_PRAGMA_EOL token.  */\n+static inline bool\n+cp_token_is_module_directive (cp_token *token)\n+{\n+  return token->keyword == RID__EXPORT\n+    || token->keyword == RID__MODULE\n+    || token->keyword == RID__IMPORT;\n+}\n+\n /* Create a new main C++ lexer, the lexer that gets tokens from the\n    preprocessor.  */\n \n@@ -3833,9 +3843,7 @@ cp_parser_skip_to_closing_parenthesis_1 (cp_parser *parser,\n \t  break;\n \n \tcase CPP_KEYWORD:\n-\t  if (token->keyword != RID__EXPORT\n-\t      && token->keyword != RID__MODULE\n-\t      && token->keyword != RID__IMPORT)\n+\t  if (!cp_token_is_module_directive (token))\n \t    break;\n \t  /* FALLTHROUGH  */\n \n@@ -3936,9 +3944,7 @@ cp_parser_skip_to_end_of_statement (cp_parser* parser)\n \t  break;\n \n \tcase CPP_KEYWORD:\n-\t  if (token->keyword != RID__EXPORT\n-\t      && token->keyword != RID__MODULE\n-\t      && token->keyword != RID__IMPORT)\n+\t  if (!cp_token_is_module_directive (token))\n \t    break;\n \t  /* FALLTHROUGH  */\n \n@@ -4025,9 +4031,7 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n \t  break;\n \n \tcase CPP_KEYWORD:\n-\t  if (token->keyword != RID__EXPORT\n-\t      && token->keyword != RID__MODULE\n-\t      && token->keyword != RID__IMPORT)\n+\t  if (!cp_token_is_module_directive (token))\n \t    break;\n \t  /* FALLTHROUGH  */\n \n@@ -14958,9 +14962,7 @@ cp_parser_declaration (cp_parser* parser, tree prefix_attrs)\n       else\n \tcp_parser_module_export (parser);\n     }\n-  else if (token1->keyword == RID__EXPORT\n-\t   || token1->keyword == RID__IMPORT\n-\t   || token1->keyword == RID__MODULE)\n+  else if (cp_token_is_module_directive (token1))\n     {\n       bool exporting = token1->keyword == RID__EXPORT;\n       cp_token *next = exporting ? token2 : token1;"}]}