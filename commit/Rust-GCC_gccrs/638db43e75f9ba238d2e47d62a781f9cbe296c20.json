{"sha": "638db43e75f9ba238d2e47d62a781f9cbe296c20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM4ZGI0M2U3NWY5YmEyMzhkMmU0N2Q2MmE3ODFmOWNiZTI5NmMyMA==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2003-05-09T16:05:46Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2003-05-09T16:05:46Z"}, "message": "* config/xtensa/xtensa.c: Formatting.\n\nFrom-SVN: r66636", "tree": {"sha": "92b788cb807b42ec28279becaffb350b051ab641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92b788cb807b42ec28279becaffb350b051ab641"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/638db43e75f9ba238d2e47d62a781f9cbe296c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638db43e75f9ba238d2e47d62a781f9cbe296c20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638db43e75f9ba238d2e47d62a781f9cbe296c20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638db43e75f9ba238d2e47d62a781f9cbe296c20/comments", "author": null, "committer": null, "parents": [{"sha": "5675294bcbd17311491358f8dc299deeeb11d2c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5675294bcbd17311491358f8dc299deeeb11d2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5675294bcbd17311491358f8dc299deeeb11d2c5"}], "stats": {"total": 124, "additions": 64, "deletions": 60}, "files": [{"sha": "a3ae7dd7f43861483733e2406ea770989fdc3244", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638db43e75f9ba238d2e47d62a781f9cbe296c20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638db43e75f9ba238d2e47d62a781f9cbe296c20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=638db43e75f9ba238d2e47d62a781f9cbe296c20", "patch": "@@ -1,3 +1,7 @@\n+2003-05-09  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa.c: Formatting.\n+\n 2003-05-09  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-dump.c (dequeue_and_dump): Use CONSTRUCTOR_ELTS,"}, {"sha": "271409922e3a7e76205f4304c7817a16db7bf9d2", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638db43e75f9ba238d2e47d62a781f9cbe296c20/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638db43e75f9ba238d2e47d62a781f9cbe296c20/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=638db43e75f9ba238d2e47d62a781f9cbe296c20", "patch": "@@ -52,7 +52,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Enumeration for all of the relational tests, so that we can build\n    arrays indexed by the test type, and not worry about the order\n-   of EQ, NE, etc. */\n+   of EQ, NE, etc.  */\n \n enum internal_test {\n     ITEST_EQ,\n@@ -96,7 +96,7 @@ struct machine_function GTY(())\n \n /* Vector, indexed by hard register number, which contains 1 for a\n    register that is allowable in a candidate for leaf function\n-   treatment. */\n+   treatment.  */\n \n const char xtensa_leaf_regs[FIRST_PSEUDO_REGISTER] =\n {\n@@ -376,7 +376,7 @@ xtensa_uimm8x4 (v)\n \n \n /* This is just like the standard true_regnum() function except that it\n-   works even when reg_renumber is not initialized. */\n+   works even when reg_renumber is not initialized.  */\n \n int\n xt_true_regnum (x)\n@@ -404,56 +404,56 @@ xt_true_regnum (x)\n \n int\n add_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+     rtx op;\n+     enum machine_mode mode;\n {\n-    if (GET_CODE (op) == CONST_INT)\n-\treturn (xtensa_simm8 (INTVAL (op)) ||\n-\t\txtensa_simm8x256 (INTVAL (op)));\n+  if (GET_CODE (op) == CONST_INT)\n+    return (xtensa_simm8 (INTVAL (op)) ||\n+\t    xtensa_simm8x256 (INTVAL (op)));\n \n-    return register_operand (op, mode);\n+  return register_operand (op, mode);\n }\n \n \n int\n arith_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+     rtx op;\n+     enum machine_mode mode;\n {\n-    if (GET_CODE (op) == CONST_INT)\n-\treturn xtensa_simm8 (INTVAL (op));\n+  if (GET_CODE (op) == CONST_INT)\n+    return xtensa_simm8 (INTVAL (op));\n \n-    return register_operand (op, mode);\n+  return register_operand (op, mode);\n }\n \n \n int\n nonimmed_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+     rtx op;\n+     enum machine_mode mode;\n {\n-    /* We cannot use the standard nonimmediate_operand() predicate because\n-       it includes constant pool memory operands. */\n+  /* We cannot use the standard nonimmediate_operand() predicate because\n+     it includes constant pool memory operands.  */\n \n-    if (memory_operand (op, mode))\n-\treturn !constantpool_address_p (XEXP (op, 0));\n+  if (memory_operand (op, mode))\n+    return !constantpool_address_p (XEXP (op, 0));\n \n-    return register_operand (op, mode);\n+  return register_operand (op, mode);\n }\n \n \n int\n mem_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+     rtx op;\n+     enum machine_mode mode;\n {\n-    /* We cannot use the standard memory_operand() predicate because\n-       it includes constant pool memory operands. */\n+  /* We cannot use the standard memory_operand() predicate because\n+     it includes constant pool memory operands.  */\n \n-    if (memory_operand (op, mode))\n-\treturn !constantpool_address_p (XEXP (op, 0));\n+  if (memory_operand (op, mode))\n+    return !constantpool_address_p (XEXP (op, 0));\n \n-    return FALSE;\n+  return FALSE;\n }\n \n \n@@ -469,7 +469,7 @@ xtensa_valid_move (mode, operands)\n     {\n       int dst_regnum = xt_true_regnum (operands[0]);\n \n-      /* The stack pointer can only be assigned with a MOVSP opcode. */\n+      /* The stack pointer can only be assigned with a MOVSP opcode.  */\n       if (dst_regnum == STACK_POINTER_REGNUM)\n \treturn (mode == SImode\n \t\t&& register_operand (operands[1], mode)\n@@ -610,7 +610,7 @@ move_operand (op, mode)\n     return TRUE;\n \n   /* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and\n-     result in 0/1. */\n+     result in 0/1.  */\n   if (GET_CODE (op) == CONSTANT_P_RTX)\n     return TRUE;\n \n@@ -894,7 +894,7 @@ xtensa_mem_offset (v, mode)\n \t where we emit an optimized block move operation if the block can be\n \t moved in < \"move_ratio\" pieces.  The worst case is when the block is\n \t aligned but has a size of (3 mod 4) (does this happen?) so that the\n-\t last piece requires a byte load/store. */\n+\t last piece requires a byte load/store.  */\n       return (xtensa_uimm8 (v) &&\n \t      xtensa_uimm8 (v + MOVE_MAX * LARGEST_MOVE_RATIO));\n \n@@ -943,7 +943,7 @@ map_test_to_internal_test (test_code)\n \n \n /* Generate the code to compare two integer values.  The return value is\n-   the comparison expression. */\n+   the comparison expression.  */\n \n static rtx\n gen_int_relational (test_code, cmp0, cmp1, p_invert)\n@@ -1042,7 +1042,7 @@ gen_int_relational (test_code, cmp0, cmp1, p_invert)\n \n \n /* Generate the code to compare two float values.  The return value is\n-   the comparison expression. */\n+   the comparison expression.  */\n \n static rtx\n gen_float_relational (test_code, cmp0, cmp1)\n@@ -1146,7 +1146,7 @@ gen_conditional_move (cmp)\n \t comparison supported in Xtensa.  We shouldn't have to\n \t transform <LE x const> comparisons, because neither\n \t xtensa_expand_conditional_branch() nor get_condition() will\n-\t produce them. */\n+\t produce them.  */\n \n       if ((code == GT) && (op1 == constm1_rtx))\n \t{\n@@ -1285,8 +1285,8 @@ xtensa_emit_move_sequence (operands, mode)\n     }\n \n   /* During reload we don't want to emit (subreg:X (mem:Y)) since that\n-     instruction won't be recognized after reload. So we remove the\n-     subreg and adjust mem accordingly. */\n+     instruction won't be recognized after reload, so we remove the\n+     subreg and adjust mem accordingly.  */\n   if (reload_in_progress)\n     {\n       operands[0] = fixup_subreg_mem (operands[0]);\n@@ -1598,7 +1598,7 @@ xtensa_init_machine_status ()\n void\n xtensa_setup_frame_addresses ()\n {\n-  /* Set flag to cause FRAME_POINTER_REQUIRED to be set. */\n+  /* Set flag to cause FRAME_POINTER_REQUIRED to be set.  */\n   cfun->machine->accesses_prev_frame = 1;\n \n   emit_library_call\n@@ -1607,18 +1607,18 @@ xtensa_setup_frame_addresses ()\n }\n \n \n-/* Emit the assembly for the end of a zero-cost loop. Normally we just emit\n-   a comment showing where the end of the loop is. However, if there is a\n+/* Emit the assembly for the end of a zero-cost loop.  Normally we just emit\n+   a comment showing where the end of the loop is.  However, if there is a\n    label or a branch at the end of the loop then we need to place a nop\n-   there. If the loop ends with a label we need the nop so that branches\n+   there.  If the loop ends with a label we need the nop so that branches\n    targetting that label will target the nop (and thus remain in the loop),\n    instead of targetting the instruction after the loop (and thus exiting\n-   the loop). If the loop ends with a branch, we need the nop in case the\n-   branch is targetting a location inside the loop. When the branch\n+   the loop).  If the loop ends with a branch, we need the nop in case the\n+   branch is targetting a location inside the loop.  When the branch\n    executes it will cause the loop count to be decremented even if it is\n    taken (because it is the last instruction in the loop), so we need to\n    nop after the branch to prevent the loop count from being decremented\n-   when the branch is taken. */\n+   when the branch is taken.  */\n \n void\n xtensa_emit_loop_end (insn, operands)\n@@ -1680,7 +1680,7 @@ xtensa_emit_call (callop, operands)\n }\n \n \n-/* Return the stabs register number to use for 'regno'. */\n+/* Return the stabs register number to use for 'regno'.  */\n \n int\n xtensa_dbx_register_number (regno)\n@@ -1702,7 +1702,7 @@ xtensa_dbx_register_number (regno)\n        numbered in libcc order beginning with 256.  We can't guarantee\n        that the FP registers will come first, so the following is just\n        a guess.  It seems like we should make a special case for FP\n-       registers and give them fixed numbers < 256. */\n+       registers and give them fixed numbers < 256.  */\n     first = 256;\n   }\n   else if (ACC_REG_P (regno))\n@@ -1712,7 +1712,7 @@ xtensa_dbx_register_number (regno)\n     }\n \n   /* When optimizing, we sometimes get asked about pseudo-registers\n-     that don't represent hard registers. Return 0 for these. */\n+     that don't represent hard registers.  Return 0 for these.  */\n   if (first == -1)\n     return 0;\n \n@@ -1794,7 +1794,7 @@ function_arg (cum, mode, type, incoming_p)\n      rtx that is not equal to hard_frame_pointer_rtx.  For BLKmode and\n      modes bigger than 2 words (because we only have patterns for\n      modes of 2 words or smaller), we can't control the expansion\n-     unless we explicitly list the individual registers in a PARALLEL. */\n+     unless we explicitly list the individual registers in a PARALLEL.  */\n \n   if ((mode == BLKmode || words > 2)\n       && regno < A7_REG\n@@ -1845,7 +1845,7 @@ override_options ()\n   xtensa_char_to_class['D'] = ((TARGET_DENSITY) ? GR_REGS: NO_REGS);\n   xtensa_char_to_class['d'] = ((TARGET_DENSITY) ? AR_REGS: NO_REGS);\n \n-  /* Set up array giving whether a given register can hold a given mode. */\n+  /* Set up array giving whether a given register can hold a given mode.  */\n   for (mode = VOIDmode;\n        mode != MAX_MACHINE_MODE;\n        mode = (enum machine_mode) ((int) mode + 1))\n@@ -2151,7 +2151,7 @@ xtensa_output_literal (file, x, mode, labelno)\n \n \n /* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer. */\n+   stack pointer.  */\n \n #define STACK_BYTES (STACK_BOUNDARY / BITS_PER_UNIT)\n #define XTENSA_STACK_ALIGN(LOC) (((LOC) + STACK_BYTES-1) & ~(STACK_BYTES-1))\n@@ -2178,7 +2178,7 @@ xtensa_frame_pointer_required ()\n   /* The code to expand builtin_frame_addr and builtin_return_addr\n      currently uses the hard_frame_pointer instead of frame_pointer.\n      This seems wrong but maybe it's necessary for other architectures.\n-     This function is derived from the i386 code. */\n+     This function is derived from the i386 code.  */\n \n   if (cfun->machine->accesses_prev_frame)\n     return 1;\n@@ -2212,7 +2212,7 @@ xtensa_reorg (first)\n      frame pointer.  This search will fail if the function does not\n      have an incoming argument in $a7, but in that case, we can just\n      set up the frame pointer at the very beginning of the\n-     function. */\n+     function.  */\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n@@ -2286,15 +2286,15 @@ xtensa_function_prologue (file, size)\n \n \n /* Do any necessary cleanup after a function to restore\n-   stack, frame, and regs. */\n+   stack, frame, and regs.  */\n \n void\n xtensa_function_epilogue (file, size)\n      FILE *file;\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   rtx insn = get_last_insn ();\n-  /* If the last insn was a BARRIER, we don't have to write anything. */\n+  /* If the last insn was a BARRIER, we don't have to write anything.  */\n   if (GET_CODE (insn) == NOTE)\n     insn = prev_nonnote_insn (insn);\n   if (insn == 0 || GET_CODE (insn) != BARRIER)\n@@ -2342,7 +2342,7 @@ xtensa_return_addr (count, frame)\n    registers.  E.G., if there are 6 argument registers, and each register is\n    4 bytes, then __va_stk is set to $sp - (6 * 4); then __va_reg[N*4]\n    references argument word N for 0 <= N < 6, and __va_stk[N*4] references\n-   argument word N for N >= 6. */\n+   argument word N for N >= 6.  */\n \n tree\n xtensa_build_va_list ()\n@@ -2375,7 +2375,7 @@ xtensa_build_va_list ()\n \n \n /* Save the incoming argument registers on the stack.  Returns the\n-   address of the saved registers. */\n+   address of the saved registers.  */\n \n rtx\n xtensa_builtin_saveregs ()\n@@ -2401,7 +2401,7 @@ xtensa_builtin_saveregs ()\n   /* Note: Don't use move_block_from_reg() here because the incoming\n      argument in a7 cannot be represented by hard_frame_pointer_rtx.\n      Instead, call gen_raw_REG() directly so that we get a distinct\n-     instance of (REG:SI 7). */\n+     instance of (REG:SI 7).  */\n   for (i = 0; i < gp_left; i++)\n     {\n       emit_move_insn (operand_subword (dest, i, 1, BLKmode),\n@@ -2413,7 +2413,7 @@ xtensa_builtin_saveregs ()\n \n \n /* Implement `va_start' for varargs and stdarg.  We look at the\n-   current function to fill in an initial va_list. */\n+   current function to fill in an initial va_list.  */\n \n void\n xtensa_va_start (valist, nextarg)\n@@ -2451,7 +2451,7 @@ xtensa_va_start (valist, nextarg)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  /* Set the __va_ndx member. */\n+  /* Set the __va_ndx member.  */\n   u = build_int_2 (arg_words * UNITS_PER_WORD, 0);\n   t = build (MODIFY_EXPR, integer_type_node, ndx, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n@@ -2715,7 +2715,7 @@ order_regs_for_local_alloc ()\n       for (i = 0; i < 16; i++)\n \treg_alloc_order[nxt++] = FP_REG_FIRST + i;\n \n-      /* GCC requires that we list *all* the registers.... */\n+      /* GCC requires that we list *all* the registers....  */\n       reg_alloc_order[nxt++] = 0;\t/* a0 = return address */\n       reg_alloc_order[nxt++] = 1;\t/* a1 = stack pointer */\n       reg_alloc_order[nxt++] = 16;\t/* pseudo frame pointer */\n@@ -2727,7 +2727,7 @@ order_regs_for_local_alloc ()\n \n \n /* A customized version of reg_overlap_mentioned_p that only looks for\n-   references to a7 (as opposed to hard_frame_pointer_rtx). */\n+   references to a7 (as opposed to hard_frame_pointer_rtx).  */\n \n int\n a7_overlap_mentioned_p (x)"}]}