{"sha": "28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhjZWVlMWI5MWY0OGI1YWIwOWNiZDIwZWE2YTlkZTZlYTEzN2FmOA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T17:45:43Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T23:26:47Z"}, "message": "Change gori_compute to inherit from gori_map instead of having a gori-map.\n\nMove the classes to the header file and inherit instead of instantiating.\n\n\t* gimple-range-gori.cc (range_def_chain): Move to gimple-range-gori.h.\n\t(gori_map): Move to gimple-range-gori.h.\n\t(gori_compute::gori_compute): Adjust.\n\t(gori_compute::~gori_compute): Delete.\n\t(gori_compute::compute_operand_range_switch): Adjust.\n\t(gori_compute::compute_operand_range): Adjust.\n\t(gori_compute::compute_logical_operands): Adjust.\n\t(gori_compute::has_edge_range_p ): Adjust.\n\t(gori_compute::set_range_invariant): Delete.\n\t(gori_compute::dump): Adjust.\n\t(gori_compute::outgoing_edge_range_p): Adjust.\n\t* gimple-range-gori.h (class range_def_chain): Relocate here.\n\t(class gori_map): Relocate here.\n\t(class gori_compute): Inherit from gori_map, and adjust.", "tree": {"sha": "8978c28de8782afb704e223874dd06b0ae5d18a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8978c28de8782afb704e223874dd06b0ae5d18a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8/comments", "author": null, "committer": null, "parents": [{"sha": "41ddc5b0a6b44a9df53a259636fa3b534ae41cbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ddc5b0a6b44a9df53a259636fa3b534ae41cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41ddc5b0a6b44a9df53a259636fa3b534ae41cbe"}], "stats": {"total": 124, "additions": 55, "deletions": 69}, "files": [{"sha": "074c025be370d107861b8041861ca2606133f554", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 11, "deletions": 65, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8", "patch": "@@ -91,21 +91,6 @@ is_gimple_logical_p (const gimple *gs)\n     engine implements operations for.  */\n \n \n-class range_def_chain\n-{\n-public:\n-  range_def_chain ();\n-  ~range_def_chain ();\n-  bool has_def_chain (tree name);\n-  bitmap get_def_chain (tree name);\n-  bool in_chain_p (tree name, tree def);\n-private:\n-  vec<bitmap> m_def_chain;\t// SSA_NAME : def chain components.\n-  void build_def_chain (tree name, bitmap result, basic_block bb);\n-  int m_logical_depth;\n-};\n-\n-\n // Construct a range_def_chain.\n \n range_def_chain::range_def_chain ()\n@@ -264,27 +249,6 @@ range_def_chain::get_def_chain (tree name)\n    entire def_chain of all SSA names used in the last statement of the\n    block which generate ranges.  */\n \n-class gori_map : public range_def_chain\n-{\n-public:\n-  gori_map ();\n-  ~gori_map ();\n-\n-  bool is_export_p (tree name, basic_block bb = NULL);\n-  bool def_chain_in_export_p (tree name, basic_block bb);\n-  bitmap exports (basic_block bb);\n-  void set_range_invariant (tree name);\n-\n-  void dump (FILE *f);\n-  void dump (FILE *f, basic_block bb);\n-private:\n-  bitmap_obstack m_bitmaps;\n-  vec<bitmap> m_outgoing;\t// BB: Outgoing ranges calculatable on edges\n-  bitmap m_maybe_variant;\t// Names which might have outgoing ranges.\n-  void maybe_add_gori (tree name, basic_block bb);\n-  void calculate_gori (basic_block bb);\n-};\n-\n \n // Initialize a gori-map structure.\n \n@@ -494,7 +458,6 @@ gori_compute::gori_compute ()\n   // Create a boolean_type true and false range.\n   m_bool_zero = int_range<2> (boolean_false_node, boolean_false_node);\n   m_bool_one = int_range<2> (boolean_true_node, boolean_true_node);\n-  m_gori_map = new gori_map;\n   unsigned x, lim = last_basic_block_for_fn (cfun);\n   // Calculate outgoing range info upfront.  This will fully populate the\n   // m_maybe_variant bitmap which will help eliminate processing of names\n@@ -503,17 +466,10 @@ gori_compute::gori_compute ()\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, x);\n       if (bb)\n-\tm_gori_map->exports (bb);\n+\texports (bb);\n     }\n }\n \n-// Destruct a gori_compute_object.\n-\n-gori_compute::~gori_compute ()\n-{\n-  delete m_gori_map;\n-}\n-\n // Provide a default of VARYING for all incoming SSA names.\n \n void\n@@ -597,7 +553,7 @@ gori_compute::compute_operand_range_switch (irange &r, gswitch *s,\n     }\n \n   // If op1 is in the defintion chain, pass lhs back.\n-  if (gimple_range_ssa_p (op1) && m_gori_map->in_chain_p (name, op1))\n+  if (gimple_range_ssa_p (op1) && in_chain_p (name, op1))\n     return compute_operand_range (r, SSA_NAME_DEF_STMT (op1), lhs, name);\n \n   return false;\n@@ -635,8 +591,8 @@ gori_compute::compute_operand_range (irange &r, gimple *stmt,\n \n   // NAME is not in this stmt, but one of the names in it ought to be\n   // derived from it.\n-  bool op1_in_chain = op1 && m_gori_map->in_chain_p (name, op1);\n-  bool op2_in_chain = op2 && m_gori_map->in_chain_p (name, op2);\n+  bool op1_in_chain = op1 && in_chain_p (name, op1);\n+  bool op2_in_chain = op2 && in_chain_p (name, op2);\n   if (op1_in_chain && op2_in_chain)\n     return compute_operand1_and_operand2_range (r, stmt, lhs, name);\n   if (op1_in_chain)\n@@ -881,10 +837,8 @@ gori_compute::compute_logical_operands (irange &r, gimple *stmt,\n   tree op2 = gimple_range_operand2 (stmt);\n   gcc_checking_assert (op1 != name && op2 != name);\n \n-  bool op1_in_chain = (gimple_range_ssa_p (op1)\n-\t\t       && m_gori_map->in_chain_p (name, op1));\n-  bool op2_in_chain = (gimple_range_ssa_p (op2)\n-\t\t       && m_gori_map->in_chain_p (name, op2));\n+  bool op1_in_chain = (gimple_range_ssa_p (op1) && in_chain_p (name, op1));\n+  bool op2_in_chain = (gimple_range_ssa_p (op2) && in_chain_p (name, op2));\n \n   // If neither operand is derived, then this stmt tells us nothing.\n   if (!op1_in_chain && !op2_in_chain)\n@@ -1014,26 +968,18 @@ gori_compute::has_edge_range_p (tree name, edge e)\n {\n   // If no edge is specified, check if NAME is an export on any edge.\n   if (!e)\n-    return m_gori_map->is_export_p (name);\n+    return is_export_p (name);\n \n-  return (m_gori_map->is_export_p (name, e->src)\n-\t  || m_gori_map->def_chain_in_export_p (name, e->src));\n-}\n-\n-// Clear the m_maybe_variant bit so ranges will not be tracked for NAME.\n-\n-void\n-gori_compute::set_range_invariant (tree name)\n-{\n-  m_gori_map->set_range_invariant (name);\n+  return (is_export_p (name, e->src)\n+\t  || def_chain_in_export_p (name, e->src));\n }\n \n // Dump what is known to GORI computes to listing file F.\n \n void\n gori_compute::dump (FILE *f)\n {\n-  m_gori_map->dump (f);\n+  gori_map::dump (f);\n }\n \n // Calculate a range on edge E and return it in R.  Try to evaluate a\n@@ -1052,7 +998,7 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name)\n     return false;\n \n   // If NAME can be calculated on the edge, use that.\n-  if (m_gori_map->is_export_p (name, e->src))\n+  if (is_export_p (name, e->src))\n     {\n       if (compute_operand_range (r, stmt, lhs, name))\n \t{"}, {"sha": "6208931a0d8b936e209b831f934825fc963a92ca", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=28ceee1b91f48b5ab09cbd20ea6a9de6ea137af8", "patch": "@@ -22,6 +22,49 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_RANGE_GORI_H\n #define GCC_GIMPLE_RANGE_GORI_H\n \n+// RANGE_DEF_CHAIN is used to determine which SSA names in a block can\n+// have range information calculated for them, and what the\n+// dependencies on each other are.\n+\n+class range_def_chain\n+{\n+public:\n+  range_def_chain ();\n+  ~range_def_chain ();\n+  bool has_def_chain (tree name);\n+  bitmap get_def_chain (tree name);\n+  bool in_chain_p (tree name, tree def);\n+private:\n+  vec<bitmap> m_def_chain;\t// SSA_NAME : def chain components.\n+  void build_def_chain (tree name, bitmap result, basic_block bb);\n+  int m_logical_depth;\n+};\n+\n+// GORI_MAP is used to accumulate what SSA names in a block can\n+// generate range information, and provides tools for the block ranger\n+// to enable it to efficiently calculate these ranges.\n+\n+class gori_map : public range_def_chain\n+{\n+public:\n+  gori_map ();\n+  ~gori_map ();\n+\n+  bool is_export_p (tree name, basic_block bb = NULL);\n+  bool def_chain_in_export_p (tree name, basic_block bb);\n+  bitmap exports (basic_block bb);\n+  void set_range_invariant (tree name);\n+\n+  void dump (FILE *f);\n+  void dump (FILE *f, basic_block bb);\n+private:\n+  bitmap_obstack m_bitmaps;\n+  vec<bitmap> m_outgoing;\t// BB: Outgoing ranges calculatable on edges\n+  bitmap m_maybe_variant;\t// Names which might have outgoing ranges.\n+  void maybe_add_gori (tree name, basic_block bb);\n+  void calculate_gori (basic_block bb);\n+};\n+\n \n // This class is used to determine which SSA_NAMES can have ranges\n // calculated for them on outgoing edges from basic blocks.  This represents\n@@ -65,14 +108,12 @@ along with GCC; see the file COPYING3.  If not see\n //\n // The remaining routines are internal use only.\n \n-class gori_compute \n+class gori_compute : public gori_map\n {\n public:\n   gori_compute ();\n-  ~gori_compute ();\n   bool outgoing_edge_range_p (irange &r, edge e, tree name);\n   bool has_edge_range_p (tree name, edge e = NULL);\n-  void set_range_invariant (tree name);\n   void dump (FILE *f);\n protected:\n   virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n@@ -107,7 +148,6 @@ class gori_compute\n   bool compute_operand1_and_operand2_range (irange &r, gimple *stmt,\n \t\t\t\t\t    const irange &lhs, tree name);\n \n-  class gori_map *m_gori_map;\n   gimple_outgoing_range outgoing;\t// Edge values for COND_EXPR & SWITCH_EXPR.\n };\n "}]}