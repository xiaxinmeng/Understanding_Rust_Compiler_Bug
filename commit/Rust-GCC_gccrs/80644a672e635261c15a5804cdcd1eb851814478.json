{"sha": "80644a672e635261c15a5804cdcd1eb851814478", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA2NDRhNjcyZTYzNTI2MWMxNWE1ODA0Y2RjZDFlYjg1MTgxNDQ3OA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-05-06T19:02:51Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-05-06T19:06:43Z"}, "message": "coroutines: Remove references to n4849 (NFC).\n\nThis just strips out references to the draft standard\nnumbered n4849.  The implementation is now intended to\nbe applicable to the expected final version.\n\ngcc/cp/ChangeLog:\n\n2020-05-05  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* coroutines.cc: Remove references to n4849 throughout.", "tree": {"sha": "bbcbc2af09113b953eff86626af2c57e4c793d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbcbc2af09113b953eff86626af2c57e4c793d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80644a672e635261c15a5804cdcd1eb851814478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80644a672e635261c15a5804cdcd1eb851814478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80644a672e635261c15a5804cdcd1eb851814478", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80644a672e635261c15a5804cdcd1eb851814478/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "319eafce3e54c8cb10e3fddce6823a6a558fca8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319eafce3e54c8cb10e3fddce6823a6a558fca8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/319eafce3e54c8cb10e3fddce6823a6a558fca8b"}], "stats": {"total": 32, "additions": 18, "deletions": 14}, "files": [{"sha": "218ed03c019372dbbb7cc88e4e1bc6703f85c59b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80644a672e635261c15a5804cdcd1eb851814478/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80644a672e635261c15a5804cdcd1eb851814478/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=80644a672e635261c15a5804cdcd1eb851814478", "patch": "@@ -1,3 +1,7 @@\n+2020-05-05  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* coroutines.cc: Remove references to n4849 throughout.\n+\n 2020-05-05  Jason Merrill  <jason@redhat.com>\n \n \tCWG 2235"}, {"sha": "fc319a58cc258b5379fb4652a33f1dfb71d171e2", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80644a672e635261c15a5804cdcd1eb851814478/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80644a672e635261c15a5804cdcd1eb851814478/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=80644a672e635261c15a5804cdcd1eb851814478", "patch": "@@ -2184,11 +2184,11 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   /* Expand co_returns in the saved function body  */\n   fnbody = expand_co_returns (&fnbody, promise_proxy, ap, fs_label);\n \n-  /* n4849 adds specific behaviour to treat exceptions thrown by the\n-     await_resume () of the initial suspend expression.  In order to\n-     implement this, we need to treat the initial_suspend expression\n-     as if it were part of the user-authored function body.  This\n-     only applies if exceptions are enabled.  */\n+  /* Specific behaviour to treat exceptions thrown by the await_resume ()\n+     of the initial suspend expression.  In order to implement this, we\n+     need to treat the initial_suspend expression as if it were part of the\n+     user-authored function body.  This only applies if exceptions are\n+     enabled.  */\n   if (flag_exceptions)\n     {\n       tree outer = fnbody;\n@@ -2290,7 +2290,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t}\n     }\n \n-  /* n4849 [dcl.fct.def.coroutine] / 12\n+  /* [dcl.fct.def.coroutine] / 12\n      The deallocation function\u2019s name is looked up in the scope of the promise\n      type.  If this lookup fails, the deallocation function\u2019s name is looked up\n      in the global scope.  If deallocation function lookup finds both a usual\n@@ -3845,7 +3845,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     = build_call_expr_internal_loc (fn_start, IFN_CO_FRAME, size_type_node, 2,\n \t\t\t\t    frame_size, coro_fp);\n \n-  /* n4849 [dcl.fct.def.coroutine] / 10 (part1)\n+  /* [dcl.fct.def.coroutine] / 10 (part1)\n     The unqualified-id get_return_object_on_allocation_failure is looked up\n     in the scope of the promise type by class member access lookup.  */\n \n@@ -3871,7 +3871,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     }\n \n   /* Allocate the frame, this has several possibilities:\n-     n4849 [dcl.fct.def.coroutine] / 9 (part 1)\n+     [dcl.fct.def.coroutine] / 9 (part 1)\n      The allocation function\u2019s name is looked up in the scope of the promise\n      type.  It's not a failure for it to be absent see part 4, below.  */\n   tree nwname = ovl_op_identifier (false, NEW_EXPR);\n@@ -3880,7 +3880,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree new_fn = NULL_TREE;\n   if (fns && BASELINK_P (fns))\n     {\n-      /* n4849 [dcl.fct.def.coroutine] / 9 (part 2)\n+      /* [dcl.fct.def.coroutine] / 9 (part 2)\n \tIf the lookup finds an allocation function in the scope of the promise\n \ttype, overload resolution is performed on a function call created by\n \tassembling an argument list.  The first argument is the amount of space\n@@ -3920,7 +3920,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n       if (!new_fn || new_fn == error_mark_node)\n \t{\n-\t  /* n4849 [dcl.fct.def.coroutine] / 9 (part 3)\n+\t  /* [dcl.fct.def.coroutine] / 9 (part 3)\n \t    If no viable function is found, overload resolution is performed\n \t    again on a function call created by passing just the amount of\n \t    space required as an argument of type std::size_t.  */\n@@ -3946,7 +3946,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     }\n   else\n     {\n-      /* n4849 [dcl.fct.def.coroutine] / 9 (part 4)\n+      /* [dcl.fct.def.coroutine] / 9 (part 4)\n \t If this lookup fails, the allocation function\u2019s name is looked up in\n \t the global scope.  */\n \n@@ -3957,7 +3957,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n       if (grooaf)\n \t{\n-\t  /* n4849 [dcl.fct.def.coroutine] / 10 (part 2)\n+\t  /* [dcl.fct.def.coroutine] / 10 (part 2)\n \t   If any declarations (of the get return on allocation fail) are\n \t   found, then the result of a call to an allocation function used\n \t   to obtain storage for the coroutine state is assumed to return\n@@ -3998,7 +3998,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   if (grooaf)\n     {\n-      /* n4849 [dcl.fct.def.coroutine] / 10 (part 3)\n+      /* [dcl.fct.def.coroutine] / 10 (part 3)\n \t If the allocation function returns nullptr,the coroutine returns\n \t control to the caller of the coroutine and the return value is\n \t obtained by a call to T::get_return_object_on_allocation_failure(),\n@@ -4062,7 +4062,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n-  /* n4849 [dcl.fct.def.coroutine] /13\n+  /* [dcl.fct.def.coroutine] /13\n      When a coroutine is invoked, a copy is created for each coroutine\n      parameter.  Each such copy is an object with automatic storage duration\n      that is direct-initialized from an lvalue referring to the corresponding"}]}