{"sha": "b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzMmY3NzBmNzBkNjBiMWQ2Yzg5ZDZlZjFmZThkYzg4YmRlY2RhMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-10-20T10:04:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-10-20T10:04:00Z"}, "message": "basic-block.h (find_sub_basic_blocks): Use sbitmap parameter.\n\n\t* basic-block.h (find_sub_basic_blocks): Use sbitmap parameter.\n\t* cfgbuild.c (find_bb_boundaries, compute_outgoing_frequencies):\n\tBreak out from ...\n\t(find_sub_basic_blocks): ... here;\n\t(find_many_sub_basic_blocks): New.\n\t* recog.c (split_all_insns): Update find_sub_basic_blocks call.\n\n\t* i386.h (ASM_PREFERRED_EH_DATA_FORMAT): Define sdata4.\n\n\t* i386.c (ix86_va_arg): Kill indirect_p handling; fix aliasing issues.:\n\n\t* i386.c (split_di, split_ti): Revamp to use simplify_subreg.\n\n\t* timevar.def (TV_LIFE, TV_LIFE_UPDATE, TV_MODE_SWITCH): new.\n\t* flow.c (update_life_info): Measure time.\n\t* c-decl.c: Include timevar.h\n\t(c_expand_body): Measure time.\n\t* toplev.c (rest_of_compilation): Measure time of mode switching\n\tseparately.\n\t* Makefile.in (c-decl.o, cfgcleanup.o): Add dependancy.\n\n\t* toplev.c (flag_asynchronous_unwind_tables): New global variable.\n\t(lang_independent_options): Add asynchronous-unwind-tables\n\t(toplev_main): flag_asynchronous_unwind_tables implies\n\tflag_unwind_tables.\n\t* flags.h (flag_asynchronous_unwind_tables): Declare.\n\t* dwarf2out.c (dwarf2out_stack_adjust): Take into account\n\tflag_asynchronous_unwind_tables.\n\t(output_call_frame_info): Likewise.\n\t* invoke.texi (-fasynchronous-unwind-tables): Document.\n\t* i386.c (optimization_options): Enable\n\tflag_asynchronous_unwind_tables.\n\n\t* i386.c (ix86_expand_setcc):  Always expect target to be QImode.\n\t* i386.md (s* expanders): Destination is QImode.\n\n\t* toplev.c (rest_of_compilation): Do not call clear_log_links.\n\t* rtl.h (clear_log_links): Kill.\n\t* flow.c (clear_log_links): Make static; accept blocks parameter;\n\tdo no clear life info.\n\t(update_life_info): Call clear_log_links.\n\n\t* cfganal.c (forwarder_block_p): Avoid active_insn_p calls.\n\nFrom-SVN: r46374", "tree": {"sha": "8b850e82487dad7507a2357d498b653cbeb1d71e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b850e82487dad7507a2357d498b653cbeb1d71e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/comments", "author": null, "committer": null, "parents": [{"sha": "870628131ce6ff529817509e256c7ee035d37bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870628131ce6ff529817509e256c7ee035d37bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870628131ce6ff529817509e256c7ee035d37bfd"}], "stats": {"total": 538, "additions": 322, "deletions": 216}, "files": [{"sha": "8b6793b214687e26cf6df341e49869d8b9632159", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -1,3 +1,49 @@\n+Sat Oct 20 12:01:07 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (find_sub_basic_blocks): Use sbitmap parameter.\n+\t* cfgbuild.c (find_bb_boundaries, compute_outgoing_frequencies):\n+\tBreak out from ...\n+\t(find_sub_basic_blocks): ... here;\n+\t(find_many_sub_basic_blocks): New.\n+\t* recog.c (split_all_insns): Update find_sub_basic_blocks call.\n+\n+\t* i386.h (ASM_PREFERRED_EH_DATA_FORMAT): Define sdata4.\n+\n+\t* i386.c (ix86_va_arg): Kill indirect_p handling; fix aliasing issues.:\n+\n+\t* i386.c (split_di, split_ti): Revamp to use simplify_subreg.\n+\n+\t* timevar.def (TV_LIFE, TV_LIFE_UPDATE, TV_MODE_SWITCH): new.\n+\t* flow.c (update_life_info): Measure time.\n+\t* c-decl.c: Include timevar.h\n+\t(c_expand_body): Measure time.\n+\t* toplev.c (rest_of_compilation): Measure time of mode switching\n+\tseparately.\n+\t* Makefile.in (c-decl.o, cfgcleanup.o): Add dependancy.\n+\n+\t* toplev.c (flag_asynchronous_unwind_tables): New global variable.\n+\t(lang_independent_options): Add asynchronous-unwind-tables\n+\t(toplev_main): flag_asynchronous_unwind_tables implies\n+\tflag_unwind_tables.\n+\t* flags.h (flag_asynchronous_unwind_tables): Declare.\n+\t* dwarf2out.c (dwarf2out_stack_adjust): Take into account\n+\tflag_asynchronous_unwind_tables.\n+\t(output_call_frame_info): Likewise.\n+\t* invoke.texi (-fasynchronous-unwind-tables): Document.\n+\t* i386.c (optimization_options): Enable\n+\tflag_asynchronous_unwind_tables.\n+\n+\t* i386.c (ix86_expand_setcc):  Always expect target to be QImode.\n+\t* i386.md (s* expanders): Destination is QImode.\n+\n+\t* toplev.c (rest_of_compilation): Do not call clear_log_links.\n+\t* rtl.h (clear_log_links): Kill.\n+\t* flow.c (clear_log_links): Make static; accept blocks parameter;\n+\tdo no clear life info.\n+\t(update_life_info): Call clear_log_links.\n+\n+\t* cfganal.c (forwarder_block_p): Avoid active_insn_p calls.\n+\n 2001-10-20  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cpplex.c (handle_newline, skip_escaped_newlines,"}, {"sha": "00577e1b7f75f7bf755eed0133b9c1b079c22de7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -1168,7 +1168,7 @@ $(srcdir)/c-parse.y: c-parse.in\n \n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) $(C_TREE_H) \\\n     $(GGC_H) $(TARGET_H) c-lex.h flags.h function.h output.h $(EXPR_H) \\\n-    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h\n+    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H)\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n@@ -1512,7 +1512,7 @@ cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) \n-cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TIMEVAR_H)\\\n    $(BASIC_BLOCK_H) hard-reg-set.h output.h flags.h $(RECOG_H) toplev.h $(GGC_H)\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h"}, {"sha": "1a0cab66f705e33a61a18486cf7bc2995c83e6a1", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -640,6 +640,7 @@ extern bool forwarder_block_p\t\tPARAMS ((basic_block));\n extern bool purge_all_dead_edges\tPARAMS ((void));\n extern bool purge_dead_edges\t\tPARAMS ((basic_block));\n extern void find_sub_basic_blocks\tPARAMS ((basic_block));\n+extern void find_many_sub_basic_blocks\tPARAMS ((sbitmap));\n extern bool can_fallthru\t\tPARAMS ((basic_block, basic_block));\n extern void flow_nodes_print\t\tPARAMS ((const char *, const sbitmap,\n \t\t\t\t\t\t FILE *));"}, {"sha": "45b923aae637ba9286f94668a0dfee62e22108c4", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -44,6 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cpplib.h\"\n #include \"target.h\"\n #include \"debug.h\"\n+#include \"timevar.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -6802,6 +6803,8 @@ c_expand_body (fndecl, nested_p)\n   if (flag_syntax_only)\n     return;\n \n+  timevar_push (TV_EXPAND);\n+\n   if (flag_inline_trees)\n     {\n       /* First, cache whether the current function is inlinable.  Some\n@@ -6952,6 +6955,7 @@ c_expand_body (fndecl, nested_p)\n   if (nested_p)\n     /* Return to the enclosing function.  */\n     pop_function_context ();\n+  timevar_pop (TV_EXPAND);\n }\n \f\n /* Check the declarations given in a for-loop for satisfying the C99"}, {"sha": "8615a14755ee0cc9abbbadde87eac0033e9dfeb0", "filename": "gcc/cfganal.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -67,12 +67,13 @@ forwarder_block_p (bb)\n \n   while (insn != bb->end)\n     {\n-      if (active_insn_p (insn))\n+      if (INSN_P (insn) && active_insn_p (insn))\n \treturn false;\n       insn = NEXT_INSN (insn);\n     }\n-  return (!active_insn_p (insn)\n-\t  || (GET_CODE (insn) == JUMP_INSN && onlyjump_p (insn)));\n+  return (!INSN_P (insn)\n+\t  || (GET_CODE (insn) == JUMP_INSN && simplejump_p (insn))\n+\t  || !active_insn_p (insn));\n }\n \n /* Return nonzero if we can reach target from src by falling trought.  */"}, {"sha": "ef86939d4ad5f399620fbfe99d4c39194489c2b7", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 135, "deletions": 35, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -55,6 +55,8 @@ static void make_edges\t\t\tPARAMS ((rtx, int, int, int));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t rtx, int));\n static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n+static void find_bb_boundaries\t\tPARAMS ((basic_block));\n+static void compute_outgoing_frequencies PARAMS ((basic_block));\n \n /* Count the basic blocks of the function.  */\n \n@@ -246,7 +248,8 @@ make_edges (label_value_list, min, max, update_p)\n     }\n \n   /* By nature of the way these get numbered, block 0 is always the entry.  */\n-  cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n+  if (min == 0)\n+    cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n \n   for (i = min; i <= max; ++i)\n     {\n@@ -663,18 +666,27 @@ find_basic_blocks (f, nregs, file)\n   timevar_pop (TV_CFG);\n }\n \f\n-/* Assume that someone emitted code with control flow instructions to the\n-   basic block.  Update the data structure.  */\n-void\n-find_sub_basic_blocks (bb)\n+/* State of basic block as seen by find_sub_basic_blocks.  */\n+enum state\n+  {\n+    BLOCK_NEW = 0,\n+    BLOCK_ORIGINAL,\n+    BLOCK_TO_SPLIT\n+  };\n+#define STATE(bb) (enum state)(size_t)(bb)->aux\n+#define SET_STATE(bb, state) (bb)->aux = (void *)(state)\n+\n+/* Scan basic block BB for possible BB boundaries inside the block\n+   and create new basic blocks in the progress.  */\n+\n+static void\n+find_bb_boundaries (bb)\n      basic_block bb;\n {\n   rtx insn = bb->head;\n   rtx end = bb->end;\n   rtx flow_transfer_insn = NULL_RTX;\n   edge fallthru = NULL;\n-  basic_block first_bb = bb;\n-  int i;\n \n   if (insn == bb->end)\n     return;\n@@ -694,7 +706,7 @@ find_sub_basic_blocks (bb)\n \t    abort ();\n \t  break;\n \n-\t/* On code label, split current basic block.  */\n+\t  /* On code label, split current basic block.  */\n \tcase CODE_LABEL:\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n \t  if (flow_transfer_insn)\n@@ -725,7 +737,7 @@ find_sub_basic_blocks (bb)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t\tabort();\n+\t\tabort ();\n \t      flow_transfer_insn = insn;\n \t    }\n \t  else if (code == CALL_INSN)\n@@ -764,18 +776,87 @@ find_sub_basic_blocks (bb)\n      followed by cleanup at fallthru edge, so the outgoing edges may\n      be dead.  */\n   purge_dead_edges (bb);\n+}\n+\n+/*  Assume that frequency of basic block B is known.  Compute frequencies\n+    and probabilities of outgoing edges.  */\n+\n+static void\n+compute_outgoing_frequencies (b)\n+     basic_block b;\n+{\n+  edge e, f;\n+  if (b->succ && b->succ->succ_next && !b->succ->succ_next->succ_next)\n+    {\n+      rtx note = find_reg_note (b->end, REG_BR_PROB, NULL);\n+      int probability;\n+\n+      if (!note)\n+\treturn;\n+      probability = INTVAL (XEXP (find_reg_note (b->end,\n+\t\t\t\t\t\t REG_BR_PROB, NULL), 0));\n+      e = BRANCH_EDGE (b);\n+      e->probability = probability;\n+      e->count = ((b->count * probability + REG_BR_PROB_BASE / 2)\n+\t\t  / REG_BR_PROB_BASE);\n+      f = FALLTHRU_EDGE (b);\n+      f->probability = REG_BR_PROB_BASE - probability;\n+      f->count = b->count - e->count;\n+    }\n+  if (b->succ && !b->succ->succ_next)\n+    {\n+      e = b->succ;\n+      e->probability = REG_BR_PROB_BASE;\n+      e->count = b->count;\n+    }\n+}\n+\n+/* Assume that someone emitted code with control flow instructions to the\n+   basic block.  Update the data structure.  */\n+\n+void\n+find_many_sub_basic_blocks (blocks)\n+     sbitmap blocks;\n+{\n+  int i;\n+  int min, max;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      SET_STATE (BASIC_BLOCK (i),\n+\t\t TEST_BIT (blocks, i)\n+\t\t ? BLOCK_TO_SPLIT : BLOCK_ORIGINAL);\n+    }\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      if (STATE (bb) == BLOCK_TO_SPLIT)\n+\tfind_bb_boundaries (bb);\n+    }\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (STATE (BASIC_BLOCK (i)) != BLOCK_ORIGINAL)\n+      break;\n+  min = max = i;\n+  for (; i < n_basic_blocks; i++)\n+    if (STATE (BASIC_BLOCK (i)) != BLOCK_ORIGINAL)\n+      max = i;\n \n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n-  make_edges (NULL, first_bb->index, bb->index, 1);\n+  make_edges (NULL, min, max, 1);\n \n   /* Update branch probabilities.  Expect only (un)conditional jumps\n      to be created with only the forward edges.  */\n-  for (i = first_bb->index; i <= bb->index; i++)\n+  for (i = min; i <= max; i++)\n     {\n-      edge e,f;\n+      edge e;\n       basic_block b = BASIC_BLOCK (i);\n-      if (b != first_bb)\n+\n+      if (STATE (b) == BLOCK_ORIGINAL)\n+\tcontinue;\n+      if (STATE (b) == BLOCK_NEW)\n \t{\n \t  b->count = 0;\n \t  b->frequency = 0;\n@@ -785,29 +866,48 @@ find_sub_basic_blocks (bb)\n \t      b->frequency += EDGE_FREQUENCY (e);\n \t    }\n \t}\n-      if (b->succ && b->succ->succ_next && !b->succ->succ_next->succ_next)\n-\t{\n-\t  rtx note = find_reg_note (b->end, REG_BR_PROB, NULL);\n-\t  int probability;\n-\n-\t  if (!note)\n-\t    continue;\n-\t  probability = INTVAL (XEXP (find_reg_note (b->end,\n-\t\t\t\t\t\t     REG_BR_PROB,\n-\t\t\t\t\t\t     NULL), 0));\n-\t  e = BRANCH_EDGE (b);\n-\t  e->probability = probability;\n-\t  e->count = ((b->count * probability + REG_BR_PROB_BASE / 2)\n-\t\t      / REG_BR_PROB_BASE);\n-\t  f = FALLTHRU_EDGE (b);\n-\t  f->probability = REG_BR_PROB_BASE - probability;\n-\t  f->count = b->count - e->count;\n-\t}\n-      if (b->succ && !b->succ->succ_next)\n+      compute_outgoing_frequencies (b);\n+    }\n+  for (i = 0; i < n_basic_blocks; i++)\n+    SET_STATE (BASIC_BLOCK (i), 0);\n+}\n+\n+/* Like above but for single basic block only.  */\n+\n+void\n+find_sub_basic_blocks (bb)\n+    basic_block bb;\n+{\n+  int i;\n+  int min, max;\n+  basic_block next = (bb->index == n_basic_blocks - 1\n+\t\t      ? NULL : BASIC_BLOCK (bb->index + 1));\n+\n+  min = bb->index;\n+  find_bb_boundaries (bb);\n+  max = (next ? next->index : n_basic_blocks) - 1;\n+\n+  /* Now re-scan and wire in all edges.  This expect simple (conditional)\n+     jumps at the end of each new basic blocks.  */\n+  make_edges (NULL, min, max, 1);\n+\n+  /* Update branch probabilities.  Expect only (un)conditional jumps\n+     to be created with only the forward edges.  */\n+  for (i = min; i <= max; i++)\n+    {\n+      edge e;\n+      basic_block b = BASIC_BLOCK (i);\n+\n+      if (i != min)\n \t{\n-\t  e = b->succ;\n-\t  e->probability = REG_BR_PROB_BASE;\n-\t  e->count = b->count;\n+\t  b->count = 0;\n+\t  b->frequency = 0;\n+\t  for (e = b->pred; e; e=e->pred_next)\n+\t    {\n+\t      b->count += e->count;\n+\t      b->frequency += EDGE_FREQUENCY (e);\n+\t    }\n \t}\n+      compute_outgoing_frequencies (b);\n     }\n }"}, {"sha": "b9f1470d3e1686d2c751a078a3333f5368dbb3a9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 27, "deletions": 106, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -1061,7 +1061,10 @@ optimization_options (level, size)\n   if (TARGET_64BIT && optimize >= 1)\n     flag_omit_frame_pointer = 1;\n   if (TARGET_64BIT)\n-    flag_pcc_struct_return = 0;\n+    {\n+      flag_pcc_struct_return = 0;\n+      flag_asynchronous_unwind_tables = 1;\n+    }\n }\n \f\n /* Table of valid machine attributes.  */\n@@ -2331,7 +2334,7 @@ ix86_va_arg (valist, type)\n   static int intreg[6] = { 0, 1, 2, 3, 4, 5 };\n   tree f_gpr, f_fpr, f_ovf, f_sav;\n   tree gpr, fpr, ovf, sav, t;\n-  int indirect_p = 0, size, rsize;\n+  int size, rsize;\n   rtx lab_false, lab_over = NULL_RTX;\n   rtx addr_rtx, r;\n   rtx container;\n@@ -2459,9 +2462,11 @@ ix86_va_arg (valist, type)\n \t  int i;\n \t  rtx mem;\n \n-\t  mem = assign_temp (type, 0, 1, 0);\n+\t  /* Never use the memory itself, as it has the alias set.  */\n+\t  addr_rtx = XEXP (assign_temp (type, 0, 1, 0), 0);\n+\t  mem = gen_rtx_MEM (BLKmode, addr_rtx);\n \t  set_mem_alias_set (mem, get_varargs_alias_set ());\n-\t  addr_rtx = XEXP (mem, 0);\n+\n \t  for (i = 0; i < XVECLEN (container, 0); i++)\n \t    {\n \t      rtx slot = XVECEXP (container, 0, i);\n@@ -2487,7 +2492,6 @@ ix86_va_arg (valist, type)\n \t      src_mem = adjust_address (src_mem, mode, src_offset);\n \t      dest_mem = adjust_address (mem, mode, INTVAL (XEXP (slot, 1)));\n \t      PUT_MODE (dest_mem, mode);\n-\t      /* ??? Break out TImode moves from integer registers?  */\n \t      emit_move_insn (dest_mem, src_mem);\n \t    }\n \t}\n@@ -2543,14 +2547,6 @@ ix86_va_arg (valist, type)\n   if (container)\n     emit_label (lab_over);\n \n-  if (indirect_p)\n-    {\n-      abort ();\n-      r = gen_rtx_MEM (Pmode, addr_rtx);\n-      set_mem_alias_set (r, get_varargs_alias_set ());\n-      emit_move_insn (addr_rtx, r);\n-    }\n-\n   return addr_rtx;\n }\n \f\n@@ -5931,27 +5927,19 @@ split_di (operands, num, lo_half, hi_half)\n   while (num--)\n     {\n       rtx op = operands[num];\n-      if (CONSTANT_P (op))\n-\tsplit_double (op, &lo_half[num], &hi_half[num]);\n-      else if (! reload_completed)\n-\t{\n-\t  lo_half[num] = gen_lowpart (SImode, op);\n-\t  hi_half[num] = gen_highpart (SImode, op);\n-\t}\n-      else if (GET_CODE (op) == REG)\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    abort();\n-\t  lo_half[num] = gen_rtx_REG (SImode, REGNO (op));\n-\t  hi_half[num] = gen_rtx_REG (SImode, REGNO (op) + 1);\n-\t}\n-      else if (offsettable_memref_p (op))\n+\n+      /* simplify_subreg refuse to split volatile memory addresses,\n+         but we still have to handle it.  */\n+      if (GET_CODE (op) == MEM)\n \t{\n \t  lo_half[num] = adjust_address (op, SImode, 0);\n \t  hi_half[num] = adjust_address (op, SImode, 4);\n \t}\n       else\n-\tabort ();\n+\t{\n+\t  lo_half[num] = simplify_gen_subreg (SImode, op, DImode, 0);\n+\t  hi_half[num] = simplify_gen_subreg (SImode, op, DImode, 4);\n+\t}\n     }\n }\n /* Split one or more TImode RTL references into pairs of SImode\n@@ -5969,40 +5957,19 @@ split_ti (operands, num, lo_half, hi_half)\n   while (num--)\n     {\n       rtx op = operands[num];\n-      if (CONSTANT_P (op))\n-\t{\n-\t  if (GET_CODE (op) == CONST_INT)\n-\t    {\n-\t      lo_half[num] = GEN_INT (trunc_int_for_mode (INTVAL (op), SImode));\n-\t      hi_half[num] = (1 << (HOST_BITS_PER_WIDE_INT -1)) != 0 ? constm1_rtx : const0_rtx;\n-\t    }\n-\t  else if (GET_CODE (op) == CONST_DOUBLE && HOST_BITS_PER_WIDE_INT == 64)\n-\t    {\n-\t      lo_half[num] = GEN_INT (trunc_int_for_mode (CONST_DOUBLE_LOW (op), SImode));\n-\t      hi_half[num] = GEN_INT (trunc_int_for_mode (CONST_DOUBLE_HIGH (op), SImode));\n-\t    }\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (! reload_completed)\n-\t{\n-\t  lo_half[num] = gen_lowpart (DImode, op);\n-\t  hi_half[num] = gen_highpart (DImode, op);\n-\t}\n-      else if (GET_CODE (op) == REG)\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    abort();\n-\t  lo_half[num] = gen_rtx_REG (DImode, REGNO (op));\n-\t  hi_half[num] = gen_rtx_REG (DImode, REGNO (op) + 1);\n-\t}\n-      else if (offsettable_memref_p (op))\n+\n+      /* simplify_subreg refuse to split volatile memory addresses, but we\n+         still have to handle it.  */\n+      if (GET_CODE (op) == MEM)\n \t{\n \t  lo_half[num] = adjust_address (op, DImode, 0);\n \t  hi_half[num] = adjust_address (op, DImode, 8);\n \t}\n       else\n-\tabort ();\n+\t{\n+\t  lo_half[num] = simplify_gen_subreg (DImode, op, TImode, 0);\n+\t  hi_half[num] = simplify_gen_subreg (DImode, op, TImode, 8);\n+\t}\n     }\n }\n \f\n@@ -7860,54 +7827,19 @@ ix86_expand_setcc (code, dest)\n {\n   rtx ret, tmp, tmpreg;\n   rtx second_test, bypass_test;\n-  int type;\n \n   if (GET_MODE (ix86_compare_op0) == DImode\n       && !TARGET_64BIT)\n     return 0; /* FAIL */\n \n-  /* Three modes of generation:\n-     0 -- destination does not overlap compare sources:\n-          clear dest first, emit strict_low_part setcc.\n-     1 -- destination does overlap compare sources:\n-          emit subreg setcc, zero extend.\n-     2 -- destination is in QImode:\n-          emit setcc only.\n-\n-     We don't use mode 0 early in compilation because it confuses CSE.\n-     There are peepholes to turn mode 1 into mode 0 if things work out\n-     nicely after reload.  */\n-\n-  type = cse_not_expected ? 0 : 1;\n-\n-  if (GET_MODE (dest) == QImode)\n-    type = 2;\n-  else if (reg_overlap_mentioned_p (dest, ix86_compare_op0)\n-\t   || reg_overlap_mentioned_p (dest, ix86_compare_op1))\n-    type = 1;\n-\n-  if (type == 0)\n-    emit_move_insn (dest, const0_rtx);\n+  if (GET_MODE (dest) != QImode)\n+    abort ();\n \n   ret = ix86_expand_compare (code, &second_test, &bypass_test);\n   PUT_MODE (ret, QImode);\n \n   tmp = dest;\n   tmpreg = dest;\n-  if (type == 0)\n-    {\n-      tmp = gen_lowpart (QImode, dest);\n-      tmpreg = tmp;\n-      tmp = gen_rtx_STRICT_LOW_PART (VOIDmode, tmp);\n-    }\n-  else if (type == 1)\n-    {\n-      if (!cse_not_expected)\n-\ttmp = gen_reg_rtx (QImode);\n-      else\n-        tmp = gen_lowpart (QImode, dest);\n-      tmpreg = tmp;\n-    }\n \n   emit_insn (gen_rtx_SET (VOIDmode, tmp, ret));\n   if (bypass_test || second_test)\n@@ -7932,17 +7864,6 @@ ix86_expand_setcc (code, dest)\n \temit_insn (gen_iorqi3 (tmp, tmpreg, tmp2));\n     }\n \n-  if (type == 1)\n-    {\n-      rtx clob;\n-\n-      tmp = gen_rtx_ZERO_EXTEND (GET_MODE (dest), tmp);\n-      tmp = gen_rtx_SET (VOIDmode, dest, tmp);\n-      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n-      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, clob));\n-      emit_insn (tmp);\n-    }\n-\n   return 1; /* DONE */\n }\n "}, {"sha": "da093be4e4906724710f59fe4250c2859dbd1763", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -2885,7 +2885,8 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n    Whether or not a particular assembler allows us to enter such, I\n    guess we'll have to see.  */\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)       \t\t\\\n-  (flag_pic ? (GLOBAL ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel\t\t\\\n+  (flag_pic\t\t\t\t\t\t\t\t\\\n+    ? (GLOBAL ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4\\\n    : DW_EH_PE_absptr)\n \n /* This is how to output the definition of a user-level label named NAME,"}, {"sha": "efede44cda1af5d5f05ea7537202b7f66e8c89d3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -12423,110 +12423,110 @@\n ;; way, which can later delete the movzx if only QImode is needed.\n \n (define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (eq:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (eq:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (EQ, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ne:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (ne:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (NE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (gt:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (gt:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (GT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (gtu:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (gtu:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (GTU, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (lt:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (lt:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (LT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ltu:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (ltu:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (LTU, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ge:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (ge:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (GE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (geu:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (geu:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (GEU, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (le:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (le:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (LE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (leu:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (leu:QI (reg:CC 17) (const_int 0)))]\n   \"\"\n   \"if (ix86_expand_setcc (LEU, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sunordered\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (unordered:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (unordered:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNORDERED, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sordered\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ordered:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (ordered:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387\"\n   \"if (ix86_expand_setcc (ORDERED, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"suneq\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (uneq:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (uneq:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNEQ, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sunge\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (unge:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (unge:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNGE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sungt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ungt:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (ungt:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNGT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sunle\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (unle:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (unle:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNLE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sunlt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (unlt:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (unlt:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNLT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sltgt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ltgt:SI (reg:CC 17) (const_int 0)))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (ltgt:QI (reg:CC 17) (const_int 0)))]\n   \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (LTGT, operands[0])) DONE; else FAIL;\")\n "}, {"sha": "d8887d84eca05f74c0b8f3321a3f5b15c267c3c4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -602,7 +602,7 @@ in the following sections.\n @gccoptlist{\n -fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol\n -ffixed-@var{reg} -fexceptions @gol\n--fnon-call-exceptions  -funwind-tables @gol\n+-fnon-call-exceptions  -funwind-tables -fasynchronous-unwind-tables @gol\n -finhibit-size-directive  -finstrument-functions @gol\n -fcheck-memory-usage  -fprefix-function-name @gol\n -fno-common  -fno-ident  -fno-gnu-linker @gol\n@@ -9658,6 +9658,12 @@ static data, but will not affect the generated code in any other way.\n You will normally not enable this option; instead, a language processor\n that needs this handling would enable it on your behalf.\n \n+@item -fasynchronous-unwind-tables\n+@opindex funwind-tables\n+Generate unwind table in dwarf2 format, if supported by target machine.  The\n+table is exact at each instruction boundary, so it can be used for stack\n+unwinding from asynchronous events (such as debugger or garbage collector).\n+\n @item -fpcc-struct-return\n @opindex fpcc-struct-return\n Return ``short'' @code{struct} and @code{union} values in memory like"}, {"sha": "486c7a20b27c1fe992939f05047c5b8ff108a82f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -943,7 +943,8 @@ dwarf2out_stack_adjust (insn)\n   long offset;\n   const char *label;\n \n-  if (! flag_non_call_exceptions && GET_CODE (insn) == CALL_INSN)\n+  if (!flag_asynchronous_unwind_tables\n+      && GET_CODE (insn) == CALL_INSN)\n     {\n       /* Extract the size of the args from the CALL rtx itself.  */\n \n@@ -960,7 +961,7 @@ dwarf2out_stack_adjust (insn)\n \n   /* If only calls can throw, and we have a frame pointer,\n      save up adjustments until we see the CALL_INSN.  */\n-  else if (! flag_non_call_exceptions\n+  else if (!flag_asynchronous_unwind_tables\n \t   && cfa.reg != STACK_POINTER_REGNUM)\n     return;\n \n@@ -1721,7 +1722,7 @@ output_call_frame_info (for_eh)\n      emit any EH unwind information.  */\n   if (for_eh)\n     {\n-      int any_eh_needed = 0;\n+      int any_eh_needed = flag_asynchronous_unwind_tables;\n       for (i = 0; i < fde_table_in_use; ++i)\n \tif (fde_table[i].uses_eh_lsda)\n \t  any_eh_needed = any_lsda_needed = 1;"}, {"sha": "04c3ed93eaa9c5d9648d3b4e73b2533d74bf8125", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -451,6 +451,10 @@ extern int flag_exceptions;\n \n extern int flag_unwind_tables;\n \n+/* Nonzero means generate frame unwind info table exact at each insn boundary */\n+\n+extern int flag_asynchronous_unwind_tables;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n "}, {"sha": "58bf25724c0dd6dd883327277532811eeb89d97a", "filename": "gcc/flow.c", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -344,6 +344,7 @@ static void invalidate_mems_from_autoinc PARAMS ((struct propagate_block_info *,\n static void invalidate_mems_from_set\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx));\n static void delete_dead_jumptables\tPARAMS ((void));\n+static void clear_log_links\t\tPARAMS ((sbitmap));\n \f\n \n void\n@@ -628,12 +629,19 @@ update_life_info (blocks, extent, prop_flags)\n \n   tmp = INITIALIZE_REG_SET (tmp_head);\n \n+  timevar_push ((extent == UPDATE_LIFE_LOCAL || blocks)\n+\t\t? TV_LIFE_UPDATE : TV_LIFE);\n+\n   /* Changes to the CFG are only allowed when\n      doing a global update for the entire CFG.  */\n   if ((prop_flags & PROP_ALLOW_CFG_CHANGES)\n       && (extent == UPDATE_LIFE_LOCAL || blocks))\n     abort ();\n \n+  /* Clear log links in case we are asked to (re)compute them.  */\n+  if (prop_flags & PROP_LOG_LINKS)\n+    clear_log_links (blocks);\n+\n   /* For a global update, we go through the relaxation process again.  */\n   if (extent != UPDATE_LIFE_LOCAL)\n     {\n@@ -727,6 +735,8 @@ update_life_info (blocks, extent, prop_flags)\n \t\t\t\t     }\n \t\t\t\t });\n     }\n+  timevar_pop ((extent == UPDATE_LIFE_LOCAL || blocks)\n+\t       ? TV_LIFE_UPDATE : TV_LIFE);\n }\n \n /* Free the variables allocated by find_basic_blocks.\n@@ -4088,31 +4098,33 @@ count_or_remove_death_notes (blocks, kill)\n \n   return count;\n }\n-/* Clear LOG_LINKS fields of insns in a chain.\n-   Also clear the global_live_at_{start,end} fields of the basic block\n-   structures.  */\n+/* Clear LOG_LINKS fields of insns in a selected blocks or whole chain\n+   if blocks is NULL.  */\n \n-void\n-clear_log_links (insns)\n-     rtx insns;\n+static void\n+clear_log_links (blocks)\n+     sbitmap blocks;\n {\n-  rtx i;\n-  int b;\n-\n-  for (i = insns; i; i = NEXT_INSN (i))\n-    if (INSN_P (i))\n-      LOG_LINKS (i) = 0;\n+  rtx insn;\n+  int i;\n \n-  for (b = 0; b < n_basic_blocks; b++)\n+  if (!blocks)\n     {\n-      basic_block bb = BASIC_BLOCK (b);\n-\n-      bb->global_live_at_start = NULL;\n-      bb->global_live_at_end = NULL;\n+      rtx insn;\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn))\n+\t  free_EXPR_LIST_list (&LOG_LINKS (insn));\n     }\n-\n-  ENTRY_BLOCK_PTR->global_live_at_end = NULL;\n-  EXIT_BLOCK_PTR->global_live_at_start = NULL;\n+  else\n+    EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n+      {\n+\tbasic_block bb = BASIC_BLOCK (i);\n+\trtx insn;\n+\tfor (insn = bb->head; insn != NEXT_INSN (bb->end);\n+\t     insn = NEXT_INSN (insn))\n+\t  if (INSN_P (insn))\n+\t    free_EXPR_LIST_list (&LOG_LINKS (insn));\n+      });\n }\n \n /* Given a register bitmap, turn on the bits in a HARD_REG_SET that"}, {"sha": "874d56755d2a7418426bc18e64075ccf5c0a82d8", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -2778,8 +2778,7 @@ split_all_insns (upd_life)\n \n   if (changed)\n     {\n-      for (i = 0; i < n_basic_blocks; i++)\n-\tfind_sub_basic_blocks (BASIC_BLOCK (i));\n+      find_many_sub_basic_blocks (blocks);\n     }\n \n   if (changed && upd_life)"}, {"sha": "d6908e99a27caf3db3858c1a4d770cf27884d797", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -1481,7 +1481,6 @@ void free_EXPR_LIST_node \t\tPARAMS ((rtx));\n void free_INSN_LIST_node \t\tPARAMS ((rtx));\n rtx alloc_INSN_LIST\t\t\tPARAMS ((rtx, rtx));\n rtx alloc_EXPR_LIST\t\t\tPARAMS ((int, rtx, rtx));\n-void clear_log_links                    PARAMS ((rtx));\n \n /* regclass.c */\n "}, {"sha": "353a942bf71dfe9ed2f4843dd1b461614dd575f8", "filename": "gcc/timevar.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -43,6 +43,9 @@ DEFTIMEVAR (TV_DUMP                  , \"dump files\")\n DEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n /* Time spent by cleaning up CFG.  */\n DEFTIMEVAR (TV_CLEANUP_CFG           , \"cfg cleanup\")\n+/* Time spent by life analysis.  */\n+DEFTIMEVAR (TV_LIFE\t\t     , \"life analysis\")\n+DEFTIMEVAR (TV_LIFE_UPDATE\t     , \"life info update\")\n /* Timing in various stages of the compiler.  */\n DEFTIMEVAR (TV_CPP\t\t     , \"preprocessing\")\n DEFTIMEVAR (TV_LEX\t\t     , \"lexical analysis\")\n@@ -60,6 +63,7 @@ DEFTIMEVAR (TV_FLOW                  , \"flow analysis\")\n DEFTIMEVAR (TV_COMBINE               , \"combiner\")\n DEFTIMEVAR (TV_IFCVT\t\t     , \"if-conversion\")\n DEFTIMEVAR (TV_REGMOVE               , \"regmove\")\n+DEFTIMEVAR (TV_MODE_SWITCH           , \"mode switching\")\n DEFTIMEVAR (TV_SCHED                 , \"scheduling\")\n DEFTIMEVAR (TV_LOCAL_ALLOC           , \"local alloc\")\n DEFTIMEVAR (TV_GLOBAL_ALLOC          , \"global alloc\")"}, {"sha": "3bc9dac156ba3f628c42ce6243d706bb3d9f4efe", "filename": "gcc/toplev.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b932f770f70d60b1d6c89d6ef1fe8dc88bdecda1", "patch": "@@ -737,6 +737,10 @@ int flag_exceptions;\n \n int flag_unwind_tables = 0;\n \n+/* Nonzero means generate frame unwind info table exact at each insn boundary */\n+\n+int flag_asynchronous_unwind_tables = 0;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n \n@@ -1096,6 +1100,8 @@ lang_independent_options f_options[] =\n    N_(\"Enable exception handling\") },\n   {\"unwind-tables\", &flag_unwind_tables, 1,\n    N_(\"Just generate unwind tables for exception handling\") },\n+  {\"asynchronous-unwind-tables\", &flag_asynchronous_unwind_tables, 1,\n+   N_(\"Generate unwind tables exact at each instruction boundary\") },\n   {\"non-call-exceptions\", &flag_non_call_exceptions, 1,\n    N_(\"Support synchronous non-call exceptions\") },\n   {\"profile-arcs\", &profile_arc_flag, 1,\n@@ -2933,10 +2939,6 @@ rest_of_compilation (decl)\n       convert_from_ssa ();\n       /* New registers have been created.  Rescan their usage.  */\n       reg_scan (insns, max_reg_num (), 1);\n-      /* Life analysis used in SSA adds log_links but these\n-\t shouldn't be there until the flow stage, so clear\n-\t them away.  */\n-      clear_log_links (insns);\n \n       close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n       timevar_pop (TV_FROM_SSA);\n@@ -3370,7 +3372,7 @@ rest_of_compilation (decl)\n   register_life_up_to_date = 0;\n \n #ifdef OPTIMIZE_MODE_SWITCHING\n-  timevar_push (TV_GCSE);\n+  timevar_push (TV_MODE_SWITCH);\n \n   no_new_pseudos = 0;\n   if (optimize_mode_switching (NULL))\n@@ -3382,7 +3384,7 @@ rest_of_compilation (decl)\n     }\n   no_new_pseudos = 1;\n \n-  timevar_pop (TV_GCSE);\n+  timevar_pop (TV_MODE_SWITCH);\n #endif\n \n   timevar_push (TV_SCHED);\n@@ -4911,6 +4913,11 @@ toplev_main (argc, argv)\n       flag_rerun_cse_after_loop = 1;\n     }\n \n+  if (flag_non_call_exceptions)\n+    flag_asynchronous_unwind_tables = 1;\n+  if (flag_asynchronous_unwind_tables)\n+    flag_unwind_tables = 1;\n+\n   /* Warn about options that are not supported on this machine.  */\n #ifndef INSN_SCHEDULING\n   if (flag_schedule_insns || flag_schedule_insns_after_reload)"}]}