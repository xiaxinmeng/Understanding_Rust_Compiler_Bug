{"sha": "bb6e3d4145581f36d908c9a0868d6b72f3503176", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI2ZTNkNDE0NTU4MWYzNmQ5MDhjOWEwODY4ZDZiNzJmMzUwMzE3Ng==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-08-31T10:20:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-31T10:20:38Z"}, "message": "checks.adb (In_Declarative_Region_Of_Subprogram_Body): New routine.\n\n2007-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (In_Declarative_Region_Of_Subprogram_Body): New routine.\n\t(Mark_Non_Null): If the node for which we just generated an access check\n\tis a reference to an *in* parameter and the reference appears in the\n\tdeclarative part of a subprogram body, mark the node as known non null.\n\nFrom-SVN: r127969", "tree": {"sha": "16ef625e05835919908dbc3e3d3f1c29170fccbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16ef625e05835919908dbc3e3d3f1c29170fccbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb6e3d4145581f36d908c9a0868d6b72f3503176", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6e3d4145581f36d908c9a0868d6b72f3503176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6e3d4145581f36d908c9a0868d6b72f3503176", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6e3d4145581f36d908c9a0868d6b72f3503176/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a687fbb9ece39f225fd15ea2bbb319e3b4c58a39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a687fbb9ece39f225fd15ea2bbb319e3b4c58a39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a687fbb9ece39f225fd15ea2bbb319e3b4c58a39"}], "stats": {"total": 98, "additions": 95, "deletions": 3}, "files": [{"sha": "b025ce803e0742b1498cd39e3c7f9f5c5a6f479f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 95, "deletions": 3, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6e3d4145581f36d908c9a0868d6b72f3503176/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6e3d4145581f36d908c9a0868d6b72f3503176/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=bb6e3d4145581f36d908c9a0868d6b72f3503176", "patch": "@@ -4988,20 +4988,112 @@ package body Checks is\n       Loc : constant Source_Ptr := Sloc (N);\n       Typ : constant Entity_Id  := Etype (N);\n \n+      function In_Declarative_Region_Of_Subprogram_Body return Boolean;\n+      --  Determine whether node N, a reference to an *in* parameter, is\n+      --  inside the declarative region of the current subprogram body.\n+\n       procedure Mark_Non_Null;\n-      --  After installation of check, marks node as non-null if entity\n+      --  After installation of check, if the node in question is an entity\n+      --  name, then mark this entity as non-null if possible.\n+\n+      ----------------------------------------------\n+      -- In_Declarative_Region_Of_Subprogram_Body --\n+      ----------------------------------------------\n+\n+      function In_Declarative_Region_Of_Subprogram_Body return Boolean is\n+         E     : constant Entity_Id := Entity (N);\n+         S     : constant Entity_Id := Current_Scope;\n+         S_Par : Node_Id;\n+\n+      begin\n+         pragma Assert (Ekind (E) = E_In_Parameter);\n+\n+         --  Two initial context checks. We must be inside a subprogram body\n+         --  with declarations and reference must not appear in nested scopes.\n+\n+         if (Ekind (S) /= E_Function\n+             and then Ekind (S) /= E_Procedure)\n+           or else Scope (E) /= S\n+         then\n+            return False;\n+         end if;\n+\n+         S_Par := Parent (Parent (S));\n+\n+         if Nkind (S_Par) /= N_Subprogram_Body\n+           or else No (Declarations (S_Par))\n+         then\n+            return False;\n+         end if;\n+\n+         declare\n+            N_Decl : Node_Id;\n+            P      : Node_Id;\n+\n+         begin\n+            --  Retrieve the declaration node of N (if any). Note that N\n+            --  may be a part of a complex initialization expression.\n+\n+            P := Parent (N);\n+            N_Decl := Empty;\n+            while Present (P) loop\n+\n+               --  While traversing the parent chain, we find that N\n+               --  belongs to a statement, thus it may never appear in\n+               --  a declarative region.\n+\n+               if Nkind (P) in N_Statement_Other_Than_Procedure_Call\n+                 or else Nkind (P) = N_Procedure_Call_Statement\n+               then\n+                  return False;\n+               end if;\n+\n+               if Nkind (P) in N_Declaration\n+                 and then Nkind (P) not in N_Subprogram_Specification\n+               then\n+                  N_Decl := P;\n+                  exit;\n+               end if;\n+\n+               P := Parent (P);\n+            end loop;\n+\n+            if No (N_Decl) then\n+               return False;\n+            end if;\n+\n+            return List_Containing (N_Decl) = Declarations (S_Par);\n+         end;\n+      end In_Declarative_Region_Of_Subprogram_Body;\n \n       -------------------\n       -- Mark_Non_Null --\n       -------------------\n \n       procedure Mark_Non_Null is\n       begin\n+         --  Only case of interest is if node N is an entity name\n+\n          if Is_Entity_Name (N) then\n+\n+            --  For sure, we want to clear an indication that this is known to\n+            --  be null, since if we get past this check, it definitely is not!\n+\n             Set_Is_Known_Null (Entity (N), False);\n \n-            if Safe_To_Capture_Value (N, Entity (N)) then\n-               Set_Is_Known_Non_Null (Entity (N), True);\n+            --  We can mark the entity as known to be non-null if either it is\n+            --  safe to capture the value, or in the case of an IN parameter,\n+            --  which is a constant, if the check we just installed is in the\n+            --  declarative region of the subprogram body. In this latter case,\n+            --  a check is decisive for the rest of the body, since we know we\n+            --  must complete all declarations before executing the body.\n+\n+            if Safe_To_Capture_Value (N, Entity (N))\n+              or else\n+                (Ekind (Entity (N)) = E_In_Parameter\n+                   and then In_Declarative_Region_Of_Subprogram_Body)\n+            then\n+               Set_Is_Known_Non_Null (Entity (N));\n             end if;\n          end if;\n       end Mark_Non_Null;"}]}