{"sha": "5e27f0d5d54d83e13d8b845b965b96fd10706f46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyN2YwZDVkNTRkODNlMTNkOGI4NDViOTY1Yjk2ZmQxMDcwNmY0Ng==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-02-20T20:22:01Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-02-20T20:22:01Z"}, "message": "PR middle-end/84095 - false-positive -Wrestrict warnings for memcpy within array\n\ngcc/ChangeLog:\n\n\tPR middle-end/84095\n\t* gimple-ssa-warn-restrict.c (builtin_memref::extend_offset_range): New.\n\t(builtin_memref::set_base_and_offset): Same.  Handle inner references.\n\t(builtin_memref::builtin_memref): Factor out parts into\n\tset_base_and_offset and call it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/84095\n\t* c-c++-common/Warray-bounds-3.c: Adjust text of expected warnings.\n\t* c-c++-common/Wrestrict.c: Same.\n\t* gcc.dg/Wrestrict-6.c: Same.\n\t* gcc.dg/Warray-bounds-27.c: New test.\n\t* gcc.dg/Wrestrict-8.c: New test.\n\t* gcc.dg/Wrestrict-9.c: New test.\n\t* gcc.dg/pr84095.c: New test.\n\nFrom-SVN: r257860", "tree": {"sha": "6f9d63e7d0aab885e612d0f3546e51175425c258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f9d63e7d0aab885e612d0f3546e51175425c258"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e27f0d5d54d83e13d8b845b965b96fd10706f46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e27f0d5d54d83e13d8b845b965b96fd10706f46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e27f0d5d54d83e13d8b845b965b96fd10706f46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e27f0d5d54d83e13d8b845b965b96fd10706f46/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75b81dcdad7b41fb6cc9d0fa6064966c2016ce96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b81dcdad7b41fb6cc9d0fa6064966c2016ce96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b81dcdad7b41fb6cc9d0fa6064966c2016ce96"}], "stats": {"total": 840, "additions": 699, "deletions": 141}, "files": [{"sha": "8b686d03a14f47855adafcb7227d856a57a341b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -1,3 +1,11 @@\n+2018-02-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/84095\n+\t* gimple-ssa-warn-restrict.c (builtin_memref::extend_offset_range): New.\n+\t(builtin_memref::set_base_and_offset): Same.  Handle inner references.\n+\t(builtin_memref::builtin_memref): Factor out parts into\n+\tset_base_and_offset and call it.\n+\n 2018-02-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR middle-end/84406"}, {"sha": "9d5c6e043701cbee9eb0aa7f32658f82f6438326", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 183, "deletions": 124, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -158,6 +158,14 @@ struct builtin_memref\n   builtin_memref (tree, tree);\n \n   tree offset_out_of_bounds (int, offset_int[2]) const;\n+\n+private:\n+\n+  /* Ctor helper to set or extend OFFRANGE based on argument.  */\n+  void extend_offset_range (tree);\n+\n+  /*  Ctor helper to determine BASE and OFFRANGE from argument.  */\n+  void set_base_and_offset (tree);\n };\n \n /* Description of a memory access by a raw memory or string built-in\n@@ -235,11 +243,120 @@ builtin_memref::builtin_memref (tree expr, tree size)\n \n   const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n \n+  /* Find the BASE object or pointer referenced by EXPR and set\n+     the offset range OFFRANGE in the process.  */\n+  set_base_and_offset (expr);\n+\n+  if (size)\n+    {\n+      tree range[2];\n+      /* Determine the size range, allowing for the result to be [0, 0]\n+\t for SIZE in the anti-range ~[0, N] where N >= PTRDIFF_MAX.  */\n+      get_size_range (size, range, true);\n+      sizrange[0] = wi::to_offset (range[0]);\n+      sizrange[1] = wi::to_offset (range[1]);\n+      /* get_size_range returns SIZE_MAX for the maximum size.\n+\t Constrain it to the real maximum of PTRDIFF_MAX.  */\n+      if (sizrange[1] > maxobjsize)\n+\tsizrange[1] = maxobjsize;\n+    }\n+  else\n+    sizrange[1] = maxobjsize;\n+\n+  tree basetype = TREE_TYPE (base);\n+  if (DECL_P (base) && TREE_CODE (basetype) == ARRAY_TYPE)\n+    {\n+      /* If the offset could be in range of the referenced object\n+\t constrain its bounds so neither exceeds those of the object.  */\n+      if (offrange[0] < 0 && offrange[1] > 0)\n+\toffrange[0] = 0;\n+\n+      offset_int maxoff = maxobjsize;\n+      if (ref && array_at_struct_end_p (ref))\n+\t;   /* Use the maximum possible offset for last member arrays.  */\n+      else if (tree basesize = TYPE_SIZE_UNIT (basetype))\n+\tmaxoff = wi::to_offset (basesize);\n+\n+      if (offrange[0] >= 0)\n+\t{\n+\t  if (offrange[1] < 0)\n+\t    offrange[1] = offrange[0] <= maxoff ? maxoff : maxobjsize;\n+\t  else if (offrange[0] <= maxoff && offrange[1] > maxoff)\n+\t    offrange[1] = maxoff;\n+\t}\n+    }\n+}\n+\n+/* Ctor helper to set or extend OFFRANGE based on the OFFSET argument.  */\n+\n+void\n+builtin_memref::extend_offset_range (tree offset)\n+{\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  if (TREE_CODE (offset) == INTEGER_CST)\n+    {\n+      offset_int off = int_cst_value (offset);\n+      if (off != 0)\n+\t{\n+\t  offrange[0] += off;\n+\t  offrange[1] += off;\n+\t}\n+      return;\n+    }\n+\n+  if (TREE_CODE (offset) == SSA_NAME)\n+    {\n+      wide_int min, max;\n+      value_range_type rng = get_range_info (offset, &min, &max);\n+      if (rng == VR_RANGE)\n+\t{\n+\t  offrange[0] += offset_int::from (min, SIGNED);\n+\t  offrange[1] += offset_int::from (max, SIGNED);\n+\t}\n+      else if (rng == VR_ANTI_RANGE)\n+\t{\n+\t  offrange[0] += offset_int::from (max + 1, SIGNED);\n+\t  offrange[1] += offset_int::from (min - 1, SIGNED);\n+\t}\n+      else\n+\t{\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (offset);\n+\t  tree type;\n+\t  if (is_gimple_assign (stmt)\n+\t      && gimple_assign_rhs_code (stmt) == NOP_EXPR\n+\t      && (type = TREE_TYPE (gimple_assign_rhs1 (stmt)))\n+\t      && INTEGRAL_TYPE_P (type))\n+\t    {\n+\t      /* Use the bounds of the type of the NOP_EXPR operand\n+\t\t even if it's signed.  The result doesn't trigger\n+\t\t warnings but makes their output more readable.  */\n+\t      offrange[0] += wi::to_offset (TYPE_MIN_VALUE (type));\n+\t      offrange[1] += wi::to_offset (TYPE_MAX_VALUE (type));\n+\t    }\n+\t  else\n+\t    offrange[1] += maxobjsize;\n+\t}\n+      return;\n+    }\n+\n+  offrange[1] += maxobjsize;\n+}\n+\n+/* Determines the base object or pointer of the reference EXPR\n+   and the offset range from the beginning of the base.  */\n+\n+void\n+builtin_memref::set_base_and_offset (tree expr)\n+{\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n   if (TREE_CODE (expr) == SSA_NAME)\n     {\n       /* Try to tease the offset out of the pointer.  */\n       gimple *stmt = SSA_NAME_DEF_STMT (expr);\n-      if (gimple_assign_single_p (stmt)\n+      if (!base\n+\t  && gimple_assign_single_p (stmt)\n \t  && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n \texpr = gimple_assign_rhs1 (stmt);\n       else if (is_gimple_assign (stmt))\n@@ -250,154 +367,88 @@ builtin_memref::builtin_memref (tree expr, tree size)\n \t      tree rhs = gimple_assign_rhs1 (stmt);\n \t      if (POINTER_TYPE_P (TREE_TYPE (rhs)))\n \t\texpr = gimple_assign_rhs1 (stmt);\n+\t      else\n+\t\t{\n+\t\t  base = expr;\n+\t\t  return;\n+\t\t}\n \t    }\n \t  else if (code == POINTER_PLUS_EXPR)\n \t    {\n \t      expr = gimple_assign_rhs1 (stmt);\n \n \t      tree offset = gimple_assign_rhs2 (stmt);\n-\t      if (TREE_CODE (offset) == INTEGER_CST)\n-\t\t{\n-\t\t  offset_int off = int_cst_value (offset);\n-\t\t  offrange[0] = off;\n-\t\t  offrange[1] = off;\n-\n-\t\t  if (TREE_CODE (expr) == SSA_NAME)\n-\t\t    {\n-\t\t      gimple *stmt = SSA_NAME_DEF_STMT (expr);\n-\t\t      if (gimple_assign_single_p (stmt)\n-\t\t\t  && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n-\t\t\texpr = gimple_assign_rhs1 (stmt);\n-\t\t    }\n-\t\t}\n-\t      else if (TREE_CODE (offset) == SSA_NAME)\n-\t\t{\n-\t\t  wide_int min, max;\n-\t\t  value_range_type rng = get_range_info (offset, &min, &max);\n-\t\t  if (rng == VR_RANGE)\n-\t\t    {\n-\t\t      offrange[0] = offset_int::from (min, SIGNED);\n-\t\t      offrange[1] = offset_int::from (max, SIGNED);\n-\t\t    }\n-\t\t  else if (rng == VR_ANTI_RANGE)\n-\t\t    {\n-\t\t      offrange[0] = offset_int::from (max + 1, SIGNED);\n-\t\t      offrange[1] = offset_int::from (min - 1, SIGNED);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      gimple *stmt = SSA_NAME_DEF_STMT (offset);\n-\t\t      tree type;\n-\t\t      if (is_gimple_assign (stmt)\n-\t\t\t  && gimple_assign_rhs_code (stmt) == NOP_EXPR\n-\t\t\t  && (type = TREE_TYPE (gimple_assign_rhs1 (stmt)))\n-\t\t\t  && INTEGRAL_TYPE_P (type))\n-\t\t\t{\n-\t\t\t  /* Use the bounds of the type of the NOP_EXPR operand\n-\t\t\t     even if it's signed.  The result doesn't trigger\n-\t\t\t     warnings but makes their output more readable.  */\n-\t\t\t  offrange[0] = wi::to_offset (TYPE_MIN_VALUE (type));\n-\t\t\t  offrange[1] = wi::to_offset (TYPE_MAX_VALUE (type));\n-\t\t\t}\n-\t\t      else\n-\t\t\toffrange[1] = maxobjsize;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\toffrange[1] = maxobjsize;\n+\t      extend_offset_range (offset);\n \t    }\n+\t  else\n+\t    {\n+\t      base = expr;\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  base = expr;\n+\t  return;\n \t}\n     }\n \n   if (TREE_CODE (expr) == ADDR_EXPR)\n-    {\n-      poly_int64 off;\n-      tree op = TREE_OPERAND (expr, 0);\n+    expr = TREE_OPERAND (expr, 0);\n \n-      /* Determine the base object or pointer of the reference\n-\t and its constant offset from the beginning of the base.  */\n-      base = get_addr_base_and_unit_offset (op, &off);\n+  poly_int64 bitsize, bitpos;\n+  tree var_off;\n+  machine_mode mode;\n+  int sign, reverse, vol;\n \n-      HOST_WIDE_INT const_off;\n-      if (base && off.is_constant (&const_off))\n-\t{\n-\t  offrange[0] += const_off;\n-\t  offrange[1] += const_off;\n+  /* Determine the base object or pointer of the reference and\n+     the constant bit offset from the beginning of the base.\n+     If the offset has a non-constant component, it will be in\n+     VAR_OFF.  MODE, SIGN, REVERSE, and VOL are write only and\n+     unused here.  */\n+  base = get_inner_reference (expr, &bitsize, &bitpos, &var_off,\n+\t\t\t      &mode, &sign, &reverse, &vol);\n \n-\t  /* Stash the reference for offset validation.  */\n-\t  ref = op;\n+  poly_int64 bytepos = exact_div (bitpos, BITS_PER_UNIT);\n \n-\t  /* Also stash the constant offset for offset validation.  */\n-\t  if (TREE_CODE (op) == COMPONENT_REF)\n-\t    refoff = const_off;\n-\t}\n-      else\n-\t{\n-\t  size = NULL_TREE;\n-\t  base = get_base_address (TREE_OPERAND (expr, 0));\n-\t}\n+  HOST_WIDE_INT const_off;\n+  if (!base || !bytepos.is_constant (&const_off))\n+    {\n+      base = get_base_address (TREE_OPERAND (expr, 0));\n+      return;\n     }\n \n-  if (!base)\n-    base = build2 (MEM_REF, char_type_node, expr, null_pointer_node);\n+  offrange[0] += const_off;\n+  offrange[1] += const_off;\n \n-  if (TREE_CODE (base) == MEM_REF)\n+  if (var_off)\n     {\n-      offset_int off;\n-      if (mem_ref_offset (base).is_constant (&off))\n+      if (TREE_CODE (var_off) == INTEGER_CST)\n \t{\n-\t  refoff += off;\n-\t  offrange[0] += off;\n-\t  offrange[1] += off;\n+\t  offset_int cstoff = wi::to_offset (var_off);\n+\t  offrange[0] += cstoff;\n+\t  offrange[1] += cstoff;\n \t}\n       else\n-\tsize = NULL_TREE;\n-      base = TREE_OPERAND (base, 0);\n+\toffrange[1] += maxobjsize;\n     }\n \n-  if (TREE_CODE (base) == SSA_NAME)\n-    if (gimple *stmt = SSA_NAME_DEF_STMT (base))\n-      {\n-\tenum gimple_code code = gimple_code (stmt);\n-\tif (code == GIMPLE_ASSIGN)\n-\t  if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n-\t    {\n-\t      base = gimple_assign_rhs1 (stmt);\n+  /* Stash the reference for offset validation.  */\n+  ref = expr;\n \n-\t      tree offset = gimple_assign_rhs2 (stmt);\n-\t      if (TREE_CODE (offset) == INTEGER_CST)\n-\t\t{\n-\t\t  offset_int off = int_cst_value (offset);\n-\t\t  refoff += off;\n-\t\t  offrange[0] += off;\n-\t\t  offrange[1] += off;\n-\t\t}\n-\t    }\n-      }\n+  /* Also stash the constant offset for offset validation.  */\n+  if (TREE_CODE (expr) == COMPONENT_REF)\n+    refoff = const_off;\n \n-  if (DECL_P (base) && TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE)\n+  if (TREE_CODE (base) == MEM_REF)\n     {\n-      /* For array objects, where a negative offset wouldn't make\n-\t sense, use zero instead if the upper bound is positive.  */\n-      if (offrange[0] < 0 && offrange[1] > 0)\n-\toffrange[0] = 0;\n+      tree memrefoff = TREE_OPERAND (base, 1);\n+      extend_offset_range (memrefoff);\n+      base = TREE_OPERAND (base, 0);\n     }\n \n-  if (size)\n-    {\n-      tree range[2];\n-      /* Determine the size range, allowing for the result to be [0, 0]\n-\t for SIZE in the anti-range ~[0, N] where N >= PTRDIFF_MAX.  */\n-      get_size_range (size, range, true);\n-      sizrange[0] = wi::to_offset (range[0]);\n-      sizrange[1] = wi::to_offset (range[1]);\n-      /* get_size_range returns SIZE_MAX for the maximum size.\n-\t Constrain it to the real maximum of PTRDIFF_MAX.  */\n-      if (sizrange[1] > maxobjsize)\n-\tsizrange[1] = maxobjsize;\n-    }\n-  else\n-    sizrange[1] = maxobjsize;\n+  if (TREE_CODE (base) == SSA_NAME)\n+    set_base_and_offset (base);\n }\n \n /* Return error_mark_node if the signed offset exceeds the bounds\n@@ -864,10 +915,18 @@ builtin_access::generic_overlap ()\n      the other.  */\n   bool depends_p = detect_overlap != &builtin_access::generic_overlap;\n \n-  if (!overlap_certain\n-      && !dstref->strbounded_p\n-      && !depends_p)\n-    return false;\n+  if (!overlap_certain)\n+    {\n+      if (!dstref->strbounded_p && !depends_p)\n+\treturn false;\n+\n+      /* There's no way to distinguish an access to the same member\n+\t of a structure from one to two distinct members of the same\n+\t structure.  Give up to avoid excessive false positives.  */\n+      tree basetype = TREE_TYPE (TREE_TYPE (dstref->base));\n+      if (RECORD_OR_UNION_TYPE_P (basetype))\n+\treturn false;\n+    }\n \n   /* True for stpcpy and strcpy.  */\n   bool stxcpy_p = (!dstref->strbounded_p"}, {"sha": "97983a56a58893ee8792c5c4b1341b34e8922025", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -1,3 +1,14 @@\n+2018-02-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/84095\n+\t* c-c++-common/Warray-bounds-3.c: Adjust text of expected warnings.\n+\t* c-c++-common/Wrestrict.c: Same.\n+\t* gcc.dg/Wrestrict-6.c: Same.\n+\t* gcc.dg/Warray-bounds-27.c: New test.\n+\t* gcc.dg/Wrestrict-8.c: New test.\n+\t* gcc.dg/Wrestrict-9.c: New test.\n+\t* gcc.dg/pr84095.c: New test.\n+\n 2018-02-20  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* gfortran.dg/structure_constructor_14.f90: Adjust STOP number."}, {"sha": "2ee81464375d29e156062ed7901f90b6c97b58c6", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -61,7 +61,7 @@ void test_memcpy_bounds (char *d, const char *s, size_t n)\n      they appear as large positive in the source.  It would be nice\n      if they retained their type but unfortunately that's not how\n      it works so be prepared for both in case it even gets fixed.  */\n-  T (char, 1, a + UR (3, SIZE_MAX - 1), s, n);   /* { dg-warning \"offset \\\\\\[3, -2] is out of the bounds \\\\\\[0, 1] of object\" \"memcpy\" } */\n+  T (char, 1, a + UR (3, SIZE_MAX - 1), s, n);   /* { dg-warning \"offset \\\\\\[3, -?\\[0-9\\]+] is out of the bounds \\\\\\[0, 1] of object\" \"memcpy\" } */\n \n   /* Verify that invalid offsets into an array of unknown size are\n      detected.  */\n@@ -226,7 +226,7 @@ T (char, 1, a + SR (-2, -1), s, n);     /* { dg-warning \"offset \\\\\\[-2, -1] is o\n      they appear as large positive in the source.  It would be nice\n      if they retained their type but unfortunately that's not how\n      it works so be prepared for both in case it ever gets fixed.  */\n-  T (char, 1, a + UR (3, SIZE_MAX), s, n);   /* { dg-warning \"offset \\\\\\[3, -1] is out of the bounds \\\\\\[0, 1] of object \"  \"mempcpy\" } */\n+  T (char, 1, a + UR (3, SIZE_MAX), s, n);   /* { dg-warning \"offset \\\\\\[3, -?\\[0-9\\]+] is out of the bounds \\\\\\[0, 1] of object \"  \"mempcpy\" } */\n \n   /* Verify that invalid offsets into an array of unknown size are\n      detected.  */"}, {"sha": "e62652f78e1a97d1797785fff51f8b70e9a476cd", "filename": "gcc/testsuite/c-c++-common/Wrestrict.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -223,7 +223,7 @@ void test_memcpy_range (char *d, size_t sz)\n \n   /* Because the size is constant and a power of 2 the following is\n      folded too early to detect the overlap.  */\n-  T (d + ir, d, 4);               /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 3] and 0 overlaps 2 byte at offset 2\" \"\" { xfail *-*-* } } */\n+  T (d + ir, d, 4);               /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 3] and 0 overlaps 2 byte at offset 2\" \"memcpy\" { xfail *-*-* } } */\n   T (d + ir, d, 5);               /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 3] and 0 overlaps between 2 and 3 bytes at offset \\\\\\[2, 3]\" \"memcpy\" } */\n \n   /* Exercise the full range of size_t.  */\n@@ -325,11 +325,11 @@ void test_memcpy_anti_range (char *d, const char *s)\n   T (d, d + SAR (0, 3), 1);\n   T (d, d + SAR (0, 3), 2);\n   T (d, d + SAR (0, 3), 3);\n-  T (d, d + SAR (0, 3), DIFF_MAX - 2);   /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 2\" } */\n-  T (d, d + SAR (0, 3), DIFF_MAX - 1);   /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 1\" } */\n-  T (d, d + SAR (0, 3), DIFF_MAX);       /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 0\" } */\n+  T (d, d + SAR (0, 3), DIFF_MAX - 2);   /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 2\" \"memcpy\" } */\n+  T (d, d + SAR (0, 3), DIFF_MAX - 1);   /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 1\" \"memcpy\" } */\n+  T (d, d + SAR (0, 3), DIFF_MAX);       /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 0\" \"memcpy\" } */\n \n-  T (d, d + SAR (0, 3), UR (DIFF_MAX - 2, DIFF_MAX));               /* { dg-warning \"accessing \\[0-9\\]+ or more bytes at offsets 0 and \\\\\\[-?\\[0-9\\]+, -?\\[0-9\\]+] overlaps \\[0-9\\]+ bytes at offset 2\" } */\n+  T (d, d + SAR (0, 3), UR (DIFF_MAX - 2, DIFF_MAX));               /* { dg-warning \"accessing \\[0-9\\]+ or more bytes at offsets 0 and \\\\\\[-?\\[0-9\\]+, -?\\[0-9\\]+] overlaps \\[0-9\\]+ bytes at offset 2\" \"memcpy\" } */\n \n   /* Verify that a size in an anti-range ~[0, N] where N >= PTRDIFF_MAX\n      doesn't trigger a warning.  */\n@@ -399,7 +399,7 @@ void test_memcpy_range_exceed (char *d, const char *s)\n   T (d + i, s, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[9223372036854775805, 9223372036854775807] and 0 overlaps 3 bytes at offset 9223372036854775802\" \"LP64\" { target lp64 } } */\n #elif __SIZEOF_SIZE_T__ == 4\n   T (d, d + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2147483645, 2147483647] overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32 } } */\n-  T (d + i, d, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2147483645, 2147483647] and 0 overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32} } */\n+  T (d + i, d, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2147483645, 2147483647] and 0 overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32 } } */\n \n   T (d, s + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2147483645, 2147483647] overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32 } } */\n   T (d + i, s, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2147483645, 2147483647] and 0 overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32} } */\n@@ -523,7 +523,7 @@ void test_memcpy_memarrray (struct MemArrays *p)\n   T (p->a8, p->a8 + 2, 2);\n   T (p->a8, p->a8 + 8, 1);\n \n-  T (p->a8, p->a8 + 2, 3);        /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" } */\n+  T (p->a8, p->a8 + 2, 3);        /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" \"memcpy\" } */\n }\n \n /* Exercise the absence of warnings with memmove.  */\n@@ -768,13 +768,13 @@ void test_strcpy_range (void)\n \n   /* The overlap in the cases below isn't inevitable but it is diagnosed\n      because it is possible and so the code is considered unsafe.  */\n-  T (8, \"\", a, a + r);               /* { dg-warning \"accessing 1 byte may overlap 1 byte\" \"strcpy\" } */\n-  T (8, \"0\", a + r, a);              /* { dg-warning \"accessing 2 bytes may overlap up to 2 bytes\" \"strcpy\" } */\n-  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes may overlap up to 4 bytes\" \"strcpy\" } */\n+  T (8, \"\", a, a + r);               /* { dg-warning \"accessing 1 byte at offsets 0 and \\\\\\[0, 8] may overlap 1 byte\" \"strcpy\" } */\n+  T (8, \"0\", a + r, a);              /* { dg-warning \"accessing 2 bytes at offsets \\\\\\[0, 8] and 0 may overlap up to 2 bytes\" \"strcpy\" } */\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[0, 8] and 0 may overlap up to 4 bytes\" \"strcpy\" } */\n \n-  T (8, \"\", a, a + r);               /* { dg-warning \"accessing 1 byte may overlap\" \"strcpy\" } */\n-  T (8, \"0\", a, a + r);              /* { dg-warning \"accessing between 0 and 2 bytes may overlap up to 2 bytes\" \"strcpy\" } */\n-  T (8, \"012\", a, a + r);            /* { dg-warning \"accessing between 0 and 4 bytes may overlap up to 4 bytes\" \"strcpy\" } */\n+  T (8, \"\", a, a + r);               /* { dg-warning \"accessing 1 byte at offsets 0 and \\\\\\[0, 8] may overlap\" \"strcpy\" } */\n+  T (8, \"0\", a, a + r);              /* { dg-warning \"accessing between 0 and 2 bytes at offsets 0 and \\\\\\[0, 8] may overlap up to 2 bytes\" \"strcpy\" } */\n+  T (8, \"012\", a, a + r);            /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[0, 8] may overlap up to 4 bytes\" \"strcpy\" } */\n }\n \n /* Exercise strcpy with destination and/or source of unknown lengthu.  */"}, {"sha": "98c9439bbf358eecfeb19870e82e030ccf3cd3e1", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-27.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-27.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wextra -Warray-bounds -Wrestrict\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void* restrict, const void* restrict, size_t);\n+\n+extern void sink (void*, ...);\n+\n+struct Data {\n+  size_t n;\n+  void *p;\n+};\n+\n+void test_copy (void)\n+{\n+  struct Data d;\n+  sink (&d);\n+\n+  char dp1[sizeof d + 1];\n+  char d2x[2 * sizeof d];\n+  char d2xp1[2 * sizeof d + 1];\n+\n+  /* During development the following would incorrectly trigger:\n+     warning: 'memcpy' forming offset [17, 25] is out of the bounds [0, 16]\n+\t      of object \u2018d\u2019 with type 'struct Data' [-Warray-bounds]\n+     that wasn't caught by the test suite.  Make sure it is.  */\n+  memcpy (&dp1, d.p, sizeof dp1);       /* { dg-bogus \"\\\\\\[-Warray-bounds\" } */\n+\n+  /* Likewise.  */\n+  memcpy (&d2x, d.p, sizeof d2x);       /* { dg-bogus \"\\\\\\[-Warray-bounds\" } */\n+  memcpy (&d2xp1, d.p, sizeof d2xp1);   /* { dg-bogus \"\\\\\\[-Warray-bounds\" } */\n+\n+  sink (&d, &dp1, &d2x, &d2xp1);\n+}"}, {"sha": "cc7185f0998967f8aca707340b053adde1ae780b", "filename": "gcc/testsuite/gcc.dg/Wrestrict-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-6.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -21,7 +21,7 @@ void warn_2_smax_p2 (void)\n \n   ptrdiff_t i = UR (2, DIFF_MAX + (size_t)2);\n \n-  strcpy (d, d + i);          /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[2, -\\[0-9\\]+] may overlap up to 2 bytes at offset 2\" } */\n+  strcpy (d, d + i);          /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[2, 7] may overlap up to 2 bytes at offset 2\" } */\n \n   sink (d);\n }\n@@ -47,7 +47,7 @@ void warn_2u_smax_p2 (void)\n \n   size_t i = UR (2, DIFF_MAX + (size_t)2);\n \n-  strcpy (d, d + i);          /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[2, -\\[0-9\\]+] may overlap up to 2 bytes at offset 2\" } */\n+  strcpy (d, d + i);          /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[2, 7] may overlap up to 2 bytes at offset 2\" } */\n \n   sink (d);\n }"}, {"sha": "24946b08c3b91ca59e41b0feb644f0e38c8a5f5c", "filename": "gcc/testsuite/gcc.dg/Wrestrict-8.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-8.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -0,0 +1,116 @@\n+/* PR tree-optimization/84095 - false-positive -Wrestrict warnings for\n+   memcpy within array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wrestrict -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void* restrict, const void* restrict, size_t);\n+\n+#define T(d, s, n)   memcpy (d, s, n)\n+\n+struct S1 { char c; } a8_1[8];\n+\n+void test_1_dim_var (int i, int j)\n+{\n+  /* Variable destination index and constant source index.  */\n+  T (&a8_1[i], &a8_1[0], 1);\n+  T (&a8_1[i], &a8_1[0], 2);\n+  T (&a8_1[i], &a8_1[0], 3);\n+  T (&a8_1[i], &a8_1[0], 4);\n+\n+  T (&a8_1[i], &a8_1[0], 5);    /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[0, 8] and 0 overlaps between 2 and 5 bytes at offset \\\\\\[0, 3\\\\\\]\" } */\n+  T (&a8_1[i], &a8_1[0], 6);    /* { dg-warning \"accessing 6 bytes at offsets \\\\\\[0, 8] and 0 overlaps between 4 and 6 bytes at offset \\\\\\[0, 2\\\\\\]\" } */\n+  T (&a8_1[i], &a8_1[0], 7);    /* { dg-warning \"accessing 7 bytes at offsets \\\\\\[0, 8] and 0 overlaps between 6 and 7 bytes at offset \\\\\\[0, 1\\\\\\]\" } */\n+  T (&a8_1[i], &a8_1[0], 8);    /* { dg-warning \"accessing 8 bytes at offsets \\\\\\[0, 8] and 0 overlaps 8 bytes at offset 0\" } */\n+\n+  /* The following is diagnosed by -Warray-bounds when it's enabled\n+     rather than by -Wrestrict.  */\n+  T (&a8_1[i], &a8_1[0], 9);    /* { dg-warning \"accessing 9 bytes at offsets \\\\\\[0, 8] and 0 overlaps 9 bytes at offset 0\" } */\n+\n+  /* Same as above but with constant destination index and variable\n+     source index.  */\n+  T (&a8_1[0], &a8_1[i], 1);\n+  T (&a8_1[0], &a8_1[i], 2);\n+  T (&a8_1[0], &a8_1[i], 3);\n+  T (&a8_1[0], &a8_1[i], 4);\n+\n+  T (&a8_1[0], &a8_1[i], 5);    /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[0, 8] overlaps between 2 and 5 bytes at offset \\\\\\[0, 3\\\\\\]\" } */\n+  T (&a8_1[0], &a8_1[i], 6);    /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[0, 8] overlaps between 4 and 6 bytes at offset \\\\\\[0, 2\\\\\\]\" } */\n+  T (&a8_1[0], &a8_1[i], 7);    /* { dg-warning \"accessing 7 bytes at offsets 0 and \\\\\\[0, 8] overlaps between 6 and 7 bytes at offset \\\\\\[0, 1\\\\\\]\" } */\n+  T (&a8_1[0], &a8_1[i], 8);    /* { dg-warning \"accessing 8 bytes at offsets 0 and \\\\\\[0, 8] overlaps 8 bytes at offset 0\" } */\n+  T (&a8_1[0], &a8_1[i], 9);    /* { dg-warning \"accessing 9 bytes at offsets 0 and \\\\\\[0, 8] overlaps 9 bytes at offset 0\" } */\n+\n+\n+  /* Variable destination and source indices.  */\n+  T (&a8_1[i], &a8_1[j], 1);\n+  T (&a8_1[i], &a8_1[j], 2);\n+  T (&a8_1[i], &a8_1[j], 3);\n+  T (&a8_1[i], &a8_1[j], 4);\n+\n+  T (&a8_1[i], &a8_1[j], 5);    /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps between 2 and 5 bytes at offset \\\\\\[0, 3\\\\\\]\" } */\n+  T (&a8_1[i], &a8_1[j], 6);    /* { dg-warning \"accessing 6 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps between 4 and 6 bytes at offset \\\\\\[0, 2\\\\\\]\" } */\n+  T (&a8_1[i], &a8_1[j], 7);    /* { dg-warning \"accessing 7 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps between 6 and 7 bytes at offset \\\\\\[0, 1\\\\\\]\" } */\n+  T (&a8_1[i], &a8_1[j], 8);    /* { dg-warning \"accessing 8 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps 8 bytes at offset 0\" } */\n+\n+  /* The following is diagnosed by -Warray-bounds when it's enabled\n+     rather than by -Wrestrict.  */\n+  T (&a8_1[i], &a8_1[j], 9);    /* { dg-warning \"accessing 9 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps 9 bytes at offset 0\" } */\n+}\n+\n+struct S4 { char a4[4]; } a2_4[2];\n+\n+void test_2_dim (int i, int j)\n+{\n+  T (&a2_4[i], &a2_4[0], 1);\n+  T (&a2_4[i], &a2_4[0], 4);\n+\n+  T (&a2_4[i], &a2_4[0], 5);    /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[0, 8] and 0 overlaps between 2 and 5 bytes at offset \\\\\\[0, 3]\" } */\n+  T (&a2_4[i], &a2_4[0], 6);    /* { dg-warning \"accessing 6 bytes at offsets \\\\\\[0, 8] and 0 overlaps between 4 and 6 bytes at offset \\\\\\[0, 2]\" } */\n+  T (&a2_4[i], &a2_4[0], 7);    /* { dg-warning \"accessing 7 bytes at offsets \\\\\\[0, 8] and 0 overlaps between 6 and 7 bytes at offset \\\\\\[0, 1]\" } */\n+  T (&a2_4[i], &a2_4[0], 8);    /* { dg-warning \"accessing 8 bytes at offsets \\\\\\[0, 8] and 0 overlaps 8 bytes at offset 0\" } */\n+\n+  T (a2_4[i].a4, a2_4[0].a4, 1);\n+  T (a2_4[i].a4, a2_4[0].a4, 4);\n+\n+  T (a2_4[i].a4, a2_4[0].a4, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[0, 8] and 0 overlaps between 2 and 5 bytes at offset \\\\\\[0, 3]\" } */\n+  T (a2_4[i].a4, a2_4[0].a4, 8);   /* { dg-warning \"accessing 8 bytes at offsets \\\\\\[0, 8] and 0 overlaps 8 bytes at offset 0\" } */\n+\n+  T (a2_4[i].a4, a2_4[j].a4, 1);\n+  T (a2_4[i].a4, a2_4[j].a4, 4);\n+\n+  /* The destination and source offsets printed below ignore the size\n+     of the copy and only indicate the values that are valid for each\n+     of the destination and source arguments on its own, without\n+     considering the size of the overlapping access.  */\n+  T (a2_4[i].a4, a2_4[j].a4, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps between 2 and 5 bytes at offset \\\\\\[0, 3]\" } */\n+  T (a2_4[i].a4, a2_4[j].a4, 8);   /* { dg-warning \"accessing 8 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps 8 bytes at offset 0\" } */\n+\n+  /* Same as above but referencing the first elements of each array.  */\n+  T (&a2_4[i].a4[0], &a2_4[j].a4[0], 1);\n+  T (&a2_4[i].a4[0], &a2_4[j].a4[0], 4);\n+\n+  T (&a2_4[i].a4[0], &a2_4[j].a4[0], 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps between 2 and 5 bytes at offset \\\\\\[0, 3]\" } */\n+  T (&a2_4[i].a4[0], &a2_4[j].a4[0], 8);   /* { dg-warning \"accessing 8 bytes at offsets \\\\\\[0, 8] and \\\\\\[0, 8] overlaps 8 bytes at offset 0\" } */\n+\n+  T (&a2_4[i].a4[0], &a2_4[j].a4[1], 3);\n+  T (&a2_4[i].a4[0], &a2_4[j].a4[2], 2);\n+  T (&a2_4[i].a4[0], &a2_4[j].a4[3], 1);\n+}\n+\n+struct { int i; } a2[2][8];\n+\n+void test_single_2_dim_major (int i)\n+{\n+  memcpy (&a2[i], &a2[0], sizeof *a2);   /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+}\n+\n+void test_single_2_dim_minor (int i)\n+{\n+  memcpy (&a2[i][0], &a2[0][0], sizeof a2[0][0]);   /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+}\n+\n+void test_single_2_dim_major_minor (int i, int j)\n+{\n+  memcpy (&a2[i][j], &a2[0][0], sizeof a2[0][0]);   /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+}"}, {"sha": "5ad87401ed9969292279abd471f59ffd12699c0c", "filename": "gcc/testsuite/gcc.dg/Wrestrict-9.c", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-9.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -0,0 +1,315 @@\n+/* PR tree-optimization/84095 - false-positive -Wrestrict warnings for\n+   strcpy within array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wrestrict -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void* restrict, const void* restrict, size_t);\n+extern char* strcpy (char* restrict, const char* restrict);\n+\n+#define T(d, s)   strcpy (d, s)\n+\n+struct MemArrays {\n+  char pad[8];\n+  char a2[3][9];\n+  char a3[3][4][9];\n+} a[2];\n+\n+struct NestedMemArrays {\n+  struct MemArrays ma;\n+  struct MemArrays ma1[2];\n+} nma[2];\n+\n+/* Use a variable as the source of a copy to verify that VAR_DECL\n+   is handled correctly when it's the source of GIMPLE assignment.  */\n+const char *str = \"1234567\";\n+\n+void test_obj_2_dim_const (void)\n+{\n+  const char *s = strcpy (a[0].a2[0], \"1234567\");\n+\n+  T (a[0].a2[1], s);\n+  T (a[0].a2[2], s);\n+\n+  /* Ideally, the offsets in the warning below would be relative to\n+     the beginning of the accessed array member.  Unfortunately, when\n+     the offset is represented as\n+     MEM_REF (char[9], A, offsetof (struct MemArrays, A[0].A2[0]) + 1)\n+     as it is in this instance it's difficult to determine the member\n+     that is being accessed and tease out from the MEM_REF the offset\n+     as it appears in the source.  As a result, the warning mentions\n+     the offset from the beginning of A instead.  This is suboptimal\n+     and should be fixed, either by printing the correct offsets or\n+     by mentioning the base object that the offset is relative to.  */\n+  T (a[0].a2[0] + 1, s);      /* { dg-warning \"accessing 8 bytes at offsets \\(1|9\\) and \\(0|8\\) overlaps 7 bytes at offset \\(1|9\\).\" } */\n+  T (a[0].a2[1] + 2, s);\n+  T (a[0].a2[2] + 3, s);\n+\n+  T (a[1].a2[0], s);\n+  T (a[1].a2[1], s);\n+  T (a[1].a2[2], s);\n+\n+  T (a[1].a2[0] + 1, s);\n+  T (a[1].a2[1] + 2, s);\n+  T (a[1].a2[2] + 3, s);\n+}\n+\n+void test_obj_nested_2_dim_const (void)\n+{\n+  const char *s = strcpy (nma[0].ma.a2[0], str);\n+\n+  T (nma[0].ma.a2[1], s);\n+  T (nma[0].ma.a2[2], s);\n+\n+  T (nma[0].ma.a2[0] + 1, s);      /* { dg-warning \"accessing 8 bytes at offsets 1 and 0 overlaps 7 bytes at offset 1\" \"bug \" { xfail *-*-* } } */\n+  T (nma[0].ma.a2[1] + 2, s);\n+  T (nma[0].ma.a2[2] + 3, s);\n+\n+  T (nma[1].ma.a2[1], s);\n+  T (nma[1].ma.a2[2], s);\n+\n+  T (nma[1].ma.a2[0] + 1, s);\n+  T (nma[1].ma.a2[1] + 2, s);\n+  T (nma[1].ma.a2[2] + 3, s);\n+\n+\n+  T (nma[0].ma1[0].a2[1], s);\n+  T (nma[0].ma1[0].a2[2], s);\n+\n+  T (nma[0].ma1[0].a2[0] + 1, s);\n+  T (nma[0].ma1[0].a2[1] + 2, s);\n+  T (nma[0].ma1[0].a2[2] + 3, s);\n+\n+  T (nma[1].ma1[0].a2[1], s);\n+  T (nma[1].ma1[0].a2[2], s);\n+\n+  T (nma[1].ma1[0].a2[0] + 1, s);\n+  T (nma[1].ma1[0].a2[1] + 2, s);\n+  T (nma[1].ma1[0].a2[2] + 3, s);\n+}\n+\n+void test_obj_2_dim_var (int i, int j)\n+{\n+  const char *s = memcpy (a[0].a2[0], \"1234567\", 8);\n+\n+  T (a[i].a2[0], s);          /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+  T (a[i].a2[1], s);\n+  T (a[i].a2[2], s);\n+\n+  T (a[i].a2[0] + 1, s);\n+  T (a[i].a2[1] + 1, s);\n+  T (a[i].a2[2] + 1, s);\n+\n+  T (a[0].a2[i], s);          /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+  T (a[1].a2[i], s);\n+\n+  T (a[i].a2[0] + j, s);\n+  T (a[i].a2[1] + j, s);\n+  T (a[i].a2[2] + j, s);\n+\n+  T (a[0].a2[i] + 1, s);\n+  T (a[1].a2[i] + 1, s);\n+\n+  T (a[0].a2[i] + j, s);\n+  T (a[1].a2[i] + j, s);\n+\n+  if (i < 0 || 1 < i)\n+    i = 1;\n+\n+  T (a[i].a2[0], s);\n+  T (a[i].a2[1], s);\n+  T (a[i].a2[2], s);\n+\n+  T (a[i].a2[0] + 1, s);\n+  T (a[i].a2[1] + 1, s);\n+  T (a[i].a2[2] + 1, s);\n+\n+  T (a[0].a2[i], s);\n+  T (a[1].a2[i], s);\n+\n+  T (a[i].a2[0] + j, s);\n+  T (a[i].a2[1] + j, s);\n+  T (a[i].a2[2] + j, s);\n+\n+  T (a[0].a2[i] + 1, s);\n+  T (a[1].a2[i] + 1, s);\n+\n+  T (a[0].a2[i] + j, s);\n+  T (a[1].a2[i] + j, s);\n+}\n+\n+void test_obj_nested_2_dim_var (int i, int j)\n+{\n+  const char *s = strcpy (nma[0].ma.a2[0], \"1234567\");\n+\n+  T (nma[i].ma.a2[0], s);     /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+  T (nma[i].ma.a2[1], s);\n+  T (nma[i].ma.a2[2], s);\n+\n+  T (nma[i].ma.a2[0] + 1, s);\n+  T (nma[i].ma.a2[1] + 1, s);\n+  T (nma[i].ma.a2[2] + 1, s);\n+\n+  T (nma[0].ma.a2[i], s);     /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+  T (nma[1].ma.a2[i], s);\n+\n+  T (nma[i].ma.a2[0] + j, s);\n+  T (nma[i].ma.a2[1] + j, s);\n+  T (nma[i].ma.a2[2] + j, s);\n+\n+  T (nma[0].ma.a2[i] + 1, s);\n+  T (nma[1].ma.a2[i] + 1, s);\n+\n+  T (nma[0].ma.a2[i] + j, s);\n+  T (nma[1].ma.a2[i] + j, s);\n+}\n+\n+void test_ref_2_dim_const (struct MemArrays *p)\n+{\n+  strcpy (p[0].a2[0], \"1234567\");\n+  const char *s = p[0].a2[0];\n+\n+  T (p[0].a2[1], s);\n+  T (p[0].a2[2], s);\n+\n+  T (p[1].a2[0], s);\n+  T (p[1].a2[1], s);\n+  T (p[1].a2[2], s);\n+}\n+\n+void test_ref_2_dim_var (struct MemArrays *p, int i, int j)\n+{\n+  strcpy (p[0].a2[0], \"1234567\");\n+  const char *s = p[0].a2[0];\n+\n+  T (p[i].a2[0], s);          /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+  T (p[i].a2[1], s);\n+  T (p[i].a2[2], s);\n+\n+  T (p[0].a2[i], s);\n+  T (p[1].a2[i], s);\n+\n+  T (p[i].a2[0] + j, s);\n+  T (p[i].a2[1] + j, s);\n+  T (p[i].a2[2] + j, s);\n+\n+  T (p[0].a2[i] + j, s);\n+  T (p[1].a2[i] + j, s);\n+}\n+\n+void test_obj_3_dim_var (int i, int j)\n+{\n+  strcpy (a[0].a3[0][0], \"1234567\");\n+  const char *s = a[0].a3[0][0];\n+\n+  T (a[0].a3[0][i], s);\n+  T (a[0].a3[1][i], s);\n+  T (a[0].a3[2][i], s);\n+\n+  T (a[1].a3[0][i], s);\n+  T (a[1].a3[1][i], s);\n+  T (a[1].a3[2][i], s);\n+\n+  T (a[0].a3[i][0], s);       /* { dg-bogus \"\\\\\\[-Wrestrict\\]\" } */\n+  T (a[0].a3[i][1], s);\n+  T (a[0].a3[i][2], s);\n+\n+  T (a[1].a3[i][0], s);\n+  T (a[1].a3[i][1], s);\n+  T (a[1].a3[i][2], s);\n+\n+  T (a[i].a3[0][0], s);       /* { dg-bogus \"\\\\\\[-Wrestrict\\]\" } */\n+  T (a[i].a3[0][1], s);\n+  T (a[i].a3[0][2], s);\n+\n+  T (a[i].a3[1][0], s);\n+  T (a[i].a3[1][1], s);\n+  T (a[i].a3[1][2], s);\n+\n+  T (a[i].a3[2][0], s);\n+  T (a[i].a3[2][1], s);\n+  T (a[i].a3[2][2], s);\n+\n+\n+  T (a[0].a3[0][i] + 1, s);\n+  T (a[0].a3[1][i] + 1, s);\n+  T (a[0].a3[2][i] + 1, s);\n+\n+  T (a[1].a3[0][i] + 1, s);\n+  T (a[1].a3[1][i] + 1, s);\n+  T (a[1].a3[2][i] + 1, s);\n+\n+\n+  T (a[0].a3[0][i] + j, s);\n+  T (a[0].a3[1][i] + j, s);\n+  T (a[0].a3[2][i] + j, s);\n+\n+  T (a[1].a3[0][i] + j, s);\n+  T (a[1].a3[1][i] + j, s);\n+  T (a[1].a3[2][i] + j, s);\n+\n+  T (a[0].a3[i][0] + j, s);\n+  T (a[0].a3[i][1] + j, s);\n+  T (a[0].a3[i][2] + j, s);\n+\n+  T (a[1].a3[i][0] + j, s);\n+  T (a[1].a3[i][1] + j, s);\n+  T (a[1].a3[i][2] + j, s);\n+\n+  T (a[i].a3[0][0] + j, s);\n+  T (a[i].a3[0][1] + j, s);\n+  T (a[i].a3[0][2] + j, s);\n+\n+  T (a[i].a3[1][0] + j, s);\n+  T (a[i].a3[1][1] + j, s);\n+  T (a[i].a3[1][2] + j, s);\n+\n+  T (a[i].a3[2][0] + j, s);\n+  T (a[i].a3[2][1] + j, s);\n+  T (a[i].a3[2][2] + j, s);\n+}\n+\n+void test_obj_3_dim_const (struct MemArrays *p)\n+{\n+  strcpy (p[0].a3[0][0], \"1234567\");\n+  const char *s = p[0].a3[0][0];\n+\n+  T (p[0].a3[0][1], s);\n+  T (p[0].a3[0][2], s);\n+  T (p[0].a3[0][3], s);\n+\n+  T (p[0].a3[0][1] + 1, s);\n+  T (p[0].a3[0][2] + 1, s);\n+  T (p[0].a3[0][3] + 1, s);\n+\n+  T (p[0].a3[1][0], s);\n+  T (p[0].a3[1][1], s);\n+  T (p[0].a3[1][2], s);\n+  T (p[0].a3[1][3], s);\n+\n+  T (p[0].a3[1][0] + 1, s);\n+  T (p[0].a3[1][1] + 1, s);\n+  T (p[0].a3[1][2] + 1, s);\n+  T (p[0].a3[1][3] + 1, s);\n+\n+  T (p[0].a3[2][0], s);\n+  T (p[0].a3[2][1], s);\n+  T (p[0].a3[2][2], s);\n+  T (p[0].a3[2][3], s);\n+\n+  T (p[1].a3[0][0], s);\n+  T (p[1].a3[0][1], s);\n+  T (p[1].a3[0][2], s);\n+  T (p[1].a3[0][3], s);\n+\n+  T (p[1].a3[1][0], s);\n+  T (p[1].a3[1][1], s);\n+  T (p[1].a3[1][2], s);\n+  T (p[1].a3[1][3], s);\n+\n+  T (p[1].a3[2][0], s);\n+  T (p[1].a3[2][1], s);\n+  T (p[1].a3[2][2], s);\n+  T (p[1].a3[2][3], s);\n+}"}, {"sha": "af2bc0e3f258c0103fa0de04aaaac10fde7a1cf1", "filename": "gcc/testsuite/gcc.dg/pr84095.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84095.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e27f0d5d54d83e13d8b845b965b96fd10706f46/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84095.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84095.c?ref=5e27f0d5d54d83e13d8b845b965b96fd10706f46", "patch": "@@ -0,0 +1,14 @@\n+/* PR tree-optimization/84095 - false-positive -Wrestrict warnings for\n+   memcpy within array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wrestrict\" } */\n+\n+struct { int i; } a[8];\n+\n+void f (void)\n+{\n+  int i;\n+\n+  for (i = 1; i < 8; i++)\n+    __builtin_memcpy (&a[i], &a[0], sizeof(a[0]));   /* { dg-bogus \"\\\\\\[-Wrestrict]\" } */\n+}"}]}