{"sha": "b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhlYzU3NjQxOWU4ZGQxZTMzNWRkMTZkMjJhMGNkN2E5YjE4NjVlMA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2001-08-30T20:44:51Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2001-08-30T20:44:51Z"}, "message": "rtl.def: Undo my patch commited 2001-08-27.\n\n2001-08-30  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* rtl.def: Undo my patch commited 2001-08-27.\n\n\t* genattrtab.c: Ditto.\n\n\t* rtl.h: Ditto.\n\n\t* sched-int.h: Ditto.\n\n\t* target-def.h: Ditto.\n\n\t* target.h: Ditto.\n\n\t* haifa-sched.c: Ditto.\n\n\t* sched-rgn.c: Ditto.\n\n\t* sched-vis.c: Ditto.\n\n\t* Makefile.in: Ditto.\n\n\t* doc/md.texi: Ditto.\n\n\t* doc/tm.texi: Ditto.\n\n\t* doc/contrib.texi: Ditto.\n\n\t* doc/gcc.texi: Ditto.\n\n\t* genattrtab.h: Remove it.\n\n\t* genautomata.c: Remove it.\n\n\t* genattr.c: Undo my patch and Richard Henderson's patch commited\n\t2001-08-27.\n\nFrom-SVN: r45297", "tree": {"sha": "9cc1dc4a63e4c3af0ab3e68c017e773ea05dec6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cc1dc4a63e4c3af0ab3e68c017e773ea05dec6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e4302ec5b8658dbbed93bc09cf45b52aa94766c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4302ec5b8658dbbed93bc09cf45b52aa94766c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e4302ec5b8658dbbed93bc09cf45b52aa94766c"}], "stats": {"total": 10745, "additions": 248, "deletions": 10497}, "files": [{"sha": "a803fef3cdfd7018d0068e1c5a6d0f2b3fec3684", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -1,3 +1,40 @@\n+2001-08-30  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* rtl.def: Undo my patch commited 2001-08-27.\n+\n+\t* genattrtab.c: Ditto.\n+\n+\t* rtl.h: Ditto.\n+\n+\t* sched-int.h: Ditto.\n+\n+\t* target-def.h: Ditto.\n+\n+\t* target.h: Ditto.\n+\n+\t* haifa-sched.c: Ditto.\n+\n+\t* sched-rgn.c: Ditto.\n+\n+\t* sched-vis.c: Ditto.\n+\n+\t* Makefile.in: Ditto.\n+\n+\t* doc/md.texi: Ditto.\n+\n+\t* doc/tm.texi: Ditto.\n+\n+\t* doc/contrib.texi: Ditto.\n+\n+\t* doc/gcc.texi: Ditto.\n+\n+\t* genattrtab.h: Remove it.\n+\n+\t* genautomata.c: Remove it.\n+\n+\t* genattr.c: Undo my patch and Richard Henderson's patch commited\n+\t2001-08-27.\n+\n Thu Aug 30 19:22:15 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* config.gcc (h8300-*-elf*): New case."}, {"sha": "90a1834a30f508c8db7c0bdeb849f76297f9cd3e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -346,10 +346,6 @@ INTL_SUBDIRS = intl $(POSUB)\n # system library.\n OBSTACK=obstack.o\n \n-# The following object files is used by genautomata.\n-GETRUNTIME = getruntime.o\n-HASHTAB = hashtab.o\n-\n # The GC method to be used on this system.\n GGC=@GGC@.o\n \n@@ -486,8 +482,6 @@ HOST_CPPFLAGS=$(ALL_CPPFLAGS)\n HOST_OBSTACK=$(OBSTACK)\n HOST_VFPRINTF=$(VFPRINTF)\n HOST_DOPRINT=$(DOPRINT)\n-HOST_GETRUNTIME=$(GETRUNTIME)\n-HOST_HASHTAB=$(HASHTAB)\n HOST_STRSTR=$(STRSTR)\n \n # Actual name to use when installing a native compiler.\n@@ -615,8 +609,6 @@ ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n USE_HOST_OBSTACK= ` case \"${HOST_OBSTACK}\" in ?*) echo ${HOST_PREFIX}${HOST_OBSTACK} ;; esac `\n USE_HOST_VFPRINTF= ` case \"${HOST_VFPRINTF}\" in ?*) echo ${HOST_PREFIX}${HOST_VFPRINTF} ;; esac `\n USE_HOST_DOPRINT= ` case \"${HOST_DOPRINT}\" in ?*) echo ${HOST_PREFIX}${HOST_DOPRINT} ;; esac `\n-USE_HOST_GETRUNTIME= ` case \"${HOST_GETRUNTIME}\" in ?*) echo ${HOST_PREFIX}${HOST_GETRUNTIME} ;; esac `\n-USE_HOST_HASHTAB= ` case \"${HOST_HASHTAB}\" in ?*) echo ${HOST_PREFIX}${HOST_HASHTAB} ;; esac `\n USE_HOST_STRSTR= ` case \"${HOST_STRSTR}\" in ?*) echo ${HOST_PREFIX}${HOST_STRSTR} ;; esac `\n \n # Dependency on obstack or whatever library facilities\n@@ -645,7 +637,6 @@ HOST_RTL = $(HOST_PREFIX)rtl.o read-rtl.o $(HOST_PREFIX)bitmap.o \\\n \n HOST_PRINT = $(HOST_PREFIX)print-rtl.o\n HOST_ERRORS = $(HOST_PREFIX)errors.o\n-HOST_VARRAY = $(HOST_PREFIX)varray.o\n \n # Specify the directories to be searched for header files.\n # Both . and srcdir are used, in that order,\n@@ -1342,11 +1333,6 @@ obstack.o: $(srcdir)/../libiberty/obstack.c $(GCONFIG_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\tobstack.c $(OUTPUT_OPTION)\n \n-getruntime.o: $(srcdir)/../libiberty/getruntime.c $(CONFIG_H)\n-\trm -f getruntime.c\n-\t$(LN_S) $(srcdir)/../libiberty/getruntime.c getruntime.c\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) getruntime.c\n-\n prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) Makefile prefix.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t-DPREFIX=\\\"$(prefix)\\\" \\\n@@ -1547,13 +1533,12 @@ sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h $(PARAMS_H) $(TM_P_H)\n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n-   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)\n+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H)\n sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H)\n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n-   hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(REGS_H) $(TM_P_H) \\\n-   $(TARGET_H)\n+   hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(REGS_H) $(TM_P_H)\n final.o : final.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) function.h \\\n    real.h output.h hard-reg-set.h except.h debug.h xcoffout.h \\\n@@ -1857,18 +1842,14 @@ genattr$(build_exeext) : genattr.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HO\n genattr.o : genattr.c $(RTL_H) $(HCONFIG_H) $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattr.c\n \n-genattrtab$(build_exeext) : genattrtab.o genautomata.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_VARRAY) $(HOST_PREFIX)$(HOST_GETRUNTIME) $(HOST_LIBDEPS)\n+genattrtab$(build_exeext) : genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genattrtab.o genautomata.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_VARRAY) $(USE_HOST_GETRUNTIME) $(HOST_LIBS) -lm\n+\t genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n \n genattrtab.o : genattrtab.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n-  $(SYSTEM_H) errors.h $(GGC_H) gensupport.h genattrtab.h\n+  $(SYSTEM_H) errors.h $(GGC_H) gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattrtab.c\n \n-genautomata.o : genautomata.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n-  $(SYSTEM_H) errors.h varray.h hash.h genattrtab.h\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genautomata.c\n-\n genoutput$(build_exeext) : genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n \t genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n@@ -1919,16 +1900,6 @@ $(HOST_PREFIX_1)obstack.o: $(srcdir)/../libiberty/obstack.c $(HCONFIG_H)\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/obstack.c > $(HOST_PREFIX)obstack.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)obstack.c\n \n-$(HOST_PREFIX_1)getruntime.o: $(srcdir)/../libiberty/getruntime.c\n-\trm -f $(HOST_PREFIX)getruntime.c\n-\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/getruntime.c > $(HOST_PREFIX)getruntime.c\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)getruntime.c\n-\n-$(HOST_PREFIX_1)hashtab.o: $(srcdir)/../libiberty/hashtab.c\n-\trm -f $(HOST_PREFIX)hashtab.c\n-\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/hashtab.c > $(HOST_PREFIX)hashtab.c\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)hashtab.c\n-\n $(HOST_PREFIX_1)vfprintf.o: $(srcdir)/../libiberty/vfprintf.c $(HCONFIG_H)\n \trm -f $(HOST_PREFIX)vfprintf.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/vfprintf.c > $(HOST_PREFIX)vfprintf.c"}, {"sha": "caaf15b6232bc3357003a743043cb7632a13761f", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -313,10 +313,9 @@ Andrew MacLeod for his ongoing work in building a real EH system,\n various code generation improvements, work on the global optimizer, etc.\n \n @item\n-Vladimir Makarov for hacking some ugly i960 problems, PowerPC hacking\n-improvements to compile-time performance, overall knowledge and\n-direction in the area of instruction scheduling, and design and\n-implementation of the automaton based instruction scheduler.\n+Vladimir Makarov for hacking some ugly i960 problems, PowerPC\n+hacking improvements to compile-time performance and overall knowledge\n+and direction in the area of instruction scheduling.\n \n @item\n Bob Manson for his behind the scenes work on dejagnu."}, {"sha": "befee3643bbb4d01066ca188ac260968c80afc59", "filename": "gcc/doc/gcc.texi", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc.texi?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -3826,10 +3826,8 @@ Several passes use instruction attributes.  A definition of the\n attributes defined for a particular machine is in file\n @file{insn-attr.h}, which is generated from the machine description by\n the program @file{genattr}.  The file @file{insn-attrtab.c} contains\n-subroutines to obtain the attribute values for insns and information\n-about processor pipeline characteristics for the instruction scheduler.\n-It is generated from the machine description by the program\n-@file{genattrtab}.\n+subroutines to obtain the attribute values for insns.  It is generated\n+from the machine description by the program @file{genattrtab}.\n @end itemize\n @end ifset\n "}, {"sha": "f2e7b8fd604a2c53bf735cb9fd4dda0c342b8fb3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 25, "deletions": 482, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -3676,14 +3676,13 @@ in the compiler.\n @cindex instruction splitting\n @cindex splitting instructions\n \n-There are two cases where you should specify how to split a pattern\n-into multiple insns.  On machines that have instructions requiring\n-delay slots (@pxref{Delay Slots}) or that have instructions whose\n-output is not available for multiple cycles (@pxref{Processor pipeline\n-description}), the compiler phases that optimize these cases need to\n-be able to move insns into one-instruction delay slots.  However, some\n-insns may generate more than one machine instruction.  These insns\n-cannot be placed into a delay slot.\n+There are two cases where you should specify how to split a pattern into\n+multiple insns.  On machines that have instructions requiring delay\n+slots (@pxref{Delay Slots}) or that have instructions whose output is\n+not available for multiple cycles (@pxref{Function Units}), the compiler\n+phases that optimize these cases need to be able to move insns into\n+one-instruction delay slots.  However, some insns may generate more than one\n+machine instruction.  These insns cannot be placed into a delay slot.\n \n Often you can rewrite the single insn as a list of individual insns,\n each corresponding to one machine instruction.  The disadvantage of\n@@ -4228,7 +4227,7 @@ to track the condition codes.\n * Insn Lengths::        Computing the length of insns.\n * Constant Attributes:: Defining attributes that are constant.\n * Delay Slots::         Defining delay slots required for a machine.\n-* Processor pipeline description:: Specifying information for insn scheduling.\n+* Function Units::      Specifying information for insn scheduling.\n @end menu\n \n @node Defining Attributes\n@@ -4858,101 +4857,14 @@ branch is true, we might represent this as follows:\n @end smallexample\n @c the above is *still* too long.  --mew 4feb93\n \n-@node Processor pipeline description\n-@subsection Specifying processor pipeline description\n-@cindex processor pipeline description\n-@cindex processor functional units\n-@cindex instruction latency time\n-@cindex interlock delays\n-@cindex data dependence delays\n-@cindex reservation delays\n-@cindex pipeline hazard recognizer\n-@cindex automaton based pipeline description\n-@cindex regular expressions\n-@cindex deterministic finite state automaton\n-@cindex automaton based scheduler\n-@cindex RISC\n-@cindex VLIW\n-\n-To achieve better productivity most modern processors\n-(super-pipelined, superscalar @acronym{RISC}, and @acronym{VLIW}\n-processors) have many @dfn{functional units} on which several\n-instructions can be executed simultaneously.  An instruction starts\n-execution if its issue conditions are satisfied.  If not, the\n-instruction is interlocked until its conditions are satisfied.  Such\n-@dfn{interlock (pipeline) delay} causes interruption of the fetching\n-of successor instructions (or demands nop instructions, e.g. for some\n-MIPS processors).\n-\n-There are two major kinds of interlock delays in modern processors.\n-The first one is a data dependence delay determining @dfn{instruction\n-latency time}.  The instruction execution is not started until all\n-source data have been evaluated by prior instructions (there are more\n-complex cases when the instruction execution starts even when the data\n-are not availaible but will be ready in given time after the\n-instruction execution start).  Taking the data dependence delays into\n-account is simple.  The data dependence (true, output, and\n-anti-dependence) delay between two instructions is given by a\n-constant.  In most cases this approach is adequate.  The second kind\n-of interlock delays is a reservation delay.  The reservation delay\n-means that two instructions under execution will be in need of shared\n-processors resources, i.e. buses, internal registers, and/or\n-functional units, which are reserved for some time.  Taking this kind\n-of delay into account is complex especially for modern @acronym{RISC}\n-processors.\n-\n-The task of exploiting more processor parallelism is solved by an\n-instruction scheduler.  For better solution of this problem, the\n-instruction scheduler has to have an adequate description of the\n-processor parallelism (or @dfn{pipeline description}).  Currently GCC\n-has two ways to describe processor parallelism.  The first one is old\n-and originated from instruction scheduler written by Michael Tiemann\n-and described in the first subsequent section.  The second one was\n-created later.  It is based on description of functional unit\n-reservations by processor instructions with the aid of @dfn{regular\n-expressions}.  This is so called @dfn{automaton based description}.\n-\n-Gcc instruction scheduler uses a @dfn{pipeline hazard recognizer} to\n-figure out the possibility of the instruction issue by the processor\n-on given simulated processor cycle.  The pipeline hazard recognizer is\n-a code generated from the processor pipeline description.  The\n-pipeline hazard recognizer generated from the automaton based\n-description is more sophisticated and based on deterministic finite\n-state automaton (@acronym{DFA}) and therefore faster than one\n-generated from the old description.  Also its speed is not depended on\n-processor complexity.  The instruction issue is possible if there is\n-a transition from one automaton state to another one.\n-\n-You can use any model to describe processor pipeline characteristics\n-or even a mix of them.  You could use the old description for some\n-processor submodels and the @acronym{DFA}-based one for the rest\n-processor submodels.\n-\n-In general, the usage of the automaton based description is more\n-preferable.  Its model is more rich.  It permits to describe more\n-accurately pipeline characteristics of processors which results in\n-improving code quality (although sometimes only on several percent\n-fractions).  It will be also used as an infrastructure to implement\n-sophisticated and practical insn scheduling which will try many\n-instruction sequences to choose the best one.\n-\n-\n-@menu\n-* Old pipeline description:: Specifying information for insn scheduling.\n-* Automaton pipeline description:: Describing insn pipeline characteristics.\n-* Comparison of the two descriptions:: Drawbacks of the old pipeline description\n-@end menu\n-\n-@node Old pipeline description\n-@subsubsection Specifying Function Units\n-@cindex old pipeline description\n+@node Function Units\n+@subsection Specifying Function Units\n @cindex function units, for scheduling\n \n-On most @acronym{RISC} machines, there are instructions whose results\n-are not available for a specific number of cycles.  Common cases are\n-instructions that load data from memory.  On many machines, a pipeline\n-stall will result if the data is referenced too soon after the load\n-instruction.\n+On most RISC machines, there are instructions whose results are not\n+available for a specific number of cycles.  Common cases are instructions\n+that load data from memory.  On many machines, a pipeline stall will result\n+if the data is referenced too soon after the load instruction.\n \n In addition, many newer microprocessors have multiple function units, usually\n one for integer and one for floating point, and often will incur pipeline\n@@ -4966,14 +4878,13 @@ due to function unit conflicts.\n \n For the purposes of the specifications in this section, a machine is\n divided into @dfn{function units}, each of which execute a specific\n-class of instructions in first-in-first-out order.  Function units\n-that accept one instruction each cycle and allow a result to be used\n-in the succeeding instruction (usually via forwarding) need not be\n-specified.  Classic @acronym{RISC} microprocessors will normally have\n-a single function unit, which we can call @samp{memory}.  The newer\n-``superscalar'' processors will often have function units for floating\n-point operations, usually at least a floating point adder and\n-multiplier.\n+class of instructions in first-in-first-out order.  Function units that\n+accept one instruction each cycle and allow a result to be used in the\n+succeeding instruction (usually via forwarding) need not be specified.\n+Classic RISC microprocessors will normally have a single function unit,\n+which we can call @samp{memory}.  The newer ``superscalar'' processors\n+will often have function units for floating point operations, usually at\n+least a floating point adder and multiplier.\n \n @findex define_function_unit\n Each usage of a function units by a class of insns is specified with a\n@@ -5036,10 +4947,10 @@ Typical uses of this vector are where a floating point function unit can\n pipeline either single- or double-precision operations, but not both, or\n where a memory unit can pipeline loads, but not stores, etc.\n \n-As an example, consider a classic @acronym{RISC} machine where the\n-result of a load instruction is not available for two cycles (a single\n-``delay'' instruction is required) and where only one load instruction\n-can be executed simultaneously.  This would be specified as:\n+As an example, consider a classic RISC machine where the result of a\n+load instruction is not available for two cycles (a single ``delay''\n+instruction is required) and where only one load instruction can be executed\n+simultaneously.  This would be specified as:\n \n @smallexample\n (define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n@@ -5064,374 +4975,6 @@ units.  These insns will cause a potential conflict for the second unit\n used during their execution and there is no way of representing that\n conflict.  We welcome any examples of how function unit conflicts work\n in such processors and suggestions for their representation.\n-\n-@node Automaton pipeline description\n-@subsubsection Describing instruction pipeline characteristics\n-@cindex automaton based pipeline description\n-\n-This section describes constructions of the automaton based processor\n-pipeline description.  The order of all mentioned below constructions\n-in the machine description file is not important.\n-\n-@findex define_automaton\n-@cindex pipeline hazard recognizer\n-The following optional construction describes names of automata\n-generated and used for the pipeline hazards recognition.  Sometimes\n-the generated finite state automaton used by the pipeline hazard\n-recognizer is large.  If we use more one automaton and bind functional\n-units to the automata, the summary size of the automata usually is\n-less than the size of the single automaton.  If there is no one such\n-construction, only one finite state automaton is generated.\n-\n-@smallexample\n-(define_automaton @var{automata-names})\n-@end smallexample\n-\n-@var{automata-names} is a string giving names of the automata.  The\n-names are separated by commas.  All the automata should have unique names.\n-The automaton name is used in construction @code{define_cpu_unit} and\n-@code{define_query_cpu_unit}.\n-\n-@findex define_cpu_unit\n-@cindex processor functional units\n-Each processor functional unit used in description of instruction\n-reservations should be described by the following construction.\n-\n-@smallexample\n-(define_cpu_unit @var{unit-names} [@var{automaton-name}])\n-@end smallexample\n-\n-@var{unit-names} is a string giving the names of the functional units\n-separated by commas.  Don't use name @samp{nothing}, it is reserved\n-for other goals.\n-\n-@var{automaton-name} is a string giving the name of automaton with\n-which the unit is bound.  The automaton should be described in\n-construction @code{define_automaton}.  You should give\n-@dfn{automaton-name}, if there is a defined automaton.\n-\n-@findex define_query_cpu_unit\n-@cindex querying function unit reservations\n-The following construction describes CPU functional units analogously\n-to @code{define_cpu_unit}.  If we use automata without their\n-minimization, the reservation of such units can be queried for an\n-automaton state.  The instruction scheduler never queries reservation\n-of functional units for given automaton state.  So as a rule, you\n-don't need this construction.  This construction could be used for\n-future code generation goals (e.g. to generate @acronym{VLIW} insn\n-templates).\n-\n-@smallexample\n-(define_query_cpu_unit @var{unit-names} [@var{automaton-name}])\n-@end smallexample\n-\n-@var{unit-names} is a string giving names of the functional units\n-separated by commas.\n-\n-@var{automaton-name} is a string giving name of the automaton with\n-which the unit is bound.\n-\n-@findex define_insn_reservation\n-@cindex instruction latency time\n-@cindex regular expressions\n-@cindex data bypass\n-The following construction is major one to describe pipeline\n-characteristics of an instruction.\n-\n-@smallexample\n-(define_insn_reservation @var{insn-name} @var{default_latency}\n-                         @var{condition} @var{regexp})\n-@end smallexample\n-\n-@var{default_latency} is a number giving latency time of the\n-instruction.\n-\n-@var{insn-names} is a string giving internal name of the insn.  The\n-internal names are used in constructions @code{define_bypass} and in\n-the automaton description file generated for debugging.  The internal\n-name has nothing common with the names in @code{define_insn}.  It is a\n-good practice to use insn classes described in the processor manual.\n-\n-@var{condition} defines what RTL insns are described by this\n-construction.\n-\n-@var{regexp} is a string describing reservation of the cpu functional\n-units by the instruction.  The reservations are described by a regular\n-expression according to the following syntax:\n-\n-@smallexample\n-       regexp = regexp \",\" oneof\n-              | oneof\n-\n-       oneof = oneof \"|\" allof\n-             | allof\n-\n-       allof = allof \"+\" repeat\n-             | repeat\n- \n-       repeat = element \"*\" number\n-              | element\n-\n-       element = cpu_function_unit_name\n-               | reservation_name\n-               | result_name\n-               | \"nothing\"\n-               | \"(\" regexp \")\"\n-@end smallexample\n-\n-@itemize @bullet\n-@item\n-@samp{,} is used for describing the start of the next cycle in\n-the reservation.\n-\n-@item\n-@samp{|} is used for describing a reservation described by the first\n-regular expression @strong{or} a reservation described by the second\n-regular expression @strong{or} etc.\n-\n-@item\n-@samp{+} is used for describing a reservation described by the first\n-regular expression @strong{and} a reservation described by the\n-second regular expression @strong{and} etc.\n-\n-@item\n-@samp{*} is used for convenience and simply means a sequence in which\n-the regular expression are repeated @var{number} times with cycle\n-advancing (see @samp{,}).\n-\n-@item\n-@samp{cpu_function_unit_name} denotes reservation of the named\n-functional unit.\n-\n-@item\n-@samp{reservation_name} --- see description of construction\n-@samp{define_reservation}.\n-\n-@item\n-@samp{nothing} denotes no unit reservations.\n-@end itemize\n-\n-@findex define_reservation\n-Sometimes unit reservations for different insns contain common parts.\n-In such case, you can simplify the pipeline description by describing\n-the common part by the following construction\n-\n-@smallexample\n-(define_reservation @var{reservation-name} @var{regexp})\n-@end smallexample\n-\n-@var{reservation-name} is a string giving name of @var{regexp}.\n-Functional unit names and reservation names are in the same name\n-space.  So the reservation names should be different from the\n-functional unit names and can not be reserved name @samp{nothing}.\n-\n-@findex define_bypass\n-@cindex instruction latency time\n-@cindex data bypass\n-The following construction is used to describe exceptions in the\n-latency time for given instruction pair.  This is so called bypasses.\n-\n-@smallexample\n-(define_bypass @var{number} @var{out_insn_names} @var{in_insn_names}\n-               [@var{guard}])\n-@end smallexample\n-\n-@var{number} defines when the result generated by the instructions\n-given in string @var{out_insn_names} will be ready for the\n-instructions given in string @var{in_insn_names}.  The instructions in\n-the string are separated by commas.\n-\n-@var{guard} is an optional string giving name of a C function which\n-defines an additional guard for the bypass.  The function will get the\n-two insns as parameters.  If the function returns zero the bypass will\n-be ignored for this case.  The additional guard is necessary to\n-recognize complicated bypasses, e.g. when consumer is only an address\n-of insn @samp{store} (not a stored value).\n-\n-@findex exclusion_set\n-@findex presence_set\n-@findex absence_set\n-@cindex VLIW\n-@cindex RISC\n-Usually the following three constructions are used to describe\n-@acronym{VLIW} processors (more correctly to describe a placement of\n-small insns into @acronym{VLIW} insn slots).  Although they can be\n-used for @acronym{RISC} processors too.\n-\n-@smallexample\n-(exclusion_set @var{unit-names} @var{unit-names})\n-(presence_set @var{unit-names} @var{unit-names})\n-(absence_set @var{unit-names} @var{unit-names})\n-@end smallexample\n-\n-@var{unit-names} is a string giving names of functional units\n-separated by commas.\n-\n-The first construction (@samp{exclusion_set}) means that each\n-functional unit in the first string can not be reserved simultaneously\n-with a unit whose name is in the second string and vice versa.  For\n-example, the construction is useful for describing processors\n-(e.g. some SPARC processors) with a fully pipelined floating point\n-functional unit which can execute simultaneously only single floating\n-point insns or only double floating point insns.\n-\n-The second construction (@samp{presence_set}) means that each\n-functional unit in the first string can not be reserved unless at\n-least one of units whose names are in the second string is reserved.\n-This is an asymmetric relation.  For example, it is useful for\n-description that @acronym{VLIW} @samp{slot1} is reserved after\n-@samp{slot0} reservation.\n-\n-The third construction (@samp{absence_set}) means that each functional\n-unit in the first string can be reserved only if each unit whose name\n-is in the second string is not reserved.  This is an asymmetric\n-relation (actually @samp{exclusion_set} is analogous to this one but\n-it is symmetric).  For example, it is useful for description that\n-@acronym{VLIW} @samp{slot0} can not be reserved after @samp{slot1} or\n-@samp{slot2} reservation.\n-\n-@findex automata_option\n-@cindex deterministic finite state automaton\n-@cindex nondeterministic finite state automaton\n-@cindex finite state automaton minimization\n-You can control the generator of the pipeline hazard recognizer with\n-the following construction.\n-\n-@smallexample\n-(automata_option @var{options})\n-@end smallexample\n-\n-@var{options} is a string giving options which affect the generated\n-code.  Currently there are the following options:\n-\n-@itemize @bullet\n-@item\n-@dfn{no-minimization} makes no minimization of the automaton.  This is\n-only worth to do when we are going to query CPU functional unit\n-reservations in an automaton state.\n-\n-@item\n-@dfn{w} means a generation of the file describing the result\n-automaton.  The file can be used to verify the description.\n-\n-@item\n-@dfn{ndfa} makes nondeterministic finite state automata.  This affects\n-the treatment of operator @samp{|} in the regular expressions.  The\n-usual treatment of the operator is to try the first alternative and,\n-if the reservation is not possible, the second alternative.  The\n-nondeterministic treatment means trying all alternatives, some of them\n-may be rejected by reservations in the subsequent insns.  You can not\n-query functional unit reservations in nondeterministic automaton\n-states.\n-@end itemize\n-\n-As an example, consider a superscalar @acronym{RISC} machine which can\n-issue three insns (two integer insns and one floating point insn) on\n-the cycle but can finish only two insns.  To describe this, we define\n-the following functional units.\n-\n-@smallexample\n-(define_cpu_unit \"i0_pipeline, i1_pipeline, f_pipeline\")\n-(define_cpu_unit \"port_0, port1\")\n-@end smallexample\n-\n-All simple integer insns can be executed in any integer pipeline and\n-their result is ready in two cycles.  The simple integer insns are\n-issued into the first pipeline unless it is reserved, otherwise they\n-are issued into the second pipeline.  Integer division and\n-multiplication insns can be executed only in the second integer\n-pipeline and their results are ready correspondingly in 8 and 4\n-cycles.  The integer division is not pipelined, i.e. the subsequent\n-integer division insn can not be issued until the current division\n-insn finished.  Floating point insns are fully pipelined and their\n-results are ready in 3 cycles.  There is also additional one cycle\n-delay in the usage by integer insns of result produced by floating\n-point insns.  To describe all of this we could specify\n-\n-@smallexample\n-(define_cpu_unit \"div\")\n-\n-(define_insn_reservation \"simple\" 2 (eq_attr \"cpu\" \"int\")\n-                         \"(i0_pipeline | i1_pipeline), (port_0 | port1)\")\n-\n-(define_insn_reservation \"mult\" 4 (eq_attr \"cpu\" \"mult\")\n-                         \"i1_pipeline, nothing*3, (port_0 | port1)\")\n-\n-(define_insn_reservation \"div\" 8 (eq_attr \"cpu\" \"div\")\n-                         \"i1_pipeline, div*7, (port_0 | port1)\")\n-\n-(define_insn_reservation \"float\" 3 (eq_attr \"cpu\" \"float\")\n-                         \"f_pipeline, nothing, (port_0 | port1))\n-\n-(define_bypass 4 \"float\" \"simple,mut,div\")\n-@end smallexample\n-\n-To simplify the description we could describe the following reservation\n-\n-@smallexample\n-(define_reservation \"finish\" \"port0|port1\")\n-@end smallexample\n-\n-and use it in all @code{define_insn_reservation} as in the following\n-construction\n-\n-@smallexample\n-(define_insn_reservation \"simple\" 2 (eq_attr \"cpu\" \"int\")\n-                         \"(i0_pipeline | i1_pipeline), finish\")\n-@end smallexample\n-\n-\n-@node Comparison of the two descriptions\n-@subsubsection Drawbacks of the old pipeline description\n-@cindex old pipeline description\n-@cindex automaton based pipeline description\n-@cindex processor functional units\n-@cindex interlock delays\n-@cindex instruction latency time\n-@cindex pipeline hazard recognizer\n-@cindex data bypass\n-\n-The old instruction level parallelism description and the pipeline\n-hazards recognizer based on it have the following drawbacks in\n-comparison with the @acronym{DFA}-based ones:\n-  \n-@itemize @bullet\n-@item\n-Each functional unit is believed to be reserved at the instruction\n-execution start.  This is a very inaccurate model for modern\n-processors.\n-\n-@item\n-An inadequate description of instruction latency times.  The latency\n-time is bound with a functional unit reserved by an instruction not\n-with the instruction itself.  In other words, the description is\n-oriented to describe at most one unit reservation by each instruction.\n-It also does not permit to describe special bypasses between\n-instruction pairs.\n-\n-@item\n-The implementation of the pipeline hazard recognizer interface has\n-constraints on number of functional units.  This is a number of bits\n-in integer on the host machine.\n-\n-@item\n-The interface to the pipeline hazard recognizer is more complex than\n-one to the automaton based pipeline recognizer.\n-\n-@item\n-An unnatural description when you write an unit and a condition which\n-selects instructions using the unit.  Writing all unit reservations\n-for an instruction (an instruction class) is more natural.\n-\n-@item\n-The recognition of the interlock delays has slow implementation.  GCC\n-scheduler supports structures which describe the unit reservations.\n-The more processor has functional units, the slower pipeline hazard\n-recognizer.  Such implementation would become slower when we enable to\n-reserve functional units not only at the instruction execution start.\n-The automaton based pipeline hazard recognizer speed is not depended\n-on processor complexity.\n-@end itemize\n @end ifset\n \n @node Conditional Execution"}, {"sha": "80e8e75209d065b4522b2ed32c4d301ff9e12a8c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 156, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -5446,19 +5446,11 @@ hooks for this purpose.  It is usually enough to define just a few of\n them: try the first ones in this list first.\n \n @deftypefn {Target Hook} int TARGET_SCHED_ISSUE_RATE (void)\n-This hook returns the maximum number of instructions that can ever\n-issue at the same time on the target machine.  The default is one.\n-Although the insn scheduler can define itself the possibility of issue\n-an insn on the same cycle, the value can serve as an additional\n-constraint to issue insns on the same simulated processor cycle (see\n-hooks @samp{TARGET_SCHED_REORDER} and @samp{TARGET_SCHED_REORDER2}).\n-This value must be constant over the entire compilation.  If you need\n-it to vary depending on what the instructions are, you must use\n+This hook returns the maximum number of instructions that can ever issue\n+at the same time on the target machine.  The default is one.  This value\n+must be constant over the entire compilation.  If you need it to vary\n+depending on what the instructions are, you must use\n @samp{TARGET_SCHED_VARIABLE_ISSUE}.\n-\n-You could use the value of macro @samp{MAX_DFA_ISSUE_RATE} to return\n-the value of the hook @samp{TARGET_SCHED_ISSUE_RATE} for the automaton\n-based pipeline interface.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_VARIABLE_ISSUE (FILE *@var{file}, int @var{verbose}, rtx @var{insn}, int @var{more})\n@@ -5474,17 +5466,12 @@ instruction that was scheduled.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_ADJUST_COST (rtx @var{insn}, rtx @var{link}, rtx @var{dep_insn}, int @var{cost})\n-This function corrects the value of @var{cost} based on the\n-relationship between @var{insn} and @var{dep_insn} through the\n-dependence @var{link}.  It should return the new value.  The default\n-is to make no adjustment to @var{cost}.  This can be used for example\n-to specify to the scheduler using the traditional pipeline description\n+This function corrects the value of @var{cost} based on the relationship\n+between @var{insn} and @var{dep_insn} through the dependence @var{link}.\n+It should return the new value.  The default is to make no adjustment to\n+@var{cost}.  This can be used for example to specify to the scheduler\n that an output- or anti-dependence does not incur the same cost as a\n-data-dependence.  If the scheduler using the automaton based pipeline\n-description, the cost of anti-dependence is zero and the cost of\n-output-dependence is maximum of one and the difference of latency\n-times of the first and the second insns.  If these values are not\n-acceptable, you could use the hook to modify them too.\n+data-dependence.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_ADJUST_PRIORITY (rtx @var{insn}, int @var{priority})\n@@ -5550,140 +5537,6 @@ RTL dumps and assembly output.  Define this hook only if you need this\n level of detail about what the scheduler is doing.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE (void)\n-This hook is called many times during insn scheduling.  If the hook\n-returns nonzero, the automaton based pipeline description is used for\n-insn scheduling.  Otherwise the traditional pipeline description is\n-used.  The default is usage of the traditional pipeline description.\n-\n-You should also remember that to simplify the insn scheduler sources\n-an empty traditional pipeline description interface is generated even\n-if there is no a traditional pipeline description in the @file{.md}\n-file.  The same is true for the automaton based pipeline description.\n-That means that you should be accurate in defining the hook.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} int TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)\n-The hook returns an RTL insn.  The automaton state used in the\n-pipeline hazard recognizer is changed as if the insn were scheduled\n-when the new simulated processor cycle starts.  Usage of the hook may\n-simplify the automaton pipeline description for some @acronym{VLIW}\n-processors.  If the hook is defined, it is used only for the automaton\n-based pipeline description.  The default is not to change the state\n-when the new simulated processor cycle starts.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN (void)\n-The hook can be used to initialize data used by the previous hook.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} int TARGET_SCHED_DFA_POST_CYCLE_INSN (void)\n-The hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used\n-to changed the state as if the insn were scheduled when the new\n-simulated processor cycle finishes.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN (void)\n-The hook is analogous to @samp{TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN} but\n-used to initialize data used by the previous hook.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD (void)\n-This hook controls better choosing an insn from the ready insn queue\n-for the @acronym{DFA}-based insn scheduler.  Usually the scheduler\n-chooses the first insn from the queue.  If the hook returns a positive\n-value, an additional scheduler code tries all permutations of\n-@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()}\n-subsequent ready insns to choose an insn whose issue will result in\n-maximal number of issued insns on the same cycle.  For the\n-@acronym{VLIW} processor, the code could actually solve the problem of\n-packing simple insns into the @acronym{VLIW} insn.  Of course, if the\n-rules of @acronym{VLIW} packing are described in the automaton.\n-\n-This code also could be used for superscalar @acronym{RISC}\n-processors.  Let us consider a superscalar @acronym{RISC} processor\n-with 3 pipelines.  Some insns can be executed in pipelines @var{A} or\n-@var{B}, some insns can be executed only in pipelines @var{B} or\n-@var{C}, and one insn can be executed in pipeline @var{B}.  The\n-processor may issue the 1st insn into @var{A} and the 2nd one into\n-@var{B}.  In this case, the 3rd insn will wait for freeing @var{B}\n-until the next cycle.  If the scheduler issues the 3rd insn the first,\n-the processor could issue all 3 insns per cycle.\n-\n-Actually this code demonstrates advantages of the automaton based\n-pipeline hazard recognizer.  We try quickly and easy many insn\n-schedules to choose the best one.\n-\n-The default is no multipass scheduling.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_BUBBLES (void)\n-The @acronym{DFA}-based scheduler could take the insertion of nop\n-operations for better insn scheduling into account.  It can be done\n-only if the multi-pass insn scheduling works (see hook\n-@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD}).\n-\n-Let us consider a @acronym{VLIW} processor insn with 3 slots.  Each\n-insn can be placed only in one of the three slots.  We have 3 ready\n-insns @var{A}, @var{B}, and @var{C}.  @var{A} and @var{C} can be\n-placed only in the 1st slot, @var{B} can be placed only in the 3rd\n-slot.  We described the automaton which does not permit empty slot\n-gaps between insns (usually such description is simpler).  Without\n-this code the scheduler would place each insn in 3 separate\n-@acronym{VLIW} insns.  If the scheduler places a nop insn into the 2nd\n-slot, it could place the 3 insns into 2 @acronym{VLIW} insns.  What is\n-the nop insn is returned by hook @samp{TARGET_SCHED_DFA_BUBBLE}.  Hook\n-@samp{TARGET_SCHED_INIT_DFA_BUBBLES} can be used to initialize or\n-create the nop insns.\n-\n-You should remember that the scheduler does not insert the nop insns.\n-It is not wise because of the following optimizations.  The scheduler\n-only considers such possibility to improve the result schedule.  The\n-nop insns should be inserted lately, e.g. on the final phase.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} rtx TARGET_SCHED_DFA_BUBBLE (int @var{index})\n-This hook @samp{FIRST_CYCLE_MULTIPASS_SCHEDULING} is used to insert\n-nop operations for better insn scheduling when @acronym{DFA}-based\n-scheduler makes multipass insn scheduling (see also description of\n-hook @samp{TARGET_SCHED_INIT_DFA_BUBBLES}).  This hook\n-returns a nop insn with given @var{index}.  The indexes start with\n-zero.  The hook should return @code{NULL} if there are no more nop\n-insns with indexes greater than given index.\n-@end deftypefn\n-\n-Macros in the following table are generated by the program\n-@file{genattr} and can be useful for writing the hooks.\n-\n-@table @code\n-@findex TRADITIONAL_PIPELINE_INTERFACE\n-@item TRADITIONAL_PIPELINE_INTERFACE\n-The macro definition is generated if there is a traditional pipeline\n-description in @file{.md} file. You should also remember that to\n-simplify the insn scheduler sources an empty traditional pipeline\n-description interface is generated even if there is no a traditional\n-pipeline description in the @file{.md} file.  The macro can be used to\n-distinguish the two types of the traditional interface.\n-\n-@findex DFA_PIPELINE_INTERFACE\n-@item DFA_PIPELINE_INTERFACE\n-The macro definition is generated if there is an automaton pipeline\n-description in @file{.md} file.  You should also remember that to\n-simplify the insn scheduler sources an empty automaton pipeline\n-description interface is generated even if there is no an automaton\n-pipeline description in the @file{.md} file.  The macro can be used to\n-distinguish the two types of the automaton interface.\n-\n-@findex MAX_DFA_ISSUE_RATE\n-@item MAX_DFA_ISSUE_RATE\n-The macro definition is generated in the automaton based pipeline\n-description interface.  Its value is calculated from the automaton\n-based pipeline description and is equal to maximal number of all insns\n-described in constructions @samp{define_insn_reservation} which can be\n-issued on the same processor cycle.\n-\n-@end table\n-\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "cbb1175ceeed9ccfdd0ab44c279c7f35e8bd3dd6", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 106, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -193,7 +193,6 @@ main (argc, argv)\n   int have_delay = 0;\n   int have_annul_true = 0;\n   int have_annul_false = 0;\n-  int num_insn_reservations = 0;\n   int num_units = 0;\n   struct range all_simultaneity, all_multiplicity;\n   struct range all_ready_cost, all_issue_delay, all_blockage;\n@@ -309,18 +308,10 @@ main (argc, argv)\n \t  extend_range (&all_issue_delay,\n \t\t\tunit->issue_delay.min, unit->issue_delay.max);\n \t}\n-      else if (GET_CODE (desc) == DEFINE_INSN_RESERVATION)\n-\tnum_insn_reservations++;\n     }\n \n-  if (num_units > 0 || num_insn_reservations > 0)\n+  if (num_units > 0)\n     {\n-      if (num_units > 0)\n-\tprintf (\"#define TRADITIONAL_PIPELINE_INTERFACE 1\\n\");\n-\n-      if (num_insn_reservations > 0)\n-\tprintf (\"#define DFA_PIPELINE_INTERFACE 1\\n\");\n-\n       /* Compute the range of blockage cost values.  See genattrtab.c\n \t for the derivation.  BLOCKAGE (E,C) when SIMULTANEITY is zero is\n \n@@ -357,102 +348,6 @@ main (argc, argv)\n \n       write_units (num_units, &all_multiplicity, &all_simultaneity,\n \t\t   &all_ready_cost, &all_issue_delay, &all_blockage);\n-\n-      /* Output interface for pipeline hazards recognition based on\n-\t DFA (deterministic finite state automata.  */\n-      printf (\"\\n/* DFA based pipeline interface.  */\");\n-      printf (\"\\n#ifndef AUTOMATON_STATE_ALTS\\n\");\n-      printf (\"#define AUTOMATON_STATE_ALTS 0\\n\");\n-      printf (\"#endif\\n\\n\");\n-      printf (\"#ifndef CPU_UNITS_QUERY\\n\");\n-      printf (\"#define CPU_UNITS_QUERY 0\\n\");\n-      printf (\"#endif\\n\\n\");\n-      /* Interface itself: */\n-      printf (\"extern int max_dfa_issue_rate;\\n\\n\");\n-      printf (\"/* The following macro value is calculated from the\\n\");\n-      printf (\"   automaton based pipeline description and is equal to\\n\");\n-      printf (\"   maximal number of all insns described in constructions\\n\");\n-      printf (\"   `define_insn_reservation' which can be issued on the\\n\");\n-      printf (\"   same processor cycle. */\\n\");\n-      printf (\"#define MAX_DFA_ISSUE_RATE max_dfa_issue_rate\\n\\n\");\n-      printf (\"/* Insn latency time defined in define_insn_reservation. */\\n\");\n-      printf (\"extern int insn_default_latency PARAMS ((rtx));\\n\\n\");\n-      printf (\"/* Return nonzero if there is a bypass for given insn\\n\");\n-      printf (\"   which is a data producer.  */\\n\");\n-      printf (\"extern int bypass_p PARAMS ((rtx));\\n\\n\");\n-      printf (\"/* Insn latency time on data consumed by the 2nd insn.\\n\");\n-      printf (\"   Use the function if bypass_p returns nonzero for\\n\");\n-      printf (\"   the 1st insn. */\\n\");\n-      printf (\"extern int insn_latency PARAMS ((rtx, rtx));\\n\\n\");\n-      printf (\"/* The following function returns number of alternative\\n\");\n-      printf (\"   reservations of given insn.  It may be used for better\\n\");\n-      printf (\"   insns scheduling heuristics. */\\n\");\n-      printf (\"extern int insn_alts PARAMS ((rtx));\\n\\n\");\n-      printf (\"/* Maximal possible number of insns waiting results being\\n\");\n-      printf (\"   produced by insns whose execution is not finished. */\\n\");\n-      printf (\"extern int max_insn_queue_index;\\n\\n\");\n-      printf (\"/* Pointer to data describing current state of DFA.  */\\n\");\n-      printf (\"typedef void *state_t;\\n\\n\");\n-      printf (\"/* Size of the data in bytes.  */\\n\");\n-      printf (\"extern int state_size PARAMS ((void));\\n\\n\");\n-      printf (\"/* Initiate given DFA state, i.e. Set up the state\\n\");\n-      printf (\"   as all functional units were not reserved.  */\\n\");\n-      printf (\"extern void state_reset PARAMS ((state_t));\\n\");\n-      printf (\"/* The following function returns negative value if given\\n\");\n-      printf (\"   insn can be issued in processor state described by given\\n\");\n-      printf (\"   DFA state.  In this case, the DFA state is changed to\\n\");\n-      printf (\"   reflect the current and future reservations by given\\n\");\n-      printf (\"   insn.  Otherwise the function returns minimal time\\n\");\n-      printf (\"   delay to issue the insn.  This delay may be zero\\n\");\n-      printf (\"   for superscalar or VLIW processors.  If the second\\n\");\n-      printf (\"   parameter is NULL the function changes given DFA state\\n\");\n-      printf (\"   as new processor cycle started.  */\\n\");\n-      printf (\"extern int state_transition PARAMS ((state_t, rtx));\\n\");\n-      printf (\"\\n#if AUTOMATON_STATE_ALTS\\n\");\n-      printf (\"/* The following function returns number of possible\\n\");\n-      printf (\"   alternative reservations of given insn in given\\n\");\n-      printf (\"   DFA state.  It may be used for better insns scheduling\\n\");\n-      printf (\"   heuristics.  By default the function is defined if\\n\");\n-      printf (\"   macro AUTOMATON_STATE_ALTS is defined because its\\n\");\n-      printf (\"   implementation may require much memory.  */\\n\");\n-      printf (\"extern int state_alts PARAMS ((state_t, rtx));\\n\");\n-      printf (\"#endif\\n\\n\");\n-      printf (\"extern int min_issue_delay PARAMS ((state_t, rtx));\\n\");\n-      printf (\"/* The following function returns nonzero if no one insn\\n\");\n-      printf (\"   can be issued in current DFA state. */\\n\");\n-      printf (\"extern int state_dead_lock_p PARAMS ((state_t));\\n\");\n-      printf (\"/* The function returns minimal delay of issue of the 2nd\\n\");\n-      printf (\"   insn after issuing the 1st insn in given DFA state.\\n\");\n-      printf (\"   The 1st insn should be issued in given state (i.e.\\n\");\n-      printf (\"    state_transition should return negative value for\\n\");\n-      printf (\"    the insn and the state).  Data dependencies between\\n\");\n-      printf (\"    the insns are ignored by the function.  */\\n\");\n-      printf\n-\t(\"extern int min_insn_conflict_delay PARAMS ((state_t, rtx, rtx));\\n\");\n-      printf (\"/* The following function outputs reservations for given\\n\");\n-      printf (\"   insn as they are described in the corresponding\\n\");\n-      printf (\"   define_insn_reservation.  */\\n\");\n-      printf (\"extern void print_reservation PARAMS ((FILE *, rtx));\\n\");\n-      printf (\"\\n#if CPU_UNITS_QUERY\\n\");\n-      printf (\"/* The following function returns code of functional unit\\n\");\n-      printf (\"   with given name (see define_cpu_unit). */\\n\");\n-      printf (\"extern int get_cpu_unit_code PARAMS ((const char *));\\n\");\n-      printf (\"/* The following function returns nonzero if functional\\n\");\n-      printf (\"   unit with given code is currently reserved in given\\n\");\n-      printf (\"   DFA state.  */\\n\");\n-      printf (\"extern int cpu_unit_reservation_p PARAMS ((state_t, int));\\n\");\n-      printf (\"#endif\\n\\n\");\n-      printf (\"/* Initiate and finish work with DFA.  They should be\\n\");\n-      printf (\"   called as the first and the last interface\\n\");\n-      printf (\"   functions.  */\\n\");\n-      printf (\"extern void dfa_start PARAMS ((void));\\n\");\n-      printf (\"extern void dfa_finish PARAMS ((void));\\n\");\n-    }\n-  else\n-    {\n-      /* Otherwise we do no scheduling, but we need these typedefs\n-\t in order to avoid uglifying other code with more ifdefs.  */\n-      printf (\"typedef void *state_t;\\n\\n\");\n     }\n \n   /* Output flag masks for use by reorg.  "}, {"sha": "56641105c45c5cb94698964568f0a72896ff5ed8", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 15, "deletions": 65, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -110,8 +110,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"obstack.h\"\n #include \"errors.h\"\n \n-#include \"genattrtab.h\"\n-\n static struct obstack obstack1, obstack2;\n struct obstack *hash_obstack = &obstack1;\n struct obstack *temp_obstack = &obstack2;\n@@ -306,8 +304,6 @@ static int have_annul_true, have_annul_false;\n static int num_units, num_unit_opclasses;\n static int num_insn_ents;\n \n-int num_dfa_decls;\n-\n /* Used as operand to `operate_exp':  */\n \n enum operator {PLUS_OP, MINUS_OP, POS_MINUS_OP, EQ_OP, OR_OP, ORX_OP, MAX_OP, MIN_OP, RANGE_OP};\n@@ -369,7 +365,10 @@ rtx pic_offset_table_rtx;\n static void attr_hash_add_rtx\tPARAMS ((int, rtx));\n static void attr_hash_add_string PARAMS ((int, char *));\n static rtx attr_rtx\t\tPARAMS ((enum rtx_code, ...));\n+static char *attr_printf\tPARAMS ((int, const char *, ...))\n+  ATTRIBUTE_PRINTF_2;\n static char *attr_string        PARAMS ((const char *, int));\n+static rtx check_attr_test\tPARAMS ((rtx, int, int));\n static rtx check_attr_value\tPARAMS ((rtx, struct attr_desc *));\n static rtx convert_set_attr_alternative PARAMS ((rtx, struct insn_def *));\n static rtx convert_set_attr\tPARAMS ((rtx, struct insn_def *));\n@@ -453,8 +452,10 @@ static void write_const_num_delay_slots PARAMS ((void));\n static int n_comma_elts\t\tPARAMS ((const char *));\n static char *next_comma_elt\tPARAMS ((const char **));\n static struct attr_desc *find_attr PARAMS ((const char *, int));\n+static void make_internal_attr\tPARAMS ((const char *, rtx, int));\n static struct attr_value *find_most_used  PARAMS ((struct attr_desc *));\n static rtx find_single_value\tPARAMS ((struct attr_desc *));\n+static rtx make_numeric_value\tPARAMS ((int));\n static void extend_range\tPARAMS ((struct range *, int, int));\n static rtx attr_eq\t\tPARAMS ((const char *, const char *));\n static const char *attr_numeral\tPARAMS ((int));\n@@ -741,7 +742,7 @@ attr_rtx VPARAMS ((enum rtx_code code, ...))\n \n    rtx attr_printf (len, format, [arg1, ..., argn])  */\n \n-char *\n+static char *\n attr_printf VPARAMS ((register int len, const char *fmt, ...))\n {\n   char str[256];\n@@ -921,7 +922,7 @@ attr_copy_rtx (orig)\n \n    Return the new expression, if any.   */\n \n-rtx\n+static rtx\n check_attr_test (exp, is_const, lineno)\n      rtx exp;\n      int is_const;\n@@ -5876,7 +5877,7 @@ find_attr (name, create)\n \n /* Create internal attribute with the given default value.  */\n \n-void\n+static void\n make_internal_attr (name, value, special)\n      const char *name;\n      rtx value;\n@@ -5943,7 +5944,7 @@ find_single_value (attr)\n \n /* Return (attr_value \"n\") */\n \n-rtx\n+static rtx\n make_numeric_value (n)\n      int n;\n {\n@@ -6093,7 +6094,6 @@ from the machine description file `md'.  */\\n\\n\");\n \n   /* Read the machine description.  */\n \n-  initiate_automaton_gen (argc, argv);\n   while (1)\n     {\n       int lineno;\n@@ -6122,46 +6122,6 @@ from the machine description file `md'.  */\\n\\n\");\n \t  gen_unit (desc, lineno);\n \t  break;\n \n-\tcase DEFINE_CPU_UNIT:\n-\t  gen_cpu_unit (desc);\n-\t  break;\n-\t  \n-\tcase DEFINE_QUERY_CPU_UNIT:\n-\t  gen_query_cpu_unit (desc);\n-\t  break;\n-\t  \n-\tcase DEFINE_BYPASS:\n-\t  gen_bypass (desc);\n-\t  break;\n-\t  \n-\tcase EXCLUSION_SET:\n-\t  gen_excl_set (desc);\n-\t  break;\n-\t  \n-\tcase PRESENCE_SET:\n-\t  gen_presence_set (desc);\n-\t  break;\n-\t  \n-\tcase ABSENCE_SET:\n-\t  gen_absence_set (desc);\n-\t  break;\n-\t  \n-\tcase DEFINE_AUTOMATON:\n-\t  gen_automaton (desc);\n-\t  break;\n-\t  \n-\tcase AUTOMATA_OPTION:\n-\t  gen_automata_option (desc);\n-\t  break;\n-\t  \n-\tcase DEFINE_RESERVATION:\n-\t  gen_reserv (desc);\n-\t  break;\n-\t  \n-\tcase DEFINE_INSN_RESERVATION:\n-\t  gen_insn_reserv (desc);\n-\t  break;\n-\n \tdefault:\n \t  break;\n \t}\n@@ -6186,14 +6146,9 @@ from the machine description file `md'.  */\\n\\n\");\n   if (num_delays)\n     expand_delays ();\n \n-  if (num_units || num_dfa_decls)\n-    {\n-      /* Expand DEFINE_FUNCTION_UNIT information into new attributes.  */\n-      expand_units ();\n-      /* Build DFA, output some functions and expand DFA information\n-\t into new attributes.  */\n-      expand_automata ();\n-    }\n+  /* Expand DEFINE_FUNCTION_UNIT information into new attributes.  */\n+  if (num_units)\n+    expand_units ();\n \n   printf (\"#include \\\"config.h\\\"\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n@@ -6268,14 +6223,9 @@ from the machine description file `md'.  */\\n\\n\");\n \twrite_eligible_delay (\"annul_false\");\n     }\n \n-  if (num_units || num_dfa_decls)\n-    {\n-      /* Write out information about function units.  */\n-      write_function_unit_info ();\n-      /* Output code for pipeline hazards recognition based on DFA\n-\t (deterministic finite state automata. */\n-      write_automata ();\n-    }\n+  /* Write out information about function units.  */\n+  if (num_units)\n+    write_function_unit_info ();\n \n   /* Write out constant delay slot info */\n   write_const_num_delay_slots ();"}, {"sha": "cc9e36e1ac4cb58cb682c70dea7301208ef4dbb0", "filename": "gcc/genattrtab.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4302ec5b8658dbbed93bc09cf45b52aa94766c/gcc%2Fgenattrtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4302ec5b8658dbbed93bc09cf45b52aa94766c/gcc%2Fgenattrtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.h?ref=6e4302ec5b8658dbbed93bc09cf45b52aa94766c", "patch": "@@ -1,43 +0,0 @@\n-/* External definitions of source files of genattrtab.\n-   Copyright (C)  2001 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Defined in genattrtab.c: */\n-extern rtx check_attr_test\tPARAMS ((rtx, int, int));\n-extern rtx make_numeric_value\tPARAMS ((int));\n-extern void make_internal_attr\tPARAMS ((const char *, rtx, int));\n-extern char *attr_printf\tPARAMS ((int, const char *, ...))\n-  ATTRIBUTE_PRINTF_2;\n-\n-extern int num_dfa_decls;\n-\n-/* Defined in genautomata.c: */\n-extern void gen_cpu_unit\t\tPARAMS ((rtx));\n-extern void gen_query_cpu_unit\t\tPARAMS ((rtx));\n-extern void gen_bypass\t\t\tPARAMS ((rtx));\n-extern void gen_excl_set\t\tPARAMS ((rtx));\n-extern void gen_presence_set\t\tPARAMS ((rtx));\n-extern void gen_absence_set\t\tPARAMS ((rtx));\n-extern void gen_automaton\t\tPARAMS ((rtx));\n-extern void gen_automata_option\t\tPARAMS ((rtx));\n-extern void gen_reserv   \t\tPARAMS ((rtx));\n-extern void gen_insn_reserv     \tPARAMS ((rtx));\n-extern void initiate_automaton_gen\tPARAMS ((int, char **));\n-extern void expand_automata             PARAMS ((void));\n-extern void write_automata              PARAMS ((void));"}, {"sha": "6da05ba587611d14a8ce2ffc5511a05e1aa6fcb2", "filename": "gcc/genautomata.c", "status": "removed", "additions": 0, "deletions": 8767, "changes": 8767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4302ec5b8658dbbed93bc09cf45b52aa94766c/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4302ec5b8658dbbed93bc09cf45b52aa94766c/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=6e4302ec5b8658dbbed93bc09cf45b52aa94766c"}, {"sha": "3fea98c5e6853f0ebb6eb2526645c1fe9157875a", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 100, "deletions": 539, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -158,12 +158,6 @@ Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int issue_rate;\n \n-/* If the following variable value is non zero, the scheduler inserts\n-   bubbles (nop insns).  The value of variable affects on scheduler\n-   behavior only if automaton pipeline interface with multipass\n-   scheduling is used and hook dfa_bubble is defined.  */\n-int insert_schedule_bubbles_p = 0;\n-\n /* sched-verbose controls the amount of debugging output the\n    scheduler prints.  It is controlled by -fsched-verbose=N:\n    N>0 and no -DSR : the output is directed to stderr.\n@@ -260,39 +254,14 @@ static rtx note_list;\n    passes or stalls are introduced.  */\n \n /* Implement a circular buffer to delay instructions until sufficient\n-   time has passed.  For the old pipeline description interface,\n-   INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and\n-   MAX_READY_COST computed by genattr.c.  For the new pipeline\n-   description interface, MAX_INSN_QUEUE_INDEX is a power of two minus\n-   one which is larger than maximal time of instruction execution\n-   computed by genattr.c on the base maximal time of functional unit\n-   reservations and geting a result.  This is the longest time an\n-   insn may be queued.  */\n-\n-#define MAX_INSN_QUEUE_INDEX max_insn_queue_index_macro_value\n-\n-static rtx *insn_queue;\n+   time has passed.  INSN_QUEUE_SIZE is a power of two larger than\n+   MAX_BLOCKAGE and MAX_READY_COST computed by genattr.c.  This is the\n+   longest time an isnsn may be queued.  */\n+static rtx insn_queue[INSN_QUEUE_SIZE];\n static int q_ptr = 0;\n static int q_size = 0;\n-#define NEXT_Q(X) (((X)+1) & MAX_INSN_QUEUE_INDEX)\n-#define NEXT_Q_AFTER(X, C) (((X)+C) & MAX_INSN_QUEUE_INDEX)\n-\n-/* The following variable defines value for macro\n-   MAX_INSN_QUEUE_INDEX.  */\n-static int max_insn_queue_index_macro_value;\n-\n-/* The following variable value refers for all current and future\n-   reservations of the processor units.  */\n-state_t curr_state;\n-\n-/* The following variable value is size of memory representing all\n-   current and future reservations of the processor units.  It is used\n-   only by DFA based scheduler.  */\n-static size_t dfa_state_size;\n-\n-/* The following array is used to find the best insn from ready when\n-   the automaton pipeline interface is used.  */\n-static char *ready_try;\n+#define NEXT_Q(X) (((X)+1) & (INSN_QUEUE_SIZE-1))\n+#define NEXT_Q_AFTER(X, C) (((X)+C) & (INSN_QUEUE_SIZE-1))\n \n /* Describe the ready list of the scheduler.\n    VEC holds space enough for all insns in the current region.  VECLEN\n@@ -311,15 +280,11 @@ struct ready_list\n };\n \n /* Forward declarations.  */\n-\n-/* The scheduler using only DFA description should never use the\n-   following five functions:  */\n static unsigned int blockage_range PARAMS ((int, rtx));\n static void clear_units PARAMS ((void));\n static void schedule_unit PARAMS ((int, rtx, int));\n static int actual_hazard PARAMS ((int, rtx, int, int));\n static int potential_hazard PARAMS ((int, rtx, int));\n-\n static int priority PARAMS ((rtx));\n static int rank_for_schedule PARAMS ((const PTR, const PTR));\n static void swap_sort PARAMS ((rtx *, int));\n@@ -366,14 +331,6 @@ static void debug_ready_list PARAMS ((struct ready_list *));\n static rtx move_insn1 PARAMS ((rtx, rtx));\n static rtx move_insn PARAMS ((rtx, rtx));\n \n-/* The following functions are used to implement multi-pass scheduling\n-   on the first cycle.  It is used only for DFA based scheduler.  */\n-static rtx ready_element PARAMS ((struct ready_list *, int));\n-static rtx ready_remove PARAMS ((struct ready_list *, int));\n-static int max_issue PARAMS ((struct ready_list *, state_t, int *, int *));\n-\n-static rtx choose_ready PARAMS ((struct ready_list *));\n-\n #endif /* INSN_SCHEDULING */\n \f\n /* Point to state used for the current scheduling pass.  */\n@@ -397,8 +354,7 @@ static rtx last_scheduled_insn;\n    returned by function_units_used.  A function unit is encoded as the\n    unit number if the value is non-negative and the compliment of a\n    mask if the value is negative.  A function unit index is the\n-   non-negative encoding.  The scheduler using only DFA description\n-   should never use the following function.  */\n+   non-negative encoding.  */\n \n HAIFA_INLINE int\n insn_unit (insn)\n@@ -435,9 +391,7 @@ insn_unit (insn)\n /* Compute the blockage range for executing INSN on UNIT.  This caches\n    the value returned by the blockage_range_function for the unit.\n    These values are encoded in an int where the upper half gives the\n-   minimum value and the lower half gives the maximum value.  The\n-   scheduler using only DFA description should never use the following\n-   function.  */\n+   minimum value and the lower half gives the maximum value.  */\n \n HAIFA_INLINE static unsigned int\n blockage_range (unit, insn)\n@@ -461,38 +415,20 @@ blockage_range (unit, insn)\n   return range;\n }\n \n-/* A vector indexed by function unit instance giving the last insn to\n-   use the unit.  The value of the function unit instance index for\n-   unit U instance I is (U + I * FUNCTION_UNITS_SIZE).  The scheduler\n-   using only DFA description should never use the following variable.  */\n-#if FUNCTION_UNITS_SIZE\n+/* A vector indexed by function unit instance giving the last insn to use\n+   the unit.  The value of the function unit instance index for unit U\n+   instance I is (U + I * FUNCTION_UNITS_SIZE).  */\n static rtx unit_last_insn[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n-#else\n-static rtx unit_last_insn[1];\n-#endif\n \n-/* A vector indexed by function unit instance giving the minimum time\n-   when the unit will unblock based on the maximum blockage cost.  The\n-   scheduler using only DFA description should never use the following\n-   variable.  */\n-#if FUNCTION_UNITS_SIZE\n+/* A vector indexed by function unit instance giving the minimum time when\n+   the unit will unblock based on the maximum blockage cost.  */\n static int unit_tick[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n-#else\n-static int unit_tick[1];\n-#endif\n \n /* A vector indexed by function unit number giving the number of insns\n-   that remain to use the unit.  The scheduler using only DFA\n-   description should never use the following variable.  */\n-#if FUNCTION_UNITS_SIZE\n+   that remain to use the unit.  */\n static int unit_n_insns[FUNCTION_UNITS_SIZE];\n-#else\n-static int unit_n_insns[1];\n-#endif\n \n-/* Access the unit_last_insn array.  Used by the visualization code.\n-   The scheduler using only DFA description should never use the\n-   following function.  */\n+/* Access the unit_last_insn array.  Used by the visualization code.  */\n \n rtx\n get_unit_last_insn (instance)\n@@ -511,8 +447,7 @@ clear_units ()\n   memset ((char *) unit_n_insns, 0, sizeof (unit_n_insns));\n }\n \n-/* Return the issue-delay of an insn.  The scheduler using only DFA\n-   description should never use the following function.  */\n+/* Return the issue-delay of an insn.  */\n \n HAIFA_INLINE int\n insn_issue_delay (insn)\n@@ -542,8 +477,7 @@ insn_issue_delay (insn)\n \n /* Return the actual hazard cost of executing INSN on the unit UNIT,\n    instance INSTANCE at time CLOCK if the previous actual hazard cost\n-   was COST.  The scheduler using only DFA description should never\n-   use the following function.  */\n+   was COST.  */\n \n HAIFA_INLINE int\n actual_hazard_this_instance (unit, instance, insn, clock, cost)\n@@ -579,9 +513,8 @@ actual_hazard_this_instance (unit, instance, insn, clock, cost)\n   return cost;\n }\n \n-/* Record INSN as having begun execution on the units encoded by UNIT\n-   at time CLOCK.  The scheduler using only DFA description should\n-   never use the following function.  */\n+/* Record INSN as having begun execution on the units encoded by UNIT at\n+   time CLOCK.  */\n \n HAIFA_INLINE static void\n schedule_unit (unit, insn, clock)\n@@ -612,10 +545,8 @@ schedule_unit (unit, insn, clock)\n \tschedule_unit (i, insn, clock);\n }\n \n-/* Return the actual hazard cost of executing INSN on the units\n-   encoded by UNIT at time CLOCK if the previous actual hazard cost\n-   was COST.  The scheduler using only DFA description should never\n-   use the following function.  */\n+/* Return the actual hazard cost of executing INSN on the units encoded by\n+   UNIT at time CLOCK if the previous actual hazard cost was COST.  */\n \n HAIFA_INLINE static int\n actual_hazard (unit, insn, clock, cost)\n@@ -660,13 +591,11 @@ actual_hazard (unit, insn, clock, cost)\n }\n \n /* Return the potential hazard cost of executing an instruction on the\n-   units encoded by UNIT if the previous potential hazard cost was\n-   COST.  An insn with a large blockage time is chosen in preference\n-   to one with a smaller time; an insn that uses a unit that is more\n-   likely to be used is chosen in preference to one with a unit that\n-   is less used.  We are trying to minimize a subsequent actual\n-   hazard.  The scheduler using only DFA description should never use\n-   the following function.  */\n+   units encoded by UNIT if the previous potential hazard cost was COST.\n+   An insn with a large blockage time is chosen in preference to one\n+   with a smaller time; an insn that uses a unit that is more likely\n+   to be used is chosen in preference to one with a unit that is less\n+   used.  We are trying to minimize a subsequent actual hazard.  */\n \n HAIFA_INLINE static int\n potential_hazard (unit, insn, cost)\n@@ -719,67 +648,62 @@ insn_cost (insn, link, used)\n {\n   register int cost = INSN_COST (insn);\n \n-  if (cost < 0)\n+  if (cost == 0)\n     {\n-      /* A USE insn, or something else we don't need to\n-\t understand.  We can't pass these directly to\n-\t result_ready_cost or insn_default_latency because it will\n-\t trigger a fatal error for unrecognizable insns.  */\n-      if (recog_memoized (insn) < 0)\n+      recog_memoized (insn);\n+\n+      /* A USE insn, or something else we don't need to understand.\n+         We can't pass these directly to result_ready_cost because it will\n+         trigger a fatal error for unrecognizable insns.  */\n+      if (INSN_CODE (insn) < 0)\n \t{\n-\t  INSN_COST (insn) = 0;\n-\t  return 0;\n+\t  INSN_COST (insn) = 1;\n+\t  return 1;\n \t}\n       else\n \t{\n-\t  if (targetm.sched.use_dfa_pipeline_interface)\n-\t    cost = insn_default_latency (insn);\n-\t  else\n-\t    cost = result_ready_cost (insn);\n-\t  \n-\t  if (cost < 0)\n-\t    cost = 0;\n-\t  \n+\t  cost = result_ready_cost (insn);\n+\n+\t  if (cost < 1)\n+\t    cost = 1;\n+\n \t  INSN_COST (insn) = cost;\n \t}\n     }\n \n   /* In this case estimate cost without caring how insn is used.  */\n-  if (link == 0 || used == 0)\n+  if (link == 0 && used == 0)\n     return cost;\n \n-  /* A USE insn should never require the value used to be computed.\n-     This allows the computation of a function's result and parameter\n-     values to overlap the return and call.  */\n-  if (recog_memoized (used) < 0)\n+  /* A USE insn should never require the value used to be computed.  This\n+     allows the computation of a function's result and parameter values to\n+     overlap the return and call.  */\n+  recog_memoized (used);\n+  if (INSN_CODE (used) < 0)\n+    LINK_COST_FREE (link) = 1;\n+\n+  /* If some dependencies vary the cost, compute the adjustment.  Most\n+     commonly, the adjustment is complete: either the cost is ignored\n+     (in the case of an output- or anti-dependence), or the cost is\n+     unchanged.  These values are cached in the link as LINK_COST_FREE\n+     and LINK_COST_ZERO.  */\n+\n+  if (LINK_COST_FREE (link))\n     cost = 0;\n-  else\n+  else if (!LINK_COST_ZERO (link) && targetm.sched.adjust_cost)\n     {\n-      if (targetm.sched.use_dfa_pipeline_interface)\n+      int ncost = (*targetm.sched.adjust_cost) (used, link, insn, cost);\n+\n+      if (ncost < 1)\n \t{\n-\t  if (INSN_CODE (insn) >= 0)\n-\t    {\n-\t      if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tcost = 0;\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n-\t\t{\n-\t\t  cost = (insn_default_latency (insn)\n-\t\t\t  - insn_default_latency (used));\n-\t\t  if (cost <= 0)\n-\t\t    cost = 1;\n-\t\t}\n-\t      else if (bypass_p (insn))\n-\t\tcost = insn_latency (insn, used);\n-\t    }\n+\t  LINK_COST_FREE (link) = 1;\n+\t  ncost = 0;\n \t}\n-\n-      if (targetm.sched.adjust_cost)\n-\tcost = (*targetm.sched.adjust_cost) (used, link, insn, cost);\n-\n-      if (cost < 0)\n-\tcost = 0;\n+      if (cost == ncost)\n+\tLINK_COST_ZERO (link) = 1;\n+      cost = ncost;\n     }\n-  \n+\n   return cost;\n }\n \n@@ -1006,48 +930,6 @@ ready_remove_first (ready)\n   return t;\n }\n \n-/* The following code implements multi-pass scheduling for the first\n-   cycle.  In other words, we will try to choose ready insn which\n-   permits to start maximum number of insns on the same cycle.  */\n-\n-/* Return a pointer to the element INDEX from the ready.  INDEX for\n-   insn with the highest priority is 0, and the lowest priority has\n-   N_READY - 1.  */\n-\n-HAIFA_INLINE static rtx\n-ready_element (ready, index)\n-     struct ready_list *ready;\n-     int index;\n-{\n-  if (ready->n_ready == 0 || index >= ready->n_ready)\n-    abort ();\n-  return ready->vec[ready->first - index];\n-}\n-\n-/* Remove the element INDEX from the ready list and return it.  INDEX\n-   for insn with the highest priority is 0, and the lowest priority\n-   has N_READY - 1.  */\n-\n-HAIFA_INLINE static rtx\n-ready_remove (ready, index)\n-     struct ready_list *ready;\n-     int index;\n-{\n-  rtx t;\n-  int i;\n-\n-  if (index == 0)\n-    return ready_remove_first (ready);\n-  if (ready->n_ready == 0 || index >= ready->n_ready)\n-    abort ();\n-  t = ready->vec[ready->first - index];\n-  ready->n_ready--;\n-  for (i = index; i < ready->n_ready; i++)\n-    ready [ready->first - i] = ready [ready->first - i - 1];\n-  return t;\n-}\n-\n-\n /* Sort the ready list READY by ascending priority, using the SCHED_SORT\n    macro.  */\n \n@@ -1094,47 +976,26 @@ schedule_insn (insn, ready, clock)\n      int clock;\n {\n   rtx link;\n-  int unit = 0;\n+  int unit;\n \n-  if (!targetm.sched.use_dfa_pipeline_interface)\n-    unit = insn_unit (insn);\n+  unit = insn_unit (insn);\n \n   if (sched_verbose >= 2)\n     {\n-\n-      if (targetm.sched.use_dfa_pipeline_interface)\n-\t{\n-\t  fprintf (sched_dump,\n-\t\t   \";;\\t\\t--> scheduling insn <<<%d>>>:reservation \",\n-\t\t   INSN_UID (insn));\n-\t  \n-\t  if (recog_memoized (insn) < 0)\n-\t    fprintf (sched_dump, \"nothing\");\n-\t  else\n-\t    print_reservation (sched_dump, insn);\n-\t}\n-      else\n-\t{\n-\t  fprintf (sched_dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n-\t\t   INSN_UID (insn));\n-\t  insn_print_units (insn);\n-\t}\n-\n+      fprintf (sched_dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n+\t       INSN_UID (insn));\n+      insn_print_units (insn);\n       fprintf (sched_dump, \"\\n\");\n     }\n \n-  if (!targetm.sched.use_dfa_pipeline_interface)\n-    {\n-      if (sched_verbose && unit == -1)\n-\tvisualize_no_unit (insn);\n+  if (sched_verbose && unit == -1)\n+    visualize_no_unit (insn);\n \n+  if (MAX_BLOCKAGE > 1 || issue_rate > 1 || sched_verbose)\n+    schedule_unit (unit, insn, clock);\n \n-      if (MAX_BLOCKAGE > 1 || issue_rate > 1 || sched_verbose)\n-\tschedule_unit (unit, insn, clock);\n-      \n-      if (INSN_DEPEND (insn) == 0)\n-\treturn;\n-    }\n+  if (INSN_DEPEND (insn) == 0)\n+    return;\n \n   for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n     {\n@@ -1176,9 +1037,7 @@ schedule_insn (insn, ready, clock)\n      to issue on the same cycle as the previous insn.  A machine\n      may use this information to decide how the instruction should\n      be aligned.  */\n-  if (reload_completed && issue_rate > 1\n-      && GET_CODE (PATTERN (insn)) != USE\n-      && GET_CODE (PATTERN (insn)) != CLOBBER)\n+  if (reload_completed && issue_rate > 1)\n     {\n       PUT_MODE (insn, clock > last_clock_var ? TImode : VOIDmode);\n       last_clock_var = clock;\n@@ -1605,7 +1464,7 @@ queue_to_ready (ready)\n     {\n       register int stalls;\n \n-      for (stalls = 1; stalls <= MAX_INSN_QUEUE_INDEX; stalls++)\n+      for (stalls = 1; stalls < INSN_QUEUE_SIZE; stalls++)\n \t{\n \t  if ((link = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)]))\n \t    {\n@@ -1624,28 +1483,13 @@ queue_to_ready (ready)\n \t\t}\n \t      insn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = 0;\n \n-\t      /* Advance time on one cycle.  */\n-\t      if (targetm.sched.use_dfa_pipeline_interface)\n-\t\t{\n-\t\t  if (targetm.sched.dfa_pre_cycle_insn)\n-\t\t    state_transition (curr_state,\n-\t\t\t\t      (*targetm.sched.dfa_pre_cycle_insn) ());\n-\n-\t\t  state_transition (curr_state, NULL);\n-\n-\t\t  if (targetm.sched.dfa_post_cycle_insn)\n-\t\t    state_transition (curr_state,\n-\t\t\t\t      (*targetm.sched.dfa_post_cycle_insn) ());\n-\t\t}\n-\n \t      if (ready->n_ready)\n \t\tbreak;\n \t    }\n \t}\n \n-      if (!targetm.sched.use_dfa_pipeline_interface && sched_verbose && stalls)\n+      if (sched_verbose && stalls)\n \tvisualize_stall_cycles (stalls);\n-\n       q_ptr = NEXT_Q_AFTER (q_ptr, stalls);\n       clock_var += stalls;\n     }\n@@ -1661,10 +1505,7 @@ debug_ready_list (ready)\n   int i;\n \n   if (ready->n_ready == 0)\n-    {\n-      fprintf (sched_dump, \"\\n\");\n-      return;\n-    }\n+    return;\n \n   p = ready_lastpos (ready);\n   for (i = 0; i < ready->n_ready; i++)\n@@ -1776,117 +1617,6 @@ move_insn (insn, last)\n   return retval;\n }\n \n-/* The following function returns maximal (or close to maximal) number\n-   of insns which can be issued on the same cycle and one of which\n-   insns is insns with the best rank (the last insn in READY).  To\n-   make this function tries different samples of ready insns.  READY\n-   is current queue `ready'.  Global array READY_TRY reflects what\n-   insns are already issued in this try.  STATE is current processor\n-   state.  If the function returns nonzero, INDEX will contain index\n-   of the best insn in READY.  *LAST_P is nonzero if the insn with the\n-   highest rank is in the current sample.  The following function is\n-   used only for first cycle multipass scheduling.  */\n-\n-static int\n-max_issue (ready, state, index, last_p)\n-     struct ready_list *ready;\n-     state_t state;\n-     int *index;\n-     int *last_p;\n-     \n-{\n-  int i, best, n, temp_index, delay;\n-  state_t temp_state;\n-  rtx insn;\n-  int max_lookahead = (*targetm.sched.first_cycle_multipass_dfa_lookahead) ();\n-\n-  if (state_dead_lock_p (state))\n-    return 0;\n-  \n-  temp_state = alloca (dfa_state_size);\n-  best = 0;\n-  \n-  for (i = 0; i < ready->n_ready; i++)\n-    if (!ready_try [i])\n-      {\n-\tinsn = ready_element (ready, i);\n-\t\n-\tif (INSN_CODE (insn) < 0)\n-\t  continue;\n-\t\n-\tmemcpy (temp_state, state, dfa_state_size);\n-\t\n-\tdelay = state_transition (temp_state, insn);\n-\t\n-\tif (delay == 0)\n-\t  {\n-\t    if (!targetm.sched.dfa_bubble)\n-\t      continue;\n-\t    else\n-\t      {\n-\t\tint j;\n-\t\trtx bubble;\n-\t\t\n-\t\tfor (j = 0;\n-\t\t     (bubble = (*targetm.sched.dfa_bubble) (j)) != NULL_RTX;\n-\t\t     j++)\n-\t\t  if (state_transition (temp_state, bubble) < 0\n-\t\t      && state_transition (temp_state, insn) < 0)\n-\t\t    break;\n-\t\t\n-\t\tif (bubble == NULL_RTX)\n-\t\t  continue;\n-\t      }\n-\t  }\n-\telse if (delay > 0)\n-\t  continue;\n-\t\n-\t--max_lookahead;\n-\t\n-\tif (max_lookahead < 0)\n-\t  break;\n-\t\n-\tready_try [i] = 1;\n-\t*last_p = 0;\n-\t\n-\tn = max_issue (ready, temp_state, &temp_index, last_p) + 1;\n-\t\n-\tif (best < n && (ready_try [0] || *last_p))\n-\t  {\n-\t    best = n;\n-\t    *index = i;\n-\t    *last_p = 1;\n-\t  }\n-\tready_try [i] = 0;\n-      }\n-  \n-  return best;\n-}\n-\n-/* The following function chooses insn from READY and modifies\n-   *N_READY and READY.  The following function is used only for first\n-   cycle multipass scheduling.  */\n-\n-static rtx\n-choose_ready (ready)\n-     struct ready_list *ready;\n-{\n-  if (!targetm.sched.first_cycle_multipass_dfa_lookahead\n-      || (*targetm.sched.first_cycle_multipass_dfa_lookahead) () <= 0)\n-    return ready_remove_first (ready);\n-  else\n-    {\n-      /* Try to choose the better insn.  */\n-      int index;\n-      int last_p = 0;\n-      \n-      if (max_issue (ready, curr_state, &index, &last_p) == 0)\n-\treturn ready_remove_first (ready);\n-      else\n-\treturn ready_remove (ready, index);\n-    }\n-}\n-\n /* Use forward list scheduling to rearrange insns of block B in region RGN,\n    possibly bringing insns from subsequent blocks in the same region.  */\n \n@@ -1897,9 +1627,7 @@ schedule_block (b, rgn_n_insns)\n {\n   rtx last;\n   struct ready_list ready;\n-  int first_cycle_insn_p;\n   int can_issue_more;\n-  state_t temp_state = NULL;  /* It is used for multipass scheduling.  */\n \n   /* Head/tail info for this block.  */\n   rtx prev_head = current_sched_info->prev_head;\n@@ -1932,25 +1660,14 @@ schedule_block (b, rgn_n_insns)\n       init_block_visualization ();\n     }\n \n-  if (targetm.sched.use_dfa_pipeline_interface)\n-    state_reset (curr_state);\n-  else\n-    clear_units ();\n+  clear_units ();\n \n   /* Allocate the ready list.  */\n   ready.veclen = rgn_n_insns + 1 + issue_rate;\n   ready.first = ready.veclen - 1;\n   ready.vec = (rtx *) xmalloc (ready.veclen * sizeof (rtx));\n   ready.n_ready = 0;\n \n-  if (targetm.sched.use_dfa_pipeline_interface)\n-    {\n-      /* It is used for first cycle multipass scheduling.  */\n-      temp_state = alloca (dfa_state_size);\n-      ready_try = (char *) xmalloc ((rgn_n_insns + 1) * sizeof (char));\n-      memset (ready_try, 0, (rgn_n_insns + 1) * sizeof (char));\n-    }\n-\n   (*current_sched_info->init_ready_list) (&ready);\n \n   if (targetm.sched.md_init)\n@@ -1963,15 +1680,8 @@ schedule_block (b, rgn_n_insns)\n      queue.  */\n   q_ptr = 0;\n   q_size = 0;\n-\n-  if (!targetm.sched.use_dfa_pipeline_interface)\n-    max_insn_queue_index_macro_value = INSN_QUEUE_SIZE - 1;\n-  else\n-    max_insn_queue_index_macro_value = max_insn_queue_index;\n-\n-  insn_queue = (rtx *) alloca ((MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n-  memset ((char *) insn_queue, 0, (MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n-  last_clock_var = -1;\n+  last_clock_var = 0;\n+  memset ((char *) insn_queue, 0, sizeof (insn_queue));\n \n   /* Start just before the beginning of time.  */\n   clock_var = -1;\n@@ -1984,20 +1694,6 @@ schedule_block (b, rgn_n_insns)\n     {\n       clock_var++;\n \n-      if (targetm.sched.use_dfa_pipeline_interface)\n-\t{\n-\t  if (targetm.sched.dfa_pre_cycle_insn)\n-\t    state_transition (curr_state,\n-\t\t\t      (*targetm.sched.dfa_pre_cycle_insn) ());\n-\n-\t  /* Advance time on one cycle.  */\n-\t  state_transition (curr_state, NULL);\n-\n-\t  if (targetm.sched.dfa_post_cycle_insn)\n-\t    state_transition (curr_state,\n-\t\t\t      (*targetm.sched.dfa_post_cycle_insn) ());\n-\t}\n-\n       /* Add to the ready list all pending insns that can be issued now.\n          If there are no ready insns, increment clock until one\n          is ready and add all pending insns at that point to the ready\n@@ -2029,122 +1725,20 @@ schedule_block (b, rgn_n_insns)\n       else\n \tcan_issue_more = issue_rate;\n \n-      first_cycle_insn_p = 1;\n-      for (;;)\n+      if (sched_verbose)\n \t{\n-\t  rtx insn;\n-\t  int cost;\n-\n-\t  if (sched_verbose)\n-\t    {\n-\t      fprintf (sched_dump, \";;\\tReady list (t =%3d):  \",\n-\t\t       clock_var);\n-\t      debug_ready_list (&ready);\n-\t    }\n-\n-\t  if (!targetm.sched.use_dfa_pipeline_interface)\n-\t    {\n-\t      if (ready.n_ready == 0 || !can_issue_more\n-\t\t  || !(*current_sched_info->schedule_more_p) ())\n-\t\tbreak;\n-\t      insn = choose_ready (&ready);\n-\t      cost = actual_hazard (insn_unit (insn), insn, clock_var, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (ready.n_ready == 0 || !can_issue_more\n-\t\t  || state_dead_lock_p (curr_state)\n-\t\t  || !(*current_sched_info->schedule_more_p) ())\n-\t\tbreak;\n-\t      \n-\t      /* Select and remove the insn from the ready list.  */\n-\t      insn = choose_ready (&ready);\n-\t      \n-\t      if (recog_memoized (insn) < 0)\n-\t\t{\n-\t\t  if (!first_cycle_insn_p\n-\t\t      && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n-\t\t\t  || asm_noperands (PATTERN (insn)) >= 0))\n-\t\t    /* This is asm insn which is tryed to be issued on the\n-\t\t       cycle not first.  Issue it on the next cycle.  */\n-\t\t    cost = 1;\n-\t\t  else\n-\t\t    /* A USE insn, or something else we don't need to\n-\t\t       understand.  We can't pass these directly to\n-\t\t       state_transition because it will trigger a\n-\t\t       fatal error for unrecognizable insns.  */\n-\t\t    cost = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  cost = state_transition (curr_state, insn);\n-\n-\t\t  if (targetm.sched.first_cycle_multipass_dfa_lookahead\n-\t\t      && targetm.sched.dfa_bubble)\n-\t\t    {\n-\t\t      if (cost == 0)\n-\t\t\t{\n-\t\t\t  int j;\n-\t\t\t  rtx bubble;\n-\t\t\t  \n-\t\t\t  for (j = 0;\n-\t\t\t       (bubble = (*targetm.sched.dfa_bubble) (j))\n-\t\t\t\t != NULL_RTX;\n-\t\t\t       j++)\n-\t\t\t    {\n-\t\t\t      memcpy (temp_state, curr_state, dfa_state_size);\n-\t\t\t      \n-\t\t\t      if (state_transition (temp_state, bubble) < 0\n-\t\t\t\t  && state_transition (temp_state, insn) < 0)\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t  \n-\t\t\t  if (bubble != NULL_RTX)\n-\t\t\t    {\n-\t\t\t      memcpy (curr_state, temp_state, dfa_state_size);\n-\t\t\t      \n-\t\t\t      if (insert_schedule_bubbles_p)\n-\t\t\t\t{\n-\t\t\t\t  rtx copy;\n-\t\t\t\t  \n-\t\t\t\t  copy = copy_rtx (PATTERN (bubble));\n-\t\t\t\t  emit_insn_after (copy, last);\n-\t\t\t\t  last = NEXT_INSN (last);\n-\t\t\t\t  INSN_CODE (last) = INSN_CODE (bubble);\n-\t\t\t\t  \n-\t\t\t\t  /* Annotate the same for the first insns\n-\t\t\t\t     scheduling by using mode.  */\n-\t\t\t\t  PUT_MODE (last, (clock_var > last_clock_var\n-\t\t\t\t\t\t   ? clock_var - last_clock_var\n-\t\t\t\t\t\t   : VOIDmode));\n-\t\t\t\t  last_clock_var = clock_var;\n-\t\t\t\t  \n-\t\t\t\t  if (sched_verbose >= 2)\n-\t\t\t\t    {\n-\t\t\t\t      fprintf (sched_dump,\n-\t\t\t\t\t       \";;\\t\\t--> scheduling bubble insn <<<%d>>>:reservation \",\n-\t\t\t\t\t       INSN_UID (last));\n-\t\t\t\t      \n-\t\t\t\t      if (recog_memoized (last) < 0)\n-\t\t\t\t\tfprintf (sched_dump, \"nothing\");\n-\t\t\t\t      else\n-\t\t\t\t\tprint_reservation (sched_dump, last);\n-\t\t\t\t      \n-\t\t\t\t      fprintf (sched_dump, \"\\n\");\n-\t\t\t\t    }\n-\t\t\t\t}\n-\t\t\t      cost = -1;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  if (cost < 0)\n-\t\t    cost = 0;\n-\t\t  else if (cost == 0)\n-\t\t    cost = 1;\n-\t\t}\n-\t    }\n+\t  fprintf (sched_dump, \"\\n;;\\tReady list (t =%3d):  \", clock_var);\n+\t  debug_ready_list (&ready);\n+\t}\n \n+      /* Issue insns from ready list.  */\n+      while (ready.n_ready != 0\n+\t     && can_issue_more\n+\t     && (*current_sched_info->schedule_more_p) ())\n+\t{\n+\t  /* Select and remove the insn from the ready list.  */\n+\t  rtx insn = ready_remove_first (&ready);\n+\t  int cost = actual_hazard (insn_unit (insn), insn, clock_var, 0);\n \n \t  if (cost >= 1)\n \t    {\n@@ -2168,8 +1762,6 @@ schedule_block (b, rgn_n_insns)\n \t  schedule_insn (insn, &ready, clock_var);\n \n \tnext:\n-\t  first_cycle_insn_p = 0;\n-\n \t  if (targetm.sched.reorder2)\n \t    {\n \t      /* Sort the ready list based on priority.  */\n@@ -2183,8 +1775,8 @@ schedule_block (b, rgn_n_insns)\n \t    }\n \t}\n \n-      if (!targetm.sched.use_dfa_pipeline_interface && sched_verbose)\n-\t/* Debug info.  */\n+      /* Debug info.  */\n+      if (sched_verbose)\n \tvisualize_scheduled_insns (clock_var);\n     }\n \n@@ -2196,8 +1788,7 @@ schedule_block (b, rgn_n_insns)\n     {\n       fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n-      if (!targetm.sched.use_dfa_pipeline_interface)\n-\tprint_block_visualization (\"\");\n+      print_block_visualization (\"\");\n     }\n \n   /* Sanity check -- queue must be empty now.  Meaningless if region has\n@@ -2242,9 +1833,6 @@ schedule_block (b, rgn_n_insns)\n   current_sched_info->tail = tail;\n \n   free (ready.vec);\n-\n-  if (targetm.sched.use_dfa_pipeline_interface)\n-    free (ready_try);\n }\n \f\n /* Set_priorities: compute priority of each insn in the block.  */\n@@ -2286,7 +1874,6 @@ sched_init (dump_file)\n {\n   int luid, b;\n   rtx insn;\n-  int i;\n \n   /* Disable speculative loads in their presence if cc0 defined.  */\n #ifdef HAVE_cc0\n@@ -2314,26 +1901,6 @@ sched_init (dump_file)\n \n   h_i_d = (struct haifa_insn_data *) xcalloc (old_max_uid, sizeof (*h_i_d));\n \n-  for (i = 0; i < old_max_uid; i++)\n-    h_i_d [i].cost = -1;\n-\n-  if (targetm.sched.use_dfa_pipeline_interface)\n-    {\n-      if (targetm.sched.init_dfa_pre_cycle_insn)\n-\t(*targetm.sched.init_dfa_pre_cycle_insn) ();\n-      \n-      if (targetm.sched.init_dfa_post_cycle_insn)\n-\t(*targetm.sched.init_dfa_post_cycle_insn) ();\n-      \n-      if (targetm.sched.first_cycle_multipass_dfa_lookahead\n-\t  && targetm.sched.init_dfa_bubbles)\n-\t(*targetm.sched.init_dfa_bubbles) ();\n-      \n-      dfa_start ();\n-      dfa_state_size = state_size ();\n-      curr_state = xmalloc (dfa_state_size);\n-    }\n-\n   h_i_d[0].luid = 0;\n   luid = 1;\n   for (b = 0; b < n_basic_blocks; b++)\n@@ -2391,8 +1958,8 @@ sched_init (dump_file)\n \t}\n     }\n \n-  if (!targetm.sched.use_dfa_pipeline_interface && sched_verbose)\n-    /* Find units used in this function, for visualization.  */\n+  /* Find units used in this fuction, for visualization.  */\n+  if (sched_verbose)\n     init_target_units ();\n \n   /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n@@ -2418,12 +1985,6 @@ void\n sched_finish ()\n {\n   free (h_i_d);\n-\n-  if (targetm.sched.use_dfa_pipeline_interface)\n-    {\n-      free (curr_state);\n-      dfa_finish ();\n-    }\n   free_dependency_caches ();\n   end_alias_analysis ();\n   if (write_symbols != NO_DEBUG)"}, {"sha": "80f8e5c33880a03b3c2151c9023381b64a8b85ed", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -333,144 +333,6 @@ DEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", 'x')\n /* Refers to the address of its argument.  This is only used in alias.c.  */\n DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n \n-/* ----------------------------------------------------------------------\n-   Constructions for CPU pipeline description described by NDFAs.\n-   These do not appear in actual rtl code in the compiler.\n-   ---------------------------------------------------------------------- */\n-\n-/* (define_cpu_unit string [string]) describes cpu functional\n-   units (separated by comma).\n-\n-   1st operand: Names of cpu functional units.\n-   2nd operand: Name of automaton (see comments for DEFINE_AUTOMATON).\n-\n-   All define_reservations, define_cpu_units, and\n-   define_query_cpu_units should have unique names which may not be\n-   \"nothing\".  */\n-DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", 'x')\n-\n-/* (define_query_cpu_unit string [string]) describes cpu functional\n-   units analogously to define_cpu_unit.  If we use automaton without\n-   minimization, the reservation of such units can be queried for\n-   automaton state.  */\n-DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", 'x')\n-\n-/* (exclusion_set string string) means that each CPU functional unit\n-   in the first string can not be reserved simultaneously with any\n-   unit whose name is in the second string and vise versa.  CPU units\n-   in the string are separated by commas.  For example, it is useful\n-   for description CPU with fully pipelined floating point functional\n-   unit which can execute simultaneously only single floating point\n-   insns or only double floating point insns.  */\n-DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", 'x')\n-\n-/* (presence_set string string) means that each CPU functional unit in\n-   the first string can not be reserved unless at least one of units\n-   whose names are in the second string is reserved.  This is an\n-   asymmetric relation.  CPU units in the string are separated by\n-   commas.  For example, it is useful for description that slot1 is\n-   reserved after slot0 reservation for VLIW processor.  */\n-DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", 'x')\n-\n-/* (absence_set string string) means that each CPU functional unit in\n-   the first string can not be reserved only if each unit whose name\n-   is in the second string is not reserved.  This is an asymmetric\n-   relation (actually exclusion set is analogous to this one but it is\n-   symmetric).  CPU units in the string are separated by commas.  For\n-   example, it is useful for description that slot0 can not be\n-   reserved after slot1 or slot2 reservation for VLIW processor.  */\n-DEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", 'x')\n-\n-/* (define_bypass number out_insn_names in_insn_names) names bypass\n-   with given latency (the first number) from insns given by the first\n-   string (see define_insn_reservation) into insns given by the second\n-   string.  Insn names in the strings are separated by commas.  The\n-   third operand is optional name of function which is additional\n-   guard for the bypass.  The function will get the two insns as\n-   parameters.  If the function returns zero the bypass will be\n-   ignored for this case.  Additional guard is necessary to recognize\n-   complicated bypasses, e.g. when consumer is load address.  */\n-DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", 'x')\n-\n-/* (define_automaton string) describes names of automata generated and\n-   used for pipeline hazards recognition.  The names are separated by\n-   comma.  Actually it is possibly to generate the single automaton\n-   but unfortunately it can be very large.  If we use more one\n-   automata, the summary size of the automata usually is less than the\n-   single one.  The automaton name is used in define_cpu_unit and\n-   define_query_cpu_unit.  All automata should have unique names.  */\n-DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", 'x')\n-\n-/* (automata_option string) describes option for generation of\n-   automata.  Currently there are the following options:\n-\n-   o \"no-minimization\" which makes no minimization of automata.  This\n-     is only worth to do when we are going to query CPU functional\n-     unit reservations in an automaton state.\n-\n-   o \"w\" which means generation of file describing the result\n-     automaton.  The file can be used for the description verification.\n-\n-   o \"ndfa\" which makes nondeterministic finite state automata.  */\n-DEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", 'x')\n-\n-/* (define_reservation string string) names reservation (the first\n-   string) of cpu functional units (the 2nd string).  Sometimes unit\n-   reservations for different insns contain common parts.  In such\n-   case, you can describe common part and use its name (the 1st\n-   parameter) in regular expression in define_insn_reservation.  All\n-   define_reservations, define_cpu_units, and define_query_cpu_units\n-   should have unique names which may not be \"nothing\".  */\n-DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", 'x')\n-\n-/* (define_insn_reservation name default_latency condition regexpr)\n-   describes reservation of cpu functional units (the 3nd operand) for\n-   instruction which is selected by the condition (the 2nd parameter).\n-   The first parameter is used for output of debugging information.\n-   The reservations are described by a regular expression according\n-   the following syntax:\n-\n-       regexp = regexp \",\" oneof\n-              | oneof\n-\n-       oneof = oneof \"|\" allof\n-             | allof\n-\n-       allof = allof \"+\" repeat\n-             | repeat\n- \n-       repeat = element \"*\" number\n-              | element\n-\n-       element = cpu_function_unit_name\n-               | reservation_name\n-               | result_name\n-               | \"nothing\"\n-               | \"(\" regexp \")\"\n-\n-       1. \",\" is used for describing start of the next cycle in\n-       reservation.\n-\n-       2. \"|\" is used for describing the reservation described by the\n-       first regular expression *or* the reservation described by the\n-       second regular expression *or* etc.\n-\n-       3. \"+\" is used for describing the reservation described by the\n-       first regular expression *and* the reservation described by the\n-       second regular expression *and* etc.\n-\n-       4. \"*\" is used for convinience and simply means sequence in\n-       which the regular expression are repeated NUMBER times with\n-       cycle advancing (see \",\").\n-\n-       5. cpu functional unit name which means its reservation.\n-\n-       6. reservation name -- see define_reservation.\n-\n-       7. string \"nothing\" means no units reservation.  */\n-\n-DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", 'x')\n-\n /* ----------------------------------------------------------------------\n    Expressions used for insn attributes.  These also do not appear in\n    actual rtl code in the compiler."}, {"sha": "3a0a019f0f0cba95f5df73ccb2cc7481eeb18d08", "filename": "gcc/rtl.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -110,9 +110,11 @@ struct rtx_def\n   ENUM_BITFIELD(machine_mode) mode : 8;\n \n   /* 1 in an INSN if it can alter flow of control\n-     within this function.  */\n+     within this function.\n+     LINK_COST_ZERO in an INSN_LIST.  */\n   unsigned int jump : 1;\n-  /* 1 in an INSN if it can call another function.  */\n+  /* 1 in an INSN if it can call another function.\n+     LINK_COST_FREE in an INSN_LIST.  */\n   unsigned int call : 1;\n   /* 1 in a REG if value of this expression will never change during\n      the current function, even though it is not manifestly constant.\n@@ -897,6 +899,16 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n    with the preceding insn.  */\n #define SCHED_GROUP_P(INSN) ((INSN)->in_struct)\n \n+/* During sched, for the LOG_LINKS of an insn, these cache the adjusted\n+   cost of the dependence link.  The cost of executing an instruction\n+   may vary based on how the results are used.  LINK_COST_ZERO is 1 when\n+   the cost through the link varies and is unchanged (i.e., the link has\n+   zero additional cost).  LINK_COST_FREE is 1 when the cost through the\n+   link is zero (i.e., the link makes the cost free).  In other cases,\n+   the adjustment to the cost is recomputed each time it is needed.  */\n+#define LINK_COST_ZERO(X) ((X)->jump)\n+#define LINK_COST_FREE(X) ((X)->call)\n+\n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n #define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)"}, {"sha": "0637813d7649edc5a3e83247ed0b764fe337c64f", "filename": "gcc/sched-int.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -20,9 +20,6 @@ along with GCC; see the file COPYING.  If not, write to the Free the\n Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-/* Pointer to data describing the current DFA state.  */\n-extern state_t curr_state;\n-\n /* Forward declaration.  */\n struct ready_list;\n \n@@ -184,7 +181,7 @@ struct haifa_insn_data\n   int dep_count;\n \n   /* An encoding of the blockage range function.  Both unit and range\n-     are coded.  This member is used only for old pipeline interface.  */\n+     are coded.  */\n   unsigned int blockage;\n \n   /* Number of instructions referring to this insn.  */\n@@ -196,8 +193,7 @@ struct haifa_insn_data\n \n   short cost;\n \n-  /* An encoding of the function units used.  This member is used only\n-     for old pipeline interface.  */\n+  /* An encoding of the function units used.  */\n   short units;\n \n   /* This weight is an estimation of the insn's contribution to"}, {"sha": "e0a2a63e338c59c2c7ddbd2fe63132c5ad62f4f7", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 23, "deletions": 71, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -61,7 +61,6 @@ Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"sched-int.h\"\n-#include \"target.h\"\n \n #ifdef INSN_SCHEDULING\n /* Some accessor macros for h_i_d members only used within this file.  */\n@@ -2143,13 +2142,7 @@ init_ready_list (ready)\n \n \t    if (!CANT_MOVE (insn)\n \t\t&& (!IS_SPECULATIVE_INSN (insn)\n-\t\t    || ((0\n-\t\t\t || (targetm.sched.use_dfa_pipeline_interface\n-\t\t\t     && recog_memoized (insn) >= 0\n-\t\t\t     && min_insn_conflict_delay (curr_state, insn,\n-\t\t\t\t\t\t\t insn) <= 3)\n-\t\t\t || (!targetm.sched.use_dfa_pipeline_interface\n-\t\t\t     && insn_issue_delay (insn) <= 3))\n+\t\t    || (insn_issue_delay (insn) <= 3\n \t\t\t&& check_live (insn, bb_src)\n \t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n \t      {\n@@ -2257,13 +2250,7 @@ new_ready (next)\n       && (!IS_VALID (INSN_BB (next))\n \t  || CANT_MOVE (next)\n \t  || (IS_SPECULATIVE_INSN (next)\n-\t      && (0\n-\t\t  || (targetm.sched.use_dfa_pipeline_interface\n-\t\t      && (recog_memoized (next) < 0\n-\t\t\t  || min_insn_conflict_delay (curr_state, next,\n-\t\t\t\t\t\t      next) > 3))\n-\t\t  || (!targetm.sched.use_dfa_pipeline_interface\n-\t\t      && insn_issue_delay (next) > 3)\n+\t      && (insn_issue_delay (next) > 3\n \t\t  || !check_live (next, INSN_BB (next))\n \t\t  || !is_exception_free (next, INSN_BB (next), target_bb)))))\n     return 0;\n@@ -2655,26 +2642,14 @@ debug_dependencies ()\n \t  fprintf (sched_dump, \"\\n;;   --- Region Dependences --- b %d bb %d \\n\",\n \t\t   BB_TO_BLOCK (bb), bb);\n \n-\t  if (targetm.sched.use_dfa_pipeline_interface)\n-\t    {\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n-\t\t       \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\",\n-\t\t       \"reservation\");\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n-\t\t       \"----\", \"----\", \"--\", \"---\", \"----\", \"----\",\n-\t\t       \"-----------\");\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n-\t      \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\", \"blockage\", \"units\");\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n-\t      \"----\", \"----\", \"--\", \"---\", \"----\", \"----\", \"--------\", \"-----\");\n-\t    }\n-\n+\t  fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n+\t  \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\", \"blockage\", \"units\");\n+\t  fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n+\t  \"----\", \"----\", \"--\", \"---\", \"----\", \"----\", \"--------\", \"-----\");\n \t  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n \t    {\n \t      rtx link;\n+\t      int unit, range;\n \n \t      if (! INSN_P (insn))\n \t\t{\n@@ -2694,45 +2669,22 @@ debug_dependencies ()\n \t\t  continue;\n \t\t}\n \n-\t      if (targetm.sched.use_dfa_pipeline_interface)\n-\t\t{\n-\t\t  fprintf (sched_dump,\n-\t\t\t   \";;   %s%5d%6d%6d%6d%6d%6d   \",\n-\t\t\t   (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n-\t\t\t   INSN_UID (insn),\n-\t\t\t   INSN_CODE (insn),\n-\t\t\t   INSN_BB (insn),\n-\t\t\t   INSN_DEP_COUNT (insn),\n-\t\t\t   INSN_PRIORITY (insn),\n-\t\t\t   insn_cost (insn, 0, 0));\n-\t\t  \n-\t\t  if (recog_memoized (insn) < 0)\n-\t\t    fprintf (sched_dump, \"nothing\");\n-\t\t  else\n-\t\t    print_reservation (sched_dump, insn);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  int unit = insn_unit (insn);\n-\t\t  int range\n-\t\t    = (unit < 0\n-\t\t       || function_units[unit].blockage_range_function == 0\n-\t\t       ? 0\n-\t\t       : function_units[unit].blockage_range_function (insn));\n-\t\t  fprintf (sched_dump,\n-\t\t\t   \";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   \",\n-\t\t\t   (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n-\t\t\t   INSN_UID (insn),\n-\t\t\t   INSN_CODE (insn),\n-\t\t\t   INSN_BB (insn),\n-\t\t\t   INSN_DEP_COUNT (insn),\n-\t\t\t   INSN_PRIORITY (insn),\n-\t\t\t   insn_cost (insn, 0, 0),\n-\t\t\t   (int) MIN_BLOCKAGE_COST (range),\n-\t\t\t   (int) MAX_BLOCKAGE_COST (range));\n-\t\t  insn_print_units (insn);\n-\t\t}\n-\n+\t      unit = insn_unit (insn);\n+\t      range = (unit < 0\n+\t\t || function_units[unit].blockage_range_function == 0) ? 0 :\n+\t\tfunction_units[unit].blockage_range_function (insn);\n+\t      fprintf (sched_dump,\n+\t\t       \";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   \",\n+\t\t       (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n+\t\t       INSN_UID (insn),\n+\t\t       INSN_CODE (insn),\n+\t\t       INSN_BB (insn),\n+\t\t       INSN_DEP_COUNT (insn),\n+\t\t       INSN_PRIORITY (insn),\n+\t\t       insn_cost (insn, 0, 0),\n+\t\t       (int) MIN_BLOCKAGE_COST (range),\n+\t\t       (int) MAX_BLOCKAGE_COST (range));\n+\t      insn_print_units (insn);\n \t      fprintf (sched_dump, \"\\t: \");\n \t      for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n \t\tfprintf (sched_dump, \"%d \", INSN_UID (XEXP (link, 0)));"}, {"sha": "90521a24703a82f98eae6f1b8798fb0320fd32b8", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -31,16 +31,14 @@ Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"insn-attr.h\"\n #include \"sched-int.h\"\n-#include \"target.h\"\n \n #ifdef INSN_SCHEDULING\n /* target_units bitmask has 1 for each unit in the cpu.  It should be\n    possible to compute this variable from the machine description.\n    But currently it is computed by examining the insn list.  Since\n    this is only needed for visualization, it seems an acceptable\n    solution.  (For understanding the mapping of bits to units, see\n-   definition of function_units[] in \"insn-attrtab.c\".)  The scheduler\n-   using only DFA description should never use the following variable.  */\n+   definition of function_units[] in \"insn-attrtab.c\".)  */\n \n static int target_units = 0;\n \n@@ -124,13 +122,6 @@ get_visual_tbl_length ()\n   int n, n1;\n   char *s;\n \n-  if (targetm.sched.use_dfa_pipeline_interface)\n-    {\n-      visual_tbl_line_length = 1;\n-      return 1; /* Can't return 0 because that will cause problems\n-                   with alloca.  */\n-    }\n-\n   /* Compute length of one field in line.  */\n   s = (char *) alloca (INSN_LEN + 6);\n   sprintf (s, \"  %33s\", \"uname\");\n@@ -818,8 +809,7 @@ print_insn (buf, x, verbose)\n     }\n }\t\t\t\t/* print_insn */\n \n-/* Print visualization debugging info.  The scheduler using only DFA\n-   description should never use the following function.  */\n+/* Print visualization debugging info.  */\n \n void\n print_block_visualization (s)"}, {"sha": "3282b3ca24959fc55d3f94dcce1b146a2f75c50a", "filename": "gcc/target-def.h", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -93,33 +93,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SCHED_REORDER 0\n #define TARGET_SCHED_REORDER2 0\n #define TARGET_SCHED_CYCLE_DISPLAY 0\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE 0\n-#define TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN 0\n-#define TARGET_SCHED_DFA_PRE_CYCLE_INSN 0\n-#define TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN 0\n-#define TARGET_SCHED_DFA_POST_CYCLE_INSN 0\n-#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD 0\n-#define TARGET_SCHED_INIT_DFA_BUBBLES 0\n-#define TARGET_SCHED_DFA_BUBBLE 0\n-\n-#define TARGET_SCHED\t\t\t\t\t\t\\\n-  {TARGET_SCHED_ADJUST_COST,\t\t\t\t\t\\\n-   TARGET_SCHED_ADJUST_PRIORITY,\t\t\t\t\\\n-   TARGET_SCHED_ISSUE_RATE,\t\t\t\t\t\\\n-   TARGET_SCHED_VARIABLE_ISSUE,\t\t\t\t\t\\\n-   TARGET_SCHED_INIT,\t\t\t\t\t\t\\\n-   TARGET_SCHED_FINISH,\t\t\t\t\t\t\\\n-   TARGET_SCHED_REORDER,\t\t\t\t\t\\\n-   TARGET_SCHED_REORDER2,\t\t\t\t\t\\\n-   TARGET_SCHED_CYCLE_DISPLAY,\t\t\t\t\t\\\n-   TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\t\t\t\\\n-   TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\t\t\t\\\n-   TARGET_SCHED_DFA_PRE_CYCLE_INSN,\t\t\t\t\\\n-   TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\t\t\t\\\n-   TARGET_SCHED_DFA_POST_CYCLE_INSN,\t\t\t\t\\\n-   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\t\t\\\n-   TARGET_SCHED_INIT_DFA_BUBBLES,\t\t\t\t\\\n-   TARGET_SCHED_DFA_BUBBLE}\n+\n+#define TARGET_SCHED\t{TARGET_SCHED_ADJUST_COST,\t\\\n+\t\t\t TARGET_SCHED_ADJUST_PRIORITY,\t\\\n+\t\t\t TARGET_SCHED_ISSUE_RATE,\t\\\n+\t\t\t TARGET_SCHED_VARIABLE_ISSUE,\t\\\n+\t\t\t TARGET_SCHED_INIT,\t\t\\\n+\t\t\t TARGET_SCHED_FINISH,\t\t\\\n+\t\t\t TARGET_SCHED_REORDER,\t\t\\\n+\t\t\t TARGET_SCHED_REORDER2,\t\t\\\n+\t\t\t TARGET_SCHED_CYCLE_DISPLAY}\n \n /* All in tree.c.  */\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes"}, {"sha": "8d73f496ba0d4a58a2512918c0d7f355a48869b3", "filename": "gcc/target.h", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=b8ec576419e8dd1e335dd16d22a0cd7a9b1865e0", "patch": "@@ -113,47 +113,6 @@ struct gcc_target\n        insn in the new chain we're building.  Returns a new LAST.\n        The default is to do nothing.  */\n     rtx (* cycle_display) PARAMS ((int clock, rtx last));\n-    /* The following member value is a pointer to a function returning\n-       nonzero if we should use DFA based scheduling.  The default is\n-       to use the old pipeline scheduler.  */\n-    int (* use_dfa_pipeline_interface) PARAMS ((void));\n-    /* The values of all the following members are used only for the\n-       DFA based scheduler: */\n-    /* The values of the following four members are pointers to\n-       functions used to simplify the automaton descriptions.\n-       dfa_pre_cycle_insn and dfa_post_cycle_insn give functions\n-       returning insns which are used to change the pipeline hazard\n-       recognizer state when the new simulated processor cycle\n-       correspondingly starts and finishes.  The function defined by\n-       init_dfa_pre_cycle_insn and init_dfa_post_cycle_insn are used\n-       to initialize the corresponding insns.  The default values of\n-       the memebers result in not changing the automaton state when\n-       the new simulated processor cycle correspondingly starts and\n-       finishes.  */\n-    void (* init_dfa_pre_cycle_insn) PARAMS ((void));\n-    rtx (* dfa_pre_cycle_insn) PARAMS ((void));\n-    void (* init_dfa_post_cycle_insn) PARAMS ((void));\n-    rtx (* dfa_post_cycle_insn) PARAMS ((void));\n-    /* The following member value is a pointer to a function returning value\n-       which defines how many insns in queue `ready' will we try for\n-       multi-pass scheduling.  if the member value is nonzero and the\n-       function returns positive value, the DFA based scheduler will make\n-       multi-pass scheduling for the first cycle.  In other words, we will\n-       try to choose ready insn which permits to start maximum number of\n-       insns on the same cycle.  */\n-    int (* first_cycle_multipass_dfa_lookahead) PARAMS ((void));\n-    /* The values of the following members are pointers to functions\n-       used to improve the first cycle multipass scheduling by\n-       inserting nop insns.  dfa_scheduler_bubble gives a function\n-       returning a nop insn with given index.  The indexes start with\n-       zero.  The function should return NULL if there are no more nop\n-       insns with indexes greater than given index.  To initialize the\n-       nop insn the function given by member\n-       init_dfa_scheduler_bubbles is used.  The default values of the\n-       members result in not inserting nop insns during the multipass\n-       scheduling.  */\n-    void (* init_dfa_bubbles) PARAMS ((void));\n-    rtx (* dfa_bubble) PARAMS ((int));\n   } sched;\n \n   /* Given two decls, merge their attributes and return the result.  */"}]}