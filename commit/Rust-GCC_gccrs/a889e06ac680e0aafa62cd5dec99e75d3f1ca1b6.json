{"sha": "a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg4OWUwNmFjNjgwZTBhYWZhNjJjZDVkZWM5OWU3NWQzZjFjYTFiNg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-09-17T07:34:29Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-01T15:10:47Z"}, "message": "Convert vr-values to value query class.\n\ngcc/ChangeLog:\n\n\t* gimple-loop-versioning.cc (lv_dom_walker::before_dom_children):\n\tPass m_range_analyzer instead of get_vr_values.\n\t(loop_versioning::name_prop::get_value): Rename to...\n\t(loop_versioning::name_prop::value_of_expr): ...this.\n\t* gimple-ssa-evrp-analyze.c (evrp_range_analyzer::evrp_range_analyzer):\n\tAdjust for evrp_range_analyzer\n\tinheriting from vr_values.\n\t(evrp_range_analyzer::try_find_new_range): Same.\n\t(evrp_range_analyzer::record_ranges_from_incoming_edge): Same.\n\t(evrp_range_analyzer::record_ranges_from_phis): Same.\n\t(evrp_range_analyzer::record_ranges_from_stmt): Same.\n\t(evrp_range_analyzer::push_value_range): Same.\n\t(evrp_range_analyzer::pop_value_range): Same.\n\t* gimple-ssa-evrp-analyze.h (class evrp_range_analyzer): Inherit from\n\tvr_values.  Adjust accordingly.\n\t* gimple-ssa-evrp.c: Adjust for evrp_range_analyzer inheriting from\n\tvr_values.\n\t(evrp_folder::value_of_evrp): Rename from get_value.\n\t* tree-ssa-ccp.c (class ccp_folder): Rename get_value to\n\tvalue_of_expr.\n\t(ccp_folder::get_value): Rename to...\n\t(ccp_folder::value_of_expr): ...this.\n\t* tree-ssa-copy.c (class copy_folder): Rename get_value to\n\tvalue_of_expr.\n\t(copy_folder::get_value): Rename to...\n\t(copy_folder::value_of_expr): ...this.\n\t* tree-ssa-dom.c (dom_opt_dom_walker::after_dom_children): Adjust\n\tfor evrp_range_analyzer inheriting from vr_values.\n\t(dom_opt_dom_walker::optimize_stmt): Same.\n\t* tree-ssa-propagate.c (substitute_and_fold_engine::replace_uses_in):\n\tCall value_of_* instead of get_value.\n\t(substitute_and_fold_engine::replace_phi_args_in): Same.\n\t(substitute_and_fold_engine::propagate_into_phi_args): Same.\n\t(substitute_and_fold_dom_walker::before_dom_children): Same.\n\t* tree-ssa-propagate.h: Include value-query.h.\n\t(class substitute_and_fold_engine): Inherit from value_query.\n\t* tree-ssa-strlen.c (strlen_dom_walker::before_dom_children):\n\tAdjust for evrp_range_analyzer inheriting from vr_values.\n\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n\tSame.\n\t* tree-vrp.c (class vrp_folder): Same.\n\t(vrp_folder::get_value): Rename to value_of_expr.\n\t* vr-values.c (vr_values::get_lattice_entry): Adjust for\n\tvr_values inheriting from range_query.\n\t(vr_values::range_of_expr): New.\n\t(vr_values::value_of_expr): New.\n\t(vr_values::value_on_edge): New.\n\t(vr_values::value_of_stmt): New.\n\t(simplify_using_ranges::op_with_boolean_value_range_p): Call\n\tget_value_range through query.\n\t(check_for_binary_op_overflow): Rename store to query.\n\t(vr_values::vr_values): Remove vrp_value_range_pool.\n\t(vr_values::~vr_values): Same.\n\t(simplify_using_ranges::get_vr_for_comparison): Call get_value_range\n\tthrough query.\n\t(simplify_using_ranges::compare_names): Same.\n\t(simplify_using_ranges::vrp_evaluate_conditional): Same.\n\t(simplify_using_ranges::vrp_visit_cond_stmt): Same.\n\t(simplify_using_ranges::simplify_abs_using_ranges): Same.\n\t(simplify_using_ranges::simplify_cond_using_ranges_1): Same.\n\t(simplify_cond_using_ranges_2): Same.\n\t(simplify_using_ranges::simplify_switch_using_ranges): Same.\n\t(simplify_using_ranges::two_valued_val_range_p): Same.\n\t(simplify_using_ranges::simplify_using_ranges): Rename store to query.\n\t(simplify_using_ranges::simplify): Assert that we have a query.\n\t* vr-values.h (class range_query): Remove.\n\t(class simplify_using_ranges): Remove inheritance of range_query.\n\t(class vr_values): Add virtuals for range_of_expr, value_of_expr,\n\tvalue_on_edge, value_of_stmt, and get_value_range.\n\tCall range_query allocator instead of using vrp_value_range_pool.\n\tRemove vrp_value_range_pool.\n\t(simplify_using_ranges::get_value_range): Remove.", "tree": {"sha": "a725f803b72e952bc35ce737ef2893bd0628b084", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a725f803b72e952bc35ce737ef2893bd0628b084"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b99da898a9817e72fedb4063589648b7961ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b99da898a9817e72fedb4063589648b7961ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04b99da898a9817e72fedb4063589648b7961ac5"}], "stats": {"total": 285, "additions": 139, "deletions": 146}, "files": [{"sha": "afe353e452db57f57cd402a3bd051af02a083ae5", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -277,7 +277,7 @@ class loop_versioning\n   {\n   public:\n     name_prop (loop_info &li) : m_li (li) {}\n-    tree get_value (tree, gimple *) FINAL OVERRIDE;\n+    tree value_of_expr (tree name, gimple *) FINAL OVERRIDE;\n \n   private:\n     /* Information about the versioning we've performed on the loop.  */\n@@ -512,8 +512,7 @@ loop_versioning::lv_dom_walker::before_dom_children (basic_block bb)\n   m_range_analyzer.enter (bb);\n \n   if (bb == bb->loop_father->header)\n-    m_lv.prune_loop_conditions (bb->loop_father,\n-\t\t\t\tm_range_analyzer.get_vr_values ());\n+    m_lv.prune_loop_conditions (bb->loop_father, &m_range_analyzer);\n \n   for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n        gsi_next (&si))\n@@ -534,8 +533,7 @@ loop_versioning::lv_dom_walker::after_dom_children (basic_block bb)\n    Return the new value if so, otherwise return null.  */\n \n tree\n-loop_versioning::name_prop::get_value (tree val,\n-\t\t\t\t       gimple *stmt ATTRIBUTE_UNUSED)\n+loop_versioning::name_prop::value_of_expr (tree val, gimple *)\n {\n   if (TREE_CODE (val) == SSA_NAME\n       && bitmap_bit_p (&m_li.unity_names, SSA_NAME_VERSION (val)))"}, {"sha": "485774d3f22ebc2988086f4b969120e4a1e20c78", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -54,7 +54,6 @@ evrp_range_analyzer::evrp_range_analyzer (bool update_global_ranges)\n       FOR_EACH_EDGE (e, ei, bb->preds)\n         e->flags |= EDGE_EXECUTABLE;\n     }\n-  vr_values = new class vr_values;\n }\n \n /* Push an unwinding marker onto the unwinding stack.  */\n@@ -87,15 +86,14 @@ evrp_range_analyzer::try_find_new_range (tree name,\n   const value_range_equiv *old_vr = get_value_range (name);\n \n   /* Discover VR when condition is true.  */\n-  vr_values->extract_range_for_var_from_comparison_expr (name, code, op,\n-\t\t\t\t\t\t\t limit, &vr);\n+  extract_range_for_var_from_comparison_expr (name, code, op, limit, &vr);\n   /* If we found any usable VR, set the VR to ssa_name and create a\n      PUSH old value in the stack with the old VR.  */\n   if (!vr.undefined_p () && !vr.varying_p ())\n     {\n       if (old_vr->equal_p (vr, /*ignore_equivs=*/true))\n \treturn NULL;\n-      value_range_equiv *new_vr = vr_values->allocate_value_range_equiv ();\n+      value_range_equiv *new_vr = allocate_value_range_equiv ();\n       new_vr->move (&vr);\n       return new_vr;\n     }\n@@ -214,7 +212,7 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n \t      tem.intersect (vrs[i].second);\n \t      if (tem.equal_p (*old_vr))\n \t\t{\n-\t\t  vr_values->free_value_range (vrs[i].second);\n+\t\t  free_value_range (vrs[i].second);\n \t\t  continue;\n \t\t}\n \t      push_value_range (vrs[i].first, vrs[i].second);\n@@ -261,7 +259,7 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n       value_range_equiv vr_result;\n       bool interesting = stmt_interesting_for_vrp (phi);\n       if (!has_unvisited_preds && interesting)\n-\tvr_values->extract_range_from_phi_node (phi, &vr_result);\n+\textract_range_from_phi_node (phi, &vr_result);\n       else\n \t{\n \t  vr_result.set_varying (TREE_TYPE (lhs));\n@@ -274,9 +272,9 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n \t      && interesting\n \t      && (l = loop_containing_stmt (phi))\n \t      && l->header == gimple_bb (phi))\n-\t  vr_values->adjust_range_with_scev (&vr_result, l, phi, lhs);\n+\t  adjust_range_with_scev (&vr_result, l, phi, lhs);\n \t}\n-      vr_values->update_value_range (lhs, &vr_result);\n+      update_value_range (lhs, &vr_result);\n \n       /* Set the SSA with the value range.  */\n       if (m_update_global_ranges)\n@@ -303,7 +301,7 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n     {\n       edge taken_edge;\n       value_range_equiv vr;\n-      vr_values->extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n+      extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n       if (output)\n \t{\n \t  /* Set the SSA with the value range.  There are two cases to\n@@ -321,7 +319,7 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n \t    {\n \t      /* Case one.  We can just update the underlying range\n \t\t information as well as the global information.  */\n-\t      vr_values->update_value_range (output, &vr);\n+\t      update_value_range (output, &vr);\n \t      if (m_update_global_ranges)\n \t\tset_ssa_range_info (output, &vr);\n \t    }\n@@ -332,18 +330,17 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n \t\t a new range and push the old range onto the stack.  We\n \t\t also have to be very careful about sharing the underlying\n \t\t bitmaps.  Ugh.  */\n-\t      value_range_equiv *new_vr\n-\t\t= vr_values->allocate_value_range_equiv ();\n+\t      value_range_equiv *new_vr = allocate_value_range_equiv ();\n \t      new_vr->set (vr.min (), vr.max (), NULL, vr.kind ());\n \t      vr.equiv_clear ();\n \t      push_value_range (output, new_vr);\n \t    }\n \t}\n       else\n-\tvr_values->set_defs_to_varying (stmt);\n+\tset_defs_to_varying (stmt);\n     }\n   else\n-    vr_values->set_defs_to_varying (stmt);\n+    set_defs_to_varying (stmt);\n \n   /* See if we can derive a range for any of STMT's operands.  */\n   tree op;\n@@ -429,7 +426,7 @@ evrp_range_analyzer::push_value_range (tree var, value_range_equiv *vr)\n       dump_value_range (dump_file, vr);\n       fprintf (dump_file, \"\\n\");\n     }\n-  value_range_equiv *old_vr = vr_values->swap_vr_value (var, vr);\n+  value_range_equiv *old_vr = swap_vr_value (var, vr);\n   stack.safe_push (std::make_pair (var, old_vr));\n }\n \n@@ -451,7 +448,7 @@ evrp_range_analyzer::pop_value_range ()\n     }\n   /* We saved off a lattice entry, now give it back and release\n      the one we popped.  */\n-  value_range_equiv *popped_vr = vr_values->swap_vr_value (var, vr);\n+  value_range_equiv *popped_vr = swap_vr_value (var, vr);\n   if (popped_vr)\n-    vr_values->free_value_range (popped_vr);\n+    free_value_range (popped_vr);\n }"}, {"sha": "c6d27f5c109a61f4df0cffe1f4f14496087dcb7c", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -20,13 +20,12 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_SSA_EVRP_ANALYZE_H\n #define GCC_GIMPLE_SSA_EVRP_ANALYZE_H\n \n-class evrp_range_analyzer\n+class evrp_range_analyzer : public vr_values\n {\n  public:\n   evrp_range_analyzer (bool update_global_ranges);\n   ~evrp_range_analyzer (void)\n   {\n-    delete vr_values;\n     stack.release ();\n   }\n \n@@ -36,34 +35,18 @@ class evrp_range_analyzer\n   void leave (basic_block);\n   void record_ranges_from_stmt (gimple *, bool);\n \n-  /* Main interface to retrieve range information.  */\n-  const value_range_equiv *get_value_range (const_tree op)\n-    { return vr_values->get_value_range (op); }\n-\n   /* Record a new unwindable range.  */\n   void push_value_range (tree var, value_range_equiv *vr);\n \n-  /* Dump all the current value ranges.  This is primarily\n-     a debugging interface.  */\n-  void dump_all_value_ranges (FILE *fp)\n-    { vr_values->dump_all_value_ranges (fp); }\n-\n   /* A bit of a wart.  This should ideally go away.  */\n   void vrp_visit_cond_stmt (gcond *cond, edge *e)\n   {\n-    simplify_using_ranges simpl (vr_values);\n+    simplify_using_ranges simpl (this);\n     simpl.vrp_visit_cond_stmt (cond, e);\n   }\n \n-  /* Get the underlying vr_values class instance.  If TRANSFER is\n-     true, then we are transferring ownership.  Else we keep ownership.\n-\n-     This should be converted to a unique_ptr.  */\n-  class vr_values *get_vr_values (void) { return vr_values; }\n-\n  private:\n   DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n-  class vr_values *vr_values;\n \n   void pop_value_range ();\n   value_range_equiv *try_find_new_range (tree, tree op, tree_code code,"}, {"sha": "60bf82a6805ad54ba0d3202a339ffe9d072aee5a", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -45,11 +45,11 @@ along with GCC; see the file COPYING3.  If not see\n class evrp_folder : public substitute_and_fold_engine\n {\n public:\n-  evrp_folder () : m_range_analyzer (/*update_global_ranges=*/true),\n-    m_vr_values (m_range_analyzer.get_vr_values ()),\n-    simplifier (m_vr_values)\n-  {\n-  }\n+  evrp_folder () :\n+    substitute_and_fold_engine (),\n+    m_range_analyzer (/*update_global_ranges=*/true),\n+    simplifier (&m_range_analyzer)\n+  { }\n \n   ~evrp_folder ()\n   {\n@@ -61,9 +61,9 @@ class evrp_folder : public substitute_and_fold_engine\n       }\n   }\n \n-  tree get_value (tree op, gimple *stmt ATTRIBUTE_UNUSED) OVERRIDE\n+  tree value_of_expr (tree name, gimple *stmt) OVERRIDE\n   {\n-    return m_vr_values->op_with_constant_singleton_value_range (op);\n+    return m_range_analyzer.value_of_expr (name, stmt);\n   }\n \n   void pre_fold_bb (basic_block bb) OVERRIDE\n@@ -95,14 +95,12 @@ class evrp_folder : public substitute_and_fold_engine\n \n   void post_new_stmt (gimple *stmt) OVERRIDE\n   {\n-    m_range_analyzer.get_vr_values ()->set_defs_to_varying (stmt);\n+    m_range_analyzer.set_defs_to_varying (stmt);\n   }\n \n private:\n   DISABLE_COPY_AND_ASSIGN (evrp_folder);\n-  class evrp_range_analyzer m_range_analyzer;\n-  class vr_values *m_vr_values;\n-\n+  evrp_range_analyzer m_range_analyzer;\n   simplify_using_ranges simplifier;\n };\n "}, {"sha": "0432fe5513dbaad82e474e4583237d5a881a8729", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -946,7 +946,7 @@ do_dbg_cnt (void)\n class ccp_folder : public substitute_and_fold_engine\n {\n  public:\n-  tree get_value (tree, gimple *) FINAL OVERRIDE;\n+  tree value_of_expr (tree, gimple *) FINAL OVERRIDE;\n   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n };\n \n@@ -955,7 +955,7 @@ class ccp_folder : public substitute_and_fold_engine\n    of calling member functions.  */\n \n tree\n-ccp_folder::get_value (tree op, gimple *stmt ATTRIBUTE_UNUSED)\n+ccp_folder::value_of_expr (tree op, gimple *)\n {\n   return get_constant_value (op);\n }"}, {"sha": "3d7798258291aa3df6f288b84a004f280432afe2", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -492,13 +492,13 @@ init_copy_prop (void)\n class copy_folder : public substitute_and_fold_engine\n {\n  public:\n-  tree get_value (tree, gimple *) FINAL OVERRIDE;\n+  tree value_of_expr (tree name, gimple *) FINAL OVERRIDE;\n };\n \n /* Callback for substitute_and_fold to get at the final copy-of values.  */\n \n tree\n-copy_folder::get_value (tree name, gimple *stmt ATTRIBUTE_UNUSED)\n+copy_folder::value_of_expr (tree name, gimple *)\n {\n   tree val;\n   if (SSA_NAME_VERSION (name) >= n_copy_of)"}, {"sha": "c21bfe9f64e643cc565c387564ae9c877c11faae", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -1500,7 +1500,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n void\n dom_opt_dom_walker::after_dom_children (basic_block bb)\n {\n-  x_vr_values = evrp_range_analyzer.get_vr_values ();\n+  x_vr_values = &evrp_range_analyzer;\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n \t\t\t m_avail_exprs_stack,\n \t\t\t &evrp_range_analyzer,\n@@ -1970,7 +1970,7 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n   opt_stats.num_stmts++;\n \n   /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */\n-  cprop_into_stmt (stmt, evrp_range_analyzer.get_vr_values ());\n+  cprop_into_stmt (stmt, &evrp_range_analyzer);\n \n   /* If the statement has been modified with constant replacements,\n      fold its RHS before checking for redundant computations.  */"}, {"sha": "87dbf55fab965b55d49155a51b89d59ac712cbc9", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -868,7 +868,7 @@ substitute_and_fold_engine::replace_uses_in (gimple *stmt)\n   FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       tree tuse = USE_FROM_PTR (use);\n-      tree val = get_value (tuse, stmt);\n+      tree val = value_of_expr (tuse, stmt);\n \n       if (val == tuse || val == NULL_TREE)\n \tcontinue;\n@@ -909,12 +909,11 @@ substitute_and_fold_engine::replace_phi_args_in (gphi *phi)\n \n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  tree val = get_value (arg, phi);\n+\t  edge e = gimple_phi_arg_edge (phi, i);\n+\t  tree val = value_on_edge (e, arg);\n \n \t  if (val && val != arg && may_propagate_copy (arg, val))\n \t    {\n-\t      edge e = gimple_phi_arg_edge (phi, i);\n-\n \t      if (TREE_CODE (val) != SSA_NAME)\n \t\tprop_stats.num_const_prop++;\n \t      else\n@@ -1036,7 +1035,7 @@ substitute_and_fold_engine::propagate_into_phi_args (basic_block bb)\n \t  if (TREE_CODE (arg) != SSA_NAME\n \t      || virtual_operand_p (arg))\n \t    continue;\n-\t  tree val = get_value (arg, phi);\n+\t  tree val = value_on_edge (e, arg);\n \t  if (val\n \t      && is_gimple_min_invariant (val)\n \t      && may_propagate_copy (arg, val))\n@@ -1070,7 +1069,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t}\n       if (res && TREE_CODE (res) == SSA_NAME)\n \t{\n-\t  tree sprime = substitute_and_fold_engine->get_value (res, phi);\n+\t  tree sprime = substitute_and_fold_engine->value_of_expr (res, phi);\n \t  if (sprime\n \t      && sprime != res\n \t      && may_propagate_copy (res, sprime))\n@@ -1110,7 +1109,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n       tree lhs = gimple_get_lhs (stmt);\n       if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t{\n-\t  tree sprime = substitute_and_fold_engine->get_value (lhs, stmt);\n+\t  tree sprime = substitute_and_fold_engine->value_of_expr (lhs, stmt);\n \t  if (sprime\n \t      && sprime != lhs\n \t      && may_propagate_copy (lhs, sprime)"}, {"sha": "da362ab562dad2ca127182f568d3f0656bc909c8", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef _TREE_SSA_PROPAGATE_H\n #define _TREE_SSA_PROPAGATE_H 1\n \n+#include \"value-query.h\"\n+\n /* If SIM_P is true, statement S will be simulated again.  */\n \n static inline void\n@@ -97,14 +99,13 @@ class ssa_propagation_engine\n   void simulate_block (basic_block);\n };\n \n-class substitute_and_fold_engine\n+class substitute_and_fold_engine : public value_query\n {\n  public:\n   substitute_and_fold_engine (bool fold_all_stmts = false)\n     : fold_all_stmts (fold_all_stmts) { }\n   virtual ~substitute_and_fold_engine (void) { }\n   virtual bool fold_stmt (gimple_stmt_iterator *) { return false; }\n-  virtual tree get_value (tree, gimple *) { return NULL_TREE; }\n \n   bool substitute_and_fold (basic_block = NULL);\n   bool replace_uses_in (gimple *);"}, {"sha": "9907cc0c8242031520d5ab25cd9c8ca244412da3", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -5860,7 +5860,7 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n \t can be used by printf argument processing.  */\n       evrp.record_ranges_from_stmt (stmt, false);\n \n-      if (check_and_optimize_stmt (&gsi, &cleanup_eh, evrp.get_vr_values ()))\n+      if (check_and_optimize_stmt (&gsi, &cleanup_eh, &evrp))\n \tgsi_next (&gsi);\n     }\n "}, {"sha": "f43d58122707ab82efd6d0c11248100193e5c0da", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -163,8 +163,8 @@ record_temporary_equivalences_from_phis (edge e,\n \t{\n \t  /* Get an empty new VR we can pass to update_value_range and save\n \t     away in the VR stack.  */\n-\t  vr_values *vr_values = evrp_range_analyzer->get_vr_values ();\n-\t  value_range_equiv *new_vr = vr_values->allocate_value_range_equiv ();\n+\t  value_range_equiv *new_vr\n+\t\t\t  = evrp_range_analyzer->allocate_value_range_equiv ();\n \t  new (new_vr) value_range_equiv ();\n \n \t  /* There are three cases to consider:\n@@ -178,7 +178,7 @@ record_temporary_equivalences_from_phis (edge e,\n \t       Otherwise set NEW_VR to varying.  This may be overly\n \t       conservative.  */\n \t  if (TREE_CODE (src) == SSA_NAME)\n-\t    new_vr->deep_copy (vr_values->get_value_range (src));\n+\t    new_vr->deep_copy (evrp_range_analyzer->get_value_range (src));\n \t  else if (TREE_CODE (src) == INTEGER_CST)\n \t    new_vr->set (src);\n \t  else"}, {"sha": "0e19690f41fab3314c20718e48f4098c6a725b1c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -4010,9 +4010,12 @@ class vrp_folder : public substitute_and_fold_engine\n     : substitute_and_fold_engine (/* Fold all stmts.  */ true),\n       m_vr_values (v), simplifier (v)\n     {  }\n-  tree get_value (tree, gimple *stmt) FINAL OVERRIDE;\n   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n \n+  tree value_of_expr (tree name, gimple *stmt) OVERRIDE\n+    {\n+      return m_vr_values->value_of_expr (name, stmt);\n+    }\n   class vr_values *m_vr_values;\n \n private:\n@@ -4023,8 +4026,6 @@ class vrp_folder : public substitute_and_fold_engine\n     { return simplifier.vrp_evaluate_conditional (code, op0, op1, stmt); }\n   bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n     { return simplifier.simplify (gsi); }\n- tree op_with_constant_singleton_value_range (tree op)\n-    { return m_vr_values->op_with_constant_singleton_value_range (op); }\n \n   simplify_using_ranges simplifier;\n };\n@@ -4102,18 +4103,6 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n   return simplify_stmt_using_ranges (si);\n }\n \n-/* If OP has a value range with a single constant value return that,\n-   otherwise return NULL_TREE.  This returns OP itself if OP is a\n-   constant.\n-\n-   Implemented as a pure wrapper right now, but this will change.  */\n-\n-tree\n-vrp_folder::get_value (tree op, gimple *stmt ATTRIBUTE_UNUSED)\n-{\n-  return op_with_constant_singleton_value_range (op);\n-}\n-\n /* Return the LHS of any ASSERT_EXPR where OP appears as the first\n    argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n    BB.  If no such ASSERT_EXPR is found, return OP.  */"}, {"sha": "4d7dfd0b4bfd66db51279ae70fc106394fb09439", "filename": "gcc/vr-values.c", "status": "modified", "additions": 74, "deletions": 31, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -92,7 +92,7 @@ vr_values::get_lattice_entry (const_tree var)\n     return vr;\n \n   /* Create a default value range.  */\n-  vr = new (vrp_value_range_pool.allocate ()) value_range_equiv;\n+  vr = allocate_value_range_equiv ();\n   vr_value[ver] = vr;\n \n   /* After propagation finished return varying.  */\n@@ -173,6 +173,49 @@ vr_values::get_value_range (const_tree var,\n   return vr;\n }\n \n+bool\n+vr_values::range_of_expr (irange &r, tree name, gimple *stmt)\n+{\n+  if (const value_range *vr = get_value_range (name, stmt))\n+    {\n+      if (vr->undefined_p () || vr->varying_p () || vr->constant_p ())\n+\tr = *vr;\n+      else\n+\t{\n+\t  value_range tmp = *vr;\n+\t  tmp.normalize_symbolics ();\n+\t  r = tmp;\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+tree\n+vr_values::value_of_expr (tree op, gimple *)\n+{\n+  return op_with_constant_singleton_value_range (op);\n+}\n+\n+tree\n+vr_values::value_on_edge (edge, tree op)\n+{\n+  return op_with_constant_singleton_value_range (op);\n+}\n+\n+tree\n+vr_values::value_of_stmt (gimple *stmt, tree op)\n+{\n+  if (!op)\n+    op = gimple_get_lhs (stmt);\n+\n+  gcc_checking_assert (!op|| op == gimple_get_lhs (stmt));\n+\n+  if (op)\n+    return op_with_constant_singleton_value_range (op);\n+  return NULL_TREE;\n+}\n+\n /* Set the lattice entry for DEF to VARYING.  */\n \n void\n@@ -451,7 +494,7 @@ simplify_using_ranges::op_with_boolean_value_range_p (tree op)\n \n   /* ?? Errr, this should probably check for [0,0] and [1,1] as well\n      as [0,1].  */\n-  const value_range *vr = get_value_range (op);\n+  const value_range *vr = query->get_value_range (op);\n   return *vr == value_range (build_zero_cst (TREE_TYPE (op)),\n \t\t\t     build_one_cst (TREE_TYPE (op)));\n }\n@@ -1006,20 +1049,20 @@ vr_values::extract_range_from_comparison (value_range_equiv *vr,\n    overflow.  */\n \n static bool\n-check_for_binary_op_overflow (range_query *store,\n+check_for_binary_op_overflow (range_query *query,\n \t\t\t      enum tree_code subcode, tree type,\n \t\t\t      tree op0, tree op1, bool *ovf)\n {\n   value_range vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *store->get_value_range (op0);\n+    vr0 = *query->get_value_range (op0);\n   else if (TREE_CODE (op0) == INTEGER_CST)\n     vr0.set (op0);\n   else\n     vr0.set_varying (TREE_TYPE (op0));\n \n   if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *store->get_value_range (op1);\n+    vr1 = *query->get_value_range (op1);\n   else if (TREE_CODE (op1) == INTEGER_CST)\n     vr1.set (op1);\n   else\n@@ -1948,8 +1991,7 @@ vr_values::dump_all_value_ranges (FILE *file)\n \n /* Initialize VRP lattice.  */\n \n-vr_values::vr_values () : vrp_value_range_pool (\"Tree VRP value ranges\"),\n-  simplifier (this)\n+vr_values::vr_values () : simplifier (this)\n {\n   values_propagated = false;\n   num_vr_values = num_ssa_names * 2;\n@@ -1966,7 +2008,6 @@ vr_values::~vr_values ()\n   free (vr_value);\n   free (vr_phi_edge_counts);\n   bitmap_obstack_release (&vrp_equiv_obstack);\n-  vrp_value_range_pool.release ();\n \n   /* So that we can distinguish between VRP data being available\n      and not available.  */\n@@ -2092,7 +2133,7 @@ const value_range_equiv *\n simplify_using_ranges::get_vr_for_comparison (int i, value_range_equiv *tem)\n {\n   /* Shallow-copy equiv bitmap.  */\n-  const value_range_equiv *vr = get_value_range (ssa_name (i));\n+  const value_range_equiv *vr = query->get_value_range (ssa_name (i));\n \n   /* If name N_i does not have a valid range, use N_i as its own\n      range.  This allows us to compare against names that may\n@@ -2117,7 +2158,7 @@ simplify_using_ranges::compare_name_with_value\n \t\t\t\t bool *strict_overflow_p, bool use_equiv_p)\n {\n   /* Get the set of equivalences for VAR.  */\n-  bitmap e = get_value_range (var)->equiv ();\n+  bitmap e = query->get_value_range (var)->equiv ();\n \n   /* Start at -1.  Set it to 0 if we do a comparison without relying\n      on overflow, or 1 if all comparisons rely on overflow.  */\n@@ -2197,8 +2238,8 @@ simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n {\n   /* Compare the ranges of every name equivalent to N1 against the\n      ranges of every name equivalent to N2.  */\n-  bitmap e1 = get_value_range (n1)->equiv ();\n-  bitmap e2 = get_value_range (n2)->equiv ();\n+  bitmap e1 = query->get_value_range (n1)->equiv ();\n+  bitmap e2 = query->get_value_range (n2)->equiv ();\n \n   /* Use the fake bitmaps if e1 or e2 are not available.  */\n   static bitmap s_e1 = NULL, s_e2 = NULL;\n@@ -2310,8 +2351,8 @@ simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n     (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p)\n {\n   const value_range_equiv *vr0, *vr1;\n-  vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n-  vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n+  vr0 = (TREE_CODE (op0) == SSA_NAME) ? query->get_value_range (op0) : NULL;\n+  vr1 = (TREE_CODE (op1) == SSA_NAME) ? query->get_value_range (op1) : NULL;\n \n   tree res = NULL_TREE;\n   if (vr0 && vr1)\n@@ -2390,7 +2431,7 @@ simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops\n \t    }\n \t  else\n \t    gcc_unreachable ();\n-\t  const value_range_equiv *vr0 = get_value_range (op0, stmt);\n+\t  const value_range_equiv *vr0 = query->get_value_range (op0, stmt);\n \t  /* If vro, the range for OP0 to pass the overflow test, has\n \t     no intersection with *vr0, OP0's known range, then the\n \t     overflow test can't pass, so return the node for false.\n@@ -2496,7 +2537,7 @@ simplify_using_ranges::vrp_evaluate_conditional (tree_code code, tree op0,\n \t always fold regardless of the value of OP0.  If -Wtype-limits\n \t was specified, emit a warning.  */\n       tree type = TREE_TYPE (op0);\n-      const value_range_equiv *vr0 = get_value_range (op0, stmt);\n+      const value_range_equiv *vr0 = query->get_value_range (op0, stmt);\n \n       if (vr0->varying_p ()\n \t  && INTEGRAL_TYPE_P (type)\n@@ -2547,7 +2588,7 @@ simplify_using_ranges::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n \t  fprintf (dump_file, \"\\t\");\n \t  print_generic_expr (dump_file, use);\n \t  fprintf (dump_file, \": \");\n-\t  dump_value_range (dump_file, get_value_range (use, stmt));\n+\t  dump_value_range (dump_file, query->get_value_range (use, stmt));\n \t}\n \n       fprintf (dump_file, \"\\n\");\n@@ -3123,7 +3164,7 @@ simplify_using_ranges::simplify_div_or_mod_using_ranges\n     }\n   else\n     {\n-      vr = get_value_range (op0, stmt);\n+      vr = query->get_value_range (op0, stmt);\n       if (range_int_cst_p (vr))\n \t{\n \t  op0min = vr->min ();\n@@ -3134,7 +3175,7 @@ simplify_using_ranges::simplify_div_or_mod_using_ranges\n   if (rhs_code == TRUNC_MOD_EXPR\n       && TREE_CODE (op1) == SSA_NAME)\n     {\n-      const value_range_equiv *vr1 = get_value_range (op1, stmt);\n+      const value_range_equiv *vr1 = query->get_value_range (op1, stmt);\n       if (range_int_cst_p (vr1))\n \top1min = vr1->min ();\n     }\n@@ -3283,7 +3324,7 @@ simplify_using_ranges::simplify_abs_using_ranges (gimple_stmt_iterator *gsi,\n \t\t\t\t\t\t  gimple *stmt)\n {\n   tree op = gimple_assign_rhs1 (stmt);\n-  const value_range *vr = get_value_range (op, stmt);\n+  const value_range *vr = query->get_value_range (op, stmt);\n \n   if (vr)\n     {\n@@ -3373,14 +3414,14 @@ simplify_using_ranges::simplify_bit_ops_using_ranges\n   wide_int mask;\n \n   if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *(get_value_range (op0, stmt));\n+    vr0 = *(query->get_value_range (op0, stmt));\n   else if (is_gimple_min_invariant (op0))\n     vr0.set (op0);\n   else\n     return false;\n \n   if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *(get_value_range (op1, stmt));\n+    vr1 = *(query->get_value_range (op1, stmt));\n   else if (is_gimple_min_invariant (op1))\n     vr1.set (op1);\n   else\n@@ -3599,7 +3640,7 @@ simplify_using_ranges::simplify_cond_using_ranges_1 (gcond *stmt)\n       && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n       && is_gimple_min_invariant (op1))\n     {\n-      const value_range *vr = get_value_range (op0, stmt);\n+      const value_range *vr = query->get_value_range (op0, stmt);\n \n       /* If we have range information for OP0, then we might be\n \t able to simplify this conditional. */\n@@ -3672,7 +3713,7 @@ simplify_using_ranges::simplify_cond_using_ranges_1 (gcond *stmt)\n    subsequent passes.  */\n \n void\n-simplify_cond_using_ranges_2 (vr_values *store, gcond *stmt)\n+simplify_cond_using_ranges_2 (vr_values *query, gcond *stmt)\n {\n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n@@ -3702,7 +3743,7 @@ simplify_cond_using_ranges_2 (vr_values *store, gcond *stmt)\n \t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n \t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n \t{\n-\t  const value_range *vr = store->get_value_range (innerop);\n+\t  const value_range *vr = query->get_value_range (innerop);\n \n \t  if (range_int_cst_p (vr)\n \t      && range_fits_type_p (vr,\n@@ -3743,7 +3784,7 @@ simplify_using_ranges::simplify_switch_using_ranges (gswitch *stmt)\n \n   if (TREE_CODE (op) == SSA_NAME)\n     {\n-      vr = get_value_range (op, stmt);\n+      vr = query->get_value_range (op, stmt);\n \n       /* We can only handle integer ranges.  */\n       if (vr->varying_p ()\n@@ -4036,7 +4077,7 @@ simplify_using_ranges::simplify_float_conversion_using_ranges\n \t\t\t\t\t gimple *stmt)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n-  const value_range *vr = get_value_range (rhs1, stmt);\n+  const value_range *vr = query->get_value_range (rhs1, stmt);\n   scalar_float_mode fltmode\n     = SCALAR_FLOAT_TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)));\n   scalar_int_mode mode;\n@@ -4141,7 +4182,7 @@ simplify_using_ranges::simplify_internal_call_using_ranges\n     return false;\n   else\n     type = TREE_TYPE (TREE_TYPE (gimple_call_lhs (stmt)));\n-  if (!check_for_binary_op_overflow (store, subcode, type, op0, op1, &ovf)\n+  if (!check_for_binary_op_overflow (query, subcode, type, op0, op1, &ovf)\n       || (is_ubsan && ovf))\n     return false;\n \n@@ -4200,7 +4241,7 @@ simplify_using_ranges::simplify_internal_call_using_ranges\n bool\n simplify_using_ranges::two_valued_val_range_p (tree var, tree *a, tree *b)\n {\n-  value_range vr = *get_value_range (var);\n+  value_range vr = *query->get_value_range (var);\n   vr.normalize_symbolics ();\n   if (vr.varying_p () || vr.undefined_p ())\n     return false;\n@@ -4217,8 +4258,8 @@ simplify_using_ranges::two_valued_val_range_p (tree var, tree *a, tree *b)\n   return false;\n }\n \n-simplify_using_ranges::simplify_using_ranges (range_query *store)\n-  : store (store)\n+simplify_using_ranges::simplify_using_ranges (range_query *query)\n+  : query (query)\n {\n   to_remove_edges = vNULL;\n   to_update_switch_stmts = vNULL;\n@@ -4234,6 +4275,8 @@ simplify_using_ranges::~simplify_using_ranges ()\n bool\n simplify_using_ranges::simplify (gimple_stmt_iterator *gsi)\n {\n+  gcc_checking_assert (query);\n+\n   gimple *stmt = gsi_stmt (*gsi);\n   if (is_gimple_assign (stmt))\n     {"}, {"sha": "a30f05cbeaa51385eea28090e7fa81d5fac2f412", "filename": "gcc/vr-values.h", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "patch": "@@ -21,28 +21,19 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_VR_VALUES_H\n \n #include \"value-range-equiv.h\"\n+#include \"value-query.h\"\n \n // Abstract class to return a range for a given SSA.\n \n-class range_query\n-{\n-public:\n-  virtual const value_range_equiv *get_value_range (const_tree,\n-\t\t\t\t\t\t    gimple * = NULL) = 0;\n-  virtual ~range_query () { }\n-};\n-\n // Class to simplify a statement using range information.\n-//\n-// The constructor takes a full vr_values, but all it needs is\n-// get_value_range() from it.  This class could be made to work with\n-// any range repository.\n \n-class simplify_using_ranges : public range_query\n+class simplify_using_ranges\n {\n public:\n-  simplify_using_ranges (class range_query *);\n+  simplify_using_ranges (class range_query *query = NULL);\n   ~simplify_using_ranges ();\n+  void set_range_query (class range_query *q) { query = q; }\n+\n   bool simplify (gimple_stmt_iterator *);\n \n   // ?? These should be cleaned, merged, and made private.\n@@ -53,8 +44,6 @@ class simplify_using_ranges : public range_query\n \t\t\t\t\t\tbool *, bool *);\n \n private:\n-  const value_range_equiv *get_value_range (const_tree op,\n-\t\t\t\t\t    gimple *stmt = NULL) OVERRIDE;\n   bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_abs_using_ranges (gimple_stmt_iterator *, gimple *);\n@@ -89,7 +78,7 @@ class simplify_using_ranges : public range_query\n \n   vec<edge> to_remove_edges;\n   vec<switch_update> to_update_switch_stmts;\n-  class range_query *store;\n+  class range_query *query;\n };\n \n /* The VR_VALUES class holds the current view of range information\n@@ -112,7 +101,12 @@ class vr_values : public range_query\n   vr_values (void);\n   ~vr_values (void);\n \n-  const value_range_equiv *get_value_range (const_tree, gimple * = NULL);\n+  virtual bool range_of_expr (irange &r, tree name, gimple *stmt) OVERRIDE;\n+  virtual tree value_of_expr (tree, gimple * = NULL) OVERRIDE;\n+  virtual tree value_on_edge (edge, tree) OVERRIDE;\n+  virtual tree value_of_stmt (gimple *, tree = NULL_TREE) OVERRIDE;\n+  virtual const value_range_equiv *get_value_range (const_tree,\n+\t\t\t\t\t\t    gimple * = NULL) OVERRIDE;\n   void set_vr_value (tree, value_range_equiv *);\n   value_range_equiv *swap_vr_value (tree, value_range_equiv *);\n \n@@ -136,9 +130,9 @@ class vr_values : public range_query\n \n   /* Allocate a new value_range object.  */\n   value_range_equiv *allocate_value_range_equiv (void)\n-    { return vrp_value_range_pool.allocate (); }\n+    { return range_query::allocate_value_range_equiv (); }\n   void free_value_range (value_range_equiv *vr)\n-    { vrp_value_range_pool.remove (vr); }\n+    { free_value_range_equiv (vr); }\n \n  private:\n   value_range_equiv *get_lattice_entry (const_tree);\n@@ -155,9 +149,6 @@ class vr_values : public range_query\n   void vrp_visit_assignment_or_call (gimple*, tree *, value_range_equiv *);\n   void vrp_visit_switch_stmt (gswitch *, edge *);\n \n-  /* Allocation pools for value_range objects.  */\n-  object_allocator<value_range_equiv> vrp_value_range_pool;\n-\n   /* This probably belongs in the lattice rather than in here.  */\n   bool values_propagated;\n \n@@ -176,12 +167,6 @@ class vr_values : public range_query\n   simplify_using_ranges simplifier;\n };\n \n-inline const value_range_equiv *\n-simplify_using_ranges::get_value_range (const_tree op, gimple *stmt)\n-{\n-  return store->get_value_range (op, stmt);\n-}\n-\n extern tree get_output_for_vrp (gimple *);\n \n // FIXME: Move this to tree-vrp.c."}]}