{"sha": "8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk1MzU3NGZhOWEwMzk4NjExZDc2YTlmZjJiOGEzYmM5ODFmOWM2OA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2018-04-18T19:14:28Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2018-04-18T19:14:28Z"}, "message": "i386: Insert ENDBR after __morestack call\n\nSince __morestack will jump back to its callee via indirect call, we\nneed to insert ENDBR after calling __morestack.\n\ngcc/\n\n\tPR target/85388\n\t* config/i386/i386.c (ix86_expand_split_stack_prologue): Insert\n\tENDBR after calling __morestack.\n\ngcc/testsuite/\n\n\tPR target/85388\n\t* gcc.dg/pr85388-1.c: New test.\n\t* gcc.dg/pr85388-2.c: Likewise.\n\t* gcc.dg/pr85388-3.c: Likewise.\n\t* gcc.dg/pr85388-4.c: Likewise.\n\t* gcc.dg/pr85388-5.c: Likewise.\n\t* gcc.dg/pr85388-6.c: Likewise.\n\nFrom-SVN: r259475", "tree": {"sha": "f64a1e19793f41f95f64754dee671bbf106b84d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f64a1e19793f41f95f64754dee671bbf106b84d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "05b14480611a6791e11f8f5811ca291e79ddbb46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b14480611a6791e11f8f5811ca291e79ddbb46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b14480611a6791e11f8f5811ca291e79ddbb46"}], "stats": {"total": 377, "additions": 376, "deletions": 1}, "files": [{"sha": "43bba1bc970a7f817611e13ee77c89ec690256bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -1,3 +1,9 @@\n+2018-04-18  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/85388\n+\t* config/i386/i386.c (ix86_expand_split_stack_prologue): Insert\n+\tENDBR after calling __morestack.\n+\n 2018-04-18  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/85384"}, {"sha": "d24c81b0dfebc526a0b2f67d450a1b315722a6ce", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -15265,7 +15265,16 @@ ix86_expand_split_stack_prologue (void)\n      instruction--we need control flow to continue at the subsequent\n      label.  Therefore, we use an unspec.  */\n   gcc_assert (crtl->args.pops_args < 65536);\n-  emit_insn (gen_split_stack_return (GEN_INT (crtl->args.pops_args)));\n+  rtx_insn *ret_insn\n+    = emit_insn (gen_split_stack_return (GEN_INT (crtl->args.pops_args)));\n+\n+  if ((flag_cf_protection & CF_BRANCH))\n+    {\n+      /* Insert ENDBR since __morestack will jump back here via indirect\n+\t call.  */\n+      rtx cet_eb = gen_nop_endbr ();\n+      emit_insn_after (cet_eb, ret_insn);\n+    }\n \n   /* If we are in 64-bit mode and this function uses a static chain,\n      we saved %r10 in %rax before calling _morestack.  */"}, {"sha": "9ac9731abb4f497ca0e9ceadfe1b9e18343be959", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -1,3 +1,13 @@\n+2018-04-18  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/85388\n+\t* gcc.dg/pr85388-1.c: New test.\n+\t* gcc.dg/pr85388-2.c: Likewise.\n+\t* gcc.dg/pr85388-3.c: Likewise.\n+\t* gcc.dg/pr85388-4.c: Likewise.\n+\t* gcc.dg/pr85388-5.c: Likewise.\n+\t* gcc.dg/pr85388-6.c: Likewise.\n+\n 2018-04-18  Jan Hubicka  <jh@suse.cz>\n \t    Martin Liska  <mliska@suse.cz>\n "}, {"sha": "86d4737e32bb69db8a1f08a8c607e44d164104d8", "filename": "gcc/testsuite/gcc.dg/pr85388-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-1.c?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -0,0 +1,50 @@\n+/* This test needs to use setrlimit to set the stack size, so it can\n+   only run on Unix.  */\n+/* { dg-do run { target { i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } } */\n+/* { dg-require-effective-target cet } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack -fcf-protection -mcet\" } */\n+\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+/* Each recursive call uses 10,000 bytes.  We call it 1000 times,\n+   using a total of 10,000,000 bytes.  If -fsplit-stack is not\n+   working, that will overflow our stack limit.  */\n+\n+static void\n+down (int i)\n+{\n+  char buf[10000];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      down (i - 1);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct rlimit r;\n+\n+  /* We set a stack limit because we are usually invoked via make, and\n+     make sets the stack limit to be as large as possible.  */\n+  r.rlim_cur = 8192 * 1024;\n+  r.rlim_max = 8192 * 1024;\n+  if (setrlimit (RLIMIT_STACK, &r) != 0)\n+    abort ();\n+  down (1000);\n+  return 0;\n+}"}, {"sha": "fd13d984c5046e4d0283762d9a89cf29520f5b3b", "filename": "gcc/testsuite/gcc.dg/pr85388-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-2.c?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run { target { i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } } */\n+/* { dg-require-effective-target cet } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-require-effective-target pthread_h } */\n+/* { dg-options \"-pthread -fsplit-stack -fcf-protection -mcet\" } */\n+\n+#include <stdlib.h>\n+#include <pthread.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+/* Each recursive call uses 10,000 bytes.  We call it 1000 times,\n+   using a total of 10,000,000 bytes.  If -fsplit-stack is not\n+   working, that will overflow our stack limit.  */\n+\n+static void\n+down (int i)\n+{\n+  char buf[10000];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      down (i - 1);\n+    }\n+}\n+\n+static void *\n+thread_routine (void *arg __attribute__ ((unused)))\n+{\n+  down (1000);\n+  return NULL;\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  pthread_t tid;\n+  void *dummy;\n+\n+  i = pthread_create (&tid, NULL, thread_routine, NULL);\n+  if (i != 0)\n+    abort ();\n+  i = pthread_join (tid, &dummy);\n+  if (i != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "730d2be9c2294b583a547ef41c00b221261b717b", "filename": "gcc/testsuite/gcc.dg/pr85388-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-3.c?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -0,0 +1,65 @@\n+/* This test needs to use setrlimit to set the stack size, so it can\n+   only run on Unix.  */\n+/* { dg-do run { target { i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } } */\n+/* { dg-require-effective-target cet } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack -fcf-protection -mcet\" } */\n+\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+/* Each recursive call uses 10,000 bytes.  We call it 1000 times,\n+   using a total of 10,000,000 bytes.  If -fsplit-stack is not\n+   working, that will overflow our stack limit.  */\n+\n+static void\n+down (int i, ...)\n+{\n+  char buf[10000];\n+  va_list ap;\n+\n+  va_start (ap, i);\n+  if (va_arg (ap, int) != 1\n+      || va_arg (ap, int) != 2\n+      || va_arg (ap, int) != 3\n+      || va_arg (ap, int) != 4\n+      || va_arg (ap, int) != 5\n+      || va_arg (ap, int) != 6\n+      || va_arg (ap, int) != 7\n+      || va_arg (ap, int) != 8\n+      || va_arg (ap, int) != 9\n+      || va_arg (ap, int) != 10)\n+    abort ();\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      down (i - 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct rlimit r;\n+\n+  /* We set a stack limit because we are usually invoked via make, and\n+     make sets the stack limit to be as large as possible.  */\n+  r.rlim_cur = 8192 * 1024;\n+  r.rlim_max = 8192 * 1024;\n+  if (setrlimit (RLIMIT_STACK, &r) != 0)\n+    abort ();\n+  down (1000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+  return 0;\n+}"}, {"sha": "03937d0e7350dd4ad68ed93653ec090cfe767e98", "filename": "gcc/testsuite/gcc.dg/pr85388-4.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-4.c?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -0,0 +1,69 @@\n+/* This test needs to use setrlimit to set the stack size, so it can\n+   only run on Unix.  */\n+/* { dg-do run { target { i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } } */\n+/* { dg-require-effective-target cet } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack -fcf-protection -mcet\" } */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf, size_t) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf, size_t c)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < c; ++i)\n+    buf[i] = (char) i;\n+}\n+\n+/* Each recursive call uses 10 * i bytes.  We call it 1000 times,\n+   using a total of 5,000,000 bytes.  If -fsplit-stack is not working,\n+   that will overflow our stack limit.  */\n+\n+static void\n+down1 (int i)\n+{\n+  char buf[10 * i];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf, 10 * i);\n+      down1 (i - 1);\n+    }\n+}\n+\n+/* Same thing, using alloca.  */\n+\n+static void\n+down2 (int i)\n+{\n+  char *buf = alloca (10 * i);\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf, 10 * i);\n+      down2 (i - 1);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct rlimit r;\n+\n+  /* We set a stack limit because we are usually invoked via make, and\n+     make sets the stack limit to be as large as possible.  */\n+  r.rlim_cur = 8192 * 1024;\n+  r.rlim_max = 8192 * 1024;\n+  if (setrlimit (RLIMIT_STACK, &r) != 0)\n+    abort ();\n+  down1 (1000);\n+  down2 (1000);\n+  return 0;\n+}"}, {"sha": "7462a40892c0235041c7726f69e4aade1387c338", "filename": "gcc/testsuite/gcc.dg/pr85388-5.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-5.c?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run { target { i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } } */\n+/* { dg-require-effective-target cet } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack -fcf-protection -mcet\" } */\n+\n+/* This test is like split-3.c, but tests with a smaller stack frame,\n+   since that uses a different prologue.  */\n+\n+#include <stdarg.h>\n+#include <stdlib.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+/* When using gold, the call to abort will force a stack split.  */\n+\n+static void\n+down (int i, ...)\n+{\n+  char buf[1];\n+  va_list ap;\n+\n+  va_start (ap, i);\n+  if (va_arg (ap, int) != 1\n+      || va_arg (ap, int) != 2\n+      || va_arg (ap, int) != 3\n+      || va_arg (ap, int) != 4\n+      || va_arg (ap, int) != 5\n+      || va_arg (ap, int) != 6\n+      || va_arg (ap, int) != 7\n+      || va_arg (ap, int) != 8\n+      || va_arg (ap, int) != 9\n+      || va_arg (ap, int) != 10)\n+    abort ();\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      down (i - 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  down (1000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+  return 0;\n+}"}, {"sha": "23b5d8e3df64dcecdc8366931be9dcfb5d371887", "filename": "gcc/testsuite/gcc.dg/pr85388-6.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8953574fa9a0398611d76a9ff2b8a3bc981f9c68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85388-6.c?ref=8953574fa9a0398611d76a9ff2b8a3bc981f9c68", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run { target { i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } } */\n+/* { dg-require-effective-target cet } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack -O2 -fcf-protection -mcet\" } */\n+/* { dg-options \"-fsplit-stack -O2 -mno-accumulate-outgoing-args -fcf-protection -mcet\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+\n+/* A case that used to fail on 32-bit x86 when optimizing and not\n+   using -maccumulate-args.  The stack adjustment of the alloca got\n+   mixed up with the arguments pushed on the stack to the function\n+   before the call of alloca.  */\n+\n+#include <stdlib.h>\n+\n+typedef struct { const char* s; int l; } s;\n+\n+typedef unsigned long long align16 __attribute__ ((aligned(16)));\n+\n+s gobats (const void *, int) __attribute__ ((noinline));\n+\n+s\n+gobats (const void* p __attribute__ ((unused)),\n+\tint l __attribute__ ((unused)))\n+{\n+  s v;\n+  v.s = 0;\n+  v.l = 0;\n+  return v;\n+}\n+\n+void check_aligned (void *p) __attribute__ ((noinline));\n+\n+void\n+check_aligned (void *p)\n+{\n+  if (((__SIZE_TYPE__) p & 0xf) != 0)\n+    abort ();\n+}\n+\n+void gap (void *) __attribute__ ((noinline));\n+\n+void gap (void *p)\n+{\n+  align16 a;\n+  check_aligned (&a);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  s *space;\n+  gobats(0, 16);\n+  space = (s *) alloca(sizeof(s) + 1);\n+  *space = (s){0, 16};\n+  gap(space);\n+  return 0;\n+}"}]}