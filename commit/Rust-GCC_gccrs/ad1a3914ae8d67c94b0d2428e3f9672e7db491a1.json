{"sha": "ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQxYTM5MTRhZThkNjdjOTRiMGQyNDI4ZTNmOTY3MmU3ZGI0OTFhMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-01-20T13:39:59Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-01-20T13:39:59Z"}, "message": "[PR 80005]  Fix __has_include\n\n__has_include is funky in that it is macro-like from the POV of #ifdef and\nfriends, but lexes its parenthesize argument #include-like.  We were\nfailing the second part of that, because we used a forwarding macro to an\ninternal name, and hence always lexed the argument in macro-parameter\ncontext.  We componded that by not setting the right flag when lexing, so\nit didn't even know.  Mostly users got lucky.\n\nThis reimplements the handline.\n1) Remove the forwarding, but declare object-like macros that\nexpand to themselves.  This satisfies the #ifdef requirement\n\n2) Correctly set angled_brackets when lexing the parameter.  This tells\nthe lexer (a) <...> is a header name and (b) \"...\" is too (not a string).\n\n3) Remove the in__has_include lexer state, just tell find_file that that's\nwhat's happenning, so it doesn't emit an error.\n\nWe lose the (undocumented) ability to #undef __has_include.  That may well\nhave been an accident of implementation.  There are no tests for it.\n\nWe gain __has_include behaviour for all users of the preprocessors -- not\njust the C-family ones that defined a forwarding macro.\n\n\tlibcpp/\n\tPR preprocessor/80005\n\t* include/cpplib.h (BT_HAS_ATTRIBUTE): Fix comment.\n\t* internal.h (struct lexer_state): Delete in__has_include field.\n\t(struct spec_nodes): Rename n__has_include{,_next}__ fields.\n\t(_cpp_defined_macro_p): New.\n\t(_cpp_find_file): Add has_include parm.\n\t* directives.c (lex_macro_node): Combine defined,\n\t__has_inline{,_next} checking.\n\t(do_ifdef, do_ifndef): Use _cpp_defined_macro_p.\n\t(_cpp_init_directives): Refactor.\n\t* expr.c (parse_defined): Use _cpp_defined_macro_p.\n\t(eval_token): Adjust parse_has_include calls.\n\t(parse_has_include): Add OP parameter.  Reimplement.\n\t* files.c (_cpp_find_file): Add HAS_INCLUDE parm.  Use it to\n\tinhibit error message.\n\t(_cpp_stack_include): Adjust _cpp_find_file call.\n\t(_cpp_fake_include, _cpp_compare_file_date): Likewise.\n\t(open_file_failed): Remove in__has_include check.\n\t(_cpp_has_header): Adjust _cpp_find_file call.\n\t* identifiers.c (_cpp_init_hashtable): Don't init\n\t__has_include{,_next} here ...\n\t* init.c (cpp_init_builtins): ... init them here.  Define as\n\tmacros.\n\t(cpp_read_main_file): Adjust _cpp_find_file call.\n\t* pch.c (cpp_read_state): Adjust __has_include{,_next} access.\n\t* traditional.c (_cpp_scan_out_locgical_line): Likewise.\n\n\tgcc/c-family/\n\tPR preprocessor/80005\n\t* c-cppbuiltins.c (c_cpp_builtins): Don't define __has_include{,_next}.\n\n\tgcc/testsuite/\n\tPR preprocessor/80005\n\t* g++.dg/cpp1y/feat-cxx14.C: Adjust.\n\t* g++.dg/cpp1z/feat-cxx17.C: Adjust.\n\t* g++.dg/cpp2a/feat-cxx2a.C: Adjust.\n\t* g++.dg/cpp/pr80005.C: New.", "tree": {"sha": "60f0771d802b20be5b8a827738e48324dcb24d2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60f0771d802b20be5b8a827738e48324dcb24d2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82ba180d6641a1e2bad1ac327234fc1cda658ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82ba180d6641a1e2bad1ac327234fc1cda658ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e82ba180d6641a1e2bad1ac327234fc1cda658ef"}], "stats": {"total": 241, "additions": 146, "deletions": 95}, "files": [{"sha": "fdddb98a74d1a97821854079278b5427e22816ce", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -1,3 +1,8 @@\n+2020-01-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR preprocessor/80005\n+\t* c-cppbuiltins.c (c_cpp_builtins): Don't define __has_include{,_next}.\n+\n 2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* c-common.c (co_await, co_yield, co_return): New."}, {"sha": "70a12055e278ad41a0cbc9a3ca20975c0e84a548", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -876,12 +876,6 @@ c_cpp_builtins (cpp_reader *pfile)\n   /* For stddef.h.  They require macros defined in c-common.c.  */\n   c_stddef_cpp_builtins ();\n \n-  /* Set include test macros for all C/C++ (not for just C++11 etc.)\n-     The builtins __has_include__ and __has_include_next__ are defined\n-     in libcpp.  */\n-  cpp_define (pfile, \"__has_include(STR)=__has_include__(STR)\");\n-  cpp_define (pfile, \"__has_include_next(STR)=__has_include_next__(STR)\");\n-\n   if (c_dialect_cxx ())\n     {\n       if (flag_weak && SUPPORTS_ONE_ONLY)"}, {"sha": "67d5f2e9e28677e6d748f4da57c76f9dd9327180", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -1,3 +1,11 @@\n+2020-01-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR preprocessor/80005\n+\t* g++.dg/cpp1y/feat-cxx14.C: Adjust.\n+\t* g++.dg/cpp1z/feat-cxx17.C: Adjust.\n+\t* g++.dg/cpp2a/feat-cxx2a.C: Adjust.\n+\t* g++.dg/cpp/pr80005.C: New.\n+\n 2020-01-20  Mark Eggleston  <mark.eggleston@codethink.com>\n \n \t* gfortran.dg/pr93263_1.f90: Change scan-tree-dump-not to"}, {"sha": "cc752616782f655d35cf24644ae537ffa19eb08e", "filename": "gcc/testsuite/g++.dg/cpp/pr80005.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fpr80005.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fpr80005.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fpr80005.C?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -0,0 +1,24 @@\n+// PR preprocessor/80005\n+// { dg-do preprocess }\n+\n+#undef vector\n+#define vector NOPE\n+#ifdef __has_include\n+\n+#if !__has_include (<vector>)\n+#error \"Header 'vector' could not be found\"\n+#endif\n+#define F(X) __has_include (X)\n+#if !F (<vector>)\n+#error \"Header 'vector' could not be found\" // { dg-error \"not be found\" }\n+#endif\n+\n+#if __has_include (\"not an escape! \\\")\t// comment\n+#endif\n+\n+#if F (\"is an escape \\\") gibberish \")\n+#endif\n+\n+#else\n+#error \"No __has_include\"\n+#endif"}, {"sha": "a78b6a36f36e1be190815c9dfad499f39e182ef3", "filename": "gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Ffeat-cxx14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Ffeat-cxx14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Ffeat-cxx14.C?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -236,20 +236,14 @@\n #  error \"__has_include\"\n #endif\n \n-//  Quoted complex.h should find at least the bracket version (use operator).\n-#if __has_include__ \"complex.h\"\n-#else\n-#  error \"complex.h\"\n-#endif\n-\n //  Try known bracket header (use operator).\n-#if __has_include__(<complex>)\n+#if __has_include (<complex>)\n #else\n #  error \"<complex>\"\n #endif\n \n //  Define and use a macro to invoke the operator.\n-#define sluggo(TXT) __has_include__(TXT)\n+#define sluggo(TXT) __has_include(TXT)\n \n #if sluggo(<complex>)\n #else"}, {"sha": "e6f456b24154b9680d756db4d4c66791ff68cc1c", "filename": "gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -225,20 +225,14 @@\n #  error \"__has_include\"\n #endif\n \n-//  Quoted complex.h should find at least the bracket version (use operator).\n-#if __has_include__ \"complex.h\"\n-#else\n-#  error \"complex.h\"\n-#endif\n-\n //  Try known bracket header (use operator).\n-#if __has_include__(<complex>)\n+#if __has_include (<complex>)\n #else\n #  error \"<complex>\"\n #endif\n \n //  Define and use a macro to invoke the operator.\n-#define sluggo(TXT) __has_include__(TXT)\n+#define sluggo(TXT) __has_include(TXT)\n \n #if sluggo(<complex>)\n #else"}, {"sha": "82fd602f9f1d592cc4deafb22af2dd176d259d9b", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -224,20 +224,14 @@\n #  error \"__has_include\"\n #endif\n \n-//  Quoted complex.h should find at least the bracket version (use operator).\n-#if __has_include__ \"complex.h\"\n-#else\n-#  error \"complex.h\"\n-#endif\n-\n //  Try known bracket header (use operator).\n-#if __has_include__(<complex>)\n+#if __has_include (<complex>)\n #else\n #  error \"<complex>\"\n #endif\n \n //  Define and use a macro to invoke the operator.\n-#define sluggo(TXT) __has_include__(TXT)\n+#define sluggo(TXT) __has_include(TXT)\n \n #if sluggo(<complex>)\n #else"}, {"sha": "27a841bbdcef48cd2d05546ac565a337045a559a", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -1,4 +1,31 @@\n-2020-01-17  Nathan Sidwell  <nathan@acm.org>\n+2020-01-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR preprocessor/80005\n+\t* include/cpplib.h (BT_HAS_ATTRIBUTE): Fix comment.\n+\t* internal.h (struct lexer_state): Delete in__has_include field.\n+\t(struct spec_nodes): Rename n__has_include{,_next}__ fields.\n+\t(_cpp_defined_macro_p): New.\n+\t(_cpp_find_file): Add has_include parm.\n+\t* directives.c (lex_macro_node): Combine defined,\n+\t__has_inline{,_next} checking.\n+\t(do_ifdef, do_ifndef): Use _cpp_defined_macro_p.\n+\t(_cpp_init_directives): Refactor.\n+\t* expr.c (parse_defined): Use _cpp_defined_macro_p.\n+\t(eval_token): Adjust parse_has_include calls.\n+\t(parse_has_include): Add OP parameter.  Reimplement.\n+\t* files.c (_cpp_find_file): Add HAS_INCLUDE parm.  Use it to\n+\tinhibit error message.\n+\t(_cpp_stack_include): Adjust _cpp_find_file call.\n+\t(_cpp_fake_include, _cpp_compare_file_date): Likewise.\n+\t(open_file_failed): Remove in__has_include check.\n+\t(_cpp_has_header): Adjust _cpp_find_file call.\n+\t* identifiers.c (_cpp_init_hashtable): Don't init\n+\t__has_include{,_next} here ...\n+\t* init.c (cpp_init_builtins): ... init them here.  Define as\n+\tmacros.\n+\t(cpp_read_main_file): Adjust _cpp_find_file call.\n+\t* pch.c (cpp_read_state): Adjust __has_include{,_next} access.\n+\t* traditional.c (_cpp_scan_out_locgical_line): Likewise.\n \n \tPR preprocessor/93306\n \t* expr.c (parse_has_include): Refactor.  Check skip_eval before"}, {"sha": "10735c8c6682290f476df51e6545db3b11a5cbe2", "filename": "libcpp/directives.c", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -595,14 +595,13 @@ lex_macro_node (cpp_reader *pfile, bool is_def_or_undef)\n     {\n       cpp_hashnode *node = token->val.node.node;\n \n-      if (is_def_or_undef && node == pfile->spec_nodes.n_defined)\n+      if (is_def_or_undef\n+\t  && (node == pfile->spec_nodes.n_defined\n+\t      || node == pfile->spec_nodes.n__has_include\n+\t      || node == pfile->spec_nodes.n__has_include_next))\n \tcpp_error (pfile, CPP_DL_ERROR,\n-\t\t   \"\\\"defined\\\" cannot be used as a macro name\");\n-      else if (is_def_or_undef\n-\t    && (node == pfile->spec_nodes.n__has_include__\n-\t     || node == pfile->spec_nodes.n__has_include_next__))\n-\tcpp_error (pfile, CPP_DL_ERROR,\n-\t\t   \"\\\"__has_include__\\\" cannot be used as a macro name\");\n+\t\t   \"\\\"%s\\\" cannot be used as a macro name\",\n+\t\t   NODE_NAME (node));\n       else if (! (node->flags & NODE_POISONED))\n \treturn node;\n     }\n@@ -1966,11 +1965,7 @@ do_ifdef (cpp_reader *pfile)\n \n       if (node)\n \t{\n-\t  /* Do not treat conditional macros as being defined.  This is due to\n-\t     the powerpc port using conditional macros for 'vector', 'bool',\n-\t     and 'pixel' to act as conditional keywords.  This messes up tests\n-\t     like #ifndef bool.  */\n-\t  skip = !cpp_macro_p (node) || (node->flags & NODE_CONDITIONAL);\n+\t  skip = !_cpp_defined_macro_p (node);\n \t  _cpp_mark_macro_used (node);\n \t  _cpp_maybe_notify_macro_use (pfile, node);\n \t  if (pfile->cb.used)\n@@ -1999,8 +1994,7 @@ do_ifndef (cpp_reader *pfile)\n \t     the powerpc port using conditional macros for 'vector', 'bool',\n \t     and 'pixel' to act as conditional keywords.  This messes up tests\n \t     like #ifndef bool.  */\n-\t  skip = (cpp_macro_p (node)\n-\t\t  && !(node->flags & NODE_CONDITIONAL));\n+\t  skip = _cpp_defined_macro_p (node);\n \t  _cpp_mark_macro_used (node);\n \t  _cpp_maybe_notify_macro_use (pfile, node);\n \t  if (pfile->cb.used)\n@@ -2638,12 +2632,9 @@ _cpp_pop_buffer (cpp_reader *pfile)\n void\n _cpp_init_directives (cpp_reader *pfile)\n {\n-  unsigned int i;\n-  cpp_hashnode *node;\n-\n-  for (i = 0; i < (unsigned int) N_DIRECTIVES; i++)\n+  for (int i = 0; i < N_DIRECTIVES; i++)\n     {\n-      node = cpp_lookup (pfile, dtable[i].name, dtable[i].length);\n+      cpp_hashnode *node = cpp_lookup (pfile, dtable[i].name, dtable[i].length);\n       node->is_directive = 1;\n       node->directive_index = i;\n     }"}, {"sha": "df21a4b9fb9f0992ab6fa90f921ce7cf33bd3e18", "filename": "libcpp/expr.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -64,7 +64,7 @@ static unsigned int interpret_float_suffix (cpp_reader *, const uchar *, size_t)\n static unsigned int interpret_int_suffix (cpp_reader *, const uchar *, size_t);\n static void check_promotion (cpp_reader *, const struct op *);\n \n-static cpp_num parse_has_include (cpp_reader *, enum include_type);\n+static cpp_num parse_has_include (cpp_reader *, cpp_hashnode *, include_type);\n \n /* Token type abuse to create unary plus and minus operators.  */\n #define CPP_UPLUS ((enum cpp_ttype) (CPP_LAST_CPP_OP + 1))\n@@ -1088,8 +1088,7 @@ parse_defined (cpp_reader *pfile)\n   result.unsignedp = false;\n   result.high = 0;\n   result.overflow = false;\n-  result.low = (node && cpp_macro_p (node)\n-\t\t&& !(node->flags & NODE_CONDITIONAL));\n+  result.low = node && _cpp_defined_macro_p (node);\n   return result;\n }\n \n@@ -1160,10 +1159,10 @@ eval_token (cpp_reader *pfile, const cpp_token *token,\n     case CPP_NAME:\n       if (token->val.node.node == pfile->spec_nodes.n_defined)\n \treturn parse_defined (pfile);\n-      else if (token->val.node.node == pfile->spec_nodes.n__has_include__)\n-\treturn parse_has_include (pfile, IT_INCLUDE);\n-      else if (token->val.node.node == pfile->spec_nodes.n__has_include_next__)\n-\treturn parse_has_include (pfile, IT_INCLUDE_NEXT);\n+      else if (token->val.node.node == pfile->spec_nodes.n__has_include)\n+\treturn parse_has_include (pfile, token->val.node.node, IT_INCLUDE);\n+      else if (token->val.node.node == pfile->spec_nodes.n__has_include_next)\n+\treturn parse_has_include (pfile, token->val.node.node, IT_INCLUDE_NEXT);\n       else if (CPP_OPTION (pfile, cplusplus)\n \t       && (token->val.node.node == pfile->spec_nodes.n_true\n \t\t   || token->val.node.node == pfile->spec_nodes.n_false))\n@@ -2190,9 +2189,9 @@ num_div_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op,\n   return lhs;\n }\n \n-/* Handle meeting \"__has_include__\" in a preprocessor expression.  */\n+/* Handle meeting \"__has_include\" in a preprocessor expression.  */\n static cpp_num\n-parse_has_include (cpp_reader *pfile, enum include_type type)\n+parse_has_include (cpp_reader *pfile, cpp_hashnode *op, include_type type)\n {\n   cpp_num result;\n \n@@ -2201,12 +2200,15 @@ parse_has_include (cpp_reader *pfile, enum include_type type)\n   result.overflow = false;\n   result.low = 0;\n \n-  pfile->state.in__has_include__++;\n-\n+  pfile->state.angled_headers = true;\n   const cpp_token *token = cpp_get_token (pfile);\n   bool paren = token->type == CPP_OPEN_PAREN;\n   if (paren)\n     token = cpp_get_token (pfile);\n+  else\n+    cpp_error (pfile, CPP_DL_ERROR,\n+\t       \"missing '(' before \\\"%s\\\" operand\", NODE_NAME (op));\n+  pfile->state.angled_headers = false;\n \n   bool bracket = token->type != CPP_STRING;\n   cpp_hashnode *node = NULL;\n@@ -2222,7 +2224,7 @@ parse_has_include (cpp_reader *pfile, enum include_type type)\n     fname = _cpp_bracket_include (pfile);\n   else\n     cpp_error (pfile, CPP_DL_ERROR,\n-\t       \"operator \\\"__has_include__\\\" requires a header string\");\n+\t       \"operator \\\"%s\\\" requires a header-name\", NODE_NAME (op));\n \n   if (fname)\n     {\n@@ -2237,14 +2239,10 @@ parse_has_include (cpp_reader *pfile, enum include_type type)\n \n   if (paren && !SEEN_EOL () && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)\n     cpp_error (pfile, CPP_DL_ERROR,\n-\t       \"missing ')' after \\\"__has_include__\\\"\");\n+\t       \"missing ')' after \\\"%s\\\" operand\", NODE_NAME (op));\n \n-  /* A possible controlling macro of the form #if !__has_include__ ().\n-     _cpp_parse_expr checks there was no other junk on the line.  */\n   if (node)\n     pfile->mi_ind_cmacro = node;\n \n-  pfile->state.in__has_include__--;\n-\n   return result;\n }"}, {"sha": "260e787c329e12982e9dabfa0e125877d49d7e6e", "filename": "libcpp/files.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -504,7 +504,8 @@ _cpp_find_failed (_cpp_file *file)\n \n _cpp_file *\n _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n-\t\tbool fake, int angle_brackets, bool implicit_preinclude,\n+\t\tint angle_brackets,\n+\t\tbool fake, bool implicit_preinclude, bool has_include,\n \t\tlocation_t loc)\n {\n   struct cpp_file_hash_entry *entry;\n@@ -592,7 +593,8 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \t\treturn NULL;\n \t      }\n \n-\t    open_file_failed (pfile, file, angle_brackets, loc);\n+\t    if (!has_include)\n+\t      open_file_failed (pfile, file, angle_brackets, loc);\n \t    break;\n \t  }\n \n@@ -1046,8 +1048,8 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n   if (!dir)\n     return false;\n \n-  _cpp_file *file = _cpp_find_file (pfile, fname, dir, false, angle_brackets,\n-\t\t\t\t    type == IT_DEFAULT, loc);\n+  _cpp_file *file = _cpp_find_file (pfile, fname, dir, angle_brackets,\n+\t\t\t\t    false, type == IT_DEFAULT, false, loc);\n   if (type == IT_DEFAULT && file == NULL)\n     return false;\n \n@@ -1062,9 +1064,6 @@ open_file_failed (cpp_reader *pfile, _cpp_file *file, int angle_brackets,\n   int sysp = pfile->line_table->highest_line > 1 && pfile->buffer ? pfile->buffer->sysp : 0;\n   bool print_dep = CPP_OPTION (pfile, deps.style) > (angle_brackets || !!sysp);\n \n-  if (pfile->state.in__has_include__)\n-    return;\n-\n   errno = file->err_no;\n   if (print_dep && CPP_OPTION (pfile, deps.missing_files) && errno == ENOENT)\n     {\n@@ -1343,7 +1342,8 @@ cpp_clear_file_cache (cpp_reader *pfile)\n void\n _cpp_fake_include (cpp_reader *pfile, const char *fname)\n {\n-  _cpp_find_file (pfile, fname, pfile->buffer->file->dir, true, 0, false, 0);\n+  _cpp_find_file (pfile, fname, pfile->buffer->file->dir,\n+\t\t  0, true, false, false, 0);\n }\n \n /* Not everyone who wants to set system-header-ness on a buffer can\n@@ -1461,7 +1461,8 @@ _cpp_compare_file_date (cpp_reader *pfile, const char *fname,\n   if (!dir)\n     return -1;\n \n-  file = _cpp_find_file (pfile, fname, dir, false, angle_brackets, false, 0);\n+  file = _cpp_find_file (pfile, fname, dir, angle_brackets,\n+\t\t\t false, false, false, 0);\n   if (file->err_no)\n     return -1;\n \n@@ -2004,9 +2005,11 @@ _cpp_has_header (cpp_reader *pfile, const char *fname, int angle_brackets,\n \t\t enum include_type type)\n {\n   cpp_dir *start_dir = search_path_head (pfile, fname, angle_brackets, type);\n-  _cpp_file *file = _cpp_find_file (pfile, fname, start_dir,\n-\t\t\t\t    /*fake=*/false, angle_brackets,\n-\t\t\t\t    /*implicit_preinclude=*/false, 0);\n+  _cpp_file *file = _cpp_find_file (pfile, fname, start_dir, angle_brackets,\n+\t\t\t\t    /*fake=*/false,\n+\t\t\t\t    /*implicit_preinclude=*/false,\n+\t\t\t\t    /*has_include=*/true,\n+\t\t\t\t    0);\n   return file->err_no != ENOENT;\n }\n "}, {"sha": "9627e1bf4b0f0851ac86dae24734008b9cf838b1", "filename": "libcpp/identifiers.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fidentifiers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fidentifiers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fidentifiers.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -72,8 +72,7 @@ _cpp_init_hashtable (cpp_reader *pfile, cpp_hash_table *table)\n   s->n__VA_ARGS__->flags |= NODE_DIAGNOSTIC;\n   s->n__VA_OPT__        = cpp_lookup (pfile, DSC(\"__VA_OPT__\"));\n   s->n__VA_OPT__->flags |= NODE_DIAGNOSTIC;\n-  s->n__has_include__   = cpp_lookup (pfile, DSC(\"__has_include__\"));\n-  s->n__has_include_next__ = cpp_lookup (pfile, DSC(\"__has_include_next__\"));\n+  /* __has_include{,_next} are inited in cpp_init_builtins.  */\n }\n \n /* Tear down the identifier hash table.  */"}, {"sha": "56cbbd82750f272cf995b564d8276084725a32d9", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -859,7 +859,7 @@ enum cpp_builtin_type\n   BT_PRAGMA,\t\t\t/* `_Pragma' operator */\n   BT_TIMESTAMP,\t\t\t/* `__TIMESTAMP__' */\n   BT_COUNTER,\t\t\t/* `__COUNTER__' */\n-  BT_HAS_ATTRIBUTE,\t\t/* `__has_attribute__(x)' */\n+  BT_HAS_ATTRIBUTE,\t\t/* `__has_attribute(x)' */\n   BT_HAS_BUILTIN\t\t/* `__has_builtin(x)' */\n };\n "}, {"sha": "e798140ef8b4d1c38a715331b8744ad6b5a746ce", "filename": "libcpp/init.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -578,6 +578,17 @@ cpp_init_builtins (cpp_reader *pfile, int hosted)\n \n   if (CPP_OPTION (pfile, objc))\n     _cpp_define_builtin (pfile, \"__OBJC__ 1\");\n+\n+  /* These two behave as macros for #ifdef, but are evaluated\n+     specially inside #if.  */\n+  _cpp_define_builtin (pfile, \"__has_include __has_include\");\n+  _cpp_define_builtin (pfile, \"__has_include_next __has_include_next\");\n+  pfile->spec_nodes.n__has_include\n+    = cpp_lookup (pfile, DSC(\"__has_include\"));\n+  pfile->spec_nodes.n__has_include->flags |= NODE_DIAGNOSTIC;\n+  pfile->spec_nodes.n__has_include_next\n+    = cpp_lookup (pfile, DSC(\"__has_include_next\"));\n+  pfile->spec_nodes.n__has_include_next->flags |= NODE_DIAGNOSTIC;\n }\n \n /* Sanity-checks are dependent on command-line options, so it is\n@@ -672,7 +683,8 @@ cpp_read_main_file (cpp_reader *pfile, const char *fname)\n     }\n \n   pfile->main_file\n-    = _cpp_find_file (pfile, fname, &pfile->no_search_path, false, 0, false,\n+    = _cpp_find_file (pfile, fname, &pfile->no_search_path, /*angle=*/0,\n+\t\t      /*fake=*/false, /*preinclude=*/false, /*hasinclude=*/false,\n \t\t      loc);\n   if (_cpp_find_failed (pfile->main_file))\n     return NULL;"}, {"sha": "5453c3bff85f0029452d2a5ef26c9b808783a5ff", "filename": "libcpp/internal.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -268,9 +268,6 @@ struct lexer_state\n   /* Nonzero when parsing arguments to a function-like macro.  */\n   unsigned char parsing_args;\n \n-  /* Nonzero if in a __has_include__ or __has_include_next__ statement.  */\n-  unsigned char in__has_include__;\n-\n   /* Nonzero if prevent_expansion is true only because output is\n      being discarded.  */\n   unsigned char discarding_output;\n@@ -293,8 +290,8 @@ struct spec_nodes\n   cpp_hashnode *n_false;\t\t/* C++ keyword false */\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n   cpp_hashnode *n__VA_OPT__;\t\t/* C++ vararg macros */\n-  cpp_hashnode *n__has_include__;\t/* __has_include__ operator */\n-  cpp_hashnode *n__has_include_next__;\t/* __has_include_next__ operator */\n+  cpp_hashnode *n__has_include;\t\t/* __has_include operator */\n+  cpp_hashnode *n__has_include_next;\t/* __has_include_next operator */\n };\n \n typedef struct _cpp_line_note _cpp_line_note;\n@@ -641,6 +638,16 @@ cpp_in_primary_file (cpp_reader *pfile)\n   return pfile->line_table->depth == 1;\n }\n \n+/* True if NODE is a macro for the purposes of ifdef, defined etc.  */\n+inline bool _cpp_defined_macro_p (cpp_hashnode *node)\n+{\n+  /* Do not treat conditional macros as being defined.  This is due to\n+     the powerpc port using conditional macros for 'vector', 'bool',\n+     and 'pixel' to act as conditional keywords.  This messes up tests\n+     like #ifndef bool.  */\n+  return cpp_macro_p (node) && !(node->flags & NODE_CONDITIONAL);\n+}\n+\n /* In macro.c */\n extern void _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node);\n inline void _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n@@ -674,7 +681,8 @@ extern void _cpp_destroy_hashtable (cpp_reader *);\n /* In files.c */\n typedef struct _cpp_file _cpp_file;\n extern _cpp_file *_cpp_find_file (cpp_reader *, const char *, cpp_dir *,\n-\t\t\t\t  bool, int, bool, location_t);\n+\t\t\t\t  int angle, bool fake, bool preinclude,\n+\t\t\t\t  bool has_include, location_t);\n extern bool _cpp_find_failed (_cpp_file *);\n extern void _cpp_mark_file_once_only (cpp_reader *, struct _cpp_file *);\n extern void _cpp_fake_include (cpp_reader *, const char *);"}, {"sha": "e631050936ba91791d6ee9078e246e1e6abe61e1", "filename": "libcpp/pch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -811,8 +811,8 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n     s->n_false\t\t= cpp_lookup (r, DSC(\"false\"));\n     s->n__VA_ARGS__     = cpp_lookup (r, DSC(\"__VA_ARGS__\"));\n     s->n__VA_OPT__      = cpp_lookup (r, DSC(\"__VA_OPT__\"));\n-    s->n__has_include__ = cpp_lookup (r, DSC(\"__has_include__\"));\n-    s->n__has_include_next__ = cpp_lookup (r, DSC(\"__has_include_next__\"));\n+    s->n__has_include   = cpp_lookup (r, DSC(\"__has_include\"));\n+    s->n__has_include_next = cpp_lookup (r, DSC(\"__has_include_next\"));\n   }\n \n   old_state = r->state;"}, {"sha": "ff06d31a897b86871aad1cb3d38c3fc3a312fdaf", "filename": "libcpp/traditional.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1a3914ae8d67c94b0d2428e3f9672e7db491a1/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=ad1a3914ae8d67c94b0d2428e3f9672e7db491a1", "patch": "@@ -78,8 +78,8 @@ enum ls {ls_none = 0,\t\t/* Normal state.  */\n \t ls_hash,\t\t/* After # in preprocessor conditional.  */\n \t ls_predicate,\t\t/* After the predicate, maybe paren?  */\n \t ls_answer,\t\t/* In answer to predicate.  */\n-\t ls_has_include,\t/* After __has_include__.  */\n-\t ls_has_include_close};\t/* Looking for ')' of __has_include__.  */\n+\t ls_has_include,\t/* After __has_include.  */\n+\t ls_has_include_close};\t/* Looking for ')' of __has_include.  */\n \n /* Lexing TODO: Maybe handle space in escaped newlines.  Stop lex.c\n    from recognizing comments and directives during its lexing pass.  */\n@@ -565,8 +565,8 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro,\n \t\t  continue;\n \t\t}\n \t      else if (pfile->state.in_expression\n-\t\t       && (node == pfile->spec_nodes.n__has_include__\n-\t\t\t|| node == pfile->spec_nodes.n__has_include_next__))\n+\t\t       && (node == pfile->spec_nodes.n__has_include\n+\t\t\t|| node == pfile->spec_nodes.n__has_include_next))\n \t\t{\n \t\t  lex_state = ls_has_include;\n \t\t  continue;"}]}