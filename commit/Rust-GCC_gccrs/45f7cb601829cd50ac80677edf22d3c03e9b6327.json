{"sha": "45f7cb601829cd50ac80677edf22d3c03e9b6327", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmN2NiNjAxODI5Y2Q1MGFjODA2NzdlZGYyMmQzYzAzZTliNjMyNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-01T05:28:01Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-01T05:28:01Z"}, "message": "adaint.c, [...]: Fix comment typos.\n\n\t* adaint.c, cal.c, decl.c, gigi.h, gmem.c, init.c, link.c,\n\traise.c, tracebak.c, trans.c, utils2.c, utils.c: Fix comment\n\ttypos.\n\nFrom-SVN: r97369", "tree": {"sha": "639823f0b45b5a525e2e96e30ce0899ecb12b108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/639823f0b45b5a525e2e96e30ce0899ecb12b108"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45f7cb601829cd50ac80677edf22d3c03e9b6327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f7cb601829cd50ac80677edf22d3c03e9b6327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f7cb601829cd50ac80677edf22d3c03e9b6327", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f7cb601829cd50ac80677edf22d3c03e9b6327/comments", "author": null, "committer": null, "parents": [{"sha": "38b974a6cf4ea5e2ea107c63aa4c2b6d64a89894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b974a6cf4ea5e2ea107c63aa4c2b6d64a89894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b974a6cf4ea5e2ea107c63aa4c2b6d64a89894"}], "stats": {"total": 70, "additions": 38, "deletions": 32}, "files": [{"sha": "5f0441380773ea1b705da2b346cf0c3f8fd64a7b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -1,3 +1,9 @@\n+2005-04-01  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* adaint.c, cal.c, decl.c, gigi.h, gmem.c, init.c, link.c,\n+\traise.c, tracebak.c, trans.c, utils2.c, utils.c: Fix comment\n+\ttypos.\n+\n 2005-03-30  Tom Tromey  <tromey@redhat.com>\n \n \t* decl.c (gnat_substitute_in_type): Don't handle FILE_TYPE."}, {"sha": "6d65efdb53cc5eee4efafaf247ddde776f2fb179", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -1643,7 +1643,7 @@ __gnat_dup (int oldfd)\n }\n \n /* Make newfd be the copy of oldfd, closing newfd first if necessary.\n-   Return -1 if an error occured.  */\n+   Return -1 if an error occurred.  */\n \n int\n __gnat_dup2 (int oldfd, int newfd)"}, {"sha": "20a631634bb39de3b9ede002be50c7c9dd92ee06", "filename": "gcc/ada/cal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fcal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fcal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcal.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -31,7 +31,7 @@\n  ****************************************************************************/\n \n /*  This file contains those routines named by Import pragmas in package    */\n-/*  GNAT.Calendar. It is used to to Duration to timeval convertion.         */\n+/*  GNAT.Calendar. It is used to do Duration to timeval conversion.         */\n /*  These are simple wrappers function to abstarct the fact that the C      */\n /*  struct timeval fields type are not normalized (they are generaly        */\n /*  defined as int or long values).                                         */\n@@ -75,7 +75,7 @@ __gnat_timeval_to_duration (struct timeval *t, long *sec, long *usec)\n void\n __gnat_duration_to_timeval (long sec, long usec, struct timeval *t)\n {\n-  /* here we are doing implicit convertion from a long to the struct timeval\n+  /* here we are doing implicit conversion from a long to the struct timeval\n      fields types. */\n \n   t->tv_sec = sec;"}, {"sha": "c881d55b41f7a628245b32fa365c60949ec631a9", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -1039,7 +1039,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_ext_name = create_concat_name (gnat_entity, 0);\n \n \t/* If this is constant initialized to a static constant and the\n-\t   object has an aggregrate type, force it to be statically\n+\t   object has an aggregate type, force it to be statically\n \t   allocated. */\n \tif (const_flag && gnu_expr && TREE_CONSTANT (gnu_expr)\n \t    && host_integerp (TYPE_SIZE_UNIT (gnu_type), 1)\n@@ -2884,7 +2884,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If we are pointing to an incomplete type whose completion is an\n \t   unconstrained array, make a fat pointer type instead of a pointer\n \t   to VOID.  The two types in our fields will be pointers to VOID and\n-\t   will be replaced in update_pointer_to.  Similiarly, if the type\n+\t   will be replaced in update_pointer_to.  Similarly, if the type\n \t   itself is a dummy type or an unconstrained array.  Also make\n \t   a dummy TYPE_OBJECT_RECORD_TYPE in case we have any thin\n \t   pointers to it.  */\n@@ -3421,7 +3421,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      post_error (\"unsupported mechanism for&\", gnat_param);\n \n \t    /* If this is either a foreign function or if the\n-\t       underlying type won't be passed by refererence, strip off\n+\t       underlying type won't be passed by reference, strip off\n \t       possible padding type.  */\n \t    if (TREE_CODE (gnu_param_type) == RECORD_TYPE\n \t\t&& TYPE_IS_PADDING_P (gnu_param_type)\n@@ -4348,7 +4348,7 @@ copy_alias_set (tree gnu_new_type, tree gnu_old_type)\n /* Return a TREE_LIST describing the substitutions needed to reflect\n    discriminant substitutions from GNAT_SUBTYPE to GNAT_TYPE and add\n    them to GNU_LIST.  If GNAT_TYPE is not specified, use the base type\n-   of GNAT_SUBTYPE. The substitions can be in any order.  TREE_PURPOSE\n+   of GNAT_SUBTYPE. The substitutions can be in any order.  TREE_PURPOSE\n    gives the tree for the discriminant and TREE_VALUES is the replacement\n    value.  They are in the form of operands to substitute_in_expr.\n    DEFINITION is as in gnat_to_gnu_entity.  */\n@@ -4617,7 +4617,7 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity,\n \t\t   && Ekind (Entity (gnat_expr)) == E_Discriminant)))\n     return 0;\n \n-  /* Otherwise, convert this tree to its GCC equivalant.  */\n+  /* Otherwise, convert this tree to its GCC equivalent.  */\n   gnu_expr\n     = elaborate_expression_1 (gnat_expr, gnat_entity, gnat_to_gnu (gnat_expr),\n \t\t\t      gnu_name, definition, need_debug);\n@@ -5211,7 +5211,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t    }\n \n \t  /* If Aliased, the size must match exactly the rounded size.  We\n-\t     used to be more accomodating here and accept greater sizes, but\n+\t     used to be more accommodating here and accept greater sizes, but\n \t     fully supporting this case on big-endian platforms would require\n \t     switching to a more involved layout for the field.  */\n \t  else if (Is_Aliased (gnat_field)\n@@ -5703,7 +5703,7 @@ annotate_value (tree gnu_size)\n       /* For negative values, use NEGATE_EXPR of the supplied value.  */\n       if (tree_int_cst_sgn (gnu_size) < 0)\n \t{\n-\t  /* The rediculous code below is to handle the case of the largest\n+\t  /* The ridiculous code below is to handle the case of the largest\n \t     negative integer.  */\n \t  tree negative_size = size_diffop (bitsize_zero_node, gnu_size);\n \t  bool adjust = false;"}, {"sha": "79fdf51250e49edd38382fa66b08ca0f6fd7778e", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -200,7 +200,7 @@ extern int gnat_gimplify_expr (tree *expr_p, tree *pre_p,\n \n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n-   make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n+   make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n extern void process_type (Entity_Id gnat_entity);\n \n /* Convert Sloc into *LOCUS (a location_t).  Return true if this Sloc\n@@ -623,7 +623,7 @@ extern tree remove_conversions (tree exp, bool true_address);\n    likewise return an expression pointing to the underlying array.  */\n extern tree maybe_unconstrained_array (tree exp);\n \n-/* Return an expression that does an unchecked converstion of EXPR to TYPE.\n+/* Return an expression that does an unchecked conversion of EXPR to TYPE.\n    If NOTRUNC_P is true, truncation operations should be suppressed.  */\n extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n "}, {"sha": "cb7e0a27205b055edcdc7416fa747c208fbed91b", "filename": "gcc/ada/gmem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fgmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fgmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgmem.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -83,7 +83,7 @@ gmem_read_backtrace (void)\n }\n \n /* initialize gmem feature from the dumpname file. It returns 1 if the\n-   dumpname has beed generated by GMEM (instrumented malloc/free) and 0 if not\n+   dumpname has been generated by GMEM (instrumented malloc/free) and 0 if not\n    (i.e. probably a GDB generated file).\n */\n "}, {"sha": "6e7356be0615072b7cdd7f159a1ed2018a8c746c", "filename": "gcc/ada/init.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -291,7 +291,7 @@ __gnat_set_globals (int main_priority,\n    as the faulting instruction address in the corresponding signal context\n    pushed by the kernel. Leaving this address untouched may loose, because if\n    the triggering instruction happens to be the very first of a region, the\n-   later adjustements performed by the unwinder would yield an address outside\n+   later adjustments performed by the unwinder would yield an address outside\n    that region. We need to compensate for those adjustments at some point,\n    which we currently do in the GCC unwinding fallback macro.\n \n@@ -1291,7 +1291,7 @@ extern Exception_Code Base_Code_In (Exception_Code);\n \n /* Define macro symbols for the VMS conditions that become Ada exceptions.\n    Most of these are also defined in the header file ssdef.h which has not\n-   yet been converted to be recoginized by Gnu C. Some, which couldn't be\n+   yet been converted to be recognized by Gnu C. Some, which couldn't be\n    located, are assigned names based on the DEC test suite tests which\n    raise them. */\n \n@@ -1337,7 +1337,7 @@ long __gnat_error_handler (int *, void *);\n    ??? This is not a perfect solution to deal with the possible\n    interactions between the GNAT and the DECAda exception handling\n    models and better (more general) schemes are studied.  This is so\n-   just provided as a conveniency workaround in the meantime, and\n+   just provided as a convenient workaround in the meantime, and\n    should be use with caution since the implementation has been kept\n    very simple.  */\n \n@@ -1761,7 +1761,7 @@ __gnat_init_float (void)\n   asm (\"mtfsb0 26\");\n #endif\n \n-  /* Similarily for sparc64. Achieved by masking bits in the Trap Enable Mask\n+  /* Similarly for sparc64. Achieved by masking bits in the Trap Enable Mask\n      field of the Floating-point Status Register (see the Sparc Architecture\n      Manual Version 9, p 48).  */\n #if defined (sparc64)"}, {"sha": "97ff11468c7cf472448bdfe887fc267931f4e06f", "filename": "gcc/ada/link.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -30,7 +30,7 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/*  This file contains host-specific parameters describing the behaviour    */\n+/*  This file contains host-specific parameters describing the behavior     */\n /*  of the linker. It is used by gnatlink as well as all tools that use     */\n /*  Mlib.                                                                   */\n "}, {"sha": "d0abc8a79c0ad26cb4dd2c16eaaee195a26959a1", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -469,7 +469,7 @@ db_phases (int phases)\n \n /* This is an incomplete \"proxy\" of the structure of exception objects as\n    built by the GNAT runtime library. Accesses to other fields than the common\n-   header are performed through subprogram calls to aleviate the need of an\n+   header are performed through subprogram calls to alleviate the need of an\n    exact counterpart here and potential alignment/size issues for the common\n    header. See a-exexpr.adb.  */\n \n@@ -854,7 +854,7 @@ is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n \n   /* Base matching rules: An exception data (id) matches itself, \"when\n      all_others\" matches anything and \"when others\" matches anything unless\n-     explicitely stated otherwise in the propagated occurrence.  */\n+     explicitly stated otherwise in the propagated occurrence.  */\n \n   bool is_handled =\n     choice == E\n@@ -970,7 +970,7 @@ get_action_description_for (_Unwind_Context *uw_context,\n \n /* Setup in UW_CONTEXT the eh return target IP and data registers, which will\n    be restored with the others and retrieved by the landing pad once the jump\n-   occured.  */\n+   occurred.  */\n \n static void\n setup_to_install (_Unwind_Context *uw_context,"}, {"sha": "b55f85103029985d12b9a8c6bb093dbe7ec8151c", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -344,7 +344,7 @@ struct layout\n    libgcc, and the stage1 compiler is unlikely to be linked against a post 3.3\n    library.  It actually disables the support for backtraces in this compiler\n    for targets defining USE_GCC_UNWINDER, which is OK since we don't use the\n-   traceback capablity in the compiler anyway.\n+   traceback capability in the compiler anyway.\n \n    The condition is expressed the way above because we cannot reliably rely on\n    any other macro from the base compiler when compiling stage1.  */"}, {"sha": "869ce3f56030969f072e3b6b933424722d965a35", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -348,7 +348,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n     }\n   else\n     {\n-      /* Expand the type of this identitier first, in case it is an enumeral\n+      /* Expand the type of this identifier first, in case it is an enumeral\n \t literal, which only get made when the type is expanded.  There is no\n \t order-of-elaboration issue here.  We want to use the Actual_Subtype if\n \t it has already been elaborated, otherwise the Etype.  Avoid using\n@@ -1335,7 +1335,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* Save debug output mode in case it is reset.  */\n   enum debug_info_type save_write_symbols = write_symbols;\n   const struct gcc_debug_hooks *const save_debug_hooks = debug_hooks;\n-  /* Definining identifier of a parameter to the subprogram.  */\n+  /* Defining identifier of a parameter to the subprogram.  */\n   Entity_Id gnat_param;\n   /* The defining identifier for the subprogram body. Note that if a\n      specification has appeared before for this body, then the identifier\n@@ -3641,7 +3641,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Defining_Program_Unit_Name:\n       /* For a child unit identifier go up a level to get the\n-         specificaton.  We get this when we try to find the spec of\n+         specification.  We get this when we try to find the spec of\n \t a child unit package that is the compilation unit being compiled. */\n       gnu_result = gnat_to_gnu (Parent (gnat_node));\n       break;\n@@ -3969,7 +3969,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* If the result is a pointer type, see if we are either converting\n          from a non-pointer or from a pointer to a type with a different\n  \t alias set and warn if so.  If the result defined in the same unit as\n- \t this unchecked convertion, we can allow this because we can know to\n+ \t this unchecked conversion, we can allow this because we can know to\n  \t make that type have alias set 0.  */\n       {\n  \ttree gnu_source_type = gnat_to_gnu_type (Source_Type (gnat_node));\n@@ -5351,7 +5351,7 @@ addressable_p (tree gnu_expr)\n \f\n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n-   make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n+   make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n \n void\n process_type (Entity_Id gnat_entity)"}, {"sha": "f6ea29bb28810c2bf31ff280f2a87fe5d5248e9d", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -1554,7 +1554,7 @@ value_factor_p (tree value, HOST_WIDE_INT factor)\n \n /* Given 2 consecutive field decls PREV_FIELD and CURR_FIELD, return true\n    unless we can prove these 2 fields are laid out in such a way that no gap\n-   exist between the end of PREV_FIELD and the begining of CURR_FIELD.  OFFSET\n+   exist between the end of PREV_FIELD and the beginning of CURR_FIELD.  OFFSET\n    is the distance in bits between the end of PREV_FIELD and the starting\n    position of CURR_FIELD. It is ignored if null. */\n \n@@ -1573,7 +1573,7 @@ potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n   if (TREE_CODE (TREE_TYPE (prev_field)) == QUAL_UNION_TYPE)\n     return false;\n \n-  /* If the distance between the end of prev_field and the begining of\n+  /* If the distance between the end of prev_field and the beginning of\n      curr_field is constant, then there is a gap if the value of this\n      constant is not null. */\n   if (offset && host_integerp (offset, 1))\n@@ -2705,7 +2705,7 @@ convert (tree type, tree expr)\n \n       /* If the result type is a padded type with a self-referentially-sized\n \t field and the expression type is a record, do this as an\n-\t unchecked converstion.  */\n+\t unchecked conversion.  */\n       else if (TREE_CODE (etype) == RECORD_TYPE\n \t       && CONTAINS_PLACEHOLDER_P (DECL_SIZE (TYPE_FIELDS (type))))\n \treturn unchecked_convert (type, expr, false);\n@@ -3075,7 +3075,7 @@ maybe_unconstrained_array (tree exp)\n   return exp;\n }\n \f\n-/* Return an expression that does an unchecked converstion of EXPR to TYPE.\n+/* Return an expression that does an unchecked conversion of EXPR to TYPE.\n    If NOTRUNC_P is true, truncation operations should be suppressed.  */\n \n tree"}, {"sha": "6ca8b99e50ac7a843fa09a5552ab354e12f805c3", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f7cb601829cd50ac80677edf22d3c03e9b6327/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=45f7cb601829cd50ac80677edf22d3c03e9b6327", "patch": "@@ -504,7 +504,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n     rhs = fold (build2 (MINUS_EXPR, type, modulus, rhs)), op_code = MINUS_EXPR;\n \n   /* For the logical operations, we only need PRECISION bits.  For\n-     addition and subraction, we need one more and for multiplication we\n+     addition and subtraction, we need one more and for multiplication we\n      need twice as many.  But we never want to make a size smaller than\n      our size. */\n   if (op_code == PLUS_EXPR || op_code == MINUS_EXPR)"}]}