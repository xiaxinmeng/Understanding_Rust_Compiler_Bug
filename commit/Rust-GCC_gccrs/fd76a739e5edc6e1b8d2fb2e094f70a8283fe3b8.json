{"sha": "fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3NmE3MzllNWVkYzZlMWI4ZDJmYjJlMDk0ZjcwYTgyODNmZTNiOA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T05:39:37Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T05:39:37Z"}, "message": "If REAL_ARITHMETIC is defined or if LONG_DOUBLE_TYPE_SIZE is 96...\n\nIf REAL_ARITHMETIC is defined or if LONG_DOUBLE_TYPE_SIZE\nis 96, then define REAL_VALUE_ macros to invoke functions in real.c.\n\n(REAL_VALUE_RNDZINT, REAL_VALUE_UNSIGNED_RNDZINT):\nNew macros truncate toward zero to integer value but\nreturn REAL_VALUE_TYPE.\n\n(REAL_VALUE_TO_DECIMAL): New macro defaults to\nfprintf if no REAL_ARITHMETIC, otherwise uses real.c for\nbinary to decimal conversion.  Used in ASM_OUTPUT_ macros.\n\nFrom-SVN: r3934", "tree": {"sha": "fce52e724f0f1543abd5bd430a11822c3977e803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fce52e724f0f1543abd5bd430a11822c3977e803"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8/comments", "author": null, "committer": null, "parents": [{"sha": "985b6196e635b59aff9af3e4d9603678febba797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985b6196e635b59aff9af3e4d9603678febba797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/985b6196e635b59aff9af3e4d9603678febba797"}], "stats": {"total": 153, "additions": 139, "deletions": 14}, "files": [{"sha": "527c205e077338a495a23904d4c873dec8fa091d", "filename": "gcc/real.h", "status": "modified", "additions": 139, "deletions": 14, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=fd76a739e5edc6e1b8d2fb2e094f70a8283fe3b8", "patch": "@@ -24,6 +24,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define UNKNOWN_FLOAT_FORMAT 0\n #define IEEE_FLOAT_FORMAT 1\n #define VAX_FLOAT_FORMAT 2\n+#define IBM_FLOAT_FORMAT 3\n \n /* Default to IEEE float if not specified.  Nearly all machines use it.  */\n \n@@ -39,6 +40,103 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define REAL_INFINITY\n #endif\n \n+/* Defining REAL_ARITHMETIC invokes a floating point emulator\n+   that can produce a target machine format differing by more\n+   than just endian-ness from the host's format.  The emulator\n+   is also used to support extended real XFmode.  */\n+#ifndef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+#endif\n+#if (LONG_DOUBLE_TYPE_SIZE == 96) || defined (REAL_ARITHMETIC)\n+/* **** Start of software floating point emulator interface macros **** */\n+\n+/* Support 80-bit extended real XFmode if LONG_DOUBLE_TYPE_SIZE\n+   has been defined to be 96 in the tm.h machine file. */\n+#if (LONG_DOUBLE_TYPE_SIZE == 96)\n+#define REAL_IS_NOT_DOUBLE\n+#define REAL_ARITHMETIC\n+typedef struct {\n+  HOST_WIDE_INT r[(11 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))];\n+} realvaluetype;\n+#define REAL_VALUE_TYPE realvaluetype\n+\n+#else /* no XFmode support */\n+\n+#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+/* If no XFmode support, then a REAL_VALUE_TYPE is 64 bits wide\n+   but it is not necessarily a host machine double. */\n+#define REAL_IS_NOT_DOUBLE\n+typedef struct {\n+  HOST_WIDE_INT r[(7 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))];\n+} realvaluetype;\n+#define REAL_VALUE_TYPE realvaluetype\n+#else\n+/* If host and target formats are compatible, then a REAL_VALUE_TYPE\n+   is actually a host machine double. */\n+#define REAL_VALUE_TYPE double\n+#endif\n+#endif /* no XFmode support */\n+\n+/* If emulation has been enabled by defining REAL_ARITHMETIC or by\n+   setting LONG_DOUBLE_TYPE_SIZE to 96, then define macros so that\n+   they invoke emulator functions. This will succeed only if the machine\n+   files have been updated to use these macros in place of any\n+   references to host machine `double' or `float' types.  */\n+#ifdef REAL_ARITHMETIC\n+#undef REAL_ARITHMETIC\n+#define REAL_ARITHMETIC(value, code, d1, d2) \\\n+  earith (&(value), (code), &(d1), &(d2))\n+\n+/* Declare functions in real.c that are referenced here. */\n+void earith (), ereal_from_uint (), ereal_from_int (), ereal_to_int ();\n+void etarldouble (), etardouble ();\n+long etarsingle ();\n+int ereal_cmp (), eroundi (), ereal_isneg ();\n+unsigned int eroundui ();\n+REAL_VALUE_TYPE etrunci (), etruncui (), ereal_ldexp (), ereal_atof ();\n+REAL_VALUE_TYPE ereal_negate (), ereal_truncate ();\n+\n+#define REAL_VALUES_EQUAL(x, y) (ereal_cmp ((x), (y)) == 0)\n+/* true if x < y : */\n+#define REAL_VALUES_LESS(x, y) (ereal_cmp ((x), (y)) < 0)\n+#define REAL_VALUE_LDEXP(x, n) ereal_ldexp (x, n)\n+\n+/* These return REAL_VALUE_TYPE: */\n+#define REAL_VALUE_RNDZINT(x) (etrunci (x))\n+#define REAL_VALUE_UNSIGNED_RNDZINT(x) (etruncui (x))\n+extern REAL_VALUE_TYPE real_value_truncate ();\n+#define REAL_VALUE_TRUNCATE(mode, x)  real_value_truncate (mode, x)\n+\n+/* These return int: */\n+#define REAL_VALUE_FIX(x) (eroundi (x))\n+#define REAL_VALUE_UNSIGNED_FIX(x) ((unsigned int) eroundui (x))\n+\n+#define REAL_VALUE_ATOF ereal_atof\n+#define REAL_VALUE_NEGATE ereal_negate\n+\n+#define REAL_VALUE_MINUS_ZERO(x) \\\n+ ((ereal_cmp (x, dconst0) == 0) && (ereal_isneg (x) != 0 ))\n+\n+#define REAL_VALUE_TO_INT ereal_to_int\n+#define REAL_VALUE_FROM_INT(d, i, j) (ereal_from_int (&d, i, j))\n+#define REAL_VALUE_FROM_UNSIGNED_INT(d, i, j) (ereal_from_uint (&d, i, j))\n+\n+/* IN is a REAL_VALUE_TYPE.  OUT is an array of longs. */\n+#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT) (etarldouble ((IN), (OUT)))\n+#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT) (etardouble ((IN), (OUT)))\n+\n+/* IN is a REAL_VALUE_TYPE.  OUT is a long. */\n+#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT) ((OUT) = etarsingle ((IN)))\n+\n+/* Conversions to decimal ASCII string.  */\n+#define REAL_VALUE_TO_DECIMAL(r, fmt, s) (ereal_to_decimal (r, s))\n+\n+#endif /* REAL_ARITHMETIC defined */\n+\n+/* **** End of software floating point emulator interface macros **** */\n+#else /* LONG_DOUBLE_TYPE_SIZE != 96 and REAL_ARITHMETIC not defined */\n+\n+/* old interface */\n #ifdef REAL_ARITHMETIC\n /* Defining REAL_IS_NOT_DOUBLE breaks certain initializations\n    when REAL_ARITHMETIC etc. are not defined.  */\n@@ -52,12 +150,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n #define\tREAL_IS_NOT_DOUBLE\n #ifndef REAL_VALUE_TYPE\n-#define REAL_VALUE_TYPE \\\n-  struct real_value{ HOST_WIDE_INT i[sizeof (double)/sizeof (HOST_WIDE_INT)]; }\n+typedef struct {\n+    HOST_WIDE_INT r[sizeof (double)/sizeof (HOST_WIDE_INT)];\n+  } realvaluetype;\n+#define REAL_VALUE_TYPE realvaluetype\n #endif /* no REAL_VALUE_TYPE */\n #endif /* formats differ */\n #endif /* 0 */\n \n+#endif /* emulator not used */\n+\n /* If we are not cross-compiling, use a `double' to represent the\n    floating-point value.  Otherwise, use some other type\n    (probably a struct containing an array of longs).  */\n@@ -72,14 +174,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Convert a type `double' value in host format first to a type `float'\n    value in host format and then to a single type `long' value which\n    is the bitwise equivalent of the `float' value.  */\n+#ifndef REAL_VALUE_TO_TARGET_SINGLE\n #define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT)\t\t\t\t\\\n do { float f = (float) (IN);\t\t\t\t\t\t\\\n      (OUT) = *(long *) &f;\t\t\t\t\t\t\\\n-  } while (0)\n+   } while (0)\n+#endif\n \n /* Convert a type `double' value in host format to a pair of type `long'\n    values which is its bitwise equivalent, but put the two words into\n    proper word order for the target.  */\n+#ifndef REAL_VALUE_TO_TARGET_DOUBLE\n #if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n #define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT)\t\t\t\t\\\n do { REAL_VALUE_TYPE in = (IN);  /* Make sure it's not in a register.  */\\\n@@ -93,26 +198,32 @@ do { REAL_VALUE_TYPE in = (IN);  /* Make sure it's not in a register.  */\\\n      (OUT)[0] = ((long *) &in)[1];\t\t\t\t\t\\\n    } while (0)\n #endif\n+#endif\n #endif /* HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT */\n \n+/* In this configuration, double and long double are the same. */\n+#ifndef REAL_VALUE_TO_TARGET_LONG_DOUBLE\n+#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(a, b) REAL_VALUE_TO_TARGET_DOUBLE (a, b)\n+#endif\n+\n /* Compare two floating-point values for equality.  */\n #ifndef REAL_VALUES_EQUAL\n-#define REAL_VALUES_EQUAL(x,y) ((x) == (y))\n+#define REAL_VALUES_EQUAL(x, y) ((x) == (y))\n #endif\n \n /* Compare two floating-point values for less than.  */\n #ifndef REAL_VALUES_LESS\n-#define REAL_VALUES_LESS(x,y) ((x) < (y))\n+#define REAL_VALUES_LESS(x, y) ((x) < (y))\n #endif\n \n-/* Convert a floating-point value to integer by truncating.  */\n-#ifndef REAL_VALUE_FIX_TRUNCATE\n-#define REAL_VALUE_FIX_TRUNCATE(x) ((int) (x))\n+/* Truncate toward zero to an integer floating-point value.  */\n+#ifndef REAL_VALUE_RNDZINT\n+#define REAL_VALUE_RNDZINT(x) ((double) ((int) (x)))\n #endif\n \n-/* Convert a floating-point value to unsigned integer by truncating.  */\n-#ifndef REAL_VALUE_UNSIGNED_FIX_TRUNCATE\n-#define REAL_VALUE_UNSIGNED_FIX_TRUNCATE(x) ((unsigned int) (x))\n+/* Truncate toward zero to an unsigned integer floating-point value.  */\n+#ifndef REAL_VALUE_UNSIGNED_RNDZINT\n+#define REAL_VALUE_UNSIGNED_RNDZINT(x) ((double) ((unsigned int) (x)))\n #endif\n \n /* Convert a floating-point value to integer, using any rounding mode.  */\n@@ -128,13 +239,19 @@ do { REAL_VALUE_TYPE in = (IN);  /* Make sure it's not in a register.  */\\\n \n /* Scale X by Y powers of 2.  */\n #ifndef REAL_VALUE_LDEXP\n-#define REAL_VALUE_LDEXP(x,y) ldexp (x, y)\n+#define REAL_VALUE_LDEXP(x, y) ldexp (x, y)\n extern double ldexp ();\n #endif\n \n /* Convert the string X to a floating-point value.  */\n #ifndef REAL_VALUE_ATOF\n-#define REAL_VALUE_ATOF(x) atof (x)\n+#if 1\n+/* Use real.c to convert decimal numbers to binary, ... */\n+REAL_VALUE_TYPE ereal_atof ();\n+#define REAL_VALUE_ATOF(x, s) ereal_atof (x, s)\n+#else\n+/* ... or, if you like the host computer's atof, go ahead and use it: */\n+#define REAL_VALUE_ATOF(x, s) atof (x)\n #if defined (MIPSEL) || defined (MIPSEB)\n /* MIPS compiler can't handle parens around the function name.\n    This problem *does not* appear to be connected with any\n@@ -144,6 +261,7 @@ extern double atof ();\n extern double (atof) ();\n #endif\n #endif\n+#endif\n \n /* Negate the floating-point value X.  */\n #ifndef REAL_VALUE_NEGATE\n@@ -229,6 +347,13 @@ do { union real_extract u;\t\t\t\t\\\n \n /* Return a CONST_DOUBLE with value R and mode M.  */\n \n-#define CONST_DOUBLE_FROM_REAL_VALUE(r,m) immed_real_const_1 (r, m)\n+#define CONST_DOUBLE_FROM_REAL_VALUE(r, m) immed_real_const_1 (r,  m)\n+\n+/* Convert a floating point value `r', that can be interpreted\n+   as a host machine float or double, to a decimal ASCII string `s'\n+   using printf format string `fmt'.  */\n+#ifndef REAL_VALUE_TO_DECIMAL\n+#define REAL_VALUE_TO_DECIMAL(r, fmt, s) (sprintf (s, fmt, r))\n+#endif\n \n #endif /* Not REAL_H_INCLUDED */"}]}