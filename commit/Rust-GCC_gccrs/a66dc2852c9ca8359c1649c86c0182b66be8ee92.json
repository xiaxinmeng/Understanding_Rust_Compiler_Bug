{"sha": "a66dc2852c9ca8359c1649c86c0182b66be8ee92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY2ZGMyODUyYzljYTgzNTljMTY0OWM4NmMwMTgyYjY2YmU4ZWU5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-11T17:47:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-11T17:47:01Z"}, "message": "lto.c: Update copyright...\n\n\n\t* lto.c: Update copyright; remove params.h, ipa-inline.h\n\tand ipa-utils.h inlines; inline lto-partition.h\n\t(ltrans_partition_def, ltrans_partition, add_cgraph_node_to_partition,\n\tadd_varpool_node_to_partition, new_partition, free_ltrans_partitions,\n\tadd_references_to_partition, add_cgraph_node_to_partition_1,\n\tadd_cgraph_node_to_partition, add_varpool_node_to_partition,\n\tundo_partition, partition_cgraph_node_p, partition_varpool_node_p,\n\tlto_1_to_1_map, node_cmp, varpool_node_cmp, lto_balanced_map,\n\tpromote_var, promote_fn, lto_promote_cross_file_statics): move to...\n\t* lto-partition.c: ... here; new file.\n\t* lto-partition.h: New file.\n\t* Make-lang.in (lto.o): Update dependencies.\n\t(lto-partition.o): New.\n\nFrom-SVN: r186343", "tree": {"sha": "b09f68a90379e756d6e4c89adad4e7a2412d93bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b09f68a90379e756d6e4c89adad4e7a2412d93bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a66dc2852c9ca8359c1649c86c0182b66be8ee92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a66dc2852c9ca8359c1649c86c0182b66be8ee92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a66dc2852c9ca8359c1649c86c0182b66be8ee92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a66dc2852c9ca8359c1649c86c0182b66be8ee92/comments", "author": null, "committer": null, "parents": [{"sha": "c634f4ba6f4178ad317f03a61179ba7596b9c737", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c634f4ba6f4178ad317f03a61179ba7596b9c737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c634f4ba6f4178ad317f03a61179ba7596b9c737"}], "stats": {"total": 1877, "additions": 977, "deletions": 900}, "files": [{"sha": "fe4a9c48e896dcaaf6f5d4e961db6acb590c38be", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=a66dc2852c9ca8359c1649c86c0182b66be8ee92", "patch": "@@ -1,3 +1,19 @@\n+2012-04-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c: Update copyright; remove params.h, ipa-inline.h\n+\tand ipa-utils.h inlines; inline lto-partition.h\n+\t(ltrans_partition_def, ltrans_partition, add_cgraph_node_to_partition,\n+\tadd_varpool_node_to_partition, new_partition, free_ltrans_partitions,\n+\tadd_references_to_partition, add_cgraph_node_to_partition_1,\n+\tadd_cgraph_node_to_partition, add_varpool_node_to_partition,\n+\tundo_partition, partition_cgraph_node_p, partition_varpool_node_p,\n+\tlto_1_to_1_map, node_cmp, varpool_node_cmp, lto_balanced_map,\n+\tpromote_var, promote_fn, lto_promote_cross_file_statics): move to...\n+\t* lto-partition.c: ... here; new file.\n+\t* lto-partition.h: New file.\n+\t* Make-lang.in (lto.o): Update dependencies.\n+\t(lto-partition.o): New.\n+\n 2012-04-05  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-lang.c (LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION): Remove"}, {"sha": "b02310992c2c9650397ede979c60db49e7a571c4", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=a66dc2852c9ca8359c1649c86c0182b66be8ee92", "patch": "@@ -23,7 +23,7 @@\n # The name of the LTO compiler.\n LTO_EXE = lto1$(exeext)\n # The LTO-specific object files inclued in $(LTO_EXE).\n-LTO_OBJS = lto/lto-lang.o lto/lto.o lto/lto-object.o attribs.o\n+LTO_OBJS = lto/lto-lang.o lto/lto.o lto/lto-object.o attribs.o lto/lto-partition.o\n LTO_H = lto/lto.h $(HASHTAB_H)\n LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h\n LTO_TREE_H = lto/lto-tree.h $(LINKER_PLUGIN_API_H)\n@@ -85,8 +85,13 @@ lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n \t$(CGRAPH_H) $(GGC_H) tree-ssa-operands.h $(TREE_PASS_H) \\\n \tlanghooks.h $(VEC_H) $(BITMAP_H) pointer-set.h $(IPA_PROP_H) \\\n \t$(COMMON_H) debug.h $(TIMEVAR_H) $(GIMPLE_H) $(LTO_H) $(LTO_TREE_H) \\\n-\t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h $(PARAMS_H) \\\n-\tipa-inline.h $(IPA_UTILS_H) $(TREE_STREAMER_H)\n+\t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h \\\n+\t$(TREE_STREAMER_H) lto/lto-partition.h\n+lto/lto-partition.o: lto/lto-partition.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+\ttoplev.h $(TREE_H) $(TM_H) \\\n+\t$(CGRAPH_H) $(TIMEVAR_H) \\\n+\t$(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h $(PARAMS_H) \\\n+\tipa-inline.h $(IPA_UTILS_H) lto/lto-partition.h\n lto/lto-object.o: lto/lto-object.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(DIAGNOSTIC_CORE_H) $(LTO_H) $(TM_H) $(LTO_STREAMER_H) \\\n \t../include/simple-object.h"}, {"sha": "126c469a524e4512e435734f9ac4afa5caed3a10", "filename": "gcc/lto/lto-partition.c", "status": "added", "additions": 911, "deletions": 0, "changes": 911, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=a66dc2852c9ca8359c1649c86c0182b66be8ee92", "patch": "@@ -0,0 +1,911 @@\n+/* LTO partitioning logic routines.\n+   Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"tm.h\"\n+#include \"cgraph.h\"\n+#include \"lto-streamer.h\"\n+#include \"timevar.h\"\n+#include \"params.h\"\n+#include \"ipa-inline.h\"\n+#include \"ipa-utils.h\"\n+#include \"lto-partition.h\"\n+\n+VEC(ltrans_partition, heap) *ltrans_partitions;\n+\n+static void add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node);\n+static void add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode);\n+\n+/* Create new partition with name NAME.  */\n+static ltrans_partition\n+new_partition (const char *name)\n+{\n+  ltrans_partition part = XCNEW (struct ltrans_partition_def);\n+  part->cgraph_set = cgraph_node_set_new ();\n+  part->varpool_set = varpool_node_set_new ();\n+  part->name = name;\n+  part->insns = 0;\n+  VEC_safe_push (ltrans_partition, heap, ltrans_partitions, part);\n+  return part;\n+}\n+\n+/* Free memory used by ltrans datastructures.  */\n+void\n+free_ltrans_partitions (void)\n+{\n+  unsigned int idx;\n+  ltrans_partition part;\n+  for (idx = 0; VEC_iterate (ltrans_partition, ltrans_partitions, idx, part); idx++)\n+    {\n+      free_cgraph_node_set (part->cgraph_set);\n+      free (part);\n+    }\n+  VEC_free (ltrans_partition, heap, ltrans_partitions);\n+}\n+\n+/* See all references that go to comdat objects and bring them into partition too.\n+   Also see all aliases of the newly added entry and bring them, too.  */\n+static void\n+add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n+    {\n+      if (ref->refered_type == IPA_REF_CGRAPH\n+\t  && (DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref),\n+\t\t\t   NULL)->decl)\n+\t      || (ref->use == IPA_REF_ALIAS\n+\t\t  && lookup_attribute\n+\t\t       (\"weakref\", DECL_ATTRIBUTES (ipa_ref_node (ref)->decl))))\n+\t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n+\tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n+      else\n+\tif (ref->refered_type == IPA_REF_VARPOOL\n+\t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->decl)\n+\t        || (ref->use == IPA_REF_ALIAS\n+\t\t    && lookup_attribute\n+\t\t         (\"weakref\",\n+\t\t\t  DECL_ATTRIBUTES (ipa_ref_varpool_node (ref)->decl))))\n+\t    && !varpool_node_in_set_p (ipa_ref_varpool_node (ref),\n+\t\t\t\t       part->varpool_set))\n+\t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n+    }\n+  for (i = 0; ipa_ref_list_refering_iterate (refs, i, ref); i++)\n+    {\n+      if (ref->refering_type == IPA_REF_CGRAPH\n+\t  && ref->use == IPA_REF_ALIAS\n+\t  && !cgraph_node_in_set_p (ipa_ref_refering_node (ref),\n+\t\t\t\t    part->cgraph_set)\n+\t  && !lookup_attribute (\"weakref\",\n+\t\t\t\tDECL_ATTRIBUTES\n+\t\t\t\t  (ipa_ref_refering_node (ref)->decl)))\n+\tadd_cgraph_node_to_partition (part, ipa_ref_refering_node (ref));\n+      else\n+\tif (ref->refering_type == IPA_REF_VARPOOL\n+\t    && ref->use == IPA_REF_ALIAS\n+\t    && !varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t\t\t\t       part->varpool_set)\n+\t    && !lookup_attribute (\"weakref\",\n+\t\t\t\t  DECL_ATTRIBUTES\n+\t\t\t\t    (ipa_ref_refering_varpool_node (ref)->decl)))\n+\t  add_varpool_node_to_partition (part,\n+\t\t\t\t\t ipa_ref_refering_varpool_node (ref));\n+    }\n+}\n+\n+/* Worker for add_cgraph_node_to_partition.  */\n+\n+static bool\n+add_cgraph_node_to_partition_1 (struct cgraph_node *node, void *data)\n+{\n+  ltrans_partition part = (ltrans_partition) data;\n+\n+  /* non-COMDAT aliases of COMDAT functions needs to be output just once.  */\n+  if (!DECL_COMDAT (node->decl)\n+      && !node->global.inlined_to\n+      && node->aux)\n+    {\n+      gcc_assert (node->thunk.thunk_p || node->alias);\n+      return false;\n+    }\n+\n+  if (node->aux)\n+    {\n+      node->in_other_partition = 1;\n+      if (cgraph_dump_file)\n+        fprintf (cgraph_dump_file, \"Node %s/%i now used in multiple partitions\\n\",\n+\t\t cgraph_node_name (node), node->uid);\n+    }\n+  node->aux = (void *)((size_t)node->aux + 1);\n+  cgraph_node_set_add (part->cgraph_set, node);\n+  return false;\n+}\n+\n+/* Add NODE to partition as well as the inline callees and referred comdats into partition PART. */\n+\n+static void\n+add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  cgraph_node_set_iterator csi;\n+  struct cgraph_node *n;\n+\n+  /* If NODE is already there, we have nothing to do.  */\n+  csi = cgraph_node_set_find (part->cgraph_set, node);\n+  if (!csi_end_p (csi))\n+    return;\n+\n+  cgraph_for_node_thunks_and_aliases (node, add_cgraph_node_to_partition_1, part, true);\n+\n+  part->insns += inline_summary (node)->self_size;\n+\n+\n+  cgraph_node_set_add (part->cgraph_set, node);\n+\n+  for (e = node->callees; e; e = e->next_callee)\n+    if ((!e->inline_failed\n+\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->decl))\n+\t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n+      add_cgraph_node_to_partition (part, e->callee);\n+\n+  /* The only way to assemble non-weakref alias is to add the aliased object into\n+     the unit.  */\n+  add_references_to_partition (part, &node->ref_list);\n+  n = cgraph_function_node (node, NULL);\n+  if (n != node\n+      && !lookup_attribute (\"weakref\",\n+\t\t\t    DECL_ATTRIBUTES (node->decl)))\n+    add_cgraph_node_to_partition (part, n);\n+\n+  if (node->same_comdat_group)\n+    for (n = node->same_comdat_group; n != node; n = n->same_comdat_group)\n+      add_cgraph_node_to_partition (part, n);\n+}\n+\n+/* Add VNODE to partition as well as comdat references partition PART. */\n+\n+static void\n+add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode)\n+{\n+  varpool_node_set_iterator vsi;\n+  struct varpool_node *v;\n+\n+  /* If NODE is already there, we have nothing to do.  */\n+  vsi = varpool_node_set_find (part->varpool_set, vnode);\n+  if (!vsi_end_p (vsi))\n+    return;\n+\n+  varpool_node_set_add (part->varpool_set, vnode);\n+\n+  if (vnode->aux)\n+    {\n+      vnode->in_other_partition = 1;\n+      if (cgraph_dump_file)\n+        fprintf (cgraph_dump_file, \"Varpool node %s now used in multiple partitions\\n\",\n+\t\t varpool_node_name (vnode));\n+    }\n+  vnode->aux = (void *)((size_t)vnode->aux + 1);\n+\n+  /* The only way to assemble non-weakref alias is to add the aliased object into\n+     the unit.  */\n+  v = varpool_variable_node (vnode, NULL);\n+  if (v != vnode\n+      && !lookup_attribute (\"weakref\",\n+\t\t\t    DECL_ATTRIBUTES (vnode->decl)))\n+    add_varpool_node_to_partition (part, v);\n+\n+  add_references_to_partition (part, &vnode->ref_list);\n+\n+  if (vnode->same_comdat_group\n+      && !varpool_node_in_set_p (vnode->same_comdat_group, part->varpool_set))\n+    add_varpool_node_to_partition (part, vnode->same_comdat_group);\n+}\n+\n+/* Undo all additions until number of cgraph nodes in PARITION is N_CGRAPH_NODES\n+   and number of varpool nodes is N_VARPOOL_NODES.  */\n+\n+static void\n+undo_partition (ltrans_partition partition, unsigned int n_cgraph_nodes,\n+\t\tunsigned int n_varpool_nodes)\n+{\n+  while (VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes) >\n+\t n_cgraph_nodes)\n+    {\n+      struct cgraph_node *node = VEC_index (cgraph_node_ptr,\n+\t\t\t\t\t    partition->cgraph_set->nodes,\n+\t\t\t\t\t    n_cgraph_nodes);\n+      partition->insns -= inline_summary (node)->self_size;\n+      cgraph_node_set_remove (partition->cgraph_set, node);\n+      node->aux = (void *)((size_t)node->aux - 1);\n+    }\n+  while (VEC_length (varpool_node_ptr, partition->varpool_set->nodes) >\n+\t n_varpool_nodes)\n+    {\n+      struct varpool_node *node = VEC_index (varpool_node_ptr,\n+\t\t\t\t\t     partition->varpool_set->nodes,\n+\t\t\t\t\t     n_varpool_nodes);\n+      varpool_node_set_remove (partition->varpool_set, node);\n+      node->aux = (void *)((size_t)node->aux - 1);\n+    }\n+}\n+\n+/* Return true if NODE should be partitioned.\n+   This means that partitioning algorithm should put NODE into one of partitions.\n+   This apply to most functions with bodies.  Functions that are not partitions\n+   are put into every unit needing them.  This is the case of i.e. COMDATs.  */\n+\n+static bool\n+partition_cgraph_node_p (struct cgraph_node *node)\n+{\n+  /* We will get proper partition based on function they are inlined to.  */\n+  if (node->global.inlined_to)\n+    return false;\n+  /* Nodes without a body do not need partitioning.  */\n+  if (!node->analyzed)\n+    return false;\n+  /* Extern inlines and comdat are always only in partitions they are needed.  */\n+  if (DECL_EXTERNAL (node->decl)\n+      || (DECL_COMDAT (node->decl)\n+\t  && !cgraph_used_from_object_file_p (node)))\n+    return false;\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->decl)))\n+    return false;\n+  return true;\n+}\n+\n+/* Return true if VNODE should be partitioned. \n+   This means that partitioning algorithm should put VNODE into one of partitions. */\n+\n+static bool\n+partition_varpool_node_p (struct varpool_node *vnode)\n+{\n+  if (vnode->alias || !vnode->needed)\n+    return false;\n+  /* Constant pool and comdat are always only in partitions they are needed.  */\n+  if (DECL_IN_CONSTANT_POOL (vnode->decl)\n+      || (DECL_COMDAT (vnode->decl)\n+\t  && !vnode->force_output\n+\t  && !varpool_used_from_object_file_p (vnode)))\n+    return false;\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->decl)))\n+    return false;\n+  return true;\n+}\n+\n+/* Group cgrah nodes by input files.  This is used mainly for testing\n+   right now.  */\n+\n+void\n+lto_1_to_1_map (void)\n+{\n+  struct cgraph_node *node;\n+  struct varpool_node *vnode;\n+  struct lto_file_decl_data *file_data;\n+  struct pointer_map_t *pmap;\n+  ltrans_partition partition;\n+  void **slot;\n+  int npartitions = 0;\n+\n+  timevar_push (TV_WHOPR_WPA);\n+\n+  pmap = pointer_map_create ();\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (!partition_cgraph_node_p (node)\n+\t  || node->aux)\n+\tcontinue;\n+\n+      file_data = node->local.lto_file_data;\n+\n+      if (file_data)\n+\t{\n+          slot = pointer_map_contains (pmap, file_data);\n+          if (slot)\n+\t    partition = (ltrans_partition) *slot;\n+\t  else\n+\t    {\n+\t      partition = new_partition (file_data->file_name);\n+\t      slot = pointer_map_insert (pmap, file_data);\n+\t      *slot = partition;\n+\t      npartitions++;\n+\t    }\n+\t}\n+      else if (!file_data\n+\t       && VEC_length (ltrans_partition, ltrans_partitions))\n+\tpartition = VEC_index (ltrans_partition, ltrans_partitions, 0);\n+      else\n+\t{\n+\t  partition = new_partition (\"\");\n+\t  slot = pointer_map_insert (pmap, NULL);\n+\t  *slot = partition;\n+\t  npartitions++;\n+\t}\n+\n+      add_cgraph_node_to_partition (partition, node);\n+    }\n+\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    {\n+      if (!partition_varpool_node_p (vnode)\n+\t  || vnode->aux)\n+\tcontinue;\n+      file_data = vnode->lto_file_data;\n+      slot = pointer_map_contains (pmap, file_data);\n+      if (slot)\n+\tpartition = (ltrans_partition) *slot;\n+      else\n+\t{\n+\t  partition = new_partition (file_data->file_name);\n+\t  slot = pointer_map_insert (pmap, file_data);\n+\t  *slot = partition;\n+\t  npartitions++;\n+\t}\n+\n+      add_varpool_node_to_partition (partition, vnode);\n+    }\n+  for (node = cgraph_nodes; node; node = node->next)\n+    node->aux = NULL;\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    vnode->aux = NULL;\n+\n+  /* If the cgraph is empty, create one cgraph node set so that there is still\n+     an output file for any variables that need to be exported in a DSO.  */\n+  if (!npartitions)\n+    new_partition (\"empty\");\n+\n+  pointer_map_destroy (pmap);\n+\n+  timevar_pop (TV_WHOPR_WPA);\n+\n+  lto_stats.num_cgraph_partitions += VEC_length (ltrans_partition, \n+\t\t\t\t\t\t ltrans_partitions);\n+}\n+\n+/* Helper function for qsort; sort nodes by order.  */\n+static int\n+node_cmp (const void *pa, const void *pb)\n+{\n+  const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n+  const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n+  return b->order - a->order;\n+}\n+\n+/* Helper function for qsort; sort nodes by order.  */\n+static int\n+varpool_node_cmp (const void *pa, const void *pb)\n+{\n+  const struct varpool_node *a = *(const struct varpool_node * const *) pa;\n+  const struct varpool_node *b = *(const struct varpool_node * const *) pb;\n+  return b->order - a->order;\n+}\n+\n+/* Group cgraph nodes into equally-sized partitions.\n+\n+   The partitioning algorithm is simple: nodes are taken in predefined order.\n+   The order corresponds to the order we want functions to have in the final\n+   output.  In the future this will be given by function reordering pass, but\n+   at the moment we use the topological order, which is a good approximation.\n+\n+   The goal is to partition this linear order into intervals (partitions) so\n+   that all the partitions have approximately the same size and the number of\n+   callgraph or IPA reference edges crossing boundaries is minimal.\n+\n+   This is a lot faster (O(n) in size of callgraph) than algorithms doing\n+   priority-based graph clustering that are generally O(n^2) and, since\n+   WHOPR is designed to make things go well across partitions, it leads\n+   to good results.\n+\n+   We compute the expected size of a partition as:\n+\n+     max (total_size / lto_partitions, min_partition_size)\n+\n+   We use dynamic expected size of partition so small programs are partitioned\n+   into enough partitions to allow use of multiple CPUs, while large programs\n+   are not partitioned too much.  Creating too many partitions significantly\n+   increases the streaming overhead.\n+\n+   In the future, we would like to bound the maximal size of partitions so as\n+   to prevent the LTRANS stage from consuming too much memory.  At the moment,\n+   however, the WPA stage is the most memory intensive for large benchmarks,\n+   since too many types and declarations are read into memory.\n+\n+   The function implements a simple greedy algorithm.  Nodes are being added\n+   to the current partition until after 3/4 of the expected partition size is\n+   reached.  Past this threshold, we keep track of boundary size (number of\n+   edges going to other partitions) and continue adding functions until after\n+   the current partition has grown to twice the expected partition size.  Then\n+   the process is undone to the point where the minimal ratio of boundary size\n+   and in-partition calls was reached.  */\n+\n+void\n+lto_balanced_map (void)\n+{\n+  int n_nodes = 0;\n+  int n_varpool_nodes = 0, varpool_pos = 0;\n+  struct cgraph_node **postorder =\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  struct cgraph_node **order = XNEWVEC (struct cgraph_node *, cgraph_max_uid);\n+  struct varpool_node **varpool_order = NULL;\n+  int i, postorder_len;\n+  struct cgraph_node *node;\n+  int total_size = 0, best_total_size = 0;\n+  int partition_size;\n+  ltrans_partition partition;\n+  unsigned int last_visited_cgraph_node = 0, last_visited_varpool_node = 0;\n+  struct varpool_node *vnode;\n+  int cost = 0, internal = 0;\n+  int best_n_nodes = 0, best_n_varpool_nodes = 0, best_i = 0, best_cost =\n+    INT_MAX, best_internal = 0;\n+  int npartitions;\n+  int current_order = -1;\n+\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    gcc_assert (!vnode->aux);\n+  /* Until we have better ordering facility, use toplogical order.\n+     Include only nodes we will partition and compute estimate of program\n+     size.  Note that since nodes that are not partitioned might be put into\n+     multiple partitions, this is just an estimate of real size.  This is why\n+     we keep partition_size updated after every partition is finalized.  */\n+  postorder_len = ipa_reverse_postorder (postorder);\n+    \n+  for (i = 0; i < postorder_len; i++)\n+    {\n+      node = postorder[i];\n+      if (partition_cgraph_node_p (node))\n+\t{\n+\t  order[n_nodes++] = node;\n+          total_size += inline_summary (node)->size;\n+\t}\n+    }\n+  free (postorder);\n+\n+  if (!flag_toplevel_reorder)\n+    {\n+      qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n+\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+\tif (partition_varpool_node_p (vnode))\n+\t  n_varpool_nodes++;\n+      varpool_order = XNEWVEC (struct varpool_node *, n_varpool_nodes);\n+\n+      n_varpool_nodes = 0;\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+\tif (partition_varpool_node_p (vnode))\n+\t  varpool_order[n_varpool_nodes++] = vnode;\n+      qsort (varpool_order, n_varpool_nodes, sizeof (struct varpool_node *),\n+\t     varpool_node_cmp);\n+    }\n+\n+  /* Compute partition size and create the first partition.  */\n+  partition_size = total_size / PARAM_VALUE (PARAM_LTO_PARTITIONS);\n+  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n+    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n+  npartitions = 1;\n+  partition = new_partition (\"\");\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Total unit size: %i, partition size: %i\\n\",\n+\t     total_size, partition_size);\n+\n+  for (i = 0; i < n_nodes; i++)\n+    {\n+      if (order[i]->aux)\n+\tcontinue;\n+\n+      current_order = order[i]->order;\n+\n+      if (!flag_toplevel_reorder)\n+\twhile (varpool_pos < n_varpool_nodes && varpool_order[varpool_pos]->order < current_order)\n+\t  {\n+\t    if (!varpool_order[varpool_pos]->aux)\n+\t      add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n+\t    varpool_pos++;\n+\t  }\n+\n+      add_cgraph_node_to_partition (partition, order[i]);\n+      total_size -= inline_summary (order[i])->size;\n+\t  \n+\n+      /* Once we added a new node to the partition, we also want to add\n+         all referenced variables unless they was already added into some\n+         earlier partition.\n+\t add_cgraph_node_to_partition adds possibly multiple nodes and\n+\t variables that are needed to satisfy needs of ORDER[i].\n+         We remember last visited cgraph and varpool node from last iteration\n+         of outer loop that allows us to process every new addition. \n+\n+\t At the same time we compute size of the boundary into COST.  Every\n+         callgraph or IPA reference edge leaving the partition contributes into\n+         COST.  Every edge inside partition was earlier computed as one leaving\n+\t it and thus we need to subtract it from COST.  */\n+      while (last_visited_cgraph_node <\n+\t     VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes)\n+\t     || last_visited_varpool_node < VEC_length (varpool_node_ptr,\n+\t\t\t\t\t\t\tpartition->varpool_set->\n+\t\t\t\t\t\t\tnodes))\n+\t{\n+\t  struct ipa_ref_list *refs;\n+\t  int j;\n+\t  struct ipa_ref *ref;\n+\t  bool cgraph_p = false;\n+\n+\t  if (last_visited_cgraph_node <\n+\t      VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes))\n+\t    {\n+\t      struct cgraph_edge *edge;\n+\n+\t      cgraph_p = true;\n+\t      node = VEC_index (cgraph_node_ptr, partition->cgraph_set->nodes,\n+\t\t\t\tlast_visited_cgraph_node);\n+\t      refs = &node->ref_list;\n+\n+\t      last_visited_cgraph_node++;\n+\n+\t      gcc_assert (node->analyzed);\n+\n+\t      /* Compute boundary cost of callgraph edges.  */\n+\t      for (edge = node->callees; edge; edge = edge->next_callee)\n+\t\tif (edge->callee->analyzed)\n+\t\t  {\n+\t\t    int edge_cost = edge->frequency;\n+\t\t    cgraph_node_set_iterator csi;\n+\n+\t\t    if (!edge_cost)\n+\t\t      edge_cost = 1;\n+\t\t    gcc_assert (edge_cost > 0);\n+\t\t    csi = cgraph_node_set_find (partition->cgraph_set, edge->callee);\n+\t\t    if (!csi_end_p (csi)\n+\t\t        && csi.index < last_visited_cgraph_node - 1)\n+\t\t      cost -= edge_cost, internal+= edge_cost;\n+\t\t    else\n+\t\t      cost += edge_cost;\n+\t\t  }\n+\t      for (edge = node->callers; edge; edge = edge->next_caller)\n+\t\t{\n+\t\t  int edge_cost = edge->frequency;\n+\t\t  cgraph_node_set_iterator csi;\n+\n+\t\t  gcc_assert (edge->caller->analyzed);\n+\t\t  if (!edge_cost)\n+\t\t    edge_cost = 1;\n+\t\t  gcc_assert (edge_cost > 0);\n+\t\t  csi = cgraph_node_set_find (partition->cgraph_set, edge->caller);\n+\t\t  if (!csi_end_p (csi)\n+\t\t      && csi.index < last_visited_cgraph_node)\n+\t\t    cost -= edge_cost;\n+\t\t  else\n+\t\t    cost += edge_cost;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      refs =\n+\t\t&VEC_index (varpool_node_ptr, partition->varpool_set->nodes,\n+\t\t\t    last_visited_varpool_node)->ref_list;\n+\t      last_visited_varpool_node++;\n+\t    }\n+\n+\t  /* Compute boundary cost of IPA REF edges and at the same time look into\n+\t     variables referenced from current partition and try to add them.  */\n+\t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n+\t    if (ref->refered_type == IPA_REF_VARPOOL)\n+\t      {\n+\t\tvarpool_node_set_iterator vsi;\n+\n+\t\tvnode = ipa_ref_varpool_node (ref);\n+\t\tif (!vnode->finalized)\n+\t\t  continue;\n+\t\tif (!vnode->aux && flag_toplevel_reorder\n+\t\t    && partition_varpool_node_p (vnode))\n+\t\t  add_varpool_node_to_partition (partition, vnode);\n+\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n+\t\tif (!vsi_end_p (vsi)\n+\t\t    && vsi.index < last_visited_varpool_node - !cgraph_p)\n+\t\t  cost--, internal++;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcgraph_node_set_iterator csi;\n+\n+\t\tnode = ipa_ref_node (ref);\n+\t\tif (!node->analyzed)\n+\t\t  continue;\n+\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n+\t\tif (!csi_end_p (csi)\n+\t\t    && csi.index < last_visited_cgraph_node - cgraph_p)\n+\t\t  cost--, internal++;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t  for (j = 0; ipa_ref_list_refering_iterate (refs, j, ref); j++)\n+\t    if (ref->refering_type == IPA_REF_VARPOOL)\n+\t      {\n+\t\tvarpool_node_set_iterator vsi;\n+\n+\t\tvnode = ipa_ref_refering_varpool_node (ref);\n+\t\tgcc_assert (vnode->finalized);\n+\t\tif (!vnode->aux && flag_toplevel_reorder\n+\t\t    && partition_varpool_node_p (vnode))\n+\t\t  add_varpool_node_to_partition (partition, vnode);\n+\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n+\t\tif (!vsi_end_p (vsi)\n+\t\t    && vsi.index < last_visited_varpool_node)\n+\t\t  cost--;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcgraph_node_set_iterator csi;\n+\n+\t\tnode = ipa_ref_refering_node (ref);\n+\t\tgcc_assert (node->analyzed);\n+\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n+\t\tif (!csi_end_p (csi)\n+\t\t    && csi.index < last_visited_cgraph_node)\n+\t\t  cost--;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t}\n+\n+      /* If the partition is large enough, start looking for smallest boundary cost.  */\n+      if (partition->insns < partition_size * 3 / 4\n+\t  || best_cost == INT_MAX\n+\t  || ((!cost \n+\t       || (best_internal * (HOST_WIDE_INT) cost\n+\t\t   > (internal * (HOST_WIDE_INT)best_cost)))\n+  \t      && partition->insns < partition_size * 5 / 4))\n+\t{\n+\t  best_cost = cost;\n+\t  best_internal = internal;\n+\t  best_i = i;\n+\t  best_n_nodes = VEC_length (cgraph_node_ptr,\n+\t\t\t\t     partition->cgraph_set->nodes);\n+\t  best_n_varpool_nodes = VEC_length (varpool_node_ptr,\n+\t\t\t\t\t     partition->varpool_set->nodes);\n+\t  best_total_size = total_size;\n+\t}\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i best %i/%i, step %i\\n\", i,\n+\t\t cgraph_node_name (order[i]), order[i]->uid, partition->insns, cost, internal,\n+\t\t best_cost, best_internal, best_i);\n+      /* Partition is too large, unwind into step when best cost was reached and\n+\t start new partition.  */\n+      if (partition->insns > 2 * partition_size)\n+\t{\n+\t  if (best_i != i)\n+\t    {\n+\t      if (cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file, \"Unwinding %i insertions to step %i\\n\",\n+\t\t\t i - best_i, best_i);\n+\t      undo_partition (partition, best_n_nodes, best_n_varpool_nodes);\n+\t    }\n+\t  i = best_i;\n+ \t  /* When we are finished, avoid creating empty partition.  */\n+\t  while (i < n_nodes - 1 && order[i + 1]->aux)\n+\t    i++;\n+\t  if (i == n_nodes - 1)\n+\t    break;\n+\t  partition = new_partition (\"\");\n+\t  last_visited_cgraph_node = 0;\n+\t  last_visited_varpool_node = 0;\n+\t  total_size = best_total_size;\n+\t  cost = 0;\n+\n+\t  if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \"New partition\\n\");\n+\t  best_n_nodes = 0;\n+\t  best_n_varpool_nodes = 0;\n+\t  best_cost = INT_MAX;\n+\n+\t  /* Since the size of partitions is just approximate, update the size after\n+\t     we finished current one.  */\n+\t  if (npartitions < PARAM_VALUE (PARAM_LTO_PARTITIONS))\n+\t    partition_size = total_size\n+\t      / (PARAM_VALUE (PARAM_LTO_PARTITIONS) - npartitions);\n+\t  else\n+\t    partition_size = INT_MAX;\n+\n+\t  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n+\t    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n+\t  npartitions ++;\n+\t}\n+    }\n+\n+  /* Varables that are not reachable from the code go into last partition.  */\n+  if (flag_toplevel_reorder)\n+    {\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+        if (partition_varpool_node_p (vnode) && !vnode->aux)\n+\t  add_varpool_node_to_partition (partition, vnode);\n+    }\n+  else\n+    {\n+      while (varpool_pos < n_varpool_nodes)\n+\t{\n+\t  if (!varpool_order[varpool_pos]->aux)\n+\t    add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n+\t  varpool_pos++;\n+\t}\n+      free (varpool_order);\n+    }\n+  free (order);\n+}\n+\n+/* Promote variable VNODE to be static.  */\n+\n+static bool\n+promote_var (struct varpool_node *vnode)\n+{\n+  if (TREE_PUBLIC (vnode->decl) || DECL_EXTERNAL (vnode->decl))\n+    return false;\n+  gcc_assert (flag_wpa);\n+  TREE_PUBLIC (vnode->decl) = 1;\n+  DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n+  DECL_VISIBILITY_SPECIFIED (vnode->decl) = true;\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file,\n+\t    \"Promoting var as hidden: %s\\n\", varpool_node_name (vnode));\n+  return true;\n+}\n+\n+/* Promote function NODE to be static.  */\n+\n+static bool\n+promote_fn (struct cgraph_node *node)\n+{\n+  gcc_assert (flag_wpa);\n+  if (TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n+    return false;\n+  TREE_PUBLIC (node->decl) = 1;\n+  DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n+  DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file,\n+\t     \"Promoting function as hidden: %s/%i\\n\",\n+\t     cgraph_node_name (node), node->uid);\n+  return true;\n+}\n+\n+/* Find out all static decls that need to be promoted to global because\n+   of cross file sharing.  This function must be run in the WPA mode after\n+   all inlinees are added.  */\n+\n+void\n+lto_promote_cross_file_statics (void)\n+{\n+  struct varpool_node *vnode;\n+  unsigned i, n_sets;\n+  cgraph_node_set set;\n+  varpool_node_set vset;\n+  cgraph_node_set_iterator csi;\n+  varpool_node_set_iterator vsi;\n+  VEC(varpool_node_ptr, heap) *promoted_initializers = NULL;\n+  struct pointer_set_t *inserted = pointer_set_create ();\n+\n+  gcc_assert (flag_wpa);\n+\n+  n_sets = VEC_length (ltrans_partition, ltrans_partitions);\n+  for (i = 0; i < n_sets; i++)\n+    {\n+      ltrans_partition part\n+\t= VEC_index (ltrans_partition, ltrans_partitions, i);\n+      set = part->cgraph_set;\n+      vset = part->varpool_set;\n+\n+      /* If node called or referred to from other partition, it needs to be\n+\t globalized.  */\n+      for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+\t{\n+\t  struct cgraph_node *node = csi_node (csi);\n+\t  if (node->local.externally_visible)\n+\t    continue;\n+\t  if (node->global.inlined_to)\n+\t    continue;\n+\t  if ((!DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n+\t      && (referenced_from_other_partition_p (&node->ref_list, set, vset)\n+\t\t  || reachable_from_other_partition_p (node, set)))\n+\t    promote_fn (node);\n+\t}\n+      for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n+\t{\n+\t  vnode = vsi_node (vsi);\n+\t  /* Constant pool references use internal labels and thus can not\n+\t     be made global.  It is sensible to keep those ltrans local to\n+\t     allow better optimization.  */\n+\t  if (!DECL_IN_CONSTANT_POOL (vnode->decl) && !DECL_COMDAT (vnode->decl)\n+\t      && !vnode->externally_visible && vnode->analyzed\n+\t      && referenced_from_other_partition_p (&vnode->ref_list,\n+\t\t\t\t\t\t    set, vset))\n+\t    promote_var (vnode);\n+\t}\n+\n+      /* We export the initializer of a read-only var into each partition\n+\t referencing the var.  Folding might take declarations from the\n+\t initializer and use them, so everything referenced from the\n+\t initializer can be accessed from this partition after folding.\n+\n+\t This means that we need to promote all variables and functions\n+\t referenced from all initializers of read-only vars referenced\n+\t from this partition that are not in this partition.  This needs\n+\t to be done recursively.  */\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+\tif (const_value_known_p (vnode->decl)\n+\t    && DECL_INITIAL (vnode->decl)\n+\t    && !varpool_node_in_set_p (vnode, vset)\n+\t    && referenced_from_this_partition_p (&vnode->ref_list, set, vset)\n+\t    && !pointer_set_insert (inserted, vnode))\n+\tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n+\n+      while (!VEC_empty (varpool_node_ptr, promoted_initializers))\n+\t{\n+\t  int i;\n+\t  struct ipa_ref *ref;\n+\n+\t  vnode = VEC_pop (varpool_node_ptr, promoted_initializers);\n+\t  for (i = 0;\n+\t       ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref);\n+\t       i++)\n+\t    {\n+\t      if (ref->refered_type == IPA_REF_CGRAPH)\n+\t\t{\n+\t\t  struct cgraph_node *n = ipa_ref_node (ref);\n+\t\t  gcc_assert (!n->global.inlined_to);\n+\t\t  if (!n->local.externally_visible\n+\t\t      && !cgraph_node_in_set_p (n, set))\n+\t\t    promote_fn (n);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct varpool_node *v = ipa_ref_varpool_node (ref);\n+\t\t  if (varpool_node_in_set_p (v, vset))\n+\t\t    continue;\n+\n+\t\t  /* Constant pool references use internal labels and thus\n+\t\t     cannot be made global.  It is sensible to keep those\n+\t\t     ltrans local to allow better optimization.  */\n+\t\t  if (DECL_IN_CONSTANT_POOL (v->decl))\n+\t\t    {\n+\t\t      if (!pointer_set_insert (inserted, vnode))\n+\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n+\t\t\t\t       promoted_initializers, v);\n+\t\t    }\n+\t\t  else if (!v->externally_visible && v->analyzed)\n+\t\t    {\n+\t\t      if (promote_var (v)\n+\t\t\t  && DECL_INITIAL (v->decl)\n+\t\t\t  && const_value_known_p (v->decl)\n+\t\t\t  && !pointer_set_insert (inserted, vnode))\n+\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n+\t\t\t\t       promoted_initializers, v);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  pointer_set_destroy (inserted);\n+}"}, {"sha": "2160274dda62270340dca80de942caf1d6792605", "filename": "gcc/lto/lto-partition.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2Flto-partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2Flto-partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.h?ref=a66dc2852c9ca8359c1649c86c0182b66be8ee92", "patch": "@@ -0,0 +1,40 @@\n+/* LTO partitioning logic routines.\n+   Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Structure describing ltrans partitions.  */\n+\n+struct ltrans_partition_def\n+{\n+  cgraph_node_set cgraph_set;\n+  varpool_node_set varpool_set;\n+  const char * name;\n+  int insns;\n+};\n+\n+typedef struct ltrans_partition_def *ltrans_partition;\n+DEF_VEC_P(ltrans_partition);\n+DEF_VEC_ALLOC_P(ltrans_partition,heap);\n+\n+extern VEC(ltrans_partition, heap) *ltrans_partitions;\n+\n+void lto_1_to_1_map (void);\n+void lto_balanced_map (void);\n+void lto_promote_cross_file_statics (void);\n+void free_ltrans_partitions (void);"}, {"sha": "921533f01bea91366501d698534df9ca991d1cea", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 897, "changes": 899, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a66dc2852c9ca8359c1649c86c0182b66be8ee92/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=a66dc2852c9ca8359c1649c86c0182b66be8ee92", "patch": "@@ -1,5 +1,5 @@\n /* Top-level LTO routines.\n-   Copyright 2009, 2010, 2011 Free Software Foundation, Inc.\n+   Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by CodeSourcery, Inc.\n \n This file is part of GCC.\n@@ -45,9 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"tree-streamer.h\"\n #include \"splay-tree.h\"\n-#include \"params.h\"\n-#include \"ipa-inline.h\"\n-#include \"ipa-utils.h\"\n+#include \"lto-partition.h\"\n \n static GTY(()) tree first_personality_decl;\n \n@@ -1398,899 +1396,6 @@ free_section_data (struct lto_file_decl_data *file_data ATTRIBUTE_UNUSED,\n #endif\n }\n \n-/* Structure describing ltrans partitions.  */\n-\n-struct ltrans_partition_def\n-{\n-  cgraph_node_set cgraph_set;\n-  varpool_node_set varpool_set;\n-  const char * name;\n-  int insns;\n-};\n-\n-typedef struct ltrans_partition_def *ltrans_partition;\n-DEF_VEC_P(ltrans_partition);\n-DEF_VEC_ALLOC_P(ltrans_partition,heap);\n-\n-static VEC(ltrans_partition, heap) *ltrans_partitions;\n-\n-static void add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node);\n-static void add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode);\n-\n-/* Create new partition with name NAME.  */\n-static ltrans_partition\n-new_partition (const char *name)\n-{\n-  ltrans_partition part = XCNEW (struct ltrans_partition_def);\n-  part->cgraph_set = cgraph_node_set_new ();\n-  part->varpool_set = varpool_node_set_new ();\n-  part->name = name;\n-  part->insns = 0;\n-  VEC_safe_push (ltrans_partition, heap, ltrans_partitions, part);\n-  return part;\n-}\n-\n-/* Free memory used by ltrans datastructures.  */\n-static void\n-free_ltrans_partitions (void)\n-{\n-  unsigned int idx;\n-  ltrans_partition part;\n-  for (idx = 0; VEC_iterate (ltrans_partition, ltrans_partitions, idx, part); idx++)\n-    {\n-      free_cgraph_node_set (part->cgraph_set);\n-      free (part);\n-    }\n-  VEC_free (ltrans_partition, heap, ltrans_partitions);\n-}\n-\n-/* See all references that go to comdat objects and bring them into partition too.\n-   Also see all aliases of the newly added entry and bring them, too.  */\n-static void\n-add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n-{\n-  int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n-    {\n-      if (ref->refered_type == IPA_REF_CGRAPH\n-\t  && (DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref),\n-\t\t\t   NULL)->decl)\n-\t      || (ref->use == IPA_REF_ALIAS\n-\t\t  && lookup_attribute\n-\t\t       (\"weakref\", DECL_ATTRIBUTES (ipa_ref_node (ref)->decl))))\n-\t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n-\tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n-      else\n-\tif (ref->refered_type == IPA_REF_VARPOOL\n-\t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->decl)\n-\t        || (ref->use == IPA_REF_ALIAS\n-\t\t    && lookup_attribute\n-\t\t         (\"weakref\",\n-\t\t\t  DECL_ATTRIBUTES (ipa_ref_varpool_node (ref)->decl))))\n-\t    && !varpool_node_in_set_p (ipa_ref_varpool_node (ref),\n-\t\t\t\t       part->varpool_set))\n-\t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n-    }\n-  for (i = 0; ipa_ref_list_refering_iterate (refs, i, ref); i++)\n-    {\n-      if (ref->refering_type == IPA_REF_CGRAPH\n-\t  && ref->use == IPA_REF_ALIAS\n-\t  && !cgraph_node_in_set_p (ipa_ref_refering_node (ref),\n-\t\t\t\t    part->cgraph_set)\n-\t  && !lookup_attribute (\"weakref\",\n-\t\t\t\tDECL_ATTRIBUTES\n-\t\t\t\t  (ipa_ref_refering_node (ref)->decl)))\n-\tadd_cgraph_node_to_partition (part, ipa_ref_refering_node (ref));\n-      else\n-\tif (ref->refering_type == IPA_REF_VARPOOL\n-\t    && ref->use == IPA_REF_ALIAS\n-\t    && !varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n-\t\t\t\t       part->varpool_set)\n-\t    && !lookup_attribute (\"weakref\",\n-\t\t\t\t  DECL_ATTRIBUTES\n-\t\t\t\t    (ipa_ref_refering_varpool_node (ref)->decl)))\n-\t  add_varpool_node_to_partition (part,\n-\t\t\t\t\t ipa_ref_refering_varpool_node (ref));\n-    }\n-}\n-\n-/* Worker for add_cgraph_node_to_partition.  */\n-\n-static bool\n-add_cgraph_node_to_partition_1 (struct cgraph_node *node, void *data)\n-{\n-  ltrans_partition part = (ltrans_partition) data;\n-\n-  /* non-COMDAT aliases of COMDAT functions needs to be output just once.  */\n-  if (!DECL_COMDAT (node->decl)\n-      && !node->global.inlined_to\n-      && node->aux)\n-    {\n-      gcc_assert (node->thunk.thunk_p || node->alias);\n-      return false;\n-    }\n-\n-  if (node->aux)\n-    {\n-      node->in_other_partition = 1;\n-      if (cgraph_dump_file)\n-        fprintf (cgraph_dump_file, \"Node %s/%i now used in multiple partitions\\n\",\n-\t\t cgraph_node_name (node), node->uid);\n-    }\n-  node->aux = (void *)((size_t)node->aux + 1);\n-  cgraph_node_set_add (part->cgraph_set, node);\n-  return false;\n-}\n-\n-/* Add NODE to partition as well as the inline callees and referred comdats into partition PART. */\n-\n-static void\n-add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n-{\n-  struct cgraph_edge *e;\n-  cgraph_node_set_iterator csi;\n-  struct cgraph_node *n;\n-\n-  /* If NODE is already there, we have nothing to do.  */\n-  csi = cgraph_node_set_find (part->cgraph_set, node);\n-  if (!csi_end_p (csi))\n-    return;\n-\n-  cgraph_for_node_thunks_and_aliases (node, add_cgraph_node_to_partition_1, part, true);\n-\n-  part->insns += inline_summary (node)->self_size;\n-\n-\n-  cgraph_node_set_add (part->cgraph_set, node);\n-\n-  for (e = node->callees; e; e = e->next_callee)\n-    if ((!e->inline_failed\n-\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->decl))\n-\t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n-      add_cgraph_node_to_partition (part, e->callee);\n-\n-  /* The only way to assemble non-weakref alias is to add the aliased object into\n-     the unit.  */\n-  add_references_to_partition (part, &node->ref_list);\n-  n = cgraph_function_node (node, NULL);\n-  if (n != node\n-      && !lookup_attribute (\"weakref\",\n-\t\t\t    DECL_ATTRIBUTES (node->decl)))\n-    add_cgraph_node_to_partition (part, n);\n-\n-  if (node->same_comdat_group)\n-    for (n = node->same_comdat_group; n != node; n = n->same_comdat_group)\n-      add_cgraph_node_to_partition (part, n);\n-}\n-\n-/* Add VNODE to partition as well as comdat references partition PART. */\n-\n-static void\n-add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode)\n-{\n-  varpool_node_set_iterator vsi;\n-  struct varpool_node *v;\n-\n-  /* If NODE is already there, we have nothing to do.  */\n-  vsi = varpool_node_set_find (part->varpool_set, vnode);\n-  if (!vsi_end_p (vsi))\n-    return;\n-\n-  varpool_node_set_add (part->varpool_set, vnode);\n-\n-  if (vnode->aux)\n-    {\n-      vnode->in_other_partition = 1;\n-      if (cgraph_dump_file)\n-        fprintf (cgraph_dump_file, \"Varpool node %s now used in multiple partitions\\n\",\n-\t\t varpool_node_name (vnode));\n-    }\n-  vnode->aux = (void *)((size_t)vnode->aux + 1);\n-\n-  /* The only way to assemble non-weakref alias is to add the aliased object into\n-     the unit.  */\n-  v = varpool_variable_node (vnode, NULL);\n-  if (v != vnode\n-      && !lookup_attribute (\"weakref\",\n-\t\t\t    DECL_ATTRIBUTES (vnode->decl)))\n-    add_varpool_node_to_partition (part, v);\n-\n-  add_references_to_partition (part, &vnode->ref_list);\n-\n-  if (vnode->same_comdat_group\n-      && !varpool_node_in_set_p (vnode->same_comdat_group, part->varpool_set))\n-    add_varpool_node_to_partition (part, vnode->same_comdat_group);\n-}\n-\n-/* Undo all additions until number of cgraph nodes in PARITION is N_CGRAPH_NODES\n-   and number of varpool nodes is N_VARPOOL_NODES.  */\n-\n-static void\n-undo_partition (ltrans_partition partition, unsigned int n_cgraph_nodes,\n-\t\tunsigned int n_varpool_nodes)\n-{\n-  while (VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes) >\n-\t n_cgraph_nodes)\n-    {\n-      struct cgraph_node *node = VEC_index (cgraph_node_ptr,\n-\t\t\t\t\t    partition->cgraph_set->nodes,\n-\t\t\t\t\t    n_cgraph_nodes);\n-      partition->insns -= inline_summary (node)->self_size;\n-      cgraph_node_set_remove (partition->cgraph_set, node);\n-      node->aux = (void *)((size_t)node->aux - 1);\n-    }\n-  while (VEC_length (varpool_node_ptr, partition->varpool_set->nodes) >\n-\t n_varpool_nodes)\n-    {\n-      struct varpool_node *node = VEC_index (varpool_node_ptr,\n-\t\t\t\t\t     partition->varpool_set->nodes,\n-\t\t\t\t\t     n_varpool_nodes);\n-      varpool_node_set_remove (partition->varpool_set, node);\n-      node->aux = (void *)((size_t)node->aux - 1);\n-    }\n-}\n-\n-/* Return true if NODE should be partitioned.\n-   This means that partitioning algorithm should put NODE into one of partitions.\n-   This apply to most functions with bodies.  Functions that are not partitions\n-   are put into every unit needing them.  This is the case of i.e. COMDATs.  */\n-\n-static bool\n-partition_cgraph_node_p (struct cgraph_node *node)\n-{\n-  /* We will get proper partition based on function they are inlined to.  */\n-  if (node->global.inlined_to)\n-    return false;\n-  /* Nodes without a body do not need partitioning.  */\n-  if (!node->analyzed)\n-    return false;\n-  /* Extern inlines and comdat are always only in partitions they are needed.  */\n-  if (DECL_EXTERNAL (node->decl)\n-      || (DECL_COMDAT (node->decl)\n-\t  && !cgraph_used_from_object_file_p (node)))\n-    return false;\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->decl)))\n-    return false;\n-  return true;\n-}\n-\n-/* Return true if VNODE should be partitioned. \n-   This means that partitioning algorithm should put VNODE into one of partitions. */\n-\n-static bool\n-partition_varpool_node_p (struct varpool_node *vnode)\n-{\n-  if (vnode->alias || !vnode->needed)\n-    return false;\n-  /* Constant pool and comdat are always only in partitions they are needed.  */\n-  if (DECL_IN_CONSTANT_POOL (vnode->decl)\n-      || (DECL_COMDAT (vnode->decl)\n-\t  && !vnode->force_output\n-\t  && !varpool_used_from_object_file_p (vnode)))\n-    return false;\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->decl)))\n-    return false;\n-  return true;\n-}\n-\n-/* Group cgrah nodes by input files.  This is used mainly for testing\n-   right now.  */\n-\n-static void\n-lto_1_to_1_map (void)\n-{\n-  struct cgraph_node *node;\n-  struct varpool_node *vnode;\n-  struct lto_file_decl_data *file_data;\n-  struct pointer_map_t *pmap;\n-  ltrans_partition partition;\n-  void **slot;\n-  int npartitions = 0;\n-\n-  timevar_push (TV_WHOPR_WPA);\n-\n-  pmap = pointer_map_create ();\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      if (!partition_cgraph_node_p (node)\n-\t  || node->aux)\n-\tcontinue;\n-\n-      file_data = node->local.lto_file_data;\n-\n-      if (file_data)\n-\t{\n-          slot = pointer_map_contains (pmap, file_data);\n-          if (slot)\n-\t    partition = (ltrans_partition) *slot;\n-\t  else\n-\t    {\n-\t      partition = new_partition (file_data->file_name);\n-\t      slot = pointer_map_insert (pmap, file_data);\n-\t      *slot = partition;\n-\t      npartitions++;\n-\t    }\n-\t}\n-      else if (!file_data\n-\t       && VEC_length (ltrans_partition, ltrans_partitions))\n-\tpartition = VEC_index (ltrans_partition, ltrans_partitions, 0);\n-      else\n-\t{\n-\t  partition = new_partition (\"\");\n-\t  slot = pointer_map_insert (pmap, NULL);\n-\t  *slot = partition;\n-\t  npartitions++;\n-\t}\n-\n-      add_cgraph_node_to_partition (partition, node);\n-    }\n-\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    {\n-      if (!partition_varpool_node_p (vnode)\n-\t  || vnode->aux)\n-\tcontinue;\n-      file_data = vnode->lto_file_data;\n-      slot = pointer_map_contains (pmap, file_data);\n-      if (slot)\n-\tpartition = (ltrans_partition) *slot;\n-      else\n-\t{\n-\t  partition = new_partition (file_data->file_name);\n-\t  slot = pointer_map_insert (pmap, file_data);\n-\t  *slot = partition;\n-\t  npartitions++;\n-\t}\n-\n-      add_varpool_node_to_partition (partition, vnode);\n-    }\n-  for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = NULL;\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    vnode->aux = NULL;\n-\n-  /* If the cgraph is empty, create one cgraph node set so that there is still\n-     an output file for any variables that need to be exported in a DSO.  */\n-  if (!npartitions)\n-    new_partition (\"empty\");\n-\n-  pointer_map_destroy (pmap);\n-\n-  timevar_pop (TV_WHOPR_WPA);\n-\n-  lto_stats.num_cgraph_partitions += VEC_length (ltrans_partition, \n-\t\t\t\t\t\t ltrans_partitions);\n-}\n-\n-/* Helper function for qsort; sort nodes by order.  */\n-static int\n-node_cmp (const void *pa, const void *pb)\n-{\n-  const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n-  const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n-  return b->order - a->order;\n-}\n-\n-/* Helper function for qsort; sort nodes by order.  */\n-static int\n-varpool_node_cmp (const void *pa, const void *pb)\n-{\n-  const struct varpool_node *a = *(const struct varpool_node * const *) pa;\n-  const struct varpool_node *b = *(const struct varpool_node * const *) pb;\n-  return b->order - a->order;\n-}\n-\n-/* Group cgraph nodes into equally-sized partitions.\n-\n-   The partitioning algorithm is simple: nodes are taken in predefined order.\n-   The order corresponds to the order we want functions to have in the final\n-   output.  In the future this will be given by function reordering pass, but\n-   at the moment we use the topological order, which is a good approximation.\n-\n-   The goal is to partition this linear order into intervals (partitions) so\n-   that all the partitions have approximately the same size and the number of\n-   callgraph or IPA reference edges crossing boundaries is minimal.\n-\n-   This is a lot faster (O(n) in size of callgraph) than algorithms doing\n-   priority-based graph clustering that are generally O(n^2) and, since\n-   WHOPR is designed to make things go well across partitions, it leads\n-   to good results.\n-\n-   We compute the expected size of a partition as:\n-\n-     max (total_size / lto_partitions, min_partition_size)\n-\n-   We use dynamic expected size of partition so small programs are partitioned\n-   into enough partitions to allow use of multiple CPUs, while large programs\n-   are not partitioned too much.  Creating too many partitions significantly\n-   increases the streaming overhead.\n-\n-   In the future, we would like to bound the maximal size of partitions so as\n-   to prevent the LTRANS stage from consuming too much memory.  At the moment,\n-   however, the WPA stage is the most memory intensive for large benchmarks,\n-   since too many types and declarations are read into memory.\n-\n-   The function implements a simple greedy algorithm.  Nodes are being added\n-   to the current partition until after 3/4 of the expected partition size is\n-   reached.  Past this threshold, we keep track of boundary size (number of\n-   edges going to other partitions) and continue adding functions until after\n-   the current partition has grown to twice the expected partition size.  Then\n-   the process is undone to the point where the minimal ratio of boundary size\n-   and in-partition calls was reached.  */\n-\n-static void\n-lto_balanced_map (void)\n-{\n-  int n_nodes = 0;\n-  int n_varpool_nodes = 0, varpool_pos = 0;\n-  struct cgraph_node **postorder =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  struct cgraph_node **order = XNEWVEC (struct cgraph_node *, cgraph_max_uid);\n-  struct varpool_node **varpool_order = NULL;\n-  int i, postorder_len;\n-  struct cgraph_node *node;\n-  int total_size = 0, best_total_size = 0;\n-  int partition_size;\n-  ltrans_partition partition;\n-  unsigned int last_visited_cgraph_node = 0, last_visited_varpool_node = 0;\n-  struct varpool_node *vnode;\n-  int cost = 0, internal = 0;\n-  int best_n_nodes = 0, best_n_varpool_nodes = 0, best_i = 0, best_cost =\n-    INT_MAX, best_internal = 0;\n-  int npartitions;\n-  int current_order = -1;\n-\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    gcc_assert (!vnode->aux);\n-  /* Until we have better ordering facility, use toplogical order.\n-     Include only nodes we will partition and compute estimate of program\n-     size.  Note that since nodes that are not partitioned might be put into\n-     multiple partitions, this is just an estimate of real size.  This is why\n-     we keep partition_size updated after every partition is finalized.  */\n-  postorder_len = ipa_reverse_postorder (postorder);\n-    \n-  for (i = 0; i < postorder_len; i++)\n-    {\n-      node = postorder[i];\n-      if (partition_cgraph_node_p (node))\n-\t{\n-\t  order[n_nodes++] = node;\n-          total_size += inline_summary (node)->size;\n-\t}\n-    }\n-  free (postorder);\n-\n-  if (!flag_toplevel_reorder)\n-    {\n-      qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n-\n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-\tif (partition_varpool_node_p (vnode))\n-\t  n_varpool_nodes++;\n-      varpool_order = XNEWVEC (struct varpool_node *, n_varpool_nodes);\n-\n-      n_varpool_nodes = 0;\n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-\tif (partition_varpool_node_p (vnode))\n-\t  varpool_order[n_varpool_nodes++] = vnode;\n-      qsort (varpool_order, n_varpool_nodes, sizeof (struct varpool_node *),\n-\t     varpool_node_cmp);\n-    }\n-\n-  /* Compute partition size and create the first partition.  */\n-  partition_size = total_size / PARAM_VALUE (PARAM_LTO_PARTITIONS);\n-  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n-    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n-  npartitions = 1;\n-  partition = new_partition (\"\");\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Total unit size: %i, partition size: %i\\n\",\n-\t     total_size, partition_size);\n-\n-  for (i = 0; i < n_nodes; i++)\n-    {\n-      if (order[i]->aux)\n-\tcontinue;\n-\n-      current_order = order[i]->order;\n-\n-      if (!flag_toplevel_reorder)\n-\twhile (varpool_pos < n_varpool_nodes && varpool_order[varpool_pos]->order < current_order)\n-\t  {\n-\t    if (!varpool_order[varpool_pos]->aux)\n-\t      add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n-\t    varpool_pos++;\n-\t  }\n-\n-      add_cgraph_node_to_partition (partition, order[i]);\n-      total_size -= inline_summary (order[i])->size;\n-\t  \n-\n-      /* Once we added a new node to the partition, we also want to add\n-         all referenced variables unless they was already added into some\n-         earlier partition.\n-\t add_cgraph_node_to_partition adds possibly multiple nodes and\n-\t variables that are needed to satisfy needs of ORDER[i].\n-         We remember last visited cgraph and varpool node from last iteration\n-         of outer loop that allows us to process every new addition. \n-\n-\t At the same time we compute size of the boundary into COST.  Every\n-         callgraph or IPA reference edge leaving the partition contributes into\n-         COST.  Every edge inside partition was earlier computed as one leaving\n-\t it and thus we need to subtract it from COST.  */\n-      while (last_visited_cgraph_node <\n-\t     VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes)\n-\t     || last_visited_varpool_node < VEC_length (varpool_node_ptr,\n-\t\t\t\t\t\t\tpartition->varpool_set->\n-\t\t\t\t\t\t\tnodes))\n-\t{\n-\t  struct ipa_ref_list *refs;\n-\t  int j;\n-\t  struct ipa_ref *ref;\n-\t  bool cgraph_p = false;\n-\n-\t  if (last_visited_cgraph_node <\n-\t      VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes))\n-\t    {\n-\t      struct cgraph_edge *edge;\n-\n-\t      cgraph_p = true;\n-\t      node = VEC_index (cgraph_node_ptr, partition->cgraph_set->nodes,\n-\t\t\t\tlast_visited_cgraph_node);\n-\t      refs = &node->ref_list;\n-\n-\t      last_visited_cgraph_node++;\n-\n-\t      gcc_assert (node->analyzed);\n-\n-\t      /* Compute boundary cost of callgraph edges.  */\n-\t      for (edge = node->callees; edge; edge = edge->next_callee)\n-\t\tif (edge->callee->analyzed)\n-\t\t  {\n-\t\t    int edge_cost = edge->frequency;\n-\t\t    cgraph_node_set_iterator csi;\n-\n-\t\t    if (!edge_cost)\n-\t\t      edge_cost = 1;\n-\t\t    gcc_assert (edge_cost > 0);\n-\t\t    csi = cgraph_node_set_find (partition->cgraph_set, edge->callee);\n-\t\t    if (!csi_end_p (csi)\n-\t\t        && csi.index < last_visited_cgraph_node - 1)\n-\t\t      cost -= edge_cost, internal+= edge_cost;\n-\t\t    else\n-\t\t      cost += edge_cost;\n-\t\t  }\n-\t      for (edge = node->callers; edge; edge = edge->next_caller)\n-\t\t{\n-\t\t  int edge_cost = edge->frequency;\n-\t\t  cgraph_node_set_iterator csi;\n-\n-\t\t  gcc_assert (edge->caller->analyzed);\n-\t\t  if (!edge_cost)\n-\t\t    edge_cost = 1;\n-\t\t  gcc_assert (edge_cost > 0);\n-\t\t  csi = cgraph_node_set_find (partition->cgraph_set, edge->caller);\n-\t\t  if (!csi_end_p (csi)\n-\t\t      && csi.index < last_visited_cgraph_node)\n-\t\t    cost -= edge_cost;\n-\t\t  else\n-\t\t    cost += edge_cost;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      refs =\n-\t\t&VEC_index (varpool_node_ptr, partition->varpool_set->nodes,\n-\t\t\t    last_visited_varpool_node)->ref_list;\n-\t      last_visited_varpool_node++;\n-\t    }\n-\n-\t  /* Compute boundary cost of IPA REF edges and at the same time look into\n-\t     variables referenced from current partition and try to add them.  */\n-\t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n-\t    if (ref->refered_type == IPA_REF_VARPOOL)\n-\t      {\n-\t\tvarpool_node_set_iterator vsi;\n-\n-\t\tvnode = ipa_ref_varpool_node (ref);\n-\t\tif (!vnode->finalized)\n-\t\t  continue;\n-\t\tif (!vnode->aux && flag_toplevel_reorder\n-\t\t    && partition_varpool_node_p (vnode))\n-\t\t  add_varpool_node_to_partition (partition, vnode);\n-\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n-\t\tif (!vsi_end_p (vsi)\n-\t\t    && vsi.index < last_visited_varpool_node - !cgraph_p)\n-\t\t  cost--, internal++;\n-\t\telse\n-\t\t  cost++;\n-\t      }\n-\t    else\n-\t      {\n-\t\tcgraph_node_set_iterator csi;\n-\n-\t\tnode = ipa_ref_node (ref);\n-\t\tif (!node->analyzed)\n-\t\t  continue;\n-\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n-\t\tif (!csi_end_p (csi)\n-\t\t    && csi.index < last_visited_cgraph_node - cgraph_p)\n-\t\t  cost--, internal++;\n-\t\telse\n-\t\t  cost++;\n-\t      }\n-\t  for (j = 0; ipa_ref_list_refering_iterate (refs, j, ref); j++)\n-\t    if (ref->refering_type == IPA_REF_VARPOOL)\n-\t      {\n-\t\tvarpool_node_set_iterator vsi;\n-\n-\t\tvnode = ipa_ref_refering_varpool_node (ref);\n-\t\tgcc_assert (vnode->finalized);\n-\t\tif (!vnode->aux && flag_toplevel_reorder\n-\t\t    && partition_varpool_node_p (vnode))\n-\t\t  add_varpool_node_to_partition (partition, vnode);\n-\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n-\t\tif (!vsi_end_p (vsi)\n-\t\t    && vsi.index < last_visited_varpool_node)\n-\t\t  cost--;\n-\t\telse\n-\t\t  cost++;\n-\t      }\n-\t    else\n-\t      {\n-\t\tcgraph_node_set_iterator csi;\n-\n-\t\tnode = ipa_ref_refering_node (ref);\n-\t\tgcc_assert (node->analyzed);\n-\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n-\t\tif (!csi_end_p (csi)\n-\t\t    && csi.index < last_visited_cgraph_node)\n-\t\t  cost--;\n-\t\telse\n-\t\t  cost++;\n-\t      }\n-\t}\n-\n-      /* If the partition is large enough, start looking for smallest boundary cost.  */\n-      if (partition->insns < partition_size * 3 / 4\n-\t  || best_cost == INT_MAX\n-\t  || ((!cost \n-\t       || (best_internal * (HOST_WIDE_INT) cost\n-\t\t   > (internal * (HOST_WIDE_INT)best_cost)))\n-  \t      && partition->insns < partition_size * 5 / 4))\n-\t{\n-\t  best_cost = cost;\n-\t  best_internal = internal;\n-\t  best_i = i;\n-\t  best_n_nodes = VEC_length (cgraph_node_ptr,\n-\t\t\t\t     partition->cgraph_set->nodes);\n-\t  best_n_varpool_nodes = VEC_length (varpool_node_ptr,\n-\t\t\t\t\t     partition->varpool_set->nodes);\n-\t  best_total_size = total_size;\n-\t}\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i best %i/%i, step %i\\n\", i,\n-\t\t cgraph_node_name (order[i]), order[i]->uid, partition->insns, cost, internal,\n-\t\t best_cost, best_internal, best_i);\n-      /* Partition is too large, unwind into step when best cost was reached and\n-\t start new partition.  */\n-      if (partition->insns > 2 * partition_size)\n-\t{\n-\t  if (best_i != i)\n-\t    {\n-\t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \"Unwinding %i insertions to step %i\\n\",\n-\t\t\t i - best_i, best_i);\n-\t      undo_partition (partition, best_n_nodes, best_n_varpool_nodes);\n-\t    }\n-\t  i = best_i;\n- \t  /* When we are finished, avoid creating empty partition.  */\n-\t  while (i < n_nodes - 1 && order[i + 1]->aux)\n-\t    i++;\n-\t  if (i == n_nodes - 1)\n-\t    break;\n-\t  partition = new_partition (\"\");\n-\t  last_visited_cgraph_node = 0;\n-\t  last_visited_varpool_node = 0;\n-\t  total_size = best_total_size;\n-\t  cost = 0;\n-\n-\t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \"New partition\\n\");\n-\t  best_n_nodes = 0;\n-\t  best_n_varpool_nodes = 0;\n-\t  best_cost = INT_MAX;\n-\n-\t  /* Since the size of partitions is just approximate, update the size after\n-\t     we finished current one.  */\n-\t  if (npartitions < PARAM_VALUE (PARAM_LTO_PARTITIONS))\n-\t    partition_size = total_size\n-\t      / (PARAM_VALUE (PARAM_LTO_PARTITIONS) - npartitions);\n-\t  else\n-\t    partition_size = INT_MAX;\n-\n-\t  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n-\t    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n-\t  npartitions ++;\n-\t}\n-    }\n-\n-  /* Varables that are not reachable from the code go into last partition.  */\n-  if (flag_toplevel_reorder)\n-    {\n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-        if (partition_varpool_node_p (vnode) && !vnode->aux)\n-\t  add_varpool_node_to_partition (partition, vnode);\n-    }\n-  else\n-    {\n-      while (varpool_pos < n_varpool_nodes)\n-\t{\n-\t  if (!varpool_order[varpool_pos]->aux)\n-\t    add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n-\t  varpool_pos++;\n-\t}\n-      free (varpool_order);\n-    }\n-  free (order);\n-}\n-\n-/* Promote variable VNODE to be static.  */\n-\n-static bool\n-promote_var (struct varpool_node *vnode)\n-{\n-  if (TREE_PUBLIC (vnode->decl) || DECL_EXTERNAL (vnode->decl))\n-    return false;\n-  gcc_assert (flag_wpa);\n-  TREE_PUBLIC (vnode->decl) = 1;\n-  DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n-  DECL_VISIBILITY_SPECIFIED (vnode->decl) = true;\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n-\t    \"Promoting var as hidden: %s\\n\", varpool_node_name (vnode));\n-  return true;\n-}\n-\n-/* Promote function NODE to be static.  */\n-\n-static bool\n-promote_fn (struct cgraph_node *node)\n-{\n-  gcc_assert (flag_wpa);\n-  if (TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n-    return false;\n-  TREE_PUBLIC (node->decl) = 1;\n-  DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n-  DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n-\t     \"Promoting function as hidden: %s/%i\\n\",\n-\t     cgraph_node_name (node), node->uid);\n-  return true;\n-}\n-\n-/* Find out all static decls that need to be promoted to global because\n-   of cross file sharing.  This function must be run in the WPA mode after\n-   all inlinees are added.  */\n-\n-static void\n-lto_promote_cross_file_statics (void)\n-{\n-  struct varpool_node *vnode;\n-  unsigned i, n_sets;\n-  cgraph_node_set set;\n-  varpool_node_set vset;\n-  cgraph_node_set_iterator csi;\n-  varpool_node_set_iterator vsi;\n-  VEC(varpool_node_ptr, heap) *promoted_initializers = NULL;\n-  struct pointer_set_t *inserted = pointer_set_create ();\n-\n-  gcc_assert (flag_wpa);\n-\n-  n_sets = VEC_length (ltrans_partition, ltrans_partitions);\n-  for (i = 0; i < n_sets; i++)\n-    {\n-      ltrans_partition part\n-\t= VEC_index (ltrans_partition, ltrans_partitions, i);\n-      set = part->cgraph_set;\n-      vset = part->varpool_set;\n-\n-      /* If node called or referred to from other partition, it needs to be\n-\t globalized.  */\n-      for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-\t{\n-\t  struct cgraph_node *node = csi_node (csi);\n-\t  if (node->local.externally_visible)\n-\t    continue;\n-\t  if (node->global.inlined_to)\n-\t    continue;\n-\t  if ((!DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n-\t      && (referenced_from_other_partition_p (&node->ref_list, set, vset)\n-\t\t  || reachable_from_other_partition_p (node, set)))\n-\t    promote_fn (node);\n-\t}\n-      for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n-\t{\n-\t  vnode = vsi_node (vsi);\n-\t  /* Constant pool references use internal labels and thus can not\n-\t     be made global.  It is sensible to keep those ltrans local to\n-\t     allow better optimization.  */\n-\t  if (!DECL_IN_CONSTANT_POOL (vnode->decl) && !DECL_COMDAT (vnode->decl)\n-\t      && !vnode->externally_visible && vnode->analyzed\n-\t      && referenced_from_other_partition_p (&vnode->ref_list,\n-\t\t\t\t\t\t    set, vset))\n-\t    promote_var (vnode);\n-\t}\n-\n-      /* We export the initializer of a read-only var into each partition\n-\t referencing the var.  Folding might take declarations from the\n-\t initializer and use them, so everything referenced from the\n-\t initializer can be accessed from this partition after folding.\n-\n-\t This means that we need to promote all variables and functions\n-\t referenced from all initializers of read-only vars referenced\n-\t from this partition that are not in this partition.  This needs\n-\t to be done recursively.  */\n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-\tif (const_value_known_p (vnode->decl)\n-\t    && DECL_INITIAL (vnode->decl)\n-\t    && !varpool_node_in_set_p (vnode, vset)\n-\t    && referenced_from_this_partition_p (&vnode->ref_list, set, vset)\n-\t    && !pointer_set_insert (inserted, vnode))\n-\tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n-\n-      while (!VEC_empty (varpool_node_ptr, promoted_initializers))\n-\t{\n-\t  int i;\n-\t  struct ipa_ref *ref;\n-\n-\t  vnode = VEC_pop (varpool_node_ptr, promoted_initializers);\n-\t  for (i = 0;\n-\t       ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref);\n-\t       i++)\n-\t    {\n-\t      if (ref->refered_type == IPA_REF_CGRAPH)\n-\t\t{\n-\t\t  struct cgraph_node *n = ipa_ref_node (ref);\n-\t\t  gcc_assert (!n->global.inlined_to);\n-\t\t  if (!n->local.externally_visible\n-\t\t      && !cgraph_node_in_set_p (n, set))\n-\t\t    promote_fn (n);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  struct varpool_node *v = ipa_ref_varpool_node (ref);\n-\t\t  if (varpool_node_in_set_p (v, vset))\n-\t\t    continue;\n-\n-\t\t  /* Constant pool references use internal labels and thus\n-\t\t     cannot be made global.  It is sensible to keep those\n-\t\t     ltrans local to allow better optimization.  */\n-\t\t  if (DECL_IN_CONSTANT_POOL (v->decl))\n-\t\t    {\n-\t\t      if (!pointer_set_insert (inserted, vnode))\n-\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n-\t\t\t\t       promoted_initializers, v);\n-\t\t    }\n-\t\t  else if (!v->externally_visible && v->analyzed)\n-\t\t    {\n-\t\t      if (promote_var (v)\n-\t\t\t  && DECL_INITIAL (v->decl)\n-\t\t\t  && const_value_known_p (v->decl)\n-\t\t\t  && !pointer_set_insert (inserted, vnode))\n-\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n-\t\t\t\t       promoted_initializers, v);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  pointer_set_destroy (inserted);\n-}\n-\n static lto_file *current_lto_file;\n \n /* Helper for qsort; compare partitions and return one with smaller size."}]}