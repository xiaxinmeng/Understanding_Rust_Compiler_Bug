{"sha": "c517cf2e685e2903b591d63c1034ff9726cb3822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUxN2NmMmU2ODVlMjkwM2I1OTFkNjNjMTAzNGZmOTcyNmNiMzgyMg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-08-13T15:22:35Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-08-16T11:37:49Z"}, "message": "Speed up jump table switch detection.\n\n\tPR tree-optimization/100393\n\ngcc/ChangeLog:\n\n\t* tree-switch-conversion.c (group_cluster::dump): Use\n\t  get_comparison_count.\n\t(jump_table_cluster::find_jump_tables): Pre-compute number of\n\tcomparisons and then decrement it. Cache also max_ratio.\n\t(jump_table_cluster::can_be_handled): Change signature.\n\t* tree-switch-conversion.h (get_comparison_count): New.", "tree": {"sha": "723f4bb29ab6783546386005b2b17a3a1f51907c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/723f4bb29ab6783546386005b2b17a3a1f51907c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c517cf2e685e2903b591d63c1034ff9726cb3822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c517cf2e685e2903b591d63c1034ff9726cb3822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c517cf2e685e2903b591d63c1034ff9726cb3822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c517cf2e685e2903b591d63c1034ff9726cb3822/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29020d0527512ae0444ad32b1461b7f8526e7427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29020d0527512ae0444ad32b1461b7f8526e7427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29020d0527512ae0444ad32b1461b7f8526e7427"}], "stats": {"total": 56, "additions": 35, "deletions": 21}, "files": [{"sha": "244cf4be010c638b79ef732982774a31fd9809a7", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c517cf2e685e2903b591d63c1034ff9726cb3822/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c517cf2e685e2903b591d63c1034ff9726cb3822/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=c517cf2e685e2903b591d63c1034ff9726cb3822", "patch": "@@ -1091,7 +1091,7 @@ group_cluster::dump (FILE *f, bool details)\n   for (unsigned i = 0; i < m_cases.length (); i++)\n     {\n       simple_cluster *sc = static_cast<simple_cluster *> (m_cases[i]);\n-      comparison_count += sc->m_range_p ? 2 : 1;\n+      comparison_count += sc->get_comparison_count ();\n     }\n \n   unsigned HOST_WIDE_INT range = get_range (get_low (), get_high ());\n@@ -1186,11 +1186,24 @@ jump_table_cluster::find_jump_tables (vec<cluster *> &clusters)\n \n   min.quick_push (min_cluster_item (0, 0, 0));\n \n+  unsigned HOST_WIDE_INT max_ratio\n+    = (optimize_insn_for_size_p ()\n+       ? param_jump_table_max_growth_ratio_for_size\n+       : param_jump_table_max_growth_ratio_for_speed);\n+\n   for (unsigned i = 1; i <= l; i++)\n     {\n       /* Set minimal # of clusters with i-th item to infinite.  */\n       min.quick_push (min_cluster_item (INT_MAX, INT_MAX, INT_MAX));\n \n+      /* Pre-calculate number of comparisons for the clusters.  */\n+      HOST_WIDE_INT comparison_count = 0;\n+      for (unsigned k = 0; k <= i - 1; k++)\n+\t{\n+\t  simple_cluster *sc = static_cast<simple_cluster *> (clusters[k]);\n+\t  comparison_count += sc->get_comparison_count ();\n+\t}\n+\n       for (unsigned j = 0; j < i; j++)\n \t{\n \t  unsigned HOST_WIDE_INT s = min[j].m_non_jt_cases;\n@@ -1201,10 +1214,15 @@ jump_table_cluster::find_jump_tables (vec<cluster *> &clusters)\n \t  if ((min[j].m_count + 1 < min[i].m_count\n \t       || (min[j].m_count + 1 == min[i].m_count\n \t\t   && s < min[i].m_non_jt_cases))\n-\t      && can_be_handled (clusters, j, i - 1))\n+\t      && can_be_handled (clusters, j, i - 1, max_ratio,\n+\t\t\t\t comparison_count))\n \t    min[i] = min_cluster_item (min[j].m_count + 1, j, s);\n+\n+\t  simple_cluster *sc = static_cast<simple_cluster *> (clusters[j]);\n+\t  comparison_count -= sc->get_comparison_count ();\n \t}\n \n+      gcc_checking_assert (comparison_count == 0);\n       gcc_checking_assert (min[i].m_count != INT_MAX);\n     }\n \n@@ -1242,7 +1260,9 @@ jump_table_cluster::find_jump_tables (vec<cluster *> &clusters)\n \n bool\n jump_table_cluster::can_be_handled (const vec<cluster *> &clusters,\n-\t\t\t\t    unsigned start, unsigned end)\n+\t\t\t\t    unsigned start, unsigned end,\n+\t\t\t\t    unsigned HOST_WIDE_INT max_ratio,\n+\t\t\t\t    unsigned HOST_WIDE_INT comparison_count)\n {\n   /* If the switch is relatively small such that the cost of one\n      indirect jump on the target are higher than the cost of a\n@@ -1261,10 +1281,6 @@ jump_table_cluster::can_be_handled (const vec<cluster *> &clusters,\n   if (start == end)\n     return true;\n \n-  unsigned HOST_WIDE_INT max_ratio\n-    = (optimize_insn_for_size_p ()\n-       ? param_jump_table_max_growth_ratio_for_size\n-       : param_jump_table_max_growth_ratio_for_speed);\n   unsigned HOST_WIDE_INT range = get_range (clusters[start]->get_low (),\n \t\t\t\t\t    clusters[end]->get_high ());\n   /* Check overflow.  */\n@@ -1278,18 +1294,6 @@ jump_table_cluster::can_be_handled (const vec<cluster *> &clusters,\n   if (lhs < range)\n     return false;\n \n-  /* First make quick guess as each cluster\n-     can add at maximum 2 to the comparison_count.  */\n-  if (lhs > 2 * max_ratio * (end - start + 1))\n-    return false;\n-\n-  unsigned HOST_WIDE_INT comparison_count = 0;\n-  for (unsigned i = start; i <= end; i++)\n-    {\n-      simple_cluster *sc = static_cast<simple_cluster *> (clusters[i]);\n-      comparison_count += sc->m_range_p ? 2 : 1;\n-    }\n-\n   return lhs <= max_ratio * comparison_count;\n }\n "}, {"sha": "a375e52636e29a6299b5e5ff92a4904712e80f31", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c517cf2e685e2903b591d63c1034ff9726cb3822/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c517cf2e685e2903b591d63c1034ff9726cb3822/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=c517cf2e685e2903b591d63c1034ff9726cb3822", "patch": "@@ -180,6 +180,13 @@ class simple_cluster: public cluster\n     return tree_int_cst_equal (get_low (), get_high ());\n   }\n \n+  /* Return number of comparisons needed for the case.  */\n+  unsigned\n+  get_comparison_count ()\n+  {\n+    return m_range_p ? 2 : 1;\n+  }\n+\n   /* Low value of the case.  */\n   tree m_low;\n \n@@ -267,9 +274,12 @@ class jump_table_cluster: public group_cluster\n   static vec<cluster *> find_jump_tables (vec<cluster *> &clusters);\n \n   /* Return true when cluster starting at START and ending at END (inclusive)\n-     can build a jump-table.  */\n+     can build a jump-table.  COMPARISON_COUNT is number of comparison\n+     operations needed if the clusters are expanded as decision tree.\n+     MAX_RATIO tells about the maximum code growth (in percent).  */\n   static bool can_be_handled (const vec<cluster *> &clusters, unsigned start,\n-\t\t\t      unsigned end);\n+\t\t\t      unsigned end, unsigned HOST_WIDE_INT max_ratio,\n+\t\t\t      unsigned HOST_WIDE_INT comparison_count);\n \n   /* Return true if cluster starting at START and ending at END (inclusive)\n      is profitable transformation.  */"}]}