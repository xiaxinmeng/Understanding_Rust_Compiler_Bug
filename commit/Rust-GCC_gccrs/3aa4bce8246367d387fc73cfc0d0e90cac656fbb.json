{"sha": "3aa4bce8246367d387fc73cfc0d0e90cac656fbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FhNGJjZTgyNDYzNjdkMzg3ZmM3M2NmYzBkMGU5MGNhYzY1NmZiYg==", "commit": {"author": {"name": "Nala Ginrut", "email": "mulei@gnu.org", "date": "2021-02-26T10:38:36Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-01T10:36:42Z"}, "message": "Fix to parse inner attribute correctly", "tree": {"sha": "c736bd67f30e99fa1ec6ec505920c0a1bd9d4b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c736bd67f30e99fa1ec6ec505920c0a1bd9d4b81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aa4bce8246367d387fc73cfc0d0e90cac656fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa4bce8246367d387fc73cfc0d0e90cac656fbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aa4bce8246367d387fc73cfc0d0e90cac656fbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa4bce8246367d387fc73cfc0d0e90cac656fbb/comments", "author": {"login": "NalaGinrut", "id": 19734, "node_id": "MDQ6VXNlcjE5NzM0", "avatar_url": "https://avatars.githubusercontent.com/u/19734?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NalaGinrut", "html_url": "https://github.com/NalaGinrut", "followers_url": "https://api.github.com/users/NalaGinrut/followers", "following_url": "https://api.github.com/users/NalaGinrut/following{/other_user}", "gists_url": "https://api.github.com/users/NalaGinrut/gists{/gist_id}", "starred_url": "https://api.github.com/users/NalaGinrut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NalaGinrut/subscriptions", "organizations_url": "https://api.github.com/users/NalaGinrut/orgs", "repos_url": "https://api.github.com/users/NalaGinrut/repos", "events_url": "https://api.github.com/users/NalaGinrut/events{/privacy}", "received_events_url": "https://api.github.com/users/NalaGinrut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c6eaa19077eebebf661fe1d633d03ecdc03cbb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c6eaa19077eebebf661fe1d633d03ecdc03cbb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c6eaa19077eebebf661fe1d633d03ecdc03cbb2"}], "stats": {"total": 162, "additions": 87, "deletions": 75}, "files": [{"sha": "9ae1a7d7b74efd8f45e8b055f821bb78e0087eea", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 87, "deletions": 75, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa4bce8246367d387fc73cfc0d0e90cac656fbb/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa4bce8246367d387fc73cfc0d0e90cac656fbb/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=3aa4bce8246367d387fc73cfc0d0e90cac656fbb", "patch": "@@ -206,11 +206,11 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n       return true;\n       case RIGHT_SHIFT: {\n #if 0\n-\t/* shit. preferred HACK would be to replace this token in stream with\n-\t * '>', but may not be possible at this point. */\n-\t// FIXME: ensure locations aren't messed up\n-\tTokenPtr right_angle = Token::make (RIGHT_ANGLE, tok->get_locus () + 1);\n-\tlexer.replace_current_token (right_angle);\n+        /* shit. preferred HACK would be to replace this token in stream with\n+         * '>', but may not be possible at this point. */\n+        // FIXME: ensure locations aren't messed up\n+        TokenPtr right_angle = Token::make (RIGHT_ANGLE, tok->get_locus () + 1);\n+        lexer.replace_current_token (right_angle);\n #endif\n \n \t// new implementation that should be better\n@@ -220,13 +220,13 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n       }\n       case GREATER_OR_EQUAL: {\n #if 0\n-\t// another HACK - replace with equal (as assignment intended, probably)\n-\t/* FIXME: is this even required? how many people wouldn't leave a space?\n-\t * - apparently rustc has this feature */\n-\t// FIXME: ensure locations aren't messed up\n-\tTokenPtr equal = Token::make (EQUAL, tok->get_locus () + 1);\n-\tlexer.replace_current_token (equal);\n-\treturn true;\n+        // another HACK - replace with equal (as assignment intended, probably)\n+        /* FIXME: is this even required? how many people wouldn't leave a space?\n+         * - apparently rustc has this feature */\n+        // FIXME: ensure locations aren't messed up\n+        TokenPtr equal = Token::make (EQUAL, tok->get_locus () + 1);\n+        lexer.replace_current_token (equal);\n+        return true;\n #endif\n \n \t// new implementation that should be better\n@@ -236,13 +236,13 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n       }\n       case RIGHT_SHIFT_EQ: {\n #if 0\n-\t// another HACK - replace with greater or equal\n-\t// FIXME: again, is this really required? rustc has the feature, though\n-\t// FIXME: ensure locations aren't messed up\n-\tTokenPtr greater_equal\n-\t  = Token::make (GREATER_OR_EQUAL, tok->get_locus () + 1);\n-\tlexer.replace_current_token (greater_equal);\n-\treturn true;\n+        // another HACK - replace with greater or equal\n+        // FIXME: again, is this really required? rustc has the feature, though\n+        // FIXME: ensure locations aren't messed up\n+        TokenPtr greater_equal\n+          = Token::make (GREATER_OR_EQUAL, tok->get_locus () + 1);\n+        lexer.replace_current_token (greater_equal);\n+        return true;\n #endif\n \n \t// new implementation that should be better\n@@ -490,25 +490,37 @@ AST::Attribute\n Parser<ManagedTokenSource>::parse_inner_attribute ()\n {\n   if (lexer.peek_token ()->get_id () != HASH)\n-    return AST::Attribute::create_empty ();\n-\n+    {\n+      rust_error_at (\n+\tlexer.peek_token ()->get_locus (),\n+\t\"BUG: token %<#%> is missing, but parse_inner_attribute was invoked.\");\n+      return AST::Attribute::create_empty ();\n+    }\n   lexer.skip_token ();\n \n   if (lexer.peek_token ()->get_id () != EXCLAM)\n-    return AST::Attribute::create_empty ();\n-\n+    {\n+      rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t     \"Expect one of `!' or `['\");\n+      return AST::Attribute::create_empty ();\n+    }\n   lexer.skip_token ();\n \n   if (lexer.peek_token ()->get_id () != LEFT_SQUARE)\n-    return AST::Attribute::create_empty ();\n-\n+    {\n+      rust_error_at (lexer.peek_token ()->get_locus (), \"Expect `['\");\n+      return AST::Attribute::create_empty ();\n+    }\n   lexer.skip_token ();\n \n   AST::Attribute actual_attribute = parse_attribute_body ();\n+  lexer.skip_token ();\n \n   if (lexer.peek_token ()->get_id () != RIGHT_SQUARE)\n-    return AST::Attribute::create_empty ();\n-\n+    {\n+      rust_error_at (lexer.peek_token ()->get_locus (), \"Expect `]'\");\n+      return AST::Attribute::create_empty ();\n+    }\n   lexer.skip_token ();\n \n   return actual_attribute;\n@@ -8247,55 +8259,55 @@ Parser<ManagedTokenSource>::parse_match_expr (\n #if 0\n       // branch on next token - if '{', block expr, otherwise just expr\n       if (lexer.peek_token ()->get_id () == LEFT_CURLY)\n-\t{\n-\t  // block expr\n-\t  std::unique_ptr<AST::BlockExpr> block_expr = parse_block_expr ();\n-\t  if (block_expr == nullptr)\n-\t    {\n-\t      rust_error_at (\n-\t\tlexer.peek_token ()->get_locus (),\n-\t\t\"failed to parse block expr in match arm in match expr\");\n-\t      // skip somewhere\n-\t      return nullptr;\n-\t    }\n-\n-\t  // create match case block expr and add to cases\n-\t  std::unique_ptr<AST::MatchCaseBlockExpr> match_case_block (\n-\t    new AST::MatchCaseBlockExpr (std::move (arm),\n-\t\t\t\t\t std::move (block_expr)));\n-\t  match_arms.push_back (std::move (match_case_block));\n-\n-\t  // skip optional comma\n-\t  if (lexer.peek_token ()->get_id () == COMMA)\n-\t    {\n-\t      lexer.skip_token ();\n-\t    }\n-\t}\n+        {\n+          // block expr\n+          std::unique_ptr<AST::BlockExpr> block_expr = parse_block_expr ();\n+          if (block_expr == nullptr)\n+            {\n+              rust_error_at (\n+                lexer.peek_token ()->get_locus (),\n+                \"failed to parse block expr in match arm in match expr\");\n+              // skip somewhere\n+              return nullptr;\n+            }\n+\n+          // create match case block expr and add to cases\n+          std::unique_ptr<AST::MatchCaseBlockExpr> match_case_block (\n+            new AST::MatchCaseBlockExpr (std::move (arm),\n+                                         std::move (block_expr)));\n+          match_arms.push_back (std::move (match_case_block));\n+\n+          // skip optional comma\n+          if (lexer.peek_token ()->get_id () == COMMA)\n+            {\n+              lexer.skip_token ();\n+            }\n+        }\n       else\n-\t{\n-\t  // regular expr\n-\t  std::unique_ptr<AST::Expr> expr = parse_expr ();\n-\t  if (expr == nullptr)\n-\t    {\n-\t      rust_error_at (lexer.peek_token ()->get_locus (),\n-\t\t\t     \"failed to parse expr in match arm in match expr\");\n-\t      // skip somewhere?\n-\t      return nullptr;\n-\t    }\n-\n-\t  // construct match case expr and add to cases\n-\t  std::unique_ptr<AST::MatchCaseExpr> match_case_expr (\n-\t    new AST::MatchCaseExpr (std::move (arm), std::move (expr)));\n-\t  match_arms.push_back (std::move (match_case_expr));\n-\n-\t  // skip REQUIRED comma - if no comma, break\n-\t  if (lexer.peek_token ()->get_id () != COMMA)\n-\t    {\n-\t      // if no comma, must be end of cases\n-\t      break;\n-\t    }\n-\t  lexer.skip_token ();\n-\t}\n+        {\n+          // regular expr\n+          std::unique_ptr<AST::Expr> expr = parse_expr ();\n+          if (expr == nullptr)\n+            {\n+              rust_error_at (lexer.peek_token ()->get_locus (),\n+                             \"failed to parse expr in match arm in match expr\");\n+              // skip somewhere?\n+              return nullptr;\n+            }\n+\n+          // construct match case expr and add to cases\n+          std::unique_ptr<AST::MatchCaseExpr> match_case_expr (\n+            new AST::MatchCaseExpr (std::move (arm), std::move (expr)));\n+          match_arms.push_back (std::move (match_case_expr));\n+\n+          // skip REQUIRED comma - if no comma, break\n+          if (lexer.peek_token ()->get_id () != COMMA)\n+            {\n+              // if no comma, must be end of cases\n+              break;\n+            }\n+          lexer.skip_token ();\n+        }\n #endif\n     }\n "}]}