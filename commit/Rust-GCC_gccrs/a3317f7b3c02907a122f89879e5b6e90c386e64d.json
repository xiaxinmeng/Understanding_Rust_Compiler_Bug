{"sha": "a3317f7b3c02907a122f89879e5b6e90c386e64d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMzMTdmN2IzYzAyOTA3YTEyMmY4OTg3OWU1YjZlOTBjMzg2ZTY0ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-15T10:37:38Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-15T10:37:38Z"}, "message": "c: Don't drop vector attributes that affect type identity [PR98852]\n\n<arm_neon.h> types are distinct from GNU vector types in at least\ntheir mangling.  However, there used to be nothing explicit in the\nVECTOR_TYPE itself to indicate the difference: we simply treated them\nas distinct TYPE_MAIN_VARIANTs.  This caused problems like the ones\nreported in PR95726.\n\nThe fix for that PR was to add type attributes to the <arm_neon.h>\ntypes, in order to maintain the distinction between them and GNU\nvectors.  However, this in turn caused PR98852, where c_common_type\nwould unconditionally drop the attributes on the source types.\nThis meant that:\n\n   <arm_neon.h> vector + <arm_neon.h> vector\n\nhad a GNU vector type rather than an <arm_neon.h> vector type.\n\nSee https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96377#c2 for\nJakub's analysis of the history of this c_common_type code.\nTBH I'm not sure which case the build_type_attribute_variant\ncode is handling, but I think we should at least avoid dropping\nattributes that affect type identity.\n\nI've tried to audit the C and target-specific attributes to look\nfor other types that might be affected by this, but I couldn't\nsee any.  We are only dealing with:\n\n  gcc_assert (code1 == VECTOR_TYPE || code1 == COMPLEX_TYPE\n\t      || code1 == FIXED_POINT_TYPE || code1 == REAL_TYPE\n\t      || code1 == INTEGER_TYPE);\n\nwhich excludes most affects_type_identity attributes.  The closest\nwas s390_vector_bool, but the handler for that attribute changes\nthe type node and drops the attribute itself (*no_add_attrs = true).\n\nI put the main list handling into a separate function\n(remove_attributes_matching) because a later patch will need it\nfor something else.\n\ngcc/\n\tPR c/98852\n\t* attribs.h (affects_type_identity_attributes): Declare.\n\t* attribs.c (remove_attributes_matching): New function.\n\t(affects_type_identity_attributes): Likewise.\n\ngcc/c/\n\tPR c/98852\n\t* c-typeck.c (c_common_type): Do not drop attributes that\n\taffect type identity.\n\ngcc/testsuite/\n\tPR c/98852\n\t* gcc.target/aarch64/advsimd-intrinsics/pr98852.c: New test.", "tree": {"sha": "ff690fd76bbd0d8470dc70e22180cb4bcef03ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff690fd76bbd0d8470dc70e22180cb4bcef03ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3317f7b3c02907a122f89879e5b6e90c386e64d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3317f7b3c02907a122f89879e5b6e90c386e64d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3317f7b3c02907a122f89879e5b6e90c386e64d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3317f7b3c02907a122f89879e5b6e90c386e64d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5f644a98b3f3543d3a8d2dfea7785c22879013f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f644a98b3f3543d3a8d2dfea7785c22879013f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f644a98b3f3543d3a8d2dfea7785c22879013f"}], "stats": {"total": 195, "additions": 193, "deletions": 2}, "files": [{"sha": "2fb29541f3fd4879e4849e77afd71fdefdde9a40", "filename": "gcc/attribs.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=a3317f7b3c02907a122f89879e5b6e90c386e64d", "patch": "@@ -1366,6 +1366,60 @@ comp_type_attributes (const_tree type1, const_tree type2)\n   return targetm.comp_type_attributes (type1, type2);\n }\n \n+/* PREDICATE acts as a function of type:\n+\n+     (const_tree attr, const attribute_spec *as) -> bool\n+\n+   where ATTR is an attribute and AS is its possibly-null specification.\n+   Return a list of every attribute in attribute list ATTRS for which\n+   PREDICATE is true.  Return ATTRS itself if PREDICATE returns true\n+   for every attribute.  */\n+\n+template<typename Predicate>\n+tree\n+remove_attributes_matching (tree attrs, Predicate predicate)\n+{\n+  tree new_attrs = NULL_TREE;\n+  tree *ptr = &new_attrs;\n+  const_tree start = attrs;\n+  for (const_tree attr = attrs; attr; attr = TREE_CHAIN (attr))\n+    {\n+      tree name = get_attribute_name (attr);\n+      const attribute_spec *as = lookup_attribute_spec (name);\n+      const_tree end;\n+      if (!predicate (attr, as))\n+\tend = attr;\n+      else if (start == attrs)\n+\tcontinue;\n+      else\n+\tend = TREE_CHAIN (attr);\n+\n+      for (; start != end; start = TREE_CHAIN (start))\n+\t{\n+\t  *ptr = tree_cons (TREE_PURPOSE (start),\n+\t\t\t    TREE_VALUE (start), NULL_TREE);\n+\t  TREE_CHAIN (*ptr) = NULL_TREE;\n+\t  ptr = &TREE_CHAIN (*ptr);\n+\t}\n+      start = TREE_CHAIN (attr);\n+    }\n+  gcc_assert (!start || start == attrs);\n+  return start ? attrs : new_attrs;\n+}\n+\n+/* If VALUE is true, return the subset of ATTRS that affect type identity,\n+   otherwise return the subset of ATTRS that don't affect type identity.  */\n+\n+tree\n+affects_type_identity_attributes (tree attrs, bool value)\n+{\n+  auto predicate = [value](const_tree, const attribute_spec *as) -> bool\n+    {\n+      return bool (as && as->affects_type_identity) == value;\n+    };\n+  return remove_attributes_matching (attrs, predicate);\n+}\n+\n /* Return a type like TTYPE except that its TYPE_ATTRIBUTE\n    is ATTRIBUTE.\n "}, {"sha": "eadb1d0fac94308984d9858f043f2fdab7d4b8fa", "filename": "gcc/attribs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=a3317f7b3c02907a122f89879e5b6e90c386e64d", "patch": "@@ -65,6 +65,8 @@ extern bool attribute_value_equal (const_tree, const_tree);\n    warning to be generated).  */\n extern int comp_type_attributes (const_tree, const_tree);\n \n+extern tree affects_type_identity_attributes (tree, bool = true);\n+\n /* Default versions of target-overridable functions.  */\n extern tree merge_decl_attributes (tree, tree);\n extern tree merge_type_attributes (tree, tree);"}, {"sha": "51a62c800f79035c4c63c11751a4c7c12a9fa04b", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=a3317f7b3c02907a122f89879e5b6e90c386e64d", "patch": "@@ -740,10 +740,16 @@ c_common_type (tree t1, tree t2)\n     t2 = TYPE_MAIN_VARIANT (t2);\n \n   if (TYPE_ATTRIBUTES (t1) != NULL_TREE)\n-    t1 = build_type_attribute_variant (t1, NULL_TREE);\n+    {\n+      tree attrs = affects_type_identity_attributes (TYPE_ATTRIBUTES (t1));\n+      t1 = build_type_attribute_variant (t1, attrs);\n+    }\n \n   if (TYPE_ATTRIBUTES (t2) != NULL_TREE)\n-    t2 = build_type_attribute_variant (t2, NULL_TREE);\n+    {\n+      tree attrs = affects_type_identity_attributes (TYPE_ATTRIBUTES (t2));\n+      t2 = build_type_attribute_variant (t2, attrs);\n+    }\n \n   /* Save time if the two types are the same.  */\n "}, {"sha": "31e51b0d89376f684b0e8fb82ef011ffc4d42006", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/pr98852.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fpr98852.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3317f7b3c02907a122f89879e5b6e90c386e64d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fpr98852.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fpr98852.c?ref=a3317f7b3c02907a122f89879e5b6e90c386e64d", "patch": "@@ -0,0 +1,129 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99\" } */\n+\n+#include <arm_neon.h>\n+\n+typedef __typeof(((int32x4_t *) 0)[0][0]) int32_elt;\n+typedef __typeof(((uint32x4_t *) 0)[0][0]) uint32_elt;\n+\n+typedef int32_elt gnu_int32x4_t __attribute__((vector_size(16)));\n+typedef uint32_elt gnu_uint32x4_t __attribute__((vector_size(16)));\n+\n+#define X_gnu_int32x4_t 1\n+#define X_gnu_uint32x4_t 2\n+#define X_int32x4_t 3\n+#define X_uint32x4_t 4\n+\n+#define CHECK(T) T: X_##T\n+\n+#define CHECK_TYPE(EXPR, TYPE) \\\n+  do { \\\n+    int x[_Generic (EXPR, \\\n+\t\t    CHECK (gnu_int32x4_t), \\\n+\t\t    CHECK (gnu_uint32x4_t), \\\n+\t\t    CHECK (int32x4_t), \\\n+\t\t    CHECK (uint32x4_t), \\\n+\t\t    default : 0) == X_##TYPE ? 1 : -1]; \\\n+  } while (0)\n+\n+void\n+f (gnu_int32x4_t sg, gnu_uint32x4_t ug, int32x4_t sn, uint32x4_t un, int c)\n+{\n+  CHECK_TYPE (sg, gnu_int32x4_t);\n+  CHECK_TYPE (ug, gnu_uint32x4_t);\n+  CHECK_TYPE (sn, int32x4_t);\n+  CHECK_TYPE (un, uint32x4_t);\n+\n+  CHECK_TYPE (sg + 1, gnu_int32x4_t);\n+  CHECK_TYPE (ug + 1, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + 1, int32x4_t);\n+  CHECK_TYPE (un + 1, uint32x4_t);\n+\n+  CHECK_TYPE (1 + sg, gnu_int32x4_t);\n+  CHECK_TYPE (1 + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (1 + sn, int32x4_t);\n+  CHECK_TYPE (1 + un, uint32x4_t);\n+\n+  CHECK_TYPE (sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + sn, int32x4_t);\n+  CHECK_TYPE (un + un, uint32x4_t);\n+\n+  /* Traditional behavior for mixed signs is to pick the signedness of the\n+     first operand.  We don't have any Arm-specific reason for preferring that\n+     behavior, but including the tests helps to demonstrate the points in the\n+     comments below.  */\n+  CHECK_TYPE (sg + ug, gnu_int32x4_t);\n+  CHECK_TYPE (ug + sg, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + un, int32x4_t);\n+  CHECK_TYPE (un + sn, uint32x4_t);\n+\n+  /* Nothing specifies the type of mixed GNU and arm_neon.h operations, but:\n+\n+     - it would be surprising if sg + un had a different signedness from\n+       sg + ug\n+\n+     - it would also be mildly surprising if sg + un had a different type from\n+       both of its operands\n+\n+     So in cases where the operands differ in both signedness and ABI, it seems\n+     more consistent to ignore the ABI difference and apply the usual rules for\n+     differences in sign.  */\n+  CHECK_TYPE (sg + un, gnu_int32x4_t);\n+  CHECK_TYPE (ug + sn, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + ug, int32x4_t);\n+  CHECK_TYPE (un + sg, uint32x4_t);\n+\n+  /* And if the first vector wins when operands differ in both signedness\n+     and ABI, it seems more consistent to do the same if the operands differ\n+     only in ABI.  */\n+  CHECK_TYPE (sg + sn, gnu_int32x4_t);\n+  CHECK_TYPE (ug + un, gnu_uint32x4_t);\n+  CHECK_TYPE (sn + sg, int32x4_t);\n+  CHECK_TYPE (un + ug, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + sg : sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + ug : ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + sn : sn, int32x4_t);\n+  CHECK_TYPE (c ? un + un : un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + 1 : sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + 1 : ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + 1 : sn, int32x4_t);\n+  CHECK_TYPE (c ? un + 1 : un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? 1 + sg : sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? 1 + ug : ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? 1 + sn : sn, int32x4_t);\n+  CHECK_TYPE (c ? 1 + un : un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg : sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug : ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn : sn + sn, int32x4_t);\n+  CHECK_TYPE (c ? un : un + un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg : sg + 1, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug : ug + 1, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn : sn + 1, int32x4_t);\n+  CHECK_TYPE (c ? un : un + 1, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg : 1 + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug : 1 + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn : 1 + sn, int32x4_t);\n+  CHECK_TYPE (c ? un : 1 + un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + sg : sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + ug : ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + sn : sn + sn, int32x4_t);\n+  CHECK_TYPE (c ? un + un : un + un, uint32x4_t);\n+\n+  CHECK_TYPE (c ? sg + sg : sg + 1, gnu_int32x4_t);\n+  CHECK_TYPE (c ? ug + ug : ug + 1, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? sn + sn : sn + 1, int32x4_t);\n+  CHECK_TYPE (c ? un + un : un + 1, uint32x4_t);\n+\n+  CHECK_TYPE (c ? 1 + sg : sg + sg, gnu_int32x4_t);\n+  CHECK_TYPE (c ? 1 + ug : ug + ug, gnu_uint32x4_t);\n+  CHECK_TYPE (c ? 1 + sn : sn + sn, int32x4_t);\n+  CHECK_TYPE (c ? 1 + un : un + un, uint32x4_t);\n+}"}]}