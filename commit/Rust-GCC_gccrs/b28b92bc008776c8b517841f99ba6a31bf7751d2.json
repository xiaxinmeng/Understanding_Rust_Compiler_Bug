{"sha": "b28b92bc008776c8b517841f99ba6a31bf7751d2", "node_id": "C_kwDOANBUbNoAKGIyOGI5MmJjMDA4Nzc2YzhiNTE3ODQxZjk5YmE2YTMxYmY3NzUxZDI", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2022-02-03T02:55:36Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2022-02-04T19:43:23Z"}, "message": "rs6000: More factoring of overload processing\n\nThis patch continues the refactoring started with r12-6014.  I had previously\nnoted that the resolve_vec* routines can be further simplified by processing\nthe argument list earlier, so that all routines can use the arrays of arguments\nand types.  I found that this was useful for some of the routines, but not for\nall of them.\n\nFor several of the special-cased overloads, we don't specify all of the\npossible type combinations in rs6000-overload.def, because the types don't\nmatter for the expansion we do.  For these, we can't use generic error message\nhandling when the number of arguments is incorrect, because the result is\nmisleading error messages that indicate argument types are wrong.\n\nSo this patch goes halfway and improves the factoring on the remaining special\ncases, but leaves vec_splats, vec_promote, vec_extract, vec_insert, and\nvec_step alone.\n\n2022-02-02  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-c.cc (resolve_vec_mul): Accept args and types\n\tparameters instead of arglist and nargs.  Simplify accordingly.  Remove\n\tunnecessary test for argument count mismatch.\n\t(resolve_vec_cmpne): Likewise.\n\t(resolve_vec_adde_sube): Likewise.\n\t(resolve_vec_addec_subec): Likewise.\n\t(altivec_resolve_overloaded_builtin): Move overload special handling\n\tafter the gathering of arguments into args[] and types[] and the test\n\tfor correct number of arguments.  Don't perform the test for correct\n\tnumber of arguments for certain special cases.  Call the other special\n\tcases with args and types instead of arglist and nargs.", "tree": {"sha": "13c9053575d9ca8a283d68f737a2e575a16c6b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13c9053575d9ca8a283d68f737a2e575a16c6b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b28b92bc008776c8b517841f99ba6a31bf7751d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28b92bc008776c8b517841f99ba6a31bf7751d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b28b92bc008776c8b517841f99ba6a31bf7751d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28b92bc008776c8b517841f99ba6a31bf7751d2/comments", "author": null, "committer": null, "parents": [{"sha": "8cb748a31cd8c7ac9c88b6abc38ce077dd462a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cb748a31cd8c7ac9c88b6abc38ce077dd462a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cb748a31cd8c7ac9c88b6abc38ce077dd462a7a"}], "stats": {"total": 304, "additions": 127, "deletions": 177}, "files": [{"sha": "15251efc20955f63ee33f5030b5a71f09a3cfff3", "filename": "gcc/config/rs6000/rs6000-c.cc", "status": "modified", "additions": 127, "deletions": 177, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28b92bc008776c8b517841f99ba6a31bf7751d2/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28b92bc008776c8b517841f99ba6a31bf7751d2/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc?ref=b28b92bc008776c8b517841f99ba6a31bf7751d2", "patch": "@@ -939,37 +939,25 @@ altivec_build_resolved_builtin (tree *args, int n, tree fntype, tree ret_type,\n enum resolution { unresolved, resolved, resolved_bad };\n \n /* Resolve an overloaded vec_mul call and return a tree expression for the\n-   resolved call if successful.  NARGS is the number of arguments to the call.\n-   ARGLIST contains the arguments.  RES must be set to indicate the status of\n+   resolved call if successful.  ARGS contains the arguments to the call.\n+   TYPES contains their types.  RES must be set to indicate the status of\n    the resolution attempt.  LOC contains statement location information.  */\n \n static tree\n-resolve_vec_mul (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n-\t\t location_t loc)\n+resolve_vec_mul (resolution *res, tree *args, tree *types, location_t loc)\n {\n   /* vec_mul needs to be special cased because there are no instructions for it\n      for the {un}signed char, {un}signed short, and {un}signed int types.  */\n-  if (nargs != 2)\n-    {\n-      error (\"builtin %qs only accepts 2 arguments\", \"vec_mul\");\n-      *res = resolved;\n-      return error_mark_node;\n-    }\n-\n-  tree arg0 = (*arglist)[0];\n-  tree arg0_type = TREE_TYPE (arg0);\n-  tree arg1 = (*arglist)[1];\n-  tree arg1_type = TREE_TYPE (arg1);\n \n   /* Both arguments must be vectors and the types must be compatible.  */\n-  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n-      || !lang_hooks.types_compatible_p (arg0_type, arg1_type))\n+  if (TREE_CODE (types[0]) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (types[0], types[1]))\n     {\n       *res = resolved_bad;\n       return error_mark_node;\n     }\n \n-  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+  switch (TYPE_MODE (TREE_TYPE (types[0])))\n     {\n     case E_QImode:\n     case E_HImode:\n@@ -978,21 +966,21 @@ resolve_vec_mul (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n     case E_TImode:\n       /* For scalar types just use a multiply expression.  */\n       *res = resolved;\n-      return fold_build2_loc (loc, MULT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t      fold_convert (TREE_TYPE (arg0), arg1));\n+      return fold_build2_loc (loc, MULT_EXPR, types[0], args[0],\n+\t\t\t      fold_convert (types[0], args[1]));\n     case E_SFmode:\n       {\n \t/* For floats use the xvmulsp instruction directly.  */\n \t*res = resolved;\n \ttree call = rs6000_builtin_decls[RS6000_BIF_XVMULSP];\n-\treturn build_call_expr (call, 2, arg0, arg1);\n+\treturn build_call_expr (call, 2, args[0], args[1]);\n       }\n     case E_DFmode:\n       {\n \t/* For doubles use the xvmuldp instruction directly.  */\n \t*res = resolved;\n \ttree call = rs6000_builtin_decls[RS6000_BIF_XVMULDP];\n-\treturn build_call_expr (call, 2, arg0, arg1);\n+\treturn build_call_expr (call, 2, args[0], args[1]);\n       }\n     /* Other types are errors.  */\n     default:\n@@ -1002,37 +990,25 @@ resolve_vec_mul (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n }\n \n /* Resolve an overloaded vec_cmpne call and return a tree expression for the\n-   resolved call if successful.  NARGS is the number of arguments to the call.\n-   ARGLIST contains the arguments.  RES must be set to indicate the status of\n+   resolved call if successful.  ARGS contains the arguments to the call.\n+   TYPES contains their types.  RES must be set to indicate the status of\n    the resolution attempt.  LOC contains statement location information.  */\n \n static tree\n-resolve_vec_cmpne (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n-\t\t   location_t loc)\n+resolve_vec_cmpne (resolution *res, tree *args, tree *types, location_t loc)\n {\n   /* vec_cmpne needs to be special cased because there are no instructions\n      for it (prior to power 9).  */\n-  if (nargs != 2)\n-    {\n-      error (\"builtin %qs only accepts 2 arguments\", \"vec_cmpne\");\n-      *res = resolved;\n-      return error_mark_node;\n-    }\n-\n-  tree arg0 = (*arglist)[0];\n-  tree arg0_type = TREE_TYPE (arg0);\n-  tree arg1 = (*arglist)[1];\n-  tree arg1_type = TREE_TYPE (arg1);\n \n   /* Both arguments must be vectors and the types must be compatible.  */\n-  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n-      || !lang_hooks.types_compatible_p (arg0_type, arg1_type))\n+  if (TREE_CODE (types[0]) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (types[0], types[1]))\n     {\n       *res = resolved_bad;\n       return error_mark_node;\n     }\n \n-  machine_mode arg0_elt_mode = TYPE_MODE (TREE_TYPE (arg0_type));\n+  machine_mode arg0_elt_mode = TYPE_MODE (TREE_TYPE (types[0]));\n \n   /* Power9 instructions provide the most efficient implementation of\n      ALTIVEC_BUILTIN_VEC_CMPNE if the mode is not DImode or TImode\n@@ -1060,8 +1036,8 @@ resolve_vec_cmpne (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n \t    /* call = vec_cmpeq (va, vb)\n \t       result = vec_nor (call, call).  */\n \t    vec<tree, va_gc> *params = make_tree_vector ();\n-\t    vec_safe_push (params, arg0);\n-\t    vec_safe_push (params, arg1);\n+\t    vec_safe_push (params, args[0]);\n+\t    vec_safe_push (params, args[1]);\n \t    tree decl = rs6000_builtin_decls[RS6000_OVLD_VEC_CMPEQ];\n \t    tree call = altivec_resolve_overloaded_builtin (loc, decl, params);\n \t    /* Use save_expr to ensure that operands used more than once\n@@ -1088,46 +1064,30 @@ resolve_vec_cmpne (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n   return error_mark_node;\n }\n \n-/* Resolve an overloaded vec_adde or vec_sube call and return a tree\n-   expression for the resolved call if successful.  NARGS is the number of\n-   arguments to the call.  ARGLIST contains the arguments.  RES must be set\n-   to indicate the status of the resolution attempt.  LOC contains statement\n-   location information.  */\n+/* Resolve an overloaded vec_adde or vec_sube call and return a tree expression\n+   for the resolved call if successful.  ARGS contains the arguments to the\n+   call.  TYPES contains their arguments.  RES must be set to indicate the\n+   status of the resolution attempt.  LOC contains statement location\n+   information.  */\n \n static tree\n resolve_vec_adde_sube (resolution *res, rs6000_gen_builtins fcode,\n-\t\t       vec<tree, va_gc> *arglist, unsigned nargs,\n-\t\t       location_t loc)\n+\t\t       tree *args, tree *types, location_t loc)\n {\n   /* vec_adde needs to be special cased because there is no instruction\n      for the {un}signed int version.  */\n-  if (nargs != 3)\n-    {\n-      const char *name;\n-      name = fcode == RS6000_OVLD_VEC_ADDE ? \"vec_adde\" : \"vec_sube\";\n-      error (\"builtin %qs only accepts 3 arguments\", name);\n-      *res = resolved;\n-      return error_mark_node;\n-    }\n-\n-  tree arg0 = (*arglist)[0];\n-  tree arg0_type = TREE_TYPE (arg0);\n-  tree arg1 = (*arglist)[1];\n-  tree arg1_type = TREE_TYPE (arg1);\n-  tree arg2 = (*arglist)[2];\n-  tree arg2_type = TREE_TYPE (arg2);\n \n   /* All 3 arguments must be vectors of (signed or unsigned) (int or\n      __int128) and the types must be compatible.  */\n-  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n-      || !lang_hooks.types_compatible_p (arg0_type, arg1_type)\n-      || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n+  if (TREE_CODE (types[0]) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (types[0], types[1])\n+      || !lang_hooks.types_compatible_p (types[1], types[2]))\n     {\n       *res = resolved_bad;\n       return error_mark_node;\n     }\n \n-  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+  switch (TYPE_MODE (TREE_TYPE (types[0])))\n     {\n       /* For {un}signed ints,\n \t vec_adde (va, vb, carryv) == vec_add (vec_add (va, vb),\n@@ -1137,8 +1097,8 @@ resolve_vec_adde_sube (resolution *res, rs6000_gen_builtins fcode,\n     case E_SImode:\n       {\n \tvec<tree, va_gc> *params = make_tree_vector ();\n-\tvec_safe_push (params, arg0);\n-\tvec_safe_push (params, arg1);\n+\tvec_safe_push (params, args[0]);\n+\tvec_safe_push (params, args[1]);\n \n \ttree add_sub_builtin;\n \tif (fcode == RS6000_OVLD_VEC_ADDE)\n@@ -1148,10 +1108,10 @@ resolve_vec_adde_sube (resolution *res, rs6000_gen_builtins fcode,\n \n \ttree call = altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n \t\t\t\t\t\t\tparams);\n-\ttree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n-\ttree ones_vector = build_vector_from_val (arg0_type, const1);\n-\ttree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n-\t\t\t\t\t arg2, ones_vector);\n+\ttree const1 = build_int_cstu (TREE_TYPE (types[0]), 1);\n+\ttree ones_vector = build_vector_from_val (types[0], const1);\n+\ttree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, types[0],\n+\t\t\t\t\t args[2], ones_vector);\n \tparams = make_tree_vector ();\n \tvec_safe_push (params, call);\n \tvec_safe_push (params, and_expr);\n@@ -1175,45 +1135,29 @@ resolve_vec_adde_sube (resolution *res, rs6000_gen_builtins fcode,\n }\n \n /* Resolve an overloaded vec_addec or vec_subec call and return a tree\n-   expression for the resolved call if successful.  NARGS is the number of\n-   arguments to the call.  ARGLIST contains the arguments.  RES must be set\n-   to indicate the status of the resolution attempt.  LOC contains statement\n-   location information.  */\n+   expression for the resolved call if successful.  ARGS contains the arguments\n+   to the call.  TYPES contains their types.  RES must be set to indicate the\n+   status of the resolution attempt.  LOC contains statement location\n+   information.  */\n \n static tree\n resolve_vec_addec_subec (resolution *res, rs6000_gen_builtins fcode,\n-\t\t\t vec<tree, va_gc> *arglist, unsigned nargs,\n-\t\t\t location_t loc)\n+\t\t\t tree *args, tree *types, location_t loc)\n {\n   /* vec_addec and vec_subec needs to be special cased because there is\n      no instruction for the (un)signed int version.  */\n-  if (nargs != 3)\n-    {\n-      const char *name;\n-      name = fcode == RS6000_OVLD_VEC_ADDEC ? \"vec_addec\" : \"vec_subec\";\n-      error (\"builtin %qs only accepts 3 arguments\", name);\n-      *res = resolved;\n-      return error_mark_node;\n-    }\n-\n-  tree arg0 = (*arglist)[0];\n-  tree arg0_type = TREE_TYPE (arg0);\n-  tree arg1 = (*arglist)[1];\n-  tree arg1_type = TREE_TYPE (arg1);\n-  tree arg2 = (*arglist)[2];\n-  tree arg2_type = TREE_TYPE (arg2);\n \n   /* All 3 arguments must be vectors of (signed or unsigned) (int or\n      __int128) and the types must be compatible.  */\n-  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n-      || !lang_hooks.types_compatible_p (arg0_type, arg1_type)\n-      || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n+  if (TREE_CODE (types[0]) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (types[0], types[1])\n+      || !lang_hooks.types_compatible_p (types[1], types[2]))\n     {\n       *res = resolved_bad;\n       return error_mark_node;\n     }\n \n-  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+  switch (TYPE_MODE (TREE_TYPE (types[0])))\n     {\n       /* For {un}signed ints,\n \t   vec_addec (va, vb, carryv) ==\n@@ -1224,11 +1168,11 @@ resolve_vec_addec_subec (resolution *res, rs6000_gen_builtins fcode,\n       {\n \t/* Use save_expr to ensure that operands used more than once that may\n \t   have side effects (like calls) are only evaluated once.  */\n-\targ0 = save_expr (arg0);\n-\targ1 = save_expr (arg1);\n+\targs[0] = save_expr (args[0]);\n+\targs[1] = save_expr (args[1]);\n \tvec<tree, va_gc> *params = make_tree_vector ();\n-\tvec_safe_push (params, arg0);\n-\tvec_safe_push (params, arg1);\n+\tvec_safe_push (params, args[0]);\n+\tvec_safe_push (params, args[1]);\n \n \ttree as_c_builtin;\n \tif (fcode == RS6000_OVLD_VEC_ADDEC)\n@@ -1239,8 +1183,8 @@ resolve_vec_addec_subec (resolution *res, rs6000_gen_builtins fcode,\n \ttree call1 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n \t\t\t\t\t\t\t params);\n \tparams = make_tree_vector ();\n-\tvec_safe_push (params, arg0);\n-\tvec_safe_push (params, arg1);\n+\tvec_safe_push (params, args[0]);\n+\tvec_safe_push (params, args[1]);\n \n \ttree as_builtin;\n \tif (fcode == RS6000_OVLD_VEC_ADDEC)\n@@ -1250,10 +1194,10 @@ resolve_vec_addec_subec (resolution *res, rs6000_gen_builtins fcode,\n \n \ttree call2 = altivec_resolve_overloaded_builtin (loc, as_builtin,\n \t\t\t\t\t\t\t params);\n-\ttree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n-\ttree ones_vector = build_vector_from_val (arg0_type, const1);\n-\ttree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n-\t\t\t\t\t arg2, ones_vector);\n+\ttree const1 = build_int_cstu (TREE_TYPE (types[0]), 1);\n+\ttree ones_vector = build_vector_from_val (types[0], const1);\n+\ttree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, types[0],\n+\t\t\t\t\t args[2], ones_vector);\n \tparams = make_tree_vector ();\n \tvec_safe_push (params, call2);\n \tvec_safe_push (params, and_expr);\n@@ -1783,78 +1727,22 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t     \"%<vec_lvsr%> is deprecated for little endian; use \"\n \t     \"assignment for unaligned loads and stores\");\n \n-  /* Some overloads require special handling.  */\n-  /* FIXME: Could we simplify the helper functions if we gathered arguments\n-     and types into arrays first?  */\n-  tree returned_expr = NULL;\n-  resolution res = unresolved;\n-  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n-  unsigned int nargs = vec_safe_length (arglist);\n-\n-  switch (fcode)\n-    {\n-    case RS6000_OVLD_VEC_MUL:\n-      returned_expr = resolve_vec_mul (&res, arglist, nargs, loc);\n-      break;\n-\n-    case RS6000_OVLD_VEC_CMPNE:\n-      returned_expr = resolve_vec_cmpne (&res, arglist, nargs, loc);\n-      break;\n-\n-    case RS6000_OVLD_VEC_ADDE:\n-    case RS6000_OVLD_VEC_SUBE:\n-      returned_expr = resolve_vec_adde_sube (&res, fcode, arglist, nargs, loc);\n-      break;\n-\n-    case RS6000_OVLD_VEC_ADDEC:\n-    case RS6000_OVLD_VEC_SUBEC:\n-      returned_expr = resolve_vec_addec_subec (&res, fcode, arglist, nargs,\n-\t\t\t\t\t       loc);\n-      break;\n-\n-    case RS6000_OVLD_VEC_SPLATS:\n-    case RS6000_OVLD_VEC_PROMOTE:\n-      returned_expr = resolve_vec_splats (&res, fcode, arglist, nargs);\n-      break;\n-\n-    case RS6000_OVLD_VEC_EXTRACT:\n-      returned_expr = resolve_vec_extract (&res, arglist, nargs, loc);\n-      break;\n-\n-    case RS6000_OVLD_VEC_INSERT:\n-      returned_expr = resolve_vec_insert (&res, arglist, nargs, loc);\n-      break;\n-\n-    case RS6000_OVLD_VEC_STEP:\n-      returned_expr = resolve_vec_step (&res, arglist, nargs);\n-      break;\n-\n-    default:\n-      ;\n-    }\n-\n-  if (res == resolved)\n-    return returned_expr;\n-\n-  /* \"Regular\" built-in functions and overloaded functions share a namespace\n-     for some arrays, like rs6000_builtin_decls.  But rs6000_overload_info\n-     only has information for the overloaded functions, so we need an\n-     adjusted index for that.  */\n-  unsigned int adj_fcode = fcode - RS6000_OVLD_NONE;\n-\n-  if (res == resolved_bad)\n-    {\n-      const char *name = rs6000_overload_info[adj_fcode].ovld_name;\n-      error (\"invalid parameter combination for AltiVec intrinsic %qs\", name);\n-      return error_mark_node;\n-    }\n-\n   /* Gather the arguments and their types into arrays for easier handling.  */\n   tree fnargs = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n   tree types[MAX_OVLD_ARGS];\n   tree args[MAX_OVLD_ARGS];\n   unsigned int n;\n \n+  /* Count the number of expected arguments.  */\n+  unsigned expected_args = 0;\n+  for (tree chain = fnargs;\n+       chain && !VOID_TYPE_P (TREE_VALUE (chain));\n+       chain = TREE_CHAIN (chain))\n+    expected_args++;\n+\n+  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n+  unsigned int nargs = vec_safe_length (arglist);\n+\n   for (n = 0;\n        !VOID_TYPE_P (TREE_VALUE (fnargs)) && n < nargs;\n        fnargs = TREE_CHAIN (fnargs), n++)\n@@ -1915,10 +1803,72 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n     }\n \n   /* If the number of arguments did not match the prototype, return NULL\n-     and the generic code will issue the appropriate error message.  */\n-  if (!VOID_TYPE_P (TREE_VALUE (fnargs)) || n < nargs)\n+     and the generic code will issue the appropriate error message.  Skip\n+     this test for functions where we don't fully describe all the possible\n+     overload signatures in rs6000-overload.def (because they aren't relevant\n+     to the expansion here).  If we don't, we get confusing error messages.  */\n+  /* As an example, for vec_splats we have:\n+\n+; There are no actual builtins for vec_splats.  There is special handling for\n+; this in altivec_resolve_overloaded_builtin in rs6000-c.cc, where the call\n+; is replaced by a constructor.  The single overload here causes\n+; __builtin_vec_splats to be registered with the front end so that can happen.\n+[VEC_SPLATS, vec_splats, __builtin_vec_splats]\n+  vsi __builtin_vec_splats (vsi);\n+    ABS_V4SI SPLATS_FAKERY\n+\n+    So even though __builtin_vec_splats accepts all vector types, the\n+    infrastructure cheats and just records one prototype.  We end up getting\n+    an error message that refers to this specific prototype even when we\n+    are handling a different argument type.  That is completely confusing\n+    to the user, so it's best to let these cases be handled individually\n+    in the resolve_vec_splats, etc., helper functions.  */\n+\n+  if (n != expected_args\n+      && !(fcode == RS6000_OVLD_VEC_PROMOTE\n+\t   || fcode == RS6000_OVLD_VEC_SPLATS\n+\t   || fcode == RS6000_OVLD_VEC_EXTRACT\n+\t   || fcode == RS6000_OVLD_VEC_INSERT\n+\t   || fcode == RS6000_OVLD_VEC_STEP))\n     return NULL;\n \n+  /* Some overloads require special handling.  */\n+  tree returned_expr = NULL;\n+  resolution res = unresolved;\n+\n+  if (fcode == RS6000_OVLD_VEC_MUL)\n+    returned_expr = resolve_vec_mul (&res, args, types, loc);\n+  else if (fcode == RS6000_OVLD_VEC_CMPNE)\n+    returned_expr = resolve_vec_cmpne (&res, args, types, loc);\n+  else if (fcode == RS6000_OVLD_VEC_ADDE || fcode == RS6000_OVLD_VEC_SUBE)\n+    returned_expr = resolve_vec_adde_sube (&res, fcode, args, types, loc);\n+  else if (fcode == RS6000_OVLD_VEC_ADDEC || fcode == RS6000_OVLD_VEC_SUBEC)\n+    returned_expr = resolve_vec_addec_subec (&res, fcode, args, types, loc);\n+  else if (fcode == RS6000_OVLD_VEC_SPLATS || fcode == RS6000_OVLD_VEC_PROMOTE)\n+    returned_expr = resolve_vec_splats (&res, fcode, arglist, nargs);\n+  else if (fcode == RS6000_OVLD_VEC_EXTRACT)\n+    returned_expr = resolve_vec_extract (&res, arglist, nargs, loc);\n+  else if (fcode == RS6000_OVLD_VEC_INSERT)\n+    returned_expr = resolve_vec_insert (&res, arglist, nargs, loc);\n+  else if (fcode == RS6000_OVLD_VEC_STEP)\n+    returned_expr = resolve_vec_step (&res, arglist, nargs);\n+\n+  if (res == resolved)\n+    return returned_expr;\n+\n+  /* \"Regular\" built-in functions and overloaded functions share a namespace\n+     for some arrays, like rs6000_builtin_decls.  But rs6000_overload_info\n+     only has information for the overloaded functions, so we need an\n+     adjusted index for that.  */\n+  unsigned int adj_fcode = fcode - RS6000_OVLD_NONE;\n+\n+  if (res == resolved_bad)\n+    {\n+      const char *name = rs6000_overload_info[adj_fcode].ovld_name;\n+      error (\"invalid parameter combination for AltiVec intrinsic %qs\", name);\n+      return error_mark_node;\n+    }\n+\n   bool unsupported_builtin = false;\n   rs6000_gen_builtins instance_code;\n   bool supported = false;"}]}