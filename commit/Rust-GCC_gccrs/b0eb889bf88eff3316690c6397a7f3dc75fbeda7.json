{"sha": "b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBlYjg4OWJmODhlZmYzMzE2NjkwYzYzOTdhN2YzZGM3NWZiZWRhNw==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2015-08-31T14:02:00Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2015-08-31T14:02:00Z"}, "message": "Move some comparison simplifications to match.pd\n\n2015-08-31  Marc Glisse  <marc.glisse@inria.fr>\n\ngcc/\n\t* tree.h (zerop): New function.\n\t* tree.c (zerop): Likewise.\n\t(element_precision): Handle expressions.\n\t* match.pd (define_predicates): Add zerop.\n\t(x <= +Inf): Fix comment.\n\t(abs (x) == 0, A & C == C, A & C != 0): Converted from ...\n\t* fold-const.c (fold_binary_loc): ... here. Remove.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/cmp-1.c: New file.\n\nFrom-SVN: r227346", "tree": {"sha": "a33c135ce9d2d8750a86956b05a1741e6d13de2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a33c135ce9d2d8750a86956b05a1741e6d13de2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f196d062919feaf10ec10c67ac0d20f15fcfd2f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f196d062919feaf10ec10c67ac0d20f15fcfd2f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f196d062919feaf10ec10c67ac0d20f15fcfd2f5"}], "stats": {"total": 101, "additions": 80, "deletions": 21}, "files": [{"sha": "fdc02094e27ed5c76a37af7340530ea9a25b74db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "patch": "@@ -1,3 +1,13 @@\n+2015-08-31  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* tree.h (zerop): New function.\n+\t* tree.c (zerop): Likewise.\n+\t(element_precision): Handle expressions.\n+\t* match.pd (define_predicates): Add zerop.\n+\t(x <= +Inf): Fix comment.\n+\t(abs (x) == 0, A & C == C, A & C != 0): Converted from ...\n+\t* fold-const.c (fold_binary_loc): ... here. Remove.\n+\n 2015-08-31  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/67381"}, {"sha": "d478c4dc1c234a7223922d2bf5d987514a7134a1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "patch": "@@ -10678,11 +10678,6 @@ fold_binary_loc (location_t loc,\n \t\t\t\t    TREE_OPERAND (arg0, 1), arg1);\n \t}\n \n-      /* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */\n-      if (TREE_CODE (arg0) == ABS_EXPR\n-\t  && (integer_zerop (arg1) || real_zerop (arg1)))\n-\treturn fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0), arg1);\n-\n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n \t two operations, but the latter can be done in one less insn\n@@ -10785,21 +10780,6 @@ fold_binary_loc (location_t loc,\n \t    }\n \t}\n \n-      /* If we have (A & C) == C where C is a power of 2, convert this into\n-\t (A & C) != 0.  Similarly for NE_EXPR.  */\n-      if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn fold_build2_loc (loc, code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n-\t\t\t    arg0, fold_convert_loc (loc, TREE_TYPE (arg0),\n-\t\t\t\t\t\t    integer_zero_node));\n-\n-      /* If we have (A & C) != 0 or (A & C) == 0 and C is the sign\n-\t bit, then fold the expression into A < 0 or A >= 0.  */\n-      tem = fold_single_bit_test_into_sign_test (loc, code, arg0, arg1, type);\n-      if (tem)\n-\treturn tem;\n-\n       /* If we have (A & C) == D where D & ~C != 0, convert this into 0.\n \t Similarly for NE_EXPR.  */\n       if (TREE_CODE (arg0) == BIT_AND_EXPR"}, {"sha": "fb4b342d31d26a03bc756c538f6635f2acf6ddb2", "filename": "gcc/match.pd", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n    integer_onep integer_zerop integer_all_onesp integer_minus_onep\n    integer_each_onep integer_truep integer_nonzerop\n    real_zerop real_onep real_minus_onep\n+   zerop\n    CONSTANT_CLASS_P\n    tree_expr_nonnegative_p\n    integer_pow2p\n@@ -1608,7 +1609,7 @@ along with GCC; see the file COPYING3.  If not see\n        /* x <= +Inf is always true, if we don't case about NaNs.  */\n        (if (! HONOR_NANS (@0))\n \t{ constant_boolean_node (true, type); }\n-\t/* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n+\t/* x <= +Inf is the same as x == x, i.e. !isnan(x).  */\n \t(eq @0 @0)))\n       /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n       (if (code == EQ_EXPR || code == GE_EXPR)\n@@ -1765,6 +1766,12 @@ along with GCC; see the file COPYING3.  If not see\n     (if (tem && !TREE_OVERFLOW (tem))\n      (scmp @0 { tem; }))))))\n \n+/* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */\n+(for op (eq ne)\n+ (simplify\n+  (op (abs @0) zerop@1)\n+  (op @0 @1)))\n+\n /* From fold_sign_changed_comparison and fold_widened_comparison.  */\n (for cmp (simple_comparison)\n  (simplify\n@@ -1871,6 +1878,28 @@ along with GCC; see the file COPYING3.  If not see\n   (if (tree_single_nonzero_warnv_p (@0, NULL))\n    { constant_boolean_node (cmp == NE_EXPR, type); })))\n \n+/* If we have (A & C) == C where C is a power of 2, convert this into\n+   (A & C) != 0.  Similarly for NE_EXPR.  */\n+(for cmp (eq ne)\n+     icmp (ne eq)\n+ (simplify\n+  (cmp (bit_and@2 @0 integer_pow2p@1) @1)\n+  (icmp @2 { build_zero_cst (TREE_TYPE (@0)); })))\n+ \n+/* If we have (A & C) != 0 where C is the sign bit of A, convert\n+   this into A < 0.  Similarly for (A & C) == 0 into A >= 0.  */\n+(for cmp (eq ne)\n+     ncmp (ge lt)\n+ (simplify\n+  (cmp (bit_and (convert?@2 @0) integer_pow2p@1) integer_zerop)\n+  (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && (TYPE_PRECISION (TREE_TYPE (@0))\n+\t   == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n+       && element_precision (@2) >= element_precision (@0)\n+       && wi::only_sign_bit_p (@1, element_precision (@0)))\n+   (with { tree stype = signed_type_for (TREE_TYPE (@0)); }\n+    (ncmp (convert:stype @0) { build_zero_cst (stype); })))))\n+\n /* When the addresses are not directly of decls compare base and offset.\n    This implements some remaining parts of fold_comparison address\n    comparisons but still no complete part of it.  Still it is good"}, {"sha": "15dc00dd211fcb49a51905c650cc8b7e85050767", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "patch": "@@ -1,3 +1,7 @@\n+2015-08-31  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* gcc.dg/tree-ssa/cmp-1.c: New file.\n+\n 2015-08-31  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* gcc.dg/tree-ssa/complex-7.c: New file."}, {"sha": "6faa70c8df3a741c4abcd639e147020340217f32", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cmp-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcmp-1.c?ref=b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-gimple -fdump-tree-optimized\" } */\n+\n+int f(int a){\n+  int b = -__INT_MAX__-1;\n+  a &= b;\n+  return a == b;\n+}\n+int g(int x){\n+    x = x < 0 ? -x : x;\n+    return x == 0;\n+}\n+\n+/* This should work even if int is not 32 bits, it is just not meaningful in\n+   that case.  */\n+/* { dg-final { scan-tree-dump-not \"-2147483648\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump \" < 0\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump \"ABS_EXPR\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump-not \"ABS_EXPR\" \"optimized\"} } */"}, {"sha": "ed64fe7d273de68bdc1aae334356cb0f2c7065ea", "filename": "gcc/tree.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "patch": "@@ -2215,6 +2215,17 @@ grow_tree_vec_stat (tree v, int len MEM_STAT_DECL)\n   return v;\n }\n \f\n+/* Return 1 if EXPR is the constant zero, whether it is integral, float or\n+   fixed, and scalar, complex or vector.  */\n+\n+int\n+zerop (const_tree expr)\n+{\n+  return (integer_zerop (expr)\n+\t  || real_zerop (expr)\n+\t  || fixed_zerop (expr));\n+}\n+\n /* Return 1 if EXPR is the integer constant zero or a complex constant\n    of zero.  */\n \n@@ -7512,6 +7523,8 @@ valid_constant_size_p (const_tree size)\n unsigned int\n element_precision (const_tree type)\n {\n+  if (!TYPE_P (type))\n+    type = TREE_TYPE (type);\n   enum tree_code code = TREE_CODE (type);\n   if (code == COMPLEX_TYPE || code == VECTOR_TYPE)\n     type = TREE_TYPE (type);"}, {"sha": "e5001510bdc6c13e98200dda7dbb24afe5b9bc7c", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0eb889bf88eff3316690c6397a7f3dc75fbeda7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b0eb889bf88eff3316690c6397a7f3dc75fbeda7", "patch": "@@ -4109,6 +4109,10 @@ extern tree uniform_vector_p (const_tree);\n \n extern vec<tree, va_gc> *ctor_to_vec (tree);\n \n+/* zerop (tree x) is nonzero if X is a constant of value 0.  */\n+\n+extern int zerop (const_tree);\n+\n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0.  */\n \n extern int integer_zerop (const_tree);"}]}