{"sha": "58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThlY2I1ZTJjZDMzYWRkY2Y3M2Q3MGY4N2QwZjNhNWZmMjIxZTIyNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2000-11-24T11:36:27Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-24T11:36:27Z"}, "message": "Avoid a bit of copy propagation when there's a REG_EQUIV note\n\nFrom-SVN: r37705", "tree": {"sha": "cb9f0718cf4e398375383fde98eea639a6545067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb9f0718cf4e398375383fde98eea639a6545067"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226/comments", "author": null, "committer": null, "parents": [{"sha": "c34102419d7a73cafeb889085d73db22e79f0316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34102419d7a73cafeb889085d73db22e79f0316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34102419d7a73cafeb889085d73db22e79f0316"}], "stats": {"total": 27, "additions": 21, "deletions": 6}, "files": [{"sha": "cbda5d08640060eb59e186a9ba7b10253a3504b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "patch": "@@ -3,6 +3,12 @@\n \t* combine.c (cant_combine_insn_p): New function.\n \t(try_combine): Use it.\n \n+2000-11-24  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc/cse.c (cse_insn): Removed conversion of REG_EQUIV to REG_EQUAL\n+\twhen reversing a register-to-register copy.  Reversal now disabled\n+\twhen the previous instruction has a REG_EQUIV.\n+\n 2000-11-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-parse.in (unary_expr): Move VA_ARG from here ..."}, {"sha": "a961e80a27baf3408ac68bfe4b87a15410707e51", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "patch": "@@ -6238,23 +6238,32 @@ cse_insn (insn, libcall_insn)\n \t{\n \t  rtx prev = prev_nonnote_insn (insn);\n \n+\t  /* Do not swap the registers around if the previous instruction\n+\t     attaches a REG_EQUIV note to REG1.\n+\n+\t     ??? It's not entirely clear whether we can transfer a REG_EQUIV\n+\t     from the pseudo that originally shadowed an incoming argument\n+\t     to another register.  Some uses of REG_EQUIV might rely on it\n+\t     being attached to REG1 rather than REG2.\n+\n+\t     This section previously turned the REG_EQUIV into a REG_EQUAL\n+\t     note.  We cannot do that because REG_EQUIV may provide an\n+\t     uninitialised stack slot when REG_PARM_STACK_SPACE is used. */\n+\n \t  if (prev != 0 && GET_CODE (prev) == INSN\n \t      && GET_CODE (PATTERN (prev)) == SET\n-\t      && SET_DEST (PATTERN (prev)) == SET_SRC (sets[0].rtl))\n+\t      && SET_DEST (PATTERN (prev)) == SET_SRC (sets[0].rtl)\n+\t      && ! find_reg_note (prev, REG_EQUIV, NULL_RTX))\n \t    {\n \t      rtx dest = SET_DEST (sets[0].rtl);\n \t      rtx src = SET_SRC (sets[0].rtl);\n-\t      rtx note = find_reg_note (prev, REG_EQUIV, NULL_RTX);\n+\t      rtx note;\n \n \t      validate_change (prev, &SET_DEST (PATTERN (prev)), dest, 1);\n \t      validate_change (insn, &SET_DEST (sets[0].rtl), src, 1);\n \t      validate_change (insn, &SET_SRC (sets[0].rtl), dest, 1);\n \t      apply_change_group ();\n \n-\t      /* If REG1 was equivalent to a constant, REG0 is not.  */\n-\t      if (note)\n-\t\tPUT_REG_NOTE_KIND (note, REG_EQUAL);\n-\n \t      /* If there was a REG_WAS_0 note on PREV, remove it.  Move\n \t\t any REG_WAS_0 note on INSN to PREV.  */\n \t      note = find_reg_note (prev, REG_WAS_0, NULL_RTX);"}]}