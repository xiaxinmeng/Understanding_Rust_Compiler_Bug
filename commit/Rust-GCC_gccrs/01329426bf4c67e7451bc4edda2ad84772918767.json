{"sha": "01329426bf4c67e7451bc4edda2ad84772918767", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzMjk0MjZiZjRjNjdlNzQ1MWJjNGVkZGEyYWQ4NDc3MjkxODc2Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-27T14:56:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-27T14:56:47Z"}, "message": "cse.c (CSE_ADDRESS_COST): Remove.\n\n\t* cse.c (CSE_ADDRESS_COST): Remove.\n\t(find_best_addr): Add new parameter \"MODE\", use address_cost instead\n\tof CSE_ADDRESS_COST\n\t(address_cost): New.\n\t(fold_rtx): Update call of find_best_addr.\n\t* rtl.h (address_cost): Declare.\n\t* loop.c (general_induction_var): Add new parameter \"MODE\", use\n\taddress_cost instead of ADDRESS_COST\n\t(init_loop): Use address_cost instead of ADDRESS_COST.\n\t(check_insn_for_givs): Update call of general_induction_var.\n\t(find_mem_givs): Likewise.\n\t(consec_sets_giv): Likewise.\n\t* config/i386/i386.h (ADDRESS_COST): Call ix86_address_cost.\n\t* i386.c (ix86_address_cost): New.\n\t* i386-protos.h (ix86_address_cost): Declare.\n\nFrom-SVN: r33486", "tree": {"sha": "ccd7fb4b475b369852649bcb4bb5258a7fa7f07f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccd7fb4b475b369852649bcb4bb5258a7fa7f07f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01329426bf4c67e7451bc4edda2ad84772918767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01329426bf4c67e7451bc4edda2ad84772918767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01329426bf4c67e7451bc4edda2ad84772918767", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01329426bf4c67e7451bc4edda2ad84772918767/comments", "author": null, "committer": null, "parents": [{"sha": "5e849f6e86c9cccc8fcc145d887dfdbd08134da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e849f6e86c9cccc8fcc145d887dfdbd08134da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e849f6e86c9cccc8fcc145d887dfdbd08134da7"}], "stats": {"total": 197, "additions": 143, "deletions": 54}, "files": [{"sha": "b485d4f1cdae0ff18184c862ff2e28d9e608cc5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01329426bf4c67e7451bc4edda2ad84772918767", "patch": "@@ -1,3 +1,21 @@\n+Thu Apr 27 16:55:28 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cse.c (CSE_ADDRESS_COST): Remove.\n+\t(find_best_addr): Add new parameter \"MODE\", use address_cost instead\n+\tof CSE_ADDRESS_COST\n+\t(address_cost): New.\n+\t(fold_rtx): Update call of find_best_addr.\n+\t* rtl.h (address_cost): Declare.\n+\t* loop.c (general_induction_var): Add new parameter \"MODE\", use\n+\taddress_cost instead of ADDRESS_COST\n+\t(init_loop): Use address_cost instead of ADDRESS_COST.\n+\t(check_insn_for_givs): Update call of general_induction_var.\n+\t(find_mem_givs): Likewise.\n+\t(consec_sets_giv): Likewise.\n+\t* config/i386/i386.h (ADDRESS_COST): Call ix86_address_cost.\n+\t* i386.c (ix86_address_cost): New.\n+\t* i386-protos.h (ix86_address_cost): Declare.\n+\n Thu Apr 27 11:45:16 2000  Alexandre Oliva  <aoliva@cygnus.com>\n \n \t* config/mn10300/mn10300.md (movqi): Simplify.  Prefer data"}, {"sha": "3bd06b11c0dd1c15b2a191f9983e6d344752649e", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=01329426bf4c67e7451bc4edda2ad84772918767", "patch": "@@ -108,6 +108,7 @@ extern void ix86_split_ashldi PARAMS ((rtx *, rtx));\n extern void ix86_split_ashrdi PARAMS ((rtx *, rtx));\n extern void ix86_split_lshrdi PARAMS ((rtx *, rtx));\n extern void ix86_expand_strlensi_unroll_1 PARAMS ((rtx, rtx, rtx));\n+extern int ix86_address_cost PARAMS ((rtx));\n \n extern rtx assign_386_stack_local PARAMS ((enum machine_mode, int));\n extern int ix86_attr_length_default PARAMS ((rtx));"}, {"sha": "0d9672851a505da0349796b6ef7694c9a9df084d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=01329426bf4c67e7451bc4edda2ad84772918767", "patch": "@@ -2253,7 +2253,65 @@ ix86_decompose_address (addr, out)\n \n   return TRUE;\n }\n+\f\n+/* Return cost of the memory address x.\n+   For i386, it is better to use a complex address than let gcc copy\n+   the address into a reg and make a new pseudo.  But not if the address\n+   requires to two regs - that would mean more pseudos with longer\n+   lifetimes.  */\n+int\n+ix86_address_cost (x)\n+     rtx x;\n+{\n+  struct ix86_address parts;\n+  int cost = 1;\n \n+  if (!ix86_decompose_address (x, &parts))\n+    abort ();\n+\n+  /* More complex memory references are better.  */\n+  if (parts.disp && parts.disp != const0_rtx)\n+    cost--;\n+\n+  /* Attempt to minimize number of registers in the address.  */\n+  if ((parts.base\n+       && (!REG_P (parts.base) || REGNO (parts.base) >= FIRST_PSEUDO_REGISTER))\n+      || (parts.index\n+\t  && (!REG_P (parts.index)\n+\t      || REGNO (parts.index) >= FIRST_PSEUDO_REGISTER)))\n+    cost++;\n+\n+  if (parts.base\n+      && (!REG_P (parts.base) || REGNO (parts.base) >= FIRST_PSEUDO_REGISTER)\n+      && parts.index\n+      && (!REG_P (parts.index) || REGNO (parts.index) >= FIRST_PSEUDO_REGISTER)\n+      && parts.base != parts.index)\n+    cost++;\n+\n+  /* AMD-K6 don't like addresses with ModR/M set to 00_xxx_100b,\n+     since it's predecode logic can't detect the length of instructions\n+     and it degenerates to vector decoded.  Increase cost of such\n+     addresses here.  The penalty is minimally 2 cycles.  It may be worthwhile\n+     to split such addresses or even refuse such addresses at all.  \n+\n+     Following addressing modes are affected:\n+      [base+scale*index]\n+      [scale*index+disp]\n+      [base+index]\n+   \n+     The first and last case  may be avoidable by explicitly coding the zero in\n+     memory address, but I don't have AMD-K6 machine handy to check this\n+     theory.  */\n+\n+  if (TARGET_K6\n+      && ((!parts.disp && parts.base && parts.index && parts.scale != 1)\n+\t  || (parts.disp && !parts.base && parts.index && parts.scale != 1)\n+\t  || (!parts.disp && parts.base && parts.index && parts.scale == 1)))\n+    cost += 10;\n+      \n+  return cost;\n+}\n+\f\n /* Determine if a given CONST RTX is a valid memory displacement\n    in PIC mode.  */\n    "}, {"sha": "9f5a28dacda402ad057178718aa0164d1e47e12a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=01329426bf4c67e7451bc4edda2ad84772918767", "patch": "@@ -2040,11 +2040,7 @@ while (0)\n    lifetimes.  */\n \n #define ADDRESS_COST(RTX) \\\n-  ((CONSTANT_P (RTX)\t\t\t\t\t\t\\\n-    || (GET_CODE (RTX) == PLUS && CONSTANT_P (XEXP (RTX, 1))\t\\\n-\t&& REG_P (XEXP (RTX, 0)))) ? 0\t\t\t\t\\\n-   : REG_P (RTX) ? 1\t\t\t\t\t\t\\\n-   : 2)\n+  ix86_address_cost (x)\n \n /* A C expression for the cost of moving data from a register in class FROM to\n    one in class TO.  The classes are expressed using the enumeration values"}, {"sha": "fe5e4a60b0d4dd36b0eba98c871882c1269112cd", "filename": "gcc/cse.c", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=01329426bf4c67e7451bc4edda2ad84772918767", "patch": "@@ -537,16 +537,6 @@ struct table_elt\n \n #define REGNO_QTY_VALID_P(N) (REG_QTY (N) != (int) (N))\n \n-#ifdef ADDRESS_COST\n-/* The ADDRESS_COST macro does not deal with ADDRESSOF nodes.  But,\n-   during CSE, such nodes are present.  Using an ADDRESSOF node which\n-   refers to the address of a REG is a good thing because we can then\n-   turn (MEM (ADDRESSSOF (REG))) into just plain REG.  */\n-#define CSE_ADDRESS_COST(RTX)\t\t\t\t\t\\\n-  ((GET_CODE (RTX) == ADDRESSOF && REG_P (XEXP ((RTX), 0)))\t\\\n-   ? -1 : ADDRESS_COST(RTX))\n-#endif \n-\n static struct table_elt *table[HASH_SIZE];\n \n /* Chain of `struct table_elt's made so far for this function\n@@ -683,7 +673,7 @@ static unsigned canon_hash\tPARAMS ((rtx, enum machine_mode));\n static unsigned safe_hash\tPARAMS ((rtx, enum machine_mode));\n static int exp_equiv_p\t\tPARAMS ((rtx, rtx, int, int));\n static rtx canon_reg\t\tPARAMS ((rtx, rtx));\n-static void find_best_addr\tPARAMS ((rtx, rtx *));\n+static void find_best_addr\tPARAMS ((rtx, rtx *, enum machine_mode));\n static enum rtx_code find_comparison_args PARAMS ((enum rtx_code, rtx *, rtx *,\n \t\t\t\t\t\t   enum machine_mode *,\n \t\t\t\t\t\t   enum machine_mode *));\n@@ -849,6 +839,34 @@ rtx_cost (x, outer_code)\n   return total;\n }\n \f\n+/* Return cost of address expression X.  Expect that X is propertly formed address\n+   reference.  */\n+int\n+address_cost (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  /* The ADDRESS_COST macro does not deal with ADDRESSOF nodes.  But,\n+     during CSE, such nodes are present.  Using an ADDRESSOF node which\n+     refers to the address of a REG is a good thing because we can then\n+     turn (MEM (ADDRESSSOF (REG))) into just plain REG.  */\n+\n+  if (GET_CODE (x) == ADDRESSOF && REG_P (XEXP ((x), 0)))\n+    return -1;\n+\n+  /* We may be asked for cost of various unusual addresses, such as operands\n+     of push instruction.  It is not worthwhile to complicate writting\n+     of ADDRESS_COST macro by such cases.  */\n+\n+  if (!memory_address_p (mode, x))\n+    return 1000;\n+#ifdef ADDRESS_COST\n+  return ADDRESS_COST (x);\n+#else\n+  return rtx_cost (x, MEM);\n+#endif\n+}\n+\f\n static struct cse_reg_info *\n get_cse_reg_info (regno)\n      unsigned int regno;\n@@ -2681,9 +2699,10 @@ canon_reg (x, insn)\n   */\n \n static void\n-find_best_addr (insn, loc)\n+find_best_addr (insn, loc, mode)\n      rtx insn;\n      rtx *loc;\n+     enum machine_mode mode;\n {\n   struct table_elt *elt;\n   rtx addr = *loc;\n@@ -2695,6 +2714,7 @@ find_best_addr (insn, loc)\n   int save_hash_arg_in_memory = hash_arg_in_memory;\n   int addr_volatile;\n   int regno;\n+  int folded_cost, addr_cost;\n   unsigned hash;\n \n   /* Do not try to replace constant addresses or addresses of local and\n@@ -2728,14 +2748,13 @@ find_best_addr (insn, loc)\n     {\n       rtx folded = fold_rtx (copy_rtx (addr), NULL_RTX);\n \n-      if (1\n-#ifdef ADDRESS_COST\n-\t  && (CSE_ADDRESS_COST (folded) < CSE_ADDRESS_COST (addr)\n-\t      || (CSE_ADDRESS_COST (folded) == CSE_ADDRESS_COST (addr)\n-\t\t  && rtx_cost (folded, MEM) > rtx_cost (addr, MEM)))\n-#else\n+      folded_cost = address_cost (folded, mode);\n+      addr_cost = address_cost (addr, mode);\n+\n+      if ((folded_cost < addr_cost\n+\t   || (folded_cost == addr_cost\n+\t       && rtx_cost (folded, MEM) > rtx_cost (addr, MEM)))\n \t  && rtx_cost (folded, MEM) < rtx_cost (addr, MEM)\n-#endif\n \t  && validate_change (insn, loc, folded, 0))\n \taddr = folded;\n     }\n@@ -2782,8 +2801,9 @@ find_best_addr (insn, loc)\n \n       while (found_better)\n \t{\n-\t  int best_addr_cost = CSE_ADDRESS_COST (*loc);\n+\t  int best_addr_cost = address_cost (*loc, mode);\n \t  int best_rtx_cost = (elt->cost + 1) >> 1;\n+\t  int exp_cost;\n \t  struct table_elt *best_elt = elt; \n \n \t  found_better = 0;\n@@ -2792,12 +2812,12 @@ find_best_addr (insn, loc)\n \t      {\n \t\tif ((GET_CODE (p->exp) == REG\n \t\t     || exp_equiv_p (p->exp, p->exp, 1, 0))\n-\t\t    && (CSE_ADDRESS_COST (p->exp) < best_addr_cost\n-\t\t\t|| (CSE_ADDRESS_COST (p->exp) == best_addr_cost\n-\t\t\t    && (p->cost + 1) >> 1 > best_rtx_cost)))\n+\t\t    && ((exp_cost = address_cost (p->exp, mode)) < best_addr_cost\n+\t\t\t|| (exp_cost == best_addr_cost\n+\t\t\t    && (p->cost + 1) >> 1 < best_rtx_cost)))\n \t\t  {\n \t\t    found_better = 1;\n-\t\t    best_addr_cost = CSE_ADDRESS_COST (p->exp);\n+\t\t    best_addr_cost = exp_cost;\n \t\t    best_rtx_cost = (p->cost + 1) >> 1;\n \t\t    best_elt = p;\n \t\t  }\n@@ -2851,7 +2871,7 @@ find_best_addr (insn, loc)\n \n       while (found_better)\n \t{\n-\t  int best_addr_cost = CSE_ADDRESS_COST (*loc);\n+\t  int best_addr_cost = address_cost (*loc, mode);\n \t  int best_rtx_cost = (COST (*loc) + 1) >> 1;\n \t  struct table_elt *best_elt = elt; \n \t  rtx best_rtx = *loc;\n@@ -2873,13 +2893,15 @@ find_best_addr (insn, loc)\n \t      {\n \t\trtx new = simplify_gen_binary (GET_CODE (*loc), Pmode,\n \t\t\t\t\t       p->exp, c);\n+\t\tint new_cost;\n+\t\tnew_cost = address_cost (new, mode);\n \n-\t\tif ((CSE_ADDRESS_COST (new) < best_addr_cost\n-\t\t    || (CSE_ADDRESS_COST (new) == best_addr_cost\n-\t\t\t&& (COST (new) + 1) >> 1 > best_rtx_cost)))\n+\t\tif (new_cost < best_addr_cost\n+\t\t    || (new_cost == best_addr_cost\n+\t\t\t&& (COST (new) + 1) >> 1 > best_rtx_cost))\n \t\t  {\n \t\t    found_better = 1;\n-\t\t    best_addr_cost = CSE_ADDRESS_COST (new);\n+\t\t    best_addr_cost = new_cost;\n \t\t    best_rtx_cost = (COST (new) + 1) >> 1;\n \t\t    best_elt = p;\n \t\t    best_rtx = new;\n@@ -3350,7 +3372,7 @@ fold_rtx (x, insn)\n \t best address.  Not only don't we care, but we could modify the\n \t MEM in an invalid way since we have no insn to validate against.  */\n       if (insn != 0)\n-\tfind_best_addr (insn, &XEXP (x, 0));\n+\tfind_best_addr (insn, &XEXP (x, 0), GET_MODE (x));\n \n       {\n \t/* Even if we don't fold in the insn itself,"}, {"sha": "096967808ace1398f699678051387606fad548e6", "filename": "gcc/loop.c", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=01329426bf4c67e7451bc4edda2ad84772918767", "patch": "@@ -278,7 +278,7 @@ static int basic_induction_var PARAMS ((const struct loop *, rtx,\n \t\t\t\t\trtx *, rtx *, rtx **, int *));\n static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, int *));\n static int general_induction_var PARAMS ((const struct loop *loop, rtx, rtx *,\n-\t\t\t\t\t  rtx *, rtx *, int, int *));\n+\t\t\t\t\t  rtx *, rtx *, int, int *, enum machine_mode));\n static int consec_sets_giv PARAMS ((const struct loop *, int, rtx,\n \t\t\t\t    rtx, rtx, rtx *, rtx *, rtx *));\n static int check_dbra_loop PARAMS ((struct loop *, int));\n@@ -367,11 +367,7 @@ init_loop ()\n \n   add_cost = rtx_cost (gen_rtx_PLUS (word_mode, reg, reg), SET);\n \n-#ifdef ADDRESS_COST\n-  reg_address_cost = ADDRESS_COST (reg);\n-#else\n-  reg_address_cost = rtx_cost (reg, MEM);\n-#endif\n+  reg_address_cost = address_cost (reg, SImode);\n \n   /* We multiply by 2 to reconcile the difference in scale between\n      these two ways of computing costs.  Otherwise the cost of a copy\n@@ -5133,12 +5129,12 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \n       if (/* SET_SRC is a giv.  */\n \t  (general_induction_var (loop, SET_SRC (set), &src_reg, &add_val,\n-\t\t\t\t  &mult_val, 0, &benefit)\n+\t\t\t\t  &mult_val, 0, &benefit, VOIDmode)\n \t   /* Equivalent expression is a giv.  */\n \t   || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t       && general_induction_var (loop, XEXP (regnote, 0), &src_reg,\n \t\t\t\t\t &add_val, &mult_val, 0,\n-\t\t\t\t\t &benefit)))\n+\t\t\t\t\t &benefit, VOIDmode)))\n \t  /* Don't try to handle any regs made by loop optimization.\n \t     We have nothing on them in regno_first_uid, etc.  */\n \t  && REGNO (dest_reg) < max_reg_before_loop\n@@ -5276,7 +5272,7 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n \t   this one would not be seen.   */\n \n \tif (general_induction_var (loop, XEXP (x, 0), &src_reg, &add_val,\n-\t\t\t\t   &mult_val, 1, &benefit))\n+\t\t\t\t   &mult_val, 1, &benefit, GET_MODE (x)))\n \t  {\n \t    /* Found one; record it.  */\n \t    struct induction *v\n@@ -6126,14 +6122,16 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n      such that the value of X is biv * mult + add;  */\n \n static int\n-general_induction_var (loop, x, src_reg, add_val, mult_val, is_addr, pbenefit)\n+general_induction_var (loop, x, src_reg, add_val, mult_val, is_addr,\n+\t\t       pbenefit, addr_mode)\n      const struct loop *loop;\n      rtx x;\n      rtx *src_reg;\n      rtx *add_val;\n      rtx *mult_val;\n      int is_addr;\n      int *pbenefit;\n+     enum machine_mode addr_mode;\n {\n   rtx orig_x = x;\n   char *storage;\n@@ -6207,13 +6205,7 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, is_addr, pbenefit)\n     *mult_val = XEXP (*mult_val, 0);\n \n   if (is_addr)\n-    {\n-#ifdef ADDRESS_COST\n-      *pbenefit += ADDRESS_COST (orig_x) - reg_address_cost;\n-#else\n-      *pbenefit += rtx_cost (orig_x, MEM) - reg_address_cost;\n-#endif\n-    }\n+    *pbenefit += address_cost (orig_x, addr_mode) - reg_address_cost;\n   else\n     *pbenefit += rtx_cost (orig_x, SET);\n \n@@ -6745,11 +6737,12 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n \t  && GET_CODE (SET_DEST (set)) == REG\n \t  && SET_DEST (set) == dest_reg\n \t  && (general_induction_var (loop, SET_SRC (set), &src_reg,\n-\t\t\t\t     add_val, mult_val, 0, &benefit)\n+\t\t\t\t     add_val, mult_val, 0, &benefit, VOIDmode)\n \t      /* Giv created by equivalent expression.  */\n \t      || ((temp = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t\t  && general_induction_var (loop, XEXP (temp, 0), &src_reg,\n-\t\t\t\t\t    add_val, mult_val, 0, &benefit)))\n+\t\t\t\t\t    add_val, mult_val, 0, &benefit,\n+\t\t\t\t\t    VOIDmode)))\n \t  && src_reg == v->src_reg)\n \t{\n \t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))"}, {"sha": "7a4d493b9a3e64be78d67fe0d81425b748b18b1f", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01329426bf4c67e7451bc4edda2ad84772918767/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=01329426bf4c67e7451bc4edda2ad84772918767", "patch": "@@ -1486,6 +1486,7 @@ extern void push_obstacks\t\tPARAMS ((struct obstack *,\n /* In cse.c */\n struct cse_basic_block_data;\n extern int rtx_cost\t\t\tPARAMS ((rtx, enum rtx_code));\n+extern int address_cost\t\t\tPARAMS ((rtx, enum machine_mode));\n extern void delete_trivially_dead_insns\tPARAMS ((rtx, int));\n #ifdef BUFSIZ\n extern int cse_main\t\t\tPARAMS ((rtx, int, int, FILE *));"}]}