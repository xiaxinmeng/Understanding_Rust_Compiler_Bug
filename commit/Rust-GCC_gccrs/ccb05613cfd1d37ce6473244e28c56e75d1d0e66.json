{"sha": "ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NiMDU2MTNjZmQxZDM3Y2U2NDczMjQ0ZTI4YzU2ZTc1ZDFkMGU2Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-10-08T16:09:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-10-08T16:09:22Z"}, "message": "re PR c++/37177 ([c++0x] ICE on decltype(rel_ops::operator><int>);)\n\n\tPR c++/37177\n\t* pt.c (resolve_nondeduced_context): New.\n\t* cvt.c (convert_to_void): Call it.\n\t* semantics.c (finish_decltype_type): Likewise.\n\t* typeck.c (decay_conversion): Here too.\n\t* pt.c (tsubst_decl): Don't clobber input_location.\n\tDon't register a bad specialization.\n\nFrom-SVN: r152564", "tree": {"sha": "0b5aca150e69844718e291632a5913000e0f6868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b5aca150e69844718e291632a5913000e0f6868"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6728ee79872ffd3dbcf858dab076c96c71ec95e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6728ee79872ffd3dbcf858dab076c96c71ec95e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6728ee79872ffd3dbcf858dab076c96c71ec95e5"}], "stats": {"total": 241, "additions": 214, "deletions": 27}, "files": [{"sha": "5f672041fffa1da174bf03612e8b4767cd29f5e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -1,3 +1,13 @@\n+2009-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/37177\n+\t* pt.c (resolve_nondeduced_context): New.\n+\t* cvt.c (convert_to_void): Call it.\n+\t* semantics.c (finish_decltype_type): Likewise.\n+\t* typeck.c (decay_conversion): Here too.\n+\t* pt.c (tsubst_decl): Don't clobber input_location.\n+\tDon't register a bad specialization.\n+\n 2009-10-07  Gabriel Dos Reis  <gdr@cs.tamu.edu>\n \n \t* cp-tree.h: Fix location of documentation for DECL_LANG_FLAG_7."}, {"sha": "3d826b9ad92257f197fd532f8db3b679b7200984", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -4845,7 +4845,9 @@ bool template_template_parameter_p\t\t(const_tree);\n extern tree get_primary_template_innermost_parameters\t(const_tree);\n extern tree get_template_innermost_arguments\t(const_tree);\n extern tree get_template_argument_pack_elems\t(const_tree);\n-extern tree get_function_template_decl (const_tree);\n+extern tree get_function_template_decl\t\t(const_tree);\n+extern tree resolve_nondeduced_context\t\t(tree);\n+\n /* in repo.c */\n extern void init_repo\t\t\t\t(void);\n extern int repo_emit_p\t\t\t\t(tree);"}, {"sha": "8c5b001dd15c2107f5ee9f321cf64d307730fb06", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -956,6 +956,7 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \n     default:;\n     }\n+  expr = resolve_nondeduced_context (expr);\n   {\n     tree probe = expr;\n "}, {"sha": "19d8c9a87df25d9d00be4fa3119bc8e83559b40a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 127, "deletions": 17, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -8461,6 +8461,7 @@ tsubst_default_arguments (tree fn)\n static tree\n tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n {\n+#define RETURN(EXP) do { r = (EXP); goto out; } while(0)\n   location_t saved_loc;\n   tree r = NULL_TREE;\n   tree in_decl = t;\n@@ -8486,7 +8487,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    /* Template template parameter is treated here.  */\n \t    tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    if (new_type == error_mark_node)\n-\t      return error_mark_node;\n+\t      RETURN (error_mark_node);\n \n \t    r = copy_decl (t);\n \t    TREE_CHAIN (r) = NULL_TREE;\n@@ -8517,12 +8518,12 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t\t\t\t  complain, in_decl);\n \t--processing_template_decl;\n \tif (full_args == error_mark_node)\n-\t  return error_mark_node;\n+\t  RETURN (error_mark_node);\n \n \t/* If this is a default template template argument,\n \t   tsubst might not have changed anything.  */\n \tif (full_args == tmpl_args)\n-\t  return t;\n+\t  RETURN (t);\n \n \thash = hash_tmpl_and_args (t, full_args);\n \tspec = retrieve_specialization (t, full_args, hash);\n@@ -8550,7 +8551,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    --processing_template_decl;\n \t    if (new_type == error_mark_node)\n-\t      return error_mark_node;\n+\t      RETURN (error_mark_node);\n \n \t    TREE_TYPE (r) = new_type;\n \t    CLASSTYPE_TI_TEMPLATE (new_type) = r;\n@@ -8565,7 +8566,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    new_decl = tsubst (decl, args, complain, in_decl);\n \t    --processing_template_decl;\n \t    if (new_decl == error_mark_node)\n-\t      return error_mark_node;\n+\t      RETURN (error_mark_node);\n \n \t    DECL_TEMPLATE_RESULT (r) = new_decl;\n \t    DECL_TI_TEMPLATE (new_decl) = r;\n@@ -8623,7 +8624,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    dependent_p = value_dependent_expression_p (t);\n \t    --processing_template_decl;\n \t    if (!dependent_p)\n-\t      return t;\n+\t      RETURN (t);\n \n \t    /* Calculate the most general template of which R is a\n \t       specialization, and the complete set of arguments used to\n@@ -8714,7 +8715,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  }\n \ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \tif (type == error_mark_node)\n-\t  return error_mark_node;\n+\t  RETURN (error_mark_node);\n \n \t/* We do NOT check for matching decls pushed separately at this\n \t   point, as they may not represent instantiations of this\n@@ -8757,6 +8758,13 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t/* We'll re-clone as appropriate in instantiate_template.  */\n \tDECL_CLONED_FUNCTION (r) = NULL_TREE;\n \n+\t/* If we aren't complaining now, return on error before we register\n+\t   the specialization so that we'll complain eventually.  */\n+\tif ((complain & tf_error) == 0\n+\t    && IDENTIFIER_OPNAME_P (DECL_NAME (r))\n+\t    && !grok_op_properties (r, /*complain=*/false))\n+\t  RETURN (error_mark_node);\n+\n \t/* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do\n \t   this in the special friend case mentioned above where\n \t   GEN_TMPL is NULL.  */\n@@ -8808,9 +8816,10 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    if (PRIMARY_TEMPLATE_P (gen_tmpl))\n \t      clone_function_decl (r, /*update_method_vec_p=*/0);\n \t  }\n-\telse if (IDENTIFIER_OPNAME_P (DECL_NAME (r))\n-\t\t && !grok_op_properties (r, (complain & tf_error) != 0))\n-\t  return error_mark_node;\n+\telse if ((complain & tf_error) != 0\n+\t\t && IDENTIFIER_OPNAME_P (DECL_NAME (r))\n+\t\t && !grok_op_properties (r, /*complain=*/true))\n+\t  RETURN (error_mark_node);\n \n \tif (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))\n \t  SET_DECL_FRIEND_CONTEXT (r,\n@@ -8851,7 +8860,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n             if (spec \n                 && TREE_CODE (spec) == PARM_DECL\n                 && TREE_CODE (TREE_TYPE (spec)) != TYPE_PACK_EXPANSION)\n-              return spec;\n+              RETURN (spec);\n \n             /* Expand the TYPE_PACK_EXPANSION that provides the types for\n                the parameters in this function parameter pack.  */\n@@ -8864,8 +8873,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n                 /* Zero-length parameter packs are boring. Just substitute\n                    into the chain.  */\n                 if (len == 0)\n-                  return tsubst (TREE_CHAIN (t), args, complain, \n-                                 TREE_CHAIN (t));\n+                  RETURN (tsubst (TREE_CHAIN (t), args, complain,\n+\t\t\t\t  TREE_CHAIN (t)));\n               }\n             else\n               {\n@@ -8955,7 +8964,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tr = copy_decl (t);\n \ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \tif (type == error_mark_node)\n-\t  return error_mark_node;\n+\t  RETURN (error_mark_node);\n \tTREE_TYPE (r) = type;\n \tcp_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n@@ -9018,7 +9027,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t       we've copied the type for a typedef.  */\n \t    type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    if (type == error_mark_node)\n-\t      return error_mark_node;\n+\t      RETURN (error_mark_node);\n \t    r = TYPE_NAME (type);\n \t    break;\n \t  }\n@@ -9091,7 +9100,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    DECL_INITIALIZED_P (r) = 0;\n \t    DECL_TEMPLATE_INSTANTIATED (r) = 0;\n \t    if (type == error_mark_node)\n-\t      return error_mark_node;\n+\t      RETURN (error_mark_node);\n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n \t      {\n \t\t/* It may seem that this case cannot occur, since:\n@@ -9111,7 +9120,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t       /* R is not yet sufficiently initialized, so we\n \t\t\t  just use its name.  */\n \t\t       DECL_NAME (r));\n-\t\treturn error_mark_node;\n+\t\tRETURN (error_mark_node);\n \t      }\n \t    type = complete_type (type);\n \t    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (r)\n@@ -9207,7 +9216,9 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n     default:\n       gcc_unreachable ();\n     }\n+#undef RETURN\n \n+ out:\n   /* Restore the file and line information.  */\n   input_location = saved_loc;\n \n@@ -13307,6 +13318,105 @@ resolve_overloaded_unification (tree tparms,\n   return false;\n }\n \n+/* Core DR 115: In contexts where deduction is done and fails, or in\n+   contexts where deduction is not done, if a template argument list is\n+   specified and it, along with any default template arguments, identifies\n+   a single function template specialization, then the template-id is an\n+   lvalue for the function template specialization.  */\n+\n+tree\n+resolve_nondeduced_context (tree orig_expr)\n+{\n+  tree expr, offset, baselink;\n+  bool addr;\n+\n+  if (!type_unknown_p (orig_expr))\n+    return orig_expr;\n+\n+  expr = orig_expr;\n+  addr = false;\n+  offset = NULL_TREE;\n+  baselink = NULL_TREE;\n+\n+  if (TREE_CODE (expr) == ADDR_EXPR)\n+    {\n+      expr = TREE_OPERAND (expr, 0);\n+      addr = true;\n+    }\n+  if (TREE_CODE (expr) == OFFSET_REF)\n+    {\n+      offset = expr;\n+      expr = TREE_OPERAND (expr, 1);\n+    }\n+  if (TREE_CODE (expr) == BASELINK)\n+    {\n+      baselink = expr;\n+      expr = BASELINK_FUNCTIONS (expr);\n+    }\n+\n+  if (TREE_CODE (expr) == TEMPLATE_ID_EXPR)\n+    {\n+      int good = 0;\n+      tree goodfn = NULL_TREE;\n+\n+      /* If we got some explicit template args, we need to plug them into\n+\t the affected templates before we try to unify, in case the\n+\t explicit args will completely resolve the templates in question.  */\n+\n+      tree expl_subargs = TREE_OPERAND (expr, 1);\n+      tree arg = TREE_OPERAND (expr, 0);\n+      tree badfn = NULL_TREE;\n+      tree badargs = NULL_TREE;\n+\n+      for (; arg; arg = OVL_NEXT (arg))\n+\t{\n+\t  tree fn = OVL_CURRENT (arg);\n+\t  tree subargs, elem;\n+\n+\t  if (TREE_CODE (fn) != TEMPLATE_DECL)\n+\t    continue;\n+\n+\t  ++processing_template_decl;\n+\t  subargs = get_bindings (fn, DECL_TEMPLATE_RESULT (fn),\n+\t\t\t\t  expl_subargs, /*check_ret=*/false);\n+\t  if (subargs && !any_dependent_template_arguments_p (subargs))\n+\t    {\n+\t      elem = instantiate_template (fn, subargs, tf_none);\n+\t      if (elem == error_mark_node)\n+\t\t{\n+\t\t  badfn = fn;\n+\t\t  badargs = subargs;\n+\t\t}\n+\t      else if (elem && (!goodfn || !decls_match (goodfn, elem)))\n+\t\t{\n+\t\t  goodfn = elem;\n+\t\t  ++good;\n+\t\t}\n+\t    }\n+\t  --processing_template_decl;\n+\t}\n+      if (good == 1)\n+\t{\n+\t  expr = goodfn;\n+\t  if (baselink)\n+\t    expr = build_baselink (BASELINK_BINFO (baselink),\n+\t\t\t\t   BASELINK_ACCESS_BINFO (baselink),\n+\t\t\t\t   expr, BASELINK_OPTYPE (baselink));\n+\t  if (offset)\n+\t    expr = build2 (OFFSET_REF, TREE_TYPE (expr),\n+\t\t\t   TREE_OPERAND (offset, 0), expr);\n+\t  if (addr)\n+\t    expr = build_address (expr);\n+\t  return expr;\n+\t}\n+      else if (good == 0 && badargs)\n+\t/* There were no good options and at least one bad one, so let the\n+\t   user know what the problem is.  */\n+\tinstantiate_template (badfn, badargs, tf_warning_or_error);\n+    }\n+  return orig_expr;\n+}\n+\n /* Subroutine of resolve_overloaded_unification; does deduction for a single\n    overload.  Fills TARGS with any deduced arguments, or error_mark_node if\n    different overloads deduce different arguments for a given parm."}, {"sha": "6cf22204a5e0bf2c93a1bca3b1a04aa5ce53af5d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -4741,6 +4741,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n \n   /* The type denoted by decltype(e) is defined as follows:  */\n \n+  expr = resolve_nondeduced_context (expr);\n   if (id_expression_or_member_access_p)\n     {\n       /* If e is an id-expression or a class member access (5.2.5\n@@ -4766,9 +4767,13 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n         /* See through BASELINK nodes to the underlying functions.  */\n         expr = BASELINK_FUNCTIONS (expr);\n \n+      if (TREE_CODE (expr) == TEMPLATE_ID_EXPR)\n+\texpr = TREE_OPERAND (expr, 0);\n+\n       if (TREE_CODE (expr) == OVERLOAD)\n         {\n-          if (OVL_CHAIN (expr))\n+          if (OVL_CHAIN (expr)\n+\t      || TREE_CODE (OVL_FUNCTION (expr)) == TEMPLATE_DECL)\n             {\n               error (\"%qE refers to a set of overloaded functions\", orig_expr);\n               return error_mark_node;"}, {"sha": "526e7066a60c0e07c7fc3b81ac1240207f6189a6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -1613,6 +1613,7 @@ decay_conversion (tree exp)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n+  exp = resolve_nondeduced_context (exp);\n   if (type_unknown_p (exp))\n     {\n       cxx_incomplete_type_error (exp, TREE_TYPE (exp));"}, {"sha": "edfbe1df6739662956836f32ce646bce5551a589", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -1,3 +1,11 @@\n+2009-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/37177\n+\t* g++.dg/cpp0x/variadic-throw.C: Adjust errors.\n+\t* g++.dg/template/explicit-args2.C: New.\n+\t* g++.dg/template/explicit-args3.C: New.\n+\t* g++.old-deja/g++.pt/crash58.C: Remove some errors.\n+\n 2009-10-08  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/41573"}, {"sha": "ee85bf2a5692c7ff45a38c20301574484d742792", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-throw.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-throw.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-throw.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-throw.C?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -8,7 +8,7 @@ template<int M, int N> struct pair\n \n template<int... M> struct S\n {\n-  template<int... N> static int foo() throw (pair <M, N>...) // { dg-error \"mismatched|no matching\" }\n+  template<int... N> static int foo() throw (pair <M, N>...) // { dg-error \"mismatched\" }\n   {\n     return 1;\n   }\n@@ -21,5 +21,5 @@ int bar ()\n \n int wibble()\n {\n-  return S<0, 1, 2>::foo<0, 1> ();\n+  return S<0, 1, 2>::foo<0, 1> (); // { dg-error \"no matching\" }\n }"}, {"sha": "cd53b456dcc776600a24b68e9873d280af987e14", "filename": "gcc/testsuite/g++.dg/template/explicit-args2.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args2.C?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -0,0 +1,38 @@\n+// PR c++/37177\n+// { dg-options -std=c++0x }\n+\n+namespace N1\n+{\n+  template<class T> bool foo();\n+}\n+\n+struct S\n+{\n+  template <class T>\n+  static bool foo();\n+\n+  template <class T>\n+  bool bar();\n+};\n+\n+template<class T> bool foo();\n+\n+int main()\n+{\n+  (void)(&S::bar<int>);\n+  decltype(&S::bar<int>) a;\n+\n+  (void*)(&S::foo<int>);\n+  (void)(&S::foo<int>);\n+  decltype(&S::foo<int>) b;\n+\n+  (void*)(&N1::foo<int>);\n+  (void)(&N1::foo<int>);\n+  decltype(&N1::foo<int>) c;\n+\n+  (void*)(&foo<int>);\n+  (void)(&foo<int>);\n+  decltype(&foo<int>) d;\n+\n+  &foo<int> == 0;\n+}"}, {"sha": "c095e6688fdcf764174bce40bfeaf71f8a794212", "filename": "gcc/testsuite/g++.dg/template/explicit-args3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args3.C?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/37177\n+\n+template <class T>\n+struct A { };\n+\n+template <class T>\n+void operator+(T, T);\t\t// { dg-error \"class or enum\" }\n+\n+int main()\n+{\n+  operator+<int>;\t\t// { dg-error \"cannot resolve\" }\n+}"}, {"sha": "0ce3d81723d5465fca6579e1b01115cb01c84f3f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash58.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash58.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05613cfd1d37ce6473244e28c56e75d1d0e66/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash58.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash58.C?ref=ccb05613cfd1d37ce6473244e28c56e75d1d0e66", "patch": "@@ -15,16 +15,16 @@ struct MatrixC\n {\n   void foo () {\n     EManip::do_assign<T> (0);\n-    &EManip::do_assign<T>;\t// { dg-error \"\" } unresolved\n-    &do_assign<T>;\t\t// { dg-error \"\" } unresolved\n-    EManip::do_assign<T>;       // { dg-error \"\" } unresolved\n-    do_assign<T>;               // { dg-error \"\" } unresolved\n+    &EManip::do_assign<T>;\t// { dg-bogus \"\" } unresolved\n+    &do_assign<T>;\t\t// { dg-bogus \"\" } unresolved\n+    EManip::do_assign<T>;       // { dg-bogus \"\" } unresolved\n+    do_assign<T>;               // { dg-bogus \"\" } unresolved\n   }\n };\n void foo(MatrixC <double> *ptr)\n {\n-  EManip::do_assign<double>;    // { dg-error \"\" } unresolved\n-  &EManip::do_assign<double>;\t// { dg-error \"\" } unresolved\n+  EManip::do_assign<double>;    // { dg-bogus \"\" } unresolved\n+  &EManip::do_assign<double>;\t// { dg-bogus \"\" } unresolved\n   ptr->foo ();\n   void (*p1) (int *) = &do_assign<double>;       // { dg-error \"\" } cannot convert\n   void (*p2) (int *) = &EManip::do_assign<double>; // { dg-error \"\" } cannot convert"}]}