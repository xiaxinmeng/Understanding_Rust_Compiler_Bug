{"sha": "1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYyNGRkNDc0ZTRlM2Q2NzY2ODRkN2VjMDIyYjM1MzUwZDRjNGEwZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-01-06T22:08:27Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-01-06T22:08:27Z"}, "message": "re PR tree-optimization/18792 (ICE with -O1 -ftree-loop-linear on small test case)\n\n2005-01-06  Daniel Berlin <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/18792\n\n\t* tree-data-ref.c (build_classic_dist_vector): Change first_loop\n\tto first_loop_depth, and use loop depth instead of loop number.\n\t(build_classic_dir_vector): Ditto.\n\t(compute_data_dependences_for_loop): Use depth, not loop number.\n\t* tree-loop-linear.c (try_interchange_loops): Use loop depth, not loop\n\tnumber. Pass in loops, instead of loop numbers.\n\t(gather_interchange_stats): Ditto.\n\t(linear_transform_loops): Ditto.\n\nFrom-SVN: r93008", "tree": {"sha": "0cefe92e4de94b5984c23671a4fd98a1e642c18f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cefe92e4de94b5984c23671a4fd98a1e642c18f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8e3a00f544e678384844899cec3a636442e1517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e3a00f544e678384844899cec3a636442e1517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e3a00f544e678384844899cec3a636442e1517"}], "stats": {"total": 197, "additions": 116, "deletions": 81}, "files": [{"sha": "bdadf4a91472ae89f797a38f35385f4f3dc20f74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "patch": "@@ -1,3 +1,16 @@\n+2005-01-06  Daniel Berlin <dberlin@dberlin.org>\n+\t\n+\tFix PR tree-optimization/18792\n+\n+\t* tree-data-ref.c (build_classic_dist_vector): Change first_loop\n+\tto first_loop_depth, and use loop depth instead of loop number.\n+\t(build_classic_dir_vector): Ditto.\n+\t(compute_data_dependences_for_loop): Use depth, not loop number.\n+\t* tree-loop-linear.c (try_interchange_loops): Use loop depth, not loop \n+\tnumber. Pass in loops, instead of loop numbers.\n+\t(gather_interchange_stats): Ditto.\n+\t(linear_transform_loops): Ditto.\n+\n 2005-01-06  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR rtl-opt/13299"}, {"sha": "4e93fe145f365627b46d770a3ca214ef8f2fd11b", "filename": "gcc/testsuite/gcc.dg/pr18792.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr18792.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr18792.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr18792.c?ref=1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/18792 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -ftree-loop-linear\" } */\n+void put_atoms_in_triclinic_unitcell(float x[][3])\n+{\n+\tint i=0,d;\n+\n+\twhile (x[i][3] < 0)\n+\t\tfor (d=0; d<=3; d++)\n+\t\t\tx[i][d] = 0;\n+\n+\twhile (x[i][3] >= 0)\n+\t\tfor (d=0; d<=3; d++)\n+\t\t\tx[i][d] = 0;\n+\n+}"}, {"sha": "112522efc2a4095af756851e8d0eaafb6185cf2c", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "patch": "@@ -1781,15 +1781,15 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n \n    DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n-   FIRST_LOOP is the loop->num of the first loop in the analyzed \n+   FIRST_LOOP_DEPTH is the loop->depth of the first loop in the analyzed\n    loop nest.  \n    Return FALSE if the dependence relation is outside of the loop nest\n-   starting with FIRST_LOOP. \n+   starting at FIRST_LOOP_DEPTH. \n    Return TRUE otherwise.  */\n \n static bool\n build_classic_dist_vector (struct data_dependence_relation *ddr, \n-\t\t\t   int nb_loops, unsigned int first_loop)\n+\t\t\t   int nb_loops, int first_loop_depth)\n {\n   unsigned i;\n   lambda_vector dist_v, init_v;\n@@ -1819,19 +1819,18 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n       if (TREE_CODE (access_fn_a) == POLYNOMIAL_CHREC \n \t  && TREE_CODE (access_fn_b) == POLYNOMIAL_CHREC)\n \t{\n-\t  int dist, loop_nb;\n+\t  int dist, loop_nb, loop_depth;\n \t  int loop_nb_a = CHREC_VARIABLE (access_fn_a);\n \t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n \t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n \t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n-\t  struct loop *loop_first = current_loops->parray[first_loop];\n \n \t  /* If the loop for either variable is at a lower depth than \n \t     the first_loop's depth, then we can't possibly have a\n \t     dependency at this level of the loop.  */\n \t     \n-\t  if (loop_a->depth < loop_first->depth\n-\t      || loop_b->depth < loop_first->depth)\n+\t  if (loop_a->depth < first_loop_depth\n+\t      || loop_b->depth < first_loop_depth)\n \t    return false;\n \n \t  if (loop_nb_a != loop_nb_b\n@@ -1862,13 +1861,13 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t     | endloop_1\n \t     In this case, the dependence is carried by loop_1.  */\n \t  loop_nb = loop_nb_a < loop_nb_b ? loop_nb_a : loop_nb_b;\n-\t  loop_nb -= first_loop;\n+\t  loop_depth = current_loops->parray[loop_nb]->depth - first_loop_depth;\n \n \t  /* If the loop number is still greater than the number of\n \t     loops we've been asked to analyze, or negative,\n \t     something is borked.  */\n-\t  gcc_assert (loop_nb >= 0);\n-\t  gcc_assert (loop_nb < nb_loops);\n+\t  gcc_assert (loop_depth >= 0);\n+\t  gcc_assert (loop_depth < nb_loops);\n \t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t    {\n \t      non_affine_dependence_relation (ddr);\n@@ -1883,15 +1882,15 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t     |   ... = T[i][i]\n \t     | endloop\n \t     There is no dependence.  */\n-\t  if (init_v[loop_nb] != 0\n-\t      && dist_v[loop_nb] != dist)\n+\t  if (init_v[loop_depth] != 0\n+\t      && dist_v[loop_depth] != dist)\n \t    {\n \t      finalize_ddr_dependent (ddr, chrec_known);\n \t      return true;\n \t    }\n \n-\t  dist_v[loop_nb] = dist;\n-\t  init_v[loop_nb] = 1;\n+\t  dist_v[loop_depth] = dist;\n+\t  init_v[loop_depth] = 1;\n \t}\n     }\n   \n@@ -1906,43 +1905,43 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n     struct loop *lca, *loop_a, *loop_b;\n     struct data_reference *a = DDR_A (ddr);\n     struct data_reference *b = DDR_B (ddr);\n-    int lca_nb;\n+    int lca_depth;\n     loop_a = loop_containing_stmt (DR_STMT (a));\n     loop_b = loop_containing_stmt (DR_STMT (b));\n     \n     /* Get the common ancestor loop.  */\n     lca = find_common_loop (loop_a, loop_b); \n     \n-    lca_nb = lca->num;\n-    lca_nb -= first_loop;\n-    gcc_assert (lca_nb >= 0);\n-    gcc_assert (lca_nb < nb_loops);\n+    lca_depth = lca->depth;\n+    lca_depth -= first_loop_depth;\n+    gcc_assert (lca_depth >= 0);\n+    gcc_assert (lca_depth < nb_loops);\n \n     /* For each outer loop where init_v is not set, the accesses are\n        in dependence of distance 1 in the loop.  */\n     if (lca != loop_a\n \t&& lca != loop_b\n-\t&& init_v[lca_nb] == 0)\n-      dist_v[lca_nb] = 1;\n+\t&& init_v[lca_depth] == 0)\n+      dist_v[lca_depth] = 1;\n     \n     lca = lca->outer;\n     \n     if (lca)\n       {\n-\tlca_nb = lca->num - first_loop;\n+\tlca_depth = lca->depth - first_loop_depth;\n \twhile (lca->depth != 0)\n \t  {\n \t    /* If we're considering just a sub-nest, then don't record\n \t       any information on the outer loops.  */\n-\t    if (lca_nb < 0)\n+\t    if (lca_depth < 0)\n \t      break;\n \n-\t    gcc_assert (lca_nb < nb_loops);\n+\t    gcc_assert (lca_depth < nb_loops);\n \n-\t    if (init_v[lca_nb] == 0)\n-\t      dist_v[lca_nb] = 1;\n+\t    if (init_v[lca_depth] == 0)\n+\t      dist_v[lca_depth] = 1;\n \t    lca = lca->outer;\n-\t    lca_nb = lca->num - first_loop;\n+\t    lca_depth = lca->depth - first_loop_depth;\n \t  \n \t  }\n       }\n@@ -1957,15 +1956,15 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \n    DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n-   FIRST_LOOP is the loop->num of the first loop in the analyzed \n+   FIRST_LOOP_DEPTH is the loop->depth of the first loop in the analyzed \n    loop nest.\n    Return FALSE if the dependence relation is outside of the loop nest\n-   starting with FIRST_LOOP. \n+   at FIRST_LOOP_DEPTH. \n    Return TRUE otherwise.  */\n \n static bool\n build_classic_dir_vector (struct data_dependence_relation *ddr, \n-\t\t\t  int nb_loops, unsigned int first_loop)\n+\t\t\t  int nb_loops, int first_loop_depth)\n {\n   unsigned i;\n   lambda_vector dir_v, init_v;\n@@ -1994,20 +1993,19 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n       if (TREE_CODE (access_fn_a) == POLYNOMIAL_CHREC\n \t  && TREE_CODE (access_fn_b) == POLYNOMIAL_CHREC)\n \t{\n-\t  int dist, loop_nb;\n+\t  int dist, loop_nb, loop_depth;\n \t  enum data_dependence_direction dir = dir_star;\n \t  int loop_nb_a = CHREC_VARIABLE (access_fn_a);\n \t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n \t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n \t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n-\t  struct loop *loop_first = current_loops->parray[first_loop];\n  \n \t  /* If the loop for either variable is at a lower depth than \n \t     the first_loop's depth, then we can't possibly have a\n \t     dependency at this level of the loop.  */\n \t     \n-\t  if (loop_a->depth < loop_first->depth\n-\t      || loop_b->depth < loop_first->depth)\n+\t  if (loop_a->depth < first_loop_depth\n+\t      || loop_b->depth < first_loop_depth)\n \t    return false;\n \n \t  if (loop_nb_a != loop_nb_b\n@@ -2038,13 +2036,13 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t     | endloop_1\n \t     In this case, the dependence is carried by loop_1.  */\n \t  loop_nb = loop_nb_a < loop_nb_b ? loop_nb_a : loop_nb_b;\n-\t  loop_nb -= first_loop;\n+\t  loop_depth = current_loops->parray[loop_nb]->depth - first_loop_depth;\n \n \t  /* If the loop number is still greater than the number of\n \t     loops we've been asked to analyze, or negative,\n \t     something is borked.  */\n-\t  gcc_assert (loop_nb >= 0);\n-\t  gcc_assert (loop_nb < nb_loops);\n+\t  gcc_assert (loop_depth >= 0);\n+\t  gcc_assert (loop_depth < nb_loops);\n \n \t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t    {\n@@ -2067,17 +2065,17 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t     |   ... = T[i][i]\n \t     | endloop\n \t     There is no dependence.  */\n-\t  if (init_v[loop_nb] != 0\n+\t  if (init_v[loop_depth] != 0\n \t      && dir != dir_star\n-\t      && (enum data_dependence_direction) dir_v[loop_nb] != dir\n-\t      && (enum data_dependence_direction) dir_v[loop_nb] != dir_star)\n+\t      && (enum data_dependence_direction) dir_v[loop_depth] != dir\n+\t      && (enum data_dependence_direction) dir_v[loop_depth] != dir_star)\n \t    {\n \t      finalize_ddr_dependent (ddr, chrec_known);\n \t      return true;\n \t    }\n \t  \n-\t  dir_v[loop_nb] = dir;\n-\t  init_v[loop_nb] = 1;\n+\t  dir_v[loop_depth] = dir;\n+\t  init_v[loop_depth] = 1;\n \t}\n     }\n   \n@@ -2092,41 +2090,41 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n     struct loop *lca, *loop_a, *loop_b;\n     struct data_reference *a = DDR_A (ddr);\n     struct data_reference *b = DDR_B (ddr);\n-    int lca_nb;\n+    int lca_depth;\n     loop_a = loop_containing_stmt (DR_STMT (a));\n     loop_b = loop_containing_stmt (DR_STMT (b));\n     \n     /* Get the common ancestor loop.  */\n     lca = find_common_loop (loop_a, loop_b); \n-    lca_nb = lca->num - first_loop;\n+    lca_depth = lca->depth - first_loop_depth;\n \n-    gcc_assert (lca_nb >= 0);\n-    gcc_assert (lca_nb < nb_loops);\n+    gcc_assert (lca_depth >= 0);\n+    gcc_assert (lca_depth < nb_loops);\n \n     /* For each outer loop where init_v is not set, the accesses are\n        in dependence of distance 1 in the loop.  */\n     if (lca != loop_a\n \t&& lca != loop_b\n-\t&& init_v[lca_nb] == 0)\n-      dir_v[lca_nb] = dir_positive;\n+\t&& init_v[lca_depth] == 0)\n+      dir_v[lca_depth] = dir_positive;\n     \n     lca = lca->outer;\n     if (lca)\n       {\n-\tlca_nb = lca->num - first_loop;\n+\tlca_depth = lca->depth - first_loop_depth;\n \twhile (lca->depth != 0)\n \t  {\n \t    /* If we're considering just a sub-nest, then don't record\n \t       any information on the outer loops.  */\n-\t    if (lca_nb < 0)\n+\t    if (lca_depth < 0)\n \t      break;\n \n-\t    gcc_assert (lca_nb < nb_loops);\n+\t    gcc_assert (lca_depth < nb_loops);\n \n-\t    if (init_v[lca_nb] == 0)\n-\t      dir_v[lca_nb] = dir_positive;\n+\t    if (init_v[lca_depth] == 0)\n+\t      dir_v[lca_depth] = dir_positive;\n \t    lca = lca->outer;\n-\t    lca_nb = lca->num - first_loop;\n+\t    lca_depth = lca->depth - first_loop_depth;\n \t   \n \t  }\n       }\n@@ -2330,8 +2328,8 @@ compute_data_dependences_for_loop (unsigned nb_loops,\n \t chrec_dont_know.  */\n       ddr = initialize_data_dependence_relation (NULL, NULL);\n       VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-      build_classic_dist_vector (ddr, nb_loops, loop->num);\n-      build_classic_dir_vector (ddr, nb_loops, loop->num);\n+      build_classic_dist_vector (ddr, nb_loops, loop->depth);\n+      build_classic_dir_vector (ddr, nb_loops, loop->depth);\n       return;\n     }\n \n@@ -2342,10 +2340,10 @@ compute_data_dependences_for_loop (unsigned nb_loops,\n     {\n       struct data_dependence_relation *ddr;\n       ddr = VARRAY_GENERIC_PTR (allrelations, i);\n-      if (build_classic_dist_vector (ddr, nb_loops, loop->num))\n+      if (build_classic_dist_vector (ddr, nb_loops, loop->depth))\n \t{\n \t  VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-\t  build_classic_dir_vector (ddr, nb_loops, loop->num);\n+\t  build_classic_dir_vector (ddr, nb_loops, loop->depth);\n \t}\n     }\n }"}, {"sha": "8309789d0946990123131a6cda515a5606b0afff", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f24dd474e4e3d676684d7ec022b35350d4c4a0e/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=1f24dd474e4e3d676684d7ec022b35350d4c4a0e", "patch": "@@ -55,19 +55,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    transform matrix for locality purposes.\n    TODO: Completion of partial transforms.  */\n \n-/* Gather statistics for loop interchange.  LOOP_NUMBER is a relative\n-   index in the considered loop nest.  The first loop in the\n-   considered loop nest is FIRST_LOOP, and consequently the index of\n-   the considered loop is obtained by FIRST_LOOP + LOOP_NUMBER.\n+/* Gather statistics for loop interchange.  LOOP is the loop being\n+   considered. The first loop in the considered loop nest is\n+   FIRST_LOOP, and consequently, the index of the considered loop is\n+   obtained by LOOP->DEPTH - FIRST_LOOP->DEPTH\n    \n    Initializes:\n    - DEPENDENCE_STEPS the sum of all the data dependence distances\n-   carried by loop LOOP_NUMBER,\n+   carried by loop LOOP,\n \n    - NB_DEPS_NOT_CARRIED_BY_LOOP the number of dependence relations\n-   for which the loop LOOP_NUMBER is not carrying any dependence,\n+   for which the loop LOOP is not carrying any dependence,\n \n-   - ACCESS_STRIDES the sum of all the strides in LOOP_NUMBER.\n+   - ACCESS_STRIDES the sum of all the strides in LOOP.\n \n    Example: for the following loop,\n \n@@ -93,8 +93,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static void\n gather_interchange_stats (varray_type dependence_relations, \n \t\t\t  varray_type datarefs,\n-\t\t\t  unsigned int loop_number, \n-\t\t\t  unsigned int first_loop,\n+\t\t\t  struct loop *loop,\n+\t\t\t  struct loop *first_loop,\n \t\t\t  unsigned int *dependence_steps, \n \t\t\t  unsigned int *nb_deps_not_carried_by_loop, \n \t\t\t  unsigned int *access_strides)\n@@ -123,7 +123,7 @@ gather_interchange_stats (varray_type dependence_relations,\n       \n \n       \n-      dist = DDR_DIST_VECT (ddr)[loop_number];\n+      dist = DDR_DIST_VECT (ddr)[loop->depth - first_loop->depth];\n       if (dist == 0)\n \t(*nb_deps_not_carried_by_loop) += 1;\n       else if (dist < 0)\n@@ -139,17 +139,16 @@ gather_interchange_stats (varray_type dependence_relations,\n       struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n       tree stmt = DR_STMT (dr);\n       struct loop *stmt_loop = loop_containing_stmt (stmt);\n-      struct loop *inner_loop = current_loops->parray[first_loop + 1];\n-\n-      if (!flow_loop_nested_p (inner_loop, stmt_loop)\n-\t  && inner_loop->num != stmt_loop->num)\n+      struct loop *inner_loop = first_loop->inner;\n+      \n+      if (inner_loop != stmt_loop \n+\t  && !flow_loop_nested_p (inner_loop, stmt_loop))\n \tcontinue;\n-\n       for (it = 0; it < DR_NUM_DIMENSIONS (dr); it++)\n \t{\n \t  tree chrec = DR_ACCESS_FN (dr, it);\n \t  tree tstride = evolution_part_in_loop_num \n-\t    (chrec, first_loop + loop_number);\n+\t    (chrec, loop->num);\n \t  \n \t  if (tstride == NULL_TREE\n \t      || TREE_CODE (tstride) != INTEGER_CST)\n@@ -173,9 +172,10 @@ try_interchange_loops (lambda_trans_matrix trans,\n \t\t       unsigned int depth,\t\t       \n \t\t       varray_type dependence_relations,\n \t\t       varray_type datarefs, \n-\t\t       unsigned int first_loop)\n+\t\t       struct loop *first_loop)\n {\n-  unsigned int loop_i, loop_j;\n+  struct loop *loop_i;\n+  struct loop *loop_j;\n   unsigned int dependence_steps_i, dependence_steps_j;\n   unsigned int access_strides_i, access_strides_j;\n   unsigned int nb_deps_not_carried_by_i, nb_deps_not_carried_by_j;\n@@ -189,8 +189,12 @@ try_interchange_loops (lambda_trans_matrix trans,\n     return trans;\n   \n   /* LOOP_I is always the outer loop.  */\n-  for (loop_j = 1; loop_j < depth; loop_j++)\n-    for (loop_i = 0; loop_i < loop_j; loop_i++)\n+  for (loop_j = first_loop->inner; \n+       loop_j; \n+       loop_j = loop_j->inner)\n+    for (loop_i = first_loop; \n+\t loop_i->depth < loop_j->depth; \n+\t loop_i = loop_i->inner)\n       {\n \tgather_interchange_stats (dependence_relations, datarefs,\n \t\t\t\t  loop_i, first_loop,\n@@ -218,11 +222,15 @@ try_interchange_loops (lambda_trans_matrix trans,\n \t    || nb_deps_not_carried_by_i > nb_deps_not_carried_by_j\n \t    || access_strides_i < access_strides_j)\n \t  {\n-\t    lambda_matrix_row_exchange (LTM_MATRIX (trans), loop_i, loop_j);\n+\t    lambda_matrix_row_exchange (LTM_MATRIX (trans),\n+\t\t\t\t\tloop_i->depth - first_loop->depth,\n+\t\t\t\t\tloop_j->depth - first_loop->depth);\n \t    /* Validate the resulting matrix.  When the transformation\n \t       is not valid, reverse to the previous transformation.  */\n \t    if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n-\t      lambda_matrix_row_exchange (LTM_MATRIX (trans), loop_i, loop_j);\n+\t      lambda_matrix_row_exchange (LTM_MATRIX (trans), \n+\t\t\t\t\t  loop_i->depth - first_loop->depth, \n+\t\t\t\t\t  loop_j->depth - first_loop->depth);\n \t  }\n       }\n \n@@ -318,7 +326,7 @@ linear_transform_loops (struct loops *loops)\n       lambda_matrix_id (LTM_MATRIX (trans), depth);\n \n       trans = try_interchange_loops (trans, depth, dependence_relations,\n-\t\t\t\t     datarefs, loop_nest->num);\n+\t\t\t\t     datarefs, loop_nest);\n \n       if (lambda_trans_matrix_id_p (trans))\n \t{"}]}