{"sha": "9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0MGIyZmE4N2NjOTY1N2RjYTJiNjNkYzY2ZDM3Zjk0ZDJjOWNiOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2014-10-22T12:02:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-10-22T12:02:11Z"}, "message": "md.texi: Document \"preferred_for_size\" and \"preferred_for_speed\" attributes.\n\ngcc/\n\t* doc/md.texi: Document \"preferred_for_size\" and \"preferred_for_speed\"\n\tattributes.\n\t* genattr.c (main): Handle \"preferred_for_size\" and\n\t\"preferred_for_speed\" in the same way as \"enabled\".\n\t* recog.h (bool_attr): New enum.\n\t(target_recog): Replace x_enabled_alternatives with x_bool_attr_masks.\n\t(get_preferred_alternatives, check_bool_attrs): Declare.\n\t* recog.c (have_bool_attr, get_bool_attr, get_bool_attr_mask_uncached)\n\t(get_bool_attr_mask, get_preferred_alternatives, check_bool_attrs):\n\tNew functions.\n\t(get_enabled_alternatives): Use get_bool_attr_mask.\n\t* ira-costs.c (record_reg_classes): Use get_preferred_alternatives\n\tinstead of recog_data.enabled_alternatives.\n\t* ira.c (ira_setup_alts): Likewise.\n\t* postreload.c (reload_cse_simplify_operands): Likewise.\n\t* config/i386/i386.c (ix86_legitimate_combined_insn): Likewise.\n\t* ira-lives.c (preferred_alternatives): New variable.\n\t(process_bb_node_lives): Set it.\n\t(check_and_make_def_conflict, make_early_clobber_and_input_conflicts)\n\t(single_reg_class, ira_implicitly_set_insn_hard_regs): Use it instead\n\tof recog_data.enabled_alternatives.\n\t* lra-int.h (lra_insn_recog_data): Replace enabled_alternatives\n\tto preferred_alternatives.\n\t* lra-constraints.c (process_alt_operands): Update accordingly.\n\t* lra.c (lra_set_insn_recog_data): Likewise.\n\t(lra_update_insn_recog_data): Assert check_bool_attrs.\n\nFrom-SVN: r216554", "tree": {"sha": "69a28087e5d6c8f66821aa2540f8d19983b792eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69a28087e5d6c8f66821aa2540f8d19983b792eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75d25a02fcd6d85c314700b5b2e03743f1bec04a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d25a02fcd6d85c314700b5b2e03743f1bec04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d25a02fcd6d85c314700b5b2e03743f1bec04a"}], "stats": {"total": 335, "additions": 229, "deletions": 106}, "files": [{"sha": "c3d8f810741956a101ebdfcc083cf425d01ff93c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -1,3 +1,32 @@\n+2014-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/md.texi: Document \"preferred_for_size\" and \"preferred_for_speed\"\n+\tattributes.\n+\t* genattr.c (main): Handle \"preferred_for_size\" and\n+\t\"preferred_for_speed\" in the same way as \"enabled\".\n+\t* recog.h (bool_attr): New enum.\n+\t(target_recog): Replace x_enabled_alternatives with x_bool_attr_masks.\n+\t(get_preferred_alternatives, check_bool_attrs): Declare.\n+\t* recog.c (have_bool_attr, get_bool_attr, get_bool_attr_mask_uncached)\n+\t(get_bool_attr_mask, get_preferred_alternatives, check_bool_attrs):\n+\tNew functions.\n+\t(get_enabled_alternatives): Use get_bool_attr_mask.\n+\t* ira-costs.c (record_reg_classes): Use get_preferred_alternatives\n+\tinstead of recog_data.enabled_alternatives.\n+\t* ira.c (ira_setup_alts): Likewise.\n+\t* postreload.c (reload_cse_simplify_operands): Likewise.\n+\t* config/i386/i386.c (ix86_legitimate_combined_insn): Likewise.\n+\t* ira-lives.c (preferred_alternatives): New variable.\n+\t(process_bb_node_lives): Set it.\n+\t(check_and_make_def_conflict, make_early_clobber_and_input_conflicts)\n+\t(single_reg_class, ira_implicitly_set_insn_hard_regs): Use it instead\n+\tof recog_data.enabled_alternatives.\n+\t* lra-int.h (lra_insn_recog_data): Replace enabled_alternatives\n+\tto preferred_alternatives.\n+\t* lra-constraints.c (process_alt_operands): Update accordingly.\n+\t* lra.c (lra_set_insn_recog_data): Likewise.\n+\t(lra_update_insn_recog_data): Assert check_bool_attrs.\n+\n 2014-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* recog.h (extract_constrain_insn): Declare."}, {"sha": "65b31734d39ce0977ff970aea72eab306b584202", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -5905,10 +5905,10 @@ ix86_legitimate_combined_insn (rtx_insn *insn)\n \t  /* Operand has no constraints, anything is OK.  */\n  \t  win = !n_alternatives;\n \n-\t  alternative_mask enabled = recog_data.enabled_alternatives;\n+\t  alternative_mask preferred = get_preferred_alternatives (insn);\n \t  for (j = 0; j < n_alternatives; j++, op_alt += n_operands)\n \t    {\n-\t      if (!TEST_BIT (enabled, j))\n+\t      if (!TEST_BIT (preferred, j))\n \t\tcontinue;\n \t      if (op_alt[i].anything_ok\n \t\t  || (op_alt[i].matches != -1"}, {"sha": "1d16e2947114a9bcc4b46c9e84c1cb5ac9045e9c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -1080,7 +1080,7 @@ the addressing register.\n * Class Preferences::   Constraints guide which hard register to put things in.\n * Modifiers::           More precise control over effects of constraints.\n * Machine Constraints:: Existing constraints for some particular machines.\n-* Disable Insn Alternatives:: Disable insn alternatives using the @code{enabled} attribute.\n+* Disable Insn Alternatives:: Disable insn alternatives using attributes.\n * Define Constraints::  How to define machine-specific constraints.\n * C Constraint Interface:: How to test constraints from C code.\n @end menu\n@@ -4006,42 +4006,49 @@ Unsigned constant valid for BccUI instructions\n @subsection Disable insn alternatives using the @code{enabled} attribute\n @cindex enabled\n \n-The @code{enabled} insn attribute may be used to disable insn\n-alternatives that are not available for the current subtarget.\n-This is useful when adding new instructions to an existing pattern\n-which are only available for certain cpu architecture levels as\n-specified with the @code{-march=} option.\n+There are three insn attributes that may be used to selectively disable\n+instruction alternatives:\n \n-If an insn alternative is disabled, then it will never be used.  The\n-compiler treats the constraints for the disabled alternative as\n-unsatisfiable.\n+@table @code\n+@item enabled\n+Says whether an alternative is available on the current subtarget.\n \n-In order to make use of the @code{enabled} attribute a back end has to add\n-in the machine description files:\n+@item preferred_for_size\n+Says whether an enabled alternative should be used in code that is\n+optimized for size.\n \n-@enumerate\n-@item\n-A definition of the @code{enabled} insn attribute.  The attribute is\n-defined as usual using the @code{define_attr} command.  This\n-definition should be based on other insn attributes and/or target flags.\n-The attribute must be a static property of the subtarget; that is, it\n-must not depend on the current operands or any other dynamic context\n-(for example, the location of the insn within the body of a loop).\n-\n-The @code{enabled} attribute is a numeric attribute and should evaluate to\n-@code{(const_int 1)} for an enabled alternative and to\n-@code{(const_int 0)} otherwise.\n-@item\n-A definition of another insn attribute used to describe for what\n-reason an insn alternative might be available or\n-not.  E.g. @code{cpu_facility} as in the example below.\n-@item\n-An assignment for the second attribute to each insn definition\n-combining instructions which are not all available under the same\n-circumstances.  (Note: It obviously only makes sense for definitions\n-with more than one alternative.  Otherwise the insn pattern should be\n-disabled or enabled using the insn condition.)\n-@end enumerate\n+@item preferred_for_speed\n+Says whether an enabled alternative should be used in code that is\n+optimized for speed.\n+@end table\n+\n+All these attributes should use @code{(const_int 1)} to allow an alternative\n+or @code{(const_int 0)} to disallow it.  The attributes must be a static\n+property of the subtarget; they cannot for example depend on the\n+current operands, on the current optimization level, on the location\n+of the insn within the body of a loop, on whether register allocation\n+has finished, or on the current compiler pass.\n+\n+The @code{enabled} attribute is a correctness property.  It tells GCC to act\n+as though the disabled alternatives were never defined in the first place.\n+This is useful when adding new instructions to an existing pattern in\n+cases where the new instructions are only available for certain cpu\n+architecture levels (typically mapped to the @code{-march=} command-line\n+option).\n+\n+In contrast, the @code{preferred_for_size} and @code{preferred_for_speed}\n+attributes are strong optimization hints rather than correctness properties.\n+@code{preferred_for_size} tells GCC which alternatives to consider when\n+adding or modifying an instruction that GCC wants to optimize for size.\n+@code{preferred_for_speed} does the same thing for speed.  Note that things\n+like code motion can lead to cases where code optimized for size uses\n+alternatives that are not preferred for size, and similarly for speed.\n+\n+Although @code{define_insn}s can in principle specify the @code{enabled}\n+attribute directly, it is often clearer to have subsiduary attributes\n+for each architectural feature of interest.  The @code{define_insn}s\n+can then use these subsiduary attributes to say which alternatives\n+require which features.  The example below does this for @code{cpu_facility}.\n \n E.g. the following two patterns could easily be merged using the @code{enabled}\n attribute:"}, {"sha": "8c45979bb49323ba461ee7215159fad8304e61d5", "filename": "gcc/genattr.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -338,7 +338,9 @@ main (int argc, char **argv)\n     }\n \n   /* Special-purpose attributes should be tested with if, not #ifdef.  */\n-  const char * const special_attrs[] = { \"length\", \"enabled\", 0 };\n+  const char * const special_attrs[] = { \"length\", \"enabled\",\n+\t\t\t\t\t \"preferred_for_size\",\n+\t\t\t\t\t \"preferred_for_speed\", 0 };\n   for (const char * const *p = special_attrs; *p; p++)\n     {\n       printf (\"#ifndef HAVE_ATTR_%s\\n\"\n@@ -355,9 +357,15 @@ main (int argc, char **argv)\n \t\"#define insn_current_length hook_int_rtx_insn_unreachable\\n\"\n \t\"#include \\\"insn-addr.h\\\"\\n\"\n \t\"#endif\\n\"\n-\t\"#if !HAVE_ATTR_enabled\\n\"\n \t\"extern int hook_int_rtx_1 (rtx);\\n\"\n+\t\"#if !HAVE_ATTR_enabled\\n\"\n \t\"#define get_attr_enabled hook_int_rtx_1\\n\"\n+\t\"#endif\\n\"\n+\t\"#if !HAVE_ATTR_preferred_for_size\\n\"\n+\t\"#define get_attr_preferred_for_size hook_int_rtx_1\\n\"\n+\t\"#endif\\n\"\n+\t\"#if !HAVE_ATTR_preferred_for_speed\\n\"\n+\t\"#define get_attr_preferred_for_speed hook_int_rtx_1\\n\"\n \t\"#endif\\n\");\n \n   /* Output flag masks for use by reorg."}, {"sha": "8b6c9f9047d999306670b068d34089ddcb15439f", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -416,6 +416,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \n   /* Process each alternative, each time minimizing an operand's cost\n      with the cost for each operand in that alternative.  */\n+  alternative_mask preferred = get_preferred_alternatives (insn);\n   for (alt = 0; alt < n_alts; alt++)\n     {\n       enum reg_class classes[MAX_RECOG_OPERANDS];\n@@ -424,7 +425,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       int alt_fail = 0;\n       int alt_cost = 0, op_cost_add;\n \n-      if (!TEST_BIT (recog_data.enabled_alternatives, alt))\n+      if (!TEST_BIT (preferred, alt))\n \t{\n \t  for (i = 0; i < recog_data.n_operands; i++)\n \t    constraints[i] = skip_alternative (constraints[i]);"}, {"sha": "1c9f8841dfeb474f2372f3b54a7a5cd14efaab9d", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -85,6 +85,10 @@ static int last_call_num;\n /* The number of last call at which given allocno was saved.  */\n static int *allocno_saved_at_call;\n \n+/* The value of get_preferred_alternatives for the current instruction,\n+   supplemental to recog_data.  */\n+static alternative_mask preferred_alternatives;\n+\n /* Record the birth of hard register REGNO, updating hard_regs_live and\n    hard reg conflict information for living allocnos.  */\n static void\n@@ -641,10 +645,9 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n       /* If there's any alternative that allows USE to match DEF, do not\n \t record a conflict.  If that causes us to create an invalid\n \t instruction due to the earlyclobber, reload must fix it up.  */\n-      alternative_mask enabled = recog_data.enabled_alternatives;\n       for (alt1 = 0; alt1 < recog_data.n_alternatives; alt1++)\n \t{\n-\t  if (!TEST_BIT (enabled, alt1))\n+\t  if (!TEST_BIT (preferred_alternatives, alt1))\n \t    continue;\n \t  const operand_alternative *op_alt1\n \t    = &recog_op_alt[alt1 * n_operands];\n@@ -692,10 +695,9 @@ make_early_clobber_and_input_conflicts (void)\n \n   int n_alternatives = recog_data.n_alternatives;\n   int n_operands = recog_data.n_operands;\n-  alternative_mask enabled = recog_data.enabled_alternatives;\n   const operand_alternative *op_alt = recog_op_alt;\n   for (alt = 0; alt < n_alternatives; alt++, op_alt += n_operands)\n-    if (TEST_BIT (enabled, alt))\n+    if (TEST_BIT (preferred_alternatives, alt))\n       for (def = 0; def < n_operands; def++)\n \t{\n \t  def_cl = NO_REGS;\n@@ -762,13 +764,13 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n   enum constraint_num cn;\n \n   cl = NO_REGS;\n-  alternative_mask enabled = recog_data.enabled_alternatives;\n+  alternative_mask preferred = preferred_alternatives;\n   for (; (c = *constraints); constraints += CONSTRAINT_LEN (c, constraints))\n     if (c == '#')\n-      enabled &= ~ALTERNATIVE_BIT (0);\n+      preferred &= ~ALTERNATIVE_BIT (0);\n     else if (c == ',')\n-      enabled >>= 1;\n-    else if (enabled & 1)\n+      preferred >>= 1;\n+    else if (preferred & 1)\n       switch (c)\n \t{\n \tcase 'g':\n@@ -851,13 +853,13 @@ ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n \t  mode = (GET_CODE (op) == SCRATCH\n \t\t  ? GET_MODE (op) : PSEUDO_REGNO_MODE (regno));\n \t  cl = NO_REGS;\n-\t  alternative_mask enabled = recog_data.enabled_alternatives;\n+\t  alternative_mask preferred = preferred_alternatives;\n \t  for (; (c = *p); p += CONSTRAINT_LEN (c, p))\n \t    if (c == '#')\n-\t      enabled &= ~ALTERNATIVE_BIT (0);\n+\t      preferred &= ~ALTERNATIVE_BIT (0);\n \t    else if (c == ',')\n-\t      enabled >>= 1;\n-\t    else if (enabled & 1)\n+\t      preferred >>= 1;\n+\t    else if (preferred & 1)\n \t      {\n \t\tcl = reg_class_for_constraint (lookup_constraint (p));\n \t\tif (cl != NO_REGS)\n@@ -1174,6 +1176,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      }\n \n \t  extract_insn (insn);\n+\t  preferred_alternatives = get_preferred_alternatives (insn);\n \t  preprocess_constraints (insn);\n \t  process_single_reg_class_operands (false, freq);\n "}, {"sha": "1bdc44612dbb75e7bffda60038d02682a9872fb7", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -1788,6 +1788,7 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n   int commutative = -1;\n \n   extract_insn (insn);\n+  alternative_mask preferred = get_preferred_alternatives (insn);\n   CLEAR_HARD_REG_SET (alts);\n   insn_constraints.release ();\n   insn_constraints.safe_grow_cleared (recog_data.n_operands\n@@ -1817,7 +1818,7 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n \t}\n       for (nalt = 0; nalt < recog_data.n_alternatives; nalt++)\n \t{\n-\t  if (!TEST_BIT (recog_data.enabled_alternatives, nalt)\n+\t  if (!TEST_BIT (preferred, nalt)\n \t      || TEST_HARD_REG_BIT (alts, nalt))\n \t    continue;\n "}, {"sha": "7f9f3178507a2a3139f0a8306fac6c50367b42a6", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -1685,14 +1685,14 @@ process_alt_operands (int only_alternative)\n      together, the second alternatives go together, etc.\n \n      First loop over alternatives.  */\n-  alternative_mask enabled = curr_id->enabled_alternatives;\n+  alternative_mask preferred = curr_id->preferred_alternatives;\n   if (only_alternative >= 0)\n-    enabled &= ALTERNATIVE_BIT (only_alternative);\n+    preferred &= ALTERNATIVE_BIT (only_alternative);\n \n   for (nalt = 0; nalt < n_alternatives; nalt++)\n     {\n       /* Loop over operands for one constraint alternative.  */\n-      if (!TEST_BIT (enabled, nalt))\n+      if (!TEST_BIT (preferred, nalt))\n \tcontinue;\n \n       overall = losers = reject = reload_nregs = reload_sum = 0;"}, {"sha": "8bd45b207b54ae219006e6969af1cfe499e41005", "filename": "gcc/lra-int.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -233,8 +233,8 @@ struct lra_insn_recog_data\n      value can be NULL or points to array of the hard register numbers\n      ending with a negative value.  */\n   int *arg_hard_regs;\n-  /* Alternative enabled for the insn.\tNULL for debug insns.  */\n-  alternative_mask enabled_alternatives;\n+  /* Cached value of get_preferred_alternatives.  */\n+  alternative_mask preferred_alternatives;\n   /* The following member value is always NULL for a debug insn.  */\n   struct lra_insn_reg *regs;\n };"}, {"sha": "22226361e64a3e1c8a56501d3eef8cf936fc0a7b", "filename": "gcc/lra.c", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -921,7 +921,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n       data->insn_static_data = &debug_insn_static_data;\n       data->dup_loc = NULL;\n       data->arg_hard_regs = NULL;\n-      data->enabled_alternatives = ALL_ALTERNATIVES;\n+      data->preferred_alternatives = ALL_ALTERNATIVES;\n       data->operand_loc = XNEWVEC (rtx *, 1);\n       data->operand_loc[0] = &INSN_VAR_LOCATION_LOC (insn);\n       return data;\n@@ -981,7 +981,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n \t  = (insn_static_data->operand[i].constraint[0] == '=' ? OP_OUT\n \t     : insn_static_data->operand[i].constraint[0] == '+' ? OP_INOUT\n \t     : OP_IN);\n-      data->enabled_alternatives = ALL_ALTERNATIVES;\n+      data->preferred_alternatives = ALL_ALTERNATIVES;\n       if (nop > 0)\n \t{\n \t  operand_alternative *op_alt = XCNEWVEC (operand_alternative,\n@@ -1015,7 +1015,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n \t  memcpy (locs, recog_data.dup_loc, n * sizeof (rtx *));\n \t}\n       data->dup_loc = locs;\n-      data->enabled_alternatives = get_enabled_alternatives (insn);\n+      data->preferred_alternatives = get_preferred_alternatives (insn);\n       const operand_alternative *op_alt = preprocess_insn_constraints (icode);\n       if (!insn_static_data->operand_alternative)\n \tsetup_operand_alternative (data, op_alt);\n@@ -1206,27 +1206,7 @@ lra_update_insn_recog_data (rtx_insn *insn)\n       n = insn_static_data->n_dups;\n       if (n != 0)\n \tmemcpy (data->dup_loc, recog_data.dup_loc, n * sizeof (rtx *));\n-#if HAVE_ATTR_enabled\n-#ifdef ENABLE_CHECKING\n-      {\n-\tint i;\n-\talternative_mask enabled;\n-\n-\tn = insn_static_data->n_alternatives;\n-\tenabled = data->enabled_alternatives;\n-\tlra_assert (n >= 0);\n-\t/* Cache the insn to prevent extract_insn call from\n-\t   get_attr_enabled.  */\n-\trecog_data.insn = insn;\n-\tfor (i = 0; i < n; i++)\n-\t  {\n-\t    which_alternative = i;\n-\t    lra_assert (TEST_BIT (enabled, i)\n-\t\t\t== (bool) get_attr_enabled (insn));\n-\t  }\n-      }\n-#endif\n-#endif\n+      lra_assert (check_bool_attrs (insn));\n     }\n   return data;\n }"}, {"sha": "dcdfedfd920b399b417ccd519402ef88020c15e9", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -497,6 +497,7 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n \t  SET_HARD_REG_BIT (equiv_regs[i], REGNO (l->loc));\n     }\n \n+  alternative_mask preferred = get_preferred_alternatives (insn);\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       enum machine_mode mode;\n@@ -570,7 +571,7 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n \t\t     alternative yet and the operand being replaced is not\n \t\t     a cheap CONST_INT.  */\n \t\t  if (op_alt_regno[i][j] == -1\n-\t\t      && TEST_BIT (recog_data.enabled_alternatives, j)\n+\t\t      && TEST_BIT (preferred, j)\n \t\t      && reg_fits_class_p (testreg, rclass, 0, mode)\n \t\t      && (!CONST_INT_P (recog_data.operand[i])\n \t\t\t  || (set_src_cost (recog_data.operand[i],"}, {"sha": "afcab998124d9f60b377ac581643d775bbed585d", "filename": "gcc/recog.c", "status": "modified", "additions": 105, "deletions": 23, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -2060,46 +2060,128 @@ mode_dependent_address_p (rtx addr, addr_space_t addrspace)\n   return targetm.mode_dependent_address_p (addr, addrspace);\n }\n \f\n-/* Return the mask of operand alternatives that are allowed for INSN.\n-   This mask depends only on INSN and on the current target; it does not\n-   depend on things like the values of operands.  */\n+/* Return true if boolean attribute ATTR is supported.  */\n \n-alternative_mask\n-get_enabled_alternatives (rtx_insn *insn)\n+static bool\n+have_bool_attr (bool_attr attr)\n {\n-  /* Quick exit for asms and for targets that don't use the \"enabled\"\n-     attribute.  */\n-  int code = INSN_CODE (insn);\n-  if (code < 0 || !HAVE_ATTR_enabled)\n-    return ALL_ALTERNATIVES;\n+  switch (attr)\n+    {\n+    case BA_ENABLED:\n+      return HAVE_ATTR_enabled;\n+    case BA_PREFERRED_FOR_SIZE:\n+      return HAVE_ATTR_enabled || HAVE_ATTR_preferred_for_size;\n+    case BA_PREFERRED_FOR_SPEED:\n+      return HAVE_ATTR_enabled || HAVE_ATTR_preferred_for_speed;\n+    }\n+  gcc_unreachable ();\n+}\n \n-  /* Calling get_attr_enabled can be expensive, so cache the mask\n-     for speed.  */\n-  if (this_target_recog->x_enabled_alternatives[code])\n-    return this_target_recog->x_enabled_alternatives[code];\n+/* Return the value of ATTR for instruction INSN.  */\n \n-  /* Temporarily install enough information for get_attr_enabled to assume\n+static bool\n+get_bool_attr (rtx_insn *insn, bool_attr attr)\n+{\n+  switch (attr)\n+    {\n+    case BA_ENABLED:\n+      return get_attr_enabled (insn);\n+    case BA_PREFERRED_FOR_SIZE:\n+      return get_attr_enabled (insn) && get_attr_preferred_for_size (insn);\n+    case BA_PREFERRED_FOR_SPEED:\n+      return get_attr_enabled (insn) && get_attr_preferred_for_speed (insn);\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Like get_bool_attr_mask, but don't use the cache.  */\n+\n+static alternative_mask\n+get_bool_attr_mask_uncached (rtx_insn *insn, bool_attr attr)\n+{\n+  /* Temporarily install enough information for get_attr_<foo> to assume\n      that the insn operands are already cached.  As above, the attribute\n      mustn't depend on the values of operands, so we don't provide their\n      real values here.  */\n   rtx old_insn = recog_data.insn;\n   int old_alternative = which_alternative;\n \n   recog_data.insn = insn;\n-  alternative_mask enabled = ALL_ALTERNATIVES;\n-  int n_alternatives = insn_data[code].n_alternatives;\n+  alternative_mask mask = ALL_ALTERNATIVES;\n+  int n_alternatives = insn_data[INSN_CODE (insn)].n_alternatives;\n   for (int i = 0; i < n_alternatives; i++)\n     {\n       which_alternative = i;\n-      if (!get_attr_enabled (insn))\n-\tenabled &= ~ALTERNATIVE_BIT (i);\n+      if (!get_bool_attr (insn, attr))\n+\tmask &= ~ALTERNATIVE_BIT (i);\n     }\n \n   recog_data.insn = old_insn;\n   which_alternative = old_alternative;\n+  return mask;\n+}\n+\n+/* Return the mask of operand alternatives that are allowed for INSN\n+   by boolean attribute ATTR.  This mask depends only on INSN and on\n+   the current target; it does not depend on things like the values of\n+   operands.  */\n+\n+static alternative_mask\n+get_bool_attr_mask (rtx_insn *insn, bool_attr attr)\n+{\n+  /* Quick exit for asms and for targets that don't use these attributes.  */\n+  int code = INSN_CODE (insn);\n+  if (code < 0 || !have_bool_attr (attr))\n+    return ALL_ALTERNATIVES;\n \n-  this_target_recog->x_enabled_alternatives[code] = enabled;\n-  return enabled;\n+  /* Calling get_attr_<foo> can be expensive, so cache the mask\n+     for speed.  */\n+  if (!this_target_recog->x_bool_attr_masks[code][attr])\n+    this_target_recog->x_bool_attr_masks[code][attr]\n+      = get_bool_attr_mask_uncached (insn, attr);\n+  return this_target_recog->x_bool_attr_masks[code][attr];\n+}\n+\n+/* Return the set of alternatives of INSN that are allowed by the current\n+   target.  */\n+\n+alternative_mask\n+get_enabled_alternatives (rtx_insn *insn)\n+{\n+  return get_bool_attr_mask (insn, BA_ENABLED);\n+}\n+\n+/* Return the set of alternatives of INSN that are allowed by the current\n+   target and are preferred for the current size/speed optimization\n+   choice.  */\n+\n+alternative_mask\n+get_preferred_alternatives (rtx_insn *insn)\n+{\n+  if (optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn)))\n+    return get_bool_attr_mask (insn, BA_PREFERRED_FOR_SPEED);\n+  else\n+    return get_bool_attr_mask (insn, BA_PREFERRED_FOR_SIZE);\n+}\n+\n+/* Assert that the cached boolean attributes for INSN are still accurate.\n+   The backend is required to define these attributes in a way that only\n+   depends on the current target (rather than operands, compiler phase,\n+   etc.).  */\n+\n+bool\n+check_bool_attrs (rtx_insn *insn)\n+{\n+  int code = INSN_CODE (insn);\n+  if (code >= 0)\n+    for (int i = 0; i <= BA_LAST; ++i)\n+      {\n+\tenum bool_attr attr = (enum bool_attr) i;\n+\tif (this_target_recog->x_bool_attr_masks[code][attr])\n+\t  gcc_assert (this_target_recog->x_bool_attr_masks[code][attr]\n+\t\t      == get_bool_attr_mask_uncached (insn, attr));\n+      }\n+  return true;\n }\n \n /* Like extract_insn, but save insn extracted and don't extract again, when\n@@ -4048,8 +4130,8 @@ recog_init ()\n       this_target_recog->x_initialized = true;\n       return;\n     }\n-  memset (this_target_recog->x_enabled_alternatives, 0,\n-\t  sizeof (this_target_recog->x_enabled_alternatives));\n+  memset (this_target_recog->x_bool_attr_masks, 0,\n+\t  sizeof (this_target_recog->x_bool_attr_masks));\n   for (int i = 0; i < LAST_INSN_CODE; ++i)\n     if (this_target_recog->x_op_alt[i])\n       {"}, {"sha": "fe8e0e80e9201a09b70948b6d93d34a4ed2d9de4", "filename": "gcc/recog.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "patch": "@@ -389,10 +389,19 @@ extern int peep2_current_count;\n #ifndef GENERATOR_FILE\n #include \"insn-codes.h\"\n \n+/* An enum of boolean attributes that may only depend on the current\n+   subtarget, not on things like operands or compiler phase.  */\n+enum bool_attr {\n+  BA_ENABLED,\n+  BA_PREFERRED_FOR_SPEED,\n+  BA_PREFERRED_FOR_SIZE,\n+  BA_LAST = BA_PREFERRED_FOR_SIZE\n+};\n+\n /* Target-dependent globals.  */\n struct target_recog {\n   bool x_initialized;\n-  alternative_mask x_enabled_alternatives[LAST_INSN_CODE];\n+  alternative_mask x_bool_attr_masks[LAST_INSN_CODE][BA_LAST + 1];\n   operand_alternative *x_op_alt[LAST_INSN_CODE];\n };\n \n@@ -404,6 +413,8 @@ extern struct target_recog *this_target_recog;\n #endif\n \n alternative_mask get_enabled_alternatives (rtx_insn *);\n+alternative_mask get_preferred_alternatives (rtx_insn *);\n+bool check_bool_attrs (rtx_insn *);\n \n void recog_init ();\n #endif"}]}