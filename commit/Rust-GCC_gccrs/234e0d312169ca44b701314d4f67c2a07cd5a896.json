{"sha": "234e0d312169ca44b701314d4f67c2a07cd5a896", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM0ZTBkMzEyMTY5Y2E0NGI3MDEzMTRkNGY2N2MyYTA3Y2Q1YTg5Ng==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-01-28T10:37:32Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-01-28T10:37:32Z"}, "message": "basic_string.h (_S_create(size_t, const _Alloc&): Change signature to take two size_type arguments.\n\n2004-01-28  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/basic_string.h (_S_create(size_t,\n\tconst _Alloc&): Change signature to take two size_type\n\targuments.\n\t* include/bits/basic_string.tcc (_S_construct(_InIterator,\n\t_InIterator, const _Alloc&, input_iterator_tag)): Update\n\tcall, tweak a bit.\n\t(_S_construct(_InIterator, _InIterator, const _Alloc&,\n\tforward_iterator_tag)): Likewise.\n\t(_S_construct(size_type, _CharT, const _Alloc&)): Likewise.\n\t(_M_mutate(size_type, size_type, size_type)): Don't\n\timplement the exponential growth policy, demand it to\n\t_S_create, update call and simplify.\n\t(_M_clone(const _Alloc&, size_type)): Likewise.\n\t(_S_create(size_type, size_type, const _Alloc&)): Implement\n\tthe growth policy, simplify otherwise.\n\n\t* include/bits/basic_string.h (_Rep::operator[]): Tweak\n\tsignature to take a size_type, consistently with the other\n\tmembers.\n\nFrom-SVN: r76786", "tree": {"sha": "ec59f9b8a30f81398a50bb6d291a5d0d8b9431a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec59f9b8a30f81398a50bb6d291a5d0d8b9431a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/234e0d312169ca44b701314d4f67c2a07cd5a896", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/234e0d312169ca44b701314d4f67c2a07cd5a896", "html_url": "https://github.com/Rust-GCC/gccrs/commit/234e0d312169ca44b701314d4f67c2a07cd5a896", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/234e0d312169ca44b701314d4f67c2a07cd5a896/comments", "author": null, "committer": null, "parents": [{"sha": "220a38ab6e9973dac69fa339127b88b57e44dc9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220a38ab6e9973dac69fa339127b88b57e44dc9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220a38ab6e9973dac69fa339127b88b57e44dc9b"}], "stats": {"total": 138, "additions": 72, "deletions": 66}, "files": [{"sha": "a830353e9f0b7fb992fcd78bf44a4d46e4f8cb1c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234e0d312169ca44b701314d4f67c2a07cd5a896/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234e0d312169ca44b701314d4f67c2a07cd5a896/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=234e0d312169ca44b701314d4f67c2a07cd5a896", "patch": "@@ -1,3 +1,25 @@\n+2004-01-28  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/basic_string.h (_S_create(size_t,\n+\tconst _Alloc&): Change signature to take two size_type\n+\targuments.\n+\t* include/bits/basic_string.tcc (_S_construct(_InIterator,\n+\t_InIterator, const _Alloc&, input_iterator_tag)): Update\n+\tcall, tweak a bit.\n+\t(_S_construct(_InIterator, _InIterator, const _Alloc&,\n+\tforward_iterator_tag)): Likewise.\n+\t(_S_construct(size_type, _CharT, const _Alloc&)): Likewise.\n+\t(_M_mutate(size_type, size_type, size_type)): Don't\n+\timplement the exponential growth policy, demand it to\n+\t_S_create, update call and simplify.\n+\t(_M_clone(const _Alloc&, size_type)): Likewise.\n+\t(_S_create(size_type, size_type, const _Alloc&)): Implement\n+\tthe growth policy, simplify otherwise.\n+\n+\t* include/bits/basic_string.h (_Rep::operator[]): Tweak\n+\tsignature to take a size_type, consistently with the other\n+\tmembers.\n+\t\n 2004-01-27  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/27_io/ios_base/storage/11584.cc: Correct new and"}, {"sha": "b456280a25988a719162f1c239ed34b1325c8393", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234e0d312169ca44b701314d4f67c2a07cd5a896/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234e0d312169ca44b701314d4f67c2a07cd5a896/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=234e0d312169ca44b701314d4f67c2a07cd5a896", "patch": "@@ -198,7 +198,7 @@ namespace std\n \t{ return reinterpret_cast<_CharT*>(this + 1); }\n \n \t_CharT&\n-\toperator[](size_t __s) throw()\n+\toperator[](size_type __s) throw()\n \t{ return _M_refdata() [__s]; }\n \n \t_CharT*\n@@ -210,7 +210,7 @@ namespace std\n \n \t// Create & Destroy\n \tstatic _Rep*\n-\t_S_create(size_t, const _Alloc&);\n+\t_S_create(size_type, size_type, const _Alloc&);\n \n \tvoid\n \t_M_dispose(const _Alloc& __a)"}, {"sha": "80ee245570323e1035d0fe3391706fece260f293", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234e0d312169ca44b701314d4f67c2a07cd5a896/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234e0d312169ca44b701314d4f67c2a07cd5a896/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=234e0d312169ca44b701314d4f67c2a07cd5a896", "patch": "@@ -98,7 +98,7 @@ namespace std\n \t    __buf[__i++] = *__beg; \n \t    ++__beg; \n \t  }\n-\t_Rep* __r = _Rep::_S_create(__i, __a);\n+\t_Rep* __r = _Rep::_S_create(__i, size_type(0), __a);\n \ttraits_type::copy(__r->_M_refdata(), __buf, __i);\n \t__r->_M_length = __i;\n \ttry \n@@ -124,8 +124,8 @@ namespace std\n \t\t    ++__beg;\n \t\t  }\n \t\t// Allocate more space.\n-\t\tconst size_type __len = __p - __r->_M_refdata();\n-\t\t_Rep* __another = _Rep::_S_create(__len + 1, __a);\n+\t\tconst size_type __len = __r->_M_capacity;\n+\t\t_Rep* __another = _Rep::_S_create(__len + 1, __len, __a);\n \t\ttraits_type::copy(__another->_M_refdata(), \n \t\t\t\t  __r->_M_refdata(), __len);\n \t\t__r->_M_destroy(__a);\n@@ -157,9 +157,8 @@ namespace std\n \n \tconst size_type __dnew = static_cast<size_type>(std::distance(__beg,\n \t\t\t\t\t\t\t\t      __end));\n-\t\n \t// Check for out_of_range and length_error exceptions.\n-\t_Rep* __r = _Rep::_S_create(__dnew, __a);\n+\t_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);\n \ttry \n \t  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }\n \tcatch(...) \n@@ -182,7 +181,7 @@ namespace std\n \treturn _S_empty_rep()._M_refdata();\n \n       // Check for out_of_range and length_error exceptions.\n-      _Rep* __r = _Rep::_S_create(__n, __a);\n+      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);\n       if (__n) \n \ttraits_type::assign(__r->_M_refdata(), __n, __c); \n \n@@ -391,12 +390,6 @@ namespace std\n       _M_rep()->_M_set_leaked();\n     }\n \n-  // _M_mutate and, below, _M_clone, include, in the same form, an exponential\n-  // growth policy, necessary to meet amortized linear time requirements of\n-  // the library: see http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n-  // The policy is active for allocations requiring an amount of memory above\n-  // system pagesize. This is consistent with the requirements of the standard:\n-  // see, f.i., http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -412,26 +405,12 @@ namespace std\n \t{\n \t  // Must reallocate.\n \t  const allocator_type __a = get_allocator();\n-\t  // See below (_S_create) for the meaning and value of these\n-\t  // constants.\n-\t  const size_type __pagesize = 4096;\n-\t  const size_type __malloc_header_size = 4 * sizeof (void*);\n-\t  // The biggest string which fits in a memory page\n-\t  const size_type __page_capacity = (__pagesize - __malloc_header_size\n-\t\t\t\t\t     - sizeof(_Rep) - sizeof(_CharT)) \n-\t    \t\t\t\t     / sizeof(_CharT);\n-\t  _Rep* __r;\n-\t  if (__new_size > capacity() && __new_size > __page_capacity)\n-\t    // Growing exponentially.\n-\t    __r = _Rep::_S_create(__new_size > 2*capacity() ?\n-\t\t\t\t  __new_size : 2*capacity(), __a);\n-\t  else\n-\t    __r = _Rep::_S_create(__new_size, __a);\n+\t  _Rep* __r = _Rep::_S_create(__new_size, capacity(), __a);\n \n \t  if (__pos)\n \t    traits_type::copy(__r->_M_refdata(), _M_data(), __pos);\n \t  if (__how_much)\n-\t    traits_type::copy(__r->_M_refdata() + __pos + __len2, \n+\t    traits_type::copy(__r->_M_refdata() + __pos + __len2,\n \t\t\t      __src, __how_much);\n \n \t  _M_rep()->_M_dispose(__a);\n@@ -494,23 +473,20 @@ namespace std\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::_Rep*\n     basic_string<_CharT, _Traits, _Alloc>::_Rep::\n-    _S_create(size_t __capacity, const _Alloc& __alloc)\n+    _S_create(size_type __capacity, size_type __old_capacity,\n+\t      const _Alloc& __alloc)\n     {\n       typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 83.  String::npos vs. string::max_size()\n       if (__capacity > _S_max_size)\n \t__throw_length_error(__N(\"basic_string::_S_create\"));\n \n-      // NB: Need an array of char_type[__capacity], plus a\n-      // terminating null char_type() element, plus enough for the\n-      // _Rep data structure. Whew. Seemingly so needy, yet so elemental.\n-      size_t __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep_base);\n-\n       // The standard places no restriction on allocating more memory\n       // than is strictly needed within this layer at the moment or as\n-      // requested by an explicit application call to reserve().  Many\n-      // malloc implementations perform quite poorly when an\n+      // requested by an explicit application call to reserve().\n+\n+      // Many malloc implementations perform quite poorly when an\n       // application attempts to allocate memory in a stepwise fashion\n       // growing each allocation size by only 1 char.  Additionally,\n       // it makes little sense to allocate less linear memory than the\n@@ -529,24 +505,46 @@ namespace std\n       // low-balling it (especially when this algorithm is used with\n       // malloc implementations that allocate memory blocks rounded up\n       // to a size which is a power of 2).\n-      const size_t __pagesize = 4096; // must be 2^i * __subpagesize\n-      const size_t __subpagesize = 128; // should be >> __malloc_header_size\n-      const size_t __malloc_header_size = 4 * sizeof (void*);\n-      if ((__size + __malloc_header_size) > __pagesize)\n+      const size_type __pagesize = 4096; // must be 2^i * __subpagesize\n+      const size_type __subpagesize = 128; // should be >> __malloc_header_size\n+      const size_type __malloc_header_size = 4 * sizeof (void*);\n+\n+      // The below implements an exponential growth policy, necessary to\n+      // meet amortized linear time requirements of the library: see\n+      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n+      // It's active for allocations requiring an amount of memory above\n+      // system pagesize. This is consistent with the requirements of the\n+      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\n+\n+      // The biggest string which fits in a memory page\n+      const size_type __page_capacity = ((__pagesize - __malloc_header_size\n+\t\t\t\t\t  - sizeof(_Rep) - sizeof(_CharT))\n+\t\t\t\t\t / sizeof(_CharT));\n+      \n+      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity\n+\t  && __capacity > __page_capacity)\n+\t__capacity = 2 * __old_capacity;\n+\n+      // NB: Need an array of char_type[__capacity], plus a terminating\n+      // null char_type() element, plus enough for the _Rep data structure.\n+      // Whew. Seemingly so needy, yet so elemental.\n+      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n+\n+      if (__size + __malloc_header_size > __pagesize)\n \t{\n-\t  const size_t __extra =\n-\t    (__pagesize - ((__size + __malloc_header_size) % __pagesize))\n-\t    % __pagesize;\n+\t  const size_type __extra = (__pagesize\n+\t\t\t\t     - (__size + __malloc_header_size)\n+\t\t\t\t     % __pagesize);\n \t  __capacity += __extra / sizeof(_CharT);\n-\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep_base);\n+\t  __size += __extra;\n \t}\n       else if (__size > __subpagesize)\n \t{\n-\t  const size_t __extra =\n-\t    (__subpagesize - ((__size + __malloc_header_size) % __subpagesize))\n-\t    % __subpagesize;\n+\t  const size_type __extra = (__subpagesize\n+\t\t\t\t     - (__size + __malloc_header_size)\n+\t\t\t\t     % __subpagesize);\n \t  __capacity += __extra / sizeof(_CharT);\n-\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep_base);\n+\t  __size += __extra;\n \t}\n \n       // NB: Might throw, but no worries about a leak, mate: _Rep()\n@@ -566,22 +564,8 @@ namespace std\n     {\n       // Requested capacity of the clone.\n       const size_type __requested_cap = this->_M_length + __res;\n-      // See above (_S_create) for the meaning and value of these constants.\n-      const size_type __pagesize = 4096;\n-      const size_type __malloc_header_size = 4 * sizeof (void*);\n-      // The biggest string which fits in a memory page.\n-      const size_type __page_capacity =\n-        (__pagesize - __malloc_header_size - sizeof(_Rep_base) - sizeof(_CharT))\n-        / sizeof(_CharT);\n-      _Rep* __r;\n-      if (__requested_cap > this->_M_capacity\n-\t  && __requested_cap > __page_capacity)\n-        // Growing exponentially.\n-        __r = _Rep::_S_create(__requested_cap > 2*this->_M_capacity ?\n-                              __requested_cap : 2*this->_M_capacity, __alloc);\n-      else\n-        __r = _Rep::_S_create(__requested_cap, __alloc);\n-\n+      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,\n+\t\t\t\t  __alloc);\n       if (this->_M_length)\n \ttraits_type::copy(__r->_M_refdata(), _M_refdata(),\n \t\t\t  this->_M_length);"}]}