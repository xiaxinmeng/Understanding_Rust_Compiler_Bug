{"sha": "c21644704160710a17d1ea6c1cd212e079cd5e36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIxNjQ0NzA0MTYwNzEwYTE3ZDFlYTZjMWNkMjEyZTA3OWNkNWUzNg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T18:15:50Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T23:28:04Z"}, "message": "Add imports and strengthen the export definition in range_def and gori_map.\n\nAll add up to 2 direct dependencies for each ssa-name.\nAdd gori import/export iterators.\n\n\t* gimple-range-gori.cc (range_def_chain::range_def_chain): init\n\tbitmap obstack.\n\t(range_def_chain::~range_def_chain): Dispose of obstack rather than\n\teach individual bitmap.\n\t(range_def_chain::set_import): New.\n\t(range_def_chain::get_imports): New.\n\t(range_def_chain::chain_import_p): New.\n\t(range_def_chain::register_dependency): Rename from build_def_chain\n\tand set imports.\n\t(range_def_chain::def_chain_in_bitmap_p): New.\n\t(range_def_chain::add_def_chain_to_bitmap): New.\n\t(range_def_chain::has_def_chain): Just check first depenedence.\n\t(range_def_chain::get_def_chain): Process imports, use generic\n\tregister_dependency routine.\n\t(range_def_chain::dump): New.\n\t(gori_map::gori_map): Allocate import list.\n\t(gori_map::~gori_map): Release imports.\n\t(gori_map::exports): Check for past allocated block size.\n\t(gori_map::imports): New.\n\t(gori_map::def_chain_in_export_p): Delete.\n\t(gori_map::is_import_p): New.\n\t(gori_map::maybe_add_gori): Handle imports.\n\t(gori_map::dump): Adjust output, add imports.\n\t(gori_compute::has_edge_range_p): Remove def_chain_in_export call.\n\t(gori_export_iterator::gori_export_iterator): New.\n\t(gori_export_iterator::next): New.\n\t(gori_export_iterator::get_name): New.\n\t* gimple-range-gori.h (range_def_chain): Add imports and direct\n\tdependecies via struct rdc.\n\t(range_def_chain::depend1): New.\n\t(range_def_chain::depend2): New.\n\t(class gori_map): Adjust.\n\t(FOR_EACH_GORI_IMPORT_NAME): New.\n\t(FOR_EACH_GORI_EXPORT_NAME): New.\n\t(class gori_export_iterator): New.", "tree": {"sha": "9ad11b32876750c33d02e22e7a2c61c4508ba873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ad11b32876750c33d02e22e7a2c61c4508ba873"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c21644704160710a17d1ea6c1cd212e079cd5e36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21644704160710a17d1ea6c1cd212e079cd5e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c21644704160710a17d1ea6c1cd212e079cd5e36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21644704160710a17d1ea6c1cd212e079cd5e36/comments", "author": null, "committer": null, "parents": [{"sha": "cb33af1a62b09576b0782ac36e5f5cff049f1035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb33af1a62b09576b0782ac36e5f5cff049f1035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb33af1a62b09576b0782ac36e5f5cff049f1035"}], "stats": {"total": 433, "additions": 327, "deletions": 106}, "files": [{"sha": "94640adc041efaf2f8f6bcef25c99f1d48ba3a21", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 256, "deletions": 100, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c21644704160710a17d1ea6c1cd212e079cd5e36/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c21644704160710a17d1ea6c1cd212e079cd5e36/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=c21644704160710a17d1ea6c1cd212e079cd5e36", "patch": "@@ -56,7 +56,7 @@ is_gimple_logical_p (const gimple *gs)\n   return false;\n }\n \n-/* RANGE_DEF_CHAIN is used to determine what SSA names in a block can\n+/* RANGE_DEF_CHAIN is used to determine which SSA names in a block can\n    have range information calculated for them, and what the\n    dependencies on each other are.\n \n@@ -95,6 +95,7 @@ is_gimple_logical_p (const gimple *gs)\n \n range_def_chain::range_def_chain ()\n {\n+  bitmap_obstack_initialize (&m_bitmaps);\n   m_def_chain.create (0);\n   m_def_chain.safe_grow_cleared (num_ssa_names);\n   m_logical_depth = 0;\n@@ -104,11 +105,8 @@ range_def_chain::range_def_chain ()\n \n range_def_chain::~range_def_chain ()\n {\n-  unsigned x;\n-  for (x = 0; x < m_def_chain.length (); ++x)\n-    if (m_def_chain[x])\n-      BITMAP_FREE (m_def_chain[x]);\n   m_def_chain.release ();\n+  bitmap_obstack_release (&m_bitmaps);\n }\n \n // Return true if NAME is in the def chain of DEF.  If BB is provided,\n@@ -128,26 +126,112 @@ range_def_chain::in_chain_p (tree name, tree def)\n   return bitmap_bit_p (chain, SSA_NAME_VERSION (name));\n }\n \n+// Add either IMP or the import list B to the import set of DATA.\n+\n+void\n+range_def_chain::set_import (struct rdc &data, tree imp, bitmap b)\n+{\n+  // If there are no imports, just return\n+  if (imp == NULL_TREE && !b)\n+    return;\n+  if (!data.m_import)\n+    data.m_import = BITMAP_ALLOC (&m_bitmaps);\n+  if (imp != NULL_TREE)\n+    bitmap_set_bit (data.m_import, SSA_NAME_VERSION (imp));\n+  else\n+    bitmap_ior_into (data.m_import, b);\n+}\n+\n+// Return the import list for NAME.\n+\n+bitmap\n+range_def_chain::get_imports (tree name)\n+{\n+  if (!has_def_chain (name))\n+    get_def_chain (name);\n+  bitmap i = m_def_chain[SSA_NAME_VERSION (name)].m_import;\n+  // Either this is a default def,  OR imports must be a subset of exports.\n+  gcc_checking_assert (!get_def_chain (name) || !i\n+\t\t       || !bitmap_intersect_compl_p (i, get_def_chain (name)));\n+  return i;\n+}\n+\n+// Return true if IMPORT is an import to NAMEs def chain.\n+\n+bool\n+range_def_chain::chain_import_p (tree name, tree import)\n+{\n+  bitmap b = get_imports (name);\n+  if (b)\n+    return bitmap_bit_p (b, SSA_NAME_VERSION (import));\n+  return false;\n+}\n+\n // Build def_chains for NAME if it is in BB.  Copy the def chain into RESULT.\n \n void\n-range_def_chain::build_def_chain (tree name, bitmap result, basic_block bb)\n+range_def_chain::register_dependency (tree name, tree dep, basic_block bb)\n {\n+  if (!gimple_range_ssa_p (dep))\n+    return;\n+\n+  unsigned v = SSA_NAME_VERSION (name);\n+  struct rdc &src = m_def_chain[v];\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (dep);\n+  unsigned dep_v = SSA_NAME_VERSION (dep);\n   bitmap b;\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\n+  // Set the direct dependency cache entries.\n+  if (!src.ssa1)\n+    src.ssa1 = dep;\n+  else if (!src.ssa2 && src.ssa1 != dep)\n+    src.ssa2 = dep;\n+\n+  // Don't calculate imports or export/dep chains if BB is not provided.\n+  // This is usually the case for when the temporal cache wants the direct\n+  // dependencies of a stmt.\n+  if (!bb)\n+    return;\n+\n+  if (!src.bm)\n+    src.bm = BITMAP_ALLOC (&m_bitmaps);\n+\n   // Add this operand into the result.\n-  bitmap_set_bit (result, SSA_NAME_VERSION (name));\n+  bitmap_set_bit (src.bm, dep_v);\n \n   if (gimple_bb (def_stmt) == bb && !is_a<gphi *>(def_stmt))\n     {\n       // Get the def chain for the operand.\n-      b = get_def_chain (name);\n+      b = get_def_chain (dep);\n       // If there was one, copy it into result.\n       if (b)\n-\tbitmap_ior_into (result, b);\n+\tbitmap_ior_into (src.bm, b);\n+      // And copy the import list.\n+      set_import (src, NULL_TREE, get_imports (dep));\n     }\n+  else\n+    // Originated outside the block, so it is an import.\n+    set_import (src, dep, NULL);\n+}\n+\n+bool\n+range_def_chain::def_chain_in_bitmap_p (tree name, bitmap b)\n+{\n+  bitmap a = get_def_chain (name);\n+  if (a && b)\n+    return bitmap_intersect_p (a, b);\n+  return false;\n }\n \n+void\n+range_def_chain::add_def_chain_to_bitmap (bitmap b, tree name)\n+{\n+  bitmap r = get_def_chain (name);\n+  if (r)\n+    bitmap_ior_into (b, r);\n+}\n+\n+\n // Return TRUE if NAME has been processed for a def_chain.\n \n inline bool\n@@ -157,9 +241,11 @@ range_def_chain::has_def_chain (tree name)\n   unsigned v = SSA_NAME_VERSION (name);\n   if (v >= m_def_chain.length ())\n     m_def_chain.safe_grow_cleared (num_ssa_names + 1);\n-  return (m_def_chain[v] != NULL);\n+  return (m_def_chain[v].ssa1 != 0);\n }\n \n+\n+\n // Calculate the def chain for NAME and all of its dependent\n // operands. Only using names in the same BB.  Return the bitmap of\n // all names in the m_def_chain.  This only works for supported range\n@@ -174,11 +260,15 @@ range_def_chain::get_def_chain (tree name)\n \n   // If it has already been processed, just return the cached value.\n   if (has_def_chain (name))\n-    return m_def_chain[v];\n+    return m_def_chain[v].bm;\n \n   // No definition chain for default defs.\n   if (SSA_NAME_IS_DEFAULT_DEF (name))\n-    return NULL;\n+    {\n+      // A Default def is always an import.\n+      set_import (m_def_chain[v], name, NULL);\n+      return NULL;\n+    }\n \n   gimple *stmt = SSA_NAME_DEF_STMT (name);\n   if (gimple_range_handler (stmt))\n@@ -205,30 +295,63 @@ range_def_chain::get_def_chain (tree name)\n       ssa3 = gimple_range_ssa_p (gimple_assign_rhs3 (st));\n     }\n   else\n-    return NULL;\n-\n-  basic_block bb = gimple_bb (stmt);\n-\n-  m_def_chain[v] = BITMAP_ALLOC (NULL);\n+    {\n+      // Stmts not understood are always imports.\n+      set_import (m_def_chain[v], name, NULL);\n+      return NULL;\n+    }\n \n-  if (ssa1)\n-    build_def_chain (ssa1, m_def_chain[v], bb);\n-  if (ssa2)\n-    build_def_chain (ssa2, m_def_chain[v], bb);\n-  if (ssa3)\n-    build_def_chain (ssa3, m_def_chain[v], bb);\n+  register_dependency (name, ssa1, gimple_bb (stmt));\n+  register_dependency (name, ssa2, gimple_bb (stmt));\n+  register_dependency (name, ssa3, gimple_bb (stmt));\n+  // Stmts with no understandable operands are also imports.\n+  if (!ssa1 && !ssa2 & !ssa3)\n+    set_import (m_def_chain[v], name, NULL);\n \n   if (is_logical)\n     m_logical_depth--;\n \n-  // If we run into pathological cases where the defintion chains are\n-  // huge (ie  huge basic block fully unrolled) we might be able to limit\n-  // this by deciding here that if some criteria is satisfied, we change the\n-  // def_chain back to be just the ssa-names.  That will help prevent chains\n-  // of a_2 = b_6 + a_8 from creating a pathological case.\n-  return m_def_chain[v];\n+  return m_def_chain[v].bm;\n+}\n+\n+// Dump what we know for basic block BB to file F.\n+\n+void\n+range_def_chain::dump (FILE *f, basic_block bb, const char *prefix)\n+{\n+  unsigned x, y;\n+  bitmap_iterator bi;\n+\n+  // Dump the def chain for each SSA_NAME defined in BB.\n+  for (x = 1; x < num_ssa_names; x++)\n+    {\n+      tree name = ssa_name (x);\n+      if (!name)\n+\tcontinue;\n+      gimple *stmt = SSA_NAME_DEF_STMT (name);\n+      if (!stmt || (bb && gimple_bb (stmt) != bb))\n+\tcontinue;\n+      bitmap chain = (has_def_chain (name) ? get_def_chain (name) : NULL);\n+      if (chain && !bitmap_empty_p (chain))\n+\t{\n+\t  fprintf (f, prefix);\n+\t  print_generic_expr (f, name, TDF_SLIM);\n+\t  fprintf (f, \" : \");\n+\n+\t  bitmap imports = get_imports (name);\n+\t  EXECUTE_IF_SET_IN_BITMAP (chain, 0, y, bi)\n+\t    {\n+\t      print_generic_expr (f, ssa_name (y), TDF_SLIM);\n+\t      if (imports && bitmap_bit_p (imports, y))\n+\t\tfprintf (f, \"(I)\");\n+\t      fprintf (f, \"  \");\n+\t    }\n+\t  fprintf (f, \"\\n\");\n+\t}\n+    }\n }\n \n+\n // -------------------------------------------------------------------\n \n /* GORI_MAP is used to accumulate what SSA names in a block can\n@@ -256,15 +379,16 @@ gori_map::gori_map ()\n {\n   m_outgoing.create (0);\n   m_outgoing.safe_grow_cleared (last_basic_block_for_fn (cfun));\n-  bitmap_obstack_initialize (&m_bitmaps);\n+  m_incoming.create (0);\n+  m_incoming.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   m_maybe_variant = BITMAP_ALLOC (&m_bitmaps);\n }\n \n // Free any memory the GORI map allocated.\n \n gori_map::~gori_map ()\n {\n-  bitmap_obstack_release (&m_bitmaps);\n+  m_incoming.release ();\n   m_outgoing.release ();\n }\n \n@@ -273,11 +397,21 @@ gori_map::~gori_map ()\n bitmap\n gori_map::exports (basic_block bb)\n {\n-  if (!m_outgoing[bb->index])\n+  if (bb->index >= (signed int)m_outgoing.length () || !m_outgoing[bb->index])\n     calculate_gori (bb);\n   return m_outgoing[bb->index];\n }\n \n+// Return the bitmap vector of all imports to BB.  Calculate if necessary.\n+\n+bitmap\n+gori_map::imports (basic_block bb)\n+{\n+  if (bb->index >= (signed int)m_outgoing.length () || !m_outgoing[bb->index])\n+    calculate_gori (bb);\n+  return m_incoming[bb->index];\n+}\n+\n // Return true if NAME is can have ranges generated for it from basic\n // block BB.\n \n@@ -298,17 +432,13 @@ gori_map::set_range_invariant (tree name)\n   bitmap_clear_bit (m_maybe_variant, SSA_NAME_VERSION (name));\n }\n \n-// Return true if any element in the def chain of NAME is in the\n-// export list for BB.\n+// Return true if NAME is an import to block BB.\n \n bool\n-gori_map::def_chain_in_export_p (tree name, basic_block bb)\n+gori_map::is_import_p (tree name, basic_block bb)\n {\n-  bitmap a = exports (bb);\n-  bitmap b = get_def_chain (name);\n-  if (a && b)\n-    return bitmap_intersect_p (a, b);\n-  return false;\n+  // If no BB is specified, test if it is exported anywhere in the IL.\n+  return bitmap_bit_p (imports (bb), SSA_NAME_VERSION (name));\n }\n \n // If NAME is non-NULL and defined in block BB, calculate the def\n@@ -319,11 +449,17 @@ gori_map::maybe_add_gori (tree name, basic_block bb)\n {\n   if (name)\n     {\n-      gimple *s = SSA_NAME_DEF_STMT (name);\n-      bitmap r = get_def_chain (name);\n-      // Check if there is a def chain, and it is in this block.\n-      if (r && gimple_bb (s) == bb)\n-\tbitmap_copy (m_outgoing[bb->index], r);\n+      // Check if there is a def chain, regardless of the block.\n+      add_def_chain_to_bitmap (m_outgoing[bb->index], name);\n+      // Check for any imports.\n+      bitmap imp = get_imports (name);\n+      // If there were imports, add them so we can recompute\n+      if (imp)\n+\tbitmap_ior_into (m_incoming[bb->index], imp);\n+      // This name is always an import.\n+      if (gimple_bb (SSA_NAME_DEF_STMT (name)) != bb)\n+\tbitmap_set_bit (m_incoming[bb->index], SSA_NAME_VERSION (name));\n+\n       // Def chain doesn't include itself, and even if there isn't a\n       // def chain, this name should be added to exports.\n       bitmap_set_bit (m_outgoing[bb->index], SSA_NAME_VERSION (name));\n@@ -337,9 +473,13 @@ gori_map::calculate_gori (basic_block bb)\n {\n   tree name;\n   if (bb->index >= (signed int)m_outgoing.length ())\n-    m_outgoing.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+    {\n+      m_outgoing.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+      m_incoming.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+    }\n   gcc_checking_assert (m_outgoing[bb->index] == NULL);\n   m_outgoing[bb->index] = BITMAP_ALLOC (&m_bitmaps);\n+  m_incoming[bb->index] = BITMAP_ALLOC (&m_bitmaps);\n \n   // If this block's last statement may generate range informaiton, go\n   // calculate it.\n@@ -368,65 +508,42 @@ gori_map::calculate_gori (basic_block bb)\n // Dump the table information for BB to file F.\n \n void\n-gori_map::dump (FILE *f, basic_block bb)\n+gori_map::dump (FILE *f, basic_block bb, bool verbose)\n {\n-  bool header = false;\n-  const char *header_string = \"bb%-4d \";\n-  const char *header2 = \"       \";\n-  bool printed_something = false;;\n-  unsigned x, y;\n-  bitmap_iterator bi;\n-\n   // BB was not processed.\n-  if (!m_outgoing[bb->index])\n+  if (!m_outgoing[bb->index] || bitmap_empty_p (m_outgoing[bb->index]))\n     return;\n \n-  // Dump the def chain for each SSA_NAME defined in BB.\n-  for (x = 1; x < num_ssa_names; x++)\n+  tree name;\n+\n+  bitmap imp = imports (bb);\n+  if (!bitmap_empty_p (imp))\n     {\n-      tree name = ssa_name (x);\n-      if (!name)\n-\tcontinue;\n-      gimple *stmt = SSA_NAME_DEF_STMT (name);\n-      bitmap chain = (has_def_chain (name) ? get_def_chain (name) : NULL);\n-      if (stmt && gimple_bb (stmt) == bb && chain && !bitmap_empty_p (chain))\n-        {\n-\t  fprintf (f, header_string, bb->index);\n-\t  header_string = header2;\n-\t  header = true;\n+      if (verbose)\n+\tfprintf (f, \"bb<%u> Imports: \",bb->index);\n+      else\n+\tfprintf (f, \"Imports: \");\n+      FOR_EACH_GORI_IMPORT_NAME (*this, bb, name)\n+\t{\n \t  print_generic_expr (f, name, TDF_SLIM);\n-\t  fprintf (f, \" : \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (chain, 0, y, bi)\n-\t    {\n-\t      print_generic_expr (f, ssa_name (y), TDF_SLIM);\n-\t      fprintf (f, \"  \");\n-\t    }\n-\t  fprintf (f, \"\\n\");\n+\t  fprintf (f, \"  \");\n \t}\n+      fputc ('\\n', f);\n     }\n \n-  printed_something |= header;\n-\n-  // Now dump the export vector.\n-  header = false;\n-  EXECUTE_IF_SET_IN_BITMAP (m_outgoing[bb->index], 0, y, bi)\n+  if (verbose)\n+    fprintf (f, \"bb<%u> Exports: \",bb->index);\n+  else\n+    fprintf (f, \"Exports: \");\n+  // Dump the export vector.\n+  FOR_EACH_GORI_EXPORT_NAME (*this, bb, name)\n     {\n-      if (!header)\n-        {\n-\t  fprintf (f, header_string, bb->index);\n-\t  fprintf (f, \"exports: \");\n-\t  header_string = header2;\n-\t  header = true;\n-\t}\n-      print_generic_expr (f, ssa_name (y), TDF_SLIM);\n+      print_generic_expr (f, name, TDF_SLIM);\n       fprintf (f, \"  \");\n     }\n-  if (header)\n-    fputc ('\\n', f);\n+  fputc ('\\n', f);\n \n-  printed_something |= header;\n-  if (printed_something)\n-    fprintf (f, \"\\n\");\n+  range_def_chain::dump (f, bb, \"         \");\n }\n \n // Dump the entire GORI map structure to file F.\n@@ -436,11 +553,7 @@ gori_map::dump (FILE *f)\n {\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      dump (f, bb);\n-      if (m_outgoing[bb->index])\n-\tfprintf (f, \"\\n\");\n-    }\n+    dump (f, bb);\n }\n \n DEBUG_FUNCTION void\n@@ -960,8 +1073,7 @@ gori_compute::has_edge_range_p (tree name, edge e)\n   if (!e)\n     return is_export_p (name);\n \n-  return (is_export_p (name, e->src)\n-\t  || def_chain_in_export_p (name, e->src));\n+  return is_export_p (name, e->src);\n }\n \n // Dump what is known to GORI computes to listing file F.\n@@ -1006,6 +1118,50 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name)\n   return false;\n }\n \n+\n+// ------------------------------------------------------------------------\n+//  GORI iterator.  Although we have bitmap iterators, don't expose that it\n+//  is currently a bitmap.  Use an export iterator to hide future changes.\n+\n+// Construct a basic iterator over an export bitmap.\n+\n+gori_export_iterator::gori_export_iterator (bitmap b)\n+{\n+  bm = b;\n+  if (b)\n+    bmp_iter_set_init (&bi, b, 1, &y);\n+}\n+\n+\n+// Move to the next export bitmap spot.\n+\n+void\n+gori_export_iterator::next ()\n+{\n+  bmp_iter_next (&bi, &y);\n+}\n+\n+\n+// Fetch the name of the next export in the export list.  Return NULL if\n+// iteration is done.\n+\n+tree\n+gori_export_iterator::get_name ()\n+{\n+  if (!bm)\n+    return NULL_TREE;\n+\n+  while (bmp_iter_set (&bi, &y))\n+    {\n+      tree t = ssa_name (y);\n+      if (t)\n+\treturn t;\n+      next ();\n+    }\n+  return NULL_TREE;\n+}\n+\n+\n // --------------------------------------------------------------------------\n \n // Cache for SSAs that appear on the RHS of a boolean assignment."}, {"sha": "8f44216cfcd2ec78990e24d87e2541ab56f8d92b", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c21644704160710a17d1ea6c1cd212e079cd5e36/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c21644704160710a17d1ea6c1cd212e079cd5e36/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=c21644704160710a17d1ea6c1cd212e079cd5e36", "patch": "@@ -31,15 +31,55 @@ class range_def_chain\n public:\n   range_def_chain ();\n   ~range_def_chain ();\n+  tree depend1 (tree name) const;\n+  tree depend2 (tree name) const;\n+  bool in_chain_p (tree name, tree def);\n+  bool chain_import_p (tree name, tree import);\n+  void register_dependency (tree name, tree ssa1, basic_block bb = NULL);\n+  void dump (FILE *f, basic_block bb, const char *prefix = NULL);\n+protected:\n   bool has_def_chain (tree name);\n+  bool def_chain_in_bitmap_p (tree name, bitmap b);\n+  void add_def_chain_to_bitmap (bitmap b, tree name);\n   bitmap get_def_chain (tree name);\n-  bool in_chain_p (tree name, tree def);\n+  bitmap get_imports (tree name);\n+  bitmap_obstack m_bitmaps;\n private:\n-  vec<bitmap> m_def_chain;\t// SSA_NAME : def chain components.\n-  void build_def_chain (tree name, bitmap result, basic_block bb);\n+  struct rdc {\n+   tree ssa1;\t\t// First direct dependency\n+   tree ssa2;\t\t// Second direct dependency\n+   bitmap bm;\t\t// All dependencies\n+   bitmap m_import;\n+  };\n+  vec<rdc> m_def_chain;\t// SSA_NAME : def chain components.\n+  void set_import (struct rdc &data, tree imp, bitmap b);\n   int m_logical_depth;\n };\n \n+// Return the first direct dependency for NAME, if there is one.\n+// Direct dependencies are those which occur on the defintion statement.\n+// Only the first 2 such names are cached.\n+\n+inline tree\n+range_def_chain::depend1 (tree name) const\n+{\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (v >= m_def_chain.length ())\n+    return NULL_TREE;\n+  return m_def_chain[v].ssa1;\n+}\n+\n+// Return the second direct dependency for NAME, if there is one.\n+\n+inline tree\n+range_def_chain::depend2 (tree name) const\n+{\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (v >= m_def_chain.length ())\n+    return NULL_TREE;\n+  return m_def_chain[v].ssa2;\n+}\n+\n // GORI_MAP is used to accumulate what SSA names in a block can\n // generate range information, and provides tools for the block ranger\n // to enable it to efficiently calculate these ranges.\n@@ -51,15 +91,16 @@ class gori_map : public range_def_chain\n   ~gori_map ();\n \n   bool is_export_p (tree name, basic_block bb = NULL);\n-  bool def_chain_in_export_p (tree name, basic_block bb);\n+  bool is_import_p (tree name, basic_block bb);\n   bitmap exports (basic_block bb);\n+  bitmap imports (basic_block bb);\n   void set_range_invariant (tree name);\n \n   void dump (FILE *f);\n-  void dump (FILE *f, basic_block bb);\n+  void dump (FILE *f, basic_block bb, bool verbose = true);\n private:\n-  bitmap_obstack m_bitmaps;\n   vec<bitmap> m_outgoing;\t// BB: Outgoing ranges calculatable on edges\n+  vec<bitmap> m_incoming;\t// BB: Incoming ranges which can affect exports.\n   bitmap m_maybe_variant;\t// Names which might have outgoing ranges.\n   void maybe_add_gori (tree name, basic_block bb);\n   void calculate_gori (basic_block bb);\n@@ -152,6 +193,30 @@ class gori_compute : public gori_map\n };\n \n \n+// For each name that is an import into BB's exports..\n+#define FOR_EACH_GORI_IMPORT_NAME(gori, bb, name)\t\t\t\\\n+  for (gori_export_iterator iter ((gori).imports ((bb)));\t\\\n+       ((name) = iter.get_name ());\t\t\t\t\\\n+       iter.next ())\n+\n+// For each name possibly exported from block BB.\n+#define FOR_EACH_GORI_EXPORT_NAME(gori, bb, name)\t\t\\\n+  for (gori_export_iterator iter ((gori).exports ((bb)));\t\\\n+       ((name) = iter.get_name ());\t\t\t\t\\\n+       iter.next ())\n+\n+// Used to assist with iterating over the GORI export list in various ways\n+class gori_export_iterator {\n+public:\n+  gori_export_iterator (bitmap b);\n+  void next ();\n+  tree get_name ();\n+protected:\n+  bitmap bm;\n+  bitmap_iterator bi;\n+  unsigned y;\n+};\n+\n // This class adds a cache to gori_computes for logical expressions.\n //       bool result = x && y\n // requires calcuation of both X and Y for both true and false results."}]}