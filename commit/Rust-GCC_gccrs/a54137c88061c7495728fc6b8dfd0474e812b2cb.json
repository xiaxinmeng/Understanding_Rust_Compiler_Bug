{"sha": "a54137c88061c7495728fc6b8dfd0474e812b2cb", "node_id": "C_kwDOANBUbNoAKGE1NDEzN2M4ODA2MWM3NDk1NzI4ZmM2YjhkZmQwNDc0ZTgxMmIyY2I", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-04-15T13:34:09Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-04-15T13:34:09Z"}, "message": "libstdc++: Optimize integer std::from_chars\n\nThis applies the following optimizations to the integer std::from_chars\nimplementation:\n\n  1. Use a lookup table for converting an alphanumeric digit to its\n     base-36 value instead of using a range test (for 0-9) and switch\n     (for a-z and A-Z).  The table is constructed using a C++14\n     constexpr function which doesn't assume a particular character\n     encoding or __CHAR_BIT__ value.  This new conversion function\n     __from_chars_alnum_to_val is templated on whether we care\n     only about the decimal digits, in which case we can perform the\n     conversion with a single subtraction since the digit characters\n     are guaranteed to be contiguous (unlike the letters).\n  2. Generalize __from_chars_binary to handle all power-of-two bases.\n     This function (now named __from_chars_pow2_base) is also templated\n     on whether we care only about the decimal digits for the benefit of\n     faster digit conversion for base 2, 4 and 8.\n  3. In __from_chars_digit, use\n       static_cast<unsigned char>(__c - '0') < __base\n     instead of\n       '0' <= __c && __c <= ('0' + (__base - 1)).\n     as the digit recognition test (exhaustively verified that the two\n     tests are equivalent).\n  4. In __from_chars_alnum, use a nested loop to consume the rest of the\n     digits in the overflow case (mirroring __from_chars_digit) so that\n     the main loop doesn't have to maintain the overflow flag __valid.\n\nAt this point, __from_chars_digit is nearly identical to\n__from_chars_alnum, so this patch merges the two functions by removing\nthe former and templatizing the latter according to whether we care only\nabout the decimal digits.  Finally,\n\n  5. In __from_chars_alnum, maintain a lower bound on the number of\n     unused bits in the result and use it to omit the overflow check\n     when it's safe to do so.\n\nIn passing, this patch replaces the non-portable function ascii_to_hexit\nused by __floating_from_chars_hex with the new conversion function.\n\nSome runtime measurements for a simple 15-line benchmark that roundtrips\nprinting/parsing 200 million integers via std::to/from_chars (average of\n5 runs):\n\n  Base  Before  After (seconds, lower is better)\n     2    9.37   9.37\n     3   15.79  12.13\n     8    4.15   3.67\n    10    4.90   3.86\n    11    6.84   5.03\n    16    4.14   2.93\n    32    3.85   2.39\n    36    5.22   3.26\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/charconv (__from_chars_alnum_to_val_table): Define.\n\t(__from_chars_alnum_to_val): Define.\n\t(__from_chars_binary): Rename to ...\n\t(__from_chars_pow2_base): ... this.  Generalize to handle any\n\tpower-of-two base using __from_chars_alnum_to_val.\n\t(__from_chars_digit): Optimize digit recognition to a single\n\ttest instead of two tests.  Use [[__unlikely___]] attribute.\n\t(__from_chars_alpha_to_num): Remove.\n\t(__from_chars_alnum): Use __from_chars_alnum_to_val.  Use a\n\tnested loop for the overflow case.  Maintain a lower bound\n\ton the number of available bits in the result and use it to\n\tomit the overflow check.\n\t(from_chars): Adjust appropriately.\n\t* src/c++17/floating_from_chars.cc (ascii_to_hexit): Remove.\n\t(__floating_from_chars_hex): Use __from_chars_alnum_to_val\n\tto recognize a hex digit instead.", "tree": {"sha": "6281bd29a4f89f0d41c478d49e939e96f96c915c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6281bd29a4f89f0d41c478d49e939e96f96c915c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a54137c88061c7495728fc6b8dfd0474e812b2cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54137c88061c7495728fc6b8dfd0474e812b2cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a54137c88061c7495728fc6b8dfd0474e812b2cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54137c88061c7495728fc6b8dfd0474e812b2cb/comments", "author": null, "committer": null, "parents": [{"sha": "a335a94a1bf49dcb3c966af05cd68be6ee36277e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a335a94a1bf49dcb3c966af05cd68be6ee36277e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a335a94a1bf49dcb3c966af05cd68be6ee36277e"}], "stats": {"total": 265, "additions": 102, "deletions": 163}, "files": [{"sha": "dda4ec877792c2fed7134361540f1c0af3034a2a", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 100, "deletions": 147, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54137c88061c7495728fc6b8dfd0474e812b2cb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54137c88061c7495728fc6b8dfd0474e812b2cb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=a54137c88061c7495728fc6b8dfd0474e812b2cb", "patch": "@@ -407,176 +407,124 @@ namespace __detail\n       return true;\n     }\n \n-  /// std::from_chars implementation for integers in base 2.\n-  template<typename _Tp>\n+  // Construct and return a lookup table that maps 0-9, A-Z and a-z to their\n+  // corresponding base-36 value and maps all other characters to 127.\n+  constexpr auto\n+  __from_chars_alnum_to_val_table()\n+  {\n+    constexpr unsigned char __lower_letters[]\n+      = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n+\t  'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n+\t  'u', 'v', 'w', 'x', 'y', 'z' };\n+    constexpr unsigned char __upper_letters[]\n+      = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n+\t  'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n+\t  'U', 'V', 'W', 'X', 'Y', 'Z' };\n+    struct { unsigned char __data[1u << __CHAR_BIT__] = {}; } __table;\n+    for (auto& __entry : __table.__data)\n+      __entry = 127;\n+    for (int __i = 0; __i < 10; ++__i)\n+      __table.__data['0' + __i] = __i;\n+    for (int __i = 0; __i < 26; ++__i)\n+      {\n+\t__table.__data[__lower_letters[__i]] = 10 + __i;\n+\t__table.__data[__upper_letters[__i]] = 10 + __i;\n+      }\n+    return __table;\n+  }\n+\n+  // If _DecOnly is true: if the character is a decimal digit, then\n+  // return its corresponding base-10 value, otherwise return a value >= 127.\n+  // If _DecOnly is false: if the character is an alphanumeric digit, then\n+  // return its corresponding base-36 value, otherwise return a value >= 127.\n+  template<bool _DecOnly>\n+    unsigned char\n+    __from_chars_alnum_to_val(unsigned char __c)\n+    {\n+      if _GLIBCXX17_CONSTEXPR (_DecOnly)\n+\treturn __c - '0';\n+      else\n+\t{\n+\t  static constexpr auto __table = __from_chars_alnum_to_val_table();\n+\t  return __table.__data[__c];\n+\t}\n+    }\n+\n+  /// std::from_chars implementation for integers in a power-of-two base.\n+  /// If _DecOnly is true, then we may assume __base is at most 8.\n+  template<bool _DecOnly, typename _Tp>\n     bool\n-    __from_chars_binary(const char*& __first, const char* __last, _Tp& __val)\n+    __from_chars_pow2_base(const char*& __first, const char* __last, _Tp& __val,\n+\t\t\t   int __base)\n     {\n       static_assert(is_integral<_Tp>::value, \"implementation bug\");\n       static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n \n+      // __glibcxx_assert((__base & (__base - 1)) == 0);\n+      // __glibcxx_assert(_DecOnly ? __base <= 8 : __base <= 32);\n+      const int __log2_base = __countr_zero(__base);\n+\n       const ptrdiff_t __len = __last - __first;\n       ptrdiff_t __i = 0;\n       while (__i < __len && __first[__i] == '0')\n \t++__i;\n       const ptrdiff_t __leading_zeroes = __i;\n \n-      while (__i < __len)\n+      unsigned char __leading_c = 0;\n+      for (; __i < __len; ++__i)\n \t{\n-\t  const unsigned char __c = (unsigned)__first[__i] - '0';\n-\t  if (__c < 2)\n-\t    __val = (__val << 1) | __c;\n-\t  else\n+\t  const unsigned char __c = __from_chars_alnum_to_val<_DecOnly>(__first[__i]);\n+\t  if (__c >= __base)\n \t    break;\n-\t  __i++;\n+\t  __val = (__val << __log2_base) | __c;\n+\n+\t  if (__i == __leading_zeroes)\n+\t    {\n+\t      // At the first iteration, remember the leading significant digit.\n+\t      // __glibcxx_assert(__leading_c == 0 && __c != 0);\n+\t      __leading_c = __c;\n+\t    }\n \t}\n       __first += __i;\n-      return (__i - __leading_zeroes) <= __gnu_cxx::__int_traits<_Tp>::__digits;\n+      auto __significant_bits = (__i - __leading_zeroes) * __log2_base;\n+      if (__base != 2 && __leading_c != 0)\n+\t// Compensate for a leading significant digit that didn't use all\n+\t// of its available bits.\n+\t__significant_bits -= __log2_base - __bit_width(__leading_c);\n+      // __glibcxx_assert(__significant_bits >= 0);\n+      return __significant_bits <= __gnu_cxx::__int_traits<_Tp>::__digits;\n     }\n \n-  /// std::from_chars implementation for integers in bases 3 to 10.\n-  template<typename _Tp>\n+  /// std::from_chars implementation for integers in any base.\n+  /// If _DecOnly is true, then we may assume __base is at most 10.\n+  template<bool _DecOnly, typename _Tp>\n     bool\n-    __from_chars_digit(const char*& __first, const char* __last, _Tp& __val,\n+    __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,\n \t\t       int __base)\n     {\n-      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n-      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n-\n-      auto __matches = [__base](char __c) {\n-\t  return '0' <= __c && __c <= ('0' + (__base - 1));\n-      };\n+      // __glibcxx_assert(!_DecOnly || __base <= 10);\n \n-      while (__first != __last)\n+      const int __bits_per_digit = __bit_width(__base);\n+      int __unused_bits_lower_bound = __gnu_cxx::__int_traits<_Tp>::__digits;\n+      for (; __first != __last; ++__first)\n \t{\n-\t  const char __c = *__first;\n-\t  if (__matches(__c))\n-\t  {\n-\t    if (!__raise_and_add(__val, __base, __c - '0'))\n-\t      {\n-\t\twhile (++__first != __last && __matches(*__first))\n-\t\t  ;\n-\t\treturn false;\n-\t      }\n-\t    __first++;\n-\t  }\n-\t  else\n+\t  const unsigned char __c = __from_chars_alnum_to_val<_DecOnly>(*__first);\n+\t  if (__c >= __base)\n \t    return true;\n-\t}\n-      return true;\n-    }\n \n-  constexpr char\n-  __from_chars_alpha_to_num(char __c)\n-  {\n-    switch (__c)\n-    {\n-    case 'a':\n-    case 'A':\n-      return 10;\n-    case 'b':\n-    case 'B':\n-      return 11;\n-    case 'c':\n-    case 'C':\n-      return 12;\n-    case 'd':\n-    case 'D':\n-      return 13;\n-    case 'e':\n-    case 'E':\n-      return 14;\n-    case 'f':\n-    case 'F':\n-      return 15;\n-    case 'g':\n-    case 'G':\n-      return 16;\n-    case 'h':\n-    case 'H':\n-      return 17;\n-    case 'i':\n-    case 'I':\n-      return 18;\n-    case 'j':\n-    case 'J':\n-      return 19;\n-    case 'k':\n-    case 'K':\n-      return 20;\n-    case 'l':\n-    case 'L':\n-      return 21;\n-    case 'm':\n-    case 'M':\n-      return 22;\n-    case 'n':\n-    case 'N':\n-      return 23;\n-    case 'o':\n-    case 'O':\n-      return 24;\n-    case 'p':\n-    case 'P':\n-      return 25;\n-    case 'q':\n-    case 'Q':\n-      return 26;\n-    case 'r':\n-    case 'R':\n-      return 27;\n-    case 's':\n-    case 'S':\n-      return 28;\n-    case 't':\n-    case 'T':\n-      return 29;\n-    case 'u':\n-    case 'U':\n-      return 30;\n-    case 'v':\n-    case 'V':\n-      return 31;\n-    case 'w':\n-    case 'W':\n-      return 32;\n-    case 'x':\n-    case 'X':\n-      return 33;\n-    case 'y':\n-    case 'Y':\n-      return 34;\n-    case 'z':\n-    case 'Z':\n-      return 35;\n-    }\n-    return 127;\n-  }\n-\n-  /// std::from_chars implementation for integers in bases 11 to 36.\n-  template<typename _Tp>\n-    bool\n-    __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,\n-\t\t       int __base)\n-    {\n-      bool __valid = true;\n-      while (__first != __last)\n-\t{\n-\t  char __c = *__first;\n-\t  if ('0' <= __c && __c <= '9') // isdigit\n-\t    __c -= '0';\n-\t  else\n+\t  __unused_bits_lower_bound -= __bits_per_digit;\n+\t  if (__unused_bits_lower_bound >= 0) [[__likely__]]\n+\t    // We're definitely not going to overflow.\n+\t    __val = __val * __base + __c;\n+\t  else if (!__raise_and_add(__val, __base, __c)) [[__unlikely__]]\n \t    {\n-\t      __c = __from_chars_alpha_to_num(__c);\n-\t      if (__c >= __base)\n-\t\tbreak;\n+\t      while (++__first != __last\n+\t\t     && __from_chars_alnum_to_val<_DecOnly>(*__first) < __base)\n+\t\t;\n+\t      return false;\n \t    }\n-\n-\t  if (__builtin_expect(__valid, 1))\n-\t    __valid = __raise_and_add(__val, __base, __c);\n-\t  __first++;\n \t}\n-      return __valid;\n+      return true;\n     }\n \n   template<typename _Tp>\n@@ -611,12 +559,17 @@ namespace __detail\n \n       const auto __start = __first;\n       bool __valid;\n-      if (__base == 2)\n-\t__valid = __detail::__from_chars_binary(__first, __last, __val);\n+      if ((__base & (__base - 1)) == 0)\n+\t{\n+\t  if (__base <= 8)\n+\t    __valid = __detail::__from_chars_pow2_base<true>(__first, __last, __val, __base);\n+\t  else\n+\t    __valid = __detail::__from_chars_pow2_base<false>(__first, __last, __val, __base);\n+\t}\n       else if (__base <= 10)\n-\t__valid = __detail::__from_chars_digit(__first, __last, __val, __base);\n+\t__valid = __detail::__from_chars_alnum<true>(__first, __last, __val, __base);\n       else\n-\t__valid = __detail::__from_chars_alnum(__first, __last, __val, __base);\n+\t__valid = __detail::__from_chars_alnum<false>(__first, __last, __val, __base);\n \n       if (__builtin_expect(__first == __start, 0))\n \t__res.ec = errc::invalid_argument;"}, {"sha": "bbe03f7f068129903795ba123cb8b2e497936bbd", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54137c88061c7495728fc6b8dfd0474e812b2cb/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54137c88061c7495728fc6b8dfd0474e812b2cb/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=a54137c88061c7495728fc6b8dfd0474e812b2cb", "patch": "@@ -451,20 +451,6 @@ namespace\n #endif // USE_STRTOD_FOR_FROM_CHARS\n \n #if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n-  // If the given ASCII character represents a hexit, return that hexit.\n-  // Otherwise return -1.\n-  int\n-  ascii_to_hexit(char ch)\n-  {\n-    if (ch >= '0' && ch <= '9')\n-      return ch - '0';\n-    if (ch >= 'a' && ch <= 'f')\n-      return ch - 'a' + 10;\n-    if (ch >= 'A' && ch <= 'F')\n-      return ch - 'A' + 10;\n-    return -1;\n-  }\n-\n   // Return true iff [FIRST,LAST) begins with PREFIX, ignoring case.\n   bool\n   starts_with_ci(const char* first, const char* last, string_view prefix)\n@@ -614,8 +600,8 @@ namespace\n \t    continue;\n \t  }\n \n-\tint hexit = ascii_to_hexit(ch);\n-\tif (hexit == -1)\n+\tint hexit = __detail::__from_chars_alnum_to_val<false>(ch);\n+\tif (hexit >= 16)\n \t  break;\n \tseen_hexit = true;\n "}]}