{"sha": "95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVmN2QxMWIwYWM2ZDdmNGQ4MmJhNDA0NWM2ZDhhNzQ3YTIzZGI2MA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T11:59:40Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T11:59:40Z"}, "message": "tree-loop-distribution.c (ref_base_address): Delete.\n\n\t* tree-loop-distribution.c (ref_base_address): Delete.\n\t(similar_memory_accesses): Rename ...\n\t(share_memory_accesses): ... to this.  Check if partitions access\n\tthe same memory reference.\n\t(distribute_loop): Call share_memory_accesses.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/ldist-6.c: XFAIL.\n\nFrom-SVN: r249990", "tree": {"sha": "0e9dd5382745ad8b9719f64511972efde8e8b8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e9dd5382745ad8b9719f64511972efde8e8b8cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/comments", "author": null, "committer": null, "parents": [{"sha": "a7a44c07369631201744422c02dbe59655201865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a44c07369631201744422c02dbe59655201865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a44c07369631201744422c02dbe59655201865"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "2843435309d8a84d7a80fdaee3d676eed001b913", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "patch": "@@ -1,3 +1,11 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (ref_base_address): Delete.\n+\t(similar_memory_accesses): Rename ...\n+\t(share_memory_accesses): ... to this.  Check if partitions access\n+\tthe same memory reference.\n+\t(distribute_loop): Call share_memory_accesses.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (struct partition): New field recording"}, {"sha": "fe6f4f328a5d4639230bc695ef029808d673fefe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "patch": "@@ -1,3 +1,7 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/ldist-6.c: XFAIL.\n+\n 2017-07-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/81300"}, {"sha": "e0a68d87f7fe9e0c784da7751ac48fdf18c148ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-6.c?ref=95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "patch": "@@ -34,4 +34,4 @@ int loop1 (int k)\n   return a[1000-2] + b[1000-1] + c[1000-2] + d[1000-2];\n }\n \n-/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" { xfail *-*-* } } } */"}, {"sha": "119863febf1e424fb71fd7a64a4e568bd968b3a1", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "patch": "@@ -1268,30 +1268,16 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition)\n     }\n }\n \n-/* For a data reference REF, return the declaration of its base\n-   address or NULL_TREE if the base is not determined.  */\n-\n-static tree\n-ref_base_address (data_reference_p dr)\n-{\n-  tree base_address = DR_BASE_ADDRESS (dr);\n-  if (base_address\n-      && TREE_CODE (base_address) == ADDR_EXPR)\n-    return TREE_OPERAND (base_address, 0);\n-\n-  return base_address;\n-}\n-\n-/* Returns true when PARTITION1 and PARTITION2 have similar memory\n-   accesses in RDG.  */\n+/* Returns true when PARTITION1 and PARTITION2 access the same memory\n+   object in RDG.  */\n \n static bool\n-similar_memory_accesses (struct graph *rdg, partition *partition1,\n-\t\t\t partition *partition2)\n+share_memory_accesses (struct graph *rdg,\n+\t\t       partition *partition1, partition *partition2)\n {\n-  unsigned i, j, k, l;\n+  unsigned i, j;\n   bitmap_iterator bi, bj;\n-  data_reference_p ref1, ref2;\n+  data_reference_p dr1, dr2;\n \n   /* First check whether in the intersection of the two partitions are\n      any loads or stores.  Common loads are the situation that happens\n@@ -1301,23 +1287,30 @@ similar_memory_accesses (struct graph *rdg, partition *partition1,\n \t|| RDG_MEM_READS_STMT (rdg, i))\n       return true;\n \n-  /* Then check all data-references against each other.  */\n-  EXECUTE_IF_SET_IN_BITMAP (partition1->stmts, 0, i, bi)\n-    if (RDG_MEM_WRITE_STMT (rdg, i)\n-\t|| RDG_MEM_READS_STMT (rdg, i))\n-      EXECUTE_IF_SET_IN_BITMAP (partition2->stmts, 0, j, bj)\n-\tif (RDG_MEM_WRITE_STMT (rdg, j)\n-\t    || RDG_MEM_READS_STMT (rdg, j))\n-\t  {\n-\t    FOR_EACH_VEC_ELT (RDG_DATAREFS (rdg, i), k, ref1)\n-\t      {\n-\t\ttree base1 = ref_base_address (ref1);\n-\t\tif (base1)\n-\t\t  FOR_EACH_VEC_ELT (RDG_DATAREFS (rdg, j), l, ref2)\n-\t\t    if (base1 == ref_base_address (ref2))\n-\t\t      return true;\n-\t      }\n-\t  }\n+  /* Then check whether the two partitions access the same memory object.  */\n+  EXECUTE_IF_SET_IN_BITMAP (partition1->datarefs, 0, i, bi)\n+    {\n+      dr1 = datarefs_vec[i];\n+\n+      if (!DR_BASE_ADDRESS (dr1)\n+\t  || !DR_OFFSET (dr1) || !DR_INIT (dr1) || !DR_STEP (dr1))\n+\tcontinue;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (partition2->datarefs, 0, j, bj)\n+\t{\n+\t  dr2 = datarefs_vec[j];\n+\n+\t  if (!DR_BASE_ADDRESS (dr2)\n+\t      || !DR_OFFSET (dr2) || !DR_INIT (dr2) || !DR_STEP (dr2))\n+\t    continue;\n+\n+\t  if (operand_equal_p (DR_BASE_ADDRESS (dr1), DR_BASE_ADDRESS (dr2), 0)\n+\t      && operand_equal_p (DR_OFFSET (dr1), DR_OFFSET (dr2), 0)\n+\t      && operand_equal_p (DR_INIT (dr1), DR_INIT (dr2), 0)\n+\t      && operand_equal_p (DR_STEP (dr1), DR_STEP (dr2), 0))\n+\t    return true;\n+\t}\n+    }\n \n   return false;\n }\n@@ -1654,7 +1647,7 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n       for (int j = i + 1;\n \t   partitions.iterate (j, &partition); ++j)\n \t{\n-\t  if (similar_memory_accesses (rdg, into, partition))\n+\t  if (share_memory_accesses (rdg, into, partition))\n \t    {\n \t      partition_merge_into (into, partition, FUSE_SHARE_REF);\n \t      partitions.unordered_remove (j);"}]}