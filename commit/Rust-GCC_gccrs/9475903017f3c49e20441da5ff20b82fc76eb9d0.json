{"sha": "9475903017f3c49e20441da5ff20b82fc76eb9d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3NTkwMzAxN2YzYzQ5ZTIwNDQxZGE1ZmYyMGI4MmZjNzZlYjlkMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-06-28T22:25:59Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-06-28T22:25:59Z"}, "message": "arm: Clean out dead code from thumb_pushpop.\n\nRenaming to thumb_pop at the same time.  The important part\nof this is removing the text-based dwarf2out calls.\n\n        * config/arm/arm.c (thumb_pop): Rename from thumb_pushpop.  Delete\n        all code and arguments that handled pushes.  Update all callers.\n\nFrom-SVN: r175606", "tree": {"sha": "1846aadb5342d06ce0edc59b82858b81fb9e33f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1846aadb5342d06ce0edc59b82858b81fb9e33f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9475903017f3c49e20441da5ff20b82fc76eb9d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9475903017f3c49e20441da5ff20b82fc76eb9d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9475903017f3c49e20441da5ff20b82fc76eb9d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9475903017f3c49e20441da5ff20b82fc76eb9d0/comments", "author": null, "committer": null, "parents": [{"sha": "d018b46e328163477ca334b844bb7ea9f99c42f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d018b46e328163477ca334b844bb7ea9f99c42f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d018b46e328163477ca334b844bb7ea9f99c42f7"}], "stats": {"total": 86, "additions": 18, "deletions": 68}, "files": [{"sha": "a56e5904fe1740bf077a0b008c3919f25c6fb07e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9475903017f3c49e20441da5ff20b82fc76eb9d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9475903017f3c49e20441da5ff20b82fc76eb9d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9475903017f3c49e20441da5ff20b82fc76eb9d0", "patch": "@@ -1,3 +1,8 @@\n+2011-06-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/arm/arm.c (thumb_pop): Rename from thumb_pushpop.  Delete\n+\tall code and arguments that handled pushes.  Update all callers.\n+\n 2011-06-28  Richard Henderson  <rth@redhat.com>\n \n \t* config/arm/arm.c (arm_output_function_prologue): Don't call"}, {"sha": "4c6041ab5534b4a26c1fb20bc0b2c2c119f2e393", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 13, "deletions": 68, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9475903017f3c49e20441da5ff20b82fc76eb9d0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9475903017f3c49e20441da5ff20b82fc76eb9d0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9475903017f3c49e20441da5ff20b82fc76eb9d0", "patch": "@@ -20188,47 +20188,25 @@ thumb1_emit_multi_reg_push (unsigned long mask, unsigned long real_regs)\n }\n \n /* Emit code to push or pop registers to or from the stack.  F is the\n-   assembly file.  MASK is the registers to push or pop.  PUSH is\n-   nonzero if we should push, and zero if we should pop.  For debugging\n-   output, if pushing, adjust CFA_OFFSET by the amount of space added\n-   to the stack.  REAL_REGS should have the same number of bits set as\n-   MASK, and will be used instead (in the same order) to describe which\n-   registers were saved - this is used to mark the save slots when we\n-   push high registers after moving them to low registers.  */\n+   assembly file.  MASK is the registers to pop.  */\n static void\n-thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n-\t       unsigned long real_regs)\n+thumb_pop (FILE *f, unsigned long mask)\n {\n   int regno;\n   int lo_mask = mask & 0xFF;\n   int pushed_words = 0;\n \n   gcc_assert (mask);\n \n-  if (lo_mask == 0 && !push && (mask & (1 << PC_REGNUM)))\n+  if (lo_mask == 0 && (mask & (1 << PC_REGNUM)))\n     {\n       /* Special case.  Do not generate a POP PC statement here, do it in\n \t thumb_exit() */\n       thumb_exit (f, -1);\n       return;\n     }\n \n-  if (push && arm_except_unwind_info (&global_options) == UI_TARGET)\n-    {\n-      fprintf (f, \"\\t.save\\t{\");\n-      for (regno = 0; regno < 15; regno++)\n-\t{\n-\t  if (real_regs & (1 << regno))\n-\t    {\n-\t      if (real_regs & ((1 << regno) -1))\n-\t\tfprintf (f, \", \");\n-\t      asm_fprintf (f, \"%r\", regno);\n-\t    }\n-\t}\n-      fprintf (f, \"}\\n\");\n-    }\n-\n-  fprintf (f, \"\\t%s\\t{\", push ? \"push\" : \"pop\");\n+  fprintf (f, \"\\tpop\\t{\");\n \n   /* Look at the low registers first.  */\n   for (regno = 0; regno <= LAST_LO_REGNUM; regno++, lo_mask >>= 1)\n@@ -20244,17 +20222,7 @@ thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n \t}\n     }\n \n-  if (push && (mask & (1 << LR_REGNUM)))\n-    {\n-      /* Catch pushing the LR.  */\n-      if (mask & 0xFF)\n-\tfprintf (f, \", \");\n-\n-      asm_fprintf (f, \"%r\", LR_REGNUM);\n-\n-      pushed_words++;\n-    }\n-  else if (!push && (mask & (1 << PC_REGNUM)))\n+  if (mask & (1 << PC_REGNUM))\n     {\n       /* Catch popping the PC.  */\n       if (TARGET_INTERWORK || TARGET_BACKTRACE\n@@ -20278,23 +20246,6 @@ thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n     }\n \n   fprintf (f, \"}\\n\");\n-\n-  if (push && pushed_words && dwarf2out_do_frame ())\n-    {\n-      char *l = dwarf2out_cfi_label (false);\n-      int pushed_mask = real_regs;\n-\n-      *cfa_offset += pushed_words * 4;\n-      dwarf2out_def_cfa (l, SP_REGNUM, *cfa_offset);\n-\n-      pushed_words = 0;\n-      pushed_mask = real_regs;\n-      for (regno = 0; regno <= 14; regno++, pushed_mask >>= 1)\n-\t{\n-\t  if (pushed_mask & 1)\n-\t    dwarf2out_reg_save (l, regno, 4 * pushed_words++ - *cfa_offset);\n-\t}\n-    }\n }\n \n /* Generate code to return from a thumb function.\n@@ -20440,8 +20391,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n     }\n \n   /* Pop as many registers as we can.  */\n-  thumb_pushpop (f, regs_available_for_popping, FALSE, NULL,\n-\t\t regs_available_for_popping);\n+  thumb_pop (f, regs_available_for_popping);\n \n   /* Process the registers we popped.  */\n   if (reg_containing_return_addr == -1)\n@@ -20522,8 +20472,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n       int  popped_into;\n       int  move_to;\n \n-      thumb_pushpop (f, regs_available_for_popping, FALSE, NULL,\n-\t\t     regs_available_for_popping);\n+      thumb_pop (f, regs_available_for_popping);\n \n       /* We have popped either FP or SP.\n \t Move whichever one it is into the correct register.  */\n@@ -20543,8 +20492,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n     {\n       int  popped_into;\n \n-      thumb_pushpop (f, regs_available_for_popping, FALSE, NULL,\n-\t\t     regs_available_for_popping);\n+      thumb_pop (f, regs_available_for_popping);\n \n       popped_into = number_of_first_bit_set (regs_available_for_popping);\n \n@@ -20876,7 +20824,7 @@ thumb_unexpanded_epilogue (void)\n \t  mask &= (2 << regno) - 1;\t/* A noop if regno == 8 */\n \n \t  /* Pop the values into the low register(s).  */\n-\t  thumb_pushpop (asm_out_file, mask, 0, NULL, mask);\n+\t  thumb_pop (asm_out_file, mask);\n \n \t  /* Move the value(s) into the high registers.  */\n \t  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n@@ -20908,12 +20856,11 @@ thumb_unexpanded_epilogue (void)\n \t structure was created which includes an adjusted stack\n \t pointer, so just pop everything.  */\n       if (live_regs_mask)\n-\tthumb_pushpop (asm_out_file, live_regs_mask, FALSE, NULL,\n-\t\t       live_regs_mask);\n+\tthumb_pop (asm_out_file, live_regs_mask);\n \n       /* We have either just popped the return address into the\n \t PC or it is was kept in LR for the entire function.\n-\t Note that thumb_pushpop has already called thumb_exit if the\n+\t Note that thumb_pop has already called thumb_exit if the\n \t PC was in the list.  */\n       if (!had_to_push_lr)\n \tthumb_exit (asm_out_file, LR_REGNUM);\n@@ -20922,8 +20869,7 @@ thumb_unexpanded_epilogue (void)\n     {\n       /* Pop everything but the return address.  */\n       if (live_regs_mask)\n-\tthumb_pushpop (asm_out_file, live_regs_mask, FALSE, NULL,\n-\t\t       live_regs_mask);\n+\tthumb_pop (asm_out_file, live_regs_mask);\n \n       if (had_to_push_lr)\n \t{\n@@ -20935,8 +20881,7 @@ thumb_unexpanded_epilogue (void)\n \t    }\n \n \t  /* Get the return address into a temporary register.  */\n-\t  thumb_pushpop (asm_out_file, 1 << LAST_ARG_REGNUM, 0, NULL,\n-\t\t\t 1 << LAST_ARG_REGNUM);\n+\t  thumb_pop (asm_out_file, 1 << LAST_ARG_REGNUM);\n \n \t  if (size > 12)\n \t    {"}]}