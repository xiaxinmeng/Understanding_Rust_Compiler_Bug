{"sha": "e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTViYWNmMzJkZDU2YWM4ZWQxMDlkN2NlYWFlZTdjZWQ1YmM1NGZjYQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-08-09T06:46:42Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-08-09T06:46:42Z"}, "message": "expr.c (var_rtx): Remove.\n\n2004-07-24  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* expr.c (var_rtx): Remove.\n\t(expand_expr_real_1) <LOOP_EXPR, EXIT_EXPR,\n\tLABELED_BLOCK_EXPR, EXIT_BLOCK_EXPR, TRUTH_ANDIF_EXPR,\n\tTRUTH_ORIF_EXPR, COMPOUND_EXPR, CONJ_EXPR, INIT_EXPR>:\n\tAbort.\n\t(expand_expr_real_1) <COND_EXPR>: Remove most special cases.\n\t* optabs.c (emit_clr_insn, emit_0_to_1_insn): Remove.\n\t* optabs.h (emit_clr_insn, emit_0_to_1_insn): Remove.\n\nFrom-SVN: r85710", "tree": {"sha": "feb0afb26e5a52a3cc92c493dd00b008d273d787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feb0afb26e5a52a3cc92c493dd00b008d273d787"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1e8ac22028a4c1881666510d506d735321f5e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e8ac22028a4c1881666510d506d735321f5e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e8ac22028a4c1881666510d506d735321f5e2c"}], "stats": {"total": 563, "additions": 82, "deletions": 481}, "files": [{"sha": "86764366904269550a581c849cd968d5b9d6f64e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "patch": "@@ -1,3 +1,14 @@\n+2004-07-24  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* expr.c (var_rtx): Remove.\n+\t(expand_expr_real_1) <LOOP_EXPR, EXIT_EXPR,\n+\tLABELED_BLOCK_EXPR, EXIT_BLOCK_EXPR, TRUTH_ANDIF_EXPR,\n+\tTRUTH_ORIF_EXPR, COMPOUND_EXPR, CONJ_EXPR, INIT_EXPR>:\n+\tAbort.\n+\t(expand_expr_real_1) <COND_EXPR>: Remove most special cases.\n+\t* optabs.c (emit_clr_insn, emit_0_to_1_insn): Remove.\n+\t* optabs.h (emit_clr_insn, emit_0_to_1_insn): Remove.\n+\n 2004-08-08  Mostafa Hagog  <mustafa@il.ibm.com>\n \tAyal Zaks <zaks@il.ibm.com>\n "}, {"sha": "0c321b95232b203cacdf239139c10000e787b594", "filename": "gcc/expr.c", "status": "modified", "additions": 71, "deletions": 458, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "patch": "@@ -144,7 +144,6 @@ static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode,\n \t\t\ttree, enum machine_mode, int, tree, int);\n-static rtx var_rtx (tree);\n \n static unsigned HOST_WIDE_INT highest_pow2_factor (tree);\n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (tree, tree);\n@@ -5898,22 +5897,6 @@ safe_from_p (rtx x, tree exp, int top_p)\n   return 1;\n }\n \n-/* Subroutine of expand_expr: return rtx if EXP is a\n-   variable or parameter; else return 0.  */\n-\n-static rtx\n-var_rtx (tree exp)\n-{\n-  STRIP_NOPS (exp);\n-  switch (TREE_CODE (exp))\n-    {\n-    case PARM_DECL:\n-    case VAR_DECL:\n-      return DECL_RTL (exp);\n-    default:\n-      return 0;\n-    }\n-}\n \f\n /* Return the highest power of two that EXP is known to be a multiple of.\n    This is used in updating alignment of MEMs in array references.  */\n@@ -6538,26 +6521,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \texpand_computed_goto (TREE_OPERAND (exp, 0));\n       return const0_rtx;\n \n-    /* These are lowered during gimplification, so we should never ever\n-       see them here.  */\n-    case LOOP_EXPR:\n-    case EXIT_EXPR:\n-      abort ();\n-\n-    case LABELED_BLOCK_EXPR:\n-      if (LABELED_BLOCK_BODY (exp))\n-\texpand_expr_stmt (LABELED_BLOCK_BODY (exp));\n-      /* Should perhaps use expand_label, but this is simpler and safer.  */\n-      do_pending_stack_adjust ();\n-      emit_label (label_rtx (LABELED_BLOCK_LABEL (exp)));\n-      return const0_rtx;\n-\n-    case EXIT_BLOCK_EXPR:\n-      if (EXIT_BLOCK_RETURN (exp))\n-\tsorry (\"returned value in block_exit_expr\");\n-      expand_goto (LABELED_BLOCK_LABEL (EXIT_BLOCK_LABELED_BLOCK (exp)));\n-      return const0_rtx;\n-\n     case CONSTRUCTOR:\n       /* If we don't need the result, just ensure we evaluate any\n \t subexpressions.  */\n@@ -7827,34 +7790,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  return temp;\n \t}\n \n-      /* If no set-flag instruction, must generate a conditional\n-\t store into a temporary variable.  Drop through\n-\t and handle this like && and ||.  */\n-\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-      if (! ignore\n-\t  && (target == 0\n-\t      || modifier == EXPAND_STACK_PARM\n-\t      || ! safe_from_p (target, exp, 1)\n-\t      /* Make sure we don't have a hard reg (such as function's return\n-\t\t value) live across basic blocks, if not optimizing.  */\n-\t      || (!optimize && REG_P (target)\n-\t\t  && REGNO (target) < FIRST_PSEUDO_REGISTER)))\n-\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n-\n-      if (target)\n-\temit_clr_insn (target);\n-\n-      op1 = gen_label_rtx ();\n-      jumpifnot (exp, op1);\n-\n-      if (target)\n-\temit_0_to_1_insn (target);\n-\n-      emit_label (op1);\n-      return ignore ? const0_rtx : target;\n-\n     case TRUTH_NOT_EXPR:\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n@@ -7867,12 +7802,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tabort ();\n       return temp;\n \n-    case COMPOUND_EXPR:\n-      expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n-      return expand_expr_real (TREE_OPERAND (exp, 1),\n-\t\t\t       (ignore ? const0_rtx : target),\n-\t\t\t       VOIDmode, modifier, alt_rtl);\n-\n     case STATEMENT_LIST:\n       {\n \ttree_stmt_iterator iter;\n@@ -7890,350 +7819,66 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (VOID_TYPE_P (TREE_TYPE (exp)))\n \t{\n \t  tree pred = TREE_OPERAND (exp, 0);\n-\t  tree then_ = TREE_OPERAND (exp, 1);\n-\t  tree else_ = TREE_OPERAND (exp, 2);\n-\n-\t  if (TREE_CODE (then_) == GOTO_EXPR\n-\t      && TREE_CODE (GOTO_DESTINATION (then_)) == LABEL_DECL)\n-\t    {\n-\t      jumpif (pred, label_rtx (GOTO_DESTINATION (then_)));\n-\t      return expand_expr (else_, const0_rtx, VOIDmode, 0);\n-\t    }\n-\t  else if (TREE_CODE (else_) == GOTO_EXPR\n-\t\t   && TREE_CODE (GOTO_DESTINATION (else_)) == LABEL_DECL)\n-\t    {\n-\t      jumpifnot (pred, label_rtx (GOTO_DESTINATION (else_)));\n-\t      return expand_expr (then_, const0_rtx, VOIDmode, 0);\n-\t    }\n-\n-\t  /* Just use the 'if' machinery.  */\n-\t  expand_start_cond (pred, 0);\n-\t  expand_expr (then_, const0_rtx, VOIDmode, 0);\n-\n-\t  exp = else_;\n-\n-\t  /* Iterate over 'else if's instead of recursing.  */\n-\t  for (; TREE_CODE (exp) == COND_EXPR; exp = TREE_OPERAND (exp, 2))\n-\t    {\n-\t      expand_start_else ();\n-\t      if (EXPR_HAS_LOCATION (exp))\n-\t\t{\n-\t\t  emit_line_note (EXPR_LOCATION (exp));\n-\t\t  record_block_change (TREE_BLOCK (exp));\n-\t\t}\n-\t      expand_elseif (TREE_OPERAND (exp, 0));\n-\t      expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, 0);\n-\t    }\n-\t  /* Don't emit the jump and label if there's no 'else' clause.  */\n-\t  if (TREE_SIDE_EFFECTS (exp))\n-\t    {\n-\t      expand_start_else ();\n-\t      expand_expr (exp, const0_rtx, VOIDmode, 0);\n-\t    }\n-\t  expand_end_cond ();\n-\t  return const0_rtx;\n-\t}\n-\n-      /* If we would have a \"singleton\" (see below) were it not for a\n-\t conversion in each arm, bring that conversion back out.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 1)) == NOP_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (exp, 2)) == NOP_EXPR\n-\t  && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 1), 0))\n-\t      == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 2), 0))))\n-\t{\n-\t  tree iftrue = TREE_OPERAND (TREE_OPERAND (exp, 1), 0);\n-\t  tree iffalse = TREE_OPERAND (TREE_OPERAND (exp, 2), 0);\n-\n-\t  if ((TREE_CODE_CLASS (TREE_CODE (iftrue)) == '2'\n-\t       && operand_equal_p (iffalse, TREE_OPERAND (iftrue, 0), 0))\n-\t      || (TREE_CODE_CLASS (TREE_CODE (iffalse)) == '2'\n-\t\t  && operand_equal_p (iftrue, TREE_OPERAND (iffalse, 0), 0))\n-\t      || (TREE_CODE_CLASS (TREE_CODE (iftrue)) == '1'\n-\t\t  && operand_equal_p (iffalse, TREE_OPERAND (iftrue, 0), 0))\n-\t      || (TREE_CODE_CLASS (TREE_CODE (iffalse)) == '1'\n-\t\t  && operand_equal_p (iftrue, TREE_OPERAND (iffalse, 0), 0)))\n-\t    return expand_expr (build1 (NOP_EXPR, type,\n-\t\t\t\t\tbuild3 (COND_EXPR, TREE_TYPE (iftrue),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 0),\n-\t\t\t\t\t\tiftrue, iffalse)),\n-\t\t\t\ttarget, tmode, modifier);\n-\t}\n-\n-      {\n-\t/* Note that COND_EXPRs whose type is a structure or union\n-\t   are required to be constructed to contain assignments of\n-\t   a temporary variable, so that we can evaluate them here\n-\t   for side effect only.  If type is void, we must do likewise.  */\n-\n-\t/* If an arm of the branch requires a cleanup,\n-\t   only that cleanup is performed.  */\n-\n-\ttree singleton = 0;\n-\ttree binary_op = 0, unary_op = 0;\n-\n-\t/* If this is (A ? 1 : 0) and A is a condition, just evaluate it and\n-\t   convert it to our mode, if necessary.  */\n-\tif (integer_onep (TREE_OPERAND (exp, 1))\n-\t    && integer_zerop (TREE_OPERAND (exp, 2))\n-\t    && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<')\n-\t  {\n-\t    if (ignore)\n-\t      {\n-\t\texpand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n-\t\t\t     modifier);\n-\t\treturn const0_rtx;\n-\t      }\n-\n-\t    if (modifier == EXPAND_STACK_PARM)\n-\t      target = 0;\n-\t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, modifier);\n-\t    if (GET_MODE (op0) == mode)\n-\t      return op0;\n-\n-\t    if (target == 0)\n-\t      target = gen_reg_rtx (mode);\n-\t    convert_move (target, op0, unsignedp);\n-\t    return target;\n-\t  }\n-\n-\t/* Check for X ? A + B : A.  If we have this, we can copy A to the\n-\t   output and conditionally add B.  Similarly for unary operations.\n-\t   Don't do this if X has side-effects because those side effects\n-\t   might affect A or B and the \"?\" operation is a sequence point in\n-\t   ANSI.  (operand_equal_p tests for side effects.)  */\n-\n-\tif (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 1))) == '2'\n-\t    && operand_equal_p (TREE_OPERAND (exp, 2),\n-\t\t\t\tTREE_OPERAND (TREE_OPERAND (exp, 1), 0), 0))\n-\t  singleton = TREE_OPERAND (exp, 2), binary_op = TREE_OPERAND (exp, 1);\n-\telse if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 2))) == '2'\n-\t\t && operand_equal_p (TREE_OPERAND (exp, 1),\n-\t\t\t\t     TREE_OPERAND (TREE_OPERAND (exp, 2), 0), 0))\n-\t  singleton = TREE_OPERAND (exp, 1), binary_op = TREE_OPERAND (exp, 2);\n-\telse if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 1))) == '1'\n-\t\t && operand_equal_p (TREE_OPERAND (exp, 2),\n-\t\t\t\t     TREE_OPERAND (TREE_OPERAND (exp, 1), 0), 0))\n-\t  singleton = TREE_OPERAND (exp, 2), unary_op = TREE_OPERAND (exp, 1);\n-\telse if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 2))) == '1'\n-\t\t && operand_equal_p (TREE_OPERAND (exp, 1),\n-\t\t\t\t     TREE_OPERAND (TREE_OPERAND (exp, 2), 0), 0))\n-\t  singleton = TREE_OPERAND (exp, 1), unary_op = TREE_OPERAND (exp, 2);\n-\n-\t/* If we are not to produce a result, we have no target.  Otherwise,\n-\t   if a target was specified use it; it will not be used as an\n-\t   intermediate target unless it is safe.  If no target, use a\n-\t   temporary.  */\n-\n-\tif (ignore)\n-\t  temp = 0;\n-\telse if (modifier == EXPAND_STACK_PARM)\n-\t  temp = assign_temp (type, 0, 0, 1);\n-\telse if (original_target\n-\t\t && (safe_from_p (original_target, TREE_OPERAND (exp, 0), 1)\n-\t\t     || (singleton && REG_P (original_target)\n-\t\t\t && REGNO (original_target) >= FIRST_PSEUDO_REGISTER\n-\t\t\t && original_target == var_rtx (singleton)))\n-\t\t && GET_MODE (original_target) == mode\n+  \t  tree then_ = TREE_OPERAND (exp, 1);\n+  \t  tree else_ = TREE_OPERAND (exp, 2);\n+  \n+\t  if (TREE_CODE (then_) != GOTO_EXPR\n+\t      || TREE_CODE (GOTO_DESTINATION (then_)) != LABEL_DECL\n+\t      || TREE_CODE (else_) != GOTO_EXPR\n+\t      || TREE_CODE (GOTO_DESTINATION (else_)) != LABEL_DECL)\n+\t    abort ();\n+  \n+\t  jumpif (pred, label_rtx (GOTO_DESTINATION (then_)));\n+\t  return expand_expr (else_, const0_rtx, VOIDmode, 0);\n+  \t}\n+  \n+        /* Note that COND_EXPRs whose type is a structure or union\n+  \t are required to be constructed to contain assignments of\n+  \t a temporary variable, so that we can evaluate them here\n+  \t for side effect only.  If type is void, we must do likewise.  */\n+\n+        if (TREE_ADDRESSABLE (type)\n+ \t  || ignore\n+ \t  || TREE_TYPE (TREE_OPERAND (exp, 1)) == void_type_node\n+ \t  || TREE_TYPE (TREE_OPERAND (exp, 2)) == void_type_node)\n+ \tabort ();\n+       \n+       /* If we are not to produce a result, we have no target.  Otherwise,\n+ \t if a target was specified use it; it will not be used as an\n+ \t intermediate target unless it is safe.  If no target, use a\n+ \t temporary.  */\n+       \n+       if (modifier != EXPAND_STACK_PARM\n+ \t  && original_target\n+ \t  && safe_from_p (original_target, TREE_OPERAND (exp, 0), 1)\n+ \t  && GET_MODE (original_target) == mode\n #ifdef HAVE_conditional_move\n-\t\t && (! can_conditionally_move_p (mode)\n-\t\t     || REG_P (original_target)\n-\t\t     || TREE_ADDRESSABLE (type))\n+ \t  && (! can_conditionally_move_p (mode)\n+ \t      || REG_P (original_target))\n #endif\n-\t\t && (!MEM_P (original_target)\n-\t\t     || TREE_ADDRESSABLE (type)))\n-\t  temp = original_target;\n-\telse if (TREE_ADDRESSABLE (type))\n-\t  abort ();\n-\telse\n-\t  temp = assign_temp (type, 0, 0, 1);\n-\n-\t/* If we had X ? A + C : A, with C a constant power of 2, and we can\n-\t   do the test of X as a store-flag operation, do this as\n-\t   A + ((X != 0) << log C).  Similarly for other simple binary\n-\t   operators.  Only do for C == 1 if BRANCH_COST is low.  */\n-\tif (temp && singleton && binary_op\n-\t    && (TREE_CODE (binary_op) == PLUS_EXPR\n-\t\t|| TREE_CODE (binary_op) == MINUS_EXPR\n-\t\t|| TREE_CODE (binary_op) == BIT_IOR_EXPR\n-\t\t|| TREE_CODE (binary_op) == BIT_XOR_EXPR)\n-\t    && (BRANCH_COST >= 3 ? integer_pow2p (TREE_OPERAND (binary_op, 1))\n-\t\t: integer_onep (TREE_OPERAND (binary_op, 1)))\n-\t    && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<')\n-\t  {\n-\t    rtx result;\n-\t    tree cond;\n-\t    optab boptab = (TREE_CODE (binary_op) == PLUS_EXPR\n-\t\t\t    ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n-\t\t\t       ? addv_optab : add_optab)\n-\t\t\t    : TREE_CODE (binary_op) == MINUS_EXPR\n-\t\t\t    ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n-\t\t\t       ? subv_optab : sub_optab)\n-\t\t\t    : TREE_CODE (binary_op) == BIT_IOR_EXPR ? ior_optab\n-\t\t\t    : xor_optab);\n-\n-\t    /* If we had X ? A : A + 1, do this as A + (X == 0).  */\n-\t    if (singleton == TREE_OPERAND (exp, 1))\n-\t      cond = invert_truthvalue (TREE_OPERAND (exp, 0));\n-\t    else\n-\t      cond = TREE_OPERAND (exp, 0);\n-\n-\t    result = do_store_flag (cond, (safe_from_p (temp, singleton, 1)\n-\t\t\t\t\t   ? temp : NULL_RTX),\n-\t\t\t\t    mode, BRANCH_COST <= 1);\n-\n-\t    if (result != 0 && ! integer_onep (TREE_OPERAND (binary_op, 1)))\n-\t      result = expand_shift (LSHIFT_EXPR, mode, result,\n-\t\t\t\t     build_int_2 (tree_log2\n-\t\t\t\t\t\t  (TREE_OPERAND\n-\t\t\t\t\t\t   (binary_op, 1)),\n-\t\t\t\t\t\t  0),\n-\t\t\t\t     (safe_from_p (temp, singleton, 1)\n-\t\t\t\t      ? temp : NULL_RTX), 0);\n-\n-\t    if (result)\n-\t      {\n-\t\top1 = expand_expr (singleton, NULL_RTX, VOIDmode, 0);\n-\t\treturn expand_binop (mode, boptab, op1, result, temp,\n-\t\t\t\t     unsignedp, OPTAB_LIB_WIDEN);\n-\t      }\n-\t  }\n-\n-\tdo_pending_stack_adjust ();\n-\tNO_DEFER_POP;\n-\top0 = gen_label_rtx ();\n-\n-\tif (singleton && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0)))\n-\t  {\n-\t    if (temp != 0)\n-\t      {\n-\t\t/* If the target conflicts with the other operand of the\n-\t\t   binary op, we can't use it.  Also, we can't use the target\n-\t\t   if it is a hard register, because evaluating the condition\n-\t\t   might clobber it.  */\n-\t\tif ((binary_op\n-\t\t     && ! safe_from_p (temp, TREE_OPERAND (binary_op, 1), 1))\n-\t\t    || (REG_P (temp)\n-\t\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER))\n-\t\t  temp = gen_reg_rtx (mode);\n-\t\tstore_expr (singleton, temp,\n-\t\t\t    modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t      }\n-\t    else\n-\t      expand_expr (singleton,\n-\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    if (singleton == TREE_OPERAND (exp, 1))\n-\t      jumpif (TREE_OPERAND (exp, 0), op0);\n-\t    else\n-\t      jumpifnot (TREE_OPERAND (exp, 0), op0);\n-\n-\t    if (binary_op && temp == 0)\n-\t      /* Just touch the other operand.  */\n-\t      expand_expr (TREE_OPERAND (binary_op, 1),\n-\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    else if (binary_op)\n-\t      store_expr (build2 (TREE_CODE (binary_op), type,\n-\t\t\t\t  make_tree (type, temp),\n-\t\t\t\t  TREE_OPERAND (binary_op, 1)),\n-\t\t\t  temp, modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    else\n-\t      store_expr (build1 (TREE_CODE (unary_op), type,\n-\t\t\t\t  make_tree (type, temp)),\n-\t\t\t  temp, modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    op1 = op0;\n-\t  }\n-\t/* Check for A op 0 ? A : FOO and A op 0 ? FOO : A where OP is any\n-\t   comparison operator.  If we have one of these cases, set the\n-\t   output to A, branch on A (cse will merge these two references),\n-\t   then set the output to FOO.  */\n-\telse if (temp\n-\t\t && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<'\n-\t\t && integer_zerop (TREE_OPERAND (TREE_OPERAND (exp, 0), 1))\n-\t\t && operand_equal_p (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t\t     TREE_OPERAND (exp, 1), 0)\n-\t\t && (! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n-\t\t     || TREE_CODE (TREE_OPERAND (exp, 1)) == SAVE_EXPR)\n-\t\t && safe_from_p (temp, TREE_OPERAND (exp, 2), 1))\n-\t  {\n-\t    if (REG_P (temp)\n-\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n-\t      temp = gen_reg_rtx (mode);\n-\t    store_expr (TREE_OPERAND (exp, 1), temp,\n-\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    jumpif (TREE_OPERAND (exp, 0), op0);\n-\n-\t    if (TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node)\n-\t      store_expr (TREE_OPERAND (exp, 2), temp,\n-\t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    else\n-\t      expand_expr (TREE_OPERAND (exp, 2),\n-\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    op1 = op0;\n-\t  }\n-\telse if (temp\n-\t\t && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<'\n-\t\t && integer_zerop (TREE_OPERAND (TREE_OPERAND (exp, 0), 1))\n-\t\t && operand_equal_p (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t\t     TREE_OPERAND (exp, 2), 0)\n-\t\t && (! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n-\t\t     || TREE_CODE (TREE_OPERAND (exp, 2)) == SAVE_EXPR)\n-\t\t && safe_from_p (temp, TREE_OPERAND (exp, 1), 1))\n-\t  {\n-\t    if (REG_P (temp)\n-\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n-\t      temp = gen_reg_rtx (mode);\n-\t    store_expr (TREE_OPERAND (exp, 2), temp,\n-\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n-\n-\t    if (TREE_TYPE (TREE_OPERAND (exp, 1)) != void_type_node)\n-\t      store_expr (TREE_OPERAND (exp, 1), temp,\n-\t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    else\n-\t      expand_expr (TREE_OPERAND (exp, 1),\n-\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    op1 = op0;\n-\t  }\n-\telse\n-\t  {\n-\t    op1 = gen_label_rtx ();\n-\t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n-\n-\t    /* One branch of the cond can be void, if it never returns. For\n-\t       example A ? throw : E  */\n-\t    if (temp != 0\n-\t\t&& TREE_TYPE (TREE_OPERAND (exp, 1)) != void_type_node)\n-\t      store_expr (TREE_OPERAND (exp, 1), temp,\n-\t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    else\n-\t      expand_expr (TREE_OPERAND (exp, 1),\n-\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    emit_jump_insn (gen_jump (op1));\n-\t    emit_barrier ();\n-\t    emit_label (op0);\n-\t    if (temp != 0\n-\t\t&& TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node)\n-\t      store_expr (TREE_OPERAND (exp, 2), temp,\n-\t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\t    else\n-\t      expand_expr (TREE_OPERAND (exp, 2),\n-\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t  }\n-\n-\temit_label (op1);\n-\tOK_DEFER_POP;\n-\n-\treturn temp;\n-      }\n-\n-    case INIT_EXPR:\n-      {\n-\ttree lhs = TREE_OPERAND (exp, 0);\n-\ttree rhs = TREE_OPERAND (exp, 1);\n-\n-\ttemp = expand_assignment (lhs, rhs, ! ignore);\n-\treturn temp;\n-      }\n-\n+ \t  && !MEM_P (original_target))\n+ \ttemp = original_target;\n+       else\n+ \ttemp = assign_temp (type, 0, 0, 1);\n+       \n+       do_pending_stack_adjust ();\n+       NO_DEFER_POP;\n+       op0 = gen_label_rtx ();\n+       op1 = gen_label_rtx ();\n+       jumpifnot (TREE_OPERAND (exp, 0), op0);\n+       store_expr (TREE_OPERAND (exp, 1), temp,\n+ \t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n+       \n+       emit_jump_insn (gen_jump (op1));\n+       emit_barrier ();\n+       emit_label (op0);\n+       store_expr (TREE_OPERAND (exp, 2), temp,\n+ \t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n+       \n+       emit_label (op1);\n+       OK_DEFER_POP;\n+       return temp;\n+  \n     case MODIFY_EXPR:\n       {\n \t/* If lhs is complex, expand calls in rhs before computing it.\n@@ -8466,47 +8111,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n       return gen_imagpart (mode, op0);\n \n-    case CONJ_EXPR:\n-      {\n-\tenum machine_mode partmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n-\trtx imag_t;\n-\trtx insns;\n-\n-\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n-\n-\tif (! target)\n-\t  target = gen_reg_rtx (mode);\n-\n-\tstart_sequence ();\n-\n-\t/* Store the realpart and the negated imagpart to target.  */\n-\temit_move_insn (gen_realpart (partmode, target),\n-\t\t\tgen_realpart (partmode, op0));\n-\n-\timag_t = gen_imagpart (partmode, target);\n-\ttemp = expand_unop (partmode,\n-\t\t\t    ! unsignedp && flag_trapv\n-\t\t\t    && (GET_MODE_CLASS(partmode) == MODE_INT)\n-\t\t\t    ? negv_optab : neg_optab,\n-\t\t\t    gen_imagpart (partmode, op0), imag_t, 0);\n-\tif (temp != imag_t)\n-\t  emit_move_insn (imag_t, temp);\n-\n-\tinsns = get_insns ();\n-\tend_sequence ();\n-\n-\t/* Conjugate should appear as a single unit\n-\t   If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS,\n-\t   each with a separate pseudo as destination.\n-\t   It's not correct for flow to treat them as a unit.  */\n-\tif (GET_CODE (target) != CONCAT)\n-\t  emit_no_conflict_block (insns, target, op0, NULL_RTX, NULL_RTX);\n-\telse\n-\t  emit_insn (insns);\n-\n-\treturn target;\n-      }\n-\n     case RESX_EXPR:\n       expand_resx_expr (exp);\n       return const0_rtx;\n@@ -8524,6 +8128,19 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case CASE_LABEL_EXPR:\n     case VA_ARG_EXPR:\n     case BIND_EXPR:\n+    case INIT_EXPR:\n+    case CONJ_EXPR:\n+    case COMPOUND_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case LOOP_EXPR:\n+    case EXIT_EXPR:\n+    case LABELED_BLOCK_EXPR:\n+    case EXIT_BLOCK_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n       /* Lowered by gimplify.c.  */\n       abort ();\n \n@@ -8533,10 +8150,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case FILTER_EXPR:\n       return get_exception_filter (cfun);\n \n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n     case FDESC_EXPR:\n       /* Function descriptors are not valid except for as\n \t initialization constants, and should not be expanded.  */"}, {"sha": "b76e952a954cc3d40f72758a0521739cd21529f9", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "patch": "@@ -3612,23 +3612,6 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n     }\n }\n \f\n-/* Generate code to store zero in X.  */\n-\n-void\n-emit_clr_insn (rtx x)\n-{\n-  emit_move_insn (x, const0_rtx);\n-}\n-\n-/* Generate code to store 1 in X\n-   assuming it contains zero beforehand.  */\n-\n-void\n-emit_0_to_1_insn (rtx x)\n-{\n-  emit_move_insn (x, const1_rtx);\n-}\n-\n /* Nonzero if we can perform a comparison of mode MODE straightforwardly.\n    PURPOSE describes how this comparison will be used.  CODE is the rtx\n    comparison code we will be using."}, {"sha": "2e24c2450214bb618de2d1590abd6d2e854f7269", "filename": "gcc/optabs.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=e5bacf32dd56ac8ed109d7ceaaee7ced5bc54fca", "patch": "@@ -435,12 +435,6 @@ extern void emit_unop_insn (int, rtx, rtx, enum rtx_code);\n    word at a time.  */\n extern rtx emit_no_conflict_block (rtx, rtx, rtx, rtx, rtx);\n \n-/* Emit one rtl instruction to store zero in specified rtx.  */\n-extern void emit_clr_insn (rtx);\n-\n-/* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\n-extern void emit_0_to_1_insn (rtx);\n-\n /* Emit one rtl insn to compare two rtx's.  */\n extern void emit_cmp_insn (rtx, rtx, enum rtx_code, rtx, enum machine_mode,\n \t\t\t   int);"}]}