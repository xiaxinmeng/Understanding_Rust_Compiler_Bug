{"sha": "769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY5ODI4YWJhZjlhODdiYTA0M2EwYjk1OGMxYmI1ZDE4MzNjZjZlMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-11-12T09:22:28Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-11-12T09:22:28Z"}, "message": "h8300.c (shift_alg_qi): New.\n\n\t* config/h8300/h8300.c (shift_alg_qi): New.\n\t(shift_alg_hi): Likewise.\n\t(shift_alg_si): Likewise.\n\t(get_shift_alg): Change the type of count to unsigned int.\n\tUse the tables.\n\nFrom-SVN: r46937", "tree": {"sha": "289728d648d87735a47aa74284e7261c6a3e4f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/289728d648d87735a47aa74284e7261c6a3e4f7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769828abaf9a87ba043a0b958c1bb5d1833cf6e3/comments", "author": null, "committer": null, "parents": [{"sha": "d676d94e5b99dd7c477c4ace7caba214805c21f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d676d94e5b99dd7c477c4ace7caba214805c21f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d676d94e5b99dd7c477c4ace7caba214805c21f1"}], "stats": {"total": 273, "additions": 213, "deletions": 60}, "files": [{"sha": "7b641c45288bcd3163e43b84c00c79f3a97632b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/769828abaf9a87ba043a0b958c1bb5d1833cf6e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/769828abaf9a87ba043a0b958c1bb5d1833cf6e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "patch": "@@ -1,3 +1,11 @@\n+2001-11-12  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/h8300/h8300.c (shift_alg_qi): New.\n+\t(shift_alg_hi): Likewise.\n+\t(shift_alg_si): Likewise.\n+\t(get_shift_alg): Change the type of count to unsigned int.\n+\tUse the tables.\n+\n 2001-11-11  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* Makefile.in (c-lang.o): Depend on $(VARRAY_H)."}, {"sha": "5dda782978398e0876b4261006fdfecab2d968df", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 205, "deletions": 60, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/769828abaf9a87ba043a0b958c1bb5d1833cf6e3/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/769828abaf9a87ba043a0b958c1bb5d1833cf6e3/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "patch": "@@ -2154,6 +2154,142 @@ static const char *const rotate_two[3][3] =\n     }\n };\n \n+/* Macros to keep the shift algorithm tables small.  */\n+#define INL SHIFT_INLINE\n+#define ROT SHIFT_ROT_AND\n+#define LOP SHIFT_LOOP\n+#define SPC SHIFT_SPECIAL\n+\n+/* The shift algorithms for each machine, mode, shift type, and shift\n+   count are defined below.  The three tables below correspond to\n+   QImode, HImode, and SImode, respectively.  Each table is organized\n+   by, in the order of indecies, machine, shift type, and shift count.  */\n+\n+static const enum shift_alg shift_alg_qi[3][3][8] = {\n+  {\n+    /* TARGET_H8300  */\n+    /* 0    1    2    3    4    5    6    7  */\n+    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC }  /* SHIFT_ASHIFTRT */\n+  },\n+  {\n+    /* TARGET_H8300H  */\n+    /* 0    1    2    3    4    5    6    7  */\n+    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC }  /* SHIFT_ASHIFTRT */\n+  },\n+  {\n+    /* TARGET_H8300S  */\n+    /*  0    1    2    3    4    5    6    7  */\n+    { INL, INL, INL, INL, INL, INL, INL, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, INL, INL, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, INL, INL, SPC }  /* SHIFT_ASHIFTRT */\n+  }\n+};\n+\n+static const enum shift_alg shift_alg_hi[3][3][16] = {\n+  {\n+    /* TARGET_H8300  */\n+    /*  0    1    2    3    4    5    6    7  */\n+    /*  8    9   10   11   12   13   14   15  */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */\n+  },\n+  {\n+    /* TARGET_H8300H  */\n+    /*  0    1    2    3    4    5    6    7  */\n+    /*  8    9   10   11   12   13   14   15  */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n+      SPC, SPC, SPC, SPC, SPC, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n+      SPC, SPC, SPC, SPC, SPC, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */\n+  },\n+  {\n+    /* TARGET_H8300S  */\n+    /*  0    1    2    3    4    5    6    7  */\n+    /*  8    9   10   11   12   13   14   15  */\n+    { INL, INL, INL, INL, INL, INL, INL, INL,\n+      SPC, SPC, SPC, SPC, SPC, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, INL, INL, INL,\n+      SPC, SPC, SPC, SPC, SPC, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, INL, INL, INL,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */\n+  }\n+};\n+\n+static const enum shift_alg shift_alg_si[3][3][32] = {\n+  {\n+    /* TARGET_H8300  */\n+    /*  0    1    2    3    4    5    6    7  */\n+    /*  8    9   10   11   12   13   14   15  */\n+    /* 16   17   18   19   20   21   22   23  */\n+    /* 24   25   26   27   28   29   30   31  */\n+    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      LOP, LOP, LOP, LOP, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      LOP, LOP, LOP, LOP, LOP, LOP, LOP, SPC }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      LOP, LOP, LOP, LOP, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */\n+  },\n+  {\n+    /* TARGET_H8300H  */\n+    /*  0    1    2    3    4    5    6    7  */\n+    /*  8    9   10   11   12   13   14   15  */\n+    /* 16   17   18   19   20   21   22   23  */\n+    /* 24   25   26   27   28   29   30   31  */\n+    { INL, INL, INL, INL, INL, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      SPC, SPC, SPC, SPC, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, ROT, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      SPC, SPC, SPC, SPC, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, ROT, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n+      SPC, SPC, SPC, SPC, LOP, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */\n+  },\n+  {\n+    /* TARGET_H8300S  */\n+    /*  0    1    2    3    4    5    6    7  */\n+    /*  8    9   10   11   12   13   14   15  */\n+    /* 16   17   18   19   20   21   22   23  */\n+    /* 24   25   26   27   28   29   30   31  */\n+    { INL, INL, INL, INL, INL, INL, INL, INL,\n+      INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, ROT, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */\n+    { INL, INL, INL, INL, INL, INL, INL, INL,\n+      INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, ROT, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */\n+    { INL, INL, INL, INL, INL, INL, INL, INL,\n+      INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n+      SPC, SPC, SPC, SPC, SPC, LOP, LOP, LOP,\n+      SPC, LOP, LOP, LOP, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */\n+  }\n+};\n+\n+#undef INL\n+#undef ROT\n+#undef LOP\n+#undef SPC\n+\n struct shift_info {\n   /* Shift algorithm.  */\n   enum shift_alg alg;\n@@ -2178,7 +2314,7 @@ struct shift_info {\n };\n \n static void get_shift_alg PARAMS ((enum shift_type,\n-\t\t\t\t   enum shift_mode, int,\n+\t\t\t\t   enum shift_mode, unsigned int,\n \t\t\t\t   struct shift_info *));\n \n /* Given SHIFT_TYPE, SHIFT_MODE, and shift count COUNT, determine the\n@@ -2198,9 +2334,19 @@ static void\n get_shift_alg (shift_type, shift_mode, count, info)\n      enum shift_type shift_type;\n      enum shift_mode shift_mode;\n-     int count;\n+     unsigned int count;\n      struct shift_info *info;\n {\n+  int cpu;\n+\n+  /* Find the target CPU.  */\n+  if (TARGET_H8300)\n+    cpu = 0;\n+  else if (TARGET_H8300H)\n+    cpu = 1;\n+  else\n+    cpu = 2;\n+\n   /* In case we end up with SHIFT_SPECIAL, initialize REMAINDER to 0.  */\n   info->remainder = 0;\n \n@@ -2214,37 +2360,47 @@ get_shift_alg (shift_type, shift_mode, count, info)\n   switch (shift_mode)\n     {\n     case QIshift:\n-      if (count <= 4)\n-\tgoto return_shift_inline;\n-      else\n+      if (GET_MODE_BITSIZE (QImode) <= count)\n+\tgoto return_shift_loop;\n+\n+      switch (shift_alg_qi[cpu][shift_type][count])\n \t{\n-\t  /* Shift by 5/6 are only 3 insns on the H8/S, so it's just as\n-\t     fast as SHIFT_ROT_AND, plus CC is valid.  */\n-\t  if (TARGET_H8300S && count <= 6)\n-\t    goto return_shift_inline;\n-\n-\t  /* For ASHIFTRT by 7 bits, the sign bit is simply replicated\n-\t     through the entire value.  */\n-\t  if (shift_type == SHIFT_ASHIFTRT && count == 7)\n-\t    {\n-\t      info->special = \"shll\\t%X0\\n\\tsubx\\t%X0,%X0\";\n-\t      goto return_shift_special;\n-\t    }\n+\tcase SHIFT_INLINE:\n+\t  goto return_shift_inline;\n+\tcase SHIFT_LOOP:\n+\t  goto return_shift_loop;\n+\tcase SHIFT_ROT_AND:\n+\t  goto return_shift_rot_and;\n+\tcase SHIFT_SPECIAL:\n+\t  ;\n+\t}\n \n-\t  /* Other ASHIFTRTs are too much of a pain.  */\n-\t  if (shift_type == SHIFT_ASHIFTRT)\n-\t    goto return_shift_loop;\n+      /* For ASHIFTRT by 7 bits, the sign bit is simply replicated\n+\t through the entire value.  */\n+      if (shift_type == SHIFT_ASHIFTRT && count == 7)\n+\t{\n+\t  info->special = \"shll\\t%X0\\n\\tsubx\\t%X0,%X0\";\n+\t  goto return_shift_special;\n+\t}\n+      abort ();\n+\n+    case HIshift:\n+      if (GET_MODE_BITSIZE (HImode) <= count)\n+\tgoto return_shift_loop;\n \n-\t  /* Other shifts by 5, 6, or 7 bits use SHIFT_ROT_AND.  */\n+      switch (shift_alg_hi[cpu][shift_type][count])\n+\t{\n+\tcase SHIFT_INLINE:\n+\t  goto return_shift_inline;\n+\tcase SHIFT_LOOP:\n+\t  goto return_shift_loop;\n+\tcase SHIFT_ROT_AND:\n \t  goto return_shift_rot_and;\n+\tcase SHIFT_SPECIAL:\n+\t  ;\n \t}\n \n-    case HIshift:\n-      if (count <= 4)\n-\tgoto return_shift_inline;\n-      else if (TARGET_H8300S && count <= 7)\n-\tgoto return_shift_inline;\n-      else if (count == 7)\n+      if (count == 7)\n \t{\n \t  if (shift_type == SHIFT_ASHIFT && TARGET_H8300)\n \t    {\n@@ -2302,27 +2458,31 @@ get_shift_alg (shift_type, shift_mode, count, info)\n \t      goto return_shift_special;\n \t    }\n \t}\n-      else if ((!TARGET_H8300 && (count == 13 || count == 14))\n-\t       || count == 15)\n+      else if (count == 15 && shift_type == SHIFT_ASHIFTRT)\n \t{\n-\t  if (count == 15 && shift_type == SHIFT_ASHIFTRT)\n-\t    {\n-\t      info->special = \"shll\\t%t0\\n\\tsubx\\t%t0,%t0\\n\\tmov.b\\t%t0,%s0\";\n-\t      goto return_shift_special;\n-\t    }\n-\t  else if (shift_type != SHIFT_ASHIFTRT)\n-\t    {\n-\t      goto return_shift_rot_and;\n-\t    }\n+\t  info->special = \"shll\\t%t0\\n\\tsubx\\t%t0,%t0\\n\\tmov.b\\t%t0,%s0\";\n+\t  goto return_shift_special;\n \t}\n-      break;\n+      abort ();\n \n     case SIshift:\n-      if (count <= (TARGET_H8300 ? 2 : 4))\n-\tgoto return_shift_inline;\n-      else if (TARGET_H8300S && count <= 10)\n-\tgoto return_shift_inline;\n-      else if (count == 8 && TARGET_H8300)\n+      if (GET_MODE_BITSIZE (SImode) <= count)\n+\tgoto return_shift_loop;\n+\n+      info->alg = shift_alg_si[cpu][shift_type][count];\n+      switch (info->alg)\n+\t{\n+\tcase SHIFT_INLINE:\n+\t  goto return_shift_inline;\n+\tcase SHIFT_LOOP:\n+\t  goto return_shift_loop;\n+\tcase SHIFT_ROT_AND:\n+\t  goto return_shift_rot_and;\n+\tcase SHIFT_SPECIAL:\n+\t  ;\n+\t}\n+\n+      if (count == 8 && TARGET_H8300)\n \t{\n \t  switch (shift_type)\n \t    {\n@@ -2395,17 +2555,6 @@ get_shift_alg (shift_type, shift_mode, count, info)\n \t      goto return_shift_special;\n \t    }\n \t}\n-      else if (count >= 28 && count <= 30 && !TARGET_H8300)\n-\t{\n-\t  if (shift_type == SHIFT_ASHIFTRT)\n-\t    {\n-\t      goto return_shift_loop;\n-\t    }\n-\t  else\n-\t    {\n-\t      goto return_shift_rot_and;\n-\t    }\n-\t}\n       else if (count == 31)\n \t{\n \t  if (shift_type == SHIFT_ASHIFTRT)\n@@ -2426,13 +2575,9 @@ get_shift_alg (shift_type, shift_mode, count, info)\n \t\t    info->special = \"sub.w\\t%f0,%f0\\n\\tshll\\t%z0\\n\\tmov.w\\t%f0,%e0\\n\\trotxl\\t%w0\";\n \t\t  goto return_shift_special;\n \t\t}\n-\t      else\n-\t\t{\n-\t\t  goto return_shift_rot_and;\n-\t\t}\n \t    }\n \t}\n-      break;\n+      abort ();\n \n     default:\n       abort ();"}]}