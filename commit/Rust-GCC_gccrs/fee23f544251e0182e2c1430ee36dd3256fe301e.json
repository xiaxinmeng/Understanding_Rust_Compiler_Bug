{"sha": "fee23f544251e0182e2c1430ee36dd3256fe301e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVlMjNmNTQ0MjUxZTAxODJlMmMxNDMwZWUzNmRkMzI1NmZlMzAxZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-10-09T19:13:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-09T19:13:22Z"}, "message": "pt.c (tsubst): Fix thinko.\n\n\t* pt.c (tsubst): Fix thinko.\n\t(instantiate_decl): Really use the original template.\n\n\t* call.c (build_new_method_call): Use simple constructor_name for\n\terror messages.\n\nFrom-SVN: r15882", "tree": {"sha": "a84ececb7d056369239fa1afe1bb734ff02e6416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a84ececb7d056369239fa1afe1bb734ff02e6416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fee23f544251e0182e2c1430ee36dd3256fe301e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee23f544251e0182e2c1430ee36dd3256fe301e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee23f544251e0182e2c1430ee36dd3256fe301e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee23f544251e0182e2c1430ee36dd3256fe301e/comments", "author": null, "committer": null, "parents": [{"sha": "c89078531b42dd05b827feb6230a209d4a54d94f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89078531b42dd05b827feb6230a209d4a54d94f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c89078531b42dd05b827feb6230a209d4a54d94f"}], "stats": {"total": 85, "additions": 44, "deletions": 41}, "files": [{"sha": "0f703f19c5819f478411413a5d9676d616cd35ec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee23f544251e0182e2c1430ee36dd3256fe301e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee23f544251e0182e2c1430ee36dd3256fe301e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fee23f544251e0182e2c1430ee36dd3256fe301e", "patch": "@@ -1,3 +1,11 @@\n+Thu Oct  9 12:08:21 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst): Fix thinko.\n+\t(instantiate_decl): Really use the original template.\n+\n+\t* call.c (build_new_method_call): Use simple constructor_name for\n+\terror messages.\n+\n Wed Oct  8 22:44:42 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* method.c (build_underscore_int): Don't use ANSI specific"}, {"sha": "8d1bd04e832dffc60d831498c69e60f69cfd2a0d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee23f544251e0182e2c1430ee36dd3256fe301e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee23f544251e0182e2c1430ee36dd3256fe301e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=fee23f544251e0182e2c1430ee36dd3256fe301e", "patch": "@@ -5538,7 +5538,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     }\n \n   pretty_name\n-    = (name == ctor_identifier ? constructor_name_full (basetype) : name);\n+    = (name == ctor_identifier ? constructor_name (basetype) : name);\n \n   fns = lookup_fnfields (basetype_path, name, 1);\n "}, {"sha": "4daf0522032a6a9c312e82a78c34497ff2e4918b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee23f544251e0182e2c1430ee36dd3256fe301e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee23f544251e0182e2c1430ee36dd3256fe301e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fee23f544251e0182e2c1430ee36dd3256fe301e", "patch": "@@ -22,9 +22,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Known bugs or deficiencies include:\n \n-     templates for class static data don't work (methods only),\n-     duplicated method templates can crash the compiler,\n-     interface/impl data is taken from file defining the template,\n      all methods must be provided in header files; can't use a source\n      file that contains only the method templates and \"just win\".  */\n \n@@ -2203,11 +2200,10 @@ tsubst (t, args, nargs, in_decl)\n \tDECL_TEMPLATE_INFO (tmpl) = build_tree_list (t, args);\n \tnew_decl = tsubst (decl, args, nargs, in_decl);\n \tDECL_RESULT (tmpl) = new_decl;\n-\tDECL_INITIAL (new_decl) = DECL_INITIAL (decl);\n \tDECL_TI_TEMPLATE (new_decl) = tmpl;\n \tTREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n \tDECL_TEMPLATE_INSTANTIATIONS (tmpl) = NULL_TREE;\n-\tSET_DECL_IMPLICIT_INSTANTIATION (decl);\n+\tSET_DECL_IMPLICIT_INSTANTIATION (tmpl);\n \n \t/* The template parameters for this new template are all the\n \t   template parameters for the old template, except the\n@@ -2344,6 +2340,13 @@ tsubst (t, args, nargs, in_decl)\n \t\t   template parameters are still just template\n \t\t   parameters; there are no corresponding subsitution\n \t\t   arguments.  */\n+\t\t/* FIXME The messed up thing here is that we get here with\n+\t\t   full args and only one level of parms.  This is necessary\n+\t\t   because when we partially instantiate a member template,\n+\t\t   even though there's really only one level of parms left\n+\t\t   we re-use the parms from the original template, which\n+\t\t   have level 2.  When this is fixed we can remove the\n+\t\t   add_to_template_args from instantiate_template.  */\n \t\ttree tparms = DECL_TEMPLATE_PARMS (tmpl);\n \n \t\twhile (tparms && TREE_CHAIN (tparms) != NULL_TREE)\n@@ -3409,8 +3412,7 @@ instantiate_template (tmpl, targ_ptr)\n       for (specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n \t   specs != NULL_TREE;\n \t   specs = TREE_CHAIN (specs))\n-\tif (comp_template_args (TREE_PURPOSE(specs),\n-\t\t\t\ttarg_ptr))\n+\tif (comp_template_args (TREE_PURPOSE (specs), targ_ptr))\n \t  return TREE_VALUE (specs);\n     }\n \n@@ -4401,45 +4403,40 @@ instantiate_decl (d)\n   tree tmpl = TI_TEMPLATE (ti);\n   tree args = TI_ARGS (ti);\n   tree td;\n-  tree pattern;\n+  tree decl_pattern, code_pattern;\n   tree save_ti;\n   int nested = in_function_p ();\n   int d_defined;\n   int pattern_defined;\n   int line = lineno;\n   char *file = input_filename;\n \n-  while (DECL_TEMPLATE_INSTANTIATION (tmpl))\n-    tmpl = DECL_TI_TEMPLATE (tmpl);\n+  if (DECL_TEMPLATE_SPECIALIZATION (d))\n+    return d;\n+\n+  for (td = tmpl; DECL_TEMPLATE_INSTANTIATION (td); )\n+    td = DECL_TI_TEMPLATE (td);\n \n-  pattern = DECL_TEMPLATE_RESULT (tmpl);\n+  /* In the case of a member template, decl_pattern is the partially\n+     instantiated declaration (in the instantiated class), and code_pattern\n+     is the original template definition.  */\n+  decl_pattern = DECL_TEMPLATE_RESULT (tmpl);\n+  code_pattern = DECL_TEMPLATE_RESULT (td);\n \n   if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n       d_defined = (DECL_INITIAL (d) != NULL_TREE);\n-      pattern_defined = (DECL_INITIAL (pattern) != NULL_TREE);\n+      pattern_defined = (DECL_INITIAL (code_pattern) != NULL_TREE);\n     }\n   else\n     {\n       d_defined = ! DECL_IN_AGGR_P (d);\n-      pattern_defined = ! DECL_IN_AGGR_P (pattern);\n+      pattern_defined = ! DECL_IN_AGGR_P (code_pattern);\n     }\n \n   if (d_defined)\n     return d;\n \n-  if (TREE_CODE (d) == FUNCTION_DECL) \n-    {\n-      tree specs;\n-\n-      /* Check to see if there is a matching specialization. */\n-      for (specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-\t   specs != NULL_TREE;\n-\t   specs = TREE_CHAIN (specs))\n-\tif (comp_template_args (TREE_PURPOSE (specs), args))\n-\t  return TREE_VALUE (specs);\n-    }\n-\n   /* This needs to happen before any tsubsting.  */\n   if (! push_tinst_level (d))\n     return d;\n@@ -4451,12 +4448,11 @@ instantiate_decl (d)\n   /* We need to set up DECL_INITIAL regardless of pattern_defined if the\n      variable is a static const initialized in the class body.  */\n   if (TREE_CODE (d) == VAR_DECL\n-      && ! DECL_INITIAL (d) && DECL_INITIAL (pattern))\n+      && ! DECL_INITIAL (d) && DECL_INITIAL (code_pattern))\n     {\n       pushclass (DECL_CONTEXT (d), 2);\n-      DECL_INITIAL (d) = tsubst_expr\n-\t(DECL_INITIAL (pattern), args,\n-\t TREE_VEC_LENGTH (args), tmpl);\n+      DECL_INITIAL (d) = tsubst_expr (DECL_INITIAL (code_pattern), args,\n+\t\t\t\t      TREE_VEC_LENGTH (args), tmpl);\n       popclass (1);\n     }\n \n@@ -4472,13 +4468,13 @@ instantiate_decl (d)\n \t      if (interface_unknown)\n \t\twarn_if_unknown_interface (d);\n \t    }\n-\t  else if (DECL_INTERFACE_KNOWN (pattern))\n+\t  else if (DECL_INTERFACE_KNOWN (code_pattern))\n \t    {\n \t      DECL_INTERFACE_KNOWN (d) = 1;\n-\t      DECL_NOT_REALLY_EXTERN (d) = ! DECL_EXTERNAL (pattern);\n+\t      DECL_NOT_REALLY_EXTERN (d) = ! DECL_EXTERNAL (code_pattern);\n \t    }\n \t  else\n-\t    warn_if_unknown_interface (pattern);\n+\t    warn_if_unknown_interface (code_pattern);\n \t}\n \n       if (at_eof)\n@@ -4503,18 +4499,17 @@ instantiate_decl (d)\n   input_filename = DECL_SOURCE_FILE (d);\n \n   /* Trick tsubst into giving us a new decl in case the template changed.  */\n-  save_ti = DECL_TEMPLATE_INFO (pattern);\n-  DECL_TEMPLATE_INFO (pattern) = NULL_TREE;\n-  td = tsubst (pattern, args, TREE_VEC_LENGTH (args), tmpl);\n-  DECL_TEMPLATE_INFO (pattern) = save_ti;\n+  save_ti = DECL_TEMPLATE_INFO (decl_pattern);\n+  DECL_TEMPLATE_INFO (decl_pattern) = NULL_TREE;\n+  td = tsubst (decl_pattern, args, TREE_VEC_LENGTH (args), tmpl);\n+  DECL_TEMPLATE_INFO (decl_pattern) = save_ti;\n \n   /* And set up DECL_INITIAL, since tsubst doesn't.  */\n   if (TREE_CODE (td) == VAR_DECL)\n     {\n       pushclass (DECL_CONTEXT (d), 2);\n-      DECL_INITIAL (td) = tsubst_expr\n-\t(DECL_INITIAL (pattern), args,\n-\t TREE_VEC_LENGTH (args), tmpl);\n+      DECL_INITIAL (td) = tsubst_expr (DECL_INITIAL (code_pattern), args,\n+\t\t\t\t       TREE_VEC_LENGTH (args), tmpl);\n       popclass (1);\n     }\n \n@@ -4546,7 +4541,7 @@ instantiate_decl (d)\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n-      tree t = DECL_SAVED_TREE (pattern);\n+      tree t = DECL_SAVED_TREE (code_pattern);\n \n       start_function (NULL_TREE, d, NULL_TREE, 1);\n       store_parm_decls ();"}]}