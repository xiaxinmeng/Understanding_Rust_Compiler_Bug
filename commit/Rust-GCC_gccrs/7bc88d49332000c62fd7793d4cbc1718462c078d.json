{"sha": "7bc88d49332000c62fd7793d4cbc1718462c078d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JjODhkNDkzMzIwMDBjNjJmZDc3OTNkNGNiYzE3MTg0NjJjMDc4ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-04T13:12:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-04T13:12:13Z"}, "message": "(output_function_{pro,epi}logue): Use addq/subq when adjusting stack\npointer by small displacements.\n\nFrom-SVN: r13366", "tree": {"sha": "6f44587a9c40e9508ad889e0b7c55cb3c55fb7b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f44587a9c40e9508ad889e0b7c55cb3c55fb7b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bc88d49332000c62fd7793d4cbc1718462c078d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc88d49332000c62fd7793d4cbc1718462c078d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bc88d49332000c62fd7793d4cbc1718462c078d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc88d49332000c62fd7793d4cbc1718462c078d/comments", "author": null, "committer": null, "parents": [{"sha": "fe1590618e122673f416ef98a14b0f5281ccd4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1590618e122673f416ef98a14b0f5281ccd4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1590618e122673f416ef98a14b0f5281ccd4b4"}], "stats": {"total": 94, "additions": 83, "deletions": 11}, "files": [{"sha": "029e89c98e26ed1b4ad36302581b2c7286fa4c6c", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 83, "deletions": 11, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bc88d49332000c62fd7793d4cbc1718462c078d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bc88d49332000c62fd7793d4cbc1718462c078d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=7bc88d49332000c62fd7793d4cbc1718462c078d", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Motorola 68000 family.\n-   Copyright (C) 1987, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -211,24 +211,61 @@ output_function_prologue (stream, size)\n     }\n   else if (fsize)\n     {\n-      /* Adding negative number is faster on the 68040.  */\n       if (fsize + 4 < 0x8000)\n \t{\n-\t  if (!TARGET_68040)\n+#ifdef NO_ADDSUB_Q\n+\t  if (fsize + 4 <= 8)\n \t    {\n+\t      if (!TARGET_5200)\n+\t\t{\n+\t\t  /* asm_fprintf() cannot handle %. */\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tlea (%d,%Rsp),%Rsp\\n\", - (fsize + 4));\n+\t\t  asm_fprintf (stream, \"\\tsubq.w %OI%d,%Rsp\\n\", fsize + 4);\n #else\n-\t      asm_fprintf (stream, \"\\tlea %Rsp@(%d),%Rsp\\n\", - (fsize + 4));\n+\t\t  asm_fprintf (stream, \"\\tsubqw %OI%d,%Rsp\\n\", fsize + 4);\n+#endif\n+\t\t}\n+\t      else\n+\t\t{\n+#ifdef MOTOROLA\n+\t\t  asm_fprintf (stream, \"\\tsubq.l %OI%d,%Rsp\\n\", fsize + 4);\n+#else\n+\t\t  asm_fprintf (stream, \"\\tsubql %OI%d,%Rsp\\n\", fsize + 4);\n #endif\n+\t\t}\n \t    }\n-\t  else\n+\t  else if (fsize + 4 <= 16 && TARGET_CPU32)\n+\t    {\n+\t      /* On the CPU32 it is faster to use two subqw instructions to\n+\t\t subtract a small integer (8 < N <= 16) to a register. */\n+\t      /* asm_fprintf() cannot handle %. */\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tsubq.w %OI8,%Rsp\\n\\tsubq.w %OI%d,%Rsp\\n\",\n+\t\t\t   fsize + 4);\n+#else\n+\t      asm_fprintf (stream, \"\\tsubqw %OI8,%Rsp\\n\\tsubqw %OI%d,%Rsp\\n\",\n+\t\t\t   fsize + 4);\n+#endif\n+\t    }\n+\t  else \n+#endif /* NO_ADDSUB_Q */\n+\t  if (TARGET_68040)\n \t    {\n+\t      /* Adding negative number is faster on the 68040.  */\n \t      /* asm_fprintf() cannot handle %. */\n #ifdef MOTOROLA\n \t      asm_fprintf (stream, \"\\tadd.w %0I%d,%Rsp\\n\", - (fsize + 4));\n #else\n \t      asm_fprintf (stream, \"\\taddw %0I%d,%Rsp\\n\", - (fsize + 4));\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+\t      /* asm_fprintf() cannot handle %. */\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tlea (%d,%Rsp),%Rsp\\n\", - (fsize + 4));\n+#else\n+\t      asm_fprintf (stream, \"\\tlea %Rsp@(%d),%Rsp\\n\", - (fsize + 4));\n #endif\n \t    }\n \t}\n@@ -640,23 +677,58 @@ output_function_epilogue (stream, size)\n \t     reg_names[FRAME_POINTER_REGNUM]);\n   else if (fsize)\n     {\n-      if (fsize + 4 < 0x8000)\n+#ifdef NO_ADDSUB_Q\n+      if (fsize + 4 <= 8) \n \t{\n-\t  if (!TARGET_68040)\n-\t    { \n+\t  if (!TARGET_5200)\n+\t    {\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tlea (%d,%Rsp),%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\taddq.w %OI%d,%Rsp\\n\", fsize + 4);\n #else\n-\t      asm_fprintf (stream, \"\\tlea %Rsp@(%d),%Rsp\\n\", fsize + 4);\n+\t      asm_fprintf (stream, \"\\taddqw %OI%d,%Rsp\\n\", fsize + 4);\n #endif\n \t    }\n \t  else\n \t    {\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\taddq.l %OI%d,%Rsp\\n\", fsize + 4);\n+#else\n+\t      asm_fprintf (stream, \"\\taddql %OI%d,%Rsp\\n\", fsize + 4);\n+#endif\n+\t    }\n+\t}\n+      else if (fsize + 4 <= 16 && TARGET_CPU32)\n+\t{\n+\t  /* On the CPU32 it is faster to use two addqw instructions to\n+\t     add a small integer (8 < N <= 16) to a register. */\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\taddq.w %OI8,%Rsp\\n\\taddq.w %OI%d,%Rsp\\n\",\n+\t\t       fsize + 4);\n+#else\n+\t  asm_fprintf (stream, \"\\taddqw %OI8,%Rsp\\n\\taddqw %OI%d,%Rsp\\n\",\n+\t\t       fsize + 4);\n+#endif\n+\t}\n+      else\n+#endif /* NO_ADDSUB_Q */\n+      if (fsize + 4 < 0x8000)\n+\t{\n+\t  if (TARGET_68040)\n+\t    { \n \t      /* asm_fprintf() cannot handle %. */\n #ifdef MOTOROLA\n \t      asm_fprintf (stream, \"\\tadd.w %0I%d,%Rsp\\n\", fsize + 4);\n #else\n \t      asm_fprintf (stream, \"\\taddw %0I%d,%Rsp\\n\", fsize + 4);\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+\t      /* asm_fprintf() cannot handle %. */\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tlea (%d,%Rsp),%Rsp\\n\", fsize + 4);\n+#else\n+\t      asm_fprintf (stream, \"\\tlea %Rsp@(%d),%Rsp\\n\", fsize + 4);\n #endif\n \t    }\n \t}"}]}