{"sha": "291fa23ac04e317877c1e102937532f080180bb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkxZmEyM2FjMDRlMzE3ODc3YzFlMTAyOTM3NTMyZjA4MDE4MGJiMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-02T09:21:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-02T09:21:57Z"}, "message": "tree-vectorizer.h (stmt_vec_info_type::cycle_phi_info_type): New.\n\n2019-10-02  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (stmt_vec_info_type::cycle_phi_info_type):\n\tNew.\n\t(vect_transform_cycle_phi): Declare.\n\t* tree-vect-stmts.c (vect_transform_stmt): Call\n\tvect_transform_cycle_phi.\n\t* tree-vect-loop.c (vectorizable_reduction): Split out\n\tPHI transformation stage to ...\n\t(vect_transform_cycle_phi): ... here.\n\nFrom-SVN: r276441", "tree": {"sha": "37c3d9a34979bc154b7de76b287aaf55d62a5b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37c3d9a34979bc154b7de76b287aaf55d62a5b4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/291fa23ac04e317877c1e102937532f080180bb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/291fa23ac04e317877c1e102937532f080180bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/291fa23ac04e317877c1e102937532f080180bb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/291fa23ac04e317877c1e102937532f080180bb2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1bcb4c4faa4bd6b1c917c75b100d618faf9e628c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bcb4c4faa4bd6b1c917c75b100d618faf9e628c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bcb4c4faa4bd6b1c917c75b100d618faf9e628c"}], "stats": {"total": 438, "additions": 239, "deletions": 199}, "files": [{"sha": "b7830a447943d1bf860965ace6813ca33cda70e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/291fa23ac04e317877c1e102937532f080180bb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/291fa23ac04e317877c1e102937532f080180bb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=291fa23ac04e317877c1e102937532f080180bb2", "patch": "@@ -1,3 +1,14 @@\n+2019-10-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (stmt_vec_info_type::cycle_phi_info_type):\n+\tNew.\n+\t(vect_transform_cycle_phi): Declare.\n+\t* tree-vect-stmts.c (vect_transform_stmt): Call\n+\tvect_transform_cycle_phi.\n+\t* tree-vect-loop.c (vectorizable_reduction): Split out\n+\tPHI transformation stage to ...\n+\t(vect_transform_cycle_phi): ... here.\n+\n 2019-10-02  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR middle-end/91957"}, {"sha": "a3fd011e6c422ad3b35a8a7d704778c5ddcbd3e6", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 219, "deletions": 199, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/291fa23ac04e317877c1e102937532f080180bb2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/291fa23ac04e317877c1e102937532f080180bb2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=291fa23ac04e317877c1e102937532f080180bb2", "patch": "@@ -5783,7 +5783,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   bool is_simple_use;\n   int i;\n   int ncopies;\n-  stmt_vec_info prev_phi_info;\n   bool single_defuse_cycle = false;\n   int j;\n   tree ops[3];\n@@ -5811,207 +5810,15 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     gcc_assert (slp_node\n \t\t&& REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info);\n \n-  if (gphi *phi = dyn_cast <gphi *> (stmt_info->stmt))\n+  if (is_a <gphi *> (stmt_info->stmt))\n     {\n-      tree phi_result = gimple_phi_result (phi);\n       /* Analysis is fully done on the reduction stmt invocation.  */\n-      if (! vec_stmt)\n-\t{\n-\t  if (slp_node)\n-\t    slp_node_instance->reduc_phis = slp_node;\n-\n-\t  STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n-\t  return true;\n-\t}\n-\n-      if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION)\n-\t/* Leave the scalar phi in place.  Note that checking\n-\t   STMT_VINFO_VEC_REDUCTION_TYPE (as below) only works\n-\t   for reductions involving a single statement.  */\n-\treturn true;\n-\n-      stmt_vec_info reduc_stmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n-      reduc_stmt_info = vect_stmt_to_vectorize (reduc_stmt_info);\n-\n-      if (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n-\t  == EXTRACT_LAST_REDUCTION)\n-\t/* Leave the scalar phi in place.  */\n-\treturn true;\n-\n-      if (gassign *reduc_stmt = dyn_cast <gassign *> (reduc_stmt_info->stmt))\n-\tfor (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n-\t  {\n-\t    tree op = gimple_op (reduc_stmt, k);\n-\t    if (op == phi_result)\n-\t      continue;\n-\t    if (k == 1 && gimple_assign_rhs_code (reduc_stmt) == COND_EXPR)\n-\t      continue;\n-\t    bool is_simple_use = vect_is_simple_use (op, loop_vinfo, &dt);\n-\t    gcc_assert (is_simple_use);\n-\t    if (dt == vect_constant_def || dt == vect_external_def)\n-\t      continue;\n-\t    if (!vectype_in\n-\t\t|| (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n-\t\t    < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (op)))))\n-\t      vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op));\n-\t    break;\n-\t  }\n-      /* For a nested cycle we might end up with an operation like\n-         phi_result * phi_result.  */\n-      if (!vectype_in)\n-\tvectype_in = STMT_VINFO_VECTYPE (stmt_info);\n-      gcc_assert (vectype_in);\n+      gcc_assert (! vec_stmt);\n \n       if (slp_node)\n-\t{\n-\t  /* The size vect_schedule_slp_instance computes is off for us.  */\n-\t  vec_num = vect_get_num_vectors\n-\t      (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t       * SLP_TREE_SCALAR_STMTS (slp_node).length (), vectype_in);\n-\t  ncopies = 1;\n-\t}\n-      else\n-\t{\n-\t  vec_num = 1;\n-\t  ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n-\t}\n-\n-      /* Check whether we can use a single PHI node and accumulate\n-         vectors to one before the backedge.  */\n-      stmt_vec_info use_stmt_info;\n-      if (ncopies > 1\n-\t  && STMT_VINFO_RELEVANT (reduc_stmt_info) <= vect_used_only_live\n-\t  && (use_stmt_info = loop_vinfo->lookup_single_use (phi_result))\n-\t  && (!STMT_VINFO_IN_PATTERN_P (use_stmt_info)\n-\t      || !STMT_VINFO_PATTERN_DEF_SEQ (use_stmt_info))\n-\t  && vect_stmt_to_vectorize (use_stmt_info) == reduc_stmt_info)\n-\t{\n-\t  single_defuse_cycle = true;\n-\t  ncopies = 1;\n-\t}\n-\n-      /* Create the destination vector  */\n-      tree vec_dest = vect_create_destination_var (phi_result, vectype_out);\n-\n-      /* Get the loop-entry arguments.  */\n-      tree vec_initial_def;\n-      auto_vec<tree> vec_initial_defs;\n-      if (slp_node)\n-\t{\n-\t  vec_initial_defs.reserve (vec_num);\n-\t  gcc_assert (slp_node == slp_node_instance->reduc_phis);\n-\t  stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (reduc_stmt_info);\n-\t  tree neutral_op\n-\t      = neutral_op_for_slp_reduction (slp_node,\n-\t\t\t\t\t      STMT_VINFO_REDUC_CODE\n-\t\t\t\t\t      (first ? first : reduc_stmt_info),\n-\t\t\t\t\t      first != NULL);\n-\t  get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n-\t\t\t\t\t  &vec_initial_defs, vec_num,\n-\t\t\t\t\t  first != NULL, neutral_op);\n-\t}\n-      else\n-\t{\n-\t  /* Get at the scalar def before the loop, that defines the initial\n-\t     value of the reduction variable.  */\n-\t  tree initial_def = PHI_ARG_DEF_FROM_EDGE (phi,\n-\t\t\t\t\t\t    loop_preheader_edge (loop));\n-\t  /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n-\t     and we can't use zero for induc_val, use initial_def.  Similarly\n-\t     for REDUC_MIN and initial_def larger than the base.  */\n-\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n-\t      == INTEGER_INDUC_COND_REDUCTION)\n-\t    {\n-\t      tree induc_val\n-\t\t= STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info);\n-\t      if (TREE_CODE (initial_def) == INTEGER_CST\n-\t\t  && (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n-\t\t      == INTEGER_INDUC_COND_REDUCTION)\n-\t\t  && !integer_zerop (induc_val)\n-\t\t  && (((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n-\t\t\t== MAX_EXPR)\n-\t\t       && tree_int_cst_lt (initial_def, induc_val))\n-\t\t      || ((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n-\t\t\t   == MIN_EXPR)\n-\t\t\t  && tree_int_cst_lt (induc_val, initial_def))))\n-\t\t{\n-\t\t  induc_val = initial_def;\n-\t\t  /* Communicate we used the initial_def to epilouge\n-\t\t     generation.  */\n-\t\t  STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info)\n-\t\t    = NULL_TREE;\n-\t\t}\n-\t      vec_initial_def = build_vector_from_val (vectype_out, induc_val);\n-\t    }\n-\t  else if (nested_cycle)\n-\t    {\n-\t      /* Do not use an adjustment def as that case is not supported\n-\t\t correctly if ncopies is not one.  */\n-\t      vec_initial_def = vect_get_vec_def_for_operand (initial_def,\n-\t\t\t\t\t\t\t      reduc_stmt_info);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree adjustment_def = NULL_TREE;\n-\t      tree *adjustment_defp = &adjustment_def;\n-\t      enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_stmt_info);\n-\t      /* ???  For the outer loop PHI we have to do a bit of searching\n-\t\t to find the stmt with the code.  reduc_stmt_info here is the\n-\t\t loop-closed PHI of the inner reduction which means we can look\n-\t\t at its single-arg def.  */\n-\t      if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n-\t\t{\n-\t\t  tree def = gimple_phi_arg_def\n-\t\t\t\t(as_a <gphi *> (reduc_stmt_info->stmt), 0);\n-\t\t  code = STMT_VINFO_REDUC_CODE\n-\t\t      (vect_stmt_to_vectorize (loop_vinfo->lookup_def (def)));\n-\t\t  adjustment_defp = NULL;\n-\t\t}\n-\t      vec_initial_def\n-\t\t= get_initial_def_for_reduction (reduc_stmt_info, code,\n-\t\t\t\t\t\t initial_def, adjustment_defp);\n-\t      STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_stmt_info)\n-\t\t= adjustment_def;\n-\t    }\n-\t  vec_initial_defs.create (1);\n-\t  vec_initial_defs.quick_push (vec_initial_def);\n-\t}\n-\n-      /* Generate the reduction PHIs upfront.  */\n-      prev_phi_info = NULL;\n-      for (i = 0; i < vec_num; i++)\n-\t{\n-\t  tree vec_init_def = vec_initial_defs[i];\n-\t  for (j = 0; j < ncopies; j++)\n-\t    {\n-\t      /* Create the reduction-phi that defines the reduction\n-\t\t operand.  */\n-\t      gphi *new_phi = create_phi_node (vec_dest, loop->header);\n-\t      stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n-\n-\t      /* Set the loop-entry arg of the reduction-phi.  */\n-\t      if (j != 0 && nested_cycle)\n-\t\tvec_init_def = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n-\t\t\t\t\t\t\t       vec_init_def);\n-\t      add_phi_arg (new_phi, vec_init_def, loop_preheader_edge (loop),\n-\t\t\t   UNKNOWN_LOCATION);\n-\n-\t      /* The loop-latch arg is set in epilogue processing.  */\n-\n-\t      if (slp_node)\n-\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n-\t      else\n-\t\t{\n-\t\t  if (j == 0)\n-\t\t    STMT_VINFO_VEC_STMT (stmt_info)\n-\t\t\t= *vec_stmt = new_phi_info;\n-\t\t  else\n-\t\t    STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi_info;\n-\t\t  prev_phi_info = new_phi_info;\n-\t\t}\n-\t    }\n-\t}\n+\tslp_node_instance->reduc_phis = slp_node;\n \n+      STMT_VINFO_TYPE (stmt_info) = cycle_phi_info_type;\n       return true;\n     }\n \n@@ -6841,7 +6648,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   tree vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n   prev_stmt_info = NULL;\n-  prev_phi_info = NULL;\n   if (!slp_node)\n     {\n       vec_oprnds0.create (1);\n@@ -6998,7 +6804,221 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   return true;\n }\n \n-/* Vectorizes LC PHIs of nested cycles (sofar).  */\n+/* Transform phase of a cycle PHI.  */\n+\n+bool\n+vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n+\t\t\t  slp_tree slp_node, slp_instance slp_node_instance)\n+{\n+  tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vectype_in = NULL_TREE;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  enum vect_def_type dt;\n+  int i;\n+  int ncopies;\n+  stmt_vec_info prev_phi_info;\n+  int j;\n+  bool nested_cycle = false;\n+  int vec_num;\n+\n+  if (nested_in_vect_loop_p (loop, stmt_info))\n+    {\n+      loop = loop->inner;\n+      nested_cycle = true;\n+    }\n+\n+  gphi *phi = as_a <gphi *> (stmt_info->stmt);\n+  tree phi_result = gimple_phi_result (phi);\n+\n+  if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION)\n+    /* Leave the scalar phi in place.  Note that checking\n+       STMT_VINFO_VEC_REDUCTION_TYPE (as below) only works\n+       for reductions involving a single statement.  */\n+    return true;\n+\n+  stmt_vec_info reduc_stmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n+  reduc_stmt_info = vect_stmt_to_vectorize (reduc_stmt_info);\n+\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n+      == EXTRACT_LAST_REDUCTION)\n+    /* Leave the scalar phi in place.  */\n+    return true;\n+\n+  if (gassign *reduc_stmt = dyn_cast <gassign *> (reduc_stmt_info->stmt))\n+    for (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n+      {\n+\ttree op = gimple_op (reduc_stmt, k);\n+\tif (op == phi_result)\n+\t  continue;\n+\tif (k == 1 && gimple_assign_rhs_code (reduc_stmt) == COND_EXPR)\n+\t  continue;\n+\tbool is_simple_use = vect_is_simple_use (op, loop_vinfo, &dt);\n+\tgcc_assert (is_simple_use);\n+\tif (dt == vect_constant_def || dt == vect_external_def)\n+\t  continue;\n+\tif (!vectype_in\n+\t    || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n+\t\t< GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (op)))))\n+\t  vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op));\n+\tbreak;\n+      }\n+  /* For a nested cycle we might end up with an operation like\n+     phi_result * phi_result.  */\n+  if (!vectype_in)\n+    vectype_in = STMT_VINFO_VECTYPE (stmt_info);\n+  gcc_assert (vectype_in);\n+\n+  if (slp_node)\n+    {\n+      /* The size vect_schedule_slp_instance computes is off for us.  */\n+      vec_num = vect_get_num_vectors\n+\t  (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t   * SLP_TREE_SCALAR_STMTS (slp_node).length (), vectype_in);\n+      ncopies = 1;\n+    }\n+  else\n+    {\n+      vec_num = 1;\n+      ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n+    }\n+\n+  /* Check whether we can use a single PHI node and accumulate\n+     vectors to one before the backedge.  */\n+  stmt_vec_info use_stmt_info;\n+  if (ncopies > 1\n+      && STMT_VINFO_RELEVANT (reduc_stmt_info) <= vect_used_only_live\n+      && (use_stmt_info = loop_vinfo->lookup_single_use (phi_result))\n+      && (!STMT_VINFO_IN_PATTERN_P (use_stmt_info)\n+\t  || !STMT_VINFO_PATTERN_DEF_SEQ (use_stmt_info))\n+      && vect_stmt_to_vectorize (use_stmt_info) == reduc_stmt_info)\n+    ncopies = 1;\n+\n+  /* Create the destination vector  */\n+  tree vec_dest = vect_create_destination_var (phi_result, vectype_out);\n+\n+  /* Get the loop-entry arguments.  */\n+  tree vec_initial_def;\n+  auto_vec<tree> vec_initial_defs;\n+  if (slp_node)\n+    {\n+      vec_initial_defs.reserve (vec_num);\n+      gcc_assert (slp_node == slp_node_instance->reduc_phis);\n+      stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (reduc_stmt_info);\n+      tree neutral_op\n+\t= neutral_op_for_slp_reduction (slp_node,\n+\t\t\t\t\tSTMT_VINFO_REDUC_CODE\n+\t\t\t\t\t  (first ? first : reduc_stmt_info),\n+\t\t\t\t\tfirst != NULL);\n+      get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n+\t\t\t\t      &vec_initial_defs, vec_num,\n+\t\t\t\t      first != NULL, neutral_op);\n+    }\n+  else\n+    {\n+      /* Get at the scalar def before the loop, that defines the initial\n+\t value of the reduction variable.  */\n+      tree initial_def = PHI_ARG_DEF_FROM_EDGE (phi,\n+\t\t\t\t\t\tloop_preheader_edge (loop));\n+      /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n+\t and we can't use zero for induc_val, use initial_def.  Similarly\n+\t for REDUC_MIN and initial_def larger than the base.  */\n+      if (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n+\t  == INTEGER_INDUC_COND_REDUCTION)\n+\t{\n+\t  tree induc_val\n+\t    = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info);\n+\t  if (TREE_CODE (initial_def) == INTEGER_CST\n+\t      && (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n+\t\t  == INTEGER_INDUC_COND_REDUCTION)\n+\t      && !integer_zerop (induc_val)\n+\t      && (((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n+\t\t    == MAX_EXPR)\n+\t\t   && tree_int_cst_lt (initial_def, induc_val))\n+\t\t  || ((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n+\t\t       == MIN_EXPR)\n+\t\t      && tree_int_cst_lt (induc_val, initial_def))))\n+\t    {\n+\t      induc_val = initial_def;\n+\t      /* Communicate we used the initial_def to epilouge\n+\t\t generation.  */\n+\t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info)\n+\t\t= NULL_TREE;\n+\t    }\n+\t  vec_initial_def = build_vector_from_val (vectype_out, induc_val);\n+\t}\n+      else if (nested_cycle)\n+\t{\n+\t  /* Do not use an adjustment def as that case is not supported\n+\t     correctly if ncopies is not one.  */\n+\t  vec_initial_def = vect_get_vec_def_for_operand (initial_def,\n+\t\t\t\t\t\t\t  reduc_stmt_info);\n+\t}\n+      else\n+\t{\n+\t  tree adjustment_def = NULL_TREE;\n+\t  tree *adjustment_defp = &adjustment_def;\n+\t  enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_stmt_info);\n+\t  /* ???  For the outer loop PHI we have to do a bit of searching\n+\t     to find the stmt with the code.  reduc_stmt_info here is the\n+\t     loop-closed PHI of the inner reduction which means we can look\n+\t     at its single-arg def.  */\n+\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+\t    {\n+\t      tree def = gimple_phi_arg_def\n+\t\t\t   (as_a <gphi *> (reduc_stmt_info->stmt), 0);\n+\t      code = STMT_VINFO_REDUC_CODE\n+\t\t       (vect_stmt_to_vectorize (loop_vinfo->lookup_def (def)));\n+\t      adjustment_defp = NULL;\n+\t    }\n+\t  vec_initial_def\n+\t    = get_initial_def_for_reduction (reduc_stmt_info, code,\n+\t\t\t\t\t     initial_def, adjustment_defp);\n+\t  STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_stmt_info)\n+\t    = adjustment_def;\n+\t}\n+      vec_initial_defs.create (1);\n+      vec_initial_defs.quick_push (vec_initial_def);\n+    }\n+\n+  /* Generate the reduction PHIs upfront.  */\n+  prev_phi_info = NULL;\n+  for (i = 0; i < vec_num; i++)\n+    {\n+      tree vec_init_def = vec_initial_defs[i];\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  /* Create the reduction-phi that defines the reduction\n+\t     operand.  */\n+\t  gphi *new_phi = create_phi_node (vec_dest, loop->header);\n+\t  stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n+\n+\t  /* Set the loop-entry arg of the reduction-phi.  */\n+\t  if (j != 0 && nested_cycle)\n+\t    vec_init_def = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n+\t\t\t\t\t\t\t   vec_init_def);\n+\t  add_phi_arg (new_phi, vec_init_def, loop_preheader_edge (loop),\n+\t\t       UNKNOWN_LOCATION);\n+\n+\t  /* The loop-latch arg is set in epilogue processing.  */\n+\n+\t  if (slp_node)\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n+\t  else\n+\t    {\n+\t      if (j == 0)\n+\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_phi_info;\n+\t      else\n+\t\tSTMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi_info;\n+\t      prev_phi_info = new_phi_info;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Vectorizes LC PHIs.  */\n \n bool\n vectorizable_lc_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,"}, {"sha": "ddc2f7408d82f7ec0803af9434dc8eacd02a31d9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/291fa23ac04e317877c1e102937532f080180bb2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/291fa23ac04e317877c1e102937532f080180bb2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=291fa23ac04e317877c1e102937532f080180bb2", "patch": "@@ -10824,6 +10824,12 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       gcc_assert (done);\n       break;\n \n+    case cycle_phi_info_type:\n+      done = vect_transform_cycle_phi (stmt_info, &vec_stmt, slp_node,\n+\t\t\t\t       slp_node_instance);\n+      gcc_assert (done);\n+      break;\n+\n     case lc_phi_info_type:\n       done = vectorizable_lc_phi (stmt_info, &vec_stmt, slp_node);\n       gcc_assert (done);"}, {"sha": "eae9d4c9a1891b9001703cbf3fdaed818a491644", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/291fa23ac04e317877c1e102937532f080180bb2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/291fa23ac04e317877c1e102937532f080180bb2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=291fa23ac04e317877c1e102937532f080180bb2", "patch": "@@ -694,6 +694,7 @@ enum stmt_vec_info_type {\n   type_promotion_vec_info_type,\n   type_demotion_vec_info_type,\n   type_conversion_vec_info_type,\n+  cycle_phi_info_type,\n   lc_phi_info_type,\n   loop_exit_ctrl_vec_info_type\n };\n@@ -1658,6 +1659,8 @@ extern bool vectorizable_reduction (stmt_vec_info, gimple_stmt_iterator *,\n extern bool vectorizable_induction (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n+extern bool vect_transform_cycle_phi (stmt_vec_info, stmt_vec_info *,\n+\t\t\t\t      slp_tree, slp_instance);\n extern bool vectorizable_lc_phi (stmt_vec_info, stmt_vec_info *, slp_tree);\n extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,"}]}