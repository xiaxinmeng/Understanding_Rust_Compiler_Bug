{"sha": "6fa6eb35446c6fc17b41caa615e700420eb5f7be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhNmViMzU0NDZjNmZjMTdiNDFjYWE2MTVlNzAwNDIwZWI1ZjdiZQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2014-08-21T01:56:41Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2014-08-21T01:56:41Z"}, "message": "rs6000.c (context.h): New include.\n\n[gcc]\n\n2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (context.h): New include.\n\t(tree-pass.h): Likewise.\n\t(make_pass_analyze_swaps): New decl.\n\t(rs6000_option_override): Register pass_analyze_swaps.\n\t(swap_web_entry): New subsclass of web_entry_base (df.h).\n\t(special_handling_values): New enum.\n\t(union_defs): New function.\n\t(union_uses): Likewise.\n\t(insn_is_load_p): Likewise.\n\t(insn_is_store_p): Likewise.\n\t(insn_is_swap_p): Likewise.\n\t(rtx_is_swappable_p): Likewise.\n\t(insn_is_swappable_p): Likewise.\n\t(chain_purpose): New enum.\n\t(chain_contains_only_swaps): New function.\n\t(mark_swaps_for_removal): Likewise.\n\t(swap_const_vector_halves): Likewise.\n\t(adjust_subreg_index): Likewise.\n\t(permute_load): Likewise.\n\t(permute_store): Likewise.\n\t(handle_special_swappables): Likewise.\n\t(replace_swap_with_copy): Likewise.\n\t(dump_swap_insn_table): Likewise.\n\t(rs6000_analyze_swaps): Likewise.\n\t(pass_data_analyze_swaps): New pass_data.\n\t(pass_analyze_swaps): New rtl_opt_pass.\n\t(make_pass_analyze_swaps): New function.\n\t* config/rs6000/rs6000.opt (moptimize-swaps): New option.\n\n[gcc/testsuite]\n\n2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/swaps-p8-1.c: New test.\n\t* gcc.target/powerpc/swaps-p8-2.c: New test.\n\t* gcc.target/powerpc/swaps-p8-3.c: New test.\n\t* gcc.target/powerpc/swaps-p8-4.c: New test.\n\t* gcc.target/powerpc/swaps-p8-5.c: New test.\n\t* gcc.target/powerpc/swaps-p8-6.c: New test.\n\t* gcc.target/powerpc/swaps-p8-7.c: New test.\n\t* gcc.target/powerpc/swaps-p8-8.c: New test.\n\t* gcc.target/powerpc/swaps-p8-9.c: New test.\n\t* gcc.target/powerpc/swaps-p8-10.c: New test.\n\t* gcc.target/powerpc/swaps-p8-11.c: New test.\n\t* gcc.target/powerpc/swaps-p8-12.c: New test.\n\nFrom-SVN: r214254", "tree": {"sha": "00817377b51250a3dd522da5f7f6afbaa29277d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00817377b51250a3dd522da5f7f6afbaa29277d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fa6eb35446c6fc17b41caa615e700420eb5f7be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa6eb35446c6fc17b41caa615e700420eb5f7be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa6eb35446c6fc17b41caa615e700420eb5f7be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa6eb35446c6fc17b41caa615e700420eb5f7be/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c068b732ce5ba399be2643cc48ae59a782a6c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c068b732ce5ba399be2643cc48ae59a782a6c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c068b732ce5ba399be2643cc48ae59a782a6c76"}], "stats": {"total": 1600, "additions": 1600, "deletions": 0}, "files": [{"sha": "c1c471fc192f334e1f502a8a362d8b184ff866e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -1,3 +1,34 @@\n+2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (context.h): New include.\n+\t(tree-pass.h): Likewise.\n+\t(make_pass_analyze_swaps): New decl.\n+\t(rs6000_option_override): Register pass_analyze_swaps.\n+\t(swap_web_entry): New subsclass of web_entry_base (df.h).\n+\t(special_handling_values): New enum.\n+\t(union_defs): New function.\n+\t(union_uses): Likewise.\n+\t(insn_is_load_p): Likewise.\n+\t(insn_is_store_p): Likewise.\n+\t(insn_is_swap_p): Likewise.\n+\t(rtx_is_swappable_p): Likewise.\n+\t(insn_is_swappable_p): Likewise.\n+\t(chain_purpose): New enum.\n+\t(chain_contains_only_swaps): New function.\n+\t(mark_swaps_for_removal): Likewise.\n+\t(swap_const_vector_halves): Likewise.\n+\t(adjust_subreg_index): Likewise.\n+\t(permute_load): Likewise.\n+\t(permute_store): Likewise.\n+\t(handle_special_swappables): Likewise.\n+\t(replace_swap_with_copy): Likewise.\n+\t(dump_swap_insn_table): Likewise.\n+\t(rs6000_analyze_swaps): Likewise.\n+\t(pass_data_analyze_swaps): New pass_data.\n+\t(pass_analyze_swaps): New rtl_opt_pass.\n+\t(make_pass_analyze_swaps): New function.\n+\t* config/rs6000/rs6000.opt (moptimize-swaps): New option.\n+\n 2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* sel-sched-ir.h (create_insn_rtx_from_pattern): Strengthen return"}, {"sha": "f27759ba0c23fd80e8685e7db45b24c52b18abd4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1050, "deletions": 0, "changes": 1050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -79,6 +79,8 @@\n #include \"cgraph.h\"\n #include \"target-globals.h\"\n #include \"builtins.h\"\n+#include \"context.h\"\n+#include \"tree-pass.h\"\n #if TARGET_XCOFF\n #include \"xcoffout.h\"  /* get declarations of xcoff_*_section_name */\n #endif\n@@ -1170,6 +1172,7 @@ static bool rs6000_secondary_reload_move (enum rs6000_reg_type,\n \t\t\t\t\t  enum machine_mode,\n \t\t\t\t\t  secondary_reload_info *,\n \t\t\t\t\t  bool);\n+rtl_opt_pass *make_pass_analyze_swaps (gcc::context*);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -4085,6 +4088,15 @@ static void\n rs6000_option_override (void)\n {\n   (void) rs6000_option_override_internal (true);\n+\n+  /* Register machine-specific passes.  This needs to be done at start-up.\n+     It's convenient to do it here (like i386 does).  */\n+  opt_pass *pass_analyze_swaps = make_pass_analyze_swaps (g);\n+\n+  static struct register_pass_info analyze_swaps_info\n+    = { pass_analyze_swaps, \"cse1\", 1, PASS_POS_INSERT_BEFORE };\n+\n+  register_pass (&analyze_swaps_info);\n }\n \n \f\n@@ -33421,7 +33433,1045 @@ emit_fusion_gpr_load (rtx *operands)\n \n   return \"\";\n }\n+\f\n+/* Analyze vector computations and remove unnecessary doubleword\n+   swaps (xxswapdi instructions).  This pass is performed only\n+   for little-endian VSX code generation.\n+\n+   For this specific case, loads and stores of 4x32 and 2x64 vectors\n+   are inefficient.  These are implemented using the lvx2dx and\n+   stvx2dx instructions, which invert the order of doublewords in\n+   a vector register.  Thus the code generation inserts an xxswapdi\n+   after each such load, and prior to each such store.  (For spill\n+   code after register assignment, an additional xxswapdi is inserted\n+   following each store in order to return a hard register to its\n+   unpermuted value.)\n+\n+   The extra xxswapdi instructions reduce performance.  This can be\n+   particularly bad for vectorized code.  The purpose of this pass\n+   is to reduce the number of xxswapdi instructions required for\n+   correctness.\n+\n+   The primary insight is that much code that operates on vectors\n+   does not care about the relative order of elements in a register,\n+   so long as the correct memory order is preserved.  If we have\n+   a computation where all input values are provided by lvxd2x/xxswapdi\n+   sequences, all outputs are stored using xxswapdi/stvxd2x sequences,\n+   and all intermediate computations are pure SIMD (independent of\n+   element order), then all the xxswapdi's associated with the loads\n+   and stores may be removed.\n+\n+   This pass uses some of the infrastructure and logical ideas from\n+   the \"web\" pass in web.c.  We create maximal webs of computations\n+   fitting the description above using union-find.  Each such web is\n+   then optimized by removing its unnecessary xxswapdi instructions.\n+\n+   The pass is placed prior to global optimization so that we can\n+   perform the optimization in the safest and simplest way possible;\n+   that is, by replacing each xxswapdi insn with a register copy insn.\n+   Subsequent forward propagation will remove copies where possible.\n+\n+   There are some operations sensitive to element order for which we\n+   can still allow the operation, provided we modify those operations.\n+   These include CONST_VECTORs, for which we must swap the first and\n+   second halves of the constant vector; and SUBREGs, for which we\n+   must adjust the byte offset to account for the swapped doublewords.\n+   A remaining opportunity would be non-immediate-form splats, for\n+   which we should adjust the selected lane of the input.  We should\n+   also make code generation adjustments for sum-across operations,\n+   since this is a common vectorizer reduction.\n+\n+   Because we run prior to the first split, we can see loads and stores\n+   here that match *vsx_le_perm_{load,store}_<mode>.  These are vanilla\n+   vector loads and stores that have not yet been split into a permuting\n+   load/store and a swap.  (One way this can happen is with a builtin\n+   call to vec_vsx_{ld,st}.)  We can handle these as well, but rather\n+   than deleting a swap, we convert the load/store into a permuting\n+   load/store (which effectively removes the swap).  */\n+\n+/* This is based on the union-find logic in web.c.  web_entry_base is\n+   defined in df.h.  */\n+class swap_web_entry : public web_entry_base\n+{\n+ public:\n+  /* Pointer to the insn.  */\n+  rtx insn;\n+  /* Set if insn contains a mention of a vector register.  All other\n+     fields are undefined if this field is unset.  */\n+  unsigned int is_relevant : 1;\n+  /* Set if insn is a load.  */\n+  unsigned int is_load : 1;\n+  /* Set if insn is a store.  */\n+  unsigned int is_store : 1;\n+  /* Set if insn is a doubleword swap.  This can either be a register swap\n+     or a permuting load or store (test is_load and is_store for this).  */\n+  unsigned int is_swap : 1;\n+  /* Set if the insn has a live-in use of a parameter register.  */\n+  unsigned int is_live_in : 1;\n+  /* Set if the insn has a live-out def of a return register.  */\n+  unsigned int is_live_out : 1;\n+  /* Set if the insn contains a subreg reference of a vector register.  */\n+  unsigned int contains_subreg : 1;\n+  /* Set if the insn contains a 128-bit integer operand.  */\n+  unsigned int is_128_int : 1;\n+  /* Set if this is a call-insn.  */\n+  unsigned int is_call : 1;\n+  /* Set if this insn does not perform a vector operation for which\n+     element order matters, or if we know how to fix it up if it does.\n+     Undefined if is_swap is set.  */\n+  unsigned int is_swappable : 1;\n+  /* A nonzero value indicates what kind of special handling for this\n+     insn is required if doublewords are swapped.  Undefined if\n+     is_swappable is not set.  */\n+  unsigned int special_handling : 3;\n+  /* Set if the web represented by this entry cannot be optimized.  */\n+  unsigned int web_not_optimizable : 1;\n+  /* Set if this insn should be deleted.  */\n+  unsigned int will_delete : 1;\n+};\n+\n+enum special_handling_values {\n+  SH_NONE = 0,\n+  SH_CONST_VECTOR,\n+  SH_SUBREG,\n+  SH_NOSWAP_LD,\n+  SH_NOSWAP_ST\n+};\n+\n+/* Union INSN with all insns containing definitions that reach USE.\n+   Detect whether USE is live-in to the current function.  */\n+static void\n+union_defs (swap_web_entry *insn_entry, rtx insn, df_ref use)\n+{\n+  struct df_link *link = DF_REF_CHAIN (use);\n+\n+  if (!link)\n+    insn_entry[INSN_UID (insn)].is_live_in = 1;\n+\n+  while (link)\n+    {\n+      if (DF_REF_IS_ARTIFICIAL (link->ref))\n+\tinsn_entry[INSN_UID (insn)].is_live_in = 1;\n+\n+      if (DF_REF_INSN_INFO (link->ref))\n+\t{\n+\t  rtx def_insn = DF_REF_INSN (link->ref);\n+\t  (void)unionfind_union (insn_entry + INSN_UID (insn),\n+\t\t\t\t insn_entry + INSN_UID (def_insn));\n+\t}\n+\n+      link = link->next;\n+    }\n+}\n+\n+/* Union INSN with all insns containing uses reached from DEF.\n+   Detect whether DEF is live-out from the current function.  */\n+static void\n+union_uses (swap_web_entry *insn_entry, rtx insn, df_ref def)\n+{\n+  struct df_link *link = DF_REF_CHAIN (def);\n+\n+  if (!link)\n+    insn_entry[INSN_UID (insn)].is_live_out = 1;\n+\n+  while (link)\n+    {\n+      /* This could be an eh use or some other artificial use;\n+\t we treat these all the same (killing the optimization).  */\n+      if (DF_REF_IS_ARTIFICIAL (link->ref))\n+\tinsn_entry[INSN_UID (insn)].is_live_out = 1;\n+\n+      if (DF_REF_INSN_INFO (link->ref))\n+\t{\n+\t  rtx use_insn = DF_REF_INSN (link->ref);\n+\t  (void)unionfind_union (insn_entry + INSN_UID (insn),\n+\t\t\t\t insn_entry + INSN_UID (use_insn));\n+\t}\n+\n+      link = link->next;\n+    }\n+}\n+\n+/* Return 1 iff INSN is a load insn, including permuting loads that\n+   represent an lvxd2x instruction; else return 0.  */\n+static unsigned int\n+insn_is_load_p (rtx insn)\n+{\n+  rtx body = PATTERN (insn);\n+\n+  if (GET_CODE (body) == SET)\n+    {\n+      if (GET_CODE (SET_SRC (body)) == MEM)\n+\treturn 1;\n+\n+      if (GET_CODE (SET_SRC (body)) == VEC_SELECT\n+\t  && GET_CODE (XEXP (SET_SRC (body), 0)) == MEM)\n+\treturn 1;\n+\n+      return 0;\n+    }\n+\n+  if (GET_CODE (body) != PARALLEL)\n+    return 0;\n+\n+  rtx set = XVECEXP (body, 0, 0);\n+\n+  if (GET_CODE (set) == SET && GET_CODE (SET_SRC (set)) == MEM)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return 1 iff INSN is a store insn, including permuting stores that\n+   represent an stvxd2x instruction; else return 0.  */\n+static unsigned int\n+insn_is_store_p (rtx insn)\n+{\n+  rtx body = PATTERN (insn);\n+  if (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == MEM)\n+    return 1;\n+  if (GET_CODE (body) != PARALLEL)\n+    return 0;\n+  rtx set = XVECEXP (body, 0, 0);\n+  if (GET_CODE (set) == SET && GET_CODE (SET_DEST (set)) == MEM)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return 1 iff INSN swaps doublewords.  This may be a reg-reg swap,\n+   a permuting load, or a permuting store.  */\n+static unsigned int\n+insn_is_swap_p (rtx insn)\n+{\n+  rtx body = PATTERN (insn);\n+  if (GET_CODE (body) != SET)\n+    return 0;\n+  rtx rhs = SET_SRC (body);\n+  if (GET_CODE (rhs) != VEC_SELECT)\n+    return 0;\n+  rtx parallel = XEXP (rhs, 1);\n+  if (GET_CODE (parallel) != PARALLEL)\n+    return 0;\n+  unsigned int len = XVECLEN (parallel, 0);\n+  if (len != 2 && len != 4 && len != 8 && len != 16)\n+    return 0;\n+  for (unsigned int i = 0; i < len / 2; ++i)\n+    {\n+      rtx op = XVECEXP (parallel, 0, i);\n+      if (GET_CODE (op) != CONST_INT || INTVAL (op) != len / 2 + i)\n+\treturn 0;\n+    }\n+  for (unsigned int i = len / 2; i < len; ++i)\n+    {\n+      rtx op = XVECEXP (parallel, 0, i);\n+      if (GET_CODE (op) != CONST_INT || INTVAL (op) != i - len / 2)\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+/* Return 1 iff OP is an operand that will not be affected by having\n+   vector doublewords swapped in memory.  */\n+static unsigned int\n+rtx_is_swappable_p (rtx op, unsigned int *special)\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  int i, j;\n+\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CLOBBER:\n+    case REG:\n+      return 1;\n+\n+    case VEC_CONCAT:\n+    case VEC_SELECT:\n+    case ASM_INPUT:\n+    case ASM_OPERANDS:\n+      return 0;\n+\n+    case CONST_VECTOR:\n+      {\n+\t*special = SH_CONST_VECTOR;\n+\treturn 1;\n+      }\n+\n+    case VEC_DUPLICATE:\n+      /* Opportunity: If XEXP (op, 0) has the same mode as the result,\n+\t and XEXP (op, 1) is a PARALLEL with a single QImode const int,\n+\t it represents a vector splat for which we can do special\n+\t handling.  */\n+      if (GET_CODE (XEXP (op, 0)) == CONST_INT)\n+\treturn 1;\n+      else\n+\treturn 0;\n+\n+    case UNSPEC:\n+      {\n+\t/* Various operations are unsafe for this optimization, at least\n+\t   without significant additional work.  Permutes are obviously\n+\t   problematic, as both the permute control vector and the ordering\n+\t   of the target values are invalidated by doubleword swapping.\n+\t   Vector pack and unpack modify the number of vector lanes.\n+\t   Merge-high/low will not operate correctly on swapped operands.\n+\t   Vector shifts across element boundaries are clearly uncool,\n+\t   as are vector select and concatenate operations.  Vector\n+\t   sum-across instructions define one operand with a specific\n+\t   order-dependent element, so additional fixup code would be\n+\t   needed to make those work.  Vector set and non-immediate-form\n+\t   vector splat are element-order sensitive.  A few of these\n+\t   cases might be workable with special handling if required.  */\n+\tint val = XINT (op, 1);\n+\tif (val == UNSPEC_VMRGH_DIRECT\n+\t    || val == UNSPEC_VMRGL_DIRECT\n+\t    || val == UNSPEC_VPACK_SIGN_SIGN_SAT\n+\t    || val == UNSPEC_VPACK_SIGN_UNS_SAT\n+\t    || val == UNSPEC_VPACK_UNS_UNS_MOD\n+\t    || val == UNSPEC_VPACK_UNS_UNS_MOD_DIRECT\n+\t    || val == UNSPEC_VPACK_UNS_UNS_SAT\n+\t    || val == UNSPEC_VPERM\n+\t    || val == UNSPEC_VPERM_UNS\n+\t    || val == UNSPEC_VPERMHI\n+\t    || val == UNSPEC_VPERMSI\n+\t    || val == UNSPEC_VPKPX\n+\t    || val == UNSPEC_VSLDOI\n+\t    || val == UNSPEC_VSLO\n+\t    || val == UNSPEC_VSPLT_DIRECT\n+\t    || val == UNSPEC_VSRO\n+\t    || val == UNSPEC_VSUM2SWS\n+\t    || val == UNSPEC_VSUM4S\n+\t    || val == UNSPEC_VSUM4UBS\n+\t    || val == UNSPEC_VSUMSWS\n+\t    || val == UNSPEC_VSUMSWS_DIRECT\n+\t    || val == UNSPEC_VSX_CONCAT\n+\t    || val == UNSPEC_VSX_CVSPDP\n+\t    || val == UNSPEC_VSX_CVSPDPN\n+\t    || val == UNSPEC_VSX_SET\n+\t    || val == UNSPEC_VSX_SLDWI\n+\t    || val == UNSPEC_VSX_XXSPLTW\n+\t    || val == UNSPEC_VUNPACK_HI_SIGN\n+\t    || val == UNSPEC_VUNPACK_HI_SIGN_DIRECT\n+\t    || val == UNSPEC_VUNPACK_LO_SIGN\n+\t    || val == UNSPEC_VUNPACK_LO_SIGN_DIRECT\n+\t    || val == UNSPEC_VUPKHPX\n+\t    || val == UNSPEC_VUPKHS_V4SF\n+\t    || val == UNSPEC_VUPKHU_V4SF\n+\t    || val == UNSPEC_VUPKLPX\n+\t    || val == UNSPEC_VUPKLS_V4SF\n+\t    || val == UNSPEC_VUPKHU_V4SF)\n+\t  return 0;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  int ok = 1;\n+\n+  for (i = 0; i < GET_RTX_LENGTH (code); ++i)\n+    if (fmt[i] == 'e' || fmt[i] == 'u')\n+      {\n+\tunsigned int special_op = SH_NONE;\n+\tok &= rtx_is_swappable_p (XEXP (op, i), &special_op);\n+\t/* Ensure we never have two kinds of special handling\n+\t   for the same insn.  */\n+\tif (*special != SH_NONE && special_op != SH_NONE\n+\t    && *special != special_op)\n+\t  return 0;\n+\t*special = special_op;\n+      }\n+    else if (fmt[i] == 'E')\n+      for (j = 0; j < XVECLEN (op, i); ++j)\n+\t{\n+\t  unsigned int special_op = SH_NONE;\n+\t  ok &= rtx_is_swappable_p (XVECEXP (op, i, j), &special_op);\n+\t  /* Ensure we never have two kinds of special handling\n+\t     for the same insn.  */\n+\t  if (*special != SH_NONE && special_op != SH_NONE\n+\t      && *special != special_op)\n+\t    return 0;\n+\t  *special = special_op;\n+\t}\n+\n+  return ok;\n+}\n+\n+/* Return 1 iff INSN is an operand that will not be affected by\n+   having vector doublewords swapped in memory (in which case\n+   *SPECIAL is unchanged), or that can be modified to be correct\n+   if vector doublewords are swapped in memory (in which case\n+   *SPECIAL is changed to a value indicating how).  */\n+static unsigned int\n+insn_is_swappable_p (swap_web_entry *insn_entry, rtx insn,\n+\t\t     unsigned int *special)\n+{\n+  /* Calls are always bad.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    return 0;\n+\n+  /* Loads and stores seen here are not permuting, but we can still\n+     fix them up by converting them to permuting ones.  Exception:\n+     UNSPEC_LVX and UNSPEC_STVX, which have a PARALLEL body instead\n+     of a SET.  */\n+  rtx body = PATTERN (insn);\n+  int i = INSN_UID (insn);\n+\n+  if (insn_entry[i].is_load)\n+    {\n+      if (GET_CODE (body) == SET)\n+\t{\n+\t  *special = SH_NOSWAP_LD;\n+\t  return 1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+\n+  if (insn_entry[i].is_store)\n+    {\n+      if (GET_CODE (body) == SET)\n+\t{\n+\t  *special = SH_NOSWAP_ST;\n+\t  return 1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+\n+  /* Otherwise check the operands for vector lane violations.  */\n+  return rtx_is_swappable_p (body, special);\n+}\n+\n+enum chain_purpose { FOR_LOADS, FOR_STORES };\n+\n+/* Return true if the UD or DU chain headed by LINK is non-empty,\n+   and every entry on the chain references an insn that is a\n+   register swap.  Furthermore, if PURPOSE is FOR_LOADS, each such\n+   register swap must have only permuting loads as reaching defs.\n+   If PURPOSE is FOR_STORES, each such register swap must have only\n+   register swaps or permuting stores as reached uses.  */\n+static bool\n+chain_contains_only_swaps (swap_web_entry *insn_entry, struct df_link *link,\n+\t\t\t   enum chain_purpose purpose)\n+{\n+  if (!link)\n+    return false;\n+\n+  for (; link; link = link->next)\n+    {\n+      if (!VECTOR_MODE_P (GET_MODE (DF_REF_REG (link->ref))))\n+\tcontinue;\n+\n+      if (DF_REF_IS_ARTIFICIAL (link->ref))\n+\treturn false;\n+\n+      rtx reached_insn = DF_REF_INSN (link->ref);\n+      unsigned uid = INSN_UID (reached_insn);\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (reached_insn);\n+\n+      if (!insn_entry[uid].is_swap || insn_entry[uid].is_load\n+\t  || insn_entry[uid].is_store)\n+\treturn false;\n+\n+      if (purpose == FOR_LOADS)\n+\t{\n+\t  df_ref use;\n+\t  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t    {\n+\t      struct df_link *swap_link = DF_REF_CHAIN (use);\n+\n+\t      while (swap_link)\n+\t\t{\n+\t\t  if (DF_REF_IS_ARTIFICIAL (link->ref))\n+\t\t    return false;\n+\n+\t\t  rtx swap_def_insn = DF_REF_INSN (swap_link->ref);\n+\t\t  unsigned uid2 = INSN_UID (swap_def_insn);\n+\n+\t\t  /* Only permuting loads are allowed.  */\n+\t\t  if (!insn_entry[uid2].is_swap || !insn_entry[uid2].is_load)\n+\t\t    return false;\n+\n+\t\t  swap_link = swap_link->next;\n+\t\t}\n+\t    }\n+\t}\n+      else if (purpose == FOR_STORES)\n+\t{\n+\t  df_ref def;\n+\t  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t    {\n+\t      struct df_link *swap_link = DF_REF_CHAIN (def);\n+\n+\t      while (swap_link)\n+\t\t{\n+\t\t  if (DF_REF_IS_ARTIFICIAL (link->ref))\n+\t\t    return false;\n+\n+\t\t  rtx swap_use_insn = DF_REF_INSN (swap_link->ref);\n+\t\t  unsigned uid2 = INSN_UID (swap_use_insn);\n+\n+\t\t  /* Permuting stores or register swaps are allowed.  */\n+\t\t  if (!insn_entry[uid2].is_swap || insn_entry[uid2].is_load)\n+\t\t    return false;\n+\n+\t\t  swap_link = swap_link->next;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Mark the xxswapdi instructions associated with permuting loads and\n+   stores for removal.  Note that we only flag them for deletion here,\n+   as there is a possibility of a swap being reached from multiple\n+   loads, etc.  */\n+static void\n+mark_swaps_for_removal (swap_web_entry *insn_entry, unsigned int i)\n+{\n+  rtx insn = insn_entry[i].insn;\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\n+  if (insn_entry[i].is_load)\n+    {\n+      df_ref def;\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t{\n+\t  struct df_link *link = DF_REF_CHAIN (def);\n+\n+\t  /* We know by now that these are swaps, so we can delete\n+\t     them confidently.  */\n+\t  while (link)\n+\t    {\n+\t      rtx use_insn = DF_REF_INSN (link->ref);\n+\t      insn_entry[INSN_UID (use_insn)].will_delete = 1;\n+\t      link = link->next;\n+\t    }\n+\t}\n+    }\n+  else if (insn_entry[i].is_store)\n+    {\n+      df_ref use;\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t{\n+\t  /* Ignore uses for addressability.  */\n+\t  enum machine_mode mode = GET_MODE (DF_REF_REG (use));\n+\t  if (!VECTOR_MODE_P (mode))\n+\t    continue;\n+\n+\t  struct df_link *link = DF_REF_CHAIN (use);\n+\n+\t  /* We know by now that these are swaps, so we can delete\n+\t     them confidently.  */\n+\t  while (link)\n+\t    {\n+\t      rtx def_insn = DF_REF_INSN (link->ref);\n+\t      insn_entry[INSN_UID (def_insn)].will_delete = 1;\n+\t      link = link->next;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* OP is either a CONST_VECTOR or an expression containing one.\n+   Swap the first half of the vector with the second in the first\n+   case.  Recurse to find it in the second.  */\n+static void\n+swap_const_vector_halves (rtx op)\n+{\n+  int i;\n+  enum rtx_code code = GET_CODE (op);\n+  if (GET_CODE (op) == CONST_VECTOR)\n+    {\n+      int half_units = GET_MODE_NUNITS (GET_MODE (op)) / 2;\n+      for (i = 0; i < half_units; ++i)\n+\t{\n+\t  rtx temp = CONST_VECTOR_ELT (op, i);\n+\t  CONST_VECTOR_ELT (op, i) = CONST_VECTOR_ELT (op, i + half_units);\n+\t  CONST_VECTOR_ELT (op, i + half_units) = temp;\n+\t}\n+    }\n+  else\n+    {\n+      int j;\n+      const char *fmt = GET_RTX_FORMAT (code);\n+      for (i = 0; i < GET_RTX_LENGTH (code); ++i)\n+\tif (fmt[i] == 'e' || fmt[i] == 'u')\n+\t  swap_const_vector_halves (XEXP (op, i));\n+\telse if (fmt[i] == 'E')\n+\t  for (j = 0; j < XVECLEN (op, i); ++j)\n+\t    swap_const_vector_halves (XVECEXP (op, i, j));\n+    }\n+}\n+\n+/* Find all subregs of a vector expression that perform a narrowing,\n+   and adjust the subreg index to account for doubleword swapping.  */\n+static void\n+adjust_subreg_index (rtx op)\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  if (code == SUBREG\n+      && (GET_MODE_SIZE (GET_MODE (op))\n+\t  < GET_MODE_SIZE (GET_MODE (XEXP (op, 0)))))\n+    {\n+      unsigned int index = SUBREG_BYTE (op);\n+      if (index < 8)\n+\tindex += 8;\n+      else\n+\tindex -= 8;\n+      SUBREG_BYTE (op) = index;\n+    }\n+\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  int i,j;\n+  for (i = 0; i < GET_RTX_LENGTH (code); ++i)\n+    if (fmt[i] == 'e' || fmt[i] == 'u')\n+      adjust_subreg_index (XEXP (op, i));\n+    else if (fmt[i] == 'E')\n+      for (j = 0; j < XVECLEN (op, i); ++j)\n+\tadjust_subreg_index (XVECEXP (op, i, j));\n+}\n+\n+/* Convert the non-permuting load INSN to a permuting one.  */\n+static void\n+permute_load (rtx insn)\n+{\n+  rtx body = PATTERN (insn);\n+  rtx mem_op = SET_SRC (body);\n+  rtx tgt_reg = SET_DEST (body);\n+  enum machine_mode mode = GET_MODE (tgt_reg);\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  int half_elts = n_elts / 2;\n+  rtx par = gen_rtx_PARALLEL (mode, rtvec_alloc (n_elts));\n+  int i, j;\n+  for (i = 0, j = half_elts; i < half_elts; ++i, ++j)\n+    XVECEXP (par, 0, i) = GEN_INT (j);\n+  for (i = half_elts, j = 0; j < half_elts; ++i, ++j)\n+    XVECEXP (par, 0, i) = GEN_INT (j);\n+  rtx sel = gen_rtx_VEC_SELECT (mode, mem_op, par);\n+  SET_SRC (body) = sel;\n+  INSN_CODE (insn) = -1; /* Force re-recognition.  */\n+  df_insn_rescan (insn);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Replacing load %d with permuted load\\n\",\n+\t     INSN_UID (insn));\n+}\n+\n+/* Convert the non-permuting store INSN to a permuting one.  */\n+static void\n+permute_store (rtx insn)\n+{\n+  rtx body = PATTERN (insn);\n+  rtx src_reg = SET_SRC (body);\n+  enum machine_mode mode = GET_MODE (src_reg);\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  int half_elts = n_elts / 2;\n+  rtx par = gen_rtx_PARALLEL (mode, rtvec_alloc (n_elts));\n+  int i, j;\n+  for (i = 0, j = half_elts; i < half_elts; ++i, ++j)\n+    XVECEXP (par, 0, i) = GEN_INT (j);\n+  for (i = half_elts, j = 0; j < half_elts; ++i, ++j)\n+    XVECEXP (par, 0, i) = GEN_INT (j);\n+  rtx sel = gen_rtx_VEC_SELECT (mode, src_reg, par);\n+  SET_SRC (body) = sel;\n+  INSN_CODE (insn) = -1; /* Force re-recognition.  */\n+  df_insn_rescan (insn);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Replacing store %d with permuted store\\n\",\n+\t     INSN_UID (insn));\n+}\n+\n+/* The insn described by INSN_ENTRY[I] can be swapped, but only\n+   with special handling.  Take care of that here.  */\n+static void\n+handle_special_swappables (swap_web_entry *insn_entry, unsigned i)\n+{\n+  rtx insn = insn_entry[i].insn;\n+  rtx body = PATTERN (insn);\n+\n+  switch (insn_entry[i].special_handling)\n+    {\n+    case SH_CONST_VECTOR:\n+      {\n+\t/* A CONST_VECTOR will only show up somewhere in the RHS of a SET.  */\n+\tgcc_assert (GET_CODE (body) == SET);\n+\trtx rhs = SET_SRC (body);\n+\tswap_const_vector_halves (rhs);\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"Swapping constant halves in insn %d\\n\", i);\n+\tbreak;\n+      }\n+    case SH_SUBREG:\n+      /* A subreg of the same size is already safe.  For subregs that\n+\t select a smaller portion of a reg, adjust the index for\n+\t swapped doublewords.  */\n+      adjust_subreg_index (body);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Adjusting subreg in insn %d\\n\", i);\n+      break;\n+    case SH_NOSWAP_LD:\n+      /* Convert a non-permuting load to a permuting one.  */\n+      permute_load (insn);\n+      break;\n+    case SH_NOSWAP_ST:\n+      /* Convert a non-permuting store to a permuting one.  */\n+      permute_store (insn);\n+      break;\n+    }\n+}\n+\n+/* Find the insn from the Ith table entry, which is known to be a\n+   register swap Y = SWAP(X).  Replace it with a copy Y = X.  */\n+static void\n+replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)\n+{\n+  rtx insn = insn_entry[i].insn;\n+  rtx body = PATTERN (insn);\n+  rtx src_reg = XEXP (SET_SRC (body), 0);\n+  rtx copy = gen_rtx_SET (VOIDmode, SET_DEST (body), src_reg);\n+  rtx new_insn = emit_insn_before (copy, insn);\n+  set_block_for_insn (new_insn, BLOCK_FOR_INSN (insn));\n+  df_insn_rescan (new_insn);\n+\n+  if (dump_file)\n+    {\n+      unsigned int new_uid = INSN_UID (new_insn);\n+      fprintf (dump_file, \"Replacing swap %d with copy %d\\n\", i, new_uid);\n+    }\n+\n+  df_insn_delete (insn);\n+  remove_insn (insn);\n+  INSN_DELETED_P (insn) = 1;\n+}\n+\n+/* Dump the swap table to DUMP_FILE.  */\n+static void\n+dump_swap_insn_table (swap_web_entry *insn_entry)\n+{\n+  int e = get_max_uid ();\n+  fprintf (dump_file, \"\\nRelevant insns with their flag settings\\n\\n\");\n+\n+  for (int i = 0; i < e; ++i)\n+    if (insn_entry[i].is_relevant)\n+      {\n+\tswap_web_entry *pred_entry = (swap_web_entry *)insn_entry[i].pred ();\n+\tfprintf (dump_file, \"%6d %6d  \", i,\n+\t\t pred_entry && pred_entry->insn\n+\t\t ? INSN_UID (pred_entry->insn) : 0);\n+\tif (insn_entry[i].is_load)\n+\t  fputs (\"load \", dump_file);\n+\tif (insn_entry[i].is_store)\n+\t  fputs (\"store \", dump_file);\n+\tif (insn_entry[i].is_swap)\n+\t  fputs (\"swap \", dump_file);\n+\tif (insn_entry[i].is_live_in)\n+\t  fputs (\"live-in \", dump_file);\n+\tif (insn_entry[i].is_live_out)\n+\t  fputs (\"live-out \", dump_file);\n+\tif (insn_entry[i].contains_subreg)\n+\t  fputs (\"subreg \", dump_file);\n+\tif (insn_entry[i].is_128_int)\n+\t  fputs (\"int128 \", dump_file);\n+\tif (insn_entry[i].is_call)\n+\t  fputs (\"call \", dump_file);\n+\tif (insn_entry[i].is_swappable)\n+\t  {\n+\t    fputs (\"swappable \", dump_file);\n+\t    if (insn_entry[i].special_handling == SH_CONST_VECTOR)\n+\t      fputs (\"special:constvec \", dump_file);\n+\t    else if (insn_entry[i].special_handling == SH_SUBREG)\n+\t      fputs (\"special:subreg \", dump_file);\n+\t    else if (insn_entry[i].special_handling == SH_NOSWAP_LD)\n+\t      fputs (\"special:load \", dump_file);\n+\t    else if (insn_entry[i].special_handling == SH_NOSWAP_ST)\n+\t      fputs (\"special:store \", dump_file);\n+\t  }\n+\tif (insn_entry[i].web_not_optimizable)\n+\t  fputs (\"unoptimizable \", dump_file);\n+\tif (insn_entry[i].will_delete)\n+\t  fputs (\"delete \", dump_file);\n+\tfputs (\"\\n\", dump_file);\n+      }\n+  fputs (\"\\n\", dump_file);\n+}\n \n+/* Main entry point for this pass.  */\n+unsigned int\n+rs6000_analyze_swaps (function *fun)\n+{\n+  swap_web_entry *insn_entry;\n+  basic_block bb;\n+  rtx insn;\n+\n+  /* Dataflow analysis for use-def chains.  */\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);\n+  df_analyze ();\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n+  /* Allocate structure to represent webs of insns.  */\n+  insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());\n+\n+  /* Walk the insns to gather basic data.  */\n+  FOR_ALL_BB_FN (bb, fun)\n+    FOR_BB_INSNS (bb, insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  insn_entry[uid].insn = insn;\n+\n+\t  if (GET_CODE (insn) == CALL_INSN)\n+\t    insn_entry[uid].is_call = 1;\n+\n+\t  /* Walk the uses and defs to see if we mention vector regs.\n+\t     Record any constraints on optimization of such mentions.  */\n+\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t  df_ref mention;\n+\t  FOR_EACH_INSN_INFO_USE (mention, insn_info)\n+\t    {\n+\t      /* We use DF_REF_REAL_REG here to get inside any subregs.  */\n+\t      enum machine_mode mode = GET_MODE (DF_REF_REAL_REG (mention));\n+\n+\t      /* If a use gets its value from a call insn, it will be\n+\t\t a hard register and will look like (reg:V4SI 3 3).\n+\t\t The df analysis creates two mentions for GPR3 and GPR4,\n+\t\t both DImode.  We must recognize this and treat it as a\n+\t\t vector mention to ensure the call is unioned with this\n+\t\t use.  */\n+\t      if (mode == DImode && DF_REF_INSN_INFO (mention))\n+\t\t{\n+\t\t  rtx feeder = DF_REF_INSN (mention);\n+\t\t  /* FIXME:  It is pretty hard to get from the df mention\n+\t\t     to the mode of the use in the insn.  We arbitrarily\n+\t\t     pick a vector mode here, even though the use might\n+\t\t     be a real DImode.  We can be too conservative\n+\t\t     (create a web larger than necessary) because of\n+\t\t     this, so consider eventually fixing this.  */\n+\t\t  if (GET_CODE (feeder) == CALL_INSN)\n+\t\t    mode = V4SImode;\n+\t\t}\n+\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t{\n+\t\t  insn_entry[uid].is_relevant = 1;\n+\t\t  if (mode == TImode || mode == V1TImode)\n+\t\t    insn_entry[uid].is_128_int = 1;\n+\t\t  if (DF_REF_INSN_INFO (mention))\n+\t\t    insn_entry[uid].contains_subreg\n+\t\t      = !rtx_equal_p (DF_REF_REG (mention),\n+\t\t\t\t      DF_REF_REAL_REG (mention));\n+\t\t  union_defs (insn_entry, insn, mention);\n+\t\t}\n+\t    }\n+\t  FOR_EACH_INSN_INFO_DEF (mention, insn_info)\n+\t    {\n+\t      /* We use DF_REF_REAL_REG here to get inside any subregs.  */\n+\t      enum machine_mode mode = GET_MODE (DF_REF_REAL_REG (mention));\n+\n+\t      /* If we're loading up a hard vector register for a call,\n+\t\t it looks like (set (reg:V4SI 9 9) (...)).  The df\n+\t\t analysis creates two mentions for GPR9 and GPR10, both\n+\t\t DImode.  So relying on the mode from the mentions\n+\t\t isn't sufficient to ensure we union the call into the\n+\t\t web with the parameter setup code.  */\n+\t      if (mode == DImode && GET_CODE (insn) == SET\n+\t\t  && VECTOR_MODE_P (GET_MODE (SET_DEST (insn))))\n+\t\tmode = GET_MODE (SET_DEST (insn));\n+\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t{\n+\t\t  insn_entry[uid].is_relevant = 1;\n+\t\t  if (mode == TImode || mode == V1TImode)\n+\t\t    insn_entry[uid].is_128_int = 1;\n+\t\t  if (DF_REF_INSN_INFO (mention))\n+\t\t    insn_entry[uid].contains_subreg\n+\t\t      = !rtx_equal_p (DF_REF_REG (mention),\n+\t\t\t\t      DF_REF_REAL_REG (mention));\n+\t\t  /* REG_FUNCTION_VALUE_P is not valid for subregs. */\n+\t\t  else if (REG_FUNCTION_VALUE_P (DF_REF_REG (mention)))\n+\t\t    insn_entry[uid].is_live_out = 1;\n+\t\t  union_uses (insn_entry, insn, mention);\n+\t\t}\n+\t    }\n+\n+\t  if (insn_entry[uid].is_relevant)\n+\t    {\n+\t      /* Determine if this is a load or store.  */\n+\t      insn_entry[uid].is_load = insn_is_load_p (insn);\n+\t      insn_entry[uid].is_store = insn_is_store_p (insn);\n+\n+\t      /* Determine if this is a doubleword swap.  If not,\n+\t\t determine whether it can legally be swapped.  */\n+\t      if (insn_is_swap_p (insn))\n+\t\tinsn_entry[uid].is_swap = 1;\n+\t      else\n+\t\t{\n+\t\t  unsigned int special = SH_NONE;\n+\t\t  insn_entry[uid].is_swappable\n+\t\t    = insn_is_swappable_p (insn_entry, insn, &special);\n+\t\t  if (special != SH_NONE && insn_entry[uid].contains_subreg)\n+\t\t    insn_entry[uid].is_swappable = 0;\n+\t\t  else if (special != SH_NONE)\n+\t\t    insn_entry[uid].special_handling = special;\n+\t\t  else if (insn_entry[uid].contains_subreg)\n+\t\t    insn_entry[uid].special_handling = SH_SUBREG;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nSwap insn entry table when first built\\n\");\n+      dump_swap_insn_table (insn_entry);\n+    }\n+\n+  /* Record unoptimizable webs.  */\n+  unsigned e = get_max_uid (), i;\n+  for (i = 0; i < e; ++i)\n+    {\n+      if (!insn_entry[i].is_relevant)\n+\tcontinue;\n+\n+      swap_web_entry *root\n+\t= (swap_web_entry*)(&insn_entry[i])->unionfind_root ();\n+\n+      if (insn_entry[i].is_live_in || insn_entry[i].is_live_out\n+\t  || (insn_entry[i].contains_subreg\n+\t      && insn_entry[i].special_handling != SH_SUBREG)\n+\t  || insn_entry[i].is_128_int || insn_entry[i].is_call\n+\t  || !(insn_entry[i].is_swappable || insn_entry[i].is_swap))\n+\troot->web_not_optimizable = 1;\n+\n+      /* If we have loads or stores that aren't permuting then the\n+\t optimization isn't appropriate.  */\n+      else if ((insn_entry[i].is_load || insn_entry[i].is_store)\n+\t  && !insn_entry[i].is_swap && !insn_entry[i].is_swappable)\n+\troot->web_not_optimizable = 1;\n+\n+      /* If we have permuting loads or stores that are not accompanied\n+\t by a register swap, the optimization isn't appropriate.  */\n+      else if (insn_entry[i].is_load && insn_entry[i].is_swap)\n+\t{\n+\t  rtx insn = insn_entry[i].insn;\n+\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t  df_ref def;\n+\n+\t  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t    {\n+\t      struct df_link *link = DF_REF_CHAIN (def);\n+\n+\t      if (!chain_contains_only_swaps (insn_entry, link, FOR_LOADS))\n+\t\t{\n+\t\t  root->web_not_optimizable = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else if (insn_entry[i].is_store && insn_entry[i].is_swap)\n+\t{\n+\t  rtx insn = insn_entry[i].insn;\n+\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t  df_ref use;\n+\n+\t  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t    {\n+\t      struct df_link *link = DF_REF_CHAIN (use);\n+\n+\t      if (!chain_contains_only_swaps (insn_entry, link, FOR_STORES))\n+\t\t{\n+\t\t  root->web_not_optimizable = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nSwap insn entry table after web analysis\\n\");\n+      dump_swap_insn_table (insn_entry);\n+    }\n+\n+  /* For each load and store in an optimizable web (which implies\n+     the loads and stores are permuting), find the associated\n+     register swaps and mark them for removal.  Due to various\n+     optimizations we may mark the same swap more than once.  Also\n+     perform special handling for swappable insns that require it.  */\n+  for (i = 0; i < e; ++i)\n+    if ((insn_entry[i].is_load || insn_entry[i].is_store)\n+\t&& insn_entry[i].is_swap)\n+      {\n+\tswap_web_entry* root_entry\n+\t  = (swap_web_entry*)((&insn_entry[i])->unionfind_root ());\n+\tif (!root_entry->web_not_optimizable)\n+\t  mark_swaps_for_removal (insn_entry, i);\n+      }\n+    else if (insn_entry[i].is_swappable && insn_entry[i].special_handling)\n+      {\n+\tswap_web_entry* root_entry\n+\t  = (swap_web_entry*)((&insn_entry[i])->unionfind_root ());\n+\tif (!root_entry->web_not_optimizable)\n+\t  handle_special_swappables (insn_entry, i);\n+      }\n+\n+  /* Now delete the swaps marked for removal.  */\n+  for (i = 0; i < e; ++i)\n+    if (insn_entry[i].will_delete)\n+      replace_swap_with_copy (insn_entry, i);\n+\n+  /* Clean up.  */\n+  free (insn_entry);\n+  return 0;\n+}\n+\n+const pass_data pass_data_analyze_swaps =\n+{\n+  RTL_PASS, /* type */\n+  \"swaps\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n+};\n+\n+class pass_analyze_swaps : public rtl_opt_pass\n+{\n+public:\n+  pass_analyze_swaps(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_analyze_swaps, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return (optimize > 0 && !BYTES_BIG_ENDIAN && TARGET_VSX\n+\t      && rs6000_optimize_swaps);\n+    }\n+\n+  virtual unsigned int execute (function *fun)\n+    {\n+      return rs6000_analyze_swaps (fun);\n+    }\n+\n+}; // class pass_analyze_swaps\n+\n+rtl_opt_pass *\n+make_pass_analyze_swaps (gcc::context *ctxt)\n+{\n+  return new pass_analyze_swaps (ctxt);\n+}\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "4d0d5e73db1b8ac8b9e09e4801780fc1772c79af", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -588,3 +588,7 @@ Allow double variables in upper registers with -mcpu=power7 or -mvsx\n mupper-regs-sf\n Target Undocumented Mask(UPPER_REGS_SF) Var(rs6000_isa_flags)\n Allow float variables in upper registers with -mcpu=power8 or -mp8-vector\n+\n+moptimize-swaps\n+Target Undocumented Var(rs6000_optimize_swaps) Init(1) Save\n+Analyze and remove doubleword swaps from VSX computations."}, {"sha": "f7e0abe477ff03c54e6af0febf9f63499f822652", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -1,3 +1,18 @@\n+2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/swaps-p8-1.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-2.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-3.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-4.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-5.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-6.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-7.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-8.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-9.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-10.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-11.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-12.c: New test.\n+\n 2014-08-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/ipa/devirt-37.C: Fix testcase."}, {"sha": "8658afb83dd95a35d8e29ad1c5ff2c9fb8c2bcfc", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-1.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+void abort();\n+\n+#define N 16\n+\n+signed char ca[N] __attribute__((aligned(16)));\n+signed char cb[] __attribute__((aligned(16)))\n+  = {8, 7, 6, 5, 4, 3, 2,  1,  0, -1, -2, -3, -4, -5, -6, -7};\n+signed char cc[] __attribute__((aligned(16)))\n+  = {1, 1, 2, 2, 3, 3, 2,  2,  1,  1,  0,  0, -1, -1, -2, -2};\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = cb[i] - cc[i];\n+  }\n+}\n+\n+int main ()\n+{\n+  signed char cd[] = {7, 6, 4, 3, 1, 0, 0, -1, -1, -2, -2, -3, -3, -4, -4, -5};\n+  int i;\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (ca[i] != cd[i])\n+      abort ();\n+  return 0;\n+}"}, {"sha": "c343eae8fc15f474240db9a78ccd5e65251c2408", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-10.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-10.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+void abort ();\n+\n+#define N 4096\n+int ca[N] __attribute__((aligned(16)));\n+int cb[N] __attribute__((aligned(16)));\n+int cc[N] __attribute__((aligned(16)));\n+int cd[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = 3 * i - 2048;\n+    cc[i] = -5 * i + 93;\n+    cd[i] = i % 2 ? 1 : -1;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)\n+      abort ();\n+    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "ccb49971285be04225a83a5b2fe6248f0cbd757f", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-11.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-11.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+#include <altivec.h>\n+void abort ();\n+\n+#define N 4096\n+int ca[N] __attribute__((aligned(16)));\n+int cb[N] __attribute__((aligned(16)));\n+int cc[N] __attribute__((aligned(16)));\n+int cd[N] __attribute__((aligned(16)));\n+int hey;\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  vector int va, vb, vc, vd, tmp;\n+  vector unsigned int threes = vec_splat_u32(3);\n+  for (i = 0; i < N; i+=4) {\n+    vb = vec_vsx_ld (0, &cb[i]);\n+    vc = vec_vsx_ld (0, &cc[i]);\n+    vd = vec_vsx_ld (0, &cd[i]);\n+    tmp = vec_add (vb, vc);\n+    tmp = vec_sub (tmp, vd);\n+    tmp = vec_sra (tmp, threes);\n+    hey = tmp[3];\n+    vec_vsx_st (tmp, 0, &ca[i]);\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = 3 * i - 2048;\n+    cc[i] = -5 * i + 93;\n+    cd[i] = i + 14;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (ca[i] != (-3 * i - 1969) >> 3)\n+      abort ();\n+  if (hey != ca[N-1])\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c0b29bd511b4e87fcc8e49d8561f811891278f2e", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-12.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-12.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+#include \"altivec.h\"\n+void abort ();\n+\n+#define N 4096\n+int ca[N] __attribute__((aligned(16)));\n+int cb[N] __attribute__((aligned(16)));\n+int cc[N] __attribute__((aligned(16)));\n+int cd[N] __attribute__((aligned(16)));\n+int hey;\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  vector int va, vb, vc, vd, tmp;\n+  vector unsigned int threes = vec_splat_u32(3);\n+  for (i = 0; i < N; i+=4) {\n+    vb = vec_vsx_ld (0, &cb[i]);\n+    vc = vec_vsx_ld (0, &cc[i]);\n+    vd = vec_vsx_ld (0, &cd[i]);\n+    tmp = vec_add (vb, vc);\n+    tmp = vec_sub (tmp, vd);\n+    tmp = vec_sra (tmp, threes);\n+    hey = tmp[3];\n+    vec_vsx_st (tmp, 0, &ca[i]);\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = 3 * i - 2048;\n+    cc[i] = -5 * i + 93;\n+    cd[i] = i + 14;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (ca[i] != (-3 * i - 1969) >> 3)\n+      abort ();\n+  if (hey != ca[N-1])\n+    abort ();\n+  return 0;\n+}"}, {"sha": "93b49357dd8794f7f2cd2f012a2cc670501a9933", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-2.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+void abort ();\n+\n+#define N 256\n+signed char ca[N] __attribute__((aligned(16)));\n+signed char cb[N] __attribute__((aligned(16)));\n+signed char cc[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = cb[i] - cc[i];\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = i - 128;\n+    cc[i] = i/2 - 64;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (ca[i] != i - i/2 - 64)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "d305a469544c8ff501bef8fa395dd561404914c1", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-3.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-3.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+void abort ();\n+\n+#define N 4096\n+signed char ca[N] __attribute__((aligned(16)));\n+signed char cb[N] __attribute__((aligned(16)));\n+signed char cc[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = cb[i] - cc[i];\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i, ii;\n+  for (i = 0, ii = 0; i < N; ++i, ii = (ii + 1) % 128) {\n+    cb[i] = ii - 128;\n+    cc[i] = ii/2 - 64;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i, ii;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i) {\n+    ii = i % 128;\n+    if (ca[i] != ii - ii/2 - 64)\n+      abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "dbaca6be6dfe82c4fefff150c036fb2190749e88", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-4.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+void abort ();\n+\n+#define N 4096\n+int ca[N] __attribute__((aligned(16)));\n+int cb[N] __attribute__((aligned(16)));\n+int cc[N] __attribute__((aligned(16)));\n+int cd[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = (cb[i] + cc[i]) * cd[i];\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = 3 * i - 2048;\n+    cc[i] = -5 * i + 93;\n+    cd[i] = i % 2 ? 1 : -1;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (i % 2 == 1 && ca[i] != -2 * i - 1955)\n+      abort ();\n+    else if (i % 2 == 0 && ca[i] != 1955 + 2 * i)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "19606f0e0f18a94bb7e9bc298ac27050124918e9", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-5.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-5.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+void abort ();\n+\n+#define N 4096\n+int ca[N] __attribute__((aligned(16)));\n+int cb[N] __attribute__((aligned(16)));\n+int cc[N] __attribute__((aligned(16)));\n+int cd[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = 3 * i - 2048;\n+    cc[i] = -5 * i + 93;\n+    cd[i] = i % 2 ? 1 : -1;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)\n+      abort ();\n+    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "dd25c52671687642680e9a9b0bc7c5c6a657b1b9", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-6.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-6.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+void abort();\n+\n+#define N 16\n+\n+signed char ca[N] __attribute__((aligned(16)));\n+signed char cb[] __attribute__((aligned(16)))\n+  = {8, 7, 6, 5, 4, 3, 2,  1,  0, -1, -2, -3, -4, -5, -6, -7};\n+signed char cc[] __attribute__((aligned(16)))\n+  = {1, 1, 2, 2, 3, 3, 2,  2,  1,  1,  0,  0, -1, -1, -2, -2};\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = cb[i] - cc[i];\n+  }\n+}\n+\n+int main ()\n+{\n+  signed char cd[] = {7, 6, 4, 3, 1, 0, 0, -1, -1, -2, -2, -3, -3, -4, -4, -5};\n+  int i;\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (ca[i] != cd[i])\n+      abort ();\n+  return 0;\n+}"}, {"sha": "0cc37e28310cf91b505cf9e5b9c770113601eef1", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-7.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+void abort ();\n+\n+#define N 256\n+signed char ca[N] __attribute__((aligned(16)));\n+signed char cb[N] __attribute__((aligned(16)));\n+signed char cc[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = cb[i] - cc[i];\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = i - 128;\n+    cc[i] = i/2 - 64;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (ca[i] != i - i/2 - 64)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "16edebe0bd8bc10585f415a97b2055ce1592323f", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-8.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-8.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+void abort ();\n+\n+#define N 4096\n+signed char ca[N] __attribute__((aligned(16)));\n+signed char cb[N] __attribute__((aligned(16)));\n+signed char cc[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = cb[i] - cc[i];\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i, ii;\n+  for (i = 0, ii = 0; i < N; ++i, ii = (ii + 1) % 128) {\n+    cb[i] = ii - 128;\n+    cc[i] = ii/2 - 64;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i, ii;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i) {\n+    ii = i % 128;\n+    if (ca[i] != ii - ii/2 - 64)\n+      abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "c12a5842a32948a22b2ef2407815404e208889a9", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-9.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa6eb35446c6fc17b41caa615e700420eb5f7be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-9.c?ref=6fa6eb35446c6fc17b41caa615e700420eb5f7be", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+void abort ();\n+\n+#define N 4096\n+int ca[N] __attribute__((aligned(16)));\n+int cb[N] __attribute__((aligned(16)));\n+int cc[N] __attribute__((aligned(16)));\n+int cd[N] __attribute__((aligned(16)));\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    ca[i] = (cb[i] + cc[i]) * cd[i];\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = 3 * i - 2048;\n+    cc[i] = -5 * i + 93;\n+    cd[i] = i % 2 ? 1 : -1;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (i % 2 == 1 && ca[i] != -2 * i - 1955)\n+      abort ();\n+    else if (i % 2 == 0 && ca[i] != 1955 + 2 * i)\n+      abort ();\n+  return 0;\n+}"}]}