{"sha": "11775988d5f6db984fb902b7447a5b2817b555b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE3NzU5ODhkNWY2ZGI5ODRmYjkwMmI3NDQ3YTViMjgxN2I1NTViMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:06:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:06:47Z"}, "message": "[multiple changes]\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Generate_Range_Check): Revert previous change.\n\n2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_util.adb: Minor reformatting/rewording.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib-xref.adb (Generate_Reference): The use\n\tof attribute 'Result is not considered a violation of pragma\n\tUnreferenced.\n\n2017-04-27  Justin Squirek  <squirek@adacore.com>\n\n\t* cstand.adb (Create_Standard): Correctly set\n\tDirectly_Designated_Type for Any_Access.\n\t* sem_type.adb (Covers): Minor grammar fixes.\n\n2017-04-27  Bob Duff  <duff@adacore.com>\n\n\t* sem_attr.adb: Minor cleanup.\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cofuba.ads, a-cofuba.adb (Ada.Containers.Functional_Base): New\n\tprivate child of Ada.Containers used to implement all functional\n\tcontainers.\n\t* a-cofuma.ads, a-cofuma.adb (Ada.Containers.Functional_Maps): New\n\tchild of Ada.Containers. It provides functional indefinite unbounded\n\tmaps which can be used as high level models for specification\n\tof data structures.\n\t* a-cofuse.ads, a-cofuse.adb (Ada.Containers.Functional_Sets): New\n\tchild of Ada.Containers. It provides functional indefinite unbounded\n\tsets which can be used as high level models for specification\n\tof data structures.\n\t* a-cofuve.ads, a-cofuve.adb (Ada.Containers.Functional_Vectors): New\n\tchild of Ada.Containers.  It provides functional indefinite unbounded\n\tvectors which can be used as high level models for specification\n\tof data structures.\n\t* Makefile.rtl: Add new packages.\n\t* impunit.adb: Add new packages.\n\nFrom-SVN: r247296", "tree": {"sha": "9203c93f7366264fb3b03a3a500654d527e52570", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9203c93f7366264fb3b03a3a500654d527e52570"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11775988d5f6db984fb902b7447a5b2817b555b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11775988d5f6db984fb902b7447a5b2817b555b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11775988d5f6db984fb902b7447a5b2817b555b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11775988d5f6db984fb902b7447a5b2817b555b1/comments", "author": null, "committer": null, "parents": [{"sha": "f32eb59134d6d55d50cbce3e1900e2dafdfac8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32eb59134d6d55d50cbce3e1900e2dafdfac8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32eb59134d6d55d50cbce3e1900e2dafdfac8aa"}], "stats": {"total": 1434, "additions": 1400, "deletions": 34}, "files": [{"sha": "91c78f8371f521123653e3092ade9c623e59b3cf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -1,3 +1,47 @@\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Generate_Range_Check): Revert previous change.\n+\n+2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_util.adb: Minor reformatting/rewording.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib-xref.adb (Generate_Reference): The use\n+\tof attribute 'Result is not considered a violation of pragma\n+\tUnreferenced.\n+\n+2017-04-27  Justin Squirek  <squirek@adacore.com>\n+\n+\t* cstand.adb (Create_Standard): Correctly set\n+\tDirectly_Designated_Type for Any_Access.\n+\t* sem_type.adb (Covers): Minor grammar fixes.\n+\n+2017-04-27  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_attr.adb: Minor cleanup.\n+\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cofuba.ads, a-cofuba.adb (Ada.Containers.Functional_Base): New\n+\tprivate child of Ada.Containers used to implement all functional\n+\tcontainers.\n+\t* a-cofuma.ads, a-cofuma.adb (Ada.Containers.Functional_Maps): New\n+\tchild of Ada.Containers. It provides functional indefinite unbounded\n+\tmaps which can be used as high level models for specification\n+\tof data structures.\n+\t* a-cofuse.ads, a-cofuse.adb (Ada.Containers.Functional_Sets): New\n+\tchild of Ada.Containers. It provides functional indefinite unbounded\n+\tsets which can be used as high level models for specification\n+\tof data structures.\n+\t* a-cofuve.ads, a-cofuve.adb (Ada.Containers.Functional_Vectors): New\n+\tchild of Ada.Containers.  It provides functional indefinite unbounded\n+\tvectors which can be used as high level models for specification\n+\tof data structures.\n+\t* Makefile.rtl: Add new packages.\n+\t* impunit.adb: Add new packages.\n+\n 2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch4.adb: Minor reformatting."}, {"sha": "611b09b1b6ead45637ba39a242627f2c17a29599", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -137,6 +137,10 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-coboho$(objext) \\\n   a-cobove$(objext) \\\n   a-cofove$(objext) \\\n+  a-cofuba$(objext) \\\n+  a-cofuma$(objext) \\\n+  a-cofuse$(objext) \\\n+  a-cofuve$(objext) \\\n   a-cogeso$(objext) \\\n   a-cohama$(objext) \\\n   a-cohase$(objext) \\"}, {"sha": "dd29eea2f562a54b59d21e19d7704a32e2327583", "filename": "gcc/ada/a-cofuba.adb", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuba.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,206 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      ADA.CONTAINERS.FUNCTIONAL_BASE                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+\n+package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n+\n+   pragma Assertion_Policy\n+      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n+\n+   function To_Count (Idx : Extended_Index) return Count_Type\n+   is (Count_Type\n+       (Extended_Index'Pos (Idx)\n+        - Extended_Index'Pos (Extended_Index'First)));\n+   function To_Index (Position : Count_Type) return Extended_Index\n+   is (Extended_Index'Val\n+       (Position\n+        + Extended_Index'Pos (Extended_Index'First)));\n+   --  Conversion functions between Index_Type and Count_Type\n+\n+   function Find (C : Container; E : access Element_Type) return Count_Type;\n+   --  Search a container C for an element equal to E.all, return the\n+   --  position in the underlying array.\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (C1, C2 : Container) return Boolean is\n+   begin\n+      if C1.Elements'Length /= C2.Elements'Length then\n+         return False;\n+      end if;\n+\n+      for I in C1.Elements'Range loop\n+         if C1.Elements (I).all /= C2.Elements (I).all then\n+            return False;\n+         end if;\n+      end loop;\n+      return True;\n+   end \"=\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (C1, C2 : Container) return Boolean is\n+   begin\n+      for I in C1.Elements'Range loop\n+         if Find (C2, C1.Elements (I)) = 0 then\n+            return False;\n+         end if;\n+      end loop;\n+      return True;\n+   end \"<=\";\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   function Add (C : Container; E : Element_Type) return Container is\n+   begin\n+      return Container'(Elements =>\n+                           new Element_Array'\n+                          (C.Elements.all & new Element_Type'(E)));\n+   end Add;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (C : Container; E : access Element_Type) return Count_Type is\n+   begin\n+      for I in C.Elements'Range loop\n+         if C.Elements (I).all = E.all then\n+            return I;\n+         end if;\n+      end loop;\n+      return 0;\n+   end Find;\n+\n+   function Find (C : Container; E : Element_Type) return Extended_Index is\n+     (To_Index (Find (C, E'Unrestricted_Access)));\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get (C : Container; I : Index_Type) return Element_Type is\n+     (C.Elements (To_Count (I)).all);\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   function Intersection (C1, C2 : Container) return Container is\n+      A : constant Element_Array_Access :=\n+        new Element_Array'(1 .. Num_Overlaps (C1, C2) => <>);\n+      P : Count_Type := 0;\n+   begin\n+      for I in C1.Elements'Range loop\n+         if Find (C2, C1.Elements (I)) > 0 then\n+            P := P + 1;\n+            A (P) := C1.Elements (I);\n+         end if;\n+      end loop;\n+      return Container'(Elements => A);\n+   end Intersection;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (C : Container) return Count_Type is\n+     (C.Elements'Length);\n+\n+   ---------------------\n+   -- Num_Overlaps --\n+   ---------------------\n+\n+   function Num_Overlaps (C1, C2 : Container) return Count_Type is\n+      P : Count_Type := 0;\n+   begin\n+      for I in C1.Elements'Range loop\n+         if Find (C2, C1.Elements (I)) > 0 then\n+            P := P + 1;\n+         end if;\n+      end loop;\n+      return P;\n+   end Num_Overlaps;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   function Set (C : Container; I : Index_Type; E : Element_Type)\n+                 return Container\n+   is\n+      Result : constant Container :=\n+        Container'(Elements => new Element_Array'(C.Elements.all));\n+   begin\n+      Result.Elements (To_Count (I)) := new Element_Type'(E);\n+      return Result;\n+   end Set;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   function Union (C1, C2 : Container) return Container is\n+      N : constant Count_Type := Num_Overlaps (C1, C2);\n+\n+   begin\n+      --  if C2 is completely included in C1 then return C1\n+\n+      if N = Length (C2) then\n+         return C1;\n+      end if;\n+\n+      --  else loop through C2 to find the remaining elements\n+\n+      declare\n+         L : constant Count_Type := Length (C1) - N + Length (C2);\n+         A : constant Element_Array_Access :=\n+           new Element_Array'(C1.Elements.all & (Length (C1) + 1 .. L => <>));\n+         P : Count_Type := Length (C1);\n+      begin\n+         for I in C2.Elements'Range loop\n+            if Find (C1, C2.Elements (I)) = 0 then\n+               P := P + 1;\n+               A (P) := C2.Elements (I);\n+            end if;\n+         end loop;\n+         return Container'(Elements => A);\n+      end;\n+   end Union;\n+\n+end Ada.Containers.Functional_Base;"}, {"sha": "6bcea9d20226ff305257f5a2336d7a7e65629b87", "filename": "gcc/ada/a-cofuba.ads", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuba.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuba.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuba.ads?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,104 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      ADA.CONTAINERS.FUNCTIONAL_BASE                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+--  Functional containers are neither controlled nor limited. This is safe as\n+--  no primitives is provided to modify them.\n+--  Memory allocated inside functional containers is never reclaimed.\n+\n+pragma Ada_2012;\n+\n+private generic\n+   type Index_Type is (<>);\n+   --  To avoid Constraint_Error being raised at runtime, Index_Type'Base\n+   --  should have at least one more element at the left than Index_Type.\n+\n+   type Element_Type (<>) is private;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+package Ada.Containers.Functional_Base with SPARK_Mode => Off is\n+\n+   subtype Extended_Index is Index_Type'Base range\n+     Index_Type'Pred (Index_Type'First) .. Index_Type'Last;\n+\n+   type Container is private;\n+\n+   function \"=\" (C1, C2 : Container) return Boolean;\n+   --  Return True if C1 and C2 contain the same elements at the same position\n+\n+   function Length (C : Container) return Count_Type;\n+   --  Number of elements stored in C.\n+\n+   function Get (C : Container; I : Index_Type) return Element_Type;\n+   --  Access to the element at index I in C.\n+\n+   function Set (C : Container; I : Index_Type; E : Element_Type)\n+                 return Container;\n+   --  Return a new container which is equal to C except for the element at\n+   --  index I which is set to E.\n+\n+   function Add (C : Container; E : Element_Type) return Container;\n+   --  Return a new container which is C appended with E.\n+\n+   function Find (C : Container; E : Element_Type) return Extended_Index;\n+   --  Return the first index for which the element stored in C is I.\n+   --  If there are no such indexes, return Extended_Index'First.\n+\n+   --------------------\n+   -- Set Operations --\n+   --------------------\n+\n+   function \"<=\" (C1, C2 : Container) return Boolean;\n+   --  Return True if every element of C1 is in C2\n+\n+   function Num_Overlaps (C1, C2 : Container) return Count_Type;\n+   --  Return the number of elements that are both in\n+\n+   function Union (C1, C2 : Container) return Container;\n+   --  Return a container which is C1 plus all the elements of C2 that are not\n+   --  in C1.\n+\n+   function Intersection (C1, C2 : Container) return Container;\n+   --  Return a container which is C1 minus all the elements that are also in\n+   --  C2.\n+\n+private\n+\n+   subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+   type Element_Access is access all Element_Type;\n+   type Element_Array is\n+     array (Positive_Count_Type range <>) of Element_Access;\n+   type Element_Array_Access is not null access Element_Array;\n+   Empty_Element_Array_Access : constant Element_Array_Access :=\n+     new Element_Array'(1 .. 0 => null);\n+\n+   type Container is record\n+      Elements : Element_Array_Access := Empty_Element_Array_Access;\n+   end record;\n+end Ada.Containers.Functional_Base;"}, {"sha": "9367baeea1341745a8ace611f371bc2565bc2005", "filename": "gcc/ada/a-cofuma.adb", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,161 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      ADA.CONTAINERS.FUNCTIONAL_MAPS                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n+   use Key_Containers;\n+   use Element_Containers;\n+\n+   pragma Assertion_Policy\n+      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (M1, M2 : Map) return Boolean is\n+     (M1.Keys <= M2.Keys and M2 <= M1);\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (M1, M2 : Map) return Boolean is\n+      I2 : Count_Type;\n+   begin\n+      for I1 in 1 .. Length (M1.Keys) loop\n+         I2 := Find (M2.Keys, Get (M1.Keys, I1));\n+         if I2 = 0\n+           or else Get (M2.Elements, I2) /= Get (M1.Elements, I1)\n+         then\n+            return False;\n+         end if;\n+      end loop;\n+      return True;\n+   end \"<=\";\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   function Add (M : Map; K : Key_Type; E : Element_Type) return Map is\n+   begin\n+      return\n+        (Keys     => Add (M.Keys, K),\n+         Elements => Add (M.Elements, E));\n+   end Add;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get (M : Map; K : Key_Type) return Element_Type is\n+   begin\n+      return Get (M.Elements, Find (M.Keys, K));\n+   end Get;\n+\n+   ------------\n+   -- Is_Add --\n+   ------------\n+\n+   function Is_Add\n+     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n+   is\n+   begin\n+      if Mem (M, K) or not Mem (Result, K) or Get (Result, K) /= E then\n+         return False;\n+      end if;\n+\n+      for K of M loop\n+         if not Mem (Result, K) or else Get (Result, K) /= Get (M, K) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      for KK of Result loop\n+         if KK /= K and not Mem (M, KK) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Is_Add;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (M : Map) return Boolean is\n+   begin\n+      return Length (M.Keys) = 0;\n+   end Is_Empty;\n+\n+   ------------\n+   -- Is_Set --\n+   ------------\n+\n+   function Is_Set\n+     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n+   is\n+     (Mem (M, K)\n+      and then Mem (Result, K)\n+      and then Get (Result, K) = E\n+      and then (for all KK of M => Mem (Result, KK)\n+                and then\n+                  (if K /= KK\n+                   then Get (Result, KK) = Get (M, KK)))\n+      and then (for all K of Result => Mem (M, K)));\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (M : Map) return Count_Type is\n+   begin\n+      return Length (M.Elements);\n+   end Length;\n+\n+   ---------\n+   -- Mem --\n+   ---------\n+\n+   function Mem (M : Map; K : Key_Type) return Boolean is\n+   begin\n+      return Find (M.Keys, K) > 0;\n+   end Mem;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   function Set (M : Map; K : Key_Type; E : Element_Type) return Map is\n+     (Keys => M.Keys, Elements => Set (M.Elements, Find (M.Keys, K), E));\n+end Ada.Containers.Functional_Maps;"}, {"sha": "23fb45c0a9d2280e168cd339bceec1e3ea80b5c8", "filename": "gcc/ada/a-cofuma.ads", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,193 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      ADA.CONTAINERS.FUNCTIONAL_MAPS                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+private with Ada.Containers.Functional_Base;\n+\n+generic\n+   type Key_Type (<>) is private;\n+   type Element_Type (<>)  is private;\n+   with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+package Ada.Containers.Functional_Maps with SPARK_Mode is\n+\n+   type Map is private with\n+     Default_Initial_Condition => Is_Empty (Map) and Length (Map) = 0,\n+     Iterable                  => (First       => Iter_First,\n+                                   Next        => Iter_Next,\n+                                   Has_Element => Iter_Has_Element,\n+                                   Element     => Iter_Element);\n+   --  Maps are empty when default initialized.\n+   --  For in quantification over maps should not be used.\n+   --  For of quantification over maps iterates over keys.\n+\n+   --  Maps are axiomatized using Mem and Get encoding respectively the\n+   --  presence of a key in a map and an accessor to elements associated to its\n+   --  keys. The length of a map is also added to protect Add against overflows\n+   --  but it is not actually modeled.\n+\n+   function Mem (M : Map; K : Key_Type) return Boolean with\n+     Global => null;\n+   function Get (M : Map; K : Key_Type) return Element_Type with\n+     Global => null,\n+     Pre    => Mem (M, K);\n+\n+   function Length (M : Map) return Count_Type with\n+     Global => null;\n+\n+   function \"<=\" (M1, M2 : Map) return Boolean with\n+   --  Map inclusion.\n+\n+     Global => null,\n+     Post   => \"<=\"'Result =\n+       (for all K of M1 => Mem (M2, K)\n+        and then Get (M2, K) = Get (M1, K));\n+\n+   function \"=\" (M1, M2 : Map) return Boolean with\n+   --  Extensional equality over maps.\n+\n+     Global => null,\n+     Post   => \"=\"'Result =\n+       ((for all K of M1 => Mem (M2, K)\n+        and then Get (M2, K) = Get (M1, K))\n+        and (for all K of M2 => Mem (M1, K)));\n+\n+   pragma Warnings (Off, \"unused variable \"\"K\"\"\");\n+   function Is_Empty (M : Map) return Boolean with\n+   --  A map is empty if it contains no key.\n+\n+     Global => null,\n+     Post   => Is_Empty'Result = (for all K of M => False);\n+   pragma Warnings (On, \"unused variable \"\"K\"\"\");\n+\n+   function Is_Add\n+     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n+   --  Returns True if Result is M augmented with the mapping K -> E.\n+\n+   with\n+     Global => null,\n+     Post   => Is_Add'Result =\n+         (not Mem (M, K)\n+          and then (Mem (Result, K) and then Get (Result, K) = E\n+            and then (for all K of M => Mem (Result, K)\n+                 and then Get (Result, K) = Get (M, K))\n+            and then (for all KK of Result =>\n+                        Equivalent_Keys (KK, K) or Mem (M, KK))));\n+\n+   function Add (M : Map; K : Key_Type; E : Element_Type) return Map with\n+   --  Returns M augmented with the mapping K -> E.\n+   --  Is_Add (M, K, E, Result) should be used instead of\n+   --  Result = Add (M, K, E) whenever possible both for execution and for\n+   --  proof.\n+\n+     Global => null,\n+     Pre    => not Mem (M, K) and Length (M) < Count_Type'Last,\n+     Post   => Length (M) + 1 = Length (Add'Result)\n+               and Is_Add (M, K, E, Add'Result);\n+\n+   function Is_Set\n+     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n+   --  Returns True if Result is M where the element associated to K has been\n+   --  replaced by E.\n+\n+   with\n+     Global => null,\n+     Post   => Is_Set'Result =\n+         (Mem (M, K)\n+          and then Mem (Result, K)\n+          and then Get (Result, K) = E\n+          and then (for all KK of M => Mem (Result, KK)\n+               and then (if not Equivalent_Keys (K, KK)\n+                         then Get (Result, KK) = Get (M, KK)))\n+          and then (for all K of Result => Mem (M, K)));\n+\n+   function Set (M : Map; K : Key_Type; E : Element_Type) return Map with\n+   --  Returns M where the element associated to K has been replaced by E.\n+   --  Is_Set (M, K, E, Result) should be used instead of\n+   --  Result = Set (M, K, E) whenever possible both for execution and for\n+   --  proof.\n+\n+     Global => null,\n+     Pre    => Mem (M, K),\n+     Post   => Length (M) = Length (Set'Result)\n+     and Is_Set (M, K, E, Set'Result);\n+\n+   ---------------------------\n+   --  Iteration Primitives --\n+   ---------------------------\n+\n+   type Private_Key is private;\n+\n+   function Iter_First (M : Map) return Private_Key with\n+     Global => null;\n+   function Iter_Has_Element (M : Map; K : Private_Key) return Boolean with\n+     Global => null;\n+   function Iter_Next (M : Map; K : Private_Key) return Private_Key with\n+     Global => null,\n+     Pre    => Iter_Has_Element (M, K);\n+   function Iter_Element (M : Map; K : Private_Key) return Key_Type with\n+     Global => null,\n+     Pre    => Iter_Has_Element (M, K);\n+   pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Mem);\n+private\n+   pragma SPARK_Mode (Off);\n+\n+   function \"=\"  (Left, Right : Key_Type) return Boolean\n+                  renames Equivalent_Keys;\n+\n+   subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+   package Element_Containers is new Ada.Containers.Functional_Base\n+     (Element_Type        => Element_Type,\n+      Index_Type          => Positive_Count_Type);\n+\n+   package Key_Containers is new Ada.Containers.Functional_Base\n+     (Element_Type        => Key_Type,\n+      Index_Type          => Positive_Count_Type);\n+\n+   type Map is record\n+      Keys     : Key_Containers.Container;\n+      Elements : Element_Containers.Container;\n+   end record;\n+\n+   type Private_Key is new Count_Type;\n+\n+   function Iter_First (M : Map) return Private_Key is (1);\n+\n+   function Iter_Has_Element (M : Map; K : Private_Key) return Boolean is\n+     (Count_Type (K) in 1 .. Key_Containers.Length (M.Keys));\n+\n+   function Iter_Next (M : Map; K : Private_Key) return Private_Key is\n+     (if K = Private_Key'Last then 0 else K + 1);\n+\n+   function Iter_Element (M : Map; K : Private_Key) return Key_Type is\n+     (Key_Containers.Get (M.Keys, Count_Type (K)));\n+end Ada.Containers.Functional_Maps;"}, {"sha": "21417b2eda76adf979946b3c2e0be497bdd39e97", "filename": "gcc/ada/a-cofuse.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      ADA.CONTAINERS.FUNCTIONAL_SETS                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+\n+package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n+   use Containers;\n+\n+   pragma Assertion_Policy\n+      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (S1, S2 : Set) return Boolean is\n+     (S1.Content <= S2.Content and S2.Content <= S1.Content);\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (S1, S2 : Set) return Boolean is (S1.Content <= S2.Content);\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   function Add (S : Set; E : Element_Type) return Set is\n+     (Content => Add (S.Content, E));\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (S : Set) return Count_Type is (Length (S.Content));\n+\n+   ---------\n+   -- Mem --\n+   ---------\n+\n+   function Mem (S : Set; E : Element_Type) return Boolean is\n+      (Find (S.Content, E) > 0);\n+\n+   ------------------\n+   -- Num_Overlaps --\n+   ------------------\n+\n+   function Num_Overlaps (S1, S2 : Set) return Count_Type is\n+      (Num_Overlaps (S1.Content, S2.Content));\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   function Intersection (S1, S2 : Set) return Set is\n+     (Content => Intersection (S1.Content, S2.Content));\n+\n+   ------------\n+   -- Is_Add --\n+   ------------\n+\n+   function Is_Add (S : Set; E : Element_Type; Result : Set) return Boolean\n+   is\n+     (Mem (Result, E)\n+      and (for all F of Result => Mem (S, F) or F = E)\n+      and (for all E of S => Mem (Result, E)));\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (S : Set) return Boolean is (Length (S.Content) = 0);\n+\n+   ---------------------\n+   -- Is_Intersection --\n+   ---------------------\n+\n+   function Is_Intersection (S1, S2, Result : Set) return Boolean is\n+     ((for all E of Result =>\n+            Mem (S1, E) and Mem (S2, E))\n+      and (for all E of S1 =>\n+               (if Mem (S2, E) then Mem (Result, E))));\n+\n+   --------------\n+   -- Is_Union --\n+   --------------\n+\n+   function Is_Union (S1, S2, Result : Set) return Boolean is\n+     ((for all E of Result => Mem (S1, E) or Mem (S2, E))\n+      and (for all E of S1 => Mem (Result, E))\n+      and (for all E of S2 => Mem (Result, E)));\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   function Union (S1, S2 : Set) return Set is\n+     (Content => Union (S1.Content, S2.Content));\n+end Ada.Containers.Functional_Sets;"}, {"sha": "cbc03fa8e046e189f95d3ec466737e154e274dd2", "filename": "gcc/ada/a-cofuse.ads", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,195 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      ADA.CONTAINERS.FUNCTIONAL_SETS                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+private with Ada.Containers.Functional_Base;\n+\n+generic\n+   type Element_Type (<>) is private;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+package Ada.Containers.Functional_Sets with SPARK_Mode is\n+\n+   type Set is private with\n+     Default_Initial_Condition => Is_Empty (Set) and Length (Set) = 0,\n+     Iterable                  => (First       => Iter_First,\n+                                   Next        => Iter_Next,\n+                                   Has_Element => Iter_Has_Element,\n+                                   Element     => Iter_Element);\n+   --  Sets are empty when default initialized.\n+   --  For in quantification over sets should not be used.\n+   --  For of quantification over sets iterates over elements.\n+\n+   --  Sets are axiomatized using Mem which encodes whether an element is\n+   --  contained in a set.  The length of a set is also added to protect Add\n+   --  against overflows but it is not actually modeled.\n+\n+   function Mem (S : Set; E : Element_Type) return Boolean with\n+     Global => null;\n+\n+   function Length (S : Set) return Count_Type with\n+     Global => null;\n+\n+   function \"<=\" (S1, S2 : Set) return Boolean with\n+   --  Set inclusion.\n+\n+     Global => null,\n+     Post   => \"<=\"'Result = (for all E of S1 => Mem (S2, E));\n+\n+   function \"=\" (S1, S2 : Set) return Boolean with\n+   --  Extensional equality over sets.\n+\n+     Global => null,\n+     Post   =>\n+       \"=\"'Result = ((for all E of S1 => Mem (S2, E))\n+                     and (for all E of S2 => Mem (S1, E)));\n+\n+   pragma Warnings (Off, \"unused variable \"\"E\"\"\");\n+   function Is_Empty (S : Set) return Boolean with\n+   --  A set is empty if it contains no element.\n+\n+     Global => null,\n+     Post   => Is_Empty'Result = (for all E of S => False);\n+   pragma Warnings (On, \"unused variable \"\"E\"\"\");\n+\n+   function Is_Add (S : Set; E : Element_Type; Result : Set) return Boolean\n+   --  Returns True if Result is S augmented with E.\n+\n+   with\n+     Global => null,\n+     Post   => Is_Add'Result =\n+       (Mem (Result, E) and not Mem (S, E)\n+        and (for all F of Result => Mem (S, F) or F = E)\n+        and (for all E of S => Mem (Result, E)));\n+\n+   function Add (S : Set; E : Element_Type) return Set with\n+   --  Returns S augmented with E.\n+   --  Is_Add (S, E, Result) should be used instead of Result = Add (S, E)\n+   --  whenever possible both for execution and for proof.\n+\n+     Global => null,\n+     Pre    => not Mem (S, E) and Length (S) < Count_Type'Last,\n+     Post   => Length (Add'Result) = Length (S) + 1\n+     and Is_Add (S, E, Add'Result);\n+\n+   function Is_Intersection (S1, S2, Result : Set) return Boolean with\n+   --  Returns True if Result is the intersection of S1 and S2.\n+\n+     Global => null,\n+     Post   => Is_Intersection'Result =\n+       ((for all E of Result =>\n+               Mem (S1, E) and Mem (S2, E))\n+        and (for all E of S1 =>\n+               (if Mem (S2, E) then Mem (Result, E))));\n+\n+   function Num_Overlaps (S1, S2 : Set) return Count_Type with\n+   --  Number of elements that are both in S1 and S2.\n+\n+     Global => null,\n+     Post   => Num_Overlaps'Result <= Length (S1)\n+     and Num_Overlaps'Result <= Length (S2)\n+     and (if Num_Overlaps'Result = 0 then\n+            (for all E of S1 => not Mem (S2, E)));\n+\n+   function Intersection (S1, S2 : Set) return Set with\n+   --  Returns the intersection of S1 and S2.\n+   --  Intersection (S1, S2, Result) should be used instead of\n+   --  Result = Intersection (S1, S2) whenever possible both for execution and\n+   --  for proof.\n+\n+     Global => null,\n+     Post   => Length (Intersection'Result) = Num_Overlaps (S1, S2)\n+     and Is_Intersection (S1, S2, Intersection'Result);\n+\n+   function Is_Union (S1, S2, Result : Set) return Boolean with\n+   --  Returns True if Result is the union of S1 and S2.\n+\n+     Global => null,\n+     Post   => Is_Union'Result =\n+       ((for all E of Result => Mem (S1, E) or Mem (S2, E))\n+        and (for all E of S1 => Mem (Result, E))\n+        and (for all E of S2 => Mem (Result, E)));\n+\n+   function Union (S1, S2 : Set) return Set with\n+   --  Returns the union of S1 and S2.\n+   --  Is_Union (S1, S2, Result) should be used instead of\n+   --  Result = Union (S1, S2) whenever possible both for execution and for\n+   --  proof.\n+\n+     Global => null,\n+     Pre    => Length (S1) - Num_Overlaps (S1, S2) <=\n+     Count_Type'Last - Length (S2),\n+     Post   => Length (Union'Result) = Length (S1) - Num_Overlaps (S1, S2)\n+     + Length (S2)\n+     and Is_Union (S1, S2, Union'Result);\n+\n+   ---------------------------\n+   --  Iteration Primitives --\n+   ---------------------------\n+\n+   type Private_Key is private;\n+\n+   function Iter_First (S : Set) return Private_Key with\n+     Global => null;\n+   function Iter_Has_Element (S : Set; K : Private_Key) return Boolean with\n+     Global => null;\n+   function Iter_Next (S : Set; K : Private_Key) return Private_Key with\n+     Global => null,\n+     Pre    => Iter_Has_Element (S, K);\n+   function Iter_Element (S : Set; K : Private_Key) return Element_Type with\n+     Global => null,\n+     Pre    => Iter_Has_Element (S, K);\n+   pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Mem);\n+private\n+   pragma SPARK_Mode (Off);\n+\n+   subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+   package Containers is new Ada.Containers.Functional_Base\n+     (Element_Type        => Element_Type,\n+      Index_Type          => Positive_Count_Type);\n+\n+   type Set is record\n+      Content : Containers.Container;\n+   end record;\n+\n+   type Private_Key is new Count_Type;\n+\n+   function Iter_First (S : Set) return Private_Key is (1);\n+\n+   function Iter_Has_Element (S : Set; K : Private_Key) return Boolean is\n+     (Count_Type (K) in 1 .. Containers.Length (S.Content));\n+\n+   function Iter_Next (S : Set; K : Private_Key) return Private_Key is\n+     (if K = Private_Key'Last then 0 else K + 1);\n+\n+   function Iter_Element (S : Set; K : Private_Key) return Element_Type is\n+     (Containers.Get (S.Content, Count_Type (K)));\n+end Ada.Containers.Functional_Sets;"}, {"sha": "6f4f2b131b630c82b12f53c9ea1a954fbf35e5b9", "filename": "gcc/ada/a-cofuve.adb", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,133 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.FUNCTIONAL_VECTORS                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n+   use Containers;\n+\n+   pragma Assertion_Policy\n+      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (S1, S2 : Sequence) return Boolean is\n+     (S1.Content = S2.Content);\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (S1, S2 : Sequence) return Boolean is\n+     (Length (S1.Content) < Length (S2.Content)\n+      and then (for all I in Index_Type'First .. Last (S1) =>\n+                   Get (S1.Content, I) = Get (S2.Content, I)));\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (S1, S2 : Sequence) return Boolean is\n+     (Length (S1.Content) <= Length (S2.Content)\n+      and then (for all I in Index_Type'First .. Last (S1) =>\n+                   Get (S1.Content, I) = Get (S2.Content, I)));\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   function Add (S : Sequence; E : Element_Type) return Sequence is\n+     (Content => Add (S.Content, E));\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get (S : Sequence; N : Extended_Index) return Element_Type is\n+     (Get (S.Content, N));\n+\n+   ------------\n+   -- Is_Add --\n+   ------------\n+\n+   function Is_Add\n+     (S : Sequence; E : Element_Type; Result : Sequence) return Boolean is\n+     (Length (Result) = Length (S) + 1\n+      and then Get (Result, Index_Type'Val\n+                    ((Index_Type'Pos (Index_Type'First) - 1) +\n+                       Length (Result))) = E\n+      and then\n+        (for all M in Index_Type'First ..\n+             (Index_Type'Val\n+                  ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))) =>\n+              Get (Result, M) = Get (S, M)));\n+\n+   ------------\n+   -- Is_Set --\n+   ------------\n+\n+   function Is_Set\n+     (S : Sequence; N : Index_Type; E : Element_Type; Result : Sequence)\n+      return Boolean is\n+     (N in Index_Type'First ..\n+             (Index_Type'Val\n+                  ((Index_Type'Pos (Index_Type'First) - 1) + Length (S)))\n+      and then Length (Result) = Length (S)\n+      and then Get (Result, N) = E\n+      and then\n+        (for all M in  Index_Type'First ..\n+             (Index_Type'Val\n+                  ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))) =>\n+             (if M /= N then Get (Result, M) = Get (S, M))));\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (S : Sequence) return Extended_Index is\n+     (Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1) + Length (S)));\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (S : Sequence) return Count_Type is\n+     (Length (S.Content));\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   function Set (S : Sequence; N : Index_Type; E : Element_Type)\n+                 return Sequence is\n+     (Content => Set (S.Content, N, E));\n+end Ada.Containers.Functional_Vectors;"}, {"sha": "9d990a9afc32541f97d4cffd843464b81fb0e402", "filename": "gcc/ada/a-cofuve.ads", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.ads?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -0,0 +1,198 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.FUNCTIONAL_VECTORS                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2016-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+private with Ada.Containers.Functional_Base;\n+\n+generic\n+   type Index_Type is (<>);\n+   --  To avoid Constraint_Error being raised at runtime, Index_Type'Base\n+   --  should have at least one more element at the left than Index_Type.\n+\n+   type Element_Type (<>) is private;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+package Ada.Containers.Functional_Vectors with SPARK_Mode is\n+\n+   subtype Extended_Index is Index_Type'Base range\n+     Index_Type'Pred (Index_Type'First) .. Index_Type'Last;\n+   --  Index_Type with one more element to the left.\n+   --  This type is never used but it forces GNATprove to check that there is\n+   --  room for one more element at the left of Index_Type.\n+\n+   type Sequence is private\n+     with Default_Initial_Condition => Length (Sequence) = 0,\n+     Iterable => (First       => Iter_First,\n+                  Has_Element => Iter_Has_Element,\n+                  Next        => Iter_Next,\n+                  Element     => Get);\n+   --  Sequences are empty when default initialized.\n+   --  Quantification over sequences can be done using the regular\n+   --  quantification over its range or directky on its elements using for of.\n+\n+   --  Sequences are axiomatized using Length and Get providing respectively\n+   --  the length of a sequence and an accessor to its Nth element:\n+\n+   function Length (S : Sequence) return Count_Type with\n+     Global => null,\n+     Post => (Index_Type'Pos (Index_Type'First) - 1) + Length'Result <=\n+       Index_Type'Pos (Index_Type'Last);\n+\n+   function Last (S : Sequence) return Extended_Index with\n+     Global => null,\n+     Post => Last'Result =\n+       Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1) + Length (S));\n+\n+   function First return Extended_Index is (Index_Type'First);\n+\n+   function Get (S : Sequence; N : Extended_Index) return Element_Type\n+   --  Get ranges over Extended_Index so that it can be used for iteration.\n+\n+   with\n+     Global => null,\n+     Pre    => N in Index_Type'First .. Last (S);\n+\n+   function \"=\" (S1, S2 : Sequence) return Boolean with\n+   --  Extensional equality over sequences.\n+\n+     Global => null,\n+     Post   => \"=\"'Result =\n+       (Length (S1) = Length (S2)\n+        and then (for all N in Index_Type'First .. Last (S1) =>\n+            Get (S1, N) = Get (S2, N)));\n+\n+   function \"<\" (S1, S2 : Sequence) return Boolean with\n+   --  S1 is a strict subsequence of S2\n+\n+     Global => null,\n+     Post   => \"<\"'Result =\n+     (Length (S1) < Length (S2)\n+      and then (for all N in Index_Type'First .. Last (S1) =>\n+          Get (S1, N) = Get (S2, N)));\n+\n+   function \"<=\" (S1, S2 : Sequence) return Boolean with\n+   --  S1 is a subsequence of S2\n+\n+     Global => null,\n+     Post   => \"<=\"'Result =\n+     (Length (S1) <= Length (S2)\n+      and then (for all N in Index_Type'First .. Last (S1) =>\n+          Get (S1, N) = Get (S2, N)));\n+\n+   function Is_Set\n+     (S : Sequence; N : Index_Type; E : Element_Type; Result : Sequence)\n+      return Boolean\n+   --  Returns True if Result is S where the Nth element has been replaced by\n+   --  E.\n+\n+   with\n+     Global => null,\n+       Post   => Is_Set'Result =\n+         (N in Index_Type'First .. Last (S)\n+          and then Length (Result) = Length (S)\n+          and then Get (Result, N) = E\n+          and then (for all M in Index_Type'First .. Last (S) =>\n+              (if M /= N then Get (Result, M) = Get (S, M))));\n+\n+   function Set\n+     (S : Sequence; N : Index_Type; E : Element_Type) return Sequence\n+   --  Returns S where the Nth element has been replaced by E.\n+   --  Is_Set (S, N, E, Result) should be instead of than\n+   --  Result = Set (S, N, E) whenever possible both for execution and for\n+   --  proof.\n+\n+   with\n+     Global => null,\n+     Pre    => N in Index_Type'First .. Last (S),\n+     Post   => Is_Set (S, N, E, Set'Result);\n+\n+   function Is_Add\n+     (S : Sequence; E : Element_Type; Result : Sequence) return Boolean\n+   --  Returns True if Result is S appended with E.\n+\n+   with\n+     Global => null,\n+     Post   => Is_Add'Result =\n+         (Length (Result) = Length (S) + 1\n+          and then Get (Result, Last (Result)) = E\n+          and then (for all M in Index_Type'First .. Last (S) =>\n+              Get (Result, M) = Get (S, M)));\n+\n+   function Add (S : Sequence; E : Element_Type) return Sequence with\n+   --  Returns S appended with E.\n+   --  Is_Add (S, E, Result) should be used instead of Result = Add (S, E)\n+   --  whenever possible both for execution and for proof.\n+\n+     Global => null,\n+     Pre    => Length (S) < Count_Type'Last and Last (S) < Index_Type'Last,\n+     Post   => Is_Add (S, E, Add'Result);\n+\n+   ---------------------------\n+   --  Iteration Primitives --\n+   ---------------------------\n+\n+   function Iter_First (S : Sequence) return Extended_Index with\n+     Global => null;\n+   function Iter_Has_Element (S : Sequence; I : Extended_Index) return Boolean\n+   with\n+     Global => null,\n+     Post   => Iter_Has_Element'Result = (I in Index_Type'First .. Last (S));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Iter_Has_Element);\n+\n+   function Iter_Next (S : Sequence; I : Extended_Index) return Extended_Index\n+   with\n+     Global => null,\n+     Pre    => Iter_Has_Element (S, I);\n+\n+private\n+   pragma SPARK_Mode (Off);\n+\n+   package Containers is new Ada.Containers.Functional_Base\n+     (Index_Type   => Index_Type,\n+      Element_Type => Element_Type);\n+\n+   type Sequence is record\n+      Content : Containers.Container;\n+   end record;\n+\n+   function Iter_First (S :\n+                        Sequence) return Extended_Index\n+   is (Index_Type'First);\n+   function Iter_Next (S : Sequence; I : Extended_Index) return Extended_Index\n+   is\n+     (if I = Extended_Index'Last then Extended_Index'First\n+      else Extended_Index'Succ (I));\n+\n+   function Iter_Has_Element (S : Sequence; I : Extended_Index) return Boolean\n+   is\n+     (I in Index_Type'First ..\n+        (Index_Type'Val\n+             ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))));\n+end Ada.Containers.Functional_Vectors;"}, {"sha": "2833fff87a1c6fc7e5c122d06d44b5b6d6ee89b4", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -6697,20 +6697,9 @@ package body Checks is\n          Set_Etype (N, Target_Base_Type);\n       end Convert_And_Check_Range;\n \n-      --  Local variables\n-\n-      Checks_On : constant Boolean :=\n-                    not Index_Checks_Suppressed (Target_Type)\n-                      or else\n-                    not Range_Checks_Suppressed (Target_Type);\n-\n    --  Start of processing for Generate_Range_Check\n \n    begin\n-      if not Expander_Active or not Checks_On then\n-         return;\n-      end if;\n-\n       --  First special case, if the source type is already within the range\n       --  of the target type, then no check is needed (probably we should have\n       --  stopped Do_Range_Check from being set in the first place, but better"}, {"sha": "5989530c9ffd09e79bb2c78b465fb0cdc7e3ec09", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -1194,6 +1194,7 @@ package body CStand is\n       Set_Etype             (Any_Access, Any_Access);\n       Init_Size             (Any_Access, System_Address_Size);\n       Set_Elem_Alignment    (Any_Access);\n+      Set_Directly_Designated_Type (Any_Access, Any_Type);\n \n       Any_Character := New_Standard_Entity (\"a character type\");\n       Set_Ekind             (Any_Character, E_Enumeration_Type);"}, {"sha": "c53391a17bd43651655a55f5f951da41b1576918", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2000-2016, Free Software Foundation, Inc.        --\n+--           Copyright (C) 2000-2017, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -590,6 +590,9 @@ package body Impunit is\n     (\"a-cfinve\", F),  -- Ada.Containers.Formal_Indefinite_Vectors\n     (\"a-coboho\", F),  -- Ada.Containers.Bounded_Holders\n     (\"a-cofove\", F),  -- Ada.Containers.Formal_Vectors\n+    (\"a-cofuma\", F),  -- Ada.Containers.Functional_Maps\n+    (\"a-cofuse\", F),  -- Ada.Containers.Functional_Sets\n+    (\"a-cofuve\", F),  -- Ada.Containers.Functional_Vectors\n     (\"a-cfdlli\", F),  -- Ada.Containers.Formal_Doubly_Linked_Lists\n     (\"a-cforse\", F),  -- Ada.Containers.Formal_Ordered_Sets\n     (\"a-cforma\", F),  -- Ada.Containers.Formal_Ordered_Maps"}, {"sha": "bcb1b6cfcad94280e1a92e3e3f41652a64bdbd0b", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -848,21 +848,31 @@ package body Lib.Xref is\n          if Has_Unreferenced (E)\n            and then In_Same_Extended_Unit (E, N)\n          then\n-            --  A reference as a named parameter in a call does not count\n-            --  as a violation of pragma Unreferenced for this purpose...\n+            --  A reference as a named parameter in a call does not count as a\n+            --  violation of pragma Unreferenced for this purpose...\n \n             if Nkind (N) = N_Identifier\n               and then Nkind (Parent (N)) = N_Parameter_Association\n               and then Selector_Name (Parent (N)) = N\n             then\n                null;\n \n-            --  ... Neither does a reference to a variable on the left side\n-            --  of an assignment.\n+            --  ... Neither does a reference to a variable on the left side of\n+            --  an assignment.\n \n             elsif Is_On_LHS (N) then\n                null;\n \n+            --  Do not consider F'Result as a violation of pragma Unreferenced\n+            --  since the attribute acts as an anonymous alias of the function\n+            --  result and not as a real reference to the function.\n+\n+            elsif Ekind_In (E, E_Function, E_Generic_Function)\n+              and then Is_Entity_Name (N)\n+              and then Is_Attribute_Result (Parent (N))\n+            then\n+               null;\n+\n             --  No warning if the reference is in a call that does not come\n             --  from source (e.g. a call to a controlled type primitive).\n "}, {"sha": "790b6f6bcb970c15a2a970c88b6f90b6ce0cdc42", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -6220,7 +6220,7 @@ package body Sem_Attr is\n          --  single dereference link in a composite type.\n \n          procedure Compute_Type_Key (T : Entity_Id);\n-         --  Create a CRC integer from the declaration of the type, For a\n+         --  Create a CRC integer from the declaration of the type. For a\n          --  composite type, fold in the representation of its components in\n          --  recursive fashion. We use directly the source representation of\n          --  the types involved.\n@@ -6245,19 +6245,13 @@ package body Sem_Attr is\n             -----------------------------\n \n             procedure Process_One_Declaration is\n-               Ptr : Source_Ptr;\n-\n             begin\n-               Ptr := P_Min;\n-\n                --  Scan type declaration, skipping blanks\n \n-               while Ptr <= P_Max loop\n+               for Ptr in P_Min .. P_Max loop\n                   if Buffer (Ptr) /= ' ' then\n                      System.CRC32.Update (CRC, Buffer (Ptr));\n                   end if;\n-\n-                  Ptr := Ptr + 1;\n                end loop;\n             end Process_One_Declaration;\n \n@@ -6284,7 +6278,8 @@ package body Sem_Attr is\n             end if;\n \n             Sloc_Range (Enclosing_Declaration (T), P_Min, P_Max);\n-            SFI    := Get_Source_File_Index (P_Min);\n+            SFI := Get_Source_File_Index (P_Min);\n+            pragma Assert (SFI = Get_Source_File_Index (P_Max));\n             Buffer := Source_Text (SFI);\n \n             Process_One_Declaration;\n@@ -6301,7 +6296,7 @@ package body Sem_Attr is\n                end if;\n \n             elsif Is_Derived_Type (T) then\n-               Compute_Type_Key (Etype  (T));\n+               Compute_Type_Key (Etype (T));\n \n             elsif Is_Record_Type (T) then\n                declare\n@@ -6323,6 +6318,8 @@ package body Sem_Attr is\n             while Present (Rep) loop\n                if Comes_From_Source (Rep) then\n                   Sloc_Range (Rep, P_Min, P_Max);\n+                  pragma Assert (SFI = Get_Source_File_Index (P_Min));\n+                  pragma Assert (SFI = Get_Source_File_Index (P_Max));\n                   Process_One_Declaration;\n                end if;\n "}, {"sha": "1e5199dc403e2e8ce1e73addd0ddf0a7f860f21f", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -802,8 +802,8 @@ package body Sem_Type is\n    --  Start of processing for Covers\n \n    begin\n-      --  If either operand missing, then this is an error, but ignore it (and\n-      --  pretend we have a cover) if errors already detected, since this may\n+      --  If either operand is missing, then this is an error, but ignore it\n+      --  and pretend we have a cover if errors already detected since this may\n       --  simply mean we have malformed trees or a semantic error upstream.\n \n       if No (T1) or else No (T2) then"}, {"sha": "de8dcedf5badb60ce364677fc2599e0d08d88c0f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11775988d5f6db984fb902b7447a5b2817b555b1/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=11775988d5f6db984fb902b7447a5b2817b555b1", "patch": "@@ -3229,7 +3229,7 @@ package body Sem_Util is\n          Result_Seen : in out Boolean)\n       is\n          procedure Check_Conjunct (Expr : Node_Id);\n-         --  Check an individual conjunct in a conjunctions of Boolean\n+         --  Check an individual conjunct in a conjunction of Boolean\n          --  expressions, connected by \"and\" or \"and then\" operators.\n \n          procedure Check_Conjuncts (Expr : Node_Id);\n@@ -3286,12 +3286,12 @@ package body Sem_Util is\n \n             function Applied_On_Conjunct return Boolean is\n             begin\n-               --  Expr is the conjunct of an \"and\" enclosing expression\n+               --  Expr is the conjunct of an enclosing \"and\" expression\n \n                return Nkind (Parent (Expr)) in N_Subexpr\n \n-                 --  or Expr is a conjunct of an \"and then\" enclosing\n-                 --  expression in a postcondition aspect, which was split in\n+                 --  or Expr is a conjunct of an enclosing \"and then\"\n+                 --  expression in a postcondition aspect that was split into\n                  --  multiple pragmas. The first conjunct has the \"and then\"\n                  --  expression as Original_Node, and other conjuncts have\n                  --  Split_PCC set to True."}]}