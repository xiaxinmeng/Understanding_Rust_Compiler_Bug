{"sha": "6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyMDI4ZmYwZjI0NTYxMTI1ZDQ2NWIzYzhkNmFjYzg4ZDRkODJkYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-08-15T07:50:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-08-15T07:50:40Z"}, "message": "re PR tree-optimization/62031 (Different results between O2 and O2 -fpredictive-commoning)\n\n2014-08-15  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/62031\n\t* tree-data-ref.c (dr_analyze_indices): Do not set\n\tDR_UNCONSTRAINED_BASE.\n\t(dr_may_alias_p): All indirect accesses have to go the\n\tformerly DR_UNCONSTRAINED_BASE path.\n\t* tree-data-ref.h (struct indices): Remove\n\tunconstrained_base member.\n\t(DR_UNCONSTRAINED_BASE): Remove.\n\n\t* gcc.dg/torture/pr62031.c: New testcase.\n\nFrom-SVN: r214006", "tree": {"sha": "d715e9fb4a2949aee3ce02f70c58ffb10d618df5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d715e9fb4a2949aee3ce02f70c58ffb10d618df5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94351473749ce2618a1f2193380c0d690f9d6bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94351473749ce2618a1f2193380c0d690f9d6bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94351473749ce2618a1f2193380c0d690f9d6bb8"}], "stats": {"total": 110, "additions": 95, "deletions": 15}, "files": [{"sha": "06b57ff6c0c73c3fbaa7cfb7b2f99905b41af90b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "patch": "@@ -1,3 +1,14 @@\n+2014-08-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/62031\n+\t* tree-data-ref.c (dr_analyze_indices): Do not set\n+\tDR_UNCONSTRAINED_BASE.\n+\t(dr_may_alias_p): All indirect accesses have to go the\n+\tformerly DR_UNCONSTRAINED_BASE path.\n+\t* tree-data-ref.h (struct indices): Remove\n+\tunconstrained_base member.\n+\t(DR_UNCONSTRAINED_BASE): Remove.\n+\n 2014-08-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/62092"}, {"sha": "ab8e0544302e258919073e37041d83403d8e6e99", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "patch": "@@ -1,3 +1,8 @@\n+2014-08-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/62031\n+\t* gcc.dg/torture/pr62031.c: New testcase.\n+\n 2014-08-15  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.dg/tree-ssa/ivopts-lt-2.c: New test."}, {"sha": "f0dcef44b1da93322eb971f071327f8c062032d9", "filename": "gcc/testsuite/gcc.dg/torture/pr62031.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr62031.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr62031.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr62031.c?ref=6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define NUM_OF_STATES 4\n+typedef unsigned int entry_t[2];\n+typedef struct entries_item { entry_t metricEntries_[0]; } entries_item_t;\n+\n+void __attribute__((noinline,noclone))\n+test_00(size_t numOfStates, entries_item_t* p_bm,\n+\tconst unsigned int* polyArray,\n+\tsize_t polyArraySize)\n+{\n+  size_t idx;\n+  unsigned int hlp0, hlp1;\n+  for (idx = 0; idx < numOfStates; ++idx)\n+    {\n+      size_t idy;\n+\n+      hlp0 = (idx << 1) | 0x00;\n+      hlp1 = (idx << 1) | 0x01;\n+      p_bm->metricEntries_[idx][0] = 0;\n+      p_bm->metricEntries_[idx][1] = 0;\n+      for (idy = 0; idy < polyArraySize; ++idy)\n+\t{\n+\t  p_bm->metricEntries_[idx][0]\n+\t      |= __builtin_parity(hlp0 & polyArray[idy]) << idy;\n+\t  p_bm->metricEntries_[idx][1]\n+\t      |= __builtin_parity(hlp1 & polyArray[idy]) << idy;\n+\t}\n+    }\n+}\n+\n+int main()\n+{\n+  unsigned int polyArray[] = { 0x07, 0x05 };\n+  entries_item_t* pBranchMetrics;\n+  pBranchMetrics = malloc(sizeof(entry_t) * NUM_OF_STATES);\n+  test_00(NUM_OF_STATES, pBranchMetrics, polyArray,\n+\t  sizeof(polyArray) / sizeof(polyArray[0]));\n+  if (pBranchMetrics->metricEntries_[0][0] != 0\n+      || pBranchMetrics->metricEntries_[0][1] != 3\n+      || pBranchMetrics->metricEntries_[1][0] != 1\n+      || pBranchMetrics->metricEntries_[1][1] != 2\n+      || pBranchMetrics->metricEntries_[2][0] != 3\n+      || pBranchMetrics->metricEntries_[2][1] != 0\n+      || pBranchMetrics->metricEntries_[3][0] != 2\n+      || pBranchMetrics->metricEntries_[3][1] != 1)\n+    abort ();\n+  free(pBranchMetrics);\n+  return 0;\n+}"}, {"sha": "1d3efa67813fe00e82df07fc698a39c754f4c399", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "patch": "@@ -982,7 +982,6 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n \t  ref = fold_build2_loc (EXPR_LOCATION (ref),\n \t\t\t\t MEM_REF, TREE_TYPE (ref),\n \t\t\t\t base, memoff);\n-\t  DR_UNCONSTRAINED_BASE (dr) = true;\n \t  access_fns.safe_push (access_fn);\n \t}\n     }\n@@ -1389,24 +1388,42 @@ dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,\n \treturn false;\n     }\n \n-  /* If we had an evolution in a MEM_REF BASE_OBJECT we do not know\n-     the size of the base-object.  So we cannot do any offset/overlap\n-     based analysis but have to rely on points-to information only.  */\n+  /* If we had an evolution in a pointer-based MEM_REF BASE_OBJECT we\n+     do not know the size of the base-object.  So we cannot do any\n+     offset/overlap based analysis but have to rely on points-to\n+     information only.  */\n   if (TREE_CODE (addr_a) == MEM_REF\n-      && DR_UNCONSTRAINED_BASE (a))\n+      && TREE_CODE (TREE_OPERAND (addr_a, 0)) == SSA_NAME)\n     {\n-      if (TREE_CODE (addr_b) == MEM_REF\n-\t  && DR_UNCONSTRAINED_BASE (b))\n+      /* For true dependences we can apply TBAA.  */\n+      if (flag_strict_aliasing\n+\t  && DR_IS_WRITE (a) && DR_IS_READ (b)\n+\t  && !alias_sets_conflict_p (get_alias_set (DR_REF (a)),\n+\t\t\t\t     get_alias_set (DR_REF (b))))\n+\treturn false;\n+      if (TREE_CODE (addr_b) == MEM_REF)\n \treturn ptr_derefs_may_alias_p (TREE_OPERAND (addr_a, 0),\n \t\t\t\t       TREE_OPERAND (addr_b, 0));\n       else\n \treturn ptr_derefs_may_alias_p (TREE_OPERAND (addr_a, 0),\n \t\t\t\t       build_fold_addr_expr (addr_b));\n     }\n   else if (TREE_CODE (addr_b) == MEM_REF\n-\t   && DR_UNCONSTRAINED_BASE (b))\n-    return ptr_derefs_may_alias_p (build_fold_addr_expr (addr_a),\n-\t\t\t\t   TREE_OPERAND (addr_b, 0));\n+\t   && TREE_CODE (TREE_OPERAND (addr_b, 0)) == SSA_NAME)\n+    {\n+      /* For true dependences we can apply TBAA.  */\n+      if (flag_strict_aliasing\n+\t  && DR_IS_WRITE (a) && DR_IS_READ (b)\n+\t  && !alias_sets_conflict_p (get_alias_set (DR_REF (a)),\n+\t\t\t\t     get_alias_set (DR_REF (b))))\n+\treturn false;\n+      if (TREE_CODE (addr_a) == MEM_REF)\n+\treturn ptr_derefs_may_alias_p (TREE_OPERAND (addr_a, 0),\n+\t\t\t\t       TREE_OPERAND (addr_b, 0));\n+      else\n+\treturn ptr_derefs_may_alias_p (build_fold_addr_expr (addr_a),\n+\t\t\t\t       TREE_OPERAND (addr_b, 0));\n+    }\n \n   /* Otherwise DR_BASE_OBJECT is an access that covers the whole object\n      that is being subsetted in the loop nest.  */"}, {"sha": "a96c5ff4c476ead12b87e8dd7ac86b58ac339cad", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2028ff0f24561125d465b3c8d6acc88d4d82dc/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=6e2028ff0f24561125d465b3c8d6acc88d4d82dc", "patch": "@@ -81,10 +81,6 @@ struct indices\n \n   /* A list of chrecs.  Access functions of the indices.  */\n   vec<tree> access_fns;\n-\n-  /* Whether BASE_OBJECT is an access representing the whole object\n-     or whether the access could not be constrained.  */\n-  bool unconstrained_base;\n };\n \n struct dr_alias\n@@ -195,7 +191,6 @@ struct data_reference\n #define DR_STMT(DR)                (DR)->stmt\n #define DR_REF(DR)                 (DR)->ref\n #define DR_BASE_OBJECT(DR)         (DR)->indices.base_object\n-#define DR_UNCONSTRAINED_BASE(DR)  (DR)->indices.unconstrained_base\n #define DR_ACCESS_FNS(DR)\t   (DR)->indices.access_fns\n #define DR_ACCESS_FN(DR, I)        DR_ACCESS_FNS (DR)[I]\n #define DR_NUM_DIMENSIONS(DR)      DR_ACCESS_FNS (DR).length ()"}]}