{"sha": "0b50e6540fe69191c78689d0ff5d0a1e18130391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1MGU2NTQwZmU2OTE5MWM3ODY4OWQwZmY1ZDBhMWUxODEzMDM5MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-03-05T15:51:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-03-05T15:51:48Z"}, "message": "re PR middle-end/56461 (GCC is leaking lots of memory)\n\n\tPR middle-end/56461\n\t* ggc-common.c (gt_pch_save): For ENABLE_VALGRIND_CHECKING,\n\tif VALGRIND_GET_VBITS is defined, temporarily make object\n\tmemory all defined, and restore previous valgrind addressability\n\tand definability afterwards.  Free this_object at the end.\n\n\t* c-pch.c (pch_init): Free target_validity at the end.\n\nFrom-SVN: r196469", "tree": {"sha": "621a132b81c013b0cba91140e85a6ab093c5ecd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/621a132b81c013b0cba91140e85a6ab093c5ecd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b50e6540fe69191c78689d0ff5d0a1e18130391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b50e6540fe69191c78689d0ff5d0a1e18130391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b50e6540fe69191c78689d0ff5d0a1e18130391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b50e6540fe69191c78689d0ff5d0a1e18130391/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ccf8f43ce30db2991656165ddd8839598751075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ccf8f43ce30db2991656165ddd8839598751075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ccf8f43ce30db2991656165ddd8839598751075"}], "stats": {"total": 81, "additions": 80, "deletions": 1}, "files": [{"sha": "4c0744f12d425aec7eb84e8258e8ff26314366ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b50e6540fe69191c78689d0ff5d0a1e18130391", "patch": "@@ -1,5 +1,11 @@\n 2013-03-05  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/56461\n+\t* ggc-common.c (gt_pch_save): For ENABLE_VALGRIND_CHECKING,\n+\tif VALGRIND_GET_VBITS is defined, temporarily make object\n+\tmemory all defined, and restore previous valgrind addressability\n+\tand definability afterwards.  Free this_object at the end.\n+\n \tPR middle-end/56461\n \t* lra.c (lra): Call lra_clear_live_ranges if live_p,\n \tright before calling lra_create_live_ranges, also call it"}, {"sha": "6d90bfb37d27ac475ae1627604372bb7afef3873", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0b50e6540fe69191c78689d0ff5d0a1e18130391", "patch": "@@ -1,3 +1,8 @@\n+2013-03-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/56461\n+\t* c-pch.c (pch_init): Free target_validity at the end.\n+\n 2013-03-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-pretty-print.c (pp_c_pretty_printer_init): Clear pp->flags."}, {"sha": "7b0eca7fde1222e2a73e30518f782a4c2e7debd5", "filename": "gcc/c-family/c-pch.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2Fc-family%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2Fc-family%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pch.c?ref=0b50e6540fe69191c78689d0ff5d0a1e18130391", "patch": "@@ -141,6 +141,8 @@ pch_init (void)\n \n   if (pch_ready_to_save_cpp_state)\n     pch_cpp_save_state ();\n+\n+  XDELETE (target_validity);\n }\n \n /* Whether preprocessor state has been saved in a PCH file.  */"}, {"sha": "91c8249f3aebc34d8660bc5cf37ff62683779a62", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b50e6540fe69191c78689d0ff5d0a1e18130391/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=0b50e6540fe69191c78689d0ff5d0a1e18130391", "patch": "@@ -561,6 +561,10 @@ gt_pch_save (FILE *f)\n \n   ggc_pch_prepare_write (state.d, state.f);\n \n+#if defined ENABLE_VALGRIND_CHECKING && defined VALGRIND_GET_VBITS\n+  vec<char> vbits = vNULL;\n+#endif\n+\n   /* Actually write out the objects.  */\n   for (i = 0; i < state.count; i++)\n     {\n@@ -569,6 +573,50 @@ gt_pch_save (FILE *f)\n \t  this_object_size = state.ptrs[i]->size;\n \t  this_object = XRESIZEVAR (char, this_object, this_object_size);\n \t}\n+#if defined ENABLE_VALGRIND_CHECKING && defined VALGRIND_GET_VBITS\n+      /* obj might contain uninitialized bytes, e.g. in the trailing\n+\t padding of the object.  Avoid warnings by making the memory\n+\t temporarily defined and then restoring previous state.  */\n+      int get_vbits = 0;\n+      size_t valid_size = state.ptrs[i]->size;\n+      if (__builtin_expect (RUNNING_ON_VALGRIND, 0))\n+\t{\n+\t  if (vbits.length () < valid_size)\n+\t    vbits.safe_grow (valid_size);\n+\t  get_vbits = VALGRIND_GET_VBITS (state.ptrs[i]->obj,\n+\t\t\t\t\t  vbits.address (), valid_size);\n+\t  if (get_vbits == 3)\n+\t    {\n+\t      /* We assume that first part of obj is addressable, and\n+\t\t the rest is unaddressable.  Find out where the boundary is\n+\t\t using binary search.  */\n+\t      size_t lo = 0, hi = valid_size;\n+\t      while (hi > lo)\n+\t\t{\n+\t\t  size_t mid = (lo + hi) / 2;\n+\t\t  get_vbits = VALGRIND_GET_VBITS ((char *) state.ptrs[i]->obj\n+\t\t\t\t\t\t  + mid, vbits.address (),\n+\t\t\t\t\t\t  1);\n+\t\t  if (get_vbits == 3)\n+\t\t    hi = mid;\n+\t\t  else if (get_vbits == 1)\n+\t\t    lo = mid + 1;\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      if (get_vbits == 1 || get_vbits == 3)\n+\t\t{\n+\t\t  valid_size = lo;\n+\t\t  get_vbits = VALGRIND_GET_VBITS (state.ptrs[i]->obj,\n+\t\t\t\t\t\t  vbits.address (),\n+\t\t\t\t\t\t  valid_size);\n+\t\t}\n+\t    }\n+\t  if (get_vbits == 1)\n+\t    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (state.ptrs[i]->obj,\n+\t\t\t\t\t\t\t state.ptrs[i]->size));\n+\t}\n+#endif\n       memcpy (this_object, state.ptrs[i]->obj, state.ptrs[i]->size);\n       if (state.ptrs[i]->reorder_fn != NULL)\n \tstate.ptrs[i]->reorder_fn (state.ptrs[i]->obj,\n@@ -582,11 +630,29 @@ gt_pch_save (FILE *f)\n \t\t\t    state.ptrs[i]->note_ptr_fn == gt_pch_p_S);\n       if (state.ptrs[i]->note_ptr_fn != gt_pch_p_S)\n \tmemcpy (state.ptrs[i]->obj, this_object, state.ptrs[i]->size);\n+#if defined ENABLE_VALGRIND_CHECKING && defined VALGRIND_GET_VBITS\n+      if (__builtin_expect (get_vbits == 1, 0))\n+\t{\n+\t  (void) VALGRIND_SET_VBITS (state.ptrs[i]->obj, vbits.address (),\n+\t\t\t\t     valid_size);\n+\t  if (valid_size != state.ptrs[i]->size)\n+\t    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS ((char *)\n+\t\t\t\t\t\t\t  state.ptrs[i]->obj\n+\t\t\t\t\t\t\t  + valid_size,\n+\t\t\t\t\t\t\t  state.ptrs[i]->size\n+\t\t\t\t\t\t\t  - valid_size));\n+\t}\n+#endif\n     }\n+#if defined ENABLE_VALGRIND_CHECKING && defined VALGRIND_GET_VBITS\n+  vbits.release ();\n+#endif\n+\n   ggc_pch_finish (state.d, state.f);\n   gt_pch_fixup_stringpool ();\n \n-  free (state.ptrs);\n+  XDELETE (state.ptrs);\n+  XDELETE (this_object);\n   htab_delete (saving_htab);\n }\n "}]}