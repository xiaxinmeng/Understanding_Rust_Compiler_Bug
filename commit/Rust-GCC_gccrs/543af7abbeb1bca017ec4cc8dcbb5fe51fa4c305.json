{"sha": "543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzYWY3YWJiZWIxYmNhMDE3ZWM0Y2M4ZGNiYjVmZTUxZmE0YzMwNQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-02-21T22:25:06Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-02-21T22:25:06Z"}, "message": "re PR fortran/38914 ([4.3 only] ICE with array inquiry functions above contains in parameter expression)\n\n2008-02-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/38914\n\t* array.c (ref_dimen_size):  Rename to gfc_ref_dimen_size,\n\tmake global.  Change function name in error messages.\n\t(ref_size):  Change ref_dimen_size to gfc_ref_dimen_size.\n\t(gfc_array_ref_shape):  Likewise.\n\t* gfortran.h:  Add prototype for gfc_ref_dimen_size.\n\t* simplify.c (simplify_bound_dim):  Add ref argument.\n\tIf the reference isn't a full array, return one for\n\tthe lower bound and the extent for the upper bound.\n\t(simplify_bound):  For array sections, take as from the\n\targument.  Add reference to all to simplify_bound_dim.\n\n2008-02-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/38914\n\t* bound_simplification_2.f90:  New test case.\n\t* bound_7.f90:  New test case.\n\nFrom-SVN: r144362", "tree": {"sha": "e156f268a9631504958d59dd37561d3f6ea3612c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e156f268a9631504958d59dd37561d3f6ea3612c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/comments", "author": null, "committer": null, "parents": [{"sha": "4bb09c26bc590129675100ee0a87f9408b8afab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb09c26bc590129675100ee0a87f9408b8afab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bb09c26bc590129675100ee0a87f9408b8afab9"}], "stats": {"total": 325, "additions": 299, "deletions": 26}, "files": [{"sha": "57ad11b3214a2f459d1ed1d2d577417c7def86d2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "patch": "@@ -1,3 +1,17 @@\n+2008-02-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/38914\n+\t* array.c (ref_dimen_size):  Rename to gfc_ref_dimen_size,\n+\tmake global.  Change function name in error messages.\n+\t(ref_size):  Change ref_dimen_size to gfc_ref_dimen_size.\n+\t(gfc_array_ref_shape):  Likewise.\n+\t* gfortran.h:  Add prototype for gfc_ref_dimen_size.\n+\t* simplify.c (simplify_bound_dim):  Add ref argument.\n+\tIf the reference isn't a full array, return one for\n+\tthe lower bound and the extent for the upper bound.\n+\t(simplify_bound):  For array sections, take as from the\n+\targument.  Add reference to all to simplify_bound_dim.\n+\n 2009-02-19  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* scanner.c (load_line): At end of line, skip '\\r' without setting"}, {"sha": "46c7425b9c1d3a90004ff268005e7468eb3a057f", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "patch": "@@ -1876,14 +1876,14 @@ spec_size (gfc_array_spec *as, mpz_t *result)\n \n /* Get the number of elements in an array section.  */\n \n-static gfc_try\n-ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result)\n+gfc_try\n+gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result)\n {\n   mpz_t upper, lower, stride;\n   gfc_try t;\n \n   if (dimen < 0 || ar == NULL || dimen > ar->dimen - 1)\n-    gfc_internal_error (\"ref_dimen_size(): Bad dimension\");\n+    gfc_internal_error (\"gfc_ref_dimen_size(): Bad dimension\");\n \n   switch (ar->dimen_type[dimen])\n     {\n@@ -1957,7 +1957,7 @@ ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result)\n       return t;\n \n     default:\n-      gfc_internal_error (\"ref_dimen_size(): Bad dimen_type\");\n+      gfc_internal_error (\"gfc_ref_dimen_size(): Bad dimen_type\");\n     }\n \n   return t;\n@@ -1974,7 +1974,7 @@ ref_size (gfc_array_ref *ar, mpz_t *result)\n \n   for (d = 0; d < ar->dimen; d++)\n     {\n-      if (ref_dimen_size (ar, d, &size) == FAILURE)\n+      if (gfc_ref_dimen_size (ar, d, &size) == FAILURE)\n \t{\n \t  mpz_clear (*result);\n \t  return FAILURE;\n@@ -2020,7 +2020,7 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n \t\tif (ref->u.ar.dimen_type[i] != DIMEN_ELEMENT)\n \t\t  dimen--;\n \n-\t      return ref_dimen_size (&ref->u.ar, i - 1, result);\n+\t      return gfc_ref_dimen_size (&ref->u.ar, i - 1, result);\n \t    }\n \t}\n \n@@ -2148,7 +2148,7 @@ gfc_array_ref_shape (gfc_array_ref *ar, mpz_t *shape)\n \t{\n \t  if (ar->dimen_type[i] != DIMEN_ELEMENT)\n \t    {\n-\t      if (ref_dimen_size (ar, i, &shape[d]) == FAILURE)\n+\t      if (gfc_ref_dimen_size (ar, i, &shape[d]) == FAILURE)\n \t\tgoto cleanup;\n \t      d++;\n \t    }"}, {"sha": "8795bee3c9103a1e31fa90617dc2f4676e316ffc", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "patch": "@@ -2517,6 +2517,9 @@ gfc_try spec_size (gfc_array_spec *, mpz_t *);\n gfc_try spec_dimen_size (gfc_array_spec *, int, mpz_t *);\n int gfc_is_compile_time_shape (gfc_array_spec *);\n \n+gfc_try gfc_ref_dimen_size (gfc_array_ref *, int dimen, mpz_t *);\n+\n+\n /* interface.c -- FIXME: some of these should be in symbol.c */\n void gfc_free_interface (gfc_interface *);\n int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);"}, {"sha": "6893a88c43319c72780c2a1e8da533ce26559c89", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "patch": "@@ -2178,7 +2178,7 @@ gfc_simplify_kind (gfc_expr *e)\n \n static gfc_expr *\n simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n-\t\t    gfc_array_spec *as)\n+\t\t    gfc_array_spec *as, gfc_ref *ref)\n {\n   gfc_expr *l, *u, *result;\n   int k;\n@@ -2192,35 +2192,50 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n \treturn NULL;\n     }\n \n-  /* Then, we need to know the extent of the given dimension.  */\n-  l = as->lower[d-1];\n-  u = as->upper[d-1];\n-\n-  if (l->expr_type != EXPR_CONSTANT || u->expr_type != EXPR_CONSTANT)\n-    return NULL;\n-\n   k = get_kind (BT_INTEGER, kind, upper ? \"UBOUND\" : \"LBOUND\",\n \t\tgfc_default_integer_kind); \n   if (k == -1)\n     return &gfc_bad_expr;\n \n   result = gfc_constant_result (BT_INTEGER, k, &array->where);\n \n-  if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n+\n+  /* Then, we need to know the extent of the given dimension.  */\n+  if (ref->u.ar.type == AR_FULL)\n     {\n-      /* Zero extent.  */\n-      if (upper)\n-\tmpz_set_si (result->value.integer, 0);\n+      l = as->lower[d-1];\n+      u = as->upper[d-1];\n+\n+      if (l->expr_type != EXPR_CONSTANT || u->expr_type != EXPR_CONSTANT)\n+\treturn NULL;\n+\n+      if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n+\t{\n+\t  /* Zero extent.  */\n+\t  if (upper)\n+\t    mpz_set_si (result->value.integer, 0);\n+\t  else\n+\t    mpz_set_si (result->value.integer, 1);\n+\t}\n       else\n-\tmpz_set_si (result->value.integer, 1);\n+\t{\n+\t  /* Nonzero extent.  */\n+\t  if (upper)\n+\t    mpz_set (result->value.integer, u->value.integer);\n+\t  else\n+\t    mpz_set (result->value.integer, l->value.integer);\n+\t}\n     }\n   else\n     {\n-      /* Nonzero extent.  */\n       if (upper)\n-\tmpz_set (result->value.integer, u->value.integer);\n+\t{\n+\t  if (gfc_ref_dimen_size (&ref->u.ar, d-1, &result->value.integer)\n+\t      != SUCCESS)\n+\t    return NULL;\n+\t}\n       else\n-\tmpz_set (result->value.integer, l->value.integer);\n+\tmpz_set_si (result->value.integer, (long int) 1);\n     }\n \n   return range_check (result, upper ? \"UBOUND\" : \"LBOUND\");\n@@ -2258,9 +2273,12 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \n \t    /* Fall through.  */\n \n-\t    case AR_SECTION:\n \t    case AR_UNKNOWN:\n \t      return NULL;\n+\n+\t    case AR_SECTION:\n+\t      as = ref->u.ar.as;\n+\t      goto done;\n \t    }\n \n \t  gcc_unreachable ();\n@@ -2300,7 +2318,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n       /* Simplify the bounds for each dimension.  */\n       for (d = 0; d < array->rank; d++)\n \t{\n-\t  bounds[d] = simplify_bound_dim (array, kind, d + 1, upper, as);\n+\t  bounds[d] = simplify_bound_dim (array, kind, d + 1, upper, as, ref);\n \t  if (bounds[d] == NULL || bounds[d] == &gfc_bad_expr)\n \t    {\n \t      int j;\n@@ -2366,7 +2384,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \t  return &gfc_bad_expr;\n \t}\n \n-      return simplify_bound_dim (array, kind, d, upper, as);\n+      return simplify_bound_dim (array, kind, d, upper, as, ref);\n     }\n }\n "}, {"sha": "9c63dbf64480cf6a6051dc7d389718b1f6970946", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "patch": "@@ -1,3 +1,9 @@\n+2008-02-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/38914\n+\t* bound_simplification_2.f90:  New test case.\n+\t* bound_7.f90:  New test case.\n+\n 2009-02-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/cpp/include4.c: New test."}, {"sha": "e422845b90008451455bd664436a015c72a3a5cf", "filename": "gcc/testsuite/gfortran.dg/bound_7.f90", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_7.f90?ref=543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "patch": "@@ -0,0 +1,223 @@\n+! { dg-do run }\n+! { dg-options \"-std=gnu\" }\n+! PR fortran/29391\n+! This file is here to check that LBOUND and UBOUND return correct values\n+!\n+! Contributed by Francois-Xavier Coudert (coudert@clipper.ens.fr)\n+  implicit none\n+  integer, allocatable :: i(:,:), j(:), u(:,:,:,:)\n+\n+  allocate (i(-1:1,-1:1))\n+  i = 0\n+  allocate (j(-1:2))\n+  j = 0\n+  allocate (u(7,4,2,9))\n+\n+  call foo(u,4)\n+  call jackal(-1,-8)\n+  call jackal(-1,8)\n+\n+  if (any(lbound(i(-1:1,-1:1)) /= 1)) call abort\n+  if (lbound(i(-1:1,-1:1), 1) /= 1) call abort\n+  if (lbound(i(-1:1,-1:1), 2) /= 1) call abort\n+\n+  if (any(ubound(i(-1:1,-1:1)) /= 3)) call abort\n+  if (ubound(i(-1:1,-1:1), 1) /= 3) call abort\n+  if (ubound(i(-1:1,-1:1), 2) /= 3) call abort\n+\n+  if (any(lbound(i(:,:)) /= 1)) call abort\n+  if (lbound(i(:,:), 1) /= 1) call abort\n+  if (lbound(i(:,:), 2) /= 1) call abort\n+\n+  if (any(ubound(i(:,:)) /= 3)) call abort\n+  if (ubound(i(:,:), 1) /= 3) call abort\n+  if (ubound(i(:,:), 2) /= 3) call abort\n+\n+  if (any(lbound(i(0:,-1:)) /= 1)) call abort\n+  if (lbound(i(0:,-1:), 1) /= 1) call abort\n+  if (lbound(i(0:,-1:), 2) /= 1) call abort\n+\n+  if (any(ubound(i(0:,-1:)) /= [2,3])) call abort\n+  if (ubound(i(0:,-1:), 1) /= 2) call abort\n+  if (ubound(i(0:,-1:), 2) /= 3) call abort\n+\n+  if (any(lbound(i(:0,:0)) /= 1)) call abort\n+  if (lbound(i(:0,:0), 1) /= 1) call abort\n+  if (lbound(i(:0,:0), 2) /= 1) call abort\n+\n+  if (any(ubound(i(:0,:0)) /= 2)) call abort\n+  if (ubound(i(:0,:0), 1) /= 2) call abort\n+  if (ubound(i(:0,:0), 2) /= 2) call abort\n+\n+  if (any(lbound(transpose(i)) /= 1)) call abort\n+  if (lbound(transpose(i), 1) /= 1) call abort\n+  if (lbound(transpose(i), 2) /= 1) call abort\n+\n+  if (any(ubound(transpose(i)) /= 3)) call abort\n+  if (ubound(transpose(i), 1) /= 3) call abort\n+  if (ubound(transpose(i), 2) /= 3) call abort\n+\n+  if (any(lbound(reshape(i,[2,2])) /= 1)) call abort\n+  if (lbound(reshape(i,[2,2]), 1) /= 1) call abort\n+  if (lbound(reshape(i,[2,2]), 2) /= 1) call abort\n+\n+  if (any(ubound(reshape(i,[2,2])) /= 2)) call abort\n+  if (ubound(reshape(i,[2,2]), 1) /= 2) call abort\n+  if (ubound(reshape(i,[2,2]), 2) /= 2) call abort\n+\n+  if (any(lbound(cshift(i,-1)) /= 1)) call abort\n+  if (lbound(cshift(i,-1), 1) /= 1) call abort\n+  if (lbound(cshift(i,-1), 2) /= 1) call abort\n+\n+  if (any(ubound(cshift(i,-1)) /= 3)) call abort\n+  if (ubound(cshift(i,-1), 1) /= 3) call abort\n+  if (ubound(cshift(i,-1), 2) /= 3) call abort\n+\n+  if (any(lbound(eoshift(i,-1)) /= 1)) call abort\n+  if (lbound(eoshift(i,-1), 1) /= 1) call abort\n+  if (lbound(eoshift(i,-1), 2) /= 1) call abort\n+\n+  if (any(ubound(eoshift(i,-1)) /= 3)) call abort\n+  if (ubound(eoshift(i,-1), 1) /= 3) call abort\n+  if (ubound(eoshift(i,-1), 2) /= 3) call abort\n+\n+  if (any(lbound(spread(i,1,2)) /= 1)) call abort\n+  if (lbound(spread(i,1,2), 1) /= 1) call abort\n+  if (lbound(spread(i,1,2), 2) /= 1) call abort\n+\n+  if (any(ubound(spread(i,1,2)) /= [2,3,3])) call abort\n+  if (ubound(spread(i,1,2), 1) /= 2) call abort\n+  if (ubound(spread(i,1,2), 2) /= 3) call abort\n+  if (ubound(spread(i,1,2), 3) /= 3) call abort\n+\n+  if (any(lbound(maxloc(i)) /= 1)) call abort\n+  if (lbound(maxloc(i), 1) /= 1) call abort\n+\n+  if (any(ubound(maxloc(i)) /= 2)) call abort\n+  if (ubound(maxloc(i), 1) /= 2) call abort\n+\n+  if (any(lbound(minloc(i)) /= 1)) call abort\n+  if (lbound(minloc(i), 1) /= 1) call abort\n+\n+  if (any(ubound(minloc(i)) /= 2)) call abort\n+  if (ubound(minloc(i), 1) /= 2) call abort\n+\n+  if (any(lbound(maxval(i,2)) /= 1)) call abort\n+  if (lbound(maxval(i,2), 1) /= 1) call abort\n+\n+  if (any(ubound(maxval(i,2)) /= 3)) call abort\n+  if (ubound(maxval(i,2), 1) /= 3) call abort\n+\n+  if (any(lbound(minval(i,2)) /= 1)) call abort\n+  if (lbound(minval(i,2), 1) /= 1) call abort\n+\n+  if (any(ubound(minval(i,2)) /= 3)) call abort\n+  if (ubound(minval(i,2), 1) /= 3) call abort\n+\n+  if (any(lbound(any(i==1,2)) /= 1)) call abort\n+  if (lbound(any(i==1,2), 1) /= 1) call abort\n+\n+  if (any(ubound(any(i==1,2)) /= 3)) call abort\n+  if (ubound(any(i==1,2), 1) /= 3) call abort\n+\n+  if (any(lbound(count(i==1,2)) /= 1)) call abort\n+  if (lbound(count(i==1,2), 1) /= 1) call abort\n+\n+  if (any(ubound(count(i==1,2)) /= 3)) call abort\n+  if (ubound(count(i==1,2), 1) /= 3) call abort\n+\n+  if (any(lbound(merge(i,i,.true.)) /= 1)) call abort\n+  if (lbound(merge(i,i,.true.), 1) /= 1) call abort\n+  if (lbound(merge(i,i,.true.), 2) /= 1) call abort\n+\n+  if (any(ubound(merge(i,i,.true.)) /= 3)) call abort\n+  if (ubound(merge(i,i,.true.), 1) /= 3) call abort\n+  if (ubound(merge(i,i,.true.), 2) /= 3) call abort\n+\n+  if (any(lbound(lbound(i)) /= 1)) call abort\n+  if (lbound(lbound(i), 1) /= 1) call abort\n+\n+  if (any(ubound(lbound(i)) /= 2)) call abort\n+  if (ubound(lbound(i), 1) /= 2) call abort\n+\n+  if (any(lbound(ubound(i)) /= 1)) call abort\n+  if (lbound(ubound(i), 1) /= 1) call abort\n+\n+  if (any(ubound(ubound(i)) /= 2)) call abort\n+  if (ubound(ubound(i), 1) /= 2) call abort\n+\n+  if (any(lbound(shape(i)) /= 1)) call abort\n+  if (lbound(shape(i), 1) /= 1) call abort\n+\n+  if (any(ubound(shape(i)) /= 2)) call abort\n+  if (ubound(shape(i), 1) /= 2) call abort\n+\n+  if (any(lbound(product(i,2)) /= 1)) call abort\n+  if (any(ubound(product(i,2)) /= 3)) call abort\n+  if (any(lbound(sum(i,2)) /= 1)) call abort\n+  if (any(ubound(sum(i,2)) /= 3)) call abort\n+  if (any(lbound(matmul(i,i)) /= 1)) call abort\n+  if (any(ubound(matmul(i,i)) /= 3)) call abort\n+  if (any(lbound(pack(i,.true.)) /= 1)) call abort\n+  if (any(ubound(pack(i,.true.)) /= 9)) call abort\n+  if (any(lbound(unpack(j,[.true.],[2])) /= 1)) call abort\n+  if (any(ubound(unpack(j,[.true.],[2])) /= 1)) call abort\n+\n+  call sub1(i,3)\n+  call sub1(reshape([7,9,4,6,7,9],[3,2]),3)\n+  call sub2\n+\n+contains\n+\n+  subroutine sub1(a,n)\n+    integer :: n, a(2:n+1,4:*)\n+\n+    if (any([lbound(a,1), lbound(a,2)] /= [2, 4])) call abort\n+    if (any(lbound(a) /= [2, 4])) call abort\n+  end subroutine sub1\n+\n+  subroutine sub2\n+    integer :: x(3:2, 1:2)\n+\n+    if (size(x) /= 0) call abort\n+    if (lbound (x, 1) /= 1 .or. lbound(x, 2) /= 1) call abort\n+    if (any (lbound (x) /= [1, 1])) call abort\n+    if (ubound (x, 1) /= 0 .or. ubound(x, 2) /= 2) call abort\n+    if (any (ubound (x) /= [0, 2])) call abort\n+  end subroutine sub2\n+\n+  subroutine sub3\n+    integer :: x(4:5, 1:2)\n+\n+    if (size(x) /= 0) call abort\n+    if (lbound (x, 1) /= 4 .or. lbound(x, 2) /= 1) call abort\n+    if (any (lbound (x) /= [4, 1])) call abort\n+    if (ubound (x, 1) /= 4 .or. ubound(x, 2) /= 2) call abort\n+    if (any (ubound (x) /= [4, 2])) call abort\n+  end subroutine sub3\n+\n+  subroutine foo (x,n)\n+    integer :: x(7,n,2,*), n\n+\n+    if (ubound(x,1) /= 7 .or. ubound(x,2) /= 4 .or. ubound(x,3) /= 2) call abort\n+  end subroutine foo\n+\n+  subroutine jackal (b, c)\n+    integer :: b, c\n+    integer :: soda(b:c, 3:4)\n+\n+    if (b > c) then\n+      if (size(soda) /= 0) call abort\n+      if (lbound (soda, 1) /= 1 .or. ubound (soda, 1) /= 0) call abort\n+    else\n+      if (size(soda) /= 2*(c-b+1)) call abort\n+      if (lbound (soda, 1) /= b .or. ubound (soda, 1) /= c) call abort\n+    end if\n+\n+    if (lbound (soda, 2) /= 3 .or. ubound (soda, 2) /= 4) call abort\n+    if (any (lbound (soda) /= [lbound(soda,1), lbound(soda,2)])) call abort\n+    if (any (ubound (soda) /= [ubound(soda,1), ubound(soda,2)])) call abort\n+\n+  end subroutine jackal\n+\n+end"}, {"sha": "05477776f080f918c13266f74da4c8e4f95fa303", "filename": "gcc/testsuite/gfortran.dg/bound_simplification_2.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_simplification_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_simplification_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_simplification_2.f90?ref=543af7abbeb1bca017ec4cc8dcbb5fe51fa4c305", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+! PR 38914 - this used to give an ICE due to missing\n+! simplification.\n+module foo\n+  INTEGER, PARAMETER, DIMENSION(0:20,4) :: IP_ARRAY2_4_S = 0\n+  INTEGER, PARAMETER, DIMENSION(2) ::  IP_ARRAY1_32_S = &\n+  & (/  LBOUND(IP_ARRAY2_4_S(5:10,2:3))/)\n+END module foo\n+! { dg-final { cleanup-modules \"foo\" } }"}]}