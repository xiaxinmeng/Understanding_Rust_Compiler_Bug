{"sha": "747800ee8a9782cea34d002fe6a53439da75b25c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ3ODAwZWU4YTk3ODJjZWEzNGQwMDJmZTZhNTM0MzlkYTc1YjI1Yw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-11-03T20:27:07Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-11-03T20:27:07Z"}, "message": "lex.h (_JAVA_IDENTIFIER_IGNORABLE): New macro.\n\n\t* lex.h (_JAVA_IDENTIFIER_IGNORABLE): New macro.\n\t(JAVA_ID_CHAR_P): Also try java_ignorable_control_p.\n\t* lex.c (java_read_unicode): Removed `term_context' argument.\n\tRecognize any number of `u' in `\\u'.\n\t(java_read_unicode_collapsing_terminators): New function.\n\t(java_get_unicode): Use it.\n\t(java_lineterminator): Removed.\n\t(yylex): Produce error if character literal is newline or single\n\tquote.  Return if eof found in middle of `//' comment.  EOF in\n\t`//' comment is only an error if pedantic.\n\t(java_ignorable_control_p): New function.\n\t(java_parse_end_comment): Return if eof found in middle of\n\tcomment.\n\tInclude flags.h.\n\t* jv-scan.c (pedantic): New global.\n\nFrom-SVN: r37232", "tree": {"sha": "3ec9a05402bdb242bd150aacc46596d394cd2d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ec9a05402bdb242bd150aacc46596d394cd2d1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/747800ee8a9782cea34d002fe6a53439da75b25c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/747800ee8a9782cea34d002fe6a53439da75b25c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/747800ee8a9782cea34d002fe6a53439da75b25c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/747800ee8a9782cea34d002fe6a53439da75b25c/comments", "author": null, "committer": null, "parents": [{"sha": "35e9340fc9994dbd2025f8770593fa0136e33740", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e9340fc9994dbd2025f8770593fa0136e33740", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e9340fc9994dbd2025f8770593fa0136e33740"}], "stats": {"total": 169, "additions": 113, "deletions": 56}, "files": [{"sha": "ca29aec406bb24e554826d39b59bdd145a0d8168", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=747800ee8a9782cea34d002fe6a53439da75b25c", "patch": "@@ -1,3 +1,21 @@\n+2000-11-03  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* lex.h (_JAVA_IDENTIFIER_IGNORABLE): New macro.\n+\t(JAVA_ID_CHAR_P): Also try java_ignorable_control_p.\n+\t* lex.c (java_read_unicode): Removed `term_context' argument.\n+\tRecognize any number of `u' in `\\u'.\n+\t(java_read_unicode_collapsing_terminators): New function.\n+\t(java_get_unicode): Use it.\n+\t(java_lineterminator): Removed.\n+\t(yylex): Produce error if character literal is newline or single\n+\tquote.  Return if eof found in middle of `//' comment.  EOF in\n+\t`//' comment is only an error if pedantic.\n+\t(java_ignorable_control_p): New function.\n+\t(java_parse_end_comment): Return if eof found in middle of\n+\tcomment.\n+\tInclude flags.h.\n+\t* jv-scan.c (pedantic): New global.\n+\n 2000-10-27  Zack Weinberg  <zack@wolery.stanford.edu>\n \n \t* Make-lang.in: Move all build rules here from Makefile.in,"}, {"sha": "a96b80506178f1f28f6720c1be039b493d62c70a", "filename": "gcc/java/jv-scan.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2Fjv-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2Fjv-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjv-scan.c?ref=747800ee8a9782cea34d002fe6a53439da75b25c", "patch": "@@ -62,6 +62,8 @@ int flag_find_main = 0;\n int flag_dump_class = 0;\n int flag_list_filename = 0;\n \n+int pedantic = 0;\n+\n \f\n \n /* This is used to mark options with no short value.  */"}, {"sha": "2c123ce87c19391fd889deab544704dc7444f305", "filename": "gcc/java/lex.c", "status": "modified", "additions": 78, "deletions": 56, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=747800ee8a9782cea34d002fe6a53439da75b25c", "patch": "@@ -35,9 +35,9 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n    Addison Wesley 1996\" (http://java.sun.com/docs/books/jls/html/3.doc.html) */\n \n #include \"keyword.h\"\n+#include \"flags.h\"\n \n /* Function declaration  */\n-static int java_lineterminator PARAMS ((unicode_t));\n static char *java_sprint_unicode PARAMS ((struct java_line *, int));\n static void java_unicode_2_utf8 PARAMS ((unicode_t));\n static void java_lex_error PARAMS ((const char *, int));\n@@ -48,10 +48,13 @@ static tree build_wfl_node PARAMS ((tree));\n static void java_store_unicode PARAMS ((struct java_line *, unicode_t, int));\n static unicode_t java_parse_escape_sequence PARAMS ((void));\n static int java_letter_or_digit_p PARAMS ((unicode_t));\n+static int java_ignorable_control_p PARAMS ((unicode_t));\n static int java_parse_doc_section PARAMS ((unicode_t));\n static void java_parse_end_comment PARAMS ((unicode_t));\n static unicode_t java_get_unicode PARAMS ((void));\n-static unicode_t java_read_unicode PARAMS ((java_lexer *, int, int *));\n+static unicode_t java_read_unicode PARAMS ((java_lexer *, int *));\n+static unicode_t java_read_unicode_collapsing_terminators\n+    PARAMS ((java_lexer *, int *));\n static void java_store_unicode PARAMS ((struct java_line *, unicode_t, int));\n static unicode_t java_read_char PARAMS ((java_lexer *));\n static void java_allocate_new_line PARAMS ((void));\n@@ -494,9 +497,8 @@ java_store_unicode (l, c, unicode_escape_p)\n }\n \n static unicode_t\n-java_read_unicode (lex, term_context, unicode_escape_p)\n+java_read_unicode (lex, unicode_escape_p)\n      java_lexer *lex;\n-     int term_context;\n      int *unicode_escape_p;\n {\n   unicode_t c;\n@@ -507,9 +509,7 @@ java_read_unicode (lex, term_context, unicode_escape_p)\n   if (c != '\\\\')\n     {\n       lex->bs_count = 0;\n-      return (term_context ? c : (java_lineterminator (c)\n-\t\t\t\t  ? '\\n'\n-\t\t\t\t  : (unicode_t) c));\n+      return c;\n     }\n \n   ++lex->bs_count;\n@@ -532,19 +532,45 @@ java_read_unicode (lex, term_context, unicode_escape_p)\n \t\tunicode |= (unicode_t)((c-'0') << shift);\n \t      else if ((c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))\n \t        unicode |= (unicode_t)((10+(c | 0x20)-'a') << shift);\n+\t      else if (c == 'u')\n+\t\t{\n+\t\t  /* Recognize any number of u in \\u.  */\n+\t\t  shift += 4;\n+\t\t}\n \t      else\n \t\tjava_lex_error (\"Non hex digit in Unicode escape sequence\", 0);\n \t    }\n \t  lex->bs_count = 0;\n \t  *unicode_escape_p = 1;\n-\t  return (term_context\n-\t\t  ? unicode : (java_lineterminator (c) ? '\\n' : unicode));\n+\t  return unicode;\n \t}\n       lex->unget_value = c;\n     }\n   return (unicode_t) '\\\\';\n }\n \n+static unicode_t\n+java_read_unicode_collapsing_terminators (lex, unicode_escape_p)\n+     java_lexer *lex;\n+     int *unicode_escape_p;\n+{\n+  unicode_t c = java_read_unicode (lex, unicode_escape_p);\n+\n+  if (c == '\\r')\n+    {\n+      /* We have to read ahead to see if we got \\r\\n.  In that case we\n+\t return a single line terminator.  */\n+      int dummy;\n+      c = java_read_unicode (lex, &dummy);\n+      if (c != '\\n')\n+\tlex->unget_value = c;\n+      /* In either case we must return a newline.  */\n+      c = '\\n';\n+    }\n+\n+  return c;\n+}\n+\n static unicode_t\n java_get_unicode ()\n {\n@@ -554,54 +580,28 @@ java_get_unicode ()\n       unicode_t c;\n       java_allocate_new_line ();\n       if (ctxp->c_line->line[0] != '\\n')\n-\tfor (;;)\n-\t  {\n-\t    int unicode_escape_p;\n-\t    c = java_read_unicode (ctxp->lexer, 0, &unicode_escape_p);\n-\t    java_store_unicode (ctxp->c_line, c, unicode_escape_p);\n-\t    if (ctxp->c_line->white_space_only \n-\t\t&& !JAVA_WHITE_SPACE_P (c) && c!='\\n')\n-\t      ctxp->c_line->white_space_only = 0;\n-\t    if ((c == '\\n') || (c == UEOF))\n-\t      break;\n-\t  }\n+\t{\n+\t  for (;;)\n+\t    {\n+\t      int unicode_escape_p;\n+\t      c = java_read_unicode_collapsing_terminators (ctxp->lexer,\n+\t\t\t\t\t\t\t    &unicode_escape_p);\n+\t      java_store_unicode (ctxp->c_line, c, unicode_escape_p);\n+\t      if (ctxp->c_line->white_space_only \n+\t\t  && !JAVA_WHITE_SPACE_P (c)\n+\t\t  && c != '\\n'\n+\t\t  && c != UEOF)\n+\t\tctxp->c_line->white_space_only = 0;\n+\t      if ((c == '\\n') || (c == UEOF))\n+\t\tbreak;\n+\t    }\n+\t}\n     }\n   ctxp->c_line->char_col += JAVA_COLUMN_DELTA (0);\n   JAVA_LEX_CHAR (ctxp->c_line->line [ctxp->c_line->current]);\n   return ctxp->c_line->line [ctxp->c_line->current++];\n }\n \n-static int\n-java_lineterminator (c)\n-     unicode_t c;\n-{\n-  if (c == '\\n')\t\t/* LF */\n-    return 1;\n-  else if (c == '\\r')\t\t/* CR */\n-    {\n-      int unicode_escape_p;\n-      c = java_read_unicode (ctxp->lexer, 1, &unicode_escape_p);\n-      if (c == '\\r')\n-\t{\n-\t  /* In this case we will have another terminator.  For some\n-\t     reason the lexer has several different unget methods.  We\n-\t     can't use the `ahead' method because then the \\r will end\n-\t     up in the actual text of the line, causing an error.  So\n-\t     instead we choose a very low-level method.  FIXME: this\n-\t     is incredibly ugly.  */\n-\t  ctxp->lexer->unget_value = c;\n-\t}\n-      else if (c != '\\n')\n-\t{\n-\t  ctxp->c_line->ahead [0] = c;\n-\t  ctxp->c_line->unicode_escape_ahead_p = unicode_escape_p;\n-\t}\n-      return 1;\n-    }\n-  else \n-    return 0;\n-}\n-\n /* Parse the end of a C style comment.\n  * C is the first character following the '/' and '*'. */\n static void\n@@ -615,11 +615,13 @@ java_parse_end_comment (c)\n \t{\n \tcase UEOF:\n \t  java_lex_error (\"Comment not terminated at end of input\", 0);\n+\t  return;\n \tcase '*':\n \t  switch (c = java_get_unicode ())\n \t    {\n \t    case UEOF:\n \t      java_lex_error (\"Comment not terminated at end of input\", 0);\n+\t      return;\n \t    case '/':\n \t      return;\n \t    case '*':\t/* reparse only '*' */\n@@ -692,6 +694,14 @@ java_letter_or_digit_p (c)\n   return _JAVA_LETTER_OR_DIGIT_P (c);\n }\n \n+/* This function to be used only by JAVA_ID_CHAR_P ().  */\n+static int\n+java_ignorable_control_p (c)\n+     unicode_t c;\n+{\n+  return _JAVA_IDENTIFIER_IGNORABLE (c);\n+}\n+\n static unicode_t\n java_parse_escape_sequence ()\n {\n@@ -747,7 +757,7 @@ java_parse_escape_sequence ()\n     case '\\n':\n       return '\\n';\t\t/* ULT, caught latter as a specific error */\n     default:\n-      java_lex_error (\"Illegal character in escape sequence\", 0);\n+      java_lex_error (\"Invalid character in escape sequence\", 0);\n       return JAVA_CHAR_ERROR;\n     }\n }\n@@ -839,7 +849,14 @@ java_lex (java_lval)\n \t    {\n \t      c = java_get_unicode ();\n \t      if (c == UEOF)\n-\t\tjava_lex_error (\"Comment not terminated at end of input\", 0);\n+\t\t{\n+\t\t  /* It is ok to end a `//' comment with EOF, unless\n+\t\t     we're being pedantic.  */\n+\t\t  if (pedantic)\n+\t\t    java_lex_error (\"Comment not terminated at end of input\",\n+\t\t\t\t    0);\n+\t\t  return 0;\n+\t\t}\n \t      if (c == '\\n')\t/* ULT */\n \t\tgoto step1;\n \t    }\n@@ -1134,17 +1151,22 @@ java_lex (java_lval)\n     }\n \n   ctxp->minus_seen = 0;\n+\n   /* Character literals */\n   if (c == '\\'')\n     {\n       unicode_t char_lit;\n       if ((c = java_get_unicode ()) == '\\\\')\n \tchar_lit = java_parse_escape_sequence ();\n       else\n-\tchar_lit = c;\n+\t{\n+\t  if (c == '\\n' || c == '\\'')\n+\t    java_lex_error (\"Invalid character literal\", 0);\n+\t  char_lit = c;\n+\t}\n \n       c = java_get_unicode ();\n-      \n+\n       if ((c == '\\n') || (c == UEOF))\n \tjava_lex_error (\"Character literal not terminated at end of line\", 0);\n       if (c != '\\'')\n@@ -1509,7 +1531,7 @@ java_lex (java_lval)\n   /* Everything else is an invalid character in the input */\n   {\n     char lex_error_buffer [128];\n-    sprintf (lex_error_buffer, \"Invalid character '%s' in input\", \n+    sprintf (lex_error_buffer, \"Invalid character `%s' in input\", \n \t     java_sprint_unicode (ctxp->c_line, ctxp->c_line->current));\n     java_lex_error (lex_error_buffer, 1);\n   }"}, {"sha": "b43061e45ee9e2bcfccfb3670dca397e7b25f87f", "filename": "gcc/java/lex.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747800ee8a9782cea34d002fe6a53439da75b25c/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=747800ee8a9782cea34d002fe6a53439da75b25c", "patch": "@@ -256,6 +256,7 @@ extern void set_float_handler PARAMS ((jmp_buf));\n \t\t\t\t\t    RANGE (c, '0', '9') ||\t\\\n \t\t\t\t\t    c == '_'         ||\t\t\\\n \t\t\t\t\t    c == '$'))       ||\t\t\\\n+\t\t\t       java_ignorable_control_p (c)  ||\t\t\\\n \t\t\t       (c > 127 && java_letter_or_digit_p (c)))\n #define JAVA_ASCII_DIGIT(c)    RANGE(c,'0', '9')\n #define JAVA_ASCII_OCTDIGIT(c) RANGE(c,'0', '7')\n@@ -552,6 +553,20 @@ extern void set_float_handler PARAMS ((jmp_buf));\n     RANGE (c, 0xFFD2, 0xFFD7) ||\t\t\\\n     RANGE (c, 0xFFDA, 0xFFDC))\n \n+/* Identifier-ignorable characters.  This should not be used\n+   standalone.  Note that the JCL says 200a->200e.  That is a typo.\n+   The correct values are 202a->202e.  Note also that we test against\n+   0x0000 separately to avoid a warning.  */\n+#define _JAVA_IDENTIFIER_IGNORABLE(c)\t\t\t\t\t      \\\n+  (c == 0x0000\t\t\t\t\t\t\t\t      \\\n+   || RANGE (c, 0x0001, 0x0008)\t\t\t\t\t\t      \\\n+   || RANGE (c, 0x000e, 0x001b)\t\t\t\t\t\t      \\\n+   || RANGE (c, 0x007f, 0x009f)\t\t\t\t\t\t      \\\n+   || RANGE (c, 0x200c, 0x200f)\t\t\t\t\t\t      \\\n+   || RANGE (c, 0x202a, 0x202e)\t\t\t\t\t\t      \\\n+   || RANGE (c, 0x206a, 0x206f)\t\t\t\t\t\t      \\\n+   || c == 0xfeff)\n+\n /* Constants  */\n #define JAVA_CHAR_ERROR 0xFFC1\t/* This is an illegal unicode!?! FIXME */\n #define JAVA_READ_BUFFER 256"}]}