{"sha": "779d7a1a92077724180c32fd35541b2cb2ab84b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc5ZDdhMWE5MjA3NzcyNDE4MGMzMmZkMzU1NDFiMmNiMmFiODRiOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-07-25T05:58:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-07-25T05:58:40Z"}, "message": "regclass.c (move_table): New type.\n\n\n\t* regclass.c (move_table): New type.\n\t(move_cost, may_move_in_cost, may_move_out_cost): Use it.\n\t(init_move_cost): Break out from ...\n\t(init_reg_sets_1): ... here; simplify computation of\n\thave_regs-of_mode and contains_reg_of_mode.\n\t(record_reg_classes): Unswitch internal loops.\n\t(copy_cost): Trigger lazy initialization of move cost\n\t(record_address_regs): Likewise.\n\nFrom-SVN: r126901", "tree": {"sha": "4f078700c58382b243b88aba5e79983488568e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f078700c58382b243b88aba5e79983488568e87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/779d7a1a92077724180c32fd35541b2cb2ab84b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779d7a1a92077724180c32fd35541b2cb2ab84b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779d7a1a92077724180c32fd35541b2cb2ab84b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779d7a1a92077724180c32fd35541b2cb2ab84b9/comments", "author": null, "committer": null, "parents": [{"sha": "a857cbfbbf90a7d82200e9715b24820a5c344c59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a857cbfbbf90a7d82200e9715b24820a5c344c59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a857cbfbbf90a7d82200e9715b24820a5c344c59"}], "stats": {"total": 268, "additions": 180, "deletions": 88}, "files": [{"sha": "3ce92aae323ab1e065ea39f06c822f8166a23e62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779d7a1a92077724180c32fd35541b2cb2ab84b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779d7a1a92077724180c32fd35541b2cb2ab84b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=779d7a1a92077724180c32fd35541b2cb2ab84b9", "patch": "@@ -1,3 +1,14 @@\n+2007-07-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* regclass.c (move_table): New type.\n+\t(move_cost, may_move_in_cost, may_move_out_cost): Use it.\n+\t(init_move_cost): Break out from ...\n+\t(init_reg_sets_1): ... here; simplify computation of\n+\thave_regs-of_mode and contains_reg_of_mode.\n+\t(record_reg_classes): Unswitch internal loops.\n+\t(copy_cost): Trigger lazy initialization of move cost\n+\t(record_address_regs): Likewise.\n+\n 2007-07-24  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* config/darwin.c (darwin_override_options): Don't force on"}, {"sha": "b35dc1823a2673b8219a4e96df899b7e637c1a79", "filename": "gcc/regclass.c", "status": "modified", "additions": 169, "deletions": 88, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779d7a1a92077724180c32fd35541b2cb2ab84b9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779d7a1a92077724180c32fd35541b2cb2ab84b9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=779d7a1a92077724180c32fd35541b2cb2ab84b9", "patch": "@@ -214,20 +214,22 @@ bool have_regs_of_mode [MAX_MACHINE_MODE];\n \n static char contains_reg_of_mode [N_REG_CLASSES] [MAX_MACHINE_MODE];\n \n+typedef unsigned short move_table[N_REG_CLASSES];\n+\n /* Maximum cost of moving from a register in one class to a register in\n    another class.  Based on REGISTER_MOVE_COST.  */\n \n-static int move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][N_REG_CLASSES];\n+static move_table *move_cost[MAX_MACHINE_MODE];\n \n /* Similar, but here we don't have to move if the first index is a subset\n    of the second so in that case the cost is zero.  */\n \n-static int may_move_in_cost[MAX_MACHINE_MODE][N_REG_CLASSES][N_REG_CLASSES];\n+static move_table *may_move_in_cost[MAX_MACHINE_MODE];\n \n /* Similar, but here we don't have to move if the first index is a superset\n    of the second so in that case the cost is zero.  */\n \n-static int may_move_out_cost[MAX_MACHINE_MODE][N_REG_CLASSES][N_REG_CLASSES];\n+static move_table *may_move_out_cost[MAX_MACHINE_MODE];\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n@@ -312,6 +314,96 @@ init_reg_sets (void)\n #endif\n }\n \n+/* Initialize may_move_cost and friends for mode M.  */\n+\n+static void\n+init_move_cost (enum machine_mode m)\n+{\n+  static unsigned short last_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n+  static int last_mode = -1;\n+  bool all_match = true;\n+  unsigned int i, j;\n+\n+  gcc_assert (have_regs_of_mode[m]);\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    if (contains_reg_of_mode[i][m])\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  int cost;\n+\t  if (!contains_reg_of_mode[j][m])\n+\t    cost = 65535;\n+\t  else\n+\t    {\n+\t      cost = REGISTER_MOVE_COST (m, i, j);\n+\t      gcc_assert (cost < 65535);\n+\t    }\n+\t  all_match &= (last_move_cost[i][j] == cost);\n+\t  last_move_cost[i][j] = cost;\n+\t}\n+  if (all_match && last_mode != -1)\n+    {\n+      move_cost[m] = move_cost[last_mode];\n+      may_move_in_cost[m] = may_move_in_cost[last_mode];\n+      may_move_out_cost[m] = may_move_out_cost[last_mode];\n+      return;\n+    }\n+  last_mode = m;\n+  move_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+\t\t\t\t\t* N_REG_CLASSES);\n+  may_move_in_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+\t\t\t\t\t       * N_REG_CLASSES);\n+  may_move_out_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+\t\t\t\t\t        * N_REG_CLASSES);\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    if (contains_reg_of_mode[i][m])\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  int cost;\n+\t  enum reg_class *p1, *p2;\n+\n+\t  if (last_move_cost[i][j] == 65535)\n+\t    {\n+\t      move_cost[m][i][j] = 65535;\n+\t      may_move_in_cost[m][i][j] = 65535;\n+\t      may_move_out_cost[m][i][j] = 65535;\n+\t    }\n+\t  else\n+\t    {\n+\t      cost = last_move_cost[i][j];\n+\n+\t      for (p2 = &reg_class_subclasses[j][0];\n+\t\t   *p2 != LIM_REG_CLASSES; p2++)\n+\t\tif (*p2 != i && contains_reg_of_mode[*p2][m])\n+\t\t  cost = MAX (cost, move_cost[m][i][*p2]);\n+\n+\t      for (p1 = &reg_class_subclasses[i][0];\n+\t\t   *p1 != LIM_REG_CLASSES; p1++)\n+\t\tif (*p1 != j && contains_reg_of_mode[*p1][m])\n+\t\t  cost = MAX (cost, move_cost[m][*p1][j]);\n+\n+\t      gcc_assert (cost <= 65535);\n+\t      move_cost[m][i][j] = cost;\n+\n+\t      if (reg_class_subset_p (i, j))\n+\t\tmay_move_in_cost[m][i][j] = 0;\n+\t      else\n+\t\tmay_move_in_cost[m][i][j] = cost;\n+\n+\t      if (reg_class_subset_p (j, i))\n+\t\tmay_move_out_cost[m][i][j] = 0;\n+\t      else\n+\t\tmay_move_out_cost[m][i][j] = cost;\n+\t    }\n+\t}\n+    else\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  move_cost[m][i][j] = 65535;\n+\t  may_move_in_cost[m][i][j] = 65535;\n+\t  may_move_out_cost[m][i][j] = 65535;\n+\t}\n+}\n+\n /* After switches have been processed, which perhaps alter\n    `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */\n \n@@ -476,73 +568,21 @@ init_reg_sets_1 (void)\n   memset (have_regs_of_mode, 0, sizeof (have_regs_of_mode));\n   memset (contains_reg_of_mode, 0, sizeof (contains_reg_of_mode));\n   for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)\n-    for (i = 0; i < N_REG_CLASSES; i++)\n-      if ((unsigned) CLASS_MAX_NREGS (i, m) <= reg_class_size[i])\n-\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\t  if (!fixed_regs [j] && TEST_HARD_REG_BIT (reg_class_contents[i], j)\n-\t      && HARD_REGNO_MODE_OK (j, m))\n-\t     {\n-\t       contains_reg_of_mode [i][m] = 1;\n-\t       have_regs_of_mode [m] = 1;\n-\t       break;\n-\t     }\n-\n-  /* Initialize the move cost table.  Find every subset of each class\n-     and take the maximum cost of moving any subset to any other.  */\n-\n-  for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)\n-    if (have_regs_of_mode [m])\n-      {\n-\tfor (i = 0; i < N_REG_CLASSES; i++)\n-\t  if (contains_reg_of_mode [i][m])\n-\t    for (j = 0; j < N_REG_CLASSES; j++)\n-\t      {\n-\t\tint cost;\n-\t\tenum reg_class *p1, *p2;\n-\n-\t\tif (!contains_reg_of_mode [j][m])\n-\t\t  {\n-\t\t    move_cost[m][i][j] = 65536;\n-\t\t    may_move_in_cost[m][i][j] = 65536;\n-\t\t    may_move_out_cost[m][i][j] = 65536;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    cost = REGISTER_MOVE_COST (m, i, j);\n-\n-\t\t    for (p2 = &reg_class_subclasses[j][0];\n-\t\t\t *p2 != LIM_REG_CLASSES;\n-\t\t\t p2++)\n-\t\t      if (*p2 != i && contains_reg_of_mode [*p2][m])\n-\t\t\tcost = MAX (cost, move_cost [m][i][*p2]);\n-\n-\t\t    for (p1 = &reg_class_subclasses[i][0];\n-\t\t\t *p1 != LIM_REG_CLASSES;\n-\t\t\t p1++)\n-\t\t      if (*p1 != j && contains_reg_of_mode [*p1][m])\n-\t\t\tcost = MAX (cost, move_cost [m][*p1][j]);\n-\n-\t\t    move_cost[m][i][j] = cost;\n-\n-\t\t    if (reg_class_subset_p (i, j))\n-\t\t      may_move_in_cost[m][i][j] = 0;\n-\t\t    else\n-\t\t      may_move_in_cost[m][i][j] = cost;\n-\n-\t\t    if (reg_class_subset_p (j, i))\n-\t\t      may_move_out_cost[m][i][j] = 0;\n-\t\t    else\n-\t\t      may_move_out_cost[m][i][j] = cost;\n-\t\t  }\n-\t      }\n-\t  else\n-\t    for (j = 0; j < N_REG_CLASSES; j++)\n-\t      {\n-\t\tmove_cost[m][i][j] = 65536;\n-\t\tmay_move_in_cost[m][i][j] = 65536;\n-\t\tmay_move_out_cost[m][i][j] = 65536;\n-\t      }\n-      }\n+    {\n+      HARD_REG_SET ok_regs;\n+      CLEAR_HARD_REG_SET (ok_regs);\n+      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\tif (!fixed_regs [j] && HARD_REGNO_MODE_OK (j, m))\n+\t  SET_HARD_REG_BIT (ok_regs, j);\n+      \n+      for (i = 0; i < N_REG_CLASSES; i++)\n+\tif ((unsigned) CLASS_MAX_NREGS (i, m) <= reg_class_size[i]\n+\t    && hard_reg_set_intersect_p (ok_regs, reg_class_contents[i]))\n+\t  {\n+\t     contains_reg_of_mode [i][m] = 1;\n+\t     have_regs_of_mode [m] = 1;\n+\t  }\n+     }\n }\n \n /* Compute the table of register modes.\n@@ -1465,15 +1505,33 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     copy, which is one instruction.  */\n \n \t\t  struct costs *pp = &this_op_costs[i];\n-\n-\t\t  for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t    pp->cost[class]\n-\t\t      = ((recog_data.operand_type[i] != OP_OUT\n-\t\t\t  ? may_move_in_cost[mode][class][(int) classes[i]]\n-\t\t\t  : 0)\n-\t\t\t + (recog_data.operand_type[i] != OP_IN\n-\t\t\t    ? may_move_out_cost[mode][(int) classes[i]][class]\n-\t\t\t    : 0));\n+\t\t  move_table *intable = NULL;\n+\t\t  move_table *outtable = NULL;\n+\t\t  int op_class = (int) classes[i];\n+\n+\t\t  if (!move_cost[mode])\n+\t\t    init_move_cost (mode);\n+\t\t  intable = may_move_in_cost[mode];\n+\t\t  outtable = may_move_out_cost[mode];\n+\n+\t\t  /* The loop is performance critical, so unswitch it manually.\n+\t\t   */\n+\t\t  switch (recog_data.operand_type[i])\n+\t\t    {\n+\t\t    case OP_INOUT:\n+\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t\tpp->cost[class] = (intable[class][op_class]\n+\t\t\t\t\t   + outtable[op_class][class]);\n+\t\t      break;\n+\t\t    case OP_IN:\n+\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t\tpp->cost[class] = intable[class][op_class];\n+\t\t      break;\n+\t\t    case OP_OUT:\n+\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t\tpp->cost[class] = outtable[op_class][class];\n+\t\t      break;\n+\t\t    }\n \n \t\t  /* If the alternative actually allows memory, make things\n \t\t     a bit cheaper since we won't need an extra insn to\n@@ -1691,15 +1749,33 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t      else\n \t\t{\n \t\t  struct costs *pp = &this_op_costs[i];\n-\n-\t\t  for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t    pp->cost[class]\n-\t\t      = ((recog_data.operand_type[i] != OP_OUT\n-\t\t\t  ? may_move_in_cost[mode][class][(int) classes[i]]\n-\t\t\t  : 0)\n-\t\t\t + (recog_data.operand_type[i] != OP_IN\n-\t\t\t    ? may_move_out_cost[mode][(int) classes[i]][class]\n-\t\t\t    : 0));\n+\t\t  move_table *intable = NULL;\n+\t\t  move_table *outtable = NULL;\n+\t\t  int op_class = (int) classes[i];\n+\n+\t\t  if (!move_cost[mode])\n+\t\t    init_move_cost (mode);\n+\t\t  intable = may_move_in_cost[mode];\n+\t\t  outtable = may_move_out_cost[mode];\n+\n+\t\t  /* The loop is performance critical, so unswitch it manually.\n+\t\t   */\n+\t\t  switch (recog_data.operand_type[i])\n+\t\t    {\n+\t\t    case OP_INOUT:\n+\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t\tpp->cost[class] = (intable[class][op_class]\n+\t\t\t\t\t   + outtable[op_class][class]);\n+\t\t      break;\n+\t\t    case OP_IN:\n+\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t\tpp->cost[class] = intable[class][op_class];\n+\t\t      break;\n+\t\t    case OP_OUT:\n+\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t\tpp->cost[class] = outtable[op_class][class];\n+\t\t      break;\n+\t\t    }\n \n \t\t  /* If the alternative actually allows memory, make things\n \t\t     a bit cheaper since we won't need an extra insn to\n@@ -1856,6 +1932,9 @@ copy_cost (rtx x, enum machine_mode mode, enum reg_class class, int to_p,\n   sri.extra_cost = 0;\n   secondary_class = targetm.secondary_reload (to_p, x, class, mode, &sri);\n \n+  if (!move_cost[mode])\n+    init_move_cost (mode);\n+\n   if (secondary_class != NO_REGS)\n     return (move_cost[mode][(int) secondary_class][(int) class]\n \t    + sri.extra_cost\n@@ -2056,6 +2135,8 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \n \tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, class, 1) * scale) / 2;\n \n+\tif (!move_cost[Pmode])\n+\t  init_move_cost (Pmode);\n \tfor (i = 0; i < N_REG_CLASSES; i++)\n \t  pp->cost[i] += (may_move_in_cost[Pmode][i][(int) class] * scale) / 2;\n       }"}]}