{"sha": "03dc44a6145f85805d12f902da4b1c2efb0a44cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkYzQ0YTYxNDVmODU4MDVkMTJmOTAyZGE0YjFjMmVmYjBhNDRjYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-13T20:16:51Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-13T20:16:51Z"}, "message": "(store_constructor): Handle TREE_PURPOSE of array constructor.\n\n(expand_expr, ARRAY_REF case): Likewise.\n\nFrom-SVN: r5315", "tree": {"sha": "7f9c9c553bccba017187671daedee40161a871b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f9c9c553bccba017187671daedee40161a871b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03dc44a6145f85805d12f902da4b1c2efb0a44cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03dc44a6145f85805d12f902da4b1c2efb0a44cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03dc44a6145f85805d12f902da4b1c2efb0a44cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03dc44a6145f85805d12f902da4b1c2efb0a44cc/comments", "author": null, "committer": null, "parents": [{"sha": "3181cbfdd5fddf1d6e5daa2fb48f23e216c08820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3181cbfdd5fddf1d6e5daa2fb48f23e216c08820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3181cbfdd5fddf1d6e5daa2fb48f23e216c08820"}], "stats": {"total": 41, "additions": 32, "deletions": 9}, "files": [{"sha": "c1bd3c0ab44f0551791354685e7f37d0716c8f20", "filename": "gcc/expr.c", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dc44a6145f85805d12f902da4b1c2efb0a44cc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dc44a6145f85805d12f902da4b1c2efb0a44cc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=03dc44a6145f85805d12f902da4b1c2efb0a44cc", "patch": "@@ -2720,19 +2720,41 @@ store_constructor (exp, target)\n \t  int bitsize;\n \t  int bitpos;\n \t  int unsignedp;\n+\t  tree index = TREE_PURPOSE (elt);\n+\t  rtx xtarget = target;\n \n \t  mode = TYPE_MODE (elttype);\n \t  bitsize = GET_MODE_BITSIZE (mode);\n \t  unsignedp = TREE_UNSIGNED (elttype);\n \n-\t  bitpos = (i * TREE_INT_CST_LOW (TYPE_SIZE (elttype)));\n-\n-\t  store_field (target, bitsize, bitpos, mode, TREE_VALUE (elt),\n-\t\t       /* The alignment of TARGET is\n-\t\t\t  at least what its type requires.  */\n-\t\t       VOIDmode, 0,\n-\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT,\n-\t\t       int_size_in_bytes (type));\n+\t  if (index != 0 && TREE_CODE (index) != INTEGER_CST)\n+\t    {\n+\t      /* We don't currently allow variable indices in a\n+\t\t C initializer, but let's try here to support them.  */\n+\t      rtx pos_rtx, addr, xtarget;\n+\t      tree position;\n+\n+\t      position = size_binop (MULT_EXPR, index, TYPE_SIZE (elttype));\n+\t      pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n+\t      addr = gen_rtx (PLUS, Pmode, XEXP (target, 0), pos_rtx);\n+\t      xtarget = change_address (target, mode, addr);\n+\t      store_expr (TREE_VALUE (elt), xtarget, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (index != 0)\n+\t\tbitpos = (TREE_INT_CST_LOW (index)\n+\t\t\t  * TREE_INT_CST_LOW (TYPE_SIZE (elttype)));\n+\t      else\n+\t\tbitpos = (i * TREE_INT_CST_LOW (TYPE_SIZE (elttype)));\n+\n+\t      store_field (xtarget, bitsize, bitpos, mode, TREE_VALUE (elt),\n+\t\t\t   /* The alignment of TARGET is\n+\t\t\t      at least what its type requires.  */\n+\t\t\t   VOIDmode, 0,\n+\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT,\n+\t\t\t   int_size_in_bytes (type));\n+\t    }\n \t}\n     }\n \n@@ -4013,7 +4035,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t  {\n \t\t    tree elem = CONSTRUCTOR_ELTS (init);\n \n-\t\t    while (elem && i--)\n+\t\t    while (elem\n+\t\t\t   && !tree_int_cst_equal (TREE_PURPOSE (elem), index))\n \t\t      elem = TREE_CHAIN (elem);\n \t\t    if (elem)\n \t\t      return expand_expr (fold (TREE_VALUE (elem)), target,"}]}