{"sha": "6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwNGMxN2I0ZDFhMmRkMWUxOTM2YjJlNzA1YTVjY2ZiNmU0OGFiMg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2019-12-10T21:49:55Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2019-12-10T21:49:55Z"}, "message": "libstdc++: Rework std::copy/copy_backward/move/move_backward/fill/fill_n algos\n\nEnhance those algos overloads to generalize existing optimization for\n__gnu_debug::_Safe_iterator w/o _GLIBCXX_DEBUG mode and for std::deque\n iterators.\n\nAlso extend __copy_move_a2 ostreambuf_iterator overloads to std::vector and\nstd::deque iterators.\n\n\t* include/bits/stl_algobase.h\n\t(__copy_move_a1<>(_II, _II, _OI)): New.\n\t(__copy_move_a1<>(_Deque_iterator<>, _Deque_iterator<>, _OI)): New.\n\t(__copy_move_a1<>(_Deque_iterator<>, _Deque_iterator<>,\n\t_Deque_iterator<>)): New.\n\t(__copy_move_a1<>(_II, _II, _Deque_iterator<>)): New.\n\t(__copy_move_a<>(_II, _II, _OI)): Adapt, call __copy_move_a1<>.\n\t(__copy_move_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n\t_OI)): New.\n\t(__copy_move_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n\t const _Safe_iterator<>&)): New.\n\t(__copy_move_a<>(_II, _II, const _Safe_iterator<>&)): New.\n\t(copy, move): Adapt, call __copy_move_a.\n\t(__copy_move_backward_a1<>(_II, _II, _OI)): New,\n\tcall __copy_move_backward_a2.\n\t(__copy_move_backward_a1<>(_Deque_iterator<>, _Deque_iterator<>, _OI)): New.\n\t(__copy_move_backward_a1<>(_Deque_iterator<>, _Deque_iterator<>,\n\t_Deque_iterator<>)): New.\n\t(__copy_move_backward_a1<>(_II, _II, _Deque_iterator<>)): New.\n\t(__copy_move_backward_a<>(_II, _II, _OI)): Adapt, call\n\t__copy_move_backward_a1<>.\n\t(__copy_move_backward_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n\t_OI)): New.\n\t(__copy_move_backward_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n\t const _Safe_iterator<>&)): New.\n\t(__copy_move_backward_a<>(_II, _II, const _Safe_iterator<>&)): New.\n\t(copy_backward, move_backward): Adapt, call __copy_move_backward_a<>.\n\t(__fill_a): Rename into...\n\t(__fill_a1): ... this.\n\t(__fill_a1(__normal_iterator<>, __normal_iterator<>, const _Tp&)): New.\n\t(__fill_a1(const _Deque_iterator<>&, const _Deque_iterator<>&, _VTp)):\n\tNew.\n\t(__fill_a(_FIte, _FIte, const _Tp&)): New, call __fill_a1.\n\t(__fill_a(const _Safe_iterator<>&, const _Safe_iterator<>&,\n\tconst _Tp&)): New.\n\t(fill): Adapt, remove __niter_base usage.\n\t(__fill_n_a): Rename into...\n\t(__fill_n_a1): ...this.\n\t(__fill_n_a(const _Safe_iterator<>&, _Size, const _Tp&,\n\tinput_iterator_tag)): New.\n\t(__fill_n_a(_OI, _Size, const _Tp&, output_iterator_tag)): New, call\n\t__fill_n_a1.\n\t(__fill_n_a(_OI, _Size, const _Tp&, random_access_iterator_tag)): New,\n\tcall __fill_a.\n\t(__equal_aux): Rename into...\n\t(__equal_aux1): ...this.\n\t(__equal_aux1(_Deque_iterator<>, _Deque_iterator<>, _OI)): New.\n\t(__equal_aux1(_Deque_iterator<>, _Deque_iterator<>,\n\t_Deque_iterator<>)): New.\n\t(__equal_aux1(_II, _II, _Deque_iterator<>)): New.\n\t(__equal_aux(_II1, _II1, _II2)): New, call __equal_aux1.\n\t(__equal_aux(const _Safe_iterator<>&, const _Safe_iterator<>&,\n\t_OI)): New.\n\t(__equal_aux(const _Safe_iterator<>&, const _Safe_iterator<>&,\n\t const _Safe_iterator<>&)): New.\n\t(__equal_aux(_II, _II, const _Safe_iterator<>&)): New.\n\t(equal(_II1, _II1, _II2)): Adapt.\n\t* include/bits/stl_deque.h\n\t(fill, copy, copy_backward, move, move_backward): Remove.\n\t* include/bits/deque.tcc: Include <bits/stl_algobase.h>.\n\t(__fill_a1): New.\n\t(__copy_move_dit): New.\n\t(__copy_move_a1): New, use latter.\n\t(__copy_move_a1(_II, _II, _Deque_iterator<>)): New.\n\t(__copy_move_backward_dit): New.\n\t(__copy_move_backward_a1): New, use latter.\n\t(__copy_move_backward_a1(_II, _II, _Deque_iterator<>)): New.\n\t(__equal_dit): New.\n\t(__equal_aux1): New, use latter.\n\t(__equal_aux1(_II, _II, _Deque_iterator<>)): New.\n\t* include/std/numeric (__is_random_access_iter): Move...\n\t* include/bits/stl_iterator_base_types.h (__is_random_access_iter): ...\n\there. Provide pre-C++11 definition.\n\t* include/debug/debug.h (_Safe_iterator<>): New declaration.\n\t* include/debug/safe_iterator.h (_Safe_iterator<>::_M_can_advance): Add\n\t__strict parameter.\n\t* include/debug/safe_iterator.tcc: Include <bits/stl_algobase.h>.\n\t(_Safe_iterator<>::_M_can_advance): Adapt.\n\t(std::__copy_move_a, std::__copy_move_backward_a, __fill_a): New.\n\t(__fill_n_a, __equal_aux): New.\n\t* include/debug/stl_iterator.h (__niter_base): Remove.\n\t* include/debug/vector (__niter_base): Remove.\n\t* testsuite/performance/25_algorithms/copy_backward_deque_iterators.cc:\n\tInclude <vector> and <list>. Add benches.\n\t* testsuite/performance/25_algorithms/copy_deque_iterators.cc: Likewise.\n\t* testsuite/performance/25_algorithms/equal_deque_iterators.cc: Likewise.\n\t* testsuite/25_algorithms/copy/debug/1_neg.cc: New.\n\t* testsuite/25_algorithms/copy/deque_iterators/2.cc: New.\n\t* testsuite/25_algorithms/copy/deque_iterators/31.cc: New.\n\t* testsuite/25_algorithms/copy/deque_iterators/32.cc: New.\n\t* testsuite/25_algorithms/copy/deque_iterators/33.cc: New.\n\t* testsuite/25_algorithms/copy/deque_iterators/41.cc: New.\n\t* testsuite/25_algorithms/copy/deque_iterators/42.cc: New.\n\t* testsuite/25_algorithms/copy/deque_iterators/43.cc: New.\n\t* testsuite/25_algorithms/copy/streambuf_iterators/char/4.cc (test02):\n\tNew.\n\t* testsuite/25_algorithms/copy_backward/deque_iterators/2.cc: New.\n\t* testsuite/25_algorithms/equal/deque_iterators/1.cc: New.\n\t* testsuite/25_algorithms/fill/deque_iterators/1.cc: New.\n\t* testsuite/25_algorithms/move/deque_iterators/2.cc: New.\n\t* testsuite/25_algorithms/move_backward/deque_iterators/2.cc: New.\n\nFrom-SVN: r279201", "tree": {"sha": "5c61e9683f3dcec79f0b97b8dffce41f11ad16a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c61e9683f3dcec79f0b97b8dffce41f11ad16a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/comments", "author": null, "committer": null, "parents": [{"sha": "5e72bcc1dd04034341c93f1cd0b0ac8fdf43e966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e72bcc1dd04034341c93f1cd0b0ac8fdf43e966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e72bcc1dd04034341c93f1cd0b0ac8fdf43e966"}], "stats": {"total": 2247, "additions": 1988, "deletions": 259}, "files": [{"sha": "2b8b9de8e075c5861866d063a5f7f82a5a47a173", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -1,3 +1,107 @@\n+2019-12-10  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/stl_algobase.h\n+\t(__copy_move_a1<>(_II, _II, _OI)): New.\n+\t(__copy_move_a1<>(_Deque_iterator<>, _Deque_iterator<>, _OI)): New.\n+\t(__copy_move_a1<>(_Deque_iterator<>, _Deque_iterator<>,\n+\t_Deque_iterator<>)): New.\n+\t(__copy_move_a1<>(_II, _II, _Deque_iterator<>)): New.\n+\t(__copy_move_a<>(_II, _II, _OI)): Adapt, call __copy_move_a1<>.\n+\t(__copy_move_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n+\t_OI)): New.\n+\t(__copy_move_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n+\t const _Safe_iterator<>&)): New.\n+\t(__copy_move_a<>(_II, _II, const _Safe_iterator<>&)): New.\n+\t(copy, move): Adapt, call __copy_move_a.\n+\t(__copy_move_backward_a1<>(_II, _II, _OI)): New,\n+\tcall __copy_move_backward_a2.\n+\t(__copy_move_backward_a1<>(_Deque_iterator<>, _Deque_iterator<>, _OI)): New.\n+\t(__copy_move_backward_a1<>(_Deque_iterator<>, _Deque_iterator<>,\n+\t_Deque_iterator<>)): New.\n+\t(__copy_move_backward_a1<>(_II, _II, _Deque_iterator<>)): New.\n+\t(__copy_move_backward_a<>(_II, _II, _OI)): Adapt, call\n+\t__copy_move_backward_a1<>.\n+\t(__copy_move_backward_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n+\t_OI)): New.\n+\t(__copy_move_backward_a<>(const _Safe_iterator<>&, const _Safe_iterator<>&,\n+\t const _Safe_iterator<>&)): New.\n+\t(__copy_move_backward_a<>(_II, _II, const _Safe_iterator<>&)): New.\n+\t(copy_backward, move_backward): Adapt, call __copy_move_backward_a<>.\n+\t(__fill_a): Rename into...\n+\t(__fill_a1): ... this.\n+\t(__fill_a1(__normal_iterator<>, __normal_iterator<>, const _Tp&)): New.\n+\t(__fill_a1(const _Deque_iterator<>&, const _Deque_iterator<>&, _VTp)):\n+\tNew.\n+\t(__fill_a(_FIte, _FIte, const _Tp&)): New, call __fill_a1.\n+\t(__fill_a(const _Safe_iterator<>&, const _Safe_iterator<>&,\n+\tconst _Tp&)): New.\n+\t(fill): Adapt, remove __niter_base usage.\n+\t(__fill_n_a): Rename into...\n+\t(__fill_n_a1): ...this.\n+\t(__fill_n_a(const _Safe_iterator<>&, _Size, const _Tp&,\n+\tinput_iterator_tag)): New.\n+\t(__fill_n_a(_OI, _Size, const _Tp&, output_iterator_tag)): New, call\n+\t__fill_n_a1.\n+\t(__fill_n_a(_OI, _Size, const _Tp&, random_access_iterator_tag)): New,\n+\tcall __fill_a.\n+\t(__equal_aux): Rename into...\n+\t(__equal_aux1): ...this.\n+\t(__equal_aux1(_Deque_iterator<>, _Deque_iterator<>, _OI)): New.\n+\t(__equal_aux1(_Deque_iterator<>, _Deque_iterator<>,\n+\t_Deque_iterator<>)): New.\n+\t(__equal_aux1(_II, _II, _Deque_iterator<>)): New.\n+\t(__equal_aux(_II1, _II1, _II2)): New, call __equal_aux1.\n+\t(__equal_aux(const _Safe_iterator<>&, const _Safe_iterator<>&,\n+\t_OI)): New.\n+\t(__equal_aux(const _Safe_iterator<>&, const _Safe_iterator<>&,\n+\t const _Safe_iterator<>&)): New.\n+\t(__equal_aux(_II, _II, const _Safe_iterator<>&)): New.\n+\t(equal(_II1, _II1, _II2)): Adapt.\n+\t* include/bits/stl_deque.h\n+\t(fill, copy, copy_backward, move, move_backward): Remove.\n+\t* include/bits/deque.tcc: Include <bits/stl_algobase.h>.\n+\t(__fill_a1): New.\n+\t(__copy_move_dit): New.\n+\t(__copy_move_a1): New, use latter.\n+\t(__copy_move_a1(_II, _II, _Deque_iterator<>)): New.\n+\t(__copy_move_backward_dit): New.\n+\t(__copy_move_backward_a1): New, use latter.\n+\t(__copy_move_backward_a1(_II, _II, _Deque_iterator<>)): New.\n+\t(__equal_dit): New.\n+\t(__equal_aux1): New, use latter.\n+\t(__equal_aux1(_II, _II, _Deque_iterator<>)): New.\n+\t* include/std/numeric (__is_random_access_iter): Move...\n+\t* include/bits/stl_iterator_base_types.h (__is_random_access_iter): ...\n+\there. Provide pre-C++11 definition.\n+\t* include/debug/debug.h (_Safe_iterator<>): New declaration.\n+\t* include/debug/safe_iterator.h (_Safe_iterator<>::_M_can_advance): Add\n+\t__strict parameter.\n+\t* include/debug/safe_iterator.tcc: Include <bits/stl_algobase.h>.\n+\t(_Safe_iterator<>::_M_can_advance): Adapt.\n+\t(std::__copy_move_a, std::__copy_move_backward_a, __fill_a): New.\n+\t(__fill_n_a, __equal_aux): New.\n+\t* include/debug/stl_iterator.h (__niter_base): Remove.\n+\t* include/debug/vector (__niter_base): Remove.\n+\t* testsuite/performance/25_algorithms/copy_backward_deque_iterators.cc:\n+\tInclude <vector> and <list>. Add benches.\n+\t* testsuite/performance/25_algorithms/copy_deque_iterators.cc: Likewise.\n+\t* testsuite/performance/25_algorithms/equal_deque_iterators.cc: Likewise.\n+\t* testsuite/25_algorithms/copy/debug/1_neg.cc: New.\n+\t* testsuite/25_algorithms/copy/deque_iterators/2.cc: New.\n+\t* testsuite/25_algorithms/copy/deque_iterators/31.cc: New.\n+\t* testsuite/25_algorithms/copy/deque_iterators/32.cc: New.\n+\t* testsuite/25_algorithms/copy/deque_iterators/33.cc: New.\n+\t* testsuite/25_algorithms/copy/deque_iterators/41.cc: New.\n+\t* testsuite/25_algorithms/copy/deque_iterators/42.cc: New.\n+\t* testsuite/25_algorithms/copy/deque_iterators/43.cc: New.\n+\t* testsuite/25_algorithms/copy/streambuf_iterators/char/4.cc (test02):\n+\tNew.\n+\t* testsuite/25_algorithms/copy_backward/deque_iterators/2.cc: New.\n+\t* testsuite/25_algorithms/equal/deque_iterators/1.cc: New.\n+\t* testsuite/25_algorithms/fill/deque_iterators/1.cc: New.\n+\t* testsuite/25_algorithms/move/deque_iterators/2.cc: New.\n+\t* testsuite/25_algorithms/move_backward/deque_iterators/2.cc: New.\n+\n 2019-12-10  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/92886"}, {"sha": "ae5366d620868606521a8998773df70555277a10", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 186, "deletions": 92, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -56,6 +56,8 @@\n #ifndef _DEQUE_TCC\n #define _DEQUE_TCC 1\n \n+#include <bits/stl_algobase.h>\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -967,155 +969,247 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n     }\n \n+_GLIBCXX_END_NAMESPACE_CONTAINER\n+\n   // Overload for deque::iterators, exploiting the \"segmented-iterator\n   // optimization\".\n-  template<typename _Tp>\n+  template<typename _Tp, typename _VTp>\n     void\n-    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,\n-\t const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)\n+    __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>& __first,\n+\t      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>& __last,\n+\t      const _VTp& __value)\n     {\n-      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;\n+      typedef _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;\n+      if (__first._M_node != __last._M_node)\n+\t{\n+\t  std::__fill_a1(__first._M_cur, __first._M_last, __value);\n \n-      for (typename _Self::_Map_pointer __node = __first._M_node + 1;\n-           __node < __last._M_node; ++__node)\n-\tstd::fill(*__node, *__node + _Self::_S_buffer_size(), __value);\n+\t  for (typename _Iter::_Map_pointer __node = __first._M_node + 1;\n+\t       __node < __last._M_node; ++__node)\n+\t    std::__fill_a1(*__node, *__node + _Iter::_S_buffer_size(), __value);\n \n+\t  std::__fill_a1(__last._M_first, __last._M_cur, __value);\n+\t}\n+      else\n+\tstd::__fill_a1(__first._M_cur, __last._M_cur, __value);\n+    }\n+\n+  template<bool _IsMove,\n+\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n+    _OI\n+    __copy_move_dit(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __first,\n+\t\t    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __last,\n+\t\t    _OI __result)\n+    {\n+      typedef _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;\n       if (__first._M_node != __last._M_node)\n \t{\n-\t  std::fill(__first._M_cur, __first._M_last, __value);\n-\t  std::fill(__last._M_first, __last._M_cur, __value);\n+\t  __result\n+\t    = std::__copy_move_a1<_IsMove>(__first._M_cur, __first._M_last,\n+\t\t\t\t\t   __result);\n+\n+\t  for (typename _Iter::_Map_pointer __node = __first._M_node + 1;\n+\t       __node != __last._M_node; ++__node)\n+\t    __result\n+\t      = std::__copy_move_a1<_IsMove>(*__node,\n+\t\t\t\t\t     *__node + _Iter::_S_buffer_size(),\n+\t\t\t\t\t     __result);\n+\n+\t  return std::__copy_move_a1<_IsMove>(__last._M_first, __last._M_cur,\n+\t\t\t\t\t      __result);\n \t}\n-      else\n-\tstd::fill(__first._M_cur, __last._M_cur, __value);\n+\n+      return std::__copy_move_a1<_IsMove>(__first._M_cur, __last._M_cur,\n+\t\t\t\t\t  __result);\n     }\n \n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n-\t _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n+  template<bool _IsMove,\n+\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n+    _OI\n+    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __first,\n+\t\t   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __last,\n+\t\t   _OI __result)\n+    { return __copy_move_dit<_IsMove>(__first, __last, __result); }\n+\n+  template<bool _IsMove,\n+\t   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>\n+    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>\n+    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr> __first,\n+\t\t   _GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr> __last,\n+\t\t   _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*> __result)\n+    { return __copy_move_dit<_IsMove>(__first, __last, __result); }\n+\n+  template<bool _IsMove, typename _II, typename _Tp>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value,\n+      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type\n+    __copy_move_a1(_II __first, _II __last,\n+\t\t   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n     {\n-      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;\n-      typedef typename _Self::difference_type difference_type;\n+      typedef _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;\n+      typedef typename _Iter::difference_type difference_type;\n \n       difference_type __len = __last - __first;\n       while (__len > 0)\n \t{\n \t  const difference_type __clen\n-\t    = std::min(__len, std::min(__first._M_last - __first._M_cur,\n-\t\t\t\t       __result._M_last - __result._M_cur));\n-\t  std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);\n+\t    = std::min(__len, __result._M_last - __result._M_cur);\n+\t  std::__copy_move_a1<_IsMove>(__first, __first + __clen,\n+\t\t\t\t       __result._M_cur);\n+\n \t  __first += __clen;\n \t  __result += __clen;\n \t  __len -= __clen;\n \t}\n+\n       return __result;\n     }\n \n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n-\t\t  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n+  template<bool _IsMove,\n+\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n+    _OI\n+    __copy_move_backward_dit(\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __first,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __last,\n+\t\t_OI __result)\n+    {\n+      typedef _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;\n+      if (__first._M_node != __last._M_node)\n+\t{\n+\t  __result = std::__copy_move_backward_a1<_IsMove>(\n+\t\t__last._M_first, __last._M_cur, __result);\n+\n+\t  for (typename _Iter::_Map_pointer __node = __last._M_node - 1;\n+\t       __node != __first._M_node; --__node)\n+\t    __result = std::__copy_move_backward_a1<_IsMove>(\n+\t\t*__node, *__node + _Iter::_S_buffer_size(), __result);\n+\n+\t  return std::__copy_move_backward_a1<_IsMove>(\n+\t\t\t__first._M_cur, __first._M_last, __result);\n+\t}\n+\n+      return std::__copy_move_backward_a1<_IsMove>(\n+\t\t__first._M_cur, __last._M_cur, __result);\n+    }\n+\n+  template<bool _IsMove,\n+\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n+    _OI\n+    __copy_move_backward_a1(\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __first,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __last,\n+\t\t_OI __result)\n+    { return __copy_move_backward_dit<_IsMove>(__first, __last, __result); }\n+\n+  template<bool _IsMove,\n+\t   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>\n+    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>\n+    __copy_move_backward_a1(\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr> __first,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr> __last,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*> __result)\n+    { return __copy_move_backward_dit<_IsMove>(__first, __last, __result); }\n+\n+  template<bool _IsMove, typename _II, typename _Tp>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value,\n+      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type\n+    __copy_move_backward_a1(_II __first, _II __last,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n     {\n-      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;\n-      typedef typename _Self::difference_type difference_type;\n+      typedef _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;\n+      typedef typename _Iter::difference_type difference_type;\n \n       difference_type __len = __last - __first;\n       while (__len > 0)\n \t{\n-\t  difference_type __llen = __last._M_cur - __last._M_first;\n-\t  _Tp* __lend = __last._M_cur;\n-\n \t  difference_type __rlen = __result._M_cur - __result._M_first;\n \t  _Tp* __rend = __result._M_cur;\n-\n-\t  if (!__llen)\n-\t    {\n-\t      __llen = _Self::_S_buffer_size();\n-\t      __lend = *(__last._M_node - 1) + __llen;\n-\t    }\n \t  if (!__rlen)\n \t    {\n-\t      __rlen = _Self::_S_buffer_size();\n+\t      __rlen = _Iter::_S_buffer_size();\n \t      __rend = *(__result._M_node - 1) + __rlen;\n \t    }\n \n-\t  const difference_type __clen = std::min(__len,\n-\t\t\t\t\t\t  std::min(__llen, __rlen));\n-\t  std::copy_backward(__lend - __clen, __lend, __rend);\n+\t  const difference_type __clen = std::min(__len, __rlen);\n+\t  std::__copy_move_backward_a1<_IsMove>(__last - __clen, __last, __rend);\n+\n \t  __last -= __clen;\n \t  __result -= __clen;\n \t  __len -= __clen;\n \t}\n+\n       return __result;\n     }\n \n-#if __cplusplus >= 201103L\n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n-\t _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n+  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>\n+    bool\n+    __equal_dit(\n+\tconst _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>& __first1,\n+\tconst _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>& __last1,\n+\t_II __first2)\n     {\n-      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;\n-      typedef typename _Self::difference_type difference_type;\n-\n-      difference_type __len = __last - __first;\n-      while (__len > 0)\n+      typedef _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;\n+      if (__first1._M_node != __last1._M_node)\n \t{\n-\t  const difference_type __clen\n-\t    = std::min(__len, std::min(__first._M_last - __first._M_cur,\n-\t\t\t\t       __result._M_last - __result._M_cur));\n-\t  std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);\n-\t  __first += __clen;\n-\t  __result += __clen;\n-\t  __len -= __clen;\n+\t  if (!std::__equal_aux1(__first1._M_cur, __first1._M_last, __first2))\n+\t    return false;\n+\n+\t  __first2 += __first1._M_last - __first1._M_cur;\n+\t  for (typename _Iter::_Map_pointer __node = __first1._M_node + 1;\n+\t       __node != __last1._M_node;\n+\t       __first2 += _Iter::_S_buffer_size(), ++__node)\n+\t    if (!std::__equal_aux1(*__node, *__node + _Iter::_S_buffer_size(),\n+\t\t\t\t  __first2))\n+\t      return false;\n+\n+\t  return std::__equal_aux1(__last1._M_first, __last1._M_cur, __first2);\n \t}\n-      return __result;\n+\n+      return std::__equal_aux1(__first1._M_cur, __last1._M_cur, __first2);\n     }\n \n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n-\t\t  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n+  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value, bool>::__type\n+    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __first1,\n+\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __last1,\n+\t\t _II __first2)\n+    { return std::__equal_dit(__first1, __last1, __first2); }\n+\n+  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n+\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n+    bool\n+    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __first1,\n+\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __last1,\n+\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __first2)\n+    { return std::__equal_dit(__first1, __last1, __first2); }\n+\n+  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value, bool>::__type\n+    __equal_aux1(_II __first1, _II __last1,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> __first2)\n     {\n-      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;\n-      typedef typename _Self::difference_type difference_type;\n+      typedef _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;\n+      typedef typename _Iter::difference_type difference_type;\n \n-      difference_type __len = __last - __first;\n+      difference_type __len = __last1 - __first1;\n       while (__len > 0)\n \t{\n-\t  difference_type __llen = __last._M_cur - __last._M_first;\n-\t  _Tp* __lend = __last._M_cur;\n-\n-\t  difference_type __rlen = __result._M_cur - __result._M_first;\n-\t  _Tp* __rend = __result._M_cur;\n-\n-\t  if (!__llen)\n-\t    {\n-\t      __llen = _Self::_S_buffer_size();\n-\t      __lend = *(__last._M_node - 1) + __llen;\n-\t    }\n-\t  if (!__rlen)\n-\t    {\n-\t      __rlen = _Self::_S_buffer_size();\n-\t      __rend = *(__result._M_node - 1) + __rlen;\n-\t    }\n+\t  const difference_type __clen\n+\t    = std::min(__len, __first2._M_last - __first2._M_cur);\n+\t  if (!std::__equal_aux1(__first1, __first1 + __clen, __first2._M_cur))\n+\t    return false;\n \n-\t  const difference_type __clen = std::min(__len,\n-\t\t\t\t\t\t  std::min(__llen, __rlen));\n-\t  std::move_backward(__lend - __clen, __lend, __rend);\n-\t  __last -= __clen;\n-\t  __result -= __clen;\n+\t  __first1 += __clen;\n \t  __len -= __clen;\n+\t  __first2 += __clen;\n \t}\n-      return __result;\n+\n+      return true;\n     }\n-#endif\n \n-_GLIBCXX_END_NAMESPACE_CONTAINER\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "40d056ae8d58aa74c20f58e43059ef45dbcbd3b6", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 265, "deletions": 58, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -454,22 +454,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     };\n \n-  template<bool _IsMove, typename _II, typename _OI>\n-    _GLIBCXX20_CONSTEXPR\n-    inline _OI\n-    __copy_move_a(_II __first, _II __last, _OI __result)\n-    {\n-      typedef typename iterator_traits<_II>::value_type _ValueTypeI;\n-      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;\n-      typedef typename iterator_traits<_II>::iterator_category _Category;\n-      const bool __simple = (__is_trivially_copyable(_ValueTypeI)\n-\t\t\t     && __is_pointer<_II>::__value\n-\t\t\t     && __is_pointer<_OI>::__value\n-\t\t\t     && __are_same<_ValueTypeI, _ValueTypeO>::__value);\n-      return std::__copy_move<_IsMove, __simple,\n-\t\t\t      _Category>::__copy_m(__first, __last, __result);\n-    }\n-\n   // Helpers for streambuf iterators (either istream or ostream).\n   // NB: avoid including <iosfwd>, relatively large.\n   template<typename _CharT>\n@@ -503,13 +487,83 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX20_CONSTEXPR\n     inline _OI\n     __copy_move_a2(_II __first, _II __last, _OI __result)\n+    {\n+      typedef typename iterator_traits<_II>::value_type _ValueTypeI;\n+      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;\n+      typedef typename iterator_traits<_II>::iterator_category _Category;\n+      const bool __simple = (__is_trivially_copyable(_ValueTypeI)\n+\t\t\t     && __is_pointer<_II>::__value\n+\t\t\t     && __is_pointer<_OI>::__value\n+\t\t\t     && __are_same<_ValueTypeI, _ValueTypeO>::__value);\n+      return std::__copy_move<_IsMove, __simple,\n+\t\t\t      _Category>::__copy_m(__first, __last, __result);\n+    }\n+\n+_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n+\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n+    struct _Deque_iterator;\n+\n+_GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+  template<bool _IsMove,\n+\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n+    _OI\n+    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n+\t\t   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n+\t\t   _OI);\n+\n+  template<bool _IsMove,\n+\t   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>\n+    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>\n+    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n+\t\t   _GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n+\t\t   _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);\n+\n+  template<bool _IsMove, typename _II, typename _Tp>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value,\n+      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type\n+    __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);\n+\n+  template<bool _IsMove, typename _II, typename _OI>\n+    _GLIBCXX20_CONSTEXPR\n+    inline _OI\n+    __copy_move_a1(_II __first, _II __last, _OI __result)\n+    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }\n+\n+  template<bool _IsMove, typename _II, typename _OI>\n+    _GLIBCXX20_CONSTEXPR\n+    inline _OI\n+    __copy_move_a(_II __first, _II __last, _OI __result)\n     {\n       return std::__niter_wrap(__result,\n-\t\tstd::__copy_move_a<_IsMove>(std::__niter_base(__first),\n-\t\t\t\t\t    std::__niter_base(__last),\n-\t\t\t\t\t    std::__niter_base(__result)));\n+\t\tstd::__copy_move_a1<_IsMove>(std::__niter_base(__first),\n+\t\t\t\t\t     std::__niter_base(__last),\n+\t\t\t\t\t     std::__niter_base(__result)));\n     }\n \n+  template<bool _IsMove,\n+\t   typename _Ite, typename _Seq, typename _Cat, typename _OI>\n+    _OI\n+    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n+\t\t  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n+\t\t  _OI);\n+\n+  template<bool _IsMove,\n+\t   typename _II, typename _Ite, typename _Seq, typename _Cat>\n+    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n+    __copy_move_a(_II, _II,\n+\t\t  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);\n+\n+  template<bool _IsMove,\n+\t   typename _IIte, typename _ISeq, typename _ICat,\n+\t   typename _OIte, typename _OSeq, typename _OCat>\n+    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>\n+    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n+\t\t  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n+\t\t  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);\n+\n   /**\n    *  @brief Copies the range [first,last) into result.\n    *  @ingroup mutating_algorithms\n@@ -538,7 +592,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    typename iterator_traits<_II>::value_type>)\n       __glibcxx_requires_can_increment_range(__first, __last, __result);\n \n-      return std::__copy_move_a2<__is_move_iterator<_II>::__value>\n+      return std::__copy_move_a<__is_move_iterator<_II>::__value>\n \t     (std::__miter_base(__first), std::__miter_base(__last), __result);\n     }\n \n@@ -571,16 +625,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    typename iterator_traits<_II>::value_type>)\n       __glibcxx_requires_can_increment_range(__first, __last, __result);\n \n-      return std::__copy_move_a2<true>(std::__miter_base(__first),\n-\t\t\t\t       std::__miter_base(__last), __result);\n+      return std::__copy_move_a<true>(std::__miter_base(__first),\n+\t\t\t\t      std::__miter_base(__last), __result);\n     }\n \n #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)\n #else\n #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)\n #endif\n \n-  template<bool, bool, typename>\n+  template<bool _IsMove, bool _IsSimple, typename _Category>\n     struct __copy_move_backward\n     {\n       template<typename _BI1, typename _BI2>\n@@ -669,7 +723,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<bool _IsMove, typename _BI1, typename _BI2>\n     _GLIBCXX20_CONSTEXPR\n     inline _BI2\n-    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)\n+    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)\n     {\n       typedef typename iterator_traits<_BI1>::value_type _ValueType1;\n       typedef typename iterator_traits<_BI2>::value_type _ValueType2;\n@@ -694,14 +748,65 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<bool _IsMove, typename _BI1, typename _BI2>\n     _GLIBCXX20_CONSTEXPR\n     inline _BI2\n-    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)\n+    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)\n+    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }\n+\n+  template<bool _IsMove,\n+\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n+    _OI\n+    __copy_move_backward_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n+\t\t\t    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n+\t\t\t    _OI);\n+\n+  template<bool _IsMove,\n+\t   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>\n+    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>\n+    __copy_move_backward_a1(\n+\t\t\t_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n+\t\t\t_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n+\t\t\t_GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);\n+\n+  template<bool _IsMove, typename _II, typename _Tp>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value,\n+      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type\n+    __copy_move_backward_a1(_II, _II,\n+\t\t\t    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);\n+\n+  template<bool _IsMove, typename _II, typename _OI>\n+    _GLIBCXX20_CONSTEXPR\n+    inline _OI\n+    __copy_move_backward_a(_II __first, _II __last, _OI __result)\n     {\n       return std::__niter_wrap(__result,\n-\t\tstd::__copy_move_backward_a<_IsMove>\n+\t\tstd::__copy_move_backward_a1<_IsMove>\n \t\t  (std::__niter_base(__first), std::__niter_base(__last),\n \t\t   std::__niter_base(__result)));\n     }\n \n+  template<bool _IsMove,\n+\t   typename _Ite, typename _Seq, typename _Cat, typename _OI>\n+    _OI\n+    __copy_move_backward_a(\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n+\t\t_OI);\n+\n+  template<bool _IsMove,\n+\t   typename _II, typename _Ite, typename _Seq, typename _Cat>\n+    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n+    __copy_move_backward_a(_II, _II,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);\n+\n+  template<bool _IsMove,\n+\t   typename _IIte, typename _ISeq, typename _ICat,\n+\t   typename _OIte, typename _OSeq, typename _OCat>\n+    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>\n+    __copy_move_backward_a(\n+\t\tconst ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);\n+\n   /**\n    *  @brief Copies the range [first,last) into result.\n    *  @ingroup mutating_algorithms\n@@ -733,7 +838,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    typename iterator_traits<_BI2>::value_type>)\n       __glibcxx_requires_can_decrement_range(__first, __last, __result);\n \n-      return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>\n+      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>\n \t     (std::__miter_base(__first), std::__miter_base(__last), __result);\n     }\n \n@@ -769,9 +874,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    typename iterator_traits<_BI2>::value_type>)\n       __glibcxx_requires_can_decrement_range(__first, __last, __result);\n \n-      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),\n-\t\t\t\t\t\tstd::__miter_base(__last),\n-\t\t\t\t\t\t__result);\n+      return std::__copy_move_backward_a<true>(std::__miter_base(__first),\n+\t\t\t\t\t       std::__miter_base(__last),\n+\t\t\t\t\t       __result);\n     }\n \n #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)\n@@ -783,8 +888,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX20_CONSTEXPR\n     inline typename\n     __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type\n-    __fill_a(_ForwardIterator __first, _ForwardIterator __last,\n- \t     const _Tp& __value)\n+    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,\n+\t      const _Tp& __value)\n     {\n       for (; __first != __last; ++__first)\n \t*__first = __value;\n@@ -794,8 +899,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX20_CONSTEXPR\n     inline typename\n     __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type\n-    __fill_a(_ForwardIterator __first, _ForwardIterator __last,\n-\t     const _Tp& __value)\n+    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,\n+\t      const _Tp& __value)\n     {\n       const _Tp __tmp = __value;\n       for (; __first != __last; ++__first)\n@@ -806,13 +911,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     inline typename\n     __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type\n-    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)\n+    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)\n     {\n       const _Tp __tmp = __c;\n       if (const size_t __len = __last - __first)\n \t__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);\n     }\n \n+  template<typename _Ite, typename _Cont, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n+    inline void\n+    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,\n+\t      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,\n+\t      const _Tp& __value)\n+    { std::__fill_a1(__first.base(), __last.base(), __value); }\n+\n+  template<typename _Tp, typename _VTp>\n+    void\n+    __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,\n+\t      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,\n+\t      const _VTp&);\n+\n+  template<typename _FIte, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n+    inline void\n+    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)\n+    { std::__fill_a1(__first, __last, __value); }\n+\n+  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>\n+    void\n+    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n+\t     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n+\t     const _Tp&);\n+\n   /**\n    *  @brief Fills the range [first,last) with copies of value.\n    *  @ingroup mutating_algorithms\n@@ -835,8 +966,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t  _ForwardIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),\n-\t\t    __value);\n+      std::__fill_a(__first, __last, __value);\n     }\n \n   // Used by fill_n, generate_n, etc. to convert _Size to an integral type:\n@@ -893,11 +1023,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX20_CONSTEXPR\n     inline typename\n     __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type\n-    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)\n+    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)\n     {\n-#if __cplusplus >= 201103L\n-      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n-#endif\n       for (; __n > 0; --__n, (void) ++__first)\n \t*__first = __value;\n       return __first;\n@@ -907,24 +1034,60 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX20_CONSTEXPR\n     inline typename\n     __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type\n-    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)\n+    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)\n     {\n-#if __cplusplus >= 201103L\n-      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n-#endif\n       const _Tp __tmp = __value;\n       for (; __n > 0; --__n, (void) ++__first)\n \t*__first = __tmp;\n       return __first;\n     }\n \n-  template<typename _Size, typename _Tp>\n+  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,\n+\t   typename _Tp>\n+    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n+    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,\n+\t       _Size __n, const _Tp& __value,\n+\t       std::input_iterator_tag);\n+\n+  template<typename _OutputIterator, typename _Size, typename _Tp>\n     _GLIBCXX20_CONSTEXPR\n-    inline typename\n-    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type\n-    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)\n+    inline _OutputIterator\n+    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,\n+\t       std::output_iterator_tag)\n+    {\n+#if __cplusplus >= 201103L\n+      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n+#endif\n+      return __fill_n_a1(__first, __n, __value);\n+    }\n+\n+  template<typename _OutputIterator, typename _Size, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n+    inline _OutputIterator\n+    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,\n+\t       std::input_iterator_tag)\n+    {\n+#if __cplusplus >= 201103L\n+      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n+#endif\n+      return __fill_n_a1(__first, __n, __value);\n+    }\n+\n+  template<typename _OutputIterator, typename _Size, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n+    inline _OutputIterator\n+    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,\n+\t       std::random_access_iterator_tag)\n     {\n-      std::__fill_a(__first, __first + __n, __c);\n+#if __cplusplus >= 201103L\n+      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n+#endif\n+      if (__n <= 0)\n+\treturn __first;\n+\n+      __glibcxx_requires_can_increment(__first, __n);\n+\n+      std::__fill_a(__first, __first + __n, __value);\n       return __first + __n;\n     }\n \n@@ -953,10 +1116,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // concept requirements\n       __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)\n \n-      return std::__niter_wrap(__first,\n-\t  std::__fill_n_a(std::__niter_base(__first),\n-\t\t\t  std::__size_to_integer(__n),\n-\t\t\t  __value));\n+      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,\n+\t\t\t       std::__iterator_category(__first));\n     }\n \n   template<bool _BoolType>\n@@ -988,10 +1149,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     };\n \n+  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value, bool>::__type\n+    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n+\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n+\t\t _II);\n+\n+  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n+\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n+    bool\n+    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n+\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n+\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);\n+\n+  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>\n+    typename __gnu_cxx::__enable_if<\n+      __is_random_access_iter<_II>::__value, bool>::__type\n+    __equal_aux1(_II, _II,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>);\n+\n   template<typename _II1, typename _II2>\n     _GLIBCXX20_CONSTEXPR\n     inline bool\n-    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)\n+    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)\n     {\n       typedef typename iterator_traits<_II1>::value_type _ValueType1;\n       typedef typename iterator_traits<_II2>::value_type _ValueType2;\n@@ -1004,6 +1185,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return std::__equal<__simple>::equal(__first1, __last1, __first2);\n     }\n \n+  template<typename _II1, typename _II2>\n+    _GLIBCXX20_CONSTEXPR\n+    inline bool\n+    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)\n+    {\n+      return std::__equal_aux1(std::__niter_base(__first1),\n+\t\t\t       std::__niter_base(__last1),\n+\t\t\t       std::__niter_base(__first2));\n+    }\n+\n+  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>\n+    bool\n+    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n+\t\t_II2);\n+\n+  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>\n+    bool\n+    __equal_aux(_II1, _II1,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);\n+\n+  template<typename _II1, typename _Seq1, typename _Cat1,\n+\t   typename _II2, typename _Seq2, typename _Cat2>\n+    bool\n+    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);\n+\n   template<typename, typename>\n     struct __lc_rai\n     {\n@@ -1230,9 +1439,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n \t    typename iterator_traits<_II2>::value_type>)\n       __glibcxx_requires_can_increment_range(__first1, __last1, __first2);\n \n-      return std::__equal_aux(std::__niter_base(__first1),\n-\t\t\t      std::__niter_base(__last1),\n-\t\t\t      std::__niter_base(__first2));\n+      return std::__equal_aux(__first1, __last1, __first2);\n     }\n \n   /**"}, {"sha": "dcb68da4b618d16a3c24ed8b38775eac8ab198f9", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -373,77 +373,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return __x + __n; }\n     };\n \n-  template<typename _Tp>\n-    void\n-    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,\n-\t const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);\n-\n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*>);\n-\n-  template<typename _Tp>\n-    inline _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n-    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),\n-\t\t       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),\n-\t\t       __result); }\n-\n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t\t  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*>);\n-\n-  template<typename _Tp>\n-    inline _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n-    { return std::copy_backward(_Deque_iterator<_Tp,\n-\t\t\t\tconst _Tp&, const _Tp*>(__first),\n-\t\t\t\t_Deque_iterator<_Tp,\n-\t\t\t\tconst _Tp&, const _Tp*>(__last),\n-\t\t\t\t__result); }\n-\n-#if __cplusplus >= 201103L\n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*>);\n-\n-  template<typename _Tp>\n-    inline _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n-\t _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n-    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),\n-\t\t       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),\n-\t\t       __result); }\n-\n-  template<typename _Tp>\n-    _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t\t  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*>);\n-\n-  template<typename _Tp>\n-    inline _Deque_iterator<_Tp, _Tp&, _Tp*>\n-    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n-\t\t  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n-    { return std::move_backward(_Deque_iterator<_Tp,\n-\t\t\t\tconst _Tp&, const _Tp*>(__first),\n-\t\t\t\t_Deque_iterator<_Tp,\n-\t\t\t\tconst _Tp&, const _Tp*>(__last),\n-\t\t\t\t__result); }\n-#endif\n-\n   /**\n    *  Deque base class.  This class provides the unified face for %deque's\n    *  allocation.  This class's constructor and destructor allocate and"}, {"sha": "b29a76543f4ea0fe86e6a0348ea9dfa46d799be3", "filename": "libstdc++-v3/include/bits/stl_iterator_base_types.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -249,10 +249,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using _RequireInputIter =\n       __enable_if_t<is_convertible<__iterator_category_t<_InIter>,\n \t\t\t\t   input_iterator_tag>::value>;\n+\n+  template<typename _It,\n+\t   typename _Cat = __iterator_category_t<_It>>\n+    struct __is_random_access_iter\n+      : is_base_of<random_access_iterator_tag, _Cat>\n+    {\n+      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;\n+      enum { __value = _Base::value };\n+    };\n+#else\n+  template<typename _It, typename _Traits = iterator_traits<_It>,\n+\t   typename _Cat = typename _Traits::iterator_category>\n+    struct __is_random_access_iter\n+    { enum { __value = __is_base_of(random_access_iterator_tag, _Cat) }; };\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n \n #endif /* _STL_ITERATOR_BASE_TYPES_H */\n-"}, {"sha": "8d3a8606ccd0145f63bfac8dd45853bf25681aa5", "filename": "libstdc++-v3/include/debug/debug.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -56,6 +56,9 @@ namespace std\n namespace __gnu_debug\n {\n   using namespace std::__debug;\n+\n+  template<typename _Ite, typename _Seq, typename _Cat>\n+    struct _Safe_iterator;\n }\n \n #ifndef _GLIBCXX_DEBUG"}, {"sha": "536690d6dcd2cddf49ca972596730a1f393e8866", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -400,7 +400,7 @@ namespace __gnu_debug\n \n       // Can we advance the iterator @p __n steps (@p __n may be negative)\n       bool\n-      _M_can_advance(difference_type __n) const;\n+      _M_can_advance(difference_type __n, bool __strict = false) const;\n \n       // Is the iterator range [*this, __rhs) valid?\n       bool"}, {"sha": "1d98a882d56aaeed702bfdc35da90d6531fbee76", "filename": "libstdc++-v3/include/debug/safe_iterator.tcc", "status": "modified", "additions": 246, "deletions": 7, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -29,6 +29,8 @@\n #ifndef _GLIBCXX_DEBUG_SAFE_ITERATOR_TCC\n #define _GLIBCXX_DEBUG_SAFE_ITERATOR_TCC 1\n \n+#include <bits/stl_algobase.h>\n+\n namespace __gnu_debug\n {\n   template<typename _Iterator, typename _Sequence, typename _Category>\n@@ -82,7 +84,7 @@ namespace __gnu_debug\n   template<typename _Iterator, typename _Sequence, typename _Category>\n     bool\n     _Safe_iterator<_Iterator, _Sequence, _Category>::\n-    _M_can_advance(difference_type __n) const\n+    _M_can_advance(difference_type __n, bool __strict) const\n     {\n       if (this->_M_singular())\n \treturn false;\n@@ -94,17 +96,17 @@ namespace __gnu_debug\n \t{\n \t  std::pair<difference_type, _Distance_precision> __dist =\n \t    _M_get_distance_from_begin();\n-\t  bool __ok =  ((__dist.second == __dp_exact && __dist.first >= -__n)\n-\t\t\t|| (__dist.second != __dp_exact && __dist.first > 0));\n-\t  return __ok;\n+\t  return __dist.second == __dp_exact\n+\t    ? __dist.first >= -__n\n+\t    : !__strict && __dist.first > 0;\n \t}\n       else\n \t{\n \t  std::pair<difference_type, _Distance_precision> __dist =\n \t    _M_get_distance_to_end();\n-\t  bool __ok = ((__dist.second == __dp_exact && __dist.first >= __n)\n-\t\t       || (__dist.second != __dp_exact && __dist.first > 0));\n-\t  return __ok;\n+\t  return __dist.second == __dp_exact\n+\t    ? __dist.first >= __n\n+\t    : !__strict && __dist.first > 0;\n \t}\n     }\n \n@@ -228,4 +230,241 @@ namespace __gnu_debug\n     }\n } // namespace __gnu_debug\n \n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<bool _IsMove,\n+\t   typename _Ite, typename _Seq, typename _Cat, typename _OI>\n+    _OI\n+    __copy_move_a(\n+      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,\n+      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __last,\n+      _OI __result)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_Ite>::__type __dist;\n+      __glibcxx_check_valid_range2(__first, __last, __dist);\n+      __glibcxx_check_can_increment(__result, __dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_equality)\n+\treturn std::__copy_move_a<_IsMove>(__first.base(), __last.base(),\n+\t\t\t\t\t   __result);\n+\n+      return std::__copy_move_a1<_IsMove>(__first, __last, __result);\n+    }\n+\n+  template<bool _IsMove,\n+\t   typename _II, typename _Ite, typename _Seq, typename _Cat>\n+    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n+    __copy_move_a(_II __first, _II __last,\n+      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __result)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_II>::__type __dist;\n+      __glibcxx_check_valid_range2(__first, __last, __dist);\n+      __glibcxx_check_can_increment(__result, __dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_sign\n+\t  && __result._M_can_advance(__dist.first, true))\n+\treturn ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>(\n+\t\tstd::__copy_move_a<_IsMove>(__first, __last, __result.base()),\n+\t\t__result._M_sequence);\n+\n+      return std::__copy_move_a1<_IsMove>(__first, __last, __result);\n+    }\n+\n+  template<bool _IsMove,\n+\t   typename _IIte, typename _ISeq, typename _ICat,\n+\t   typename _OIte, typename _OSeq, typename _OCat>\n+    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>\n+    __copy_move_a(\n+      const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>& __first,\n+      const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>& __last,\n+      const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>& __result)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_IIte>::__type __dist;\n+      __glibcxx_check_valid_range2(__first, __last, __dist);\n+      __glibcxx_check_can_increment(__result, __dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_equality)\n+\t{\n+\t  if (__dist.second > ::__gnu_debug::__dp_sign\n+\t      && __result._M_can_advance(__dist.first, true))\n+\t    return ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>(\n+\t      std::__copy_move_a<_IsMove>(__first.base(), __last.base(),\n+\t\t\t\t\t  __result.base()),\n+\t      __result._M_sequence);\n+\n+\t  return std::__copy_move_a<_IsMove>(__first.base(), __last.base(),\n+\t\t\t\t\t     __result);\n+\t}\n+\n+      return std::__copy_move_a1<_IsMove>(__first, __last, __result);\n+    }\n+\n+  template<bool _IsMove,\n+\t   typename _Ite, typename _Seq, typename _Cat, typename _OI>\n+    _OI\n+    __copy_move_backward_a(\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __last,\n+\t\t_OI __result)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_Ite>::__type __dist;\n+      __glibcxx_check_valid_range2(__first, __last, __dist);\n+      __glibcxx_check_can_increment(__result, -__dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_equality)\n+\treturn std::__copy_move_backward_a<_IsMove>(\n+\t\t__first.base(), __last.base(), __result);\n+\n+      return std::__copy_move_backward_a1<_IsMove>(__first, __last, __result);\n+    }\n+\n+  template<bool _IsMove,\n+\t   typename _II, typename _Ite, typename _Seq, typename _Cat>\n+    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n+    __copy_move_backward_a(_II __first, _II __last,\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __result)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_II>::__type __dist;\n+      __glibcxx_check_valid_range2(__first, __last, __dist);\n+      __glibcxx_check_can_increment(__result, -__dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_sign\n+\t  && __result._M_can_advance(-__dist.first, true))\n+\treturn ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>(\n+\t\tstd::__copy_move_backward_a<_IsMove>(__first, __last,\n+\t\t\t\t\t\t     __result.base()),\n+\t\t__result._M_sequence);\n+\n+      return std::__copy_move_backward_a1<_IsMove>(__first, __last, __result);\n+    }\n+\n+  template<bool _IsMove,\n+\t   typename _IIte, typename _ISeq, typename _ICat,\n+\t   typename _OIte, typename _OSeq, typename _OCat>\n+    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>\n+    __copy_move_backward_a(\n+\tconst ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>& __first,\n+\tconst ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>& __last,\n+\tconst ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>& __result)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_IIte>::__type __dist;\n+      __glibcxx_check_valid_range2(__first, __last, __dist);\n+      __glibcxx_check_can_increment(__result, -__dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_equality)\n+\t{\n+\t  if (__dist.second > ::__gnu_debug::__dp_sign\n+\t      && __result._M_can_advance(-__dist.first, true))\n+\t    return ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>(\n+\t      std::__copy_move_backward_a<_IsMove>(__first.base(), __last.base(),\n+\t\t\t\t\t\t   __result.base()),\n+\t      __result._M_sequence);\n+\n+\t  return std::__copy_move_backward_a<_IsMove>(\n+\t    __first.base(), __last.base(), __result);\n+\t}\n+\n+      return std::__copy_move_backward_a1<_IsMove>(__first, __last, __result);\n+    }\n+\n+  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>\n+    void\n+    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,\n+\t     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __last,\n+\t     const _Tp& __value)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_Ite>::__type __dist;\n+      __glibcxx_check_valid_range2(__first, __last, __dist);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_equality)\n+\tstd::__fill_a(__first.base(), __last.base(), __value);\n+\n+      std::__fill_a1(__first, __last, __value);\n+    }\n+\n+  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,\n+\t   typename _Tp>\n+    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n+    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,\n+\t       _Size __n, const _Tp& __value,\n+\t       std::input_iterator_tag)\n+    {\n+#if __cplusplus >= 201103L\n+      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n+#endif\n+\n+      if (__n <= 0)\n+\treturn __first;\n+\n+      __glibcxx_check_can_increment(__first, __n);\n+      if (__first._M_can_advance(__n, true))\n+\treturn ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>(\n+\t\tstd::__fill_n_a(__first.base(), __n, __value, _Cat()),\n+\t\t__first._M_sequence);\n+\n+      return std::__fill_n_a1(__first, __n, __value);\n+    }\n+\n+  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>\n+    bool\n+    __equal_aux(\n+\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>& __first1,\n+\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>& __last1,\n+\t_II2 __first2)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;\n+      __glibcxx_check_valid_range2(__first1, __last1, __dist);\n+      __glibcxx_check_can_increment(__first2, __dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_equality)\n+\treturn std::__equal_aux(__first1.base(), __last1.base(), __first2);\n+\n+      return std::__equal_aux1(__first1, __last1, __first2);\n+    }\n+\n+  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>\n+    bool\n+    __equal_aux(_II1 __first1, _II1 __last1,\n+\tconst ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>& __first2)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;\n+      __glibcxx_check_valid_range2(__first1, __last1, __dist);\n+      __glibcxx_check_can_increment(__first2, __dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_sign\n+\t  && __first2._M_can_advance(__dist.first, true))\n+\treturn std::__equal_aux(__first1, __last1, __first2.base());\n+\n+      return std::__equal_aux1(__first1, __last1, __first2);\n+    }\n+\n+  template<typename _II1, typename _Seq1, typename _Cat1,\n+\t   typename _II2, typename _Seq2, typename _Cat2>\n+    bool\n+    __equal_aux(\n+\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>& __first1,\n+\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>& __last1,\n+\tconst ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>& __first2)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist;\n+      __glibcxx_check_valid_range2(__first1, __last1, __dist);\n+      __glibcxx_check_can_increment(__first2, __dist.first);\n+\n+      if (__dist.second > ::__gnu_debug::__dp_equality)\n+\t{\n+\t  if (__dist.second > ::__gnu_debug::__dp_sign &&\n+\t      __first2._M_can_advance(__dist.first, true))\n+\t    return std::__equal_aux(__first1.base(), __last1.base(),\n+\t\t\t\t    __first2.base());\n+\t  return std::__equal_aux(__first1.base(), __last1.base(), __first2);\n+\t}\n+\n+      return __equal_aux1(__first1, __last1, __first2);\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n #endif"}, {"sha": "8a7c19428a6239bb3161c6e901efe7eccac3d8d7", "filename": "libstdc++-v3/include/debug/stl_iterator.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstl_iterator.h?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -115,17 +115,4 @@ namespace __gnu_debug\n #endif\n }\n \n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  template<typename _Iterator, typename _Container, typename _Sequence>\n-    _Iterator\n-    __niter_base(const __gnu_debug::_Safe_iterator<\n-\t\t __gnu_cxx::__normal_iterator<_Iterator, _Container>,\n-\t\t _Sequence, std::random_access_iterator_tag>&);\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-}\n-\n #endif"}, {"sha": "8138600f1439f184f736baee6bb47988c604dc2f", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -794,13 +794,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n #endif\n \n- template<typename _Iterator, typename _Container, typename _Sequence>\n-    _Iterator\n-    __niter_base(const __gnu_debug::_Safe_iterator<\n-\t\t __gnu_cxx::__normal_iterator<_Iterator, _Container>,\n-\t\t _Sequence, std::random_access_iterator_tag>& __it)\n-    { return std::__niter_base(__it.base()); }\n-\n #if __cplusplus >= 201703L\n   namespace __detail::__variant\n   {"}, {"sha": "0135db889c622358b925dae95c5855e707251462", "filename": "libstdc++-v3/include/std/numeric", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -229,12 +229,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// @addtogroup numeric_ops\n   /// @{\n \n-  /// @cond undocumented\n-  template<typename _It, typename _Cat = __iterator_category_t<_It>>\n-    using __is_random_access_iter\n-      = is_base_of<random_access_iterator_tag, _Cat>;\n-  /// @endcond\n-\n   /**\n    *  @brief  Calculate reduction of values in a range.\n    *"}, {"sha": "f5a396e811dca886618289591b0bddc445736ac2", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/debug/1_neg.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdebug%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdebug%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdebug%2F1_neg.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.1 [lib.alg.copy] Copy.\n+\n+// { dg-do run { xfail *-*-* } }\n+// { dg-require-debug-mode \"\" }\n+\n+#include <algorithm>\n+#include <list>\n+#include <vector>\n+\n+void\n+test01()\n+{\n+  std::list<int> l(10, 1);\n+  std::vector<int> v(5, 0);\n+\n+  std::copy(++l.begin(), --l.end(), v.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7b0dc3d21262d445507547495eb3492e3bfedfcc", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/deque_iterators/2.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F2.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <list>\n+#include <deque>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  copy(d.begin(), d.end(), dest.begin());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 4 * _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  const deque<int>& cd = d;\n+  copy(cd.begin(), cd.end(), dest.begin());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), cd.begin()) );\n+}\n+\n+void test03()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  d.pop_front();\n+  d.pop_back();\n+\n+  vector<int> dest(d.size(), 0);\n+\n+  copy(d.begin(), d.end(), dest.begin());\n+  VERIFY( equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test04()\n+{\n+  using namespace std;\n+\n+  vector<int> v;\n+  for (int i = 0; i != 1024; ++i)\n+    v.push_back(i);\n+\n+  deque<int> dest(v.size() - 10, 0);\n+\n+  std::copy(v.begin() + 5, v.end() - 5, dest.begin());\n+  VERIFY( std::equal(dest.begin(), dest.end(), v.begin() + 5) );\n+}\n+\n+void test05()\n+{\n+  using namespace std;\n+\n+  std::list<int> l;\n+  for (int i = 0; i != 1024; ++i)\n+    l.push_back(i);\n+\n+  std::deque<int> dest(l.size(), 0);\n+\n+  std::copy(l.begin(), l.end(), dest.begin());\n+  VERIFY( std::equal(dest.begin(), dest.end(), l.begin()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "ae2c33b1d10858cc9e4368f52ed68dd0c937345f", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/deque_iterators/31.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F31.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F31.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F31.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,43 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-do run { xfail *-*-* } }\n+// { dg-require-debug-mode \"\" }\n+\n+#include <algorithm>\n+#include <deque>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::vector<int> dest(d.size(), 0);\n+\n+  const std::deque<int>& cd = d;\n+  std::copy(cd.begin() + 10, cd.begin() + 5, dest.begin());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8028bd6b54265a1b9868536b54dfc59e66111c4e", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/deque_iterators/32.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F32.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,43 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-do run { xfail *-*-* } }\n+// { dg-require-debug-mode \"\" }\n+\n+#include <algorithm>\n+#include <deque>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::vector<int> dest(d.size() / 2, 0);\n+\n+  const std::deque<int>& cd = d;\n+  std::copy(cd.begin(), cd.end(), dest.begin());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1633fafd20c9f20821050454124765caad4e960d", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/deque_iterators/33.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F33.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F33.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F33.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-do run { xfail *-*-* } }\n+// { dg-require-debug-mode \"\" }\n+\n+#include <algorithm>\n+#include <deque>\n+#include <list>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::list<int> dest(d.size(), 0);\n+\n+  const std::deque<int>& cd = d;\n+  std::copy(cd.begin(), cd.end(), dest.begin());\n+}\n+\n+void test02()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::list<int> dest(d.size() / 2, 0);\n+  std::list<int>::iterator lit = dest.begin();\n+\n+  const std::deque<int>& cd = d;\n+  std::copy(cd.begin(), cd.end(), ++lit);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "0c9d949807a1984db3a5fef24adfd76919ce0675", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/deque_iterators/41.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F41.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F41.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F41.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-do run { xfail *-*-* } }\n+// { dg-require-debug-mode \"\" }\n+\n+#include <algorithm>\n+#include <deque>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::vector<int> dest(d.size(), 0);\n+\n+  std::copy(d.begin() + 10, d.begin() + 5, dest.begin());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c7e0c1f49fd16905b8b49adf1a4b43e19330f2f6", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/deque_iterators/42.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F42.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F42.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F42.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-do run { xfail *-*-* } }\n+// { dg-require-debug-mode \"\" }\n+\n+#include <algorithm>\n+#include <deque>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::vector<int> dest(d.size() / 2, 0);\n+\n+  std::copy(d.begin(), d.end(), dest.begin());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2f29afae09f03f15b246ab40fb89506a6274e5bf", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/deque_iterators/43.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F43.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F43.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fdeque_iterators%2F43.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-do run { xfail *-*-* } }\n+// { dg-require-debug-mode \"\" }\n+\n+#include <algorithm>\n+#include <deque>\n+#include <list>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::list<int> dest(d.size(), 0);\n+\n+  std::copy(d.begin(), d.end(), dest.begin());\n+}\n+\n+void test02()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::list<int> dest(d.size() / 2, 0);\n+  std::list<int>::iterator lit = dest.begin();\n+\n+  std::copy(d.begin(), d.end(), ++lit);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "3fd4e2715219dade78bf4cf459c5fc2b46660a95", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/streambuf_iterators/char/4.cc", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fstreambuf_iterators%2Fchar%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fstreambuf_iterators%2Fchar%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2Fstreambuf_iterators%2Fchar%2F4.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -21,6 +21,8 @@\n #include <fstream>\n #include <algorithm>\n #include <cstring>\n+#include <vector>\n+\n #include <testsuite_hooks.h>\n \n // { dg-require-fileio \"\" }\n@@ -33,7 +35,7 @@ void test01()\n   typedef istreambuf_iterator<char> in_iterator_type;\n \n   ifstream fbuf_ref(\"istream_unformatted-1.txt\"),\n-           fbuf(\"istream_unformatted-1.txt\");\n+\t   fbuf(\"istream_unformatted-1.txt\");\n \n   char buffer_ref[16500],\n        buffer[16500];\n@@ -50,8 +52,33 @@ void test01()\n   VERIFY( !memcmp(buffer, buffer_ref, 16500) );\n }\n \n+void test02()\n+{\n+  using namespace std;\n+\n+  typedef istreambuf_iterator<char> in_iterator_type;\n+\n+  ifstream fbuf_ref(\"istream_unformatted-1.txt\"),\n+\t   fbuf(\"istream_unformatted-1.txt\");\n+\n+  char buffer_ref[16500];\n+  std::vector<char> buffer(16500, 'a');\n+\n+  fbuf_ref.read(buffer_ref, 16500);\n+\n+  in_iterator_type beg(fbuf);\n+  in_iterator_type end;\n+  copy(beg, end, buffer.begin());\n+\n+  VERIFY( fbuf_ref.good() );\n+  VERIFY( fbuf.good() );\n+\n+  VERIFY( !memcmp(buffer.data(), buffer_ref, 16500) );\n+}\n+\n int main()\n {\n   test01();\n+  test02();\n   return 0;\n }"}, {"sha": "ccde52798590afc89bbb0ea214833df1e9913b40", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_backward/deque_iterators/2.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fdeque_iterators%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fdeque_iterators%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fdeque_iterators%2F2.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <list>\n+#include <deque>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  copy_backward(d.begin(), d.end(), dest.end());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 4 * _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  const deque<int>& cd = d;\n+  copy_backward(cd.begin(), cd.end(), dest.end());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), cd.begin()) );\n+}\n+\n+void test03()\n+{\n+  using namespace std;\n+\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  d.pop_front();\n+  d.pop_back();\n+\n+  std::vector<int> dest(d.size(), 0);\n+\n+  std::copy_backward(d.begin(), d.end(), dest.end());\n+  VERIFY( std::equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test04()\n+{\n+  using namespace std;\n+\n+  std::vector<int> v;\n+  for (int i = 0; i != 1024; ++i)\n+    v.push_back(i);\n+\n+  std::deque<int> dest(v.size() - 10, 0);\n+\n+  std::copy_backward(v.begin() + 5, v.end() - 5, dest.end());\n+  VERIFY( std::equal(v.begin() + 5, v.end() - 5, dest.begin()) );\n+}\n+\n+void test05()\n+{\n+  using namespace std;\n+\n+  std::list<int> l;\n+  for (int i = 0; i != 1024; ++i)\n+    l.push_back(i);\n+\n+  std::deque<int> dest(l.size(), 0);\n+\n+  std::copy_backward(l.begin(), l.end(), dest.end());\n+  VERIFY( std::equal(dest.begin(), dest.end(), l.begin()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "b99cf1df538178ee5eb99fab4d0bda2fc14c9ccd", "filename": "libstdc++-v3/testsuite/25_algorithms/equal/deque_iterators/1.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fdeque_iterators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fdeque_iterators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fdeque_iterators%2F1.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,122 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <deque>\n+\n+#include <ext/new_allocator.h>\n+#include <ext/malloc_allocator.h>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  const deque<int>& cd = d;\n+\n+  VERIFY( equal(cd.begin(), cd.end(), cd.begin()) );\n+  VERIFY( equal(cd.begin(), cd.end(), d.begin()) );\n+  VERIFY( equal(d.begin(), d.end(), d.begin()) );\n+  VERIFY( equal(d.begin(), d.end(), cd.begin()) );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i % 10);\n+\n+  VERIFY( equal(d.begin(), d.begin() + 10, d.begin() + 20) );\n+  VERIFY( equal(d.begin() + 10, d.end() - 10, d.begin()) );\n+\n+  const deque<int>& cd = d;\n+\n+  VERIFY( equal(cd.begin(), cd.begin() + 10, cd.begin() + 20) );\n+  VERIFY( equal(cd.begin() + 10, cd.end() - 10, d.begin()) );\n+  VERIFY( equal(d.begin() + 10, d.end() - 10, cd.begin()) );\n+}\n+\n+void test03()\n+{\n+  using namespace std;\n+\n+  deque<int> d1;\n+  for (int i = 0; i != 1024; ++i)\n+    d1.push_back(i % 10);\n+\n+  deque<int> d2(d1);\n+  for (int i = 0; i != 10; ++i)\n+    d2.pop_front();\n+\n+  VERIFY( equal(d1.begin(), d1.begin() + 10, d2.begin()) );\n+  VERIFY( equal(d1.begin() + 10, d1.end() - 10, d2.begin()) );\n+\n+  const deque<int>& cd1 = d1;\n+  const deque<int>& cd2 = d2;\n+\n+  VERIFY( equal(cd1.begin(), cd1.begin() + 10, cd2.begin() + 20) );\n+  VERIFY( equal(cd1.begin() + 10, cd1.end() - 10, d2.begin()) );\n+  VERIFY( equal(cd2.begin() + 10, cd2.end() - 10, cd1.begin()) );\n+}\n+\n+void test04()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  vector<int> v(d.begin(), d.end());\n+\n+  VERIFY( equal(d.begin(), d.end(), v.begin()) );\n+  VERIFY( equal(v.begin(), v.end(), d.begin()) );\n+\n+  const deque<int>& cd = d;\n+\n+  VERIFY( equal(cd.begin(), cd.end(), v.begin()) );\n+  VERIFY( equal(v.begin(), v.end(), cd.begin()) );\n+}\n+\n+void test05()\n+{\n+  using namespace std;\n+\n+  int a[] { 0, 1, 2, 3, 4 };\n+  deque<int, __gnu_cxx::new_allocator<int> > d1(a, a + 5);\n+  deque<int, __gnu_cxx::malloc_allocator<int> > d2(a, a + 5);\n+\n+  VERIFY( equal(d1.begin(), d1.end(), d2.begin()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "604ccb67fcd30a6352a24bf7d0fd4df9764b60fc", "filename": "libstdc++-v3/testsuite/25_algorithms/fill/deque_iterators/1.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2Fdeque_iterators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2Fdeque_iterators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffill%2Fdeque_iterators%2F1.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <deque>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  deque<char> d1;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(char)); ++i)\n+    d1.push_back((char)i);\n+\n+  deque<char> d2(d1.size(), '\\0');\n+\n+  fill(d1.begin(), d1.end(), '\\0');\n+\n+  VERIFY( equal(d1.begin(), d1.end(), d2.begin()) );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+\n+  deque<char> d1;\n+  for (int i = 0; i != 4 * _GLIBCXX_STD_C::__deque_buf_size(sizeof(char)); ++i)\n+    d1.push_back(i);\n+\n+  deque<char> d2(d1.size(), '\\0');\n+\n+  fill(d1.begin(), d1.end(), '\\0');\n+\n+  VERIFY( equal(d1.begin(), d1.end(), d2.begin()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "1f7930036d1006687e1f0ccbdc446ba49bfeab0d", "filename": "libstdc++-v3/testsuite/25_algorithms/move/deque_iterators/2.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2Fdeque_iterators%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2Fdeque_iterators%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2Fdeque_iterators%2F2.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,101 @@\n+// { dg-do run { target c++11 } }\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <list>\n+#include <deque>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  move(d.begin(), d.end(), dest.begin());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 4 * _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  const deque<int>& cd = d;\n+  move(cd.begin(), cd.end(), dest.begin());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), cd.begin()) );\n+}\n+\n+void test03()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::vector<int> dest(d.size(), 0);\n+\n+  std::move(d.begin(), d.end(), dest.begin());\n+  VERIFY( std::equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test04()\n+{\n+  std::vector<int> v;\n+  for (int i = 0; i != 1024; ++i)\n+    v.push_back(i);\n+\n+  std::deque<int> dest(v.size() - 10, 0);\n+\n+  std::move(v.begin() + 5, v.end() - 5, dest.begin());\n+  VERIFY( std::equal(dest.begin(), dest.end(), v.begin() + 5) );\n+}\n+\n+void test05()\n+{\n+  std::list<int> l;\n+  for (int i = 0; i != 1024; ++i)\n+    l.push_back(i);\n+\n+  std::deque<int> dest(l.size(), 0);\n+\n+  std::move(l.begin(), l.end(), dest.begin());\n+  VERIFY( std::equal(dest.begin(), dest.end(), l.begin()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "82fff3e20c87094befd9b26271d9def6d67c6d71", "filename": "libstdc++-v3/testsuite/25_algorithms/move_backward/deque_iterators/2.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2Fdeque_iterators%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2Fdeque_iterators%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2Fdeque_iterators%2F2.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,101 @@\n+// { dg-do run { target c++11 } }\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <list>\n+#include <deque>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  move_backward(d.begin(), d.end(), dest.end());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 4 * _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  deque<int> dest(d.size(), 0);\n+\n+  const deque<int>& cd = d;\n+  move_backward(cd.begin(), cd.end(), dest.end());\n+\n+  VERIFY( equal(dest.begin(), dest.end(), cd.begin()) );\n+}\n+\n+void test03()\n+{\n+  std::deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  std::vector<int> dest(d.size(), 0);\n+\n+  std::move_backward(d.begin(), d.end(), dest.end());\n+  VERIFY( std::equal(dest.begin(), dest.end(), d.begin()) );\n+}\n+\n+void test04()\n+{\n+  std::vector<int> v;\n+  for (int i = 0; i != 1024; ++i)\n+    v.push_back(i);\n+\n+  std::deque<int> dest(v.size() - 10, 0);\n+\n+  std::move_backward(v.begin() + 5, v.end() - 5, dest.end());\n+  VERIFY( std::equal(dest.begin(), dest.end(), v.begin() + 5) );\n+}\n+\n+void test05()\n+{\n+  std::list<int> l;\n+  for (int i = 0; i != 1024; ++i)\n+    l.push_back(i);\n+\n+  std::deque<int> dest(l.size(), 0);\n+\n+  std::move_backward(l.begin(), l.end(), dest.end());\n+  VERIFY( std::equal(dest.begin(), dest.end(), l.begin()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "716907c1a960bdee72d1808f5053cd852d95a523", "filename": "libstdc++-v3/testsuite/performance/25_algorithms/copy_backward_deque_iterators.cc", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fcopy_backward_deque_iterators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fcopy_backward_deque_iterators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fcopy_backward_deque_iterators.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -16,6 +16,9 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <deque>\n+#include <vector>\n+#include <list>\n+\n #include <testsuite_performance.h>\n \n int main()\n@@ -34,7 +37,71 @@ int main()\n     for (int j = 0; j < 3000; ++j)\n       std::copy_backward(data.begin(), data.begin() + j, d.end());\n   stop_counters(time, resource);\n-  report_performance(__FILE__, \"\", time, resource);\n+  report_performance(__FILE__, \"deque 2 deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::vector<int> v(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy_backward(data.begin(), data.begin() + j, v.end());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"deque 2 vector\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy_backward(v.begin(), v.begin() + j, d.end());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"vector 2 deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::vector<char> cv(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy_backward(data.begin(), data.begin() + j, cv.end());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"int deque 2 char vector\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy_backward(cv.begin(), cv.begin() + j, d.end());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"char vector 2 int deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::list<int> l(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy_backward(data.begin(), data.begin() + j, l.end());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"deque 2 list\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  std::list<int>::iterator lit;\n+  start_counters(time, resource);\n+  for (int i = 0; i < 200; ++i)\n+    {\n+      lit = l.begin();\n+      for (int j = 0; j < 3000; ++j, ++lit)\n+\tstd::copy_backward(l.begin(), lit, d.end());\n+    }\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"list 2 deque\", time, resource);\n \n   return 0;\n }"}, {"sha": "0bb2c55a95087fa6900540808bb150ec183752da", "filename": "libstdc++-v3/testsuite/performance/25_algorithms/copy_deque_iterators.cc", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fcopy_deque_iterators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fcopy_deque_iterators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fcopy_deque_iterators.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -16,6 +16,9 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <deque>\n+#include <vector>\n+#include <list>\n+\n #include <testsuite_performance.h>\n \n int main()\n@@ -34,7 +37,71 @@ int main()\n     for (int j = 0; j < 3000; ++j)\n       std::copy(data.begin(), data.begin() + j, d.begin());\n   stop_counters(time, resource);\n-  report_performance(__FILE__, \"\", time, resource);\n+  report_performance(__FILE__, \"deque 2 deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::vector<int> v(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy(data.begin(), data.begin() + j, v.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"deque 2 vector\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy(v.begin(), v.begin() + j, d.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"vector 2 deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::vector<char> cv(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy(data.begin(), data.begin() + j, cv.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"int deque 2 char vector\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy(cv.begin(), cv.begin() + j, d.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"char vector 2 int deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::list<int> l(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::copy(data.begin(), data.begin() + j, l.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"deque 2 list\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  std::list<int>::iterator lit;\n+  start_counters(time, resource);\n+  for (int i = 0; i < 200; ++i)\n+    {\n+      lit = l.begin();\n+      for (int j = 0; j < 3000; ++j, ++lit)\n+\tstd::copy(l.begin(), lit, d.begin());\n+    }\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"list 2 deque\", time, resource);\n \n   return 0;\n }"}, {"sha": "66c4601c5f656788f0583e3cab5a03ef58a0fbb2", "filename": "libstdc++-v3/testsuite/performance/25_algorithms/equal_deque_iterators.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fequal_deque_iterators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fequal_deque_iterators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fequal_deque_iterators.cc?ref=6004c17b4d1a2dd1e1936b2e705a5ccfb6e48ab2", "patch": "@@ -0,0 +1,82 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <deque>\n+#include <vector>\n+\n+#include <testsuite_performance.h>\n+\n+int main()\n+{\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  const std::deque<int> data(3000, 1);\n+\n+  std::deque<int> d(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::equal(data.begin(), data.begin() + j, d.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"deque vs deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::vector<int> v(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::equal(data.begin(), data.begin() + j, v.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"deque vs vector\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::equal(v.begin(), v.begin() + j, d.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"vector vs deque\", time, resource);\n+  clear_counters(time, resource);\n+\n+  std::vector<char> cv(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::equal(data.begin(), data.begin() + j, cv.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"int deque vs char vector\", time, resource);\n+  clear_counters(time, resource);\n+\n+  d.assign(3000, 1);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 1000; ++i)\n+    for (int j = 0; j < 3000; ++j)\n+      std::equal(cv.begin(), cv.begin() + j, d.begin());\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"char vector vs int deque\", time, resource);\n+\n+  return 0;\n+}"}]}