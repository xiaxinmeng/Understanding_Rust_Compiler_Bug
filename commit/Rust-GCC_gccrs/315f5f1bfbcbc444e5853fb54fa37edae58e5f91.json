{"sha": "315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1ZjVmMWJmYmNiYzQ0NGU1ODUzZmI1NGZhMzdlZGFlNThlNWY5MQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-30T14:06:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-30T14:06:00Z"}, "message": "re PR tree-optimization/48571 (Missed data-dependence for (bogus?) reconstructed array-refs)\n\n2011-08-30  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/48571\n\t* gimple.h (maybe_fold_offset_to_address): Remove.\n\t(maybe_fold_offset_to_reference): Likewise.\n\t(maybe_fold_stmt_addition): Likewise.\n\t(may_propagate_address_into_dereference): Likewise.\n\t* tree-inline.c (remap_gimple_op_r): Do not reconstruct\n\tarray references.\n\t* gimple-fold.c (canonicalize_constructor_val): Likewise.\n\tCanonicalize invariant POINTER_PLUS_EXPRs to invariant MEM_REF\n\taddresses instead.\n\t(may_propagate_address_into_dereference): Remove.\n\t(maybe_fold_offset_to_array_ref): Likewise.\n\t(maybe_fold_offset_to_reference): Likewise.\n\t(maybe_fold_offset_to_address): Likewise.\n\t(maybe_fold_stmt_addition): Likewise.\n\t(fold_gimple_assign): Do not reconstruct array references but\n\tinstead canonicalize invariant POINTER_PLUS_EXPRs to invariant\n\tMEM_REF addresses.\n\t(gimple_fold_stmt_to_constant_1): Likewise.\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n\t* gimplify.c (gimplify_conversion): Likewise.\n\t(gimplify_expr): Likewise.\n\n\t* gcc.c-torture/execute/pr48571-1.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-ccp-25.c: Remove.\n\t* gcc.dg/tree-ssa/ssa-ccp-26.c: Likewise.\n\t* gcc.dg/pr36902.c: XFAIL.\n\nFrom-SVN: r178312", "tree": {"sha": "04e75f6b96cabc5abbb23cc93d17526c05e9e9f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04e75f6b96cabc5abbb23cc93d17526c05e9e9f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ddd46d69b09a88fb82832285b69090fa08bddc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ddd46d69b09a88fb82832285b69090fa08bddc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ddd46d69b09a88fb82832285b69090fa08bddc2"}], "stats": {"total": 685, "additions": 126, "deletions": 559}, "files": [{"sha": "0313a8400cbe59f220dce4da9d0a767e0381449c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -1,3 +1,28 @@\n+2011-08-30  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/48571\n+\t* gimple.h (maybe_fold_offset_to_address): Remove.\n+\t(maybe_fold_offset_to_reference): Likewise.\n+\t(maybe_fold_stmt_addition): Likewise.\n+\t(may_propagate_address_into_dereference): Likewise.\n+\t* tree-inline.c (remap_gimple_op_r): Do not reconstruct\n+\tarray references.\n+\t* gimple-fold.c (canonicalize_constructor_val): Likewise.\n+\tCanonicalize invariant POINTER_PLUS_EXPRs to invariant MEM_REF\n+\taddresses instead.\n+\t(may_propagate_address_into_dereference): Remove.\n+\t(maybe_fold_offset_to_array_ref): Likewise.\n+\t(maybe_fold_offset_to_reference): Likewise.\n+\t(maybe_fold_offset_to_address): Likewise.\n+\t(maybe_fold_stmt_addition): Likewise.\n+\t(fold_gimple_assign): Do not reconstruct array references but\n+\tinstead canonicalize invariant POINTER_PLUS_EXPRs to invariant\n+\tMEM_REF addresses.\n+\t(gimple_fold_stmt_to_constant_1): Likewise.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n+\t* gimplify.c (gimplify_conversion): Likewise.\n+\t(gimplify_expr): Likewise.\n+\n 2011-08-30  Ilya Tocar  <ilya.tocar@intel.com>\n \n \t* config/i386/fmaintrin.h: New."}, {"sha": "72dc42a5bdc9f410e033f3c5fb06753d458a1038", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 21, "deletions": 432, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -116,14 +116,17 @@ tree\n canonicalize_constructor_val (tree cval)\n {\n   STRIP_NOPS (cval);\n-  if (TREE_CODE (cval) == POINTER_PLUS_EXPR)\n-    {\n-      tree t = maybe_fold_offset_to_address (EXPR_LOCATION (cval),\n-\t\t\t\t\t     TREE_OPERAND (cval, 0),\n-\t\t\t\t\t     TREE_OPERAND (cval, 1),\n-\t\t\t\t\t     TREE_TYPE (cval));\n-      if (t)\n-\tcval = t;\n+  if (TREE_CODE (cval) == POINTER_PLUS_EXPR\n+      && TREE_CODE (TREE_OPERAND (cval, 1)) == INTEGER_CST)\n+    {\n+      tree ptr = TREE_OPERAND (cval, 0);\n+      if (is_gimple_min_invariant (ptr))\n+\tcval = build1_loc (EXPR_LOCATION (cval),\n+\t\t\t   ADDR_EXPR, TREE_TYPE (ptr),\n+\t\t\t   fold_build2 (MEM_REF, TREE_TYPE (TREE_TYPE (ptr)),\n+\t\t\t\t\tptr,\n+\t\t\t\t\tfold_convert (ptr_type_node,\n+\t\t\t\t\t\t      TREE_OPERAND (cval, 1))));\n     }\n   if (TREE_CODE (cval) == ADDR_EXPR)\n     {\n@@ -173,384 +176,6 @@ get_symbol_constant_value (tree sym)\n }\n \n \n-/* Return true if we may propagate the address expression ADDR into the\n-   dereference DEREF and cancel them.  */\n-\n-bool\n-may_propagate_address_into_dereference (tree addr, tree deref)\n-{\n-  gcc_assert (TREE_CODE (deref) == MEM_REF\n-\t      && TREE_CODE (addr) == ADDR_EXPR);\n-\n-  /* Don't propagate if ADDR's operand has incomplete type.  */\n-  if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_OPERAND (addr, 0))))\n-    return false;\n-\n-  /* If the address is invariant then we do not need to preserve restrict\n-     qualifications.  But we do need to preserve volatile qualifiers until\n-     we can annotate the folded dereference itself properly.  */\n-  if (is_gimple_min_invariant (addr)\n-      && (!TREE_THIS_VOLATILE (deref)\n-\t  || TYPE_VOLATILE (TREE_TYPE (addr))))\n-    return useless_type_conversion_p (TREE_TYPE (deref),\n-\t\t\t\t      TREE_TYPE (TREE_OPERAND (addr, 0)));\n-\n-  /* Else both the address substitution and the folding must result in\n-     a valid useless type conversion sequence.  */\n-  return (useless_type_conversion_p (TREE_TYPE (TREE_OPERAND (deref, 0)),\n-\t\t\t\t     TREE_TYPE (addr))\n-\t  && useless_type_conversion_p (TREE_TYPE (deref),\n-\t\t\t\t\tTREE_TYPE (TREE_OPERAND (addr, 0))));\n-}\n-\n-\n-/* A subroutine of fold_stmt.  Attempts to fold *(A+O) to A[X].\n-   BASE is an array type.  OFFSET is a byte displacement.\n-\n-   LOC is the location of the original expression.  */\n-\n-static tree\n-maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset)\n-{\n-  tree min_idx, idx, idx_type, elt_offset = integer_zero_node;\n-  tree array_type, elt_type, elt_size;\n-  tree domain_type;\n-\n-  /* If BASE is an ARRAY_REF, we can pick up another offset (this time\n-     measured in units of the size of elements type) from that ARRAY_REF).\n-     We can't do anything if either is variable.\n-\n-     The case we handle here is *(&A[N]+O).  */\n-  if (TREE_CODE (base) == ARRAY_REF)\n-    {\n-      tree low_bound = array_ref_low_bound (base);\n-\n-      elt_offset = TREE_OPERAND (base, 1);\n-      if (TREE_CODE (low_bound) != INTEGER_CST\n-\t  || TREE_CODE (elt_offset) != INTEGER_CST)\n-\treturn NULL_TREE;\n-\n-      elt_offset = int_const_binop (MINUS_EXPR, elt_offset, low_bound);\n-      base = TREE_OPERAND (base, 0);\n-    }\n-\n-  /* Ignore stupid user tricks of indexing non-array variables.  */\n-  array_type = TREE_TYPE (base);\n-  if (TREE_CODE (array_type) != ARRAY_TYPE)\n-    return NULL_TREE;\n-  elt_type = TREE_TYPE (array_type);\n-\n-  /* Use signed size type for intermediate computation on the index.  */\n-  idx_type = ssizetype;\n-\n-  /* If OFFSET and ELT_OFFSET are zero, we don't care about the size of the\n-     element type (so we can use the alignment if it's not constant).\n-     Otherwise, compute the offset as an index by using a division.  If the\n-     division isn't exact, then don't do anything.  */\n-  elt_size = TYPE_SIZE_UNIT (elt_type);\n-  if (!elt_size)\n-    return NULL;\n-  if (integer_zerop (offset))\n-    {\n-      if (TREE_CODE (elt_size) != INTEGER_CST)\n-\telt_size = size_int (TYPE_ALIGN (elt_type));\n-\n-      idx = build_int_cst (idx_type, 0);\n-    }\n-  else\n-    {\n-      unsigned HOST_WIDE_INT lquo, lrem;\n-      HOST_WIDE_INT hquo, hrem;\n-      double_int soffset;\n-\n-      /* The final array offset should be signed, so we need\n-\t to sign-extend the (possibly pointer) offset here\n-\t and use signed division.  */\n-      soffset = double_int_sext (tree_to_double_int (offset),\n-\t\t\t\t TYPE_PRECISION (TREE_TYPE (offset)));\n-      if (TREE_CODE (elt_size) != INTEGER_CST\n-\t  || div_and_round_double (TRUNC_DIV_EXPR, 0,\n-\t\t\t\t   soffset.low, soffset.high,\n-\t\t\t\t   TREE_INT_CST_LOW (elt_size),\n-\t\t\t\t   TREE_INT_CST_HIGH (elt_size),\n-\t\t\t\t   &lquo, &hquo, &lrem, &hrem)\n-\t  || lrem || hrem)\n-\treturn NULL_TREE;\n-\n-      idx = build_int_cst_wide (idx_type, lquo, hquo);\n-    }\n-\n-  /* Assume the low bound is zero.  If there is a domain type, get the\n-     low bound, if any, convert the index into that type, and add the\n-     low bound.  */\n-  min_idx = build_int_cst (idx_type, 0);\n-  domain_type = TYPE_DOMAIN (array_type);\n-  if (domain_type)\n-    {\n-      idx_type = domain_type;\n-      if (TYPE_MIN_VALUE (idx_type))\n-\tmin_idx = TYPE_MIN_VALUE (idx_type);\n-      else\n-\tmin_idx = fold_convert (idx_type, min_idx);\n-\n-      if (TREE_CODE (min_idx) != INTEGER_CST)\n-\treturn NULL_TREE;\n-\n-      elt_offset = fold_convert (idx_type, elt_offset);\n-    }\n-\n-  if (!integer_zerop (min_idx))\n-    idx = int_const_binop (PLUS_EXPR, idx, min_idx);\n-  if (!integer_zerop (elt_offset))\n-    idx = int_const_binop (PLUS_EXPR, idx, elt_offset);\n-\n-  /* Make sure to possibly truncate late after offsetting.  */\n-  idx = fold_convert (idx_type, idx);\n-\n-  /* We don't want to construct access past array bounds. For example\n-       char *(c[4]);\n-       c[3][2];\n-     should not be simplified into (*c)[14] or tree-vrp will\n-     give false warnings.\n-     This is only an issue for multi-dimensional arrays.  */\n-  if (TREE_CODE (elt_type) == ARRAY_TYPE\n-      && domain_type)\n-    {\n-      if (TYPE_MAX_VALUE (domain_type)\n-\t  && TREE_CODE (TYPE_MAX_VALUE (domain_type)) == INTEGER_CST\n-\t  && tree_int_cst_lt (TYPE_MAX_VALUE (domain_type), idx))\n-\treturn NULL_TREE;\n-      else if (TYPE_MIN_VALUE (domain_type)\n-\t       && TREE_CODE (TYPE_MIN_VALUE (domain_type)) == INTEGER_CST\n-\t       && tree_int_cst_lt (idx, TYPE_MIN_VALUE (domain_type)))\n-\treturn NULL_TREE;\n-      else if (compare_tree_int (idx, 0) < 0)\n-\treturn NULL_TREE;\n-    }\n-\n-  {\n-    tree t = build4 (ARRAY_REF, elt_type, base, idx, NULL_TREE, NULL_TREE);\n-    SET_EXPR_LOCATION (t, loc);\n-    return t;\n-  }\n-}\n-\n-\n-/* Attempt to express (ORIG_TYPE)BASE+OFFSET as BASE[index].\n-   LOC is the location of original expression.\n-\n-   Before attempting the conversion strip off existing ADDR_EXPRs.  */\n-\n-tree\n-maybe_fold_offset_to_reference (location_t loc, tree base, tree offset,\n-\t\t\t\ttree orig_type)\n-{\n-  tree ret;\n-\n-  STRIP_NOPS (base);\n-  if (TREE_CODE (base) != ADDR_EXPR)\n-    return NULL_TREE;\n-\n-  base = TREE_OPERAND (base, 0);\n-  if (types_compatible_p (orig_type, TREE_TYPE (base))\n-      && integer_zerop (offset))\n-    return base;\n-\n-  ret = maybe_fold_offset_to_array_ref (loc, base, offset);\n-  if (ret && types_compatible_p (orig_type, TREE_TYPE (ret)))\n-    return ret;\n-  return NULL_TREE;\n-}\n-\n-/* Attempt to express (ORIG_TYPE)ADDR+OFFSET as (*ADDR)[index].\n-   LOC is the location of the original expression.  */\n-\n-tree\n-maybe_fold_offset_to_address (location_t loc, tree addr, tree offset,\n-\t\t\t      tree orig_type)\n-{\n-  tree base, ret;\n-\n-  STRIP_NOPS (addr);\n-  if (TREE_CODE (addr) != ADDR_EXPR)\n-    return NULL_TREE;\n-  base = TREE_OPERAND (addr, 0);\n-  ret = maybe_fold_offset_to_array_ref (loc, base, offset);\n-  if (ret)\n-    {\n-      ret = build_fold_addr_expr (ret);\n-      if (!useless_type_conversion_p (orig_type, TREE_TYPE (ret)))\n-\treturn NULL_TREE;\n-      SET_EXPR_LOCATION (ret, loc);\n-    }\n-\n-  return ret;\n-}\n-\n-\n-/* A quaint feature extant in our address arithmetic is that there\n-   can be hidden type changes here.  The type of the result need\n-   not be the same as the type of the input pointer.\n-\n-   What we're after here is an expression of the form\n-\t(T *)(&array + const)\n-   where array is OP0, const is OP1, RES_TYPE is T and\n-   the cast doesn't actually exist, but is implicit in the\n-   type of the POINTER_PLUS_EXPR.  We'd like to turn this into\n-\t&array[x]\n-   which may be able to propagate further.  */\n-\n-tree\n-maybe_fold_stmt_addition (location_t loc, tree res_type, tree op0, tree op1)\n-{\n-  tree ptd_type;\n-  tree t;\n-\n-  /* The first operand should be an ADDR_EXPR.  */\n-  if (TREE_CODE (op0) != ADDR_EXPR)\n-    return NULL_TREE;\n-  op0 = TREE_OPERAND (op0, 0);\n-\n-  /* It had better be a constant.  */\n-  if (TREE_CODE (op1) != INTEGER_CST)\n-    {\n-      /* Or op0 should now be A[0] and the non-constant offset defined\n-\t via a multiplication by the array element size.  */\n-      if (TREE_CODE (op0) == ARRAY_REF\n-\t  /* As we will end up creating a variable index array access\n-\t     in the outermost array dimension make sure there isn't\n-\t     a more inner array that the index could overflow to.  */\n-\t  && TREE_CODE (TREE_OPERAND (op0, 0)) != ARRAY_REF\n-\t  && integer_zerop (TREE_OPERAND (op0, 1))\n-\t  && TREE_CODE (op1) == SSA_NAME)\n-\t{\n-\t  gimple offset_def = SSA_NAME_DEF_STMT (op1);\n-\t  tree elsz = TYPE_SIZE_UNIT (TREE_TYPE (op0));\n-\t  if (!host_integerp (elsz, 1)\n-\t      || !is_gimple_assign (offset_def))\n-\t    return NULL_TREE;\n-\n-\t  /* Do not build array references of something that we can't\n-\t     see the true number of array dimensions for.  */\n-\t  if (!DECL_P (TREE_OPERAND (op0, 0))\n-\t      && !handled_component_p (TREE_OPERAND (op0, 0)))\n-\t    return NULL_TREE;\n-\n-\t  if (gimple_assign_rhs_code (offset_def) == MULT_EXPR\n-\t      && TREE_CODE (gimple_assign_rhs2 (offset_def)) == INTEGER_CST\n-\t      && tree_int_cst_equal (gimple_assign_rhs2 (offset_def), elsz))\n-\t    return build_fold_addr_expr\n-\t\t\t  (build4 (ARRAY_REF, TREE_TYPE (op0),\n-\t\t\t\t   TREE_OPERAND (op0, 0),\n-\t\t\t\t   gimple_assign_rhs1 (offset_def),\n-\t\t\t\t   TREE_OPERAND (op0, 2),\n-\t\t\t\t   TREE_OPERAND (op0, 3)));\n-\t  else if (integer_onep (elsz)\n-\t\t   && gimple_assign_rhs_code (offset_def) != MULT_EXPR)\n-\t    return build_fold_addr_expr\n-\t\t\t  (build4 (ARRAY_REF, TREE_TYPE (op0),\n-\t\t\t\t   TREE_OPERAND (op0, 0),\n-\t\t\t\t   op1,\n-\t\t\t\t   TREE_OPERAND (op0, 2),\n-\t\t\t\t   TREE_OPERAND (op0, 3)));\n-\t}\n-      else if (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE\n-\t       /* Dto.  */\n-\t       && TREE_CODE (TREE_TYPE (TREE_TYPE (op0))) != ARRAY_TYPE\n-\t       && TREE_CODE (op1) == SSA_NAME)\n-\t{\n-\t  gimple offset_def = SSA_NAME_DEF_STMT (op1);\n-\t  tree elsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (op0)));\n-\t  if (!host_integerp (elsz, 1)\n-\t      || !is_gimple_assign (offset_def))\n-\t    return NULL_TREE;\n-\n-\t  /* Do not build array references of something that we can't\n-\t     see the true number of array dimensions for.  */\n-\t  if (!DECL_P (op0)\n-\t      && !handled_component_p (op0))\n-\t    return NULL_TREE;\n-\n-\t  if (gimple_assign_rhs_code (offset_def) == MULT_EXPR\n-\t      && TREE_CODE (gimple_assign_rhs2 (offset_def)) == INTEGER_CST\n-\t      && tree_int_cst_equal (gimple_assign_rhs2 (offset_def), elsz))\n-\t    return build_fold_addr_expr\n-\t\t\t  (build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (op0)),\n-\t\t\t\t   op0, gimple_assign_rhs1 (offset_def),\n-\t\t\t\t   integer_zero_node, NULL_TREE));\n-\t  else if (integer_onep (elsz)\n-\t\t   && gimple_assign_rhs_code (offset_def) != MULT_EXPR)\n-\t    return build_fold_addr_expr\n-\t\t\t  (build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (op0)),\n-\t\t\t\t   op0, op1,\n-\t\t\t\t   integer_zero_node, NULL_TREE));\n-\t}\n-\n-      return NULL_TREE;\n-    }\n-\n-  /* If the first operand is an ARRAY_REF, expand it so that we can fold\n-     the offset into it.  */\n-  while (TREE_CODE (op0) == ARRAY_REF)\n-    {\n-      tree array_obj = TREE_OPERAND (op0, 0);\n-      tree array_idx = TREE_OPERAND (op0, 1);\n-      tree elt_type = TREE_TYPE (op0);\n-      tree elt_size = TYPE_SIZE_UNIT (elt_type);\n-      tree min_idx;\n-\n-      if (TREE_CODE (array_idx) != INTEGER_CST)\n-\tbreak;\n-      if (TREE_CODE (elt_size) != INTEGER_CST)\n-\tbreak;\n-\n-      /* Un-bias the index by the min index of the array type.  */\n-      min_idx = TYPE_DOMAIN (TREE_TYPE (array_obj));\n-      if (min_idx)\n-\t{\n-\t  min_idx = TYPE_MIN_VALUE (min_idx);\n-\t  if (min_idx)\n-\t    {\n-\t      if (TREE_CODE (min_idx) != INTEGER_CST)\n-\t\tbreak;\n-\n-\t      array_idx = fold_convert (TREE_TYPE (min_idx), array_idx);\n-\t      if (!integer_zerop (min_idx))\n-\t\tarray_idx = int_const_binop (MINUS_EXPR, array_idx,\n-\t\t\t\t\t     min_idx);\n-\t    }\n-\t}\n-\n-      /* Convert the index to a byte offset.  */\n-      array_idx = fold_convert (sizetype, array_idx);\n-      array_idx = int_const_binop (MULT_EXPR, array_idx, elt_size);\n-\n-      /* Update the operands for the next round, or for folding.  */\n-      op1 = int_const_binop (PLUS_EXPR,\n-\t\t\t     array_idx, op1);\n-      op0 = array_obj;\n-    }\n-\n-  ptd_type = TREE_TYPE (res_type);\n-  /* If we want a pointer to void, reconstruct the reference from the\n-     array element type.  A pointer to that can be trivially converted\n-     to void *.  This happens as we fold (void *)(ptr p+ off).  */\n-  if (VOID_TYPE_P (ptd_type)\n-      && TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE)\n-    ptd_type = TREE_TYPE (TREE_TYPE (op0));\n-\n-  /* At which point we can try some of the same things as for indirects.  */\n-  t = maybe_fold_offset_to_array_ref (loc, op0, op1);\n-  if (t)\n-    {\n-      t = build_fold_addr_expr (t);\n-      if (!useless_type_conversion_p (res_type, TREE_TYPE (t)))\n-\treturn NULL_TREE;\n-      SET_EXPR_LOCATION (t, loc);\n-    }\n-\n-  return t;\n-}\n \n /* Subroutine of fold_stmt.  We perform several simplifications of the\n    memory reference tree EXPR and make sure to re-gimplify them properly\n@@ -783,41 +408,14 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t    if (valid_gimple_rhs_p (result))\n \t      return result;\n \t  }\n-\telse if (CONVERT_EXPR_CODE_P (subcode)\n-\t\t && POINTER_TYPE_P (gimple_expr_type (stmt))\n-\t\t && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n-\t  {\n-\t    tree type = gimple_expr_type (stmt);\n-\t    tree t = maybe_fold_offset_to_address (loc,\n-\t\t\t\t\t\t   gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t\t   integer_zero_node, type);\n-\t    if (t)\n-\t      return t;\n-\t  }\n       }\n       break;\n \n     case GIMPLE_BINARY_RHS:\n-      /* Try to fold pointer addition.  */\n-      if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n-\t{\n-\t  tree type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t  if (TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n-\t    {\n-\t      type = build_pointer_type (TREE_TYPE (TREE_TYPE (type)));\n-\t      if (!useless_type_conversion_p\n-\t\t    (TREE_TYPE (gimple_assign_lhs (stmt)), type))\n-\t\ttype = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t    }\n-\t  result = maybe_fold_stmt_addition (gimple_location (stmt),\n-\t\t\t\t\t     type,\n-\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t     gimple_assign_rhs2 (stmt));\n-\t}\n       /* Try to canonicalize for boolean-typed X the comparisons\n \t X == 0, X == 1, X != 0, and X != 1.  */\n-      else if (gimple_assign_rhs_code (stmt) == EQ_EXPR\n-               || gimple_assign_rhs_code (stmt) == NE_EXPR)\n+      if (gimple_assign_rhs_code (stmt) == EQ_EXPR\n+\t  || gimple_assign_rhs_code (stmt) == NE_EXPR)\n         {\n \t  tree lhs = gimple_assign_lhs (stmt);\n \t  tree op1 = gimple_assign_rhs1 (stmt);\n@@ -2945,29 +2543,20 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree))\n               /* Handle unary operators that can appear in GIMPLE form.\n                  Note that we know the single operand must be a constant,\n                  so this should almost always return a simplified RHS.  */\n-              tree lhs = gimple_assign_lhs (stmt);\n+\t      tree lhs = gimple_assign_lhs (stmt);\n               tree op0 = (*valueize) (gimple_assign_rhs1 (stmt));\n \n \t      /* Conversions are useless for CCP purposes if they are\n \t\t value-preserving.  Thus the restrictions that\n-\t\t useless_type_conversion_p places for pointer type conversions\n-\t\t do not apply here.  Substitution later will only substitute to\n-\t\t allowed places.  */\n+\t\t useless_type_conversion_p places for restrict qualification\n+\t\t of pointer types should not apply here.\n+\t\t Substitution later will only substitute to allowed places.  */\n \t      if (CONVERT_EXPR_CODE_P (subcode)\n \t\t  && POINTER_TYPE_P (TREE_TYPE (lhs))\n-\t\t  && POINTER_TYPE_P (TREE_TYPE (op0)))\n-\t\t{\n-\t\t  tree tem;\n-\t\t  /* Try to re-construct array references on-the-fly.  */\n-\t\t  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n-\t\t\t\t\t\t  TREE_TYPE (op0))\n-\t\t      && ((tem = maybe_fold_offset_to_address\n-\t\t\t   (loc,\n-\t\t\t    op0, integer_zero_node, TREE_TYPE (lhs)))\n-\t\t\t  != NULL_TREE))\n-\t\t    return tem;\n-\t\t  return op0;\n-\t\t}\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (op0))\n+\t\t  && (TYPE_ADDR_SPACE (TREE_TYPE (lhs))\n+\t\t      == TYPE_ADDR_SPACE (TREE_TYPE (op0))))\n+\t\treturn op0;\n \n               return\n \t\tfold_unary_ignore_overflow_loc (loc, subcode,"}, {"sha": "7f831dffcaf042b7858b1f8180e36cac293ee736", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -5069,12 +5069,8 @@ void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n tree gimple_fold_builtin (gimple);\n bool fold_stmt (gimple_stmt_iterator *);\n bool fold_stmt_inplace (gimple);\n-tree maybe_fold_offset_to_address (location_t, tree, tree, tree);\n-tree maybe_fold_offset_to_reference (location_t, tree, tree, tree);\n-tree maybe_fold_stmt_addition (location_t, tree, tree, tree);\n tree get_symbol_constant_value (tree);\n tree canonicalize_constructor_val (tree);\n-bool may_propagate_address_into_dereference (tree, tree);\n extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree, \n \t\t\t\t\tenum tree_code, tree, tree);\n extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,"}, {"sha": "d7bc818dfb98701f295d6e036defb8e46f6214f3", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -1799,7 +1799,6 @@ canonicalize_addr_expr (tree *expr_p)\n static enum gimplify_status\n gimplify_conversion (tree *expr_p)\n {\n-  tree tem;\n   location_t loc = EXPR_LOCATION (*expr_p);\n   gcc_assert (CONVERT_EXPR_P (*expr_p));\n \n@@ -1810,17 +1809,6 @@ gimplify_conversion (tree *expr_p)\n   if (tree_ssa_useless_type_conversion (*expr_p))\n     *expr_p = TREE_OPERAND (*expr_p, 0);\n \n-  /* Attempt to avoid NOP_EXPR by producing reference to a subtype.\n-     For example this fold (subclass *)&A into &A->subclass avoiding\n-     a need for statement.  */\n-  if (CONVERT_EXPR_P (*expr_p)\n-      && POINTER_TYPE_P (TREE_TYPE (*expr_p))\n-      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 0)))\n-      && (tem = maybe_fold_offset_to_address\n-\t  (EXPR_LOCATION (*expr_p), TREE_OPERAND (*expr_p, 0),\n-\t   integer_zero_node, TREE_TYPE (*expr_p))) != NULL_TREE)\n-    *expr_p = tem;\n-\n   /* If we still have a conversion at the toplevel,\n      then canonicalize some constructs.  */\n   if (CONVERT_EXPR_P (*expr_p))\n@@ -7302,36 +7290,33 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  goto expr_3;\n \n \tcase POINTER_PLUS_EXPR:\n-          /* Convert ((type *)A)+offset into &A->field_of_type_and_offset.\n-\t     The second is gimple immediate saving a need for extra statement.\n-\t   */\n-\t  if (TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n-\t      && (tmp = maybe_fold_offset_to_address\n-\t\t  (EXPR_LOCATION (*expr_p),\n-\t\t   TREE_OPERAND (*expr_p, 0), TREE_OPERAND (*expr_p, 1),\n-\t\t   TREE_TYPE (*expr_p))))\n-\t    {\n-\t      *expr_p = tmp;\n-\t      ret = GS_OK;\n-\t      break;\n-\t    }\n-\t  /* Convert (void *)&a + 4 into (void *)&a[1].  */\n-\t  if (TREE_CODE (TREE_OPERAND (*expr_p, 0)) == NOP_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n-\t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p,\n-\t\t\t\t\t\t\t\t\t0),0)))\n-\t      && (tmp = maybe_fold_offset_to_address\n-\t\t  (EXPR_LOCATION (*expr_p),\n-\t\t   TREE_OPERAND (TREE_OPERAND (*expr_p, 0), 0),\n-\t\t   TREE_OPERAND (*expr_p, 1),\n-\t\t   TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p, 0),\n-\t\t\t\t\t    0)))))\n-\t     {\n-               *expr_p = fold_convert (TREE_TYPE (*expr_p), tmp);\n-\t       ret = GS_OK;\n-\t       break;\n-\t     }\n-          /* FALLTHRU */\n+\t  {\n+\t    enum gimplify_status r0, r1;\n+\t    r0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n+\t\t\t\tpost_p, is_gimple_val, fb_rvalue);\n+\t    r1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p,\n+\t\t\t\tpost_p, is_gimple_val, fb_rvalue);\n+\t    recalculate_side_effects (*expr_p);\n+\t    ret = MIN (r0, r1);\n+\t    /* Convert &X + CST to invariant &MEM[&X, CST].  Do this\n+\t       after gimplifying operands - this is similar to how\n+\t       it would be folding all gimplified stmts on creation\n+\t       to have them canonicalized, which is what we eventually\n+\t       should do anyway.  */\n+\t    if (TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n+\t\t&& is_gimple_min_invariant (TREE_OPERAND (*expr_p, 0)))\n+\t      {\n+\t\t*expr_p = build_fold_addr_expr_with_type_loc\n+\t\t   (input_location,\n+\t\t    fold_build2 (MEM_REF, TREE_TYPE (TREE_TYPE (*expr_p)),\n+\t\t\t\t TREE_OPERAND (*expr_p, 0),\n+\t\t\t\t fold_convert (ptr_type_node,\n+\t\t\t\t\t       TREE_OPERAND (*expr_p, 1))),\n+\t\t    TREE_TYPE (*expr_p));\n+\t\tret = MIN (ret, GS_OK);\n+\t      }\n+\t    break;\n+\t  }\n \n \tdefault:\n \t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))"}, {"sha": "2449a63ac63b7a5205c09ed5e13573945313a69d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -1,3 +1,11 @@\n+2011-08-30  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/48571\n+\t* gcc.c-torture/execute/pr48571-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-ccp-25.c: Remove.\n+\t* gcc.dg/tree-ssa/ssa-ccp-26.c: Likewise.\n+\t* gcc.dg/pr36902.c: XFAIL.\n+\n 2011-08-30  Ilya Tocar <ilya.tocar@intel.com>\n \n \t* gcc.target/i386/fma-check.h: New."}, {"sha": "063058e43b3a6918a3db5da9a0f15b99bb102b22", "filename": "gcc/testsuite/gcc.c-torture/execute/pr48571-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr48571-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr48571-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr48571-1.c?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -0,0 +1,28 @@\n+unsigned int c[624];\n+void __attribute__((noinline))\n+bar (void)\n+{\n+  unsigned int i;\n+  /* Obfuscated c[i] = c[i-1] * 2.  */\n+  for (i = 1; i < 624; ++i)\n+    *(unsigned int *)((void *)c + (__SIZE_TYPE__)i * 4)\n+\t= 2 * *(unsigned int *)((void *)c + ((__SIZE_TYPE__)i +\n+\t\t\t\t\t     ((__SIZE_TYPE__)-4)/4) * 4);\n+}\n+extern void abort (void);\n+int\n+main()\n+{\n+  unsigned int i, j;\n+  for (i = 0; i < 624; ++i)\n+    c[i] = 1;\n+  bar();\n+  j = 1;\n+  for (i = 0; i < 624; ++i)\n+    {\n+      if (c[i] != j)\n+\tabort ();\n+      j = j * 2;\n+    }\n+  return 0;\n+}"}, {"sha": "a065124ae71642946ce0a61ad84c465f884914bb", "filename": "gcc/testsuite/gcc.dg/pr36902.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -44,7 +44,7 @@ foo2(unsigned char * to, const unsigned char * from, int n)\n       *to = *from;\n       break;\n     case 5:\n-      to[4] = from [4]; /* { dg-warning \"array subscript is above array bounds\" } */\n+      to[4] = from [4]; /* { dg-warning \"array subscript is above array bounds\" \"\" { xfail *-*-* } } */\n       break;\n     }\n   return to;"}, {"sha": "7912a57f09ed0f6f1fd649d026f36db74f067355", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-25.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ddd46d69b09a88fb82832285b69090fa08bddc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ddd46d69b09a88fb82832285b69090fa08bddc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-25.c?ref=2ddd46d69b09a88fb82832285b69090fa08bddc2", "patch": "@@ -1,14 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-ccp1 -fdump-tree-forwprop1\" } */\n-\n-int a[256];\n-int foo(int i)\n-{\n-  int *p = &a[0];\n-  return *(p + i);\n-}\n-\n-/* { dg-final { scan-tree-dump \"&a\\\\\\[\\[iD\\]\\\\\\.\" \"ccp1\" } } */\n-/* { dg-final { scan-tree-dump \"= .*&a\\\\\\]\\\\\\[\\[iD\\]\\\\\\.\" \"forwprop1\" } } */\n-/* { dg-final { cleanup-tree-dump \"ccp1\" } } */\n-/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "c0a548155cb4b011b8787683cd491d2ef47ef23a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-26.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ddd46d69b09a88fb82832285b69090fa08bddc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ddd46d69b09a88fb82832285b69090fa08bddc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-26.c?ref=2ddd46d69b09a88fb82832285b69090fa08bddc2", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-forwprop1\" } */\n-\n-int a[256];\n-int foo(int i)\n-{\n-  return (a + 1)[i];\n-}\n-\n-/* { dg-final { scan-tree-dump \"=.*&a\\\\\\]\\\\\\[D\\\\\\.\" \"forwprop1\" } } */\n-/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "741e8e4d005ccb6e86079849f24c5b8bee487b1e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -853,43 +853,14 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t  tree ptr = TREE_OPERAND (*tp, 0);\n \t  tree type = remap_type (TREE_TYPE (*tp), id);\n \t  tree old = *tp;\n-\t  tree tem;\n \n \t  /* We need to re-canonicalize MEM_REFs from inline substitutions\n \t     that can happen when a pointer argument is an ADDR_EXPR.\n \t     Recurse here manually to allow that.  */\n \t  walk_tree (&ptr, remap_gimple_op_r, data, NULL);\n-\t  if ((tem = maybe_fold_offset_to_reference (EXPR_LOCATION (*tp),\n-\t\t\t\t\t\t     ptr,\n-\t\t\t\t\t\t     TREE_OPERAND (*tp, 1),\n-\t\t\t\t\t\t     type))\n-\t      && TREE_THIS_VOLATILE (tem) == TREE_THIS_VOLATILE (old))\n-\t    {\n-\t      tree *tem_basep = &tem;\n-\t      while (handled_component_p (*tem_basep))\n-\t\ttem_basep = &TREE_OPERAND (*tem_basep, 0);\n-\t      if (TREE_CODE (*tem_basep) == MEM_REF)\n-\t\t*tem_basep\n-\t\t    = build2 (MEM_REF, TREE_TYPE (*tem_basep),\n-\t\t\t      TREE_OPERAND (*tem_basep, 0),\n-\t\t\t      fold_convert (TREE_TYPE (TREE_OPERAND (*tp, 1)),\n-\t\t\t\t\t    TREE_OPERAND (*tem_basep, 1)));\n-\t      else\n-\t\t*tem_basep\n-\t\t    = build2 (MEM_REF, TREE_TYPE (*tem_basep),\n-\t\t\t      build_fold_addr_expr (*tem_basep),\n-\t\t\t      build_int_cst\n-\t\t\t      (TREE_TYPE (TREE_OPERAND (*tp, 1)), 0));\n-\t      *tp = tem;\n-\t      TREE_THIS_VOLATILE (*tem_basep) = TREE_THIS_VOLATILE (old);\n-\t      TREE_THIS_NOTRAP (*tem_basep) = TREE_THIS_NOTRAP (old);\n-\t    }\n-\t  else\n-\t    {\n-\t      *tp = fold_build2 (MEM_REF, type,\n-\t\t\t\t ptr, TREE_OPERAND (*tp, 1));\n-\t      TREE_THIS_NOTRAP (*tp) = TREE_THIS_NOTRAP (old);\n-\t    }\n+\t  *tp = fold_build2 (MEM_REF, type,\n+\t\t\t     ptr, TREE_OPERAND (*tp, 1));\n+\t  TREE_THIS_NOTRAP (*tp) = TREE_THIS_NOTRAP (old);\n \t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t  TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n \t  *walk_subtrees = 0;"}, {"sha": "7dd5e08ac6d14e77f168c7ac9671caaa4584f77c", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315f5f1bfbcbc444e5853fb54fa37edae58e5f91/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=315f5f1bfbcbc444e5853fb54fa37edae58e5f91", "patch": "@@ -1002,31 +1002,21 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n     return false;\n \n   rhs2 = gimple_assign_rhs2 (use_stmt);\n-  /* Try to optimize &x[C1] p+ C2 where C2 is a multiple of the size\n-     of the elements in X into &x[C1 + C2/element size].  */\n+  /* Optimize &x[C1] p+ C2 to  &x p+ C3 with C3 = C1 * element_size + C2.  */\n   if (TREE_CODE (rhs2) == INTEGER_CST)\n     {\n-      tree new_rhs = maybe_fold_stmt_addition (gimple_location (use_stmt),\n-\t  \t\t\t\t       TREE_TYPE (def_rhs),\n-\t\t\t\t\t       def_rhs, rhs2);\n-      if (new_rhs)\n-\t{\n-\t  tree type = TREE_TYPE (gimple_assign_lhs (use_stmt));\n-\t  new_rhs = unshare_expr (new_rhs);\n-\t  if (!useless_type_conversion_p (type, TREE_TYPE (new_rhs)))\n-\t    {\n-\t      if (!is_gimple_min_invariant (new_rhs))\n-\t\tnew_rhs = force_gimple_operand_gsi (use_stmt_gsi, new_rhs,\n-\t\t\t\t\t\t    true, NULL_TREE,\n-\t\t\t\t\t\t    true, GSI_SAME_STMT);\n-\t      new_rhs = fold_convert (type, new_rhs);\n-\t    }\n-\t  gimple_assign_set_rhs_from_tree (use_stmt_gsi, new_rhs);\n-\t  use_stmt = gsi_stmt (*use_stmt_gsi);\n-\t  update_stmt (use_stmt);\n-\t  tidy_after_forward_propagate_addr (use_stmt);\n-\t  return true;\n-\t}\n+      tree new_rhs = build1_loc (gimple_location (use_stmt),\n+\t\t\t\t ADDR_EXPR, TREE_TYPE (def_rhs),\n+\t\t\t\t fold_build2 (MEM_REF,\n+\t\t\t\t\t      TREE_TYPE (TREE_TYPE (def_rhs)),\n+\t\t\t\t\t      unshare_expr (def_rhs),\n+\t\t\t\t\t      fold_convert (ptr_type_node,\n+\t\t\t\t\t\t\t    rhs2)));\n+      gimple_assign_set_rhs_from_tree (use_stmt_gsi, new_rhs);\n+      use_stmt = gsi_stmt (*use_stmt_gsi);\n+      update_stmt (use_stmt);\n+      tidy_after_forward_propagate_addr (use_stmt);\n+      return true;\n     }\n \n   /* Try to optimize &x[0] p+ OFFSET where OFFSET is defined by"}]}