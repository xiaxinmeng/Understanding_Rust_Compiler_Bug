{"sha": "36cabc257dfb7dd4f7625896891f6c5b195a0241", "node_id": "C_kwDOANBUbNoAKDM2Y2FiYzI1N2RmYjdkZDRmNzYyNTg5Njg5MWY2YzViMTk1YTAyNDE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-29T14:55:21Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-29T14:55:21Z"}, "message": "c++: explicit specialization and trailing requirements [PR107864]\n\nHere we're crashing when using the explicit specialization of the\nfunction template g with trailing requirements ultimately because\nearlier decls_match (called indirectly from register_specialization) for\nfor the explicit specialization returned false since the template has\ntrailing requirements whereas the specialization doesn't.\n\nIn r12-2230-gddd25bd1a7c8f4, we fixed a similar issue concerning template\nrequirements instead of trailing requirements.  We could extend that fix\nto ignore trailing requirement mismatches for explicit specializations\nas well, but it seems cleaner to just propagate constraints from the\nspecialized template to the specialization when declaring an explicit\nspecialization so that decls_match will naturally return true in this\ncase.  And it looks like determine_specialization already does this,\nalbeit inconsistently (only when specializing a non-template member\nfunction of a class template as in cpp2a/concepts-explicit-spec4.C).\n\nSo this patch makes determine_specialization consistently propagate\nconstraints from the specialized template to the specialization, which\nin turn lets us get rid of the function_requirements_equivalent_p special\ncase added by r12-2230.\n\n\tPR c++/107864\n\ngcc/cp/ChangeLog:\n\n\t* decl.cc (function_requirements_equivalent_p): Don't check\n\tDECL_TEMPLATE_SPECIALIZATION.\n\t* pt.cc (determine_specialization): Propagate constraints when\n\tspecializing a function template too.  Simplify by using\n\tadd_outermost_template_args.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/concepts/explicit-spec1a.C: New test.", "tree": {"sha": "c59bd6d2f0e207a37c6cc857cd34af0e01b9c9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59bd6d2f0e207a37c6cc857cd34af0e01b9c9a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36cabc257dfb7dd4f7625896891f6c5b195a0241", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36cabc257dfb7dd4f7625896891f6c5b195a0241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36cabc257dfb7dd4f7625896891f6c5b195a0241", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36cabc257dfb7dd4f7625896891f6c5b195a0241/comments", "author": null, "committer": null, "parents": [{"sha": "fd8dd6c0384969170e594be34da278a072d5eb76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8dd6c0384969170e594be34da278a072d5eb76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd8dd6c0384969170e594be34da278a072d5eb76"}], "stats": {"total": 34, "additions": 20, "deletions": 14}, "files": [{"sha": "238e72f90da250af37cf7258c577ce1092c63006", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cabc257dfb7dd4f7625896891f6c5b195a0241/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cabc257dfb7dd4f7625896891f6c5b195a0241/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=36cabc257dfb7dd4f7625896891f6c5b195a0241", "patch": "@@ -956,9 +956,7 @@ static bool\n function_requirements_equivalent_p (tree newfn, tree oldfn)\n {\n   /* In the concepts TS, the combined constraints are compared.  */\n-  if (cxx_dialect < cxx20\n-      && (DECL_TEMPLATE_SPECIALIZATION (newfn)\n-\t  <= DECL_TEMPLATE_SPECIALIZATION (oldfn)))\n+  if (cxx_dialect < cxx20)\n     {\n       tree ci1 = get_constraints (oldfn);\n       tree ci2 = get_constraints (newfn);"}, {"sha": "2d8e4fdd4b55aac9904fd31b783b71d8a09e429d", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cabc257dfb7dd4f7625896891f6c5b195a0241/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cabc257dfb7dd4f7625896891f6c5b195a0241/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=36cabc257dfb7dd4f7625896891f6c5b195a0241", "patch": "@@ -2482,17 +2482,14 @@ determine_specialization (tree template_id,\n     }\n \n   /* It was a specialization of a template.  */\n-  targs = DECL_TI_ARGS (DECL_TEMPLATE_RESULT (TREE_VALUE (templates)));\n-  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (targs))\n-    {\n-      *targs_out = copy_node (targs);\n-      SET_TMPL_ARGS_LEVEL (*targs_out,\n-\t\t\t   TMPL_ARGS_DEPTH (*targs_out),\n-\t\t\t   TREE_PURPOSE (templates));\n-    }\n-  else\n-    *targs_out = TREE_PURPOSE (templates);\n-  return TREE_VALUE (templates);\n+  tree tmpl = TREE_VALUE (templates);\n+  *targs_out = add_outermost_template_args (tmpl, TREE_PURPOSE (templates));\n+\n+  /* Propagate the template's constraints to the declaration.  */\n+  if (tsk != tsk_template)\n+    set_constraints (decl, get_constraints (tmpl));\n+\n+  return tmpl;\n }\n \n /* Returns a chain of parameter types, exactly like the SPEC_TYPES,"}, {"sha": "ec678740cb8ebe8a18c363f23cdc95d34fdb98ab", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec1a.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cabc257dfb7dd4f7625896891f6c5b195a0241/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cabc257dfb7dd4f7625896891f6c5b195a0241/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec1a.C?ref=36cabc257dfb7dd4f7625896891f6c5b195a0241", "patch": "@@ -0,0 +1,11 @@\n+// A version of explicit-spec1.C where the template g has trailing instead of\n+// template requirements.\n+// PR c++/107864\n+// { dg-do compile { target concepts } }\n+\n+template<typename T> concept C = __is_class(T);\n+struct Y { int n; } y;\n+template<class T> void g(T) requires C<T> { }\n+int called;\n+template<> void g(Y) { called = 3; }\n+int main() { g(y); }"}]}