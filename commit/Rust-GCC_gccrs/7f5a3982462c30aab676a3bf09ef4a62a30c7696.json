{"sha": "7f5a3982462c30aab676a3bf09ef4a62a30c7696", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y1YTM5ODI0NjJjMzBhYWI2NzZhM2JmMDllZjRhNjJhMzBjNzY5Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-06-04T22:12:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-06-04T22:12:51Z"}, "message": "gimple-ssa-store-merging.c (struct merged_store_group): Move up bit_insertion field and declare can_be_merged_into method.\n\n\t* gimple-ssa-store-merging.c (struct merged_store_group): Move up\n\tbit_insertion field and declare can_be_merged_into method.\n\t(merged_store_group::can_be_merged_into): New method.\n\t(imm_store_chain_info::coalesce_immediate): Call it to decide whether\n\tconsecutive non-overlapping stores can be merged.  Turn MEM_REF stores\n\tinto BIT_INSERT_EXPR stores if the group contains a non-MEM_REF store.\n\nFrom-SVN: r261173", "tree": {"sha": "65cd8834a5ebf2e1e26081175b3fc1a4b46b0b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65cd8834a5ebf2e1e26081175b3fc1a4b46b0b3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f5a3982462c30aab676a3bf09ef4a62a30c7696", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5a3982462c30aab676a3bf09ef4a62a30c7696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f5a3982462c30aab676a3bf09ef4a62a30c7696", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5a3982462c30aab676a3bf09ef4a62a30c7696/comments", "author": null, "committer": null, "parents": [{"sha": "d552d8190dd2d9927fa55d09b73067eb6f40b7dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d552d8190dd2d9927fa55d09b73067eb6f40b7dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d552d8190dd2d9927fa55d09b73067eb6f40b7dd"}], "stats": {"total": 168, "additions": 146, "deletions": 22}, "files": [{"sha": "074e1492afc0a3c2050a4ff3dd0ea53a1f04e4ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f5a3982462c30aab676a3bf09ef4a62a30c7696", "patch": "@@ -1,3 +1,12 @@\n+2018-06-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimple-ssa-store-merging.c (struct merged_store_group): Move up\n+\tbit_insertion field and declare can_be_merged_into method.\n+\t(merged_store_group::can_be_merged_into): New method.\n+\t(imm_store_chain_info::coalesce_immediate): Call it to decide whether\n+\tconsecutive non-overlapping stores can be merged.  Turn MEM_REF stores\n+\tinto BIT_INSERT_EXPR stores if the group contains a non-MEM_REF store.\n+\n 2018-06-04  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/85955"}, {"sha": "1cefdeb69b8347d93015a39a89e3489b1ee84d7d", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 76, "deletions": 21, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=7f5a3982462c30aab676a3bf09ef4a62a30c7696", "patch": "@@ -1426,6 +1426,7 @@ struct merged_store_group\n   unsigned int load_align[2];\n   unsigned int first_order;\n   unsigned int last_order;\n+  bool bit_insertion;\n \n   auto_vec<store_immediate_info *> stores;\n   /* We record the first and last original statements in the sequence because\n@@ -1435,10 +1436,10 @@ struct merged_store_group\n   gimple *first_stmt;\n   unsigned char *val;\n   unsigned char *mask;\n-  bool bit_insertion;\n \n   merged_store_group (store_immediate_info *);\n   ~merged_store_group ();\n+  bool can_be_merged_into (store_immediate_info *);\n   void merge_into (store_immediate_info *);\n   void merge_overlapping (store_immediate_info *);\n   bool apply_stores ();\n@@ -1851,8 +1852,47 @@ merged_store_group::~merged_store_group ()\n     XDELETEVEC (val);\n }\n \n+/* Return true if the store described by INFO can be merged into the group.  */\n+\n+bool\n+merged_store_group::can_be_merged_into (store_immediate_info *info)\n+{\n+  /* Do not merge bswap patterns.  */\n+  if (info->rhs_code == LROTATE_EXPR)\n+    return false;\n+\n+  /* The canonical case.  */\n+  if (info->rhs_code == stores[0]->rhs_code)\n+    return true;\n+\n+  /* BIT_INSERT_EXPR is compatible with INTEGER_CST.  */\n+  if (info->rhs_code == BIT_INSERT_EXPR && stores[0]->rhs_code == INTEGER_CST)\n+    return true;\n+\n+  if (stores[0]->rhs_code == BIT_INSERT_EXPR && info->rhs_code == INTEGER_CST)\n+    return true;\n+\n+  /* We can turn MEM_REF into BIT_INSERT_EXPR for bit-field stores.  */\n+  if (info->rhs_code == MEM_REF\n+      && (stores[0]->rhs_code == INTEGER_CST\n+\t  || stores[0]->rhs_code == BIT_INSERT_EXPR)\n+      && info->bitregion_start == stores[0]->bitregion_start\n+      && info->bitregion_end == stores[0]->bitregion_end)\n+    return true;\n+\n+  if (stores[0]->rhs_code == MEM_REF\n+      && (info->rhs_code == INTEGER_CST\n+\t  || info->rhs_code == BIT_INSERT_EXPR)\n+      && info->bitregion_start == stores[0]->bitregion_start\n+      && info->bitregion_end == stores[0]->bitregion_end)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Helper method for merge_into and merge_overlapping to do\n    the common part.  */\n+\n void\n merged_store_group::do_merge (store_immediate_info *info)\n {\n@@ -2673,12 +2713,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t Merge it into the current store group.  There can be gaps in between\n \t the stores, but there can't be gaps in between bitregions.  */\n       else if (info->bitregion_start <= merged_store->bitregion_end\n-\t       && info->rhs_code != LROTATE_EXPR\n-\t       && (info->rhs_code == merged_store->stores[0]->rhs_code\n-\t\t   || (info->rhs_code == INTEGER_CST\n-\t\t       && merged_store->stores[0]->rhs_code == BIT_INSERT_EXPR)\n-\t\t   || (info->rhs_code == BIT_INSERT_EXPR\n-\t\t       && merged_store->stores[0]->rhs_code == INTEGER_CST)))\n+\t       && merged_store->can_be_merged_into (info))\n \t{\n \t  store_immediate_info *infof = merged_store->stores[0];\n \n@@ -2696,21 +2731,41 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t      std::swap (info->ops[0], info->ops[1]);\n \t      info->ops_swapped_p = true;\n \t    }\n-\t  if ((infof->ops[0].base_addr\n-\t       ? compatible_load_p (merged_store, info, base_addr, 0)\n-\t       : !info->ops[0].base_addr)\n-\t      && (infof->ops[1].base_addr\n-\t\t  ? compatible_load_p (merged_store, info, base_addr, 1)\n-\t\t  : !info->ops[1].base_addr)\n-\t      && check_no_overlap (m_store_info, i, info->rhs_code,\n-\t\t\t\t   MAX (merged_store->last_order,\n-\t\t\t\t\tinfo->order),\n-\t\t\t\t   MAX (merged_store->start\n-\t\t\t\t\t+ merged_store->width,\n-\t\t\t\t\tinfo->bitpos + info->bitsize)))\n+\t  if (check_no_overlap (m_store_info, i, info->rhs_code,\n+\t\t\t\tMAX (merged_store->last_order,\n+\t\t\t\t     info->order),\n+\t\t\t\tMAX (merged_store->start\n+\t\t\t\t     + merged_store->width,\n+\t\t\t\t     info->bitpos + info->bitsize)))\n \t    {\n-\t      merged_store->merge_into (info);\n-\t      goto done;\n+\t      /* Turn MEM_REF into BIT_INSERT_EXPR for bit-field stores.  */\n+\t      if (info->rhs_code == MEM_REF && infof->rhs_code != MEM_REF)\n+\t\t{\n+\t\t  info->rhs_code = BIT_INSERT_EXPR;\n+\t\t  info->ops[0].val = gimple_assign_rhs1 (info->stmt);\n+\t\t  info->ops[0].base_addr = NULL_TREE;\n+\t\t}\n+\t      else if (infof->rhs_code == MEM_REF && info->rhs_code != MEM_REF)\n+\t\t{\n+\t\t  store_immediate_info *infoj;\n+\t\t  unsigned int j;\n+\t\t  FOR_EACH_VEC_ELT (merged_store->stores, j, infoj)\n+\t\t    {\n+\t\t      infoj->rhs_code = BIT_INSERT_EXPR;\n+\t\t      infoj->ops[0].val = gimple_assign_rhs1 (infoj->stmt);\n+\t\t      infoj->ops[0].base_addr = NULL_TREE;\n+\t\t    }\n+\t\t}\n+\t      if ((infof->ops[0].base_addr\n+\t\t   ? compatible_load_p (merged_store, info, base_addr, 0)\n+\t\t   : !info->ops[0].base_addr)\n+\t\t  && (infof->ops[1].base_addr\n+\t\t      ? compatible_load_p (merged_store, info, base_addr, 1)\n+\t\t      : !info->ops[1].base_addr))\n+\t\t{\n+\t\t  merged_store->merge_into (info);\n+\t\t  goto done;\n+\t\t}\n \t    }\n \t}\n "}, {"sha": "0d7bd34864b0c99b41888e0af28c2732e6a78c78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f5a3982462c30aab676a3bf09ef4a62a30c7696", "patch": "@@ -1,3 +1,10 @@\n+2018-06-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/store_merging_21.c: New test.\n+\t* gnat.dg/opt71b.adb: Likewise.\n+\t* gnat.dg/opt71.adb: Rename into...\n+\t* gnat.dg/opt71a.adb: ...this.\n+\n 2018-06-04  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/85955"}, {"sha": "ec0c8e240b7427cb0be20d4057c9316d16b6317e", "filename": "gcc/testsuite/gcc.dg/store_merging_21.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_21.c?ref=7f5a3982462c30aab676a3bf09ef4a62a30c7696", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+extern void abort (void);\n+\n+struct S1 {\n+  unsigned int flag : 1;\n+  unsigned int size : 31;\n+};\n+\n+void foo1 (struct S1 *s, struct S1 *m)\n+{\n+  s->flag = 1;\n+  s->size = m->size;\n+}\n+\n+void bar1 (struct S1 *s, struct S1 *m, _Bool flag)\n+{\n+  s->flag = flag;\n+  s->size = m->size;\n+}\n+\n+struct S2 {\n+  unsigned int size : 31;\n+  unsigned int flag : 1;\n+};\n+\n+void foo2 (struct S2 *s, struct S2 *m)\n+{\n+  s->size = m->size;\n+  s->flag = 1;\n+}\n+\n+void bar2 (struct S2 *s, struct S2 *m, _Bool flag)\n+{\n+  s->flag = flag;\n+  s->size = m->size;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 4 \"store-merging\" } } */"}, {"sha": "d2bd2b39840f1b4e8162a143113116f143cb9f30", "filename": "gcc/testsuite/gnat.dg/opt71a.adb", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71a.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71a.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71a.adb?ref=7f5a3982462c30aab676a3bf09ef4a62a30c7696", "patch": "@@ -4,7 +4,7 @@\n \n with Opt71_Pkg; use Opt71_Pkg;\n \n-procedure Opt71 (X : not null access Rec; Size : Positive) is\n+procedure Opt71a (X : not null access Rec; Size : Positive) is\n begin\n    X.all := (Flag => True, Size => Size);\n end;", "previous_filename": "gcc/testsuite/gnat.dg/opt71.adb"}, {"sha": "9fd91180b150eca1e0d8d9d270e571c1a5f09fa2", "filename": "gcc/testsuite/gnat.dg/opt71b.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5a3982462c30aab676a3bf09ef4a62a30c7696/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71b.adb?ref=7f5a3982462c30aab676a3bf09ef4a62a30c7696", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-require-effective-target store_merge }\n+-- { dg-options \"-O2 -fdump-tree-store-merging\" }\n+\n+with Opt71_Pkg; use Opt71_Pkg;\n+\n+procedure Opt71b (X : not null access Rec; Y : not null access Rec) is\n+begin\n+   X.all := (Flag => True, Size => Y.Size);\n+end;\n+\n+-- { dg-final { scan-tree-dump \"Merging successful\" \"store-merging\" } }"}]}