{"sha": "4e85ad79a137535393d8dc169359e1730cab3533", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU4NWFkNzlhMTM3NTM1MzkzZDhkYzE2OTM1OWUxNzMwY2FiMzUzMw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-09T12:12:55Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-09T14:42:10Z"}, "message": "Cleanup irange::set.\n\n[This is actually part of a larger patch that actually changes\nbehavior, but I thought I'd commit the non-invasive cleanups first\nwhich will simplify the upcoming work.]\n\nirange::set was doing more work than it should for legacy ranges.\nI cleaned up various unnecessary calls to swap_out_of_order_endpoints,\nas well as some duplicate code that could be done with normalize_min_max.\n\nI also removed an obsolete comment wrt sticky infinite overflows.\nNot only did the -INF/+INF(OVF) code get removed in 2017,\nbut normalize_min_max() uses wide ints, which ignored overflows\naltogether.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (irange::swap_out_of_order_endpoints): Rewrite\n\tinto static function.\n\t(irange::set): Cleanup redundant manipulations.\n\t* value-range.h (irange::normalize_min_max): Modify object\n\tin-place instead of modifying arguments.", "tree": {"sha": "807f1f89053079a2680caf8d8695fe292bac0282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/807f1f89053079a2680caf8d8695fe292bac0282"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e85ad79a137535393d8dc169359e1730cab3533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e85ad79a137535393d8dc169359e1730cab3533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e85ad79a137535393d8dc169359e1730cab3533", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e85ad79a137535393d8dc169359e1730cab3533/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa59c8dcd2f97c929150bd32bae1f341e0d7b0f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa59c8dcd2f97c929150bd32bae1f341e0d7b0f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa59c8dcd2f97c929150bd32bae1f341e0d7b0f7"}], "stats": {"total": 98, "additions": 37, "deletions": 61}, "files": [{"sha": "2124e229e0ccf0a2247fe1c7707f8961684b9583", "filename": "gcc/value-range.cc", "status": "modified", "additions": 24, "deletions": 46, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e85ad79a137535393d8dc169359e1730cab3533/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e85ad79a137535393d8dc169359e1730cab3533/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=4e85ad79a137535393d8dc169359e1730cab3533", "patch": "@@ -131,13 +131,14 @@ irange::copy_to_legacy (const irange &src)\n     set (src.tree_lower_bound (), src.tree_upper_bound ());\n }\n \n-// Swap min/max if they are out of order.  Return TRUE if further\n-// processing of the range is necessary, FALSE otherwise.\n+// Swap MIN/MAX if they are out of order and adjust KIND appropriately.\n \n-bool\n-irange::swap_out_of_order_endpoints (tree &min, tree &max,\n-\t\t\t\t\t  value_range_kind &kind)\n+static void\n+swap_out_of_order_endpoints (tree &min, tree &max, value_range_kind &kind)\n {\n+  gcc_checking_assert (kind != VR_UNDEFINED);\n+  if (kind == VR_VARYING)\n+    return;\n   /* Wrong order for min and max, to swap them and the VR type we need\n      to adjust them.  */\n   if (tree_int_cst_lt (max, min))\n@@ -149,8 +150,8 @@ irange::swap_out_of_order_endpoints (tree &min, tree &max,\n \t for VR_ANTI_RANGE empty range, so drop to varying as well.  */\n       if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n \t{\n-\t  set_varying (TREE_TYPE (min));\n-\t  return false;\n+\t  kind = VR_VARYING;\n+\t  return;\n \t}\n \n       one = build_int_cst (TREE_TYPE (min), 1);\n@@ -163,12 +164,11 @@ irange::swap_out_of_order_endpoints (tree &min, tree &max,\n \t to varying in this case.  */\n       if (tree_int_cst_lt (max, min))\n \t{\n-\t  set_varying (TREE_TYPE (min));\n-\t  return false;\n+\t  kind = VR_VARYING;\n+\t  return;\n \t}\n       kind = kind == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n     }\n-  return true;\n }\n \n void\n@@ -253,13 +253,6 @@ irange::set (tree min, tree max, value_range_kind kind)\n       && (POLY_INT_CST_P (min) || POLY_INT_CST_P (max)))\n     kind = VR_VARYING;\n \n-  if (kind == VR_VARYING)\n-    {\n-      set_varying (TREE_TYPE (min));\n-      return;\n-    }\n-\n-  tree type = TREE_TYPE (min);\n   // Nothing to canonicalize for symbolic ranges.\n   if (TREE_CODE (min) != INTEGER_CST\n       || TREE_CODE (max) != INTEGER_CST)\n@@ -270,8 +263,13 @@ irange::set (tree min, tree max, value_range_kind kind)\n       m_num_ranges = 1;\n       return;\n     }\n-  if (!swap_out_of_order_endpoints (min, max, kind))\n-    goto cleanup_set;\n+\n+  swap_out_of_order_endpoints (min, max, kind);\n+  if (kind == VR_VARYING)\n+    {\n+      set_varying (TREE_TYPE (min));\n+      return;\n+    }\n \n   // Anti-ranges that can be represented as ranges should be so.\n   if (kind == VR_ANTI_RANGE)\n@@ -280,6 +278,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n          values < -INF and values > INF as -INF/INF as well.  */\n       bool is_min = vrp_val_is_min (min);\n       bool is_max = vrp_val_is_max (max);\n+      tree type = TREE_TYPE (min);\n \n       if (is_min && is_max)\n \t{\n@@ -314,38 +313,17 @@ irange::set (tree min, tree max, value_range_kind kind)\n \t  kind = VR_RANGE;\n         }\n     }\n-  else if (!swap_out_of_order_endpoints (min, max, kind))\n-    goto cleanup_set;\n-\n-  /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky\n-     to make sure VRP iteration terminates, otherwise we can get into\n-     oscillations.  */\n-  if (!normalize_min_max (type, min, max, kind))\n-    {\n-      m_kind = kind;\n-      m_base[0] = min;\n-      m_base[1] = max;\n-      m_num_ranges = 1;\n-      if (flag_checking)\n-\tverify_range ();\n-    }\n \n- cleanup_set:\n-  // Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n-  // restrict those to a subset of what actually fits in the type.\n-  // Instead use the extremes of the type precision\n-  unsigned prec = TYPE_PRECISION (type);\n-  signop sign = TYPE_SIGN (type);\n-  if (wi::eq_p (wi::to_wide (min), wi::min_value (prec, sign))\n-      && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n-    m_kind = VR_VARYING;\n-  else if (undefined_p ())\n-    m_kind = VR_UNDEFINED;\n+  m_kind = kind;\n+  m_base[0] = min;\n+  m_base[1] = max;\n+  m_num_ranges = 1;\n+  normalize_min_max ();\n   if (flag_checking)\n     verify_range ();\n }\n \n-/* Check the validity of the range.  */\n+// Check the validity of the range.\n \n void\n irange::verify_range ()"}, {"sha": "a483fc802dd569051dedbd383ac3e936021f2821", "filename": "gcc/value-range.h", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e85ad79a137535393d8dc169359e1730cab3533/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e85ad79a137535393d8dc169359e1730cab3533/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=4e85ad79a137535393d8dc169359e1730cab3533", "patch": "@@ -111,8 +111,7 @@ class irange\n   void irange_set (tree, tree);\n   void irange_set_anti_range (tree, tree);\n \n-  bool swap_out_of_order_endpoints (tree &min, tree &max, value_range_kind &);\n-  bool normalize_min_max (tree type, tree min, tree max, value_range_kind);\n+  void normalize_min_max ();\n \n   bool legacy_mode_p () const;\n   bool legacy_equal_p (const irange &) const;\n@@ -566,7 +565,7 @@ irange::set_zero (tree type)\n     irange_set (z, z);\n }\n \n-// Normalize [MIN, MAX] into VARYING and ~[MIN, MAX] into UNDEFINED.\n+// Normalize a range to VARYING or UNDEFINED if possible.\n //\n // Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n // restrict those to a subset of what actually fits in the type.\n@@ -575,24 +574,23 @@ irange::set_zero (tree type)\n // whereas if we used TYPE_*_VAL, said function would just punt upon\n // seeing a VARYING.\n \n-inline bool\n-irange::normalize_min_max (tree type, tree min, tree max,\n-\t\t\t   value_range_kind kind)\n+inline void\n+irange::normalize_min_max ()\n {\n-  unsigned prec = TYPE_PRECISION (type);\n-  signop sign = TYPE_SIGN (type);\n-  if (wi::eq_p (wi::to_wide (min), wi::min_value (prec, sign))\n-      && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n+  gcc_checking_assert (legacy_mode_p ());\n+  gcc_checking_assert (!undefined_p ());\n+  unsigned prec = TYPE_PRECISION (type ());\n+  signop sign = TYPE_SIGN (type ());\n+  if (wi::eq_p (wi::to_wide (min ()), wi::min_value (prec, sign))\n+      && wi::eq_p (wi::to_wide (max ()), wi::max_value (prec, sign)))\n     {\n-      if (kind == VR_RANGE)\n-\tset_varying (type);\n-      else if (kind == VR_ANTI_RANGE)\n+      if (m_kind == VR_RANGE)\n+\tset_varying (type ());\n+      else if (m_kind == VR_ANTI_RANGE)\n \tset_undefined ();\n       else\n \tgcc_unreachable ();\n-      return true;\n     }\n-  return false;\n }\n \n // Return the maximum value for TYPE."}]}