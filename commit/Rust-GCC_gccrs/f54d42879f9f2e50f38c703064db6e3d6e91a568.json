{"sha": "f54d42879f9f2e50f38c703064db6e3d6e91a568", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU0ZDQyODc5ZjlmMmU1MGYzOGM3MDMwNjRkYjZlM2Q2ZTkxYTU2OA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-05-21T06:39:23Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-05-21T06:39:23Z"}, "message": "Initial revision\n\nFrom-SVN: r42370", "tree": {"sha": "74fdbde7939a341e9ef653b68f90004a5beb56a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74fdbde7939a341e9ef653b68f90004a5beb56a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f54d42879f9f2e50f38c703064db6e3d6e91a568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54d42879f9f2e50f38c703064db6e3d6e91a568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f54d42879f9f2e50f38c703064db6e3d6e91a568", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54d42879f9f2e50f38c703064db6e3d6e91a568/comments", "author": null, "committer": null, "parents": [{"sha": "9d2f2c45d8936179588489a6cb3df61203ed1028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2f2c45d8936179588489a6cb3df61203ed1028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d2f2c45d8936179588489a6cb3df61203ed1028"}], "stats": {"total": 7939, "additions": 7939, "deletions": 0}, "files": [{"sha": "f4024a7978fe283bb095b668e90a195253902ce0", "filename": "boehm-gc/AmigaOS.c", "status": "added", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2FAmigaOS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2FAmigaOS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FAmigaOS.c?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,623 @@\n+\n+\n+/******************************************************************\n+\n+  AmigaOS-spesific routines for GC.\n+  This file is normally included from os_dep.c\n+\n+******************************************************************/\n+\n+\n+#if !defined(GC_AMIGA_DEF) && !defined(GC_AMIGA_SB) && !defined(GC_AMIGA_DS) && !defined(GC_AMIGA_AM)\n+# include \"gc_priv.h\"\n+# include <stdio.h>\n+# include <signal.h>\n+# define GC_AMIGA_DEF\n+# define GC_AMIGA_SB\n+# define GC_AMIGA_DS\n+# define GC_AMIGA_AM\n+#endif\n+\n+\n+#ifdef GC_AMIGA_DEF\n+\n+# ifndef __GNUC__\n+#   include <exec/exec.h>\n+# endif\n+# include <proto/exec.h>\n+# include <proto/dos.h>\n+# include <dos/dosextens.h>\n+# include <workbench/startup.h>\n+\n+#endif\n+\n+\n+\n+\n+#ifdef GC_AMIGA_SB\n+\n+/******************************************************************\n+   Find the base of the stack.\n+******************************************************************/\n+\n+ptr_t GC_get_stack_base()\n+{\n+    struct Process *proc = (struct Process*)SysBase->ThisTask;\n+ \n+    /* Reference: Amiga Guru Book Pages: 42,567,574 */\n+    if (proc->pr_Task.tc_Node.ln_Type==NT_PROCESS\n+        && proc->pr_CLI != NULL) {\n+\t/* first ULONG is StackSize */\n+\t/*longPtr = proc->pr_ReturnAddr;\n+\tsize = longPtr[0];*/\n+\n+\treturn (char *)proc->pr_ReturnAddr + sizeof(ULONG);\n+    } else {\n+\treturn (char *)proc->pr_Task.tc_SPUpper;\n+    }\n+}\n+\n+#if 0 /* old version */\n+ptr_t GC_get_stack_base()\n+{\n+    extern struct WBStartup *_WBenchMsg;\n+    extern long __base;\n+    extern long __stack;\n+    struct Task *task;\n+    struct Process *proc;\n+    struct CommandLineInterface *cli;\n+    long size;\n+\n+    if ((task = FindTask(0)) == 0) {\n+\tGC_err_puts(\"Cannot find own task structure\\n\");\n+\tABORT(\"task missing\");\n+    }\n+    proc = (struct Process *)task;\n+    cli = BADDR(proc->pr_CLI);\n+\n+    if (_WBenchMsg != 0 || cli == 0) {\n+\tsize = (char *)task->tc_SPUpper - (char *)task->tc_SPLower;\n+    } else {\n+\tsize = cli->cli_DefaultStack * 4;\n+    }\n+    return (ptr_t)(__base + GC_max(size, __stack));\n+}\n+#endif\n+\n+\n+#endif\n+\n+\n+#ifdef GC_AMIGA_DS\n+/******************************************************************\n+   Register data segments.\n+******************************************************************/\n+\n+   void GC_register_data_segments()\n+   {\n+     struct Process\t*proc;\n+     struct CommandLineInterface *cli;\n+     BPTR myseglist;\n+     ULONG *data;\n+ \n+     int\tnum;\n+\n+\n+#    ifdef __GNUC__\n+        ULONG dataSegSize;\n+        GC_bool found_segment = FALSE;\n+\textern char __data_size[];\n+\n+\tdataSegSize=__data_size+8;\n+\t/* Can`t find the Location of __data_size, because\n+           it`s possible that is it, inside the segment. */\n+\n+#     endif\n+\n+\tproc= (struct Process*)SysBase->ThisTask;\n+\n+\t/* Reference: Amiga Guru Book Pages: 538ff,565,573\n+\t\t     and XOper.asm */\n+\tif (proc->pr_Task.tc_Node.ln_Type==NT_PROCESS) {\n+\t  if (proc->pr_CLI == NULL) {\n+\t    myseglist = proc->pr_SegList;\n+\t  } else {\n+\t    /* ProcLoaded\t'Loaded as a command: '*/\n+\t    cli = BADDR(proc->pr_CLI);\n+\t    myseglist = cli->cli_Module;\n+\t  }\n+\t} else {\n+\t  ABORT(\"Not a Process.\");\n+ \t}\n+\n+\tif (myseglist == NULL) {\n+\t    ABORT(\"Arrrgh.. can't find segments, aborting\");\n+ \t}\n+\n+\t/* xoper hunks Shell Process */\n+\n+\tnum=0;\n+        for (data = (ULONG *)BADDR(myseglist); data != NULL;\n+             data = (ULONG *)BADDR(data[0])) {\n+\t  if (((ULONG) GC_register_data_segments < (ULONG) &data[1]) ||\n+\t      ((ULONG) GC_register_data_segments > (ULONG) &data[1] + data[-1])) {\n+#             ifdef __GNUC__\n+\t\tif (dataSegSize == data[-1]) {\n+\t\t  found_segment = TRUE;\n+\t\t}\n+# \t      endif\n+\t      GC_add_roots_inner((char *)&data[1],\n+\t\t\t\t ((char *)&data[1]) + data[-1], FALSE);\n+          }\n+          ++num;\n+        } /* for */\n+# \tifdef __GNUC__\n+\t   if (!found_segment) {\n+\t     ABORT(\"Can`t find correct Segments.\\nSolution: Use an newer version of ixemul.library\");\n+\t   }\n+# \tendif\n+  }\n+\n+#if 0 /* old version */\n+  void GC_register_data_segments()\n+  {\n+    extern struct WBStartup *_WBenchMsg;\n+    struct Process\t*proc;\n+    struct CommandLineInterface *cli;\n+    BPTR myseglist;\n+    ULONG *data;\n+\n+    if ( _WBenchMsg != 0 ) {\n+\tif ((myseglist = _WBenchMsg->sm_Segment) == 0) {\n+\t    GC_err_puts(\"No seglist from workbench\\n\");\n+\t    return;\n+\t}\n+    } else {\n+\tif ((proc = (struct Process *)FindTask(0)) == 0) {\n+\t    GC_err_puts(\"Cannot find process structure\\n\");\n+\t    return;\n+\t}\n+\tif ((cli = BADDR(proc->pr_CLI)) == 0) {\n+\t    GC_err_puts(\"No CLI\\n\");\n+\t    return;\n+\t}\n+\tif ((myseglist = cli->cli_Module) == 0) {\n+\t    GC_err_puts(\"No seglist from CLI\\n\");\n+\t    return;\n+\t}\n+    }\n+\n+    for (data = (ULONG *)BADDR(myseglist); data != 0;\n+         data = (ULONG *)BADDR(data[0])) {\n+#        ifdef AMIGA_SKIP_SEG\n+           if (((ULONG) GC_register_data_segments < (ULONG) &data[1]) ||\n+           ((ULONG) GC_register_data_segments > (ULONG) &data[1] + data[-1])) {\n+#\t else\n+      \t   {\n+#\t endif /* AMIGA_SKIP_SEG */\n+          GC_add_roots_inner((char *)&data[1],\n+          \t\t     ((char *)&data[1]) + data[-1], FALSE);\n+         }\n+    }\n+  }\n+#endif /* old version */\n+\n+\n+#endif\n+\n+\n+\n+#ifdef GC_AMIGA_AM\n+\n+#ifndef GC_AMIGA_FASTALLOC\n+\n+void *GC_amiga_allocwrapper(size_t size,void *(*AllocFunction)(size_t size2)){\n+\treturn (*AllocFunction)(size);\n+}\n+\n+void *(*GC_amiga_allocwrapper_do)(size_t size,void *(*AllocFunction)(size_t size2))\n+\t=GC_amiga_allocwrapper;\n+\n+#else\n+\n+\n+\n+\n+void *GC_amiga_allocwrapper_firsttime(size_t size,void *(*AllocFunction)(size_t size2));\n+\n+void *(*GC_amiga_allocwrapper_do)(size_t size,void *(*AllocFunction)(size_t size2))\n+\t=GC_amiga_allocwrapper_firsttime;\n+\n+\n+/******************************************************************\n+   Amiga-spesific routines to obtain memory, and force GC to give\n+   back fast-mem whenever possible.\n+\tThese hacks makes gc-programs go many times faster when\n+   the amiga is low on memory, and are therefore strictly necesarry.\n+\n+   -Kjetil S. Matheussen, 2000.\n+******************************************************************/\n+\n+\n+\n+/* List-header for all allocated memory. */\n+\n+struct GC_Amiga_AllocedMemoryHeader{\n+\tULONG size;\n+\tstruct GC_Amiga_AllocedMemoryHeader *next;\n+};\n+struct GC_Amiga_AllocedMemoryHeader *GC_AMIGAMEM=(struct GC_Amiga_AllocedMemoryHeader *)(int)~(NULL);\n+\n+\n+\n+/* Type of memory. Once in the execution of a program, this might change to MEMF_ANY|MEMF_CLEAR */\n+\n+ULONG GC_AMIGA_MEMF = MEMF_FAST | MEMF_CLEAR;\n+\n+\n+/* Prevents GC_amiga_get_mem from allocating memory if this one is TRUE. */\n+#ifndef GC_AMIGA_ONLYFAST\n+BOOL GC_amiga_dontalloc=FALSE;\n+#endif\n+\n+#ifdef GC_AMIGA_PRINTSTATS\n+int succ=0,succ2=0;\n+int nsucc=0,nsucc2=0;\n+int nullretries=0;\n+int numcollects=0;\n+int chipa=0;\n+int allochip=0;\n+int allocfast=0;\n+int cur0=0;\n+int cur1=0;\n+int cur10=0;\n+int cur50=0;\n+int cur150=0;\n+int cur151=0;\n+int ncur0=0;\n+int ncur1=0;\n+int ncur10=0;\n+int ncur50=0;\n+int ncur150=0;\n+int ncur151=0;\n+#endif\n+\n+/* Free everything at program-end. */\n+\n+void GC_amiga_free_all_mem(void){\n+\tstruct GC_Amiga_AllocedMemoryHeader *gc_am=(struct GC_Amiga_AllocedMemoryHeader *)(~(int)(GC_AMIGAMEM));\n+\tstruct GC_Amiga_AllocedMemoryHeader *temp;\n+\n+#ifdef GC_AMIGA_PRINTSTATS\n+\tprintf(\"\\n\\n\"\n+\t\t\"%d bytes of chip-mem, and %d bytes of fast-mem where allocated from the OS.\\n\",\n+\t\tallochip,allocfast\n+\t);\n+\tprintf(\n+\t\t\"%d bytes of chip-mem were returned from the GC_AMIGA_FASTALLOC supported allocating functions.\\n\",\n+\t\tchipa\n+\t);\n+\tprintf(\"\\n\");\n+\tprintf(\"GC_gcollect was called %d times to avoid returning NULL or start allocating with the MEMF_ANY flag.\\n\",numcollects);\n+\tprintf(\"%d of them was a success. (the others had to use allocation from the OS.)\\n\",nullretries);\n+\tprintf(\"\\n\");\n+\tprintf(\"Succeded forcing %d gc-allocations (%d bytes) of chip-mem to be fast-mem.\\n\",succ,succ2);\n+\tprintf(\"Failed forcing %d gc-allocations (%d bytes) of chip-mem to be fast-mem.\\n\",nsucc,nsucc2);\n+\tprintf(\"\\n\");\n+\tprintf(\n+\t\t\"Number of retries before succeding a chip->fast force:\\n\"\n+\t\t\"0: %d, 1: %d, 2-9: %d, 10-49: %d, 50-149: %d, >150: %d\\n\",\n+\t\tcur0,cur1,cur10,cur50,cur150,cur151\n+\t);\n+\tprintf(\n+\t\t\"Number of retries before giving up a chip->fast force:\\n\"\n+\t\t\"0: %d, 1: %d, 2-9: %d, 10-49: %d, 50-149: %d, >150: %d\\n\",\n+\t\tncur0,ncur1,ncur10,ncur50,ncur150,ncur151\n+\t);\n+#endif\n+\n+\twhile(gc_am!=NULL){\n+\t\ttemp=gc_am->next;\n+\t\tFreeMem(gc_am,gc_am->size);\n+\t\tgc_am=(struct GC_Amiga_AllocedMemoryHeader *)(~(int)(temp));\n+\t}\n+}\n+\n+#ifndef GC_AMIGA_ONLYFAST\n+\n+/* All memory with address lower than this one is chip-mem. */\n+\n+char *chipmax;\n+\n+\n+/*\n+ * Allways set to the last size of memory tried to be allocated.\n+ * Needed to ensure allocation when the size is bigger than 100000.\n+ *\n+ */\n+size_t latestsize;\n+\n+#endif\n+\n+\n+/*\n+ * The actual function that is called with the GET_MEM macro.\n+ *\n+ */\n+\n+void *GC_amiga_get_mem(size_t size){\n+\tstruct GC_Amiga_AllocedMemoryHeader *gc_am;\n+\n+#ifndef GC_AMIGA_ONLYFAST\n+\tif(GC_amiga_dontalloc==TRUE){\n+//\t\tprintf(\"rejected, size: %d, latestsize: %d\\n\",size,latestsize);\n+\t\treturn NULL;\n+\t}\n+\n+\t// We really don't want to use chip-mem, but if we must, then as little as possible.\n+\tif(GC_AMIGA_MEMF==(MEMF_ANY|MEMF_CLEAR) && size>100000 && latestsize<50000) return NULL;\n+#endif\n+\n+\tgc_am=AllocMem((ULONG)(size + sizeof(struct GC_Amiga_AllocedMemoryHeader)),GC_AMIGA_MEMF);\n+\tif(gc_am==NULL) return NULL;\n+\n+\tgc_am->next=GC_AMIGAMEM;\n+\tgc_am->size=size + sizeof(struct GC_Amiga_AllocedMemoryHeader);\n+\tGC_AMIGAMEM=(struct GC_Amiga_AllocedMemoryHeader *)(~(int)(gc_am));\n+\n+//\tprintf(\"Allocated %d (%d) bytes at address: %x. Latest: %d\\n\",size,tot,gc_am,latestsize);\n+\n+#ifdef GC_AMIGA_PRINTSTATS\n+\tif((char *)gc_am<chipmax){\n+\t\tallochip+=size;\n+\t}else{\n+\t\tallocfast+=size;\n+\t}\n+#endif\n+\n+\treturn gc_am+1;\n+\n+}\n+\n+\n+\n+\n+#ifndef GC_AMIGA_ONLYFAST\n+\n+/* Tries very hard to force GC to find fast-mem to return. Done recursively\n+ * to hold the rejected memory-pointers reachable from the collector in an\n+ * easy way.\n+ *\n+ */\n+#ifdef GC_AMIGA_RETRY\n+void *GC_amiga_rec_alloc(size_t size,void *(*AllocFunction)(size_t size2),const int rec){\n+\tvoid *ret;\n+\n+\tret=(*AllocFunction)(size);\n+\n+#ifdef GC_AMIGA_PRINTSTATS\n+\tif((char *)ret>chipmax || ret==NULL){\n+\t\tif(ret==NULL){\n+\t\t\tnsucc++;\n+\t\t\tnsucc2+=size;\n+\t\t\tif(rec==0) ncur0++;\n+\t\t\tif(rec==1) ncur1++;\n+\t\t\tif(rec>1 && rec<10) ncur10++;\n+\t\t\tif(rec>=10 && rec<50) ncur50++;\n+\t\t\tif(rec>=50 && rec<150) ncur150++;\n+\t\t\tif(rec>=150) ncur151++;\n+\t\t}else{\n+\t\t\tsucc++;\n+\t\t\tsucc2+=size;\n+\t\t\tif(rec==0) cur0++;\n+\t\t\tif(rec==1) cur1++;\n+\t\t\tif(rec>1 && rec<10) cur10++;\n+\t\t\tif(rec>=10 && rec<50) cur50++;\n+\t\t\tif(rec>=50 && rec<150) cur150++;\n+\t\t\tif(rec>=150) cur151++;\n+\t\t}\n+\t}\n+#endif\n+\n+\tif (((char *)ret)<=chipmax && ret!=NULL && (rec<(size>500000?9:size/5000))){\n+\t\tret=GC_amiga_rec_alloc(size,AllocFunction,rec+1);\n+//\t\tGC_free(ret2);\n+\t}\n+\n+\treturn ret;\n+}\n+#endif\n+\n+\n+/* The allocating-functions defined inside the amiga-blocks in gc.h is called\n+ * via these functions.\n+ */\n+\n+\n+void *GC_amiga_allocwrapper_any(size_t size,void *(*AllocFunction)(size_t size2)){\n+\tvoid *ret,*ret2;\n+\n+\tGC_amiga_dontalloc=TRUE;\t// Pretty tough thing to do, but its indeed necesarry.\n+\tlatestsize=size;\n+\n+\tret=(*AllocFunction)(size);\n+\n+\tif(((char *)ret) <= chipmax){\n+\t\tif(ret==NULL){\n+\t\t\t//Give GC access to allocate memory.\n+#ifdef GC_AMIGA_GC\n+\t\t\tif(!GC_dont_gc){\n+\t\t\t\tGC_gcollect();\n+#ifdef GC_AMIGA_PRINTSTATS\n+\t\t\t\tnumcollects++;\n+#endif\n+\t\t\t\tret=(*AllocFunction)(size);\n+\t\t\t}\n+#endif\n+\t\t\tif(ret==NULL){\n+\t\t\t\tGC_amiga_dontalloc=FALSE;\n+\t\t\t\tret=(*AllocFunction)(size);\n+\t\t\t\tif(ret==NULL){\n+\t\t\t\t\tWARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n+\t\t\t\t}\n+\t\t\t}\n+#ifdef GC_AMIGA_PRINTSTATS\n+\t\t\telse{\n+\t\t\t\tnullretries++;\n+\t\t\t}\n+\t\t\tif(ret!=NULL && (char *)ret<=chipmax) chipa+=size;\n+#endif\n+\t\t}\n+#ifdef GC_AMIGA_RETRY\n+\t\telse{\n+\t\t\t/* We got chip-mem. Better try again and again and again etc., we might get fast-mem sooner or later... */\n+\t\t\t/* Using gctest to check the effectiviness of doing this, does seldom give a very good result. */\n+\t\t\t/* However, real programs doesn't normally rapidly allocate and deallocate. */\n+//\t\t\tprintf(\"trying to force... %d bytes... \",size);\n+\t\t\tif(\n+\t\t\t\tAllocFunction!=GC_malloc_uncollectable\n+#ifdef ATOMIC_UNCOLLECTABLE\n+\t\t\t\t&& AllocFunction!=GC_malloc_atomic_uncollectable\n+#endif\n+\t\t\t){\n+\t\t\t\tret2=GC_amiga_rec_alloc(size,AllocFunction,0);\n+\t\t\t}else{\n+\t\t\t\tret2=(*AllocFunction)(size);\n+#ifdef GC_AMIGA_PRINTSTATS\n+\t\t\t\tif((char *)ret2<chipmax || ret2==NULL){\n+\t\t\t\t\tnsucc++;\n+\t\t\t\t\tnsucc2+=size;\n+\t\t\t\t\tncur0++;\n+\t\t\t\t}else{\n+\t\t\t\t\tsucc++;\n+\t\t\t\t\tsucc2+=size;\n+\t\t\t\t\tcur0++;\n+\t\t\t\t}\n+#endif\n+\t\t\t}\n+\t\t\tif(((char *)ret2)>chipmax){\n+//\t\t\t\tprintf(\"Succeeded.\\n\");\n+\t\t\t\tGC_free(ret);\n+\t\t\t\tret=ret2;\n+\t\t\t}else{\n+\t\t\t\tGC_free(ret2);\n+//\t\t\t\tprintf(\"But did not succeed.\\n\");\n+\t\t\t}\n+\t\t}\n+#endif\n+\t}\n+\n+\tGC_amiga_dontalloc=FALSE;\n+\n+\treturn ret;\n+}\n+\n+\n+\n+void (*GC_amiga_toany)(void)=NULL;\n+\n+void GC_amiga_set_toany(void (*func)(void)){\n+\tGC_amiga_toany=func;\n+}\n+\n+#endif // !GC_AMIGA_ONLYFAST\n+\n+\n+void *GC_amiga_allocwrapper_fast(size_t size,void *(*AllocFunction)(size_t size2)){\n+\tvoid *ret;\n+\n+\tret=(*AllocFunction)(size);\n+\n+\tif(ret==NULL){\n+\t\t// Enable chip-mem allocation.\n+//\t\tprintf(\"ret==NULL\\n\");\n+#ifdef GC_AMIGA_GC\n+\t\tif(!GC_dont_gc){\n+\t\t\tGC_gcollect();\n+#ifdef GC_AMIGA_PRINTSTATS\n+\t\t\tnumcollects++;\n+#endif\n+\t\t\tret=(*AllocFunction)(size);\n+\t\t}\n+#endif\n+\t\tif(ret==NULL){\n+#ifndef GC_AMIGA_ONLYFAST\n+\t\t\tGC_AMIGA_MEMF=MEMF_ANY | MEMF_CLEAR;\n+\t\t\tif(GC_amiga_toany!=NULL) (*GC_amiga_toany)();\n+\t\t\tGC_amiga_allocwrapper_do=GC_amiga_allocwrapper_any;\n+\t\t\treturn GC_amiga_allocwrapper_any(size,AllocFunction);\n+#endif\n+\t\t}\n+#ifdef GC_AMIGA_PRINTSTATS\n+\t\telse{\n+\t\t\tnullretries++;\n+\t\t}\n+#endif\n+\t}\n+\n+\treturn ret;\n+}\n+\n+void *GC_amiga_allocwrapper_firsttime(size_t size,void *(*AllocFunction)(size_t size2)){\n+\tatexit(&GC_amiga_free_all_mem);\n+\tchipmax=(char *)SysBase->MaxLocMem;\t\t// For people still having SysBase in chip-mem, this might speed up a bit.\n+\tGC_amiga_allocwrapper_do=GC_amiga_allocwrapper_fast;\n+\treturn GC_amiga_allocwrapper_fast(size,AllocFunction);\n+}\n+\n+\n+#endif //GC_AMIGA_FASTALLOC\n+\n+\n+\n+/*\n+ * The wrapped realloc function.\n+ *\n+ */\n+void *GC_amiga_realloc(void *old_object,size_t new_size_in_bytes){\n+#ifndef GC_AMIGA_FASTALLOC\n+\treturn GC_realloc(old_object,new_size_in_bytes);\n+#else\n+\tvoid *ret;\n+\tlatestsize=new_size_in_bytes;\n+\tret=GC_realloc(old_object,new_size_in_bytes);\n+\tif(ret==NULL && GC_AMIGA_MEMF==(MEMF_FAST | MEMF_CLEAR)){\n+\t\t/* Out of fast-mem. */\n+#ifdef GC_AMIGA_GC\n+\t\tif(!GC_dont_gc){\n+\t\t\tGC_gcollect();\n+#ifdef GC_AMIGA_PRINTSTATS\n+\t\t\tnumcollects++;\n+#endif\n+\t\t\tret=GC_realloc(old_object,new_size_in_bytes);\n+\t\t}\n+#endif\n+\t\tif(ret==NULL){\n+#ifndef GC_AMIGA_ONLYFAST\n+\t\t\tGC_AMIGA_MEMF=MEMF_ANY | MEMF_CLEAR;\n+\t\t\tif(GC_amiga_toany!=NULL) (*GC_amiga_toany)();\n+\t\t\tGC_amiga_allocwrapper_do=GC_amiga_allocwrapper_any;\n+\t\t\tret=GC_realloc(old_object,new_size_in_bytes);\n+#endif\n+\t\t}\n+#ifdef GC_AMIGA_PRINTSTATS\n+\t\telse{\n+\t\t\tnullretries++;\n+\t\t}\n+#endif\n+\t}\n+\tif(ret==NULL){\n+\t\tWARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n+\t}\n+#ifdef GC_AMIGA_PRINTSTATS\n+\tif(((char *)ret)<chipmax && ret!=NULL){\n+\t\tchipa+=new_size_in_bytes;\n+\t}\n+#endif\n+\treturn ret;\n+#endif\n+}\n+\n+#endif //GC_AMIGA_AM\n+\n+"}, {"sha": "cbd432388f64126554fefa76c5aea311ad8a38da", "filename": "boehm-gc/doc/README", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,608 @@\n+Copyright (c) 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n+Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+Copyright (c) 1999-2001 by Hewlett-Packard Company. All rights reserved.\n+\n+The file linux_threads.c is also\n+Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n+\n+The files Makefile.am, and configure.in are\n+Copyright (c) 2001 by Red Hat Inc. All rights reserved.\n+\n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+\n+Permission is hereby granted to use or copy this program\n+for any purpose,  provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is granted,\n+provided the above notices are retained, and a notice that the code was\n+modified is included with the above copyright notice.\n+\n+This is version 6.0alpha7 of a conservative garbage collector for C and C++.\n+\n+You might find a more recent version of this at\n+\n+http://www.hpl.hp.com/personal/Hans_Boehm/gc\n+\n+OVERVIEW\n+\n+    This is intended to be a general purpose, garbage collecting storage\n+allocator.  The algorithms used are described in:\n+\n+Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative Environment\",\n+Software Practice & Experience, September 1988, pp. 807-820.\n+\n+Boehm, H., A. Demers, and S. Shenker, \"Mostly Parallel Garbage Collection\",\n+Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design\n+and Implementation, SIGPLAN Notices 26, 6 (June 1991), pp. 157-164.\n+\n+Boehm, H., \"Space Efficient Conservative Garbage Collection\", Proceedings\n+of the ACM SIGPLAN '91 Conference on Programming Language Design and\n+Implementation, SIGPLAN Notices 28, 6 (June 1993), pp. 197-206.\n+\n+Boehm H., \"Reducing Garbage Collector Cache Misses\", Proceedings of the\n+2000 International Symposium on Memory Management.\n+\n+  Possible interactions between the collector and optimizing compilers are\n+discussed in\n+\n+Boehm, H., and D. Chase, \"A Proposal for GC-safe C Compilation\",\n+The Journal of C Language Translation 4, 2 (December 1992).\n+\n+and\n+\n+Boehm H., \"Simple GC-safe Compilation\", Proceedings\n+of the ACM SIGPLAN '96 Conference on Programming Language Design and\n+Implementation.\n+\n+(Some of these are also available from\n+http://www.hpl.hp.com/personal/Hans_Boehm/papers/, among other places.)\n+\n+  Unlike the collector described in the second reference, this collector\n+operates either with the mutator stopped during the entire collection\n+(default) or incrementally during allocations.  (The latter is supported\n+on only a few machines.)  On the most common platforms, it can be built\n+with or without thread support.  On a few platforms, it can take advantage\n+of a multiprocessor to speed up garbage collection.\n+\n+  Many of the ideas underlying the collector have previously been explored\n+by others.  Notably, some of the run-time systems developed at Xerox PARC\n+in the early 1980s conservatively scanned thread stacks to locate possible\n+pointers (cf. Paul Rovner, \"On Adding Garbage Collection and Runtime Types\n+to a Strongly-Typed Statically Checked, Concurrent Language\"  Xerox PARC\n+CSL 84-7).  Doug McIlroy wrote a simpler fully conservative collector that\n+was part of version 8 UNIX (tm), but appears to not have received\n+widespread use.\n+\n+  Rudimentary tools for use of the collector as a leak detector are included\n+(see http://www.hpl.hp.com/personal/Hans_Boehm/gc/leak.html),\n+as is a fairly sophisticated string package \"cord\" that makes use of the\n+collector.  (See doc/README.cords and H.-J. Boehm, R. Atkinson, and M. Plass,\n+\"Ropes: An Alternative to Strings\", Software Practice and Experience 25, 12\n+(December 1995), pp. 1315-1330.  This is very similar to the \"rope\" package\n+in Xerox Cedar, or the \"rope\" package in the SGI STL or the g++ distribution.)\n+\n+Further collector documantation can be found at\n+\n+http://www.hpl.hp.com/personal/Hans_Boehm/gc\n+\n+\n+GENERAL DESCRIPTION\n+\n+  This is a garbage collecting storage allocator that is intended to be\n+used as a plug-in replacement for C's malloc.\n+\n+  Since the collector does not require pointers to be tagged, it does not\n+attempt to ensure that all inaccessible storage is reclaimed.  However,\n+in our experience, it is typically more successful at reclaiming unused\n+memory than most C programs using explicit deallocation.  Unlike manually\n+introduced leaks, the amount of unreclaimed memory typically stays\n+bounded.\n+\n+  In the following, an \"object\" is defined to be a region of memory allocated\n+by the routines described below.  \n+\n+  Any objects not intended to be collected must be pointed to either\n+from other such accessible objects, or from the registers,\n+stack, data, or statically allocated bss segments.  Pointers from\n+the stack or registers may point to anywhere inside an object.\n+The same is true for heap pointers if the collector is compiled with\n+ ALL_INTERIOR_POINTERS defined, as is now the default.\n+\n+Compiling without ALL_INTERIOR_POINTERS may reduce accidental retention\n+of garbage objects, by requiring pointers from the heap to to the beginning\n+of an object.  But this no longer appears to be a significant\n+issue for most programs.\n+\n+There are a number of routines which modify the pointer recognition\n+algorithm.  GC_register_displacement allows certain interior pointers\n+to be recognized even if ALL_INTERIOR_POINTERS is nor defined.\n+GC_malloc_ignore_off_page allows some pointers into the middle of large objects\n+to be disregarded, greatly reducing the probablility of accidental\n+retention of large objects.  For most purposes it seems best to compile\n+with ALL_INTERIOR_POINTERS and to use GC_malloc_ignore_off_page if\n+you get collector warnings from allocations of very large objects.\n+See README.debugging for details.\n+\n+  WARNING: pointers inside memory allocated by the standard \"malloc\" are not\n+seen by the garbage collector.  Thus objects pointed to only from such a\n+region may be prematurely deallocated.  It is thus suggested that the\n+standard \"malloc\" be used only for memory regions, such as I/O buffers, that\n+are guaranteed not to contain pointers to garbage collectable memory.\n+Pointers in C language automatic, static, or register variables,\n+are correctly recognized.  (Note that GC_malloc_uncollectable has semantics\n+similar to standard malloc, but allocates objects that are traced by the\n+collector.)\n+\n+  WARNING: the collector does not always know how to find pointers in data\n+areas that are associated with dynamic libraries.  This is easy to\n+remedy IF you know how to find those data areas on your operating\n+system (see GC_add_roots).  Code for doing this under SunOS, IRIX 5.X and 6.X,\n+HP/UX, Alpha OSF/1, Linux, and win32 is included and used by default.  (See\n+README.win32 for win32 details.)  On other systems pointers from dynamic\n+library data areas may not be considered by the collector.\n+If you're writing a program that depends on the collector scanning\n+dynamic library data areas, it may be a good idea to include at least\n+one call to GC_is_visible() to ensure that those areas are visible\n+to the collector.\n+\n+  Note that the garbage collector does not need to be informed of shared\n+read-only data.  However if the shared library mechanism can introduce\n+discontiguous data areas that may contain pointers, then the collector does\n+need to be informed.\n+\n+  Signal processing for most signals may be deferred during collection,\n+and during uninterruptible parts of the allocation process.\n+Like standard ANSI C mallocs, by default it is unsafe to invoke\n+malloc (and other GC routines) from a signal handler while another\n+malloc call may be in progress. Removing -DNO_SIGNALS from Makefile\n+attempts to remedy that.  But that may not be reliable with a compiler that\n+substantially reorders memory operations inside GC_malloc.\n+\n+  The allocator/collector can also be configured for thread-safe operation.\n+(Full signal safety can also be achieved, but only at the cost of two system\n+calls per malloc, which is usually unacceptable.)\n+WARNING: the collector does not guarantee to scan thread-local storage\n+(e.g. of the kind accessed with pthread_getspecific()).  The collector\n+does scan thread stacks, though, so generally the best solution is to\n+ensure that any pointers stored in thread-local storage are also\n+stored on the thread's stack for the duration of their lifetime.\n+(This is arguably a longstanding bug, but it hasn't been fixed yet.)\n+\n+INSTALLATION AND PORTABILITY\n+\n+  As distributed, the macro SILENT is defined in Makefile.\n+In the event of problems, this can be removed to obtain a moderate\n+amount of descriptive output for each collection.\n+(The given statistics exhibit a few peculiarities.\n+Things don't appear to add up for a variety of reasons, most notably\n+fragmentation losses.  These are probably much more significant for the\n+contrived program \"test.c\" than for your application.)\n+\n+  Note that typing \"make test\" will automatically build the collector\n+and then run setjmp_test and gctest. Setjmp_test will give you information\n+about configuring the collector, which is useful primarily if you have\n+a machine that's not already supported.  Gctest is a somewhat superficial\n+test of collector functionality.  Failure is indicated by a core dump or\n+a message to the effect that the collector is broken.  Gctest takes about \n+35 seconds to run on a SPARCstation 2. It may use up to 8 MB of memory.  (The\n+multi-threaded version will use more.  64-bit versions may use more.)\n+\"Make test\" will also, as its last step, attempt to build and test the\n+\"cord\" string library.  This will fail without an ANSI C compiler, but\n+the garbage collector itself should still be usable.\n+\n+  The Makefile will generate a library gc.a which you should link against.\n+Typing \"make cords\" will add the cord library to gc.a.\n+Note that this requires an ANSI C compiler.\n+\n+  It is suggested that if you need to replace a piece of the collector\n+(e.g. GC_mark_rts.c) you simply list your version ahead of gc.a on the\n+ld command line, rather than replacing the one in gc.a.  (This will\n+generate numerous warnings under some versions of AIX, but it still\n+works.)\n+\n+  All include files that need to be used by clients will be put in the\n+include subdirectory.  (Normally this is just gc.h.  \"Make cords\" adds\n+\"cord.h\" and \"ec.h\".)\n+\n+  The collector currently is designed to run essentially unmodified on\n+machines that use a flat 32-bit or 64-bit address space.\n+That includes the vast majority of Workstations and X86 (X >= 3) PCs.\n+(The list here was deleted because it was getting too long and constantly\n+out of date.)\n+  It does NOT run under plain 16-bit DOS or Windows 3.X.  There are however\n+various packages (e.g. win32s, djgpp) that allow flat 32-bit address\n+applications to run under those systemsif the have at least an 80386 processor,\n+and several of those are compatible with the collector.\n+\n+  In a few cases (Amiga, OS/2, Win32, MacOS) a separate makefile\n+or equivalent is supplied.  Many of these have separate README.system\n+files.\n+\n+  Dynamic libraries are completely supported only under SunOS\n+(and even that support is not functional on the last Sun 3 release),\n+Linux, IRIX 5&6, HP-PA, Win32 (not Win32S) and OSF/1 on DEC AXP machines.\n+On other machines we recommend that you do one of the following:\n+\n+  1) Add dynamic library support (and send us the code).\n+  2) Use static versions of the libraries.\n+  3) Arrange for dynamic libraries to use the standard malloc.\n+     This is still dangerous if the library stores a pointer to a\n+     garbage collected object.  But nearly all standard interfaces\n+     prohibit this, because they deal correctly with pointers\n+     to stack allocated objects.  (Strtok is an exception.  Don't\n+     use it.)\n+\n+  In all cases we assume that pointer alignment is consistent with that\n+enforced by the standard C compilers.  If you use a nonstandard compiler\n+you may have to adjust the alignment parameters defined in gc_priv.h.\n+\n+  A port to a machine that is not byte addressed, or does not use 32 bit\n+or 64 bit addresses will require a major effort.  A port to plain MSDOS\n+or win16 is hard.\n+\n+  For machines not already mentioned, or for nonstandard compilers, the\n+following are likely to require change:\n+\n+1.  The parameters in gcconfig.h.\n+      The parameters that will usually require adjustment are\n+   STACKBOTTOM,  ALIGNMENT and DATASTART.  Setjmp_test\n+   prints its guesses of the first two.\n+      DATASTART should be an expression for computing the\n+   address of the beginning of the data segment.  This can often be\n+   &etext.  But some memory management units require that there be\n+   some unmapped space between the text and the data segment.  Thus\n+   it may be more complicated.   On UNIX systems, this is rarely\n+   documented.  But the adb \"$m\" command may be helpful.  (Note\n+   that DATASTART will usually be a function of &etext.  Thus a\n+   single experiment is usually insufficient.)\n+     STACKBOTTOM is used to initialize GC_stackbottom, which\n+   should be a sufficient approximation to the coldest stack address.\n+   On some machines, it is difficult to obtain such a value that is\n+   valid across a variety of MMUs, OS releases, etc.  A number of\n+   alternatives exist for using the collector in spite of this.  See the\n+   discussion in gcconfig.h immediately preceding the various\n+   definitions of STACKBOTTOM.\n+   \n+2.  mach_dep.c.\n+      The most important routine here is one to mark from registers.\n+    The distributed file includes a generic hack (based on setjmp) that\n+    happens to work on many machines, and may work on yours.  Try\n+    compiling and running setjmp_t.c to see whether it has a chance of\n+    working.  (This is not correct C, so don't blame your compiler if it\n+    doesn't work.  Based on limited experience, register window machines\n+    are likely to cause trouble.  If your version of setjmp claims that\n+    all accessible variables, including registers, have the value they\n+    had at the time of the longjmp, it also will not work.  Vanilla 4.2 BSD\n+    on Vaxen makes such a claim.  SunOS does not.)\n+      If your compiler does not allow in-line assembly code, or if you prefer\n+    not to use such a facility, mach_dep.c may be replaced by a .s file\n+    (as we did for the MIPS machine and the PC/RT).\n+      At this point enough architectures are supported by mach_dep.c\n+    that you will rarely need to do more than adjust for assembler\n+    syntax.\n+\n+3.  os_dep.c (and gc_priv.h).\n+  \t  Several kinds of operating system dependent routines reside here.\n+  \tMany are optional.  Several are invoked only through corresponding\n+  \tmacros in gc_priv.h, which may also be redefined as appropriate.\n+      The routine GC_register_data_segments is crucial.  It registers static\n+    data areas that must be traversed by the collector. (User calls to\n+    GC_add_roots may sometimes be used for similar effect.)\n+      Routines to obtain memory from the OS also reside here.\n+    Alternatively this can be done entirely by the macro GET_MEM\n+    defined in gc_priv.h.  Routines to disable and reenable signals\n+    also reside here if they are need by the macros DISABLE_SIGNALS\n+    and ENABLE_SIGNALS defined in gc_priv.h.\n+      In a multithreaded environment, the macros LOCK and UNLOCK\n+    in gc_priv.h will need to be suitably redefined.\n+      The incremental collector requires page dirty information, which\n+    is acquired through routines defined in os_dep.c.  Unless directed\n+    otherwise by gcconfig.h, these are implemented as stubs that simply\n+    treat all pages as dirty.  (This of course makes the incremental\n+    collector much less useful.)\n+\n+4.  dyn_load.c\n+\tThis provides a routine that allows the collector to scan data\n+\tsegments associated with dynamic libraries.  Often it is not\n+\tnecessary to provide this routine unless user-written dynamic\n+\tlibraries are used.\n+\n+  For a different version of UN*X or different machines using the\n+Motorola 68000, Vax, SPARC, 80386, NS 32000, PC/RT, or MIPS architecture,\n+it should frequently suffice to change definitions in gcconfig.h.\n+\n+\n+THE C INTERFACE TO THE ALLOCATOR\n+\n+  The following routines are intended to be directly called by the user.\n+Note that usually only GC_malloc is necessary.  GC_clear_roots and GC_add_roots\n+calls may be required if the collector has to trace from nonstandard places\n+(e.g. from dynamic library data areas on a machine on which the \n+collector doesn't already understand them.)  On some machines, it may\n+be desirable to set GC_stacktop to a good approximation of the stack base. \n+(This enhances code portability on HP PA machines, since there is no\n+good way for the collector to compute this value.)  Client code may include\n+\"gc.h\", which defines all of the following, plus many others.\n+\n+1)  GC_malloc(nbytes)\n+    - allocate an object of size nbytes.  Unlike malloc, the object is\n+      cleared before being returned to the user.  Gc_malloc will\n+      invoke the garbage collector when it determines this to be appropriate.\n+      GC_malloc may return 0 if it is unable to acquire sufficient\n+      space from the operating system.  This is the most probable\n+      consequence of running out of space.  Other possible consequences\n+      are that a function call will fail due to lack of stack space,\n+      or that the collector will fail in other ways because it cannot\n+      maintain its internal data structures, or that a crucial system\n+      process will fail and take down the machine.  Most of these\n+      possibilities are independent of the malloc implementation.\n+\n+2)  GC_malloc_atomic(nbytes)\n+    - allocate an object of size nbytes that is guaranteed not to contain any\n+      pointers.  The returned object is not guaranteed to be cleared.\n+      (Can always be replaced by GC_malloc, but results in faster collection\n+      times.  The collector will probably run faster if large character\n+      arrays, etc. are allocated with GC_malloc_atomic than if they are\n+      statically allocated.)\n+\n+3)  GC_realloc(object, new_size)\n+    - change the size of object to be new_size.  Returns a pointer to the\n+      new object, which may, or may not, be the same as the pointer to\n+      the old object.  The new object is taken to be atomic iff the old one\n+      was.  If the new object is composite and larger than the original object,\n+      then the newly added bytes are cleared (we hope).  This is very likely\n+      to allocate a new object, unless MERGE_SIZES is defined in gc_priv.h.\n+      Even then, it is likely to recycle the old object only if the object\n+      is grown in small additive increments (which, we claim, is generally bad\n+      coding practice.)\n+\n+4)  GC_free(object)\n+    - explicitly deallocate an object returned by GC_malloc or\n+      GC_malloc_atomic.  Not necessary, but can be used to minimize\n+      collections if performance is critical.  Probably a performance\n+      loss for very small objects (<= 8 bytes).\n+\n+5)  GC_expand_hp(bytes)\n+    - Explicitly increase the heap size.  (This is normally done automatically\n+      if a garbage collection failed to GC_reclaim enough memory.  Explicit\n+      calls to GC_expand_hp may prevent unnecessarily frequent collections at\n+      program startup.)\n+\n+6)  GC_malloc_ignore_off_page(bytes)\n+\t- identical to GC_malloc, but the client promises to keep a pointer to\n+\t  the somewhere within the first 256 bytes of the object while it is\n+\t  live.  (This pointer should nortmally be declared volatile to prevent\n+\t  interference from compiler optimizations.)  This is the recommended\n+\t  way to allocate anything that is likely to be larger than 100Kbytes\n+\t  or so.  (GC_malloc may result in failure to reclaim such objects.)\n+\n+7)  GC_set_warn_proc(proc)\n+\t- Can be used to redirect warnings from the collector.  Such warnings\n+\t  should be rare, and should not be ignored during code development.\n+      \n+8) GC_enable_incremental()\n+    - Enables generational and incremental collection.  Useful for large\n+      heaps on machines that provide access to page dirty information.\n+      Some dirty bit implementations may interfere with debugging\n+      (by catching address faults) and place restrictions on heap arguments\n+      to system calls (since write faults inside a system call may not be\n+      handled well).\n+\n+9) Several routines to allow for registration of finalization code.\n+   User supplied finalization code may be invoked when an object becomes\n+   unreachable.  To call (*f)(obj, x) when obj becomes inaccessible, use\n+\tGC_register_finalizer(obj, f, x, 0, 0);\n+   For more sophisticated uses, and for finalization ordering issues,\n+   see gc.h.\n+\n+  The global variable GC_free_space_divisor may be adjusted up from its\n+default value of 4 to use less space and more collection time, or down for\n+the opposite effect.  Setting it to 1 or 0 will effectively disable collections\n+and cause all allocations to simply grow the heap.\n+\n+  The variable GC_non_gc_bytes, which is normally 0, may be changed to reflect\n+the amount of memory allocated by the above routines that should not be\n+considered as a candidate for collection.  Careless use may, of course, result\n+in excessive memory consumption.\n+\n+  Some additional tuning is possible through the parameters defined\n+near the top of gc_priv.h.\n+  \n+  If only GC_malloc is intended to be used, it might be appropriate to define:\n+\n+#define malloc(n) GC_malloc(n)\n+#define calloc(m,n) GC_malloc((m)*(n))\n+\n+  For small pieces of VERY allocation intensive code, gc_inl.h\n+includes some allocation macros that may be used in place of GC_malloc\n+and friends.\n+\n+  All externally visible names in the garbage collector start with \"GC_\".\n+To avoid name conflicts, client code should avoid this prefix, except when\n+accessing garbage collector routines or variables.\n+\n+  There are provisions for allocation with explicit type information.\n+This is rarely necessary.  Details can be found in gc_typed.h.\n+\n+THE C++ INTERFACE TO THE ALLOCATOR:\n+\n+  The Ellis-Hull C++ interface to the collector is included in\n+the collector distribution.  If you intend to use this, type\n+\"make c++\" after the initial build of the collector is complete.\n+See gc_cpp.h for the definition of the interface.  This interface\n+tries to approximate the Ellis-Detlefs C++ garbage collection\n+proposal without compiler changes.\n+\n+Cautions:\n+1. Arrays allocated without new placement syntax are\n+allocated as uncollectable objects.  They are traced by the\n+collector, but will not be reclaimed.\n+\n+2. Failure to use \"make c++\" in combination with (1) will\n+result in arrays allocated using the default new operator.\n+This is likely to result in disaster without linker warnings.\n+\n+3. If your compiler supports an overloaded new[] operator,\n+then gc_cpp.cc and gc_cpp.h should be suitably modified.\n+\n+4. Many current C++ compilers have deficiencies that\n+break some of the functionality.  See the comments in gc_cpp.h\n+for suggested workarounds.\n+\n+USE AS LEAK DETECTOR:\n+\n+  The collector may be used to track down leaks in C programs that are\n+intended to run with malloc/free (e.g. code with extreme real-time or\n+portability constraints).  To do so define FIND_LEAK in Makefile\n+This will cause the collector to invoke the report_leak\n+routine defined near the top of reclaim.c whenever an inaccessible\n+object is found that has not been explicitly freed.  Such objects will\n+also be automatically reclaimed.\n+  Productive use of this facility normally involves redefining report_leak\n+to do something more intelligent.  This typically requires annotating\n+objects with additional information (e.g. creation time stack trace) that\n+identifies their origin.  Such code is typically not very portable, and is\n+not included here, except on SPARC machines.\n+  If all objects are allocated with GC_DEBUG_MALLOC (see next section),\n+then the default version of report_leak will report the source file\n+and line number at which the leaked object was allocated.  This may\n+sometimes be sufficient.  (On SPARC/SUNOS4 machines, it will also report\n+a cryptic stack trace.  This can often be turned into a sympolic stack\n+trace by invoking program \"foo\" with \"callprocs foo\".  Callprocs is\n+a short shell script that invokes adb to expand program counter values\n+to symbolic addresses.  It was largely supplied by Scott Schwartz.)\n+  Note that the debugging facilities described in the next section can\n+sometimes be slightly LESS effective in leak finding mode, since in\n+leak finding mode, GC_debug_free actually results in reuse of the object.\n+(Otherwise the object is simply marked invalid.)  Also note that the test\n+program is not designed to run meaningfully in FIND_LEAK mode.\n+Use \"make gc.a\" to build the collector.\n+\n+DEBUGGING FACILITIES:\n+\n+  The routines GC_debug_malloc, GC_debug_malloc_atomic, GC_debug_realloc,\n+and GC_debug_free provide an alternate interface to the collector, which\n+provides some help with memory overwrite errors, and the like.\n+Objects allocated in this way are annotated with additional\n+information.  Some of this information is checked during garbage\n+collections, and detected inconsistencies are reported to stderr.\n+\n+  Simple cases of writing past the end of an allocated object should\n+be caught if the object is explicitly deallocated, or if the\n+collector is invoked while the object is live.  The first deallocation\n+of an object will clear the debugging info associated with an\n+object, so accidentally repeated calls to GC_debug_free will report the\n+deallocation of an object without debugging information.  Out of\n+memory errors will be reported to stderr, in addition to returning\n+NIL.\n+\n+  GC_debug_malloc checking  during garbage collection is enabled\n+with the first call to GC_debug_malloc.  This will result in some\n+slowdown during collections.  If frequent heap checks are desired,\n+this can be achieved by explicitly invoking GC_gcollect, e.g. from\n+the debugger.\n+\n+  GC_debug_malloc allocated objects should not be passed to GC_realloc\n+or GC_free, and conversely.  It is however acceptable to allocate only\n+some objects with GC_debug_malloc, and to use GC_malloc for other objects,\n+provided the two pools are kept distinct.  In this case, there is a very\n+low probablility that GC_malloc allocated objects may be misidentified as\n+having been overwritten.  This should happen with probability at most\n+one in 2**32.  This probability is zero if GC_debug_malloc is never called.\n+\n+  GC_debug_malloc, GC_malloc_atomic, and GC_debug_realloc take two\n+additional trailing arguments, a string and an integer.  These are not\n+interpreted by the allocator.  They are stored in the object (the string is\n+not copied).  If an error involving the object is detected, they are printed.\n+\n+  The macros GC_MALLOC, GC_MALLOC_ATOMIC, GC_REALLOC, GC_FREE, and\n+GC_REGISTER_FINALIZER are also provided.  These require the same arguments\n+as the corresponding (nondebugging) routines.  If gc.h is included\n+with GC_DEBUG defined, they call the debugging versions of these\n+functions, passing the current file name and line number as the two\n+extra arguments, where appropriate.  If gc.h is included without GC_DEBUG\n+defined, then all these macros will instead be defined to their nondebugging\n+equivalents.  (GC_REGISTER_FINALIZER is necessary, since pointers to\n+objects with debugging information are really pointers to a displacement\n+of 16 bytes form the object beginning, and some translation is necessary\n+when finalization routines are invoked.  For details, about what's stored\n+in the header, see the definition of the type oh in debug_malloc.c)\n+\n+INCREMENTAL/GENERATIONAL COLLECTION:\n+\n+The collector normally interrupts client code for the duration of \n+a garbage collection mark phase.  This may be unacceptable if interactive\n+response is needed for programs with large heaps.  The collector\n+can also run in a \"generational\" mode, in which it usually attempts to\n+collect only objects allocated since the last garbage collection.\n+Furthermore, in this mode, garbage collections run mostly incrementally,\n+with a small amount of work performed in response to each of a large number of\n+GC_malloc requests.\n+\n+This mode is enabled by a call to GC_enable_incremental().\n+\n+Incremental and generational collection is effective in reducing\n+pause times only if the collector has some way to tell which objects\n+or pages have been recently modified.  The collector uses two sources\n+of information:\n+\n+1. Information provided by the VM system.  This may be provided in\n+one of several forms.  Under Solaris 2.X (and potentially under other\n+similar systems) information on dirty pages can be read from the\n+/proc file system.  Under other systems (currently SunOS4.X) it is\n+possible to write-protect the heap, and catch the resulting faults.\n+On these systems we require that system calls writing to the heap\n+(other than read) be handled specially by client code.\n+See os_dep.c for details.\n+\n+2. Information supplied by the programmer.  We define \"stubborn\"\n+objects to be objects that are rarely changed.  Such an object\n+can be allocated (and enabled for writing) with GC_malloc_stubborn.\n+Once it has been initialized, the collector should be informed with\n+a call to GC_end_stubborn_change.  Subsequent writes that store\n+pointers into the object must be preceded by a call to\n+GC_change_stubborn.\n+\n+This mechanism performs best for objects that are written only for\n+initialization, and such that only one stubborn object is writable\n+at once.  It is typically not worth using for short-lived\n+objects.  Stubborn objects are treated less efficiently than pointerfree\n+(atomic) objects.\n+\n+A rough rule of thumb is that, in the absence of VM information, garbage\n+collection pauses are proportional to the amount of pointerful storage\n+plus the amount of modified \"stubborn\" storage that is reachable during\n+the collection.  \n+\n+Initial allocation of stubborn objects takes longer than allocation\n+of other objects, since other data structures need to be maintained.\n+\n+We recommend against random use of stubborn objects in client\n+code, since bugs caused by inappropriate writes to stubborn objects\n+are likely to be very infrequently observed and hard to trace.  \n+However, their use may be appropriate in a few carefully written\n+library routines that do not make the objects themselves available\n+for writing by client code.\n+\n+\n+BUGS:\n+\n+  Any memory that does not have a recognizable pointer to it will be\n+reclaimed.  Exclusive-or'ing forward and backward links in a list\n+doesn't cut it.\n+  Some C optimizers may lose the last undisguised pointer to a memory\n+object as a consequence of clever optimizations.  This has almost\n+never been observed in practice.  Send mail to boehm@acm.org\n+for suggestions on how to fix your compiler.\n+  This is not a real-time collector.  In the standard configuration,\n+percentage of time required for collection should be constant across\n+heap sizes.  But collection pauses will increase for larger heaps.\n+(On SPARCstation 2s collection times will be on the order of 300 msecs\n+per MB of accessible memory that needs to be scanned.  Your mileage\n+may vary.)  The incremental/generational collection facility helps,\n+but is portable only if \"stubborn\" allocation is used.\n+  Please address bug reports to boehm@acm.org.  If you are\n+contemplating a major addition, you might also send mail to ask whether\n+it's already been done (or whether we tried and discarded it).\n+"}, {"sha": "04f468251a1e5f4b94181f9e6ad085b96e8ff442", "filename": "boehm-gc/doc/README.Mac", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.Mac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.Mac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.Mac?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,385 @@\n+Patrick Beard's Notes for building GC v4.12 with CodeWarrior Pro 2:\n+----------------------------------------------------------------------------\n+The current build environment for the collector is CodeWarrior Pro 2.\n+Projects for CodeWarrior Pro 2 (and for quite a few older versions)\n+are distributed in the file Mac_projects.sit.hqx. The project file\n+:Mac_projects:gc.prj builds static library versions of the collector.\n+:Mac_projects:gctest.prj builds the GC test suite.\n+\n+Configuring the collector is still done by editing the files\n+:Mac_files:MacOS_config.h and :Mac_files:MacOS_Test_config.h.\n+\n+Lars Farm's suggestions on building the collector:\n+----------------------------------------------------------------------------\n+Garbage Collection on MacOS - a manual 'MakeFile'\n+-------------------------------------------------\n+\n+Project files and IDE's are great on the Macintosh, but they do have\n+problems when used as distribution media. This note tries to provide\n+porting instructions in pure TEXT form to avoid those problems. A manual\n+'makefile' if you like.\n+\n+    GC version:     4.12a2\n+    Codewarrior:    CWPro1\n+    date:           18 July 1997\n+\n+The notes may or may not apply to earlier or later versions of the\n+GC/CWPro. Actually, they do apply to earlier versions of both except that\n+until recently a project could only build one target so each target was a\n+separate project. The notes will most likely apply to future versions too.\n+Possibly with minor tweaks.\n+\n+This is just to record my experiences. These notes do not mean I now\n+provide a supported port of the GC to MacOS. It works for me. If it works\n+for you, great. If it doesn't, sorry, try again...;-) Still, if you find\n+errors, please let me know.\n+\n+    mailto:         lars.farm@ite.mh.se\n+\n+    address:        Lars Farm\n+                    Kr\ufffdnv\ufffdgen 33b\n+                    856 44 Sundsvall\n+                    Sweden\n+\n+Porting to MacOS is a bit more complex than it first seems. Which MacOS?\n+68K/PowerPC? Which compiler? Each supports both 68K and PowerPC and offer a\n+large number of (unique to each environment) compiler settings. Each\n+combination of compiler/68K/PPC/settings require a unique combination of\n+standard libraries. And the IDE's does not select them for you. They don't\n+even check that the library is built with compatible setting and this is\n+the major source of problems when porting the GC (and otherwise too).\n+\n+You will have to make choices when you configure the GC. I've made some\n+choices here, but there are other combinations of settings and #defines\n+that work too.\n+\n+As for target settings the major obstacles may be:\n+- 68K Processor: check \"4-byte Ints\".\n+- PPC Processor: uncheck \"Store Static Data in TOC\".\n+\n+What you need to do:\n+===================\n+\n+1) Build the GC as a library\n+2) Test that the library works with 'test.c'.\n+3) Test that the C++ interface 'gc_cpp.cc/h' works with 'test_cpp.cc'.\n+\n+1) The Libraries:\n+=================\n+I made one project with four targets (68K/PPC tempmem or appheap). One target\n+will suffice if you're able to decide which one you want. I wasn't...\n+\n+Codewarrior allows a large number of compiler/linker settings. I used these:\n+\n+Settings shared by all targets:\n+------------------------------\n+o Access Paths:\n+  - User Paths:   the GC folder\n+  - System Paths: {Compiler}:Metrowerks Standard Library:\n+                  {Compiler}:MacOS Support:Headers:\n+                  {Compiler}:MacOS Support:MacHeaders:\n+o C/C++ language:\n+  - inlining: normal\n+  - direct to SOM: off\n+  - enable/check: exceptions, RTTI, bool (and if you like pool strings)\n+\n+PowerPC target settings\n+-----------------------\n+o Target Settings:\n+  - name of target\n+  - MacOS PPC Linker\n+o PPC Target\n+  - name of library\n+o C/C++ language\n+  - prefix file as described below\n+o PPC Processor\n+  - Struct Alignment: PowerPC\n+  - uncheck \"Store Static Data in TOC\" -- important!\n+    I don't think the others matter, I use full optimization and its ok\n+o PPC Linker\n+  - Factory Settings (SYM file with full paths, faster linking, dead-strip\n+    static init, Main: __start)\n+\n+\n+68K target settings\n+-------------------\n+o Target Settings:\n+  - name of target\n+  - MacOS 68K Linker\n+o 68K Target\n+  - name of library\n+  - A5 relative data\n+o C/C++ language\n+  - prefix file as described below\n+o 68K Processor\n+  - Code model: smart\n+  - Struct alignment: 68K\n+  - FP: SANE\n+  - enable 4-Byte Ints -- important!\n+    I don't think the others matter. I selected...\n+  - enable: 68020\n+  - enable: global register allocation\n+o IR Optimizer\n+  - enable: Optimize Space, Optimize Speed\n+    I suppose the others would work too, but haven't tried...\n+o 68K Linker\n+  - Factory Settings (New Style MacsBug,SYM file with full paths,\n+    A6 Frames, fast link, Merge compiler glue into segment 1,\n+    dead-strip static init)\n+\n+Prefix Files to configure the GC sources\n+----------------------------------------\n+The Codewarrior equivalent of commandline compilers -DNAME=X is to use\n+prefix-files. A TEXT file that is automatically #included before the first byte\n+of every source file. I used these:\n+\n+---- ( cut here ) ----  gc_prefix_tempmem.h     -- 68K and PPC -----\n+    #include \"gc_prefix_common.h\"\n+    #undef USE_TEMPORARY_MEMORY\n+    #define USE_TEMPORARY_MEMORY\n+---- ( cut here ) ----  gc_prefix_appmem.h      -- 68K and PPC -----\n+    #include \"gc_prefix_common.h\"\n+    #undef USE_TEMPORARY_MEMORY\n+//  #define USE_TEMPORARY_MEMORY\n+\n+---- ( cut here ) ----  gc_prefix_common.h      --------------------\n+// gc_prefix_common.h\n+// ------------------\n+// Codewarrior prefix file to configure the GC libraries\n+//\n+//   prefix files are the Codewarrior equivalent of the\n+//   command line option -Dname=x frequently seen in makefiles\n+\n+#if !__MWERKS__\n+  #error only tried this with Codewarrior\n+#endif\n+\n+#if macintosh\n+  #define MSL_USE_PRECOMPILED_HEADERS 0\n+  #include <ansi_prefix.mac.h>\n+  #ifndef __STDC__\n+    #define __STDC__ 0\n+  #endif\n+\n+  //  See list of #defines to configure the library in: 'MakeFile'\n+  //  see also README\n+\n+  #define SILENT                // no collection messages. In case\n+                                // of trouble you might want this off\n+  #define ALL_INTERIOR_POINTERS // follows interior pointers.\n+//#define DONT_ADD_BYTE_AT_END  // disables the padding if defined.\n+//#define SMALL_CONFIG          // whether to use a smaller heap.\n+  #define NO_SIGNALS            // signals aren't real on the Macintosh.\n+  #define ATOMIC_UNCOLLECTABLE  // GC_malloc_atomic_uncollectable()\n+\n+  // define either or none as per personal preference\n+  //   used in malloc.c\n+  #define REDIRECT_MALLOC GC_malloc\n+//#define REDIRECT_MALLOC GC_malloc_uncollectable\n+  // if REDIRECT_MALLOC is #defined make sure that the GC library\n+  // is listed before the ANSI/ISO libs in the Codewarrior\n+  // 'Link order' panel\n+//#define IGNORE_FREE\n+\n+  // mac specific configs\n+//#define USE_TEMPORARY_MEMORY    // use Macintosh temporary memory.\n+//#define SHARED_LIBRARY_BUILD    // build for use in a shared library.\n+\n+#else\n+  // could build Win32 here too, or in the future\n+  // Rhapsody PPC-mach, Rhapsody PPC-MacOS,\n+  // Rhapsody Intel-mach, Rhapsody Intel-Win32,...\n+  // ... ugh this will get messy ...\n+#endif\n+\n+// make sure ints are at least 32-bit\n+// ( could be set to 16-bit by compiler settings (68K) )\n+\n+struct gc_private_assert_intsize_{ char x[ sizeof(int)>=4 ? 1 : 0 ]; };\n+\n+#if __powerc\n+  #if __option(toc_data)\n+    #error turn off \"store static data in TOC\" when using GC\n+    //     ... or find a way to add TOC to the root set...(?)\n+  #endif\n+#endif\n+---- ( cut here ) ----  end of gc_prefix_common.h  -----------------\n+\n+Files to  build the GC libraries:\n+--------------------------------\n+    allchblk.c\n+    alloc.c\n+    blacklst.c\n+    checksums.c\n+    dbg_mlc.c\n+    finalize.c\n+    headers.c\n+    mach_dep.c\n+    MacOS.c    -- contains MacOS code\n+    malloc.c\n+    mallocx.c\n+    mark.c\n+    mark_rts.c\n+    misc.c\n+    new_hblk.c\n+    obj_map.c\n+    os_dep.c   -- contains MacOS code\n+    ptr_chck.c\n+    reclaim.c\n+    stubborn.c\n+    typd_mlc.c\n+    gc++.cc    -- this is 'gc_cpp.cc' with less 'inline' and\n+               -- throw std::bad_alloc when out of memory\n+               -- gc_cpp.cc works just fine too\n+\n+2) Test that the library works with 'test.c'.\n+=============================================\n+\n+The test app is just an ordinary ANSI-C console app. Make sure settings\n+match the library you're testing.\n+\n+Files\n+-----\n+    test.c\n+    the GC library to test        -- link order before ANSI libs\n+    suitable Mac+ANSI libraries\n+\n+prefix:\n+------\n+---- ( cut here ) ----  gc_prefix_testlib.h     -- all libs -----\n+#define MSL_USE_PRECOMPILED_HEADERS 0\n+#include <ansi_prefix.mac.h>\n+#undef NDEBUG\n+\n+#define ALL_INTERIOR_POINTERS\t/* for GC_priv.h */\n+---- ( cut here ) ----\n+\n+3) Test that the C++ interface 'gc_cpp.cc/h' works with 'test_cpp.cc'.\n+\n+The test app is just an ordinary ANSI-C console app. Make sure settings match\n+the library you're testing.\n+\n+Files\n+-----\n+    test_cpp.cc\n+    the GC library to test        -- link order before ANSI libs\n+    suitable Mac+ANSI libraries\n+\n+prefix:\n+------\n+same as for test.c\n+\n+For convenience I used one test-project with several targets so that all\n+test apps are build at once. Two for each library to test: test.c and\n+gc_app.cc. When I was satisfied that the libraries were ok. I put the\n+libraries + gc.h + the c++ interface-file in a folder that I then put into\n+the MSL hierarchy so that I don't have to alter access-paths in projects\n+that use the GC.\n+\n+After that, just add the proper GC library to your project and the GC is in\n+action! malloc will call GC_malloc and free GC_free, new/delete too. You\n+don't have to call free or delete. You may have to be a bit cautious about\n+delete if you're freeing other resources than RAM. See gc_cpp.h. You can\n+also keep coding as always with delete/free. That works too. If you want,\n+\"include <gc.h> and tweak it's use a bit.\n+\n+Symantec SPM\n+============\n+It has been a while since I tried the GC in SPM, but I think that the above\n+instructions should be sufficient to guide you through in SPM too. SPM\n+needs to know where the global data is. Use the files 'datastart.c' and\n+'dataend.c'. Put 'datastart.c' at the top of your project and 'dataend.c'\n+at the bottom  of your project so that all data is surrounded. This is not\n+needed in Codewarrior because it provides intrinsic variables\n+__datastart__, __data_end__ that wraps all globals.\n+\n+Source Changes (GC 4.12a2)\n+==========================\n+Very few. Just one tiny in the GC, not strictly needed.\n+- MacOS.c line 131 in routine GC_MacFreeTemporaryMemory()\n+  change #       if !defined(SHARED_LIBRARY_BUILD)\n+  to     #       if !defined(SILENT) && !defined(SHARED_LIBRARY_BUILD)\n+  To turn off a message when the application quits (actually, I faked\n+  this change by #defining SHARED_LIBRARY_BUILD in a statically linked\n+  library for more than a year without ill effects but perhaps this is\n+  better).\n+\n+- test_cpp.cc\n+  made the first lines of main() look like this:\n+  ------------\n+  int main( int argc, char* argv[] ) {\n+  #endif\n+  #if macintosh                             // MacOS\n+    char* argv_[] = {\"test_cpp\",\"10\"};      //   doesn't\n+    argv=argv_;                             //     have a\n+    argc = sizeof(argv_)/sizeof(argv_[0]);  //       commandline\n+  #endif                                    //\n+\n+  int i, iters, n;\n+  # ifndef __GNUC__\n+   alloc dummy_to_fool_the_compiler_into_doing_things_it_currently_cant_handle;\n+  ------------\n+\n+- config.h [now gcconfig.h]\n+  __MWERKS__ does not have to mean MACOS. You can use Codewarrior to\n+  build a Win32 or BeOS library and soon a Rhapsody library. You may\n+  have to change that #if...\n+\n+\n+\n+   It worked for me, hope it works for you.\n+\n+   Lars Farm\n+   18 July 1997\n+----------------------------------------------------------------------------\n+\n+\n+Patrick Beard's instructions (may be dated):\n+\n+v4.3 of the collector now runs under Symantec C++/THINK C v7.0.4, and\n+Metrowerks C/C++ v4.5 both 68K and PowerPC. Project files are provided\n+to build and test the collector under both development systems.\n+\n+Configuration\n+-------------\n+\n+To configure the collector, under both development systems, a prefix file\n+is used to set preprocessor directives. This file is called \"MacOS_config.h\".\n+Also to test the collector, \"MacOS_Test_config.h\" is provided.\n+\n+Testing\n+-------\n+\n+To test the collector (always a good idea), build one of the gctest projects,\n+gctest.\ufffd (Symantec C++/THINK C), mw/gctest.68K.\ufffd, or mw/gctest.PPC.\ufffd. The\n+test will ask you how many times to run; 1 should be sufficient.\n+\n+Building \n+--------\n+\n+For your convenience project files for the major Macintosh development\n+systems are provided.\n+\n+For Symantec C++/THINK C, you must build the two projects gclib-1.\ufffd and\n+gclib-2.\ufffd. It has to be split up because the collector has more than 32k\n+of static data and no library can have more than this in the Symantec\n+environment. (Future versions will probably fix this.)\n+\n+For Metrowerks C/C++ 4.5 you build gc.68K.\ufffd/gc.PPC.\ufffd and the result will\n+be a library called gc.68K.lib/gc.PPC.lib.\n+\n+Using\n+-----\n+\n+Under Symantec C++/THINK C, you can just add the gclib-1.\ufffd and gclib-2.\ufffd\n+projects to your own project. Under Metrowerks, you add gc.68K.lib or\n+gc.PPC.lib and two additional files. You add the files called datastart.c\n+and dataend.c to your project, bracketing all files that use the collector.\n+See mw/gctest.\ufffd for an example.\n+\n+Include the projects/libraries you built above into your own project,\n+#include \"gc.h\", and call GC_malloc. You don't have to call GC_free.\n+\n+\n+Patrick C. Beard\n+January 4, 1995"}, {"sha": "82343dd9efae164626688ff2ec4ebc9586fe648f", "filename": "boehm-gc/doc/README.MacOSX", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.MacOSX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.MacOSX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.MacOSX?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,19 @@\n+While the GC should work on MacOS X Server, MacOS X and Darwin, I only tested\n+it on MacOS X Server.\n+I've added a PPC assembly version of GC_push_regs(), thus the setjmp() hack is\n+no longer necessary. Incremental collection is supported via mprotect/signal.\n+The current solution isn't really optimal because the signal handler must decode\n+the faulting PPC machine instruction in order to find the correct heap address.\n+Further, it must poke around in the register state which the kernel saved away\n+in some obscure register state structure before it calls the signal handler -\n+needless to say the layout of this structure is no where documented.\n+Threads and dynamic libraries are not yet supported (adding dynamic library\n+support via the low-level dyld API shouldn't be that hard).\n+\n+The original MacOS X port was brought to you by Andrew Stone.\n+\n+\n+June, 1 2000\n+\n+Dietmar Planitzer\n+dave.pl@ping.at"}, {"sha": "5345bbd0f654592d01fcb0f4a6ae5fb1cac0170a", "filename": "boehm-gc/doc/README.OS2", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.OS2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.OS2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.OS2?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,6 @@\n+The code assumes static linking, and a single thread.  The editor de has\n+not been ported.  The cord test program has.  The supplied OS2_MAKEFILE\n+assumes the IBM C Set/2 environment, but the code shouldn't.\n+\n+Since we haven't figured out hoe to do perform partial links or to build static\n+libraries, clients currently need to link against a long list of executables."}, {"sha": "730dce3fe96f6950b82f79c6a3a1ecda08a4b122", "filename": "boehm-gc/doc/README.amiga", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.amiga?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,322 @@\n+===========================================================================\n+            Kjetil S. Matheussen's notes (28-11-2000)\n+===========================================================================\n+Compiles under SAS/C again. Should allso still compile under other\n+amiga compilers without big changes. I haven't checked if it still\n+works under gcc, because I don't have gcc for amiga. But I have\n+updated 'Makefile', and hope it compiles fine.\n+\n+\n+WHATS NEW:\n+\n+1.\n+   Made a pretty big effort in preventing GCs allocating-functions from returning\n+   chip-mem.\n+\n+   The lower part of the new file AmigaOS.c does this in various ways, mainly by\n+   wrapping GC_malloc, GC_malloc_atomic, GC_malloc_uncollectable,\n+   GC_malloc_atomic_uncollectable, GC_malloc_stubborn, GC_malloc_ignore_off_page\n+   and GC_malloc_atomic_ignore_off_page. GC_realloc is allso wrapped, but\n+   doesn't do the same effort in preventing to return chip-mem.\n+   Other allocating-functions (f.ex. GC_*_typed_) can probably be\n+   used without any problems, but beware that the warn hook will not be called.\n+   In case of problems, don't define GC_AMIGA_FASTALLOC.\n+\n+   Programs using more time actually using the memory allocated\n+   (instead of just allocate and free rapidly) have\n+   the most to earn on this, but even gctest now normally runs twice\n+   as fast and uses less memory, on my poor 8MB machine.\n+\n+   The changes have only effect when there is no more\n+   fast-mem left. But with the way GC works, it\n+   could happen quite often. Beware that an atexit handler had to be added,\n+   so using the abort() function will make a big memory-loss.\n+   If you absolutely must call abort() instead of exit(), try calling\n+   the GC_amiga_free_all_mem function before abort().\n+\n+   New amiga-spesific compilation flags:\n+\n+   GC_AMIGA_FASTALLOC - By NOT defining this option, GC will work like before,\n+                        it will not try to force fast-mem out of the OS, and\n+                        it will use normal calloc for allocation, and the rest\n+                        of the following flags will have no effect.\n+\n+   GC_AMIGA_ONLYFAST - Makes GC never to return chip-mem. GC_AMIGA_RETRY have\n+                       no effect if this flag is set.\n+\n+   GC_AMIGA_GC - If gc returns NULL, do a GC_gcollect, and try again. This\n+                 usually is a success with the standard GC configuration. \n+                 It is allso the most important flag to set to prevent\n+                 GC from returning chip-mem. Beware that it slows down a lot\n+                 when a program is rapidly allocating/deallocating when\n+                 theres either very little fast-memory left or verly little\n+                 chip-memory left. Its not a very common situation, but gctest\n+                 sometimes (very rare) use many minutes because of this.\n+\n+   GC_AMIGA_RETRY - If gc succeed allocating memory, but it is chip-mem,\n+                    try again and see if it is fast-mem. Most of the time,\n+                    it will actually return fast-mem for the second try.\n+                    I have set max number of retries to 9 or size/5000. You\n+                    can change this if you like. (see GC_amiga_rec_alloc())\n+\n+   GC_AMIGA_PRINTSTATS - Gather some statistics during the execution of a\n+                         program, and prints out the info when the atexit-handler\n+                         is called.\n+\n+   My reccomendation is to set all this flags, except GC_AMIGA_PRINTSTATS and\n+   GC_AMIGA_ONLYFAST.\n+\n+   If your program demands high response-time, you should\n+   not define GC_AMIGA_GC, and possible allso define GC_AMIGA_ONLYFAST.\n+   GC_AMIGA_RETRY does not seem to slow down much.\n+\n+   Allso, when compiling up programs, and GC_AMIGA_FASTALLOC was not defined when\n+   compilling gc, you can define GC_AMIGA_MAKINGLIB to avoid having these allocation-\n+   functions wrapped. (see gc.h)\n+\n+   Note that GC_realloc must not be called before any of\n+   the other above mentioned allocating-functions have been called. (shouldn't be\n+   any programs doing so either, I hope).\n+\n+   Another note. The allocation-function is wrapped when defining\n+   GC_AMIGA_FASTALLOC by letting the function go thru the new\n+   GC_amiga_allocwrapper_do function-pointer (see gc.h). Means that\n+   sending function-pointers, such as GC_malloc, GC_malloc_atomic, etc.,\n+   for later to be called like f.ex this, (*GC_malloc_functionpointer)(size),\n+   will not wrap the function. This is normally not a big problem, unless\n+   all allocation function is called like this, which will cause the\n+   atexit un-allocating function never to be called. Then you either\n+   have to manually add the atexit handler, or call the allocation-\n+   functions function-pointer functions like this;\n+   (*GC_amiga_allocwrapper_do)(size,GC_malloc_functionpointer).\n+   There are probably better ways this problem could be handled, unfortunately,\n+   I didn't find any without rewriting or replacing a lot of the GC-code, which\n+   I really didn't want to. (Making new GC_malloc_* functions, and just\n+   define f.ex GC_malloc as GC_amiga_malloc should allso work).\n+\n+\n+   New amiga-spesific function:\n+\n+     void GC_amiga_set_toany(void (*func)(void));\n+\n+   'func' is a function that will be called right before gc has to change\n+   allocation-method from MEMF_FAST to MEMF_ANY. Ie. when it is likely\n+   it will return chip-mem.\n+\n+\n+2. A few small compiler-spesific additions to make it compile with SAS/C again.\n+\n+3. Updated and rewritten the smakefile, so that it works again and that\n+   the \"unnecesarry\" 'SCOPTIONS' files could be removed. Allso included\n+   the cord-smakefile stuff in the main smakefile, so that the cord smakefile\n+   could be removed too. By writing smake -f Smakefile.smk, both gc.lib and\n+   cord.lib will be made.\n+\n+\n+\n+STILL MISSING:\n+\n+Programs can not be started from workbench, at least not for SAS/C. (Martin\n+Tauchmanns note about that it now works with workbench is definitely wrong\n+when concerning SAS/C). I guess it works if you use the old \"#if 0'ed\"-code,\n+but I haven't tested it. I think the reason for MT to replace the\n+\"#if 0'ed\"-code was only because it was a bit to SAS/C-spesific. But I\n+don't know. An iconx-script solves this problem anyway.\n+\n+\n+BEWARE!\n+\n+-To run gctest, set the stack to around 200000 bytes first.\n+-SAS/C-spesific: cord will crash if you compile gc.lib with\n+ either parm=reg or parm=both. (missing legal prototypes for\n+ function-pointers someplace is the reason I guess.).\n+\n+\n+tested with software: Radium, http://www.stud.ifi.uio.no/~ksvalast/radium/\n+\n+tested with hardware: MC68060\n+\n+\n+-ksvalast@ifi.uio.no\n+\n+\n+===========================================================================\n+\t\t\t   Martin Tauchmann's notes\t\t(1-Apr-99)\n+===========================================================================\n+\n+Works now, also with the GNU-C compiler V2.7.2.1. <ftp://ftp.unina.it/pub/amiga/geekgadgets/amiga/m68k/snapshots/971125/amiga-bin/>\n+Modify the `Makefile`\n+CC=cc $(ABI_FLAG)\n+to\n+CC=gcc $(ABI_FLAG)\n+\n+TECHNICAL NOTES\n+\n+- `GC_get_stack_base()`, `GC_register_data_segments()` works now with every\n+   C compiler; also Workbench.\n+\n+- Removed AMIGA_SKIP_SEG, but the Code-Segment must not be scanned by GC.\n+\n+\n+PROBLEMS\n+- When the Linker, does`t merge all Code-Segments to an single one. LD of GCC\n+  do it always.\n+\n+- With ixemul.library V47.3, when an GC program launched from another program\n+  (example: `Make` or `if_mach M68K AMIGA gctest`), `GC_register_data_segments()`\n+  found the Segment-List of the caller program.\n+  Can be fixed, if the run-time initialization code (for C programs, usually *crt0*)\n+  support `__data` and `__bss`.\n+\n+- PowerPC Amiga currently not supported.\n+\n+- Dynamic libraries (dyn_load.c) not supported.\n+\n+\n+TESTED WITH SOFTWARE\n+\n+`Optimized Oberon 2 C` (oo2c) <http://cognac.informatik.uni-kl.de/download/index.html>\n+\n+\n+TESTED WITH HARDWARE\n+\n+MC68030\n+\n+\n+CONTACT\n+\n+Please, contact me at <martintauchmann@bigfoot.com>, when you change the\n+Amiga port. <http://martintauchmann.home.pages.de>\n+ \n+===========================================================================\n+\t\t\t   Michel Schinz's notes\n+===========================================================================\n+WHO DID WHAT\n+\n+The original Amiga port was made by Jesper Peterson. I (Michel Schinz)\n+modified it slightly to reflect the changes made in the new official\n+distributions, and to take advantage of the new SAS/C 6.x features. I also\n+created a makefile to compile the \"cord\" package (see the cord\n+subdirectory).\n+\n+TECHNICAL NOTES\n+\n+In addition to Jesper's notes, I have the following to say:\n+\n+- Starting with version 4.3, gctest checks to see if the code segment is\n+  added to the root set or not, and complains if it is. Previous versions\n+  of this Amiga port added the code segment to the root set, so I tried to\n+  fix that. The only problem is that, as far as I know, it is impossible to\n+  know which segments are code segments and which are data segments (there\n+  are indeed solutions to this problem, like scanning the program on disk\n+  or patch the LoadSeg functions, but they are rather complicated). The\n+  solution I have chosen (see os_dep.c) is to test whether the program\n+  counter is in the segment we are about to add to the root set, and if it\n+  is, to skip the segment. The problems are that this solution is rather\n+  awkward and that it works only for one code segment. This means that if\n+  your program has more than one code segment, all of them but one will be\n+  added to the root set. This isn't a big problem in fact, since the\n+  collector will continue to work correctly, but it may be slower.\n+\n+  Anyway, the code which decides whether to skip a segment or not can be\n+  removed simply by not defining AMIGA_SKIP_SEG. But notice that if you do\n+  so, gctest will complain (it will say that \"GC_is_visible produced wrong\n+  failure indication\"). However, it may be useful if you happen to have\n+  pointers stored in a code segment (you really shouldn't).\n+\n+  If anyone has a good solution to the problem of finding, when a program\n+  is loaded in memory, whether a segment is a code or a data segment,\n+  please let me know.\n+\n+PROBLEMS\n+\n+If you have any problem with this version, please contact me at\n+schinz@alphanet.ch (but do *not* send long files, since we pay for\n+every mail!).\n+\n+===========================================================================\n+\t\t\t  Jesper Peterson's notes\n+===========================================================================\n+\n+ADDITIONAL NOTES FOR AMIGA PORT\n+\n+These notes assume some familiarity with Amiga internals.\n+\n+WHY I PORTED TO THE AMIGA\n+\n+The sole reason why I made this port was as a first step in getting\n+the Sather(*) language on the Amiga. A port of this language will\n+be done as soon as the Sather 1.0 sources are made available to me.\n+Given this motivation, the garbage collection (GC) port is rather\n+minimal.\n+\n+(*) For information on Sather read the comp.lang.sather newsgroup.\n+\n+LIMITATIONS\n+\n+This port assumes that the startup code linked with target programs\n+is that supplied with SAS/C versions 6.0 or later. This allows\n+assumptions to be made about where to find the stack base pointer\n+and data segments when programs are run from WorkBench, as opposed\n+to running from the CLI. The compiler dependent code is all in the\n+GC_get_stack_base() and GC_register_data_segments() functions, but\n+may spread as I add Amiga specific features.\n+\n+Given that SAS/C was assumed, the port is set up to be built with\n+\"smake\" using the \"SMakefile\". Compiler options in \"SCoptions\" can\n+be set with \"scopts\" program. Both \"smake\" and \"scopts\" are part of\n+the SAS/C commercial development system.\n+\n+In keeping with the porting philosophy outlined above, this port\n+will not behave well with Amiga specific code. Especially not inter-\n+process comms via messages, and setting up public structures like\n+Intuition objects or anything else in the system lists. For the\n+time being the use of this library is limited to single threaded\n+ANSI/POSIX  compliant or near-complient code. (ie. Stick to stdio\n+for now). Given this limitation there is currently no mechanism for\n+allocating \"CHIP\" or \"PUBLIC\" memory under the garbage collector.\n+I'll add this after giving it considerable thought. The major\n+problem is the entire physical address space may have to me scanned,\n+since there is no telling who we may have passed memory to.\n+\n+If you allocate your own stack in client code, you will have to\n+assign the pointer plus stack size to GC_stackbottom.\n+\n+The initial stack size of the target program can be compiled in by\n+setting the __stack symbol (see SAS documentaion). It can be over-\n+ridden from the CLI by running the AmigaDOS \"stack\" program, or from\n+the WorkBench by setting the stack size in the tool types window.\n+\n+SAS/C COMPILER OPTIONS (SCoptions)\n+\n+You may wish to check the \"CPU\" code option is appropriate for your\n+intended target system.\n+\n+Under no circumstances set the \"StackExtend\" code option in either\n+compiling the library or *ANY* client code.\n+\n+All benign compiler warnings have been suppressed. These mainly\n+involve lack of prototypes in the code, and dead assignments\n+detected by the optimizer.\n+\n+THE GOOD NEWS\n+\n+The library as it stands is compatible with the GigaMem commercial\n+virtual memory software, and probably similar PD software.\n+\n+The performance of \"gctest\" on an Amiga 2630 (68030 @ 25Mhz)\n+compares favourably with an HP9000 with similar architecture (a 325\n+with a 68030 I think).\n+\n+-----------------------------------------------------------------------\n+\n+The Amiga port has been brought to you by:\n+\n+Jesper Peterson.\n+\n+jep@mtiame.mtia.oz.au\t\t(preferred, but 1 week turnaround)\n+jep@orca1.vic.design.telecom.au (that's orca<one>, 1 day turnaround)\n+\n+At least one of these addresses should be around for a while, even\n+though I don't work for either of the companies involved.\n+"}, {"sha": "b0676888c1d418165bc920dc69185cab7b3b4fb6", "filename": "boehm-gc/doc/README.changes", "status": "added", "additions": 1312, "deletions": 0, "changes": 1312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,1312 @@\n+This is a rough history of garbage collector bugs and versions.\n+\n+This has been maintained with varying diligence over the years.\n+\n+I made an attempt to include recent contributors here.  I apologize for any\n+omissions.\n+\n+-------------------------\n+\n+  Version 1.3 and immediately preceding versions contained spurious\n+assembly language assignments to TMP_SP.  Only the assignment in the PC/RT\n+code is necessary.  On other machines, with certain compiler options,\n+the assignments can lead to an unsaved register being overwritten.\n+Known to cause problems under SunOS 3.5 WITHOUT the -O option.  (With\n+-O the compiler recognizes it as dead code.  It probably shouldn't,\n+but that's another story.)\n+\n+  Version 1.4 and earlier versions used compile time determined values\n+for the stack base.  This no longer works on Sun 3s, since Sun 3/80s use\n+a different stack base.  We now use a straightforward heuristic on all\n+machines on which it is known to work (incl. Sun 3s) and compile-time\n+determined values for the rest.  There should really be library calls\n+to determine such values.\n+\n+  Version 1.5 and earlier did not ensure 8 byte alignment for objects\n+allocated on a sparc based machine.\n+\n+  Version 1.8 added ULTRIX support in gc_private.h.\n+  \n+  Version 1.9 fixed a major bug in gc_realloc.\n+  \n+  Version 2.0 introduced a consistent naming convention for collector\n+routines and added support for registering dynamic library data segments\n+in the standard mark_roots.c.  Most of the data structures were revamped.\n+The treatment of interior pointers was completely changed.  Finalization\n+was added.  Support for locking was added.  Object kinds were added.\n+We added a black listing facility to avoid allocating at addresses known\n+to occur as integers somewhere in the address space.  Much of this\n+was accomplished by adapting ideas and code from the PCR collector.\n+The test program was changed and expanded.\n+\n+  Version 2.1 was the first stable version since 1.9, and added support\n+for PPCR.\n+\n+  Version 2.2 added debugging allocation, and fixed various bugs.  Among them:\n+- GC_realloc could fail to extend the size of the object for certain large object sizes.\n+- A blatant subscript range error in GC_printf, which unfortunately\n+  wasn't exercised on machines with sufficient stack alignment constraints.\n+- GC_register_displacement did the wrong thing if it was called after\n+  any allocation had taken place.\n+- The leak finding code would eventually break after 2048 byte\n+  byte objects leaked.\n+- interface.c didn't compile.\n+- The heap size remained much too small for large stacks.\n+- The stack clearing code behaved badly for large stacks, and perhaps\n+  on HP/PA machines.\n+\n+  Version 2.3 added ALL_INTERIOR_POINTERS and fixed the following bugs:\n+- Missing declaration of etext in the A/UX version.\n+- Some PCR root-finding problems.\n+- Blacklisting was not 100% effective, because the plausible future\n+  heap bounds were being miscalculated.\n+- GC_realloc didn't handle out-of-memory correctly.\n+- GC_base could return a nonzero value for addresses inside free blocks.\n+- test.c wasn't really thread safe, and could erroneously report failure\n+  in a multithreaded environment.  (The locking primitives need to be\n+  replaced for other threads packages.)\n+- GC_CONS was thoroughly broken.\n+- On a SPARC with dynamic linking, signals stayed diabled while the\n+  client code was running.\n+  (Thanks to Manuel Serrano at INRIA for reporting the last two.)\n+  \n+  Version 2.4 added GC_free_space_divisor as a tuning knob, added\n+  support for OS/2 and linux, and fixed the following bugs:\n+- On machines with unaligned pointers (e.g. Sun 3), every 128th word could\n+  fail to be considered for marking.\n+- Dynamic_load.c erroneously added 4 bytes to the length of the data and\n+  bss sections of the dynamic library.  This could result in a bad memory\n+  reference if the actual length was a multiple of a page.  (Observed on\n+  Sun 3.  Can probably also happen on a Sun 4.)\n+  (Thanks to Robert Brazile for pointing out that the Sun 3 version\n+  was broken.  Dynamic library handling is still broken on Sun 3s\n+  under 4.1.1U1, but apparently not 4.1.1.  If you have such a machine,\n+  use -Bstatic.)\n+  \n+  Version 2.5 fixed the following bugs:\n+- Removed an explicit call to exit(1)\n+- Fixed calls to GC_printf and GC_err_printf, so the correct number of\n+  arguments are always supplied.  The OS/2 C compiler gets confused if\n+  the number of actuals and the number of formals differ.  (ANSI C\n+  doesn't require this to work.  The ANSI sanctioned way of doing things\n+  causes too many compatibility problems.)\n+  \n+  Version 3.0  added generational/incremental collection and stubborn\n+  objects.\n+\n+  Version 3.1 added the following features:\n+- A workaround for a SunOS 4.X SPARC C compiler\n+  misfeature that caused problems when the collector was turned into\n+  a dynamic library.  \n+- A fix for a bug in GC_base that could result in a memory fault.\n+- A fix for a performance bug (and several other misfeatures) pointed\n+  out by Dave Detlefs and Al Dosser.\n+- Use of dirty bit information for static data under Solaris 2.X.\n+- DEC Alpha/OSF1 support (thanks to Al Dosser).\n+- Incremental collection on more platforms.\n+- A more refined heap expansion policy.  Less space usage by default.\n+- Various minor enhancements to reduce space usage, and to reduce\n+  the amount of memory scanned by the collector.\n+- Uncollectable allocation without per object overhead.\n+- More conscientious handling of out-of-memory conditions.\n+- Fixed a bug in debugging stubborn allocation.\n+- Fixed a bug that resulted in occasional erroneous reporting of smashed\n+  objects with debugging allocation.\n+- Fixed bogus leak reports of size 4096 blocks with FIND_LEAK.\n+\n+  Version 3.2 fixed a serious and not entirely repeatable bug in\n+  the incremental collector.  It appeared only when dirty bit info\n+  on the roots was available, which is normally only under Solaris.\n+  It also added GC_general_register_disappearing_link, and some\n+  testing code.  Interface.c disappeared.\n+\n+  Version 3.3 fixes several bugs and adds new ports:\n+- PCR-specific bugs.\n+- Missing locking in GC_free, redundant FASTUNLOCK\n+  in GC_malloc_stubborn, and 2 bugs in\n+  GC_unregister_disappearing_link.\n+  All of the above were pointed out by Neil Sharman\n+  (neil@cs.mu.oz.au).\n+- Common symbols allocated by the SunOS4.X dynamic loader\n+  were not included in the root set.\n+- Bug in GC_finalize (reported by Brian Beuning and Al Dosser)\n+- Merged Amiga port from Jesper Peterson (untested)\n+- Merged NeXT port from Thomas Funke (significantly\n+  modified and untested)\n+\n+  Version 3.4:\n+- Fixed a performance bug in GC_realloc.\n+- Updated the amiga port.\n+- Added NetBSD and 386BSD ports.\n+- Added cord library.\n+- Added trivial performance enhancement for\n+  ALL_INTERIOR_POINTERS.  (Don't scan last word.)\n+  \n+  Version 3.5\n+- Minor collections now mark from roots only once, if that\n+  doesn't cause an excessive pause.\n+- The stack clearing heuristic was refined to prevent anomalies\n+  with very heavily recursive programs and sparse stacks.\n+- Fixed a bug that prevented mark stack growth in some cases.\n+  GC_objects_are_marked should be set to TRUE after a call\n+  to GC_push_roots and as part of GC_push_marked, since\n+  both can now set mark bits.  I think this is only a performance\n+  bug, but I wouldn't bet on it.  It's certainly very hard to argue\n+  that the old version was correct.\n+- Fixed an incremental collection bug that prevented it from\n+  working at all when HBLKSIZE != getpagesize()\n+- Changed dynamic_loading.c to include gc_priv.h before testing\n+  DYNAMIC_LOADING.  SunOS dynamic library scanning\n+  must have been broken in 3.4.\n+- Object size rounding now adapts to program behavior.\n+- Added a workaround (provided by Manuel Serrano and\n+  colleagues) to a long-standing SunOS 4.X (and 3.X?) ld bug\n+  that I had incorrectly assumed to have been squished.\n+  The collector was broken if the text segment size was within\n+  32 bytes of a multiple of 8K bytes, and if the beginning of\n+  the data segment contained interesting roots.  The workaround\n+  assumes a demand-loadable executable.  The original may have\n+  have \"worked\" in some other cases.\n+- Added dynamic library support under IRIX5.\n+- Added support for EMX under OS/2 (thanks to Ari Huttunen).\n+  \n+Version 3.6:\n+- fixed a bug in the mark stack growth code that was introduced\n+  in 3.4.\n+- fixed Makefile to work around DEC AXP compiler tail recursion\n+  bug.\n+\n+Version 3.7:\n+- Added a workaround for an HP/UX compiler bug.\n+- Fixed another stack clearing performance bug.  Reworked\n+  that code once more.\n+  \n+Version 4.0:\n+- Added support for Solaris threads (which was possible\n+  only by reimplementing some fraction of Solaris threads,\n+  since Sun doesn't currently make the thread debugging\n+  interface available).\n+- Added non-threads win32 and win32S support.\n+- (Grudgingly, with suitable muttering of obscenities) renamed\n+  files so that the collector distribution could live on a FAT\n+  file system.  Files that are guaranteed to be useless on\n+  a PC still have long names.  Gc_inline.h and gc_private.h\n+  still exist, but now just include  gc_inl.h and gc_priv.h.\n+- Fixed a really obscure bug in finalization that could cause\n+  undetected mark stack overflows.  (I would be surprised if\n+  any real code ever tickled this one.)\n+- Changed finalization code to dynamically resize the hash\n+  tables it maintains.  (This probably does not matter for well-\n+  -written code.  It no doubt does for C++ code that overuses\n+  destructors.)\n+- Added typed allocation primitives.  Rewrote the marker to\n+  accommodate them with more reasonable efficiency.  This\n+  change should also speed up marking for GC_malloc allocated\n+  objects a little.  See gc_typed.h for new primitives.\n+- Improved debugging facilities slightly.  Allocation time\n+  stack traces are now kept by default on SPARC/SUNOS4.\n+  (Thanks to Scott Schwartz.)\n+- Added better support for small heap applications.\n+- Significantly extended cord package.  Fixed a bug in the\n+  implementation of lazily read files.  Printf and friends now\n+  have cord variants.  Cord traversals are a bit faster.\n+- Made ALL_INTERIOR_POINTERS recognition the default.\n+- Fixed de so that it can run in constant space, independent\n+  of file size.  Added simple string searching to cords and de.\n+- Added the Hull-Ellis C++ interface.\n+- Added dynamic library support for OSF/1.\n+  (Thanks to Al Dosser and Tim Bingham at DEC.)\n+- Changed argument to GC_expand_hp to be expressed\n+  in units of bytes instead of heap blocks.  (Necessary\n+  since the heap block size now varies depending on\n+  configuration.  The old version was never very clean.)\n+- Added GC_get_heap_size().  The previous \"equivalent\"\n+  was broken.\n+- Restructured the Makefile a bit.  \n+\n+Since version 4.0:\n+- Changed finalization implementation to guarantee that\n+  finalization procedures are called outside of the allocation\n+  lock, making direct use of the interface a little less dangerous.\n+  MAY BREAK EXISTING CLIENTS that assume finalizers\n+  are protected by a lock.  Since there seem to be few multithreaded\n+  clients that use finalization, this is hopefully not much of\n+  a problem.\n+- Fixed a gross bug in CORD_prev.\n+- Fixed a bug in blacklst.c that could result in unbounded\n+  heap growth during startup on machines that do not clear\n+  memory obtained from the OS (e.g. win32S).\n+- Ported de editor to win32/win32S.  (This is now the only\n+  version with a mouse-sensitive UI.)\n+- Added GC_malloc_ignore_off_page to allocate large arrays\n+  in the presence of ALL_INTERIOR_POINTERS.\n+- Changed GC_call_with_alloc_lock to not disable signals in\n+  the single-threaded case.\n+- Reduced retry count in GC_collect_or_expand for garbage\n+  collecting when out of memory.\n+- Made uncollectable allocations bypass black-listing, as they\n+  should.\n+- Fixed a bug in typed_test in test.c that could cause (legitimate)\n+  GC crashes.\n+- Fixed some potential synchronization problems in finalize.c\n+- Fixed a real locking problem in typd_mlc.c.\n+- Worked around an AIX 3.2 compiler feature that results in\n+  out of bounds memory references.\n+- Partially worked around an IRIX5.2 beta problem (which may\n+  or may not persist to the final release).\n+- Fixed a bug in the heap integrity checking code that could\n+  result in explicitly deallocated objects being identified as\n+  smashed.  Fixed a bug in the dbg_mlc stack saving code\n+  that caused old argument pointers to be considered live.\n+- Fixed a bug in CORD_ncmp (and hence CORD_str).\n+- Repaired the OS2 port, which had suffered from bit rot\n+  in 4.0.  Worked around what appears to be CSet/2 V1.0\n+  optimizer bug.\n+- Fixed a Makefile bug for target \"c++\".\n+\n+Since version 4.1:\n+- Multiple bug fixes/workarounds in the Solaris threads version.\n+  (It occasionally failed to locate some register contents for\n+  marking.  It also turns out that thr_suspend and friends are\n+  unreliable in Solaris 2.3.  Dirty bit reads appear\n+  to be unreliable under some weird \n+  circumstances.  My stack marking code\n+  contained a serious performance bug.  The new code is\n+  extremely defensive, and has not failed in several cpu\n+  hours of testing.  But  no guarantees ...)\n+- Added MacOS support (thanks to Patrick Beard.)\n+- Fixed several syntactic bugs in gc_c++.h and friends.  (These\n+  didn't bother g++, but did bother most other compilers.)\n+  Fixed gc_c++.h finalization interface.  (It didn't.)\n+- 64 bit alignment for allocated objects was not guaranteed in a\n+  few cases in which it should have been.\n+- Added GC_malloc_atomic_ignore_off_page.\n+- Added GC_collect_a_little.\n+- Added some prototypes to gc.h.\n+- Some other minor bug fixes (notably in Makefile).\n+- Fixed OS/2 / EMX port (thanks to Ari Huttunen).\n+- Fixed AmigaDOS port. (thanks to Michel Schinz).\n+- Fixed the DATASTART definition under Solaris.  There\n+  was a 1 in 16K chance of the collector missing the first\n+  64K of static data (and thus crashing).\n+- Fixed some blatant anachronisms in the README file.\n+- Fixed PCR-Makefile for upcoming PPCR release.\n+\n+Since version 4.2:\n+- Fixed SPARC alignment problem with GC_DEBUG.\n+- Fixed Solaris threads /proc workaround.  The real\n+  problem was an interaction with mprotect.\n+- Incorporated fix from Patrick Beard for gc_c++.h (now gc_cpp.h).\n+- Slightly improved allocator space utilization by\n+  fixing the GC_size_map mechanism.\n+- Integrated some Sony News and MIPS RISCos 4.51\n+  patches.  (Thanks to Nobuyuki Hikichi of\n+  Software Research Associates, Inc. Japan)\n+- Fixed HP_PA alignment problem.  (Thanks to\n+  xjam@cork.cs.berkeley.edu.)\n+- Added GC_same_obj and friends.  Changed GC_base\n+  to return 0 for pointers past the end of large objects.\n+  Improved GC_base performance with ALL_INTERIOR_POINTERS\n+  on machines with a slow integer mod operation.\n+  Added GC_PTR_ADD, GC_PTR_STORE, etc. to prepare\n+  for preprocessor.\n+- changed the default on most UNIX machines to be that\n+  signals are not disabled during critical GC operations.\n+  This is still ANSI-conforming, though somewhat dangerous\n+  in the presence of signal handlers. But the performance\n+  cost of the alternative is sometimes problematic.\n+  Can be changed back with a minor Makefile edit.\n+- renamed IS_STRING in gc.h, to CORD_IS_STRING, thus\n+  following my own naming convention.  Added the function\n+  CORD_to_const_char_star.\n+- Fixed a gross bug in GC_finalize.  Symptom: occasional\n+  address faults in that function.  (Thanks to Anselm\n+  Baird-Smith (Anselm.BairdSmith@inria.fr)\n+- Added port to ICL DRS6000 running DRS/NX.  Restructured\n+  things a bit to factor out common code, and remove obsolete\n+  code.  Collector should now run under SUNOS5 with either\n+  mprotect or /proc dirty bits.  (Thanks to Douglas Steel\n+  (doug@wg.icl.co.uk)).\n+- More bug fixes and workarounds for Solaris 2.X.  (These were\n+  mostly related to putting the collector in a dynamic library,\n+  which didn't really work before.  Also SOLARIS_THREADS\n+  didn't interact well with dl_open.)  Thanks to btlewis@eng.sun.com.\n+- Fixed a serious performance bug on the DEC Alpha.  The text\n+  segment was getting registered as part of the root set.\n+  (Amazingly, the result was still fast enough that the bug\n+  was not conspicuous.) The fix works on OSF/1, version 1.3.\n+  Hopefully it also works on other versions of OSF/1 ...\n+- Fixed a bug in GC_clear_roots.\n+- Fixed a bug in GC_generic_malloc_words_small that broke\n+  gc_inl.h.  (Reported by Antoine de Maricourt.  I broke it\n+  in trying to tweak the Mac port.) \n+- Fixed some problems with cord/de under Linux.\n+- Fixed some cord problems, notably with CORD_riter4.\n+- Added DG/UX port.\n+  Thanks to Ben A. Mesander (ben@piglet.cr.usgs.gov)\n+- Added finalization registration routines with weaker ordering\n+  constraints.  (This is necessary for C++ finalization with\n+  multiple inheritance, since the compiler often adds self-cycles.)\n+- Filled the holes in the SCO port. (Thanks to Michael Arnoldus\n+  <chime@proinf.dk>.)\n+- John Ellis' additions to the C++ support:  From John:\n+\n+* I completely rewrote the documentation in the interface gc_c++.h\n+(later renamed gc_cpp.h).  I've tried to make it both clearer and more\n+precise.\n+\n+* The definition of accessibility now ignores pointers from an\n+finalizable object (an object with a clean-up function) to itself.\n+This allows objects with virtual base classes to be finalizable by the\n+collector.  Compilers typically implement virtual base classes using\n+pointers from an object to itself, which under the old definition of\n+accessibility prevented objects with virtual base classes from ever\n+being collected or finalized.\n+\n+* gc_cleanup now includes gc as a virtual base.  This was enabled by\n+the change in the definition of accessibility.\n+\n+* I added support for operator new[].  Since most (all?) compilers\n+don't yet support operator new[], it is conditionalized on\n+-DOPERATOR_NEW_ARRAY.  The code is untested, but its trivial and looks\n+correct.\n+\n+* The test program test_gc_c++ (later renamed test_cpp.cc)\n+tries to test for the C++-specific functionality not tested by the\n+other programs.\n+- Added <unistd.h> include to misc.c.  (Needed for ppcr.)\n+- Added PowerMac port. (Thanks to Patrick Beard again.)\n+- Fixed \"srcdir\"-related Makefile problems.  Changed things so\n+  that all externally visible include files always appear in the\n+  include subdirectory of the source.  Made gc.h directly\n+  includable from C++ code.  (These were at Per\n+  Bothner's suggestion.)\n+- Changed Intel code to also mark from ebp (Kevin Warne's\n+  suggestion).\n+- Renamed C++ related files so they could live in a FAT\n+  file system. (Charles Fiterman's suggestion.)\n+- Changed Windows NT Makefile to include C++ support in\n+  gc.lib.  Added C++ test as Makefile target.\n+  \n+Since version 4.3:\n+ - ASM_CLEAR_CODE was erroneously defined for HP\n+   PA machines, resulting in a compile error.\n+ - Fixed OS/2 Makefile to create a library.  (Thanks to\n+   Mark Boulter (mboulter@vnet.ibm.com)).\n+ - Gc_cleanup objects didn't work if they were created on\n+   the stack.  Fixed.\n+ - One copy of Gc_cpp.h in the distribution was out of \n+   synch, and failed to document some known compiler\n+   problems with explicit destructor invocation.  Partially\n+   fixed.  There are probably other compilers on which\n+   gc_cleanup is miscompiled.\n+ - Fixed Makefile to pass C compiler flags to C++ compiler.\n+ - Added Mac fixes.\n+ - Fixed os_dep.c to work around what appears to be\n+   a new and different VirtualQuery bug under newer\n+   versions of win32S.\n+ - GC_non_gc_bytes was not correctly maintained by\n+   GC_free.  Fixed.  Thanks to James Clark (jjc@jclark.com).\n+ - Added GC_set_max_heap_size.\n+ - Changed allocation code to ignore blacklisting if it is preventing\n+   use of a very large block of memory.  This has the advantage\n+   that naive code allocating very large objects is much more\n+   likely to work.  The downside is you might no\n+   longer find out that such code should really use\n+   GC_malloc_ignore_off_page.\n+ - Changed GC_printf under win32 to close and reopen the file\n+   between calls.  FAT file systems otherwise make the log file\n+   useless for debugging.\n+ - Added GC_try_to_collect and GC_get_bytes_since_gc.  These\n+   allow starting an abortable collection during idle times. \n+   This facility does not require special OS support.  (Thanks to\n+   Michael Spertus of Geodesic Systems for suggesting this.  It was\n+   actually an easy addition.  Kumar Srikantan previously added a similar\n+   facility to a now ancient version of the collector.  At the time\n+   this was much harder, and the result was less convincing.)\n+ - Added some support for the Borland development environment.  (Thanks\n+   to John Ellis and Michael Spertus.)\n+ - Removed a misfeature from checksums.c that caused unexpected \n+   heap growth.  (Thanks to Scott Schwartz.)\n+ - Changed finalize.c to call WARN if it encounters a finalization cycle.\n+   WARN is defined in gc_priv.h to write a message, usually to stdout.\n+   In many environments, this may be inappropriate.\n+ - Renamed NO_PARAMS in gc.h to GC_NO_PARAMS, thus adhering to my own\n+   naming convention.\n+ - Added GC_set_warn_proc to intercept warnings.\n+ - Fixed Amiga port. (Thanks to Michel Schinz (schinz@alphanet.ch).)\n+ - Fixed a bug in mark.c that could result in an access to unmapped\n+   memory from GC_mark_from_mark_stack on machines with unaligned\n+   pointers.\n+ - Fixed a win32 specific performance bug that could result in scanning of\n+   objects allocated with the system malloc.\n+ - Added REDIRECT_MALLOC.\n+\n+Since version 4.4:\n+ - Fixed many minor and one major README bugs. (Thanks to Franklin Chen\n+   (chen@adi.com) for pointing out many of them.)\n+ - Fixed ALPHA/OSF/1 dynamic library support. (Thanks to Jonathan Bachrach\n+   (jonathan@harlequin.com)).\n+ - Added incremental GC support (MPROTECT_VDB) for Linux (with some\n+   help from Bruno Haible).\n+ - Altered SPARC recognition tests in gc.h and config.h (mostly as\n+   suggested by Fergus Henderson).\n+ - Added basic incremental GC support for win32, as implemented by\n+   Windows NT and Windows 95.  GC_enable_incremental is a noop\n+   under win32s, which doesn't implement enough of the VM interface.\n+ - Added -DLARGE_CONFIG.\n+ - Fixed GC_..._ignore_off_page to also function without\n+   -DALL_INTERIOR_POINTERS.\n+ - (Hopefully) fixed RS/6000 port.  (Only the test was broken.)\n+ - Fixed a performance bug in the nonincremental collector running\n+   on machines supporting incremental collection with MPROTECT_VDB\n+   (e.g. SunOS 4, DEC AXP).  This turned into a correctness bug under\n+   win32s with win32 incremental collection.  (Not all memory protection\n+   was disabled.)\n+ - Fixed some ppcr related bit rot.\n+ - Caused dynamic libraries to be unregistered before reregistering.\n+   The old way turned out to be a performance bug on some machines.\n+ - GC_root_size was not properly maintained under MSWIN32.\n+ - Added -DNO_DEBUGGING and GC_dump.\n+ - Fixed a couple of bugs arising with SOLARIS_THREADS +\n+   REDIRECT_MALLOC.\n+ - Added NetBSD/M68K port.  (Thanks to Peter Seebach\n+   <seebs@taniemarie.solon.com>.)\n+ - Fixed a serious realloc bug.  For certain object sizes, the collector\n+   wouldn't scan the expanded part of the object.  (Thanks to Clay Spence\n+   (cds@peanut.sarnoff.com) for noticing the problem, and helping me to\n+   track it down.)\n+   \n+Since version 4.5:\n+ - Added Linux ELF support.  (Thanks to Arrigo Triulzi <arrigo@ic.ac.uk>.)\n+ - GC_base crashed if it was called before any other GC_ routines.\n+   This could happen if a gc_cleanup object was allocated outside the heap\n+   before any heap allocation.\n+ - The heap expansion heuristic was not stable if all objects had finalization\n+   enabled.  Fixed finalize.c to count memory in finalization queue and\n+   avoid explicit deallocation.  Changed alloc.c to also consider this count.\n+   (This is still not recommended.  It's expensive if nothing else.)  Thanks\n+   to John Ellis for pointing this out.\n+ - GC_malloc_uncollectable(0) was broken.  Thanks to Phong Vo for pointing\n+   this out.\n+ - The collector didn't compile under Linux 1.3.X.  (Thanks to Fred Gilham for\n+   pointing this out.)  The current workaround is ugly, but expected to be\n+   temporary.\n+ - Fixed a formatting problem for SPARC stack traces.\n+ - Fixed some '=='s in os_dep.c that should have been assignments.\n+   Fortunately these were in code that should never be executed anyway.\n+   (Thanks to Fergus Henderson.)\n+ - Fixed the heap block allocator to only drop blacklisted blocks in small\n+   chunks.  Made BL_LIMIT self adjusting.  (Both of these were in response\n+   to heap growth observed by Paul Graham.)\n+ - Fixed the Metrowerks/68K Mac code to also mark from a6.  (Thanks\n+   to Patrick Beard.)\n+ - Significantly updated README.debugging.\n+ - Fixed some problems with longjmps out of signal handlers, especially under\n+   Solaris.  Added a workaround for the fact that siglongjmp doesn't appear to\n+   do the right thing with -lthread under Solaris.\n+ - Added MSDOS/djgpp port.  (Thanks to Mitch Harris  (maharri@uiuc.edu).)\n+ - Added \"make reserved_namespace\" and \"make user_namespace\".  The\n+   first renames ALL \"GC_xxx\" identifiers as \"_GC_xxx\".  The second is the\n+   inverse transformation.  Note that doing this is guaranteed to break all\n+   clients written for the other names.\n+ - descriptor field for kind NORMAL in GC_obj_kinds with ADD_BYTE_AT_END\n+   defined should be -ALIGNMENT not WORDS_TO_BYTES(-1).  This is\n+   a serious bug on machines with pointer alignment of less than a word.\n+ - GC_ignore_self_finalize_mark_proc didn't handle pointers to very near the\n+   end of the object correctly.  Caused failures of the C++ test on a DEC Alpha\n+   with g++.\n+ - gc_inl.h still had problems.  Partially fixed.  Added warnings at the\n+   beginning to hopefully specify the remaining dangers.\n+ - Added DATAEND definition to config.h.\n+ - Fixed some of the .h file organization.  Fixed \"make floppy\".\n+ \n+Since version 4.6:\n+ - Fixed some compilation problems with -DCHECKSUMS (thanks to Ian Searle)\n+ - Updated some Mac specific files to synchronize with Patrick Beard.\n+ - Fixed a serious bug for machines with non-word-aligned pointers.\n+   (Thanks to Patrick Beard for pointing out the problem.  The collector\n+   should fail almost any conceivable test immediately on such machines.)\n+\n+Since version 4.7:\n+ - Changed a \"comment\" in a MacOS specific part of mach-dep.c that caused\n+   gcc to fail on other platforms.\n+\n+Since version 4.8\n+ - More README.debugging fixes.\n+ - Objects ready for finalization, but not finalized in the same GC\n+   cycle, could be prematurely collected.  This occasionally happened\n+   in test_cpp.\n+ - Too little memory was obtained from the system for very large\n+   objects.  That could cause a heap explosion if these objects were\n+   not contiguous (e.g. under PCR), and too much of them was blacklisted.\n+ - Due to an improper initialization, the collector was too hesitant to\n+   allocate blacklisted objects immediately after system startup.\n+ - Moved GC_arrays from the data into the bss segment by not explicitly\n+   initializing it to zero.  This significantly\n+   reduces the size of executables, and probably avoids some disk accesses\n+   on program startup.  It's conceivable that it might break a port that I\n+   didn't test.\n+ - Fixed EMX_MAKEFILE to reflect the gc_c++.h to gc_cpp.h renaming which\n+   occurred a while ago.\n+\n+Since 4.9:\n+ - Fixed a typo around a call to GC_collect_or_expand in alloc.c.  It broke\n+   handling of out of memory.  (Thanks to Patrick Beard for noticing.)\n+\n+Since 4.10:\n+ - Rationalized (hopefully) GC_try_to_collect in an incremental collection\n+   environment.  It appeared to not handle a call while a collection was in\n+   progress, and was otherwise too conservative.\n+ - Merged GC_reclaim_or_delete_all into GC_reclaim_all to get rid of some\n+   code.\n+ - Added Patrick Beard's Mac fixes, with substantial completely untested\n+   modifications.\n+ - Fixed the MPROTECT_VDB code to deal with large pages and imprecise\n+   fault addresses (as on an UltraSPARC running Solaris 2.5).  Note that this\n+   was not a problem in the default configuration, which uses PROC_VDB.\n+ - The DEC Alpha assembly code needed to restore $gp between calls.\n+   Thanks to Fergus Henderson for tracking this down and supplying a\n+   patch.\n+ - The write command for \"de\" was completely broken for large files.\n+   I used the easiest portable fix, which involved changing the semantics\n+   so that f.new is written instead of overwriting f.  That's safer anyway.\n+ - Added README.solaris2 with a discussion of the possible problems of\n+   mixing the collector's sbrk allocation with malloc/realloc.\n+ - Changed the data segment starting address for SGI machines.  The\n+   old code failed under IRIX6.\n+ - Required double word alignment for MIPS.\n+ - Various minor fixes to remove warnings.\n+ - Attempted to fix some Solaris threads problems reported by Zhiying Chen.\n+   In particular, the collector could try to fork a thread with the\n+   world stopped as part of GC_thr_init.  It also failed to deal with\n+   the case in which the original thread terminated before the whole\n+   process did.\n+ - Added -DNO_EXECUTE_PERMISSION.  This has a major performance impact\n+   on the incremental collector under Irix, and perhaps under other\n+   operating systems.\n+ - Added some code to support allocating the heap with mmap.  This may\n+   be preferable under some circumstances.\n+ - Integrated dynamic library support for HP.\n+   (Thanks to Knut Tvedten <knuttv@ifi.uio.no>.)\n+ - Integrated James Clark's win32 threads support, and made a number\n+   of changes to it, many of which were suggested by Pontus Rydin.\n+   This is still not 100% solid.\n+ - Integrated Alistair Crooks' support for UTS4 running on an Amdahl\n+   370-class machine.\n+ - Fixed a serious bug in explicitly typed allocation.  Objects requiring\n+   large descriptors where handled in a way that usually resulted in\n+   a segmentation fault in the marker.  (Thanks to Jeremy Fitzhardinge\n+   for helping to track this down.)\n+ - Added partial support for GNU win32 development.  (Thanks to Fergus\n+   Henderson.)\n+ - Added optional support for Java-style finalization semantics.  (Thanks\n+   to Patrick Bridges.)  This is recommended only for Java implementations.\n+ - GC_malloc_uncollectable faulted instead of returning 0 when out of\n+   memory.  (Thanks to dan@math.uiuc.edu for noticing.)\n+ - Calls to GC_base before the collector was initialized failed on a\n+   DEC Alpha.  (Thanks to Matthew Flatt.)\n+ - Added base pointer checking to GC_REGISTER_FINALIZER in debugging\n+   mode, at the suggestion of Jeremy Fitzhardinge.\n+ - GC_debug_realloc failed for uncollectable objects.  (Thanks to\n+   Jeremy Fitzhardinge.)\n+ - Explicitly typed allocation could crash if it ran out of memory.\n+   (Thanks to Jeremy Fitzhardinge.)\n+ - Added minimal support for a DEC Alpha running Linux.\n+ - Fixed a problem with allocation of objects whose size overflowed\n+   ptrdiff_t.  (This now fails unconditionally, as it should.)\n+ - Added the beginning of Irix pthread support.\n+ - Integrated Xiaokun Zhu's fixes for djgpp 2.01.\n+ - Added SGI-style STL allocator support (gc_alloc.h).\n+ - Fixed a serious bug in README.solaris2.  Multithreaded programs must include\n+   gc.h with SOLARIS_THREADS defined.\n+ - Changed GC_free so it actually deallocates uncollectable objects.\n+   (Thanks to Peter Chubb for pointing out the problem.)\n+ - Added Linux ELF support for dynamic libararies.  (Thanks again to\n+   Patrick Bridges.)\n+ - Changed the Borland cc configuration so that the assembler is not\n+   required.\n+ - Fixed a bug in the C++ test that caused it to fail in 64-bit\n+   environments.\n+\n+Since 4.11:\n+ - Fixed ElfW definition in dyn_load.c. (Thanks to Fergus Henderson.)\n+   This prevented the dynamic library support from compiling on some\n+   older ELF Linux systems.\n+ - Fixed UTS4 port (which I apparently mangled during the integration)\n+   (Thanks to again to Alistair Crooks.)\n+ - \"Make C++\" failed on Suns with SC4.0, due to a problem with \"bool\".\n+   Fixed in gc_priv.h.\n+ - Added more pieces for GNU win32.  (Thanks to Timothy N. Newsham.)\n+   The current state of things should suffice for at least some\n+   applications.\n+ - Changed the out of memory retry count handling as suggested by\n+   Kenjiro Taura.  (This matters only if GC_max_retries > 0, which\n+   is no longer the default.)\n+ - If a /proc read failed repeatedly, GC_written_pages was not updated\n+   correctly.  (Thanks to Peter Chubb for diagnosing this.)\n+ - Under unlikely circumstances, the allocator could infinite loop in\n+   an out of memory situation.  (Thanks again to Kenjiro Taura for\n+   identifying the problem and supplying a fix.)\n+ - Fixed a syntactic error in the DJGPP code.  (Thanks to Fergus\n+   Henderson for finding this by inspection.)  Also fixed a test program\n+   problem with DJGPP (Thanks to Peter Monks.)\n+ - Atomic uncollectable objects were not treated correctly by the\n+   incremental collector.  This resulted in weird log statistics and\n+   occasional performance problems.  (Thanks to Peter Chubb for pointing\n+   this out.)\n+ - Fixed some problems resulting from compilers that dont define\n+   __STDC__.  In this case void * and char * were used inconsistently\n+   in some cases.  (Void * should not have been used at all.  If\n+   you have an ANSI superset compiler that does not define __STDC__,\n+   please compile with -D__STDC__=0. Thanks to Manuel Serrano and others\n+   for pointing out the problem.)\n+ - Fixed a compilation problem on Irix with -n32 and -DIRIX_THREADS.\n+   Also fixed some other IRIX_THREADS problems which may or may not have\n+   had observable symptoms.\n+ - Fixed an HP PA compilation problem in dyn_load.c.  (Thanks to\n+   Philippe Queinnec.)\n+ - SEGV fault handlers sometimes did not get reset correctly.  (Thanks\n+   to David Pickens.)\n+ - Added a fix for SOLARIS_THREADS on Intel.  (Thanks again to David\n+   Pickens.)  This probably needs more work to become functional.\n+ - Fixed struct sigcontext_struct in os_dep.c for compilation under\n+   Linux 2.1.X.\t(Thanks to Fergus Henderson.)\n+ - Changed the DJGPP STACKBOTTOM and DATASTART values to those suggested\n+   by Kristian Kristensen.  These may still not be right, but it is\n+   it is likely to work more often than what was there before.  They may\n+   even be exactly right.\n+ - Added a #include <string.h> to test_cpp.cc.  This appears to help\n+   with HP/UX and gcc.  (Thanks to assar@sics.se.)\n+ - Version 4.11 failed to run in incremental mode on recent 64-bit Irix\n+   kernels.  This was a problem related to page unaligned heap segments.\n+   Changed the code to page align heap sections on all platforms.\n+   (I had mistakenly identified this as a kernel problem earlier.\n+   It was not.)\n+ - Version 4.11 did not make allocated storage executable, except on\n+   one or two platforms, due to a bug in a #if test.  (Thanks to Dave\n+   Grove for pointing this out.)\n+ - Added sparc_sunos4_mach_dep.s to support Sun's compilers under SunOS4.\n+ - Added GC_exclude_static_roots.\n+ - Fixed the object size mapping algorithm.  This shouldn't matter,\n+   but the old code was ugly.\n+ - Heap checking code could die if one of the allocated objects was\n+   larger than its base address.  (Unsigned underflow problem.  Thanks\n+   to Clay Spence for isolating the problem.)\n+ - Added RS6000 (AIX) dynamic library support and fixed STACK_BOTTOM.\n+   (Thanks to Fred Stearns.)\n+ - Added Fergus Henderson's patches for improved robustness with large\n+   heaps and lots of blacklisting.\n+ - Added Peter Chubb's changes to support Solaris Pthreads, to support\n+   MMAP allocation in Solaris, to allow Solaris to find dynamic libraries\n+   through /proc, to add malloc_typed_ignore_off_page, and a few other\n+   minor features and bug fixes.\n+ - The Solaris 2 port should not use sbrk.  I received confirmation from\n+   Sun that the use of sbrk and malloc in the same program is not\n+   supported.  The collector now defines USE_MMAP by default on Solaris.\n+ - Replaced the djgpp makefile with Gary Leavens' version.\n+ - Fixed MSWIN32 detection test.\n+ - Added Fergus Henderson's patches to allow putting the collector into\n+   a DLL under GNU win32.\n+ - Added Ivan V. Demakov's port to Watcom C on X86.\n+ - Added Ian Piumarta's Linux/PowerPC port.\n+ - On Brian Burton's suggestion added PointerFreeGC to the placement\n+   options in gc_cpp.h.  This is of course unsafe, and may be controversial.\n+   On the other hand, it seems to be needed often enough that it's worth\n+   adding as a standard facility.\n+\n+Since 4.12:\n+ - Fixed a crucial bug in the Watcom port.  There was a redundant decl\n+   of GC_push_one in gc_priv.h.\n+ - Added FINALIZE_ON_DEMAND.\n+ - Fixed some pre-ANSI cc problems in test.c.\n+ - Removed getpagesize() use for Solaris.  It seems to be missing in one\n+   or two versions.\n+ - Fixed bool handling for SPARCCompiler version 4.2.\n+ - Fixed some files in include that had gotten unlinked from the main\n+   copy.\n+ - Some RS/6000 fixes (missing casts).  Thanks to Toralf Foerster.\n+ - Fixed several problems in GC_debug_realloc, affecting mostly the\n+   FIND_LEAK case.\n+ - GC_exclude_static_roots contained a buggy unsigned comparison to\n+   terminate a loop.  (Thanks to Wilson Ho.)\n+ - CORD_str failed if the substring occurred at the last possible position.\n+   (Only affects cord users.)\n+ - Fixed Linux code to deal with RedHat 5.0 and integrated Peter Bigot's\n+   os_dep.c code for dealing with various Linux versions.\n+ - Added workaround for Irix pthreads sigaction bug and possible signal\n+   misdirection problems.\n+Since alpha1:\n+ - Changed RS6000 STACKBOTTOM.\n+ - Integrated Patrick Beard's Mac changes.\n+ - Alpha1 didn't compile on Irix m.n, m < 6.\n+ - Replaced Makefile.dj with a new one from Gary Leavens.\n+ - Added Andrew Stitcher's changes to support SCO OpenServer.\n+ - Added PRINT_BLACK_LIST, to allow debugging of high densities of false\n+   pointers.\n+ - Added code to debug allocator to keep track of return address\n+   in GC_malloc caller, thus giving a bit more context.\n+ - Changed default behavior of large block allocator to more\n+   aggressively avoid fragmentation.  This is likely to slow down the\n+   collector when it succeeds at reducing space cost.\n+ - Integrated Fergus Henderson's CYGWIN32 changes.  They are untested,\n+   but needed for newer versions.\n+ - USE_MMAP had some serious bugs.  This caused the collector to fail\n+   consistently on Solaris with -DSMALL_CONFIG.\n+ - Added Linux threads support, thanks largely to Fergus Henderson.\n+Since alpha2:\n+ - Fixed more Linux threads problems.\n+ - Changed default GC_free_space_divisor to 3 with new large block allocation.\n+   (Thanks to Matthew Flatt for some measurements that suggest the old\n+   value sometimes favors space too much over time.)\n+ - More CYGWIN32 fixes.\n+ - Integrated Tyson-Dowd's Linux-M68K port.\n+ - Minor HP PA and DEC UNIX fixes from Fergus Henderson.\n+ - Integrated Christoffe Raffali's Linux-SPARC changes.\n+ - Allowed for one more GC fixup iteration after a full GC in incremental\n+   mode.  Some quick measurements suggested that this significantly\n+   reduces pause times even with smaller GC_RATE values.\n+ - Moved some more GC data structures into GC_arrays.  This decreases\n+   pause times and GC overhead, but makes debugging slightly less convenient.\n+ - Fixed namespace pollution problem (\"excl_table\").\n+ - Made GC_incremental a constant for -DSMALL_CONFIG, hopefully shrinking\n+   that slightly.\n+ - Added some win32 threads fixes.\n+ - Integrated Ivan Demakov and David Stes' Watcom fixes.\n+ - Various other minor fixes contributed by many people.\n+ - Renamed config.h to gcconfig.h, since config.h tends to be used for\n+   many other things.\n+ - Integrated Matthew Flatt's support for 68K MacOS \"far globals\".\n+ - Fixed up some of the dynamic library Makefile targets for consistency\n+   across platforms.\n+ - Fixed a USE_MMAP typo that caused out-of-memory handling to fail\n+   on Solaris.\n+ - Added code to test.c to test thread creation a bit more.\n+ - Integrated GC_win32_free_heap, as suggested by Ivan Demakov.\n+ - Fixed Solaris 2.7 stack base finding problem.  (This may actually\n+   have been done in an earlier alpha release.)\n+Since alpha3:\n+ - Fixed MSWIN32 recognition test, which interfered with cygwin.\n+ - Removed unnecessary gc_watcom.asm from distribution.  Removed\n+   some obsolete README.win32 text.\n+ - Added Alpha Linux incremental GC support.  (Thanks to Philipp Tomsich\n+   for code for retrieving the fault address in a signal handler.)\n+   Changed Linux signal handler context argument to be a pointer.\n+ - Took care of some new warnings generated by the 7.3 SGI compiler.\n+ - Integrated Phillip Musumeci's FreeBSD/ELF fixes.\n+ - -DIRIX_THREADS was broken with the -o32 ABI (typo in gc_priv.h>\n+\n+Since 4.13:\n+ - Fixed GC_print_source_ptr to not use a prototype.\n+ - generalized CYGWIN test.\n+ - gc::new did the wrong thing with PointerFreeGC placement.\n+   (Thanks to Rauli Ruohonen.)\n+ - In the ALL_INTERIOR_POINTERS (default) case, some callee-save register\n+   values could fail to be scanned if the register was saved and\n+   reused in a GC frame.  This showed up in verbose mode with gctest\n+   compiled with an unreleased SGI compiler.  I vaguely recall an old\n+   bug report that may have been related.  The bug was probably quite old.\n+   (The problem was that the stack scanning could be deferred until\n+   after the relevant frame was overwritten, and the new save location\n+   might be outside the scanned area.  Fixed by more eager stack scanning.)\n+ - PRINT_BLACK_LIST had some problems.  A few source addresses were garbage.\n+ - Replaced Makefile.dj and added -I flags to cord make targets.\n+   (Thanks to Gary Leavens.)\n+ - GC_try_to_collect was broken with the nonincremental collector.\n+ - gc_cleanup destructors could pass the wrong address to\n+   GC_register_finalizer_ignore_self in the presence of multiple\n+   inheritance.  (Thanks to Darrell Schiebel.)\n+ - Changed PowerPC Linux stack finding code.\n+\n+Since 4.14alpha1\n+ - -DSMALL_CONFIG did not work reliably with large (> 4K) pages.\n+   Recycling the mark stack during expansion could result in a size\n+   zero heap segment, which confused things.  (This was probably also an\n+   issue with the normal config and huge pages.)\n+ - Did more work to make sure that callee-save registers were scanned\n+   completely, even with the setjmp-based code.  Added USE_GENERIC_PUSH_REGS\n+   macro to facilitate testing on machines I have access to.\n+ - Added code to explicitly push register contents for win32 threads.\n+   This seems to be necessary.  (Thanks to Pierre de Rop.)\n+\n+Since 4.14alpha2\n+ - changed STACKBOTTOM for DJGPP (Thanks to Salvador Eduardo Tropea).\n+ \n+Since 4.14\n+ - Reworked large block allocator.  Now uses multiple doubly linked free\n+   lists to approximate best fit.\n+ - Changed heap expansion heuristic.  Entirely free blocks are no longer\n+   counted towards the heap size.  This seems to have a major impact on\n+   heap size stability; the old version could expand the heap way too\n+   much in the presence of large block fragmentation.\n+ - added -DGC_ASSERTIONS and some simple assertions inside the collector.\n+   This is mainlyt for collector debugging.\n+ - added -DUSE_MUNMAP to allow the heap to shrink.  Suupported on only\n+   a few UNIX-like platforms for now.\n+ - added GC_dump_regions() for debugging of fragmentation issues.\n+ - Changed PowerPC pointer alignment under Linux to 4.  (This needs\n+   checking by someone who has one.  The suggestions came to me via a\n+   rather circuitous path.)\n+ - Changed the Linux/Alpha port to walk the data segment backwards until\n+   it encounters a SIGSEGV.  The old way to find the start of the data\n+   segment broke with a recent release.\n+ - cordxtra.c needed to call GC_REGISTER_FINALIZER instead of\n+   GC_register_finalizer, so that it would continue to work with GC_DEBUG.\n+ - allochblk sometimes cleared the wrong block for debugging purposes\n+   when it dropped blacklisted blocks.  This could result in spurious\n+   error reports with GC_DEBUG.\n+ - added MACOS X Server support.  (Thanks to Andrew Stone.)\n+ - Changed the Solaris threads code to ignore stack limits > 8 MB with\n+   a warning.  Empirically, it is not safe to access arbitrary pages\n+   in such large stacks.  And the dirty bit implementation does not\n+   guarantee that none of them will be accessed.\n+ - Integrated Martin Tauchmann's Amiga changes.\n+ - Integrated James Dominy's OpenBSD/SPARC port.\n+\n+Since 5.0alpha1\n+ - Fixed bugs introduced in alpha1 (OpenBSD & large block initialization).\n+ - Added -DKEEP_BACK_PTRS and backptr.h interface.  (The implementation\n+   idea came from Al Demers.)\n+\n+Since 5.0alpha2\n+ - Added some highly incomplete code to support a copied young generation.\n+   Comments on nursery.h are appreciated.\n+ - Changed -DFIND_LEAK, -DJAVA_FINALIZATION, and -DFINALIZE_ON_DEMAND,\n+   so the same effect could be obtained with a runtime switch.   This is\n+   a step towards standardizing on a single dynamic GC library.\n+ - Significantly changed the way leak detection is handled, as a consequence\n+   of the above.\n+\n+Since 5.0 alpha3\n+ - Added protection fault handling patch for Linux/M68K from Fergus\n+   Henderson and Roman Hodek.\n+ - Removed the tests for SGI_SOURCE in new_gc_alloc.h.  This was causing that\n+   interface to fail on nonSGI platforms.\n+ - Changed the Linux stack finding code to use /proc, after changing it\n+   to use HEURISTIC1.  (Thanks to David Mossberger for pointing out the\n+   /proc hook.)\n+ - Added HP/UX incremental GC support and HP/UX 11 thread support.\n+   Thread support is currently still flakey.\n+ - Added basic Linux/IA64 support.\n+ - Integrated Anthony Green's PicoJava support.\n+ - Integrated Scott Ananian's StrongARM/NetBSD support.\n+ - Fixed some fairly serious performance bugs in the incremental\n+   collector.  These have probably been there essentially forever.\n+   (Mark bits were sometimes set before scanning dirty pages.\n+   The reclaim phase unnecessarily dirtied full small object pages.)\n+ - Changed the reclaim phase to ignore nearly full pages to avoid\n+   touching them.\n+ - Limited GC_black_list_spacing to roughly the heap growth increment.\n+ - Changed full collection triggering heuristic to decrease full GC\n+   frequency by default, but to explicitly trigger full GCs during\n+   heap growth.  This doesn't always improve things, but on average it's\n+   probably a win.\n+ - GC_debug_free(0, ...) failed.  Thanks to Fergus Henderson for the\n+   bug report and fix.\n+\n+Since 5.0 alpha4\n+ - GC_malloc_explicitly_typed and friends sometimes failed to\n+   initialize first word.\n+ - Added allocation routines and support in the marker for mark descriptors\n+   in a type structure referenced by the first word of an object.  This was\n+   introduced to support gcj, but hopefully in a way that makes it\n+   generically useful.\n+ - Added GC_requested_heapsize, and inhibited collections in nonincremental\n+   mode if the actual used heap size is less than what was explicitly\n+   requested.\n+ - The Solaris pthreads version of GC_pthread_create didn't handle a NULL\n+   attribute pointer.  Solaris thread support used the wrong default thread\n+   stack size.  (Thanks to Melissa O'Neill for the patch.)\n+ - Changed PUSH_CONTENTS macro to no longer modify first parameter.\n+   This usually doesn't matter, but it was certainly an accident waiting\n+   to happen ...\n+ - Added GC_register_finalizer_no_order and friends to gc.h.  They're\n+   needed by Java implementations.\n+ - Integrated a fix for a win32 deadlock resulting from clock() calling\n+   malloc.  (Thanks to Chris Dodd.)\n+ - Integrated Hiroshi Kawashima's port to Linux/MIPS.  This was designed\n+   for a handheld platform, and may or may not be sufficient for other\n+   machines.\n+ - Fixed a va_arg problem with the %c specifier in cordprnt.c.  It appears\n+   that this was always broken, but recent versions of gcc are the first to\n+   report the (statically detectable) bug.\n+ - Added an attempt at a more general solution to dlopen races/deadlocks.\n+   GC_dlopen now temporarily disables collection.  Still not ideal, but ...\n+ - Added -DUSE_I686_PREFETCH, -DUSE_3DNOW_PREFETCH, and support for IA64\n+   prefetch instructions.  May improve performance measurably, but I'm not\n+   sure the code will run correctly on processors that don't support the\n+   instruction.  Won't build except with very recent gcc.\n+ - Added caching for header lookups in the marker.  This seems to result\n+   in a barely measurable performance gain.  Added support for interleaved\n+   lookups of two pointers, but unconfigured that since the performance\n+   gain is currently near zero, and it adds to code size.\n+ - Changed Linux DATA_START definition to check both data_start and\n+   __data_start, since nothing else seems to be portable.\n+ - Added -DUSE_LD_WRAP to optionally take advantage of the GNU ld function\n+   wrapping mechanism.  Probably currently useful only on Linux.\n+ - Moved some variables for the scratch allocator into GC_arrays, on\n+   Martin Hirzel's suggestion.\n+ - Fixed a win32 threads bug that caused the collector to not look for\n+   interior pointers from one of the thread stacks without\n+   ALL_INTERIOR_POINTERS.  (Thanks to Jeff Sturm.)\n+ - Added Mingw32 support.  (Thanks again to Jeff Sturm for the patch.)\n+ - Changed the alpha port to use the generic register scanning code instead\n+   of alpha_mach_dep.s.  Alpha_mach_dep.s doesn't look for pointers in fp\n+   registers, but gcc sometimes spills pointers there.  (Thanks to Manuel\n+   Serrano for helping me debug this by email.)  Changed the IA64 code to\n+   do something similar for similar reasons.\n+\n+[5.0alpha5 doesn't really exist, but it may have escaped.]\n+\n+Since 5.0alpha6:\n+ - -DREDIRECT_MALLOC was broken in alpha6. Fixed.\n+ - Cleaned up gc_ccp.h slightly, thus also causing the HP C++ compiler to\n+   accept it.\n+ - Removed accidental reference to dbg_mlc.c, which caused dbg_mlc.o to be\n+   linked into every executable.\n+ - Added PREFETCH to bitmap marker.  Changed it to use the header cache.\n+ - GC_push_marked sometimes pushed one object too many, resulting in a\n+   segmentation fault in GC_mark_from_mark_stack.  This was probably an old\n+   bug.  It finally showed up in gctest on win32.\n+ - Gc_priv.h erroneously #defined GC_incremental to be TRUE instead of FALSE\n+   when SMALL_CONFIG was defined.  This was no doubt a major performance bug for\n+   the default win32 configuration.\n+ - Removed -DSMALL_CONFIG from NT_MAKEFILE.  It seemed like an anchronism now\n+   that the average PC has 64MB or so.\n+ - Integrated Bryce McKinley's patches for linux threads and dynamic loading\n+   from the libgcj tree.  Turned on dynamic loading support for Linux/PPC.\n+ - Changed the stack finding code to use environ on HP/UX.  (Thanks\n+   to Gustavo Rodriguez-Rivera for the suggestion.)  This should probably\n+   be done on other platforms, too.  Since I can't test those, that'll\n+   wait until after 5.0.\n+\n+Since 5.0alpha7:\n+ - Fixed threadlibs.c for linux threads.  -DUSE_LD_WRAP was broken and\n+   -ldl was omitted.  Fixed Linux stack finding code to handle\n+   -DUSE_LD_WRAP correctly.\n+ - Added MSWIN32 exception handler around marker, so that the collector\n+   can recover from root segments that are unmapped during the collection.\n+   This caused occasional failures under Windows 98, and may also be\n+   an issue under Windows NT/2000.\n+\n+Since 5.0\n+ - Fixed a gc.h header bug which showed up under Irix.  (Thanks to\n+   Dan Sullivan.)\n+ - Fixed a typo in GC_double_descr in typd_mlc.c.\n+   This probably could result in objects described by array descriptors not\n+   getting traced correctly.  (Thanks to Ben Hutchings for pointing this out.)\n+ - The block nearly full tests in reclaim.c were not correct for 64 bit\n+   environments.  This could result in unnecessary heap growth under unlikely\n+   conditions.\n+\n+Since 5.1\n+ - dyn_load.c declared GC_scratch_last_end_ptr as an extern even if it\n+   was defined as a macro.  This prevented the collector from building on\n+   Irix.\n+ - We quietly assumed that indirect mark descriptors were never 0.\n+   Our own typed allocation interface violated that.  This could result\n+   in segmentation faults in the marker with typed allocation.\n+ - Fixed a _DUSE_MUNMAP bug in the heap block allocation code.\n+   (Thanks to Ben Hutchings for the patch.)\n+ - Taught the collector about VC++ handling array operator new.\n+   (Thanks again to Ben Hutchings for the patch.)\n+ - The two copies of gc_hdrs.h had diverged.  Made one a link to the other\n+   again.\n+\n+Since 5.2  (A few 5.2 patches are not in 6.0alpha1)\n+ - Fixed _end declaration for OSF1.\n+ - There were lots of spurious leak reports in leak detection mode, caused\n+   by the fact that some pages were not being swept, and hence unmarked\n+   objects weren't making it onto free lists.  (This bug dated back to 5.0.)\n+ - Fixed a typo in the liblinuxgc.so Makefile rule.\n+ - Added the GetExitCodeThread to Win32 GC_stop_world to (mostly) work\n+   around a Windows 95 GetOpenFileName problem.  (Thanks to Jacob Navia.)\n+\n+Since 5.3\n+ - Fixed a typo that prevented compilation with -DUSE_3DNOW_PREFETCH.\n+   (Thanks to Shawn Wagner for actually testing this.)\n+ - Fixed GC_is_thread_stack in solaris_threads.c.  It forgot to return a value\n+   in the common case.  I wonder why nobody noticed?\n+ - Fixed another silly syntax problem in GC_double_descr.  (Thanks to\n+   Fergus Henderson for finding it.)\n+ - Fixed a GC_gcj_malloc bug: It tended to release the allocator lock twice.\n+\n+Since 5.4  (A few 5.3 patches are not in 6.0alpha2)\n+ - Added HP/PA prefetch support.\n+ - Added -DDBG_HDRS_ALL and -DSHORT_DBG_HDRS to reduce the cost and improve\n+   the reliability of generating pointer backtrace information, e.g. in\n+   the Bigloo environment.\n+ - Added parallel marking support (-DPARALLEL_MARK).  This currently\n+   works only under IA32 and IA64 Linux, but it shouldn't be hard to adapt\n+   to other platforms.  This is intended to be a lighter-weight (less\n+   new code, probably not as scalable) solution than the work by Toshio Endo\n+   et al, at the University of Tokyo.  A number of their ideas were\n+   reused, though the code wasn't, and the underlying data structure\n+   is significantly different.  In particular, we keep the global mark\n+   stack as a single shared data structure, but most of the work is done\n+   on smaller thread-local mark stacks.\n+ - Changed GC_malloc_many to be cheaper, and to require less mutual exclusion\n+   with -DPARALLEL_MARK.\n+ - Added full support for thread local allocation under Linux\n+   (-DTHREAD_LOCAL_ALLOC).  This is a thin veneer on GC_malloc_many, and\n+   should be easily portable to other platforms, especially those that\n+   support pthreads.\n+ - CLEAR_DOUBLE was not always getting invoked when it should have been.\n+ - GC_gcj_malloc and friends used different out of memory handling than\n+   everything else, probably because I forgot about one when I implemented\n+   the other.  They now both call GC_oom_fn(), not GC_oom_action().\n+ - Integrated Jakub Jelinek's fixes for Linux/SPARC.\n+ - Moved GC_objfreelist, GC_aobjfreelist, and GC_words_allocd out of\n+   GC_arrays, and separately registered the first two as excluded roots.\n+   This makes code compiled with gc_inl.h less dependent on the\n+   collector version.  (It would be nice to remove the inclusion of\n+   gc_priv.h by gc_inl.h completely, but we're not there yet.  The\n+   locking definitions in gc_priv.h are still referenced.)\n+   This change was later coniditoned on SEPARATE_GLOBALS, which\n+   is not defined by default, since it involves a performance hit.\n+ - Register GC_obj_kinds separately as an excluded root region.  The\n+   attempt to register it with GC_arrays was usually failing.  (This wasn't\n+   serious, but seemed to generate some confusion.) \n+ - Moved backptr.h to gc_backptr.h.\n+\n+Since 6.0alpha1\n+ - Added USE_MARK_BYTES to reduce the need for compare-and-swap on platforms\n+   for which that's expensive.\n+ - Fixed a locking bug ib GC_gcj_malloc and some locking assertion problems.\n+ - Added a missing volatile to OR_WORD and renamed the parameter to\n+   GC_compare_and_swap so it's not a C++ reserved word.  (Thanks to\n+   Toshio Endo for pointing out both of those.)\n+ - Changed Linux dynamic library registration code to look at /proc/self/maps\n+   instead of the rld data structures when REDIRECT_MALLOC is defined.\n+   Otherwise some of the rld data data structures may be prematurely garbage\n+   collected.  (Thanks to Eric Benson for helping to track this down.)\n+ - Fixed USE_LD_WRAP a bit more, so it should now work without threads.\n+ - Renamed XXX_THREADS macros to GC_XXX_THREADS for namespace correctness.\n+   Tomporarily added some backward compatibility definitions.  Renamed\n+   USE_LD_WRAP to GC_USE_LD_WRAP.\n+ - Many MACOSX POWERPC changes, some additions to the gctest output, and\n+   a few minor generic bug fixes.  (Thanks to Dietmar Planitzer.)\n+\n+Since 6.0 alpha2\n+ - Fixed the /proc/self/maps code to not seek, since that apparently is not\n+   reliable across all interesting kernels.\n+ - Fixed some compilation problems in the absence of PARALLEL_MARK\n+   (introduced in alpha2).\n+ - Fixed an algorithmic problem with PARALLEL_MARK.  If work needs to\n+   be given back to the main mark \"stack\", the BOTTOM entries of the local\n+   stack should be given away, not the top ones.  This has substantial\n+   performance impact, especially for > 2 processors, from what I can tell.\n+ - Extracted gc_lock.h from gc_priv.h.  This should eventually make it a\n+   bit easier to avoid including gc_priv.h in clients.\n+ - Moved all include files to include/ and removed duplicate links to the\n+   same file.  The old scheme was a bad idea because it was too easy to get the\n+   copies out of sync, and many systems don't support hard links.\n+   Unfortunately, it's likely that I broke some of the non-Unix Makefiles in\n+   the process, although I tried to update them appropriately.\n+ - Removed the partial support for a copied nursery.  It's not clear that\n+   this would be a tremendous win, since we don't consistently lose to\n+   generational copying collectors.  And it would significantly complicate\n+   many things.  May be reintroduced if/when it really turns out to win.\n+ - Removed references to IRIX_JDK_THREADS, since I believe there never\n+   were and never will be any clients.\n+ - Added some code to linux_threads.c to possibly support HPUX threads\n+   using the Linux code.  Unfortunately, it doesn't work yet, and is\n+   currently disabled.\n+ - Added support under Linux/X86 for saving the call chain, both in (debug)\n+   objects for client debugging, and in GC_arrays._last_stack for GC\n+   debugging.  This was previously supported only under Solaris.  It is\n+   not enabled by default under X86, since it requires that code be compiled\n+   to explicitly dave frame pointers on the call stack.  (With gcc this\n+   currently happens by default, but is often turned off explicitly.)\n+   To turn it on, define SAVE_CALL_CHAIN.\n+ \n+Since 6.0 alpha3\n+ - Moved up the detection of mostly full blocks to the initiatiation of the\n+   sweep phase.  This eliminates some lock conention in the PARALLEL_MARK case,\n+   as multiple threads try to look at mostly full blocks concurrently.\n+ - Restored the code in GC_malloc_many that grabs a prefix of the global\n+   free list.  This avoids the case in which every GC_malloc_many call\n+   tries and fails to allocate a new heap block, and the returns a single\n+   object from the global free list.\n+ - Some minor fixes in new_hblk.c.  (Attempted to build free lists in order\n+   of increasing addresses instead of decreasing addresses for cache performance\n+   reasons.  But this seems to be only a very minor gain with -DEAGER_SWEEP,\n+   and a loss in other cases.  So the change was backed out.)\n+ - Fixed some of the documentation.  (Thanks in large part to Fergus\n+   Henderson.)\n+ - Fixed the Linux USE_PROC_FOR_LIBRARIES code to deal with apps that perform\n+   large numbers of mmaps.  (Thanks to Eric Benson.)  Also fixed that code to\n+   deal with short reads.\n+ - Added GC_get_total_bytes(). \n+ - Fixed leak detection mode to avoid spurious messages under linuxthreads.\n+   (This should also now be easy for the other supported threads packages.\n+   But the code is tricky enough that I'm hesitant to do it without being able\n+   to test.  Everything allocated in the GC thread support itself should be\n+   explicitly deallocated.)\n+ - Made it possible (with luck) to redirect malloc to GC_local_malloc.\n+\n+Since 6.0 alpha4\n+ - Changed the definition of GC_pause in linux_threads.c to use a volatile\n+   asm.  Some versions of gcc apparently optimize away writes to local volatile\n+   variables.  This caused poor locking behaviour starting at about\n+   4 processors.\n+ - Added GC_start_blocking(), GC_end_blocking() calls and wrapper for sleep\n+   to linux_threads.c.\n+   The first two calls could be used to generally avoid sending GC signals to\n+   blocked threads, avoiding both premature wakeups and unnecessary overhead.\n+ - Fixed a serious bug in thread-local allocation.  At thread termination,\n+   GC_free could get called on small integers.  Changed the code for thread\n+   termination to more efficiently return left-over free-lists.\n+ - Integrated Kjetil Matheussen's BeOS support.\n+ - Rearranged the directory structure to create the doc and tests\n+   subdirectories.\n+ - Sort of integrated Eric Benson's patch for OSF1.  This provided basic\n+   OSF1 thread support by suitably extending hpux_irix_threads.c.  Based\n+   on earlier email conversations with David Butenhof, I suspect that it\n+   will be more reliable in the long run to base this on linux_threads.c\n+   instead.  Thus I attempted to patch up linux_threads.c based on Eric's code.\n+   The result is almost certainly broken, but hopefully close enough that\n+   someone with access to a machine can pick it up.\n+ - Integrated lots of minor changes from the NetBSD distribution.  (These\n+   were supplied by David Brownlee.  I'm not sure about the original\n+   authors.)\n+ - Hacked a bit more on the HP/UX thread-support in linux_threads.c.  It\n+   now appears to work in the absence of incremental collection.  Renamed\n+   hpux_irix_threads.c back to irix_threads.c, and removed the attempt to\n+   support HPUX there.\n+ - Changed gc.h to define _REENTRANT in cases in which it should already\n+   have been defined. It is still safer to also define it on the command\n+   line. \n+\n+Since 6.0alpha5:\n+ - Changed the definition of DATASTART on ALPHA and IA64, where data_start\n+   and __data_start are not defined by earlier versions of glibc.  This might\n+   need to be fixed on other platforms as well.\n+ - Changed the way the stack base and backing store base are found on IA64.\n+   This should now remain reliable on future kernels.  But since it relies\n+   on /proc, it will no longer work in the simulated NUE environment.\n+ - Made the call to random() in dbg_mlc.c with -DKEEP_BACK_PTRS dependent\n+   on the OS.  On non-Unix systems, rand() should be used instead.  Handled\n+   small RAND_MAX.  (Thanks to Peter Ross for pointing this out.)\n+ - Fixed the cord make rules to create the cord subdirectory, if necessary.\n+   (Thanks to Doug Moen.)\n+ - Changed fo_object_size calculation in finalize.c.  Turned finalization\n+   of nonheap object into a no-op.  Removed anachronism from GC_size()\n+   implementation.\n+ - Changed GC_push_dirty call in solaris_threads.c to GC_push_selected.\n+   It was missed in a previous renaming. (Thanks to Vladimir Tsichevski\n+   for pointing this out.)\n+ - Arranged to not not mask SIGABRT in linux_threads.c.  (Thanks to Bryce\n+   McKinlay.) \n+ - Added GC_no_dls hook for applications that want to register their own\n+   roots.\n+ - Integrated Kjetil Matheussen's Amiga changes.\n+ - Added FREEBSD_STACKBOTTOM.  Changed the X86/FreeBSD port to use it.\n+   (Thanks to Matthew Flatt.)\n+ - Added pthread_detach interception for platforms supported by linux_threads.c\n+   and irix_threads.c.  Should also be added for Solaris?\n+ - Changed the USE_MMAP code to check for the case in which we got the\n+   high end of the address space, i.e. mem_ptr + mem_sz == 0.  It appears\n+   that this can happen under Solaris 7.  It seems to be allowed by what\n+   I would claim is an oversight in the mmap specification.  (Thanks to Toshio\n+   Endo for pointing out the problem.)\n+ - Cleanup of linux_threads.c.  Some code was originally cloned from\n+   irix_threads.c and now unnecessary.  Some comments were obviously wrong.\n+ - (Mostly) fixed a longstanding problem with setting of dirty bits from\n+   a signal handler.  In the presence of threads, dirty bits could get lost,\n+   since the etting of a bit in the bit vector was not atomic with respect\n+   to other updates.  The fix is 100% correct only for platforms for which\n+   GC_test_and_set is defined.  The goal is to make that all platforms with\n+   thread support.  Matters only if incremental GC and threads are both\n+   enabled.\n+ - made GC_all_interior_pointers (a.k.a. ALL_INTERIOR_POINTERS) an\n+   initialization time, instead of build-time option.  This is a \n+   nontrivial, high risk change.  It should slow down the code measurably\n+   only if MERGE_SIZES is not defined, which is a very nonstandard\n+   configuration.   \n+ - Added doc/README.environment, and implemented what it describes.  This\n+   allows a number of additional configuration options to be set through\n+   the environment.  It documents a few previously undocumented options.\n+ - Integrated Eric Benson's leak testing improvements.\n+ - Removed the option to throw away the beginning of each page (DISCARD_WORDS).\n+   This became less and less useful as processors enforce stricter alignment.\n+   And it hadn't been tested in ages, and was thus probably broken anyway.\n+\n+Since 6.0alpha6:\n+ - Added GC_finalizer_notifier.  Fixed GC_finalize_on_demand.  (The variable\n+   actually wasn't being tested at the right points.  The build-time flag\n+   was.)\n+ - Added Tom Tromey's S390 Linux patch.\n+ - Added code to push GC_finalize_now in GC_push_finalizer_structures.\n+   (Thanks to Matthew Flatt.)\n+ - Added GC_push_gc_structures() to push all GC internal roots.\n+ - Integrated some FreeBSD changes from Matthew Flatt.\n+ - It looks like USRSTACK is not always correctly defined under Solaris.\n+   Hacked gcconfig.h to attempt to work around the problem.  The result\n+   is not well tested.  (Thanks again to Matthew Flatt for pointing this\n+   out.  The gross hack is mine. - HB)\n+ - Added Ji-Yong Chung's win32 threads and C++ fixes.\n+ - Arranged for hpux_test_and_clear.s to no longer be needed or built.\n+   It was causing build problems with gas, and it's not clear this is\n+   better than the pthreads alternative on this platform.\n+ - Some MINGW32 fixes from Hubert Garavel.\n+ - Added Initial Hitachi SH4 port from Kaz Kojima.\n+ - Ported thread-local allocation and parallel mark code to HP/UX on PA_RISC.\n+ - Made include/gc_mark.h more public and separated out the really private\n+   pieces.  This is probably still not quite sufficient for clients that\n+   want to supply their own kind of type information.  But it's a start.\n+   This involved lots of identifier renaming to make it namespace clean.\n+ - Added GC_dont_precollect for clients that need complete control over\n+   the root set.\n+ - GC_is_visible didn't do the right thing with gcj objects.  (Not that\n+   many people are likely to care, but ...)\n+ - Don't redefine read with GC_USE_LD_WRAP.\n+ - Initial port to LINUX/HP_PA.  Incremental collection and threads are not\n+   yet supported.  (Incremental collection should work if you have the\n+   right kernel.  Threads may work with a sufficiently patched pthread\n+   library.)\n+ - Changed gcconfig.h to recognize __i386__ as an alternative to i386 in\n+   many places.  (Thanks to Benjamin Lerman.)\n+ - Made win32_threads.c more tolerant of detaching a thread that it didn't\n+   know about.  (Thanks to Paul Nash.)\n+ - Added Makefile.am and configure.in from gcc to the distribution, with\n+   minimal changes.  For the moment, those are just placeholders.  In the\n+   future, we're planning to switch to a GNU-style build environment for\n+   Un*x-like systems, though the old Makefile will remain as a backup.\n+ - Turned off STUBBORN_ALLOC by default, and added it back as a Makefile\n+   option.\n+ - Redistributed some functions between malloc.c and mallocx.c, so that\n+   simple statically linked apps no longer pull in mallocx.o.\n+ - Changed large object allocation to clear the first and last few words\n+   of each block before releassing the lock.  Otherwise the marker could see\n+   objects with nonsensical type descriptors.\n+ - Fixed a couple of subtle problems that could result in not recognizing\n+   interior pointers from the stack.  (I believe these were introduced\n+   in 6.0alpha6.)\n+ - GC_debug_free_inner called GC_free, which tried to reacquire the\n+   allocator lock, and hence deadlocked.  (DBG_HDRS_ALL probably never worked\n+   with threads?)\n+ - Fixed several problems with back traces.  Accidental references to a free\n+   list could cause the free list pointer to be overwritten by a back pointer.\n+   There seemed to be some problems with the encoding of root and finalizer\n+   references.\n+  \n+To do:\n+ - Very large root set sizes (> 16 MB or so) could cause the collector\n+   to abort with an unexpected mark stack overflow.  (Thanks again to\n+   Peter Chubb.)  NOT YET FIXED.  Workaround is to increase the initial\n+   size.\n+ - The SGI version of the collector marks from mmapped pages, even\n+   if they are not part of dynamic library static data areas.  This\n+   causes performance problems with some SGI libraries that use mmap\n+   as a bitmap allocator.  NOT YET FIXED.  It may be possible to turn\n+   off DYNAMIC_LOADING in the collector as a workaround.  It may also\n+   be possible to conditionally intercept mmap and use GC_exclude_static_roots.\n+   The real fix is to walk rld data structures, which looks possible.\n+ - Incremental collector should handle large objects better.  Currently,\n+   it looks like the whole object is treated as dirty if any part of it\n+   is.\n+ - Cord/cordprnt.c doesn't build on a few platforms (notably PowerPC), since\n+   we make some unwarranted assumptions about how varargs are handled.  This\n+   currently makes the cord-aware versions of printf unusable on some platforms.\n+   Fixing this is unfortunately not trivial."}, {"sha": "fd5c95f2297723c2b52f5b234ef6eb773e57ff05", "filename": "boehm-gc/doc/README.contributors", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.contributors", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.contributors", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.contributors?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,57 @@\n+This is an attempt to acknowledge early contributions to the garbage\n+collector.  Later contributions should instead be mentioned in\n+README.changes.\n+\n+HISTORY -\n+\n+  Early versions of this collector were developed as a part of research\n+projects supported in part by the National Science Foundation\n+and the Defense Advance Research Projects Agency.\n+\n+The garbage collector originated as part of the run-time system for\n+the Russell programming language implementation. The first version of the\n+garbage collector was written primarily by Al Demers.  It was then refined\n+and mostly rewritten, primarily by Hans-J. Boehm, at Cornell U., \n+the University of Washington, Rice University (where it was first used for\n+C and assembly code), Xerox PARC, SGI, and HP Labs.  However, significant\n+contributions have also been made by many others.\n+\n+Some other contributors:  \n+\n+More recent contributors are mentioned in the modification history in\n+README.changes.  My apologies for any omissions.\n+\n+The SPARC specific code was originally contributed by Mark Weiser.\n+The Encore Multimax modifications were supplied by\n+Kevin Kenny (kenny@m.cs.uiuc.edu).  The adaptation to the IBM PC/RT is largely\n+due to Vernon Lee, on machines made available to Rice by IBM.\n+Much of the HP specific code and a number of good suggestions for improving the\n+generic code are due to Walter Underwood.\n+Robert Brazile (brazile@diamond.bbn.com) originally supplied the ULTRIX code.\n+Al Dosser (dosser@src.dec.com) and Regis Cridlig (Regis.Cridlig@cl.cam.ac.uk)\n+subsequently provided updates and information on variation between ULTRIX\n+systems.  Parag Patel (parag@netcom.com) supplied the A/UX code.\n+Jesper Peterson(jep@mtiame.mtia.oz.au), Michel Schinz, and\n+Martin Tauchmann (martintauchmann@bigfoot.com) supplied the Amiga port.\n+Thomas Funke (thf@zelator.in-berlin.de(?)) and\n+Brian D.Carlstrom (bdc@clark.lcs.mit.edu) supplied the NeXT ports.\n+Douglas Steel (doug@wg.icl.co.uk) provided ICL DRS6000 code.\n+Bill Janssen (janssen@parc.xerox.com) supplied the SunOS dynamic loader\n+specific code. Manuel Serrano (serrano@cornas.inria.fr) supplied linux and\n+Sony News specific code.  Al Dosser provided Alpha/OSF/1 code.  He and\n+Dave Detlefs(detlefs@src.dec.com) also provided several generic bug fixes.\n+Alistair G. Crooks(agc@uts.amdahl.com) supplied the NetBSD and 386BSD ports.\n+Jeffrey Hsu (hsu@soda.berkeley.edu) provided the FreeBSD port.\n+Brent Benson (brent@jade.ssd.csd.harris.com) ported the collector to\n+a Motorola 88K processor running CX/UX (Harris NightHawk).\n+Ari Huttunen (Ari.Huttunen@hut.fi) generalized the OS/2 port to\n+nonIBM development environments (a nontrivial task).\n+Patrick Beard (beard@cs.ucdavis.edu) provided the initial MacOS port.\n+David Chase, then at Olivetti Research, suggested several improvements.\n+Scott Schwartz (schwartz@groucho.cse.psu.edu) supplied some of the\n+code to save and print call stacks for leak detection on a SPARC.\n+Jesse Hull and John Ellis supplied the C++ interface code.\n+Zhong Shao performed much of the experimentation that led to the\n+current typed allocation facility.  (His dynamic type inference code hasn't\n+made it into the released version of the collector, yet.)\n+"}, {"sha": "16ce00889f65b7151285766bb5406cbc4ba51d37", "filename": "boehm-gc/doc/README.cords", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.cords", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.cords", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.cords?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,39 @@\n+Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+\n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+\n+Permission is hereby granted to use or copy this program\n+for any purpose,  provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is granted,\n+provided the above notices are retained, and a notice that the code was\n+modified is included with the above copyright notice.\n+\n+Please send bug reports to Hans-J. Boehm (Hans_Boehm@hp.com or\n+boehm@acm.org).\n+\n+This is a string packages that uses a tree-based representation.\n+See cord.h for a description of the functions provided.  Ec.h describes\n+\"extensible cords\", which are essentially output streams that write\n+to a cord.  These allow for efficient construction of cords without\n+requiring a bound on the size of a cord.\n+\n+de.c is a very dumb text editor that illustrates the use of cords.\n+It maintains a list of file versions.  Each version is simply a\n+cord representing the file contents.  Nonetheless, standard\n+editing operations are efficient, even on very large files.\n+(Its 3 line \"user manual\" can be obtained by invoking it without\n+arguments.  Note that ^R^N and ^R^P move the cursor by\n+almost a screen.  It does not understand tabs, which will show\n+up as highlighred \"I\"s.  Use the UNIX \"expand\" program first.)\n+To build the editor, type \"make cord/de\" in the gc directory.\n+\n+This package assumes an ANSI C compiler such as gcc.  It will\n+not compile with an old-style K&R compiler.\n+\n+Note that CORD_printf iand friends use C functions with variable numbers\n+of arguments in non-standard-conforming ways.  This code is known to\n+break on some platforms, notably PowerPC.  It should be possible to\n+build the remainder of the library (everything but cordprnt.c) on\n+any platform that supports the collector.\n+ "}, {"sha": "f4dd65676aae5472806217081aae77aa1dd52ec7", "filename": "boehm-gc/doc/README.debugging", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.debugging", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.debugging", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.debugging?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,68 @@\n+Debugging suggestions:\n+\n+****If you get a segmentation fault or bus error while debugging with a debugger:\n+If the fault occurred in GC_find_limit, or with incremental collection enabled, this is probably normal.  The collector installs handlers to take care of these.  You will not see these unless you are using a debugger.  Your debugger should allow you to continue.  It's preferable to tell the debugger to ignore SIGBUS and SIGSEGV (\"handle\" in gdb, \"ignore\" in most versions of dbx) and set a breakpoint in abort.  The collector will call abort if the signal had another cause, and there was not other handler previously installed.  I recommend debugging without incremental collection if possible.  (This applies directly to UNIX systems.  Debugging with incremental collection under win32 is worse.  See README.win32.)  \n+\n+****If you get warning messages informing you that the collector needed to allocate blacklisted blocks:\n+\n+0) Ignore these warnings while you are using GC_DEBUG.  Some of the routines mentioned below don't have debugging equivalents.  (Alternatively, write the missing routines and send them to me.)\n+\n+1) Replace allocator calls that request large blocks with calls to GC_malloc_ignore_off_page or GC_malloc_atomic_ignore_off_page.  You may want to set a breakpoint in GC_default_warn_proc to help you identify such calls.  Make sure that a pointer to somewhere near the beginning of the resulting block is maintained in a (preferably volatile) variable as long as the block is needed.\n+\n+2) If the large blocks are allocated with realloc, I suggest instead allocating them with something like the following.  Note that the realloc size increment should be fairly large (e.g. a factor of 3/2) for this to exhibit reasonable performance.  But we all know we should do that anyway.\n+\n+void * big_realloc(void *p, size_t new_size)\n+{\n+    size_t old_size = GC_size(p);\n+    void * result;\n+ \n+    if (new_size <= 10000) return(GC_realloc(p, new_size));\n+    if (new_size <= old_size) return(p);\n+    result = GC_malloc_ignore_off_page(new_size);\n+    if (result == 0) return(0);\n+    memcpy(result,p,old_size);\n+    GC_free(p);\n+    return(result);\n+}\n+\n+3) In the unlikely case that even relatively small object (<20KB) allocations are triggering these warnings, then your address space contains lots of \"bogus pointers\", i.e. values that appear to be pointers but aren't.  Usually this can be solved by using GC_malloc_atomic or the routines in gc_typed.h to allocate large pointerfree regions of bitmaps, etc.  Sometimes the problem can be solved with trivial changes of encoding in certain values.  It is possible, though not pleasant, to identify the source of the bogus pointers by setting a breakpoint in GC_add_to_black_list_stack, and looking at the value of current_p in the GC_mark_from_mark_stack frame.  Current_p contains the address of the bogus pointer.\n+\n+4) If you get only a fixed number of these warnings, you are probably only introducing a bounded leak by ignoring them.  If the data structures being allocated are intended to be permanent, then it is also safe to ignore them.  The warnings can be turned off by calling GC_set_warn_proc with a procedure that ignores these warnings (e.g. by doing absolutely nothing).\n+\n+\n+****If the collector dies in GC_malloc while trying to remove a free list element:\n+\n+1) With > 99% probability, you wrote past the end of an allocated object.  Try setting GC_DEBUG and using the debugging facilities in gc.h.\n+\n+\n+****If the heap grows too much:\n+\n+1) Consider using GC_malloc_atomic for objects containing nonpointers.  This is especially important for large arrays containg compressed data, pseudo-random numbers, and the like.  (This isn't all that likely to solve your problem, but it's a useful and easy optimization anyway, and this is a good time to try it.)   If you allocate large objects containg only one or two pointers at the beginning, either try the typed allocation primitives is gc.h, or separate out the pointerfree component.\n+2) If you are using the collector in its default mode, with interior pointer recognition enabled, consider using GC_malloc_ignore_off_page to allocate large objects.  (See gc.h and above for details.  Large means > 100K in most environments.)\n+3) GC_print_block_list() will print a list of all currently allocated heap blocks and what size objects they contain.  GC_print_hblkfreelist() will print a list of free heap blocks, and whether they are blacklisted.  GC_dump calls both of these, and also prints information about heap sections, and root segments.\n+4) Build the collector with -DKEEP_BACK_PTRS, and use the backptr.h\n+interface to determine why objects are being retained.\n+\n+\n+****If the collector appears to be losing objects:\n+\n+1) Replace all calls to GC_malloc_atomic and typed allocation by GC_malloc calls.  If this fixes the problem, gradually reinsert your optimizations.\n+2) You may also want to try the safe(r) pointer manipulation primitives in gc.h.  But those are hard to use until the preprocessor becomes available.\n+3) Try using the GC_DEBUG facilities.  This is less likely to be successful here than if the collector crashes.\n+[The rest of these are primarily for wizards.  You shouldn't need them unless you're doing something really strange, or debugging a collector port.]\n+4) Don't turn on incremental collection.  If that fixes the problem, suspect a bug in the dirty bit implementation.  Try compiling with -DCHECKSUMS to check for modified, but supposedly clean, pages.\n+5) On a SPARC, in a single-threaded environment, GC_print_callers(GC_arrays._last_stack) prints a cryptic stack trace as of the time of the last collection.  (You will need a debugger to decipher the result.)  The question to ask then is \"why should this object have been accessible at the time of the last collection?  Where was a pointer to it stored?\".  This facility should be easy to add for some other collector ports (namely if it's easy to traverse stack frames), but will be hard for others.\n+6) \"print *GC_find_header(p)\" in dbx or gdb will print the garbage collector block header information associated with the object p (e.g. object size, etc.)\n+7) GC_is_marked(p) determines whether p is the base address of a marked object.  Note that objects allocated since the last collection should not be marked, and that unmarked objects are reclaimed incrementally.  It's usually most interesting to set a breakpoint in GC_finish_collection and then to determine how much of the damaged data structure is marked at that point.\n+8) Look at the tracing facility in mark.c.  (Ignore this suggestion unless you are very familiar with collector internals.)\n+9) [From Melissa O'Neill:]\n+If you're using multiple threads, double check that all thread\n+creation goes through the GC_ wrapper functions rather than\n+calling the thread-creation functions themselves (e.g.,\n+GC_pthread_create rather than pthread_create).  The gc.h header\n+file includes suitable preprocessor definitions to accomplish\n+this mapping transparently -- the question is: are you including\n+it in all the modules that create threads?\n+\n+\n+"}, {"sha": "613bc423cb147d95368108f3fe233047d632d0d4", "filename": "boehm-gc/doc/README.dj", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.dj?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,12 @@\n+[Original version supplied by Xiaokun Zhu <xiaokun@aero.gla.ac.uk>]\n+[This version came mostly from Gary Leavens.\t\t\t  ]\n+\n+Look first at Makefile.dj, and possibly change the definitions of\n+RM and MV if you don't have rm and mv installed.\n+Then use Makefile.dj to compile the garbage collector.\n+For example, you can do:\n+\n+\tmake -f Makefile.dj test\n+\n+All the tests should work fine.\n+"}, {"sha": "4681acf63bbaf5692fe86efab9c6e91a5878567d", "filename": "boehm-gc/doc/README.environment", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.environment", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.environment", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.environment?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,41 @@\n+The garbage collector looks at a number of environment variables which are\n+the used to affect its operation.  These are examined only on Un*x-like\n+platforms.\n+\n+GC_INITIAL_HEAP_SIZE=<bytes> -\tInitial heap size in bytes.  May speed up\n+\t\t\t\tprocess start-up.\n+\n+GC_LOOP_ON_ABORT - Causes the collector abort routine to enter a tight loop.\n+\t\t   This may make it easier to debug, such a process, especially\n+\t\t   for multithreaded platforms that don't produce usable core\n+\t\t   files, or if a core file would be too large.  On some\n+\t\t   platforms, this also causes SIGSEGV to be caught and\n+\t\t   result in an infinite loop in a handler, allowing\n+\t\t   similar debugging techniques.\n+\n+GC_PRINT_STATS - Turn on as much logging as is easily feasible without\n+\t\t adding signifcant runtime overhead.  Doesn't work if\n+\t\t the collector is built with SMALL_CONFIG.  Overridden\n+\t\t by setting GC_quiet.  On by default if the collector\n+\t\t was built without -DSILENT.\n+\n+GC_PRINT_ADDRESS_MAP - Linux only.  Dump /proc/self/maps, i.e. various address\n+\t\t       maps for the process, to stderr on every GC.  Useful for\n+\t\t       mapping root addresses to source for deciphering leak\n+\t\t       reports.\n+\n+GC_NPROCS=<n> - Linux w/threads only.  Explicitly sets the number of processors\n+\t        that the GC should expect to use.  Note that setting this to 1\n+\t\twhen multiple processors are available will preserve\n+\t\tcorrectness, but may lead to really horrible performance.\n+\n+The following turn on runtime flags that are also program settable.  Checked\n+only during initialization.  We expect that they will usually be set through\n+other means, but this may help with debugging and testing:\n+\n+GC_FIND_LEAK - Turns on GC_find_leak and thus leak detection.\n+\n+GC_ALL_INTERIOR_POINTERS - Turns on GC_all_interior_pointers and thus interior\n+\t\t\t   pointer recognition.\n+\n+GC_DONT_GC - Turns off garbage collection.  Use cautiously."}, {"sha": "caa8bdd19f540afe9e9f404a38998791d5af47cc", "filename": "boehm-gc/doc/README.hp", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.hp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.hp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.hp?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,18 @@\n+Dynamic loading support requires that executables be linked with -ldld.\n+The alternative is to build the collector without defining DYNAMIC_LOADING\n+in gcconfig.h and ensuring that all garbage collectable objects are\n+accessible without considering statically allocated variables in dynamic\n+libraries.\n+\n+The collector should compile with either plain cc or cc -Ae.  Cc -Aa\n+fails to define _HPUX_SOURCE and thus will not configure the collector\n+correctly.\n+\n+Incremental collection support was reccently added, and should now work.\n+\n+In spite of past claims, pthread support under HP/UX 11 should now work.\n+Define GC_HPUX_THREADS for the build.  Incremental collection still does not\n+work in combination with it.\n+\n+The stack finding code can be confused by putenv calls before collector\n+initialization.  Call GC_malloc or GC_init before any putenv calls."}, {"sha": "efd0a26bfb8bcdd078ddf1518048d70b76594303", "filename": "boehm-gc/doc/README.linux", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.linux?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,135 @@\n+See README.alpha for Linux on DEC AXP info.\n+\n+This file applies mostly to Linux/Intel IA32.  Ports to Linux on an M68K\n+and PowerPC are also integrated.  They should behave similarly, except that\n+the PowerPC port lacks incremental GC support, and it is unknown to what\n+extent the Linux threads code is functional.  See below for M68K specific\n+notes.\n+\n+Incremental GC is supported on Intel IA32 and M68K.\n+\n+Dynamic libraries are supported on an ELF system.  A static executable\n+should be linked with the gcc option \"-Wl,-defsym,_DYNAMIC=0\".\n+\n+The collector appears to work with Linux threads.  We have seen\n+intermittent hangs in sem_wait.  So far we have been unable to reproduce\n+these unless the process was being debugged or traced.  Thus it's\n+possible that the only real issue is that the debugger loses\n+signals on rare occasions.\n+\n+The garbage collector uses SIGPWR and SIGXCPU if it is used with\n+Linux threads.  These should not be touched by the client program.\n+\n+To use threads, you need to abide by the following requirements:\n+\n+1) You need to use LinuxThreads (which are included in libc6).\n+\n+   The collector relies on some implementation details of the LinuxThreads\n+   package.  It is unlikely that this code will work on other\n+   pthread implementations (in particular it will *not* work with\n+   MIT pthreads).\n+\n+2) You must compile the collector with -DGC_LINUX_THREADS and -D_REENTRANT\n+   specified in the Makefile.\n+\n+3a) Every file that makes thread calls should define GC_LINUX_THREADS and \n+   _REENTRANT and then include gc.h.  Gc.h redefines some of the\n+   pthread primitives as macros which also provide the collector with\n+   information it requires.\n+\n+3b) A new alternative to (3a) is to build the collector and compile GC clients\n+   with -DGC_USE_LD_WRAP, and to link the final program with\n+\n+   (for ld) --wrap read --wrap dlopen --wrap pthread_create \\\n+\t    --wrap pthread_join --wrap pthread_detach \\\n+\t    --wrap pthread_sigmask --wrap sleep\n+\n+   (for gcc) -Wl,--wrap -Wl,read -Wl,--wrap -Wl,dlopen -Wl,--wrap \\\n+\t     -Wl,pthread_create -Wl,--wrap -Wl,pthread_join -Wl,--wrap \\\n+\t     -Wl,pthread_detach -Wl,--wrap -Wl,pthread_sigmask \\\n+\t     -Wl,--wrap -Wl,sleep\n+\n+   In any case, _REENTRANT should be defined during compilation.\n+\n+4) Dlopen() disables collection during its execution.  (It can't run\n+   concurrently with the collector, since the collector looks at its\n+   data structures.  It can't acquire the allocator lock, since arbitrary\n+   user startup code may run as part of dlopen().)  Under unusual\n+   conditions, this may cause unexpected heap growth.\n+\n+5) The combination of GC_LINUX_THREADS, REDIRECT_MALLOC, and incremental\n+   collection fails in seemingly random places.  This hasn't been tracked\n+   down yet, but is perhaps not completely astonishing.  The thread package\n+   uses malloc, and thus can presumably get SIGSEGVs while inside the\n+   package.  There is no real guarantee that signals are handled properly\n+   at that point.\n+\n+6) Thread local storage may not be viewed as part of the root set by the\n+   collector.  This probably depends on the linuxthreads version.  For the\n+   time being, any collectable memory referenced by thread local storage should\n+   also be referenced from elsewhere, or be allocated as uncollectable.\n+   (This is really a bug that should be fixed somehow.)\n+\n+\n+M68K LINUX:\n+(From Richard Zidlicky)\n+The bad news is that it can crash every linux-m68k kernel on a 68040,\n+so an additional test is needed somewhere on startup. I have meanwhile\n+patches to correct the problem in 68040 buserror handler but it is not\n+yet in any standard kernel.\n+\n+Here is a simple test program to detect whether the kernel has the\n+problem. It could be run as a separate check in configure or tested \n+upon startup. If it fails (return !0) than mprotect can't be used\n+on that system.\n+\n+/*\n+ * test for bug that may crash 68040 based Linux\n+ */\n+\n+#include <sys/mman.h>\n+#include <signal.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+char *membase;\n+int pagesize=4096;\n+int pageshift=12;\n+int x_taken=0;\n+\n+int sighandler(int sig)\n+{\n+   mprotect(membase,pagesize,PROT_READ|PROT_WRITE);\n+   x_taken=1;\n+}\n+\n+main()\n+{\n+  long l;\n+\n+   signal(SIGSEGV,sighandler);\n+   l=(long)mmap(NULL,pagesize,PROT_READ,MAP_PRIVATE | MAP_ANON,-1,0);\n+  if (l==-1)\n+     {\n+       perror(\"mmap/malloc\");\n+       abort();\n+     }\n+  membase=(char*)l;\n+    *(long*)(membase+sizeof(long))=123456789;\n+  if (*(long*)(membase+sizeof(long)) != 123456789 )\n+    {\n+      fprintf(stderr,\"writeback failed !\\n\");\n+      exit(1);\n+    }\n+  if (!x_taken)\n+    {\n+      fprintf(stderr,\"exception not taken !\\n\");\n+      exit(1);\n+    }\n+  fprintf(stderr,\"vmtest Ok\\n\");\n+  exit(0);\n+}\n+\n+"}, {"sha": "f5630b20a3290a25903980435838bd935878372a", "filename": "boehm-gc/doc/README.rs6000", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.rs6000?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,9 @@\n+We have so far failed to find a good way to determine the stack base.\n+It is highly recommended that GC_stackbottom be set explicitly on program\n+startup.  The supplied value sometimes causes failure under AIX 4.1, though\n+it appears to work under 3.X.  HEURISTIC2 seems to work under 4.1, but\n+involves a substantial performance penalty, and will fail if there is\n+no limit on stack size.\n+\n+There is no thread support.  (I assume recent versions of AIX provide\n+pthreads?  I no longer have access to a machine ...)"}, {"sha": "7bdb50a4ef9c5e2ebbcbb1120be435d9f07acfba", "filename": "boehm-gc/doc/README.sgi", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.sgi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.sgi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.sgi?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,41 @@\n+Performance of the incremental collector can be greatly enhanced with\n+-DNO_EXECUTE_PERMISSION.\n+\n+The collector should run with all of the -32, -n32 and -64 ABIs.  Remember to\n+define the AS macro in the Makefile to be \"as -64\", or \"as -n32\".\n+\n+If you use -DREDIRECT_MALLOC=GC_malloc with C++ code, your code should make\n+at least one explicit call to malloc instead of new to ensure that the proper\n+version of malloc is linked in.\n+\n+Sproc threads are not supported in this version, though there may exist other\n+ports.\n+\n+Pthreads support is provided.  This requires that:\n+\n+1) You compile the collector with -DGC_IRIX_THREADS specified in the Makefile.\n+\n+2) You have the latest pthreads patches installed.  \n+\n+(Though the collector makes only documented pthread calls,\n+it relies on signal/threads interactions working just right in ways\n+that are not required by the standard.  It is unlikely that this code\n+will run on other pthreads platforms.  But please tell me if it does.)\n+\n+3) Every file that makes thread calls should define IRIX_THREADS and then\n+include gc.h.  Gc.h redefines some of the pthread primitives as macros which\n+also provide the collector with information it requires.\n+\n+4) pthread_cond_wait and pthread_cond_timed_wait should be prepared for\n+premature wakeups.  (I believe the pthreads and realted standards require this\n+anyway.  Irix pthreads often terminate a wait if a signal arrives.\n+The garbage collector uses signals to stop threads.)\n+\n+5) It is expensive to stop a thread waiting in IO at the time the request is\n+initiated.  Applications with many such threads may not exhibit acceptable\n+performance with the collector.  (Increasing the heap size may help.)\n+\n+6) The collector should not be compiled with -DREDIRECT_MALLOC.  This\n+confuses some library calls made by the pthreads implementation, which\n+expect the standard malloc.\n+"}, {"sha": "6ed61dc83dce6716b2007d0fbeea23a19b6236ba", "filename": "boehm-gc/doc/README.solaris2", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.solaris2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.solaris2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.solaris2?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,62 @@\n+The collector supports both incremental collection and threads under\n+Solaris 2.  The incremental collector normally retrieves page dirty information\n+through the appropriate /proc calls.  But it can also be configured\n+(by defining MPROTECT_VDB instead of PROC_VDB in gcconfig.h) to use mprotect\n+and signals.  This may result in shorter pause times, but it is no longer\n+safe to issue arbitrary system calls that write to the heap.\n+\n+Under other UNIX versions,\n+the collector normally obtains memory through sbrk.  There is some reason\n+to expect that this is not safe if the client program also calls the system\n+malloc, or especially realloc.  The sbrk man page strongly suggests this is\n+not safe: \"Many library routines use malloc() internally, so use brk()\n+and sbrk() only when you know  that malloc() definitely will not be used by\n+any library routine.\"  This doesn't make a lot of sense to me, since there\n+seems to be no documentation as to which routines can transitively call malloc.\n+Nonetheless, under Solaris2, the collector now (since 4.12) allocates\n+memory using mmap by default.  (It defines USE_MMAP in gcconfig.h.)\n+You may want to reverse this decisions if you use -DREDIRECT_MALLOC=...\n+\n+\n+SOLARIS THREADS:\n+\n+The collector must be compiled with -DGC_SOLARIS_THREADS (thr_ functions)\n+or -DGC_SOLARIS_PTHREADS (pthread_ functions) to be thread safe.\n+It is also essential that gc.h be included in files that call thr_create,\n+thr_join, thr_suspend, thr_continue, or dlopen.  Gc.h macro defines\n+these to also do GC bookkeeping, etc.  Gc.h must be included with\n+one or both of these macros defined, otherwise\n+these replacements are not visible.\n+A collector built in this way way only be used by programs that are\n+linked with the threads library.\n+\n+In this mode, the collector contains various workarounds for older Solaris\n+bugs.  Mostly, these should not be noticeable unless you look at system\n+call traces.  However, it cannot protect a guard page at the end of\n+a thread stack.  If you know that you will only be running Solaris2.5\n+or later, it should be possible to fix this by compiling the collector\n+with -DSOLARIS23_MPROTECT_BUG_FIXED.\n+\n+Since 5.0 alpha5, dlopen disables collection temporarily,\n+unless USE_PROC_FOR_LIBRARIES is defined.  In some unlikely cases, this\n+can result in unpleasant heap growth.  But it seems better than the\n+race/deadlock issues we had before.\n+\n+If solaris_threads are used on an X86 processor with malloc redirected to\n+GC_malloc, it is necessary to call GC_thr_init explicitly before forking the\n+first thread.  (This avoids a deadlock arising from calling GC_thr_init\n+with the allocation lock held.)\n+\n+It appears that there is a problem in using gc_cpp.h in conjunction with\n+Solaris threads and Sun's C++ runtime.  Apparently the overloaded new operator\n+is invoked by some iostream initialization code before threads are correctly\n+initialized.  As a result, call to thr_self() in garbage collector\n+initialization  segfaults.  Currently the only known workaround is to not\n+invoke the garbage collector from a user defined global operator new, or to\n+have it invoke the garbage-collector's allocators only after main has started.\n+(Note that the latter requires a moderately expensive test in operator\n+delete.)\n+\n+Hans-J. Boehm\n+(The above contains my personal opinions, which are probably not shared\n+by anyone else.)"}, {"sha": "6be49667d7b8852c8b38845514ad597e08a01184", "filename": "boehm-gc/doc/README.uts", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.uts", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.uts", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.uts?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,2 @@\n+Alistair Crooks supplied the port.  He used Lexa C version 2.1.3 with\n+-Xa to compile."}, {"sha": "417281da43d4c8db715554b6937751c3ea86f163", "filename": "boehm-gc/doc/README.win32", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.win32?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,149 @@\n+The collector has at various times been compiled under Windows 95 & NT,\n+with the original Microsoft SDK, with Visual C++ 2.0, 4.0, and 6, with\n+the GNU win32 environment, with Borland 4.5, and recently with\n+Watcom C.  It is likely that some of these have been broken in the\n+meantime.  Patches are appreciated.\n+\n+It runs under both win32s and win32, but with different semantics.\n+Under win32, all writable pages outside of the heaps and stack are\n+scanned for roots.  Thus the collector sees pointers in DLL data\n+segments.  Under win32s, only the main data segment is scanned.\n+(The main data segment should always be scanned.  Under some\n+versions of win32s, other regions may also be scanned.)\n+Thus all accessible objects should be accessible from local variables\n+or variables in the main data segment.  Alternatively, other data\n+segments (e.g. in DLLs) may be registered with the collector by\n+calling GC_init() and then GC_register_root_section(a), where\n+a is the address of some variable inside the data segment.  (Duplicate\n+registrations are ignored, but not terribly quickly.)\n+\n+(There are two reasons for this.  We didn't want to see many 16:16\n+pointers.  And the VirtualQuery call has different semantics under\n+the two systems, and under different versions of win32s.)\n+\n+The collector test program \"gctest\" is linked as a GUI application,\n+but does not open any windows.  Its output appears in the file\n+\"gc.log\".  It may be started from the file manager.  The hour glass\n+cursor may appear as long as it's running.  If it is started from the\n+command line, it will usually run in the background.  Wait a few\n+minutes (a few seconds on a modern machine) before you check the output.\n+You should see either a failure indication or a \"Collector appears to\n+work\" message.\n+\n+The cord test program has not been ported (but should port\n+easily).  A toy editor (cord/de.exe) based on cords (heavyweight\n+strings represented as trees) has been ported and is included.\n+It runs fine under either win32 or win32S.  It serves as an example\n+of a true Windows application, except that it was written by a\n+nonexpert Windows programmer.  (There are some peculiarities\n+in the way files are displayed.  The <cr> is displayed explicitly\n+for standard DOS text files.  As in the UNIX version, control\n+characters are displayed explicitly, but in this case as red text.\n+This may be suboptimal for some tastes and/or sets of default\n+window colors.)\n+\n+In general -DREDIRECT_MALLOC is unlikely to work unless the\n+application is completely statically linked.\n+\n+For Microsoft development tools, rename NT_MAKEFILE as\n+MAKEFILE.  (Make sure that the CPU environment variable is defined\n+to be i386.)  In order to use the gc_cpp.h C++ interface, all\n+client code should include gc_cpp.h.\n+\n+Clients may need to define GC_NOT_DLL before including gc.h, if the\n+collector was built as a static library (as it normally is in the\n+absence of thread support).\n+\n+For GNU-win32, use the regular makefile, possibly after uncommenting\n+the line \"include Makefile.DLLs\".  The latter should be necessary only\n+if you want to package the collector as a DLL.  The GNU-win32 port is\n+believed to work only for b18, not b19, probably dues to linker changes\n+in b19.  This is probably fixable with a different definition of\n+DATASTART and DATAEND in gcconfig.h.\n+\n+For Borland tools, use BCC_MAKEFILE.  Note that\n+Borland's compiler defaults to 1 byte alignment in structures (-a1),\n+whereas Visual C++ appears to default to 8 byte alignment (/Zp8).\n+The garbage collector in its default configuration EXPECTS AT\n+LEAST 4 BYTE ALIGNMENT.  Thus the BORLAND DEFAULT MUST\n+BE OVERRIDDEN.  (In my opinion, it should usually be anyway.\n+I expect that -a1 introduces major performance penalties on a\n+486 or Pentium.)  Note that this changes structure layouts.  (As a last\n+resort, gcconfig.h can be changed to allow 1 byte alignment.  But\n+this has significant negative performance implications.)\n+The Makefile is set up to assume Borland 4.5.  If you have another\n+version, change the line near the top.  By default, it does not\n+require the assembler.  If you do have the assembler, I recommend\n+removing the -DUSE_GENERIC.\n+\n+There is some support for incremental collection.  This is\n+currently pretty simple-minded.  Pages are protected.  Protection\n+faults are caught by a handler installed at the bottom of the handler\n+stack.  This is both slow and interacts poorly with a debugger.\n+Whenever possible, I recommend adding a call to\n+GC_enable_incremental at the last possible moment, after most\n+debugging is complete.  Unlike the UNIX versions, no system\n+calls are wrapped by the collector itself.  It may be necessary\n+to wrap ReadFile calls that use a buffer in the heap, so that the\n+call does not encounter a protection fault while it's running.\n+(As usual, none of this is an issue unless GC_enable_incremental\n+is called.)\n+\n+Note that incremental collection is disabled with -DSMALL_CONFIG.\n+\n+James Clark has contributed the necessary code to support win32 threads.\n+Use NT_THREADS_MAKEFILE (a.k.a gc.mak) instead of NT_MAKEFILE\n+to build this version.  Note that this requires some files whose names\n+are more than 8 + 3 characters long.  Thus you should unpack the tar file\n+so that long file names are preserved.  To build the garbage collector\n+test with VC++ from the command line, use\n+\n+nmake /F \".\\gc.mak\" CFG=\"gctest - Win32 Release\"\n+\n+This requires that the subdirectory gctest\\Release exist.\n+The test program and DLL will reside in the Release directory.\n+\n+This version relies on the collector residing in a dll.\n+\n+This version currently supports incremental collection only if it is\n+enabled before any additional threads are created.\n+Version 4.13 attempts to fix some of the earlier problems, but there\n+may be other issues.  If you need solid support for win32 threads, you\n+might check with Geodesic Systems.  Their collector must be licensed,\n+but they have invested far more time in win32-specific issues.\n+\n+Hans\n+\n+Ivan V. Demakov's README for the Watcom port:\n+\n+The collector has been compiled with Watcom C 10.6 and 11.0.\n+It runs under win32, win32s, and even under msdos with dos4gw\n+dos-extender. It should also run under OS/2, though this isn't\n+tested. Under win32 the collector can be built either as dll\n+or as static library.\n+\n+Note that all compilations were done under Windows 95 or NT.\n+For unknown reason compiling under Windows 3.11 for NT (one\n+attempt has been made) leads to broken executables.\n+\n+Incremental collection is not supported.\n+\n+cord is not ported.\n+\n+Before compiling you may need to edit WCC_MAKEFILE to set target\n+platform, library type (dynamic or static), calling conventions, and\n+optimization options.\n+\n+To compile the collector and testing programs use the command:\n+    wmake -f WCC_MAKEFILE\n+\n+All programs using gc should be compiled with 4-byte alignment.\n+For further explanations on this see comments about Borland.\n+\n+If gc compiled as dll, the macro ``GC_DLL'' should be defined before\n+including \"gc.h\" (for example, with -DGC_DLL compiler option). It's\n+important, otherwise resulting programs will not run.\n+\n+Ivan Demakov (email: ivan@tgrad.nsk.su)\n+\n+"}, {"sha": "27e80dc15cd103b5c3ad02a2cc60972370bd2842", "filename": "boehm-gc/doc/barrett_diagram", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2Fbarrett_diagram", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2Fbarrett_diagram", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fbarrett_diagram?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,106 @@\n+This is an ASCII diagram of the data structure used to check pointer\n+validity.  It was provided by Dave Barrett <barrett@asgard.cs.colorado.edu>,\n+and should be of use to others attempting to understand the code.\n+The data structure in GC4.X is essentially the same.   -HB\n+\n+\n+\n+\n+\t\tData Structure used by GC_base in gc3.7:\n+\t\t\t      21-Apr-94\n+\t\t\t \n+\t\t\t\n+\n+\n+    63                  LOG_TOP_SZ[11]  LOG_BOTTOM_SZ[10]   LOG_HBLKSIZE[13]\n+   +------------------+----------------+------------------+------------------+\n+ p:|                  |   TL_HASH(hi)  |                  |   HBLKDISPL(p)   |\n+   +------------------+----------------+------------------+------------------+\n+    \\-----------------------HBLKPTR(p)-------------------/\n+    \\------------hi-------------------/ \n+                      \\______ ________/ \\________ _______/ \\________ _______/\n+                             V                   V                  V\n+                             |                   |                  |\n+           GC_top_index[]    |                   |                  | \n+ ---      +--------------+   |                   |                  |  \n+  ^       |              |   |                   |                  |   \n+  |       |              |   |                   |                  |   \n+ TOP      +--------------+<--+                   |                  |      \n+ _SZ   +-<|      []      | *                     |                  |     \n+(items)|  +--------------+  if 0 < bi< HBLKSIZE  |                  |    \n+  |    |  |              | then large object     |                  |    \n+  |    |  |              | starts at the bi'th   |                  |    \n+  v    |  |              | HBLK before p.        |             i    |    \n+ ---   |  +--------------+                       |          (word-  |    \n+       v                                         |         aligned) |    \n+   bi= |GET_BI(p){->hash_link}->key==hi          |                  |   \n+       v                                         |                  |    \n+       |   (bottom_index)  \\ scratch_alloc'd     |                  |    \n+       |   ( struct  bi )  / by get_index()      |                  |    \n+ ---   +->+--------------+                       |                  |    \n+  ^       |              |                       |                  |\n+  ^       |              |                       |                  |\n+ BOTTOM   |              |   ha=GET_HDR_ADDR(p)  |                  |\n+_SZ(items)+--------------+<----------------------+          +-------+\n+  |   +--<|   index[]    |                                  |         \n+  |   |   +--------------+                      GC_obj_map: v              \n+  |   |   |              |              from      / +-+-+-----+-+-+-+-+  --- \n+  v   |   |              |              GC_add   < 0| | |     | | | | |   ^  \n+ ---  |   +--------------+             _map_entry \\ +-+-+-----+-+-+-+-+   |  \n+      |   |   asc_link   |                          +-+-+-----+-+-+-+-+ MAXOBJSZ\n+      |   +--------------+                      +-->| | |  j  | | | | |  +1   \n+      |   |     key      |                      |   +-+-+-----+-+-+-+-+   |  \n+      |   +--------------+                      |   +-+-+-----+-+-+-+-+   | \n+      |   |  hash_link   |                      |   | | |     | | | | |   v \n+      |   +--------------+                      |   +-+-+-----+-+-+-+-+  ---\n+      |                                         |   |<--MAX_OFFSET--->|   \n+      |                                         |         (bytes)\n+HDR(p)| GC_find_header(p)                       |   |<--MAP_ENTRIES-->| \n+      |                           \\ from        |    =HBLKSIZE/WORDSZ   \n+      |    (hdr) (struct hblkhdr) / alloc_hdr() |    (1024 on Alpha)\n+      +-->+----------------------+              |    (8/16 bits each)\n+GET_HDR(p)| word   hb_sz (words) |              |          \n+          +----------------------+              |     \n+          | struct hblk *hb_next |              |\n+          +----------------------+              |       \n+          |mark_proc hb_mark_proc|              |\n+          +----------------------+              |\n+          | char * hb_map        |>-------------+\n+          +----------------------+           \n+          | ushort hb_obj_kind   |           \n+          +----------------------+           \n+          |   hb_last_reclaimed  |           \n+ ---      +----------------------+                \n+  ^       |                      |\n+ MARK_BITS|       hb_marks[]     | *if hdr is free, hb_sz + DISCARD_WORDS\n+_SZ(words)|                      |  is the size of a heap chunk (struct hblk)\n+  v       |                      |  of at least MININCR*HBLKSIZE bytes (below),\n+ ---      +----------------------+  otherwise, size of each object in chunk.\n+\n+Dynamic data structures above are interleaved throughout the heap in blocks of \n+size MININCR * HBLKSIZE bytes as done by gc_scratch_alloc which cannot be\n+freed; free lists are used (e.g. alloc_hdr).  HBLKs's below are collected.\n+\n+\t      (struct hblk)      \n+ ---      +----------------------+ < HBLKSIZE ---         ---          DISCARD_\n+  ^       |garbage[DISCARD_WORDS]|   aligned   ^           ^ HDR_BYTES WORDS\n+  |       |                      |             |           v (bytes)   (words)\n+  |       +-----hb_body----------+ < WORDSZ    |          ---   ---   \n+  |       |                      |   aligned   |           ^     ^\n+  |       |      Object 0        |             |           hb_sz |\n+  |       |                      |           i |(word-    (words)|\n+  |       |                      |      (bytes)|aligned)   v     |\n+  |       + - - - - - - - - - - -+ ---         |          ---    |\n+  |       |                      |  ^          |           ^     |\n+  n *     |                      |  j (words)  |          hb_sz BODY_SZ \n+ HBLKSIZE |      Object 1        |  v          v           |   (words)\n+ (bytes)  |                      |---------------          v   MAX_OFFSET\n+  |       + - - - - - - - - - - -+                        ---  (bytes)\n+  |       |                      | !All_INTERIOR_PTRS      ^     |\n+  |       |                      | sets j only for       hb_sz   |\n+  |       |      Object N        | valid object offsets.   |     |\n+  v       |                      | All objects WORDSZ      v     v\n+ ---      +----------------------+ aligned.               ---   ---\n+\n+DISCARD_WORDS is normally zero.  Indeed the collector has not been tested\n+with another value in ages."}, {"sha": "5409e7065502e877616da445048632efbb23be78", "filename": "boehm-gc/doc/gc.man", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2Fgc.man", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fdoc%2Fgc.man", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgc.man?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,80 @@\n+.TH GC_MALLOC 1L \"12 February 1996\"\n+.SH NAME\n+GC_malloc, GC_malloc_atomic, GC_free, GC_realloc, GC_enable_incremental, GC_register_finalizer, GC_malloc_ignore_off_page, GC_malloc_atomic_ignore_off_page, GC_set_warn_proc \\- Garbage collecting malloc replacement\n+.SH SYNOPSIS\n+#include \"gc.h\"\n+.br\n+# define malloc(n) GC_malloc(n)\n+.br\n+... malloc(...) ...\n+.br\n+.sp\n+cc ... gc.a\n+.LP\n+.SH DESCRIPTION\n+.I GC_malloc\n+and\n+.I GC_free\n+are plug-in replacements for standard malloc and free.  However,\n+.I\n+GC_malloc\n+will attempt to reclaim inaccessible space automatically by invoking a conservative garbage collector at appropriate points.  The collector traverses all data structures accessible by following pointers from the machines registers, stack(s), data, and bss segments.  Inaccessible structures will be reclaimed.  A machine word is considered to be a valid pointer if it is an address inside an object allocated by\n+.I\n+GC_malloc\n+or friends.\n+.LP\n+See the documentation in the include file gc_cpp.h for an alternate, C++ specific interface to the garbage collector.\n+.LP\n+Unlike the standard implementations of malloc,\n+.I\n+GC_malloc\n+clears the newly allocated storage.\n+.I\n+GC_malloc_atomic\n+does not.  Furthermore, it informs the collector that the resulting object will never contain any pointers, and should therefore not be scanned by the collector.\n+.LP\n+.I\n+GC_free\n+can be used to deallocate objects, but its use is optional, and generally discouraged.\n+.I\n+GC_realloc\n+has the standard realloc semantics.  It preserves pointer-free-ness.\n+.I\n+GC_register_finalizer\n+allows for registration of functions that are invoked when an object becomes inaccessible.\n+.LP\n+The garbage collector tries to avoid allocating memory at locations that already appear to be referenced before allocation.  (Such apparent ``pointers'' are usually large integers and the like that just happen to look like an address.)  This may make it hard to allocate very large objects.  An attempt to do so may generate a warning.\n+.LP\n+.I\n+GC_malloc_ignore_off_page\n+and\n+.I\n+GC_malloc_atomic_ignore_off_page\n+inform the collector that the client code will always maintain a pointer to near the beginning of the object (within the first 512 bytes), and that pointers beyond that can be ignored by the collector.  This makes it much easier for the collector to place large objects.  These are recommended for large object allocation.  (Objects expected to be larger than about 100KBytes should be allocated this way.)\n+.LP\n+It is also possible to use the collector to find storage leaks in programs destined to be run with standard malloc/free.  The collector can be compiled for thread-safe operation.  Unlike standard malloc, it is safe to call malloc after a previous malloc call was interrupted by a signal, provided the original malloc call is not resumed.\n+.LP\n+The collector may, on rare occasion produce warning messages.  On UNIX machines these appear on stderr.  Warning messages can be filtered, redirected, or ignored with\n+.I\n+GC_set_warn_proc.\n+This is recommended for production code.  See gc.h for details.\n+.LP\n+Debugging versions of many of the above routines are provided as macros.  Their names are identical to the above, but consist of all capital letters.  If GC_DEBUG is defined before gc.h is included, these routines do additional checking, and allow the leak detecting version of the collector to produce slightly more useful output.  Without GC_DEBUG defined, they behave exactly like the lower-case versions.\n+.LP\n+On some machines, collection will be performed incrementally after a call to\n+.I\n+GC_enable_incremental.\n+This may temporarily write protect pages in the heap.  See the README file for more information on how this interacts with system calls that write to the heap.\n+.LP\n+Other facilities not discussed here include limited facilities to support incremental collection on machines without appropriate VM support, provisions for providing more explicit object layout information to the garbage collector, more direct support for ``weak'' pointers, support for ``abortable'' garbage collections during idle time, etc.\n+.LP\n+.SH \"SEE ALSO\"\n+The README and gc.h files in the distribution.  More detailed definitions of the functions exported by the collector are given there.  (The above list is not complete.)\n+.LP\n+Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative Environment\",\n+\\fISoftware Practice & Experience\\fP, September 1988, pp. 807-820.\n+.LP\n+The malloc(3) man page.\n+.LP\n+.SH AUTHOR\n+Hans-J. Boehm (boehm@parc.xerox.com).  Some of the code was written by others, most notably Alan Demers."}, {"sha": "f6bd95e59a5f5b62d8ebf5ba3eb9811160ebff09", "filename": "boehm-gc/gc_cpp.cpp", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fgc_cpp.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fgc_cpp.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.cpp?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,2 @@\n+// Visual C++ seems to prefer a .cpp extension to .cc\n+#include \"gc_cpp.cc\""}, {"sha": "943c4b0c3eb9afa0741e4ed931b55b591cb9e629", "filename": "boehm-gc/gc_dlopen.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fgc_dlopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fgc_dlopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_dlopen.c?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ * Original author: Bill Janssen\n+ * Heavily modified by Hans Boehm and others\n+ */\n+\n+/*\n+ * This used to be in dyn_load.c.  It was extracted into a separate file\n+ * to avoid having to link against libdl.{a,so} if the client doesn't call\n+ * dlopen.  -HB\n+ */\n+\n+#include \"private/gc_priv.h\"\n+\n+# if defined(LINUX_THREADS) || defined(SOLARIS_THREADS) \\\n+     || defined(HPUX_THREADS) || defined(IRIX_THREADS)\n+\n+# if defined(dlopen) && !defined(GC_USE_LD_WRAP)\n+    /* To support various threads pkgs, gc.h interposes on dlopen by     */\n+    /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n+    /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n+    /* real system dlopen() in their implementation. We first remove     */\n+    /* gc.h's dlopen definition and restore it later, after GC_dlopen(). */\n+#   undef dlopen\n+# endif\n+\n+  /* Make sure we're not in the middle of a collection, and make\t*/\n+  /* sure we don't start any.\tReturns previous value of GC_dont_gc.\t*/\n+  /* This is invoked prior to a dlopen call to avoid synchronization\t*/\n+  /* issues.  We can't just acquire the allocation lock, since startup \t*/\n+  /* code in dlopen may try to allocate.\t\t\t\t*/\n+  /* This solution risks heap growth in the presence of many dlopen\t*/\n+  /* calls in either a multithreaded environment, or if the library\t*/\n+  /* initialization code allocates substantial amounts of GC'ed memory.\t*/\n+  /* But I don't know of a better solution.\t\t\t\t*/\n+  /* This can still deadlock if the client explicitly starts a GC \t*/\n+  /* during the dlopen.  He shouldn't do that.\t\t\t\t*/\n+  static GC_bool disable_gc_for_dlopen()\n+  {\n+    GC_bool result;\n+    LOCK();\n+    result = GC_dont_gc;\n+    while (GC_incremental && GC_collection_in_progress()) {\n+\tGC_collect_a_little_inner(1000);\n+    }\n+    GC_dont_gc = TRUE;\n+    UNLOCK();\n+    return(result);\n+  }\n+\n+  /* Redefine dlopen to guarantee mutual exclusion with\t*/\n+  /* GC_register_dynamic_libraries.\t\t\t*/\n+  /* Should probably happen for other operating\tsystems, too. */\n+\n+#include <dlfcn.h>\n+\n+#ifdef GC_USE_LD_WRAP\n+  void * __wrap_dlopen(const char *path, int mode)\n+#else\n+  void * GC_dlopen(path, mode)\n+  GC_CONST char * path;\n+  int mode;\n+#endif\n+{\n+    void * result;\n+    GC_bool dont_gc_save;\n+    \n+#   ifndef USE_PROC_FOR_LIBRARIES\n+      dont_gc_save = disable_gc_for_dlopen();\n+#   endif\n+#   ifdef GC_USE_LD_WRAP\n+      result = (void *)__real_dlopen(path, mode);\n+#   else\n+      result = dlopen(path, mode);\n+#   endif\n+#   ifndef USE_PROC_FOR_LIBRARIES\n+      GC_dont_gc = dont_gc_save;\n+#   endif\n+    return(result);\n+}\n+# endif  /* LINUX_THREADS || SOLARIS_THREADS || ... */\n+\n+\n+"}, {"sha": "9e975c8c832246808e7ad39e622c38e2eaa95dee", "filename": "boehm-gc/include/gc_amiga_redirects.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_amiga_redirects.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_amiga_redirects.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_amiga_redirects.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,30 @@\n+#ifndef GC_AMIGA_REDIRECTS_H\n+\n+# define GC_AMIGA_REDIRECTS_H\n+\n+# if ( defined(_AMIGA) && !defined(GC_AMIGA_MAKINGLIB) )\n+    extern void *GC_amiga_realloc(void *old_object,size_t new_size_in_bytes);\n+#   define GC_realloc(a,b) GC_amiga_realloc(a,b)\n+    extern void GC_amiga_set_toany(void (*func)(void));\n+    extern int GC_amiga_free_space_divisor_inc;\n+    extern void *(*GC_amiga_allocwrapper_do) \\\n+\t(size_t size,void *(*AllocFunction)(size_t size2));\n+#   define GC_malloc(a) \\\n+\t(*GC_amiga_allocwrapper_do)(a,GC_malloc)\n+#   define GC_malloc_atomic(a) \\\n+\t(*GC_amiga_allocwrapper_do)(a,GC_malloc_atomic)\n+#   define GC_malloc_uncollectable(a) \\\n+\t(*GC_amiga_allocwrapper_do)(a,GC_malloc_uncollectable)\n+#   define GC_malloc_stubborn(a) \\\n+\t(*GC_amiga_allocwrapper_do)(a,GC_malloc_stubborn)\n+#   define GC_malloc_atomic_uncollectable(a) \\\n+\t(*GC_amiga_allocwrapper_do)(a,GC_malloc_atomic_uncollectable)\n+#   define GC_malloc_ignore_off_page(a) \\\n+\t(*GC_amiga_allocwrapper_do)(a,GC_malloc_ignore_off_page)\n+#   define GC_malloc_atomic_ignore_off_page(a) \\\n+\t(*GC_amiga_allocwrapper_do)(a,GC_malloc_atomic_ignore_off_page)\n+# endif /* _AMIGA && !GC_AMIGA_MAKINGLIB */\n+\n+#endif /* GC_AMIGA_REDIRECTS_H */\n+\n+"}, {"sha": "5899496e0fe59db1065ca13d3b681abffdba8499", "filename": "boehm-gc/include/gc_backptr.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_backptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_backptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_backptr.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,65 @@\n+/*\n+ * This is a simple API to implement pointer back tracing, i.e.\n+ * to answer questions such as \"who is pointing to this\" or\n+ * \"why is this object being retained by the collector\"\n+ *\n+ * This API assumes that we have an ANSI C compiler.\n+ *\n+ * Most of these calls yield useful information on only after\n+ * a garbage collection.  Usually the client will first force\n+ * a full collection and then gather information, preferably\n+ * before much intervening allocation.\n+ *\n+ * The implementation of the interface is only about 99.9999%\n+ * correct.  It is intended to be good enough for profiling,\n+ * but is not intended to be used with production code.\n+ *\n+ * Results are likely to be much more useful if all allocation is\n+ * accomplished through the debugging allocators.\n+ *\n+ * The implementation idea is due to A. Demers.\n+ */\n+\n+#ifndef GC_BACKPTR_H\n+#define GC_BACKPTR_H\n+/* Store information about the object referencing dest in *base_p     */\n+/* and *offset_p.                                                     */\n+/* If multiple objects or roots point to dest, the one reported\t      */\n+/* will be the last on used by the garbage collector to trace the     */\n+/* object.\t\t\t\t\t\t\t      */\n+/*   source is root ==> *base_p = address, *offset_p = 0\t      */\n+/*   source is heap object ==> *base_p != 0, *offset_p = offset       */\n+/*   Returns 1 on success, 0 if source couldn't be determined.        */\n+/* Dest can be any address within a heap object.                      */\n+typedef enum {  GC_UNREFERENCED, /* No reference info available.\t*/\n+\t\tGC_NO_SPACE,\t/* Dest not allocated with debug alloc  */\n+\t\tGC_REFD_FROM_ROOT, /* Referenced directly by root *base_p */\n+\t\tGC_REFD_FROM_REG,  /* Referenced from a register, i.e.\t*/\n+\t\t\t\t   /* a root without an address.\t*/\n+\t\tGC_REFD_FROM_HEAP, /* Referenced from another heap obj. */\n+\t\tGC_FINALIZER_REFD /* Finalizable and hence accessible.  */\n+} GC_ref_kind;\n+\n+GC_ref_kind GC_get_back_ptr_info(void *dest, void **base_p, size_t *offset_p);\n+\n+/* Generate a random heap address.            */\n+/* The resulting address is in the heap, but  */\n+/* not necessarily inside a valid object.     */\n+void * GC_generate_random_heap_address(void);\n+\n+/* Generate a random address inside a valid marked heap object. */\n+void * GC_generate_random_valid_address(void);\n+\n+/* Force a garbage collection and generate a backtrace from a */\n+/* random heap address.                                       */\n+/* This uses the GC logging mechanism (GC_printf) to produce  */\n+/* output.  It can often be called from a debugger.  The      */\n+/* source in dbg_mlc.c also serves as a sample client.\t      */\n+void GC_generate_random_backtrace(void);\n+\n+/* Print a backtrace from a specific address.  Used by the \t*/\n+/* above.  The client should call GC_gcollect() immediately\t*/\n+/* before invocation.\t\t\t\t\t\t*/\n+void GC_print_backtrace(void *);\n+\n+#endif /* GC_BACKPTR_H */"}, {"sha": "1e58730cfe811152892b83040b410a3157e68084", "filename": "boehm-gc/include/gc_local_alloc.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_local_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_local_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_local_alloc.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,85 @@\n+/* \n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/*\n+ * Interface for thread local allocation.  Memory obtained\n+ * this way can be used by all threads, as though it were obtained\n+ * from an allocator like GC_malloc.  The difference is that GC_local_malloc\n+ * counts the number of allocations of a given size from the current thread,\n+ * and uses GC_malloc_many to perform the allocations once a threashold\n+ * is exceeded.  Thus far less synchronization may be needed.\n+ * Allocation of known large objects should not use this interface.\n+ * This interface is designed primarily for fast allocation of small\n+ * objects on multiprocessors, e.g. for a JVM running on an MP server.\n+ *\n+ * If this file is included with GC_GCJ_SUPPORT defined, GCJ-style\n+ * bitmap allocation primitives will also be included.\n+ *\n+ * If this file is included with GC_REDIRECT_TO_LOCAL defined, then\n+ * GC_MALLOC, GC_MALLOC_ATOMIC, and possibly GC_GCJ_MALLOC will\n+ * be redefined to use the thread local allocatoor.\n+ *\n+ * The interface is available only if the collector is built with\n+ * -DTHREAD_LOCAL_ALLOC, which is currently supported only on Linux.\n+ *\n+ * The debugging allocators use standard, not thread-local allocation.\n+ */\n+\n+#ifndef GC_LOCAL_ALLOC_H\n+#define GC_LOCAL_ALLOC_H\n+\n+#ifndef _GC_H\n+#   include \"gc.h\"\n+#endif\n+\n+#if defined(GC_GCJ_SUPPORT) && !defined(GC_GCJ_H)\n+#   include \"gc_gcj.h\"\n+#endif\n+\n+/* We assume ANSI C for this interface.\t*/\n+\n+GC_PTR GC_local_malloc(size_t bytes);\n+\n+GC_PTR GC_local_malloc_atomic(size_t bytes);\n+\n+#if defined(GC_GCJ_SUPPORT)\n+  GC_PTR GC_local_gcj_malloc(size_t bytes,\n+\t\t\t     void * ptr_to_struct_containing_descr);\n+#endif\n+\n+# ifdef GC_DEBUG\n+#   define GC_LOCAL_MALLOC(s) GC_debug_malloc(s,GC_EXTRAS)\n+#   define GC_LOCAL_MALLOC_ATOMIC(s) GC_debug_malloc_atomic(s,GC_EXTRAS)\n+#   ifdef GC_GCJ_SUPPORT\n+#\tdefine GC_LOCAL_GCJ_MALLOC(s,d) GC_debug_gcj_malloc(s,d,GC_EXTRAS)\n+#   endif\n+# else\n+#   define GC_LOCAL_MALLOC(s) GC_local_malloc(s)\n+#   define GC_LOCAL_MALLOC_ATOMIC(s) GC_local_malloc_atomic(s)\n+#   ifdef GC_GCJ_SUPPORT\n+#\tdefine GC_LOCAL_GCJ_MALLOC(s,d) GC_local_gcj_malloc(s,d)\n+#   endif\n+# endif\n+\n+# ifdef GC_REDIRECT_TO_LOCAL\n+#   undef GC_MALLOC\n+#   define GC_MALLOC(s) GC_LOCAL_MALLOC(s)\n+#   undef GC_MALLOC_ATOMIC\n+#   define GC_MALLOC_ATOMIC(s) GC_LOCAL_MALLOC_ATOMIC(s)\n+#   ifdef GC_GCJ_SUPPORT\n+#\tundef GC_GCJ_MALLOC\n+# \tdefine GC_GCJ_MALLOC(s,d) GC_LOCAL_GCJ_MALLOC(s,d)\n+#   endif\n+# endif\n+\n+#endif /* GC_LOCAL_ALLOC_H */"}, {"sha": "0856d16fdaeb67f7bf5d6acb6878f6b51a65ae79", "filename": "boehm-gc/include/gc_mark.h", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_mark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_mark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_mark.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 2001 by Hewlett-Packard Company. All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ */\n+\n+/*\n+ * This contains interfaces to the GC marker that are likely to be useful to\n+ * clients that provide detailed heap layout information to the collector.\n+ * This interface should not be used by normal C or C++ clients.\n+ * It will be useful to runtimes for other languages.\n+ * \n+ * Note that this file is not \"namespace-clean\", i.e. it introduces names\n+ * not prefixed with GC_, which may collide with the client's names.  It\n+ * should be included only in those few places that directly provide\n+ * information to the collector.\n+ */\n+#ifndef GC_MARK_H\n+# define GC_MARK_H\n+\n+# ifndef GC_H\n+#   include \"gc.h\"\n+# endif\n+\n+/* A client supplied mark procedure.  Returns new mark stack pointer.\t*/\n+/* Primary effect should be to push new entries on the mark stack.\t*/\n+/* Mark stack pointer values are passed and returned explicitly.\t*/\n+/* Global variables decribing mark stack are not necessarily valid.\t*/\n+/* (This usually saves a few cycles by keeping things in registers.)\t*/\n+/* Assumed to scan about GC_PROC_BYTES on average.  If it needs to do\t*/\n+/* much more work than that, it should do it in smaller pieces by\t*/\n+/* pushing itself back on the mark stack.\t\t\t\t*/\n+/* Note that it should always do some work (defined as marking some\t*/\n+/* objects) before pushing more than one entry on the mark stack.\t*/\n+/* This is required to ensure termination in the event of mark stack\t*/\n+/* overflows.\t\t\t\t\t\t\t\t*/\n+/* This procedure is always called with at least one empty entry on the */\n+/* mark stack.\t\t\t\t\t\t\t\t*/\n+/* Currently we require that mark procedures look for pointers in a\t*/\n+/* subset of the places the conservative marker would.  It must be safe\t*/\n+/* to invoke the normal mark procedure instead.\t\t\t\t*/\n+/* WARNING: Such a mark procedure may be invoked on an unused object    */\n+/* residing on a free list.  Such objects are cleared, except for a\t*/\n+/* free list link field in the first word.  Thus mark procedures may\t*/\n+/* not count on the presence of a type descriptor, and must handle this\t*/\n+/* case correctly somehow.\t\t\t\t\t\t*/\n+# define GC_PROC_BYTES 100\n+struct GC_ms_entry;\n+typedef struct GC_ms_entry * (*GC_mark_proc) GC_PROTO((\n+\t\tGC_word * addr, struct GC_ms_entry * mark_stack_ptr,\n+\t\tstruct GC_ms_entry * mark_stack_limit, GC_word env));\n+\n+# define GC_LOG_MAX_MARK_PROCS 6\n+# define GC_MAX_MARK_PROCS (1 << GC_LOG_MAX_MARK_PROCS)\n+\n+/* In a few cases it's necessary to assign statically known indices to\t*/\n+/* certain mark procs.  Thus we reserve a few for well known clients.\t*/\n+/* (This is necessary if mark descriptors are compiler generated.)\t*/\n+#define GC_RESERVED_MARK_PROCS 8\n+#   define GC_GCJ_RESERVED_MARK_PROC_INDEX 0\n+\n+/* Object descriptors on mark stack or in objects.  Low order two\t*/\n+/* bits are tags distinguishing among the following 4 possibilities\t*/\n+/* for the high order 30 bits.\t\t\t\t\t\t*/\n+#define GC_DS_TAG_BITS 2\n+#define GC_DS_TAGS   ((1 << GC_DS_TAG_BITS) - 1)\n+#define GC_DS_LENGTH 0\t/* The entire word is a length in bytes that\t*/\n+\t\t\t/* must be a multiple of 4.\t\t\t*/\n+#define GC_DS_BITMAP 1\t/* 30 (62) bits are a bitmap describing pointer\t*/\n+\t\t\t/* fields.  The msb is 1 iff the first word\t*/\n+\t\t\t/* is a pointer.\t\t\t\t*/\n+\t\t\t/* (This unconventional ordering sometimes\t*/\n+\t\t\t/* makes the marker slightly faster.)\t\t*/\n+\t\t\t/* Zeroes indicate definite nonpointers.  Ones\t*/\n+\t\t\t/* indicate possible pointers.\t\t\t*/\n+\t\t\t/* Only usable if pointers are word aligned.\t*/\n+#define GC_DS_PROC   2\n+\t\t\t/* The objects referenced by this object can be */\n+\t\t\t/* pushed on the mark stack by invoking\t\t*/\n+\t\t\t/* PROC(descr).  ENV(descr) is passed as the\t*/\n+\t\t\t/* last argument.\t\t\t\t*/\n+#   define GC_MAKE_PROC(proc_index, env) \\\n+\t    (((((env) << GC_LOG_MAX_MARK_PROCS) \\\n+\t       | (proc_index)) << GC_DS_TAG_BITS) | GC_DS_PROC)\n+#define GC_DS_PER_OBJECT 3  /* The real descriptor is at the\t\t*/\n+\t\t\t/* byte displacement from the beginning of the\t*/\n+\t\t\t/* object given by descr & ~DS_TAGS\t\t*/\n+\t\t\t/* If the descriptor is negative, the real\t*/\n+\t\t\t/* descriptor is at (*<object_start>) -\t\t*/\n+\t\t\t/* (descr & ~DS_TAGS) - GC_INDIR_PER_OBJ_BIAS\t*/\n+\t\t\t/* The latter alternative can be used if each\t*/\n+\t\t\t/* object contains a type descriptor in the\t*/\n+\t\t\t/* first word.\t\t\t\t\t*/\n+\t\t\t/* Note that in multithreaded environments\t*/\n+\t\t\t/* per object descriptors maust be located in\t*/\n+\t\t\t/* either the first two or last two words of\t*/\n+\t\t\t/* the object, since only those are guaranteed\t*/\n+\t\t\t/* to be cleared while the allocation lock is\t*/\n+\t\t\t/* held.\t\t\t\t\t*/\n+#define GC_INDIR_PER_OBJ_BIAS 0x10\n+\t\t\t\n+extern GC_PTR GC_least_plausible_heap_addr;\n+extern GC_PTR GC_greatest_plausible_heap_addr;\n+\t\t\t/* Bounds on the heap.  Guaranteed valid\t*/\n+\t\t\t/* Likely to include future heap expansion.\t*/\n+\n+/* Handle nested references in a custom mark procedure.\t\t\t*/\n+/* Check if obj is a valid object. If so, ensure that it is marked.\t*/\n+/* If it was not previously marked, push its contents onto the mark \t*/\n+/* stack for future scanning.  The object will then be scanned using\t*/\n+/* its mark descriptor.  \t\t\t\t\t\t*/\n+/* Returns the new mark stack pointer.\t\t\t\t\t*/\n+/* Handles mark stack overflows correctly.\t\t\t\t*/\n+/* Since this marks first, it makes progress even if there are mark\t*/\n+/* stack overflows.\t\t\t\t\t\t\t*/\n+/* Src is the address of the pointer to obj, which is used only\t\t*/\n+/* for back pointer-based heap debugging.\t\t\t\t*/\n+/* It is strongly recommended that most objects be handled without mark\t*/\n+/* procedures, e.g. with bitmap descriptors, and that mark procedures\t*/\n+/* be reserved for exceptional cases.  That will ensure that \t\t*/\n+/* performance of this call is not extremely performance critical.\t*/\n+/* (Otherwise we would need to inline GC_mark_and_push completely,\t*/\n+/* which would tie the client code to a fixed colllector version.)\t*/\n+struct GC_ms_entry *GC_mark_and_push\n+\t\tGC_PROTO((GC_PTR obj,\n+\t\t\t  struct GC_ms_entry * mark_stack_ptr,\n+\t\t          struct GC_ms_entry * mark_stack_limit, GC_PTR *src));\n+\n+#define GC_MARK_AND_PUSH(obj, msp, lim, src) \\\n+\t(((GC_word)obj >= (GC_word)GC_least_plausible_heap_addr && \\\n+\t  (GC_word)obj <= (GC_word)GC_greatest_plausible_heap_addr)? \\\n+\t  GC_mark_and_push(obj, msp, lim, src) : \\\n+\t  msp)\n+\n+#endif  /* GC_MARK_H */\n+"}, {"sha": "ac254a86726ea067736aaec03410c8bf165c710c", "filename": "boehm-gc/include/gc_pthread_redirects.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_pthread_redirects.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,69 @@\n+/* Our pthread support normally needs to intercept a number of thread\t*/\n+/* calls.  We arrange to do that here, if appropriate.\t\t\t*/\n+\n+#ifndef GC_PTHREAD_REDIRECTS_H\n+\n+#define GC_PTHREAD_REDIRECTS_H\n+\n+#if defined(GC_SOLARIS_THREADS)\n+/* We need to intercept calls to many of the threads primitives, so \t*/\n+/* that we can locate thread stacks and stop the world.\t\t\t*/\n+/* Note also that the collector cannot see thread specific data.\t*/\n+/* Thread specific data should generally consist of pointers to\t\t*/\n+/* uncollectable objects (allocated with GC_malloc_uncollectable,\t*/\n+/* not the system malloc), which are deallocated using the destructor\t*/\n+/* facility in thr_keycreate.  Alternatively, keep a redundant pointer\t*/\n+/* to thread specific data on the thread stack.\t\t\t        */\n+# include <thread.h>\n+  int GC_thr_create(void *stack_base, size_t stack_size,\n+                    void *(*start_routine)(void *), void *arg, long flags,\n+                    thread_t *new_thread);\n+  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n+  int GC_thr_suspend(thread_t target_thread);\n+  int GC_thr_continue(thread_t target_thread);\n+  void * GC_dlopen(const char *path, int mode);\n+# define thr_create GC_thr_create\n+# define thr_join GC_thr_join\n+# define thr_suspend GC_thr_suspend\n+# define thr_continue GC_thr_continue\n+#endif /* GC_SOLARIS_THREADS */\n+\n+#if defined(GC_SOLARIS_PTHREADS)\n+# include <pthread.h>\n+# include <signal.h>\n+  extern int GC_pthread_create(pthread_t *new_thread,\n+    \t\t\t         const pthread_attr_t *attr,\n+          \t\t\t void * (*thread_execp)(void *), void *arg);\n+  extern int GC_pthread_join(pthread_t wait_for, void **status);\n+# define pthread_join GC_pthread_join\n+# define pthread_create GC_pthread_create\n+#endif\n+\n+#if defined(GC_SOLARIS_PTHREADS) || defined(GC_SOLARIS_THREADS)\n+# define dlopen GC_dlopen\n+#endif /* SOLARIS_THREADS || SOLARIS_PTHREADS */\n+\n+\n+#if !defined(GC_USE_LD_WRAP) && \\\n+    (defined(GC_IRIX_THREADS) || defined(GC_LINUX_THREADS) \\\n+     || defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS))\n+/* We treat these similarly. */\n+# include <pthread.h>\n+# include <signal.h>\n+\n+  int GC_pthread_create(pthread_t *new_thread,\n+                        const pthread_attr_t *attr,\n+\t\t        void *(*start_routine)(void *), void *arg);\n+  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n+  int GC_pthread_join(pthread_t thread, void **retval);\n+  int GC_pthread_detach(pthread_t thread);\n+\n+# define pthread_create GC_pthread_create\n+# define pthread_sigmask GC_pthread_sigmask\n+# define pthread_join GC_pthread_join\n+# define pthread_detach GC_pthread_detach\n+# define dlopen GC_dlopen\n+\n+#endif /* GC_xxxxx_THREADS */\n+\n+#endif /* GC_PTHREAD_REDIRECTS_H */"}, {"sha": "1ee814db19bef695e9cbc19136386c30850cf2bc", "filename": "boehm-gc/include/private/dbg_mlc.h", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,132 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/*\n+ * This is mostly an internal header file.  Typical clients should\n+ * not use it.  Clients that define their own object kinds with\n+ * debugging allocators will probably want to include this, however.\n+ * No attempt is made to keep the namespace clean.  This should not be\n+ * included from header filrd that are frequently included by clients.\n+ */\n+\n+#ifndef _DBG_MLC_H\n+\n+#define _DBG_MLC_H\n+\n+# define I_HIDE_POINTERS\n+# include \"gc_priv.h\"\n+# ifdef KEEP_BACK_PTRS\n+#   include \"gc_backptr.h\"\n+# endif\n+\n+# define START_FLAG ((word)0xfedcedcb)\n+# define END_FLAG ((word)0xbcdecdef)\n+\t/* Stored both one past the end of user object, and one before\t*/\n+\t/* the end of the object as seen by the allocator.\t\t*/\n+\n+\n+/* Object header */\n+typedef struct {\n+#   ifdef KEEP_BACK_PTRS\n+\tGC_hidden_pointer oh_back_ptr;\n+\t    /* We make sure that we only store even valued\t*/\n+\t    /* pointers here, so that the hidden version has\t*/\n+\t    /* the least significant bit set.  We never\t\t*/\n+\t    /* overwrite a value with the least significant\t*/\n+\t    /* bit clear, thus ensuring that we never overwrite\t*/\n+\t    /* a free list link field.\t\t\t\t*/\n+\t    /* The following are special back pointer values.\t*/\n+\t    /* Note that the \"hidden\" (i.e. bitwise \t\t*/\n+\t    /* complemented version) of these is actually \t*/\n+\t    /* stored.\t\t\t\t\t\t*/\n+#\tdefine NOT_MARKED (ptr_t)(0)\n+#\tdefine MARKED_FOR_FINALIZATION (ptr_t)(2)\n+\t    /* Object was marked because it is finalizable.\t*/\n+#\tdefine MARKED_FROM_REGISTER (ptr_t)(4)\n+\t    /* Object was marked from a rgister.  Hence the\t*/\n+\t    /* source of the reference doesn't have an address.\t*/\n+#       if ALIGNMENT == 1\n+\t  /* Fudge back pointer to be even.  */\n+#\t  define HIDE_BACK_PTR(p) HIDE_POINTER(~1 & (GC_word)(p))\n+#\telse\n+#\t  define HIDE_BACK_PTR(p) HIDE_POINTER(p)\n+#\tendif\n+#\tifdef ALIGN_DOUBLE\n+\t  word oh_dummy;\n+#\tendif\n+#   endif\n+    char * oh_string;\t\t/* object descriptor string\t*/\n+    word oh_int;\t\t/* object descriptor integers\t*/\n+#   ifdef NEED_CALLINFO\n+      struct callinfo oh_ci[NFRAMES];\n+#   endif\n+#   ifndef SHORT_DBG_HDRS\n+      word oh_sz;\t\t\t/* Original malloc arg.\t\t*/\n+      word oh_sf;\t\t\t/* start flag */\n+#   endif /* SHORT_DBG_HDRS */\n+} oh;\n+/* The size of the above structure is assumed not to dealign things,\t*/\n+/* and to be a multiple of the word length.\t\t\t\t*/\n+\n+#define DEBUG_BYTES (sizeof (oh) + sizeof (word))\n+#define USR_PTR_FROM_BASE(p) ((ptr_t)(p) + sizeof(oh))\n+\n+/* There is no reason to ever add a byte at the end explicitly, since we */\n+/* already add a guard word.\t\t\t\t\t\t */\n+#undef ROUNDED_UP_WORDS\n+#define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)\n+\n+#ifdef SAVE_CALL_CHAIN\n+#   define ADD_CALL_CHAIN(base, ra) GC_save_callers(((oh *)(base)) -> oh_ci)\n+#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n+#else\n+# ifdef GC_ADD_CALLER\n+#   define ADD_CALL_CHAIN(base, ra) ((oh *)(base)) -> oh_ci[0].ci_pc = (ra)\n+#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n+# else\n+#   define ADD_CALL_CHAIN(base, ra)\n+#   define PRINT_CALL_CHAIN(base)\n+# endif\n+#endif\n+\n+# ifdef GC_ADD_CALLER\n+#   define OPT_RA ra,\n+# else\n+#   define OPT_RA\n+# endif\n+\n+\n+/* Check whether object with base pointer p has debugging info\t*/ \n+/* p is assumed to point to a legitimate object in our part\t*/\n+/* of the heap.\t\t\t\t\t\t\t*/\n+#ifdef SHORT_DBG_HDRS\n+# define GC_has_other_debug_info(p) TRUE\n+#else\n+  GC_bool GC_has_other_debug_info(/* p */);\n+#endif\n+\n+#ifdef KEEP_BACK_PTRS\n+# define GC_HAS_DEBUG_INFO(p) \\\n+\t((((oh *)p)->oh_back_ptr & 1) && GC_has_other_debug_info(p))\n+#else\n+# define GC_HAS_DEBUG_INFO(p) GC_has_other_debug_info(p)\n+#endif\n+\n+/* Store debugging info into p.  Return displaced pointer. */\n+/* Assumes we don't hold allocation lock.\t\t   */\n+ptr_t GC_store_debug_info(/* p, sz, string, integer */);\n+\n+#endif /* _DBG_MLC_H */"}, {"sha": "b9ff0cf19339e6a94d4f597df5b73ad035ec85a8", "filename": "boehm-gc/include/private/gc_locks.h", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,480 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n+ *\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+#ifndef GC_LOCKS_H\n+#define GC_LOCKS_H\n+\n+/*\n+ * Mutual exclusion between allocator/collector routines.\n+ * Needed if there is more than one allocator thread.\n+ * FASTLOCK() is assumed to try to acquire the lock in a cheap and\n+ * dirty way that is acceptable for a few instructions, e.g. by\n+ * inhibiting preemption.  This is assumed to have succeeded only\n+ * if a subsequent call to FASTLOCK_SUCCEEDED() returns TRUE.\n+ * FASTUNLOCK() is called whether or not FASTLOCK_SUCCEEDED().\n+ * If signals cannot be tolerated with the FASTLOCK held, then\n+ * FASTLOCK should disable signals.  The code executed under\n+ * FASTLOCK is otherwise immune to interruption, provided it is\n+ * not restarted.\n+ * DCL_LOCK_STATE declares any local variables needed by LOCK and UNLOCK\n+ * and/or DISABLE_SIGNALS and ENABLE_SIGNALS and/or FASTLOCK.\n+ * (There is currently no equivalent for FASTLOCK.)\n+ *\n+ * In the PARALLEL_MARK case, we also need to define a number of\n+ * other inline finctions here:\n+ *   GC_bool GC_compare_and_exchange( volatile GC_word *addr,\n+ *   \t\t\t\t      GC_word old, GC_word new )\n+ *   GC_word GC_atomic_add( volatile GC_word *addr, GC_word how_much )\n+ *   void GC_memory_barrier( )\n+ *   \n+ */  \n+# ifdef THREADS\n+#  ifdef PCR_OBSOLETE\t/* Faster, but broken with multiple lwp's\t*/\n+#    include  \"th/PCR_Th.h\"\n+#    include  \"th/PCR_ThCrSec.h\"\n+     extern struct PCR_Th_MLRep GC_allocate_ml;\n+#    define DCL_LOCK_STATE  PCR_sigset_t GC_old_sig_mask\n+#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml) \n+#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n+#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n+#    define FASTLOCK() PCR_ThCrSec_EnterSys()\n+     /* Here we cheat (a lot): */\n+#        define FASTLOCK_SUCCEEDED() (*(int *)(&GC_allocate_ml) == 0)\n+\t\t/* TRUE if nobody currently holds the lock */\n+#    define FASTUNLOCK() PCR_ThCrSec_ExitSys()\n+#  endif\n+#  ifdef PCR\n+#    include <base/PCR_Base.h>\n+#    include <th/PCR_Th.h>\n+     extern PCR_Th_ML GC_allocate_ml;\n+#    define DCL_LOCK_STATE \\\n+\t PCR_ERes GC_fastLockRes; PCR_sigset_t GC_old_sig_mask\n+#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml)\n+#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n+#    define FASTLOCK() (GC_fastLockRes = PCR_Th_ML_Try(&GC_allocate_ml))\n+#    define FASTLOCK_SUCCEEDED() (GC_fastLockRes == PCR_ERes_okay)\n+#    define FASTUNLOCK()  {\\\n+        if( FASTLOCK_SUCCEEDED() ) PCR_Th_ML_Release(&GC_allocate_ml); }\n+#  endif\n+#  ifdef SRC_M3\n+     extern GC_word RT0u__inCritical;\n+#    define LOCK() RT0u__inCritical++\n+#    define UNLOCK() RT0u__inCritical--\n+#  endif\n+#  ifdef SOLARIS_THREADS\n+#    include <thread.h>\n+#    include <signal.h>\n+     extern mutex_t GC_allocate_ml;\n+#    define LOCK() mutex_lock(&GC_allocate_ml);\n+#    define UNLOCK() mutex_unlock(&GC_allocate_ml);\n+#  endif\n+\n+/* Try to define GC_TEST_AND_SET and a matching GC_CLEAR for spin lock\t*/\n+/* acquisition and release.  We need this for correct operation of the\t*/\n+/* incremental GC.\t\t\t\t\t\t\t*/\n+#  ifdef __GNUC__\n+#    if defined(I386)\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n+\t  int oldval;\n+\t  /* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n+\t  __asm__ __volatile__(\"xchgl %0, %1\"\n+\t\t: \"=r\"(oldval), \"=m\"(*(addr))\n+\t\t: \"0\"(1), \"m\"(*(addr)) : \"memory\");\n+\t  return oldval;\n+       }\n+#      define GC_TEST_AND_SET_DEFINED\n+#    endif\n+#    if defined(IA64)\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n+\t  long oldval, n = 1;\n+\t  __asm__ __volatile__(\"xchg4 %0=%1,%2\"\n+\t\t: \"=r\"(oldval), \"=m\"(*addr)\n+\t\t: \"r\"(n), \"1\"(*addr) : \"memory\");\n+\t  return oldval;\n+       }\n+#      define GC_TEST_AND_SET_DEFINED\n+       /* Should this handle post-increment addressing?? */\n+       inline static void GC_clear(volatile unsigned int *addr) {\n+\t __asm__ __volatile__(\"st4.rel %0=r0\" : \"=m\" (*addr) : : \"memory\");\n+       }\n+#      define GC_CLEAR_DEFINED\n+#    endif\n+#    ifdef SPARC\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n+\t int oldval;\n+\n+\t __asm__ __volatile__(\"ldstub %1,%0\"\n+\t : \"=r\"(oldval), \"=m\"(*addr)\n+\t : \"m\"(*addr) : \"memory\");\n+\t return oldval;\n+       }\n+#      define GC_TEST_AND_SET_DEFINED\n+#    endif\n+#    ifdef M68K\n+       /* Contributed by Tony Mantler.  I'm not sure how well it was\t*/\n+       /* tested.\t\t\t\t\t\t\t*/\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n+          char oldval; /* this must be no longer than 8 bits */\n+\n+          /* The return value is semi-phony. */\n+          /* 'tas' sets bit 7 while the return */\n+          /* value pretends bit 0 was set */\n+          __asm__ __volatile__(\n+                 \"tas %1@; sne %0; negb %0\"\n+                 : \"=d\" (oldval)\n+                 : \"a\" (addr) : \"memory\");\n+          return oldval;\n+       }\n+#      define GC_TEST_AND_SET_DEFINED\n+#    endif\n+#    if defined(POWERPC)\n+        inline static int GC_test_and_set(volatile unsigned int *addr) {\n+          int oldval;\n+          int temp = 1; // locked value\n+\n+          __asm__ __volatile__(\n+               \"1:\\tlwarx %0,0,%3\\n\"   // load and reserve\n+               \"\\tcmpwi %0, 0\\n\"       // if load is\n+               \"\\tbne 2f\\n\"            //   non-zero, return already set\n+               \"\\tstwcx. %2,0,%1\\n\"    // else store conditional\n+               \"\\tbne- 1b\\n\"           // retry if lost reservation\n+               \"2:\\t\\n\"                // oldval is zero if we set\n+              : \"=&r\"(oldval), \"=p\"(addr)\n+              : \"r\"(temp), \"1\"(addr)\n+              : \"memory\");\n+          return (int)oldval;\n+        }\n+#       define GC_TEST_AND_SET_DEFINED\n+        inline static void GC_clear(volatile unsigned int *addr) {\n+\t  __asm__ __volatile__(\"eieio\" ::: \"memory\");\n+          *(addr) = 0;\n+        }\n+#       define GC_CLEAR_DEFINED\n+#    endif\n+#    if defined(ALPHA) \n+        inline static int GC_test_and_set(volatile unsigned int * addr)\n+        {\n+          unsigned long oldvalue;\n+          unsigned long temp;\n+\n+          __asm__ __volatile__(\n+                             \"1:     ldl_l %0,%1\\n\"\n+                             \"       and %0,%3,%2\\n\"\n+                             \"       bne %2,2f\\n\"\n+                             \"       xor %0,%3,%0\\n\"\n+                             \"       stl_c %0,%1\\n\"\n+                             \"       beq %0,3f\\n\"\n+                             \"       mb\\n\"\n+                             \"2:\\n\"\n+                             \".section .text2,\\\"ax\\\"\\n\"\n+                             \"3:     br 1b\\n\"\n+                             \".previous\"\n+                             :\"=&r\" (temp), \"=m\" (*addr), \"=&r\" (oldvalue)\n+                             :\"Ir\" (1), \"m\" (*addr)\n+\t\t\t     :\"memory\");\n+\n+          return oldvalue;\n+        }\n+#       define GC_TEST_AND_SET_DEFINED\n+        /* Should probably also define GC_clear, since it needs\t*/\n+        /* a memory barrier ??\t\t\t\t\t*/\n+#    endif /* ALPHA */\n+#    ifdef ARM32\n+        inline static int GC_test_and_set(volatile unsigned int *addr) {\n+          int oldval;\n+          /* SWP on ARM is very similar to XCHG on x86.  Doesn't lock the\n+           * bus because there are no SMP ARM machines.  If/when there are,\n+           * this code will likely need to be updated. */\n+          /* See linuxthreads/sysdeps/arm/pt-machine.h in glibc-2.1 */\n+          __asm__ __volatile__(\"swp %0, %1, [%2]\"\n+      \t\t  \t     : \"=r\"(oldval)\n+      \t\t\t     : \"r\"(1), \"r\"(addr)\n+\t\t\t     : \"memory\");\n+          return oldval;\n+        }\n+#       define GC_TEST_AND_SET_DEFINED\n+#    endif /* ARM32 */\n+#  endif /* __GNUC__ */\n+#  if (defined(ALPHA) && !defined(__GNUC__))\n+#    define GC_test_and_set(addr) __cxx_test_and_set_atomic(addr, 1)\n+#    define GC_TEST_AND_SET_DEFINED\n+#  endif\n+#  if defined(MSWIN32)\n+#    define GC_test_and_set(addr) InterlockedExchange((LPLONG)addr,1)\n+#    define GC_TEST_AND_SET_DEFINED\n+#  endif\n+#  ifdef MIPS\n+#    if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n+\t|| !defined(_COMPILER_VERSION) || _COMPILER_VERSION < 700\n+#        define GC_test_and_set(addr, v) test_and_set(addr,v)\n+#    else\n+#\t define GC_test_and_set(addr, v) __test_and_set(addr,v)\n+#\t define GC_clear(addr) __lock_release(addr);\n+#\t define GC_CLEAR_DEFINED\n+#    endif\n+#    define GC_TEST_AND_SET_DEFINED\n+#  endif /* MIPS */\n+#  if 0 /* defined(HP_PA) */\n+     /* The official recommendation seems to be to not use ldcw from\t*/\n+     /* user mode.  Since multithreaded incremental collection doesn't\t*/\n+     /* work anyway on HP_PA, this shouldn't be a major loss.\t\t*/\n+\n+     /* \"set\" means 0 and \"clear\" means 1 here.\t\t*/\n+#    define GC_test_and_set(addr) !GC_test_and_clear(addr);\n+#    define GC_TEST_AND_SET_DEFINED\n+#    define GC_clear(addr) GC_noop1(addr); *(volatile unsigned int *)addr = 1;\n+\t/* The above needs a memory barrier! */\n+#    define GC_CLEAR_DEFINED\n+#  endif\n+#  if defined(GC_TEST_AND_SET_DEFINED) && !defined(GC_CLEAR_DEFINED)\n+#    ifdef __GNUC__\n+       inline static void GC_clear(volatile unsigned int *addr) {\n+         /* Try to discourage gcc from moving anything past this. */\n+         __asm__ __volatile__(\" \" : : : \"memory\");\n+         *(addr) = 0;\n+       }\n+#    else\n+\t    /* The function call in the following should prevent the\t*/\n+\t    /* compiler from moving assignments to below the UNLOCK.\t*/\n+#      define GC_clear(addr) GC_noop1((word)(addr)); \\\n+\t\t\t     *((volatile unsigned int *)(addr)) = 0;\n+#    endif\n+#    define GC_CLEAR_DEFINED\n+#  endif /* !GC_CLEAR_DEFINED */\n+\n+#  if !defined(GC_TEST_AND_SET_DEFINED)\n+#    define USE_PTHREAD_LOCKS\n+#  endif\n+\n+#  if defined(LINUX_THREADS) || defined(OSF1_THREADS) \\\n+      || defined(HPUX_THREADS)\n+#    define NO_THREAD (pthread_t)(-1)\n+#    include <pthread.h>\n+#    if defined(PARALLEL_MARK) \n+      /* We need compare-and-swap to update mark bits, where it's\t*/\n+      /* performance critical.  If USE_MARK_BYTES is defined, it is\t*/\n+      /* no longer needed for this purpose.  However we use it in\t*/\n+      /* either case to implement atomic fetch-and-add, though that's\t*/\n+      /* less performance critical, and could perhaps be done with\t*/\n+      /* a lock.\t\t\t\t\t\t\t*/\n+#     if defined(GENERIC_COMPARE_AND_SWAP)\n+\t/* Probably not useful, except for debugging.\t*/\n+\t/* We do use GENERIC_COMPARE_AND_SWAP on PA_RISC, but we \t*/\n+\t/* minimize its use.\t\t\t\t\t\t*/\n+\textern pthread_mutex_t GC_compare_and_swap_lock;\n+\n+\t/* Note that if GC_word updates are not atomic, a concurrent \t*/\n+\t/* reader should acquire GC_compare_and_swap_lock.  On \t\t*/\n+\t/* currently supported platforms, such updates are atomic.\t*/\n+\textern GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+\t\t\t\t\t       GC_word old, GC_word new_val);\n+#     endif /* GENERIC_COMPARE_AND_SWAP */\n+#     if defined(I386)\n+#      if !defined(GENERIC_COMPARE_AND_SWAP)\n+         /* Returns TRUE if the comparison succeeded. */\n+         inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+\t\t  \t\t\t\t       GC_word old,\n+\t\t\t\t\t\t       GC_word new_val) \n+         {\n+\t   char result;\n+\t   __asm__ __volatile__(\"lock; cmpxchgl %2, %0; setz %1\"\n+\t    \t: \"=m\"(*(addr)), \"=r\"(result)\n+\t\t: \"r\" (new_val), \"0\"(*(addr)), \"a\"(old) : \"memory\");\n+\t   return (GC_bool) result;\n+         }\n+#      endif /* !GENERIC_COMPARE_AND_SWAP */\n+       inline static void GC_memory_write_barrier()\n+       {\n+\t /* We believe the processor ensures at least processor\t*/\n+\t /* consistent ordering.  Thus a compiler barrier\t*/\n+\t /* should suffice.\t\t\t\t\t*/\n+         __asm__ __volatile__(\"\" : : : \"memory\");\n+       }\n+#     endif /* I386 */\n+#     if defined(IA64)\n+#      if !defined(GENERIC_COMPARE_AND_SWAP)\n+         inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+\t\t\t\t\t\t       GC_word old, GC_word new_val) \n+\t {\n+\t  unsigned long oldval;\n+\t  __asm__ __volatile__(\"mov ar.ccv=%4 ;; cmpxchg8.rel %0=%1,%2,ar.ccv\"\n+\t\t: \"=r\"(oldval), \"=m\"(*addr)\n+\t\t: \"r\"(new_val), \"1\"(*addr), \"r\"(old) : \"memory\");\n+\t  return (oldval == old);\n+         }\n+#      endif /* !GENERIC_COMPARE_AND_SWAP */\n+#      if 0\n+\t/* Shouldn't be needed; we use volatile stores instead. */\n+        inline static void GC_memory_write_barrier()\n+        {\n+          __asm__ __volatile__(\"mf\" : : : \"memory\");\n+        }\n+#      endif /* 0 */\n+#     endif /* IA64 */\n+#     if !defined(GENERIC_COMPARE_AND_SWAP)\n+        /* Returns the original value of *addr.\t*/\n+        inline static GC_word GC_atomic_add(volatile GC_word *addr,\n+\t\t\t\t\t    GC_word how_much)\n+        {\n+\t  GC_word old;\n+\t  do {\n+\t    old = *addr;\n+\t  } while (!GC_compare_and_exchange(addr, old, old+how_much));\n+          return old;\n+        }\n+#     else /* GENERIC_COMPARE_AND_SWAP */\n+\t/* So long as a GC_word can be atomically updated, it should\t*/\n+\t/* be OK to read *addr without a lock.\t\t\t\t*/\n+\textern GC_word GC_atomic_add(volatile GC_word *addr, GC_word how_much);\n+#     endif /* GENERIC_COMPARE_AND_SWAP */\n+\n+#    endif /* PARALLEL_MARK */\n+\n+#    if !defined(THREAD_LOCAL_ALLOC) && !defined(USE_PTHREAD_LOCKS)\n+      /* In the THREAD_LOCAL_ALLOC case, the allocation lock tends to\t*/\n+      /* be held for long periods, if it is held at all.  Thus spinning\t*/\n+      /* and sleeping for fixed periods are likely to result in \t*/\n+      /* significant wasted time.  We thus rely mostly on queued locks. */\n+#     define USE_SPIN_LOCK\n+      extern volatile unsigned int GC_allocate_lock;\n+      extern void GC_lock(void);\n+\t/* Allocation lock holder.  Only set if acquired by client through */\n+\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n+#     ifdef GC_ASSERTIONS\n+#        define LOCK() \\\n+\t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); \\\n+\t\t  SET_LOCK_HOLDER(); }\n+#        define UNLOCK() \\\n+\t\t{ GC_ASSERT(I_HOLD_LOCK()); UNSET_LOCK_HOLDER(); \\\n+\t          GC_clear(&GC_allocate_lock); }\n+#     else\n+#        define LOCK() \\\n+\t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n+#        define UNLOCK() \\\n+\t\tGC_clear(&GC_allocate_lock)\n+#     endif /* !GC_ASSERTIONS */\n+#     if 0\n+\t/* Another alternative for OSF1 might be:\t\t*/\n+#       include <sys/mman.h>\n+        extern msemaphore GC_allocate_semaphore;\n+#       define LOCK() { if (msem_lock(&GC_allocate_semaphore, MSEM_IF_NOWAIT) \\\n+ \t\t\t    != 0) GC_lock(); else GC_allocate_lock = 1; }\n+        /* The following is INCORRECT, since the memory model is too weak. */\n+\t/* Is this true?  Presumably msem_unlock has the right semantics?  */\n+\t/*\t\t- HB\t\t\t\t\t\t   */\n+#       define UNLOCK() { GC_allocate_lock = 0; \\\n+                          msem_unlock(&GC_allocate_semaphore, 0); }\n+#     endif /* 0 */\n+#    else /* THREAD_LOCAL_ALLOC  || USE_PTHREAD_LOCKS */\n+#      ifndef USE_PTHREAD_LOCKS\n+#        define USE_PTHREAD_LOCKS\n+#      endif\n+#    endif /* THREAD_LOCAL_ALLOC */\n+#   ifdef USE_PTHREAD_LOCKS\n+#      include <pthread.h>\n+       extern pthread_mutex_t GC_allocate_ml;\n+#      ifdef GC_ASSERTIONS\n+#        define LOCK() \\\n+\t\t{ GC_lock(); \\\n+\t\t  SET_LOCK_HOLDER(); }\n+#        define UNLOCK() \\\n+\t\t{ GC_ASSERT(I_HOLD_LOCK()); UNSET_LOCK_HOLDER(); \\\n+\t          pthread_mutex_unlock(&GC_allocate_ml); }\n+#      else /* !GC_ASSERTIONS */\n+#        define LOCK() \\\n+\t   { if (0 != pthread_mutex_trylock(&GC_allocate_ml)) GC_lock(); }\n+#        define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#      endif /* !GC_ASSERTIONS */\n+#   endif /* USE_PTHREAD_LOCKS */\n+#   define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n+#   define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n+#   define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n+    extern VOLATILE GC_bool GC_collecting;\n+#   define ENTER_GC() GC_collecting = 1;\n+#   define EXIT_GC() GC_collecting = 0;\n+    extern void GC_lock(void);\n+    extern pthread_t GC_lock_holder;\n+#   ifdef GC_ASSERTIONS\n+      extern pthread_t GC_mark_lock_holder;\n+#   endif\n+#  endif /* LINUX_THREADS || OSF1_THREADS  || HPUX_THREADS */\n+#  if defined(IRIX_THREADS)\n+#    include <pthread.h>\n+     /* This probably should never be included, but I can't test\t*/\n+     /* on Irix anymore.\t\t\t\t\t\t*/\n+#    include <mutex.h>\n+\n+     extern unsigned long GC_allocate_lock;\n+\t/* This is not a mutex because mutexes that obey the (optional) \t*/\n+\t/* POSIX scheduling rules are subject to convoys in high contention\t*/\n+\t/* applications.  This is basically a spin lock.\t\t\t*/\n+     extern pthread_t GC_lock_holder;\n+     extern void GC_lock(void);\n+\t/* Allocation lock holder.  Only set if acquired by client through */\n+\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n+#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n+#    define NO_THREAD (pthread_t)(-1)\n+#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n+#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n+#    define LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n+#    define UNLOCK() GC_clear(&GC_allocate_lock);\n+     extern VOLATILE GC_bool GC_collecting;\n+#    define ENTER_GC() \\\n+\t\t{ \\\n+\t\t    GC_collecting = 1; \\\n+\t\t}\n+#    define EXIT_GC() GC_collecting = 0;\n+#  endif /* IRIX_THREADS */\n+#  ifdef WIN32_THREADS\n+#    include <windows.h>\n+     GC_API CRITICAL_SECTION GC_allocate_ml;\n+#    define LOCK() EnterCriticalSection(&GC_allocate_ml);\n+#    define UNLOCK() LeaveCriticalSection(&GC_allocate_ml);\n+#  endif\n+#  ifndef SET_LOCK_HOLDER\n+#      define SET_LOCK_HOLDER()\n+#      define UNSET_LOCK_HOLDER()\n+#      define I_HOLD_LOCK() FALSE\n+\t\t/* Used on platforms were locks can be reacquired,\t*/\n+\t\t/* so it doesn't matter if we lie.\t\t\t*/\n+#  endif\n+# else /* !THREADS */\n+#    define LOCK()\n+#    define UNLOCK()\n+# endif /* !THREADS */\n+# ifndef SET_LOCK_HOLDER\n+#   define SET_LOCK_HOLDER()\n+#   define UNSET_LOCK_HOLDER()\n+#   define I_HOLD_LOCK() FALSE\n+\t\t/* Used on platforms were locks can be reacquired,\t*/\n+\t\t/* so it doesn't matter if we lie.\t\t\t*/\n+# endif\n+# ifndef ENTER_GC\n+#   define ENTER_GC()\n+#   define EXIT_GC()\n+# endif\n+\n+# ifndef DCL_LOCK_STATE\n+#   define DCL_LOCK_STATE\n+# endif\n+# ifndef FASTLOCK\n+#   define FASTLOCK() LOCK()\n+#   define FASTLOCK_SUCCEEDED() TRUE\n+#   define FASTUNLOCK() UNLOCK()\n+# endif\n+\n+#endif /* GC_LOCKS_H */"}, {"sha": "1592b6ff74bdca74631d550979ad0ff21c2afdf0", "filename": "boehm-gc/include/private/gc_pmark.h", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 2001 by Hewlett-Packard Company. All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ */\n+\n+/* Private declarations of GC marker data structures and macros */\n+\n+/*\n+ * Declarations of mark stack.  Needed by marker and client supplied mark\n+ * routines.  Transitively include gc_priv.h.\n+ * (Note that gc_priv.h should not be included before this, since this\n+ * includes dbg_mlc.h, which wants to include gc_priv.h AFTER defining\n+ * I_HIDE_POINTERS.)\n+ */\n+#ifndef GC_PMARK_H\n+# define GC_PMARK_H\n+\n+# ifdef KEEP_BACK_PTRS\n+#   include \"dbg_mlc.h\"\n+# endif\n+# ifndef GC_MARK_H\n+#   include \"../gc_mark.h\"\n+# endif\n+# ifndef GC_PRIVATE_H\n+#   include \"gc_priv.h\"\n+# endif\n+\n+/* The real declarations of the following is in gc_priv.h, so that\t*/\n+/* we can avoid scanning the following table.\t\t\t\t*/\n+/*\n+extern mark_proc GC_mark_procs[MAX_MARK_PROCS];\n+*/\n+\n+/*\n+ * Mark descriptor stuff that should remain private for now, mostly\n+ * because it's hard to export WORDSZ without including gcconfig.h.\n+ */\n+# define BITMAP_BITS (WORDSZ - GC_DS_TAG_BITS)\n+# define PROC(descr) \\\n+\t(GC_mark_procs[((descr) >> GC_DS_TAG_BITS) & (GC_MAX_MARK_PROCS-1)])\n+# define ENV(descr) \\\n+\t((descr) >> (GC_DS_TAG_BITS + GC_LOG_MAX_MARK_PROCS))\n+# define MAX_ENV \\\n+  \t(((word)1 << (WORDSZ - GC_DS_TAG_BITS - GC_LOG_MAX_MARK_PROCS)) - 1)\n+\n+\n+extern word GC_n_mark_procs;\n+\n+/* Number of mark stack entries to discard on overflow.\t*/\n+#define GC_MARK_STACK_DISCARDS (INITIAL_MARK_STACK_SIZE/8)\n+\n+typedef struct GC_ms_entry {\n+    GC_word * mse_start;   /* First word of object */\n+    GC_word mse_descr;\t/* Descriptor; low order two bits are tags,\t*/\n+    \t\t\t/* identifying the upper 30 bits as one of the\t*/\n+    \t\t\t/* following:\t\t\t\t\t*/\n+} mse;\n+\n+extern word GC_mark_stack_size;\n+\n+extern mse * GC_mark_stack_limit;\n+\n+#ifdef PARALLEL_MARK\n+  extern mse * VOLATILE GC_mark_stack_top;\n+#else\n+  extern mse * GC_mark_stack_top;\n+#endif\n+\n+extern mse * GC_mark_stack;\n+\n+#ifdef PARALLEL_MARK\n+    /*\n+     * Allow multiple threads to participate in the marking process.\n+     * This works roughly as follows:\n+     *  The main mark stack never shrinks, but it can grow.\n+     *\n+     *\tThe initiating threads holds the GC lock, and sets GC_help_wanted.\n+     *  \n+     *  Other threads:\n+     *     1) update helper_count (while holding mark_lock.)\n+     *\t   2) allocate a local mark stack\n+     *     repeatedly:\n+     *\t\t3) Steal a global mark stack entry by atomically replacing\n+     *\t\t   its descriptor with 0.\n+     *\t\t4) Copy it to the local stack.\n+     *\t        5) Mark on the local stack until it is empty, or\n+     *\t\t   it may be profitable to copy it back.\n+     *\t        6) If necessary, copy local stack to global one,\n+     *\t\t   holding mark lock.\n+     *    7) Stop when the global mark stack is empty.\n+     *    8) decrement helper_count (holding mark_lock).\n+     *\n+     * This is an experiment to see if we can do something along the lines\n+     * of the University of Tokyo SGC in a less intrusive, though probably\n+     * also less performant, way.\n+     */\n+    void GC_do_parallel_mark();\n+\t\t/* inititate parallel marking.\t*/\n+\n+    extern GC_bool GC_help_wanted;\t/* Protected by mark lock\t*/\n+    extern unsigned GC_helper_count;\t/* Number of running helpers.\t*/\n+\t\t\t\t\t/* Protected by mark lock\t*/\n+    extern unsigned GC_active_count;\t/* Number of active helpers.\t*/\n+\t\t\t\t\t/* Protected by mark lock\t*/\n+\t\t\t\t\t/* May increase and decrease\t*/\n+\t\t\t\t\t/* within each mark cycle.  But\t*/\n+\t\t\t\t\t/* once it returns to 0, it\t*/\n+\t\t\t\t\t/* stays zero for the cycle.\t*/\n+    /* GC_mark_stack_top is also protected by mark lock.\t*/\n+    extern mse * VOLATILE GC_first_nonempty;\n+\t\t\t\t\t/* Lowest entry on mark stack\t*/\n+\t\t\t\t\t/* that may be nonempty.\t*/\n+\t\t\t\t\t/* Updated only by initiating \t*/\n+\t\t\t\t\t/* thread.\t\t\t*/\n+    /*\n+     * GC_notify_all_marker() is used when GC_help_wanted is first set,\n+     * when the last helper becomes inactive,\n+     * when something is added to the global mark stack, and just after\n+     * GC_mark_no is incremented.\n+     * This could be split into multiple CVs (and probably should be to\n+     * scale to really large numbers of processors.)\n+     */\n+#endif /* PARALLEL_MARK */\n+\n+ptr_t GC_find_start();\n+\n+mse * GC_signal_mark_stack_overflow();\n+\n+# ifdef GATHERSTATS\n+#   define ADD_TO_ATOMIC(sz) GC_atomic_in_use += (sz)\n+#   define ADD_TO_COMPOSITE(sz) GC_composite_in_use += (sz)\n+# else\n+#   define ADD_TO_ATOMIC(sz)\n+#   define ADD_TO_COMPOSITE(sz)\n+# endif\n+\n+/* Push the object obj with corresponding heap block header hhdr onto \t*/\n+/* the mark stack.\t\t\t\t\t\t\t*/\n+# define PUSH_OBJ(obj, hhdr, mark_stack_top, mark_stack_limit) \\\n+{ \\\n+    register word _descr = (hhdr) -> hb_descr; \\\n+        \\\n+    if (_descr == 0) { \\\n+    \tADD_TO_ATOMIC((hhdr) -> hb_sz); \\\n+    } else { \\\n+        ADD_TO_COMPOSITE((hhdr) -> hb_sz); \\\n+        mark_stack_top++; \\\n+        if (mark_stack_top >= mark_stack_limit) { \\\n+          mark_stack_top = GC_signal_mark_stack_overflow(mark_stack_top); \\\n+        } \\\n+        mark_stack_top -> mse_start = (obj); \\\n+        mark_stack_top -> mse_descr = _descr; \\\n+    } \\\n+}\n+\n+#ifdef PRINT_BLACK_LIST\n+#   define GC_FIND_START(current, hhdr, source) \\\n+\tGC_find_start(current, hhdr, source)\n+#else\n+#   define GC_FIND_START(current, hhdr, source) \\\n+\tGC_find_start(current, hhdr)\n+#endif\n+\n+/* Push the contents of current onto the mark stack if it is a valid\t*/\n+/* ptr to a currently unmarked object.  Mark it.\t\t\t*/\n+/* If we assumed a standard-conforming compiler, we could probably\t*/\n+/* generate the exit_label transparently.\t\t\t\t*/\n+# define PUSH_CONTENTS(current, mark_stack_top, mark_stack_limit, \\\n+\t\t       source, exit_label) \\\n+{ \\\n+    hdr * my_hhdr; \\\n+    ptr_t my_current = current; \\\n+ \\\n+    GET_HDR(my_current, my_hhdr); \\\n+    if (IS_FORWARDING_ADDR_OR_NIL(my_hhdr)) { \\\n+         my_current = GC_FIND_START(my_current, my_hhdr, (word)source); \\\n+         if (my_current == 0) goto exit_label; \\\n+         my_hhdr = GC_find_header(my_current); \\\n+    } \\\n+    PUSH_CONTENTS_HDR(my_current, mark_stack_top, mark_stack_limit, \\\n+\t\t  source, exit_label, my_hhdr);\t\\\n+exit_label: ; \\\n+}\n+\n+/* As above, but use header cache for header lookup.\t*/\n+# define HC_PUSH_CONTENTS(current, mark_stack_top, mark_stack_limit, \\\n+\t\t       source, exit_label) \\\n+{ \\\n+    hdr * my_hhdr; \\\n+    ptr_t my_current = current; \\\n+ \\\n+    HC_GET_HDR(my_current, my_hhdr, source); \\\n+    PUSH_CONTENTS_HDR(my_current, mark_stack_top, mark_stack_limit, \\\n+\t\t  source, exit_label, my_hhdr);\t\\\n+exit_label: ; \\\n+}\n+\n+/* As above, but deal with two pointers in interleaved fashion.\t*/\n+# define HC_PUSH_CONTENTS2(current1, current2, mark_stack_top, \\\n+\t\t\t   mark_stack_limit, \\\n+\t\t           source1, source2, exit_label1, exit_label2) \\\n+{ \\\n+    hdr * hhdr1; \\\n+    ptr_t my_current1 = current1; \\\n+    hdr * hhdr2; \\\n+    ptr_t my_current2 = current2; \\\n+ \\\n+    HC_GET_HDR2(my_current1, hhdr1, source1, my_current2, hhdr2, source2); \\\n+    PUSH_CONTENTS_HDR(my_current1, mark_stack_top, mark_stack_limit, \\\n+\t\t  source1, exit_label1, hhdr1);\t\\\n+exit_label1: ; \\\n+    if (0 != hhdr2) { \\\n+      PUSH_CONTENTS_HDR(my_current2, mark_stack_top, mark_stack_limit, \\\n+\t\t  source2, exit_label2, hhdr2);\t\\\n+    } \\\n+exit_label2: ; \\\n+}\n+\n+/* Set mark bit, exit if it was already set.\t*/\n+\n+# ifdef USE_MARK_BYTES\n+    /* Unlike the mark bit case, there is a race here, and we may set\t*/\n+    /* the bit twice in the concurrent case.  This can result in the\t*/\n+    /* object being pushed twice.  But that's only a performance issue.\t*/\n+#   define SET_MARK_BIT_EXIT_IF_SET(hhdr,displ,exit_label) \\\n+    { \\\n+        register VOLATILE char * mark_byte_addr = \\\n+\t\t\t\thhdr -> hb_marks + ((displ) >> 1); \\\n+        register char mark_byte = *mark_byte_addr; \\\n+          \\\n+\tif (mark_byte) goto exit_label; \\\n+\t*mark_byte_addr = 1;  \\\n+    } \n+# else\n+#   define SET_MARK_BIT_EXIT_IF_SET(hhdr,displ,exit_label) \\\n+    { \\\n+        register word * mark_word_addr = hhdr -> hb_marks + divWORDSZ(displ); \\\n+        register word mark_word = *mark_word_addr; \\\n+          \\\n+        OR_WORD_EXIT_IF_SET(mark_word_addr, (word)1 << modWORDSZ(displ), \\\n+\t\t\t    exit_label); \\\n+    } \n+# endif /* USE_MARK_BYTES */\n+\n+/* If the mark bit corresponding to current is not set, set it, and \t*/\n+/* push the contents of the object on the mark stack.  Since we\t\t*/\n+/* already have the header, we only look at the low order bits of \t*/\n+/* current.  (The value of current doesn't matter if hhdr = \t\t*/\n+/* GC_invalid_header.)\t\t\t\t\t\t\t*/\n+# define PUSH_CONTENTS_HDR(current, mark_stack_top, mark_stack_limit, \\\n+\t\t           source, exit_label, hhdr) \\\n+{ \\\n+    int displ;  /* Displacement in block; first bytes, then words */ \\\n+    int map_entry; \\\n+    \\\n+    displ = HBLKDISPL(current); \\\n+    map_entry = MAP_ENTRY((hhdr -> hb_map), displ); \\\n+    displ = BYTES_TO_WORDS(displ); \\\n+    if (map_entry > CPP_MAX_OFFSET) { \\\n+\tif (map_entry == OFFSET_TOO_BIG) { \\\n+\t  map_entry = displ % (hhdr -> hb_sz); \\\n+\t  displ -= map_entry; \\\n+\t  if (displ + (hhdr -> hb_sz) > BYTES_TO_WORDS(HBLKSIZE)) { \\\n+\t    GC_ADD_TO_BLACK_LIST_NORMAL((word)current, source); \\\n+\t    goto exit_label; \\\n+\t  } \\\n+\t} else { \\\n+          GC_ADD_TO_BLACK_LIST_NORMAL((word)current, source); goto exit_label; \\\n+\t} \\\n+    } else { \\\n+        displ -= map_entry; \\\n+    } \\\n+    GC_ASSERT(displ >= 0 && displ < MARK_BITS_PER_HBLK); \\\n+    SET_MARK_BIT_EXIT_IF_SET(hhdr, displ, exit_label); \\\n+    GC_STORE_BACK_PTR((ptr_t)source, (ptr_t)HBLKPTR(current) \\\n+\t\t\t\t      + WORDS_TO_BYTES(displ)); \\\n+    PUSH_OBJ(((word *)(HBLKPTR(current)) + displ), hhdr, \\\n+    \t     mark_stack_top, mark_stack_limit) \\\n+}\n+\n+#if defined(PRINT_BLACK_LIST) || defined(KEEP_BACK_PTRS)\n+#   define PUSH_ONE_CHECKED_STACK(p, source) \\\n+\tGC_mark_and_push_stack(p, (ptr_t)(source))\n+#else\n+#   define PUSH_ONE_CHECKED_STACK(p, source) \\\n+\tGC_mark_and_push_stack(p)\n+#endif\n+\n+/*\n+ * Push a single value onto mark stack. Mark from the object pointed to by p.\n+ * P is considered valid even if it is an interior pointer.\n+ * Previously marked objects are not pushed.  Hence we make progress even\n+ * if the mark stack overflows.\n+ */\n+# define GC_PUSH_ONE_STACK(p, source) \\\n+    if ((ptr_t)(p) >= (ptr_t)GC_least_plausible_heap_addr \t\\\n+\t && (ptr_t)(p) < (ptr_t)GC_greatest_plausible_heap_addr) {\t\\\n+\t PUSH_ONE_CHECKED_STACK(p, source);\t\\\n+    }\n+\n+/*\n+ * As above, but interior pointer recognition as for\n+ * normal for heap pointers.\n+ */\n+# define GC_PUSH_ONE_HEAP(p,source) \\\n+    if ((ptr_t)(p) >= (ptr_t)GC_least_plausible_heap_addr \t\\\n+\t && (ptr_t)(p) < (ptr_t)GC_greatest_plausible_heap_addr) {\t\\\n+\t    GC_mark_stack_top = GC_mark_and_push( \\\n+\t\t\t    (GC_PTR)(p), GC_mark_stack_top, \\\n+\t\t\t    GC_mark_stack_limit, (GC_PTR *)(source)); \\\n+    }\n+\n+/* Mark starting at mark stack entry top (incl.) down to\t*/\n+/* mark stack entry bottom (incl.).  Stop after performing\t*/\n+/* about one page worth of work.  Return the new mark stack\t*/\n+/* top entry.\t\t\t\t\t\t\t*/\n+mse * GC_mark_from GC_PROTO((mse * top, mse * bottom, mse *limit));\n+\n+#define MARK_FROM_MARK_STACK() \\\n+\tGC_mark_stack_top = GC_mark_from(GC_mark_stack_top, \\\n+\t\t\t\t\t GC_mark_stack, \\\n+\t\t\t\t\t GC_mark_stack + GC_mark_stack_size);\n+\n+/*\n+ * Mark from one finalizable object using the specified\n+ * mark proc. May not mark the object pointed to by \n+ * real_ptr. That is the job of the caller, if appropriate\n+ */\n+# define GC_MARK_FO(real_ptr, mark_proc) \\\n+{ \\\n+    (*(mark_proc))(real_ptr); \\\n+    while (!GC_mark_stack_empty()) MARK_FROM_MARK_STACK(); \\\n+    if (GC_mark_state != MS_NONE) { \\\n+        GC_set_mark_bit(real_ptr); \\\n+        while (!GC_mark_some((ptr_t)0)); \\\n+    } \\\n+}\n+\n+extern GC_bool GC_mark_stack_too_small;\n+\t\t\t\t/* We need a larger mark stack.  May be\t*/\n+\t\t\t\t/* set by client supplied mark routines.*/\n+\n+typedef int mark_state_t;\t/* Current state of marking, as follows:*/\n+\t\t\t\t/* Used to remember where we are during */\n+\t\t\t\t/* concurrent marking.\t\t\t*/\n+\n+\t\t\t\t/* We say something is dirty if it was\t*/\n+\t\t\t\t/* written since the last time we\t*/\n+\t\t\t\t/* retrieved dirty bits.  We say it's \t*/\n+\t\t\t\t/* grungy if it was marked dirty in the\t*/\n+\t\t\t\t/* last set of bits we retrieved.\t*/\n+\t\t\t\t\n+\t\t\t\t/* Invariant I: all roots and marked\t*/\n+\t\t\t\t/* objects p are either dirty, or point */\n+\t\t\t\t/* to objects q that are either marked \t*/\n+\t\t\t\t/* or a pointer to q appears in a range\t*/\n+\t\t\t\t/* on the mark stack.\t\t\t*/\n+\n+# define MS_NONE 0\t\t/* No marking in progress. I holds.\t*/\n+\t\t\t\t/* Mark stack is empty.\t\t\t*/\n+\n+# define MS_PUSH_RESCUERS 1\t/* Rescuing objects are currently \t*/\n+\t\t\t\t/* being pushed.  I holds, except\t*/\n+\t\t\t\t/* that grungy roots may point to \t*/\n+\t\t\t\t/* unmarked objects, as may marked\t*/\n+\t\t\t\t/* grungy objects above scan_ptr.\t*/\n+\n+# define MS_PUSH_UNCOLLECTABLE 2\n+\t\t\t\t/* I holds, except that marked \t\t*/\n+\t\t\t\t/* uncollectable objects above scan_ptr */\n+\t\t\t\t/* may point to unmarked objects.\t*/\n+\t\t\t\t/* Roots may point to unmarked objects\t*/\n+\n+# define MS_ROOTS_PUSHED 3\t/* I holds, mark stack may be nonempty  */\n+\n+# define MS_PARTIALLY_INVALID 4\t/* I may not hold, e.g. because of M.S. */\n+\t\t\t\t/* overflow.  However marked heap\t*/\n+\t\t\t\t/* objects below scan_ptr point to\t*/\n+\t\t\t\t/* marked or stacked objects.\t\t*/\n+\n+# define MS_INVALID 5\t\t/* I may not hold.\t\t\t*/\n+\n+extern mark_state_t GC_mark_state;\n+\n+#endif  /* GC_PMARK_H */\n+"}, {"sha": "b2cdb36e98d9734447c77b3c41c5f4352362552a", "filename": "boehm-gc/include/private/solaris_threads.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,34 @@\n+#ifdef SOLARIS_THREADS\n+\n+/* The set of all known threads.  We intercept thread creation and     */\n+/* joins.  We never actually create detached threads.  We allocate all */\n+/* new thread stacks ourselves.  These allow us to maintain this       */\n+/* data structure.                                                     */\n+/* Protected by GC_thr_lock.                                           */\n+/* Some of this should be declared volatile, but that's incosnsistent  */\n+/* with some library routine declarations.  In particular, the \t       */\n+/* definition of cond_t doesn't mention volatile!                      */\n+  typedef struct GC_Thread_Rep {\n+    struct GC_Thread_Rep * next;\n+    thread_t id;\n+    word flags;\n+#      define FINISHED 1       /* Thread has exited.   */\n+#      define DETACHED 2       /* Thread is intended to be detached.   */\n+#      define CLIENT_OWNS_STACK        4\n+                               /* Stack was supplied by client.        */\n+#      define SUSPENDED 8      /* Currently suspended. */\n+    ptr_t stack;\n+    size_t stack_size;\n+    cond_t join_cv;\n+    void * status;\n+  } * GC_thread;\n+  extern GC_thread GC_new_thread(thread_t id);\n+\n+  extern GC_bool GC_thr_initialized;\n+  extern volatile GC_thread GC_threads[];\n+  extern size_t GC_min_stack_sz;\n+  extern size_t GC_page_sz;\n+  extern void GC_thr_init(void);\n+\n+# endif /* SOLARIS_THREADS */\n+"}, {"sha": "60c152c6fd0e40b21268a9f7197a0d19ac423a71", "filename": "boehm-gc/include/private/specific.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fspecific.h?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,83 @@\n+/*\n+ * This is a reimplementation of a subset of the pthread_getspecific/setspecific\n+ * interface. This appears to outperform the standard linuxthreads one\n+ * by a significant margin.\n+ * The major restriction is that each thread may only make a single\n+ * pthread_setspecific call on a single key.  (The current data structure\n+ * doesn't really require that.  The restriction should be easily removable.)\n+ * We don't currently support the destruction functions, though that\n+ * could be done.\n+ * We also currently assume that only one pthread_setspecific call\n+ * can be executed at a time, though that assumption would be easy to remove\n+ * by adding a lock.\n+ */\n+\n+#include <errno.h>\n+\n+/* Called during key creation or setspecific.\t\t*/\n+/* For the GC we already hold lock.\t\t\t*/\n+/* Currently allocated objects leak on thread exit.\t*/\n+/* That's hard to fix, but OK if we allocate garbage\t*/\n+/* collected memory.\t\t\t\t\t*/\n+#define MALLOC_CLEAR(n) GC_INTERNAL_MALLOC(n, NORMAL)\n+#define PREFIXED(name) GC_##name\n+\n+#define TS_CACHE_SIZE 1024\n+#define CACHE_HASH(n) (((((long)n) >> 8) ^ (long)n) & (TS_CACHE_SIZE - 1))\n+#define TS_HASH_SIZE 1024\n+#define HASH(n) (((((long)n) >> 8) ^ (long)n) & (TS_HASH_SIZE - 1))\n+\n+typedef struct thread_specific_entry {\n+\tunsigned long qtid;\t/* quick thread id, only for cache */\n+\tvoid * value;\n+\tpthread_t thread;\n+\tstruct thread_specific_entry *next;\n+} tse;\n+\n+\n+/* We represent each thread-specific datum as two tables.  The first is\t*/\n+/* a cache, index by a \"quick thread identifier\".  The \"quick\" thread\t*/\n+/* identifier is an easy to compute value, which is guaranteed to\t*/\n+/* determine the thread, though a thread may correspond to more than\t*/\n+/* one value.  We typically use the address of a page in the stack.\t*/\n+/* The second is a hash table, indexed by pthread_self().  It is used\t*/\n+/* only as a backup.\t\t\t\t\t\t\t*/\n+\n+/* Return the \"quick thread id\".  Default version.  Assumes page size,\t*/\n+/* or at least thread stack separation, is at least 4K.\t\t\t*/\n+static __inline__ long quick_thread_id() {\n+    int dummy;\n+    return (long)(&dummy) >> 12;\n+}\n+\n+#define INVALID_QTID ((unsigned long)(-1))\n+\n+typedef struct thread_specific_data {\n+    tse * volatile cache[TS_CACHE_SIZE];\n+\t\t\t/* A faster index to the hash table */\n+    tse * hash[TS_HASH_SIZE];\n+    pthread_mutex_t lock;\n+} tsd;\n+\n+typedef tsd * PREFIXED(key_t);\n+\n+extern int PREFIXED(key_create) (tsd ** key_ptr, void (* destructor)(void *));\n+\n+extern int PREFIXED(setspecific) (tsd * key, void * value);\n+\n+extern void PREFIXED(remove_specific) (tsd * key);\n+\n+/* An internal version of getspecific that assumes a cache miss.\t*/\n+void * PREFIXED(slow_getspecific) (tsd * key, unsigned long qtid,\n+\t\t\t\t   tse * volatile * cache_entry);\n+\n+static __inline__ void * PREFIXED(getspecific) (tsd * key) {\n+    long qtid = quick_thread_id();\n+    unsigned hash_val = CACHE_HASH(qtid);\n+    tse * volatile * entry_ptr = key -> cache + hash_val;\n+    tse * entry = *entry_ptr;   /* Must be loaded only once.\t*/\n+    if (entry -> qtid == qtid) return entry -> value;\n+    return PREFIXED(slow_getspecific) (key, qtid, entry_ptr);\n+}\n+\n+"}, {"sha": "fad41d1c661266d64ef3f51a67eedec9054c40e3", "filename": "boehm-gc/powerpc_macosx_mach_dep.s", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fpowerpc_macosx_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fpowerpc_macosx_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpowerpc_macosx_mach_dep.s?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,66 @@\n+    .text\n+    \n+    .set   linkageArea,24\n+    .set   params,4\n+    .set   alignment,4\n+\n+    .set   spaceToSave,linkageArea+params+alignment\n+    .set   spaceToSave8,spaceToSave+8\n+\n+; Mark from machine registers that are saved by C compiler\n+    .globl  _GC_push_regs\n+_GC_push_regs:\n+    ; PROLOG\n+    mflr    r0          ; get return address\n+    stw     r0,8(r1)    ; save return address\n+    stwu    r1,-spaceToSave(r1)   ; skip over caller save area\n+    ;\n+    mr      r3,r2         ; mark from r2. Well I'm not really sure\n+                          ; that this is necessary or even the right\n+                          ; thing to do - at least it doesn't harm...\n+                          ; According to Apple's docs it points to\n+                          ; the direct data area, whatever that is...\n+    bl \t    _GC_push_one\n+    mr      r3,r13        ; mark from r13-r31\n+    bl \t    _GC_push_one\n+    mr      r3,r14\n+    bl \t    _GC_push_one\n+    mr      r3,r15\n+    bl \t    _GC_push_one\n+    mr      r3,r16\n+    bl \t    _GC_push_one\n+    mr      r3,r17\n+    bl \t    _GC_push_one\n+    mr      r3,r18\n+    bl \t    _GC_push_one\n+    mr      r3,r19\n+    bl \t    _GC_push_one\n+    mr      r3,r20\n+    bl \t    _GC_push_one\n+    mr      r3,r21\n+    bl \t    _GC_push_one\n+    mr      r3,r22\n+    bl \t    _GC_push_one\n+    mr      r3,r23\n+    bl \t    _GC_push_one\n+    mr      r3,r24\n+    bl \t    _GC_push_one\n+    mr      r3,r25\n+    bl \t    _GC_push_one\n+    mr      r3,r26\n+    bl \t    _GC_push_one\n+    mr      r3,r27\n+    bl \t    _GC_push_one\n+    mr      r3,r28\n+    bl \t    _GC_push_one\n+    mr      r3,r29\n+    bl \t    _GC_push_one\n+    mr      r3,r30\n+    bl \t    _GC_push_one\n+    mr      r3,r31\n+    bl \t    _GC_push_one\n+    ; EPILOG\n+    lwz     r0,spaceToSave8(r1)   ; get return address back\n+    mtlr    r0    ; reset link register\n+    addic   r1,r1,spaceToSave   ; restore stack pointer\n+    blr"}, {"sha": "bc3f1603735f1b7790fde8c22013e2a0dd6ae994", "filename": "boehm-gc/sparc_netbsd_mach_dep.s", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fsparc_netbsd_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fsparc_netbsd_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_netbsd_mach_dep.s?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,34 @@\n+!\tSPARCompiler 3.0 and later apparently no longer handles\n+!\tasm outside functions.  So we need a separate .s file\n+!\tThis is only set up for SunOS 4.\n+!\tAssumes this is called before the stack contents are\n+!\texamined.\n+\n+#include \"machine/asm.h\"\n+\n+\t.seg \t\"text\"\n+\t.globl\t_C_LABEL(GC_save_regs_in_stack)\n+\t.globl \t_C_LABEL(GC_push_regs)\n+_C_LABEL(GC_save_regs_in_stack):\n+_C_LABEL(GC_push_regs):\n+\tta\t0x3   ! ST_FLUSH_WINDOWS\n+\tmov\t%sp,%o0\n+\tretl\n+\tnop\n+\t\n+\t.globl\t_C_LABEL(GC_clear_stack_inner)\n+_C_LABEL(GC_clear_stack_inner):\n+\tmov\t%sp,%o2\t\t! Save sp\n+\tadd\t%sp,-8,%o3\t! p = sp-8\n+\tclr\t%g1\t\t! [g0,g1] = 0\n+\tadd\t%o1,-0x60,%sp\t! Move sp out of the way,\n+\t\t\t\t! so that traps still work.\n+\t\t\t\t! Includes some extra words\n+\t\t\t\t! so we can be sloppy below.\n+loop:\n+\tstd\t%g0,[%o3]\t! *(long long *)p = 0\n+\tcmp\t%o3,%o1\n+\tbgu\tloop\t\t! if (p > limit) goto loop\n+\tadd\t%o3,-8,%o3\t! p -= 8 (delay slot)\n+\tretl\n+\tmov\t%o2,%sp\t\t! Restore sp., delay slot"}, {"sha": "5afd10b7595840e03907566e1eb35a8713d86ef3", "filename": "boehm-gc/specific.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fspecific.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Fspecific.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fspecific.c?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,108 @@\n+/* \n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+#if defined(LINUX_THREADS) || defined(GC_LINUX_THREADS)\n+\n+#include \"private/gc_priv.h\" /* For GC_compare_and_exchange, GC_memory_barrier */\n+#include \"private/specific.h\"\n+\n+static tse invalid_tse; \t/* 0 qtid is guaranteed to be invalid\t*/\n+\n+int PREFIXED(key_create) (tsd ** key_ptr, void (* destructor)(void *)) {\n+    int i;\n+    tsd * result = (tsd *)MALLOC_CLEAR(sizeof (tsd));\n+\n+    if (0 == result) return ENOMEM;\n+    pthread_mutex_init(&(result -> lock), NULL);\n+    for (i = 0; i < TS_CACHE_SIZE; ++i) {\n+\tresult -> cache[i] = &invalid_tse;\n+    }\n+    *key_ptr = result;\n+    return 0;\n+}\n+\n+int PREFIXED(setspecific) (tsd * key, void * value) {\n+    pthread_t self = pthread_self();\n+    int hash_val = HASH(self);\n+    volatile tse * entry = (volatile tse *)MALLOC_CLEAR(sizeof (tse));\n+    \n+    if (0 == entry) return ENOMEM;\n+    pthread_mutex_lock(&(key -> lock));\n+    /* Could easily check for an existing entry here.\t*/\n+    entry -> next = key -> hash[hash_val];\n+    entry -> thread = self;\n+    entry -> value = value;\n+    /* There can only be one writer at a time, but this needs to be\t*/\n+    /* atomic with respect to concurrent readers.\t\t\t*/ \n+    *(volatile tse **)(key -> hash + hash_val) = entry;\n+    pthread_mutex_unlock(&(key -> lock));\n+    return 0;\n+}\n+\n+/* Remove thread-specific data for this thread.  Should be called on\t*/\n+/* thread exit.\t\t\t\t\t\t\t\t*/\n+void PREFIXED(remove_specific) (tsd * key) {\n+    pthread_t self = pthread_self();\n+    unsigned hash_val = HASH(self);\n+    tse *entry;\n+    tse **link = key -> hash + hash_val;\n+\n+    pthread_mutex_lock(&(key -> lock));\n+    entry = *link;\n+    while (entry != NULL && entry -> thread != self) {\n+\tlink = &(entry -> next);\n+        entry = *link;\n+    }\n+    /* Invalidate qtid field, since qtids may be reused, and a later \t*/\n+    /* cache lookup could otherwise find this entry.\t\t\t*/\n+        entry -> qtid = INVALID_QTID;\n+    if (entry != NULL) {\n+\t*link = entry -> next;\n+\t/* Atomic! concurrent accesses still work.\t*/\n+\t/* They must, since readers don't lock.\t\t*/\n+    }\n+    /* If we wanted to deallocate the entry, we'd first have to clear \t*/\n+    /* any cache entries pointing to it.  That probably requires\t*/\n+    /* additional synchronization, since we can't prevent a concurrent \t*/\n+    /* cache lookup, which should still be examining deallocated memory.*/\n+    /* This can only happen if the concurrent access is from another\t*/\n+    /* thread, and hence has missed the cache, but still...\t\t*/\n+\n+    /* With GC, we're done, since the pointers from the cache will \t*/\n+    /* be overwritten, all local pointers to the entries will be\t*/\n+    /* dropped, and the entry will then be reclaimed.\t\t\t*/\n+    pthread_mutex_unlock(&(key -> lock));\n+}\n+\n+/* Note that even the slow path doesn't lock.\t*/\n+void *  PREFIXED(slow_getspecific) (tsd * key, unsigned long qtid,\n+\t\t\t\t    tse * volatile * cache_ptr) {\n+    pthread_t self = pthread_self();\n+    unsigned hash_val = HASH(self);\n+    tse *entry = key -> hash[hash_val];\n+\n+    while (entry != NULL && entry -> thread != self) {\n+\tentry = entry -> next;\n+    } \n+    if (entry == NULL) return NULL;\n+    /* Set cache_entry.\t\t*/\n+        entry -> qtid = qtid;\n+\t\t/* It's safe to do this asynchronously.  Either value \t*/\n+\t\t/* is safe, though may produce spurious misses.\t\t*/\n+\t*cache_ptr = entry;\n+\t\t/* Again this is safe since pointer assignments are \t*/\n+\t\t/* presumed atomic, and either pointer is valid.\t*/\n+    return entry -> value;\n+}\n+\n+#endif /* LINUX_THREADS */"}, {"sha": "421d0c6cd4a6f9ec5544285a18797c5dc2147b85", "filename": "boehm-gc/tests/leak_test.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Fleak_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Fleak_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Fleak_test.c?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,21 @@\n+#include \"leak_detector.h\"\n+\n+main() {\n+    int *p[10];\n+    int i;\n+    GC_find_leak = 1; /* for new collect versions not compiled  */\n+    /* with -DFIND_LEAK.                                        */\n+    for (i = 0; i < 10; ++i) {\n+        p[i] = malloc(sizeof(int)+i);\n+    }\n+    CHECK_LEAKS();\n+    for (i = 1; i < 10; ++i) {\n+        free(p[i]);\n+    }\n+    for (i = 0; i < 9; ++i) {\n+        p[i] = malloc(sizeof(int)+i);\n+    }\n+    CHECK_LEAKS();\n+    CHECK_LEAKS();\n+    CHECK_LEAKS();\n+}       "}, {"sha": "de58a6bd5f2191053e6b6faaae22bd3523d3e7da", "filename": "boehm-gc/tests/test.c", "status": "added", "additions": 1654, "deletions": 0, "changes": 1654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest.c?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,1654 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* An incomplete test for the garbage collector.  \t\t*/\n+/* Some more obscure entry points are not tested at all.\t*/\n+\n+# undef GC_BUILD\n+\n+#ifdef DBG_HDRS_ALL\n+#  define GC_DEBUG\n+#endif\n+\n+# if defined(mips) && defined(SYSTYPE_BSD43)\n+    /* MIPS RISCOS 4 */\n+# else\n+#   include <stdlib.h>\n+# endif\n+# include <stdio.h>\n+# ifdef _WIN32_WCE\n+#   include <winbase.h>\n+#   define assert ASSERT\n+# else\n+#   include <assert.h>        /* Not normally used, but handy for debugging. */\n+# endif\n+# include <assert.h>\t/* Not normally used, but handy for debugging. */\n+# include \"gc.h\"\n+# include \"gc_typed.h\"\n+# ifdef THREAD_LOCAL_ALLOC\n+#   include \"gc_local_alloc.h\"\n+# endif\n+# include \"private/gc_priv.h\"\t/* For output, locking, MIN_WORDS, \t*/\n+\t\t\t/* and some statistics.\t\t\t*/\n+# include \"private/gcconfig.h\"\n+\n+# if defined(MSWIN32) || defined(MSWINCE)\n+#   include <windows.h>\n+# endif\n+\n+# ifdef PCR\n+#   include \"th/PCR_ThCrSec.h\"\n+#   include \"th/PCR_Th.h\"\n+#   undef GC_printf0\n+#   define GC_printf0 printf\n+#   undef GC_printf1\n+#   define GC_printf1 printf\n+# endif\n+\n+# ifdef SOLARIS_THREADS\n+#   include <thread.h>\n+#   include <synch.h>\n+# endif\n+\n+# if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+#   include <pthread.h>\n+# endif\n+\n+# ifdef WIN32_THREADS\n+#   ifndef MSWINCE\n+#     include <process.h>\n+#     define GC_CreateThread(a,b,c,d,e,f) ((HANDLE) _beginthreadex(a,b,c,d,e,f))\n+#   endif\n+    static CRITICAL_SECTION incr_cs;\n+# endif\n+\n+\n+/* Allocation Statistics */\n+int stubborn_count = 0;\n+int uncollectable_count = 0;\n+int collectable_count = 0;\n+int atomic_count = 0;\n+int realloc_count = 0;\n+\n+#if defined(GC_AMIGA_FASTALLOC) && defined(AMIGA)\n+\n+  extern void GC_amiga_free_all_mem(void);\n+  void Amiga_Fail(void){GC_amiga_free_all_mem();abort();}\n+# define FAIL (void)Amiga_Fail()\n+  void *GC_amiga_gctest_malloc_explicitly_typed(size_t lb, GC_descr d){\n+    void *ret=GC_malloc_explicitly_typed(lb,d);\n+    if(ret==NULL){\n+\t\tif(!GC_dont_gc){\n+\t      GC_gcollect();\n+\t      ret=GC_malloc_explicitly_typed(lb,d);\n+\t\t}\n+      if(ret==NULL){\n+        GC_printf0(\"Out of memory, (typed allocations are not directly \"\n+\t\t   \"supported with the GC_AMIGA_FASTALLOC option.)\\n\");\n+        FAIL;\n+      }\n+    }\n+    return ret;\n+  }\n+  void *GC_amiga_gctest_calloc_explicitly_typed(size_t a,size_t lb, GC_descr d){\n+    void *ret=GC_calloc_explicitly_typed(a,lb,d);\n+    if(ret==NULL){\n+\t\tif(!GC_dont_gc){\n+\t      GC_gcollect();\n+\t      ret=GC_calloc_explicitly_typed(a,lb,d);\n+\t\t}\n+      if(ret==NULL){\n+        GC_printf0(\"Out of memory, (typed allocations are not directly \"\n+\t\t   \"supported with the GC_AMIGA_FASTALLOC option.)\\n\");\n+        FAIL;\n+      }\n+    }\n+    return ret;\n+  }\n+# define GC_malloc_explicitly_typed(a,b) GC_amiga_gctest_malloc_explicitly_typed(a,b) \n+# define GC_calloc_explicitly_typed(a,b,c) GC_amiga_gctest_calloc_explicitly_typed(a,b,c) \n+\n+#else /* !AMIGA_FASTALLOC */\n+\n+# ifdef PCR\n+#   define FAIL (void)abort()\n+# else\n+#   ifdef MSWINCE\n+#     define FAIL DebugBreak()\n+#   else\n+#     define FAIL GC_abort(\"Test failed\");\n+#   endif\n+# endif\n+\n+#endif /* !AMIGA_FASTALLOC */\n+\n+/* AT_END may be defined to exercise the interior pointer test\t*/\n+/* if the collector is configured with ALL_INTERIOR_POINTERS.   */\n+/* As it stands, this test should succeed with either\t\t*/\n+/* configuration.  In the FIND_LEAK configuration, it should\t*/\n+/* find lots of leaks, since we free almost nothing.\t\t*/\n+\n+struct SEXPR {\n+    struct SEXPR * sexpr_car;\n+    struct SEXPR * sexpr_cdr;\n+};\n+\n+\n+typedef struct SEXPR * sexpr;\n+\n+# define INT_TO_SEXPR(x) ((sexpr)(unsigned long)(x))\n+\n+# undef nil\n+# define nil (INT_TO_SEXPR(0))\n+# define car(x) ((x) -> sexpr_car)\n+# define cdr(x) ((x) -> sexpr_cdr)\n+# define is_nil(x) ((x) == nil)\n+\n+\n+int extra_count = 0;        /* Amount of space wasted in cons node */\n+\n+/* Silly implementation of Lisp cons. Intentionally wastes lots of space */\n+/* to test collector.                                                    */\n+# ifdef VERY_SMALL_CONFIG\n+#   define cons small_cons\n+# else\n+sexpr cons (x, y)\n+sexpr x;\n+sexpr y;\n+{\n+    register sexpr r;\n+    register int *p;\n+    register int my_extra = extra_count;\n+    \n+    stubborn_count++;\n+    r = (sexpr) GC_MALLOC_STUBBORN(sizeof(struct SEXPR) + my_extra);\n+    if (r == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    for (p = (int *)r;\n+         ((char *)p) < ((char *)r) + my_extra + sizeof(struct SEXPR); p++) {\n+\tif (*p) {\n+\t    (void)GC_printf1(\"Found nonzero at 0x%lx - allocator is broken\\n\",\n+\t    \t\t     (unsigned long)p);\n+\t    FAIL;\n+        }\n+        *p = 13;\n+    }\n+#   ifdef AT_END\n+\tr = (sexpr)((char *)r + (my_extra & ~7));\n+#   endif\n+    r -> sexpr_car = x;\n+    r -> sexpr_cdr = y;\n+    my_extra++;\n+    if ( my_extra >= 5000 ) {\n+        extra_count = 0;\n+    } else {\n+        extra_count = my_extra;\n+    }\n+    GC_END_STUBBORN_CHANGE((char *)r);\n+    return(r);\n+}\n+# endif\n+\n+sexpr small_cons (x, y)\n+sexpr x;\n+sexpr y;\n+{\n+    register sexpr r;\n+    \n+    collectable_count++;\n+    r = (sexpr) GC_MALLOC(sizeof(struct SEXPR));\n+    if (r == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    r -> sexpr_car = x;\n+    r -> sexpr_cdr = y;\n+    return(r);\n+}\n+\n+sexpr small_cons_uncollectable (x, y)\n+sexpr x;\n+sexpr y;\n+{\n+    register sexpr r;\n+    \n+    uncollectable_count++;\n+    r = (sexpr) GC_MALLOC_UNCOLLECTABLE(sizeof(struct SEXPR));\n+    if (r == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    r -> sexpr_car = x;\n+    r -> sexpr_cdr = (sexpr)(~(unsigned long)y);\n+    return(r);\n+}\n+\n+#ifdef GC_GCJ_SUPPORT\n+\n+#include \"gc_mark.h\"\n+#include \"dbg_mlc.h\"\n+#include \"include/gc_gcj.h\"\n+\n+/* The following struct emulates the vtable in gcj.\t*/\n+/* This assumes the default value of MARK_DESCR_OFFSET. */\n+struct fake_vtable {\n+  void * dummy;\t\t/* class pointer in real gcj.\t*/\n+  size_t descr;\n+};\n+\n+struct fake_vtable gcj_class_struct1 = { 0, sizeof(struct SEXPR)\n+\t\t\t\t\t    + sizeof(struct fake_vtable *) };\n+\t\t\t/* length based descriptor.\t*/\n+struct fake_vtable gcj_class_struct2 =\n+\t\t\t\t{ 0, (3l << (CPP_WORDSZ - 3)) | DS_BITMAP};\n+\t\t\t/* Bitmap based descriptor.\t*/\n+\n+struct GC_ms_entry * fake_gcj_mark_proc(word * addr,\n+\t\t\t\t        struct ms_entry *mark_stack_ptr,\n+\t\t\t\t        struct ms_entry *mark_stack_limit,\n+\t\t\t\t        word env   )\n+{\n+    sexpr x;\n+    if (1 == env) {\n+\t/* Object allocated with debug allocator.\t*/\n+\taddr = (word *)USR_PTR_FROM_BASE(addr);\n+    }\n+    x = (sexpr)(addr + 1); /* Skip the vtable pointer. */\n+    /* We could just call PUSH_CONTENTS directly here.  But any real\t*/\n+    /* real client would try to filter out the obvious misses.\t\t*/\n+    if (0 != x -> sexpr_cdr) {\n+\tPUSH_CONTENTS((ptr_t)(x -> sexpr_cdr), mark_stack_ptr,\n+\t\t\t      mark_stack_limit, &(x -> sexpr_cdr), exit1);\n+    }\n+    if ((ptr_t)(x -> sexpr_car) > GC_least_plausible_heap_addr) {\n+\tPUSH_CONTENTS((ptr_t)(x -> sexpr_car), mark_stack_ptr,\n+\t\t\t      mark_stack_limit, &(x -> sexpr_car), exit2);\n+    }\n+    return(mark_stack_ptr);\n+}\n+\n+sexpr gcj_cons(x, y)\n+sexpr x;\n+sexpr y;\n+{\n+    GC_word * r;\n+    sexpr result;\n+    static int count = 0;\n+    \n+    if (++count & 1) {\n+#     ifdef USE_MARK_BYTES\n+        r = (GC_word *) GC_GCJ_FAST_MALLOC(4, &gcj_class_struct1);\n+#     else\n+        r = (GC_word *) GC_GCJ_FAST_MALLOC(3, &gcj_class_struct1);\n+#     endif\n+    } else {\n+        r = (GC_word *) GC_GCJ_MALLOC(sizeof(struct SEXPR)\n+\t\t\t\t      + sizeof(struct fake_vtable*),\n+\t\t\t\t      &gcj_class_struct2);\n+    }\n+    if (r == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    result = (sexpr)(r + 1);\n+    result -> sexpr_car = x;\n+    result -> sexpr_cdr = y;\n+    return(result);\n+}\n+#endif\n+\n+/* Return reverse(x) concatenated with y */\n+sexpr reverse1(x, y)\n+sexpr x, y;\n+{\n+    if (is_nil(x)) {\n+        return(y);\n+    } else {\n+        return( reverse1(cdr(x), cons(car(x), y)) );\n+    }\n+}\n+\n+sexpr reverse(x)\n+sexpr x;\n+{\n+    return( reverse1(x, nil) );\n+}\n+\n+sexpr ints(low, up)\n+int low, up;\n+{\n+    if (low > up) {\n+\treturn(nil);\n+    } else {\n+        return(small_cons(small_cons(INT_TO_SEXPR(low), nil), ints(low+1, up)));\n+    }\n+}\n+\n+#ifdef GC_GCJ_SUPPORT\n+/* Return reverse(x) concatenated with y */\n+sexpr gcj_reverse1(x, y)\n+sexpr x, y;\n+{\n+    if (is_nil(x)) {\n+        return(y);\n+    } else {\n+        return( gcj_reverse1(cdr(x), gcj_cons(car(x), y)) );\n+    }\n+}\n+\n+sexpr gcj_reverse(x)\n+sexpr x;\n+{\n+    return( gcj_reverse1(x, nil) );\n+}\n+\n+sexpr gcj_ints(low, up)\n+int low, up;\n+{\n+    if (low > up) {\n+\treturn(nil);\n+    } else {\n+        return(gcj_cons(gcj_cons(INT_TO_SEXPR(low), nil), gcj_ints(low+1, up)));\n+    }\n+}\n+#endif /* GC_GCJ_SUPPORT */\n+\n+/* To check uncollectable allocation we build lists with disguised cdr\t*/\n+/* pointers, and make sure they don't go away.\t\t\t\t*/\n+sexpr uncollectable_ints(low, up)\n+int low, up;\n+{\n+    if (low > up) {\n+\treturn(nil);\n+    } else {\n+        return(small_cons_uncollectable(small_cons(INT_TO_SEXPR(low), nil),\n+               uncollectable_ints(low+1, up)));\n+    }\n+}\n+\n+void check_ints(list, low, up)\n+sexpr list;\n+int low, up;\n+{\n+    if ((int)(GC_word)(car(car(list))) != low) {\n+        (void)GC_printf0(\n+           \"List reversal produced incorrect list - collector is broken\\n\");\n+        FAIL;\n+    }\n+    if (low == up) {\n+        if (cdr(list) != nil) {\n+           (void)GC_printf0(\"List too long - collector is broken\\n\");\n+           FAIL;\n+        }\n+    } else {\n+        check_ints(cdr(list), low+1, up);\n+    }\n+}\n+\n+# define UNCOLLECTABLE_CDR(x) (sexpr)(~(unsigned long)(cdr(x)))\n+\n+void check_uncollectable_ints(list, low, up)\n+sexpr list;\n+int low, up;\n+{\n+    if ((int)(GC_word)(car(car(list))) != low) {\n+        (void)GC_printf0(\n+           \"Uncollectable list corrupted - collector is broken\\n\");\n+        FAIL;\n+    }\n+    if (low == up) {\n+        if (UNCOLLECTABLE_CDR(list) != nil) {\n+           (void)GC_printf0(\"Uncollectable list too long - collector is broken\\n\");\n+           FAIL;\n+        }\n+    } else {\n+        check_uncollectable_ints(UNCOLLECTABLE_CDR(list), low+1, up);\n+    }\n+}\n+\n+/* Not used, but useful for debugging: */\n+void print_int_list(x)\n+sexpr x;\n+{\n+    if (is_nil(x)) {\n+        (void)GC_printf0(\"NIL\\n\");\n+    } else {\n+        (void)GC_printf1(\"(%ld)\", (long)(car(car(x))));\n+        if (!is_nil(cdr(x))) {\n+            (void)GC_printf0(\", \");\n+            (void)print_int_list(cdr(x));\n+        } else {\n+            (void)GC_printf0(\"\\n\");\n+        }\n+    }\n+}\n+\n+/* Try to force a to be strangely aligned */\n+struct {\n+  char dummy;\n+  sexpr aa;\n+} A;\n+#define a A.aa\n+\n+/*\n+ * A tiny list reversal test to check thread creation.\n+ */\n+#ifdef THREADS\n+\n+# ifdef WIN32_THREADS\n+    unsigned __stdcall tiny_reverse_test(void * arg)\n+# else\n+    void * tiny_reverse_test(void * arg)\n+# endif\n+{\n+    check_ints(reverse(reverse(ints(1,10))), 1, 10);\n+    return 0;\n+}\n+\n+# if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+     || defined(SOLARIS_PTHREADS) || defined(HPUX_THREADS)\n+    void fork_a_thread()\n+    {\n+      pthread_t t;\n+      int code;\n+      if ((code = pthread_create(&t, 0, tiny_reverse_test, 0)) != 0) {\n+    \t(void)GC_printf1(\"Small thread creation failed %lu\\n\",\n+\t\t         (unsigned long)code);\n+    \tFAIL;\n+      }\n+      if ((code = pthread_join(t, 0)) != 0) {\n+        (void)GC_printf1(\"Small thread join failed %lu\\n\",\n+\t(unsigned long)code);\n+        FAIL;\n+      }\n+    }\n+\n+# elif defined(WIN32_THREADS)\n+    void fork_a_thread()\n+    {\n+  \tunsigned thread_id;\n+\tHANDLE h;\n+    \th = GC_CreateThread(NULL, 0, tiny_reverse_test, 0, 0, &thread_id);\n+        if (h == (HANDLE)NULL) {\n+            (void)GC_printf1(\"Small thread creation failed %lu\\n\",\n+\t\t\t     (unsigned long)GetLastError());\n+      \t    FAIL;\n+        }\n+    \tif (WaitForSingleObject(h, INFINITE) != WAIT_OBJECT_0) {\n+      \t    (void)GC_printf1(\"Small thread wait failed %lu\\n\",\n+\t\t\t     (unsigned long)GetLastError());\n+      \t    FAIL;\n+    \t}\n+    }\n+\n+/* # elif defined(SOLARIS_THREADS) */\n+\n+# else\n+\n+#   define fork_a_thread()\n+\n+# endif\n+\n+#else\n+\n+# define fork_a_thread()\n+\n+#endif \n+\n+/*\n+ * Repeatedly reverse lists built out of very different sized cons cells.\n+ * Check that we didn't lose anything.\n+ */\n+void reverse_test()\n+{\n+    int i;\n+    sexpr b;\n+    sexpr c;\n+    sexpr d;\n+    sexpr e;\n+    sexpr *f, *g, *h;\n+#   if defined(MSWIN32) || defined(MACOS)\n+      /* Win32S only allows 128K stacks */\n+#     define BIG 1000\n+#   else\n+#     if defined PCR\n+\t/* PCR default stack is 100K.  Stack frames are up to 120 bytes. */\n+#\tdefine BIG 700\n+#     else\n+#\tif defined MSWINCE\n+\t  /* WinCE only allows 64K stacks */\n+#\t  define BIG 500\n+#\telse\n+#\t  if defined(OSF1)\n+\t    /* OSF has limited stack space by default, and large frames. */\n+#           define BIG 200\n+#\t  else\n+#           define BIG 4500\n+#\t  endif\n+#\tendif\n+#     endif\n+#   endif\n+\n+    A.dummy = 17;\n+    a = ints(1, 49);\n+    b = ints(1, 50);\n+    c = ints(1, BIG);\n+    d = uncollectable_ints(1, 100);\n+    e = uncollectable_ints(1, 1);\n+    /* Check that realloc updates object descriptors correctly */\n+    collectable_count++;\n+    f = (sexpr *)GC_MALLOC(4 * sizeof(sexpr));\n+    realloc_count++;\n+    f = (sexpr *)GC_REALLOC((GC_PTR)f, 6 * sizeof(sexpr));\n+    f[5] = ints(1,17);\n+    collectable_count++;\n+    g = (sexpr *)GC_MALLOC(513 * sizeof(sexpr));\n+    realloc_count++;\n+    g = (sexpr *)GC_REALLOC((GC_PTR)g, 800 * sizeof(sexpr));\n+    g[799] = ints(1,18);\n+    collectable_count++;\n+    h = (sexpr *)GC_MALLOC(1025 * sizeof(sexpr));\n+    realloc_count++;\n+    h = (sexpr *)GC_REALLOC((GC_PTR)h, 2000 * sizeof(sexpr));\n+#   ifdef GC_GCJ_SUPPORT\n+      h[1999] = gcj_ints(1,200);\n+      h[1999] = gcj_reverse(h[1999]);\n+#   else\n+      h[1999] = ints(1,200);\n+#   endif\n+    /* Try to force some collections and reuse of small list elements */\n+      for (i = 0; i < 10; i++) {\n+        (void)ints(1, BIG);\n+      }\n+    /* Superficially test interior pointer recognition on stack */\n+      c = (sexpr)((char *)c + sizeof(char *));\n+      d = (sexpr)((char *)d + sizeof(char *));\n+\n+#   ifdef __STDC__\n+        GC_FREE((void *)e);\n+#   else\n+        GC_FREE((char *)e);\n+#   endif\n+    check_ints(b,1,50);\n+    check_ints(a,1,49);\n+    for (i = 0; i < 50; i++) {\n+        check_ints(b,1,50);\n+        b = reverse(reverse(b));\n+    }\n+    check_ints(b,1,50);\n+    check_ints(a,1,49);\n+    for (i = 0; i < 60; i++) {\n+\tif (i % 10 == 0) fork_a_thread();\n+    \t/* This maintains the invariant that a always points to a list of */\n+    \t/* 49 integers.  Thus this is thread safe without locks,\t  */\n+    \t/* assuming atomic pointer assignments.\t\t\t\t  */\n+        a = reverse(reverse(a));\n+#\tif !defined(AT_END) && !defined(THREADS)\n+\t  /* This is not thread safe, since realloc explicitly deallocates */\n+          if (i & 1) {\n+            a = (sexpr)GC_REALLOC((GC_PTR)a, 500);\n+          } else {\n+            a = (sexpr)GC_REALLOC((GC_PTR)a, 8200);\n+          }\n+#\tendif\n+    }\n+    check_ints(a,1,49);\n+    check_ints(b,1,50);\n+    c = (sexpr)((char *)c - sizeof(char *));\n+    d = (sexpr)((char *)d - sizeof(char *));\n+    check_ints(c,1,BIG);\n+    check_uncollectable_ints(d, 1, 100);\n+    check_ints(f[5], 1,17);\n+    check_ints(g[799], 1,18);\n+#   ifdef GC_GCJ_SUPPORT\n+      h[1999] = gcj_reverse(h[1999]);\n+#   endif\n+    check_ints(h[1999], 1,200);\n+#   ifndef THREADS\n+\ta = 0;\n+#   endif  \n+    b = c = 0;\n+}\n+\n+/*\n+ * The rest of this builds balanced binary trees, checks that they don't\n+ * disappear, and tests finalization.\n+ */\n+typedef struct treenode {\n+    int level;\n+    struct treenode * lchild;\n+    struct treenode * rchild;\n+} tn;\n+\n+int finalizable_count = 0;\n+int finalized_count = 0;\n+VOLATILE int dropped_something = 0;\n+\n+# ifdef __STDC__\n+  void finalizer(void * obj, void * client_data)\n+# else\n+  void finalizer(obj, client_data)\n+  char * obj;\n+  char * client_data;\n+# endif\n+{\n+  tn * t = (tn *)obj;\n+\n+# ifdef PCR\n+     PCR_ThCrSec_EnterSys();\n+# endif\n+# ifdef SOLARIS_THREADS\n+    static mutex_t incr_lock;\n+    mutex_lock(&incr_lock);\n+# endif\n+# if  defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+    static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n+    pthread_mutex_lock(&incr_lock);\n+# endif\n+# ifdef WIN32_THREADS\n+    EnterCriticalSection(&incr_cs);\n+# endif\n+  if ((int)(GC_word)client_data != t -> level) {\n+     (void)GC_printf0(\"Wrong finalization data - collector is broken\\n\");\n+     FAIL;\n+  }\n+  finalized_count++;\n+# ifdef PCR\n+    PCR_ThCrSec_ExitSys();\n+# endif\n+# ifdef SOLARIS_THREADS\n+    mutex_unlock(&incr_lock);\n+# endif\n+# if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+    pthread_mutex_unlock(&incr_lock);\n+# endif\n+# ifdef WIN32_THREADS\n+    LeaveCriticalSection(&incr_cs);\n+# endif\n+}\n+\n+size_t counter = 0;\n+\n+# define MAX_FINALIZED 8000\n+\n+# if !defined(MACOS)\n+  GC_FAR GC_word live_indicators[MAX_FINALIZED] = {0};\n+#else\n+  /* Too big for THINK_C. have to allocate it dynamically. */\n+  GC_word *live_indicators = 0;\n+#endif\n+\n+int live_indicators_count = 0;\n+\n+tn * mktree(n)\n+int n;\n+{\n+#   ifdef THREAD_LOCAL_ALLOC\n+      tn * result = (tn *)GC_LOCAL_MALLOC(sizeof(tn));\n+#   else\n+      tn * result = (tn *)GC_MALLOC(sizeof(tn));\n+#   endif\n+    \n+    collectable_count++;\n+#   if defined(MACOS)\n+\t/* get around static data limitations. */\n+\tif (!live_indicators)\n+\t\tlive_indicators =\n+\t\t    (GC_word*)NewPtrClear(MAX_FINALIZED * sizeof(GC_word));\n+\tif (!live_indicators) {\n+          (void)GC_printf0(\"Out of memory\\n\");\n+          exit(1);\n+        }\n+#   endif\n+    if (n == 0) return(0);\n+    if (result == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    result -> level = n;\n+    result -> lchild = mktree(n-1);\n+    result -> rchild = mktree(n-1);\n+    if (counter++ % 17 == 0 && n >= 2) {\n+        tn * tmp = result -> lchild -> rchild;\n+        \n+        result -> lchild -> rchild = result -> rchild -> lchild;\n+        result -> rchild -> lchild = tmp;\n+    }\n+    if (counter++ % 119 == 0) {\n+        int my_index;\n+        \n+        {\n+#\t  ifdef PCR\n+ \t    PCR_ThCrSec_EnterSys();\n+#\t  endif\n+#\t  ifdef SOLARIS_THREADS\n+\t    static mutex_t incr_lock;\n+\t    mutex_lock(&incr_lock);\n+#\t  endif\n+#         if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+\t     || defined(HPUX_THREADS)\n+            static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n+            pthread_mutex_lock(&incr_lock);\n+#         endif\n+#         ifdef WIN32_THREADS\n+            EnterCriticalSection(&incr_cs);\n+#         endif\n+\t\t/* Losing a count here causes erroneous report of failure. */\n+          finalizable_count++;\n+          my_index = live_indicators_count++;\n+#\t  ifdef PCR\n+ \t    PCR_ThCrSec_ExitSys();\n+#\t  endif\n+#\t  ifdef SOLARIS_THREADS\n+\t    mutex_unlock(&incr_lock);\n+#\t  endif\n+#\t  if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+\t     || defined(HPUX_THREADS)\n+\t    pthread_mutex_unlock(&incr_lock);\n+#\t  endif\n+#         ifdef WIN32_THREADS\n+            LeaveCriticalSection(&incr_cs);\n+#         endif\n+\t}\n+\n+        GC_REGISTER_FINALIZER((GC_PTR)result, finalizer, (GC_PTR)(GC_word)n,\n+        \t\t      (GC_finalization_proc *)0, (GC_PTR *)0);\n+        if (my_index >= MAX_FINALIZED) {\n+\t\tGC_printf0(\"live_indicators overflowed\\n\");\n+\t\tFAIL;\n+\t}\n+        live_indicators[my_index] = 13;\n+        if (GC_GENERAL_REGISTER_DISAPPEARING_LINK(\n+         \t(GC_PTR *)(&(live_indicators[my_index])),\n+         \t(GC_PTR)result) != 0) {\n+         \tGC_printf0(\"GC_general_register_disappearing_link failed\\n\");\n+         \tFAIL;\n+        }\n+        if (GC_unregister_disappearing_link(\n+         \t(GC_PTR *)\n+         \t   (&(live_indicators[my_index]))) == 0) {\n+         \tGC_printf0(\"GC_unregister_disappearing_link failed\\n\");\n+         \tFAIL;\n+        }\n+        if (GC_GENERAL_REGISTER_DISAPPEARING_LINK(\n+         \t(GC_PTR *)(&(live_indicators[my_index])),\n+         \t(GC_PTR)result) != 0) {\n+         \tGC_printf0(\"GC_general_register_disappearing_link failed 2\\n\");\n+         \tFAIL;\n+        }\n+    }\n+    return(result);\n+}\n+\n+void chktree(t,n)\n+tn *t;\n+int n;\n+{\n+    if (n == 0 && t != 0) {\n+        (void)GC_printf0(\"Clobbered a leaf - collector is broken\\n\");\n+        FAIL;\n+    }\n+    if (n == 0) return;\n+    if (t -> level != n) {\n+        (void)GC_printf1(\"Lost a node at level %lu - collector is broken\\n\",\n+        \t\t (unsigned long)n);\n+        FAIL;\n+    }\n+    if (counter++ % 373 == 0) {\n+\tcollectable_count++;\n+\t(void) GC_MALLOC(counter%5001);\n+    }\n+    chktree(t -> lchild, n-1);\n+    if (counter++ % 73 == 0) {\n+\tcollectable_count++;\n+\t(void) GC_MALLOC(counter%373);\n+    }\n+    chktree(t -> rchild, n-1);\n+}\n+\n+# if defined(SOLARIS_THREADS) && !defined(_SOLARIS_PTHREADS)\n+thread_key_t fl_key;\n+\n+void * alloc8bytes()\n+{\n+# if defined(SMALL_CONFIG) || defined(GC_DEBUG)\n+    collectable_count++;\n+    return(GC_MALLOC(8));\n+# else\n+    void ** my_free_list_ptr;\n+    void * my_free_list;\n+    \n+    if (thr_getspecific(fl_key, (void **)(&my_free_list_ptr)) != 0) {\n+    \t(void)GC_printf0(\"thr_getspecific failed\\n\");\n+    \tFAIL;\n+    }\n+    if (my_free_list_ptr == 0) {\n+        uncollectable_count++;\n+        my_free_list_ptr = GC_NEW_UNCOLLECTABLE(void *);\n+        if (thr_setspecific(fl_key, my_free_list_ptr) != 0) {\n+    \t    (void)GC_printf0(\"thr_setspecific failed\\n\");\n+    \t    FAIL;\n+        }\n+    }\n+    my_free_list = *my_free_list_ptr;\n+    if (my_free_list == 0) {\n+        collectable_count++;\n+        my_free_list = GC_malloc_many(8);\n+        if (my_free_list == 0) {\n+            (void)GC_printf0(\"alloc8bytes out of memory\\n\");\n+    \t    FAIL;\n+        }\n+    }\n+    *my_free_list_ptr = GC_NEXT(my_free_list);\n+    GC_NEXT(my_free_list) = 0;\n+    return(my_free_list);\n+# endif\n+}\n+\n+#else\n+\n+# if defined(GC_SOLARIS_PTHREADS) || defined(GC_IRIX_THREADS) \\\n+     || defined(GC_LINUX_THREADS) || defined(GC_HPUX_THREADS) \\\n+     || defined(GC_SOLARIS_THREADS)\n+pthread_key_t fl_key;\n+\n+void * alloc8bytes()\n+{\n+# if defined(SMALL_CONFIG) || defined(GC_DEBUG)\n+    collectable_count++;\n+    return(GC_MALLOC(8));\n+# else\n+    void ** my_free_list_ptr;\n+    void * my_free_list;\n+    \n+    my_free_list_ptr = (void **)pthread_getspecific(fl_key);\n+    if (my_free_list_ptr == 0) {\n+        uncollectable_count++;\n+        my_free_list_ptr = GC_NEW_UNCOLLECTABLE(void *);\n+        if (pthread_setspecific(fl_key, my_free_list_ptr) != 0) {\n+    \t    (void)GC_printf0(\"pthread_setspecific failed\\n\");\n+    \t    FAIL;\n+        }\n+    }\n+    my_free_list = *my_free_list_ptr;\n+    if (my_free_list == 0) {\n+        my_free_list = GC_malloc_many(8);\n+        if (my_free_list == 0) {\n+            (void)GC_printf0(\"alloc8bytes out of memory\\n\");\n+    \t    FAIL;\n+        }\n+    }\n+    *my_free_list_ptr = GC_NEXT(my_free_list);\n+    GC_NEXT(my_free_list) = 0;\n+    collectable_count++;\n+    return(my_free_list);\n+# endif\n+}\n+\n+# else\n+#   define alloc8bytes() GC_MALLOC_ATOMIC(8)\n+# endif\n+#endif\n+\n+void alloc_small(n)\n+int n;\n+{\n+    register int i;\n+    \n+    for (i = 0; i < n; i += 8) {\n+        atomic_count++;\n+        if (alloc8bytes() == 0) {\n+            (void)GC_printf0(\"Out of memory\\n\");\n+            FAIL;\n+        }\n+    }\n+}\n+\n+# if defined(THREADS) && defined(GC_DEBUG)\n+#   ifdef VERY_SMALL_CONFIG\n+#     define TREE_HEIGHT 12\n+#   else\n+#     define TREE_HEIGHT 15\n+#   endif\n+# else\n+#   ifdef VERY_SMALL_CONFIG\n+#     define TREE_HEIGHT 13\n+#   else\n+#     define TREE_HEIGHT 16\n+#   endif\n+# endif\n+void tree_test()\n+{\n+    tn * root;\n+    register int i;\n+    \n+    root = mktree(TREE_HEIGHT);\n+#   ifndef VERY_SMALL_CONFIG\n+      alloc_small(5000000);\n+#   endif\n+    chktree(root, TREE_HEIGHT);\n+    if (finalized_count && ! dropped_something) {\n+        (void)GC_printf0(\"Premature finalization - collector is broken\\n\");\n+        FAIL;\n+    }\n+    dropped_something = 1;\n+    GC_noop(root);\t/* Root needs to remain live until\t*/\n+    \t\t\t/* dropped_something is set.\t\t*/\n+    root = mktree(TREE_HEIGHT);\n+    chktree(root, TREE_HEIGHT);\n+    for (i = TREE_HEIGHT; i >= 0; i--) {\n+        root = mktree(i);\n+        chktree(root, i);\n+    }\n+#   ifndef VERY_SMALL_CONFIG\n+      alloc_small(5000000);\n+#   endif\n+}\n+\n+unsigned n_tests = 0;\n+\n+GC_word bm_huge[10] = {\n+    0xffffffff,\n+    0xffffffff,\n+    0xffffffff,\n+    0xffffffff,\n+    0xffffffff,\n+    0xffffffff,\n+    0xffffffff,\n+    0xffffffff,\n+    0xffffffff,\n+    0x00ffffff,\n+};\n+\n+/* A very simple test of explicitly typed allocation\t*/\n+void typed_test()\n+{\n+    GC_word * old, * new;\n+    GC_word bm3 = 0x3;\n+    GC_word bm2 = 0x2;\n+    GC_word bm_large = 0xf7ff7fff;\n+    GC_descr d1 = GC_make_descriptor(&bm3, 2);\n+    GC_descr d2 = GC_make_descriptor(&bm2, 2);\n+#   ifndef LINT\n+      GC_descr dummy = GC_make_descriptor(&bm_large, 32);\n+#   endif\n+    GC_descr d3 = GC_make_descriptor(&bm_large, 32);\n+    GC_descr d4 = GC_make_descriptor(bm_huge, 320);\n+    GC_word * x = (GC_word *)GC_malloc_explicitly_typed(2000, d4);\n+    register int i;\n+    \n+    collectable_count++;\n+    old = 0;\n+    for (i = 0; i < 4000; i++) {\n+\tcollectable_count++;\n+        new = (GC_word *) GC_malloc_explicitly_typed(4 * sizeof(GC_word), d1);\n+        if (0 != new[0] || 0 != new[1]) {\n+\t    GC_printf0(\"Bad initialization by GC_malloc_explicitly_typed\\n\");\n+\t    FAIL;\n+\t}\n+        new[0] = 17;\n+        new[1] = (GC_word)old;\n+        old = new;\n+\tcollectable_count++;\n+        new = (GC_word *) GC_malloc_explicitly_typed(4 * sizeof(GC_word), d2);\n+        new[0] = 17;\n+        new[1] = (GC_word)old;\n+        old = new;\n+\tcollectable_count++;\n+        new = (GC_word *) GC_malloc_explicitly_typed(33 * sizeof(GC_word), d3);\n+        new[0] = 17;\n+        new[1] = (GC_word)old;\n+        old = new;\n+\tcollectable_count++;\n+        new = (GC_word *) GC_calloc_explicitly_typed(4, 2 * sizeof(GC_word),\n+        \t\t\t\t\t     d1);\n+        new[0] = 17;\n+        new[1] = (GC_word)old;\n+        old = new;\n+\tcollectable_count++;\n+        if (i & 0xff) {\n+          new = (GC_word *) GC_calloc_explicitly_typed(7, 3 * sizeof(GC_word),\n+        \t\t\t\t\t     d2);\n+        } else {\n+          new = (GC_word *) GC_calloc_explicitly_typed(1001,\n+          \t\t\t\t\t       3 * sizeof(GC_word),\n+        \t\t\t\t\t       d2);\n+          if (0 != new[0] || 0 != new[1]) {\n+\t    GC_printf0(\"Bad initialization by GC_malloc_explicitly_typed\\n\");\n+\t    FAIL;\n+\t  }\n+        }\n+        new[0] = 17;\n+        new[1] = (GC_word)old;\n+        old = new;\n+    }\n+    for (i = 0; i < 20000; i++) {\n+        if (new[0] != 17) {\n+            (void)GC_printf1(\"typed alloc failed at %lu\\n\",\n+            \t\t     (unsigned long)i);\n+            FAIL;\n+        }\n+        new[0] = 0;\n+        old = new;\n+        new = (GC_word *)(old[1]);\n+    }\n+    GC_gcollect();\n+    GC_noop(x);\n+}\n+\n+int fail_count = 0;\n+\n+#ifndef __STDC__\n+/*ARGSUSED*/\n+void fail_proc1(x)\n+GC_PTR x;\n+{\n+    fail_count++;\n+}\n+\n+#else\n+\n+/*ARGSUSED*/\n+void fail_proc1(GC_PTR x)\n+{\n+    fail_count++;\n+}   \n+\n+#endif /* __STDC__ */\n+\n+#ifdef THREADS\n+#   define TEST_FAIL_COUNT(n) 1\n+#else \n+#   define TEST_FAIL_COUNT(n) (fail_count >= (n))\n+#endif\n+\n+void run_one_test()\n+{\n+    char *x;\n+#   ifdef LINT\n+    \tchar *y = 0;\n+#   else\n+    \tchar *y = (char *)(size_t)fail_proc1;\n+#   endif\n+    DCL_LOCK_STATE;\n+    \n+#   ifdef FIND_LEAK\n+\t(void)GC_printf0(\n+\t\t\"This test program is not designed for leak detection mode\\n\");\n+\t(void)GC_printf0(\"Expect lots of problems.\\n\");\n+#   endif\n+    GC_FREE(0);\n+#   ifndef DBG_HDRS_ALL\n+      collectable_count += 3;\n+      if (GC_size(GC_malloc(7)) != 8 &&\n+\t  GC_size(GC_malloc(7)) != MIN_WORDS * sizeof(GC_word)\n+\t|| GC_size(GC_malloc(15)) != 16) {\n+\t    (void)GC_printf0(\"GC_size produced unexpected results\\n\");\n+\t    FAIL;\n+      }\n+      collectable_count += 1;\n+      if (GC_size(GC_malloc(0)) != MIN_WORDS * sizeof(GC_word)) {\n+    \t(void)GC_printf1(\"GC_malloc(0) failed: GC_size returns %ld\\n\",\n+\t\t\t GC_size(GC_malloc(0)));\n+\t    FAIL;\n+      }\n+      collectable_count += 1;\n+      if (GC_size(GC_malloc_uncollectable(0)) != MIN_WORDS * sizeof(GC_word)) {\n+    \t(void)GC_printf0(\"GC_malloc_uncollectable(0) failed\\n\");\n+\t    FAIL;\n+      }\n+      GC_is_valid_displacement_print_proc = fail_proc1;\n+      GC_is_visible_print_proc = fail_proc1;\n+      collectable_count += 1;\n+      x = GC_malloc(16);\n+      if (GC_base(x + 13) != x) {\n+    \t(void)GC_printf0(\"GC_base(heap ptr) produced incorrect result\\n\");\n+\tFAIL;\n+      }\n+#     ifndef PCR\n+        if (GC_base(y) != 0) {\n+    \t  (void)GC_printf0(\"GC_base(fn_ptr) produced incorrect result\\n\");\n+\t  FAIL;\n+        }\n+#     endif\n+      if (GC_same_obj(x+5, x) != x + 5) {\n+    \t(void)GC_printf0(\"GC_same_obj produced incorrect result\\n\");\n+\tFAIL;\n+      }\n+      if (GC_is_visible(y) != y || GC_is_visible(x) != x) {\n+    \t(void)GC_printf0(\"GC_is_visible produced incorrect result\\n\");\n+\tFAIL;\n+      }\n+      if (!TEST_FAIL_COUNT(1)) {\n+#\tif!(defined(RS6000) || defined(POWERPC) || defined(IA64))\n+\t  /* ON RS6000s function pointers point to a descriptor in the\t*/\n+\t  /* data segment, so there should have been no failures.\t*/\n+    \t  (void)GC_printf0(\"GC_is_visible produced wrong failure indication\\n\");\n+    \t  FAIL;\n+#\tendif\n+      }\n+      if (GC_is_valid_displacement(y) != y\n+        || GC_is_valid_displacement(x) != x\n+        || GC_is_valid_displacement(x + 3) != x + 3) {\n+    \t(void)GC_printf0(\n+    \t\t\"GC_is_valid_displacement produced incorrect result\\n\");\n+\tFAIL;\n+      }\n+#     ifndef ALL_INTERIOR_POINTERS\n+#      if defined(RS6000) || defined(POWERPC)\n+        if (!TEST_FAIL_COUNT(1)) {\n+#      else\n+        if (GC_all_interior_pointers && !TEST_FAIL_COUNT(1)\n+\t    || !GC_all_interior_pointers && !TEST_FAIL_COUNT(2)) {\n+#      endif\n+    \t  (void)GC_printf0(\"GC_is_valid_displacement produced wrong failure indication\\n\");\n+    \t  FAIL;\n+        }\n+#     endif\n+#   endif /* DBG_HDRS_ALL */\n+    /* Test floating point alignment */\n+   collectable_count += 2;\n+\t*(double *)GC_MALLOC(sizeof(double)) = 1.0;\n+\t*(double *)GC_MALLOC(sizeof(double)) = 1.0;\n+#   ifdef GC_GCJ_SUPPORT\n+      GC_REGISTER_DISPLACEMENT(sizeof(struct fake_vtable *));\n+      GC_init_gcj_malloc(0, (void *)fake_gcj_mark_proc);\n+#   endif\n+    /* Repeated list reversal test. */\n+\treverse_test();\n+#   ifdef PRINTSTATS\n+\tGC_printf0(\"-------------Finished reverse_test\\n\");\n+#   endif\n+#   ifndef DBG_HDRS_ALL\n+      typed_test();\n+#     ifdef PRINTSTATS\n+\tGC_printf0(\"-------------Finished typed_test\\n\");\n+#     endif\n+#   endif /* DBG_HDRS_ALL */\n+    tree_test();\n+    LOCK();\n+    n_tests++;\n+    UNLOCK();\n+    /* GC_printf1(\"Finished %x\\n\", pthread_self()); */\n+}\n+\n+void check_heap_stats()\n+{\n+    unsigned long max_heap_sz;\n+    register int i;\n+    int still_live;\n+    int late_finalize_count = 0;\n+    \n+#   ifdef VERY_SMALL_CONFIG\n+    /* these are something of a guess */\n+    if (sizeof(char *) > 4) {\n+        max_heap_sz = 4500000;\n+    } else {\n+    \tmax_heap_sz = 2800000;\n+    }\n+#   else\n+    if (sizeof(char *) > 4) {\n+        max_heap_sz = 15000000;\n+    } else {\n+    \tmax_heap_sz = 11000000;\n+    }\n+#   endif\n+#   ifdef GC_DEBUG\n+\tmax_heap_sz *= 2;\n+#       ifdef SAVE_CALL_CHAIN\n+\t    max_heap_sz *= 3;\n+#           ifdef SAVE_CALL_COUNT\n+\t\tmax_heap_sz *= SAVE_CALL_COUNT/4;\n+#\t    endif\n+#       endif\n+#   endif\n+    /* Garbage collect repeatedly so that all inaccessible objects\t*/\n+    /* can be finalized.\t\t\t\t\t\t*/\n+      while (GC_collect_a_little()) { }\n+      for (i = 0; i < 16; i++) {\n+        GC_gcollect();\n+        late_finalize_count += GC_invoke_finalizers();\n+      }\n+    (void)GC_printf1(\"Completed %lu tests\\n\", (unsigned long)n_tests);\n+    (void)GC_printf1(\"Allocated %lu collectable objects\\n\", (unsigned long)collectable_count);\n+    (void)GC_printf1(\"Allocated %lu uncollectable objects\\n\", (unsigned long)uncollectable_count);\n+    (void)GC_printf1(\"Allocated %lu atomic objects\\n\", (unsigned long)atomic_count);\n+    (void)GC_printf1(\"Allocated %lu stubborn objects\\n\", (unsigned long)stubborn_count);\n+    (void)GC_printf2(\"Finalized %lu/%lu objects - \",\n+    \t\t     (unsigned long)finalized_count,\n+    \t\t     (unsigned long)finalizable_count);\n+#   ifdef FINALIZE_ON_DEMAND\n+\tif (finalized_count != late_finalize_count) {\n+            (void)GC_printf0(\"Demand finalization error\\n\");\n+\t    FAIL;\n+\t}\n+#   endif\n+    if (finalized_count > finalizable_count\n+        || finalized_count < finalizable_count/2) {\n+        (void)GC_printf0(\"finalization is probably broken\\n\");\n+        FAIL;\n+    } else {\n+        (void)GC_printf0(\"finalization is probably ok\\n\");\n+    }\n+    still_live = 0;\n+    for (i = 0; i < MAX_FINALIZED; i++) {\n+    \tif (live_indicators[i] != 0) {\n+    \t    still_live++;\n+    \t}\n+    }\n+    i = finalizable_count - finalized_count - still_live;\n+    if (0 != i) {\n+        (void)GC_printf2\n+            (\"%lu disappearing links remain and %ld more objects were not finalized\\n\",\n+             (unsigned long) still_live, (long)i);\n+        if (i > 10) {\n+\t    GC_printf0(\"\\tVery suspicious!\\n\");\n+\t} else {\n+\t    GC_printf0(\"\\tSlightly suspicious, but probably OK.\\n\");\n+\t}\n+    }\n+    (void)GC_printf1(\"Total number of bytes allocated is %lu\\n\",\n+    \t\t(unsigned long)\n+    \t           WORDS_TO_BYTES(GC_words_allocd + GC_words_allocd_before_gc));\n+    (void)GC_printf1(\"Final heap size is %lu bytes\\n\",\n+    \t\t     (unsigned long)GC_get_heap_size());\n+    if (WORDS_TO_BYTES(GC_words_allocd + GC_words_allocd_before_gc)\n+#   ifdef VERY_SMALL_CONFIG\n+        < 2700000*n_tests) {\n+#   else\n+        < 33500000*n_tests) {\n+#   endif\n+        (void)GC_printf0(\"Incorrect execution - missed some allocations\\n\");\n+        FAIL;\n+    }\n+    if (GC_get_heap_size() > max_heap_sz*n_tests) {\n+        (void)GC_printf0(\"Unexpected heap growth - collector may be broken\\n\");\n+        FAIL;\n+    }\n+    (void)GC_printf0(\"Collector appears to work\\n\");\n+}\n+\n+#if defined(MACOS)\n+void SetMinimumStack(long minSize)\n+{\n+\tlong newApplLimit;\n+\n+\tif (minSize > LMGetDefltStack())\n+\t{\n+\t\tnewApplLimit = (long) GetApplLimit()\n+\t\t\t\t- (minSize - LMGetDefltStack());\n+\t\tSetApplLimit((Ptr) newApplLimit);\n+\t\tMaxApplZone();\n+\t}\n+}\n+\n+#define cMinStackSpace (512L * 1024L)\n+\n+#endif\n+\n+#ifdef __STDC__\n+    void warn_proc(char *msg, GC_word p)\n+#else\n+    void warn_proc(msg, p)\n+    char *msg;\n+    GC_word p;\n+#endif\n+{\n+    GC_printf1(msg, (unsigned long)p);\n+    /*FAIL;*/\n+}\n+\n+\n+#if !defined(PCR) && !defined(GC_SOLARIS_THREADS) \\\n+    && !defined(GC_WIN32_THREADS) \\\n+    && !defined(GC_IRIX_THREADS) && !defined(GC_LINUX_THREADS) \\\n+    && !defined(GC_HPUX_THREADS) || defined(LINT)\n+#if defined(MSWIN32) && !defined(__MINGW32__)\n+  int APIENTRY WinMain(HINSTANCE instance, HINSTANCE prev, LPTSTR cmd, int n)\n+#else\n+  int main()\n+#endif\n+{\n+#   if defined(DJGPP)\n+\tint dummy;\n+#   endif\n+    n_tests = 0;\n+    \n+#   if defined(DJGPP)\n+\t/* No good way to determine stack base from library; do it */\n+\t/* manually on this platform.\t\t\t\t   */\n+    \tGC_stackbottom = (GC_PTR)(&dummy);\n+#   endif\n+#   if defined(MACOS)\n+\t/* Make sure we have lots and lots of stack space. \t*/\n+\tSetMinimumStack(cMinStackSpace);\n+\t/* Cheat and let stdio initialize toolbox for us.\t*/\n+\tprintf(\"Testing GC Macintosh port.\\n\");\n+#   endif\n+    GC_INIT();\t/* Only needed if gc is dynamic library.\t*/\n+    (void) GC_set_warn_proc(warn_proc);\n+#   if defined(MPROTECT_VDB) || defined(PROC_VDB)\n+      GC_enable_incremental();\n+      (void) GC_printf0(\"Switched to incremental mode\\n\");\n+#     if defined(MPROTECT_VDB)\n+\t(void)GC_printf0(\"Emulating dirty bits with mprotect/signals\\n\");\n+#     else\n+\t(void)GC_printf0(\"Reading dirty bits from /proc\\n\");\n+#      endif\n+#   endif\n+    run_one_test();\n+    check_heap_stats();\n+#   ifndef MSWINCE\n+    (void)fflush(stdout);\n+#   endif\n+#   ifdef LINT\n+\t/* Entry points we should be testing, but aren't.\t\t   */\n+\t/* Some can be tested by defining GC_DEBUG at the top of this file */\n+\t/* This is a bit SunOS4 specific.\t\t\t\t   */\t\t\t\n+\tGC_noop(GC_expand_hp, GC_add_roots, GC_clear_roots,\n+\t        GC_register_disappearing_link,\n+\t        GC_register_finalizer_ignore_self,\n+\t\tGC_debug_register_displacement,\n+\t        GC_print_obj, GC_debug_change_stubborn,\n+\t        GC_debug_end_stubborn_change, GC_debug_malloc_uncollectable,\n+\t        GC_debug_free, GC_debug_realloc, GC_generic_malloc_words_small,\n+\t        GC_init, GC_make_closure, GC_debug_invoke_finalizer,\n+\t        GC_page_was_ever_dirty, GC_is_fresh,\n+\t\tGC_malloc_ignore_off_page, GC_malloc_atomic_ignore_off_page,\n+\t\tGC_set_max_heap_size, GC_get_bytes_since_gc,\n+\t\tGC_get_total_bytes, GC_pre_incr, GC_post_incr);\n+#   endif\n+#   ifdef MSWIN32\n+      GC_win32_free_heap();\n+#   endif\n+    return(0);\n+}\n+# endif\n+\n+#ifdef GC_WIN32_THREADS\n+\n+unsigned __stdcall thr_run_one_test(void *arg)\n+{\n+  run_one_test();\n+  return 0;\n+}\n+\n+#ifdef MSWINCE\n+HANDLE win_created_h;\n+HWND win_handle;\n+\n+LRESULT CALLBACK window_proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n+{\n+  LRESULT ret = 0;\n+  switch (uMsg) {\n+    case WM_HIBERNATE:\n+      GC_printf0(\"Received WM_HIBERNATE, calling GC_gcollect\\n\");\n+      GC_gcollect();\n+      break;\n+    case WM_CLOSE:\n+      GC_printf0(\"Received WM_CLOSE, closing window\\n\");\n+      DestroyWindow(hwnd);\n+      break;\n+    case WM_DESTROY:\n+      PostQuitMessage(0);\n+      break;\n+    default:\n+      ret = DefWindowProc(hwnd, uMsg, wParam, lParam);\n+      break;\n+  }\n+  return ret;\n+}\n+\n+unsigned __stdcall thr_window(void *arg)\n+{\n+  WNDCLASS win_class = {\n+    CS_NOCLOSE,\n+    window_proc,\n+    0,\n+    0,\n+    GetModuleHandle(NULL),\n+    NULL,\n+    NULL,\n+    (HBRUSH)(COLOR_APPWORKSPACE+1),\n+    NULL,\n+    L\"GCtestWindow\"\n+  };\n+  MSG msg;\n+\n+  if (!RegisterClass(&win_class))\n+    FAIL;\n+\n+  win_handle = CreateWindowEx(\n+    0,\n+    L\"GCtestWindow\",\n+    L\"GCtest\",\n+    0,\n+    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\n+    NULL,\n+    NULL,\n+    GetModuleHandle(NULL),\n+    NULL);\n+\n+  if (win_handle == NULL)\n+    FAIL;\n+\n+  SetEvent(win_created_h);\n+\n+  ShowWindow(win_handle, SW_SHOW);\n+  UpdateWindow(win_handle);\n+\n+  while (GetMessage(&msg, NULL, 0, 0)) {\n+    TranslateMessage(&msg);\n+    DispatchMessage(&msg);\n+  }\n+\n+  return 0;\n+}\n+#endif\n+\n+#define NTEST 2\n+\n+# ifdef MSWINCE\n+int APIENTRY GC_WinMain(HINSTANCE instance, HINSTANCE prev, LPWSTR cmd, int n)\n+#   else\n+int APIENTRY WinMain(HINSTANCE instance, HINSTANCE prev, LPSTR cmd, int n)\n+# endif\n+{\n+# if NTEST > 0\n+   HANDLE h[NTEST];\n+   int i;\n+# endif\n+# ifdef MSWINCE\n+    HANDLE win_thr_h;\n+# endif\n+  unsigned thread_id;\n+# if 0\n+    GC_enable_incremental();\n+# endif\n+  InitializeCriticalSection(&incr_cs);\n+  (void) GC_set_warn_proc(warn_proc);\n+# ifdef MSWINCE\n+    win_created_h = CreateEvent(NULL, FALSE, FALSE, NULL);\n+    if (win_created_h == (HANDLE)NULL) {\n+      (void)GC_printf1(\"Event creation failed %lu\\n\", (unsigned long)GetLastError());\n+      FAIL;\n+    }\n+    win_thr_h = GC_CreateThread(NULL, 0, thr_window, 0, 0, &thread_id);\n+    if (win_thr_h == (HANDLE)NULL) {\n+      (void)GC_printf1(\"Thread creation failed %lu\\n\", (unsigned long)GetLastError());\n+      FAIL;\n+    }\n+    if (WaitForSingleObject(win_created_h, INFINITE) != WAIT_OBJECT_0)\n+      FAIL;\n+    CloseHandle(win_created_h);\n+# endif\n+# if NTEST > 0\n+   for (i = 0; i < NTEST; i++) {\n+    h[i] = GC_CreateThread(NULL, 0, thr_run_one_test, 0, 0, &thread_id);\n+    if (h[i] == (HANDLE)NULL) {\n+      (void)GC_printf1(\"Thread creation failed %lu\\n\", (unsigned long)GetLastError());\n+      FAIL;\n+    }\n+   }\n+# endif /* NTEST > 0 */\n+  run_one_test();\n+# if NTEST > 0\n+   for (i = 0; i < NTEST; i++) {\n+    if (WaitForSingleObject(h[i], INFINITE) != WAIT_OBJECT_0) {\n+      (void)GC_printf1(\"Thread wait failed %lu\\n\", (unsigned long)GetLastError());\n+      FAIL;\n+    }\n+   }\n+# endif /* NTEST > 0 */\n+# ifdef MSWINCE\n+    PostMessage(win_handle, WM_CLOSE, 0, 0);\n+    if (WaitForSingleObject(win_thr_h, INFINITE) != WAIT_OBJECT_0)\n+      FAIL;\n+# endif\n+  check_heap_stats();\n+  return(0);\n+}\n+\n+#endif /* GC_WIN32_THREADS */\n+\n+\n+#ifdef PCR\n+test()\n+{\n+    PCR_Th_T * th1;\n+    PCR_Th_T * th2;\n+    int code;\n+\n+    n_tests = 0;\n+    /* GC_enable_incremental(); */\n+    (void) GC_set_warn_proc(warn_proc);\n+    th1 = PCR_Th_Fork(run_one_test, 0);\n+    th2 = PCR_Th_Fork(run_one_test, 0);\n+    run_one_test();\n+    if (PCR_Th_T_Join(th1, &code, NIL, PCR_allSigsBlocked, PCR_waitForever)\n+        != PCR_ERes_okay || code != 0) {\n+        (void)GC_printf0(\"Thread 1 failed\\n\");\n+    }\n+    if (PCR_Th_T_Join(th2, &code, NIL, PCR_allSigsBlocked, PCR_waitForever)\n+        != PCR_ERes_okay || code != 0) {\n+        (void)GC_printf0(\"Thread 2 failed\\n\");\n+    }\n+    check_heap_stats();\n+    return(0);\n+}\n+#endif\n+\n+#if defined(GC_SOLARIS_THREADS) || defined(GC_IRIX_THREADS) \\\n+ || defined(GC_HPUX_THREADS) || defined(GC_LINUX_THREADS)\n+void * thr_run_one_test(void * arg)\n+{\n+    run_one_test();\n+    return(0);\n+}\n+\n+#ifdef GC_DEBUG\n+#  define GC_free GC_debug_free\n+#endif\n+\n+#ifdef GC_SOLARIS_THREADS\n+main()\n+{\n+    thread_t th1;\n+    thread_t th2;\n+    int code;\n+\n+    n_tests = 0;\n+    GC_INIT();\t/* Only needed if gc is dynamic library.\t*/\n+    GC_enable_incremental();\n+    (void) GC_set_warn_proc(warn_proc);\n+    if (thr_keycreate(&fl_key, GC_free) != 0) {\n+        (void)GC_printf1(\"Key creation failed %lu\\n\", (unsigned long)code);\n+    \tFAIL;\n+    }\n+    if ((code = thr_create(0, 1024*1024, thr_run_one_test, 0, 0, &th1)) != 0) {\n+    \t(void)GC_printf1(\"Thread 1 creation failed %lu\\n\", (unsigned long)code);\n+    \tFAIL;\n+    }\n+    if ((code = thr_create(0, 1024*1024, thr_run_one_test, 0, THR_NEW_LWP, &th2)) != 0) {\n+    \t(void)GC_printf1(\"Thread 2 creation failed %lu\\n\", (unsigned long)code);\n+    \tFAIL;\n+    }\n+    run_one_test();\n+    if ((code = thr_join(th1, 0, 0)) != 0) {\n+        (void)GC_printf1(\"Thread 1 failed %lu\\n\", (unsigned long)code);\n+        FAIL;\n+    }\n+    if (thr_join(th2, 0, 0) != 0) {\n+        (void)GC_printf1(\"Thread 2 failed %lu\\n\", (unsigned long)code);\n+        FAIL;\n+    }\n+    check_heap_stats();\n+    (void)fflush(stdout);\n+    return(0);\n+}\n+#else /* pthreads */\n+main()\n+{\n+    pthread_t th1;\n+    pthread_t th2;\n+    pthread_attr_t attr;\n+    int code;\n+\n+#   ifdef GC_IRIX_THREADS\n+\t/* Force a larger stack to be preallocated      */\n+\t/* Since the initial cant always grow later.\t*/\n+\t*((volatile char *)&code - 1024*1024) = 0;      /* Require 1 Mb */\n+#   endif /* GC_IRIX_THREADS */\n+    pthread_attr_init(&attr);\n+#   if defined(GC_IRIX_THREADS) || defined(GC_HPUX_THREADS)\n+    \tpthread_attr_setstacksize(&attr, 1000000);\n+#   endif\n+    n_tests = 0;\n+#   if  defined(MPROTECT_VDB) && !defined(PARALLEL_MARK) &&!defined(REDIRECT_MALLOC)\n+    \tGC_enable_incremental();\n+        (void) GC_printf0(\"Switched to incremental mode\\n\");\n+\t(void) GC_printf0(\"Emulating dirty bits with mprotect/signals\\n\");\n+#   endif\n+    (void) GC_set_warn_proc(warn_proc);\n+    if ((code = pthread_key_create(&fl_key, 0)) != 0) {\n+        (void)GC_printf1(\"Key creation failed %lu\\n\", (unsigned long)code);\n+    \tFAIL;\n+    }\n+    if ((code = pthread_create(&th1, &attr, thr_run_one_test, 0)) != 0) {\n+    \t(void)GC_printf1(\"Thread 1 creation failed %lu\\n\", (unsigned long)code);\n+    \tFAIL;\n+    }\n+    if ((code = pthread_create(&th2, &attr, thr_run_one_test, 0)) != 0) {\n+    \t(void)GC_printf1(\"Thread 2 creation failed %lu\\n\", (unsigned long)code);\n+    \tFAIL;\n+    }\n+    run_one_test();\n+    if ((code = pthread_join(th1, 0)) != 0) {\n+        (void)GC_printf1(\"Thread 1 failed %lu\\n\", (unsigned long)code);\n+        FAIL;\n+    }\n+    if (pthread_join(th2, 0) != 0) {\n+        (void)GC_printf1(\"Thread 2 failed %lu\\n\", (unsigned long)code);\n+        FAIL;\n+    }\n+    check_heap_stats();\n+    (void)fflush(stdout);\n+    pthread_attr_destroy(&attr);\n+    GC_printf1(\"Completed %d collections\\n\", GC_gc_no);\n+    return(0);\n+}\n+#endif /* pthreads */\n+#endif /* SOLARIS_THREADS || IRIX_THREADS || LINUX_THREADS || HPUX_THREADS */"}, {"sha": "75fd366860569255a57c0854316b059b537da9cd", "filename": "boehm-gc/tests/test_cpp.cc", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Ftest_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Ftest_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest_cpp.cc?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,277 @@\n+/****************************************************************************\n+Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ \n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ \n+Permission is hereby granted to use or copy this program for any\n+purpose, provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is\n+granted, provided the above notices are retained, and a notice that\n+the code was modified is included with the above copyright notice.\n+****************************************************************************\n+Last modified on Mon Jul 10 21:06:03 PDT 1995 by ellis\n+     modified on December 20, 1994 7:27 pm PST by boehm\n+\n+usage: test_cpp number-of-iterations\n+\n+This program tries to test the specific C++ functionality provided by\n+gc_c++.h that isn't tested by the more general test routines of the\n+collector.\n+\n+A recommended value for number-of-iterations is 10, which will take a\n+few minutes to complete.\n+\n+***************************************************************************/\n+\n+#include \"gc_cpp.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#ifdef __GNUC__\n+#   include \"new_gc_alloc.h\"\n+#else\n+#   include \"gc_alloc.h\"\n+#endif\n+extern \"C\" {\n+#include \"private/gc_priv.h\"\n+}\n+#ifdef MSWIN32\n+#   include <windows.h>\n+#endif\n+#ifdef GC_NAME_CONFLICT\n+#   define USE_GC UseGC\n+    struct foo * GC;\n+#else\n+#   define USE_GC GC\n+#endif\n+\n+\n+#define my_assert( e ) \\\n+    if (! (e)) { \\\n+        GC_printf1( \"Assertion failure in \" __FILE__ \", line %d: \" #e \"\\n\", \\\n+                    __LINE__ ); \\\n+        exit( 1 ); }\n+\n+\n+class A {public:\n+    /* An uncollectable class. */\n+\n+    A( int iArg ): i( iArg ) {}\n+    void Test( int iArg ) {\n+        my_assert( i == iArg );} \n+    int i;};\n+\n+\n+class B: public gc, public A {public:\n+    /* A collectable class. */\n+\n+    B( int j ): A( j ) {}\n+    ~B() {\n+        my_assert( deleting );}\n+    static void Deleting( int on ) {\n+        deleting = on;}\n+    static int deleting;};\n+\n+int B::deleting = 0;\n+\n+\n+class C: public gc_cleanup, public A {public:\n+    /* A collectable class with cleanup and virtual multiple inheritance. */\n+\n+    C( int levelArg ): A( levelArg ), level( levelArg ) {\n+        nAllocated++;\n+        if (level > 0) {\n+            left = new C( level - 1 );\n+            right = new C( level - 1 );}\n+        else {\n+            left = right = 0;}}\n+    ~C() {\n+        this->A::Test( level );\n+        nFreed++;\n+        my_assert( level == 0 ? \n+                   left == 0 && right == 0 :\n+                   level == left->level + 1 && level == right->level + 1 );\n+        left = right = 0;\n+        level = -123456;}\n+    static void Test() {\n+        my_assert( nFreed <= nAllocated && nFreed >= .8 * nAllocated );}\n+\n+    static int nFreed;\n+    static int nAllocated;\n+    int level;\n+    C* left;\n+    C* right;};\n+\n+int C::nFreed = 0;\n+int C::nAllocated = 0;\n+\n+\n+class D: public gc {public:\n+    /* A collectable class with a static member function to be used as\n+    an explicit clean-up function supplied to ::new. */\n+\n+    D( int iArg ): i( iArg ) {\n+        nAllocated++;}\n+    static void CleanUp( void* obj, void* data ) {\n+        D* self = (D*) obj;\n+        nFreed++;\n+        my_assert( self->i == (int) (long) data );}\n+    static void Test() {\n+        my_assert( nFreed >= .8 * nAllocated );}\n+       \n+    int i;\n+    static int nFreed;\n+    static int nAllocated;};\n+\n+int D::nFreed = 0;\n+int D::nAllocated = 0;\n+\n+\n+class E: public gc_cleanup {public:\n+    /* A collectable class with clean-up for use by F. */\n+\n+    E() {\n+        nAllocated++;}\n+    ~E() {\n+        nFreed++;}\n+\n+    static int nFreed;\n+    static int nAllocated;};\n+    \n+int E::nFreed = 0;\n+int E::nAllocated = 0;\n+   \n+\n+class F: public E {public:\n+    /* A collectable class with clean-up, a base with clean-up, and a\n+    member with clean-up. */\n+\n+    F() {\n+        nAllocated++;}\n+    ~F() {\n+        nFreed++;}\n+    static void Test() {\n+        my_assert( nFreed >= .8 * nAllocated );\n+        my_assert( 2 * nFreed == E::nFreed );}\n+       \n+    E e;\n+    static int nFreed;\n+    static int nAllocated;};\n+    \n+int F::nFreed = 0;\n+int F::nAllocated = 0;\n+   \n+\n+long Disguise( void* p ) {\n+    return ~ (long) p;}\n+\n+void* Undisguise( long i ) {\n+    return (void*) ~ i;}\n+\n+\n+#ifdef MSWIN32\n+int APIENTRY WinMain(\n+    HINSTANCE instance, HINSTANCE prev, LPSTR cmd, int cmdShow ) \n+{\n+    int argc;\n+    char* argv[ 3 ];\n+\n+    for (argc = 1; argc < sizeof( argv ) / sizeof( argv[ 0 ] ); argc++) {\n+        argv[ argc ] = strtok( argc == 1 ? cmd : 0, \" \\t\" );\n+        if (0 == argv[ argc ]) break;}\n+\n+#else\n+# ifdef MACOS\n+    int main() {\n+# else\n+    int main( int argc, char* argv[] ) {\n+# endif\n+#endif\n+\n+#  if defined(MACOS)                        // MacOS\n+    char* argv_[] = {\"test_cpp\", \"10\"};     //   doesn't\n+    argv = argv_;                           //     have a\n+    argc = sizeof(argv_)/sizeof(argv_[0]);  //       commandline\n+#  endif \n+    int i, iters, n;\n+#   if !defined(MACOS)\n+#     ifdef __GNUC__\n+        int *x = (int *)gc_alloc::allocate(sizeof(int));\n+#     else\n+        int *x = (int *)alloc::allocate(sizeof(int));\n+#     endif\n+\n+      *x = 29;\n+      x -= 3;\n+#   endif\n+    if (argc != 2 || (0 >= (n = atoi( argv[ 1 ] )))) {\n+        GC_printf0( \"usage: test_cpp number-of-iterations\\n\" );\n+        exit( 1 );}\n+        \n+    for (iters = 1; iters <= n; iters++) {\n+        GC_printf1( \"Starting iteration %d\\n\", iters );\n+\n+            /* Allocate some uncollectable As and disguise their pointers.\n+            Later we'll check to see if the objects are still there.  We're\n+            checking to make sure these objects really are uncollectable. */\n+        long as[ 1000 ];\n+        long bs[ 1000 ];\n+        for (i = 0; i < 1000; i++) {\n+            as[ i ] = Disguise( new (NoGC) A( i ) );\n+            bs[ i ] = Disguise( new (NoGC) B( i ) );}\n+\n+            /* Allocate a fair number of finalizable Cs, Ds, and Fs.\n+            Later we'll check to make sure they've gone away. */\n+        for (i = 0; i < 1000; i++) {\n+            C* c = new C( 2 );\n+            C c1( 2 );           /* stack allocation should work too */\n+            D* d = ::new (USE_GC, D::CleanUp, (void*)(long)i) D( i );\n+            F* f = new F;\n+            if (0 == i % 10) delete c;}\n+\n+            /* Allocate a very large number of collectable As and Bs and\n+            drop the references to them immediately, forcing many\n+            collections. */\n+        for (i = 0; i < 1000000; i++) {\n+            A* a = new (USE_GC) A( i );\n+            B* b = new B( i );\n+            b = new (USE_GC) B( i );\n+            if (0 == i % 10) {\n+                B::Deleting( 1 );\n+                delete b;\n+                B::Deleting( 0 );}\n+#\t    ifdef FINALIZE_ON_DEMAND\n+\t      GC_invoke_finalizers();\n+#\t    endif\n+\t    }\n+\n+            /* Make sure the uncollectable As and Bs are still there. */\n+        for (i = 0; i < 1000; i++) {\n+            A* a = (A*) Undisguise( as[ i ] );\n+            B* b = (B*) Undisguise( bs[ i ] );\n+            a->Test( i );\n+            delete a;\n+            b->Test( i );\n+            B::Deleting( 1 );\n+            delete b;\n+            B::Deleting( 0 );\n+#\t    ifdef FINALIZE_ON_DEMAND\n+\t   \t GC_invoke_finalizers();\n+#\t    endif\n+\n+\t    }\n+\n+            /* Make sure most of the finalizable Cs, Ds, and Fs have\n+            gone away. */\n+        C::Test();\n+        D::Test();\n+        F::Test();}\n+\n+#   if !defined(__GNUC__) && !defined(MACOS)\n+      my_assert (29 == x[3]);\n+#   endif\n+    GC_printf0( \"The test appears to have succeeded.\\n\" );\n+    return( 0 );}\n+    \n+"}, {"sha": "1174705e45e9b7e81f32737b6bc757a2149126af", "filename": "boehm-gc/tests/thread_leak_test.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Fthread_leak_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Fthread_leak_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Fthread_leak_test.c?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,40 @@\n+#define GC_LINUX_THREADS\n+#include \"leak_detector.h\"\n+#include <pthread.h>\n+#include <stdio.h>\n+\n+void * test(void * arg) {\n+    int *p[10];\n+    int i;\n+    GC_find_leak = 1; /* for new collect versions not compiled  */\n+    /* with -DFIND_LEAK.                                        */\n+    for (i = 0; i < 10; ++i) {\n+        p[i] = malloc(sizeof(int)+i);\n+    }\n+    CHECK_LEAKS();\n+    for (i = 1; i < 10; ++i) {\n+        free(p[i]);\n+    }\n+}       \n+\n+#define NTHREADS 5\n+\n+main() {\n+    int i;\n+    pthread_t t[NTHREADS];\n+    int code;\n+\n+    for (i = 0; i < NTHREADS; ++i) {\n+\tif ((code = pthread_create(t + i, 0, test, 0)) != 0) {\n+    \t    printf(\"Thread creation failed %d\\n\", code);\n+        }\n+    }\n+    for (i = 0; i < NTHREADS; ++i) {\n+\tif ((code = pthread_join(t[i], 0)) != 0) {\n+            printf(\"Thread join failed %lu\\n\", code);\n+        }\n+    }\n+    CHECK_LEAKS();\n+    CHECK_LEAKS();\n+    CHECK_LEAKS();\n+}"}, {"sha": "be9cb6ce6b6b2a6a0a60568b9d974c38bbd4f207", "filename": "boehm-gc/tests/trace_test.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Ftrace_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d42879f9f2e50f38c703064db6e3d6e91a568/boehm-gc%2Ftests%2Ftrace_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftrace_test.c?ref=f54d42879f9f2e50f38c703064db6e3d6e91a568", "patch": "@@ -0,0 +1,28 @@\n+#include <stdio.h>\n+#define GC_DEBUG\n+#include \"gc.h\"\n+\n+struct treenode {\n+    struct treenode *x;\n+    struct treenode *y;\n+} * root[10];\n+\n+struct treenode * mktree(int i) {\n+  struct treenode * r = GC_MALLOC(sizeof(struct treenode));\n+  if (0 == i) return 0;\n+  r -> x = mktree(i-1);\n+  r -> y = mktree(i-1);\n+  return r;\n+}\n+\n+main()\n+{\n+  int i;\n+  for (i = 0; i < 10; ++i) {\n+    root[i] = mktree(12);\n+  }\n+  GC_generate_random_backtrace();\n+  GC_generate_random_backtrace();\n+  GC_generate_random_backtrace();\n+  GC_generate_random_backtrace();\n+}"}]}