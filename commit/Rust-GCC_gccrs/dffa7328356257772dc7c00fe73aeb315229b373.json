{"sha": "dffa7328356257772dc7c00fe73aeb315229b373", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZmYTczMjgzNTYyNTc3NzJkYzdjMDBmZTczYWViMzE1MjI5YjM3Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-07-19T21:36:26Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-07-19T21:36:26Z"}, "message": "reflect, runtime: Use libffi closures to implement reflect.MakeFunc.\n\nKeep using the existing 386 and amd64 code on those archs,\nsince it is more efficient.\n\nFrom-SVN: r212853", "tree": {"sha": "b56b22f6c7e733e05e3f634ca63f18e10bc1b304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b56b22f6c7e733e05e3f634ca63f18e10bc1b304"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dffa7328356257772dc7c00fe73aeb315229b373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dffa7328356257772dc7c00fe73aeb315229b373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dffa7328356257772dc7c00fe73aeb315229b373", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dffa7328356257772dc7c00fe73aeb315229b373/comments", "author": null, "committer": null, "parents": [{"sha": "0c92e4881a61a2483c2878f9953ff92188e9661e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c92e4881a61a2483c2878f9953ff92188e9661e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c92e4881a61a2483c2878f9953ff92188e9661e"}], "stats": {"total": 1117, "additions": 709, "deletions": 408}, "files": [{"sha": "6d00bcc38c6fc40fe71f68c65e3304f540987d5c", "filename": "libgo/Makefile.am", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -444,6 +444,7 @@ runtime_files = \\\n \truntime/go-deferred-recover.c \\\n \truntime/go-eface-compare.c \\\n \truntime/go-eface-val-compare.c \\\n+\truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n \truntime/go-int-array-to-string.c \\\n \truntime/go-int-to-string.c \\\n@@ -951,9 +952,12 @@ endif\n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n \tgo/reflect/makefunc.go \\\n+\tgo/reflect/makefunc_ffi.go \\\n \t$(go_reflect_makefunc_file) \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n+go_reflect_makefunc_c_file = \\\n+\tgo/reflect/makefunc_ffi_c.c\n \n go_regexp_files = \\\n \tgo/regexp/exec.go \\\n@@ -1849,6 +1853,7 @@ libgo_go_objs = \\\n \tpath.lo \\\n \treflect-go.lo \\\n \treflect/makefunc.lo \\\n+\treflect/makefunc_ffi_c.lo \\\n \tregexp.lo \\\n \truntime-go.lo \\\n \tsort.lo \\\n@@ -2252,6 +2257,9 @@ reflect/check: $(CHECK_DEPS)\n reflect/makefunc.lo: $(go_reflect_makefunc_s_file)\n \t@$(MKDIR_P) reflect\n \t$(LTCOMPILE) -c -o $@ $<\n+reflect/makefunc_ffi_c.lo: $(go_reflect_makefunc_c_file)\n+\t@$(MKDIR_P) reflect\n+\t$(LTCOMPILE) -c -o $@ $<\n .PHONY: reflect/check\n \n @go_include@ regexp.lo.dep"}, {"sha": "1e085b73a73b7f23ab0c6180ae39c159a234f2ab", "filename": "libgo/Makefile.in", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -135,17 +135,18 @@ am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tencoding.lo errors.lo expvar.lo flag.lo fmt.lo hash.lo html.lo \\\n \timage.lo io.lo log.lo math.lo mime.lo net.lo os.lo path.lo \\\n-\treflect-go.lo reflect/makefunc.lo regexp.lo runtime-go.lo \\\n-\tsort.lo strconv.lo strings.lo strings/index.lo sync.lo \\\n-\tsyscall.lo syscall/errno.lo syscall/signame.lo syscall/wait.lo \\\n-\ttesting.lo time-go.lo unicode.lo archive/tar.lo archive/zip.lo \\\n-\tcompress/bzip2.lo compress/flate.lo compress/gzip.lo \\\n-\tcompress/lzw.lo compress/zlib.lo container/heap.lo \\\n-\tcontainer/list.lo container/ring.lo crypto/aes.lo \\\n-\tcrypto/cipher.lo crypto/des.lo crypto/dsa.lo crypto/ecdsa.lo \\\n-\tcrypto/elliptic.lo crypto/hmac.lo crypto/md5.lo crypto/rand.lo \\\n-\tcrypto/rc4.lo crypto/rsa.lo crypto/sha1.lo crypto/sha256.lo \\\n-\tcrypto/sha512.lo crypto/subtle.lo crypto/tls.lo crypto/x509.lo \\\n+\treflect-go.lo reflect/makefunc.lo reflect/makefunc_ffi_c.lo \\\n+\tregexp.lo runtime-go.lo sort.lo strconv.lo strings.lo \\\n+\tstrings/index.lo sync.lo syscall.lo syscall/errno.lo \\\n+\tsyscall/signame.lo syscall/wait.lo testing.lo time-go.lo \\\n+\tunicode.lo archive/tar.lo archive/zip.lo compress/bzip2.lo \\\n+\tcompress/flate.lo compress/gzip.lo compress/lzw.lo \\\n+\tcompress/zlib.lo container/heap.lo container/list.lo \\\n+\tcontainer/ring.lo crypto/aes.lo crypto/cipher.lo crypto/des.lo \\\n+\tcrypto/dsa.lo crypto/ecdsa.lo crypto/elliptic.lo \\\n+\tcrypto/hmac.lo crypto/md5.lo crypto/rand.lo crypto/rc4.lo \\\n+\tcrypto/rsa.lo crypto/sha1.lo crypto/sha256.lo crypto/sha512.lo \\\n+\tcrypto/subtle.lo crypto/tls.lo crypto/x509.lo \\\n \tcrypto/x509/pkix.lo database/sql.lo database/sql/driver.lo \\\n \tdebug/dwarf.lo debug/elf.lo debug/gosym.lo debug/macho.lo \\\n \tdebug/pe.lo debug/plan9obj.lo encoding/ascii85.lo \\\n@@ -196,7 +197,7 @@ am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-check-interface.lo go-construct-map.lo \\\n \tgo-convert-interface.lo go-copy.lo go-defer.lo \\\n \tgo-deferred-recover.lo go-eface-compare.lo \\\n-\tgo-eface-val-compare.lo go-fieldtrack.lo \\\n+\tgo-eface-val-compare.lo go-ffi.lo go-fieldtrack.lo \\\n \tgo-int-array-to-string.lo go-int-to-string.lo \\\n \tgo-interface-compare.lo go-interface-eface-compare.lo \\\n \tgo-interface-val-compare.lo go-make-slice.lo go-map-delete.lo \\\n@@ -773,6 +774,7 @@ runtime_files = \\\n \truntime/go-deferred-recover.c \\\n \truntime/go-eface-compare.c \\\n \truntime/go-eface-val-compare.c \\\n+\truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n \truntime/go-int-array-to-string.c \\\n \truntime/go-int-to-string.c \\\n@@ -1121,10 +1123,14 @@ go_path_files = \\\n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n \tgo/reflect/makefunc.go \\\n+\tgo/reflect/makefunc_ffi.go \\\n \t$(go_reflect_makefunc_file) \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n \n+go_reflect_makefunc_c_file = \\\n+\tgo/reflect/makefunc_ffi_c.c\n+\n go_regexp_files = \\\n \tgo/regexp/exec.go \\\n \tgo/regexp/onepass.go \\\n@@ -1910,6 +1916,7 @@ libgo_go_objs = \\\n \tpath.lo \\\n \treflect-go.lo \\\n \treflect/makefunc.lo \\\n+\treflect/makefunc_ffi_c.lo \\\n \tregexp.lo \\\n \truntime-go.lo \\\n \tsort.lo \\\n@@ -2430,6 +2437,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-deferred-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-eface-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-eface-val-compare.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-fieldtrack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-iface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-int-array-to-string.Plo@am__quote@\n@@ -2677,6 +2685,13 @@ go-eface-val-compare.lo: runtime/go-eface-val-compare.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-eface-val-compare.lo `test -f 'runtime/go-eface-val-compare.c' || echo '$(srcdir)/'`runtime/go-eface-val-compare.c\n \n+go-ffi.lo: runtime/go-ffi.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-ffi.lo -MD -MP -MF $(DEPDIR)/go-ffi.Tpo -c -o go-ffi.lo `test -f 'runtime/go-ffi.c' || echo '$(srcdir)/'`runtime/go-ffi.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-ffi.Tpo $(DEPDIR)/go-ffi.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-ffi.c' object='go-ffi.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-ffi.lo `test -f 'runtime/go-ffi.c' || echo '$(srcdir)/'`runtime/go-ffi.c\n+\n go-fieldtrack.lo: runtime/go-fieldtrack.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-fieldtrack.lo -MD -MP -MF $(DEPDIR)/go-fieldtrack.Tpo -c -o go-fieldtrack.lo `test -f 'runtime/go-fieldtrack.c' || echo '$(srcdir)/'`runtime/go-fieldtrack.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-fieldtrack.Tpo $(DEPDIR)/go-fieldtrack.Plo\n@@ -4585,6 +4600,9 @@ reflect/check: $(CHECK_DEPS)\n reflect/makefunc.lo: $(go_reflect_makefunc_s_file)\n \t@$(MKDIR_P) reflect\n \t$(LTCOMPILE) -c -o $@ $<\n+reflect/makefunc_ffi_c.lo: $(go_reflect_makefunc_c_file)\n+\t@$(MKDIR_P) reflect\n+\t$(LTCOMPILE) -c -o $@ $<\n .PHONY: reflect/check\n \n @go_include@ regexp.lo.dep"}, {"sha": "f888d648c19b19ef8f6f6896a66cffd0d10e3e49", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -1502,12 +1502,6 @@ func TestCallWithStruct(t *testing.T) {\n }\n \n func TestMakeFunc(t *testing.T) {\n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n-\tdefault:\n-\t\tt.Skip(\"MakeFunc not implemented for \" + runtime.GOARCH)\n-\t}\n-\n \tf := dummy\n \tfv := MakeFunc(TypeOf(f), func(in []Value) []Value { return in })\n \tValueOf(&f).Elem().Set(fv)\n@@ -1526,12 +1520,6 @@ func TestMakeFunc(t *testing.T) {\n }\n \n func TestMakeFuncInterface(t *testing.T) {\n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n-\tdefault:\n-\t\tt.Skip(\"MakeFunc not implemented for \" + runtime.GOARCH)\n-\t}\n-\n \tfn := func(i int) int { return i }\n \tincr := func(in []Value) []Value {\n \t\treturn []Value{ValueOf(int(in[0].Int() + 1))}\n@@ -1676,12 +1664,6 @@ func TestMethod(t *testing.T) {\n }\n \n func TestMethodValue(t *testing.T) {\n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n-\tdefault:\n-\t\tt.Skip(\"reflect method values not implemented for \" + runtime.GOARCH)\n-\t}\n-\n \tp := Point{3, 4}\n \tvar i int64\n \n@@ -1853,12 +1835,6 @@ type Tm4 struct {\n func (t4 Tm4) M(x int, b byte) (byte, int) { return b, x + 40 }\n \n func TestMethod5(t *testing.T) {\n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n-\tdefault:\n-\t\tt.Skip(\"reflect method values not implemented for \" + runtime.GOARCH)\n-\t}\n-\n \tCheckF := func(name string, f func(int, byte) (byte, int), inc int) {\n \t\tb, x := f(1000, 99)\n \t\tif b != 99 || x != 1000+inc {"}, {"sha": "736ac36ade74d50c7caf9bae6d58886bf51d337b", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 60, "deletions": 35, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -22,6 +22,10 @@ type makeFuncImpl struct {\n \t// method values.\n \tmethod int\n \trcvr   Value\n+\n+\t// When using FFI, hold onto the FFI closure for the garbage\n+\t// collector.\n+\tffi *ffiData\n }\n \n // MakeFunc returns a new function of the given Type\n@@ -51,22 +55,29 @@ func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {\n \t\tpanic(\"reflect: call of MakeFunc with non-Func type\")\n \t}\n \n+\tt := typ.common()\n+\tftyp := (*funcType)(unsafe.Pointer(t))\n+\n+\tvar code uintptr\n+\tvar ffi *ffiData\n \tswitch runtime.GOARCH {\n \tcase \"amd64\", \"386\":\n+\t\t// Indirect Go func value (dummy) to obtain actual\n+\t\t// code address. (A Go func value is a pointer to a C\n+\t\t// function pointer. http://golang.org/s/go11func.)\n+\t\tdummy := makeFuncStub\n+\t\tcode = **(**uintptr)(unsafe.Pointer(&dummy))\n \tdefault:\n-\t\tpanic(\"reflect.MakeFunc not implemented for \" + runtime.GOARCH)\n+\t\tcode, ffi = makeFuncFFI(ftyp, fn)\n \t}\n \n-\tt := typ.common()\n-\tftyp := (*funcType)(unsafe.Pointer(t))\n-\n-\t// Indirect Go func value (dummy) to obtain\n-\t// actual code address. (A Go func value is a pointer\n-\t// to a C function pointer. http://golang.org/s/go11func.)\n-\tdummy := makeFuncStub\n-\tcode := **(**uintptr)(unsafe.Pointer(&dummy))\n-\n-\timpl := &makeFuncImpl{code: code, typ: ftyp, fn: fn, method: -1}\n+\timpl := &makeFuncImpl{\n+\t\tcode:   code,\n+\t\ttyp:    ftyp,\n+\t\tfn:     fn,\n+\t\tmethod: -1,\n+\t\tffi:    ffi,\n+\t}\n \n \treturn Value{t, unsafe.Pointer(&impl), flag(Func<<flagKindShift) | flagIndir}\n }\n@@ -90,12 +101,6 @@ func makeMethodValue(op string, v Value) Value {\n \t\tpanic(\"reflect: internal error: invalid use of makeMethodValue\")\n \t}\n \n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n-\tdefault:\n-\t\tpanic(\"reflect.makeMethodValue not implemented for \" + runtime.GOARCH)\n-\t}\n-\n \t// Ignoring the flagMethod bit, v describes the receiver, not the method type.\n \tfl := v.flag & (flagRO | flagAddr | flagIndir)\n \tfl |= flag(v.typ.Kind()) << flagKindShift\n@@ -104,22 +109,37 @@ func makeMethodValue(op string, v Value) Value {\n \t// v.Type returns the actual type of the method value.\n \tft := v.Type().(*rtype)\n \n-\t// Indirect Go func value (dummy) to obtain\n-\t// actual code address. (A Go func value is a pointer\n-\t// to a C function pointer. http://golang.org/s/go11func.)\n-\tdummy := makeFuncStub\n-\tcode := **(**uintptr)(unsafe.Pointer(&dummy))\n-\n \t// Cause panic if method is not appropriate.\n \t// The panic would still happen during the call if we omit this,\n \t// but we want Interface() and other operations to fail early.\n \t_, t, _ := methodReceiver(op, rcvr, int(v.flag)>>flagMethodShift)\n \n+\tftyp := (*funcType)(unsafe.Pointer(t))\n+\tmethod := int(v.flag) >> flagMethodShift\n+\n+\tvar code uintptr\n+\tvar ffi *ffiData\n+\tswitch runtime.GOARCH {\n+\tcase \"amd64\", \"386\":\n+\t\t// Indirect Go func value (dummy) to obtain actual\n+\t\t// code address. (A Go func value is a pointer to a C\n+\t\t// function pointer. http://golang.org/s/go11func.)\n+\t\tdummy := makeFuncStub\n+\t\tcode = **(**uintptr)(unsafe.Pointer(&dummy))\n+\tdefault:\n+\t\tcode, ffi = makeFuncFFI(ftyp,\n+\t\t\tfunc(in []Value) []Value {\n+\t\t\t\tm := rcvr.Method(method)\n+\t\t\t\treturn m.Call(in)\n+\t\t\t})\n+\t}\n+\n \tfv := &makeFuncImpl{\n \t\tcode:   code,\n-\t\ttyp:    (*funcType)(unsafe.Pointer(t)),\n-\t\tmethod: int(v.flag) >> flagMethodShift,\n+\t\ttyp:    ftyp,\n+\t\tmethod: method,\n \t\trcvr:   rcvr,\n+\t\tffi:    ffi,\n \t}\n \n \treturn Value{ft, unsafe.Pointer(&fv), v.flag&flagRO | flag(Func)<<flagKindShift | flagIndir}\n@@ -137,26 +157,31 @@ func makeValueMethod(v Value) Value {\n \t\tpanic(\"reflect: call of makeValueMethod with non-MethodFn\")\n \t}\n \n+\tt := typ.common()\n+\tftyp := (*funcType)(unsafe.Pointer(t))\n+\n+\tvar code uintptr\n+\tvar ffi *ffiData\n \tswitch runtime.GOARCH {\n \tcase \"amd64\", \"386\":\n+\t\t// Indirect Go func value (dummy) to obtain actual\n+\t\t// code address. (A Go func value is a pointer to a C\n+\t\t// function pointer. http://golang.org/s/go11func.)\n+\t\tdummy := makeFuncStub\n+\t\tcode = **(**uintptr)(unsafe.Pointer(&dummy))\n \tdefault:\n-\t\tpanic(\"reflect.makeValueMethod not implemented for \" + runtime.GOARCH)\n+\t\tcode, ffi = makeFuncFFI(ftyp,\n+\t\t\tfunc(in []Value) []Value {\n+\t\t\t\treturn v.Call(in)\n+\t\t\t})\n \t}\n \n-\tt := typ.common()\n-\tftyp := (*funcType)(unsafe.Pointer(t))\n-\n-\t// Indirect Go func value (dummy) to obtain\n-\t// actual code address. (A Go func value is a pointer\n-\t// to a C function pointer. http://golang.org/s/go11func.)\n-\tdummy := makeFuncStub\n-\tcode := **(**uintptr)(unsafe.Pointer(&dummy))\n-\n \timpl := &makeFuncImpl{\n \t\tcode:   code,\n \t\ttyp:    ftyp,\n \t\tmethod: -2,\n \t\trcvr:   v,\n+\t\tffi:    ffi,\n \t}\n \n \treturn Value{t, unsafe.Pointer(&impl), flag(Func<<flagKindShift) | flagIndir}"}, {"sha": "8eff0c1dfacd0dac7dd1c607abf1f3be7da1adbe", "filename": "libgo/go/reflect/makefunc_dummy.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -2,11 +2,14 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64\n+#include \"runtime.h\"\n \n-// Dummy function for processors without makefunc support.\n+/* Dummy function for processors that implement MakeFunc using FFI\n+   rather than having builtin support.  */\n \n-void makeFuncStub () __asm__ (\"reflect.makeFuncStub\");\n-void makeFuncStub ()\n+void makeFuncStub (void) __asm__ (\"reflect.makeFuncStub\");\n+\n+void makeFuncStub (void)\n {\n+  runtime_throw (\"impossible call to makeFuncStub\");\n }"}, {"sha": "a13ef179f5db4ccdc5b10bc96ac3b4f46a4d8306", "filename": "libgo/go/reflect/makefunc_ffi.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package reflect\n+\n+import (\n+\t\"runtime\"\n+\t\"unsafe\"\n+)\n+\n+// The ffi function, written in C, allocates an FFI closure.  It\n+// returns the code and data pointers.  When the code pointer is\n+// called, it will call callback.  CIF is an FFI data structure\n+// allocated as part of the closure, and is returned to ensure that\n+// the GC retains it.\n+func ffi(ftyp *funcType, callback func(unsafe.Pointer, unsafe.Pointer)) (code uintptr, data uintptr, cif unsafe.Pointer)\n+\n+// The ffiFree function, written in C, releases the FFI closure.\n+func ffiFree(uintptr)\n+\n+// An ffiData holds the information needed to preserve an FFI closure\n+// for the garbage collector.\n+type ffiData struct {\n+\tcode     uintptr\n+\tdata     uintptr\n+\tcif      unsafe.Pointer\n+\tcallback func(unsafe.Pointer, unsafe.Pointer)\n+}\n+\n+// The makeFuncFFI function uses libffi closures to implement\n+// reflect.MakeFunc.  This is used for processors for which we don't\n+// have more efficient support.\n+func makeFuncFFI(ftyp *funcType, fn func(args []Value) (results []Value)) (uintptr, *ffiData) {\n+\tcallback := func(params, results unsafe.Pointer) {\n+\t\tffiCall(ftyp, fn, params, results)\n+\t}\n+\n+\tcode, data, cif := ffi(ftyp, callback)\n+\n+\tc := &ffiData{code: code, data: data, cif: cif, callback: callback}\n+\n+\truntime.SetFinalizer(c,\n+\t\tfunc(p *ffiData) {\n+\t\t\tffiFree(p.data)\n+\t\t})\n+\n+\treturn code, c\n+}\n+\n+// ffiCall takes pointers to the parameters, calls the function, and\n+// stores the results back into memory.\n+func ffiCall(ftyp *funcType, fn func([]Value) []Value, params unsafe.Pointer, results unsafe.Pointer) {\n+\tin := make([]Value, 0, len(ftyp.in))\n+\tap := params\n+\tfor _, rt := range ftyp.in {\n+\t\tp := unsafe_New(rt)\n+\t\tmemmove(p, *(*unsafe.Pointer)(ap), rt.size)\n+\t\tv := Value{rt, p, flag(rt.Kind()<<flagKindShift) | flagIndir}\n+\t\tin = append(in, v)\n+\t\tap = (unsafe.Pointer)(uintptr(ap) + ptrSize)\n+\t}\n+\n+\tout := fn(in)\n+\n+\toff := uintptr(0)\n+\tfor i, typ := range ftyp.out {\n+\t\tv := out[i]\n+\t\tif v.typ != typ {\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(fn) +\n+\t\t\t\t\" returned wrong type: have \" +\n+\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n+\t\t}\n+\t\tif v.flag&flagRO != 0 {\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(fn) +\n+\t\t\t\t\" returned value obtained from unexported field\")\n+\t\t}\n+\n+\t\toff = align(off, uintptr(typ.fieldAlign))\n+\t\taddr := unsafe.Pointer(uintptr(results) + off)\n+\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n+\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n+\t\t} else {\n+\t\t\tmemmove(addr, v.ptr, typ.size)\n+\t\t}\n+\t\toff += typ.size\n+\t}\n+}"}, {"sha": "fba269dcb58e0e7ab12dfab15b2a8306e529d4e7", "filename": "libgo/go/reflect/makefunc_ffi_c.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"runtime.h\"\n+#include \"go-type.h\"\n+#include \"go-panic.h\"\n+\n+#ifdef USE_LIBFFI\n+\n+#include \"go-ffi.h\"\n+\n+#if FFI_CLOSURES\n+#define USE_LIBFFI_CLOSURES\n+#endif\n+\n+#endif /* defined(USE_LIBFFI) */\n+\n+/* Declare C functions with the names used to call from Go.  */\n+\n+struct ffi_ret {\n+  void *code;\n+  void *data;\n+  void *cif;\n+};\n+\n+struct ffi_ret ffi(const struct __go_func_type *ftyp, FuncVal *callback)\n+  __asm__ (GOSYM_PREFIX \"reflect.ffi\");\n+\n+void ffiFree(void *data)\n+  __asm__ (GOSYM_PREFIX \"reflect.ffiFree\");\n+\n+#ifdef USE_LIBFFI_CLOSURES\n+\n+/* The function that we pass to ffi_prep_closure_loc.  This calls the\n+   Go callback function (passed in user_data) with the pointer to the\n+   arguments and the results area.  */\n+\n+static void\n+ffi_callback (ffi_cif* cif __attribute__ ((unused)), void *results,\n+\t      void **args, void *user_data)\n+{\n+  Location locs[6];\n+  int n;\n+  int i;\n+  const void *pc;\n+  FuncVal *fv;\n+  void (*f) (void *, void *);\n+\n+  /* This function is called from some series of FFI closure functions\n+     called by a Go function.  We want to pass the PC of the Go\n+     function to makefunc_can_recover.  Look up the stack for a\n+     function that is definitely not an FFI function.  */\n+  n = runtime_callers (1, &locs[0], sizeof locs / sizeof locs[0], true);\n+  for (i = 0; i < n; i++)\n+    {\n+      const byte *name;\n+\n+      if (locs[i].function.len == 0)\n+\tcontinue;\n+      if (locs[i].function.len < 4)\n+\tbreak;\n+      name = locs[i].function.str;\n+      if (*name == '_')\n+\t{\n+\t  if (locs[i].function.len < 5)\n+\t    break;\n+\t  ++name;\n+\t}\n+      if (name[0] != 'f' || name[1] != 'f' || name[2] != 'i' || name[3] != '_')\n+\tbreak;\n+    }\n+  if (i < n)\n+    pc = (const void *) locs[i].pc;\n+  else\n+    pc = __builtin_return_address (0);\n+\n+  __go_makefunc_can_recover (pc);\n+\n+  fv = (FuncVal *) user_data;\n+  __go_set_closure (fv);\n+  f = (void *) fv->fn;\n+  f (args, results);\n+\n+  __go_makefunc_returning ();\n+}\n+\n+/* Allocate an FFI closure and arrange to call ffi_callback.  */\n+\n+struct ffi_ret\n+ffi (const struct __go_func_type *ftyp, FuncVal *callback)\n+{\n+  ffi_cif *cif;\n+  void *code;\n+  void *data;\n+  struct ffi_ret ret;\n+\n+  cif = (ffi_cif *) __go_alloc (sizeof (ffi_cif));\n+  __go_func_to_cif (ftyp, 0, 0, cif);\n+  data = ffi_closure_alloc (sizeof (ffi_closure), &code);\n+  if (data == NULL)\n+    runtime_panicstring (\"ffi_closure_alloc failed\");\n+  if (ffi_prep_closure_loc (data, cif, ffi_callback, callback, code)\n+      != FFI_OK)\n+    runtime_panicstring (\"ffi_prep_closure_loc failed\");\n+  ret.code = code;\n+  ret.data = data;\n+  ret.cif = cif;\n+  return ret;\n+}\n+\n+/* Free the FFI closure.  */\n+\n+void\n+ffiFree (void *data)\n+{\n+  ffi_closure_free (data);\n+}\n+\n+#else /* !defined(USE_LIBFFI_CLOSURES) */\n+\n+struct ffi_ret\n+ffi(const struct __go_func_type *ftyp, FuncVal *callback)\n+{\n+  runtime_panicstring (\"libgo built without FFI does not support \"\n+\t\t       \"reflect.MakeFunc\");\n+}\n+\n+void ffiFree(void *data)\n+{\n+  runtime_panicstring (\"libgo built without FFI does not support \"\n+\t\t       \"reflect.MakeFunc\");\n+}\n+\n+#endif"}, {"sha": "a5c687d00f49f816f7e37a0edefb68b87eeb06ec", "filename": "libgo/runtime/go-caller.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-caller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-caller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-caller.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -177,7 +177,7 @@ Caller (int skip)\n   int32 n;\n \n   runtime_memclr (&ret, sizeof ret);\n-  n = runtime_callers (skip + 1, &loc, 1);\n+  n = runtime_callers (skip + 1, &loc, 1, false);\n   if (n < 1)\n     return ret;\n   ret.pc = loc.pc;"}, {"sha": "047034539a90bebade6e3c0efaf97d26e3af0c4a", "filename": "libgo/runtime/go-callers.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -26,6 +26,7 @@ struct callers_data\n   int skip;\n   int index;\n   int max;\n+  int keep_thunks;\n };\n \n /* Callback function for backtrace_full.  Just collect the locations.\n@@ -63,7 +64,7 @@ callback (void *data, uintptr_t pc, const char *filename, int lineno,\n   /* Skip thunks and recover functions.  There is no equivalent to\n      these functions in the gc toolchain, so returning them here means\n      significantly different results for runtime.Caller(N).  */\n-  if (function != NULL)\n+  if (function != NULL && !arg->keep_thunks)\n     {\n       const char *p;\n \n@@ -136,14 +137,15 @@ error_callback (void *data __attribute__ ((unused)),\n /* Gather caller PC's.  */\n \n int32\n-runtime_callers (int32 skip, Location *locbuf, int32 m)\n+runtime_callers (int32 skip, Location *locbuf, int32 m, bool keep_thunks)\n {\n   struct callers_data data;\n \n   data.locbuf = locbuf;\n   data.skip = skip + 1;\n   data.index = 0;\n   data.max = m;\n+  data.keep_thunks = keep_thunks;\n   runtime_xadd (&runtime_in_callers, 1);\n   backtrace_full (__go_get_backtrace_state (), 0, callback, error_callback,\n \t\t  &data);\n@@ -167,7 +169,7 @@ Callers (int skip, struct __go_open_array pc)\n      which we can not correct because it would break backward\n      compatibility.  Normally we would add 1 to SKIP here, but we\n      don't so that we are compatible.  */\n-  ret = runtime_callers (skip, locbuf, pc.__count);\n+  ret = runtime_callers (skip, locbuf, pc.__count, false);\n \n   for (i = 0; i < ret; i++)\n     ((uintptr *) pc.__values)[i] = locbuf[i].pc;"}, {"sha": "21879b95b77ff505fdb5b318b7ad5fa4751a69b6", "filename": "libgo/runtime/go-ffi.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-ffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-ffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-ffi.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -0,0 +1,338 @@\n+/* go-ffi.c -- convert Go type description to libffi.\n+\n+   Copyright 2009 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+#include \"runtime.h\"\n+#include \"go-alloc.h\"\n+#include \"go-assert.h\"\n+#include \"go-type.h\"\n+\n+#ifdef USE_LIBFFI\n+\n+#include \"ffi.h\"\n+\n+/* The functions in this file are only called from reflect_call and\n+   reflect.ffi.  As these functions call libffi functions, which will\n+   be compiled without -fsplit-stack, they will always run with a\n+   large stack.  */\n+\n+static ffi_type *go_array_to_ffi (const struct __go_array_type *)\n+  __attribute__ ((no_split_stack));\n+static ffi_type *go_slice_to_ffi (const struct __go_slice_type *)\n+  __attribute__ ((no_split_stack));\n+static ffi_type *go_struct_to_ffi (const struct __go_struct_type *)\n+  __attribute__ ((no_split_stack));\n+static ffi_type *go_string_to_ffi (void) __attribute__ ((no_split_stack));\n+static ffi_type *go_interface_to_ffi (void) __attribute__ ((no_split_stack));\n+static ffi_type *go_complex_to_ffi (ffi_type *)\n+  __attribute__ ((no_split_stack, unused));\n+static ffi_type *go_type_to_ffi (const struct __go_type_descriptor *)\n+  __attribute__ ((no_split_stack));\n+static ffi_type *go_func_return_ffi (const struct __go_func_type *)\n+  __attribute__ ((no_split_stack));\n+\n+/* Return an ffi_type for a Go array type.  The libffi library does\n+   not have any builtin support for passing arrays as values.  We work\n+   around this by pretending that the array is a struct.  */\n+\n+static ffi_type *\n+go_array_to_ffi (const struct __go_array_type *descriptor)\n+{\n+  ffi_type *ret;\n+  uintptr_t len;\n+  ffi_type *element;\n+  uintptr_t i;\n+\n+  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n+  ret->type = FFI_TYPE_STRUCT;\n+  len = descriptor->__len;\n+  ret->elements = (ffi_type **) __go_alloc ((len + 1) * sizeof (ffi_type *));\n+  element = go_type_to_ffi (descriptor->__element_type);\n+  for (i = 0; i < len; ++i)\n+    ret->elements[i] = element;\n+  ret->elements[len] = NULL;\n+  return ret;\n+}\n+\n+/* Return an ffi_type for a Go slice type.  This describes the\n+   __go_open_array type defines in array.h.  */\n+\n+static ffi_type *\n+go_slice_to_ffi (\n+    const struct __go_slice_type *descriptor __attribute__ ((unused)))\n+{\n+  ffi_type *ret;\n+  ffi_type *ffi_intgo;\n+\n+  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n+  ret->type = FFI_TYPE_STRUCT;\n+  ret->elements = (ffi_type **) __go_alloc (4 * sizeof (ffi_type *));\n+  ret->elements[0] = &ffi_type_pointer;\n+  ffi_intgo = sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n+  ret->elements[1] = ffi_intgo;\n+  ret->elements[2] = ffi_intgo;\n+  ret->elements[3] = NULL;\n+  return ret;\n+}\n+\n+/* Return an ffi_type for a Go struct type.  */\n+\n+static ffi_type *\n+go_struct_to_ffi (const struct __go_struct_type *descriptor)\n+{\n+  ffi_type *ret;\n+  int field_count;\n+  const struct __go_struct_field *fields;\n+  int i;\n+\n+  field_count = descriptor->__fields.__count;\n+  if (field_count == 0) {\n+    return &ffi_type_void;\n+  }\n+  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n+  ret->type = FFI_TYPE_STRUCT;\n+  fields = (const struct __go_struct_field *) descriptor->__fields.__values;\n+  ret->elements = (ffi_type **) __go_alloc ((field_count + 1)\n+\t\t\t\t\t    * sizeof (ffi_type *));\n+  for (i = 0; i < field_count; ++i)\n+    ret->elements[i] = go_type_to_ffi (fields[i].__type);\n+  ret->elements[field_count] = NULL;\n+  return ret;\n+}\n+\n+/* Return an ffi_type for a Go string type.  This describes the String\n+   struct.  */\n+\n+static ffi_type *\n+go_string_to_ffi (void)\n+{\n+  ffi_type *ret;\n+  ffi_type *ffi_intgo;\n+\n+  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n+  ret->type = FFI_TYPE_STRUCT;\n+  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n+  ret->elements[0] = &ffi_type_pointer;\n+  ffi_intgo = sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n+  ret->elements[1] = ffi_intgo;\n+  ret->elements[2] = NULL;\n+  return ret;\n+}\n+\n+/* Return an ffi_type for a Go interface type.  This describes the\n+   __go_interface and __go_empty_interface structs.  */\n+\n+static ffi_type *\n+go_interface_to_ffi (void)\n+{\n+  ffi_type *ret;\n+\n+  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n+  ret->type = FFI_TYPE_STRUCT;\n+  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n+  ret->elements[0] = &ffi_type_pointer;\n+  ret->elements[1] = &ffi_type_pointer;\n+  ret->elements[2] = NULL;\n+  return ret;\n+}\n+\n+/* Return an ffi_type for a Go complex type.  */\n+\n+static ffi_type *\n+go_complex_to_ffi (ffi_type *float_type)\n+{\n+  ffi_type *ret;\n+\n+  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n+  ret->type = FFI_TYPE_STRUCT;\n+  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n+  ret->elements[0] = float_type;\n+  ret->elements[1] = float_type;\n+  ret->elements[2] = NULL;\n+  return ret;\n+}\n+\n+/* Return an ffi_type for a type described by a\n+   __go_type_descriptor.  */\n+\n+static ffi_type *\n+go_type_to_ffi (const struct __go_type_descriptor *descriptor)\n+{\n+  switch (descriptor->__code & GO_CODE_MASK)\n+    {\n+    case GO_BOOL:\n+      if (sizeof (_Bool) == 1)\n+\treturn &ffi_type_uint8;\n+      else if (sizeof (_Bool) == sizeof (int))\n+\treturn &ffi_type_uint;\n+      abort ();\n+    case GO_FLOAT32:\n+      if (sizeof (float) == 4)\n+\treturn &ffi_type_float;\n+      abort ();\n+    case GO_FLOAT64:\n+      if (sizeof (double) == 8)\n+\treturn &ffi_type_double;\n+      abort ();\n+    case GO_COMPLEX64:\n+#ifdef __alpha__\n+      runtime_throw(\"the libffi library does not support Complex64 type with \"\n+\t\t    \"reflect.Call or runtime.SetFinalizer\");\n+#else\n+      if (sizeof (float) == 4)\n+\treturn go_complex_to_ffi (&ffi_type_float);\n+      abort ();\n+#endif\n+    case GO_COMPLEX128:\n+#ifdef __alpha__\n+      runtime_throw(\"the libffi library does not support Complex128 type with \"\n+\t\t    \"reflect.Call or runtime.SetFinalizer\");\n+#else\n+      if (sizeof (double) == 8)\n+\treturn go_complex_to_ffi (&ffi_type_double);\n+      abort ();\n+#endif\n+    case GO_INT16:\n+      return &ffi_type_sint16;\n+    case GO_INT32:\n+      return &ffi_type_sint32;\n+    case GO_INT64:\n+      return &ffi_type_sint64;\n+    case GO_INT8:\n+      return &ffi_type_sint8;\n+    case GO_INT:\n+      return sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n+    case GO_UINT16:\n+      return &ffi_type_uint16;\n+    case GO_UINT32:\n+      return &ffi_type_uint32;\n+    case GO_UINT64:\n+      return &ffi_type_uint64;\n+    case GO_UINT8:\n+      return &ffi_type_uint8;\n+    case GO_UINT:\n+      return sizeof (uintgo) == 4 ? &ffi_type_uint32 : &ffi_type_uint64;\n+    case GO_UINTPTR:\n+      if (sizeof (void *) == 2)\n+\treturn &ffi_type_uint16;\n+      else if (sizeof (void *) == 4)\n+\treturn &ffi_type_uint32;\n+      else if (sizeof (void *) == 8)\n+\treturn &ffi_type_uint64;\n+      abort ();\n+    case GO_ARRAY:\n+      return go_array_to_ffi ((const struct __go_array_type *) descriptor);\n+    case GO_SLICE:\n+      return go_slice_to_ffi ((const struct __go_slice_type *) descriptor);\n+    case GO_STRUCT:\n+      return go_struct_to_ffi ((const struct __go_struct_type *) descriptor);\n+    case GO_STRING:\n+      return go_string_to_ffi ();\n+    case GO_INTERFACE:\n+      return go_interface_to_ffi ();\n+    case GO_CHAN:\n+    case GO_FUNC:\n+    case GO_MAP:\n+    case GO_PTR:\n+    case GO_UNSAFE_POINTER:\n+      /* These types are always pointers, and for FFI purposes nothing\n+\t else matters.  */\n+      return &ffi_type_pointer;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Return the return type for a function, given the number of out\n+   parameters and their types.  */\n+\n+static ffi_type *\n+go_func_return_ffi (const struct __go_func_type *func)\n+{\n+  int count;\n+  const struct __go_type_descriptor **types;\n+  ffi_type *ret;\n+  int i;\n+\n+  count = func->__out.__count;\n+  if (count == 0)\n+    return &ffi_type_void;\n+\n+  types = (const struct __go_type_descriptor **) func->__out.__values;\n+\n+  if (count == 1)\n+    {\n+\n+#if defined (__i386__) && !defined (__x86_64__)\n+      /* FFI does not support complex types.  On 32-bit x86, a\n+\t complex64 will be returned in %eax/%edx.  We normally tell\n+\t FFI that a complex64 is a struct of two floats.  On 32-bit\n+\t x86 a struct of two floats is returned via a hidden first\n+\t pointer parameter.  Fortunately we can make everything work\n+\t by pretending that complex64 is int64.  */\n+      if ((types[0]->__code & GO_CODE_MASK) == GO_COMPLEX64)\n+\treturn &ffi_type_sint64;\n+#endif\n+\n+      return go_type_to_ffi (types[0]);\n+    }\n+\n+  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n+  ret->type = FFI_TYPE_STRUCT;\n+  ret->elements = (ffi_type **) __go_alloc ((count + 1) * sizeof (ffi_type *));\n+  for (i = 0; i < count; ++i)\n+    ret->elements[i] = go_type_to_ffi (types[i]);\n+  ret->elements[count] = NULL;\n+  return ret;\n+}\n+\n+/* Build an ffi_cif structure for a function described by a\n+   __go_func_type structure.  */\n+\n+void\n+__go_func_to_cif (const struct __go_func_type *func, _Bool is_interface,\n+\t\t_Bool is_method, ffi_cif *cif)\n+{\n+  int num_params;\n+  const struct __go_type_descriptor **in_types;\n+  size_t num_args;\n+  ffi_type **args;\n+  int off;\n+  int i;\n+  ffi_type *rettype;\n+  ffi_status status;\n+\n+  num_params = func->__in.__count;\n+  in_types = ((const struct __go_type_descriptor **)\n+\t      func->__in.__values);\n+\n+  num_args = num_params + (is_interface ? 1 : 0);\n+  args = (ffi_type **) __go_alloc (num_args * sizeof (ffi_type *));\n+  i = 0;\n+  off = 0;\n+  if (is_interface)\n+    {\n+      args[0] = &ffi_type_pointer;\n+      off = 1;\n+    }\n+  else if (is_method)\n+    {\n+      args[0] = &ffi_type_pointer;\n+      i = 1;\n+    }\n+  for (; i < num_params; ++i)\n+    args[i + off] = go_type_to_ffi (in_types[i]);\n+\n+  rettype = go_func_return_ffi (func);\n+\n+  status = ffi_prep_cif (cif, FFI_DEFAULT_ABI, num_args, rettype, args);\n+  __go_assert (status == FFI_OK);\n+}\n+\n+#endif /* defined(USE_LIBFFI) */"}, {"sha": "afae4b6d6ed8f87791df7c7c0c55ab8c680bec44", "filename": "libgo/runtime/go-ffi.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-ffi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-ffi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-ffi.h?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -0,0 +1,16 @@\n+/* go-ffi.c -- convert Go type description to libffi.\n+\n+   Copyright 2014 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"config.h\"\n+#include \"go-type.h\"\n+\n+#ifdef USE_LIBFFI\n+\n+#include \"ffi.h\"\n+\n+void __go_func_to_cif (const struct __go_func_type *, _Bool, _Bool, ffi_cif *);\n+\n+#endif"}, {"sha": "bcaa7e1ee382ab82addc6dd02eabb412c2b3aed1", "filename": "libgo/runtime/go-panic.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-panic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-panic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.h?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -38,6 +38,12 @@ extern void __go_print_string (struct String);\n \n extern struct __go_empty_interface __go_recover (void);\n \n+extern _Bool __go_can_recover (const void *);\n+\n+extern void __go_makefunc_can_recover (const void *retaddr);\n+\n+extern void __go_makefunc_returning (void);\n+\n extern void __go_unwind_stack (void);\n \n #endif /* !defined(LIBGO_GO_PANIC_H) */"}, {"sha": "2d3db55cbc95878b1d98b6291f46875eee2504d4", "filename": "libgo/runtime/go-recover.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-recover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-recover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-recover.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -63,7 +63,7 @@ __go_can_recover (const void *retaddr)\n   if (!d->__makefunc_can_recover)\n     return 0;\n \n-  if (runtime_callers (2, &loc, 1) < 1)\n+  if (runtime_callers (2, &loc, 1, false) < 1)\n     return 0;\n \n   /* If we have no function name, then we weren't called by Go code.\n@@ -84,9 +84,10 @@ __go_can_recover (const void *retaddr)\n   if (name[0] == 'f' && name[1] == 'f' && name[2] == 'i' && name[3] == '_')\n     return 1;\n \n-  /* We may also be called by reflect.makeFuncImpl.call, for a\n-     function created by reflect.MakeFunc.  */\n-  if (__builtin_strstr ((const char *) name, \"makeFuncImpl\") != NULL)\n+  /* We may also be called by reflect.makeFuncImpl.call or\n+     reflect.ffiCall, for a function created by reflect.MakeFunc.  */\n+  if (__builtin_strstr ((const char *) name, \"makeFuncImpl\") != NULL\n+      || __builtin_strcmp ((const char *) name, \"reflect.ffiCall\") == 0)\n     return 1;\n \n   return 0;"}, {"sha": "dfc703eb2c827c92ba06511104228ff7a37dab03", "filename": "libgo/runtime/go-reflect-call.c", "status": "modified", "additions": 2, "deletions": 317, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-reflect-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-reflect-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-call.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -15,333 +15,18 @@\n \n #ifdef USE_LIBFFI\n \n-#include \"ffi.h\"\n+#include \"go-ffi.h\"\n \n /* The functions in this file are only called from reflect_call.  As\n    reflect_call calls a libffi function, which will be compiled\n    without -fsplit-stack, it will always run with a large stack.  */\n \n-static ffi_type *go_array_to_ffi (const struct __go_array_type *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_slice_to_ffi (const struct __go_slice_type *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_struct_to_ffi (const struct __go_struct_type *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_string_to_ffi (void) __attribute__ ((no_split_stack));\n-static ffi_type *go_interface_to_ffi (void) __attribute__ ((no_split_stack));\n-static ffi_type *go_complex_to_ffi (ffi_type *)\n-  __attribute__ ((no_split_stack, unused));\n-static ffi_type *go_type_to_ffi (const struct __go_type_descriptor *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_func_return_ffi (const struct __go_func_type *)\n-  __attribute__ ((no_split_stack));\n-static void go_func_to_cif (const struct __go_func_type *, _Bool, _Bool,\n-\t\t\t    ffi_cif *)\n-  __attribute__ ((no_split_stack));\n static size_t go_results_size (const struct __go_func_type *)\n   __attribute__ ((no_split_stack));\n static void go_set_results (const struct __go_func_type *, unsigned char *,\n \t\t\t    void **)\n   __attribute__ ((no_split_stack));\n \n-/* Return an ffi_type for a Go array type.  The libffi library does\n-   not have any builtin support for passing arrays as values.  We work\n-   around this by pretending that the array is a struct.  */\n-\n-static ffi_type *\n-go_array_to_ffi (const struct __go_array_type *descriptor)\n-{\n-  ffi_type *ret;\n-  uintptr_t len;\n-  ffi_type *element;\n-  uintptr_t i;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  len = descriptor->__len;\n-  ret->elements = (ffi_type **) __go_alloc ((len + 1) * sizeof (ffi_type *));\n-  element = go_type_to_ffi (descriptor->__element_type);\n-  for (i = 0; i < len; ++i)\n-    ret->elements[i] = element;\n-  ret->elements[len] = NULL;\n-  return ret;\n-}\n-\n-/* Return an ffi_type for a Go slice type.  This describes the\n-   __go_open_array type defines in array.h.  */\n-\n-static ffi_type *\n-go_slice_to_ffi (\n-    const struct __go_slice_type *descriptor __attribute__ ((unused)))\n-{\n-  ffi_type *ret;\n-  ffi_type *ffi_intgo;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (4 * sizeof (ffi_type *));\n-  ret->elements[0] = &ffi_type_pointer;\n-  ffi_intgo = sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n-  ret->elements[1] = ffi_intgo;\n-  ret->elements[2] = ffi_intgo;\n-  ret->elements[3] = NULL;\n-  return ret;\n-}\n-\n-/* Return an ffi_type for a Go struct type.  */\n-\n-static ffi_type *\n-go_struct_to_ffi (const struct __go_struct_type *descriptor)\n-{\n-  ffi_type *ret;\n-  int field_count;\n-  const struct __go_struct_field *fields;\n-  int i;\n-\n-  field_count = descriptor->__fields.__count;\n-  if (field_count == 0) {\n-    return &ffi_type_void;\n-  }\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  fields = (const struct __go_struct_field *) descriptor->__fields.__values;\n-  ret->elements = (ffi_type **) __go_alloc ((field_count + 1)\n-\t\t\t\t\t    * sizeof (ffi_type *));\n-  for (i = 0; i < field_count; ++i)\n-    ret->elements[i] = go_type_to_ffi (fields[i].__type);\n-  ret->elements[field_count] = NULL;\n-  return ret;\n-}\n-\n-/* Return an ffi_type for a Go string type.  This describes the String\n-   struct.  */\n-\n-static ffi_type *\n-go_string_to_ffi (void)\n-{\n-  ffi_type *ret;\n-  ffi_type *ffi_intgo;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n-  ret->elements[0] = &ffi_type_pointer;\n-  ffi_intgo = sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n-  ret->elements[1] = ffi_intgo;\n-  ret->elements[2] = NULL;\n-  return ret;\n-}\n-\n-/* Return an ffi_type for a Go interface type.  This describes the\n-   __go_interface and __go_empty_interface structs.  */\n-\n-static ffi_type *\n-go_interface_to_ffi (void)\n-{\n-  ffi_type *ret;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n-  ret->elements[0] = &ffi_type_pointer;\n-  ret->elements[1] = &ffi_type_pointer;\n-  ret->elements[2] = NULL;\n-  return ret;\n-}\n-\n-/* Return an ffi_type for a Go complex type.  */\n-\n-static ffi_type *\n-go_complex_to_ffi (ffi_type *float_type)\n-{\n-  ffi_type *ret;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n-  ret->elements[0] = float_type;\n-  ret->elements[1] = float_type;\n-  ret->elements[2] = NULL;\n-  return ret;\n-}\n-\n-/* Return an ffi_type for a type described by a\n-   __go_type_descriptor.  */\n-\n-static ffi_type *\n-go_type_to_ffi (const struct __go_type_descriptor *descriptor)\n-{\n-  switch (descriptor->__code & GO_CODE_MASK)\n-    {\n-    case GO_BOOL:\n-      if (sizeof (_Bool) == 1)\n-\treturn &ffi_type_uint8;\n-      else if (sizeof (_Bool) == sizeof (int))\n-\treturn &ffi_type_uint;\n-      abort ();\n-    case GO_FLOAT32:\n-      if (sizeof (float) == 4)\n-\treturn &ffi_type_float;\n-      abort ();\n-    case GO_FLOAT64:\n-      if (sizeof (double) == 8)\n-\treturn &ffi_type_double;\n-      abort ();\n-    case GO_COMPLEX64:\n-#ifdef __alpha__\n-      runtime_throw(\"the libffi library does not support Complex64 type with \"\n-\t\t    \"reflect.Call or runtime.SetFinalizer\");\n-#else\n-      if (sizeof (float) == 4)\n-\treturn go_complex_to_ffi (&ffi_type_float);\n-      abort ();\n-#endif\n-    case GO_COMPLEX128:\n-#ifdef __alpha__\n-      runtime_throw(\"the libffi library does not support Complex128 type with \"\n-\t\t    \"reflect.Call or runtime.SetFinalizer\");\n-#else\n-      if (sizeof (double) == 8)\n-\treturn go_complex_to_ffi (&ffi_type_double);\n-      abort ();\n-#endif\n-    case GO_INT16:\n-      return &ffi_type_sint16;\n-    case GO_INT32:\n-      return &ffi_type_sint32;\n-    case GO_INT64:\n-      return &ffi_type_sint64;\n-    case GO_INT8:\n-      return &ffi_type_sint8;\n-    case GO_INT:\n-      return sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n-    case GO_UINT16:\n-      return &ffi_type_uint16;\n-    case GO_UINT32:\n-      return &ffi_type_uint32;\n-    case GO_UINT64:\n-      return &ffi_type_uint64;\n-    case GO_UINT8:\n-      return &ffi_type_uint8;\n-    case GO_UINT:\n-      return sizeof (uintgo) == 4 ? &ffi_type_uint32 : &ffi_type_uint64;\n-    case GO_UINTPTR:\n-      if (sizeof (void *) == 2)\n-\treturn &ffi_type_uint16;\n-      else if (sizeof (void *) == 4)\n-\treturn &ffi_type_uint32;\n-      else if (sizeof (void *) == 8)\n-\treturn &ffi_type_uint64;\n-      abort ();\n-    case GO_ARRAY:\n-      return go_array_to_ffi ((const struct __go_array_type *) descriptor);\n-    case GO_SLICE:\n-      return go_slice_to_ffi ((const struct __go_slice_type *) descriptor);\n-    case GO_STRUCT:\n-      return go_struct_to_ffi ((const struct __go_struct_type *) descriptor);\n-    case GO_STRING:\n-      return go_string_to_ffi ();\n-    case GO_INTERFACE:\n-      return go_interface_to_ffi ();\n-    case GO_CHAN:\n-    case GO_FUNC:\n-    case GO_MAP:\n-    case GO_PTR:\n-    case GO_UNSAFE_POINTER:\n-      /* These types are always pointers, and for FFI purposes nothing\n-\t else matters.  */\n-      return &ffi_type_pointer;\n-    default:\n-      abort ();\n-    }\n-}\n-\n-/* Return the return type for a function, given the number of out\n-   parameters and their types.  */\n-\n-static ffi_type *\n-go_func_return_ffi (const struct __go_func_type *func)\n-{\n-  int count;\n-  const struct __go_type_descriptor **types;\n-  ffi_type *ret;\n-  int i;\n-\n-  count = func->__out.__count;\n-  if (count == 0)\n-    return &ffi_type_void;\n-\n-  types = (const struct __go_type_descriptor **) func->__out.__values;\n-\n-  if (count == 1)\n-    {\n-\n-#if defined (__i386__) && !defined (__x86_64__)\n-      /* FFI does not support complex types.  On 32-bit x86, a\n-\t complex64 will be returned in %eax/%edx.  We normally tell\n-\t FFI that a complex64 is a struct of two floats.  On 32-bit\n-\t x86 a struct of two floats is returned via a hidden first\n-\t pointer parameter.  Fortunately we can make everything work\n-\t by pretending that complex64 is int64.  */\n-      if ((types[0]->__code & GO_CODE_MASK) == GO_COMPLEX64)\n-\treturn &ffi_type_sint64;\n-#endif\n-\n-      return go_type_to_ffi (types[0]);\n-    }\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc ((count + 1) * sizeof (ffi_type *));\n-  for (i = 0; i < count; ++i)\n-    ret->elements[i] = go_type_to_ffi (types[i]);\n-  ret->elements[count] = NULL;\n-  return ret;\n-}\n-\n-/* Build an ffi_cif structure for a function described by a\n-   __go_func_type structure.  */\n-\n-static void\n-go_func_to_cif (const struct __go_func_type *func, _Bool is_interface,\n-\t\t_Bool is_method, ffi_cif *cif)\n-{\n-  int num_params;\n-  const struct __go_type_descriptor **in_types;\n-  size_t num_args;\n-  ffi_type **args;\n-  int off;\n-  int i;\n-  ffi_type *rettype;\n-  ffi_status status;\n-\n-  num_params = func->__in.__count;\n-  in_types = ((const struct __go_type_descriptor **)\n-\t      func->__in.__values);\n-\n-  num_args = num_params + (is_interface ? 1 : 0);\n-  args = (ffi_type **) __go_alloc (num_args * sizeof (ffi_type *));\n-  i = 0;\n-  off = 0;\n-  if (is_interface)\n-    {\n-      args[0] = &ffi_type_pointer;\n-      off = 1;\n-    }\n-  else if (is_method)\n-    {\n-      args[0] = &ffi_type_pointer;\n-      i = 1;\n-    }\n-  for (; i < num_params; ++i)\n-    args[i + off] = go_type_to_ffi (in_types[i]);\n-\n-  rettype = go_func_return_ffi (func);\n-\n-  status = ffi_prep_cif (cif, FFI_DEFAULT_ABI, num_args, rettype, args);\n-  __go_assert (status == FFI_OK);\n-}\n-\n /* Get the total size required for the result parameters of a\n    function.  */\n \n@@ -532,7 +217,7 @@ reflect_call (const struct __go_func_type *func_type, FuncVal *func_val,\n   unsigned char *call_result;\n \n   __go_assert ((func_type->__common.__code & GO_CODE_MASK) == GO_FUNC);\n-  go_func_to_cif (func_type, is_interface, is_method, &cif);\n+  __go_func_to_cif (func_type, is_interface, is_method, &cif);\n \n   call_result = (unsigned char *) malloc (go_results_size (func_type));\n "}, {"sha": "7b33cca86815e39a2e8b568b8ecfb3d4bebd5d43", "filename": "libgo/runtime/go-traceback.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-traceback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fgo-traceback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-traceback.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -16,7 +16,7 @@ runtime_traceback ()\n   Location locbuf[100];\n   int32 c;\n \n-  c = runtime_callers (1, locbuf, nelem (locbuf));\n+  c = runtime_callers (1, locbuf, nelem (locbuf), false);\n   runtime_printtrace (locbuf, c, true);\n }\n "}, {"sha": "d9c220bca23fcefcae33d73171bb7bc5ae777979", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -186,7 +186,7 @@ runtime_MProf_Malloc(void *p, uintptr size)\n \tBucket *b;\n \tint32 nstk;\n \n-\tnstk = runtime_callers(1, stk, nelem(stk));\n+\tnstk = runtime_callers(1, stk, nelem(stk), false);\n \truntime_lock(&proflock);\n \tb = stkbucket(MProf, size, stk, nstk, true);\n \tb->recent_allocs++;\n@@ -249,7 +249,7 @@ runtime_blockevent(int64 cycles, int32 skip)\n \tif(rate <= 0 || (rate > cycles && runtime_fastrand1()%rate > cycles))\n \t\treturn;\n \n-\tnstk = runtime_callers(skip, stk, nelem(stk));\n+\tnstk = runtime_callers(skip, stk, nelem(stk), false);\n \truntime_lock(&proflock);\n \tb = stkbucket(BProf, 0, stk, nstk, true);\n \tb->count++;\n@@ -449,7 +449,7 @@ saveg(G *gp, TRecord *r)\n \tLocation locstk[nelem(r->stk)];\n \n \tif(gp == runtime_g()) {\n-\t\tn = runtime_callers(0, locstk, nelem(r->stk));\n+\t\tn = runtime_callers(0, locstk, nelem(r->stk), false);\n \t\tfor(i = 0; i < n; i++)\n \t\t\tr->stk[i] = locstk[i].pc;\n \t}"}, {"sha": "4195aff76a78a5f87ba1964ffaf57af449c15bdc", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -756,7 +756,7 @@ gtraceback(G* gp)\n \ttraceback = gp->traceback;\n \tgp->traceback = nil;\n \ttraceback->c = runtime_callers(1, traceback->locbuf,\n-\t\tsizeof traceback->locbuf / sizeof traceback->locbuf[0]);\n+\t\tsizeof traceback->locbuf / sizeof traceback->locbuf[0], false);\n \truntime_gogo(traceback->gp);\n }\n \n@@ -766,7 +766,7 @@ mcommoninit(M *mp)\n \t// If there is no mcache runtime_callers() will crash,\n \t// and we are most likely in sysmon thread so the stack is senseless anyway.\n \tif(m->mcache)\n-\t\truntime_callers(1, mp->createstack, nelem(mp->createstack));\n+\t\truntime_callers(1, mp->createstack, nelem(mp->createstack), false);\n \n \tmp->fastrand = 0x49f6428aUL + mp->id + runtime_cputicks();\n \n@@ -2584,7 +2584,7 @@ runtime_sigprof()\n \t}\n \n \tif(traceback) {\n-\t\tn = runtime_callers(0, prof.locbuf, nelem(prof.locbuf));\n+\t\tn = runtime_callers(0, prof.locbuf, nelem(prof.locbuf), false);\n \t\tfor(i = 0; i < n; i++)\n \t\t\tprof.pcbuf[i] = prof.locbuf[i].pc;\n \t}"}, {"sha": "6650be1b3d349488260b22c10bfd060aacd2a0ba", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dffa7328356257772dc7c00fe73aeb315229b373/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=dffa7328356257772dc7c00fe73aeb315229b373", "patch": "@@ -609,7 +609,7 @@ void\truntime_exitsyscall(void) __asm__ (GOSYM_PREFIX \"syscall.Exitsyscall\");\n G*\t__go_go(void (*pfn)(void*), void*);\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n-int32\truntime_callers(int32, Location*, int32);\n+int32\truntime_callers(int32, Location*, int32, bool keep_callers);\n int64\truntime_nanotime(void);\t// monotonic time\n int64\truntime_unixnanotime(void); // real time, can skip\n void\truntime_dopanic(int32) __attribute__ ((noreturn));"}]}