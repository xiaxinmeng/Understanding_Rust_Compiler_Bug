{"sha": "9e7d1164368531bd7747f4f6f93d3c90b6018354", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU3ZDExNjQzNjg1MzFiZDc3NDdmNGY2ZjkzZDNjOTBiNjAxODM1NA==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T16:13:07Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T16:13:07Z"}, "message": "* lex.c: Convert to ISO C.\n\nFrom-SVN: r67904", "tree": {"sha": "34171868ddcece2398d5aef6b8883d3fb815ce0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34171868ddcece2398d5aef6b8883d3fb815ce0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e7d1164368531bd7747f4f6f93d3c90b6018354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7d1164368531bd7747f4f6f93d3c90b6018354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7d1164368531bd7747f4f6f93d3c90b6018354", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7d1164368531bd7747f4f6f93d3c90b6018354/comments", "author": null, "committer": null, "parents": [{"sha": "362efdc10b1a46b86153662300a9e6cf554dccd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362efdc10b1a46b86153662300a9e6cf554dccd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/362efdc10b1a46b86153662300a9e6cf554dccd6"}], "stats": {"total": 121, "additions": 47, "deletions": 74}, "files": [{"sha": "9c3069d2a816845286d3af207a15106dc75979d8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7d1164368531bd7747f4f6f93d3c90b6018354/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7d1164368531bd7747f4f6f93d3c90b6018354/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e7d1164368531bd7747f4f6f93d3c90b6018354", "patch": "@@ -1,5 +1,7 @@\n 2003-06-13  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n+\t* lex.c: Convert to ISO C.\n+\n \t2003-05-19  Jens-Michael Hoffmann  <jensmh@gmx.de>\n \t* init.c: removes use of PARAMS macro.  Use ISO style function\n \tdeclarations.  (Not copyright-significant change.)"}, {"sha": "1f8cb0672a39aaf1953ffecb815773e0fc54417b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 45, "deletions": 74, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7d1164368531bd7747f4f6f93d3c90b6018354/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7d1164368531bd7747f4f6f93d3c90b6018354/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=9e7d1164368531bd7747f4f6f93d3c90b6018354", "patch": "@@ -40,19 +40,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n \n-static int interface_strcmp PARAMS ((const char *));\n-static void init_cp_pragma PARAMS ((void));\n+static int interface_strcmp (const char *);\n+static void init_cp_pragma (void);\n \n-static tree parse_strconst_pragma PARAMS ((const char *, int));\n-static void handle_pragma_vtable PARAMS ((cpp_reader *));\n-static void handle_pragma_unit PARAMS ((cpp_reader *));\n-static void handle_pragma_interface PARAMS ((cpp_reader *));\n-static void handle_pragma_implementation PARAMS ((cpp_reader *));\n-static void handle_pragma_java_exceptions PARAMS ((cpp_reader *));\n+static tree parse_strconst_pragma (const char *, int);\n+static void handle_pragma_vtable (cpp_reader *);\n+static void handle_pragma_unit (cpp_reader *);\n+static void handle_pragma_interface (cpp_reader *);\n+static void handle_pragma_implementation (cpp_reader *);\n+static void handle_pragma_java_exceptions (cpp_reader *);\n \n-static int is_global PARAMS ((tree));\n-static void init_operators PARAMS ((void));\n-static void copy_lang_type PARAMS ((tree));\n+static int is_global (tree);\n+static void init_operators (void);\n+static void copy_lang_type (tree);\n \n /* A constraint that can be tested at compile time.  */\n #define CONSTRAINT(name, expr) extern int constraint_##name [(expr) ? 1 : -1]\n@@ -94,8 +94,7 @@ static struct impl_files *impl_file_chain;\n    and whose type is the modifier list.  */\n \n tree\n-make_pointer_declarator (cv_qualifiers, target)\n-     tree cv_qualifiers, target;\n+make_pointer_declarator (tree cv_qualifiers, tree target)\n {\n   if (target && TREE_CODE (target) == IDENTIFIER_NODE\n       && ANON_AGGRNAME_P (target))\n@@ -114,17 +113,16 @@ make_pointer_declarator (cv_qualifiers, target)\n    and whose type is the modifier list.  */\n \n tree\n-make_reference_declarator (cv_qualifiers, target)\n-     tree cv_qualifiers, target;\n+make_reference_declarator (tree cv_qualifiers, tree target)\n {\n   target = build_nt (ADDR_EXPR, target);\n   TREE_TYPE (target) = cv_qualifiers;\n   return target;\n }\n \n tree\n-make_call_declarator (target, parms, cv_qualifiers, exception_specification)\n-     tree target, parms, cv_qualifiers, exception_specification;\n+make_call_declarator (tree target, tree parms, tree cv_qualifiers, \n+                      tree exception_specification)\n {\n   target = build_nt (CALL_EXPR, target,\n \t\t     tree_cons (parms, cv_qualifiers, NULL_TREE),\n@@ -136,8 +134,8 @@ make_call_declarator (target, parms, cv_qualifiers, exception_specification)\n }\n \n void\n-set_quals_and_spec (call_declarator, cv_qualifiers, exception_specification)\n-     tree call_declarator, cv_qualifiers, exception_specification;\n+set_quals_and_spec (tree call_declarator, tree cv_qualifiers, \n+                    tree exception_specification)\n {\n   CALL_DECLARATOR_QUALS (call_declarator) = cv_qualifiers;\n   CALL_DECLARATOR_EXCEPTION_SPEC (call_declarator) = exception_specification;\n@@ -151,7 +149,7 @@ int interface_unknown;\t\t/* whether or not we know this class\n \f\n /* Initialization before switch parsing.  */\n int\n-cxx_init_options ()\n+cxx_init_options (void)\n {\n   /* Default exceptions on.  */\n   flag_exceptions = 1;\n@@ -166,7 +164,7 @@ cxx_init_options ()\n }\n \n void\n-cxx_finish ()\n+cxx_finish (void)\n {\n   c_common_finish ();\n }\n@@ -184,7 +182,7 @@ operator_name_info_t assignment_operator_name_info[(int) LAST_CPLUS_TREE_CODE];\n #undef DEF_OPERATOR\n \n static void\n-init_operators ()\n+init_operators (void)\n {\n   tree identifier;\n   char buffer[256];\n@@ -367,7 +365,7 @@ static const struct resword reswords[] =\n };\n \n void\n-init_reswords ()\n+init_reswords (void)\n {\n   unsigned int i;\n   tree id;\n@@ -386,7 +384,7 @@ init_reswords ()\n }\n \n static void\n-init_cp_pragma ()\n+init_cp_pragma (void)\n {\n   c_register_pragma (0, \"vtable\", handle_pragma_vtable);\n   c_register_pragma (0, \"unit\", handle_pragma_unit);\n@@ -461,7 +459,7 @@ cxx_init (void)\n    information.  */\n \n void\n-extract_interface_info ()\n+extract_interface_info (void)\n {\n   struct c_fileinfo *finfo = 0;\n \n@@ -483,8 +481,7 @@ extract_interface_info ()\n    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */\n \n static int\n-interface_strcmp (s)\n-     const char *s;\n+interface_strcmp (const char* s)\n {\n   /* Set the interface/implementation bits for this scope.  */\n   struct impl_files *ifiles;\n@@ -521,8 +518,7 @@ interface_strcmp (s)\n }\n \n void\n-note_got_semicolon (type)\n-     tree type;\n+note_got_semicolon (tree type)\n {\n   if (!TYPE_P (type))\n     abort ();\n@@ -531,8 +527,7 @@ note_got_semicolon (type)\n }\n \n void\n-note_list_got_semicolon (declspecs)\n-     tree declspecs;\n+note_list_got_semicolon (tree declspecs)\n {\n   tree link;\n \n@@ -549,9 +544,7 @@ note_list_got_semicolon (declspecs)\n /* Parse a #pragma whose sole argument is a string constant.\n    If OPT is true, the argument is optional.  */\n static tree\n-parse_strconst_pragma (name, opt)\n-     const char *name;\n-     int opt;\n+parse_strconst_pragma (const char* name, int opt)\n {\n   tree result, x;\n   enum cpp_ttype t;\n@@ -573,24 +566,21 @@ parse_strconst_pragma (name, opt)\n }\n \n static void\n-handle_pragma_vtable (dfile)\n-     cpp_reader *dfile ATTRIBUTE_UNUSED;\n+handle_pragma_vtable (cpp_reader* dfile ATTRIBUTE_UNUSED )\n {\n   parse_strconst_pragma (\"vtable\", 0);\n   sorry (\"#pragma vtable no longer supported\");\n }\n \n static void\n-handle_pragma_unit (dfile)\n-     cpp_reader *dfile ATTRIBUTE_UNUSED;\n+handle_pragma_unit (cpp_reader* dfile ATTRIBUTE_UNUSED )\n {\n   /* Validate syntax, but don't do anything.  */\n   parse_strconst_pragma (\"unit\", 0);\n }\n \n static void\n-handle_pragma_interface (dfile)\n-     cpp_reader *dfile ATTRIBUTE_UNUSED;\n+handle_pragma_interface (cpp_reader* dfile ATTRIBUTE_UNUSED )\n {\n   tree fname = parse_strconst_pragma (\"interface\", 1);\n   struct c_fileinfo *finfo;\n@@ -632,8 +622,7 @@ handle_pragma_interface (dfile)\n    a matching #p interface for this to have any effect.  */\n \n static void\n-handle_pragma_implementation (dfile)\n-     cpp_reader *dfile ATTRIBUTE_UNUSED;\n+handle_pragma_implementation (cpp_reader* dfile ATTRIBUTE_UNUSED )\n {\n   tree fname = parse_strconst_pragma (\"implementation\", 1);\n   const char *main_filename;\n@@ -674,8 +663,7 @@ handle_pragma_implementation (dfile)\n \n /* Indicate that this file uses Java-personality exception handling.  */\n static void\n-handle_pragma_java_exceptions (dfile)\n-     cpp_reader *dfile ATTRIBUTE_UNUSED;\n+handle_pragma_java_exceptions (cpp_reader* dfile ATTRIBUTE_UNUSED )\n {\n   tree x;\n   if (c_lex (&x) != CPP_EOF)\n@@ -687,8 +675,7 @@ handle_pragma_java_exceptions (dfile)\n /* Return true if d is in a global scope.  */\n \n static int\n-is_global (d)\n-  tree d;\n+is_global (tree d)\n {\n   while (1)\n     switch (TREE_CODE (d))\n@@ -740,9 +727,7 @@ unqualified_name_lookup_error (tree name)\n }\n \n tree\n-do_identifier (token, args)\n-     register tree token;\n-     tree args;\n+do_identifier (register tree token, tree args)\n {\n   register tree id;\n \n@@ -821,9 +806,7 @@ do_identifier (token, args)\n }\n \n tree\n-do_scoped_id (token, id)\n-     tree token;\n-     tree id;\n+do_scoped_id (tree token, tree id)\n {\n   timevar_push (TV_NAME_LOOKUP);\n   if (!id || (TREE_CODE (id) == FUNCTION_DECL\n@@ -872,8 +855,7 @@ do_scoped_id (token, id)\n }\n \n tree\n-identifier_typedecl_value (node)\n-     tree node;\n+identifier_typedecl_value (tree node)\n {\n   tree t, type;\n   type = IDENTIFIER_TYPE_VALUE (node);\n@@ -932,10 +914,7 @@ extern int tree_node_sizes[];\n #endif\n \n tree\n-build_lang_decl (code, name, type)\n-     enum tree_code code;\n-     tree name;\n-     tree type;\n+build_lang_decl (enum tree_code code, tree name, tree type)\n {\n   tree t;\n \n@@ -949,8 +928,7 @@ build_lang_decl (code, name, type)\n    and pushdecl (for functions generated by the backend).  */\n \n void\n-retrofit_lang_decl (t)\n-     tree t;\n+retrofit_lang_decl (tree t)\n {\n   struct lang_decl *ld;\n   size_t size;\n@@ -984,8 +962,7 @@ retrofit_lang_decl (t)\n }\n \n void\n-cxx_dup_lang_specific_decl (node)\n-     tree node;\n+cxx_dup_lang_specific_decl (tree node)\n {\n   int size;\n   struct lang_decl *ld;\n@@ -1010,8 +987,7 @@ cxx_dup_lang_specific_decl (node)\n /* Copy DECL, including any language-specific parts.  */\n \n tree\n-copy_decl (decl)\n-     tree decl;\n+copy_decl (tree decl)\n {\n   tree copy;\n \n@@ -1023,8 +999,7 @@ copy_decl (decl)\n /* Replace the shared language-specific parts of NODE with a new copy.  */\n \n static void\n-copy_lang_type (node)\n-     tree node;\n+copy_lang_type (tree node)\n {\n   int size;\n   struct lang_type *lt;\n@@ -1049,8 +1024,7 @@ copy_lang_type (node)\n /* Copy TYPE, including any language-specific parts.  */\n \n tree\n-copy_type (type)\n-     tree type;\n+copy_type (tree type)\n {\n   tree copy;\n \n@@ -1060,8 +1034,7 @@ copy_type (type)\n }\n \n tree\n-cxx_make_type (code)\n-     enum tree_code code;\n+cxx_make_type (enum tree_code code)\n {\n   register tree t = make_node (code);\n \n@@ -1113,8 +1086,7 @@ cxx_make_type (code)\n }\n \n tree\n-make_aggr_type (code)\n-     enum tree_code code;\n+make_aggr_type (enum tree_code code)\n {\n   tree t = cxx_make_type (code);\n \n@@ -1128,8 +1100,7 @@ make_aggr_type (code)\n    RID.  */\n \n int\n-cp_type_qual_from_rid (rid)\n-     tree rid;\n+cp_type_qual_from_rid (tree rid)\n {\n   if (rid == ridpointers[(int) RID_CONST])\n     return TYPE_QUAL_CONST;"}]}