{"sha": "bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5ZWMwZTA2YjRlMDc0YjJhNWM3NWMyMWY4ZjdlZWZiZGI4OGM4Zg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-05-05T19:33:52Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-05-05T19:33:52Z"}, "message": "rs6000.c (validate_condition_mode): Use flag_finite_math_only.\n\n2003-05-05  Geoffrey Keating  <geoffk@apple.com>\n\n\t* config/rs6000/rs6000.c (validate_condition_mode): Use\n\tflag_finite_math_only.\n\t(rs6000_reverse_condition): Never return UNKNOWN; use\n\tflag_finite_math_only.\n\t(rs6000_generate_compare): Use flag_finite_math_only.\n\t(rs6000_emit_cmove): Handle UNLE.  Support UNEQ under -ffast-math.\n\tUse HONOR_* rather than flag_unsafe_math_optimizations.  Correct\n\tUNGE and GT cases.  Handle UNEQ and LTGT when ! HONOR_NANS.\n\nIndex: testsuite/ChangeLog\n2003-05-05  Geoffrey Keating  <geoffk@apple.com>\n\n\t* gcc.c-torture/execute/ieee/fp-cmp-8.c: New test.\n\t* gcc.dg/ppc-fsel-2.c: New test.\n\nFrom-SVN: r66499", "tree": {"sha": "0e5be2a8db71f0d0635751e3cb960ed2c9c73e7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e5be2a8db71f0d0635751e3cb960ed2c9c73e7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3e9f1084699af912b12b5a63c64c72dc868854f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3e9f1084699af912b12b5a63c64c72dc868854f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3e9f1084699af912b12b5a63c64c72dc868854f"}], "stats": {"total": 271, "additions": 254, "deletions": 17}, "files": [{"sha": "573ec59e6e78961bcb16c6be7583e146c57eeb5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "patch": "@@ -22,6 +22,15 @@\n \n 2003-05-05  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* config/rs6000/rs6000.c (validate_condition_mode): Use\n+\tflag_finite_math_only.\n+\t(rs6000_reverse_condition): Never return UNKNOWN; use\n+\tflag_finite_math_only.\n+\t(rs6000_generate_compare): Use flag_finite_math_only.\n+\t(rs6000_emit_cmove): Handle UNLE.  Support UNEQ under -ffast-math.\n+\tUse HONOR_* rather than flag_unsafe_math_optimizations.  Correct\n+\tUNGE and GT cases.  Handle UNEQ and LTGT when ! HONOR_NANS.  \n+\n \t* toplev.c (check_global_declarations): Suppress not-used warning\n \tfor volatile variables.\n "}, {"sha": "4847a8572bd22b6cd0bb317cbfffc62dace468b0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "patch": "@@ -7191,9 +7191,8 @@ validate_condition_mode (code, mode)\n     abort ();\n   \n   /* These should never be generated except for \n-     flag_unsafe_math_optimizations and flag_finite_math_only.  */\n+     flag_finite_math_only.  */\n   if (mode == CCFPmode\n-      && ! flag_unsafe_math_optimizations\n       && ! flag_finite_math_only\n       && (code == LE || code == GE\n \t  || code == UNEQ || code == LTGT\n@@ -8637,7 +8636,10 @@ rs6000_reverse_condition (mode, code)\n {\n   /* Reversal of FP compares takes care -- an ordered compare\n      becomes an unordered compare and vice versa.  */\n-  if (mode == CCFPmode && !flag_unsafe_math_optimizations)\n+  if (mode == CCFPmode \n+      && (!flag_finite_math_only\n+\t  || code == UNLT || code == UNLE || code == UNGT || code == UNGE\n+\t  || code == UNEQ || code == LTGT))\n     return reverse_condition_maybe_unordered (code);\n   else\n     return reverse_condition (code);\n@@ -8676,7 +8678,7 @@ rs6000_generate_compare (code)\n \tcase UNEQ:\n \tcase NE:\n \tcase LTGT:\n-\t  cmp = flag_unsafe_math_optimizations\n+\t  cmp = flag_finite_math_only\n \t    ? gen_tstsfeq_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1)\n \t    : gen_cmpsfeq_gpr (compare_result, rs6000_compare_op0,\n@@ -8688,7 +8690,7 @@ rs6000_generate_compare (code)\n \tcase UNGE:\n \tcase GE:\n \tcase GEU:\n-\t  cmp = flag_unsafe_math_optimizations\n+\t  cmp = flag_finite_math_only\n \t    ? gen_tstsfgt_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1)\n \t    : gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n@@ -8700,7 +8702,7 @@ rs6000_generate_compare (code)\n \tcase UNLE:\n \tcase LE:\n \tcase LEU:\n-\t  cmp = flag_unsafe_math_optimizations\n+\t  cmp = flag_finite_math_only\n \t    ? gen_tstsflt_gpr (compare_result, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1)\n \t    : gen_cmpsflt_gpr (compare_result, rs6000_compare_op0,\n@@ -8732,7 +8734,7 @@ rs6000_generate_compare (code)\n \t  compare_result2 = gen_reg_rtx (CCFPmode);\n \n \t  /* Do the EQ.  */\n-\t  cmp = flag_unsafe_math_optimizations\n+\t  cmp = flag_finite_math_only\n \t    ? gen_tstsfeq_gpr (compare_result2, rs6000_compare_op0,\n \t\t\t       rs6000_compare_op1)\n \t    : gen_cmpsfeq_gpr (compare_result2, rs6000_compare_op0,\n@@ -8788,9 +8790,9 @@ rs6000_generate_compare (code)\n \t\t\t\t\t     rs6000_compare_op1)));\n   \n   /* Some kinds of FP comparisons need an OR operation;\n-     except for flag_unsafe_math_optimizations we don't bother.  */\n+     under flag_finite_math_only we don't bother.  */\n   if (rs6000_compare_fp_p\n-      && ! flag_unsafe_math_optimizations\n+      && ! flag_finite_math_only\n       && ! (TARGET_HARD_FLOAT && TARGET_E500 && !TARGET_FPRS)\n       && (code == LE || code == GE\n \t  || code == UNEQ || code == LTGT\n@@ -9069,7 +9071,7 @@ rs6000_emit_cmove (dest, op, true_cond, false_cond)\n   /* Eliminate half of the comparisons by switching operands, this\n      makes the remaining code simpler.  */\n   if (code == UNLT || code == UNGT || code == UNORDERED || code == NE\n-      || code == LTGT || code == LT)\n+      || code == LTGT || code == LT || code == UNLE)\n     {\n       code = reverse_condition_maybe_unordered (code);\n       temp = true_cond;\n@@ -9079,7 +9081,7 @@ rs6000_emit_cmove (dest, op, true_cond, false_cond)\n \n   /* UNEQ and LTGT take four instructions for a comparison with zero,\n      it'll probably be faster to use a branch here too.  */\n-  if (code == UNEQ)\n+  if (code == UNEQ && HONOR_NANS (compare_mode))\n     return 0;\n   \n   if (GET_CODE (op1) == CONST_DOUBLE)\n@@ -9090,7 +9092,7 @@ rs6000_emit_cmove (dest, op, true_cond, false_cond)\n      Inf - Inf is NaN which is not zero, and so if we don't\n      know that the operand is finite and the comparison\n      would treat EQ different to UNORDERED, we can't do it.  */\n-  if (! flag_unsafe_math_optimizations\n+  if (HONOR_INFINITIES (compare_mode)\n       && code != GT && code != UNGE\n       && (GET_CODE (op1) != CONST_DOUBLE || real_isinf (&c1))\n       /* Constructs of the form (a OP b ? a : b) are safe.  */\n@@ -9109,7 +9111,7 @@ rs6000_emit_cmove (dest, op, true_cond, false_cond)\n \n   /* If we don't care about NaNs we can reduce some of the comparisons\n      down to faster ones.  */\n-  if (flag_unsafe_math_optimizations)\n+  if (! HONOR_NANS (compare_mode))\n     switch (code)\n       {\n       case GT:\n@@ -9155,29 +9157,31 @@ rs6000_emit_cmove (dest, op, true_cond, false_cond)\n       break;\n \n     case UNGE:\n+      /* a UNGE 0 <-> (a GE 0 || -a UNLT 0) */\n       temp = gen_reg_rtx (result_mode);\n       emit_insn (gen_rtx_SET (VOIDmode, temp,\n \t\t\t      gen_rtx_IF_THEN_ELSE (result_mode,\n \t\t\t\t\t\t    gen_rtx_GE (VOIDmode,\n \t\t\t\t\t\t\t\top0, op1),\n \t\t\t\t\t\t    true_cond, false_cond)));\n-      false_cond = temp;\n-      true_cond = false_cond;\n+      false_cond = true_cond;\n+      true_cond = temp;\n \n       temp = gen_reg_rtx (compare_mode);\n       emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_NEG (compare_mode, op0)));\n       op0 = temp;\n       break;\n \n     case GT:\n+      /* a GT 0 <-> (a GE 0 && -a UNLT 0) */\n       temp = gen_reg_rtx (result_mode);\n       emit_insn (gen_rtx_SET (VOIDmode, temp,\n \t\t\t      gen_rtx_IF_THEN_ELSE (result_mode, \n \t\t\t\t\t\t    gen_rtx_GE (VOIDmode,\n \t\t\t\t\t\t\t\top0, op1),\n \t\t\t\t\t\t    true_cond, false_cond)));\n-      true_cond = temp;\n-      false_cond = true_cond;\n+      true_cond = false_cond;\n+      false_cond = temp;\n \n       temp = gen_reg_rtx (compare_mode);\n       emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_NEG (compare_mode, op0)));"}, {"sha": "90eb31bd8c38e0d6549331e9c5e5fd129b2b24f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "patch": "@@ -4,6 +4,9 @@\n \n 2003-05-05  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* gcc.c-torture/execute/ieee/fp-cmp-8.c: New test.\n+\t* gcc.dg/ppc-fsel-2.c: New test.\n+\n \t* gcc.dg/unused-5.c: New test.\n \n 2003-05-05  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>"}, {"sha": "225539b83eb1b6160cdde52cf098d55c802cd1a4", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-8.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-8.c?ref=bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "patch": "@@ -0,0 +1,141 @@\n+/* Like fp-cmp-4.c, but test that the cmove patterns are correct.  */\n+\n+static double\n+test_isunordered(double x, double y, double a, double b)\n+{\n+  return __builtin_isunordered(x, y) ? a : b;\n+}\n+\n+static double\n+test_not_isunordered(double x, double y, double a, double b)\n+{\n+  return !__builtin_isunordered(x, y) ? a : b;\n+}\n+\n+static double\n+test_isless(double x, double y, double a, double b)\n+{\n+  return __builtin_isless(x, y) ? a : b;\n+}\n+\n+static double\n+test_not_isless(double x, double y, double a, double b)\n+{\n+  return !__builtin_isless(x, y) ? a : b;\n+}\n+\n+static double\n+test_islessequal(double x, double y, double a, double b)\n+{\n+  return __builtin_islessequal(x, y) ? a : b;\n+}\n+\n+static double\n+test_not_islessequal(double x, double y, double a, double b)\n+{\n+  return !__builtin_islessequal(x, y) ? a : b;\n+}\n+\n+static double\n+test_isgreater(double x, double y, double a, double b)\n+{\n+  return __builtin_isgreater(x, y) ? a : b;\n+}\n+\n+static double\n+test_not_isgreater(double x, double y, double a, double b)\n+{\n+  return !__builtin_isgreater(x, y) ? a : b;\n+}\n+\n+static double\n+test_isgreaterequal(double x, double y, double a, double b)\n+{\n+  return __builtin_isgreaterequal(x, y) ? a : b;\n+}\n+\n+static double\n+test_not_isgreaterequal(double x, double y, double a, double b)\n+{\n+  return !__builtin_isgreaterequal(x, y) ? a : b;\n+}\n+\n+static double\n+test_islessgreater(double x, double y, double a, double b)\n+{\n+  return __builtin_islessgreater(x, y) ? a : b;\n+}\n+\n+static double\n+test_not_islessgreater(double x, double y, double a, double b)\n+{\n+  return !__builtin_islessgreater(x, y) ? a : b;\n+}\n+\n+static void\n+one_test(double x, double y, int expected,\n+         double (*pos) (double, double, double, double), \n+\t double (*neg) (double, double, double, double))\n+{\n+  if (((*pos)(x, y, 1.0, 2.0) == 1.0) != expected)\n+    abort ();\n+  if (((*neg)(x, y, 3.0, 4.0) == 4.0) != expected)\n+    abort ();\n+}\n+\n+#define NAN (0.0 / 0.0)\n+#define INF (1.0 / 0.0)\n+\n+int\n+main()\n+{\n+  struct try\n+  {\n+    double x, y;\n+    int result[6];\n+  };\n+\n+  static struct try const data[] =\n+  {\n+    { NAN, NAN, { 1, 0, 0, 0, 0, 0 } },\n+    { 0.0, NAN, { 1, 0, 0, 0, 0, 0 } },\n+    { NAN, 0.0, { 1, 0, 0, 0, 0, 0 } },\n+    { 0.0, 0.0, { 0, 0, 1, 0, 1, 0 } },\n+    { 1.0, 2.0, { 0, 1, 1, 0, 0, 1 } },\n+    { 2.0, 1.0, { 0, 0, 0, 1, 1, 1 } },\n+    { INF, 0.0, { 0, 0, 0, 1, 1, 1 } },\n+    { 1.0, INF, { 0, 1, 1, 0, 0, 1 } },\n+    { INF, INF, { 0, 0, 1, 0, 1, 0 } },\n+    { 0.0, -INF, { 0, 0, 0, 1, 1, 1 } },\n+    { -INF, 1.0, { 0, 1, 1, 0, 0, 1 } },\n+    { -INF, -INF, { 0, 0, 1, 0, 1, 0 } },\n+    { INF, -INF, { 0, 0, 0, 1, 1, 1 } },\n+    { -INF, INF, { 0, 1, 1, 0, 0, 1 } },\n+  };\n+\n+  struct test\n+  {\n+    double (*pos)(double, double, double, double);\n+    double (*neg)(double, double, double, double);\n+  };\n+\n+  static struct test const tests[] =\n+  {\n+    { test_isunordered, test_not_isunordered },\n+    { test_isless, test_not_isless },\n+    { test_islessequal, test_not_islessequal },\n+    { test_isgreater, test_not_isgreater },\n+    { test_isgreaterequal, test_not_isgreaterequal },\n+    { test_islessgreater, test_not_islessgreater }\n+  };\n+\n+  const int n = sizeof(data) / sizeof(data[0]);\n+  int i, j;\n+\n+  for (i = 0; i < n; ++i)\n+    for (j = 0; j < 6; ++j)\n+      one_test (data[i].x, data[i].y, data[i].result[j],\n+\t\ttests[j].pos, tests[j].neg);\n+\n+  exit (0);\n+}"}, {"sha": "9768b165c245a6d9ed2f349b9f81979fee9bfcc8", "filename": "gcc/testsuite/gcc.dg/ppc-fsel-2.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Ftestsuite%2Fgcc.dg%2Fppc-fsel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f/gcc%2Ftestsuite%2Fgcc.dg%2Fppc-fsel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fppc-fsel-2.c?ref=bc9ec0e06b4e074b2a5c75c21f8f7eefbdb88c8f", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-options \"-O -mpowerpc-gfxopt -g0 -ffinite-math-only\" } */\n+/* { dg-final { scan-assembler-not \"^L\" } } */\n+\n+/* Every single one of these should be compiled into straight-line\n+   code using fsel (or, in a few cases, hardwired to 'true' or\n+   'false'), no branches anywhere.  */\n+\n+double\n+test_isunordered(double x, double y, double a, double b)\n+{\n+  return __builtin_isunordered(x, y) ? a : b;\n+}\n+\n+double\n+test_not_isunordered(double x, double y, double a, double b)\n+{\n+  return !__builtin_isunordered(x, y) ? a : b;\n+}\n+\n+double\n+test_isless(double x, double y, double a, double b)\n+{\n+  return __builtin_isless(x, y) ? a : b;\n+}\n+\n+double\n+test_not_isless(double x, double y, double a, double b)\n+{\n+  return !__builtin_isless(x, y) ? a : b;\n+}\n+\n+double\n+test_islessequal(double x, double y, double a, double b)\n+{\n+  return __builtin_islessequal(x, y) ? a : b;\n+}\n+\n+double\n+test_not_islessequal(double x, double y, double a, double b)\n+{\n+  return !__builtin_islessequal(x, y) ? a : b;\n+}\n+\n+double\n+test_isgreater(double x, double y, double a, double b)\n+{\n+  return __builtin_isgreater(x, y) ? a : b;\n+}\n+\n+double\n+test_not_isgreater(double x, double y, double a, double b)\n+{\n+  return !__builtin_isgreater(x, y) ? a : b;\n+}\n+\n+double\n+test_isgreaterequal(double x, double y, double a, double b)\n+{\n+  return __builtin_isgreaterequal(x, y) ? a : b;\n+}\n+\n+double\n+test_not_isgreaterequal(double x, double y, double a, double b)\n+{\n+  return !__builtin_isgreaterequal(x, y) ? a : b;\n+}\n+\n+double\n+test_islessgreater(double x, double y, double a, double b)\n+{\n+  return __builtin_islessgreater(x, y) ? a : b;\n+}\n+\n+double\n+test_not_islessgreater(double x, double y, double a, double b)\n+{\n+  return !__builtin_islessgreater(x, y) ? a : b;\n+}\n+"}]}