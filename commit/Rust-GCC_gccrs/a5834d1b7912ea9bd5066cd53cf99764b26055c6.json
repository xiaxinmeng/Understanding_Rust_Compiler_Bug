{"sha": "a5834d1b7912ea9bd5066cd53cf99764b26055c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU4MzRkMWI3OTEyZWE5YmQ1MDY2Y2Q1M2NmOTk3NjRiMjYwNTVjNg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@purist.soma.redhat.com", "date": "2000-08-22T08:18:10Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-08-22T08:18:10Z"}, "message": "codecvt.h: Implement codecvt<wchar_t, char, mbstate_t>.\n\n\n2000-08-21  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* bits/codecvt.h: Implement codecvt<wchar_t, char, mbstate_t>. Fix\n\tup __enc_traits template so as to be marginally useful.\n\t* src/codecvt.cc: And here.\n\t* bits/char_traits: Tweak.\n\t* bits/locale_facets.h: Tweak.\n\t* bits/locale_facets.tcc: Tweak.\n\t* bits/localefwd.h: Tweak.\n\t* src/locale-inst.cc: Add use_facet/has_facet instantiations here.\n\t* testsuite/22_locale/codecvt_wchar_t_cc.cc: New file.\n\t* testsuite/22_locale/codecvt_char_char.cc: New file.\n\t* testsuite/22_locale/codecvt_unicode_char.cc: New file.\n\nFrom-SVN: r35870", "tree": {"sha": "5208c08351eec22070a9a231c88f51f4119b3b89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5208c08351eec22070a9a231c88f51f4119b3b89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5834d1b7912ea9bd5066cd53cf99764b26055c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5834d1b7912ea9bd5066cd53cf99764b26055c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5834d1b7912ea9bd5066cd53cf99764b26055c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5834d1b7912ea9bd5066cd53cf99764b26055c6/comments", "author": null, "committer": null, "parents": [{"sha": "199acebbefe62e469b374d455fd02c47584387d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/199acebbefe62e469b374d455fd02c47584387d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/199acebbefe62e469b374d455fd02c47584387d8"}], "stats": {"total": 541, "additions": 406, "deletions": 135}, "files": [{"sha": "f66ac57ddfbaa73c7fa46f44bf70491853e58e88", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -1,3 +1,17 @@\n+2000-08-21  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+\n+\t* bits/codecvt.h: Implement codecvt<wchar_t, char, mbstate_t>. Fix\n+\tup __enc_traits template so as to be marginally useful.\n+\t* src/codecvt.cc: And here.\n+\t* bits/char_traits: Tweak.\n+\t* bits/locale_facets.h: Tweak.\n+\t* bits/locale_facets.tcc: Tweak.\n+\t* bits/localefwd.h: Tweak.\n+\t* src/locale-inst.cc: Add use_facet/has_facet instantiations here.\n+\t* testsuite/22_locale/codecvt_wchar_t_cc.cc: New file.\n+\t* testsuite/22_locale/codecvt_char_char.cc: New file.\n+\t* testsuite/22_locale/codecvt_unicode_char.cc: New file.\n+\t\n 2000-08-21  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n \n \t* bits/std_cmath.h (std::abs): Overload for int and long."}, {"sha": "9d4b4ff58ec4d3e5f0cc296257af83342fa9d36f", "filename": "libstdc++-v3/bits/char_traits.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fchar_traits.h?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -82,8 +82,8 @@ namespace std {\n       compare(const char_type* __s1, const char_type* __s2, size_t __n)\n       { \n \tfor (size_t __i = 0; __i < __n; ++__i)\n-\t  if (!eq(__s1[__i],__s2[__i]))\n-\t    return lt(__s1[__i],__s2[__i]) ? -1 : 1;\n+\t  if (!eq(__s1[__i], __s2[__i]))\n+\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n \treturn 0; \n       }\n "}, {"sha": "18339025b9bd0b99e2bfed8e89ae56b4f98d7956", "filename": "libstdc++-v3/bits/codecvt.h", "status": "modified", "additions": 272, "deletions": 56, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fcodecvt.h?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -39,9 +39,8 @@\n #define _CPP_BITS_CODECVT_H\t1\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n-// #include <localefwd.h>\n-// XXX include iconv here or higher up.... \n #include <iconv.h>\t\t// For iconv, iconv_t\n+#include <langinfo.h>\n #endif\n \n namespace std\n@@ -53,16 +52,14 @@ namespace std\n   // including conversions and comparisons between various character\n   // sets.  This object encapsulates data that may need to be shared between\n   // char_traits, codecvt and ctype.\n-  template<typename _InternT, typename _ExternT>\n   class __enc_traits\n   {\n   public:\n     // Types:\n-    typedef _InternT\t__intc_type;\n-    typedef _ExternT\t__extc_type;\n     typedef iconv_t\t__conv_type;\n     typedef mbstate_t\t__state_type;\n     \n+  protected:\n     // Data Members:\n     // Max size of charset encoding name\n     static const int \t__max_size = 32;\n@@ -72,62 +69,71 @@ namespace std\n     char  \t       \t__extc_enc[__max_size];\n \n     // Conversion descriptor between external encoding to internal encoding.\n-    __conv_type\t\t__in_conv;\n+    __conv_type\t\t__in_desc;\n     // Conversion descriptor between internal encoding to external encoding.\n-    __conv_type\t\t__out_conv;\n+    __conv_type\t\t__out_desc;\n \n-    __enc_traits()\n+  public:\n+    __enc_traits() : __in_desc(0), __out_desc(0)\n     {\n       // __intc_end = whatever we are using internally, which is\n       // UCS4 (linux) \n-      // UCS2 (microsoft, java, aix, whatever...)\n+      // UCS2 == UNICODE  (microsoft, java, aix, whatever...)\n       // XXX Currently don't know how to get this data from target system...\n       strcpy(__intc_enc, \"UCS4\");\n \n       // __extc_end = external codeset in current locale\n       strcpy(__extc_enc, nl_langinfo(CODESET));\n-      __in_conv = iconv_open(__intc_enc, __extc_enc);\n-      __out_conv = iconv_open(__extc_enc, __intc_enc);\n-      if (__out_conv == (iconv_t) -1 || __in_conv == (iconv_t) -1)\n-\t{\n-\t  // XXX Extended error checking.\n-\t}\n     }\n \n     __enc_traits(const char* __int, const char* __ext)\n+    : __in_desc(0), __out_desc(0)\n     {\n       strcpy(__intc_enc, __int);\n       strcpy(__extc_enc, __ext);\n-      __in_conv = iconv_open(__intc_enc, __extc_enc);\n-      __out_conv = iconv_open(__extc_enc, __intc_enc);\n-      if (__out_conv == (iconv_t) -1 || __in_conv == (iconv_t) -1)\n-\t{\n-\t  // XXX Extended error checking.\n-\t}\n     }\n \n     ~__enc_traits()\n     {\n-      iconv_close(__in_conv);\n-      iconv_close(__out_conv);\n+      iconv_close(__in_desc);\n+      iconv_close(__out_desc);\n     } \n \n-    const char* \n-    _M_get_intc_enc(void)\n-    { return __intc_enc; }\n-\n+    // Initializes\n     void\n-    _M_set_intc_enc(const char* __c)\n-    { strcpy(__intc_enc, __c); }\n+    _M_init()\n+    {\n+      __in_desc = iconv_open(__intc_enc, __extc_enc);\n+      __out_desc = iconv_open(__extc_enc, __intc_enc);\n+      if (__out_desc == (iconv_t) -1 || __in_desc == (iconv_t) -1)\n+\t{\n+\t  // XXX Extended error checking.\n+\t}\n+    }\n+\n+    bool\n+    _M_good()\n+    { \n+      return __out_desc && __in_desc \n+\t     && __out_desc != iconv_t(-1) && __in_desc != iconv_t(-1);\n+    }\n+\n+    const __conv_type* \n+    _M_get_in_descriptor()\n+    { return &__in_desc; }\n+\n+    const __conv_type* \n+    _M_get_out_descriptor()\n+    { return &__out_desc; }\n+\n+   const char* \n+    _M_get_internal_enc()\n+    { return __intc_enc; }\n \n     const char* \n-    _M_get_extc_enc(void)\n+    _M_get_external_enc()\n     { return __extc_enc; }\n \n-    void\n-    _M_set_extc_enc(const char* __c)\n-    { strcpy(__extc_enc, __c); }\n-   \n   protected:\n     // 21.1.2 traits typedefs\n     // p4\n@@ -163,34 +169,35 @@ namespace std\n     {\n     public:\n       // Types:\n-      typedef _InternT intern_type;\n-      typedef _ExternT extern_type;\n-      typedef _StateT  state_type;\n+      typedef codecvt_base::result\t\t\tresult;\n+      typedef _InternT \t\t\t\t\tintern_type;\n+      typedef _ExternT \t\t\t\t\textern_type;\n+      typedef _StateT  \t\t\t\t\tstate_type;\n       \n       // 22.2.1.5.1 codecvt members\n       result\n       out(state_type& __state, const intern_type* __from, \n \t  const intern_type* __from_end, const intern_type*& __from_next,\n-\t  extern_type* __to, extern_type* __to_limit, \n+\t  extern_type* __to, extern_type* __to_end, \n \t  extern_type*& __to_next) const\n       { \n \treturn this->do_out(__state, __from, __from_end, __from_next, \n-\t\t\t    __to, __to_limit, __to_next); \n+\t\t\t    __to, __to_end, __to_next); \n       }\n \n       result\n-      unshift(state_type& __state, extern_type* __to, extern_type* __to_limit,\n+      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,\n \t      extern_type*& __to_next) const\n-      { return this->do_unshift(__state, __to,__to_limit,__to_next); }\n+      { return this->do_unshift(__state, __to,__to_end,__to_next); }\n \n       result\n       in(state_type& __state, const extern_type* __from, \n \t const extern_type* __from_end, const extern_type*& __from_next,\n-\t intern_type* __to, intern_type* __to_limit, \n+\t intern_type* __to, intern_type* __to_end, \n \t intern_type*& __to_next) const\n       { \n \treturn this->do_in(__state, __from, __from_end, __from_next,\n-\t\t\t   __to, __to_limit, __to_next); \n+\t\t\t   __to, __to_end, __to_next); \n       }\n \n       int \n@@ -220,17 +227,17 @@ namespace std\n       virtual result\n       do_out(state_type& __state, const intern_type* __from, \n \t     const intern_type* __from_end, const intern_type*& __from_next,\n-\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type* __to, extern_type* __to_end,\n \t     extern_type*& __to_next) const = 0;\n \n       virtual result\n       do_unshift(state_type& __state, extern_type* __to, \n-\t\t extern_type* __to_limit, extern_type*& __to_next) const = 0;\n+\t\t extern_type* __to_end, extern_type*& __to_next) const = 0;\n       \n       virtual result\n       do_in(state_type& __state, const extern_type* __from, \n \t    const extern_type* __from_end, const extern_type*& __from_next, \n-\t    intern_type* __to, intern_type* __to_limit, \n+\t    intern_type* __to, intern_type* __to_end, \n \t    intern_type*& __to_next) const = 0;\n       \n       virtual int \n@@ -255,6 +262,7 @@ namespace std\n     {\n     public:      \n       // Types:\n+      typedef codecvt_base::result\t\t\tresult;\n       typedef _InternT intern_type;\n       typedef _ExternT extern_type;\n       typedef _StateT  state_type;\n@@ -275,11 +283,219 @@ namespace std\n     locale::id codecvt<_InternT, _ExternT, _StateT>::id;\n \n   // partial specialization\n+  // This specialization takes advantage of iconv to provide code\n+  // conversions between a large number of character encodings.\n   template<typename _InternT, typename _ExternT>\n-  class codecvt<_InternT, _ExternT, __enc_traits<_InternT, _ExternT> >\n-  : public __codecvt_abstract_base<_InternT, \n-    \t\t\t\t   _ExternT, __enc_traits<_InternT, _ExternT> >\n-  { };\n+    class codecvt<_InternT, _ExternT, __enc_traits>\n+    : public __codecvt_abstract_base<_InternT, _ExternT, __enc_traits>\n+    {\n+    public:      \n+      // Types:\n+      typedef codecvt_base::result\t\t\tresult;\n+      typedef _InternT \t\t\t\t\tintern_type;\n+      typedef _ExternT \t\t\t\t\textern_type;\n+      typedef __enc_traits \t\t\t\tstate_type;\n+      typedef __enc_traits::__conv_type \t\t__conv_type;\n+      typedef __enc_traits\t\t\t\t__enc_type;\n+\n+      // Data Members:\n+      static locale::id \t\tid;\n+\n+      explicit \n+      codecvt(size_t __refs = 0)\n+      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)\n+      { }\n+\n+      explicit \n+      codecvt(__enc_type* __enc, size_t __refs = 0)\n+      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)\n+      { }\n+\n+    protected:\n+      virtual \n+      ~codecvt() { }\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_end,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state, extern_type* __to, \n+\t\t extern_type* __to_end, extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state, const extern_type* __from, \n+\t    const extern_type* __from_end, const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_end, \n+\t    intern_type*& __to_next) const;\n+\n+      virtual int \n+      do_encoding() const throw();\n+\n+      virtual bool \n+      do_always_noconv() const throw();\n+\n+      virtual int \n+      do_length(const state_type&, const extern_type* __from, \n+\t\tconst extern_type* __end, size_t __max) const;\n+\n+      virtual int \n+      do_max_length() const throw();\n+    };\n+\n+  template<typename _InternT, typename _ExternT>\n+    locale::id \n+    codecvt<_InternT, _ExternT, __enc_traits>::id;\n+\n+  template<typename _InternT, typename _ExternT>\n+    codecvt_base::result\n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_out(state_type& __state, const intern_type* __from, \n+\t   const intern_type* __from_end, const intern_type*& __from_next,\n+\t   extern_type* __to, extern_type* __to_end,\n+\t   extern_type*& __to_next) const\n+    {\n+      result __ret = error;\n+      if (__state._M_good())\n+\t{\n+\t  typedef state_type::__conv_type\t__conv_type;\n+\t  const __conv_type* __desc = __state._M_get_out_descriptor();\n+\t  const size_t __fmultiple = sizeof(intern_type) / sizeof(char);\n+\t  size_t __flen = __fmultiple * (__from_end - __from);\n+\t  const size_t __tmultiple = sizeof(extern_type) / sizeof(char);\n+\t  size_t __tlen = __tmultiple * (__to_end - __to); \n+\t  \n+\t  // Argument list for iconv specifies a byte sequence. Thus,\n+\t  // all to/from arrays must be brutally casted to char*.\n+\t  const char* __cfrom = reinterpret_cast<const char*>(__from);\n+\t  char* __cto = reinterpret_cast<char*>(__to);\n+\t  size_t __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t  \n+\t  if (__conv != size_t(-1))\n+\t    {\n+\t      __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n+\t      __to_next = reinterpret_cast<extern_type*>(__cto);\n+\t      __ret = ok;\n+\t    }\n+\t  else \n+\t    {\n+\t      if (__flen < __from_end - __from)\n+\t\t{\n+\t\t  __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n+\t\t  __to_next = reinterpret_cast<extern_type*>(__cto);\n+\t\t  __ret = partial;\n+\t\t}\n+\t      else\n+\t\t__ret = error;\n+\t    }\n+\t}\n+      return __ret; \n+    }\n+\n+  template<typename _InternT, typename _ExternT>\n+    codecvt_base::result\n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_unshift(state_type& __state, extern_type* __to, \n+\t       extern_type* __to_end, extern_type*& __to_next) const\n+    {\n+      result __ret = error;\n+      if (__state._M_good())\n+\t{\n+\t  typedef state_type::__conv_type\t__conv_type;\n+\t  const __conv_type* __desc = __state._M_get_in_descriptor();\n+\t  const size_t __tmultiple = sizeof(intern_type) / sizeof(char);\n+\t  size_t __tlen = __tmultiple * (__to_end - __to); \n+\t  \n+\t  // Argument list for iconv specifies a byte sequence. Thus,\n+\t  // all to/from arrays must be brutally casted to char*.\n+\t  char* __cto = reinterpret_cast<char*>(__to);\n+\t  size_t __conv = iconv(*__desc, NULL, NULL, &__cto, &__tlen); \n+\t  \n+\t  if (__conv != size_t(-1))\n+\t    {\n+\t      __to_next = reinterpret_cast<extern_type*>(__cto);\n+\t      __ret = ok;\n+\t    }\n+\t  else \n+\t    __ret = error;\n+\t}\n+      return __ret; \n+    }\n+   \n+  template<typename _InternT, typename _ExternT>\n+    codecvt_base::result\n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_in(state_type& __state, const extern_type* __from, \n+\t  const extern_type* __from_end, const extern_type*& __from_next,\n+\t  intern_type* __to, intern_type* __to_end, \n+\t  intern_type*& __to_next) const\n+    { \n+      result __ret = error;\n+      if (__state._M_good())\n+\t{\n+\t  typedef state_type::__conv_type\t__conv_type;\n+\t  const __conv_type* __desc = __state._M_get_in_descriptor();\n+\t  const size_t __fmultiple = sizeof(extern_type) / sizeof(char);\n+\t  size_t __flen = __fmultiple * (__from_end - __from);\n+\t  const size_t __tmultiple = sizeof(intern_type) / sizeof(char);\n+\t  size_t __tlen = __tmultiple * (__to_end - __to); \n+\t  \n+\t  // Argument list for iconv specifies a byte sequence. Thus,\n+\t  // all to/from arrays must be brutally casted to char*.\n+\t  const char* __cfrom = reinterpret_cast<const char*>(__from);\n+\t  char* __cto = reinterpret_cast<char*>(__to);\n+\t  size_t __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t  \n+\t  if (__conv != size_t(-1))\n+\t    {\n+\t      __from_next = reinterpret_cast<const extern_type*>(__cfrom);\n+\t      __to_next = reinterpret_cast<intern_type*>(__cto);\n+\t      __ret = ok;\n+\t    }\n+\t  else \n+\t    {\n+\t      if (__flen < __from_end - __from)\n+\t\t{\n+\t\t  __from_next = reinterpret_cast<const extern_type*>(__cfrom);\n+\t\t  __to_next = reinterpret_cast<intern_type*>(__cto);\n+\t\t  __ret = partial;\n+\t\t}\n+\t      else\n+\t\t__ret = error;\n+\t    }\n+\t}\n+      return __ret; \n+    }\n+  \n+  template<typename _InternT, typename _ExternT>\n+    int \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_encoding() const throw()\n+    { return 0; }\n+  \n+  template<typename _InternT, typename _ExternT>\n+    bool \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_always_noconv() const throw()\n+    { return false; }\n+  \n+  template<typename _InternT, typename _ExternT>\n+    int \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_length(const state_type& __state, const extern_type* __from, \n+\t      const extern_type* __end, size_t __max) const\n+    { return min(__max, static_cast<size_t>(__end - __from)); }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 74.  Garbled text for codecvt::do_max_length\n+  template<typename _InternT, typename _ExternT>\n+    int \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_max_length() const throw()\n+    { return 1; }\n+#endif\n \n   // codecvt<char, char, mbstate_t> required specialization\n   template<>\n@@ -305,17 +521,17 @@ namespace std\n       virtual result\n       do_out(state_type& __state, const intern_type* __from, \n \t     const intern_type* __from_end, const intern_type*& __from_next,\n-\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type* __to, extern_type* __to_end,\n \t     extern_type*& __to_next) const;\n \n       virtual result\n       do_unshift(state_type& __state, extern_type* __to, \n-\t\t extern_type* __to_limit, extern_type*& __to_next) const;\n+\t\t extern_type* __to_end, extern_type*& __to_next) const;\n \n       virtual result\n       do_in(state_type& __state, const extern_type* __from, \n \t    const extern_type* __from_end, const extern_type*& __from_next,\n-\t    intern_type* __to, intern_type* __to_limit, \n+\t    intern_type* __to, intern_type* __to_end, \n \t    intern_type*& __to_next) const;\n \n       virtual int \n@@ -357,19 +573,19 @@ namespace std\n       virtual result\n       do_out(state_type& __state, const intern_type* __from, \n \t     const intern_type* __from_end, const intern_type*& __from_next,\n-\t     extern_type* __to, extern_type* __to_limit,\n+\t     extern_type* __to, extern_type* __to_end,\n \t     extern_type*& __to_next) const;\n \n       virtual result\n       do_unshift(state_type& __state,\n-\t\t extern_type* __to, extern_type* __to_limit,\n+\t\t extern_type* __to, extern_type* __to_end,\n \t\t extern_type*& __to_next) const;\n \n       virtual result\n       do_in(state_type& __state,\n \t     const extern_type* __from, const extern_type* __from_end,\n \t     const extern_type*& __from_next,\n-\t     intern_type* __to, intern_type* __to_limit,\n+\t     intern_type* __to, intern_type* __to_end,\n \t     intern_type*& __to_next) const;\n \n       virtual "}, {"sha": "94950e4dfe80dc373babfc625b1ffe6db2dcac73", "filename": "libstdc++-v3/bits/locale_facets.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -389,7 +389,7 @@ namespace std\n  \n   template<>\n     const ctype<char>&\n-    use_facet<const ctype<char> > (const locale& __loc);\n+    use_facet<const ctype<char> >(const locale& __loc);\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   // ctype<wchar_t> specialization\n@@ -455,7 +455,7 @@ namespace std\n \n   template<>\n     const ctype<wchar_t>&\n-    use_facet< const ctype<wchar_t> > (const locale& __loc);\n+    use_facet< const ctype<wchar_t> >(const locale& __loc);\n #endif //_GLIBCPP_USE_WCHAR_T\n \n   // Include host-specific ctype specializations.\n@@ -1615,66 +1615,66 @@ namespace std\n   template<typename _CharT>\n     inline bool \n     isspace(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::space, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }\n \n   template<typename _CharT>\n     inline bool \n     isprint(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::print, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }\n \n   template<typename _CharT>\n     inline bool \n     iscntrl(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::cntrl, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }\n \n   template<typename _CharT>\n     inline bool \n     isupper(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::upper, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }\n \n   template<typename _CharT>\n     inline bool islower(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::lower, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }\n \n   template<typename _CharT>\n     inline bool \n     isalpha(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::alpha, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }\n \n   template<typename _CharT>\n     inline bool \n     isdigit(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::digit, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }\n \n   template<typename _CharT>\n     inline bool \n     ispunct(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::punct, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }\n \n   template<typename _CharT>\n     inline bool \n     isxdigit(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::xdigit, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }\n \n   template<typename _CharT>\n     inline bool \n     isalnum(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::alnum, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }\n \n   template<typename _CharT>\n     inline bool \n     isgraph(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).is(ctype_base::graph, __c); }\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }\n \n   template<typename _CharT>\n     inline _CharT \n     toupper(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).toupper(__c); }\n+    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }\n \n   template<typename _CharT>\n     inline _CharT \n     tolower(_CharT __c, const locale& __loc)\n-    { return use_facet<ctype<_CharT> > (__loc).tolower(__c); }\n+    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }\n \n } // namespace std\n "}, {"sha": "44f36e784002c2ae105fc3f6b76c2b4437f9a586", "filename": "libstdc++-v3/bits/locale_facets.tcc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -35,10 +35,10 @@\n #include <bits/std_cerrno.h>\n #include <bits/std_cstdlib.h>   // For strof, strtold\n #include <bits/std_limits.h>    // For numeric_limits\n-#include <bits/std_vector.h>\n #include <bits/std_memory.h>    // For auto_ptr\n #include <bits/sbuf_iter.h>     // For streambuf_iterators\n #include <bits/std_cctype.h>    // For isspace\n+#include <bits/std_vector.h>\t\n \n namespace std\n {\n@@ -69,12 +69,12 @@ namespace std\n     const _Facet&\n     use_facet(const locale& __loc)\n     {\n+      typedef locale::_Impl::__vec_facet        __vec_facet;\n       const locale::facet* __fp = (const _Facet*)0;    // check derivation\n       locale::id& __id = _Facet::id;         // check member id\n       size_t __i = __id._M_index;\n-      const locale::_Impl* __tmp = __loc._M_impl;\n-      if (__id._M_index >= __loc._M_impl->_M_facets->size()\n-          || (__fp = (*(__tmp->_M_facets))[__i]) == 0)\n+      __vec_facet* __facet = __loc._M_impl->_M_facets;\n+      if (__i >= __facet->size() || (__fp = (*(__facet))[__i]) == 0)\n         return _Use_facet_failure_handler<_Facet>(__loc);\n       return static_cast<const _Facet&>(*__fp);\n     }\n@@ -86,8 +86,8 @@ namespace std\n       typedef locale::_Impl::__vec_facet        __vec_facet;\n       locale::id& __id = _Facet::id;         // check member id\n       size_t __i = __id._M_index;\n-      __vec_facet* __tmpv = __loc._M_impl->_M_facets;\n-      return (__i < __tmpv->size() && (*__tmpv)[__i] != 0);\n+      __vec_facet* __facet = __loc._M_impl->_M_facets;\n+      return (__i < __facet->size() && (*__facet)[__i] != 0);\n     }\n \n   // __match_parallel\n@@ -405,7 +405,6 @@ namespace std\n       // We now seek \"units\", i.e. digits and thousands separators.\n       // We may need to know if anything is found here. A leading zero\n       // (removed by now) would count.\n-\n       bool __testunits = __testzero;\n       while (__valid && __beg != __end)\n         {"}, {"sha": "23347be37a74bef325bfced561145f22eb18a5c5", "filename": "libstdc++-v3/bits/localefwd.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -67,14 +67,6 @@ namespace std\n   template<typename _Tp, typename _Alloc> class vector;\n   class locale;\n \n-  template<typename _Facet>\n-    const _Facet&  \n-    use_facet(const locale&);\n-\n-  template<typename _Facet>\n-    bool           \n-    has_facet(const locale&) throw();\n-\n   // 22.1.3 Convenience interfaces\n   template<typename _CharT> \n     inline bool \n@@ -289,10 +281,14 @@ namespace std\n     classic();\n \n   private:\n-    _Impl* _M_impl;  // The (shared) implementation\n+    // The (shared) implementation\n+    _Impl* \t\t_M_impl;  \n \n-    static _Impl* _S_classic; // The one true C reference locale\n-    static _Impl* _S_global;  // Current global reference locale\n+    // The one true C reference locale\n+    static _Impl* \t_S_classic; \n+\n+    // Current global reference locale\n+    static _Impl* \t_S_global;  \n \n     explicit \n     locale(_Impl*) throw();\n@@ -312,10 +308,11 @@ namespace std\n   // locale implementation object\n   class locale::_Impl\n   {\n+    // Types.\n     typedef vector<facet*, allocator<facet*> > __vec_facet;\n     typedef vector<string, allocator<string> > __vec_string;\n \n-    // Friends:\n+    // Friends.\n     friend class locale;\n     friend class facet;\n \n@@ -327,12 +324,13 @@ namespace std\n       friend bool  \n       has_facet(const locale&) throw();\n \n-    size_t _M_num_references;\n-    __vec_facet* _M_facets;\n-    __vec_string* _M_category_names;\n-    bool _M_has_name;\n-    bool _M_cached_name_ok;\n-    string _M_cached_name;\n+    // Data Members.\n+    size_t \t\t_M_num_references;\n+    __vec_facet* \t_M_facets;\n+    __vec_string* \t_M_category_names;\n+    bool \t\t_M_has_name;\n+    bool \t\t_M_cached_name_ok;\n+    string \t\t_M_cached_name;\n \n     inline void \n     _M_add_reference() throw()\n@@ -467,11 +465,13 @@ namespace std\n   public:\n     id() {};\n   private:\n-    // NB: there is no accessor for _M_index because it may be used\n+    // NB: There is no accessor for _M_index because it may be used\n     // before the constructor is run; the effect of calling a member\n     // function (even an inline) would be undefined.\n-    mutable size_t _M_index;\n-    static size_t _S_highwater;   // last id number assigned\n+    mutable size_t \t_M_index;\n+\n+    // Last id number assigned\n+    static size_t \t_S_highwater;   \n \n     void \n     operator=(const id&);  // not defined"}, {"sha": "09f372e522b7db9a5929ea3f5590d3b8cbf906d4", "filename": "libstdc++-v3/src/codecvt.cc", "status": "modified", "additions": 65, "deletions": 32, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -31,6 +31,7 @@\n \n namespace std {\n \n+  // codecvt<char, char, mbstate_t> required specialization\n   locale::id codecvt<char, char, mbstate_t>::id;\n \n   codecvt<char, char, mbstate_t>::\n@@ -48,10 +49,8 @@ namespace std {\n \t extern_type* __to, extern_type* __to_end, \n \t extern_type*& __to_next) const\n   { \n-    size_t __sizefrom = __from_end - __from;\n-    size_t __sizeto = __to_end - __to;\n-    size_t __length = __sizefrom <= __sizeto ? __sizefrom : __sizeto;\n-    memcpy(__to, __from, __length);\n+    size_t __len = min(__from_end - __from, __to_end - __to);\n+    memcpy(__to, __from, __len);\n     __from_next = __from; \n     __to_next = __to;\n     return noconv;  \n@@ -60,7 +59,7 @@ namespace std {\n   codecvt_base::result\n   codecvt<char, char, mbstate_t>::\n   do_unshift(state_type& /*__state*/, extern_type* __to,\n-             extern_type* /*__to_limit*/, extern_type*& __to_next) const\n+             extern_type* /*__to_end*/, extern_type*& __to_next) const\n   { \n     __to_next = __to; \n     return noconv; \n@@ -73,32 +72,33 @@ namespace std {\n \tintern_type* __to, intern_type* __to_end, \n \tintern_type*& __to_next) const\n   { \n-    size_t __sizefrom = __from_end - __from;\n-    size_t __sizeto = __to_end - __to;\n-    size_t __length = __sizefrom <= __sizeto ? __sizefrom : __sizeto;\n-    memcpy(__to, __from, __length);\n+    size_t __len = min(__from_end - __from, __to_end - __to);\n+    memcpy(__to, __from, __len);\n     __from_next = __from; \n     __to_next = __to;\n     return noconv;  \n   }\n \n   int \n   codecvt<char, char, mbstate_t>::\n-  do_encoding() const throw() { return 1; }\n+  do_encoding() const throw() \n+  { return 1; }\n   \n   bool \n   codecvt<char, char, mbstate_t>::\n-  do_always_noconv() const throw() { return true; }\n+  do_always_noconv() const throw() \n+  { return true; }\n   \n   int \n   codecvt<char, char, mbstate_t>::\n   do_length (const state_type& /*__state*/, const extern_type* __from,\n \t     const extern_type* __end, size_t __max) const\n-  { return (__max < size_t(__end - __from)) ? __max : __end - __from; }\n+  { return min(__max, static_cast<size_t>(__end - __from)); }\n   \n   int \n   codecvt<char, char, mbstate_t>::\n-  do_max_length() const throw() { return 1; }\n+  do_max_length() const throw() \n+  { return 1; }\n   \n   codecvt_byname<char, char, mbstate_t>::\n   codecvt_byname(const char* /*__s*/, size_t __refs)\n@@ -108,6 +108,7 @@ namespace std {\n   ~codecvt_byname() { }\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n+  // codecvt<wchar_t, char, mbstate_t> required specialization\n   locale::id codecvt<wchar_t, char, mbstate_t>::id;\n \n   codecvt<wchar_t, char, mbstate_t>::\n@@ -119,44 +120,75 @@ namespace std {\n   \n   codecvt_base::result\n   codecvt<wchar_t, char, mbstate_t>::\n-  do_out(state_type& /*__state*/, const intern_type* __from, \n+  do_out(state_type& __state, const intern_type* __from, \n \t const intern_type* __from_end, const intern_type*& __from_next,\n-\t extern_type* __to, extern_type* __to_limit,\n+\t extern_type* __to, extern_type* __to_end,\n \t extern_type*& __to_next) const\n   {\n-    for (; __from < __from_end && __to < __to_limit; ++__from, ++__to)\n-      *__to = static_cast<char>(*__from);\n-    __from_next = __from; __to_next = __to;\n-    return __from == __from_end ? ok : partial;\n+    result __ret = error;\n+    size_t __len = min(__from_end - __from, __to_end - __to);\n+    size_t __conv = wcsrtombs(__to, &__from, __len, &__state);\n+\n+    if (__conv == __len)\n+      {\n+\t__from_next = __from;\n+\t__to_next = __to + __conv;\n+\t__ret = ok;\n+      }\n+    else if (__conv > 0 && __conv < __len)\n+      {\n+\t__from_next = __from;\n+\t__to_next = __to + __conv;\n+\t__ret = partial;\n+      }\n+    else\n+      __ret = error;\n+\t\n+    return __ret; \n   }\n   \n   codecvt_base::result\n   codecvt<wchar_t, char, mbstate_t>::\n-  do_unshift (state_type& /*__state*/, extern_type* __to,\n-              extern_type* /*__to_limit*/, extern_type*& __to_next) const\n+  do_unshift(state_type& /*__state*/, extern_type* __to,\n+\t     extern_type* /*__to_end*/, extern_type*& __to_next) const\n   {\n     __to_next = __to;\n     return noconv;\n   }\n   \n   codecvt_base::result\n   codecvt<wchar_t, char, mbstate_t>::\n-  do_in(state_type& /*__state*/, const extern_type* __from, \n+  do_in(state_type& __state, const extern_type* __from, \n \tconst extern_type* __from_end, const extern_type*& __from_next,\n-\tintern_type* __to, intern_type* __to_limit,\n+\tintern_type* __to, intern_type* __to_end,\n \tintern_type*& __to_next) const\n   {\n-    for (; __from < __from_end && __to < __to_limit; ++__from, ++__to)\n-      *__to = static_cast<wchar_t>(*__from);\n-    __from_next = __from; \n-    __to_next = __to;\n-    return __from == __from_end ? ok : partial;\n+    result __ret = error;\n+    size_t __len = min(__from_end - __from, __to_end - __to);\n+    size_t __conv = mbsrtowcs(__to, &__from, __len, &__state);\n+\n+    if (__conv == __len)\n+      {\n+\t__from_next = __from;\n+\t__to_next = __to + __conv;\n+\t__ret = ok;\n+      }\n+    else if (__conv > 0 && __conv < __len)\n+      {\n+\t__from_next = __from;\n+\t__to_next = __to + __conv;\n+\t__ret = partial;\n+      }\n+    else\n+      __ret = error;\n+\t\n+    return __ret; \n   }\n   \n   int \n   codecvt<wchar_t, char, mbstate_t>::\n   do_encoding() const throw()\n-  { return 1; }\n+  { return 0; }\n   \n   bool \n   codecvt<wchar_t, char, mbstate_t>::\n@@ -167,10 +199,11 @@ namespace std {\n   codecvt<wchar_t, char, mbstate_t>::\n   do_length(const state_type& /*__state*/, const extern_type* __from,\n \t    const extern_type* __end, size_t __max) const\n-  { return (__max < size_t(__end - __from)) ? __max : __end - __from; }\n-  \n+  { return min(__max, static_cast<size_t>(__end - __from)); }\n+\n   int \n-  codecvt<wchar_t, char, mbstate_t>::do_max_length() const throw()\n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_max_length() const throw()\n   { return 1; }\n \n   codecvt_byname<wchar_t, char, mbstate_t>::"}, {"sha": "d17f3322adce619ef3f6ab022d3904a9c3fd5431", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5834d1b7912ea9bd5066cd53cf99764b26055c6/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=a5834d1b7912ea9bd5066cd53cf99764b26055c6", "patch": "@@ -135,6 +135,15 @@ namespace std {\n   // codecvt\n   template class __codecvt_abstract_base<char, char, mbstate_t>;\n   template class __codecvt_abstract_base<wchar_t, char, mbstate_t>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  typedef unsigned short\t\t\tunicode_t;\n+  template\n+    const codecvt<unicode_t, char, __enc_traits>& \n+    use_facet<codecvt<unicode_t, char, __enc_traits> >(const locale&);\n+  template \n+    bool\n+    has_facet<codecvt<unicode_t, char, __enc_traits> >(const locale &);\n+#endif\n \n   // collate\n   template class _Collate<char>;\n@@ -160,8 +169,8 @@ namespace std {\n     use_facet<ctype<char> >(const locale& __loc);\n   template\n     const codecvt<char, char, mbstate_t>& \n-    use_facet<codecvt<char, char, mbstate_t> >(locale const &);\n-  template \n+    use_facet<codecvt<char, char, mbstate_t> >(const locale&);\n+   template \n     const num_put<char, obuf_iterator>& \n     _Use_facet_failure_handler<num_put<char, obuf_iterator> >\n     (const locale &);"}]}