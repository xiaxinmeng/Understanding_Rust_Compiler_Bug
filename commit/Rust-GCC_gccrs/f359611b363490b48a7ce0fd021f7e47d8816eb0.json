{"sha": "f359611b363490b48a7ce0fd021f7e47d8816eb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1OTYxMWIzNjM0OTBiNDhhN2NlMGZkMDIxZjdlNDdkODgxNmViMA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2019-06-10T19:17:57Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-06-10T19:17:57Z"}, "message": "i386-protos.h (ix86_split_fp_absneg_operator): New prototype.\n\n\t* config/i386/i386-protos.h (ix86_split_fp_absneg_operator):\n\tNew prototype.\n\t* config/i386/i386-expand.c (ix86_expand_fp_absneg_operator):\n\tEmit clobber also for non-sse operations.\n\t(ix86_split_fp_absneg_operator): New function.\n\t* config/i386/i386.md (SSEMODEF): New mode iterator.\n\t(ssevecmodef): New mode attribute.\n\t(<code>tf2): Use absneg code iterator.\n\t(*<code>tf2_1): Rename from *absnegtf3_sse. Use absneg code iterator.\n\tAdd three-operand AVX alternatives.\n\t(*<code><mode>2_i387_1): Rename from *absnegxf2_i387.\n\tUse absneg code iterator and X87MODEF mode iterator.\n\t(absneg fp_reg non-sse splitter): Call absneg code iterator\n\tand X87MODEF mode iterator.\n\t(absneg general_reg non-sse splitter): Use absneg code iterator\n\tand X87MODEF mode iterator.  Use ix86_split_fp_absneg_operator.\n\t(*<code><mode>2_1): Rename from *absneg<mode>2.  Use absneg\n\tcode iterator.  Add three-operand AVX alternative.\n\t(absneg sse_reg splitter): Use absneg code iterator\n\tand SSEMODEF mode iterator.  Handle AVX operands.\n\t(absneg fp_reg splitter): Use absneg code iterator\n\tand MODEF mode iterator.\n\t(absneg general_reg splitter): Merge splitters using MODEF mode\n\titerator.  Use absneg code iterator.  Call\n\tix86_split_fp_absneg_operator.\n\t(*<code><mode>2_i387): Rename from *<code><mode>2_1.\n\tDo not enable for non-sse modes before reload.\n\t(CSGNMODE): Remove.\n\t(CSGNVMODE): Ditto.\n\t(copysing<mode>3): Use SSEMODEF instead of CSGNMODE and\n\tssevecmodef mode attribute instaed of CSGNVMODE.\n\t(copysign<mode>3_const): Ditto.\n\t(copysign<mode>3_var): Ditto.\n\t* config/i386/i386.md (*<code><mode>2): Rename from *absneg<mode>2.\n\tUse absneg code iterator.  Simplify code using std::swap.\n\t* config/i386/predicates.md (absneg_operator): Remove.\n\nFrom-SVN: r272123", "tree": {"sha": "ff081924bb1da6cbe1c1bc19755aa21115dcc0cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff081924bb1da6cbe1c1bc19755aa21115dcc0cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f359611b363490b48a7ce0fd021f7e47d8816eb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f359611b363490b48a7ce0fd021f7e47d8816eb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f359611b363490b48a7ce0fd021f7e47d8816eb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f359611b363490b48a7ce0fd021f7e47d8816eb0/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2ee751da8551c9d1a84c337239b0e52211fd1aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ee751da8551c9d1a84c337239b0e52211fd1aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ee751da8551c9d1a84c337239b0e52211fd1aa"}], "stats": {"total": 463, "additions": 262, "deletions": 201}, "files": [{"sha": "a4796446a5b25120fddab1068d211e829692b61b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f359611b363490b48a7ce0fd021f7e47d8816eb0", "patch": "@@ -1,3 +1,42 @@\n+2019-06-10  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-protos.h (ix86_split_fp_absneg_operator):\n+\tNew prototype.\n+\t* config/i386/i386-expand.c (ix86_expand_fp_absneg_operator):\n+\tEmit clobber also for non-sse operations.\n+\t(ix86_split_fp_absneg_operator): New function.\n+\t* config/i386/i386.md (SSEMODEF): New mode iterator.\n+\t(ssevecmodef): New mode attribute.\n+\t(<code>tf2): Use absneg code iterator.\n+\t(*<code>tf2_1): Rename from *absnegtf3_sse. Use absneg code iterator.\n+\tAdd three-operand AVX alternatives.\n+\t(*<code><mode>2_i387_1): Rename from *absnegxf2_i387.\n+\tUse absneg code iterator and X87MODEF mode iterator.\n+\t(absneg fp_reg non-sse splitter): Call absneg code iterator\n+\tand X87MODEF mode iterator.\n+\t(absneg general_reg non-sse splitter): Use absneg code iterator\n+\tand X87MODEF mode iterator.  Use ix86_split_fp_absneg_operator.\n+\t(*<code><mode>2_1): Rename from *absneg<mode>2.  Use absneg\n+\tcode iterator.  Add three-operand AVX alternative.\n+\t(absneg sse_reg splitter): Use absneg code iterator\n+\tand SSEMODEF mode iterator.  Handle AVX operands.\n+\t(absneg fp_reg splitter): Use absneg code iterator\n+\tand MODEF mode iterator.\n+\t(absneg general_reg splitter): Merge splitters using MODEF mode\n+\titerator.  Use absneg code iterator.  Call\n+\tix86_split_fp_absneg_operator.\n+\t(*<code><mode>2_i387): Rename from *<code><mode>2_1.\n+\tDo not enable for non-sse modes before reload.\n+\t(CSGNMODE): Remove.\n+\t(CSGNVMODE): Ditto.\n+\t(copysing<mode>3): Use SSEMODEF instead of CSGNMODE and\n+\tssevecmodef mode attribute instaed of CSGNVMODE.\n+\t(copysign<mode>3_const): Ditto.\n+\t(copysign<mode>3_var): Ditto.\n+\t* config/i386/i386.md (*<code><mode>2): Rename from *absneg<mode>2.\n+\tUse absneg code iterator.  Simplify code using std::swap.\n+\t* config/i386/predicates.md (absneg_operator): Remove.\n+\n 2019-06-10  Martin Sebor  <msebor@redhat.com>\n \n \t* gimple-fold.c (get_range_strlen): Update comment that didn't"}, {"sha": "0585c7d08bd057659e41ed4c705be579c4c131c8", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 103, "deletions": 13, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=f359611b363490b48a7ce0fd021f7e47d8816eb0", "patch": "@@ -1704,10 +1704,11 @@ void\n ix86_expand_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n \t\t\t\trtx operands[])\n {\n-  rtx mask, set, dst, src;\n+  rtx set, dst, src;\n   bool use_sse = false;\n   bool vector_mode = VECTOR_MODE_P (mode);\n   machine_mode vmode = mode;\n+  rtvec par;\n \n   if (vector_mode)\n     use_sse = true;\n@@ -1722,24 +1723,19 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n \tvmode = V2DFmode;\n     }\n \n-  /* NEG and ABS performed with SSE use bitwise mask operations.\n-     Create the appropriate mask now.  */\n-  if (use_sse)\n-    mask = ix86_build_signbit_mask (vmode, vector_mode, code == ABS);\n-  else\n-    mask = NULL_RTX;\n-\n   dst = operands[0];\n   src = operands[1];\n \n   set = gen_rtx_fmt_e (code, mode, src);\n   set = gen_rtx_SET (dst, set);\n \n-  if (mask)\n+  if (use_sse)\n     {\n-      rtx use, clob;\n-      rtvec par;\n+      rtx mask, use, clob;\n \n+      /* NEG and ABS performed with SSE use bitwise mask operations.\n+\t Create the appropriate mask now.  */\n+      mask = ix86_build_signbit_mask (vmode, vector_mode, code == ABS);\n       use = gen_rtx_USE (VOIDmode, mask);\n       if (vector_mode)\n \tpar = gen_rtvec (2, set, use);\n@@ -1748,10 +1744,104 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n           clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n \t  par = gen_rtvec (3, set, use, clob);\n         }\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n     }\n   else\n-    emit_insn (set);\n+    {\n+      rtx clob;\n+\n+      /* Changing of sign for FP values is doable using integer unit too.  */\n+      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+      par = gen_rtvec (2, set, clob);\n+    }\n+\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+}\n+\n+/* Deconstruct a floating point ABS or NEG operation\n+   with integer registers into integer operations.  */\n+\n+void\n+ix86_split_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n+\t\t\t       rtx operands[])\n+{\n+  enum rtx_code absneg_op;\n+  rtx dst, set;\n+\n+  gcc_assert (operands_match_p (operands[0], operands[1]));\n+\n+  switch (mode)\n+    {\n+    case E_SFmode:\n+      dst = gen_lowpart (SImode, operands[0]);\n+\n+      if (code == ABS)\n+\t{\n+\t  set = gen_int_mode (0x7fffffff, SImode);\n+\t  absneg_op = AND;\n+\t}\n+      else\n+\t{\n+\t  set = gen_int_mode (0x80000000, SImode);\n+\t  absneg_op = XOR;\n+\t}\n+      set = gen_rtx_fmt_ee (absneg_op, SImode, dst, set);\n+      break;\n+\n+    case E_DFmode:\n+      if (TARGET_64BIT)\n+\t{\n+\t  dst = gen_lowpart (DImode, operands[0]);\n+\t  dst = gen_rtx_ZERO_EXTRACT (DImode, dst, const1_rtx, GEN_INT (63));\n+\n+\t  if (code == ABS)\n+\t    set = const0_rtx;\n+\t  else\n+\t    set = gen_rtx_NOT (DImode, dst);\n+\t}\n+      else\n+\t{\n+\t  dst = gen_highpart (SImode, operands[0]);\n+\n+\t  if (code == ABS)\n+\t    {\n+\t      set = gen_int_mode (0x7fffffff, SImode);\n+\t      absneg_op = AND;\n+\t    }\n+\t  else\n+\t    {\n+\t      set = gen_int_mode (0x80000000, SImode);\n+\t      absneg_op = XOR;\n+\t    }\n+\t  set = gen_rtx_fmt_ee (absneg_op, SImode, dst, set);\n+\t}\n+      break;\n+\n+    case E_XFmode:\n+      dst = gen_rtx_REG (SImode,\n+\t\t\t REGNO (operands[0]) + (TARGET_64BIT ? 1 : 2));\n+      if (code == ABS)\n+\t{\n+\t  set = GEN_INT (0x7fff);\n+\t  absneg_op = AND;\n+\t}\n+      else\n+\t{\n+\t  set = GEN_INT (0x8000);\n+\t  absneg_op = XOR;\n+\t}\n+      set = gen_rtx_fmt_ee (absneg_op, SImode, dst, set);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  set = gen_rtx_SET (dst, set);\n+\n+  rtx clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+  rtvec par = gen_rtvec (2, set, clob);\n+\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n }\n \n /* Expand a copysign operation.  Special case operand 0 being a constant.  */"}, {"sha": "80b6ee7cbbc83b92c41382b1f3f20a15106a0f81", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f359611b363490b48a7ce0fd021f7e47d8816eb0", "patch": "@@ -121,6 +121,8 @@ extern rtx ix86_expand_adjust_ufix_to_sfix_si (rtx, rtx *);\n extern enum ix86_fpcmp_strategy ix86_fp_comparison_strategy (enum rtx_code);\n extern void ix86_expand_fp_absneg_operator (enum rtx_code, machine_mode,\n \t\t\t\t\t    rtx[]);\n+extern void ix86_split_fp_absneg_operator (enum rtx_code, machine_mode,\n+\t\t\t\t\t   rtx[]);\n extern void ix86_expand_copysign (rtx []);\n extern void ix86_split_copysign_const (rtx []);\n extern void ix86_split_copysign_var (rtx []);"}, {"sha": "9f8194b369fb506aa62f4dfbb740e5d36af2aa2c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 106, "deletions": 163, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f359611b363490b48a7ce0fd021f7e47d8816eb0", "patch": "@@ -1162,6 +1162,10 @@\n ;; All x87 floating point modes\n (define_mode_iterator X87MODEF [SF DF XF])\n \n+;; All SSE floating point modes\n+(define_mode_iterator SSEMODEF [SF DF TF])\n+(define_mode_attr ssevecmodef [(SF \"V4SF\") (DF \"V2DF\") (TF \"TF\")])\n+\n ;; SSE instruction suffix for various modes\n (define_mode_attr ssemodesuffix\n   [(SF \"ss\") (DF \"sd\")\n@@ -9488,211 +9492,150 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-;; Changing of sign for FP values is doable using integer unit too.\n+(define_expand \"<code>tf2\"\n+  [(set (match_operand:TF 0 \"register_operand\")\n+\t(absneg:TF (match_operand:TF 1 \"register_operand\")))]\n+  \"TARGET_SSE\"\n+  \"ix86_expand_fp_absneg_operator (<CODE>, TFmode, operands); DONE;\")\n+\n+(define_insn \"*<code>tf2_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=x,x,Yv,Yv\")\n+\t(absneg:TF\n+\t  (match_operand:TF 1 \"vector_operand\" \"0,xBm,Yv,m\")))\n+   (use (match_operand:TF 2 \"vector_operand\" \"xBm,0,Yvm,Yv\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_SSE\"\n+  \"#\"\n+  [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n \n (define_expand \"<code><mode>2\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\")\n \t(absneg:X87MODEF (match_operand:X87MODEF 1 \"register_operand\")))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n   \"ix86_expand_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*absneg<mode>2\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=Yv,Yv,f,!r\")\n-\t(match_operator:MODEF 3 \"absneg_operator\"\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"0,Yv,0,0\")]))\n-   (use (match_operand:<ssevecmode> 2 \"nonimmediate_operand\" \"Yvm,0,X,X\"))\n+;; Changing of sign for FP values is doable using integer unit too.\n+(define_insn \"*<code><mode>2_i387_1\"\n+  [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f,!r\")\n+\t(absneg:X87MODEF\n+\t  (match_operand:X87MODEF 1 \"register_operand\" \"0,0\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_80387\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:X87MODEF 0 \"fp_register_operand\")\n+\t(absneg:X87MODEF (match_operand:X87MODEF 1 \"fp_register_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 0) (absneg:X87MODEF (match_dup 1)))])\n+\n+(define_split\n+  [(set (match_operand:X87MODEF 0 \"general_reg_operand\")\n+\t(absneg:X87MODEF (match_operand:X87MODEF 1 \"general_reg_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n+\n+(define_insn \"*<code><mode>2_1\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x,Yv,f,!r\")\n+\t(absneg:MODEF\n+\t  (match_operand:MODEF 1 \"register_operand\" \"0,x,Yv,0,0\")))\n+   (use (match_operand:<ssevecmode> 2 \"vector_operand\" \"xBm,0,Yvm,X,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n   \"#\"\n-  [(set (attr \"enabled\")\n+  [(set_attr \"isa\" \"noavx,noavx,avx,*,*\")\n+   (set (attr \"enabled\")\n      (if_then_else\n        (match_test (\"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"))\n        (if_then_else\n-\t (eq_attr \"alternative\" \"2\")\n+\t (eq_attr \"alternative\" \"3,4\")\n \t (symbol_ref \"TARGET_MIX_SSE_I387\")\n-\t (symbol_ref \"true\"))\n+\t (const_string \"*\"))\n        (if_then_else\n-\t (eq_attr \"alternative\" \"2,3\")\n+\t (eq_attr \"alternative\" \"3,4\")\n \t (symbol_ref \"true\")\n \t (symbol_ref \"false\"))))])\n \n-(define_insn \"*absnegxf2_i387\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"=f,!r\")\n-\t(match_operator:XF 3 \"absneg_operator\"\n-\t  [(match_operand:XF 1 \"register_operand\" \"0,0\")]))\n-   (use (match_operand 2))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387\"\n-  \"#\")\n-\n-(define_expand \"<code>tf2\"\n-  [(set (match_operand:TF 0 \"register_operand\")\n-\t(absneg:TF (match_operand:TF 1 \"register_operand\")))]\n-  \"TARGET_SSE\"\n-  \"ix86_expand_fp_absneg_operator (<CODE>, TFmode, operands); DONE;\")\n-\n-(define_insn \"*absnegtf2_sse\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=Yv,Yv\")\n-\t(match_operator:TF 3 \"absneg_operator\"\n-\t  [(match_operand:TF 1 \"register_operand\" \"0,Yv\")]))\n-   (use (match_operand:TF 2 \"nonimmediate_operand\" \"Yvm,0\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE\"\n-  \"#\")\n-\n-;; Splitters for fp abs and neg.\n-\n (define_split\n-  [(set (match_operand 0 \"fp_register_operand\")\n-\t(match_operator 1 \"absneg_operator\" [(match_dup 0)]))\n-   (use (match_operand 2))\n+  [(set (match_operand:SSEMODEF 0 \"sse_reg_operand\")\n+\t(absneg:SSEMODEF\n+\t  (match_operand:SSEMODEF 1 \"vector_operand\")))\n+   (use (match_operand:<ssevecmodef> 2 \"vector_operand\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\"\n-  [(set (match_dup 0) (match_op_dup 1 [(match_dup 0)]))])\n-\n-(define_split\n-  [(set (match_operand 0 \"sse_reg_operand\")\n-\t(match_operator 3 \"absneg_operator\"\n-\t  [(match_operand 1 \"register_operand\")]))\n-   (use (match_operand 2 \"nonimmediate_operand\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\"\n+  \"((SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n+    || (TARGET_SSE && (<MODE>mode == TFmode)))\n+   && reload_completed\"\n   [(set (match_dup 0) (match_dup 3))]\n {\n-  machine_mode mode = GET_MODE (operands[0]);\n-  machine_mode vmode = GET_MODE (operands[2]);\n-  rtx tmp;\n+  machine_mode mode = <MODE>mode;\n+  machine_mode vmode = <ssevecmodef>mode;\n+  enum rtx_code absneg_op = <CODE> == ABS ? AND : XOR;\n \n   operands[0] = lowpart_subreg (vmode, operands[0], mode);\n   operands[1] = lowpart_subreg (vmode, operands[1], mode);\n-  if (operands_match_p (operands[0], operands[2]))\n-    std::swap (operands[1], operands[2]);\n-  if (GET_CODE (operands[3]) == ABS)\n-    tmp = gen_rtx_AND (vmode, operands[1], operands[2]);\n-  else\n-    tmp = gen_rtx_XOR (vmode, operands[1], operands[2]);\n-  operands[3] = tmp;\n-})\n \n-(define_split\n-  [(set (match_operand:SF 0 \"general_reg_operand\")\n-\t(match_operator:SF 1 \"absneg_operator\" [(match_dup 0)]))\n-   (use (match_operand:V4SF 2))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0) (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  rtx tmp;\n-  operands[0] = gen_lowpart (SImode, operands[0]);\n-  if (GET_CODE (operands[1]) == ABS)\n+  if (TARGET_AVX)\n     {\n-      tmp = gen_int_mode (0x7fffffff, SImode);\n-      tmp = gen_rtx_AND (SImode, operands[0], tmp);\n+      if (MEM_P (operands[1]))\n+        std::swap (operands[1], operands[2]);\n     }\n   else\n-    {\n-      tmp = gen_int_mode (0x80000000, SImode);\n-      tmp = gen_rtx_XOR (SImode, operands[0], tmp);\n-    }\n-  operands[1] = tmp;\n+   {\n+     if (operands_match_p (operands[0], operands[2]))\n+       std::swap (operands[1], operands[2]);\n+   }\n+\n+  operands[3]\n+    = gen_rtx_fmt_ee (absneg_op, vmode, operands[1], operands[2]);\n })\n \n (define_split\n-  [(set (match_operand:DF 0 \"general_reg_operand\")\n-\t(match_operator:DF 1 \"absneg_operator\" [(match_dup 0)]))\n+  [(set (match_operand:MODEF 0 \"fp_register_operand\")\n+\t(absneg:MODEF (match_operand:MODEF 1 \"fp_register_operand\")))\n    (use (match_operand 2))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0) (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  rtx tmp;\n-  if (TARGET_64BIT)\n-    {\n-      tmp = gen_lowpart (DImode, operands[0]);\n-      tmp = gen_rtx_ZERO_EXTRACT (DImode, tmp, const1_rtx, GEN_INT (63));\n-      operands[0] = tmp;\n-\n-      if (GET_CODE (operands[1]) == ABS)\n-\ttmp = const0_rtx;\n-      else\n-\ttmp = gen_rtx_NOT (DImode, tmp);\n-    }\n-  else\n-    {\n-      operands[0] = gen_highpart (SImode, operands[0]);\n-      if (GET_CODE (operands[1]) == ABS)\n-\t{\n-\t  tmp = gen_int_mode (0x7fffffff, SImode);\n-\t  tmp = gen_rtx_AND (SImode, operands[0], tmp);\n-\t}\n-      else\n-\t{\n-\t  tmp = gen_int_mode (0x80000000, SImode);\n-\t  tmp = gen_rtx_XOR (SImode, operands[0], tmp);\n-\t}\n-    }\n-  operands[1] = tmp;\n-})\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 0) (absneg:X87MODEF (match_dup 1)))])\n \n (define_split\n-  [(set (match_operand:XF 0 \"general_reg_operand\")\n-\t(match_operator:XF 1 \"absneg_operator\" [(match_dup 0)]))\n+  [(set (match_operand:MODEF 0 \"general_reg_operand\")\n+\t(absneg:MODEF (match_operand:MODEF 1 \"general_reg_operand\")))\n    (use (match_operand 2))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0) (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  rtx tmp;\n-  operands[0] = gen_rtx_REG (SImode,\n-\t\t\t     REGNO (operands[0]) + (TARGET_64BIT ? 1 : 2));\n-  if (GET_CODE (operands[1]) == ABS)\n-    {\n-      tmp = GEN_INT (0x7fff);\n-      tmp = gen_rtx_AND (SImode, operands[0], tmp);\n-    }\n-  else\n-    {\n-      tmp = GEN_INT (0x8000);\n-      tmp = gen_rtx_XOR (SImode, operands[0], tmp);\n-    }\n-  operands[1] = tmp;\n-})\n+  \"TARGET_80387 && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n ;; Conditionalize these after reload. If they match before reload, we\n ;; lose the clobber and ability to use integer instructions.\n \n-(define_insn \"*<code><mode>2_1\"\n+(define_insn \"*<code><mode>2_i387\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f\")\n \t(absneg:X87MODEF (match_operand:X87MODEF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_80387\n-   && (reload_completed\n-       || !(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH))\"\n+  \"TARGET_80387 && reload_completed\"\n   \"<absneg_mnemonic>\"\n   [(set_attr \"type\" \"fsgn\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; Copysign instructions\n \n-(define_mode_iterator CSGNMODE [SF DF TF])\n-(define_mode_attr CSGNVMODE [(SF \"V4SF\") (DF \"V2DF\") (TF \"TF\")])\n-\n (define_expand \"copysign<mode>3\"\n-  [(match_operand:CSGNMODE 0 \"register_operand\")\n-   (match_operand:CSGNMODE 1 \"nonmemory_operand\")\n-   (match_operand:CSGNMODE 2 \"register_operand\")]\n+  [(match_operand:SSEMODEF 0 \"register_operand\")\n+   (match_operand:SSEMODEF 1 \"nonmemory_operand\")\n+   (match_operand:SSEMODEF 2 \"register_operand\")]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n    || (TARGET_SSE && (<MODE>mode == TFmode))\"\n   \"ix86_expand_copysign (operands); DONE;\")\n \n (define_insn_and_split \"copysign<mode>3_const\"\n-  [(set (match_operand:CSGNMODE 0 \"register_operand\" \"=Yv\")\n-\t(unspec:CSGNMODE\n-\t  [(match_operand:<CSGNVMODE> 1 \"nonimm_or_0_operand\" \"YvmC\")\n-\t   (match_operand:CSGNMODE 2 \"register_operand\" \"0\")\n-\t   (match_operand:<CSGNVMODE> 3 \"nonimmediate_operand\" \"Yvm\")]\n+  [(set (match_operand:SSEMODEF 0 \"register_operand\" \"=Yv\")\n+\t(unspec:SSEMODEF\n+\t  [(match_operand:<ssevecmodef> 1 \"nonimm_or_0_operand\" \"YvmC\")\n+\t   (match_operand:SSEMODEF 2 \"register_operand\" \"0\")\n+\t   (match_operand:<ssevecmodef> 3 \"nonimmediate_operand\" \"Yvm\")]\n \t  UNSPEC_COPYSIGN))]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n    || (TARGET_SSE && (<MODE>mode == TFmode))\"\n@@ -9702,29 +9645,29 @@\n   \"ix86_split_copysign_const (operands); DONE;\")\n \n (define_insn \"copysign<mode>3_var\"\n-  [(set (match_operand:CSGNMODE 0 \"register_operand\" \"=Yv,Yv,Yv,Yv,Yv\")\n-\t(unspec:CSGNMODE\n-\t  [(match_operand:CSGNMODE 2 \"register_operand\"\t\"Yv,0,0,Yv,Yv\")\n-\t   (match_operand:CSGNMODE 3 \"register_operand\"\t\"1,1,Yv,1,Yv\")\n-\t   (match_operand:<CSGNVMODE> 4\n+  [(set (match_operand:SSEMODEF 0 \"register_operand\" \"=Yv,Yv,Yv,Yv,Yv\")\n+\t(unspec:SSEMODEF\n+\t  [(match_operand:SSEMODEF 2 \"register_operand\"\t\"Yv,0,0,Yv,Yv\")\n+\t   (match_operand:SSEMODEF 3 \"register_operand\"\t\"1,1,Yv,1,Yv\")\n+\t   (match_operand:<ssevecmodef> 4\n \t     \"nonimmediate_operand\" \"X,Yvm,Yvm,0,0\")\n-\t   (match_operand:<CSGNVMODE> 5\n+\t   (match_operand:<ssevecmodef> 5\n \t     \"nonimmediate_operand\" \"0,Yvm,1,Yvm,1\")]\n \t  UNSPEC_COPYSIGN))\n-   (clobber (match_scratch:<CSGNVMODE> 1 \"=Yv,Yv,Yv,Yv,Yv\"))]\n+   (clobber (match_scratch:<ssevecmodef> 1 \"=Yv,Yv,Yv,Yv,Yv\"))]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n    || (TARGET_SSE && (<MODE>mode == TFmode))\"\n   \"#\")\n \n (define_split\n-  [(set (match_operand:CSGNMODE 0 \"register_operand\")\n-\t(unspec:CSGNMODE\n-\t  [(match_operand:CSGNMODE 2 \"register_operand\")\n-\t   (match_operand:CSGNMODE 3 \"register_operand\")\n-\t   (match_operand:<CSGNVMODE> 4)\n-\t   (match_operand:<CSGNVMODE> 5)]\n+  [(set (match_operand:SSEMODEF 0 \"register_operand\")\n+\t(unspec:SSEMODEF\n+\t  [(match_operand:SSEMODEF 2 \"register_operand\")\n+\t   (match_operand:SSEMODEF 3 \"register_operand\")\n+\t   (match_operand:<ssevecmodef> 4)\n+\t   (match_operand:<ssevecmodef> 5)]\n \t  UNSPEC_COPYSIGN))\n-   (clobber (match_scratch:<CSGNVMODE> 1))]\n+   (clobber (match_scratch:<ssevecmodef> 1))]\n   \"((SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n     || (TARGET_SSE && (<MODE>mode == TFmode)))\n    && reload_completed\""}, {"sha": "5e8f6710137f25a01a835253170e6c02875ba860", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=f359611b363490b48a7ce0fd021f7e47d8816eb0", "patch": "@@ -1404,9 +1404,6 @@\n (define_predicate \"compare_operator\"\n   (match_code \"compare\"))\n \n-(define_predicate \"absneg_operator\"\n-  (match_code \"abs,neg\"))\n-\n ;; Return true if OP is a memory operand, aligned to\n ;; less than its natural alignment.\n (define_predicate \"misaligned_operand\""}, {"sha": "d7d542524fba16058c2612c690b461bcabd17215", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f359611b363490b48a7ce0fd021f7e47d8816eb0/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=f359611b363490b48a7ce0fd021f7e47d8816eb0", "patch": "@@ -1720,41 +1720,31 @@\n   \"TARGET_SSE\"\n   \"ix86_expand_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n-(define_insn_and_split \"*absneg<mode>2\"\n+(define_insn_and_split \"*<code><mode>2\"\n   [(set (match_operand:VF 0 \"register_operand\" \"=x,x,v,v\")\n-\t(match_operator:VF 3 \"absneg_operator\"\n-\t  [(match_operand:VF 1 \"vector_operand\" \"0,  xBm,v, m\")]))\n+\t(absneg:VF\n+\t  (match_operand:VF 1 \"vector_operand\" \"0,  xBm,v, m\")))\n    (use (match_operand:VF 2 \"vector_operand\"    \"xBm,0,  vm,v\"))]\n   \"TARGET_SSE\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(const_int 0)]\n+  [(set (match_dup 0) (match_dup 3))]\n {\n-  enum rtx_code absneg_op;\n-  rtx op1, op2;\n-  rtx t;\n+  enum rtx_code absneg_op = <CODE> == ABS ? AND : XOR;\n \n   if (TARGET_AVX)\n     {\n       if (MEM_P (operands[1]))\n-\top1 = operands[2], op2 = operands[1];\n-      else\n-\top1 = operands[1], op2 = operands[2];\n+        std::swap (operands[1], operands[2]);\n     }\n   else\n-    {\n-      op1 = operands[0];\n-      if (rtx_equal_p (operands[0], operands[1]))\n-\top2 = operands[2];\n-      else\n-\top2 = operands[1];\n-    }\n+   {\n+     if (operands_match_p (operands[0], operands[2]))\n+       std::swap (operands[1], operands[2]);\n+   }\n \n-  absneg_op = GET_CODE (operands[3]) == NEG ? XOR : AND;\n-  t = gen_rtx_fmt_ee (absneg_op, <MODE>mode, op1, op2);\n-  t = gen_rtx_SET (operands[0], t);\n-  emit_insn (t);\n-  DONE;\n+  operands[3]\n+    = gen_rtx_fmt_ee (absneg_op, <MODE>mode, operands[1], operands[2]);\n }\n   [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n "}]}