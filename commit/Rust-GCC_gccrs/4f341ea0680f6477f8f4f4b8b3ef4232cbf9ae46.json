{"sha": "4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYzNDFlYTA2ODBmNjQ3N2Y4ZjRmNGI4YjNlZjQyMzJjYmY5YWU0Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-09-06T08:08:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-09-06T08:08:49Z"}, "message": "ira-int.h (ira_zero_hard_reg_set, [...]): Delete.\n\ngcc/\n\t* ira-int.h (ira_zero_hard_reg_set, ira_one_hard_reg_set): Delete.\n\t* ira-color.c (setup_allocno_left_conflicts_num): Use\n\thard_reg_set_equal_p instead of a comparison with\n\tira_zero_hard_reg_set.\n\t* ira.c (setup_reg_subclasses): Likewise.\n\t(setup_cover_and_important_classes): Likewise.\n\t(setup_class_translate): Likewise.\n\t(setup_reg_class_intersect_union): Likewise.\n\t(ira_zero_hard_reg_set, ira_one_hard_reg_set): Delete.\n\t(ira_init_once): Don't initialize them.\n\nFrom-SVN: r140054", "tree": {"sha": "9edf81b20abbc6d6e0b8a9ad98ffbf32a4cf8d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9edf81b20abbc6d6e0b8a9ad98ffbf32a4cf8d6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af9253a1855855bc6513cbde949b6c224b51f2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af9253a1855855bc6513cbde949b6c224b51f2bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af9253a1855855bc6513cbde949b6c224b51f2bd"}], "stats": {"total": 42, "additions": 22, "deletions": 20}, "files": [{"sha": "f493fedfd890931a16e7be5671c327d388d903c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "patch": "@@ -1,3 +1,16 @@\n+2008-09-06  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira-int.h (ira_zero_hard_reg_set, ira_one_hard_reg_set): Delete.\n+\t* ira-color.c (setup_allocno_left_conflicts_num): Use\n+\thard_reg_set_equal_p instead of a comparison with\n+\tira_zero_hard_reg_set.\n+\t* ira.c (setup_reg_subclasses): Likewise.\n+\t(setup_cover_and_important_classes): Likewise.\n+\t(setup_class_translate): Likewise.\n+\t(setup_reg_class_intersect_union): Likewise.\n+\t(ira_zero_hard_reg_set, ira_one_hard_reg_set): Delete.\n+\t(ira_init_once): Don't initialize them.\n+\n 2008-09-05  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* doc/tm.texi (IRA_COVER_CLASSES): Fix a typo."}, {"sha": "833048e2541741ec3ce6841c237c60b3f3c96039", "filename": "gcc/ira-color.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "patch": "@@ -1274,15 +1274,15 @@ setup_allocno_left_conflicts_num (ira_allocno_t allocno)\n   AND_HARD_REG_SET (temp_set, reg_class_contents[cover_class]);\n   AND_COMPL_HARD_REG_SET (temp_set, ira_no_alloc_regs);\n   conflict_allocnos_size = 0;\n-  if (! hard_reg_set_equal_p (temp_set, ira_zero_hard_reg_set))\n+  if (! hard_reg_set_empty_p (temp_set))\n     for (i = 0; i < (int) hard_regs_num; i++)\n       {\n \thard_regno = ira_class_hard_regs[cover_class][i];\n \tif (TEST_HARD_REG_BIT (temp_set, hard_regno))\n \t  {\n \t    conflict_allocnos_size++;\n \t    CLEAR_HARD_REG_BIT (temp_set, hard_regno);\n-\t    if (hard_reg_set_equal_p (temp_set, ira_zero_hard_reg_set))\n+\t    if (hard_reg_set_empty_p (temp_set))\n \t      break;\n \t  }\n       }"}, {"sha": "ccd65e6683fa9570cd3c4c088a7d132dbe9cfa2e", "filename": "gcc/ira-int.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "patch": "@@ -702,10 +702,6 @@ ira_allocno_set_iter_next (ira_allocno_set_iterator *i)\n \n /* ira.c: */\n \n-/* Hard regsets whose all bits are correspondingly zero or one.  */\n-extern HARD_REG_SET ira_zero_hard_reg_set;\n-extern HARD_REG_SET ira_one_hard_reg_set;\n-\n /* Map: hard regs X modes -> set of hard registers for storing value\n    of given mode starting with given hard register.  */\n extern HARD_REG_SET ira_reg_mode_hard_regset"}, {"sha": "dfaf34fa4aa67cb87844f2c6e73d8f57a16993ee", "filename": "gcc/ira.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "patch": "@@ -670,7 +670,7 @@ setup_reg_subclasses (void)\n \n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      if (hard_reg_set_equal_p (temp_hard_regset, ira_zero_hard_reg_set))\n+      if (hard_reg_set_empty_p (temp_hard_regset))\n \tcontinue;\n       for (j = 0; j < N_REG_CLASSES; j++)\n \tif (i != j)\n@@ -734,15 +734,15 @@ setup_cover_and_important_classes (void)\n \t  gcc_unreachable ();\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      if (! hard_reg_set_equal_p (temp_hard_regset, ira_zero_hard_reg_set))\n+      if (! hard_reg_set_empty_p (temp_hard_regset))\n \tira_reg_class_cover[ira_reg_class_cover_size++] = cl;\n     }\n   ira_important_classes_num = 0;\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     {\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      if (! hard_reg_set_equal_p (temp_hard_regset, ira_zero_hard_reg_set))\n+      if (! hard_reg_set_empty_p (temp_hard_regset))\n \tfor (j = 0; j < ira_reg_class_cover_size; j++)\n \t  {\n \t    COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n@@ -794,8 +794,7 @@ setup_class_translate (void)\n \t    {\n \t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n \t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t      if (! hard_reg_set_subset_p (temp_hard_regset,\n-\t\t\t\t\t   ira_zero_hard_reg_set))\n+\t      if (! hard_reg_set_empty_p (temp_hard_regset))\n \t\tgcc_unreachable ();\n \t    }\n #endif\n@@ -818,7 +817,7 @@ setup_class_translate (void)\n \t\t\t     reg_class_contents[cover_class]);\n \t  AND_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t  if (! hard_reg_set_equal_p (temp_hard_regset, ira_zero_hard_reg_set))\n+\t  if (! hard_reg_set_empty_p (temp_hard_regset))\n \t    {\n \t      min_cost = INT_MAX;\n \t      for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n@@ -875,8 +874,8 @@ setup_reg_class_intersect_union (void)\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t  COPY_HARD_REG_SET (temp_set2, reg_class_contents[cl2]);\n \t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n-\t  if (hard_reg_set_equal_p (temp_hard_regset, ira_zero_hard_reg_set)\n-\t      && hard_reg_set_equal_p (temp_set2, ira_zero_hard_reg_set))\n+\t  if (hard_reg_set_empty_p (temp_hard_regset)\n+\t      && hard_reg_set_empty_p (temp_set2))\n \t    {\n \t      for (i = 0;; i++)\n \t\t{\n@@ -1081,10 +1080,6 @@ ira_init_register_move_cost (enum machine_mode mode)\n \n \f\n \n-/* Hard regsets whose all bits are correspondingly zero or one.  */\n-HARD_REG_SET ira_zero_hard_reg_set;\n-HARD_REG_SET ira_one_hard_reg_set;\n-\n /* This is called once during compiler work.  It sets up\n    different arrays whose values don't depend on the compiled\n    function.  */\n@@ -1093,8 +1088,6 @@ ira_init_once (void)\n {\n   enum machine_mode mode;\n \n-  CLEAR_HARD_REG_SET (ira_zero_hard_reg_set);\n-  SET_HARD_REG_SET (ira_one_hard_reg_set);\n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n     {\n       ira_register_move_cost[mode] = NULL;"}]}