{"sha": "da124b6afd64364d321813cee77442a1de624ec5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGExMjRiNmFmZDY0MzY0ZDMyMTgxM2NlZTc3NDQyYTFkZTYyNGVjNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-27T10:03:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-27T10:03:09Z"}, "message": "[multiple changes]\n\n2011-09-27  Robert Dewar  <dewar@adacore.com>\n\n\t* a-comutr.ads: Minor reformatting.\n\n2011-09-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-cimutr.adb, a-cimutr.ads, a-cbmutr.adb, a-cbmutr.ads: Add children\n\titerators to multiway trees.\n\n2011-09-27  Yannick Moy  <moy@adacore.com>\n\n\t* debug.adb (d.D): New option for strict Alfa mode.\n\t* opt.ads (Strict_Alfa_Mode): New flag to interpret compiler\n\tpermissions as strictly as possible.\n\t* sem_ch3.adb (Signed_Integer_Type_Declaration): In non-strict\n\tAlfa mode, now, interpret ranges of base types like GNAT does; in\n\tstrict mode, simply change the range of the implicit base Itype.\n\t* gnat1drv.adb: Update comments. Set Strict_Alfa_Mode.\n\nFrom-SVN: r179258", "tree": {"sha": "119eb2e20370d17d8cd10aad56e8c0dc1560c851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/119eb2e20370d17d8cd10aad56e8c0dc1560c851"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da124b6afd64364d321813cee77442a1de624ec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da124b6afd64364d321813cee77442a1de624ec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da124b6afd64364d321813cee77442a1de624ec5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da124b6afd64364d321813cee77442a1de624ec5/comments", "author": null, "committer": null, "parents": [{"sha": "706a4067b883765331b693caded5f08a43eb2645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/706a4067b883765331b693caded5f08a43eb2645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/706a4067b883765331b693caded5f08a43eb2645"}], "stats": {"total": 310, "additions": 245, "deletions": 65}, "files": [{"sha": "8346b6b96eba918b33b1c0e8b656a3dd91a9232c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -1,3 +1,22 @@\n+2011-09-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-comutr.ads: Minor reformatting.\n+\n+2011-09-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-cimutr.adb, a-cimutr.ads, a-cbmutr.adb, a-cbmutr.ads: Add children\n+\titerators to multiway trees.\n+\n+2011-09-27  Yannick Moy  <moy@adacore.com>\n+\n+\t* debug.adb (d.D): New option for strict Alfa mode.\n+\t* opt.ads (Strict_Alfa_Mode): New flag to interpret compiler\n+\tpermissions as strictly as possible.\n+\t* sem_ch3.adb (Signed_Integer_Type_Declaration): In non-strict\n+\tAlfa mode, now, interpret ranges of base types like GNAT does; in\n+\tstrict mode, simply change the range of the implicit base Itype.\n+\t* gnat1drv.adb: Update comments. Set Strict_Alfa_Mode.\n+\n 2011-09-27  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch9.adb: Minor comment fixes."}, {"sha": "f4bdc5e4035ccd6a9ca447dcd3ed26e5e2afd0b6", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -40,10 +40,29 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    end record;\n \n    overriding function First (Object : Iterator) return Cursor;\n+\n    overriding function Next\n      (Object : Iterator;\n       Position : Cursor) return Cursor;\n \n+   type Child_Iterator is new Tree_Iterator_Interfaces.Reversible_Iterator with\n+   record\n+      Container : Tree_Access;\n+      Position  : Cursor;\n+   end record;\n+\n+   overriding function First (Object : Child_Iterator) return Cursor;\n+\n+   overriding function Next\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Previous\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Last (Object : Child_Iterator) return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -1241,6 +1260,14 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       return Object.Position;\n    end First;\n \n+   function First (Object : Child_Iterator) return Cursor is\n+      Node : Count_Type'Base;\n+\n+   begin\n+      Node := Object.Container.Nodes (Object.Position.Node).Children.First;\n+      return (Object.Container, Node);\n+   end First;\n+\n    -----------------\n    -- First_Child --\n    -----------------\n@@ -1809,6 +1836,16 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       end loop;\n    end Iterate_Children;\n \n+   function Iterate_Children\n+     (Container : Tree;\n+      Parent    : Cursor)\n+     return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      pragma Unreferenced (Container);\n+   begin\n+      return Child_Iterator'(Parent.Container, Parent);\n+   end Iterate_Children;\n+\n    ---------------------\n    -- Iterate_Subtree --\n    ---------------------\n@@ -1871,6 +1908,15 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Iterate_Children (Container, Subtree, Process);\n    end Iterate_Subtree;\n \n+   ----------\n+   -- Last --\n+   ----------\n+\n+   overriding function Last (Object : Child_Iterator) return Cursor is\n+   begin\n+      return Last_Child (Object.Position);\n+   end Last;\n+\n    ----------------\n    -- Last_Child --\n    ----------------\n@@ -1992,6 +2038,19 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       end if;\n    end Next;\n \n+   function Next\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+\n+   begin\n+      if Object.Container /= Position.Container then\n+         raise Program_Error;\n+      end if;\n+\n+      return Next_Sibling (Position);\n+   end Next;\n+\n    ------------------\n    -- Next_Sibling --\n    ------------------\n@@ -2137,6 +2196,22 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Container.Count := Container.Count + Count;\n    end Prepend_Child;\n \n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   overriding function Previous\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+   begin\n+      if Object.Container /= Position.Container then\n+         raise Program_Error;\n+      end if;\n+\n+      return Previous_Sibling (Position);\n+   end Previous;\n+\n    ----------------------\n    -- Previous_Sibling --\n    ----------------------"}, {"sha": "e014f82d4539203bad332596de83a88267a79a46", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -179,6 +179,11 @@ package Ada.Containers.Bounded_Multiway_Trees is\n    function Iterate_Subtree (Position : Cursor)\n      return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n \n+   function Iterate_Children\n+     (Container : Tree;\n+      Parent    : Cursor)\n+     return Tree_Iterator_Interfaces.Reversible_Iterator'Class;\n+\n    function Child_Count (Parent : Cursor) return Count_Type;\n \n    function Child_Depth (Parent, Child : Cursor) return Count_Type;"}, {"sha": "2fdc8a7546981a5d2e80b726ee07c2bc30afda03", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -39,11 +39,28 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       From_Root : Boolean;\n    end record;\n \n+   type Child_Iterator is new Tree_Iterator_Interfaces.Reversible_Iterator with\n+   record\n+      Container : Tree_Access;\n+      Position  : Cursor;\n+   end record;\n+\n    overriding function First (Object : Iterator) return Cursor;\n    overriding function Next\n      (Object : Iterator;\n       Position : Cursor) return Cursor;\n \n+   overriding function First (Object : Child_Iterator) return Cursor;\n+   overriding function Next\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Previous\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Last (Object : Child_Iterator) return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -936,6 +953,11 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       return Object.Position;\n    end First;\n \n+   function First (Object : Child_Iterator) return Cursor is\n+   begin\n+      return (Object.Container, Object.Position.Node.Children.First);\n+   end First;\n+\n    -----------------\n    -- First_Child --\n    -----------------\n@@ -1369,6 +1391,16 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       end loop;\n    end Iterate_Children;\n \n+   function Iterate_Children\n+     (Container : Tree;\n+      Parent    : Cursor)\n+     return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      pragma Unreferenced (Container);\n+   begin\n+      return Child_Iterator'(Parent.Container, Parent);\n+   end Iterate_Children;\n+\n    ---------------------\n    -- Iterate_Subtree --\n    ---------------------\n@@ -1425,6 +1457,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Iterate_Children (Container, Subtree, Process);\n    end Iterate_Subtree;\n \n+   ----------\n+   -- Last --\n+   ----------\n+\n+   overriding function Last (Object : Child_Iterator) return Cursor is\n+   begin\n+      return (Object.Container, Object.Position.Node.Children.Last);\n+   end Last;\n+\n    ----------------\n    -- Last_Child --\n    ----------------\n@@ -1551,6 +1592,21 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       end if;\n    end Next;\n \n+   function Next\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+      C : constant Tree_Node_Access := Position.Node.Next;\n+\n+   begin\n+      if C = null then\n+         return No_Element;\n+\n+      else\n+         return (Object.Container, C);\n+      end if;\n+   end Next;\n+\n    ------------------\n    -- Next_Sibling --\n    ------------------\n@@ -1673,6 +1729,25 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Container.Count := Container.Count + Count;\n    end Prepend_Child;\n \n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   overriding function Previous\n+     (Object : Child_Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+      C : constant Tree_Node_Access := Position.Node.Prev;\n+\n+   begin\n+      if C = null then\n+         return No_Element;\n+\n+      else\n+         return (Object.Container, C);\n+      end if;\n+   end Previous;\n+\n    ----------------------\n    -- Previous_Sibling --\n    ----------------------"}, {"sha": "29be8ca39eaa943def3f1f500b9b3335979df952", "filename": "gcc/ada/a-cimutr.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cimutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-cimutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.ads?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -181,6 +181,11 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n    function Iterate_Subtree (Position : Cursor)\n      return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n \n+   function Iterate_Children\n+     (Container : Tree;\n+      Parent    : Cursor)\n+     return Tree_Iterator_Interfaces.Reversible_Iterator'Class;\n+\n    function Child_Count (Parent : Cursor) return Count_Type;\n \n    function Child_Depth (Parent, Child : Cursor) return Count_Type;"}, {"sha": "b035e1637fe40b38e9e022404058aa8ad380b5eb", "filename": "gcc/ada/a-comutr.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -171,8 +171,8 @@ package Ada.Containers.Multiway_Trees is\n       Process   : not null access procedure (Position : Cursor));\n \n    procedure Iterate_Subtree\n-     (Position  : Cursor;\n-      Process   : not null access procedure (Position : Cursor));\n+     (Position : Cursor;\n+      Process  : not null access procedure (Position : Cursor));\n \n    function Iterate (Container : Tree)\n      return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n@@ -183,7 +183,7 @@ package Ada.Containers.Multiway_Trees is\n    function Iterate_Children\n      (Container : Tree;\n       Parent    : Cursor)\n-     return Tree_Iterator_Interfaces.Reversible_Iterator'Class;\n+      return Tree_Iterator_Interfaces.Reversible_Iterator'Class;\n \n    function Child_Count (Parent : Cursor) return Count_Type;\n "}, {"sha": "b3eb5cfd8e87f6a6673c23e5cfa339f0d1f79640", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -121,7 +121,7 @@ package body Debug is\n    --  d.A  Read/write Aspect_Specifications hash table to tree\n    --  d.B\n    --  d.C  Generate concatenation call, do not generate inline code\n-   --  d.D\n+   --  d.D  Strict Alfa mode\n    --  d.E  Force Alfa mode for gnat2why\n    --  d.F  Alfa mode\n    --  d.G  Precondition only mode for gnat2why\n@@ -580,6 +580,9 @@ package body Debug is\n    --  d.C  Generate call to System.Concat_n.Str_Concat_n routines in cases\n    --       where we would normally generate inline concatenation code.\n \n+   --  d.D  Strict Alfa mode. Interpret compiler permissions as strictly as\n+   --       possible in Alfa mode.\n+\n    --  d.E  Force Alfa mode for gnat2why. In this mode, errors are issued for\n    --       all violations of Alfa in user code, and warnings are issued for\n    --       constructs not yet implemented in gnat2why."}, {"sha": "57456cc67ff424bc519268a7f74dfe2a687fcd2d", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -392,6 +392,12 @@ procedure Gnat1drv is\n \n          Alfa_Mode := True;\n \n+         --  Set strict standard interpretation of compiler permissions\n+\n+         if Debug_Flag_Dot_DD then\n+            Strict_Alfa_Mode := True;\n+         end if;\n+\n          --  Turn off inlining, which would confuse formal verification output\n          --  and gain nothing.\n \n@@ -428,6 +434,8 @@ procedure Gnat1drv is\n          Debug_Generated_Code := False;\n \n          --  Turn cross-referencing on in case it was disabled (e.g. by -gnatD)\n+         --  as it is needed for computing effects of subprograms in the formal\n+         --  verification backend.\n \n          Xref_Active := True;\n \n@@ -473,13 +481,15 @@ procedure Gnat1drv is\n \n          Warning_Mode := Suppress;\n \n-         --  Suppress the generation of name tables for enumerations\n-         --  why???\n+         --  Suppress the generation of name tables for enumerations, which are\n+         --  not needed for formal verification, and fall outside the Alfa\n+         --  subset (use of pointers).\n \n          Global_Discard_Names := True;\n \n-         --  Suppress the expansion of tagged types and dispatching calls\n-         --  why???\n+         --  Suppress the expansion of tagged types and dispatching calls,\n+         --  which lead to the generation of non-Alfa code (use of pointers),\n+         --  which is more complex to formally verify than the original source.\n \n          Tagged_Type_Expansion := False;\n       end if;"}, {"sha": "65a2d17b8e0042e71a956bf55bcb783148681e37", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -1883,6 +1883,11 @@ package Opt is\n    --  generation of Why code for those parts of the input code that belong to\n    --  the Alfa subset of Ada. Set by debug flag -gnatd.F.\n \n+   Strict_Alfa_Mode : Boolean := False;\n+   --  Interpret compiler permissions as strictly as possible. E.g. base ranges\n+   --  for integers are limited to the strict minimum with this option. Set by\n+   --  debug flag -gnatd.D.\n+\n    function Full_Expander_Active return Boolean;\n    pragma Inline (Full_Expander_Active);\n    --  Returns the value of (Expander_Active and not Alfa_Mode). This \"flag\""}, {"sha": "dd48cff4d175678824ef929afee245680f151776", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 40, "deletions": 57, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da124b6afd64364d321813cee77442a1de624ec5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=da124b6afd64364d321813cee77442a1de624ec5", "patch": "@@ -19792,88 +19792,71 @@ package body Sem_Ch3 is\n       --  Complete both implicit base and declared first subtype entities\n \n       Set_Etype          (Implicit_Base, Base_Typ);\n-      Set_Scalar_Range   (Implicit_Base, Scalar_Range   (Base_Typ));\n       Set_Size_Info      (Implicit_Base,                (Base_Typ));\n       Set_RM_Size        (Implicit_Base, RM_Size        (Base_Typ));\n       Set_First_Rep_Item (Implicit_Base, First_Rep_Item (Base_Typ));\n \n       Set_Ekind          (T, E_Signed_Integer_Subtype);\n       Set_Etype          (T, Implicit_Base);\n \n-      --  In formal verification mode, override partially the decisions above\n-      --  to restrict base type's range to the minimum allowed by RM 3.5.4,\n-      --  namely the smallest symmetric range around zero with a possible extra\n-      --  negative value that contains the subtype range. Keep Size, RM_Size\n-      --  and First_Rep_Item info, which should not be relied upon in formal\n-      --  verification.\n-\n-      if Alfa_Mode then\n-\n-         --  If the range of the type is already symmetric with a possible\n-         --  extra negative value, leave it this way.\n-\n-         if UI_Le (Lo_Val, Hi_Val)\n-           and then (UI_Eq (Lo_Val, UI_Negate (Hi_Val))\n-                      or else\n-                        UI_Eq (Lo_Val, UI_Sub (UI_Negate (Hi_Val), Uint_1)))\n-         then\n-            null;\n+      --  In formal verification mode, restrict the base type's range to the\n+      --  minimum allowed by RM 3.5.4, namely the smallest symmetric range\n+      --  around zero with a possible extra negative value that contains the\n+      --  subtype range. Keep Size, RM_Size and First_Rep_Item info, which\n+      --  should not be relied upon in formal verification.\n \n-         else\n-            declare\n-               Sym_Hi_Val : Uint;\n-               Sym_Lo_Val : Uint;\n-               Decl       : Node_Id;\n-               Dloc       : constant Source_Ptr := Sloc (Def);\n-               Lbound     : Node_Id;\n-               Ubound     : Node_Id;\n+      if Strict_Alfa_Mode then\n+         declare\n+            Sym_Hi_Val : Uint;\n+            Sym_Lo_Val : Uint;\n+            Dloc       : constant Source_Ptr := Sloc (Def);\n+            Lbound     : Node_Id;\n+            Ubound     : Node_Id;\n+            Bounds     : Node_Id;\n \n-            begin\n-               --  If the subtype range is empty, the smallest base type range\n-               --  is the symmetric range around zero containing Lo_Val and\n-               --  Hi_Val.\n+         begin\n+            --  If the subtype range is empty, the smallest base type range\n+            --  is the symmetric range around zero containing Lo_Val and\n+            --  Hi_Val.\n \n-               if UI_Gt (Lo_Val, Hi_Val) then\n-                  Sym_Hi_Val := UI_Max (UI_Abs (Lo_Val), UI_Abs (Hi_Val));\n-                  Sym_Lo_Val := UI_Negate (Sym_Hi_Val);\n+            if UI_Gt (Lo_Val, Hi_Val) then\n+               Sym_Hi_Val := UI_Max (UI_Abs (Lo_Val), UI_Abs (Hi_Val));\n+               Sym_Lo_Val := UI_Negate (Sym_Hi_Val);\n \n                --  Otherwise, if the subtype range is not empty and Hi_Val has\n                --  the largest absolute value, Hi_Val is non negative and the\n                --  smallest base type range is the symmetric range around zero\n                --  containing Hi_Val.\n \n-               elsif UI_Le (UI_Abs (Lo_Val), UI_Abs (Hi_Val)) then\n-                  Sym_Hi_Val := Hi_Val;\n-                  Sym_Lo_Val := UI_Negate (Hi_Val);\n+            elsif UI_Le (UI_Abs (Lo_Val), UI_Abs (Hi_Val)) then\n+               Sym_Hi_Val := Hi_Val;\n+               Sym_Lo_Val := UI_Negate (Hi_Val);\n \n                --  Otherwise, the subtype range is not empty, Lo_Val has the\n                --  strictly largest absolute value, Lo_Val is negative and the\n                --  smallest base type range is the symmetric range around zero\n                --  with an extra negative value Lo_Val.\n \n-               else\n-                  Sym_Lo_Val := Lo_Val;\n-                  Sym_Hi_Val := UI_Sub (UI_Negate (Lo_Val), Uint_1);\n-               end if;\n+            else\n+               Sym_Lo_Val := Lo_Val;\n+               Sym_Hi_Val := UI_Sub (UI_Negate (Lo_Val), Uint_1);\n+            end if;\n \n-               Lbound := Make_Integer_Literal (Dloc, Sym_Lo_Val);\n-               Ubound := Make_Integer_Literal (Dloc, Sym_Hi_Val);\n-               Set_Is_Static_Expression (Lbound);\n-               Set_Is_Static_Expression (Ubound);\n+            Lbound := Make_Integer_Literal (Dloc, Sym_Lo_Val);\n+            Ubound := Make_Integer_Literal (Dloc, Sym_Hi_Val);\n+            Set_Is_Static_Expression (Lbound);\n+            Set_Is_Static_Expression (Ubound);\n+            Analyze_And_Resolve (Lbound, Any_Integer);\n+            Analyze_And_Resolve (Ubound, Any_Integer);\n \n-               Decl := Make_Full_Type_Declaration (Dloc,\n-                 Defining_Identifier => Implicit_Base,\n-                 Type_Definition     =>\n-                   Make_Signed_Integer_Type_Definition (Dloc,\n-                     Low_Bound  => Lbound,\n-                     High_Bound => Ubound));\n+            Bounds := Make_Range (Dloc, Lbound, Ubound);\n+            Set_Etype (Bounds, Base_Typ);\n \n-               Analyze (Decl);\n-               Set_Etype (Implicit_Base, Base_Type (Implicit_Base));\n-               Set_Etype (T, Base_Type (Implicit_Base));\n-               Insert_Before (Parent (Def), Decl);\n-            end;\n-         end if;\n+            Set_Scalar_Range (Implicit_Base, Bounds);\n+         end;\n+\n+      else\n+         Set_Scalar_Range (Implicit_Base, Scalar_Range (Base_Typ));\n       end if;\n \n       Set_Size_Info      (T,                (Implicit_Base));"}]}