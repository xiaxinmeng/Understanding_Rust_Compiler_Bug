{"sha": "6783fdb7057d559aa1da8afa2c15a702c532a03e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc4M2ZkYjcwNTdkNTU5YWExZGE4YWZhMmMxNWE3MDJjNTMyYTAzZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:53:04Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:53:04Z"}, "message": "Use function_arg_info for TARGET_FUNCTION_(INCOMING_)ARG\n\nThis patch makes both TARGET_FUNCTION_ARG and\nTARGET_FUNCTION_INCOMING_ARG take a function_arg_info.\nThey have to be done together since many targets use the\nsame function for both.\n\nThe hooks are passed the promoted mode instead of the original type mode.\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (function_arg, function_incoming_arg): Take a\n\tfunction_arg_info instead of a mode, tree and named flag.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_function_arg): Take a function_arg_info\n\tinstead of a mode, tree and named flag.\n\t(default_function_incoming_arg): Likewise.\n\t* targhooks.c (default_function_arg): Likewise.\n\t(default_function_incoming_arg): Likewise.\n\t* calls.h (function_arg_info::end_marker_p): New function.\n\t(function_arg_info::end_marker): Likewise.\n\t* calls.c (prepare_call_address, initialize_argument_information)\n\t(expand_call, emit_library_call_value_1): Update calls to\n\ttargetm.calls.function_arg and targetm.calls.function_incoming_arg.\n\t* dse.c: Include calls.h.\n\t(get_call_args): Update call to targetm.calls.function_arg.\n\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n\t* var-tracking.c (prepare_call_arguments): Likewise.\n\t* function.c (assign_parm_find_entry_rtl): Update call to\n\ttargetm.calls.function_incoming_arg.\n\t* config/aarch64/aarch64.c (aarch64_function_arg): Take a\n\tfunction_arg_info instead of a mode, tree and named flag.\n\t* config/alpha/alpha.c (alpha_function_arg): Likewise.\n\t* config/arc/arc.c (arc_function_arg): Likewise.\n\t* config/arm/arm.c (arm_function_arg): Likewise.\n\t(cmse_func_args_or_return_in_stack): Update call accordingly.\n\t(arm_function_ok_for_sibcall): Likewise.\n\t(cmse_nonsecure_call_clear_caller_saved): Likewise.\n\t* config/avr/avr.c (avr_function_arg): Take a function_arg_info\n\tinstead of a mode, tree and named flag.\n\t* config/bfin/bfin.c (bfin_function_arg): Likewise.\n\t* config/c6x/c6x.c (c6x_function_arg): Likewise.\n\t(c6x_call_saved_register_used): Update call accordingly.\n\t* config/cr16/cr16.c (cr16_function_arg): Take a function_arg_info\n\tinstead of a mode, tree and named flag.\n\t* config/cris/cris.c (cris_function_arg, cris_function_incoming_arg)\n\t(cris_function_arg_1): Likewise.\n\t* config/csky/csky.c (csky_function_arg): Likewise.\n\t* config/epiphany/epiphany.c (epiphany_function_arg): Likewise.\n\t* config/fr30/fr30.c (fr30_function_arg): Likewise.\n\t* config/frv/frv.c (frv_function_arg, frv_function_incoming_arg)\n\t(frv_function_arg_1): Likewise.\n\t* config/ft32/ft32.c (ft32_function_arg): Likewise.\n\t* config/gcn/gcn.c (gcn_function_arg): Likewise.\n\t* config/h8300/h8300.c (h8300_function_arg): Likewise.\n\t* config/i386/i386.c (ix86_function_arg): Likewise.\n\t* config/ia64/ia64.c (ia64_function_arg, ia64_function_incoming_arg)\n\t(ia64_function_arg_1): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_function_arg): Likewise.\n\t(iq2000_expand_prologue, iq2000_pass_by_reference): Update call\n\taccordingly.\n\t* config/lm32/lm32.c (lm32_function_arg): Take a function_arg_info\n\tinstead of a mode, tree and named flag.\n\t* config/m32c/m32c.c (m32c_function_arg): Likewise.\n\t* config/m32r/m32r.c (m32r_function_arg): Likewise.\n\t* config/m68k/m68k.c (m68k_function_arg): Likewise.\n\t* config/mcore/mcore.c (mcore_function_arg): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_function_arg): Likewise.\n\t(microblaze_expand_prologue): Update call accordingly.\n\t* config/mips/mips.c (mips_function_arg): Take a function_arg_info\n\tinstead of a mode, tree and named flag.\n\t* config/mmix/mmix.c (mmix_function_incoming_arg, mmix_function_arg)\n\t(mmix_function_arg_1): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_function_arg): Likewise.\n\t* config/moxie/moxie.c (moxie_function_arg): Likewise.\n\t* config/msp430/msp430.c (msp430_function_arg): Likewise.\n\t* config/nds32/nds32.c (nds32_function_arg): Likewise.\n\t* config/nios2/nios2.c (nios2_function_arg): Likewise.\n\t* config/nvptx/nvptx.c (nvptx_function_arg): Likewise.\n\t(nvptx_function_incoming_arg): Likewise.\n\t* config/or1k/or1k.c (or1k_function_arg): Likewise.\n\t* config/pa/pa.c (pa_function_arg): Likewise.\n\t* config/pdp11/pdp11.c (pdp11_function_arg): Likewise.\n\t* config/pru/pru.c (pru_function_arg): Likewise.\n\t* config/riscv/riscv.c (riscv_function_arg): Likewise.\n\t* config/rl78/rl78.c (rl78_function_arg): Likewise.\n\t* config/rs6000/rs6000-internal.h (rs6000_function_arg): Likewise.\n\t* config/rs6000/rs6000-call.c (rs6000_function_arg): Likewise.\n\t(rs6000_parm_needs_stack): Update call accordingly.\n\t* config/rx/rx.c (rx_function_arg): Take a function_arg_info\n\tinstead of a mode, tree and named flag.\n\t* config/s390/s390.c (s390_function_arg): Likewise.\n\t(s390_call_saved_register_used): Update call accordingly.\n\t* config/sh/sh.c (sh_function_arg): Take a function_arg_info\n\tinstead of a mode, tree and named flag.\n\t(sh_output_mi_thunk): Update call accordingly.\n\t* config/sparc/sparc.c (sparc_function_arg_1, sparc_function_arg)\n\t(sparc_function_incoming_arg): Take a function_arg_info instead of\n\ta mode, tree and named flag.\n\t* config/spu/spu.c (spu_function_arg): Likewise.\n\t* config/stormy16/stormy16.c (xstormy16_function_arg): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_function_arg): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_function_arg): Likewise.\n\t* config/v850/v850.c (v850_function_arg): Likewise.\n\t* config/vax/vax.c (vax_function_arg): Likewise.\n\t* config/visium/visium.c (visium_function_arg): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_function_arg_1, xtensa_function_arg)\n\t(xtensa_function_incoming_arg): Likewise.\n\nFrom-SVN: r274700", "tree": {"sha": "3decf215bea8101c34e9e017c493ee6b8ee25ab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3decf215bea8101c34e9e017c493ee6b8ee25ab1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6783fdb7057d559aa1da8afa2c15a702c532a03e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6783fdb7057d559aa1da8afa2c15a702c532a03e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6783fdb7057d559aa1da8afa2c15a702c532a03e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6783fdb7057d559aa1da8afa2c15a702c532a03e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7056ca417326a70eca05defb6a8b20b737d3417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7056ca417326a70eca05defb6a8b20b737d3417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7056ca417326a70eca05defb6a8b20b737d3417"}], "stats": {"total": 1361, "additions": 588, "deletions": 773}, "files": [{"sha": "6377619b7344cf862e189862fca1d8c7e336ff1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1,3 +1,103 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (function_arg, function_incoming_arg): Take a\n+\tfunction_arg_info instead of a mode, tree and named flag.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_function_arg): Take a function_arg_info\n+\tinstead of a mode, tree and named flag.\n+\t(default_function_incoming_arg): Likewise.\n+\t* targhooks.c (default_function_arg): Likewise.\n+\t(default_function_incoming_arg): Likewise.\n+\t* calls.h (function_arg_info::end_marker_p): New function.\n+\t(function_arg_info::end_marker): Likewise.\n+\t* calls.c (prepare_call_address, initialize_argument_information)\n+\t(expand_call, emit_library_call_value_1): Update calls to\n+\ttargetm.calls.function_arg and targetm.calls.function_incoming_arg.\n+\t* dse.c: Include calls.h.\n+\t(get_call_args): Update call to targetm.calls.function_arg.\n+\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n+\t* var-tracking.c (prepare_call_arguments): Likewise.\n+\t* function.c (assign_parm_find_entry_rtl): Update call to\n+\ttargetm.calls.function_incoming_arg.\n+\t* config/aarch64/aarch64.c (aarch64_function_arg): Take a\n+\tfunction_arg_info instead of a mode, tree and named flag.\n+\t* config/alpha/alpha.c (alpha_function_arg): Likewise.\n+\t* config/arc/arc.c (arc_function_arg): Likewise.\n+\t* config/arm/arm.c (arm_function_arg): Likewise.\n+\t(cmse_func_args_or_return_in_stack): Update call accordingly.\n+\t(arm_function_ok_for_sibcall): Likewise.\n+\t(cmse_nonsecure_call_clear_caller_saved): Likewise.\n+\t* config/avr/avr.c (avr_function_arg): Take a function_arg_info\n+\tinstead of a mode, tree and named flag.\n+\t* config/bfin/bfin.c (bfin_function_arg): Likewise.\n+\t* config/c6x/c6x.c (c6x_function_arg): Likewise.\n+\t(c6x_call_saved_register_used): Update call accordingly.\n+\t* config/cr16/cr16.c (cr16_function_arg): Take a function_arg_info\n+\tinstead of a mode, tree and named flag.\n+\t* config/cris/cris.c (cris_function_arg, cris_function_incoming_arg)\n+\t(cris_function_arg_1): Likewise.\n+\t* config/csky/csky.c (csky_function_arg): Likewise.\n+\t* config/epiphany/epiphany.c (epiphany_function_arg): Likewise.\n+\t* config/fr30/fr30.c (fr30_function_arg): Likewise.\n+\t* config/frv/frv.c (frv_function_arg, frv_function_incoming_arg)\n+\t(frv_function_arg_1): Likewise.\n+\t* config/ft32/ft32.c (ft32_function_arg): Likewise.\n+\t* config/gcn/gcn.c (gcn_function_arg): Likewise.\n+\t* config/h8300/h8300.c (h8300_function_arg): Likewise.\n+\t* config/i386/i386.c (ix86_function_arg): Likewise.\n+\t* config/ia64/ia64.c (ia64_function_arg, ia64_function_incoming_arg)\n+\t(ia64_function_arg_1): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_function_arg): Likewise.\n+\t(iq2000_expand_prologue, iq2000_pass_by_reference): Update call\n+\taccordingly.\n+\t* config/lm32/lm32.c (lm32_function_arg): Take a function_arg_info\n+\tinstead of a mode, tree and named flag.\n+\t* config/m32c/m32c.c (m32c_function_arg): Likewise.\n+\t* config/m32r/m32r.c (m32r_function_arg): Likewise.\n+\t* config/m68k/m68k.c (m68k_function_arg): Likewise.\n+\t* config/mcore/mcore.c (mcore_function_arg): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_function_arg): Likewise.\n+\t(microblaze_expand_prologue): Update call accordingly.\n+\t* config/mips/mips.c (mips_function_arg): Take a function_arg_info\n+\tinstead of a mode, tree and named flag.\n+\t* config/mmix/mmix.c (mmix_function_incoming_arg, mmix_function_arg)\n+\t(mmix_function_arg_1): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_function_arg): Likewise.\n+\t* config/moxie/moxie.c (moxie_function_arg): Likewise.\n+\t* config/msp430/msp430.c (msp430_function_arg): Likewise.\n+\t* config/nds32/nds32.c (nds32_function_arg): Likewise.\n+\t* config/nios2/nios2.c (nios2_function_arg): Likewise.\n+\t* config/nvptx/nvptx.c (nvptx_function_arg): Likewise.\n+\t(nvptx_function_incoming_arg): Likewise.\n+\t* config/or1k/or1k.c (or1k_function_arg): Likewise.\n+\t* config/pa/pa.c (pa_function_arg): Likewise.\n+\t* config/pdp11/pdp11.c (pdp11_function_arg): Likewise.\n+\t* config/pru/pru.c (pru_function_arg): Likewise.\n+\t* config/riscv/riscv.c (riscv_function_arg): Likewise.\n+\t* config/rl78/rl78.c (rl78_function_arg): Likewise.\n+\t* config/rs6000/rs6000-internal.h (rs6000_function_arg): Likewise.\n+\t* config/rs6000/rs6000-call.c (rs6000_function_arg): Likewise.\n+\t(rs6000_parm_needs_stack): Update call accordingly.\n+\t* config/rx/rx.c (rx_function_arg): Take a function_arg_info\n+\tinstead of a mode, tree and named flag.\n+\t* config/s390/s390.c (s390_function_arg): Likewise.\n+\t(s390_call_saved_register_used): Update call accordingly.\n+\t* config/sh/sh.c (sh_function_arg): Take a function_arg_info\n+\tinstead of a mode, tree and named flag.\n+\t(sh_output_mi_thunk): Update call accordingly.\n+\t* config/sparc/sparc.c (sparc_function_arg_1, sparc_function_arg)\n+\t(sparc_function_incoming_arg): Take a function_arg_info instead of\n+\ta mode, tree and named flag.\n+\t* config/spu/spu.c (spu_function_arg): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy16_function_arg): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_function_arg): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_function_arg): Likewise.\n+\t* config/v850/v850.c (v850_function_arg): Likewise.\n+\t* config/vax/vax.c (vax_function_arg): Likewise.\n+\t* config/visium/visium.c (visium_function_arg): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_function_arg_1, xtensa_function_arg)\n+\t(xtensa_function_incoming_arg): Likewise.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (setup_incoming_varargs): Take a function_arg_info"}, {"sha": "7947009faaad8b05a29e7a13cde1e84615423cb8", "filename": "gcc/calls.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -346,7 +346,8 @@ prepare_call_address (tree fndecl_or_type, rtx funexp, rtx static_chain_value,\n    It is zero if this call doesn't want a structure value.\n \n    NEXT_ARG_REG is the rtx that results from executing\n-     targetm.calls.function_arg (&args_so_far, VOIDmode, void_type_node, true)\n+     targetm.calls.function_arg (&args_so_far,\n+\t\t\t\t function_arg_info::end_marker ());\n    just after all the args have had their registers assigned.\n    This could be whatever you like, but normally it is the first\n    arg-register beyond those used for args in this call,\n@@ -2124,8 +2125,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n       targetm.calls.warn_parameter_passing_abi (args_so_far, type);\n \n-      args[i].reg = targetm.calls.function_arg (args_so_far, mode, type,\n-\t\t\t\t\t\targpos < n_named_args);\n+      function_arg_info arg (type, mode, argpos < n_named_args);\n+      args[i].reg = targetm.calls.function_arg (args_so_far, arg);\n \n       if (args[i].reg && CONST_INT_P (args[i].reg))\n \targs[i].reg = NULL;\n@@ -2135,12 +2136,10 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t arguments have to go into the incoming registers.  */\n       if (targetm.calls.function_incoming_arg != targetm.calls.function_arg)\n \targs[i].tail_call_reg\n-\t  = targetm.calls.function_incoming_arg (args_so_far, mode, type,\n-\t\t\t\t\t\t argpos < n_named_args);\n+\t  = targetm.calls.function_incoming_arg (args_so_far, arg);\n       else\n \targs[i].tail_call_reg = args[i].reg;\n \n-      function_arg_info arg (type, mode, argpos < n_named_args);\n       if (args[i].reg)\n \targs[i].partial = targetm.calls.arg_partial_bytes (args_so_far, arg);\n \n@@ -4244,14 +4243,11 @@ expand_call (tree exp, rtx target, int ignore)\n       /* Set up next argument register.  For sibling calls on machines\n \t with register windows this should be the incoming register.  */\n       if (pass == 0)\n-\tnext_arg_reg = targetm.calls.function_incoming_arg (args_so_far,\n-\t\t\t\t\t\t\t    VOIDmode,\n-\t\t\t\t\t\t\t    void_type_node,\n-\t\t\t\t\t\t\t    true);\n+\tnext_arg_reg = targetm.calls.function_incoming_arg\n+\t  (args_so_far, function_arg_info::end_marker ());\n       else\n-\tnext_arg_reg = targetm.calls.function_arg (args_so_far,\n-\t\t\t\t\t\t   VOIDmode, void_type_node,\n-\t\t\t\t\t\t   true);\n+\tnext_arg_reg = targetm.calls.function_arg\n+\t  (args_so_far, function_arg_info::end_marker ());\n \n       if (pass == 1 && (return_flags & ERF_RETURNS_ARG))\n \t{\n@@ -4869,8 +4865,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       argvec[count].partial = 0;\n \n       function_arg_info ptr_arg (Pmode, /*named=*/true);\n-      argvec[count].reg = targetm.calls.function_arg (args_so_far,\n-\t\t\t\t\t\t      Pmode, NULL_TREE, true);\n+      argvec[count].reg = targetm.calls.function_arg (args_so_far, ptr_arg);\n       gcc_assert (targetm.calls.arg_partial_bytes (args_so_far, ptr_arg) == 0);\n \n       locate_and_pad_parm (Pmode, NULL_TREE,\n@@ -4953,8 +4948,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       function_arg_info arg (mode, /*named=*/true);\n       argvec[count].mode = mode;\n       argvec[count].value = convert_modes (mode, GET_MODE (val), val, unsigned_p);\n-      argvec[count].reg = targetm.calls.function_arg (args_so_far, mode,\n-\t\t\t\t\t\t      NULL_TREE, true);\n+      argvec[count].reg = targetm.calls.function_arg (args_so_far, arg);\n \n       argvec[count].partial\n \t= targetm.calls.arg_partial_bytes (args_so_far, arg);\n@@ -5332,7 +5326,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t       original_args_size.constant, args_size.constant,\n \t       struct_value_size,\n \t       targetm.calls.function_arg (args_so_far,\n-\t\t\t\t\t   VOIDmode, void_type_node, true),\n+\t\t\t\t\t   function_arg_info::end_marker ()),\n \t       valreg,\n \t       old_inhibit_defer_pop + 1, call_fusage, flags, args_so_far);\n "}, {"sha": "54957bcd42bb3836ad2f8ab26366f328359cab09", "filename": "gcc/calls.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -77,6 +77,17 @@ class function_arg_info\n     return GET_MODE_SIZE (mode);\n   }\n \n+  /* True if the argument represents the end of the argument list,\n+     as returned by end_marker ().  */\n+  bool end_marker_p () const { return mode == VOIDmode; }\n+\n+  /* Return a function_arg_info that represents the end of the\n+     argument list.  */\n+  static function_arg_info end_marker ()\n+  {\n+    return function_arg_info (void_type_node, /*named=*/true);\n+  }\n+\n   /* The type of the argument, or null if not known (which is true for\n      libgcc support functions).  */\n   tree type;"}, {"sha": "e8e13a2b0b56b99c3db9232a8c637f464b0c8d26", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -4801,16 +4801,15 @@ aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-aarch64_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t      const_tree type, bool named)\n+aarch64_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   gcc_assert (pcum->pcs_variant == ARM_PCS_AAPCS64);\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     return NULL_RTX;\n \n-  aarch64_layout_arg (pcum_v, mode, type, named);\n+  aarch64_layout_arg (pcum_v, arg.mode, arg.type, arg.named);\n   return pcum->aapcs_reg;\n }\n "}, {"sha": "f43415acf9caa34a41abfdb805e7b7f880e3e2e4", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -5545,38 +5545,32 @@ alpha_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n+   ARG is a description of the argument.\n \n    On Alpha the first 6 words of args are normally in registers\n    and the rest are pushed.  */\n \n static rtx\n-alpha_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n+alpha_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int basereg;\n   int num_args;\n \n   /* Don't get confused and pass small structures in FP registers.  */\n-  if (type && AGGREGATE_TYPE_P (type))\n+  if (arg.aggregate_type_p ())\n     basereg = 16;\n   else\n     {\n       /* With alpha_split_complex_arg, we shouldn't see any raw complex\n \t values here.  */\n-      gcc_checking_assert (!COMPLEX_MODE_P (mode));\n+      gcc_checking_assert (!COMPLEX_MODE_P (arg.mode));\n \n       /* Set up defaults for FP operands passed in FP registers, and\n \t integral operands passed in integer registers.  */\n-      if (TARGET_FPREGS && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+      if (TARGET_FPREGS && GET_MODE_CLASS (arg.mode) == MODE_FLOAT)\n \tbasereg = 32 + 16;\n       else\n \tbasereg = 16;\n@@ -5586,12 +5580,12 @@ alpha_function_arg (cumulative_args_t cum_v, machine_mode mode,\n      the two platforms, so we can't avoid conditional compilation.  */\n #if TARGET_ABI_OPEN_VMS\n     {\n-      if (mode == VOIDmode)\n+      if (arg.end_marker_p ())\n \treturn alpha_arg_info_reg_val (*cum);\n \n       num_args = cum->num_args;\n       if (num_args >= 6\n-\t  || targetm.calls.must_pass_in_stack (mode, type))\n+\t  || targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n \treturn NULL_RTX;\n     }\n #elif TARGET_ABI_OSF\n@@ -5600,17 +5594,16 @@ alpha_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \treturn NULL_RTX;\n       num_args = *cum;\n \n-      /* VOID is passed as a special flag for \"last argument\".  */\n-      if (type == void_type_node)\n+      if (arg.end_marker_p ())\n \tbasereg = 16;\n-      else if (targetm.calls.must_pass_in_stack (mode, type))\n+      else if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n \treturn NULL_RTX;\n     }\n #else\n #error Unhandled ABI\n #endif\n \n-  return gen_rtx_REG (mode, num_args + basereg);\n+  return gen_rtx_REG (arg.mode, num_args + basereg);\n }\n \n /* Update the data in CUM to advance over an argument"}, {"sha": "9eb9e90ccc1840c659aeda9f8d3119dc442fa7b2", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 6, "deletions": 42, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -6449,63 +6449,27 @@ arc_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n   return ret;\n }\n \n-/* This function is used to control a function argument is passed in a\n-   register, and which register.\n-\n-   The arguments are CUM, of type CUMULATIVE_ARGS, which summarizes\n-   (in a way defined by INIT_CUMULATIVE_ARGS and FUNCTION_ARG_ADVANCE)\n-   all of the previous arguments so far passed in registers; MODE, the\n-   machine mode of the argument; TYPE, the data type of the argument\n-   as a tree node or 0 if that is not known (which happens for C\n-   support library functions); and NAMED, which is 1 for an ordinary\n-   argument and 0 for nameless arguments that correspond to `...' in\n-   the called function's prototype.\n-\n-   The returned value should either be a `reg' RTX for the hard\n-   register in which to pass the argument, or zero to pass the\n-   argument on the stack.\n-\n-   For machines like the Vax and 68000, where normally all arguments\n-   are pushed, zero suffices as a definition.\n-\n-   The usual way to make the ANSI library `stdarg.h' work on a machine\n-   where some arguments are usually passed in registers, is to cause\n-   nameless arguments to be passed on the stack instead.  This is done\n-   by making the function return 0 whenever NAMED is 0.\n-\n-   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the\n-   definition of this function to determine if this argument is of a\n-   type that must be passed in the stack.  If `REG_PARM_STACK_SPACE'\n-   is not defined and the function returns non-zero for such an\n-   argument, the compiler will abort.  If `REG_PARM_STACK_SPACE' is\n-   defined, the argument will be computed in the stack and then loaded\n-   into a register.\n-\n-   The function is used to implement macro FUNCTION_ARG.  */\n-/* On the ARC the first MAX_ARC_PARM_REGS args are normally in registers\n-   and the rest are pushed.  */\n+/* Implement TARGET_FUNCTION_ARG.  On the ARC the first MAX_ARC_PARM_REGS\n+   args are normally in registers and the rest are pushed.  */\n \n static rtx\n-arc_function_arg (cumulative_args_t cum_v,\n-\t\t  machine_mode mode,\n-\t\t  const_tree type ATTRIBUTE_UNUSED,\n-\t\t  bool named ATTRIBUTE_UNUSED)\n+arc_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int arg_num = *cum;\n   rtx ret;\n   const char *debstr ATTRIBUTE_UNUSED;\n \n-  arg_num = ROUND_ADVANCE_CUM (arg_num, mode, type);\n+  arg_num = ROUND_ADVANCE_CUM (arg_num, arg.mode, arg.type);\n   /* Return a marker for use in the call instruction.  */\n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     {\n       ret = const0_rtx;\n       debstr = \"<0>\";\n     }\n   else if (GPR_REST_ARG_REGS (arg_num) > 0)\n     {\n-      ret = gen_rtx_REG (mode, arg_num);\n+      ret = gen_rtx_REG (arg.mode, arg_num);\n       debstr = reg_names [arg_num];\n     }\n   else"}, {"sha": "e9265782f08968bfffdb3025c5831d8a63f5cecd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -189,8 +189,7 @@ static rtx_insn *emit_set_insn (rtx, rtx);\n static rtx emit_multi_reg_push (unsigned long, unsigned long);\n static int arm_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t  const function_arg_info &);\n-static rtx arm_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t     const_tree, bool);\n+static rtx arm_function_arg (cumulative_args_t, const function_arg_info &);\n static void arm_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n static pad_direction arm_function_arg_padding (machine_mode, const_tree);\n@@ -6658,14 +6657,9 @@ arm_needs_doubleword_align (machine_mode mode, const_tree type)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n+   ARG is a description of the argument.\n \n    On the ARM, normally the first 16 bytes are passed in registers r0-r3; all\n    other arguments are passed on the stack.  If (NAMED == 0) (which happens\n@@ -6674,31 +6668,31 @@ arm_needs_doubleword_align (machine_mode mode, const_tree type)\n    indeed make it pass in the stack if necessary).  */\n \n static rtx\n-arm_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t  const_tree type, bool named)\n+arm_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   int nregs;\n \n   /* Handle the special case quickly.  Pick an arbitrary value for op2 of\n      a call insn (op3 of a call_value insn).  */\n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     return const0_rtx;\n \n   if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n     {\n-      aapcs_layout_arg (pcum, mode, type, named);\n+      aapcs_layout_arg (pcum, arg.mode, arg.type, arg.named);\n       return pcum->aapcs_reg;\n     }\n \n   /* Varargs vectors are treated the same as long long.\n      named_count avoids having to change the way arm handles 'named' */\n   if (TARGET_IWMMXT_ABI\n-      && arm_vector_mode_supported_p (mode)\n+      && arm_vector_mode_supported_p (arg.mode)\n       && pcum->named_count > pcum->nargs + 1)\n     {\n       if (pcum->iwmmxt_nregs <= 9)\n-\treturn gen_rtx_REG (mode, pcum->iwmmxt_nregs + FIRST_IWMMXT_REGNUM);\n+\treturn gen_rtx_REG (arg.mode,\n+\t\t\t    pcum->iwmmxt_nregs + FIRST_IWMMXT_REGNUM);\n       else\n \t{\n \t  pcum->can_split = false;\n@@ -6709,16 +6703,16 @@ arm_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n   /* Put doubleword aligned quantities in even register pairs.  */\n   if ((pcum->nregs & 1) && ARM_DOUBLEWORD_ALIGN)\n     {\n-      int res = arm_needs_doubleword_align (mode, type);\n+      int res = arm_needs_doubleword_align (arg.mode, arg.type);\n       if (res < 0 && warn_psabi)\n \tinform (input_location, \"parameter passing for argument of type \"\n-\t\t\"%qT changed in GCC 7.1\", type);\n+\t\t\"%qT changed in GCC 7.1\", arg.type);\n       else if (res > 0)\n \t{\n \t  pcum->nregs++;\n \t  if (res > 1 && warn_psabi)\n \t    inform (input_location, \"parameter passing for argument of type \"\n-\t\t    \"%qT changed in GCC 9.1\", type);\n+\t\t    \"%qT changed in GCC 9.1\", arg.type);\n \t}\n     }\n \n@@ -6728,12 +6722,12 @@ arm_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n   if (pcum->can_split)\n     nregs = 1;\n   else\n-    nregs = ARM_NUM_REGS2 (mode, type);\n+    nregs = ARM_NUM_REGS2 (arg.mode, arg.type);\n \n-  if (!named || pcum->nregs + nregs > NUM_ARG_REGS)\n+  if (!arg.named || pcum->nregs + nregs > NUM_ARG_REGS)\n     return NULL_RTX;\n \n-  return gen_rtx_REG (mode, pcum->nregs);\n+  return gen_rtx_REG (arg.mode, pcum->nregs);\n }\n \n static unsigned int\n@@ -6999,7 +6993,7 @@ cmse_func_args_or_return_in_stack (tree fndecl, tree name, tree fntype)\n       function_arg_info arg (arg_type, /*named=*/true);\n       if (!first_param)\n \tarm_function_arg_advance (args_so_far, arg_mode, arg_type, true);\n-      arg_rtx = arm_function_arg (args_so_far, arg_mode, arg_type, true);\n+      arg_rtx = arm_function_arg (args_so_far, arg);\n       if (!arg_rtx || arm_arg_partial_bytes (args_so_far, arg))\n \t{\n \t  error (\"%qE attribute not available to functions with arguments \"\n@@ -7387,7 +7381,8 @@ arm_function_ok_for_sibcall (tree decl, tree exp)\n \t    arm_function_arg_advance (cum_v, TYPE_MODE (type), type, true);\n \t}\n \n-      if (!arm_function_arg (cum_v, SImode, integer_type_node, true))\n+      function_arg_info arg (integer_type_node, /*named=*/true);\n+      if (!arm_function_arg (cum_v, arg))\n \treturn false;\n     }\n \n@@ -17451,12 +17446,12 @@ cmse_nonsecure_call_clear_caller_saved (void)\n \t      if (VOID_TYPE_P (arg_type))\n \t\tcontinue;\n \n+\t      function_arg_info arg (arg_type, /*named=*/true);\n \t      if (!first_param)\n \t\tarm_function_arg_advance (args_so_far, arg_mode, arg_type,\n \t\t\t\t\t  true);\n \n-\t      arg_rtx = arm_function_arg (args_so_far, arg_mode, arg_type,\n-\t\t\t\t\t  true);\n+\t      arg_rtx = arm_function_arg (args_so_far, arg);\n \t      gcc_assert (REG_P (arg_rtx));\n \t      to_clear_args_mask\n \t\t= compute_not_to_clear_mask (arg_type, arg_rtx,"}, {"sha": "d6a35f253c463dabd9acfa118f64c54032ff089c", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -3388,14 +3388,13 @@ avr_num_arg_regs (machine_mode mode, const_tree type)\n    in a register, and which register.  */\n \n static rtx\n-avr_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-                  const_tree type, bool named ATTRIBUTE_UNUSED)\n+avr_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int bytes = avr_num_arg_regs (mode, type);\n+  int bytes = avr_num_arg_regs (arg.mode, arg.type);\n \n   if (cum->nregs && bytes <= cum->nregs)\n-    return gen_rtx_REG (mode, cum->regno - bytes);\n+    return gen_rtx_REG (arg.mode, cum->regno - bytes);\n \n   return NULL_RTX;\n }"}, {"sha": "45fbd39dc3eb37b33deb7fb65ffd78aab4255665", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1682,32 +1682,25 @@ bfin_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+   ARG is a description of the argument.  */\n \n static rtx\n-bfin_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+bfin_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int bytes\n-    = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  int bytes = arg.promoted_size_in_bytes ();\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     /* Compute operand 2 of the call insn.  */\n     return GEN_INT (cum->call_cookie);\n \n   if (bytes == -1)\n     return NULL_RTX;\n \n   if (cum->nregs)\n-    return gen_rtx_REG (mode, *(cum->arg_regs));\n+    return gen_rtx_REG (arg.mode, *(cum->arg_regs));\n \n   return NULL_RTX;\n }"}, {"sha": "32715266291a9ccc77b4a63bf7efcefe8b8081f6", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -499,16 +499,15 @@ c6x_init_cumulative_args (CUMULATIVE_ARGS *cum, const_tree fntype, rtx libname,\n     }\n }\n \n-/* Implements the macro FUNCTION_ARG defined in c6x.h.  */\n+/* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-c6x_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n+c6x_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   if (cum->count >= cum->nregs)\n     return NULL_RTX;\n-  if (type)\n+  if (tree type = arg.type)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n       if (TARGET_BIG_ENDIAN && AGGREGATE_TYPE_P (type))\n@@ -519,11 +518,11 @@ c6x_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t      rtx reg2 = gen_rtx_REG (SImode, argument_registers[cum->count]);\n \t      rtvec vec = gen_rtvec (2, gen_rtx_EXPR_LIST (VOIDmode, reg1, const0_rtx),\n \t\t\t\t     gen_rtx_EXPR_LIST (VOIDmode, reg2, GEN_INT (4)));\n-\t      return gen_rtx_PARALLEL (mode, vec);\n+\t      return gen_rtx_PARALLEL (arg.mode, vec);\n \t    }\n \t}\n     }\n-  return gen_rtx_REG (mode, argument_registers[cum->count]);\n+  return gen_rtx_REG (arg.mode, argument_registers[cum->count]);\n }\n \n static void\n@@ -1134,7 +1133,8 @@ c6x_call_saved_register_used (tree call_expr)\n  \t  type = build_pointer_type (type);\n  \t}\n \n-       parm_rtx = c6x_function_arg (cum, mode, type, 0);\n+       function_arg_info arg (type, mode, /*named=*/false);\n+       parm_rtx = c6x_function_arg (cum, arg);\n \n        c6x_function_arg_advance (cum, mode, type, 0);\n "}, {"sha": "25185216e38745505152ffa6f00017c3cad77278", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -592,10 +592,9 @@ enough_regs_for_param (CUMULATIVE_ARGS * cum, const_tree type,\n   return 0;\n }\n \n-/* Implements the macro FUNCTION_ARG defined in cr16.h.  */\n+/* Implement TARGET_FUNCTION_ARG.  */\n static rtx\n-cr16_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+cr16_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   cum->last_parm_in_reg = 0;\n@@ -604,31 +603,31 @@ cr16_function_arg (cumulative_args_t cum_v, machine_mode mode,\n      had their registers assigned. The rtx that function_arg returns from \n      this type is supposed to pass to 'gen_call' but currently it is not \n      implemented.  */\n-  if (type == void_type_node)\n+  if (arg.end_marker_p ())\n     return NULL_RTX;\n \n-  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type) || (cum->ints < 0))\n     return NULL_RTX;\n \n-  if (mode == BLKmode)\n+  if (arg.mode == BLKmode)\n     {\n       /* Enable structures that need padding bytes at the end to pass to a\n          function in registers.  */\n-      if (enough_regs_for_param (cum, type, mode) != 0)\n+      if (enough_regs_for_param (cum, arg.type, arg.mode) != 0)\n \t{\n \t  cum->last_parm_in_reg = 1;\n-\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n+\t  return gen_rtx_REG (arg.mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n \t}\n     }\n \n   if ((MIN_REG_FOR_PASSING_ARGS + cum->ints) > MAX_REG_FOR_PASSING_ARGS)\n     return NULL_RTX;\n   else\n     {\n-      if (enough_regs_for_param (cum, type, mode) != 0)\n+      if (enough_regs_for_param (cum, arg.type, arg.mode) != 0)\n \t{\n \t  cum->last_parm_in_reg = 1;\n-\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n+\t  return gen_rtx_REG (arg.mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n \t}\n     }\n "}, {"sha": "5317e49601c97e503e3c7b842cbdce4c879600ea", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -144,10 +144,9 @@ static bool cris_pass_by_reference (cumulative_args_t,\n \t\t\t\t    const function_arg_info &);\n static int cris_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n-static rtx cris_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t      const_tree, bool);\n+static rtx cris_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx cris_function_incoming_arg (cumulative_args_t,\n-\t\t\t\t       machine_mode, const_tree, bool);\n+\t\t\t\t       const function_arg_info &);\n static void cris_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static rtx_insn *cris_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n@@ -4121,15 +4120,13 @@ cris_arg_partial_bytes (cumulative_args_t ca, const function_arg_info &arg)\n }\n \n static rtx\n-cris_function_arg_1 (cumulative_args_t ca_v,\n-\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t     const_tree type ATTRIBUTE_UNUSED,\n-\t\t     bool named, bool incoming)\n+cris_function_arg_1 (cumulative_args_t ca_v, const function_arg_info &arg,\n+\t\t     bool incoming)\n {\n   const CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n \n-  if ((!incoming || named) && ca->regs < CRIS_MAX_ARGS_IN_REGS)\n-    return gen_rtx_REG (mode, CRIS_FIRST_ARG_REG + ca->regs);\n+  if ((!incoming || arg.named) && ca->regs < CRIS_MAX_ARGS_IN_REGS)\n+    return gen_rtx_REG (arg.mode, CRIS_FIRST_ARG_REG + ca->regs);\n   else\n     return NULL_RTX;\n }\n@@ -4138,24 +4135,22 @@ cris_function_arg_1 (cumulative_args_t ca_v,\n    The void_type_node is sent as a \"closing\" call.  */\n \n static rtx\n-cris_function_arg (cumulative_args_t ca, machine_mode mode,\n-\t\t   const_tree type, bool named)\n+cris_function_arg (cumulative_args_t ca, const function_arg_info &arg)\n {\n-  return cris_function_arg_1 (ca, mode, type, named, false);\n+  return cris_function_arg_1 (ca, arg, false);\n }\n \n /* Worker function for TARGET_FUNCTION_INCOMING_ARG.\n \n    The differences between this and the previous, is that this one checks\n    that an argument is named, since incoming stdarg/varargs arguments are\n    pushed onto the stack, and we don't have to check against the \"closing\"\n-   void_type_node TYPE parameter.  */\n+   function_arg_info::end_marker parameter.  */\n \n static rtx\n-cris_function_incoming_arg (cumulative_args_t ca, machine_mode mode,\n-\t\t\t    const_tree type, bool named)\n+cris_function_incoming_arg (cumulative_args_t ca, const function_arg_info &arg)\n {\n-  return cris_function_arg_1 (ca, mode, type, named, true);\n+  return cris_function_arg_1 (ca, arg, true);\n }\n \n /* Worker function for TARGET_FUNCTION_ARG_ADVANCE.  */"}, {"sha": "13312af488ea8bf99d9af0cb8ed90dbf3d6cc8fb", "filename": "gcc/config/csky/csky.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fcsky%2Fcsky.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fcsky%2Fcsky.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1784,23 +1784,16 @@ csky_initial_elimination_offset (int from, int to)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+   ARG is a description of the argument.  */\n static rtx\n-csky_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t   const_tree type ATTRIBUTE_UNUSED,\n-\t\t   bool named ATTRIBUTE_UNUSED)\n+csky_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n \n   if (*pcum < CSKY_NPARM_REGS)\n-    return gen_rtx_REG (mode, CSKY_FIRST_PARM_REGNUM + *pcum);\n+    return gen_rtx_REG (arg.mode, CSKY_FIRST_PARM_REGNUM + *pcum);\n \n   return NULL_RTX;\n }"}, {"sha": "e1f81485d6dd50302478ce3b756cdc512ab05416", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -2254,24 +2254,18 @@ epiphany_conditional_register_usage (void)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+   ARG is a description of the argument.  */\n /* On the EPIPHANY the first MAX_EPIPHANY_PARM_REGS args are normally in\n    registers and the rest are pushed.  */\n static rtx\n-epiphany_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n+epiphany_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS cum = *get_cumulative_args (cum_v);\n \n-  if (PASS_IN_REG_P (cum, mode, type))\n-    return gen_rtx_REG (mode, ROUND_ADVANCE_CUM (cum, mode, type));\n+  if (PASS_IN_REG_P (cum, arg.mode, arg.type))\n+    return gen_rtx_REG (arg.mode, ROUND_ADVANCE_CUM (cum, arg.mode, arg.type));\n   return 0;\n }\n "}, {"sha": "873606ae017fa60da29e97aa77750a07280f48a4", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -119,8 +119,7 @@ static void fr30_setup_incoming_varargs (cumulative_args_t,\n static bool fr30_must_pass_in_stack (machine_mode, const_tree);\n static int fr30_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n-static rtx fr30_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t      const_tree, bool);\n+static rtx fr30_function_arg (cumulative_args_t, const function_arg_info &);\n static void fr30_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static bool fr30_frame_pointer_required (void);\n@@ -800,17 +799,16 @@ fr30_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n }\n \n static rtx\n-fr30_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type, bool named)\n+fr30_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (!named\n-      || fr30_must_pass_in_stack (mode, type)\n+  if (!arg.named\n+      || fr30_must_pass_in_stack (arg.mode, arg.type)\n       || *cum >= FR30_NUM_ARG_REGS)\n     return NULL_RTX;\n   else\n-    return gen_rtx_REG (mode, *cum + FIRST_ARG_REGNUM);\n+    return gen_rtx_REG (arg.mode, *cum + FIRST_ARG_REGNUM);\n }\n \n /* A C statement (sans semicolon) to update the summarizer variable CUM to"}, {"sha": "08163f0d35de1cedb46dc56bbab02f23216c22ce", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -382,10 +382,9 @@ static rtx frv_struct_value_rtx\t\t\t(tree, int);\n static bool frv_must_pass_in_stack (machine_mode mode, const_tree type);\n static int frv_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t  const function_arg_info &);\n-static rtx frv_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t     const_tree, bool);\n-static rtx frv_function_incoming_arg (cumulative_args_t, machine_mode,\n-\t\t\t\t      const_tree, bool);\n+static rtx frv_function_arg (cumulative_args_t, const function_arg_info &);\n+static rtx frv_function_incoming_arg (cumulative_args_t,\n+\t\t\t\t      const function_arg_info &);\n static void frv_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static unsigned int frv_function_arg_boundary\t(machine_mode,\n@@ -3099,13 +3098,12 @@ frv_function_arg_boundary (machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n static rtx\n-frv_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n-\t\t    const_tree type ATTRIBUTE_UNUSED, bool named,\n+frv_function_arg_1 (cumulative_args_t cum_v, const function_arg_info &arg,\n \t\t    bool incoming ATTRIBUTE_UNUSED)\n {\n   const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n+  machine_mode xmode = (arg.mode == BLKmode) ? SImode : arg.mode;\n   int arg_num = *cum;\n   rtx ret;\n   const char *debstr;\n@@ -3132,23 +3130,22 @@ frv_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n \t     \"function_arg: words = %2d, mode = %4s, named = %d, size = %3d, arg = %s\\n\",\n-\t     arg_num, GET_MODE_NAME (mode), named, GET_MODE_SIZE (mode), debstr);\n+\t     arg_num, GET_MODE_NAME (arg.mode), arg.named,\n+\t     GET_MODE_SIZE (arg.mode), debstr);\n \n   return ret;\n }\n \n static rtx\n-frv_function_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t  const_tree type, bool named)\n+frv_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n {\n-  return frv_function_arg_1 (cum, mode, type, named, false);\n+  return frv_function_arg_1 (cum, arg, false);\n }\n \n static rtx\n-frv_function_incoming_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t\t   const_tree type, bool named)\n+frv_function_incoming_arg (cumulative_args_t cum, const function_arg_info &arg)\n {\n-  return frv_function_arg_1 (cum, mode, type, named, true);\n+  return frv_function_arg_1 (cum, arg, true);\n }\n \n \f"}, {"sha": "6dc91db4ccdb7c73384608062e44da8805486f75", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -657,14 +657,12 @@ ft32_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n    NULL_RTX if there's no more space.  */\n \n static rtx\n-ft32_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-                   const_tree type ATTRIBUTE_UNUSED,\n-                   bool named ATTRIBUTE_UNUSED)\n+ft32_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   if (*cum < 8)\n-    return gen_rtx_REG (mode, *cum);\n+    return gen_rtx_REG (arg.mode, *cum);\n   else\n     return NULL_RTX;\n }"}, {"sha": "9f4e9eeb7825dd3f21024412f559ece2d658ad30", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -2255,49 +2255,48 @@ gcn_pretend_outgoing_varargs_named (cumulative_args_t cum_v)\n    and if so, which register.  */\n \n static rtx\n-gcn_function_arg (cumulative_args_t cum_v, machine_mode mode, const_tree type,\n-\t\t  bool named)\n+gcn_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   if (cum->normal_function)\n     {\n-      if (!named || mode == VOIDmode)\n+      if (!arg.named || arg.end_marker_p ())\n \treturn 0;\n \n-      if (targetm.calls.must_pass_in_stack (mode, type))\n+      if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n \treturn 0;\n \n       int reg_num = FIRST_PARM_REG + cum->num;\n-      int num_regs = num_arg_regs (mode, type);\n+      int num_regs = num_arg_regs (arg.mode, arg.type);\n       if (num_regs > 0)\n \twhile (reg_num % num_regs != 0)\n \t  reg_num++;\n       if (reg_num + num_regs <= FIRST_PARM_REG + NUM_PARM_REGS)\n-\treturn gen_rtx_REG (mode, reg_num);\n+\treturn gen_rtx_REG (arg.mode, reg_num);\n     }\n   else\n     {\n       if (cum->num >= cum->args.nargs)\n \t{\n-\t  cum->offset = (cum->offset + TYPE_ALIGN (type) / 8 - 1)\n-\t    & -(TYPE_ALIGN (type) / 8);\n+\t  cum->offset = (cum->offset + TYPE_ALIGN (arg.type) / 8 - 1)\n+\t    & -(TYPE_ALIGN (arg.type) / 8);\n \t  cfun->machine->kernarg_segment_alignment\n \t    = MAX ((unsigned) cfun->machine->kernarg_segment_alignment,\n-\t\t   TYPE_ALIGN (type) / 8);\n+\t\t   TYPE_ALIGN (arg.type) / 8);\n \t  rtx addr = gen_rtx_REG (DImode,\n \t\t\t\t  cum->args.reg[KERNARG_SEGMENT_PTR_ARG]);\n \t  if (cum->offset)\n \t    addr = gen_rtx_PLUS (DImode, addr,\n \t\t\t\t gen_int_mode (cum->offset, DImode));\n-\t  rtx mem = gen_rtx_MEM (mode, addr);\n-\t  set_mem_attributes (mem, const_cast<tree>(type), 1);\n+\t  rtx mem = gen_rtx_MEM (arg.mode, addr);\n+\t  set_mem_attributes (mem, arg.type, 1);\n \t  set_mem_addr_space (mem, ADDR_SPACE_SCALAR_FLAT);\n \t  MEM_READONLY_P (mem) = 1;\n \t  return mem;\n \t}\n \n       int a = cum->args.order[cum->num];\n-      if (mode != gcn_kernel_arg_types[a].mode)\n+      if (arg.mode != gcn_kernel_arg_types[a].mode)\n \t{\n \t  error (\"wrong type of argument %s\", gcn_kernel_arg_types[a].name);\n \t  return 0;"}, {"sha": "653d0ecd3f2efa1a5ba341c124324eb3537b8b3a", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1081,17 +1081,16 @@ h8300_pr_saveall (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n   pragma_saveall = 1;\n }\n \n-/* If the next function argument with MODE and TYPE is to be passed in\n-   a register, return a reg RTX for the hard register in which to pass\n-   the argument.  CUM represents the state after the last argument.\n-   If the argument is to be pushed, NULL_RTX is returned.\n+/* If the next function argument ARG is to be passed in a register, return\n+   a reg RTX for the hard register in which to pass the argument.  CUM\n+   represents the state after the last argument.  If the argument is to\n+   be pushed, NULL_RTX is returned.\n \n    On the H8/300 all normal args are pushed, unless -mquickcall in which\n    case the first 3 arguments are passed in registers.  */\n \n static rtx\n-h8300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t    const_tree type, bool named)\n+h8300_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n@@ -1119,7 +1118,7 @@ h8300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   int regpass = 0;\n \n   /* Never pass unnamed arguments in registers.  */\n-  if (!named)\n+  if (!arg.named)\n     return NULL_RTX;\n \n   /* Pass 3 regs worth of data in regs when user asked on the command line.  */\n@@ -1143,16 +1142,10 @@ h8300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \n   if (regpass)\n     {\n-      int size;\n-\n-      if (mode == BLKmode)\n-\tsize = int_size_in_bytes (type);\n-      else\n-\tsize = GET_MODE_SIZE (mode);\n-\n+      int size = arg.promoted_size_in_bytes ();\n       if (size + cum->nbytes <= regpass * UNITS_PER_WORD\n \t  && cum->nbytes / UNITS_PER_WORD <= 3)\n-\tresult = gen_rtx_REG (mode, cum->nbytes / UNITS_PER_WORD);\n+\tresult = gen_rtx_REG (arg.mode, cum->nbytes / UNITS_PER_WORD);\n     }\n \n   return result;"}, {"sha": "9950d2d9a105e1a763e77554b28266f1abcfe1c4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -3206,77 +3206,69 @@ function_arg_ms_64 (const CUMULATIVE_ARGS *cum, machine_mode mode,\n /* Return where to put the arguments to a function.\n    Return zero to push the argument on the stack, or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.  TYPE is the data type of the\n-   argument.  It is null for libcalls where that information may not be\n-   available.  CUM gives information about the preceding args and about\n-   the function being called.  NAMED is nonzero if this argument is a\n-   named parameter (otherwise it is an extra parameter matching an\n-   ellipsis).  */\n+   ARG describes the argument while CUM gives information about the\n+   preceding args and about the function being called.  */\n \n static rtx\n-ix86_function_arg (cumulative_args_t cum_v, machine_mode omode,\n-\t\t   const_tree type, bool named)\n+ix86_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  machine_mode mode = omode;\n+  machine_mode mode = arg.mode;\n   HOST_WIDE_INT bytes, words;\n-  rtx arg;\n+  rtx reg;\n \n   if (!cum->caller && cfun->machine->func_type != TYPE_NORMAL)\n     {\n-      gcc_assert (type != NULL_TREE);\n-      if (POINTER_TYPE_P (type))\n+      gcc_assert (arg.type != NULL_TREE);\n+      if (POINTER_TYPE_P (arg.type))\n \t{\n \t  /* This is the pointer argument.  */\n-\t  gcc_assert (TYPE_MODE (type) == Pmode);\n+\t  gcc_assert (TYPE_MODE (arg.type) == Pmode);\n \t  /* It is at -WORD(AP) in the current frame in interrupt and\n \t     exception handlers.  */\n-\t  arg = plus_constant (Pmode, arg_pointer_rtx, -UNITS_PER_WORD);\n+\t  reg = plus_constant (Pmode, arg_pointer_rtx, -UNITS_PER_WORD);\n \t}\n       else\n \t{\n \t  gcc_assert (cfun->machine->func_type == TYPE_EXCEPTION\n-\t\t      && TREE_CODE (type) == INTEGER_TYPE\n-\t\t      && TYPE_MODE (type) == word_mode);\n+\t\t      && TREE_CODE (arg.type) == INTEGER_TYPE\n+\t\t      && TYPE_MODE (arg.type) == word_mode);\n \t  /* The error code is the word-mode integer argument at\n \t     -2 * WORD(AP) in the current frame of the exception\n \t     handler.  */\n-\t  arg = gen_rtx_MEM (word_mode,\n+\t  reg = gen_rtx_MEM (word_mode,\n \t\t\t     plus_constant (Pmode,\n \t\t\t\t\t    arg_pointer_rtx,\n \t\t\t\t\t    -2 * UNITS_PER_WORD));\n \t}\n-      return arg;\n+      return reg;\n     }\n \n-  if (mode == BLKmode)\n-    bytes = int_size_in_bytes (type);\n-  else\n-    bytes = GET_MODE_SIZE (mode);\n+  bytes = arg.promoted_size_in_bytes ();\n   words = CEIL (bytes, UNITS_PER_WORD);\n \n   /* To simplify the code below, represent vector types with a vector mode\n      even if MMX/SSE are not active.  */\n-  if (type && TREE_CODE (type) == VECTOR_TYPE)\n-    mode = type_natural_mode (type, cum, false);\n+  if (arg.type && TREE_CODE (arg.type) == VECTOR_TYPE)\n+    mode = type_natural_mode (arg.type, cum, false);\n \n   if (TARGET_64BIT)\n     {\n       enum calling_abi call_abi = cum ? cum->call_abi : ix86_abi;\n \n       if (call_abi == MS_ABI)\n-\targ = function_arg_ms_64 (cum, mode, omode, named, bytes);\n+\treg = function_arg_ms_64 (cum, mode, arg.mode, arg.named, bytes);\n       else\n-\targ = function_arg_64 (cum, mode, omode, type, named);\n+\treg = function_arg_64 (cum, mode, arg.mode, arg.type, arg.named);\n     }\n   else\n-    arg = function_arg_32 (cum, mode, omode, type, bytes, words);\n+    reg = function_arg_32 (cum, mode, arg.mode, arg.type, bytes, words);\n \n   /* Track if there are outgoing arguments on stack.  */\n-  if (arg == NULL_RTX && cum->caller)\n+  if (reg == NULL_RTX && cum->caller)\n     cfun->machine->outgoing_args_on_stack = true;\n \n-  return arg;\n+  return reg;\n }\n \n /* A C expression that indicates when an argument must be passed by"}, {"sha": "0de27a371bb391c872f66429da72952ec765892c", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 36, "deletions": 43, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -204,12 +204,9 @@ static void ia64_setup_incoming_varargs (cumulative_args_t,\n \t\t\t\t\t int *, int);\n static int ia64_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n-static rtx ia64_function_arg_1 (cumulative_args_t, machine_mode,\n-\t\t\t\tconst_tree, bool, bool);\n-static rtx ia64_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t      const_tree, bool);\n+static rtx ia64_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx ia64_function_incoming_arg (cumulative_args_t,\n-\t\t\t\t       machine_mode, const_tree, bool);\n+\t\t\t\t       const function_arg_info &);\n static void ia64_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static pad_direction ia64_function_arg_padding (machine_mode, const_tree);\n@@ -4748,23 +4745,22 @@ ia64_function_arg_offset (const CUMULATIVE_ARGS *cum,\n    registers.  */\n \n static rtx\n-ia64_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n-\t\t     const_tree type, bool named, bool incoming)\n+ia64_function_arg_1 (cumulative_args_t cum_v, const function_arg_info &arg,\n+\t\t     bool incoming)\n {\n   const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   int basereg = (incoming ? GR_ARG_FIRST : AR_ARG_FIRST);\n-  int words = ia64_function_arg_words (type, mode);\n-  int offset = ia64_function_arg_offset (cum, type, words);\n+  int words = ia64_function_arg_words (arg.type, arg.mode);\n+  int offset = ia64_function_arg_offset (cum, arg.type, words);\n   machine_mode hfa_mode = VOIDmode;\n \n   /* For OPEN VMS, emit the instruction setting up the argument register here,\n      when we know this will be together with the other arguments setup related\n      insns.  This is not the conceptually best place to do this, but this is\n      the easiest as we have convenient access to cumulative args info.  */\n \n-  if (TARGET_ABI_OPEN_VMS && mode == VOIDmode && type == void_type_node\n-      && named == 1)\n+  if (TARGET_ABI_OPEN_VMS && arg.end_marker_p ())\n     {\n       unsigned HOST_WIDE_INT regval = cum->words;\n       int i;\n@@ -4783,19 +4779,19 @@ ia64_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n   /* On OpenVMS argument is either in Rn or Fn.  */\n   if (TARGET_ABI_OPEN_VMS)\n     {\n-      if (FLOAT_MODE_P (mode))\n-\treturn gen_rtx_REG (mode, FR_ARG_FIRST + cum->words);\n+      if (FLOAT_MODE_P (arg.mode))\n+\treturn gen_rtx_REG (arg.mode, FR_ARG_FIRST + cum->words);\n       else\n-\treturn gen_rtx_REG (mode, basereg + cum->words);\n+\treturn gen_rtx_REG (arg.mode, basereg + cum->words);\n     }\n \n   /* Check for and handle homogeneous FP aggregates.  */\n-  if (type)\n-    hfa_mode = hfa_element_mode (type, 0);\n+  if (arg.type)\n+    hfa_mode = hfa_element_mode (arg.type, 0);\n \n   /* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas\n      and unprototyped hfas are passed specially.  */\n-  if (hfa_mode != VOIDmode && (! cum->prototype || named))\n+  if (hfa_mode != VOIDmode && (! cum->prototype || arg.named))\n     {\n       rtx loc[16];\n       int i = 0;\n@@ -4815,8 +4811,7 @@ ia64_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n       /* Fill the FP regs.  We do this always.  We stop if we reach the end\n \t of the argument, the last FP register, or the last argument slot.  */\n \n-      byte_size = ((mode == BLKmode)\n-\t\t   ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+      byte_size = arg.promoted_size_in_bytes ();\n       args_byte_size = int_regs * UNITS_PER_WORD;\n       offset = 0;\n       for (; (offset < byte_size && fp_regs < MAX_ARGUMENT_SLOTS\n@@ -4872,62 +4867,62 @@ ia64_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n \t  else if (gr_size > UNITS_PER_WORD)\n \t    int_regs += gr_size / UNITS_PER_WORD;\n \t}\n-      return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n+      return gen_rtx_PARALLEL (arg.mode, gen_rtvec_v (i, loc));\n     }\n   \n   /* Integral and aggregates go in general registers.  If we have run out of\n      FR registers, then FP values must also go in general registers.  This can\n      happen when we have a SFmode HFA.  */\n-  else if (mode == TFmode || mode == TCmode\n-\t   || (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS))\n+  else if (arg.mode == TFmode || arg.mode == TCmode\n+\t   || !FLOAT_MODE_P (arg.mode)\n+\t   || cum->fp_regs == MAX_ARGUMENT_SLOTS)\n     {\n-      int byte_size = ((mode == BLKmode)\n-                       ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+      int byte_size = arg.promoted_size_in_bytes ();\n       if (BYTES_BIG_ENDIAN\n-\t&& (mode == BLKmode || (type && AGGREGATE_TYPE_P (type)))\n-\t&& byte_size < UNITS_PER_WORD\n-\t&& byte_size > 0)\n+\t  && (arg.mode == BLKmode || arg.aggregate_type_p ())\n+\t  && byte_size < UNITS_PER_WORD\n+\t  && byte_size > 0)\n \t{\n \t  rtx gr_reg = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t  gen_rtx_REG (DImode,\n \t\t\t\t\t\t       (basereg + cum->words\n \t\t\t\t\t\t\t+ offset)),\n \t\t\t\t\t  const0_rtx);\n-\t  return gen_rtx_PARALLEL (mode, gen_rtvec (1, gr_reg));\n+\t  return gen_rtx_PARALLEL (arg.mode, gen_rtvec (1, gr_reg));\n \t}\n       else\n-\treturn gen_rtx_REG (mode, basereg + cum->words + offset);\n+\treturn gen_rtx_REG (arg.mode, basereg + cum->words + offset);\n \n     }\n \n   /* If there is a prototype, then FP values go in a FR register when\n      named, and in a GR register when unnamed.  */\n   else if (cum->prototype)\n     {\n-      if (named)\n-\treturn gen_rtx_REG (mode, FR_ARG_FIRST + cum->fp_regs);\n+      if (arg.named)\n+\treturn gen_rtx_REG (arg.mode, FR_ARG_FIRST + cum->fp_regs);\n       /* In big-endian mode, an anonymous SFmode value must be represented\n          as (parallel:SF [(expr_list (reg:DI n) (const_int 0))]) to force\n \t the value into the high half of the general register.  */\n-      else if (BYTES_BIG_ENDIAN && mode == SFmode)\n-\treturn gen_rtx_PARALLEL (mode,\n+      else if (BYTES_BIG_ENDIAN && arg.mode == SFmode)\n+\treturn gen_rtx_PARALLEL (arg.mode,\n \t\t gen_rtvec (1,\n                    gen_rtx_EXPR_LIST (VOIDmode,\n \t\t     gen_rtx_REG (DImode, basereg + cum->words + offset),\n \t\t\t\t      const0_rtx)));\n       else\n-\treturn gen_rtx_REG (mode, basereg + cum->words + offset);\n+\treturn gen_rtx_REG (arg.mode, basereg + cum->words + offset);\n     }\n   /* If there is no prototype, then FP values go in both FR and GR\n      registers.  */\n   else\n     {\n       /* See comment above.  */\n       machine_mode inner_mode =\n-\t(BYTES_BIG_ENDIAN && mode == SFmode) ? DImode : mode;\n+\t(BYTES_BIG_ENDIAN && arg.mode == SFmode) ? DImode : arg.mode;\n \n       rtx fp_reg = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t      gen_rtx_REG (mode, (FR_ARG_FIRST\n+\t\t\t\t      gen_rtx_REG (arg.mode, (FR_ARG_FIRST\n \t\t\t\t\t\t\t  + cum->fp_regs)),\n \t\t\t\t      const0_rtx);\n       rtx gr_reg = gen_rtx_EXPR_LIST (VOIDmode,\n@@ -4936,27 +4931,25 @@ ia64_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t\t\t\t    + offset)),\n \t\t\t\t      const0_rtx);\n \n-      return gen_rtx_PARALLEL (mode, gen_rtvec (2, fp_reg, gr_reg));\n+      return gen_rtx_PARALLEL (arg.mode, gen_rtvec (2, fp_reg, gr_reg));\n     }\n }\n \n /* Implement TARGET_FUNCION_ARG target hook.  */\n \n static rtx\n-ia64_function_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t   const_tree type, bool named)\n+ia64_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n {\n-  return ia64_function_arg_1 (cum, mode, type, named, false);\n+  return ia64_function_arg_1 (cum, arg, false);\n }\n \n /* Implement TARGET_FUNCION_INCOMING_ARG target hook.  */\n \n static rtx\n ia64_function_incoming_arg (cumulative_args_t cum,\n-\t\t\t    machine_mode mode,\n-\t\t\t    const_tree type, bool named)\n+\t\t\t    const function_arg_info &arg)\n {\n-  return ia64_function_arg_1 (cum, mode, type, named, true);\n+  return ia64_function_arg_1 (cum, arg, true);\n }\n \n /* Return number of bytes, at the beginning of the argument, that must be"}, {"sha": "e1ea745abf23c7aa5d724ce4a27ca776fda8d381", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -164,7 +164,7 @@ static bool iq2000_pass_by_reference  (cumulative_args_t,\n static int  iq2000_arg_partial_bytes  (cumulative_args_t,\n \t\t\t\t       const function_arg_info &arg);\n static rtx iq2000_function_arg\t      (cumulative_args_t,\n-\t\t\t\t       machine_mode, const_tree, bool);\n+\t\t\t\t       const function_arg_info &);\n static void iq2000_function_arg_advance (cumulative_args_t,\n \t\t\t\t\t machine_mode, const_tree, bool);\n static pad_direction iq2000_function_arg_padding (machine_mode, const_tree);\n@@ -1224,14 +1224,15 @@ iq2000_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n     }\n }\n \n-/* Return an RTL expression containing the register for the given mode MODE\n-   and type TYPE in CUM, or 0 if the argument is to be passed on the stack.  */\n+/* Return an RTL expression containing the register for argument ARG in CUM,\n+   or 0 if the argument is to be passed on the stack.  */\n \n static rtx\n-iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t     const_tree type, bool named)\n+iq2000_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n   rtx ret;\n   int regbase = -1;\n   int bias = 0;\n@@ -1248,7 +1249,7 @@ iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t       cum->gp_reg_found, cum->arg_number, cum->arg_words,\n \t       GET_MODE_NAME (mode));\n       fprintf (stderr, \"%p\", (const void *) type);\n-      fprintf (stderr, \", %d ) = \", named);\n+      fprintf (stderr, \", %d ) = \", arg.named);\n     }\n \n \n@@ -1306,7 +1307,7 @@ iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n       gcc_assert (regbase != -1);\n \n       if (! type || TREE_CODE (type) != RECORD_TYPE\n-\t  || ! named  || ! TYPE_SIZE_UNIT (type)\n+\t  || ! arg.named || ! TYPE_SIZE_UNIT (type)\n \t  || ! tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n \tret = gen_rtx_REG (mode, regbase + *arg_words + bias);\n       else\n@@ -1378,11 +1379,11 @@ iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t struct_p ? \", [struct]\" : \"\");\n     }\n \n-  /* We will be called with a mode of VOIDmode after the last argument\n+  /* We will be called with an end marker after the last argument\n      has been seen.  Whatever we return will be passed to the call\n      insn.  If we need any shifts for small structures, return them in\n      a PARALLEL.  */\n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     {\n       if (cum->num_adjusts > 0)\n \tret = gen_rtx_PARALLEL ((machine_mode) cum->fp_code,\n@@ -1967,8 +1968,8 @@ iq2000_expand_prologue (void)\n \t  passed_mode = Pmode;\n \t}\n \n-      entry_parm = iq2000_function_arg (args_so_far, passed_mode,\n-\t\t\t\t\tpassed_type, true);\n+      function_arg_info arg (passed_type, passed_mode, /*named=*/true);\n+      entry_parm = iq2000_function_arg (args_so_far, arg);\n \n       iq2000_function_arg_advance (args_so_far, passed_mode,\n \t\t\t\t   passed_type, true);\n@@ -2013,8 +2014,8 @@ iq2000_expand_prologue (void)\n      iq2000_unction_arg has encoded a PARALLEL rtx, holding a vector of\n      adjustments to be made as the next_arg_reg variable, so we split up\n      the insns, and emit them separately.  */\n-  next_arg_reg = iq2000_function_arg (args_so_far, VOIDmode,\n-\t\t\t\t      void_type_node, true);\n+  next_arg_reg = iq2000_function_arg (args_so_far,\n+\t\t\t\t      function_arg_info::end_marker ());\n   if (next_arg_reg != 0 && GET_CODE (next_arg_reg) == PARALLEL)\n     {\n       rtvec adjust = XVEC (next_arg_reg, 0);\n@@ -2309,8 +2310,7 @@ iq2000_pass_by_reference (cumulative_args_t cum_v,\n        CUMULATIVE_ARGS temp;\n \n        temp = *cum;\n-       if (iq2000_function_arg (pack_cumulative_args (&temp), arg.mode,\n-\t\t\t\targ.type, arg.named) != 0)\n+       if (iq2000_function_arg (pack_cumulative_args (&temp), arg) != 0)\n \t return 1;\n      }\n "}, {"sha": "cd5663b93c311c46edb7173c6c19286637bb24a1", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -73,9 +73,7 @@ static bool\n lm32_legitimate_address_p (machine_mode mode, rtx x, bool strict);\n static HOST_WIDE_INT lm32_compute_frame_size (int size);\n static void lm32_option_override (void);\n-static rtx lm32_function_arg (cumulative_args_t cum,\n-\t\t\t      machine_mode mode, const_tree type,\n-\t\t\t      bool named);\n+static rtx lm32_function_arg (cumulative_args_t, const function_arg_info &);\n static void lm32_function_arg_advance (cumulative_args_t cum,\n \t\t\t\t       machine_mode mode,\n \t\t\t\t       const_tree type, bool named);\n@@ -619,32 +617,27 @@ lm32_print_operand_address (FILE * file, rtx addr)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+   ARG is a description of the argument.  */\n \n static rtx\n-lm32_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type, bool named)\n+lm32_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     /* Compute operand 2 of the call insn.  */\n     return GEN_INT (0);\n \n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n     return NULL_RTX;\n \n-  if (!named || (*cum + LM32_NUM_REGS2 (mode, type) > LM32_NUM_ARG_REGS))\n+  if (!arg.named\n+      || *cum + LM32_NUM_REGS2 (arg.mode, arg.type) > LM32_NUM_ARG_REGS)\n     return NULL_RTX;\n \n-  return gen_rtx_REG (mode, *cum + LM32_FIRST_ARG_REG);\n+  return gen_rtx_REG (arg.mode, *cum + LM32_FIRST_ARG_REG);\n }\n \n static void"}, {"sha": "508eb50f2b5fd9581814d31a81b9422b7493596d", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -76,8 +76,7 @@ static struct machine_function *m32c_init_machine_status (void);\n static void m32c_insert_attributes (tree, tree *);\n static bool m32c_legitimate_address_p (machine_mode, rtx, bool);\n static bool m32c_addr_space_legitimate_address_p (machine_mode, rtx, bool, addr_space_t);\n-static rtx m32c_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t      const_tree, bool);\n+static rtx m32c_function_arg (cumulative_args_t, const function_arg_info &);\n static bool m32c_pass_by_reference (cumulative_args_t,\n \t\t\t\t    const function_arg_info &);\n static void m32c_function_arg_advance (cumulative_args_t, machine_mode,\n@@ -1320,47 +1319,46 @@ m32c_push_rounding (poly_int64 n)\n #undef TARGET_FUNCTION_ARG\n #define TARGET_FUNCTION_ARG m32c_function_arg\n static rtx\n-m32c_function_arg (cumulative_args_t ca_v,\n-\t\t   machine_mode mode, const_tree type, bool named)\n+m32c_function_arg (cumulative_args_t ca_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n \n   /* Can return a reg, parallel, or 0 for stack */\n   rtx rv = NULL_RTX;\n #if DEBUG0\n   fprintf (stderr, \"func_arg %d (%s, %d)\\n\",\n-\t   ca->parm_num, mode_name[mode], named);\n-  debug_tree ((tree)type);\n+\t   ca->parm_num, mode_name[arg.mode], arg.named);\n+  debug_tree (arg.type);\n #endif\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     return GEN_INT (0);\n \n-  if (ca->force_mem || !named)\n+  if (ca->force_mem || !arg.named)\n     {\n #if DEBUG0\n       fprintf (stderr, \"func arg: force %d named %d, mem\\n\", ca->force_mem,\n-\t       named);\n+\t       arg.named);\n #endif\n       return NULL_RTX;\n     }\n \n-  if (type && INTEGRAL_TYPE_P (type) && POINTER_TYPE_P (type))\n+  if (arg.type && INTEGRAL_TYPE_P (arg.type) && POINTER_TYPE_P (arg.type))\n     return NULL_RTX;\n \n-  if (type && AGGREGATE_TYPE_P (type))\n+  if (arg.aggregate_type_p ())\n     return NULL_RTX;\n \n   switch (ca->parm_num)\n     {\n     case 1:\n-      if (GET_MODE_SIZE (mode) == 1 || GET_MODE_SIZE (mode) == 2)\n-\trv = gen_rtx_REG (mode, TARGET_A16 ? R1_REGNO : R0_REGNO);\n+      if (GET_MODE_SIZE (arg.mode) == 1 || GET_MODE_SIZE (arg.mode) == 2)\n+\trv = gen_rtx_REG (arg.mode, TARGET_A16 ? R1_REGNO : R0_REGNO);\n       break;\n \n     case 2:\n-      if (TARGET_A16 && GET_MODE_SIZE (mode) == 2)\n-\trv = gen_rtx_REG (mode, R2_REGNO);\n+      if (TARGET_A16 && GET_MODE_SIZE (arg.mode) == 2)\n+\trv = gen_rtx_REG (arg.mode, R2_REGNO);\n       break;\n     }\n "}, {"sha": "88785fcccc239997641da6999797a365d7b49735", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -96,8 +96,7 @@ static bool m32r_pass_by_reference (cumulative_args_t,\n \t\t\t\t    const function_arg_info &arg);\n static int m32r_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n-static rtx m32r_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t      const_tree, bool);\n+static rtx m32r_function_arg (cumulative_args_t, const function_arg_info &);\n static void m32r_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static bool m32r_can_eliminate (const int, const int);\n@@ -1201,26 +1200,20 @@ m32r_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+   ARG is a description of the argument.  */\n /* On the M32R the first M32R_MAX_PARM_REGS args are normally in registers\n    and the rest are pushed.  */\n \n static rtx\n-m32r_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type ATTRIBUTE_UNUSED,\n-\t\t   bool named ATTRIBUTE_UNUSED)\n+m32r_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  return (PASS_IN_REG_P (*cum, mode, type)\n-\t  ? gen_rtx_REG (mode, ROUND_ADVANCE_CUM (*cum, mode, type))\n+  return (PASS_IN_REG_P (*cum, arg.mode, arg.type)\n+\t  ? gen_rtx_REG (arg.mode,\n+\t\t\t ROUND_ADVANCE_CUM (*cum, arg.mode, arg.type))\n \t  : NULL_RTX);\n }\n "}, {"sha": "cbc6c1cfbada94679db8657053be5d80d40c3a60", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -183,8 +183,7 @@ static poly_int64 m68k_return_pops_args (tree, tree, poly_int64);\n static rtx m68k_delegitimize_address (rtx);\n static void m68k_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx m68k_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t      const_tree, bool);\n+static rtx m68k_function_arg (cumulative_args_t, const function_arg_info &);\n static bool m68k_cannot_force_const_mem (machine_mode mode, rtx x);\n static bool m68k_output_addr_const_extra (FILE *, rtx);\n static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n@@ -1464,10 +1463,7 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)\n /* On the m68k all args are always pushed.  */\n \n static rtx\n-m68k_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t   const_tree type ATTRIBUTE_UNUSED,\n-\t\t   bool named ATTRIBUTE_UNUSED)\n+m68k_function_arg (cumulative_args_t, const function_arg_info &)\n {\n   return NULL_RTX;\n }"}, {"sha": "f28219f612be45156b9b533e9bd61b5ee71b8d15", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -133,8 +133,7 @@ static bool       mcore_return_in_memory\t(const_tree, const_tree);\n static int        mcore_arg_partial_bytes       (cumulative_args_t,\n \t\t\t\t\t\t const function_arg_info &);\n static rtx        mcore_function_arg            (cumulative_args_t,\n-\t\t\t\t\t\t machine_mode,\n-\t\t\t\t\t\t const_tree, bool);\n+\t\t\t\t\t\t const function_arg_info &);\n static void       mcore_function_arg_advance    (cumulative_args_t,\n \t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t const_tree, bool);\n@@ -2788,36 +2787,31 @@ mcore_function_value (const_tree valtype, const_tree func)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n+   ARG is a description of the argument.\n \n    On MCore the first args are normally in registers\n    and the rest are pushed.  Any arg that starts within the first\n    NPARM_REGS words is at least partially passed in a register unless\n    its data type forbids.  */\n \n static rtx\n-mcore_function_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t    const_tree type, bool named)\n+mcore_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n {\n   int arg_reg;\n   \n-  if (! named || mode == VOIDmode)\n+  if (!arg.named || arg.end_marker_p ())\n     return 0;\n \n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n     return 0;\n \n-  arg_reg = ROUND_REG (*get_cumulative_args (cum), mode);\n+  arg_reg = ROUND_REG (*get_cumulative_args (cum), arg.mode);\n   \n   if (arg_reg < NPARM_REGS)\n-    return handle_structs_in_regs (mode, type, FIRST_PARM_REG + arg_reg);\n+    return handle_structs_in_regs (arg.mode, arg.type,\n+\t\t\t\t   FIRST_PARM_REG + arg_reg);\n \n   return 0;\n }"}, {"sha": "9fd49b5f2d5945f993e6f7fc380d35c421b41448", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1596,13 +1596,11 @@ microblaze_function_arg_advance (cumulative_args_t cum_v,\n     }\n }\n \n-/* Return an RTL expression containing the register for the given mode,\n+/* Return an RTL expression containing the register for the given argument\n    or 0 if the argument is to be passed on the stack.  */\n \n static rtx\n-microblaze_function_arg (cumulative_args_t cum_v, machine_mode mode, \n-\t\t\t const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t bool named ATTRIBUTE_UNUSED)\n+microblaze_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n@@ -1611,7 +1609,7 @@ microblaze_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   int *arg_words = &cum->arg_words;\n \n   cum->last_arg_fp = 0;\n-  switch (mode)\n+  switch (arg.mode)\n     {\n     case E_SFmode:\n     case E_DFmode:\n@@ -1624,8 +1622,8 @@ microblaze_function_arg (cumulative_args_t cum_v, machine_mode mode,\n       regbase = GP_ARG_FIRST;\n       break;\n     default:\n-      gcc_assert (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n-\t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n+      gcc_assert (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_INT\n+\t\t  || GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT);\n       /* FALLTHRU */\n     case E_BLKmode:\n       regbase = GP_ARG_FIRST;\n@@ -1638,10 +1636,10 @@ microblaze_function_arg (cumulative_args_t cum_v, machine_mode mode,\n     {\n       gcc_assert (regbase != -1);\n \n-      ret = gen_rtx_REG (mode, regbase + *arg_words);\n+      ret = gen_rtx_REG (arg.mode, regbase + *arg_words);\n     }\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     {\n       if (cum->num_adjusts > 0)\n \tret = gen_rtx_PARALLEL ((machine_mode) cum->fp_code,\n@@ -2916,8 +2914,8 @@ microblaze_expand_prologue (void)\n \t  passed_mode = Pmode;\n \t}\n \n-      entry_parm = targetm.calls.function_arg (args_so_far, passed_mode,\n-\t\t\t\t\t       passed_type, true);\n+      function_arg_info arg (passed_type, passed_mode, /*named=*/true);\n+      entry_parm = targetm.calls.function_arg (args_so_far, arg);\n \n       if (entry_parm)\n \t{\n@@ -2952,8 +2950,8 @@ microblaze_expand_prologue (void)\n \n   /* Split parallel insn into a sequence of insns.  */\n \n-  next_arg_reg = targetm.calls.function_arg (args_so_far, VOIDmode,\n-\t\t\t\t\t     void_type_node, true);\n+  next_arg_reg = targetm.calls.function_arg (args_so_far,\n+\t\t\t\t\t     function_arg_info::end_marker ());\n   if (next_arg_reg != 0 && GET_CODE (next_arg_reg) == PARALLEL)\n     {\n       rtvec adjust = XVEC (next_arg_reg, 0);"}, {"sha": "420a7ced7e95f6a2486b90b53d8388984c88608c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -5976,25 +5976,24 @@ mips_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-mips_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type, bool named)\n+mips_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   struct mips_arg_info info;\n \n-  /* We will be called with a mode of VOIDmode after the last argument\n+  /* We will be called with an end marker after the last argument\n      has been seen.  Whatever we return will be passed to the call expander.\n      If we need a MIPS16 fp_code, return a REG with the code stored as\n      the mode.  */\n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     {\n       if (TARGET_MIPS16 && cum->fp_code != 0)\n \treturn gen_rtx_REG ((machine_mode) cum->fp_code, 0);\n       else\n \treturn NULL;\n     }\n \n-  mips_get_arg_info (&info, cum, mode, type, named);\n+  mips_get_arg_info (&info, cum, arg.mode, arg.type, arg.named);\n \n   /* Return straight away if the whole argument is passed on the stack.  */\n   if (info.reg_offset == MAX_ARGS_IN_REGISTERS)\n@@ -6005,16 +6004,16 @@ mips_function_arg (cumulative_args_t cum_v, machine_mode mode,\n      in a floating-point register.  */\n   if (TARGET_NEWABI\n       && TARGET_HARD_FLOAT\n-      && named\n-      && type != 0\n-      && TREE_CODE (type) == RECORD_TYPE\n-      && TYPE_SIZE_UNIT (type)\n-      && tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n+      && arg.named\n+      && arg.type != 0\n+      && TREE_CODE (arg.type) == RECORD_TYPE\n+      && TYPE_SIZE_UNIT (arg.type)\n+      && tree_fits_uhwi_p (TYPE_SIZE_UNIT (arg.type)))\n     {\n       tree field;\n \n       /* First check to see if there is any such field.  */\n-      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+      for (field = TYPE_FIELDS (arg.type); field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL\n \t    && SCALAR_FLOAT_TYPE_P (TREE_TYPE (field))\n \t    && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD\n@@ -6033,10 +6032,10 @@ mips_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \n \t  /* assign_parms checks the mode of ENTRY_PARM, so we must\n \t     use the actual mode here.  */\n-\t  ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n+\t  ret = gen_rtx_PARALLEL (arg.mode, rtvec_alloc (info.reg_words));\n \n \t  bitpos = 0;\n-\t  field = TYPE_FIELDS (type);\n+\t  field = TYPE_FIELDS (arg.type);\n \t  for (i = 0; i < info.reg_words; i++)\n \t    {\n \t      rtx reg;\n@@ -6069,13 +6068,13 @@ mips_function_arg (cumulative_args_t cum_v, machine_mode mode,\n      and the imaginary part goes in the upper register.  */\n   if (TARGET_NEWABI\n       && info.fpr_p\n-      && GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+      && GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT)\n     {\n       rtx real, imag;\n       machine_mode inner;\n       unsigned int regno;\n \n-      inner = GET_MODE_INNER (mode);\n+      inner = GET_MODE_INNER (arg.mode);\n       regno = FP_ARG_FIRST + info.reg_offset;\n       if (info.reg_words * UNITS_PER_WORD == GET_MODE_SIZE (inner))\n \t{\n@@ -6093,11 +6092,11 @@ mips_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t\t    gen_rtx_REG (inner,\n \t\t\t\t\t\t regno + info.reg_words / 2),\n \t\t\t\t    GEN_INT (GET_MODE_SIZE (inner)));\n-\t  return gen_rtx_PARALLEL (mode, gen_rtvec (2, real, imag));\n+\t  return gen_rtx_PARALLEL (arg.mode, gen_rtvec (2, real, imag));\n \t}\n     }\n \n-  return gen_rtx_REG (mode, mips_arg_regno (&info, TARGET_HARD_FLOAT));\n+  return gen_rtx_REG (arg.mode, mips_arg_regno (&info, TARGET_HARD_FLOAT));\n }\n \n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */"}, {"sha": "87d5cd2df5e5ea771f838efe851dc9481e29bf20", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -151,12 +151,9 @@ static machine_mode mmix_promote_function_mode (const_tree,\n \t                                             int *, const_tree, int);\n static void mmix_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx mmix_function_arg_1 (const cumulative_args_t, machine_mode,\n-\t\t\t\tconst_tree, bool, bool);\n-static rtx mmix_function_incoming_arg (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n-static rtx mmix_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t      const_tree, bool);\n+static rtx mmix_function_incoming_arg (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n+static rtx mmix_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx mmix_function_value (const_tree, const_tree, bool);\n static rtx mmix_libcall_value (machine_mode, const_rtx);\n static bool mmix_function_value_regno_p (const unsigned int);\n@@ -636,28 +633,25 @@ mmix_function_arg_advance (cumulative_args_t argsp_v, machine_mode mode,\n \n static rtx\n mmix_function_arg_1 (const cumulative_args_t argsp_v,\n-\t\t     machine_mode mode,\n-\t\t     const_tree type,\n-\t\t     bool named ATTRIBUTE_UNUSED,\n-\t\t     bool incoming)\n+\t\t     const function_arg_info &arg, bool incoming)\n {\n   CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n \n   /* Last-argument marker.  */\n-  if (type == void_type_node)\n+  if (arg.end_marker_p ())\n     return (argsp->regs < MMIX_MAX_ARGS_IN_REGS)\n-      ? gen_rtx_REG (mode,\n+      ? gen_rtx_REG (arg.mode,\n \t\t     (incoming\n \t\t      ? MMIX_FIRST_INCOMING_ARG_REGNUM\n \t\t      : MMIX_FIRST_ARG_REGNUM) + argsp->regs)\n       : NULL_RTX;\n \n   return (argsp->regs < MMIX_MAX_ARGS_IN_REGS\n-\t  && !targetm.calls.must_pass_in_stack (mode, type)\n-\t  && (GET_MODE_BITSIZE (mode) <= 64\n+\t  && !targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+\t  && (GET_MODE_BITSIZE (arg.mode) <= 64\n \t      || argsp->lib\n \t      || TARGET_LIBFUNC))\n-    ? gen_rtx_REG (mode,\n+    ? gen_rtx_REG (arg.mode,\n \t\t   (incoming\n \t\t    ? MMIX_FIRST_INCOMING_ARG_REGNUM\n \t\t    : MMIX_FIRST_ARG_REGNUM)\n@@ -669,21 +663,16 @@ mmix_function_arg_1 (const cumulative_args_t argsp_v,\n    one that must go on stack.  */\n \n static rtx\n-mmix_function_arg (cumulative_args_t argsp,\n-\t\t   machine_mode mode,\n-\t\t   const_tree type,\n-\t\t   bool named)\n+mmix_function_arg (cumulative_args_t argsp, const function_arg_info &arg)\n {\n-  return mmix_function_arg_1 (argsp, mode, type, named, false);\n+  return mmix_function_arg_1 (argsp, arg, false);\n }\n \n static rtx\n mmix_function_incoming_arg (cumulative_args_t argsp,\n-\t\t\t    machine_mode mode,\n-\t\t\t    const_tree type,\n-\t\t\t    bool named)\n+\t\t\t    const function_arg_info &arg)\n {\n-  return mmix_function_arg_1 (argsp, mode, type, named, true);\n+  return mmix_function_arg_1 (argsp, arg, true);\n }\n \n /* Returns nonzero for everything that goes by reference, 0 for"}, {"sha": "a4d242c6ca922844558d14c587a6357c52d4052c", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1532,12 +1532,11 @@ mn10300_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n   return (size > 8 || size == 0);\n }\n \n-/* Return an RTX to represent where a value with mode MODE will be returned\n-   from a function.  If the result is NULL_RTX, the argument is pushed.  */\n+/* Return an RTX to represent where argument ARG will be passed to a function.\n+   If the result is NULL_RTX, the argument is pushed.  */\n \n static rtx\n-mn10300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n+mn10300_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   rtx result = NULL_RTX;\n@@ -1547,11 +1546,7 @@ mn10300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   int nregs = 2;\n \n   /* Figure out the size of the object to be passed.  */\n-  if (mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  size = arg.promoted_size_in_bytes ();\n   cum->nbytes = (cum->nbytes + 3) & ~3;\n \n   /* Don't pass this arg via a register if all the argument registers\n@@ -1561,17 +1556,17 @@ mn10300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \n   /* Don't pass this arg via a register if it would be split between\n      registers and memory.  */\n-  if (type == NULL_TREE\n+  if (arg.type == NULL_TREE\n       && cum->nbytes + size > nregs * UNITS_PER_WORD)\n     return result;\n \n   switch (cum->nbytes / UNITS_PER_WORD)\n     {\n     case 0:\n-      result = gen_rtx_REG (mode, FIRST_ARGUMENT_REGNUM);\n+      result = gen_rtx_REG (arg.mode, FIRST_ARGUMENT_REGNUM);\n       break;\n     case 1:\n-      result = gen_rtx_REG (mode, FIRST_ARGUMENT_REGNUM + 1);\n+      result = gen_rtx_REG (arg.mode, FIRST_ARGUMENT_REGNUM + 1);\n       break;\n     default:\n       break;"}, {"sha": "64c1e8e7a25f2289bc77f9904cb473d52a5e5fc8", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -423,14 +423,12 @@ moxie_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n    NULL_RTX if there's no more space.  */\n \n static rtx\n-moxie_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t    const_tree type ATTRIBUTE_UNUSED,\n-\t\t    bool named ATTRIBUTE_UNUSED)\n+moxie_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   if (*cum < 8)\n-    return gen_rtx_REG (mode, *cum);\n+    return gen_rtx_REG (arg.mode, *cum);\n   else \n     return NULL_RTX;\n }"}, {"sha": "1f8cfcd3292b9a288b0b28e87a3d503662c054d8", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -710,16 +710,14 @@ msp430_promote_prototypes (const_tree fntype ATTRIBUTE_UNUSED)\n \n rtx\n msp430_function_arg (cumulative_args_t cap,\n-\t\t     machine_mode mode,\n-\t\t     const_tree type,\n-\t\t     bool named)\n+\t\t     const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (cap);\n \n-  msp430_evaluate_arg (cap, mode, type, named);\n+  msp430_evaluate_arg (cap, arg.mode, arg.type, arg.named);\n \n   if (ca->reg_count)\n-    return gen_rtx_REG (mode, ca->start_reg);\n+    return gen_rtx_REG (arg.mode, ca->start_reg);\n \n   return 0;\n }"}, {"sha": "6f7b4758e5af0b462d304b5c891130d95cdc59b8", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1868,19 +1868,20 @@ nds32_can_eliminate (const int from_reg, const int to_reg)\n /* -- Passing Arguments in Registers.  */\n \n static rtx\n-nds32_function_arg (cumulative_args_t ca, machine_mode mode,\n-\t\t    const_tree type, bool named)\n+nds32_function_arg (cumulative_args_t ca, const function_arg_info &arg)\n {\n   unsigned int regno;\n   CUMULATIVE_ARGS *cum = get_cumulative_args (ca);\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n \n   /* The last time this hook is called,\n-     it is called with MODE == VOIDmode.  */\n-  if (mode == VOIDmode)\n+     it is called with an end marker.  */\n+  if (arg.end_marker_p ())\n     return NULL_RTX;\n \n   /* For nameless arguments, we need to take care it individually.  */\n-  if (!named)\n+  if (!arg.named)\n     {\n       /* If we are under hard float abi, we have arguments passed on the\n \t stack and all situation can be handled by GCC itself.  */"}, {"sha": "853ee14e6ed58c5c35584dba0ca2d3b0e1dd662c", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -3362,25 +3362,18 @@ nios2_fpu_insn_asm (enum n2fpu_code code)\n    push the argument on the stack, or a hard register in which to\n    store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-   This is null for libcalls where that information may\n-   not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-   (otherwise it is an extra parameter matching an ellipsis).  */\n+   ARG is a description of the argument.  */\n \n static rtx\n-nios2_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t    const_tree type ATTRIBUTE_UNUSED,\n-\t\t    bool named ATTRIBUTE_UNUSED)\n+nios2_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v); \n   rtx return_rtx = NULL_RTX;\n \n   if (cum->regs_used < NUM_ARG_REGS)\n-    return_rtx = gen_rtx_REG (mode, FIRST_ARG_REGNO + cum->regs_used);\n+    return_rtx = gen_rtx_REG (arg.mode, FIRST_ARG_REGNO + cum->regs_used);\n \n   return return_rtx;\n }"}, {"sha": "b37f9238024d9fd7a0db7e58c8fde7af6ca51c0b", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -520,30 +520,29 @@ promote_return (machine_mode mode)\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-nvptx_function_arg (cumulative_args_t ARG_UNUSED (cum_v), machine_mode mode,\n-\t\t    const_tree, bool named)\n+nvptx_function_arg (cumulative_args_t, const function_arg_info &arg)\n {\n-  if (mode == VOIDmode || !named)\n+  if (arg.end_marker_p () || !arg.named)\n     return NULL_RTX;\n \n-  return gen_reg_rtx (mode);\n+  return gen_reg_rtx (arg.mode);\n }\n \n /* Implement TARGET_FUNCTION_INCOMING_ARG.  */\n \n static rtx\n-nvptx_function_incoming_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t     const_tree, bool named)\n+nvptx_function_incoming_arg (cumulative_args_t cum_v,\n+\t\t\t     const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (mode == VOIDmode || !named)\n+  if (arg.end_marker_p () || !arg.named)\n     return NULL_RTX;\n \n   /* No need to deal with split modes here, the only case that can\n      happen is complex modes and those are dealt with by\n      TARGET_SPLIT_COMPLEX_ARG.  */\n-  return gen_rtx_UNSPEC (mode,\n+  return gen_rtx_UNSPEC (arg.mode,\n \t\t\t gen_rtvec (1, GEN_INT (cum->count)),\n \t\t\t UNSPEC_ARG_REG);\n }"}, {"sha": "363c3f647d9b8e3bd7430c5b2e52238fd987df53", "filename": "gcc/config/or1k/or1k.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2For1k%2For1k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2For1k%2For1k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -997,20 +997,19 @@ or1k_strict_argument_naming (cumulative_args_t /* ca */)\n    maybe be passed in registers r3 to r8.  */\n \n static rtx\n-or1k_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree /* type */, bool named)\n+or1k_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n-  /* VOIDmode is passed as a special flag for \"last argument\".  */\n-  if (mode == VOIDmode)\n+  /* Handle the special marker for the end of the arguments.  */\n+  if (arg.end_marker_p ())\n     return NULL_RTX;\n \n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int nreg = CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+  int nreg = CEIL (GET_MODE_SIZE (arg.mode), UNITS_PER_WORD);\n \n   /* Note that all large arguments are passed by reference.  */\n   gcc_assert (nreg <= 2);\n-  if (named && *cum + nreg <= 6)\n-    return gen_rtx_REG (mode, *cum + 3);\n+  if (arg.named && *cum + nreg <= 6)\n+    return gen_rtx_REG (arg.mode, *cum + 3);\n   else\n     return NULL_RTX;\n }"}, {"sha": "3ed030bfb769ea623f2a792ba87068a5dfacbc68", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -169,8 +169,7 @@ static bool pa_pass_by_reference (cumulative_args_t,\n static int pa_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n static void pa_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t     const_tree, bool);\n-static rtx pa_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t    const_tree, bool);\n+static rtx pa_function_arg (cumulative_args_t, const function_arg_info &);\n static pad_direction pa_function_arg_padding (machine_mode, const_tree);\n static unsigned int pa_function_arg_boundary (machine_mode, const_tree);\n static struct machine_function * pa_init_machine_status (void);\n@@ -9465,18 +9464,19 @@ pa_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n    ??? We might want to restructure this so that it looks more like other\n    ports.  */\n static rtx\n-pa_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n+pa_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n   int max_arg_words = (TARGET_64BIT ? 8 : 4);\n   int alignment = 0;\n   int arg_size;\n   int fpr_reg_base;\n   int gpr_reg_base;\n   rtx retval;\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     return NULL_RTX;\n \n   arg_size = pa_function_arg_size (mode, type);"}, {"sha": "21d78cd3ca6332b66145eeecf8f79991bbc4ece2", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -162,8 +162,7 @@ static rtx pdp11_function_value (const_tree, const_tree, bool);\n static rtx pdp11_libcall_value (machine_mode, const_rtx);\n static bool pdp11_function_value_regno_p (const unsigned int);\n static void pdp11_trampoline_init (rtx, tree, rtx);\n-static rtx pdp11_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t       const_tree, bool);\n+static rtx pdp11_function_arg (cumulative_args_t, const function_arg_info &);\n static void pdp11_function_arg_advance (cumulative_args_t,\n \t\t\t\t\tmachine_mode, const_tree, bool);\n static void pdp11_conditional_register_usage (void);\n@@ -2180,26 +2179,10 @@ pdp11_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   emit_move_insn (mem, fnaddr);\n }\n \n-/* Worker function for TARGET_FUNCTION_ARG.\n-\n-   Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+/* Worker function for TARGET_FUNCTION_ARG.  */\n \n static rtx\n-pdp11_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t    const_tree type ATTRIBUTE_UNUSED,\n-\t\t    bool named ATTRIBUTE_UNUSED)\n+pdp11_function_arg (cumulative_args_t, const function_arg_info &)\n {\n   return NULL_RTX;\n }"}, {"sha": "2b33929766f07aa4d680a436ac0469130f983bae", "filename": "gcc/config/pru/pru.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fpru%2Fpru.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fpru%2Fpru.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -2152,25 +2152,18 @@ pru_function_arg_regi_mark_slot (int regi,\n    push the argument on the stack, or a hard register in which to\n    store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-   This is null for libcalls where that information may\n-   not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-   (otherwise it is an extra parameter matching an ellipsis).  */\n+   ARG is a description of the argument.  */\n \n static rtx\n-pru_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t  const_tree type,\n-\t\t  bool named)\n+pru_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   rtx return_rtx = NULL_RTX;\n-  int regi = pru_function_arg_regi (cum_v, mode, type, named);\n+  int regi = pru_function_arg_regi (cum_v, arg.mode, arg.type, arg.named);\n \n   if (regi >= 0)\n-    return_rtx = gen_rtx_REG (mode, regi);\n+    return_rtx = gen_rtx_REG (arg.mode, regi);\n \n   return return_rtx;\n }"}, {"sha": "c9aaaff1de1e8043623a8fdc7378544d52d580c3", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -2743,16 +2743,15 @@ riscv_get_arg_info (struct riscv_arg_info *info, const CUMULATIVE_ARGS *cum,\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-riscv_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t    const_tree type, bool named)\n+riscv_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   struct riscv_arg_info info;\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     return NULL;\n \n-  return riscv_get_arg_info (&info, cum, mode, type, named, false);\n+  return riscv_get_arg_info (&info, cum, arg.mode, arg.type, arg.named, false);\n }\n \n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */"}, {"sha": "e5d0001999d77edb1f22ec2fa291da1ea192aaf6", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1737,21 +1737,11 @@ rl78_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n   return mode;\n }\n \n-/* Return an RTL expression describing the register holding a function\n-   parameter of mode MODE and type TYPE or NULL_RTX if the parameter should\n-   be passed on the stack.  CUM describes the previous parameters to the\n-   function and NAMED is false if the parameter is part of a variable\n-   parameter list, or the last named parameter before the start of a\n-   variable parameter list.  */\n-\n #undef  TARGET_FUNCTION_ARG\n #define TARGET_FUNCTION_ARG     \trl78_function_arg\n \n static rtx\n-rl78_function_arg (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n-\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t   const_tree type ATTRIBUTE_UNUSED,\n-\t\t   bool named ATTRIBUTE_UNUSED)\n+rl78_function_arg (cumulative_args_t, const function_arg_info &)\n {\n   return NULL_RTX;\n }"}, {"sha": "2024092978b05379fc85e6556a6b59f471b44f55", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1729,15 +1729,10 @@ rs6000_finish_function_arg (machine_mode mode, rtx *rvec, int k)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.  It is\n     not modified in this routine.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n+   ARG is a description of the argument.\n \n    On RS/6000 the first eight words of non-FP are normally in registers\n    and the rest are pushed.  Under AIX, the first 13 FP args are in registers.\n@@ -1750,14 +1745,15 @@ rs6000_finish_function_arg (machine_mode mode, rtx *rvec, int k)\n    doesn't support PARALLEL anyway.\n \n    Note that for args passed by reference, function_arg will be called\n-   with MODE and TYPE set to that of the pointer to the arg, not the arg\n-   itself.  */\n+   with ARG describing the pointer to the arg, not the arg itself.  */\n \n rtx\n-rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t     const_tree type, bool named)\n+rs6000_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n+  bool named = arg.named;\n   enum rs6000_abi abi = DEFAULT_ABI;\n   machine_mode elt_mode;\n   int n_elts;\n@@ -1766,7 +1762,7 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n      bit that V.4 uses to say fp args were passed in registers.\n      Assume that we don't need the marker for software floating point,\n      or compiler generated library calls.  */\n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     {\n       if (abi == ABI_V4\n \t  && (cum->call_cookie & CALL_LIBCALL) == 0\n@@ -2210,7 +2206,8 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n     return true;\n \n   /* If there is no incoming register, we need a stack.  */\n-  entry_parm = rs6000_function_arg (args_so_far, mode, type, true);\n+  function_arg_info arg (type, mode, /*named=*/true);\n+  entry_parm = rs6000_function_arg (args_so_far, arg);\n   if (entry_parm == NULL)\n     return true;\n \n@@ -2220,7 +2217,6 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n     return true;\n \n   /* Also true if we're partially in registers and partially not.  */\n-  function_arg_info arg (type, mode, /*named=*/true);\n   if (rs6000_arg_partial_bytes (args_so_far, arg) != 0)\n     return true;\n "}, {"sha": "f43714fa8b018f27f44ee70b62f85f86b391a464", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -164,8 +164,7 @@ extern void rs6000_function_arg_advance (cumulative_args_t cum,\n \t\t\t\t\t const_tree type, bool named);\n extern pad_direction rs6000_function_arg_padding (machine_mode mode,\n \t\t\t\t\t\t  const_tree type);\n-extern rtx rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t\tconst_tree type, bool named);\n+extern rtx rs6000_function_arg (cumulative_args_t, const function_arg_info &);\n extern rtx rs6000_darwin64_record_arg (CUMULATIVE_ARGS *, const_tree,\n \t\t\t\t       bool, bool);\n extern rtx rs6000_internal_arg_pointer (void);"}, {"sha": "da73665cda627ff4516781391397418735917f64", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1064,24 +1064,19 @@ rx_function_arg_size (machine_mode mode, const_tree type)\n #define NUM_ARG_REGS\t\t4\n #define MAX_NUM_ARG_BYTES\t(NUM_ARG_REGS * UNITS_PER_WORD)\n \n-/* Return an RTL expression describing the register holding a function\n-   parameter of mode MODE and type TYPE or NULL_RTX if the parameter should\n-   be passed on the stack.  CUM describes the previous parameters to the\n-   function and NAMED is false if the parameter is part of a variable\n-   parameter list, or the last named parameter before the start of a\n-   variable parameter list.  */\n+/* Return an RTL expression describing the register holding function\n+   argument ARG or NULL_RTX if the parameter should be passed on the\n+   stack.  CUM describes the previous parameters to the function.  */\n \n static rtx\n-rx_function_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t const_tree type, bool named)\n+rx_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n {\n   unsigned int next_reg;\n   unsigned int bytes_so_far = *get_cumulative_args (cum);\n   unsigned int size;\n   unsigned int rounded_size;\n \n-  /* An exploded version of rx_function_arg_size.  */\n-  size = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  size = arg.promoted_size_in_bytes ();\n   /* If the size is not known it cannot be passed in registers.  */\n   if (size < 1)\n     return NULL_RTX;\n@@ -1095,18 +1090,18 @@ rx_function_arg (cumulative_args_t cum, machine_mode mode,\n \n   /* Unnamed arguments and the last named argument in a\n      variadic function are always passed on the stack.  */\n-  if (!named)\n+  if (!arg.named)\n     return NULL_RTX;\n \n   /* Structures must occupy an exact number of registers,\n      otherwise they are passed on the stack.  */\n-  if ((type == NULL || AGGREGATE_TYPE_P (type))\n+  if ((arg.type == NULL || AGGREGATE_TYPE_P (arg.type))\n       && (size % UNITS_PER_WORD) != 0)\n     return NULL_RTX;\n \n   next_reg = (bytes_so_far / UNITS_PER_WORD) + 1;\n \n-  return gen_rtx_REG (mode, next_reg);\n+  return gen_rtx_REG (arg.mode, next_reg);\n }\n \n static void"}, {"sha": "e9ea76c0c07eb239f62c65ad91dc9520511065c5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -12021,14 +12021,9 @@ s390_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n+   ARG is a description of the argument.\n \n    On S/390, we use general purpose registers 2 through 6 to\n    pass integer, pointer, and certain structure arguments, and\n@@ -12037,39 +12032,38 @@ s390_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n    are pushed to the stack.  */\n \n static rtx\n-s390_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type, bool named)\n+s390_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (!named)\n-    s390_check_type_for_vector_abi (type, true, false);\n+  if (!arg.named)\n+    s390_check_type_for_vector_abi (arg.type, true, false);\n \n-  if (s390_function_arg_vector (mode, type))\n+  if (s390_function_arg_vector (arg.mode, arg.type))\n     {\n       /* Vector arguments being part of the ellipsis are passed on the\n \t stack.  */\n-      if (!named || (cum->vrs + 1 > VEC_ARG_NUM_REG))\n+      if (!arg.named || (cum->vrs + 1 > VEC_ARG_NUM_REG))\n \treturn NULL_RTX;\n \n-      return gen_rtx_REG (mode, cum->vrs + FIRST_VEC_ARG_REGNO);\n+      return gen_rtx_REG (arg.mode, cum->vrs + FIRST_VEC_ARG_REGNO);\n     }\n-  else if (s390_function_arg_float (mode, type))\n+  else if (s390_function_arg_float (arg.mode, arg.type))\n     {\n       if (cum->fprs + 1 > FP_ARG_NUM_REG)\n \treturn NULL_RTX;\n       else\n-\treturn gen_rtx_REG (mode, cum->fprs + 16);\n+\treturn gen_rtx_REG (arg.mode, cum->fprs + 16);\n     }\n-  else if (s390_function_arg_integer (mode, type))\n+  else if (s390_function_arg_integer (arg.mode, arg.type))\n     {\n-      int size = s390_function_arg_size (mode, type);\n+      int size = s390_function_arg_size (arg.mode, arg.type);\n       int n_gprs = (size + UNITS_PER_LONG - 1) / UNITS_PER_LONG;\n \n       if (cum->gprs + n_gprs > GP_ARG_NUM_REG)\n \treturn NULL_RTX;\n       else if (n_gprs == 1 || UNITS_PER_WORD == UNITS_PER_LONG)\n-\treturn gen_rtx_REG (mode, cum->gprs + 2);\n+\treturn gen_rtx_REG (arg.mode, cum->gprs + 2);\n       else if (n_gprs == 2)\n \t{\n \t  rtvec p = rtvec_alloc (2);\n@@ -12081,16 +12075,16 @@ s390_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t    = gen_rtx_EXPR_LIST (SImode, gen_rtx_REG (SImode, cum->gprs + 3),\n \t\t\t\t\t GEN_INT (4));\n \n-\t  return gen_rtx_PARALLEL (mode, p);\n+\t  return gen_rtx_PARALLEL (arg.mode, p);\n \t}\n     }\n \n-  /* After the real arguments, expand_call calls us once again\n-     with a void_type_node type.  Whatever we return here is\n-     passed as operand 2 to the call expanders.\n+  /* After the real arguments, expand_call calls us once again with an\n+     end marker.  Whatever we return here is passed as operand 2 to the\n+     call expanders.\n \n      We don't need this feature ...  */\n-  else if (type == void_type_node)\n+  else if (arg.end_marker_p ())\n     return const0_rtx;\n \n   gcc_unreachable ();\n@@ -13352,7 +13346,8 @@ s390_call_saved_register_used (tree call_expr)\n \t  type = build_pointer_type (type);\n \t}\n \n-       parm_rtx = s390_function_arg (cum, mode, type, true);\n+       function_arg_info arg (type, mode, /*named=*/true);\n+       parm_rtx = s390_function_arg (cum, arg);\n \n        s390_function_arg_advance (cum, mode, type, true);\n "}, {"sha": "43d89e24124c0afad47f2e7799f118cf1b85deb1", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -301,8 +301,7 @@ static bool sh_callee_copies (cumulative_args_t, machine_mode,\n static int sh_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n static void sh_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t     const_tree, bool);\n-static rtx sh_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t    const_tree, bool);\n+static rtx sh_function_arg (cumulative_args_t, const function_arg_info &);\n static int sh_dwarf_calling_convention (const_tree);\n static void sh_encode_section_info (tree, rtx, int);\n static bool sh2a_function_vector_p (tree);\n@@ -8010,30 +8009,25 @@ sh_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n \n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n+   ARG is a description of the argument.\n \n    On SH the first args are normally in registers\n    and the rest are pushed.  Any arg that starts within the first\n    NPARM_REGS words is at least partially passed in a register unless\n    its data type forbids.  */\n static rtx\n-sh_function_arg (cumulative_args_t ca_v, machine_mode mode,\n-\t\t const_tree type, bool named)\n+sh_function_arg (cumulative_args_t ca_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+  machine_mode mode = arg.mode;\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     return ca->renesas_abi ? const1_rtx : const0_rtx;\n \n-  if (sh_pass_in_reg_p (*ca, mode, type)\n-      && (named || ! (TARGET_HITACHI || ca->renesas_abi)))\n+  if (sh_pass_in_reg_p (*ca, mode, arg.type)\n+      && (arg.named || ! (TARGET_HITACHI || ca->renesas_abi)))\n     {\n       int regno;\n \n@@ -10819,8 +10813,8 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n       sh_function_arg_advance (pack_cumulative_args (&cum), Pmode, ptype, true);\n     }\n-  this_rtx\n-    = sh_function_arg (pack_cumulative_args (&cum), Pmode, ptr_type_node, true);\n+  function_arg_info ptr_arg (ptr_type_node, Pmode, /*named=*/true);\n+  this_rtx = sh_function_arg (pack_cumulative_args (&cum), ptr_arg);\n \n   /* For SHcompact, we only have r0 for a scratch register: r1 is the\n      static chain pointer (even if you can't have nested virtual functions"}, {"sha": "66cc1afe2bb7f9c13238cb4f120bd84900e3373b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -658,12 +658,9 @@ static bool sparc_pass_by_reference (cumulative_args_t,\n \t\t\t\t     const function_arg_info &);\n static void sparc_function_arg_advance (cumulative_args_t,\n \t\t\t\t\tmachine_mode, const_tree, bool);\n-static rtx sparc_function_arg_1 (cumulative_args_t,\n-\t\t\t\t machine_mode, const_tree, bool, bool);\n-static rtx sparc_function_arg (cumulative_args_t,\n-\t\t\t       machine_mode, const_tree, bool);\n+static rtx sparc_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx sparc_function_incoming_arg (cumulative_args_t,\n-\t\t\t\t\tmachine_mode, const_tree, bool);\n+\t\t\t\t\tconst function_arg_info &);\n static pad_direction sparc_function_arg_padding (machine_mode, const_tree);\n static unsigned int sparc_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t const_tree);\n@@ -7379,24 +7376,22 @@ function_arg_vector_value (int size, int slotno, bool named, int regno)\n \n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   NAMED is true if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n+   ARG is a description of the argument.\n    INCOMING_P is false for TARGET_FUNCTION_ARG, true for\n     TARGET_FUNCTION_INCOMING_ARG.  */\n \n static rtx\n-sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n-\t\t      const_tree type, bool named, bool incoming)\n+sparc_function_arg_1 (cumulative_args_t cum_v, const function_arg_info &arg,\n+\t\t      bool incoming)\n {\n   const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   const int regbase\n     = incoming ? SPARC_INCOMING_INT_ARG_FIRST : SPARC_OUTGOING_INT_ARG_FIRST;\n   int slotno, regno, padding;\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n+  bool named = arg.named;\n \n   slotno\n     = function_arg_slotno (cum, mode, type, named, incoming, &regno, &padding);\n@@ -7495,19 +7490,18 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n /* Handle the TARGET_FUNCTION_ARG target hook.  */\n \n static rtx\n-sparc_function_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t    const_tree type, bool named)\n+sparc_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n {\n-  return sparc_function_arg_1 (cum, mode, type, named, false);\n+  return sparc_function_arg_1 (cum, arg, false);\n }\n \n /* Handle the TARGET_FUNCTION_INCOMING_ARG target hook.  */\n \n static rtx\n-sparc_function_incoming_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t\t     const_tree type, bool named)\n+sparc_function_incoming_arg (cumulative_args_t cum,\n+\t\t\t     const function_arg_info &arg)\n {\n-  return sparc_function_arg_1 (cum, mode, type, named, true);\n+  return sparc_function_arg_1 (cum, arg, true);\n }\n \n /* For sparc64, objects requiring 16 byte alignment are passed that way.  */"}, {"sha": "0825f76925631cd47b46635fd0d2545e13e7b715", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -3829,26 +3829,23 @@ spu_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED)\n }\n \n static rtx\n-spu_function_arg (cumulative_args_t cum_v,\n-\t\t  machine_mode mode,\n-\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n+spu_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int byte_size;\n \n   if (*cum >= MAX_REGISTER_ARGS)\n     return 0;\n \n-  byte_size = ((mode == BLKmode)\n-\t       ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+  byte_size = arg.promoted_size_in_bytes ();\n \n   /* The ABI does not allow parameters to be passed partially in\n      reg and partially in stack. */\n   if ((*cum + (byte_size + 15) / 16) > MAX_REGISTER_ARGS)\n     return 0;\n \n   /* Make sure small structs are left justified in a register. */\n-  if ((mode == BLKmode || (type && AGGREGATE_TYPE_P (type)))\n+  if ((arg.mode == BLKmode || arg.aggregate_type_p ())\n       && byte_size < UNITS_PER_WORD && byte_size > 0)\n     {\n       machine_mode smode;\n@@ -3859,10 +3856,10 @@ spu_function_arg (cumulative_args_t cum_v,\n       gr_reg = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t  gen_rtx_REG (smode, FIRST_ARG_REGNUM + *cum),\n \t\t\t\t  const0_rtx);\n-      return gen_rtx_PARALLEL (mode, gen_rtvec (1, gr_reg));\n+      return gen_rtx_PARALLEL (arg.mode, gen_rtvec (1, gr_reg));\n     }\n   else\n-    return gen_rtx_REG (mode, FIRST_ARG_REGNUM + *cum);\n+    return gen_rtx_REG (arg.mode, FIRST_ARG_REGNUM + *cum);\n }\n \n static void"}, {"sha": "490606caee4fa9c8a7aca639c9c832b2fc27eb3d", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1233,17 +1233,17 @@ xstormy16_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n }\n \n static rtx\n-xstormy16_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n+xstormy16_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (mode == VOIDmode)\n+  if (arg.end_marker_p ())\n     return const0_rtx;\n-  if (targetm.calls.must_pass_in_stack (mode, type)\n-      || *cum + XSTORMY16_WORD_SIZE (type, mode) > NUM_ARGUMENT_REGISTERS)\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+      || (*cum + XSTORMY16_WORD_SIZE (arg.type, arg.mode)\n+\t  > NUM_ARGUMENT_REGISTERS))\n     return NULL_RTX;\n-  return gen_rtx_REG (mode, *cum + FIRST_ARGUMENT_REGISTER);\n+  return gen_rtx_REG (arg.mode, *cum + FIRST_ARGUMENT_REGISTER);\n }\n \n /* Build the va_list type."}, {"sha": "e62f1fda283bc29a1124c927b681a4c949912efd", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -216,21 +216,18 @@ tilegx_function_arg_boundary (machine_mode mode, const_tree type)\n \n /* Implement TARGET_FUNCTION_ARG.  */\n static rtx\n-tilegx_function_arg (cumulative_args_t cum_v,\n-\t\t     machine_mode mode,\n-\t\t     const_tree type, bool named ATTRIBUTE_UNUSED)\n+tilegx_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS cum = *get_cumulative_args (cum_v);\n-  int byte_size = ((mode == BLKmode)\n-\t\t   ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+  int byte_size = arg.promoted_size_in_bytes ();\n   bool doubleword_aligned_p;\n \n   if (cum >= TILEGX_NUM_ARG_REGS)\n     return NULL_RTX;\n \n   /* See whether the argument has doubleword alignment.  */\n   doubleword_aligned_p =\n-    tilegx_function_arg_boundary (mode, type) > BITS_PER_WORD;\n+    tilegx_function_arg_boundary (arg.mode, arg.type) > BITS_PER_WORD;\n \n   if (doubleword_aligned_p)\n     cum += cum & 1;\n@@ -241,7 +238,7 @@ tilegx_function_arg (cumulative_args_t cum_v,\n       > TILEGX_NUM_ARG_REGS)\n     return NULL_RTX;\n \n-  return gen_rtx_REG (mode, cum);\n+  return gen_rtx_REG (arg.mode, cum);\n }\n \n "}, {"sha": "dbd0b0be3e45956bd7d4902346a572b69a534e95", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -168,21 +168,18 @@ tilepro_function_arg_boundary (machine_mode mode, const_tree type)\n \n /* Implement TARGET_FUNCTION_ARG.  */\n static rtx\n-tilepro_function_arg (cumulative_args_t cum_v,\n-\t\t      machine_mode mode,\n-\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n+tilepro_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS cum = *get_cumulative_args (cum_v);\n-  int byte_size = ((mode == BLKmode)\n-\t\t   ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+  int byte_size = arg.promoted_size_in_bytes ();\n   bool doubleword_aligned_p;\n \n   if (cum >= TILEPRO_NUM_ARG_REGS)\n     return NULL_RTX;\n \n   /* See whether the argument has doubleword alignment.  */\n   doubleword_aligned_p =\n-    tilepro_function_arg_boundary (mode, type) > BITS_PER_WORD;\n+    tilepro_function_arg_boundary (arg.mode, arg.type) > BITS_PER_WORD;\n \n   if (doubleword_aligned_p)\n     cum += cum & 1;\n@@ -193,7 +190,7 @@ tilepro_function_arg (cumulative_args_t cum_v,\n       > TILEPRO_NUM_ARG_REGS)\n     return NULL_RTX;\n \n-  return gen_rtx_REG (mode, cum);\n+  return gen_rtx_REG (arg.mode, cum);\n }\n \n "}, {"sha": "07a10ba8b34bf2dfb6a35929a7a4b00d50fd4862", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -119,26 +119,20 @@ v850_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n   return size > 8;\n }\n \n-/* Return an RTX to represent where an argument with mode MODE\n-   and type TYPE will be passed to a function.  If the result\n-   is NULL_RTX, the argument will be pushed.  */\n+/* Return an RTX to represent where argument ARG will be passed to a function.\n+   If the result is NULL_RTX, the argument will be pushed.  */\n \n static rtx\n-v850_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t   const_tree type, bool named)\n+v850_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   rtx result = NULL_RTX;\n   int size, align;\n \n-  if (!named)\n+  if (!arg.named)\n     return NULL_RTX;\n \n-  if (mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  size = arg.promoted_size_in_bytes ();\n   size = (size + UNITS_PER_WORD -1) & ~(UNITS_PER_WORD -1);\n \n   if (size < 1)\n@@ -150,8 +144,8 @@ v850_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \n   if (!TARGET_GCC_ABI)\n     align = UNITS_PER_WORD;\n-  else if (size <= UNITS_PER_WORD && type)\n-    align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n+  else if (size <= UNITS_PER_WORD && arg.type)\n+    align = TYPE_ALIGN (arg.type) / BITS_PER_UNIT;\n   else\n     align = size;\n \n@@ -160,23 +154,23 @@ v850_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   if (cum->nbytes > 4 * UNITS_PER_WORD)\n     return NULL_RTX;\n \n-  if (type == NULL_TREE\n+  if (arg.type == NULL_TREE\n       && cum->nbytes + size > 4 * UNITS_PER_WORD)\n     return NULL_RTX;\n \n   switch (cum->nbytes / UNITS_PER_WORD)\n     {\n     case 0:\n-      result = gen_rtx_REG (mode, 6);\n+      result = gen_rtx_REG (arg.mode, 6);\n       break;\n     case 1:\n-      result = gen_rtx_REG (mode, 7);\n+      result = gen_rtx_REG (arg.mode, 7);\n       break;\n     case 2:\n-      result = gen_rtx_REG (mode, 8);\n+      result = gen_rtx_REG (arg.mode, 8);\n       break;\n     case 3:\n-      result = gen_rtx_REG (mode, 9);\n+      result = gen_rtx_REG (arg.mode, 9);\n       break;\n     default:\n       result = NULL_RTX;"}, {"sha": "f314948be194ba9e9aab2ce6b835778ef3cc73ee", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -54,8 +54,7 @@ static void vax_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n static int vax_address_cost_1 (rtx);\n static int vax_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool vax_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n-static rtx vax_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t     const_tree, bool);\n+static rtx vax_function_arg (cumulative_args_t, const function_arg_info &);\n static void vax_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n static rtx vax_struct_value_rtx (tree, int);\n@@ -2141,26 +2140,10 @@ vax_return_pops_args (tree fundecl ATTRIBUTE_UNUSED,\n   return size > 255 * 4 ? 0 : (HOST_WIDE_INT) size;\n }\n \n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On the VAX all args are pushed.  */\n+/* Implement TARGET_FUNCTION_ARG.  On the VAX all args are pushed.  */\n \n static rtx\n-vax_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t  const_tree type ATTRIBUTE_UNUSED,\n-\t\t  bool named ATTRIBUTE_UNUSED)\n+vax_function_arg (cumulative_args_t, const function_arg_info &)\n {\n   return NULL_RTX;\n }"}, {"sha": "95242a31f12d1f078fcbb9c12c4b99bec786dad2", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -161,8 +161,7 @@ static struct machine_function *visium_init_machine_status (void);\n static bool visium_pass_by_reference (cumulative_args_t,\n \t\t\t\t      const function_arg_info &);\n \n-static rtx visium_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t\tconst_tree, bool);\n+static rtx visium_function_arg (cumulative_args_t, const function_arg_info &);\n \n static void visium_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t\t const_tree, bool);\n@@ -1330,33 +1329,31 @@ visium_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n    in general registers.  */\n \n static rtx\n-visium_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t     const_tree type ATTRIBUTE_UNUSED,\n-\t\t     bool named ATTRIBUTE_UNUSED)\n+visium_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   int size;\n   CUMULATIVE_ARGS *ca = get_cumulative_args (pcum_v);\n \n-  size = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  if (mode == VOIDmode)\n+  size = (GET_MODE_SIZE (arg.mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  if (arg.end_marker_p ())\n     return GEN_INT (0);\n \n   /* Scalar or complex single precision floating point arguments are returned\n      in floating registers.  */\n   if (TARGET_FPU\n-      && ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE)\n-\t  || (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t      && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE * 2)))\n+      && ((GET_MODE_CLASS (arg.mode) == MODE_FLOAT\n+\t   && GET_MODE_SIZE (arg.mode) <= UNITS_PER_HWFPVALUE)\n+\t  || (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT\n+\t      && GET_MODE_SIZE (arg.mode) <= UNITS_PER_HWFPVALUE * 2)))\n     {\n       if (ca->frcount + size <= MAX_ARGS_IN_FP_REGISTERS)\n-\treturn gen_rtx_REG (mode, FP_ARG_FIRST + ca->frcount);\n+\treturn gen_rtx_REG (arg.mode, FP_ARG_FIRST + ca->frcount);\n       else\n \treturn NULL_RTX;\n     }\n \n   if (ca->grcount + size <= MAX_ARGS_IN_GP_REGISTERS)\n-    return gen_rtx_REG (mode, ca->grcount + GP_ARG_FIRST);\n+    return gen_rtx_REG (arg.mode, ca->grcount + GP_ARG_FIRST);\n \n   return NULL_RTX;\n }"}, {"sha": "d1cdbe1b7f1fcd67d1970632edba0782971350e9", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -143,10 +143,9 @@ static tree xtensa_gimplify_va_arg_expr (tree, tree, gimple_seq *,\n \t\t\t\t\t gimple_seq *);\n static void xtensa_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t\t const_tree, bool);\n-static rtx xtensa_function_arg (cumulative_args_t, machine_mode,\n-\t\t\t\tconst_tree, bool);\n+static rtx xtensa_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx xtensa_function_incoming_arg (cumulative_args_t,\n-\t\t\t\t\t machine_mode, const_tree, bool);\n+\t\t\t\t\t const function_arg_info &);\n static rtx xtensa_function_value (const_tree, const_tree, bool);\n static rtx xtensa_libcall_value (machine_mode, const_rtx);\n static bool xtensa_function_value_regno_p (const unsigned int);\n@@ -2128,13 +2127,13 @@ xtensa_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n }\n \n \n-/* Return an RTL expression containing the register for the given mode,\n+/* Return an RTL expression containing the register for the given argument,\n    or 0 if the argument is to be passed on the stack.  INCOMING_P is nonzero\n    if this is an incoming argument to the current function.  */\n \n static rtx\n-xtensa_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n-\t\t       const_tree type, bool incoming_p)\n+xtensa_function_arg_1 (cumulative_args_t cum_v, const function_arg_info &arg,\n+\t\t       bool incoming_p)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int regbase, words, max;\n@@ -2145,13 +2144,12 @@ xtensa_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n   regbase = (incoming_p ? GP_ARG_FIRST : GP_OUTGOING_ARG_FIRST);\n   max = MAX_ARGS_IN_REGISTERS;\n \n-  words = (((mode != BLKmode)\n-\t    ? (int) GET_MODE_SIZE (mode)\n-\t    : int_size_in_bytes (type)) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  words = ((arg.promoted_size_in_bytes () + UNITS_PER_WORD - 1)\n+\t   / UNITS_PER_WORD);\n \n-  if (type && (TYPE_ALIGN (type) > BITS_PER_WORD))\n+  if (arg.type && (TYPE_ALIGN (arg.type) > BITS_PER_WORD))\n     {\n-      int align = MIN (TYPE_ALIGN (type), STACK_BOUNDARY) / BITS_PER_WORD;\n+      int align = MIN (TYPE_ALIGN (arg.type), STACK_BOUNDARY) / BITS_PER_WORD;\n       *arg_words = (*arg_words + align - 1) & -align;\n     }\n \n@@ -2163,25 +2161,24 @@ xtensa_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n   if (cum->incoming && regno <= A7_REG && regno + words > A7_REG)\n     cfun->machine->need_a7_copy = TARGET_WINDOWED_ABI;\n \n-  return gen_rtx_REG (mode, regno);\n+  return gen_rtx_REG (arg.mode, regno);\n }\n \n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-xtensa_function_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t     const_tree type, bool named ATTRIBUTE_UNUSED)\n+xtensa_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n {\n-  return xtensa_function_arg_1 (cum, mode, type, false);\n+  return xtensa_function_arg_1 (cum, arg, false);\n }\n \n /* Implement TARGET_FUNCTION_INCOMING_ARG.  */\n \n static rtx\n-xtensa_function_incoming_arg (cumulative_args_t cum, machine_mode mode,\n-\t\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n+xtensa_function_incoming_arg (cumulative_args_t cum,\n+\t\t\t      const function_arg_info &arg)\n {\n-  return xtensa_function_arg_1 (cum, mode, type, true);\n+  return xtensa_function_arg_1 (cum, arg, true);\n }\n \n static unsigned int"}, {"sha": "01c405a29c277928edaf83acd3bc8324549aaffb", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -3961,18 +3961,10 @@ This section describes the macros which let you control how various\n types of arguments are passed in registers or how they are arranged in\n the stack.\n \n-@deftypefn {Target Hook} rtx TARGET_FUNCTION_ARG (cumulative_args_t @var{ca}, machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n-Return an RTX indicating whether a function argument is passed in a\n-register and if so, which register.\n-\n-The arguments are @var{ca}, which summarizes all the previous\n-arguments; @var{mode}, the machine mode of the argument; @var{type},\n-the data type of the argument as a tree node or 0 if that is not known\n-(which happens for C support library functions); and @var{named},\n-which is @code{true} for an ordinary argument and @code{false} for\n-nameless arguments that correspond to @samp{@dots{}} in the called\n-function's prototype.  @var{type} can be an incomplete type if a\n-syntax error has previously occurred.\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_ARG (cumulative_args_t @var{ca}, const function_arg_info @var{&arg})\n+Return an RTX indicating whether function argument @var{arg} is passed\n+in a register and if so, which register.  Argument @var{ca} summarizes all\n+the previous arguments.\n \n The return value is usually either a @code{reg} RTX for the hard\n register in which to pass the argument, or zero to pass the argument\n@@ -4027,7 +4019,7 @@ definition that is usually appropriate, refer to @file{expr.h} for additional\n documentation.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_FUNCTION_INCOMING_ARG (cumulative_args_t @var{ca}, machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_INCOMING_ARG (cumulative_args_t @var{ca}, const function_arg_info @var{&arg})\n Define this hook if the caller and callee on the target have different\n views of where arguments are passed.  Also define this hook if there are\n functions that are never directly called, but are invoked by the hardware"}, {"sha": "78249dacda92e4e4a449623c28085e6d2b376126", "filename": "gcc/dse.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"rtl-iter.h\"\n #include \"cfgcleanup.h\"\n+#include \"calls.h\"\n \n /* This file contains three techniques for performing Dead Store\n    Elimination (dse).\n@@ -2343,7 +2344,8 @@ get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n       if (!is_int_mode (TYPE_MODE (TREE_VALUE (arg)), &mode))\n \treturn false;\n \n-      reg = targetm.calls.function_arg (args_so_far, mode, NULL_TREE, true);\n+      function_arg_info arg (mode, /*named=*/true);\n+      reg = targetm.calls.function_arg (args_so_far, arg);\n       if (!reg || !REG_P (reg) || GET_MODE (reg) != mode)\n \treturn false;\n "}, {"sha": "471adb6879238ff09c2977b933dbd511fe1c3a1c", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -1710,8 +1710,7 @@ block_move_libcall_safe_for_call_parm (void)\n       {\n \tmachine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n \tfunction_arg_info arg_info (mode, /*named=*/true);\n-\trtx tmp = targetm.calls.function_arg (args_so_far, mode,\n-\t\t\t\t\t      NULL_TREE, true);\n+\trtx tmp = targetm.calls.function_arg (args_so_far, arg_info);\n \tif (!tmp || !REG_P (tmp))\n \t  return false;\n \tif (targetm.calls.arg_partial_bytes (args_so_far, arg_info))"}, {"sha": "13192089d1c86532613c87aff13077100a864426", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -2517,11 +2517,9 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n   targetm.calls.warn_parameter_passing_abi (all->args_so_far,\n \t\t\t\t\t    data->passed_type);\n \n-  entry_parm = targetm.calls.function_incoming_arg (all->args_so_far,\n-\t\t\t\t\t\t    data->promoted_mode,\n-\t\t\t\t\t\t    data->passed_type,\n-\t\t\t\t\t\t    data->named_arg);\n-\n+  function_arg_info arg (data->passed_type, data->promoted_mode,\n+\t\t\t data->named_arg);\n+  entry_parm = targetm.calls.function_incoming_arg (all->args_so_far, arg);\n   if (entry_parm == 0)\n     data->promoted_mode = data->passed_mode;\n \n@@ -2544,9 +2542,10 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n       if (targetm.calls.pretend_outgoing_varargs_named (all->args_so_far))\n \t{\n \t  rtx tem;\n+\t  function_arg_info named_arg (data->passed_type, data->promoted_mode,\n+\t\t\t\t       /*named=*/true);\n \t  tem = targetm.calls.function_incoming_arg (all->args_so_far,\n-\t\t\t\t\t\t     data->promoted_mode,\n-\t\t\t\t\t\t     data->passed_type, true);\n+\t\t\t\t\t\t     named_arg);\n \t  in_regs = tem != NULL;\n \t}\n     }"}, {"sha": "790c0d232b787f4037229602bdba136d9c47cb3f", "filename": "gcc/target.def", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -4732,17 +4732,9 @@ constant size shorter than an @code{int}, and upward otherwise.\",\n    argument.  */\n DEFHOOK\n (function_arg,\n- \"Return an RTX indicating whether a function argument is passed in a\\n\\\n-register and if so, which register.\\n\\\n-\\n\\\n-The arguments are @var{ca}, which summarizes all the previous\\n\\\n-arguments; @var{mode}, the machine mode of the argument; @var{type},\\n\\\n-the data type of the argument as a tree node or 0 if that is not known\\n\\\n-(which happens for C support library functions); and @var{named},\\n\\\n-which is @code{true} for an ordinary argument and @code{false} for\\n\\\n-nameless arguments that correspond to @samp{@dots{}} in the called\\n\\\n-function's prototype.  @var{type} can be an incomplete type if a\\n\\\n-syntax error has previously occurred.\\n\\\n+ \"Return an RTX indicating whether function argument @var{arg} is passed\\n\\\n+in a register and if so, which register.  Argument @var{ca} summarizes all\\n\\\n+the previous arguments.\\n\\\n \\n\\\n The return value is usually either a @code{reg} RTX for the hard\\n\\\n register in which to pass the argument, or zero to pass the argument\\n\\\n@@ -4788,8 +4780,7 @@ is not defined and @code{TARGET_FUNCTION_ARG} returns nonzero for such an\\n\\\n argument, the compiler will abort.  If @code{REG_PARM_STACK_SPACE} is\\n\\\n defined, the argument will be computed in the stack and then loaded into\\n\\\n a register.\",\n- rtx, (cumulative_args_t ca, machine_mode mode, const_tree type,\n-       bool named),\n+ rtx, (cumulative_args_t ca, const function_arg_info &arg),\n  default_function_arg)\n \n DEFHOOK\n@@ -4811,8 +4802,7 @@ so that it can be used to pass special arguments.\\n\\\n \\n\\\n If @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\\n\\\n @code{TARGET_FUNCTION_ARG} serves both purposes.\",\n- rtx, (cumulative_args_t ca, machine_mode mode, const_tree type,\n-       bool named),\n+ rtx, (cumulative_args_t ca, const function_arg_info &arg),\n  default_function_incoming_arg)\n \n DEFHOOK"}, {"sha": "911a970c55de2ec7a62c73c84002582ad266ff0b", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -828,19 +828,13 @@ default_function_arg_padding (machine_mode mode, const_tree type)\n }\n \n rtx\n-default_function_arg (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t      const_tree type ATTRIBUTE_UNUSED,\n-\t\t      bool named ATTRIBUTE_UNUSED)\n+default_function_arg (cumulative_args_t, const function_arg_info &)\n {\n   gcc_unreachable ();\n }\n \n rtx\n-default_function_incoming_arg (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t       const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t       bool named ATTRIBUTE_UNUSED)\n+default_function_incoming_arg (cumulative_args_t, const function_arg_info &)\n {\n   gcc_unreachable ();\n }"}, {"sha": "03187b27836c84769adee1f9039e0793351fb1e7", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -151,10 +151,9 @@ extern void default_function_arg_advance\n   (cumulative_args_t, machine_mode, const_tree, bool);\n extern HOST_WIDE_INT default_function_arg_offset (machine_mode, const_tree);\n extern pad_direction default_function_arg_padding (machine_mode, const_tree);\n-extern rtx default_function_arg\n-  (cumulative_args_t, machine_mode, const_tree, bool);\n-extern rtx default_function_incoming_arg\n-  (cumulative_args_t, machine_mode, const_tree, bool);\n+extern rtx default_function_arg (cumulative_args_t, const function_arg_info &);\n+extern rtx default_function_incoming_arg (cumulative_args_t,\n+\t\t\t\t\t  const function_arg_info &);\n extern unsigned int default_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t   const_tree);\n extern unsigned int default_function_arg_round_boundary (machine_mode,"}, {"sha": "88059b08da153bcb5a3c5bf23a812a3b12edf720", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6783fdb7057d559aa1da8afa2c15a702c532a03e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=6783fdb7057d559aa1da8afa2c15a702c532a03e", "patch": "@@ -6294,11 +6294,11 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t\t{\n \t\t  tree struct_addr = build_pointer_type (TREE_TYPE (type));\n \t\t  machine_mode mode = TYPE_MODE (struct_addr);\n+\t\t  function_arg_info arg (struct_addr, /*named=*/true);\n \t\t  rtx reg;\n \t\t  INIT_CUMULATIVE_ARGS (args_so_far_v, type, NULL_RTX, fndecl,\n \t\t\t\t\tnargs + 1);\n-\t\t  reg = targetm.calls.function_arg (args_so_far, mode,\n-\t\t\t\t\t\t    struct_addr, true);\n+\t\t  reg = targetm.calls.function_arg (args_so_far, arg);\n \t\t  targetm.calls.function_arg_advance (args_so_far, mode,\n \t\t\t\t\t\t      struct_addr, true);\n \t\t  if (reg == NULL_RTX)\n@@ -6318,11 +6318,9 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t\t\t\t      nargs);\n \t      if (obj_type_ref && TYPE_ARG_TYPES (type) != void_list_node)\n \t\t{\n-\t\t  machine_mode mode;\n \t\t  t = TYPE_ARG_TYPES (type);\n-\t\t  mode = TYPE_MODE (TREE_VALUE (t));\n-\t\t  this_arg = targetm.calls.function_arg (args_so_far, mode,\n-\t\t\t\t\t\t\t TREE_VALUE (t), true);\n+\t\t  function_arg_info arg (TREE_VALUE (t), /*named=*/true);\n+\t\t  this_arg = targetm.calls.function_arg (args_so_far, arg);\n \t\t  if (this_arg && !REG_P (this_arg))\n \t\t    this_arg = NULL_RTX;\n \t\t  else if (this_arg == NULL_RTX)\n@@ -6436,8 +6434,8 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t    if (pass_by_reference (&args_so_far_v, orig_arg))\n \t      argtype = build_pointer_type (argtype);\n \t    machine_mode mode = TYPE_MODE (argtype);\n-\t    reg = targetm.calls.function_arg (args_so_far, mode,\n-\t\t\t\t\t      argtype, true);\n+\t    function_arg_info arg (argtype, /*named=*/true);\n+\t    reg = targetm.calls.function_arg (args_so_far, arg);\n \t    if (TREE_CODE (argtype) == REFERENCE_TYPE\n \t\t&& INTEGRAL_TYPE_P (TREE_TYPE (argtype))\n \t\t&& reg"}]}