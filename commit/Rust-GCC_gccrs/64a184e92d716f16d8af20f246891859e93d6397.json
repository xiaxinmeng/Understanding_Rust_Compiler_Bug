{"sha": "64a184e92d716f16d8af20f246891859e93d6397", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRhMTg0ZTkyZDcxNmYxNmQ4YWYyMGYyNDY4OTE4NTllOTNkNjM5Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:34:29Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:34:29Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r481", "tree": {"sha": "e735a17b6c2d67206d0309cf5eeab93b78251601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e735a17b6c2d67206d0309cf5eeab93b78251601"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64a184e92d716f16d8af20f246891859e93d6397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a184e92d716f16d8af20f246891859e93d6397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64a184e92d716f16d8af20f246891859e93d6397", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a184e92d716f16d8af20f246891859e93d6397/comments", "author": null, "committer": null, "parents": [{"sha": "a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6"}], "stats": {"total": 173, "additions": 161, "deletions": 12}, "files": [{"sha": "6c115adcc09c07c0b644e4a623408a9d1c0847a9", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 161, "deletions": 12, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64a184e92d716f16d8af20f246891859e93d6397/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64a184e92d716f16d8af20f246891859e93d6397/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=64a184e92d716f16d8af20f246891859e93d6397", "patch": "@@ -50,11 +50,11 @@ rtx legitimize_pic_address ();\n \n /* Emit a (use pic_offset_table_rtx) if we used PIC relocation in the \n    function at any time during the compilation process.  In the future \n-   we should try and eliminate the USE if we can easily deterine that \n+   we should try and eliminate the USE if we can easily determine that \n    all PIC references were deleted from the current function.  That would \n    save an address register */\n    \n-finalize_pic()\n+finalize_pic ()\n {\n   if (flag_pic && current_function_uses_pic_offset_table)\n     emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n@@ -190,7 +190,7 @@ output_function_prologue (stream, size)\n         if (mask & (1 << i))\n           asm_fprintf (stream,\n #ifdef MOTOROLA\n-\t\t       \"\\tmov.l %s,-(%Rsp)\\n\",\n+\t\t       \"\\t%Omove.l %s,-(%Rsp)\\n\",\n #else\n \t\t       \"\\tmovel %s,%Rsp@-\\n\",\n #endif\n@@ -207,7 +207,7 @@ output_function_prologue (stream, size)\n   if (flag_pic && current_function_uses_pic_offset_table)\n     {\n #ifdef MOTOROLA\n-      asm_fprintf (stream, \"\\tmov.l %I__GLOBAL_OFFSET_TABLE_, %s\\n\",\n+      asm_fprintf (stream, \"\\t%Omove.l %I__GLOBAL_OFFSET_TABLE_, %s\\n\",\n \t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n       asm_fprintf (stream, \"\\tlea.l (%Rpc,%s.l),%s\\n\",\n \t\t   reg_names[PIC_OFFSET_TABLE_REGNUM],\n@@ -303,7 +303,7 @@ output_function_epilogue (stream, size)\n       && (mask || fmask || fpoffset))\n     {\n #ifdef MOTOROLA\n-      asm_fprintf (stream, \"\\tmov.l %0I%d,%Ra0\\n\", -fsize);\n+      asm_fprintf (stream, \"\\t%Omove.l %0I%d,%Ra0\\n\", -fsize);\n #else\n       asm_fprintf (stream, \"\\tmovel %0I%d,%Ra0\\n\", -fsize);\n #endif\n@@ -325,7 +325,7 @@ output_function_epilogue (stream, size)\n             if (big)\n \t      {\n #ifdef MOTOROLA\n-\t\tasm_fprintf (stream, \"\\tmov.l -%d(%s,%Ra0.l),%s\\n\",\n+\t\tasm_fprintf (stream, \"\\t%Omove.l -%d(%s,%Ra0.l),%s\\n\",\n \t\t\t     offset + fsize,\n \t\t\t     reg_names[FRAME_POINTER_REGNUM],\n \t\t\t     reg_names[i]);\n@@ -338,7 +338,7 @@ output_function_epilogue (stream, size)\n             else if (! frame_pointer_needed)\n \t      {\n #ifdef MOTOROLA\n-\t\tasm_fprintf (stream, \"\\tmov.l (%Rsp)+,%s\\n\",\n+\t\tasm_fprintf (stream, \"\\t%Omove.l (%Rsp)+,%s\\n\",\n \t\t\t     reg_names[i]);\n #else\n \t\tasm_fprintf (stream, \"\\tmovel %Rsp@+,%s\\n\",\n@@ -348,7 +348,7 @@ output_function_epilogue (stream, size)\n             else\n \t      {\n #ifdef MOTOROLA\n-\t\tasm_fprintf (stream, \"\\tmov.l -%d(%s),%s\\n\",\n+\t\tasm_fprintf (stream, \"\\t%Omove.l -%d(%s),%s\\n\",\n \t\t\t     offset + fsize,\n \t\t\t     reg_names[FRAME_POINTER_REGNUM],\n \t\t\t     reg_names[i]);\n@@ -515,6 +515,155 @@ not_sp_operand (op, mode)\n   return op != stack_pointer_rtx && general_operand (op, mode);\n }\n \n+/* Return TRUE if X is a valid comparison operator for the dbcc \n+   instruction.  \n+\n+   Note it rejects floating point comparison operators.\n+   (In the future we could use Fdbcc).\n+\n+   It also rejects some comparisons when CC_NO_OVERFLOW is set.  */\n+   \n+int\n+valid_dbcc_comparison_p (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  /* We could add support for these in the future */\n+  if (cc_prev_status.flags & CC_IN_68881)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+\n+      case EQ: case NE: case GTU: case LTU:\n+      case GEU: case LEU:\n+        return 1;\n+\n+      /* Reject some when CC_NO_OVERFLOW is set.  This may be over\n+         conservative */\n+      case GT: case LT: case GE: case LE:\n+        return ! (cc_prev_status.flags & CC_NO_OVERFLOW);\n+      default:\n+        return 0;\n+    }\n+}\n+\n+/* Output a dbCC; jCC sequence.  Note we do not handle the \n+   floating point version of this sequence (Fdbcc).  We also\n+   do not handle alternative conditions when CC_NO_OVERFLOW is\n+   set.  It is assumed that valid_dbcc_comparison_p will kick\n+   those out before we get here.  */\n+\n+output_dbcc_and_branch (operands)\n+     rtx *operands;\n+{\n+ \n+  switch (GET_CODE (operands[3]))\n+    {\n+      case EQ:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbeq %0,%l1\\n\\tjbeq %l2\", operands);\n+#else\n+        output_asm_insn (\"dbeq %0,%l1\\n\\tjeq %l2\", operands);\n+#endif\n+        break;\n+\n+      case NE:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbne %0,%l1\\n\\tjbne %l2\", operands);\n+#else\n+        output_asm_insn (\"dbne %0,%l1\\n\\tjne %l2\", operands);\n+#endif\n+        break;\n+\n+      case GT:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbgt %0,%l1\\n\\tjbgt %l2\", operands);\n+#else\n+        output_asm_insn (\"dbgt %0,%l1\\n\\tjgt %l2\", operands);\n+#endif\n+        break;\n+\n+      case GTU:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbhi %0,%l1\\n\\tjbhi %l2\", operands);\n+#else\n+        output_asm_insn (\"dbhi %0,%l1\\n\\tjhi %l2\", operands);\n+#endif\n+        break;\n+\n+      case LT:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dblt %0,%l1\\n\\tjblt %l2\", operands);\n+#else\n+        output_asm_insn (\"dblt %0,%l1\\n\\tjlt %l2\", operands);\n+#endif\n+        break;\n+\n+      case LTU:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbcs %0,%l1\\n\\tjbcs %l2\", operands);\n+#else\n+        output_asm_insn (\"dbcs %0,%l1\\n\\tjcs %l2\", operands);\n+#endif\n+        break;\n+\n+      case GE:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbge %0,%l1\\n\\tjbge %l2\", operands);\n+#else\n+        output_asm_insn (\"dbge %0,%l1\\n\\tjge %l2\", operands);\n+#endif\n+        break;\n+\n+      case GEU:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbcc %0,%l1\\n\\tjbcc %l2\", operands);\n+#else\n+        output_asm_insn (\"dbcc %0,%l1\\n\\tjcc %l2\", operands);\n+#endif\n+        break;\n+\n+      case LE:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dble %0,%l1\\n\\tjble %l2\", operands);\n+#else\n+        output_asm_insn (\"dble %0,%l1\\n\\tjle %l2\", operands);\n+#endif\n+        break;\n+\n+      case LEU:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"dbls %0,%l1\\n\\tjbls %l2\", operands);\n+#else\n+        output_asm_insn (\"dbls %0,%l1\\n\\tjls %l2\", operands);\n+#endif\n+        break;\n+\n+      default:\n+\tabort ();\n+    }\n+\n+  /* If the decrement is to be done in SImode, then we have\n+     to compensate for the fact that dbcc decrements in HImode. */\n+  switch (GET_MODE (operands[0]))\n+    {\n+      case SImode:\n+#ifdef MOTOROLA\n+        output_asm_insn (\"clr%.w %0\\n\\tsubq%.l %#1,%0\\n\\tjbpl %l1\", operands);\n+#else\n+        output_asm_insn (\"clr%.w %0\\n\\tsubq%.l %#1,%0\\n\\tjpl %l1\", operands);\n+#endif\n+        break;\n+\n+      case HImode:\n+        break;\n+\n+      default:\n+        abort ();\n+    }\n+}\n+\n char *\n output_btst (operands, countop, dataop, insn, signpos)\n      rtx *operands;\n@@ -697,7 +846,7 @@ singlemove_string (operands)\n       && INTVAL (operands[1]) < 128\n       && INTVAL (operands[1]) >= -128)\n     {\n-#if defined(MOTOROLA) && !defined(CRDS)\n+#if defined (MOTOROLA) && !defined (CRDS)\n       return \"moveq%.l %1,%0\";\n #else\n       return \"moveq %1,%0\";\n@@ -1018,7 +1167,7 @@ output_move_const_double (operands)\n      rtx *operands;\n {\n #ifdef SUPPORT_SUN_FPA\n-  if (TARGET_FPA && FPA_REG_P(operands[0]))\n+  if (TARGET_FPA && FPA_REG_P (operands[0]))\n     {\n       int code = standard_sun_fpa_constant_p (operands[1]);\n \n@@ -1244,7 +1393,7 @@ standard_sun_fpa_constant_p (x)\n /*\n  * Stuff that looks different if it's single or double\n  */\n-  if (GET_MODE(x) == SFmode)\n+  if (GET_MODE (x) == SFmode)\n     {\n       if (d == S_E)\n \treturn 0x8;\n@@ -1452,7 +1601,7 @@ print_operand (file, op, letter)\n     }\n #ifdef SUPPORT_SUN_FPA\n   else if ((letter == 'y' || letter == 'w')\n-\t   && GET_CODE(op) == CONST_DOUBLE\n+\t   && GET_CODE (op) == CONST_DOUBLE\n \t   && (i = standard_sun_fpa_constant_p (op)))\n     {\n       fprintf (file, \"%%%d\", i & 0x1ff);"}]}