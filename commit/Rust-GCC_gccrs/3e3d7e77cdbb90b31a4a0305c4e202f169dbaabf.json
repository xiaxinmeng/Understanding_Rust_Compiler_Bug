{"sha": "3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UzZDdlNzdjZGJiOTBiMzFhNGEwMzA1YzRlMjAyZjE2OWRiYWFiZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-25T22:52:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-25T22:52:18Z"}, "message": "(valid_machine_attribute): Use new function attribute_in_list...\n\n(valid_machine_attribute): Use new function attribute_in_list, makes\nsure type_attribute_variants are reused even when attributes have\nparameters.\nAssign any new type to TREE_TYPE (decl).\n(attribute_in_list): New function.\n(attribute_list_contained): Use it.\n\nFrom-SVN: r9456", "tree": {"sha": "74186b7084824d1db4e727022cead211f59bc5c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74186b7084824d1db4e727022cead211f59bc5c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf/comments", "author": null, "committer": null, "parents": [{"sha": "8faf4a6843d5f80497bfcddc07164ed1b78f0fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8faf4a6843d5f80497bfcddc07164ed1b78f0fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8faf4a6843d5f80497bfcddc07164ed1b78f0fa8"}], "stats": {"total": 74, "additions": 49, "deletions": 25}, "files": [{"sha": "4ffb53ff9c21032854a9ea8cec20c03ee0abc2b5", "filename": "gcc/tree.c", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3e3d7e77cdbb90b31a4a0305c4e202f169dbaabf", "patch": "@@ -2944,39 +2944,27 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n   if (decl != 0\n       && VALID_MACHINE_DECL_ATTRIBUTE (decl, decl_attr_list, attr_name))\n     {\n-      tree attr_list;\n-      int in_list = 0;\n-\n-      for (attr_list = decl_attr_list; \n-           attr_list;\n-           attr_list = TREE_CHAIN (attr_list))\n-\tif (TREE_VALUE (attr_list) == attr_name)\n-\t  in_list = 1;\n+      if (! attribute_in_list (new_attr, decl_attr_list))\n+\t{\n+\t  decl_attr_list = tree_cons (NULL_TREE, new_attr, decl_attr_list);\n \n-      if (! in_list)\n-        decl_attr_list = tree_cons (NULL_TREE, attr_name, decl_attr_list);\n+\t  /* Declarations are unique, build_decl_attribute_variant modifies\n+\t     the existing decl in situ.  */\n+\t  decl = build_decl_attribute_variant (decl, decl_attr_list);\n+\t}\n \n-      decl = build_decl_attribute_variant (decl, decl_attr_list);\n       valid = 1;\n     }\n #endif\n \n #ifdef VALID_MACHINE_TYPE_ATTRIBUTE\n   if (VALID_MACHINE_TYPE_ATTRIBUTE (type, type_attr_list, attr_name))\n     {\n-      tree attr_list;\n-      int in_list = 0;\n-\n-      for (attr_list = type_attr_list;\n-           attr_list;\n-\t   attr_list = TREE_CHAIN (attr_list))\n-\tif (TREE_VALUE (attr_list) == attr_name)\n-\t  in_list = 1;\n-\n-      if (! in_list)\n-        type_attr_list = tree_cons (NULL_TREE, attr_name, type_attr_list);\n-\n-      type = build_type_attribute_variant (type, type_attr_list);\n+      if (! attribute_in_list (new_attr, type_attr_list))\n+\t{\n+\t  type_attr_list = tree_cons (NULL_TREE, new_attr, type_attr_list);\n+\t  type = build_type_attribute_variant (type, type_attr_list);\n+\t}\n       if (decl != 0)\n \tTREE_TYPE (decl) = type;\n       valid = 1;\n@@ -3208,6 +3196,41 @@ type_hash_canon (hashcode, type)\n   return type;\n }\n \n+/* Given an attribute and a list of attributes, return true if the attribute\n+   is part of the list.  */\n+\n+int\n+attribute_in_list (attribute, list)\n+     tree attribute, list;\n+{\n+  register tree purpose, chain;\n+\n+  /* Perform a quick check.  */\n+  if (value_member (attribute, list))\n+     return 1;\n+\n+  /* If it's not a TREE_LIST, we should have had a match by now.  */\n+  if (TREE_CODE (attribute) != TREE_LIST)\n+     return 0;\n+\n+  purpose = TREE_PURPOSE (attribute);\n+  chain = TREE_CHAIN (attribute);\n+\n+  for (; list; list = TREE_CHAIN (list))\n+    {\n+      register tree value;\n+\n+      value = TREE_VALUE (list);\n+\n+      if (TREE_CODE (value) == TREE_LIST\n+          && TREE_PURPOSE (value) == purpose\n+          && simple_cst_equal (TREE_CHAIN (value), chain) == 1)\n+\t return 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Given two lists of attributes, return true if list l2 is\n    equivalent to l1.  */\n \n@@ -3243,8 +3266,9 @@ attribute_list_contained (l1, l2)\n      return 1;\n \n   for (; t2; t2 = TREE_CHAIN (t2))\n-     if (!value_member (l1, t2))\n+     if (! attribute_in_list (TREE_VALUE (t2), l1))\n \treturn 0;\n+\n   return 1;\n }\n "}]}