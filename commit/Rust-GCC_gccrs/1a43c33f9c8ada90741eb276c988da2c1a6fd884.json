{"sha": "1a43c33f9c8ada90741eb276c988da2c1a6fd884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0M2MzM2Y5YzhhZGE5MDc0MWViMjc2Yzk4OGRhMmMxYTZmZDg4NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-04-10T11:23:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-04-10T11:23:17Z"}, "message": "regrename.c: Minor cleanups, including changing some variables to unsigned int.\n\n\t* regrename.c: Minor cleanups, including changing some variables\n\tto unsigned int.\n\nFrom-SVN: r33053", "tree": {"sha": "e97a919c321d62fa3e78642e92adc46444f6c6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e97a919c321d62fa3e78642e92adc46444f6c6ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a43c33f9c8ada90741eb276c988da2c1a6fd884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a43c33f9c8ada90741eb276c988da2c1a6fd884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a43c33f9c8ada90741eb276c988da2c1a6fd884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a43c33f9c8ada90741eb276c988da2c1a6fd884/comments", "author": null, "committer": null, "parents": [{"sha": "61474454b453e664f80c0bd93ff4217d58a8dfba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61474454b453e664f80c0bd93ff4217d58a8dfba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61474454b453e664f80c0bd93ff4217d58a8dfba"}], "stats": {"total": 480, "additions": 254, "deletions": 226}, "files": [{"sha": "21985c5a85a73efcd4ebc1b9a1eb25325d8f619b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a43c33f9c8ada90741eb276c988da2c1a6fd884/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a43c33f9c8ada90741eb276c988da2c1a6fd884/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a43c33f9c8ada90741eb276c988da2c1a6fd884", "patch": "@@ -1,3 +1,8 @@\n+Mon Apr 10 07:21:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* regrename.c: Minor cleanups, including chang some variables\n+\tto unsigned int.\n+\n 2000-04-10  Neil Booth  <NeilB@earthling.net>\n \n \t* cpplex.c (skip_block_comment): Use pointer arithmetic rather"}, {"sha": "26129496f14bfd214281713f4b358d13c45c655c", "filename": "gcc/regrename.c", "status": "modified", "additions": 249, "deletions": 226, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a43c33f9c8ada90741eb276c988da2c1a6fd884/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a43c33f9c8ada90741eb276c988da2c1a6fd884/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=1a43c33f9c8ada90741eb276c988da2c1a6fd884", "patch": "@@ -75,24 +75,28 @@ ext_basic_blocks;\n #define DESTINATION 1\n #define SOURCE 2\n \n-static void build_def_use PARAMS ((int, ext_basic_blocks *, HARD_REG_SET *,\n-\t\t\t\t   def_uses *, sbitmap *));\n-static int replace_reg_in_block\n-  PARAMS ((def_uses *, varray_type *, int, rtx, int));\n-static int consider_def PARAMS ((rtx, int, def_uses *, int));\n-static int consider_available PARAMS ((rtx, int, HARD_REG_SET *, int, def_uses *, int));\n-static rtx rr_replace_reg PARAMS ((rtx, rtx, rtx, int, rtx, int *));\n-static int consider_use PARAMS ((rtx, int, int, int));\n-static int condmove_p PARAMS ((rtx));\n-static void dump_def_use_chain PARAMS ((HARD_REG_SET *, def_uses *,\n-\t\t\t\t\tvarray_type *));\n-static void dump_ext_bb_info PARAMS ((int, ext_basic_blocks *));\n-static void find_ext_basic_blocks PARAMS ((ext_basic_blocks *));\n-static void find_one_ext_basic_block PARAMS ((int, basic_block, sbitmap *,\n-\t\t\t\t\t      ext_basic_blocks *));\n-static enum reg_class get_reg_class PARAMS ((rtx, rtx, int, enum reg_class));\n-static rtx regno_first_use_in PARAMS ((int, rtx));\n-\n+static void build_def_use\t\tPARAMS ((int, ext_basic_blocks *,\n+\t\t\t\t\t\t HARD_REG_SET *, def_uses *,\n+\t\t\t\t\t\t sbitmap *));\n+static int replace_reg_in_block\t\tPARAMS ((def_uses *, varray_type *,\n+\t\t\t\t\t\t int, rtx, unsigned int));\n+static int consider_def\t\t\tPARAMS ((rtx, int, def_uses *, int));\n+static int consider_available\t\tPARAMS ((rtx, int, HARD_REG_SET *,\n+\t\t\t\t\t\t int, def_uses *, int));\n+static rtx rr_replace_reg\t\tPARAMS ((rtx, rtx, rtx, int, rtx,\n+\t\t\t\t\t\t int *));\n+static int consider_use\t\t\tPARAMS ((rtx, int, int, int));\n+static int condmove_p\t\t\tPARAMS ((rtx));\n+static void dump_def_use_chain\t\tPARAMS ((HARD_REG_SET *, def_uses *,\n+\t\t\t\t\t\t varray_type *));\n+static void dump_ext_bb_info\t\tPARAMS ((int, ext_basic_blocks *));\n+static void find_ext_basic_blocks\tPARAMS ((ext_basic_blocks *));\n+static void find_one_ext_basic_block\tPARAMS ((int, basic_block, sbitmap *,\n+\t\t\t\t\t\t ext_basic_blocks *));\n+static enum reg_class get_reg_class\tPARAMS ((rtx, rtx, int,\n+\t\t\t\t\t\t enum reg_class));\n+static rtx regno_first_use_in\t\tPARAMS ((unsigned int, rtx));\n+\f\n void\n regrename_optimize ()\n {\n@@ -101,7 +105,6 @@ regrename_optimize ()\n   def_uses du;\n   ext_basic_blocks ebb;\n \n-\n   /* Registers used in a given class */\n   HARD_REG_SET class_regs;\n \n@@ -133,11 +136,11 @@ regrename_optimize ()\n   VARRAY_RTX_INIT (uid_ruid, UID_RUID_HIGH_BOUND + 1, \"uid_ruid\");\n   VARRAY_LONG_INIT (uid_rbid, UID_RUID_HIGH_BOUND + 1, \"uid_rbid\");\n \n-  ebb.basic_block =\n-    sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  ebb.basic_block\n+    = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n   sbitmap_vector_zero (ebb.basic_block, n_basic_blocks);\n-  ebb.exit =\n-    sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  ebb.exit\n+    = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n   sbitmap_vector_zero (ebb.exit, n_basic_blocks);\n \n   find_ext_basic_blocks (&ebb);\n@@ -149,26 +152,27 @@ regrename_optimize ()\n     if (TEST_BIT (ebb.basic_block[b], b))\n       {\n \tfor (eb = du.high_bound = 0; eb < n_basic_blocks; eb++)\n-\t  {\n-\t    if (TEST_BIT (ebb.basic_block[b], eb))\n-\t      {\n-\t\tbasic_block bb = BASIC_BLOCK (eb);\n-\t\t/* Calculate high bound for uid_ruid and allocate if necessary */\n-\t\tfor (insn = bb->head;\n-\t\t     insn != NEXT_INSN (bb->end);\n-\t\t     du.high_bound++, insn = NEXT_INSN (insn))\n-\t\t  {\n-\t\t    int uid_ruid_high_bound = VARRAY_SIZE (uid_ruid);\n-\t\t    if (du.high_bound + 4 >= uid_ruid_high_bound)\n-\t\t      {\n-\t\t\tVARRAY_GROW (uid_ruid, uid_ruid_high_bound * 2);\n-\t\t\tVARRAY_GROW (uid_rbid, uid_ruid_high_bound * 2);\n-\t\t      }\n-\t\t    VARRAY_RTX (uid_ruid, du.high_bound) = insn;\n-\t\t    VARRAY_LONG (uid_rbid, du.high_bound) = eb;\n-\t\t  }\n-\t      }\n-\t  }\n+\t  if (TEST_BIT (ebb.basic_block[b], eb))\n+\t    {\n+\t      basic_block bb = BASIC_BLOCK (eb);\n+\n+\t      /* Calculate high bound for uid_ruid and allocate if necessary */\n+\t      for (insn = bb->head;\n+\t\t   insn != NEXT_INSN (bb->end);\n+\t\t   du.high_bound++, insn = NEXT_INSN (insn))\n+\t\t{\n+\t\t  int uid_ruid_high_bound = VARRAY_SIZE (uid_ruid);\n+\n+\t\t  if (du.high_bound + 4 >= uid_ruid_high_bound)\n+\t\t    {\n+\t\t      VARRAY_GROW (uid_ruid, uid_ruid_high_bound * 2);\n+\t\t      VARRAY_GROW (uid_rbid, uid_ruid_high_bound * 2);\n+\t\t    }\n+\n+\t\t  VARRAY_RTX (uid_ruid, du.high_bound) = insn;\n+\t\t  VARRAY_LONG (uid_rbid, du.high_bound) = eb;\n+\t\t}\n+\t    }\n \n \tCLEAR_HARD_REG_SET (null_bitmap);\n \tCLEAR_HARD_REG_SET (class_regs);\n@@ -177,27 +181,28 @@ regrename_optimize ()\n \tCLEAR_HARD_REG_SET (tmp_bitmap);\n \tCLEAR_HARD_REG_SET (renamed_regs);\n \n-\tdu.defs =\n-\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n+\tdu.defs\n+\t  = sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n \tsbitmap_vector_zero (du.defs, FIRST_PSEUDO_REGISTER);\n-\tdu.uses =\n-\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n+\tdu.uses\n+\t  = sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n \tsbitmap_vector_zero (du.uses, FIRST_PSEUDO_REGISTER);\n \tdu.require_call_save_reg = sbitmap_alloc (du.high_bound + 1);\n \tsbitmap_zero (du.require_call_save_reg);\n \tdefs_live_exit = sbitmap_alloc (du.high_bound + 1);\n \tsbitmap_zero (defs_live_exit);\n \n-\tdu.def_class = xrealloc\n-\t  (du.def_class,\n-\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * du.high_bound);\n+\tdu.def_class\n+\t  = xrealloc (du.def_class,\n+\t\t      (sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER\n+\t\t       * du.high_bound));\n \n-\tdu.use_class = xrealloc\n-\t  (du.use_class,\n-\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * du.high_bound);\n+\tdu.use_class\n+\t  = xrealloc (du.use_class,\n+\t\t      (sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER\n+\t\t       * du.high_bound));\n \n-\tbuild_def_use (b, &ebb, &regs_used, &du,\n-\t\t       &defs_live_exit);\n+\tbuild_def_use (b, &ebb, &regs_used, &du, &defs_live_exit);\n \n \tif (rtl_dump_file)\n \t  {\n@@ -211,17 +216,18 @@ regrename_optimize ()\n \t   as it just treats them as a big basic block. */\n \n \tCOPY_HARD_REG_SET (tmp_bitmap, regs_used);\n-\tREG_SET_TO_HARD_REG_SET (global_live_at_start, BASIC_BLOCK (b)->global_live_at_start);\n+\tREG_SET_TO_HARD_REG_SET (global_live_at_start,\n+\t\t\t\t BASIC_BLOCK (b)->global_live_at_start);\n \tIOR_HARD_REG_SET (tmp_bitmap, global_live_at_start);\n \tfor (eb = 0; eb < n_basic_blocks; eb++)\n-\t  {\n-\t    if (TEST_BIT (ebb.basic_block[b], eb))\n-\t      {\n-\t\tbasic_block bb = BASIC_BLOCK (eb);\n-\t\tREG_SET_TO_HARD_REG_SET (global_live_at_end, bb->global_live_at_end);\n-\t\tIOR_HARD_REG_SET (tmp_bitmap, global_live_at_end);\n-\t      }\n-\t  }\n+\t  if (TEST_BIT (ebb.basic_block[b], eb))\n+\t    {\n+\t      basic_block bb = BASIC_BLOCK (eb);\n+\n+\t      REG_SET_TO_HARD_REG_SET (global_live_at_end,\n+\t\t\t\t       bb->global_live_at_end);\n+\t      IOR_HARD_REG_SET (tmp_bitmap, global_live_at_end);\n+\t    }\n \n \tdef_idx = xcalloc (du.high_bound, sizeof (int));\n \n@@ -239,56 +245,53 @@ regrename_optimize ()\n \t    /* Find def_idx[N] where hbound of N is the number of \n \t       definitions of this register in this block. and def_idx\n \t       is the ordinal position of this insn in the block. */\n-\t    for (i = 0, def_idx[def_cnt] = 0;\n-\t\t i < du.high_bound;\n-\t\t i++)\n-\t      {\n-\t\tif (TEST_BIT (du.defs[r], i)\n-\t\t    && consider_def (VARRAY_RTX (uid_ruid, i), r,\n-\t\t\t\t     &du, i))\n-\t\t  {\n-\t\t    int first_use = 1;\n-\t\t    def_idx[def_cnt] = i;\n+\t    for (i = 0, def_idx[def_cnt] = 0; i < du.high_bound; i++)\n+\t      if (TEST_BIT (du.defs[r], i)\n+\t\t  && consider_def (VARRAY_RTX (uid_ruid, i), r, &du, i))\n+\t\t{\n+\t\t  int first_use = 1;\n+\t\t  def_idx[def_cnt] = i;\n \n-\t\t    /* Only consider definitions that have a use. */\n-\t\t    for (use_idx = i + 1; use_idx < du.high_bound;\n-\t\t\t use_idx++)\n-\t\t      {\n-\t\t\tif (TEST_BIT (du.uses[r], use_idx))\n-\t\t\t  {\n-\t\t\t    if (consider_use (VARRAY_RTX (uid_ruid, use_idx), r,\n-\t\t\t\t\t      VARRAY_LONG (uid_rbid, i),\n-\t\t\t\t\t   VARRAY_LONG (uid_rbid, use_idx)))\n-\t\t\t      {\n-\t\t\t\tif (first_use)\n-\t\t\t\t  {\n-\t\t\t\t    first_use = 0;\n-\t\t\t\t    def_cnt++;\n-\t\t\t\t  }\n-\t\t\t      }\n-\t\t\t    else\n-\t\t\t      {\n-\t\t\t\t/* Don't consider def if we don't want this use */\n-\t\t\t\tif (!first_use)\n-\t\t\t\t  def_cnt--;\n-\t\t\t\tbreak;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\tif (TEST_BIT (du.defs[r], use_idx))\n-\t\t\t  break;\n-\t\t      }\n-\t\t    /* Scan until the next def to avoid renaming\n-\t\t       parameter registers. */\n-\t\t    /* ??? consider using CALL_INSN_FUNCTION_USAGE */\n-\t\t    for (call_idx = i; call_idx <= use_idx; call_idx++)\n-\t\t      if (VARRAY_RTX (uid_ruid, call_idx)\n-\t\t\t  && GET_CODE (VARRAY_RTX (uid_ruid, call_idx))\n-\t\t\t  == CALL_INSN)\n+\t\t  /* Only consider definitions that have a use. */\n+\t\t  for (use_idx = i + 1; use_idx < du.high_bound; use_idx++)\n+\t\t    {\n+\t\t      if (TEST_BIT (du.uses[r], use_idx))\n \t\t\t{\n-\t\t\t  SET_BIT (du.require_call_save_reg, i);\n+\t\t\t  if (consider_use (VARRAY_RTX (uid_ruid, use_idx), r,\n+\t\t\t\t\t    VARRAY_LONG (uid_rbid, i),\n+\t\t\t\t\t    VARRAY_LONG (uid_rbid, use_idx)))\n+\t\t\t    {\n+\t\t\t      if (first_use)\n+\t\t\t\t{\n+\t\t\t\t  first_use = 0;\n+\t\t\t\t  def_cnt++;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      /* Don't consider def if we don't want this\n+\t\t\t\t use.  */\n+\t\t\t      if (!first_use)\n+\t\t\t\tdef_cnt--;\n+\n+\t\t\t      break;\n+\t\t\t    }\n \t\t\t}\n-\t\t  }\n-\t      }\n+\n+\t\t      if (TEST_BIT (du.defs[r], use_idx))\n+\t\t\tbreak;\n+\t\t    }\n+\n+\t\t  /* Scan until the next def to avoid renaming\n+\t\t     parameter registers. */\n+\t\t  /* ??? consider using CALL_INSN_FUNCTION_USAGE */\n+\t\t  for (call_idx = i; call_idx <= use_idx; call_idx++)\n+\t\t    if (VARRAY_RTX (uid_ruid, call_idx)\n+\t\t\t&& (GET_CODE (VARRAY_RTX (uid_ruid, call_idx))\n+\t\t\t    == CALL_INSN))\n+\t\t      SET_BIT (du.require_call_save_reg, i);\n+\t\t}\n+\n \t    if (def_cnt < 2)\n \t      continue;\n \n@@ -303,8 +306,9 @@ regrename_optimize ()\n \t\t\t(GET_CODE (VARRAY_RTX (uid_ruid,\n \t\t\t\t\t       def_idx[def]))) == 'i'))\n \t\t  {\n-\t\t    rtx reg_use = regno_first_use_in\n-\t\t    (r, PATTERN (VARRAY_RTX (uid_ruid, def_idx[def])));\n+\t\t    rtx reg_use\n+\t\t      = regno_first_use_in\n+\t\t\t(r, PATTERN (VARRAY_RTX (uid_ruid, def_idx[def])));\n \n \t\t    if (!reg_use)\n \t\t      break;\n@@ -314,7 +318,7 @@ regrename_optimize ()\n \t\t      break;\n #endif\n \t\t    rc = (int) DU_REG_CLASS (du.def_class,\n-\t\t\t\t      r, du.high_bound, def_idx[def]);\n+\t\t\t\t\t     r, du.high_bound, def_idx[def]);\n \t\t    COPY_HARD_REG_SET (avail_regs,\n \t\t\t\t   reg_class_contents[(enum reg_class) rc]);\n \t\t    AND_COMPL_HARD_REG_SET (avail_regs, tmp_bitmap);\n@@ -323,25 +327,26 @@ regrename_optimize ()\n \t\t    /* No available registers in this class */\n \t\t    GO_IF_HARD_REG_EQUAL (avail_regs, null_bitmap,\n \t\t\t\t\t  no_available_regs);\n+\n \t\t    for (ar_idx = 0; ar_idx < FIRST_PSEUDO_REGISTER\n \t\t\t && TEST_HARD_REG_BIT (avail_regs, ar_idx); ar_idx++)\n \t\t      ;\n+\n \t\t    if (ar_idx == FIRST_PSEUDO_REGISTER)\n \t\t      goto no_available_regs;\n \n \t\t    /* Only try register renaming if there is an available\n \t\t       register in this class. */\n-\t\t    for (ar_idx = 0;\n-\t\t\t ar_idx < FIRST_PSEUDO_REGISTER;\n-\t\t\t ar_idx++)\n+\t\t    for (ar_idx = 0; ar_idx < FIRST_PSEUDO_REGISTER; ar_idx++)\n \t\t      {\n #ifdef REG_ALLOC_ORDER\n \t\t\tavail_reg = reg_alloc_order[ar_idx];\n #else\n \t\t\tavail_reg = ar_idx;\n #endif\n-\t\t\tif (consider_available (reg_use, avail_reg, &avail_regs,\n-\t\t\t\t\t\trc, &du, def_idx[def]))\n+\t\t\tif (consider_available (reg_use, avail_reg,\n+\t\t\t\t\t\t&avail_regs, rc, &du,\n+\t\t\t\t\t\tdef_idx[def]))\n \t\t\t  break;\n \t\t      }\n \n@@ -360,8 +365,11 @@ regrename_optimize ()\n \t\t\t    if (TEST_BIT (du.require_call_save_reg,\n \t\t\t\t\t  def_idx[def]))\n \t\t\t      fprintf (rtl_dump_file, \" crosses a call\");\n-\t\t\t    fprintf (rtl_dump_file, \". No available registers\\n\");\n+\n+\t\t\t    fprintf (rtl_dump_file,\n+\t\t\t\t     \". No available registers\\n\");\n \t\t\t  }\n+\n \t\t\tgoto try_next_def;\n \t\t      }\n \n@@ -371,35 +379,51 @@ regrename_optimize ()\n \t\t    /* Replace in destination.  Replace in source for\n \t\t       remainder of block until new register is defined\n \t\t       again */\n-\t\t    replace_ok = replace_reg_in_block\n-\t\t      (&du, &uid_ruid, def_idx[def], reg_use, avail_reg);\n+\t\t    replace_ok\n+\t\t      = replace_reg_in_block (&du, &uid_ruid, def_idx[def],\n+\t\t\t\t\t      reg_use, avail_reg);\n+\n \t\t    /* Replace failed, so restore previous register */\n \t\t    if (!replace_ok)\n \t\t      {\n \t\t\treplace_reg_in_block (&du, &uid_ruid, def_idx[def],\n-\t\t\t\t\t    gen_rtx_REG (GET_MODE (reg_use),\n-\t\t\t\t\t\t\t avail_reg),\n+\t\t\t\t\t      gen_rtx_REG (GET_MODE (reg_use),\n+\t\t\t\t\t\t\t   avail_reg),\n \t\t\t\t\t      REGNO (reg_use));\n+\n \t\t\tif (rtl_dump_file)\n-\t\t\t  fprintf (rtl_dump_file,\n-\t\t\t\t   \"Register %s in class %s Renaming as %s would not satisfy constraints\\n\",\n-\t\t\t\t   reg_names[r], reg_class_names[rc],\n-\t\t\t\t   reg_names[avail_reg]);\n+\t\t\t  {\n+\t\t\t    fprintf (rtl_dump_file,\n+\t\t\t\t     \"Register %s in class %s Renaming as %s \",\n+\t\t\t\t     reg_names[r], reg_class_names[rc],\n+\t\t\t\t     reg_names[avail_reg]);\n+\t\t\t    fprintf (rtl_dump_file,\n+\t\t\t\t     \"would not satisfy constraints\\n\");\n+\t\t\t  }\n \t\t      }\n+\n \t\t    else if (rtl_dump_file)\n-\t\t      fprintf (rtl_dump_file,\n-\t\t       \"Register %s in class %s Renamed as %s at insn %d\\n\",\n-\t\t\t       reg_names[r], reg_class_names[rc],\n-\t\t\t       reg_names[avail_reg],\n-\t\t\t    INSN_UID (VARRAY_RTX (uid_ruid, def_idx[def])));\n+\t\t      {\n+\t\t\tfprintf (rtl_dump_file,\n+\t\t\t\t \"Register %s in class %s Renamed as %s \",\n+\t\t\t\t reg_names[r], reg_class_names[rc],\n+\t\t\t\t reg_names[avail_reg]);\n+\t\t\tfprintf (rtl_dump_file, \"at insn %d\\n\",\n+\t\t\t\t INSN_UID (VARRAY_RTX (uid_ruid,\n+\t\t\t\t\t\t       def_idx[def])));\n+\t\t      }\n \t\t  }\n+\n \t      try_next_def:\n \t\tcontinue;\n \t      }\n+\n \t    sbitmap_zero (du.defs[r]);\n+\n \t  no_available_regs:\n \t    continue;\n \t  }\n+\n \tfree (def_idx);\n \tsbitmap_vector_free (du.defs);\n \tsbitmap_vector_free (du.uses);\n@@ -429,7 +453,8 @@ build_def_use (b, ebb, regs_used, du, defs_live_exit)\n      sbitmap *defs_live_exit;\n {\n   rtx insn;\n-  int eb, inum, r;\n+  int eb, inum;\n+  unsigned int r;\n \n   inum = 0;\n   for (eb = 0; eb < n_basic_blocks; eb++)\n@@ -452,41 +477,40 @@ build_def_use (b, ebb, regs_used, du, defs_live_exit)\n \t  CLEAR_RESOURCE (&insn_sets);\n \t  mark_set_resources (insn, &insn_sets, 0, MARK_DEST);\n \n-\t  for (r = 0;\n-\t       r < FIRST_PSEUDO_REGISTER;\n-\t       r++)\n+\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n \t    {\n \t      if (!TEST_HARD_REG_BIT (insn_sets.regs, r))\n \t\tcontinue;\n \n \t      SET_HARD_REG_BIT (*regs_used, r);\n \t      if (REGNO_REG_SET_P (bb->global_live_at_end, r))\n \t\tSET_BIT (*defs_live_exit, inum);\n+\n \t      if (!insn_sets.memory)\n \t\tSET_BIT (du->defs[r], inum);\n-\t      DU_REG_CLASS (du->def_class, r, du->high_bound, inum) = get_reg_class\n-\t\t(insn, regno_first_use_in (r, PATTERN (insn)),\n-\t\t DESTINATION, NO_REGS);\n+\n+\t      DU_REG_CLASS (du->def_class, r, du->high_bound, inum)\n+\t\t= get_reg_class (insn, regno_first_use_in (r, PATTERN (insn)),\n+\t\t\t\t DESTINATION, NO_REGS);\n \t    }\n \n \t  CLEAR_RESOURCE (&insn_res);\n \t  mark_referenced_resources (insn, &insn_res, 0);\n \n-\t  for (r = 0;\n-\t       r < FIRST_PSEUDO_REGISTER;\n-\t       r++)\n+\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n \t    {\n \t      if (!TEST_HARD_REG_BIT (insn_res.regs, r))\n \t\tcontinue;\n \n \t      SET_HARD_REG_BIT (*regs_used, r);\n \t      SET_BIT (du->uses[r], inum);\n-\t      DU_REG_CLASS (du->use_class, r, du->high_bound, inum) = get_reg_class\n-\t\t(insn, regno_use_in (r, PATTERN (insn)),\n-\t\t SOURCE, NO_REGS);\n+\t      DU_REG_CLASS (du->use_class, r, du->high_bound, inum)\n+\t\t= get_reg_class (insn, regno_use_in (r, PATTERN (insn)),\n+\t\t\t\t SOURCE, NO_REGS);\n \t    }\n \t}\n     }\n+\n   free_resource_info ();\n }\n \n@@ -499,23 +523,24 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n      varray_type *uid_ruid;\n      int def;\n      rtx reg_def;\n-     int avail_reg;\n+     unsigned int avail_reg;\n {\n   int du_idx, status = 1;\n-  int r = REGNO (reg_def);\n+  unsigned int r = REGNO (reg_def);\n   rtx death_note;\n   rtx new_reg = gen_rtx_REG (GET_MODE (reg_def), avail_reg);\n \n+  rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, def)), reg_def, new_reg,\n+\t\t  DESTINATION, VARRAY_RTX (*uid_ruid, def), &status);\n \n-  rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, def)), reg_def,\n-\t\t  new_reg, DESTINATION, VARRAY_RTX (*uid_ruid, def),\n-\t\t  &status);\n   if (!status)\n     return status;\n \n   death_note = find_reg_note (VARRAY_RTX (*uid_ruid, def), REG_DEAD, reg_def);\n   if (!death_note)\n-    death_note = find_reg_note (VARRAY_RTX (*uid_ruid, def), REG_UNUSED, reg_def);\n+    death_note = find_reg_note (VARRAY_RTX (*uid_ruid, def), REG_UNUSED,\n+\t\t\t\treg_def);\n+\n   if (death_note)\n     rr_replace_reg (death_note, reg_def, new_reg, 0,\n \t\t    VARRAY_RTX (*uid_ruid, def), &status);\n@@ -524,10 +549,11 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n     {\n       rtx reg_use;\n       rtx new_reg;\n+\n       if (GET_RTX_CLASS (GET_CODE (VARRAY_RTX (*uid_ruid, du_idx))) != 'i')\n \tcontinue;\n-      reg_use = regno_use_in (r, PATTERN (VARRAY_RTX (*uid_ruid, du_idx)));\n \n+      reg_use = regno_use_in (r, PATTERN (VARRAY_RTX (*uid_ruid, du_idx)));\n       if (reg_use && TEST_BIT (du->uses[r], du_idx))\n \t{\n \t  new_reg = gen_rtx_REG (GET_MODE (reg_use), avail_reg);\n@@ -542,14 +568,17 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n \t  if (death_note)\n \t    rr_replace_reg (death_note, reg_use, new_reg, 0,\n \t\t\t    VARRAY_RTX (*uid_ruid, def), &status);\n+\n \t  SET_BIT (du->uses[avail_reg], du_idx);\n \t  RESET_BIT (du->uses[r], du_idx);\n \t  if (!status)\n \t    return status;\n \t}\n+\n       if (TEST_BIT (du->defs[r], du_idx))\n \tbreak;\n     }\n+\n   return status;\n }\n \n@@ -584,6 +613,7 @@ rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n \t  else\n \t    return gen_rtx_REG (GET_MODE (x), REGNO (reg_use));\n \t}\n+\n       return x;\n \n     case SET:\n@@ -592,15 +622,15 @@ rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n \t\t\t\t       replace_type, insn, status);\n       else if (replace_type == SOURCE)\n \t{\n-\t  int dest_subregno;\n+\t  unsigned int dest_subregno;\n+\t  int had_subreg = GET_CODE (SET_DEST (x)) == SUBREG;\n \n-\t  if (GET_CODE (SET_DEST (x)) == SUBREG)\n+\t  if (had_subreg)\n \t    dest_subregno = REGNO (XEXP (SET_DEST (x), 0));\n-\t  else\n-\t    dest_subregno = 0;\n \n \t  SET_SRC (x) = rr_replace_reg (SET_SRC (x), reg_use, reg_sub,\n \t\t\t\t\treplace_type, insn, status);\n+\n \t  /* If the replacement register is not part of the source\n \t     then it may be part of a source mem operand. */\n \t  if (GET_CODE (SET_DEST (x)) == MEM\n@@ -609,9 +639,8 @@ rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n \t      || GET_CODE (SET_DEST (x)) == STRICT_LOW_PART)\n \t    SET_DEST (x) = rr_replace_reg (SET_DEST (x), reg_use, reg_sub,\n \t\t\t\t\t   replace_type, insn, status);\n-\t  /* shared rtl sanity check */\n-\t  if (dest_subregno\n-\t      && dest_subregno != REGNO (XEXP (SET_DEST (x), 0)))\n+\t  /* Shared rtl sanity check. */\n+\t  if (had_subreg && dest_subregno != REGNO (XEXP (SET_DEST (x), 0)))\n \t    {\n \t      *status = 0;\n \t      return x;\n@@ -622,16 +651,18 @@ rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n       if (n >= 0)\n \t{\n \t  int id;\n+\n \t  extract_insn (insn);\n \n \t  /* Any MATCH_DUP's which are REGs must still match */\n \t  for (id = insn_data[n].n_dups - 1; id >= 0; id--)\n \t    {\n \t      int opno = recog_data.dup_num[id];\n+\n \t      if (GET_CODE (*recog_data.dup_loc[id]) == REG\n \t\t  && GET_CODE (*recog_data.operand_loc[opno]) == REG\n-\t\t  && (REGNO (*recog_data.dup_loc[id]) !=\n-\t\t      REGNO (*recog_data.operand_loc[opno])))\n+\t\t  && (REGNO (*recog_data.dup_loc[id])\n+\t\t      != REGNO (*recog_data.operand_loc[opno])))\n \t\t*status = 0;\n \t    }\n \n@@ -659,6 +690,7 @@ rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n       if (fmt[i] == 'E')\n \t{\n \t  register int xv;\n+\n \t  for (xv = 0; xv < XVECLEN (x, i); xv++)\n \t    {\n \t      XVECEXP (x, i, xv) = rr_replace_reg (XVECEXP (x, i, xv), reg_use,\n@@ -679,6 +711,7 @@ rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n \t    }\n \t}\n     }\n+\n   return x;\n }\n \n@@ -689,8 +722,8 @@ static int\n consider_def (insn, regno, du, inum)\n      rtx insn;\n      int regno;\n-     def_uses *du;\n-     int inum;\n+     def_uses *du ATTRIBUTE_UNUSED;\n+     int inum ATTRIBUTE_UNUSED;\n {\n   /* Don't rename windowed registers across a call */\n #ifdef INCOMING_REGNO\n@@ -733,12 +766,11 @@ consider_use (insn, regno, def_block, use_block)\n      then insure another predecessor does not also define this register */\n   if (def_block != use_block)\n     for (e = ub->pred; e; e = e->pred_next)\n-      {\n-\tif (e->src->index != def_block\n-\t    && e->src->index != -1\n-\t    && REGNO_REG_SET_P (BASIC_BLOCK (e->src->index)->global_live_at_end, regno))\n-\t  return 0;\n-      }\n+      if (e->src->index != def_block\n+\t  && e->src->index != -1\n+\t  && REGNO_REG_SET_P (BASIC_BLOCK (e->src->index)->global_live_at_end,\n+\t\t\t      regno))\n+\treturn 0;\n \n   /* Don't consider conditional moves.  Predicate architectures may\n      use two complementary conditional moves and the regno shouldn't change */\n@@ -755,11 +787,8 @@ consider_use (insn, regno, def_block, use_block)\n \treturn 0;\n \n       /* Don't consider register if the only use is in a USE */\n-      if (reg_mentioned_p (gen_rtx_USE (VOIDmode, reg_use),\n-\t\t\t   PATTERN (insn)))\n-\treturn 0;\n-      else\n-\treturn 1;\n+      return ! reg_mentioned_p (gen_rtx_USE (VOIDmode, reg_use),\n+\t\t\t\tPATTERN (insn));\n     }\n   else\n     return 0;\n@@ -810,17 +839,13 @@ consider_available (reg_use, avail_reg, avail_regs, rc, du, inum)\n #endif\n       )\n       || (TEST_BIT (du->require_call_save_reg, inum)\n-\t  && (call_used_regs[avail_reg] || call_used_regs[REGNO (reg_use)]\n-\t  )))\n+\t  && (call_used_regs[avail_reg] || call_used_regs[REGNO (reg_use)])))\n     return 0;\n \n   /* If register is a callee-saved register it must be saved in the frame. \n      call saved registers can not be added to regs_ever_live after reload,\n      as it would invalidate most elimination offsets */\n-  if (regs_ever_live[avail_reg] || call_used_regs[avail_reg])\n-    return 1;\n-\n-  return 0;\n+  return regs_ever_live[avail_reg] || call_used_regs[avail_reg];\n }\n \n /* Return 1 if INSN is a conditional move */\n@@ -829,19 +854,17 @@ static int\n condmove_p (insn)\n      rtx insn;\n {\n-  if (GET_CODE (insn) == INSN\n-      && GET_CODE (PATTERN (insn)) == SET\n-      && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n-    return 1;\n-  return 0;\n+  return (GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == SET\n+\t  && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE);\n }\n \n /* Searches X for the first reference to REGNO, returning the rtx of the\n    reference found if any.  Otherwise, returns NULL_RTX.  */\n \n static rtx\n regno_first_use_in (regno, x)\n-     int regno;\n+     unsigned int regno;\n      rtx x;\n {\n   register const char *fmt;\n@@ -859,13 +882,14 @@ regno_first_use_in (regno, x)\n \t  if ((tem = regno_first_use_in (regno, XEXP (x, i))))\n \t    return tem;\n \t}\n+\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t  if ((tem = regno_first_use_in (regno, XVECEXP (x, i, j))))\n \t    return tem;\n     }\n \n-  return NULL_RTX;\n+  return 0;\n }\n \n /* Dump def/use chain DU to RTL_DUMP_FILE, given insns in UID_RUID and\n@@ -877,21 +901,22 @@ dump_def_use_chain (global_live_at_end, du, uid_ruid)\n      def_uses *du;\n      varray_type *uid_ruid;\n {\n-  int r, inum;\n-\n+  unsigned int r;\n+  int inum;\n+  \n   for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n     {\n       int set = 0;\n-      for (inum = 0;\n-\t   inum <= du->high_bound;\n-\t   inum++)\n+\n+      for (inum = 0; inum <= du->high_bound; inum++)\n \t{\n \t  rtx insn = VARRAY_RTX (*uid_ruid, inum);\n #if 0\n \t  if (!insn\n \t      || GET_RTX_CLASS (GET_CODE\n \t\t\t\t(insn)) != 'i')\n \t    continue;\n+\n \t  reg_use = regno_first_use_in (r, PATTERN (insn));\n \t  if (!reg_use)\n \t    continue;\n@@ -908,11 +933,13 @@ dump_def_use_chain (global_live_at_end, du, uid_ruid)\n \t\tfprintf (rtl_dump_file, \"Live at Exit \");\n \t      set = 1;\n \t    }\n+\n \t  if (TEST_BIT (du->defs[r], inum))\n \t    fprintf (rtl_dump_file, \"=%d \", INSN_UID (insn));\n \t  if (TEST_BIT (du->uses[r], inum))\n \t    fprintf (rtl_dump_file, \"%d \", INSN_UID (insn));\n \t}\n+\n       if (set)\n \tfprintf (rtl_dump_file, \"\\n\");\n     }\n@@ -926,30 +953,30 @@ dump_ext_bb_info (eb, ebb)\n      ext_basic_blocks *ebb;\n {\n   int b;\n+  int have_ebb = 0;\n \n-  {\n-    int have_ebb = 0;\n-    for (b = 0; b < n_basic_blocks; b++)\n-      {\n-\tif (TEST_BIT (ebb->basic_block[eb], b))\n-\t  {\n-\t    if (!have_ebb)\n-\t      {\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      if (TEST_BIT (ebb->basic_block[eb], b))\n+\t{\n+\t  if (!have_ebb)\n+\t    {\n #ifndef RENAME_EXTENDED_BLOCKS\n-\t\tfprintf (rtl_dump_file, \"\\nBasic block %d: \", b);\n+\t      fprintf (rtl_dump_file, \"\\nBasic block %d: \", b);\n #else\n-\t\tfprintf (rtl_dump_file, \"\\nExtended basic block %d: \", b);\n+\t      fprintf (rtl_dump_file, \"\\nExtended basic block %d: \", b);\n #endif\n-\t\thave_ebb = 1;\n-\t      }\n-\t    fprintf (rtl_dump_file, \"%d \", b);\n-\t  }\n-\tif (TEST_BIT (ebb->exit[eb], b))\n-\t  fprintf (rtl_dump_file, \"(exit) \");\n-      }\n-    if (have_ebb)\n-      fprintf (rtl_dump_file, \"\\n\");\n-  }\n+\t      have_ebb = 1;\n+\t    }\n+\t  fprintf (rtl_dump_file, \"%d \", b);\n+\t}\n+\n+      if (TEST_BIT (ebb->exit[eb], b))\n+\tfprintf (rtl_dump_file, \"(exit) \");\n+    }\n+\n+  if (have_ebb)\n+    fprintf (rtl_dump_file, \"\\n\");\n }\n \n /* Initialize EBB with extended basic block info if RENAME_EXTENDED_BLOCKS is\n@@ -974,6 +1001,7 @@ find_ext_basic_blocks (ebb)\n #else\n   for (b = 0; b < n_basic_blocks; b++)\n     {\n+\n       basic_block bb = BASIC_BLOCK (b);\n       if (!TEST_BIT (bb_processed, b))\n \t{\n@@ -1007,13 +1035,9 @@ find_one_ext_basic_block (entry, bb, bb_processed, ebb)\n       {\n \tif (!e->dest->pred->pred_next\n \t    && (!TEST_BIT (*bb_processed, e->dest->index)))\n-\t  {\n-\t    find_one_ext_basic_block (entry, e->dest, bb_processed, ebb);\n-\t  }\n+\t  find_one_ext_basic_block (entry, e->dest, bb_processed, ebb);\n \telse\n-\t  {\n-\t    SET_BIT (ebb->exit[entry], bb->index);\n-\t  }\n+\t  SET_BIT (ebb->exit[entry], bb->index);\n       }\n }\n \n@@ -1036,17 +1060,16 @@ get_reg_class (insn, reg_use, type, default_class)\n   preprocess_constraints ();\n \n   if (type == DESTINATION)\n-    for (id = 0; id < recog_data.n_operands; id++)\n-      {\n+    {\n+      for (id = 0; id < recog_data.n_operands; id++)\n \tif (rtx_equal_p (recog_data.operand[id], reg_use))\n \t  break;\n-      }\n+    }\n+\n   else if (type == SOURCE)\n     for (id = recog_data.n_operands - 1; id >= 0; id--)\n-      {\n-\tif (rtx_equal_p (recog_data.operand[id], reg_use))\n-\t  break;\n-      }\n+      if (rtx_equal_p (recog_data.operand[id], reg_use))\n+\tbreak;\n \n   if (id == -1 || id == recog_data.n_operands)\n     return default_class;"}]}