{"sha": "d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc1NWM3ZWZmY2M1MWNlNDc1MzZjMWNiOWVkZDg3ZWQxNzZlYmMxYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-04-09T12:39:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-09T12:39:22Z"}, "message": "tree-vectorizer.h (slp_void_p): Remove.\n\n2013-04-09  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (slp_void_p): Remove.\n\t(slp_tree): Typedef before _slp_tree declaration.\n\t(struct _slp_tree): Use a vector of slp_tree as children.\n\t(vect_get_place_in_interleaving_chain): Remove.\n\t* tree-vect-data-refs.c (vect_get_place_in_interleaving_chain):\n\tMove ...\n\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain): ... here\n\tand make static.\n\t(vect_free_slp_tree, vect_print_slp_tree, vect_mark_slp_stmts,\n\tvect_mark_slp_stmts_relevant, vect_slp_rearrange_stmts,\n\tvect_detect_hybrid_slp_stmts, vect_slp_analyze_node_operations,\n\tvect_schedule_slp_instance, vect_remove_slp_scalar_calls):\n\tUse slp_node instead of slp_void_p and adjust.\n\nFrom-SVN: r197629", "tree": {"sha": "2c8bd0affb55d76dfbc3479c59b2a8b47dc84ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c8bd0affb55d76dfbc3479c59b2a8b47dc84ce1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d741091eef9e0d94e4773371542f5a3a6a00cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d741091eef9e0d94e4773371542f5a3a6a00cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d741091eef9e0d94e4773371542f5a3a6a00cbb"}], "stats": {"total": 126, "additions": 66, "deletions": 60}, "files": [{"sha": "42382597ea7976f9a86ee7aa3734ab728c154715", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "patch": "@@ -1,3 +1,19 @@\n+2013-04-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (slp_void_p): Remove.\n+\t(slp_tree): Typedef before _slp_tree declaration.\n+\t(struct _slp_tree): Use a vector of slp_tree as children.\n+\t(vect_get_place_in_interleaving_chain): Remove.\n+\t* tree-vect-data-refs.c (vect_get_place_in_interleaving_chain):\n+\tMove ...\n+\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain): ... here\n+\tand make static.\n+\t(vect_free_slp_tree, vect_print_slp_tree, vect_mark_slp_stmts,\n+\tvect_mark_slp_stmts_relevant, vect_slp_rearrange_stmts,\n+\tvect_detect_hybrid_slp_stmts, vect_slp_analyze_node_operations,\n+\tvect_schedule_slp_instance, vect_remove_slp_scalar_calls):\n+\tUse slp_node instead of slp_void_p and adjust.\n+\n 2013-04-09  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-manip.c (rewrite_into_loop_closed_ssa): Avoid"}, {"sha": "e20ab1f6d173a40cc5d1fe6b230c82bea89e5343", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "patch": "@@ -129,31 +129,6 @@ vect_get_smallest_scalar_type (gimple stmt, HOST_WIDE_INT *lhs_size_unit,\n }\n \n \n-/* Find the place of the data-ref in STMT in the interleaving chain that starts\n-   from FIRST_STMT.  Return -1 if the data-ref is not a part of the chain.  */\n-\n-int\n-vect_get_place_in_interleaving_chain (gimple stmt, gimple first_stmt)\n-{\n-  gimple next_stmt = first_stmt;\n-  int result = 0;\n-\n-  if (first_stmt != GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n-    return -1;\n-\n-  while (next_stmt && next_stmt != stmt)\n-    {\n-      result++;\n-      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n-    }\n-\n-  if (next_stmt)\n-    return result;\n-  else\n-    return -1;\n-}\n-\n-\n /* Check if data references pointed by DR_I and DR_J are same or\n    belong to same interleaving group.  Return FALSE if drs are\n    different, otherwise return TRUE.  */"}, {"sha": "34131060ee5e4fc4cc4f9253918ee5c43e0daf2d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "patch": "@@ -67,13 +67,13 @@ static void\n vect_free_slp_tree (slp_tree node)\n {\n   int i;\n-  slp_void_p child;\n+  slp_tree child;\n \n   if (!node)\n     return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_free_slp_tree ((slp_tree) child);\n+    vect_free_slp_tree (child);\n \n   SLP_TREE_CHILDREN (node).release ();\n   SLP_TREE_SCALAR_STMTS (node).release ();\n@@ -168,6 +168,31 @@ vect_free_oprnd_info (vec<slp_oprnd_info> &oprnds_info)\n }\n \n \n+/* Find the place of the data-ref in STMT in the interleaving chain that starts\n+   from FIRST_STMT.  Return -1 if the data-ref is not a part of the chain.  */\n+\n+static int\n+vect_get_place_in_interleaving_chain (gimple stmt, gimple first_stmt)\n+{\n+  gimple next_stmt = first_stmt;\n+  int result = 0;\n+\n+  if (first_stmt != GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+    return -1;\n+\n+  do\n+    {\n+      if (next_stmt == stmt)\n+\treturn result;\n+      result++;\n+      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+    }\n+  while (next_stmt);\n+\n+  return -1;\n+}\n+\n+\n /* Get the defs for the rhs of STMT (collect them in OPRNDS_INFO), check that\n    they are of a valid type and that they match the defs of the first stmt of\n    the SLP group (stored in OPRNDS_INFO).  */\n@@ -991,7 +1016,7 @@ vect_print_slp_tree (int dump_kind, slp_tree node)\n {\n   int i;\n   gimple stmt;\n-  slp_void_p child;\n+  slp_tree child;\n \n   if (!node)\n     return;\n@@ -1005,7 +1030,7 @@ vect_print_slp_tree (int dump_kind, slp_tree node)\n   dump_printf (dump_kind, \"\\n\");\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_print_slp_tree (dump_kind, (slp_tree) child);\n+    vect_print_slp_tree (dump_kind, child);\n }\n \n \n@@ -1019,7 +1044,7 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n {\n   int i;\n   gimple stmt;\n-  slp_void_p child;\n+  slp_tree child;\n \n   if (!node)\n     return;\n@@ -1029,7 +1054,7 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n       STMT_SLP_TYPE (vinfo_for_stmt (stmt)) = mark;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_mark_slp_stmts ((slp_tree) child, mark, j);\n+    vect_mark_slp_stmts (child, mark, j);\n }\n \n \n@@ -1041,7 +1066,7 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n   int i;\n   gimple stmt;\n   stmt_vec_info stmt_info;\n-  slp_void_p child;\n+  slp_tree child;\n \n   if (!node)\n     return;\n@@ -1055,7 +1080,7 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n     }\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_mark_slp_stmts_relevant ((slp_tree) child);\n+    vect_mark_slp_stmts_relevant (child);\n }\n \n \n@@ -1129,26 +1154,18 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n {\n   gimple stmt;\n   vec<gimple> tmp_stmts;\n-  unsigned int index, i;\n-  slp_void_p child;\n-\n-  if (!node)\n-    return;\n+  unsigned int i;\n+  slp_tree child;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_slp_rearrange_stmts ((slp_tree) child, group_size, permutation);\n+    vect_slp_rearrange_stmts (child, group_size, permutation);\n \n   gcc_assert (group_size == SLP_TREE_SCALAR_STMTS (node).length ());\n   tmp_stmts.create (group_size);\n-\n-  for (i = 0; i < group_size; i++)\n-    tmp_stmts.safe_push (NULL);\n+  tmp_stmts.quick_grow_cleared (group_size);\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n-    {\n-      index = permutation[i];\n-      tmp_stmts[index] = stmt;\n-    }\n+    tmp_stmts[permutation[i]] = stmt;\n \n   SLP_TREE_SCALAR_STMTS (node).release ();\n   SLP_TREE_SCALAR_STMTS (node) = tmp_stmts;\n@@ -1824,7 +1841,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node)\n   imm_use_iterator imm_iter;\n   gimple use_stmt;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  slp_void_p child;\n+  slp_tree child;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = NULL;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n@@ -1855,7 +1872,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node)\n \t  vect_mark_slp_stmts (node, hybrid, i);\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_detect_hybrid_slp_stmts ((slp_tree) child);\n+    vect_detect_hybrid_slp_stmts (child);\n }\n \n \n@@ -1953,13 +1970,13 @@ vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n   bool dummy;\n   int i;\n   gimple stmt;\n-  slp_void_p child;\n+  slp_tree child;\n \n   if (!node)\n     return true;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (!vect_slp_analyze_node_operations (bb_vinfo, (slp_tree) child))\n+    if (!vect_slp_analyze_node_operations (bb_vinfo, child))\n       return false;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n@@ -3014,14 +3031,13 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   tree vectype;\n   int i;\n   slp_tree loads_node;\n-  slp_void_p child;\n+  slp_tree child;\n \n   if (!node)\n     return false;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_schedule_slp_instance ((slp_tree) child, instance,\n-                                vectorization_factor);\n+    vect_schedule_slp_instance (child, instance, vectorization_factor);\n \n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   stmt_info = vinfo_for_stmt (stmt);\n@@ -3111,15 +3127,15 @@ vect_remove_slp_scalar_calls (slp_tree node)\n   gimple stmt, new_stmt;\n   gimple_stmt_iterator gsi;\n   int i;\n-  slp_void_p child;\n+  slp_tree child;\n   tree lhs;\n   stmt_vec_info stmt_info;\n \n   if (!node)\n     return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_remove_slp_scalar_calls ((slp_tree) child);\n+    vect_remove_slp_scalar_calls (child);\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {"}, {"sha": "1a233a01fa20db685f2487825934dddb3edf592e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755c7effcc51ce47536c1cb9edd87ed176ebc1a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d755c7effcc51ce47536c1cb9edd87ed176ebc1a", "patch": "@@ -97,13 +97,13 @@ add_stmt_info_to_vec (stmt_vector_for_cost *stmt_cost_vec, int count,\n /************************************************************************\n   SLP\n  ************************************************************************/\n-typedef void *slp_void_p;\n+typedef struct _slp_tree *slp_tree;\n \n /* A computation tree of an SLP instance.  Each node corresponds to a group of\n    stmts to be packed in a SIMD stmt.  */\n-typedef struct _slp_tree {\n+struct _slp_tree {\n   /* Nodes that contain def-stmts of this node statements operands.  */\n-  vec<slp_void_p> children;\n+  vec<slp_tree> children;\n   /* A group of scalar stmts to be vectorized together.  */\n   vec<gimple> stmts;\n   /* Vectorized stmt/s.  */\n@@ -113,7 +113,7 @@ typedef struct _slp_tree {\n      scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF\n      divided by vector size.  */\n   unsigned int vec_stmts_size;\n-} *slp_tree;\n+};\n \n \n /* SLP instance is a sequence of stmts in a loop that can be packed into\n@@ -941,7 +941,6 @@ extern tree vect_setup_realignment (gimple, gimple_stmt_iterator *, tree *,\n extern void vect_transform_grouped_load (gimple, vec<tree> , int,\n                                          gimple_stmt_iterator *);\n extern void vect_record_grouped_load_vectors (gimple, vec<tree> );\n-extern int vect_get_place_in_interleaving_chain (gimple, gimple);\n extern tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n extern tree vect_create_addr_base_for_vector_ref (gimple, gimple_seq *,\n                                                   tree, struct loop *);"}]}