{"sha": "5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyZDk0N2NlODRiMWE4YmFhMjI1MmM1ZmYwNGI5YjM5MzFiMzg5Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-16T10:33:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-16T10:33:40Z"}, "message": "basic-block.h (rtl_bb_info): Break out head_, end_, global_live_at_start, global_live_at_end from ...\n\n\n\t* basic-block.h (rtl_bb_info): Break out head_, end_,\n\tglobal_live_at_start, global_live_at_end from ...\n\t(basic_block_def): ... here; update all references\n\t(BB_RTL): New flag.\n\t(init_rtl_bb_info): Declare.\n\t* cfgexpand.c (expand_gimple_basic_block): Init bb info, set BB_RTL\n\tflag.\n\t* cfgrtl.c: Include ggc.h\n\t(create_basic_block_structure): Init bb info.\n\t(rtl_verify_flow_info_1): Check BB_RTL flag and rtl_bb_info pointer.\n\t(init_rtl_bb_info): New function.\n\t(rtl_merge_block, cfglayout_merge_block): Copy global_live_at_end here.\n\t* cfghooks.c (merge_block): Do not copy global_live_at_end here.\n\t* cfg.c (clear_bb_flags): Skip BB_RTL flag.\n\t(dump_flow_info): Gueard global_live_* dumping.\n\nFrom-SVN: r101082", "tree": {"sha": "681bd279155de09165d78fad8c1bda0ae8a5495f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/681bd279155de09165d78fad8c1bda0ae8a5495f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/comments", "author": null, "committer": null, "parents": [{"sha": "0adcdb66ecc4606e302524b98811d82fa555bc4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0adcdb66ecc4606e302524b98811d82fa555bc4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0adcdb66ecc4606e302524b98811d82fa555bc4b"}], "stats": {"total": 434, "additions": 255, "deletions": 179}, "files": [{"sha": "05f52804e49e8651d8ea4bacabea44631c44ad62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1,5 +1,21 @@\n 2005-06-16  Jan Hubicka  <jh@suse.cz>\n \n+\t* basic-block.h (rtl_bb_info): Break out head_, end_,\n+\tglobal_live_at_start, global_live_at_end from ...\n+\t(basic_block_def): ... here; update all references\n+\t(BB_RTL): New flag.\n+\t(init_rtl_bb_info): Declare.\n+\t* cfgexpand.c (expand_gimple_basic_block): Init bb info, set BB_RTL\n+\tflag.\n+\t* cfgrtl.c: Include ggc.h\n+\t(create_basic_block_structure): Init bb info.\n+\t(rtl_verify_flow_info_1): Check BB_RTL flag and rtl_bb_info pointer.\n+\t(init_rtl_bb_info): New function.\n+\t(rtl_merge_block, cfglayout_merge_block): Copy global_live_at_end here.\n+\t* cfghooks.c (merge_block): Do not copy global_live_at_end here.\n+\t* cfg.c (clear_bb_flags): Skip BB_RTL flag.\n+\t(dump_flow_info): Gueard global_live_* dumping.\n+\n \t* Makefile.in (cfg.o): Add new dependencies.\n \t* basic-block.h (reorder_block_def): Kill\n \toriginal/copy/duplicated/copy_number fields."}, {"sha": "948f9f4526ec3fbb935af35081b4e8874c131a18", "filename": "gcc/basic-block.h", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -183,6 +183,7 @@ struct loops;\n \n /* Declared in tree-flow.h.  */\n struct edge_prediction;\n+struct rtl_bb_info;\n \n /* A basic block is a sequence of instructions with only entry and\n    only one exit.  If any one of the instructions are executed, they\n@@ -212,23 +213,13 @@ struct edge_prediction;\n /* Basic block information indexed by block number.  */\n struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")))\n {\n-  /* The first and last insns of the block.  */\n-  rtx head_;\n-  rtx end_;\n-\n   /* Pointers to the first and last trees of the block.  */\n   tree stmt_list;\n \n   /* The edges into and out of the block.  */\n   VEC(edge,gc) *preds;\n   VEC(edge,gc) *succs;\n \n-  /* The registers that are live on entry to this block.  */\n-  bitmap GTY ((skip (\"\"))) global_live_at_start;\n-\n-  /* The registers that are live on exit from this block.  */\n-  bitmap GTY ((skip (\"\"))) global_live_at_end;\n-\n   /* Auxiliary info specific to a pass.  */\n   PTR GTY ((skip (\"\"))) aux;\n \n@@ -245,6 +236,10 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   /* The data used by basic block copying and reordering functions.  */\n   struct reorder_block_def * rbi;\n \n+  union basic_block_il_dependent {\n+      struct rtl_bb_info * GTY ((tag (\"1\"))) rtl;\n+    } GTY ((desc (\"((%1.flags & BB_RTL) != 0)\"))) il;\n+\n   /* Chain of PHI nodes for this block.  */\n   tree phi_nodes;\n \n@@ -267,6 +262,19 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   int flags;\n };\n \n+struct rtl_bb_info GTY(())\n+{\n+  /* The first and last insns of the block.  */\n+  rtx head_;\n+  rtx end_;\n+\n+  /* The registers that are live on entry to this block.  */\n+  bitmap GTY ((skip (\"\"))) global_live_at_start;\n+\n+  /* The registers that are live on exit from this block.  */\n+  bitmap GTY ((skip (\"\"))) global_live_at_end;\n+};\n+\n typedef struct basic_block_def *basic_block;\n \n /* Structure to hold information about the blocks during reordering and\n@@ -325,7 +333,10 @@ enum\n   BB_COLD_PARTITION = 128,\n \n   /* Set on block that was duplicated.  */\n-  BB_DUPLICATED = 256\n+  BB_DUPLICATED = 256,\n+\n+  /* Set on blocks that are in RTL format.  */\n+  BB_RTL = 1024\n };\n \n /* Dummy flag for convenience in the hot/cold partitioning code.  */\n@@ -455,8 +466,8 @@ extern bitmap_obstack reg_obstack;\n \f\n /* Stuff for recording basic block info.  */\n \n-#define BB_HEAD(B)      (B)->head_\n-#define BB_END(B)       (B)->end_\n+#define BB_HEAD(B)      (B)->il.rtl->head_\n+#define BB_END(B)       (B)->il.rtl->end_\n \n /* Special block numbers [markers] for entry and exit.  */\n #define ENTRY_BLOCK (-1)\n@@ -976,6 +987,7 @@ extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n extern void break_superblocks (void);\n extern void check_bb_profile (basic_block, FILE *);\n extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n+extern void init_rtl_bb_info (basic_block);\n \n extern void initialize_original_copy_tables (void);\n extern void free_original_copy_tables (void);"}, {"sha": "2266ce50f5e00eb7f2347577ea49fc532e8fb805", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1603,12 +1603,12 @@ fix_crossing_conditional_branches (void)\n \t\t  \n \t\t  /* Update register liveness information.  */\n \t\t  \n-\t\t  new_bb->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-\t\t  new_bb->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-\t\t  COPY_REG_SET (new_bb->global_live_at_end,\n-\t\t\t\tprev_bb->global_live_at_end);\n-\t\t  COPY_REG_SET (new_bb->global_live_at_start,\n-\t\t\t\tprev_bb->global_live_at_end);\n+\t\t  new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n+\t\t  new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n+\t\t  COPY_REG_SET (new_bb->il.rtl->global_live_at_end,\n+\t\t\t\tprev_bb->il.rtl->global_live_at_end);\n+\t\t  COPY_REG_SET (new_bb->il.rtl->global_live_at_start,\n+\t\t\t\tprev_bb->il.rtl->global_live_at_end);\n \t\t  \n \t\t  /* Put appropriate instructions in new bb.  */\n \t\t  "}, {"sha": "ab3f97e03dc8527b9dec4a058ad7b2c5a68ea47a", "filename": "gcc/bt-load.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -476,7 +476,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n       CLEAR_HARD_REG_SET (info.btrs_written_in_block);\n       for (reg = first_btr; reg <= last_btr; reg++)\n \tif (TEST_HARD_REG_BIT (all_btrs, reg)\n-\t    && REGNO_REG_SET_P (bb->global_live_at_start, reg))\n+\t    && REGNO_REG_SET_P (bb->il.rtl->global_live_at_start, reg))\n \t  SET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n \n       for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n@@ -577,7 +577,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n       COPY_HARD_REG_SET (btrs_live[i], info.btrs_live_in_block);\n       COPY_HARD_REG_SET (btrs_written[i], info.btrs_written_in_block);\n \n-      REG_SET_TO_HARD_REG_SET (btrs_live_at_end[i], bb->global_live_at_end);\n+      REG_SET_TO_HARD_REG_SET (btrs_live_at_end[i], bb->il.rtl->global_live_at_end);\n       /* If this block ends in a jump insn, add any uses or even clobbers\n \t of branch target registers that it might have.  */\n       for (insn = BB_END (bb); insn != BB_HEAD (bb) && ! INSN_P (insn); )"}, {"sha": "4add5df87623925b6237aeb4db7d96e798a57cd6", "filename": "gcc/cfg.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -421,7 +421,8 @@ clear_bb_flags (void)\n   basic_block bb;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    bb->flags = BB_PARTITION (bb)  | (bb->flags & BB_DISABLE_SCHEDULE);\n+    bb->flags = (BB_PARTITION (bb)  | (bb->flags & BB_DISABLE_SCHEDULE)\n+\t\t | (bb->flags & BB_RTL));\n }\n \f\n /* Check the consistency of profile information.  We can't do that\n@@ -553,16 +554,19 @@ dump_flow_info (FILE *file)\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tdump_edge_info (file, e, 1);\n \n-      if (bb->global_live_at_start)\n+      if (bb->flags & BB_RTL)\n \t{\n-\t  fprintf (file, \"\\nRegisters live at start:\");\n-\t  dump_regset (bb->global_live_at_start, file);\n-\t}\n-\n-      if (bb->global_live_at_end)\n-\t{\n-\t  fprintf (file, \"\\nRegisters live at end:\");\n-\t  dump_regset (bb->global_live_at_end, file);\n+\t  if (bb->il.rtl->global_live_at_start)\n+\t    {\n+\t      fprintf (file, \"\\nRegisters live at start:\");\n+\t      dump_regset (bb->il.rtl->global_live_at_start, file);\n+\t    }\n+\n+\t  if (bb->il.rtl->global_live_at_end)\n+\t    {\n+\t      fprintf (file, \"\\nRegisters live at end:\");\n+\t      dump_regset (bb->il.rtl->global_live_at_end, file);\n+\t    }\n \t}\n \n       putc ('\\n', file);"}, {"sha": "fd8a12940756c8932a487fff65e466b89b9ee555", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -395,7 +395,7 @@ thread_jump (int mode, edge e, basic_block b)\n   /* In case liveness information is available, we need to prove equivalence\n      only of the live values.  */\n   if (mode & CLEANUP_UPDATE_LIFE)\n-    AND_REG_SET (nonequal, b->global_live_at_end);\n+    AND_REG_SET (nonequal, b->il.rtl->global_live_at_end);\n \n   EXECUTE_IF_SET_IN_REG_SET (nonequal, 0, i, rsi)\n     goto failed_exit;"}, {"sha": "d3acbb0a3a92915d75e485757c0813efe94666fb", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1056,6 +1056,9 @@ expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n \t       bb->index);\n     }\n \n+  init_rtl_bb_info (bb);\n+  bb->flags |= BB_RTL;\n+\n   if (!bsi_end_p (bsi))\n     stmt = bsi_stmt (bsi);\n \n@@ -1162,6 +1165,10 @@ construct_init_block (void)\n \n   /* Multiple entry points not supported yet.  */\n   gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR->succs) == 1);\n+  init_rtl_bb_info (ENTRY_BLOCK_PTR);\n+  init_rtl_bb_info (EXIT_BLOCK_PTR);\n+  ENTRY_BLOCK_PTR->flags |= BB_RTL;\n+  EXIT_BLOCK_PTR->flags |= BB_RTL;\n \n   e = EDGE_SUCC (ENTRY_BLOCK_PTR, 0);\n "}, {"sha": "d684cc729ccd58df07d445b025ee344aa4a3ef08", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -545,7 +545,6 @@ merge_blocks (basic_block a, basic_block b)\n \n   /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n   b->preds = b->succs = NULL;\n-  a->global_live_at_end = b->global_live_at_end;\n \n   if (dom_computed[CDI_DOMINATORS])\n     redirect_immediate_dominators (CDI_DOMINATORS, b, a);"}, {"sha": "4eda4f40a75050d553335438a567f2489f973e84", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1074,12 +1074,14 @@ cfg_layout_duplicate_bb (basic_block bb)\n \tnew_bb->rbi->footer = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n-  if (bb->global_live_at_start)\n+  if (bb->il.rtl->global_live_at_start)\n     {\n-      new_bb->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      new_bb->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (new_bb->global_live_at_start, bb->global_live_at_start);\n-      COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n+      new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n+      new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n+      COPY_REG_SET (new_bb->il.rtl->global_live_at_start,\n+\t\t    bb->il.rtl->global_live_at_start);\n+      COPY_REG_SET (new_bb->il.rtl->global_live_at_end,\n+\t\t    bb->il.rtl->global_live_at_end);\n     }\n \n   return new_bb;"}, {"sha": "51c86dbb66be981c56209dc6b96d2a4e0692ddab", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -58,6 +58,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n #include \"target.h\"\n #include \"cfgloop.h\"\n+#include \"ggc.h\"\n \n static int can_delete_note_p (rtx);\n static int can_delete_label_p (rtx);\n@@ -273,6 +274,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n \n       bb = alloc_block ();\n \n+      init_rtl_bb_info (bb);\n       if (!head && !end)\n \thead = end = bb_note\n \t  = emit_note_after (NOTE_INSN_BASIC_BLOCK, get_last_insn ());\n@@ -300,7 +302,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n   BB_HEAD (bb) = head;\n   BB_END (bb) = end;\n   bb->index = last_basic_block++;\n-  bb->flags = BB_NEW;\n+  bb->flags = BB_NEW | BB_RTL;\n   link_block (bb, after);\n   BASIC_BLOCK (bb->index) = bb;\n   update_bb_for_insn (bb);\n@@ -478,21 +480,21 @@ rtl_split_block (basic_block bb, void *insnp)\n   FOR_EACH_EDGE (e, ei, new_bb->succs)\n     e->src = new_bb;\n \n-  if (bb->global_live_at_start)\n+  if (bb->il.rtl->global_live_at_start)\n     {\n-      new_bb->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      new_bb->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n+      new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n+      new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n+      COPY_REG_SET (new_bb->il.rtl->global_live_at_end, bb->il.rtl->global_live_at_end);\n \n       /* We now have to calculate which registers are live at the end\n \t of the split basic block and at the start of the new basic\n \t block.  Start with those registers that are known to be live\n \t at the end of the original basic block and get\n \t propagate_block to determine which registers are live.  */\n-      COPY_REG_SET (new_bb->global_live_at_start, bb->global_live_at_end);\n-      propagate_block (new_bb, new_bb->global_live_at_start, NULL, NULL, 0);\n-      COPY_REG_SET (bb->global_live_at_end,\n-\t\t    new_bb->global_live_at_start);\n+      COPY_REG_SET (new_bb->il.rtl->global_live_at_start, bb->il.rtl->global_live_at_end);\n+      propagate_block (new_bb, new_bb->il.rtl->global_live_at_start, NULL, NULL, 0);\n+      COPY_REG_SET (bb->il.rtl->global_live_at_end,\n+\t\t    new_bb->il.rtl->global_live_at_start);\n #ifdef HAVE_conditional_execution\n       /* In the presence of conditional execution we are not able to update\n \t liveness precisely.  */\n@@ -593,6 +595,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n     }\n \n   BB_END (a) = a_end;\n+  a->il.rtl->global_live_at_end = b->il.rtl->global_live_at_end;\n }\n \n /* Return true when block A and B can be merged.  */\n@@ -1083,14 +1086,14 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n       jump_block->frequency = EDGE_FREQUENCY (e);\n       jump_block->loop_depth = target->loop_depth;\n \n-      if (target->global_live_at_start)\n+      if (target->il.rtl->global_live_at_start)\n \t{\n-\t  jump_block->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-\t  jump_block->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-\t  COPY_REG_SET (jump_block->global_live_at_start,\n-\t\t\ttarget->global_live_at_start);\n-\t  COPY_REG_SET (jump_block->global_live_at_end,\n-\t\t\ttarget->global_live_at_start);\n+\t  jump_block->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n+\t  jump_block->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n+\t  COPY_REG_SET (jump_block->il.rtl->global_live_at_start,\n+\t\t\ttarget->il.rtl->global_live_at_start);\n+\t  COPY_REG_SET (jump_block->il.rtl->global_live_at_end,\n+\t\t\ttarget->il.rtl->global_live_at_start);\n \t}\n \n       /* Make sure new block ends up in correct hot/cold section.  */\n@@ -1351,14 +1354,14 @@ rtl_split_edge (edge edge_in)\n     }\n \n   /* ??? This info is likely going to be out of date very soon.  */\n-  if (edge_in->dest->global_live_at_start)\n+  if (edge_in->dest->il.rtl->global_live_at_start)\n     {\n-      bb->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      bb->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (bb->global_live_at_start,\n-\t\t    edge_in->dest->global_live_at_start);\n-      COPY_REG_SET (bb->global_live_at_end,\n-\t\t    edge_in->dest->global_live_at_start);\n+      bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n+      bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n+      COPY_REG_SET (bb->il.rtl->global_live_at_start,\n+\t\t    edge_in->dest->il.rtl->global_live_at_start);\n+      COPY_REG_SET (bb->il.rtl->global_live_at_end,\n+\t\t    edge_in->dest->il.rtl->global_live_at_start);\n     }\n \n   make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n@@ -1457,7 +1460,7 @@ safe_insert_insn_on_edge (rtx insn, edge e)\n \t&& !REGNO_PTR_FRAME_P (regno))\n       SET_REGNO_REG_SET (killed, regno);\n \n-  bitmap_and_into (killed, e->dest->global_live_at_start);\n+  bitmap_and_into (killed, e->dest->il.rtl->global_live_at_start);\n \n   EXECUTE_IF_SET_IN_REG_SET (killed, 0, regno, rsi)\n     {\n@@ -1760,15 +1763,15 @@ rtl_dump_bb (basic_block bb, FILE *outf, int indent)\n   s_indent[indent] = '\\0';\n \n   fprintf (outf, \";;%s Registers live at start: \", s_indent);\n-  dump_regset (bb->global_live_at_start, outf);\n+  dump_regset (bb->il.rtl->global_live_at_start, outf);\n   putc ('\\n', outf);\n \n   for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;\n        insn = NEXT_INSN (insn))\n     print_rtl_single (outf, insn);\n \n   fprintf (outf, \";;%s Registers live at end: \", s_indent);\n-  dump_regset (bb->global_live_at_end, outf);\n+  dump_regset (bb->il.rtl->global_live_at_end, outf);\n   putc ('\\n', outf);\n }\n \f\n@@ -1819,7 +1822,7 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n \t    {\n \t      fprintf (outf, \";; Start of basic block %d, registers live:\",\n \t\t       bb->index);\n-\t      dump_regset (bb->global_live_at_start, outf);\n+\t      dump_regset (bb->il.rtl->global_live_at_start, outf);\n \t      putc ('\\n', outf);\n \t    }\n \n@@ -1836,7 +1839,7 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n \t    {\n \t      fprintf (outf, \";; End of basic block %d, registers live:\\n\",\n \t\t       bb->index);\n-\t      dump_regset (bb->global_live_at_end, outf);\n+\t      dump_regset (bb->il.rtl->global_live_at_end, outf);\n \t      putc ('\\n', outf);\n \t    }\n \n@@ -1908,6 +1911,12 @@ rtl_verify_flow_info_1 (void)\n \tif (x == end)\n \t  break;\n \n+      if (!(bb->flags & BB_RTL))\n+\t{\n+\t  error (\"BB_RTL flag not set for block %d\", bb->index);\n+\t  err = 1;\n+\t}\n+\n       if (!x)\n \t{\n \t  error (\"end insn %d for block %d not found in the insn stream\",\n@@ -2775,6 +2784,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n \t}\n       b->rbi->footer = NULL;\n     }\n+  a->il.rtl->global_live_at_end = b->il.rtl->global_live_at_end;\n \n   if (dump_file)\n     fprintf (dump_file, \"Merged blocks %d and %d.\\n\",\n@@ -2793,14 +2803,14 @@ cfg_layout_split_edge (edge e)\n \n   /* ??? This info is likely going to be out of date very soon, but we must\n      create it to avoid getting an ICE later.  */\n-  if (e->dest->global_live_at_start)\n+  if (e->dest->il.rtl->global_live_at_start)\n     {\n-      new_bb->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      new_bb->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (new_bb->global_live_at_start,\n-\t\t    e->dest->global_live_at_start);\n-      COPY_REG_SET (new_bb->global_live_at_end,\n-\t\t    e->dest->global_live_at_start);\n+      new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n+      new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n+      COPY_REG_SET (new_bb->il.rtl->global_live_at_start,\n+\t\t    e->dest->il.rtl->global_live_at_start);\n+      COPY_REG_SET (new_bb->il.rtl->global_live_at_end,\n+\t\t    e->dest->il.rtl->global_live_at_start);\n     }\n \n   make_edge (new_bb, e->dest, EDGE_FALLTHRU);\n@@ -3047,6 +3057,13 @@ rtl_extract_cond_bb_edges (basic_block b, edge *branch_edge,\n     }\n }\n \n+void\n+init_rtl_bb_info (basic_block bb)\n+{\n+  gcc_assert (!bb->il.rtl);\n+  bb->il.rtl = ggc_alloc_cleared (sizeof (struct rtl_bb_info));\n+}\n+\n \n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {"}, {"sha": "d618c9fcf5ce1e8b46c8f78aba7f0cd7cecfec7f", "filename": "gcc/combine.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -985,7 +985,8 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n-      && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, REGNO (x))\n+      && ! REGNO_REG_SET_P\n+         (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start, REGNO (x))\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n@@ -8278,8 +8279,9 @@ reg_nonzero_bits_for_combine (rtx x, enum machine_mode mode,\n       && (reg_stat[REGNO (x)].last_set_label == label_tick\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n-\t      && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n-\t\t\t\t    REGNO (x))))\n+\t      && ! REGNO_REG_SET_P\n+\t         (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n+\t\t  REGNO (x))))\n       && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n     {\n       *nonzero &= reg_stat[REGNO (x)].last_set_nonzero_bits;\n@@ -8345,8 +8347,9 @@ reg_num_sign_bit_copies_for_combine (rtx x, enum machine_mode mode,\n       && (reg_stat[REGNO (x)].last_set_label == label_tick\n           || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n-\t      && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n-\t\t\t\t    REGNO (x))))\n+\t      && ! REGNO_REG_SET_P\n+\t         (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n+\t\t  REGNO (x))))\n       && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n     {\n       *result = reg_stat[REGNO (x)].last_set_sign_bit_copies;\n@@ -11180,7 +11183,8 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n \t    || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t   && REG_N_SETS (regno) == 1\n \t\t   && (! REGNO_REG_SET_P\n-\t\t       (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno)))\n+\t\t       (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n+\t\t\tregno)))\n \t\t&& reg_stat[j].last_set_label > tick))\n \t  {\n \t    if (replace)\n@@ -11290,7 +11294,8 @@ get_last_value (rtx x)\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n \t      || (REGNO_REG_SET_P\n-\t\t  (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno)))))\n+\t\t  (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n+\t\t   regno)))))\n     return 0;\n \n   /* If the value was set in a later insn than the ones we are processing,\n@@ -11451,7 +11456,7 @@ reg_dead_at_p (rtx reg, rtx insn)\n     }\n \n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n-    if (REGNO_REG_SET_P (block->global_live_at_start, i))\n+    if (REGNO_REG_SET_P (block->il.rtl->global_live_at_start, i))\n       return 0;\n \n   return 1;\n@@ -12218,7 +12223,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t was dead, there's nothing left to do.  Otherwise, we'll\n \t\t need to do a global life update after combine.  */\n \t      if (REG_NOTE_KIND (note) == REG_DEAD && place == 0\n-\t\t  && REGNO_REG_SET_P (bb->global_live_at_start,\n+\t\t  && REGNO_REG_SET_P (bb->il.rtl->global_live_at_start,\n \t\t\t\t      REGNO (XEXP (note, 0))))\n \t\tSET_BIT (refresh_blocks, this_basic_block->index);\n \t    }"}, {"sha": "f03014686317fef6946ca451369d9cb77ff4db79", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -5265,13 +5265,15 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n       for (j = CC_FIRST; j <= CC_LAST; j++)\n \tif (TEST_HARD_REG_BIT (tmp_reg->regs, j))\n \t  {\n-\t    if (REGNO_REG_SET_P (then_bb->global_live_at_start, j))\n+\t    if (REGNO_REG_SET_P (then_bb->il.rtl->global_live_at_start, j))\n \t      continue;\n \n-\t    if (else_bb && REGNO_REG_SET_P (else_bb->global_live_at_start, j))\n+\t    if (else_bb\n+\t\t&& REGNO_REG_SET_P (else_bb->il.rtl->global_live_at_start, j))\n \t      continue;\n \n-\t    if (join_bb && REGNO_REG_SET_P (join_bb->global_live_at_start, j))\n+\t    if (join_bb\n+\t\t&& REGNO_REG_SET_P (join_bb->il.rtl->global_live_at_start, j))\n \t      continue;\n \n \t    SET_HARD_REG_BIT (frv_ifcvt.nested_cc_ok_rewrite, j);\n@@ -5293,7 +5295,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n       /* Remove anything live at the beginning of the join block from being\n          available for allocation.  */\n-      EXECUTE_IF_SET_IN_REG_SET (join_bb->global_live_at_start, 0, regno, rsi)\n+      EXECUTE_IF_SET_IN_REG_SET (join_bb->il.rtl->global_live_at_start, 0, regno, rsi)\n \t{\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n@@ -5337,7 +5339,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n       /* Anything live at the beginning of the block is obviously unavailable\n          for allocation.  */\n-      EXECUTE_IF_SET_IN_REG_SET (bb[j]->global_live_at_start, 0, regno, rsi)\n+      EXECUTE_IF_SET_IN_REG_SET (bb[j]->il.rtl->global_live_at_start, 0, regno, rsi)\n \t{\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n@@ -5991,15 +5993,15 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n \t\t  severely.  */\n \t       && ce_info->join_bb\n \t       && ! (REGNO_REG_SET_P\n-\t\t     (ce_info->join_bb->global_live_at_start,\n+\t\t     (ce_info->join_bb->il.rtl->global_live_at_start,\n \t\t      REGNO (SET_DEST (set))))\n \t       /* Similarly, we must not unconditionally set a reg\n \t\t  used as scratch in the THEN branch if the same reg\n \t\t  is live in the ELSE branch.  */\n \t       && (! ce_info->else_bb\n \t\t   || BLOCK_FOR_INSN (insn) == ce_info->else_bb\n \t\t   || ! (REGNO_REG_SET_P\n-\t\t\t (ce_info->else_bb->global_live_at_start,\n+\t\t\t (ce_info->else_bb->il.rtl->global_live_at_start,\n \t\t\t  REGNO (SET_DEST (set))))))\n \tpattern = set;\n "}, {"sha": "9ced83123d8af2eaee654d84cf705a9bc375f0f9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1920,7 +1920,7 @@ ix86_eax_live_at_start_p (void)\n      to correct at this point.  This gives false positives for broken\n      functions that might use uninitialized data that happens to be\n      allocated in eax, but who cares?  */\n-  return REGNO_REG_SET_P (ENTRY_BLOCK_PTR->global_live_at_end, 0);\n+  return REGNO_REG_SET_P (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end, 0);\n }\n \n /* Value is the number of bytes of arguments automatically"}, {"sha": "dc701e4dc58c1d4bf634a4abbe1384c6cc5dd966", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -7417,7 +7417,7 @@ emit_predicate_relation_info (void)\n       /* Skip p0, which may be thought to be live due to (reg:DI p0)\n \t grabbing the entire block of predicate registers.  */\n       for (r = PR_REG (2); r < PR_REG (64); r += 2)\n-\tif (REGNO_REG_SET_P (bb->global_live_at_start, r))\n+\tif (REGNO_REG_SET_P (bb->il.rtl->global_live_at_start, r))\n \t  {\n \t    rtx p = gen_rtx_REG (BImode, r);\n \t    rtx n = emit_insn_after (gen_pred_rel_mutex (p), head);"}, {"sha": "0577cd0e74b292373e5e40801b339c5c06e74e2a", "filename": "gcc/flow.c", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -416,7 +416,7 @@ life_analysis (FILE *file, int flags)\n   allocate_bb_life_data ();\n \n   /* Find the set of registers live on function exit.  */\n-  mark_regs_live_at_end (EXIT_BLOCK_PTR->global_live_at_start);\n+  mark_regs_live_at_end (EXIT_BLOCK_PTR->il.rtl->global_live_at_start);\n \n   /* \"Update\" life info from zero.  It'd be nice to begin the\n      relaxation with just the exit and noreturn blocks, but that set\n@@ -504,7 +504,8 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n     {\n       /* After reload, there are no pseudos, nor subregs of multi-word\n \t registers.  The regsets should exactly match.  */\n-      if (! REG_SET_EQUAL_P (new_live_at_start, bb->global_live_at_start))\n+      if (! REG_SET_EQUAL_P (new_live_at_start,\n+\t    \t\t     bb->il.rtl->global_live_at_start))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -524,12 +525,12 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n       reg_set_iterator rsi;\n \n       /* Find the set of changed registers.  */\n-      XOR_REG_SET (new_live_at_start, bb->global_live_at_start);\n+      XOR_REG_SET (new_live_at_start, bb->il.rtl->global_live_at_start);\n \n       EXECUTE_IF_SET_IN_REG_SET (new_live_at_start, 0, i, rsi)\n \t{\n \t  /* No registers should die.  */\n-\t  if (REGNO_REG_SET_P (bb->global_live_at_start, i))\n+\t  if (REGNO_REG_SET_P (bb->il.rtl->global_live_at_start, i))\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -608,7 +609,7 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \t     in turn may allow for further dead code detection / removal.  */\n \t  FOR_EACH_BB_REVERSE (bb)\n \t    {\n-\t      COPY_REG_SET (tmp, bb->global_live_at_end);\n+\t      COPY_REG_SET (tmp, bb->il.rtl->global_live_at_end);\n \t      changed |= propagate_block (bb, tmp, NULL, NULL,\n \t\t\t\tprop_flags & (PROP_SCAN_DEAD_CODE\n \t\t\t\t\t      | PROP_SCAN_DEAD_STORES\n@@ -637,8 +638,8 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \t     in the code being marked live at entry.  */\n \t  FOR_EACH_BB (bb)\n \t    {\n-\t      CLEAR_REG_SET (bb->global_live_at_start);\n-\t      CLEAR_REG_SET (bb->global_live_at_end);\n+\t      CLEAR_REG_SET (bb->il.rtl->global_live_at_start);\n+\t      CLEAR_REG_SET (bb->il.rtl->global_live_at_end);\n \t    }\n \t}\n \n@@ -659,7 +660,7 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \t{\n \t  bb = BASIC_BLOCK (i);\n \n-\t  COPY_REG_SET (tmp, bb->global_live_at_end);\n+\t  COPY_REG_SET (tmp, bb->il.rtl->global_live_at_end);\n \t  propagate_block (bb, tmp, NULL, NULL, stabilized_prop_flags);\n \n \t  if (extent == UPDATE_LIFE_LOCAL)\n@@ -670,7 +671,7 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n     {\n       FOR_EACH_BB_REVERSE (bb)\n \t{\n-\t  COPY_REG_SET (tmp, bb->global_live_at_end);\n+\t  COPY_REG_SET (tmp, bb->il.rtl->global_live_at_end);\n \n \t  propagate_block (bb, tmp, NULL, NULL, stabilized_prop_flags);\n \n@@ -689,7 +690,7 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \t are those that were not set anywhere in the function.  local-alloc\n \t doesn't know how to handle these correctly, so mark them as not\n \t local to any one basic block.  */\n-      EXECUTE_IF_SET_IN_REG_SET (ENTRY_BLOCK_PTR->global_live_at_end,\n+      EXECUTE_IF_SET_IN_REG_SET (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end,\n \t\t\t\t FIRST_PSEUDO_REGISTER, i, rsi)\n \tREG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n \n@@ -767,9 +768,9 @@ free_basic_block_vars (void)\n   label_to_block_map = NULL;\n \n   ENTRY_BLOCK_PTR->aux = NULL;\n-  ENTRY_BLOCK_PTR->global_live_at_end = NULL;\n+  ENTRY_BLOCK_PTR->il.rtl->global_live_at_end = NULL;\n   EXIT_BLOCK_PTR->aux = NULL;\n-  EXIT_BLOCK_PTR->global_live_at_start = NULL;\n+  EXIT_BLOCK_PTR->il.rtl->global_live_at_start = NULL;\n }\n \n /* Delete any insns that copy a register to itself.  */\n@@ -1186,10 +1187,10 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t       confused by sibling call edges, which crashes reg-stack.  */\n \t    if (e->flags & EDGE_EH)\n \t      bitmap_ior_and_compl_into (new_live_at_end,\n-\t\t\t\t\t sb->global_live_at_start,\n+\t\t\t\t\t sb->il.rtl->global_live_at_start,\n \t\t\t\t\t invalidated_by_call);\n \t    else\n-\t      IOR_REG_SET (new_live_at_end, sb->global_live_at_start);\n+\t      IOR_REG_SET (new_live_at_end, sb->il.rtl->global_live_at_start);\n \n \t    /* If a target saves one register in another (instead of on\n \t       the stack) the save register will need to be live for EH.  */\n@@ -1236,7 +1237,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \n       if (bb == ENTRY_BLOCK_PTR)\n \t{\n-\t  COPY_REG_SET (bb->global_live_at_end, new_live_at_end);\n+\t  COPY_REG_SET (bb->il.rtl->global_live_at_end, new_live_at_end);\n \t  continue;\n \t}\n \n@@ -1259,7 +1260,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t     rescan the block.  This wouldn't be necessary if we had\n \t     precalculated local_live, however with PROP_SCAN_DEAD_CODE\n \t     local_live is really dependent on live_at_end.  */\n-\t  rescan = bitmap_intersect_compl_p (bb->global_live_at_end,\n+\t  rescan = bitmap_intersect_compl_p (bb->il.rtl->global_live_at_end,\n \t\t\t\t\t     new_live_at_end);\n \n \t  if (!rescan)\n@@ -1284,7 +1285,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \n \t      /* Find the set of changed bits.  Take this opportunity\n \t\t to notice that this set is empty and early out.  */\n-\t      bitmap_xor (tmp, bb->global_live_at_end, new_live_at_end);\n+\t      bitmap_xor (tmp, bb->il.rtl->global_live_at_end, new_live_at_end);\n \t      if (bitmap_empty_p (tmp))\n \t\tcontinue;\n   \n@@ -1305,16 +1306,16 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t  /* Add to live_at_start the set of all registers in\n \t     new_live_at_end that aren't in the old live_at_end.  */\n \t  \n-\t  changed = bitmap_ior_and_compl_into (bb->global_live_at_start,\n+\t  changed = bitmap_ior_and_compl_into (bb->il.rtl->global_live_at_start,\n \t\t\t\t\t       new_live_at_end,\n-\t\t\t\t\t       bb->global_live_at_end);\n-\t  COPY_REG_SET (bb->global_live_at_end, new_live_at_end);\n+\t\t\t\t\t       bb->il.rtl->global_live_at_end);\n+\t  COPY_REG_SET (bb->il.rtl->global_live_at_end, new_live_at_end);\n \t  if (! changed)\n \t    continue;\n \t}\n       else\n \t{\n-\t  COPY_REG_SET (bb->global_live_at_end, new_live_at_end);\n+\t  COPY_REG_SET (bb->il.rtl->global_live_at_end, new_live_at_end);\n \n \t  /* Rescan the block insn by insn to turn (a copy of) live_at_end\n \t     into live_at_start.  */\n@@ -1324,14 +1325,15 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t\t\t   flags);\n \n \t  /* If live_at start didn't change, no need to go farther.  */\n-\t  if (REG_SET_EQUAL_P (bb->global_live_at_start, new_live_at_end))\n+\t  if (REG_SET_EQUAL_P (bb->il.rtl->global_live_at_start,\n+\t\t\t       new_live_at_end))\n \t    continue;\n \n \t  if (failure_strategy_required)\n \t    {\n \t      /* Get the list of registers that were removed from the\n \t         bb->global_live_at_start set.  */\n-\t      bitmap_and_compl (tmp, bb->global_live_at_start,\n+\t      bitmap_and_compl (tmp, bb->il.rtl->global_live_at_start,\n \t\t\t\tnew_live_at_end);\n \t      if (!bitmap_empty_p (tmp))\n \t\t{\n@@ -1350,11 +1352,13 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t\t      pbb_changed = false;\n \n \t\t      pbb_changed\n-\t\t\t|= bitmap_and_compl_into (pbb->global_live_at_start,\n-\t\t\t\t\t\t  registers_made_dead);\n+\t\t\t|= bitmap_and_compl_into\n+\t\t\t    (pbb->il.rtl->global_live_at_start,\n+\t\t\t     registers_made_dead);\n \t\t      pbb_changed\n-\t\t\t|= bitmap_and_compl_into (pbb->global_live_at_end,\n-\t\t\t\t\t\t  registers_made_dead);\n+\t\t\t|= bitmap_and_compl_into\n+\t\t\t    (pbb->il.rtl->global_live_at_end,\n+\t\t\t     registers_made_dead);\n \t\t      if (!pbb_changed)\n \t\t\tcontinue;\n \n@@ -1383,7 +1387,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t\t}\n \t    } /* end of failure_strategy_required */\n \n-\t  COPY_REG_SET (bb->global_live_at_start, new_live_at_end);\n+\t  COPY_REG_SET (bb->il.rtl->global_live_at_start, new_live_at_end);\n \t}\n \n       /* Queue all predecessors of BB so that we may re-examine\n@@ -1504,7 +1508,7 @@ initialize_uninitialized_subregs (void)\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     {\n       basic_block bb = e->dest;\n-      regset map = bb->global_live_at_start;\n+      regset map = bb->il.rtl->global_live_at_start;\n       reg_set_iterator rsi;\n \n       EXECUTE_IF_SET_IN_REG_SET (map, FIRST_PSEUDO_REGISTER, reg, rsi)\n@@ -1556,8 +1560,8 @@ allocate_bb_life_data (void)\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      bb->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      bb->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n+      bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n+      bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n     }\n \n   regs_live_at_setjmp = ALLOC_REG_SET (&reg_obstack);\n@@ -1856,7 +1860,7 @@ propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n \t     except for return values.  */\n \n \t  sibcall_p = SIBLING_CALL_P (insn);\n-\t  live_at_end = EXIT_BLOCK_PTR->global_live_at_start;\n+\t  live_at_end = EXIT_BLOCK_PTR->il.rtl->global_live_at_start;\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i)\n \t\t&& ! (sibcall_p\n@@ -1991,8 +1995,8 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t}\n \n       /* Compute which register lead different lives in the successors.  */\n-      bitmap_xor (diff, bb_true->global_live_at_start,\n-\t\t  bb_false->global_live_at_start);\n+      bitmap_xor (diff, bb_true->il.rtl->global_live_at_start,\n+\t\t  bb_false->il.rtl->global_live_at_start);\n       \n       if (!bitmap_empty_p (diff))\n \t  {\n@@ -2037,7 +2041,8 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \n \t\t  rcli = xmalloc (sizeof (*rcli));\n \n-\t\t  if (REGNO_REG_SET_P (bb_true->global_live_at_start, i))\n+\t\t  if (REGNO_REG_SET_P (bb_true->il.rtl->global_live_at_start,\n+\t\t\t\t       i))\n \t\t    cond = cond_false;\n \t\t  else\n \t\t    cond = cond_true;\n@@ -2468,7 +2473,8 @@ regno_clobbered_at_setjmp (int regno)\n     return 0;\n \n   return ((REG_N_SETS (regno) > 1\n-\t   || REGNO_REG_SET_P (ENTRY_BLOCK_PTR->global_live_at_end, regno))\n+\t   || REGNO_REG_SET_P (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end,\n+\t     \t\t       regno))\n \t  && REGNO_REG_SET_P (regs_live_at_setjmp, regno));\n }\n \f"}, {"sha": "74db519955f2e006cebef1e99b7064ecead9a29e", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -4702,8 +4702,8 @@ keep_stack_depressed (rtx insns)\n \t\tif (HARD_REGNO_MODE_OK (regno, Pmode)\n \t\t    && !fixed_regs[regno]\n \t\t    && TEST_HARD_REG_BIT (regs_invalidated_by_call, regno)\n-\t\t    && !REGNO_REG_SET_P (EXIT_BLOCK_PTR->global_live_at_start,\n-\t\t\t\t\t regno)\n+\t\t    && !REGNO_REG_SET_P\n+\t\t         (EXIT_BLOCK_PTR->il.rtl->global_live_at_start, regno)\n \t\t    && !refers_to_regno_p (regno,\n \t\t\t\t\t   regno + hard_regno_nregs[regno]\n \t\t\t\t\t\t\t\t   [Pmode],"}, {"sha": "8a048108a4833954a9c646727bb30abaae4760b1", "filename": "gcc/global.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -694,7 +694,7 @@ global_conflicts (void)\n \t be explicitly marked in basic_block_live_at_start.  */\n \n       {\n-\tregset old = b->global_live_at_start;\n+\tregset old = b->il.rtl->global_live_at_start;\n \tint ax = 0;\n \treg_set_iterator rsi;\n \n@@ -1726,7 +1726,7 @@ mark_elimination (int from, int to)\n \n   FOR_EACH_BB (bb)\n     {\n-      regset r = bb->global_live_at_start;\n+      regset r = bb->il.rtl->global_live_at_start;\n       if (REGNO_REG_SET_P (r, from))\n \t{\n \t  CLEAR_REGNO_REG_SET (r, from);\n@@ -1816,7 +1816,7 @@ build_insn_chain (rtx first)\n \n \t  CLEAR_REG_SET (live_relevant_regs);\n \n-\t  EXECUTE_IF_SET_IN_BITMAP (b->global_live_at_start, 0, i, bi)\n+\t  EXECUTE_IF_SET_IN_BITMAP (b->il.rtl->global_live_at_start, 0, i, bi)\n \t    {\n \t      if (i < FIRST_PSEUDO_REGISTER\n \t\t  ? ! TEST_HARD_REG_BIT (eliminable_regset, i)\n@@ -2345,10 +2345,10 @@ calculate_reg_pav (void)\n \t      if (pred->index != ENTRY_BLOCK)\n \t\tbitmap_ior_into (bb_live_pavin, BB_INFO (pred)->live_pavout);\n \t    }\n-\t  bitmap_and_into (bb_live_pavin, bb->global_live_at_start);\n+\t  bitmap_and_into (bb_live_pavin, bb->il.rtl->global_live_at_start);\n \t  bitmap_ior_and_compl (temp_bitmap, bb_info->avloc,\n \t\t\t\tbb_live_pavin, bb_info->killed);\n-\t  bitmap_and_into (temp_bitmap, bb->global_live_at_end);\n+\t  bitmap_and_into (temp_bitmap, bb->il.rtl->global_live_at_end);\n \t  if (! bitmap_equal_p (temp_bitmap, bb_live_pavout))\n \t    {\n \t      bitmap_copy (bb_live_pavout, temp_bitmap);\n@@ -2469,8 +2469,8 @@ make_accurate_live_analysis (void)\n     {\n       bb_info = BB_INFO (bb);\n       \n-      bitmap_and_into (bb->global_live_at_start, bb_info->live_pavin);\n-      bitmap_and_into (bb->global_live_at_end, bb_info->live_pavout);\n+      bitmap_and_into (bb->il.rtl->global_live_at_start, bb_info->live_pavin);\n+      bitmap_and_into (bb->il.rtl->global_live_at_end, bb_info->live_pavout);\n     }\n   free_bb_info ();\n }"}, {"sha": "4480f530260153079308f0dc918ff5f3a90139b1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -2364,9 +2364,9 @@ merge_if_block (struct ce_if_block * ce_info)\n \n   if (then_bb)\n     {\n-      if (combo_bb->global_live_at_end)\n-\tCOPY_REG_SET (combo_bb->global_live_at_end,\n-\t\t      then_bb->global_live_at_end);\n+      if (combo_bb->il.rtl->global_live_at_end)\n+\tCOPY_REG_SET (combo_bb->il.rtl->global_live_at_end,\n+\t\t      then_bb->il.rtl->global_live_at_end);\n       merge_blocks (combo_bb, then_bb);\n       num_true_changes++;\n     }\n@@ -2417,9 +2417,9 @@ merge_if_block (struct ce_if_block * ce_info)\n \t   && join_bb != EXIT_BLOCK_PTR)\n     {\n       /* We can merge the JOIN.  */\n-      if (combo_bb->global_live_at_end)\n-\tCOPY_REG_SET (combo_bb->global_live_at_end,\n-\t\t      join_bb->global_live_at_end);\n+      if (combo_bb->il.rtl->global_live_at_end)\n+\tCOPY_REG_SET (combo_bb->il.rtl->global_live_at_end,\n+\t\t      join_bb->il.rtl->global_live_at_end);\n \n       merge_blocks (combo_bb, join_bb);\n       num_true_changes++;\n@@ -3060,9 +3060,9 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   /* Conversion went ok, including moving the insns and fixing up the\n      jump.  Adjust the CFG to match.  */\n \n-  bitmap_ior (test_bb->global_live_at_end,\n-\t      else_bb->global_live_at_start,\n-\t      then_bb->global_live_at_end);\n+  bitmap_ior (test_bb->il.rtl->global_live_at_end,\n+\t      else_bb->il.rtl->global_live_at_start,\n+\t      then_bb->il.rtl->global_live_at_end);\n \n \n   /* We can avoid creating a new basic block if then_bb is immediately\n@@ -3178,9 +3178,9 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   /* Conversion went ok, including moving the insns and fixing up the\n      jump.  Adjust the CFG to match.  */\n \n-  bitmap_ior (test_bb->global_live_at_end,\n-\t      then_bb->global_live_at_start,\n-\t      else_bb->global_live_at_end);\n+  bitmap_ior (test_bb->il.rtl->global_live_at_end,\n+\t      then_bb->il.rtl->global_live_at_start,\n+\t      else_bb->il.rtl->global_live_at_end);\n \n   delete_basic_block (else_bb);\n \n@@ -3357,7 +3357,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       /* For TEST, we're interested in a range of insns, not a whole block.\n \t Moreover, we're interested in the insns live from OTHER_BB.  */\n \n-      COPY_REG_SET (test_live, other_bb->global_live_at_start);\n+      COPY_REG_SET (test_live, other_bb->il.rtl->global_live_at_start);\n       pbi = init_propagate_block_info (test_bb, test_live, test_set, test_set,\n \t\t\t\t       0);\n \n@@ -3373,12 +3373,13 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       /* We can perform the transformation if\n \t   MERGE_SET & (TEST_SET | TEST_LIVE)\n \t and\n-\t   TEST_SET & merge_bb->global_live_at_start\n+\t   TEST_SET & merge_bb->il.rtl->global_live_at_start\n \t are empty.  */\n \n       if (bitmap_intersect_p (test_set, merge_set)\n \t  || bitmap_intersect_p (test_live, merge_set)\n-\t  || bitmap_intersect_p (test_set, merge_bb->global_live_at_start))\n+\t  || bitmap_intersect_p (test_set,\n+\t    \t\t\t merge_bb->il.rtl->global_live_at_start))\n \tfail = 1;\n \n       FREE_REG_SET (tmp);"}, {"sha": "b993d35b474ca86be1ec9c0531a85694fea3d0e4", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1193,8 +1193,10 @@ update_equiv_regs (void)\n \t{\n \t  FOR_EACH_BB (bb)\n \t    {\n-\t      AND_COMPL_REG_SET (bb->global_live_at_start, &cleared_regs);\n-\t      AND_COMPL_REG_SET (bb->global_live_at_end, &cleared_regs);\n+\t      AND_COMPL_REG_SET (bb->il.rtl->global_live_at_start,\n+\t\t\t         &cleared_regs);\n+\t      AND_COMPL_REG_SET (bb->il.rtl->global_live_at_end,\n+\t\t\t         &cleared_regs);\n \t    }\n \t}\n       else\n@@ -1204,8 +1206,8 @@ update_equiv_regs (void)\n \t    {\n \t      FOR_EACH_BB (bb)\n \t\t{\n-\t\t  CLEAR_REGNO_REG_SET (bb->global_live_at_start, j);\n-\t\t  CLEAR_REGNO_REG_SET (bb->global_live_at_end, j);\n+\t\t  CLEAR_REGNO_REG_SET (bb->il.rtl->global_live_at_start, j);\n+\t\t  CLEAR_REGNO_REG_SET (bb->il.rtl->global_live_at_end, j);\n \t\t}\n \t    }\n \t}\n@@ -1287,7 +1289,8 @@ block_alloc (int b)\n \n   /* Initialize table of hardware registers currently live.  */\n \n-  REG_SET_TO_HARD_REG_SET (regs_live, BASIC_BLOCK (b)->global_live_at_start);\n+  REG_SET_TO_HARD_REG_SET (regs_live,\n+\t\t  \t   BASIC_BLOCK (b)->il.rtl->global_live_at_start);\n \n   /* This loop scans the instructions of the basic block\n      and assigns quantities to registers."}, {"sha": "968061c2482e6e445f4aa0711d4092c7b327cd48", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -219,7 +219,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n     if (eg->flags & EDGE_FALLTHRU)\n       {\n \tbasic_block src_bb = eg->src;\n-\tregset live_at_end = src_bb->global_live_at_end;\n+\tregset live_at_end = src_bb->il.rtl->global_live_at_end;\n \trtx last_insn, ret_reg;\n \n \tgcc_assert (!pre_exit);\n@@ -368,8 +368,8 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \telse\n \t  {\n \t    pre_exit = split_edge (eg);\n-\t    COPY_REG_SET (pre_exit->global_live_at_start, live_at_end);\n-\t    COPY_REG_SET (pre_exit->global_live_at_end, live_at_end);\n+\t    COPY_REG_SET (pre_exit->il.rtl->global_live_at_start, live_at_end);\n+\t    COPY_REG_SET (pre_exit->il.rtl->global_live_at_end, live_at_end);\n \t  }\n       }\n \n@@ -453,7 +453,7 @@ optimize_mode_switching (FILE *file)\n \t  HARD_REG_SET live_now;\n \n \t  REG_SET_TO_HARD_REG_SET (live_now,\n-\t\t\t\t   bb->global_live_at_start);\n+\t\t\t\t   bb->il.rtl->global_live_at_start);\n \t  for (insn = BB_HEAD (bb);\n \t       insn != NULL && insn != NEXT_INSN (BB_END (bb));\n \t       insn = NEXT_INSN (insn))\n@@ -583,7 +583,7 @@ optimize_mode_switching (FILE *file)\n \t      src_bb = eg->src;\n \n \t      REG_SET_TO_HARD_REG_SET (live_at_edge,\n-\t\t\t\t       src_bb->global_live_at_end);\n+\t\t\t\t       src_bb->il.rtl->global_live_at_end);\n \n \t      start_sequence ();\n \t      EMIT_MODE_SET (entity_map[j], mode, live_at_edge);"}, {"sha": "d469b89f42737363235fe8e426724e3940664eff", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -739,9 +739,9 @@ reload_combine (void)\n \t  HARD_REG_SET live;\n \n \t  REG_SET_TO_HARD_REG_SET (live,\n-\t\t\t\t   bb->global_live_at_start);\n+\t\t\t\t   bb->il.rtl->global_live_at_start);\n \t  compute_use_by_pseudos (&live,\n-\t\t\t\t  bb->global_live_at_start);\n+\t\t\t\t  bb->il.rtl->global_live_at_start);\n \t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n \t  IOR_HARD_REG_SET (ever_live_at_start, live);\n \t}"}, {"sha": "2095ca018f6e1928fe17184fe30d0ce093174de9", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -3066,7 +3066,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n       peep2_current = MAX_INSNS_PER_PEEP2;\n \n       /* Start up propagation.  */\n-      COPY_REG_SET (live, bb->global_live_at_end);\n+      COPY_REG_SET (live, bb->il.rtl->global_live_at_end);\n       COPY_REG_SET (peep2_insn_data[MAX_INSNS_PER_PEEP2].live_before, live);\n \n #ifdef HAVE_conditional_execution\n@@ -3278,7 +3278,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \n       /* Some peepholes can decide the don't need one or more of their\n \t inputs.  If this happens, local life update is not enough.  */\n-      EXECUTE_IF_AND_COMPL_IN_BITMAP (bb->global_live_at_start, live,\n+      EXECUTE_IF_AND_COMPL_IN_BITMAP (bb->il.rtl->global_live_at_start, live,\n \t\t\t\t      0, j, rsi)\n \t{\n \t  do_global_life_update = true;"}, {"sha": "e37539349524f7e7e482a28f91beb02c531bd6cb", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -3077,9 +3077,9 @@ reg_to_stack (FILE *file)\n       /* Copy live_at_end and live_at_start into temporaries.  */\n       for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n \t{\n-\t  if (REGNO_REG_SET_P (bb->global_live_at_end, reg))\n+\t  if (REGNO_REG_SET_P (bb->il.rtl->global_live_at_end, reg))\n \t    SET_HARD_REG_BIT (bi->out_reg_set, reg);\n-\t  if (REGNO_REG_SET_P (bb->global_live_at_start, reg))\n+\t  if (REGNO_REG_SET_P (bb->il.rtl->global_live_at_start, reg))\n \t    SET_HARD_REG_BIT (bi->stack_in.reg_set, reg);\n \t}\n     }"}, {"sha": "862a4c4ea8ff4f8f7ac46871c7bbb781280c5bad", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -266,7 +266,7 @@ mark_flags_life_zones (rtx flags)\n       {\n \tint i;\n \tfor (i = 0; i < flags_nregs; ++i)\n-\t  live |= REGNO_REG_SET_P (block->global_live_at_start,\n+\t  live |= REGNO_REG_SET_P (block->il.rtl->global_live_at_start,\n \t\t\t\t   flags_regno + i);\n       }\n #endif"}, {"sha": "89e7bbb04aac4948685b37e2e89a3b0947581530", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -142,7 +142,7 @@ merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n   rtx insn;\n   HARD_REG_SET live;\n \n-  REG_SET_TO_HARD_REG_SET (live, b->global_live_at_start);\n+  REG_SET_TO_HARD_REG_SET (live, b->il.rtl->global_live_at_start);\n   insn = BB_HEAD (b);\n   while (t)\n     {"}, {"sha": "fe4b3ac2077ff9a84fef4e6ed42d645b9c50f956", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1537,7 +1537,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    /* Check that we don't use a hardreg for an uninitialized\n \t       pseudo.  See also find_dummy_reload().  */\n \t    && (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t\t|| ! bitmap_bit_p (ENTRY_BLOCK_PTR->global_live_at_end,\n+\t\t|| ! bitmap_bit_p (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end,\n \t\t\t\t   ORIGINAL_REGNO (XEXP (note, 0))))\n \t    && ! refers_to_regno_for_reload_p (regno,\n \t\t\t\t\t       (regno\n@@ -2011,7 +2011,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t   as they would clobber the other live pseudo using the same.\n \t   See also PR20973.  */\n       && (ORIGINAL_REGNO (in) < FIRST_PSEUDO_REGISTER\n-          || ! bitmap_bit_p (ENTRY_BLOCK_PTR->global_live_at_end,\n+          || ! bitmap_bit_p (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end,\n \t\t\t     ORIGINAL_REGNO (in))))\n     {\n       unsigned int regno = REGNO (in) + in_offset;"}, {"sha": "6a94530cc8b398997cbf1ef59898df6baa895ee8", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1079,7 +1079,7 @@ reload (rtx first, int global)\n \n   if (! frame_pointer_needed)\n     FOR_EACH_BB (bb)\n-      CLEAR_REGNO_REG_SET (bb->global_live_at_start,\n+      CLEAR_REGNO_REG_SET (bb->il.rtl->global_live_at_start,\n \t\t\t   HARD_FRAME_POINTER_REGNUM);\n \n   /* Come here (with failure set nonzero) if we can't get enough spill"}, {"sha": "eae4cf9f55341700eb235adec53f44ea3ffbd5a8", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -965,7 +965,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n      TARGET.  Otherwise, we must assume everything is live.  */\n   if (b != -1)\n     {\n-      regset regs_live = BASIC_BLOCK (b)->global_live_at_start;\n+      regset regs_live = BASIC_BLOCK (b)->il.rtl->global_live_at_start;\n       unsigned int j;\n       unsigned int regno;\n       rtx start_insn, stop_insn;"}, {"sha": "20520dd074bfaf42820f6df718569b4558dec2ba", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -183,9 +183,9 @@ compute_jump_reg_dependencies (rtx insn, regset cond_set, regset used,\n \t it may guard the fallthrough block from using a value that has\n \t conditionally overwritten that of the main codepath.  So we\n \t consider that it restores the value of the main codepath.  */\n-      bitmap_and (set, e->dest->global_live_at_start, cond_set);\n+      bitmap_and (set, e->dest->il.rtl->global_live_at_start, cond_set);\n     else\n-      bitmap_ior_into (used, e->dest->global_live_at_start);\n+      bitmap_ior_into (used, e->dest->il.rtl->global_live_at_start);\n }\n \n /* Used in schedule_insns to initialize current_sched_info for scheduling"}, {"sha": "edaf79627db1219e762b323374d5fe70072a0a4f", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2d947ce84b1a8baa2252c5ff04b9b3931b3893/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=5e2d947ce84b1a8baa2252c5ff04b9b3931b3893", "patch": "@@ -1184,7 +1184,8 @@ check_live_1 (int src, rtx x)\n \t\t{\n \t\t  basic_block b = candidate_table[src].split_bbs.first_member[i];\n \n-\t\t  if (REGNO_REG_SET_P (b->global_live_at_start, regno + j))\n+\t\t  if (REGNO_REG_SET_P (b->il.rtl->global_live_at_start,\n+\t\t\t\t       regno + j))\n \t\t    {\n \t\t      return 0;\n \t\t    }\n@@ -1198,7 +1199,7 @@ check_live_1 (int src, rtx x)\n \t    {\n \t      basic_block b = candidate_table[src].split_bbs.first_member[i];\n \n-\t      if (REGNO_REG_SET_P (b->global_live_at_start, regno))\n+\t      if (REGNO_REG_SET_P (b->il.rtl->global_live_at_start, regno))\n \t\t{\n \t\t  return 0;\n \t\t}\n@@ -1257,7 +1258,8 @@ update_live_1 (int src, rtx x)\n \t\t{\n \t\t  basic_block b = candidate_table[src].update_bbs.first_member[i];\n \n-\t\t  SET_REGNO_REG_SET (b->global_live_at_start, regno + j);\n+\t\t  SET_REGNO_REG_SET (b->il.rtl->global_live_at_start,\n+\t\t\t\t     regno + j);\n \t\t}\n \t    }\n \t}\n@@ -1267,7 +1269,7 @@ update_live_1 (int src, rtx x)\n \t    {\n \t      basic_block b = candidate_table[src].update_bbs.first_member[i];\n \n-\t      SET_REGNO_REG_SET (b->global_live_at_start, regno);\n+\t      SET_REGNO_REG_SET (b->il.rtl->global_live_at_start, regno);\n \t    }\n \t}\n     }"}]}