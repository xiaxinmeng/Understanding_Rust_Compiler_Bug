{"sha": "763121ccd908f52bc666f277ea2cf42110b3aad9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYzMTIxY2NkOTA4ZjUyYmM2NjZmMjc3ZWEyY2Y0MjExMGIzYWFkOQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-07-08T17:44:41Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-07-08T17:45:16Z"}, "message": "ipa-sra: Fix thinko when overriding safe_to_import_accesses (PR 101066)\n\nThe \"new\" IPA-SRA has a more difficult job than the previous\nnot-truly-IPA version when identifying situations in which a parameter\npassed by reference can be passed into a third function and only thee\nconverted to one passed by value (and possibly \"split\" at the same\ntime).\n\nIn order to allow this, two conditions must be fulfilled.  First the\ncall to the third function must happen before any modifications of\nmemory, because it could change the value passed by reference.\nSecond, in order to make sure we do not introduce new (invalid)\ndereferences, the call must postdominate the entry BB.\n\nThe second condition is actually not necessary if the caller function\nis also certain to dereference the pointer but the first one must\nstill hold.  Unfortunately, the code making this overriding decision\nalso happen to trigger when the first condition is not fulfilled.\nThis is fixed in the following patch.\n\ngcc/ChangeLog:\n\n2021-06-16  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/101066\n\t* ipa-sra.c (class isra_call_summary): New member\n\tm_before_any_store, initialize it in the constructor.\n\t(isra_call_summary::dump): Dump the new field.\n\t(ipa_sra_call_summaries::duplicate): Copy it.\n\t(process_scan_results): Set it.\n\t(isra_write_edge_summary): Stream it.\n\t(isra_read_edge_summary): Likewise.\n\t(param_splitting_across_edge): Only override\n\tsafe_to_import_accesses if m_before_any_store is set.\n\ngcc/testsuite/ChangeLog:\n\n2021-06-16  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/101066\n\t* gcc.dg/ipa/pr101066.c: New test.", "tree": {"sha": "617f6adbb3fb3b121a10125d0651b0364d0ac48a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/617f6adbb3fb3b121a10125d0651b0364d0ac48a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/763121ccd908f52bc666f277ea2cf42110b3aad9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmDnOawACgkQv2PBvD+k\nNUCOaRAAvqLQA9bSC+oNNi+Lkq/AyBl5HKk7afkT0YIXXcsqQuiDxNJM3DKZFkAg\n6P5oQ5kxH2ULGYWa3NCt6nmm0TzONS7AXHt9+isQVIEleGomVS7p1Who7mOUl0FV\nJitBB6xnC+JFMirs/VmrHZp4VUDk0LqP/cG2mIQbEExl5q7+ZE3bFi6sKavi8OJQ\nRuxC1yfh8uioSXVOvTDd7xKO72hnHg95cmnmkkHmm3Q30UrEOgMpYE3+2PW1i9YP\nmfXGVknNcxmPRb9QOmPFy0Mr9Uqn8kgNOpM29dyf3IJplpxoeV6dJK/G2akd0Zqz\nNZW5o9IuGV0OoBbbzAPNv8yTRdXSamsXGdCtVp4NDCfn3ihSkQYmD4SVWVa4FeaR\ndMZheGyUwC72PRbYEYhF1Cb++Vjv4jWORDvSNjC+/ZGizq/IrQPs9hAviqWPP66G\ne7hbckkeX46dhoo7mNVPf0HeFBdILaiAUJnqD8ss1wETDQLJA5aRQivizyphndxk\nVrkkYWMBIGEYAPQ8+4AW2OlUFFDbGNxiIzgPMLKhO2azc6A5L75WweqrDVuYAYbh\n8p5bwd4I4B+7Kn1mYS4TaH63NojudZgPgaoM4J53cndfTaHWTG64u+xAW+JC+Hg2\nrwWYlCK+mHVyWz0gkfcOVr+ORWB7EeUJmMSW4kstDMYTfBZnUlc=\n=VPDD\n-----END PGP SIGNATURE-----", "payload": "tree 617f6adbb3fb3b121a10125d0651b0364d0ac48a\nparent 9bf9f27ac6db4823628c435da9b242fd82bf8d68\nauthor Martin Jambor <mjambor@suse.cz> 1625766281 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1625766316 +0200\n\nipa-sra: Fix thinko when overriding safe_to_import_accesses (PR 101066)\n\nThe \"new\" IPA-SRA has a more difficult job than the previous\nnot-truly-IPA version when identifying situations in which a parameter\npassed by reference can be passed into a third function and only thee\nconverted to one passed by value (and possibly \"split\" at the same\ntime).\n\nIn order to allow this, two conditions must be fulfilled.  First the\ncall to the third function must happen before any modifications of\nmemory, because it could change the value passed by reference.\nSecond, in order to make sure we do not introduce new (invalid)\ndereferences, the call must postdominate the entry BB.\n\nThe second condition is actually not necessary if the caller function\nis also certain to dereference the pointer but the first one must\nstill hold.  Unfortunately, the code making this overriding decision\nalso happen to trigger when the first condition is not fulfilled.\nThis is fixed in the following patch.\n\ngcc/ChangeLog:\n\n2021-06-16  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/101066\n\t* ipa-sra.c (class isra_call_summary): New member\n\tm_before_any_store, initialize it in the constructor.\n\t(isra_call_summary::dump): Dump the new field.\n\t(ipa_sra_call_summaries::duplicate): Copy it.\n\t(process_scan_results): Set it.\n\t(isra_write_edge_summary): Stream it.\n\t(isra_read_edge_summary): Likewise.\n\t(param_splitting_across_edge): Only override\n\tsafe_to_import_accesses if m_before_any_store is set.\n\ngcc/testsuite/ChangeLog:\n\n2021-06-16  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/101066\n\t* gcc.dg/ipa/pr101066.c: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/763121ccd908f52bc666f277ea2cf42110b3aad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/763121ccd908f52bc666f277ea2cf42110b3aad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/763121ccd908f52bc666f277ea2cf42110b3aad9/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bf9f27ac6db4823628c435da9b242fd82bf8d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf9f27ac6db4823628c435da9b242fd82bf8d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf9f27ac6db4823628c435da9b242fd82bf8d68"}], "stats": {"total": 35, "additions": 33, "deletions": 2}, "files": [{"sha": "965e246d7886f0fe62cb5658337941bf7cdb0d88", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/763121ccd908f52bc666f277ea2cf42110b3aad9/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/763121ccd908f52bc666f277ea2cf42110b3aad9/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=763121ccd908f52bc666f277ea2cf42110b3aad9", "patch": "@@ -343,7 +343,7 @@ class isra_call_summary\n public:\n   isra_call_summary ()\n     : m_arg_flow (), m_return_ignored (false), m_return_returned (false),\n-      m_bit_aligned_arg (false)\n+      m_bit_aligned_arg (false), m_before_any_store (false)\n   {}\n \n   void init_inputs (unsigned arg_count);\n@@ -362,6 +362,10 @@ class isra_call_summary\n \n   /* Set when any of the call arguments are not byte-aligned.  */\n   unsigned m_bit_aligned_arg : 1;\n+\n+  /* Set to true if the call happend before any (other) store to memory in the\n+     caller.  */\n+  unsigned m_before_any_store : 1;\n };\n \n /* Class to manage function summaries.  */\n@@ -491,6 +495,8 @@ isra_call_summary::dump (FILE *f)\n     fprintf (f, \"    return value ignored\\n\");\n   if (m_return_returned)\n     fprintf (f, \"    return value used only to compute caller return value\\n\");\n+  if (m_before_any_store)\n+    fprintf (f, \"    happens before any store to memory\\n\");\n   for (unsigned i = 0; i < m_arg_flow.length (); i++)\n     {\n       fprintf (f, \"    Parameter %u:\\n\", i);\n@@ -535,6 +541,7 @@ ipa_sra_call_summaries::duplicate (cgraph_edge *, cgraph_edge *,\n   new_sum->m_return_ignored = old_sum->m_return_ignored;\n   new_sum->m_return_returned = old_sum->m_return_returned;\n   new_sum->m_bit_aligned_arg = old_sum->m_bit_aligned_arg;\n+  new_sum->m_before_any_store = old_sum->m_before_any_store;\n }\n \n \n@@ -2374,6 +2381,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \tunsigned count = gimple_call_num_args (call_stmt);\n \tisra_call_summary *csum = call_sums->get_create (cs);\n \tcsum->init_inputs (count);\n+\tcsum->m_before_any_store = uses_memory_as_obtained;\n \tfor (unsigned argidx = 0; argidx < count; argidx++)\n \t  {\n \t    if (!csum->m_arg_flow[argidx].pointer_pass_through)\n@@ -2546,6 +2554,7 @@ isra_write_edge_summary (output_block *ob, cgraph_edge *e)\n   bp_pack_value (&bp, csum->m_return_ignored, 1);\n   bp_pack_value (&bp, csum->m_return_returned, 1);\n   bp_pack_value (&bp, csum->m_bit_aligned_arg, 1);\n+  bp_pack_value (&bp, csum->m_before_any_store, 1);\n   streamer_write_bitpack (&bp);\n }\n \n@@ -2664,6 +2673,7 @@ isra_read_edge_summary (struct lto_input_block *ib, cgraph_edge *cs)\n   csum->m_return_ignored = bp_unpack_value (&bp, 1);\n   csum->m_return_returned = bp_unpack_value (&bp, 1);\n   csum->m_bit_aligned_arg = bp_unpack_value (&bp, 1);\n+  csum->m_before_any_store = bp_unpack_value (&bp, 1);\n }\n \n /* Read intraprocedural analysis information about NODE and all of its outgoing\n@@ -3420,7 +3430,8 @@ param_splitting_across_edge (cgraph_edge *cs)\n \t    }\n \t  else if (!ipf->safe_to_import_accesses)\n \t    {\n-\t      if (!all_callee_accesses_present_p (param_desc, arg_desc))\n+\t      if (!csum->m_before_any_store\n+\t\t  || !all_callee_accesses_present_p (param_desc, arg_desc))\n \t\t{\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file, \"  %u->%u: cannot import accesses.\\n\","}, {"sha": "1ceb6e43136a91297fcdcd45a74fea1d78046456", "filename": "gcc/testsuite/gcc.dg/ipa/pr101066.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/763121ccd908f52bc666f277ea2cf42110b3aad9/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr101066.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/763121ccd908f52bc666f277ea2cf42110b3aad9/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr101066.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr101066.c?ref=763121ccd908f52bc666f277ea2cf42110b3aad9", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do run } */\n+/* { dg-options \"-Os -fno-ipa-cp -fno-inline\" } */\n+\n+int a = 1, c, d, e;\n+int *b = &a;\n+static int g(int *h) {\n+  c = *h;\n+  return d;\n+}\n+static void f(int *h) {\n+  e = *h;\n+  *b = 0;\n+  g(h);\n+}\n+int main() {\n+  f(b);\n+  if (c)\n+    __builtin_abort();\n+  return 0;\n+}"}]}