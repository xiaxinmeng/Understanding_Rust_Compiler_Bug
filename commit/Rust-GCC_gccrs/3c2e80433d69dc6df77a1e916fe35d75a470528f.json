{"sha": "3c2e80433d69dc6df77a1e916fe35d75a470528f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyZTgwNDMzZDY5ZGM2ZGY3N2ExZTkxNmZlMzVkNzVhNDcwNTI4Zg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-03-23T07:00:56Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-03-23T07:00:56Z"}, "message": "re PR fortran/30834 (ICE with kind=8 exponentiaton)\n\n\tPR fortran/30834\n\n\t* arith.c (complex_pow): Rewrite to handle large power.\n\t(gfc_arith_power): Handle large power in the real and integer\n\tcases.\n\n\t* gfortran.dg/integer_exponentiation_3.F90: New\ttest.\n\t* gfortran.dg/integer_exponentiation_4.f90: New test.\n\t* gfortran.dg/integer_exponentiation_5.F90: New test.\n\nFrom-SVN: r123154", "tree": {"sha": "2b25f4f47d8b5f4892e7ada924f649bce679673a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b25f4f47d8b5f4892e7ada924f649bce679673a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c2e80433d69dc6df77a1e916fe35d75a470528f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2e80433d69dc6df77a1e916fe35d75a470528f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2e80433d69dc6df77a1e916fe35d75a470528f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2e80433d69dc6df77a1e916fe35d75a470528f/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03c17ccd922a49ed07c89b5c533e86318d225c78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c17ccd922a49ed07c89b5c533e86318d225c78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c17ccd922a49ed07c89b5c533e86318d225c78"}], "stats": {"total": 515, "additions": 459, "deletions": 56}, "files": [{"sha": "674b9970c6d9ea5401538f84326016e50efedb49", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3c2e80433d69dc6df77a1e916fe35d75a470528f", "patch": "@@ -1,3 +1,10 @@\n+2007-03-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/30834\n+\t* arith.c (complex_pow): Rewrite to handle large power.\n+\t(gfc_arith_power): Handle large power in the real and integer\n+\tcases.\n+\n 2007-03-22  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/31262"}, {"sha": "e6c2d0f85d45680043933a78f224f03657757a70", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 122, "deletions": 56, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=3c2e80433d69dc6df77a1e916fe35d75a470528f", "patch": "@@ -872,42 +872,69 @@ complex_reciprocal (gfc_expr *op)\n }\n \n \n-/* Raise a complex number to positive power.  */\n+/* Raise a complex number to positive power (power > 0).\n+   This function will modify the content of power.\n+\n+   Use Binary Method, which is not an optimal but a simple and reasonable\n+   arithmetic. See section 4.6.3, \"Evaluation of Powers\" of Donald E. Knuth,\n+   \"Seminumerical Algorithms\", Vol. 2, \"The Art of Computer Programming\",\n+   3rd Edition, 1998.  */\n \n static void\n-complex_pow_ui (gfc_expr *base, int power, gfc_expr *result)\n+complex_pow (gfc_expr *result, gfc_expr *base, mpz_t power)\n {\n-  mpfr_t re, im, a;\n+  mpfr_t x_r, x_i, tmp, re, im;\n \n   gfc_set_model (base->value.complex.r);\n+  mpfr_init (x_r);\n+  mpfr_init (x_i);\n+  mpfr_init (tmp);\n   mpfr_init (re);\n   mpfr_init (im);\n-  mpfr_init (a);\n \n+  /* res = 1 */\n   mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n   mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \n-  for (; power > 0; power--)\n+  /* x = base */\n+  mpfr_set (x_r, base->value.complex.r, GFC_RND_MODE);\n+  mpfr_set (x_i, base->value.complex.i, GFC_RND_MODE);\n+\n+/* Macro for complex multiplication. We have to take care that\n+   res_r/res_i and a_r/a_i can (and will) be the same variable.  */\n+#define CMULT(res_r,res_i,a_r,a_i,b_r,b_i) \\\n+    mpfr_mul (re, a_r, b_r, GFC_RND_MODE), \\\n+    mpfr_mul (tmp, a_i, b_i, GFC_RND_MODE), \\\n+    mpfr_sub (re, re, tmp, GFC_RND_MODE), \\\n+    \\\n+    mpfr_mul (im, a_r, b_i, GFC_RND_MODE), \\\n+    mpfr_mul (tmp, a_i, b_r, GFC_RND_MODE), \\\n+    mpfr_add (res_i, im, tmp, GFC_RND_MODE), \\\n+    mpfr_set (res_r, re, GFC_RND_MODE)\n+  \n+#define res_r result->value.complex.r\n+#define res_i result->value.complex.i\n+\n+  /* for (; power > 0; x *= x) */\n+  for (; mpz_cmp_si (power, 0) > 0; CMULT(x_r,x_i,x_r,x_i,x_r,x_i))\n     {\n-      mpfr_mul (re, base->value.complex.r, result->value.complex.r,\n-\t\tGFC_RND_MODE);\n-      mpfr_mul (a, base->value.complex.i, result->value.complex.i,\n-\t\tGFC_RND_MODE);\n-      mpfr_sub (re, re, a, GFC_RND_MODE);\n-\n-      mpfr_mul (im, base->value.complex.r, result->value.complex.i,\n-\t\tGFC_RND_MODE);\n-      mpfr_mul (a, base->value.complex.i, result->value.complex.r,\n-\t\tGFC_RND_MODE);\n-      mpfr_add (im, im, a, GFC_RND_MODE);\n+      /* if (power & 1) res = res * x; */\n+      if (mpz_congruent_ui_p (power, 1, 2))\n+\tCMULT(res_r,res_i,res_r,res_i,x_r,x_i);\n \n-      mpfr_set (result->value.complex.r, re, GFC_RND_MODE);\n-      mpfr_set (result->value.complex.i, im, GFC_RND_MODE);\n+      /* power /= 2; */\n+      mpz_fdiv_q_ui (power, power, 2);\n     }\n \n+#undef res_r\n+#undef res_i\n+#undef CMULT\n+\n+  mpfr_clear (x_r);\n+  mpfr_clear (x_i);\n+  mpfr_clear (tmp);\n   mpfr_clear (re);\n   mpfr_clear (im);\n-  mpfr_clear (a);\n }\n \n \n@@ -916,20 +943,17 @@ complex_pow_ui (gfc_expr *base, int power, gfc_expr *result)\n static arith\n gfc_arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n-  int power, apower;\n+  int power_sign;\n   gfc_expr *result;\n-  mpz_t unity_z;\n-  mpfr_t unity_f;\n   arith rc;\n \n-  rc = ARITH_OK;\n-\n-  if (gfc_extract_int (op2, &power) != NULL)\n-    gfc_internal_error (\"gfc_arith_power(): Bad exponent\");\n+  gcc_assert (op2->expr_type == EXPR_CONSTANT && op2->ts.type == BT_INTEGER);\n \n+  rc = ARITH_OK;\n   result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n+  power_sign = mpz_sgn (op2->value.integer);\n \n-  if (power == 0)\n+  if (power_sign == 0)\n     {\n       /* Handle something to the zeroth power.  Since we're dealing\n \t with integral exponents, there is no ambiguity in the\n@@ -955,44 +979,86 @@ gfc_arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n     }\n   else\n     {\n-      apower = power;\n-      if (power < 0)\n-\tapower = -power;\n-\n       switch (op1->ts.type)\n \t{\n \tcase BT_INTEGER:\n-\t  mpz_pow_ui (result->value.integer, op1->value.integer, apower);\n-\n-\t  if (power < 0)\n-\t    {\n-\t      mpz_init_set_ui (unity_z, 1);\n-\t      mpz_tdiv_q (result->value.integer, unity_z,\n-\t\t\t  result->value.integer);\n-\t      mpz_clear (unity_z);\n-\t    }\n+\t  {\n+\t    int power;\n+\n+\t    /* First, we simplify the cases of op1 == 1, 0 or -1.  */\n+\t    if (mpz_cmp_si (op1->value.integer, 1) == 0)\n+\t      {\n+\t\t/* 1**op2 == 1 */\n+\t\tmpz_set_si (result->value.integer, 1);\n+\t      }\n+\t    else if (mpz_cmp_si (op1->value.integer, 0) == 0)\n+\t      {\n+\t\t/* 0**op2 == 0, if op2 > 0\n+\t           0**op2 overflow, if op2 < 0 ; in that case, we\n+\t\t   set the result to 0 and return ARITH_DIV0.  */\n+\t\tmpz_set_si (result->value.integer, 0);\n+\t\tif (mpz_cmp_si (op2->value.integer, 0) < 0)\n+\t\t  rc = ARITH_DIV0;\n+\t      }\n+\t    else if (mpz_cmp_si (op1->value.integer, -1) == 0)\n+\t      {\n+\t\t/* (-1)**op2 == (-1)**(mod(op2,2)) */\n+\t\tunsigned int odd = mpz_fdiv_ui (op2->value.integer, 2);\n+\t\tif (odd)\n+\t\t  mpz_set_si (result->value.integer, -1);\n+\t\telse\n+\t\t  mpz_set_si (result->value.integer, 1);\n+\t      }\n+\t    /* Then, we take care of op2 < 0.  */\n+\t    else if (mpz_cmp_si (op2->value.integer, 0) < 0)\n+\t      {\n+\t\t/* if op2 < 0, op1**op2 == 0  because abs(op1) > 1.  */\n+\t\tmpz_set_si (result->value.integer, 0);\n+\t      }\n+\t    else if (gfc_extract_int (op2, &power) != NULL)\n+\t      {\n+\t\t/* If op2 doesn't fit in an int, the exponentiation will\n+\t\t   overflow, because op2 > 0 and abs(op1) > 1.  */\n+\t\tmpz_t max;\n+\t\tint i = gfc_validate_kind (BT_INTEGER, result->ts.kind, false);\n+\n+\t\tif (gfc_option.flag_range_check)\n+\t\t  rc = ARITH_OVERFLOW;\n+\n+\t\t/* Still, we want to give the same value as the processor.  */\n+\t\tmpz_init (max);\n+\t\tmpz_add_ui (max, gfc_integer_kinds[i].huge, 1);\n+\t\tmpz_mul_ui (max, max, 2);\n+\t\tmpz_powm (result->value.integer, op1->value.integer,\n+\t\t\t  op2->value.integer, max);\n+\t\tmpz_clear (max);\n+\t      }\n+\t    else\n+\t      mpz_pow_ui (result->value.integer, op1->value.integer, power);\n+\t  }\n \t  break;\n \n \tcase BT_REAL:\n-\t  mpfr_pow_ui (result->value.real, op1->value.real, apower,\n-\t\t       GFC_RND_MODE);\n-\n-\t  if (power < 0)\n-\t    {\n-\t      gfc_set_model (op1->value.real);\n-\t      mpfr_init (unity_f);\n-\t      mpfr_set_ui (unity_f, 1, GFC_RND_MODE);\n-\t      mpfr_div (result->value.real, unity_f, result->value.real,\n-\t\t\tGFC_RND_MODE);\n-\t      mpfr_clear (unity_f);\n-\t    }\n+\t  mpfr_pow_z (result->value.real, op1->value.real, op2->value.integer,\n+\t\t      GFC_RND_MODE);\n \t  break;\n \n \tcase BT_COMPLEX:\n-\t  complex_pow_ui (op1, apower, result);\n-\t  if (power < 0)\n-\t    complex_reciprocal (result);\n-\t  break;\n+\t  {\n+\t    mpz_t apower;\n+\n+\t    /* Compute op1**abs(op2)  */\n+\t    mpz_init (apower);\n+\t    mpz_abs (apower, op2->value.integer);\n+\t    complex_pow (result, op1, apower);\n+\t    mpz_clear (apower);\n+\n+\t    /* If (op2 < 0), compute the inverse.  */\n+\t    if (power_sign < 0)\n+\t      complex_reciprocal (result);\n+\n+\t    break;\n+\t  }\n \n \tdefault:\n \t  break;"}, {"sha": "aa313d97d8adbafbd05bcf343f7824d20db10085", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c2e80433d69dc6df77a1e916fe35d75a470528f", "patch": "@@ -1,3 +1,10 @@\n+2007-03-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/30834\n+\t* gfortran.dg/integer_exponentiation_3.F90: New\ttest.\n+\t* gfortran.dg/integer_exponentiation_4.f90: New test.\n+\t* gfortran.dg/integer_exponentiation_5.F90: New test.\n+\n 2007-03-22  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/30863"}, {"sha": "6f0640bea2f190f7f471a63495fc16a5789cc69e", "filename": "gcc/testsuite/gfortran.dg/integer_exponentiation_3.F90", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_3.F90?ref=3c2e80433d69dc6df77a1e916fe35d75a470528f", "patch": "@@ -0,0 +1,201 @@\n+! { dg-do run }\n+! { dg-options \"\" }\n+module mod_check\n+  implicit none\n+\n+  interface check\n+    module procedure check_i8\n+    module procedure check_i4\n+    module procedure check_r8\n+    module procedure check_r4\n+    module procedure check_c8\n+    module procedure check_c4\n+  end interface check\n+\n+  interface acheck\n+    module procedure acheck_c8\n+    module procedure acheck_c4\n+  end interface acheck\n+\n+contains\n+\n+  subroutine check_i8 (a, b)\n+    integer(kind=8), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_i8\n+\n+  subroutine check_i4 (a, b)\n+    integer(kind=4), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_i4\n+\n+  subroutine check_r8 (a, b)\n+    real(kind=8), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_r8\n+\n+  subroutine check_r4 (a, b)\n+    real(kind=4), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_r4\n+\n+  subroutine check_c8 (a, b)\n+    complex(kind=8), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_c8\n+\n+  subroutine check_c4 (a, b)\n+    complex(kind=4), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_c4\n+\n+  subroutine acheck_c8 (a, b)\n+    complex(kind=8), intent(in) :: a, b\n+    if (abs(a-b) > 1.d-9 * min(abs(a),abs(b))) call abort()\n+  end subroutine acheck_c8\n+\n+  subroutine acheck_c4 (a, b)\n+    complex(kind=4), intent(in) :: a, b\n+    if (abs(a-b) > 1.e-5 * min(abs(a),abs(b))) call abort()\n+  end subroutine acheck_c4\n+\n+end module mod_check\n+\n+program test\n+  use mod_check\n+  implicit none\n+\n+  integer(kind=4) :: i4\n+  integer(kind=8) :: i8\n+  real(kind=4) :: r4\n+  real(kind=8) :: r8\n+  complex(kind=4) :: c4\n+  complex(kind=8) :: c8\n+\n+#define TEST(base,exp,var) var = base; call check((var)**(exp),(base)**(exp))\n+#define ATEST(base,exp,var) var = base; call acheck((var)**(exp),(base)**(exp))\n+\n+!!!!! INTEGER BASE !!!!!\n+  TEST(0,0,i4)\n+  TEST(0_8,0_8,i8)\n+  TEST(1,0,i4)\n+  TEST(1_8,0_8,i8)\n+  TEST(-1,0,i4)\n+  TEST(-1_8,0_8,i8)\n+  TEST(huge(0),0,i4)\n+  TEST(huge(0_8),0_8,i8)\n+  TEST(-huge(0)-1,0,i4)\n+  TEST(-huge(0_8)-1_8,0_8,i8)\n+\n+  TEST(1,1,i4)\n+  TEST(1_8,1_8,i8)\n+  TEST(1,2,i4)\n+  TEST(1_8,2_8,i8)\n+  TEST(1,-1,i4)\n+  TEST(1_8,-1_8,i8)\n+  TEST(1,-2,i4)\n+  TEST(1_8,-2_8,i8)\n+  TEST(1,huge(0),i4)\n+  TEST(1_8,huge(0_8),i8)\n+  TEST(1,-huge(0)-1,i4)\n+  TEST(1_8,-huge(0_8)-1_8,i8)\n+\n+  TEST(-1,1,i4)\n+  TEST(-1_8,1_8,i8)\n+  TEST(-1,2,i4)\n+  TEST(-1_8,2_8,i8)\n+  TEST(-1,-1,i4)\n+  TEST(-1_8,-1_8,i8)\n+  TEST(-1,-2,i4)\n+  TEST(-1_8,-2_8,i8)\n+  TEST(-1,huge(0),i4)\n+  TEST(-1_8,huge(0_8),i8)\n+  TEST(-1,-huge(0)-1,i4)\n+  TEST(-1_8,-huge(0_8)-1_8,i8)\n+\n+  TEST(2,9,i4)\n+  TEST(2_8,9_8,i8)\n+  TEST(-2,9,i4)\n+  TEST(-2_8,9_8,i8)\n+  TEST(2,-9,i4)\n+  TEST(2_8,-9_8,i8)\n+  TEST(-2,-9,i4)\n+  TEST(-2_8,-9_8,i8)\n+\n+!!!!! REAL BASE !!!!!\n+  TEST(0.0,0,r4)\n+  TEST(0.0,1,r4)\n+  TEST(0.0,huge(0),r4)\n+  TEST(0.0,0_8,r4)\n+  TEST(0.0,1_8,r4)\n+  TEST(0.0,huge(0_8),r4)\n+\n+  TEST(1.0,0,r4)\n+  TEST(1.0,1,r4)\n+  TEST(1.0,-1,r4)\n+  TEST(1.0,huge(0),r4)\n+  TEST(1.0,-huge(0)-1,r4)\n+  TEST(1.0,0_8,r4)\n+  TEST(1.0,1_8,r4)\n+  TEST(1.0,-1_8,r4)\n+  TEST(1.0,huge(0_8),r4)\n+  TEST(1.0,-huge(0_8)-1_8,r4)\n+\n+  TEST(-1.0,0,r4)\n+  TEST(-1.0,1,r4)\n+  TEST(-1.0,-1,r4)\n+  TEST(-1.0,huge(0),r4)\n+  TEST(-1.0,-huge(0)-1,r4)\n+  TEST(-1.0,0_8,r4)\n+  TEST(-1.0,1_8,r4)\n+  TEST(-1.0,-1_8,r4)\n+  TEST(-1.0,huge(0_8),r4)\n+  TEST(-1.0,-huge(0_8)-1_8,r4)\n+\n+  TEST(2.0,0,r4)\n+  TEST(2.0,1,r4)\n+  TEST(2.0,-1,r4)\n+  TEST(2.0,3,r4)\n+  TEST(2.0,-3,r4)\n+  TEST(2.0,0_8,r4)\n+  TEST(2.0,1_8,r4)\n+  TEST(2.0,-1_8,r4)\n+  TEST(2.0,3_8,r4)\n+  TEST(2.0,-3_8,r4)\n+\n+  TEST(nearest(1.0,-1.0),0,r4)\n+  TEST(nearest(1.0,-1.0),huge(0),r4) ! { dg-warning \"Arithmetic underflow\" }\n+  TEST(nearest(1.0,-1.0),0_8,r4)\n+  TEST(nearest(1.0_8,-1.0),huge(0_8),r8) ! { dg-warning \"Arithmetic underflow\" }\n+\n+  TEST(nearest(1.0,-1.0),107,r4)\n+  TEST(nearest(1.0,1.0),107,r4)\n+\n+!!!!! COMPLEX BASE !!!!!\n+  TEST((1.0,0.2),0,c4)\n+  TEST((1.0,0.2),1,c4)\n+  TEST((1.0,0.2),2,c4)\n+  TEST((1.0,0.2),9,c4)\n+  ATEST((1.0,0.2),-1,c4)\n+  ATEST((1.0,0.2),-2,c4)\n+  ATEST((1.0,0.2),-9,c4)\n+\n+  TEST((0.0,0.2),0,c4)\n+  TEST((0.0,0.2),1,c4)\n+  TEST((0.0,0.2),2,c4)\n+  TEST((0.0,0.2),9,c4)\n+  ATEST((0.0,0.2),-1,c4)\n+  ATEST((0.0,0.2),-2,c4)\n+  ATEST((0.0,0.2),-9,c4)\n+\n+  TEST((1.0,0.),0,c4)\n+  TEST((1.0,0.),1,c4)\n+  TEST((1.0,0.),2,c4)\n+  TEST((1.0,0.),9,c4)\n+  ATEST((1.0,0.),-1,c4)\n+  ATEST((1.0,0.),-2,c4)\n+  ATEST((1.0,0.),-9,c4)\n+\n+end program test\n+\n+! { dg-final { cleanup-modules \"mod_check\" } }"}, {"sha": "55d1dcd86a32f10ce1e773d7804127e3281250e8", "filename": "gcc/testsuite/gfortran.dg/integer_exponentiation_4.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_4.f90?ref=3c2e80433d69dc6df77a1e916fe35d75a470528f", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! { dg-options \"\" }\n+program test\n+  implicit none\n+\n+!!!!!! INTEGER BASE !!!!!!\n+  print *, 0**0\n+  print *, 0**1\n+  print *, 0**(-1) ! { dg-error \"Division by zero\" }\n+  print *, 0**(huge(0))\n+  print *, 0**(-huge(0)-1) ! { dg-error \"Division by zero\" }\n+  print *, 0**(2_8**32)\n+  print *, 0**(-(2_8**32)) ! { dg-error \"Division by zero\" }\n+\n+  print *, 1**huge(0)\n+  print *, 1**(-huge(0)-1)\n+  print *, 1**huge(0_8)\n+  print *, 1**(-huge(0_8)-1_8)\n+  print *, (-1)**huge(0)\n+  print *, (-1)**(-huge(0)-1)\n+  print *, (-1)**huge(0_8)\n+  print *, (-1)**(-huge(0_8)-1_8)\n+\n+  print *, 2**huge(0) ! { dg-error \"Arithmetic overflow\" }\n+  print *, 2**huge(0_8) ! { dg-error \"Arithmetic overflow\" }\n+  print *, (-2)**huge(0) ! { dg-error \"Arithmetic overflow\" }\n+  print *, (-2)**huge(0_8) ! { dg-error \"Arithmetic overflow\" }\n+\n+  print *, 2**(-huge(0)-1)\n+  print *, 2**(-huge(0_8)-1_8)\n+  print *, (-2)**(-huge(0)-1)\n+  print *, (-2)**(-huge(0_8)-1_8)\n+\n+!!!!!! REAL BASE !!!!!!\n+  print *, 0.0**(-1) ! { dg-error \"Arithmetic overflow\" }\n+  print *, 0.0**(-huge(0)-1) ! { dg-error \"Arithmetic overflow\" }\n+  print *, 2.0**huge(0) ! { dg-error \"Arithmetic overflow\" }\n+  print *, nearest(1.0,-1.0)**(-huge(0)) ! { dg-error \"Arithmetic overflow\" }\n+\n+!!!!!! COMPLEX BASE !!!!!!\n+  print *, (2.0,-4.3)**huge(0) ! { dg-error \"Arithmetic NaN\" }\n+  print *, (2.0,-4.3)**(-huge(0)) ! { dg-error \"Arithmetic NaN\" }\n+\n+end program test"}, {"sha": "52410f8f5e6d71d779930c78a5d917bc9e23c843", "filename": "gcc/testsuite/gfortran.dg/integer_exponentiation_5.F90", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_5.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2e80433d69dc6df77a1e916fe35d75a470528f/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_5.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_5.F90?ref=3c2e80433d69dc6df77a1e916fe35d75a470528f", "patch": "@@ -0,0 +1,78 @@\n+! { dg-do run }\n+! { dg-options \"-fno-range-check\" }\n+module mod_check\n+  implicit none\n+\n+  interface check\n+    module procedure check_i8\n+    module procedure check_i4\n+    module procedure check_r8\n+    module procedure check_r4\n+    module procedure check_c8\n+    module procedure check_c4\n+  end interface check\n+\n+contains\n+\n+  subroutine check_i8 (a, b)\n+    integer(kind=8), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_i8\n+\n+  subroutine check_i4 (a, b)\n+    integer(kind=4), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_i4\n+\n+  subroutine check_r8 (a, b)\n+    real(kind=8), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_r8\n+\n+  subroutine check_r4 (a, b)\n+    real(kind=4), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_r4\n+\n+  subroutine check_c8 (a, b)\n+    complex(kind=8), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_c8\n+\n+  subroutine check_c4 (a, b)\n+    complex(kind=4), intent(in) :: a, b\n+    if (a /= b) call abort()\n+  end subroutine check_c4\n+\n+end module mod_check\n+\n+program test\n+  use mod_check\n+  implicit none\n+\n+  integer(kind=4) :: i4\n+  integer(kind=8) :: i8\n+  real(kind=4) :: r4\n+  real(kind=8) :: r8\n+  complex(kind=4) :: c4\n+  complex(kind=8) :: c8\n+\n+#define TEST(base,exp,var) var = base; call check((var)**(exp),(base)**(exp))\n+\n+!!!!! INTEGER BASE !!!!!\n+  TEST(3,23,i4)\n+  TEST(-3,23,i4)\n+  TEST(3_8,43_8,i8)\n+  TEST(-3_8,43_8,i8)\n+\n+  TEST(17_8,int(huge(0),kind=8)+1,i8)\n+\n+!!!!! REAL BASE !!!!!\n+  TEST(0.0,-1,r4)\n+  TEST(0.0,-huge(0)-1,r4)\n+  TEST(2.0,huge(0),r4)\n+  TEST(nearest(1.0,-1.0),-huge(0),r4)\n+\n+end program test\n+\n+! { dg-final { cleanup-modules \"mod_check\" } }"}]}