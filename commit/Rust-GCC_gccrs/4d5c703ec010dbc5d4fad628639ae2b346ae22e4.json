{"sha": "4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ1YzcwM2VjMDEwZGJjNWQ0ZmFkNjI4NjM5YWUyYjM0NmFlMjJlNA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-09-02T15:55:57Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-09-02T15:55:57Z"}, "message": "NameFinder.java (remove_interpreter): New field.\n\n       * gnu/gcj/runtime/NameFinder.java (remove_interpreter): New field.\n       (sanitizeStack): Correctly reset unknown and interpreter counters,\n       detect interpreter runtime frames.\n       (demangleInterpreterMethod): New method.\n       * gnu/gcj/runtime/natNameFinder.cc (lookupInterp): Use new method.\n       * java/lang/natVMThrowable.cc (fillInStackTrace): Change order of\n       filling in addrs[].\n\nFrom-SVN: r56741", "tree": {"sha": "eaa7255427dbc59adb36a9342d65ab7b66ffc9b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaa7255427dbc59adb36a9342d65ab7b66ffc9b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/comments", "author": null, "committer": null, "parents": [{"sha": "f60518c8debf595354f37c0b2974a5dfa56aa5f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60518c8debf595354f37c0b2974a5dfa56aa5f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60518c8debf595354f37c0b2974a5dfa56aa5f1"}], "stats": {"total": 175, "additions": 159, "deletions": 16}, "files": [{"sha": "dabee5148f5048af6f605910954610cd3bd0228b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "patch": "@@ -1,3 +1,13 @@\n+2002-09-01  Mark Wielaard  <mark@klomp.org>\n+\n+\t* gnu/gcj/runtime/NameFinder.java (remove_interpreter): New field.\n+\t(sanitizeStack): Correctly reset unknown and interpreter counters,\n+\tdetect interpreter runtime frames.\n+\t(demangleInterpreterMethod): New method.\n+\t* gnu/gcj/runtime/natNameFinder.cc (lookupInterp): Use new method.\n+\t* java/lang/natVMThrowable.cc (fillInStackTrace): Change order of\n+\tfilling in addrs[].\n+\n 2002-09-02  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/DatagramPacket.java, java/net/MulticsstSocket.java:"}, {"sha": "1d729d252accdca0ca1f96dfea00901e6746f89b", "filename": "libjava/gnu/gcj/runtime/NameFinder.java", "status": "modified", "additions": 144, "deletions": 12, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java?ref=4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "patch": "@@ -34,11 +34,15 @@\n  *     should be removed from the stack trace. Only done when names are\n  *     demangled.</ul>\n  * <ul><code>gnu.gcj.runtime.NameFinder.remove_unknown</code>\n- *     Wheter calls to unknown functions (class and method names are unknown)\n+ *     Whether calls to unknown functions (class and method names are unknown)\n  *     should be removed from the stack trace. Only done when the stack is\n  *     sanitized.</ul>\n+ * <ul><code>gnu.gcj.runtime.NameFinder.remove_interpreter</code>\n+ *     Whether runtime interpreter calls (methods in the _Jv_InterpMethod class\n+ *     and functions starting with 'ffi_') should be removed from the stack\n+ *     trace. Only done when the stack is sanitized.</ul>\n  * <ul><code>gnu.gcj.runtime.NameFinder.use_addr2line</code>\n- *     Wheter an external process (addr2line or addr2name.awk) should be used\n+ *     Whether an external process (addr2line or addr2name.awk) should be used\n  *     as fallback to convert the addresses to function names when the runtime\n  *     is unable to do it through <code>dladdr</code>.</ul>\n  * </li>\n@@ -68,6 +72,10 @@\n \t  = Boolean.valueOf(System.getProperty\n \t\t(\"gnu.gcj.runtime.NameFinder.remove_unknown\", \"true\")\n \t    ).booleanValue();\n+  private static final boolean remove_interpreter\n+\t  = Boolean.valueOf(System.getProperty\n+\t\t(\"gnu.gcj.runtime.NameFinder.remove_interpreter\", \"true\")\n+\t    ).booleanValue();\n   private static final boolean use_addr2line\n \t  = Boolean.valueOf(System.getProperty\n \t\t(\"gnu.gcj.runtime.NameFinder.use_addr2line\", \"true\")\n@@ -257,6 +265,7 @@ private static StackTraceElement[] sanitizeStack(StackTraceElement[] elements,\n       consName = className.substring(lastDot + 1) + '(';\n \n     int unknown = 0;\n+    int interpreter = 0;\n     int last_throw = -1;\n     int length = elements.length;\n     int end = length-1;\n@@ -274,10 +283,20 @@ private static StackTraceElement[] sanitizeStack(StackTraceElement[] elements,\n \t    && (MName.startsWith(consName)\n \t\t|| MName.startsWith(\"Throwable(\")\n \t\t|| MName.startsWith(\"fillInStackTrace(\"))))\n-\t  last_throw = i;\n+\t  {\n+\t    last_throw = i;\n+\t    // Reset counting of unknown and interpreter frames.\n+\t    unknown = 0;\n+\t    interpreter = 0;\n+\t  }\n \telse if (remove_unknown && CName == null \n \t\t && (MName == null || MName.startsWith(\"0x\")))\n \t  unknown++;\n+\telse if (remove_interpreter\n+\t\t && ((CName == null\n+\t\t      && MName != null && MName.startsWith(\"ffi_\"))\n+\t\t     || (CName != null && CName.equals(\"_Jv_InterpMethod\"))))\n+\t  interpreter++;\n \telse if (\"main(java.lang.String[])\".equals(MName))\n \t  {\n \t    end = i;\n@@ -287,20 +306,28 @@ else if (\"main(java.lang.String[])\".equals(MName))\n     int begin = last_throw+1;\n \n     // Now filter out everything at the start and the end that is not part\n-    // of the \"normal\" user program including any elements that have no\n-    // usefull information whatsoever unless that means we filter out all info.\n-    int nr_elements = end-begin-unknown+1;\n-    if ((begin > 0 || end < length-1 || unknown > 0) && nr_elements > 0)\n+    // of the \"normal\" user program including any elements that are interpreter\n+    // calls or have no usefull information whatsoever.\n+    // Unless that means we filter out all info.\n+    int nr_elements = end-begin-unknown-interpreter+1;\n+    if ((begin > 0 || end < length-1 || unknown > 0 || interpreter > 0)\n+\t&& nr_elements > 0)\n       {\n \tstack = new StackTraceElement[nr_elements];\n \tint pos =0;\n \tfor (int i=begin; i<=end; i++)\n \t  {\n-\t    String MName;\n-\t    if (unknown == 0\n-\t\t|| !(elements[i].getClassName() == null\n-\t\t     && ((MName = elements[i].getMethodName()) == null\n-\t\t\t || MName.startsWith(\"0x\"))))\n+\t    String MName = elements[i].getMethodName();\n+\t    String CName = elements[i].getClassName();\n+\t    if (remove_unknown && CName == null \n+\t\t && (MName == null || MName.startsWith(\"0x\")))\n+\t      ; // Skip unknown frame\n+\t    else if (remove_interpreter\n+\t\t     && ((CName == null\n+\t\t\t && MName != null && MName.startsWith(\"ffi_\"))\n+\t\t\t|| (CName != null && CName.equals(\"_Jv_InterpMethod\"))))\n+\t      ; // Skip interpreter runtime frame\n+\t    else\n \t      {\n \t\tstack[pos] = elements[i];\n \t\tpos++;\n@@ -394,6 +421,111 @@ private String demangleName(String s)\n     return s;\n   }\n \n+  /**\n+   * Returns human readable method name and aguments given a method type\n+   * signature as known to the interpreter and a classname.\n+   */\n+  public static String demangleInterpreterMethod(String m, String cn)\n+  {\n+    int index = 0;\n+    int length = m.length();\n+    StringBuffer sb = new StringBuffer(length);\n+\n+    // Figure out the real method name\n+    if (m.startsWith(\"<init>\"))\n+      {\n+\tString className;\n+\tint i = cn.lastIndexOf('.');\n+\tif (i < 0)\n+\t  className = cn;\n+\telse\n+\t  className = cn.substring(i + 1);\n+\tsb.append(className);\n+\tindex += 7;\n+      }\n+    else\n+      {\n+\tint i = m.indexOf('(');\n+\tif (i > 0)\n+\t  {\n+\t    sb.append(m.substring(0,i));\n+\t    index += i + 1;\n+\t  }\n+      }\n+\n+    sb.append('(');\n+\n+    // Demangle the type arguments\n+    int arrayDepth = 0;\n+    char c = (index < length) ? m.charAt(index) : ')';\n+    while (c != ')')\n+      {\n+\tString type;\n+\tswitch(c)\n+\t{\n+          case 'B':\n+            type = \"byte\";\n+\t    break;\n+          case 'C':\n+            type = \"char\";\n+\t    break;\n+          case 'D':\n+            type = \"double\";\n+\t    break;\n+          case 'F':\n+            type = \"float\";\n+\t    break;\n+          case 'I':\n+            type = \"int\";\n+\t    break;\n+          case 'J':\n+            type = \"long\";\n+\t    break;\n+          case 'S':\n+            type = \"short\";\n+\t    break;\n+          case 'Z':\n+            type = \"boolean\";\n+\t    break;\n+          case 'L':\n+\t    int i = m.indexOf(';', index);\n+\t    if (i > 0)\n+\t      {\n+\t\ttype = m.substring(index+1, i);\n+\t\tindex = i;\n+\t      }\n+\t    else\n+\t      type = \"<unknown ref>\";\n+\t    break;\n+          case '[':\n+\t    type = \"\";\n+\t    arrayDepth++;\n+\t    break;\n+          default:\n+\t    type = \"<unknown \" + c + '>';\n+\t}\n+\tsb.append(type);\n+\n+\t// Handle arrays\n+\tif (c != '[' && arrayDepth > 0)\n+\t  while (arrayDepth > 0)\n+\t    {\n+\t      sb.append(\"[]\");\n+\t      arrayDepth--;\n+\t    }\n+\n+\tindex++;\n+\tchar nc = (index < length) ? m.charAt(index) : ')';\n+\tif (c != '[' && nc  != ')')\n+\t  sb.append(\", \");\n+\tc = nc;\n+      }\n+\n+    // Stop. We are not interested in the return type.\n+    sb.append(')');\n+    return sb.toString();\n+  }\n+\n   /**\n    * Releases all resources used by this NameFinder.\n    */"}, {"sha": "29687cb5bb9a377915dbc06eb23862384d1bb8ba", "filename": "libjava/gnu/gcj/runtime/natNameFinder.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc?ref=4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "patch": "@@ -95,17 +95,18 @@ gnu::gcj::runtime::NameFinder::lookupInterp(RawData* addrs, jint n)\n \n   _Jv_InterpMethod *meth\n     = reinterpret_cast<_Jv_InterpMethod *> (stack[n].interp);\n-  // FIXME: demangle.\n   java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n   sb->append(_Jv_NewStringUtf8Const(meth->self->name));\n   sb->append(_Jv_NewStringUtf8Const(meth->self->signature));\n   // FIXME: source file name and line number can be found from\n   // bytecode debug information.  But currently we don't keep that\n   // around.\n   // FIXME: is using the defining class correct here?\n+  java::lang::String *className = meth->defining_class->getName();\n+  java::lang::String *methodName\n+\t  = demangleInterpreterMethod(sb->toString(), className);\n   return new java::lang::StackTraceElement(NULL, -1,\n-\t\t\t\t\t   meth->defining_class->getName(),\n-\t\t\t\t\t   sb->toString(), false);\n+\t\t\t\t\t   className, methodName, false);\n #else // INTERPRETER\n   return NULL;\n #endif // INTERPRETER"}, {"sha": "ce897c23e0b9bf75ebdd8f2d5862ecebecaca03a", "filename": "libjava/java/lang/natVMThrowable.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5c703ec010dbc5d4fad628639ae2b346ae22e4/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMThrowable.cc?ref=4d5c703ec010dbc5d4fad628639ae2b346ae22e4", "patch": "@@ -72,7 +72,7 @@ java::lang::VMThrowable::fillInStackTrace (java::lang::Throwable* t)\n       state->length = n;\n       int len = n;\n       addrs = (_Jv_frame_info *) _Jv_Malloc (n * sizeof (_Jv_frame_info));\n-      while (n--)\n+      for (n = 0; n < len; n++)\n \t{\n \t  addrs[n].addr = p[n];\n #ifdef INTERPRETER"}]}