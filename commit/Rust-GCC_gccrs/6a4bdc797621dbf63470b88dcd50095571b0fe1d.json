{"sha": "6a4bdc797621dbf63470b88dcd50095571b0fe1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE0YmRjNzk3NjIxZGJmNjM0NzBiODhkY2Q1MDA5NTU3MWIwZmUxZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-06T23:11:51Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-07-06T23:11:51Z"}, "message": "emit-rtl.c (paradoxical_subreg_p): New function.\n\n\t* emit-rtl.c (paradoxical_subreg_p): New function.\n\t* rtl.h (paradoxical_subreg_p): Declare.\n\t* combine.c (set_nonzero_bits_and_sign_copies, get_last_value,\n\tapply_distributive_law, simplify_comparison, simplify_set): Use it.\n\t* cse.c (record_jump_cond, cse_insn): Likewise.\n\t* expr.c (force_operand): Likewise.\n\t* rtlanal.c (num_sign_bit_copies1): Likewise.\n\t* reload1.c (eliminate_regs_1, strip_paradoxical_subreg): Likewise.\n\t* reload.c (push_secondary_reload, find_reloads_toplev): Likewise.\n\t(push_reload): Use precision to check for paradoxical subregs.\n\t* expmed.c (extract_bit_field_1): Likewise.\n\nFrom-SVN: r175944", "tree": {"sha": "5f9f7faef58377378ef03c74cddbf4a06d8c42d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f9f7faef58377378ef03c74cddbf4a06d8c42d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a4bdc797621dbf63470b88dcd50095571b0fe1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4bdc797621dbf63470b88dcd50095571b0fe1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a4bdc797621dbf63470b88dcd50095571b0fe1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4bdc797621dbf63470b88dcd50095571b0fe1d/comments", "author": null, "committer": null, "parents": [{"sha": "76594d53186a78667bbb7b25f9231c396509a0a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76594d53186a78667bbb7b25f9231c396509a0a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76594d53186a78667bbb7b25f9231c396509a0a2"}], "stats": {"total": 130, "additions": 63, "deletions": 67}, "files": [{"sha": "92683184a13827aa0c479c22445dd2bf421313b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -1,3 +1,17 @@\n+2011-07-07  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* emit-rtl.c (paradoxical_subreg_p): New function.\n+\t* rtl.h (paradoxical_subreg_p): Declare.\n+\t* combine.c (set_nonzero_bits_and_sign_copies, get_last_value,\n+\tapply_distributive_law, simplify_comparison, simplify_set): Use it.\n+\t* cse.c (record_jump_cond, cse_insn): Likewise.\n+\t* expr.c (force_operand): Likewise.\n+\t* rtlanal.c (num_sign_bit_copies1): Likewise.\n+\t* reload1.c (eliminate_regs_1, strip_paradoxical_subreg): Likewise.\n+\t* reload.c (push_secondary_reload, find_reloads_toplev): Likewise.\n+\t(push_reload): Use precision to check for paradoxical subregs.\n+\t* expmed.c (extract_bit_field_1): Likewise.\n+\n 2011-07-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000-protos.h (rs6000_call_indirect_aix): New"}, {"sha": "afc56b1d847388cbd6cd721fa2d1958dcddd5d49", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -1610,9 +1610,7 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n \t set what we know about X.  */\n \n       if (SET_DEST (set) == x\n-\t  || (GET_CODE (SET_DEST (set)) == SUBREG\n-\t      && (GET_MODE_SIZE (GET_MODE (SET_DEST (set)))\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (set)))))\n+\t  || (paradoxical_subreg_p (SET_DEST (set))\n \t      && SUBREG_REG (SET_DEST (set)) == x))\n \t{\n \t  rtx src = SET_SRC (set);\n@@ -6564,8 +6562,7 @@ simplify_set (rtx x)\n       && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (src)))\n       && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))) != UNKNOWN\n       && SUBREG_BYTE (src) == 0\n-      && (GET_MODE_SIZE (GET_MODE (src))\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n+      && paradoxical_subreg_p (src)\n       && MEM_P (SUBREG_REG (src)))\n     {\n       SUBST (SET_SRC (x),\n@@ -9260,8 +9257,7 @@ apply_distributive_law (rtx x)\n \t  || ! subreg_lowpart_p (lhs)\n \t  || (GET_MODE_CLASS (GET_MODE (lhs))\n \t      != GET_MODE_CLASS (GET_MODE (SUBREG_REG (lhs))))\n-\t  || (GET_MODE_SIZE (GET_MODE (lhs))\n-\t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))))\n+\t  || paradoxical_subreg_p (lhs)\n \t  || VECTOR_MODE_P (GET_MODE (lhs))\n \t  || GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))) > UNITS_PER_WORD\n \t  /* Result might need to be truncated.  Don't change mode if\n@@ -11139,9 +11135,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  HOST_WIDE_INT c1 = INTVAL (XEXP (op1, 1));\n \t  int changed = 0;\n \n-\t  if (GET_CODE (inner_op0) == SUBREG && GET_CODE (inner_op1) == SUBREG\n-\t      && (GET_MODE_SIZE (GET_MODE (inner_op0))\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (inner_op0))))\n+\t  if (paradoxical_subreg_p (inner_op0)\n+\t      && GET_CODE (inner_op1) == SUBREG\n \t      && (GET_MODE (SUBREG_REG (inner_op0))\n \t\t  == GET_MODE (SUBREG_REG (inner_op1)))\n \t      && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (inner_op0)))\n@@ -11984,8 +11979,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n       && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op0))) == MODE_INT\n       && (code == NE || code == EQ))\n     {\n-      if (GET_MODE_SIZE (GET_MODE (op0))\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0))))\n+      if (paradoxical_subreg_p (op0))\n \t{\n \t  /* For paradoxical subregs, allow case 1 as above.  Case 3 isn't\n \t     implemented.  */\n@@ -12721,8 +12715,7 @@ get_last_value (const_rtx x)\n      we cannot predict what values the \"extra\" bits might have.  */\n   if (GET_CODE (x) == SUBREG\n       && subreg_lowpart_p (x)\n-      && (GET_MODE_SIZE (GET_MODE (x))\n-\t  <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+      && !paradoxical_subreg_p (x)\n       && (value = get_last_value (SUBREG_REG (x))) != 0)\n     return gen_lowpart (GET_MODE (x), value);\n "}, {"sha": "da4b1e1ee4712bb27ba568edbca797d2c213d9c6", "filename": "gcc/cse.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -3959,9 +3959,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n      is not worth testing for with no SUBREG).  */\n \n   /* Note that GET_MODE (op0) may not equal MODE.  */\n-  if (code == EQ && GET_CODE (op0) == SUBREG\n-      && (GET_MODE_SIZE (GET_MODE (op0))\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))))\n+  if (code == EQ && paradoxical_subreg_p (op0))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n       rtx tem = record_jump_cond_subreg (inner_mode, op1);\n@@ -3970,9 +3968,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t\t\t  reversed_nonequality);\n     }\n \n-  if (code == EQ && GET_CODE (op1) == SUBREG\n-      && (GET_MODE_SIZE (GET_MODE (op1))\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1)))))\n+  if (code == EQ && paradoxical_subreg_p (op1))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op1));\n       rtx tem = record_jump_cond_subreg (inner_mode, op0);\n@@ -4556,9 +4552,7 @@ cse_insn (rtx insn)\n \t treat it as volatile.  It may do the work of an SI in one context\n \t where the extra bits are not being used, but cannot replace an SI\n \t in general.  */\n-      if (GET_CODE (src) == SUBREG\n-\t  && (GET_MODE_SIZE (GET_MODE (src))\n-\t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n+      if (paradoxical_subreg_p (src))\n \tsets[i].src_volatile = 1;\n #endif\n \n@@ -4836,9 +4830,7 @@ cse_insn (rtx insn)\n \n \t  /* Also skip paradoxical subregs, unless that's what we're\n \t     looking for.  */\n-\t  if (code == SUBREG\n-\t      && (GET_MODE_SIZE (GET_MODE (p->exp))\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (p->exp))))\n+\t  if (paradoxical_subreg_p (p->exp)\n \t      && ! (src != 0\n \t\t    && GET_CODE (src) == SUBREG\n \t\t    && GET_MODE (src) == GET_MODE (p->exp)\n@@ -4947,9 +4939,7 @@ cse_insn (rtx insn)\n \t     size, but later may be adjusted so that the upper bits aren't\n \t     what we want.  So reject it.  */\n \t  if (elt != 0\n-\t      && GET_CODE (elt->exp) == SUBREG\n-\t      && (GET_MODE_SIZE (GET_MODE (elt->exp))\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (elt->exp))))\n+\t      && paradoxical_subreg_p (elt->exp)\n \t      /* It is okay, though, if the rtx we're trying to match\n \t\t will ignore any of the bits we can't predict.  */\n \t      && ! (src != 0\n@@ -5710,9 +5700,7 @@ cse_insn (rtx insn)\n \t       some tracking to be wrong.\n \n \t       ??? Think about this more later.  */\n-\t    || (GET_CODE (dest) == SUBREG\n-\t\t&& (GET_MODE_SIZE (GET_MODE (dest))\n-\t\t    > GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))\n+\t    || (paradoxical_subreg_p (dest)\n \t\t&& (GET_CODE (sets[i].src) == SIGN_EXTEND\n \t\t    || GET_CODE (sets[i].src) == ZERO_EXTEND)))\n \t  continue;"}, {"sha": "c641b7e6ca220b543bf6baf6d910871c29a8d6f0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -1334,6 +1334,16 @@ subreg_lowpart_p (const_rtx x)\n   return (subreg_lowpart_offset (GET_MODE (x), GET_MODE (SUBREG_REG (x)))\n \t  == SUBREG_BYTE (x));\n }\n+\n+/* Return true if X is a paradoxical subreg, false otherwise.  */\n+bool\n+paradoxical_subreg_p (const_rtx x)\n+{\n+  if (GET_CODE (x) != SUBREG)\n+    return false;\n+  return (GET_MODE_PRECISION (GET_MODE (x))\n+\t  > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (x))));\n+}\n \f\n /* Return subword OFFSET of operand OP.\n    The word number, OFFSET, is interpreted as the word number starting"}, {"sha": "8349b6fb87e9d3e4d69eefe3473dd0ef12af5552", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -1476,8 +1476,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t      && TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (xtarget), ext_mode))\n \t    {\n \t      xtarget = gen_lowpart (ext_mode, xtarget);\n-\t      if (GET_MODE_SIZE (ext_mode)\n-\t\t  > GET_MODE_SIZE (GET_MODE (xspec_target)))\n+\t      if (GET_MODE_PRECISION (ext_mode)\n+\t\t  > GET_MODE_PRECISION (GET_MODE (xspec_target)))\n \t\txspec_target_subreg = xtarget;\n \t    }\n \t  else"}, {"sha": "af4c2fb8826ed6bca478d97bd3448822ef0690ce", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -6497,9 +6497,7 @@ force_operand (rtx value, rtx target)\n #ifdef INSN_SCHEDULING\n   /* On machines that have insn scheduling, we want all memory reference to be\n      explicit, so we need to deal with such paradoxical SUBREGs.  */\n-  if (GET_CODE (value) == SUBREG && MEM_P (SUBREG_REG (value))\n-      && (GET_MODE_SIZE (GET_MODE (value))\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (value)))))\n+  if (paradoxical_subreg_p (value) && MEM_P (SUBREG_REG (value)))\n     value\n       = simplify_gen_subreg (GET_MODE (value),\n \t\t\t     force_reg (GET_MODE (SUBREG_REG (value)),"}, {"sha": "605f23d596269ac2bc91f3e7489a1fb42c2a90f3", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -347,9 +347,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n   /* If X is a paradoxical SUBREG, use the inner value to determine both the\n      mode and object being reloaded.  */\n-  if (GET_CODE (x) == SUBREG\n-      && (GET_MODE_SIZE (GET_MODE (x))\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+  if (paradoxical_subreg_p (x))\n     {\n       x = SUBREG_REG (x);\n       reload_mode = GET_MODE (x);\n@@ -1026,20 +1024,20 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  || (((REG_P (SUBREG_REG (in))\n \t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n \t       || MEM_P (SUBREG_REG (in)))\n-\t      && ((GET_MODE_SIZE (inmode)\n-\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n+\t      && ((GET_MODE_PRECISION (inmode)\n+\t\t   > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n #ifdef LOAD_EXTEND_OP\n \t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n \t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t  <= UNITS_PER_WORD)\n-\t\t      && (GET_MODE_SIZE (inmode)\n-\t\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n+\t\t      && (GET_MODE_PRECISION (inmode)\n+\t\t\t  > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n \t\t      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (in)))\n \t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != UNKNOWN)\n #endif\n #ifdef WORD_REGISTER_OPERATIONS\n-\t\t  || ((GET_MODE_SIZE (inmode)\n-\t\t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n+\t\t  || ((GET_MODE_PRECISION (inmode)\n+\t\t       < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n \t\t      && ((GET_MODE_SIZE (inmode) - 1) / UNITS_PER_WORD ==\n \t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) - 1)\n \t\t\t   / UNITS_PER_WORD)))\n@@ -1134,11 +1132,11 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  || (((REG_P (SUBREG_REG (out))\n \t\t&& REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER)\n \t       || MEM_P (SUBREG_REG (out)))\n-\t      && ((GET_MODE_SIZE (outmode)\n-\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n+\t      && ((GET_MODE_PRECISION (outmode)\n+\t\t   > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n #ifdef WORD_REGISTER_OPERATIONS\n-\t\t  || ((GET_MODE_SIZE (outmode)\n-\t\t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n+\t\t  || ((GET_MODE_PRECISION (outmode)\n+\t\t       < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n \t\t      && ((GET_MODE_SIZE (outmode) - 1) / UNITS_PER_WORD ==\n \t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) - 1)\n \t\t\t   / UNITS_PER_WORD)))\n@@ -4752,16 +4750,15 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \n       if (regno >= FIRST_PSEUDO_REGISTER\n #ifdef LOAD_EXTEND_OP\n-\t       && (GET_MODE_SIZE (GET_MODE (x))\n-\t\t   <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t  && !paradoxical_subreg_p (x)\n #endif\n-\t       && (reg_equiv_address (regno) != 0\n-\t\t   || (reg_equiv_mem (regno) != 0\n-\t\t       && (! strict_memory_address_addr_space_p\n-\t\t\t       (GET_MODE (x), XEXP (reg_equiv_mem (regno), 0),\n-\t\t\t\tMEM_ADDR_SPACE (reg_equiv_mem (regno)))\n-\t\t\t   || ! offsettable_memref_p (reg_equiv_mem (regno))\n-\t\t\t   || num_not_at_initial_offset))))\n+\t  && (reg_equiv_address (regno) != 0\n+\t      || (reg_equiv_mem (regno) != 0\n+\t\t  && (! strict_memory_address_addr_space_p\n+\t\t      (GET_MODE (x), XEXP (reg_equiv_mem (regno), 0),\n+\t\t       MEM_ADDR_SPACE (reg_equiv_mem (regno)))\n+\t\t      || ! offsettable_memref_p (reg_equiv_mem (regno))\n+\t\t      || num_not_at_initial_offset))))\n \tx = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,\n \t\t\t\t\t   insn, address_reloaded);\n     }"}, {"sha": "7f84fc81416a033ea9c50b92c306b12fd5ad2d8a", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -2840,8 +2840,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t eliminated version of the memory location because push_reload\n \t may do the replacement in certain circumstances.  */\n       if (REG_P (SUBREG_REG (x))\n-\t  && (GET_MODE_SIZE (GET_MODE (x))\n-\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t  && !paradoxical_subreg_p (x)\n \t  && reg_equivs\n \t  && reg_equiv_memory_loc (REGNO (SUBREG_REG (x))) != 0)\n \t{\n@@ -4495,12 +4494,9 @@ strip_paradoxical_subreg (rtx *op_ptr, rtx *other_ptr)\n   rtx op, inner, other, tem;\n \n   op = *op_ptr;\n-  if (GET_CODE (op) != SUBREG)\n+  if (!paradoxical_subreg_p (op))\n     return false;\n-\n   inner = SUBREG_REG (op);\n-  if (GET_MODE_SIZE (GET_MODE (op)) <= GET_MODE_SIZE (GET_MODE (inner)))\n-    return false;\n \n   other = *other_ptr;\n   tem = gen_lowpart_common (GET_MODE (inner), other);"}, {"sha": "ac3c87112c79efb5b5247ba67379d70f03089a8e", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -1633,6 +1633,7 @@ extern rtx operand_subword (rtx, unsigned int, int, enum machine_mode);\n \n /* In emit-rtl.c */\n extern rtx operand_subword_force (rtx, unsigned int, enum machine_mode);\n+extern bool paradoxical_subreg_p (const_rtx);\n extern int subreg_lowpart_p (const_rtx);\n extern unsigned int subreg_lowpart_offset (enum machine_mode,\n \t\t\t\t\t   enum machine_mode);"}, {"sha": "2dfbd8fe11435b2015a92c9ca50e9fe6b19a492e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bdc797621dbf63470b88dcd50095571b0fe1d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=6a4bdc797621dbf63470b88dcd50095571b0fe1d", "patch": "@@ -4483,8 +4483,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t then we lose all sign bit copies that existed before the store\n \t to the stack.  */\n \n-      if ((GET_MODE_SIZE (GET_MODE (x))\n-\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+      if (paradoxical_subreg_p (x)\n \t  && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) == SIGN_EXTEND\n \t  && MEM_P (SUBREG_REG (x)))\n \treturn cached_num_sign_bit_copies (SUBREG_REG (x), mode,"}]}