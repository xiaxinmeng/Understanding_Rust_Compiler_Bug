{"sha": "bea002e923bdea212f928b3b9f5b9ff0c3941fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVhMDAyZTkyM2JkZWEyMTJmOTI4YjNiOWY1YjlmZjBjMzk0MWZkOQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-11-13T09:06:43Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-11-13T09:06:43Z"}, "message": "GCOV: remove typedef for block_t\n\n2017-11-13  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (struct block_info): Remove typedef for block_t.\n\t(struct line_info): Likewise.\n\t(line_info::has_block): Likewise.\n\t(EXIT_BLOCK): Likewise.\n\t(unblock): Likewise.\n\t(circuit): Likewise.\n\t(get_cycles_count): Likewise.\n\t(process_file): Likewise.\n\t(read_graph_file): Likewise.\n\t(solve_flow_graph): Likewise.\n\t(find_exception_blocks): Likewise.\n\t(add_line_counts): Likewise.\n\t(accumulate_line_info): Likewise.\n\t(output_line_details): Likewise.\n\nFrom-SVN: r254677", "tree": {"sha": "3a459c870dba97d3c2053974e1d2df6063b8636a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a459c870dba97d3c2053974e1d2df6063b8636a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bea002e923bdea212f928b3b9f5b9ff0c3941fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bea002e923bdea212f928b3b9f5b9ff0c3941fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bea002e923bdea212f928b3b9f5b9ff0c3941fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bea002e923bdea212f928b3b9f5b9ff0c3941fd9/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "232c80f2d134d37a3d7b33113bffb03262ed1559", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/232c80f2d134d37a3d7b33113bffb03262ed1559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/232c80f2d134d37a3d7b33113bffb03262ed1559"}], "stats": {"total": 69, "additions": 43, "deletions": 26}, "files": [{"sha": "92c09ef992d5e31159fa64c9bfb6ce5cecc1a549", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bea002e923bdea212f928b3b9f5b9ff0c3941fd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bea002e923bdea212f928b3b9f5b9ff0c3941fd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bea002e923bdea212f928b3b9f5b9ff0c3941fd9", "patch": "@@ -1,3 +1,20 @@\n+2017-11-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (struct block_info): Remove typedef for block_t.\n+\t(struct line_info): Likewise.\n+\t(line_info::has_block): Likewise.\n+\t(EXIT_BLOCK): Likewise.\n+\t(unblock): Likewise.\n+\t(circuit): Likewise.\n+\t(get_cycles_count): Likewise.\n+\t(process_file): Likewise.\n+\t(read_graph_file): Likewise.\n+\t(solve_flow_graph): Likewise.\n+\t(find_exception_blocks): Likewise.\n+\t(add_line_counts): Likewise.\n+\t(accumulate_line_info): Likewise.\n+\t(output_line_details): Likewise.\n+\n 2017-11-13  Martin Liska  <mliska@suse.cz>\n \n \t* gcov.c (struct arc_info): Remove typedef for arc_t."}, {"sha": "c6a0a06659324aeb8bc70b59d838a594634c0ea9", "filename": "gcc/gcov.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bea002e923bdea212f928b3b9f5b9ff0c3941fd9/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bea002e923bdea212f928b3b9f5b9ff0c3941fd9/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=bea002e923bdea212f928b3b9f5b9ff0c3941fd9", "patch": "@@ -131,7 +131,7 @@ struct block_location_info\n /* Describes a basic block. Contains lists of arcs to successor and\n    predecessor blocks.  */\n \n-typedef struct block_info\n+struct block_info\n {\n   /* Constructor.  */\n   block_info ();\n@@ -175,7 +175,7 @@ typedef struct block_info\n      line.  */\n   struct block_info *chain;\n \n-} block_t;\n+};\n \n block_info::block_info (): succ (NULL), pred (NULL), num_succ (0), num_pred (0),\n   id (0), count (0), count_valid (0), valid_chain (0), invalid_chain (0),\n@@ -194,7 +194,7 @@ struct line_info\n   line_info ();\n \n   /* Return true when NEEDLE is one of basic blocks the line belongs to.  */\n-  bool has_block (block_t *needle);\n+  bool has_block (block_info *needle);\n \n   /* Execution count.  */\n   gcov_type count;\n@@ -203,7 +203,7 @@ struct line_info\n   vector<arc_info *> branches;\n \n   /* blocks which start on this line.  Used in all-blocks mode.  */\n-  vector<block_t *> blocks;\n+  vector<block_info *> blocks;\n \n   unsigned exists : 1;\n   unsigned unexceptional : 1;\n@@ -216,7 +216,7 @@ line_info::line_info (): count (0), branches (), blocks (), exists (false),\n }\n \n bool\n-line_info::has_block (block_t *needle)\n+line_info::has_block (block_info *needle)\n {\n   return std::find (blocks.begin (), blocks.end (), needle) != blocks.end ();\n }\n@@ -261,7 +261,7 @@ struct function_info\n      at blocks[0] and the exit block is at blocks[1].  */\n #define ENTRY_BLOCK (0)\n #define EXIT_BLOCK (1)\n-  vector<block_t> blocks;\n+  vector<block_info> blocks;\n   unsigned blocks_executed;\n \n   /* Raw arc coverage counts.  */\n@@ -601,7 +601,7 @@ bool function_info::group_line_p (unsigned n, unsigned src_idx)\n    */\n \n typedef vector<arc_info *> arc_vector_t;\n-typedef vector<const block_t *> block_vector_t;\n+typedef vector<const block_info *> block_vector_t;\n \n /* Enum with types of loop in CFG.  */\n \n@@ -646,7 +646,7 @@ handle_cycle (const arc_vector_t &edges, int64_t &count)\n    blocked by U in BLOCK_LISTS.  */\n \n static void\n-unblock (const block_t *u, block_vector_t &blocked,\n+unblock (const block_info *u, block_vector_t &blocked,\n \t vector<block_vector_t > &block_lists)\n {\n   block_vector_t::iterator it = find (blocked.begin (), blocked.end (), u);\n@@ -671,7 +671,7 @@ unblock (const block_t *u, block_vector_t &blocked,\n    Returns what type of loop it contains.  */\n \n static loop_type\n-circuit (block_t *v, arc_vector_t &path, block_t *start,\n+circuit (block_info *v, arc_vector_t &path, block_info *start,\n \t block_vector_t &blocked, vector<block_vector_t> &block_lists,\n \t line_info &linfo, int64_t &count)\n {\n@@ -684,7 +684,7 @@ circuit (block_t *v, arc_vector_t &path, block_t *start,\n \n   for (arc_info *arc = v->succ; arc; arc = arc->succ_next)\n     {\n-      block_t *w = arc->dst;\n+      block_info *w = arc->dst;\n       if (w < start || !linfo.has_block (w))\n \tcontinue;\n \n@@ -703,7 +703,7 @@ circuit (block_t *v, arc_vector_t &path, block_t *start,\n   else\n     for (arc_info *arc = v->succ; arc; arc = arc->succ_next)\n       {\n-\tblock_t *w = arc->dst;\n+\tblock_info *w = arc->dst;\n \tif (w < start || !linfo.has_block (w))\n \t  continue;\n \n@@ -732,7 +732,7 @@ get_cycles_count (line_info &linfo, bool handle_negative_cycles = true)\n \n   loop_type result = NO_LOOP;\n   gcov_type count = 0;\n-  for (vector<block_t *>::iterator it = linfo.blocks.begin ();\n+  for (vector<block_info *>::iterator it = linfo.blocks.begin ();\n        it != linfo.blocks.end (); it++)\n     {\n       arc_vector_t path;\n@@ -1177,7 +1177,7 @@ process_file (const char *file_name)\n \t  for (unsigned block_no = 0; block_no != fn->blocks.size ();\n \t       block_no++)\n \t    {\n-\t      block_t *block = &fn->blocks[block_no];\n+\t      block_info *block = &fn->blocks[block_no];\n \t      for (unsigned i = 0; i < block->locations.size (); i++)\n \t\t{\n \t\t  /* Sort lines of locations.  */\n@@ -1607,7 +1607,7 @@ read_graph_file (void)\n \t  unsigned src = gcov_read_unsigned ();\n \t  fn->blocks[src].id = src;\n \t  unsigned num_dests = GCOV_TAG_ARCS_NUM (length);\n-\t  block_t *src_blk = &fn->blocks[src];\n+\t  block_info *src_blk = &fn->blocks[src];\n \t  unsigned mark_catches = 0;\n \t  struct arc_info *arc;\n \n@@ -1680,7 +1680,7 @@ read_graph_file (void)\n       else if (fn && tag == GCOV_TAG_LINES)\n \t{\n \t  unsigned blockno = gcov_read_unsigned ();\n-\t  block_t *block = &fn->blocks[blockno];\n+\t  block_info *block = &fn->blocks[blockno];\n \n \t  if (blockno >= fn->blocks.size ())\n \t    goto corrupt;\n@@ -1842,9 +1842,9 @@ solve_flow_graph (function_info *fn)\n   unsigned ix;\n   arc_info *arc;\n   gcov_type *count_ptr = &fn->counts.front ();\n-  block_t *blk;\n-  block_t *valid_blocks = NULL;    /* valid, but unpropagated blocks.  */\n-  block_t *invalid_blocks = NULL;  /* invalid, but inferable blocks.  */\n+  block_info *blk;\n+  block_info *valid_blocks = NULL;    /* valid, but unpropagated blocks.  */\n+  block_info *invalid_blocks = NULL;  /* invalid, but inferable blocks.  */\n \n   /* The arcs were built in reverse order.  Fix that now.  */\n   for (ix = fn->blocks.size (); ix--;)\n@@ -1895,7 +1895,7 @@ solve_flow_graph (function_info *fn)\n   for (unsigned i = 0; i < fn->blocks.size (); i++)\n     {\n       blk = &fn->blocks[i];\n-      block_t const *prev_dst = NULL;\n+      block_info const *prev_dst = NULL;\n       int out_of_order = 0;\n       int non_fake_succ = 0;\n \n@@ -2013,7 +2013,7 @@ solve_flow_graph (function_info *fn)\n \t  blk->valid_chain = 0;\n \t  if (blk->num_succ == 1)\n \t    {\n-\t      block_t *dst;\n+\t      block_info *dst;\n \n \t      total = blk->count;\n \t      inv_arc = NULL;\n@@ -2049,7 +2049,7 @@ solve_flow_graph (function_info *fn)\n \t    }\n \t  if (blk->num_pred == 1)\n \t    {\n-\t      block_t *src;\n+\t      block_info *src;\n \n \t      total = blk->count;\n \t      inv_arc = NULL;\n@@ -2103,7 +2103,7 @@ static void\n find_exception_blocks (function_info *fn)\n {\n   unsigned ix;\n-  block_t **queue = XALLOCAVEC (block_t *, fn->blocks.size ());\n+  block_info **queue = XALLOCAVEC (block_info *, fn->blocks.size ());\n \n   /* First mark all blocks as exceptional.  */\n   for (ix = fn->blocks.size (); ix--;)\n@@ -2114,7 +2114,7 @@ find_exception_blocks (function_info *fn)\n   queue[0]->exceptional = 0;\n   for (ix = 1; ix;)\n     {\n-      block_t *block = queue[--ix];\n+      block_info *block = queue[--ix];\n       const arc_info *arc;\n \n       for (arc = block->succ; arc; arc = arc->succ_next)\n@@ -2486,7 +2486,7 @@ add_line_counts (coverage_t *coverage, function_info *fn)\n   for (unsigned ix = 0; ix != fn->blocks.size (); ix++)\n     {\n       line_info *line = NULL;\n-      block_t *block = &fn->blocks[ix];\n+      block_info *block = &fn->blocks[ix];\n       if (block->count && ix && ix + 1 != fn->blocks.size ())\n \tfn->blocks_executed++;\n       for (unsigned i = 0; i < block->locations.size (); i++)\n@@ -2582,7 +2582,7 @@ static void accumulate_line_info (line_info *line, source_info *src,\n       gcov_type count = 0;\n \n       /* Cycle detection.  */\n-      for (vector<block_t *>::iterator it = line->blocks.begin ();\n+      for (vector<block_info *>::iterator it = line->blocks.begin ();\n \t   it != line->blocks.end (); it++)\n \t{\n \t  for (arc_info *arc = (*it)->pred; arc; arc = arc->pred_next)\n@@ -2846,7 +2846,7 @@ output_line_details (FILE *f, const line_info *line, unsigned line_num)\n       int ix, jx;\n \n       ix = jx = 0;\n-      for (vector<block_t *>::const_iterator it = line->blocks.begin ();\n+      for (vector<block_info *>::const_iterator it = line->blocks.begin ();\n \t   it != line->blocks.end (); it++)\n \t{\n \t  if (!(*it)->is_call_return)"}]}