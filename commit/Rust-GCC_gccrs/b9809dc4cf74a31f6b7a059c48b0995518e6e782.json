{"sha": "b9809dc4cf74a31f6b7a059c48b0995518e6e782", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4MDlkYzRjZjc0YTMxZjZiN2EwNTljNDhiMDk5NTUxOGU2ZTc4Mg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-02-19T02:14:17Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-02-19T02:14:17Z"}, "message": "re PR target/60203 (Support long double/_Decimal128 direct move on power8)\n\n2014-02-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/60203\n\t* config/rs6000/rs6000.md (mov<mode>_64bit, TF/TDmode moves):\n\tSplit 64-bit moves into 2 patterns.  Do not allow the use of\n\tdirect move for TDmode in little endian, since the decimal value\n\thas little endian bytes within a word, but the 64-bit pieces are\n\tordered in a big endian fashion, and normal subreg's of TDmode are\n\tnot allowed.\n\t(mov<mode>_64bit_dm): Likewise.\n\t(movtd_64bit_nodm): Likewise.\n\nFrom-SVN: r207868", "tree": {"sha": "58fca839fbf8f8be51078d382be8b1a2755ae116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58fca839fbf8f8be51078d382be8b1a2755ae116"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9809dc4cf74a31f6b7a059c48b0995518e6e782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9809dc4cf74a31f6b7a059c48b0995518e6e782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9809dc4cf74a31f6b7a059c48b0995518e6e782", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9809dc4cf74a31f6b7a059c48b0995518e6e782/comments", "author": null, "committer": null, "parents": [{"sha": "4785ca2660e8b37ca1e37e2da6534ed72b5b4714", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4785ca2660e8b37ca1e37e2da6534ed72b5b4714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4785ca2660e8b37ca1e37e2da6534ed72b5b4714"}], "stats": {"total": 32, "additions": 31, "deletions": 1}, "files": [{"sha": "6e3c8546c79fce878fd4865706e922b846d40c9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9809dc4cf74a31f6b7a059c48b0995518e6e782/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9809dc4cf74a31f6b7a059c48b0995518e6e782/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9809dc4cf74a31f6b7a059c48b0995518e6e782", "patch": "@@ -1,3 +1,15 @@\n+2014-02-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/60203\n+\t* config/rs6000/rs6000.md (mov<mode>_64bit, TF/TDmode moves):\n+\tSplit 64-bit moves into 2 patterns.  Do not allow the use of\n+\tdirect move for TDmode in little endian, since the decimal value\n+\thas little endian bytes within a word, but the 64-bit pieces are\n+\tordered in a big endian fashion, and normal subreg's of TDmode are\n+\tnot allowed.\n+\t(mov<mode>_64bit_dm): Likewise.\n+\t(movtd_64bit_nodm): Likewise.\n+\n 2014-02-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR tree-optimization/60174"}, {"sha": "b0d44c9a84fc0645065f030c62c6dd38b316dfec", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9809dc4cf74a31f6b7a059c48b0995518e6e782/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9809dc4cf74a31f6b7a059c48b0995518e6e782/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b9809dc4cf74a31f6b7a059c48b0995518e6e782", "patch": "@@ -9526,10 +9526,16 @@\n ;; It's important to list Y->r and r->Y before r->r because otherwise\n ;; reload, given m->r, will try to pick r->r and reload it, which\n ;; doesn't make progress.\n-(define_insn_and_split \"*mov<mode>_64bit\"\n+\n+;; We can't split little endian direct moves of TDmode, because the words are\n+;; not swapped like they are for TImode or TFmode.  Subregs therefore are\n+;; problematical.  Don't allow direct move for this case.\n+\n+(define_insn_and_split \"*mov<mode>_64bit_dm\"\n   [(set (match_operand:FMOVE128 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r,r,wm\")\n \t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,r,YGHF,r,wm,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64\n+   && (<MODE>mode != TDmode || WORDS_BIG_ENDIAN)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n@@ -9538,6 +9544,18 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n   [(set_attr \"length\" \"8,8,8,12,12,8,8,8\")])\n \n+(define_insn_and_split \"*movtd_64bit_nodm\"\n+  [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n+\t(match_operand:TD 1 \"input_operand\" \"d,m,d,r,YGHF,r\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64 && !WORDS_BIG_ENDIAN\n+   && (gpc_reg_operand (operands[0], TDmode)\n+       || gpc_reg_operand (operands[1], TDmode))\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+  [(set_attr \"length\" \"8,8,8,12,12,8\")])\n+\n (define_insn_and_split \"*mov<mode>_32bit\"\n   [(set (match_operand:FMOVE128 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n \t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,r,YGHF,r\"))]"}]}