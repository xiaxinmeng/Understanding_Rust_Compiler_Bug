{"sha": "3071fab5054b156e506212b86c62d614bd10e284", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA3MWZhYjUwNTRiMTU2ZTUwNjIxMmI4NmM2MmQ2MTRiZDEwZTI4NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-29T21:45:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-29T21:45:05Z"}, "message": "flow.c (count_or_remove_death_notes): Equate NULL with the universal set.\n\n        * flow.c (count_or_remove_death_notes): Equate NULL with the\n        universal set.\n\n        * jump.c, reg-stack.c, toplev.c: Revert Oct 27 change.\n        * toplev.c (rest_of_compilation): Rebuild CFG immediately before\n        dbr_schedule.\n\n        * i386.c (pic_label_no): Delete.\n        (ix86_attr_length_default): Don't use single_set to peek\n        inside a parallel.\n\n        * recog.c (peephole2_optimize): Allow recog_next_insn to index\n        the first insn after bb->end.\n        * i386.md (push mem peeps): Scratch is live after evaluation\n        of the memory.\n        (cmp mem peep): Similarly.\n\nFrom-SVN: r30269", "tree": {"sha": "694b8a79795d85b96e8abf582b97facd64974497", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/694b8a79795d85b96e8abf582b97facd64974497"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3071fab5054b156e506212b86c62d614bd10e284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3071fab5054b156e506212b86c62d614bd10e284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3071fab5054b156e506212b86c62d614bd10e284", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3071fab5054b156e506212b86c62d614bd10e284/comments", "author": null, "committer": null, "parents": [{"sha": "ed598dde43da766e72a6abf0f2b4622392b0fecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed598dde43da766e72a6abf0f2b4622392b0fecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed598dde43da766e72a6abf0f2b4622392b0fecd"}], "stats": {"total": 120, "additions": 70, "deletions": 50}, "files": [{"sha": "37642fcfab5e4d1687dc72dfca00b1599ee6417b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3071fab5054b156e506212b86c62d614bd10e284/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3071fab5054b156e506212b86c62d614bd10e284/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3071fab5054b156e506212b86c62d614bd10e284", "patch": "@@ -1,3 +1,22 @@\n+Fri Oct 29 14:34:17 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (count_or_remove_death_notes): Equate NULL with the\n+\tuniversal set.\n+\n+\t* jump.c, reg-stack.c, toplev.c: Revert Oct 27 change.\n+\t* toplev.c (rest_of_compilation): Rebuild CFG immediately before\n+\tdbr_schedule.\n+\n+\t* i386.c (pic_label_no): Delete.\n+\t(ix86_attr_length_default): Don't use single_set to peek\n+\tinside a parallel.\n+\n+\t* recog.c (peephole2_optimize): Allow recog_next_insn to index\n+\tthe first insn after bb->end.\n+\t* i386.md (push mem peeps): Scratch is live after evaluation\n+\tof the memory.\n+\t(cmp mem peep): Similarly.\n+\n Fri Oct 29 11:50:11 1999  Catherine Moore  <clm@cygnus.com>\n \n \t* calls.c (emit_library_call_value): Fix declaration of alignment_pad."}, {"sha": "43bc4eebc39d409e77f5030ca639d853380534c6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3071fab5054b156e506212b86c62d614bd10e284", "patch": "@@ -178,8 +178,6 @@ struct machine_function\n   rtx stack_locals[(int) MAX_MACHINE_MODE][MAX_386_STACK_LOCALS];\n };\n \n-static int pic_label_no = 0;\n-\n #define ix86_stack_locals (current_function->machine->stack_locals)\n \n /* which cpu are we scheduling for */\n@@ -5180,8 +5178,24 @@ ix86_attr_length_default (insn)\n       break;\n \n     case TYPE_LEA:\n-      len += memory_address_length (SET_SRC (single_set (insn)));\n-      goto just_opcode;\n+      {\n+        /* Irritatingly, single_set doesn't work with REG_UNUSED present,\n+\t   as we'll get from running life_analysis during reg-stack when\n+\t   not optimizing.  */\n+        rtx set = PATTERN (insn);\n+        if (GET_CODE (set) == SET)\n+\t  ;\n+\telse if (GET_CODE (set) == PARALLEL\n+\t\t && XVECLEN (set, 0) == 2\n+\t\t && GET_CODE (XVECEXP (set, 0, 0)) == SET\n+\t\t && GET_CODE (XVECEXP (set, 0, 1)) == CLOBBER)\n+\t  set = XVECEXP (set, 0, 0);\n+\telse\n+\t  abort ();\n+\n+\tlen += memory_address_length (SET_SRC (set));\n+\tgoto just_opcode;\n+      }\n \n     case TYPE_OTHER: \n     case TYPE_MULTI:"}, {"sha": "73a9e98ee5acd74ceebb34fcf85c9bea6742f5d8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3071fab5054b156e506212b86c62d614bd10e284", "patch": "@@ -7731,27 +7731,27 @@\n \n ;; Don't push memory operands\n (define_peephole2\n-  [(match_scratch:SI 2 \"r\")\n-   (set (match_operand:SI 0 \"push_operand\" \"\")\n-\t(match_operand:SI 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:SI 0 \"push_operand\" \"\")\n+\t(match_operand:SI 1 \"memory_operand\" \"\"))\n+   (match_scratch:SI 2 \"r\")]\n   \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n \n (define_peephole2\n-  [(match_scratch:HI 2 \"r\")\n-   (set (match_operand:HI 0 \"push_operand\" \"\")\n-\t(match_operand:HI 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:HI 0 \"push_operand\" \"\")\n+\t(match_operand:HI 1 \"memory_operand\" \"\"))\n+   (match_scratch:HI 2 \"r\")]\n   \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n \n (define_peephole2\n-  [(match_scratch:QI 2 \"q\")\n-   (set (match_operand:QI 0 \"push_operand\" \"\")\n-\t(match_operand:QI 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:QI 0 \"push_operand\" \"\")\n+\t(match_operand:QI 1 \"memory_operand\" \"\"))\n+   (match_scratch:QI 2 \"q\")]\n   \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n@@ -7827,10 +7827,10 @@\n \n ;; Don't compare memory with zero, load and use a test instead.\n (define_peephole2\n-  [(match_scratch:SI 3 \"r\")\n-   (set (reg:CCNO 17)\n+  [(set (reg:CCNO 17)\n \t(compare:CCNO (match_operand:SI 0 \"memory_operand\" \"\")\n-\t(const_int 0)))]\n+\t(const_int 0)))\n+   (match_scratch:SI 3 \"r\")]\n   \"! optimize_size\"\n    [(set (match_dup 3) (match_dup 0))\n     (set (reg:CCNO 17) (compare:CCNO (match_dup 3) (const_int 0)))]"}, {"sha": "19d50b0870d74c256e97c6d61943ab93096bffdd", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=3071fab5054b156e506212b86c62d614bd10e284", "patch": "@@ -5748,7 +5748,8 @@ recompute_reg_usage (f, loop_step)\n }\n \n /* Optionally removes all the REG_DEAD and REG_UNUSED notes from a set of\n-   blocks.  Returns a count of the number of registers that died.  */\n+   blocks.  If BLOCKS is NULL, assume the universal set.  Returns a count\n+   of the number of registers that died.  */\n \n int\n count_or_remove_death_notes (blocks, kill)\n@@ -5762,7 +5763,7 @@ count_or_remove_death_notes (blocks, kill)\n       basic_block bb;\n       rtx insn;\n \n-      if (! TEST_BIT (blocks, i))\n+      if (blocks && ! TEST_BIT (blocks, i))\n \tcontinue;\n \n       bb = BASIC_BLOCK (i);"}, {"sha": "72a13589af0893b0251997076c16256254be05e6", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=3071fab5054b156e506212b86c62d614bd10e284", "patch": "@@ -66,8 +66,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"real.h\"\n #include \"except.h\"\n-#include \"basic-block.h\"\n-#include \"output.h\"\n #include \"toplev.h\"\n \n /* ??? Eventually must record somehow the labels used by jumps\n@@ -192,7 +190,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n   int first = 1;\n   int max_uid = 0;\n   rtx last_insn;\n-  int did_cross_jump = 0;\n \n   cross_jump_death_matters = (cross_jump == 2);\n   max_uid = init_label_info (f) + 1;\n@@ -2130,7 +2127,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n \t\t  if (newjpos != 0)\n \t\t    {\n-\t\t      did_cross_jump = 1;\n \t\t      do_cross_jump (insn, newjpos, newlpos);\n \t\t      /* Make the old conditional jump\n \t\t\t into an unconditional one.  */\n@@ -2183,7 +2179,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n \t\t  if (newjpos != 0)\n \t\t    {\n-\t\t      did_cross_jump = 1;\n \t\t      do_cross_jump (insn, newjpos, newlpos);\n \t\t      changed = 1;\n \t\t      next = insn;\n@@ -2215,7 +2210,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n \t\t  if (newjpos != 0)\n \t\t    {\n-\t\t      did_cross_jump = 1;\n \t\t      do_cross_jump (insn, newjpos, newlpos);\n \t\t      changed = 1;\n \t\t      next = insn;\n@@ -2280,23 +2274,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n   /* Show JUMP_CHAIN no longer valid.  */\n   jump_chain = 0;\n-\n-#if defined(DELAY_SLOTS) || defined(STACK_REGS)\n-  /* ??? Keep the CFG up to date after cross-jumping.  */\n-  if (did_cross_jump && !cross_jump_death_matters)\n-    {\n-      sbitmap blocks;\n-\n-      find_basic_blocks (f, old_max_reg, NULL, 0);\n-\n-      blocks = sbitmap_alloc (n_basic_blocks);\n-      sbitmap_ones (blocks);\n-      count_or_remove_death_notes (blocks, 1);\n-      sbitmap_free (blocks);\n-\n-      life_analysis (f, old_max_reg, NULL, 0);\n-    }\n-#endif\n }\n \f\n /* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL"}, {"sha": "1246ca8ef78553c5b352d01586f8dcc9cd37603a", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=3071fab5054b156e506212b86c62d614bd10e284", "patch": "@@ -2730,7 +2730,7 @@ peephole2_optimize (dump_file)\n \t care about subsequent life info; recog_last_allowed_insn to\n \t restrict how far forward we will allow the match to proceed.  */\n \n-      recog_last_allowed_insn = bb->end;\n+      recog_last_allowed_insn = NEXT_INSN (bb->end);\n       for (insn = bb->end; ; insn = prev)\n \t{\n \t  prev = PREV_INSN (insn);\n@@ -2749,7 +2749,7 @@ peephole2_optimize (dump_file)\n \t\t  if (insn == bb->head)\n \t\t    bb->head = NEXT_INSN (prev);\n \n-\t\t  recog_last_allowed_insn = prev;\n+\t\t  recog_last_allowed_insn = NEXT_INSN (prev);\n \t\t  SET_BIT (blocks, i);\n \t\t  changed = 1;\n \t\t}"}, {"sha": "6f8883bbbbe532543f492d25795aa895313f3b64", "filename": "gcc/toplev.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3071fab5054b156e506212b86c62d614bd10e284/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3071fab5054b156e506212b86c62d614bd10e284", "patch": "@@ -4319,7 +4319,16 @@ rest_of_compilation (decl)\n       if (dbr_sched_dump)\n \topen_dump_file (\".19.dbr\", decl_printable_name (decl, 2));\n \n-      TIMEVAR (dbr_sched_time, dbr_schedule (insns, rtl_dump_file));\n+      TIMEVAR\n+\t(dbr_sched_time,\n+\t {\n+           /* ??? Keep the CFG up to date after cross-jumping.  */\n+\t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n+\t   count_or_remove_death_notes (NULL, 1);\n+\t   life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n+\n+           dbr_schedule (insns, rtl_dump_file);\n+\t });\n \n       if (dbr_sched_dump)\n \t{\n@@ -4333,6 +4342,12 @@ rest_of_compilation (decl)\n      ggc_collect ();\n #endif\n \n+  /* Shorten branches.  */\n+  TIMEVAR (shorten_branch_time,\n+\t   {\n+\t     shorten_branches (get_insns ());\n+\t   });\n+\n #ifdef STACK_REGS\n   if (stack_reg_dump)\n     open_dump_file (\".20.stack\", decl_printable_name (decl, 2));\n@@ -4350,12 +4365,6 @@ rest_of_compilation (decl)\n      ggc_collect ();\n #endif\n \n-  /* Shorten branches.  */\n-  TIMEVAR (shorten_branch_time,\n-\t   {\n-\t     shorten_branches (get_insns ());\n-\t   });\n-\n   /* Now turn the rtl into assembler code.  */\n \n   TIMEVAR (final_time,"}]}