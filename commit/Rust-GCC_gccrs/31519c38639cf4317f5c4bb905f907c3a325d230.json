{"sha": "31519c38639cf4317f5c4bb905f907c3a325d230", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1MTljMzg2MzljZjQzMTdmNWM0YmI5MDVmOTA3YzNhMzI1ZDIzMA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2013-11-22T20:08:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-11-22T20:08:44Z"}, "message": "ipa.c (symtab_remove_unreachable_nodes): Fix up comment typos.\n\n\t* ipa.c (symtab_remove_unreachable_nodes): Fix up comment typos.\n\t* ipa-prop.c (get_vector_of_formal_parm_types): Renamed to ...\n\t(ipa_get_vector_of_formal_parm_types): ... this.  No longer static.\n\t(ipa_modify_formal_parameters): Adjust caller.  Remove\n\tsynth_parm_prefix argument.  Use operator enum instead of bit fields.\n\tAdd assert for properly handling vector of references.  Handle\n\tcreating brand new parameters.\n\t(ipa_modify_call_arguments): Use operator enum instead of bit\n\tfields.\n\t(ipa_combine_adjustments): Same.  Assert that IPA_PARM_OP_NEW is not\n\tused.\n\t(ipa_modify_expr, get_ssa_base_param, ipa_get_adjustment_candidate):\n\tNew functions.\n\t(ipa_dump_param_adjustments): Rename reduction to new_decl.\n\tUse operator enum instead of bit fields.\n\t* ipa-prop.h (enum ipa_parm_op): New.\n\t(struct ipa_parm_adjustment): New field op.  Rename reduction\n\tto new_decl, new_arg_prefix to arg_prefix and remove remove_param\n\tand copy_param.\n\t(ipa_modify_formal_parameters): Remove last argument.\n\t(ipa_get_vector_of_formal_parm_types, ipa_modify_expr,\n\tipa_get_adjustment_candidate): New prototypes.\n\t* tree-sra.c (turn_representatives_into_adjustments): Use operator\n\tenum.  Set arg_prefix.\n\t(get_adjustment_for_base): Use operator enum.\n\t(sra_ipa_modify_expr): Rename to ipa_modify_expr and move to\n\tipa-prop.c.\n\t(sra_ipa_modify_assign): Rename sra_ipa_modify_expr to\n\tipa_modify_expr.\n\t(ipa_sra_modify_function_body): Same.  No longer static.\n\t(sra_ipa_reset_debug_stmts): Use operator enum.\n\t(modify_function): Do not pass prefix argument.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r205284", "tree": {"sha": "1615fa41425f7784a56379fbbf9492b6ad8fd64b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1615fa41425f7784a56379fbbf9492b6ad8fd64b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31519c38639cf4317f5c4bb905f907c3a325d230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31519c38639cf4317f5c4bb905f907c3a325d230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31519c38639cf4317f5c4bb905f907c3a325d230", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31519c38639cf4317f5c4bb905f907c3a325d230/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a508bb66b6056dd7a7cd7a689daa1b1dfff6863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a508bb66b6056dd7a7cd7a689daa1b1dfff6863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a508bb66b6056dd7a7cd7a689daa1b1dfff6863"}], "stats": {"total": 427, "additions": 269, "deletions": 158}, "files": [{"sha": "0757d157cc89286fc3acbc3720de1b0370cca696", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31519c38639cf4317f5c4bb905f907c3a325d230", "patch": "@@ -1,3 +1,39 @@\n+2013-11-22  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* ipa.c (symtab_remove_unreachable_nodes): Fix up comment typos.\n+\t* ipa-prop.c (get_vector_of_formal_parm_types): Renamed to ...\n+\t(ipa_get_vector_of_formal_parm_types): ... this.  No longer static.\n+\t(ipa_modify_formal_parameters): Adjust caller.  Remove\n+\tsynth_parm_prefix argument.  Use operator enum instead of bit fields.\n+\tAdd assert for properly handling vector of references.  Handle\n+\tcreating brand new parameters.\n+\t(ipa_modify_call_arguments): Use operator enum instead of bit\n+\tfields.\n+\t(ipa_combine_adjustments): Same.  Assert that IPA_PARM_OP_NEW is not\n+\tused.\n+\t(ipa_modify_expr, get_ssa_base_param, ipa_get_adjustment_candidate):\n+\tNew functions.\n+\t(ipa_dump_param_adjustments): Rename reduction to new_decl.\n+\tUse operator enum instead of bit fields.\n+\t* ipa-prop.h (enum ipa_parm_op): New.\n+\t(struct ipa_parm_adjustment): New field op.  Rename reduction\n+\tto new_decl, new_arg_prefix to arg_prefix and remove remove_param\n+\tand copy_param.\n+\t(ipa_modify_formal_parameters): Remove last argument.\n+\t(ipa_get_vector_of_formal_parm_types, ipa_modify_expr,\n+\tipa_get_adjustment_candidate): New prototypes.\n+\t* tree-sra.c (turn_representatives_into_adjustments): Use operator\n+\tenum.  Set arg_prefix.\n+\t(get_adjustment_for_base): Use operator enum.\n+\t(sra_ipa_modify_expr): Rename to ipa_modify_expr and move to\n+\tipa-prop.c.\n+\t(sra_ipa_modify_assign): Rename sra_ipa_modify_expr to\n+\tipa_modify_expr.\n+\t(ipa_sra_modify_function_body): Same.  No longer static.\n+\t(sra_ipa_reset_debug_stmts): Use operator enum.\n+\t(modify_function): Do not pass prefix argument.\n+\n 2013-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* ubsan.c (ubsan_source_location): Don't crash on"}, {"sha": "6bdb0dfc735ab3c53e13d2d3d223b1e80e84db32", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 177, "deletions": 49, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=31519c38639cf4317f5c4bb905f907c3a325d230", "patch": "@@ -3361,8 +3361,8 @@ ipa_get_vector_of_formal_parms (tree fndecl)\n /* Return a heap allocated vector containing types of formal parameters of\n    function type FNTYPE.  */\n \n-static inline vec<tree> \n-get_vector_of_formal_parm_types (tree fntype)\n+vec<tree>\n+ipa_get_vector_of_formal_parm_types (tree fntype)\n {\n   vec<tree> types;\n   int count = 0;\n@@ -3384,32 +3384,22 @@ get_vector_of_formal_parm_types (tree fntype)\n    base_index field.  */\n \n void\n-ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n-\t\t\t      const char *synth_parm_prefix)\n+ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments)\n {\n-  vec<tree> oparms, otypes;\n-  tree orig_type, new_type = NULL;\n-  tree old_arg_types, t, new_arg_types = NULL;\n-  tree parm, *link = &DECL_ARGUMENTS (fndecl);\n-  int i, len = adjustments.length ();\n-  tree new_reversed = NULL;\n-  bool care_for_types, last_parm_void;\n-\n-  if (!synth_parm_prefix)\n-    synth_parm_prefix = \"SYNTH\";\n-\n-  oparms = ipa_get_vector_of_formal_parms (fndecl);\n-  orig_type = TREE_TYPE (fndecl);\n-  old_arg_types = TYPE_ARG_TYPES (orig_type);\n+  vec<tree> oparms = ipa_get_vector_of_formal_parms (fndecl);\n+  tree orig_type = TREE_TYPE (fndecl);\n+  tree old_arg_types = TYPE_ARG_TYPES (orig_type);\n \n   /* The following test is an ugly hack, some functions simply don't have any\n      arguments in their type.  This is probably a bug but well... */\n-  care_for_types = (old_arg_types != NULL_TREE);\n+  bool care_for_types = (old_arg_types != NULL_TREE);\n+  bool last_parm_void;\n+  vec<tree> otypes;\n   if (care_for_types)\n     {\n       last_parm_void = (TREE_VALUE (tree_last (old_arg_types))\n \t\t\t== void_type_node);\n-      otypes = get_vector_of_formal_parm_types (orig_type);\n+      otypes = ipa_get_vector_of_formal_parm_types (orig_type);\n       if (last_parm_void)\n \tgcc_assert (oparms.length () + 1 == otypes.length ());\n       else\n@@ -3421,24 +3411,31 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n       otypes.create (0);\n     }\n \n-  for (i = 0; i < len; i++)\n+  int len = adjustments.length ();\n+  tree *link = &DECL_ARGUMENTS (fndecl);\n+  tree new_arg_types = NULL;\n+  for (int i = 0; i < len; i++)\n     {\n       struct ipa_parm_adjustment *adj;\n       gcc_assert (link);\n \n       adj = &adjustments[i];\n-      parm = oparms[adj->base_index];\n+      tree parm;\n+      if (adj->op == IPA_PARM_OP_NEW)\n+\tparm = NULL;\n+      else\n+\tparm = oparms[adj->base_index];\n       adj->base = parm;\n \n-      if (adj->copy_param)\n+      if (adj->op == IPA_PARM_OP_COPY)\n \t{\n \t  if (care_for_types)\n \t    new_arg_types = tree_cons (NULL_TREE, otypes[adj->base_index],\n \t\t\t\t       new_arg_types);\n \t  *link = parm;\n \t  link = &DECL_CHAIN (parm);\n \t}\n-      else if (!adj->remove_param)\n+      else if (adj->op != IPA_PARM_OP_REMOVE)\n \t{\n \t  tree new_parm;\n \t  tree ptype;\n@@ -3453,26 +3450,29 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n \n \t  new_parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE,\n \t\t\t\t ptype);\n-\t  DECL_NAME (new_parm) = create_tmp_var_name (synth_parm_prefix);\n-\n+\t  const char *prefix = adj->arg_prefix ? adj->arg_prefix : \"SYNTH\";\n+\t  DECL_NAME (new_parm) = create_tmp_var_name (prefix);\n \t  DECL_ARTIFICIAL (new_parm) = 1;\n \t  DECL_ARG_TYPE (new_parm) = ptype;\n \t  DECL_CONTEXT (new_parm) = fndecl;\n \t  TREE_USED (new_parm) = 1;\n \t  DECL_IGNORED_P (new_parm) = 1;\n \t  layout_decl (new_parm, 0);\n \n-\t  adj->base = parm;\n-\t  adj->reduction = new_parm;\n+\t  if (adj->op == IPA_PARM_OP_NEW)\n+\t    adj->base = NULL;\n+\t  else\n+\t    adj->base = parm;\n+\t  adj->new_decl = new_parm;\n \n \t  *link = new_parm;\n-\n \t  link = &DECL_CHAIN (new_parm);\n \t}\n     }\n \n   *link = NULL_TREE;\n \n+  tree new_reversed = NULL;\n   if (care_for_types)\n     {\n       new_reversed = nreverse (new_arg_types);\n@@ -3490,8 +3490,9 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n      Exception is METHOD_TYPEs must have THIS argument.\n      When we are asked to remove it, we need to build new FUNCTION_TYPE\n      instead.  */\n+  tree new_type = NULL;\n   if (TREE_CODE (orig_type) != METHOD_TYPE\n-       || (adjustments[0].copy_param\n+       || (adjustments[0].op == IPA_PARM_OP_COPY\n \t  && adjustments[0].base_index == 0))\n     {\n       new_type = build_distinct_type_copy (orig_type);\n@@ -3515,7 +3516,7 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n \n   /* This is a new type, not a copy of an old type.  Need to reassociate\n      variants.  We can handle everything except the main variant lazily.  */\n-  t = TYPE_MAIN_VARIANT (orig_type);\n+  tree t = TYPE_MAIN_VARIANT (orig_type);\n   if (orig_type != t)\n     {\n       TYPE_MAIN_VARIANT (new_type) = t;\n@@ -3564,13 +3565,13 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \n       adj = &adjustments[i];\n \n-      if (adj->copy_param)\n+      if (adj->op == IPA_PARM_OP_COPY)\n \t{\n \t  tree arg = gimple_call_arg (stmt, adj->base_index);\n \n \t  vargs.quick_push (arg);\n \t}\n-      else if (!adj->remove_param)\n+      else if (adj->op != IPA_PARM_OP_REMOVE)\n \t{\n \t  tree expr, base, off;\n \t  location_t loc;\n@@ -3689,7 +3690,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \t\t\t\t\t   NULL, true, GSI_SAME_STMT);\n \t  vargs.quick_push (expr);\n \t}\n-      if (!adj->copy_param && MAY_HAVE_DEBUG_STMTS)\n+      if (adj->op != IPA_PARM_OP_COPY && MAY_HAVE_DEBUG_STMTS)\n \t{\n \t  unsigned int ix;\n \t  tree ddecl = NULL_TREE, origin = DECL_ORIGIN (adj->base), arg;\n@@ -3764,6 +3765,124 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n   free_dominance_info (CDI_DOMINATORS);\n }\n \n+/* If the expression *EXPR should be replaced by a reduction of a parameter, do\n+   so.  ADJUSTMENTS is a pointer to a vector of adjustments.  CONVERT\n+   specifies whether the function should care about type incompatibility the\n+   current and new expressions.  If it is false, the function will leave\n+   incompatibility issues to the caller.  Return true iff the expression\n+   was modified. */\n+\n+bool\n+ipa_modify_expr (tree *expr, bool convert,\n+\t\t ipa_parm_adjustment_vec adjustments)\n+{\n+  struct ipa_parm_adjustment *cand\n+    = ipa_get_adjustment_candidate (&expr, &convert, adjustments, false);\n+  if (!cand)\n+    return false;\n+\n+  tree src;\n+  if (cand->by_ref)\n+    src = build_simple_mem_ref (cand->new_decl);\n+  else\n+    src = cand->new_decl;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"About to replace expr \");\n+      print_generic_expr (dump_file, *expr, 0);\n+      fprintf (dump_file, \" with \");\n+      print_generic_expr (dump_file, src, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (convert && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n+    {\n+      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n+      *expr = vce;\n+    }\n+  else\n+    *expr = src;\n+  return true;\n+}\n+\n+/* If T is an SSA_NAME, return NULL if it is not a default def or\n+   return its base variable if it is.  If IGNORE_DEFAULT_DEF is true,\n+   the base variable is always returned, regardless if it is a default\n+   def.  Return T if it is not an SSA_NAME.  */\n+\n+static tree\n+get_ssa_base_param (tree t, bool ignore_default_def)\n+{\n+  if (TREE_CODE (t) == SSA_NAME)\n+    {\n+      if (ignore_default_def || SSA_NAME_IS_DEFAULT_DEF (t))\n+\treturn SSA_NAME_VAR (t);\n+      else\n+\treturn NULL_TREE;\n+    }\n+  return t;\n+}\n+\n+/* Given an expression, return an adjustment entry specifying the\n+   transformation to be done on EXPR.  If no suitable adjustment entry\n+   was found, returns NULL.\n+\n+   If IGNORE_DEFAULT_DEF is set, consider SSA_NAMEs which are not a\n+   default def, otherwise bail on them.\n+\n+   If CONVERT is non-NULL, this function will set *CONVERT if the\n+   expression provided is a component reference.  ADJUSTMENTS is the\n+   adjustments vector.  */\n+\n+ipa_parm_adjustment *\n+ipa_get_adjustment_candidate (tree **expr, bool *convert,\n+\t\t\t      ipa_parm_adjustment_vec adjustments,\n+\t\t\t      bool ignore_default_def)\n+{\n+  if (TREE_CODE (**expr) == BIT_FIELD_REF\n+      || TREE_CODE (**expr) == IMAGPART_EXPR\n+      || TREE_CODE (**expr) == REALPART_EXPR)\n+    {\n+      *expr = &TREE_OPERAND (**expr, 0);\n+      if (convert)\n+\t*convert = true;\n+    }\n+\n+  HOST_WIDE_INT offset, size, max_size;\n+  tree base = get_ref_base_and_extent (**expr, &offset, &size, &max_size);\n+  if (!base || size == -1 || max_size == -1)\n+    return NULL;\n+\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      offset += mem_ref_offset (base).low * BITS_PER_UNIT;\n+      base = TREE_OPERAND (base, 0);\n+    }\n+\n+  base = get_ssa_base_param (base, ignore_default_def);\n+  if (!base || TREE_CODE (base) != PARM_DECL)\n+    return NULL;\n+\n+  struct ipa_parm_adjustment *cand = NULL;\n+  unsigned int len = adjustments.length ();\n+  for (unsigned i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj = &adjustments[i];\n+\n+      if (adj->base == base\n+\t  && (adj->offset == offset || adj->op == IPA_PARM_OP_REMOVE))\n+\t{\n+\t  cand = adj;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!cand || cand->op == IPA_PARM_OP_COPY || cand->op == IPA_PARM_OP_REMOVE)\n+    return NULL;\n+  return cand;\n+}\n+\n /* Return true iff BASE_INDEX is in ADJUSTMENTS more than once.  */\n \n static bool\n@@ -3809,10 +3928,14 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n       struct ipa_parm_adjustment *n;\n       n = &inner[i];\n \n-      if (n->remove_param)\n+      if (n->op == IPA_PARM_OP_REMOVE)\n \tremovals++;\n       else\n-\ttmp.quick_push (*n);\n+\t{\n+\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n+\t  gcc_assert (n->op != IPA_PARM_OP_NEW);\n+\t  tmp.quick_push (*n);\n+\t}\n     }\n \n   adjustments.create (outlen + removals);\n@@ -3823,27 +3946,32 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n       struct ipa_parm_adjustment *in = &tmp[out->base_index];\n \n       memset (&r, 0, sizeof (r));\n-      gcc_assert (!in->remove_param);\n-      if (out->remove_param)\n+      gcc_assert (in->op != IPA_PARM_OP_REMOVE);\n+      if (out->op == IPA_PARM_OP_REMOVE)\n \t{\n \t  if (!index_in_adjustments_multiple_times_p (in->base_index, tmp))\n \t    {\n-\t      r.remove_param = true;\n+\t      r.op = IPA_PARM_OP_REMOVE;\n \t      adjustments.quick_push (r);\n \t    }\n \t  continue;\n \t}\n+      else\n+\t{\n+\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n+\t  gcc_assert (out->op != IPA_PARM_OP_NEW);\n+\t}\n \n       r.base_index = in->base_index;\n       r.type = out->type;\n \n       /* FIXME:  Create nonlocal value too.  */\n \n-      if (in->copy_param && out->copy_param)\n-\tr.copy_param = true;\n-      else if (in->copy_param)\n+      if (in->op == IPA_PARM_OP_COPY && out->op == IPA_PARM_OP_COPY)\n+\tr.op = IPA_PARM_OP_COPY;\n+      else if (in->op == IPA_PARM_OP_COPY)\n \tr.offset = out->offset;\n-      else if (out->copy_param)\n+      else if (out->op == IPA_PARM_OP_COPY)\n \tr.offset = in->offset;\n       else\n \tr.offset = in->offset + out->offset;\n@@ -3854,7 +3982,7 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n     {\n       struct ipa_parm_adjustment *n = &inner[i];\n \n-      if (n->remove_param)\n+      if (n->op == IPA_PARM_OP_REMOVE)\n \tadjustments.quick_push (*n);\n     }\n \n@@ -3891,20 +4019,20 @@ ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n \t  fprintf (file, \", base: \");\n \t  print_generic_expr (file, adj->base, 0);\n \t}\n-      if (adj->reduction)\n+      if (adj->new_decl)\n \t{\n-\t  fprintf (file, \", reduction: \");\n-\t  print_generic_expr (file, adj->reduction, 0);\n+\t  fprintf (file, \", new_decl: \");\n+\t  print_generic_expr (file, adj->new_decl, 0);\n \t}\n       if (adj->new_ssa_base)\n \t{\n \t  fprintf (file, \", new_ssa_base: \");\n \t  print_generic_expr (file, adj->new_ssa_base, 0);\n \t}\n \n-      if (adj->copy_param)\n+      if (adj->op == IPA_PARM_OP_COPY)\n \tfprintf (file, \", copy_param\");\n-      else if (adj->remove_param)\n+      else if (adj->op == IPA_PARM_OP_REMOVE)\n \tfprintf (file, \", remove_param\");\n       else\n \tfprintf (file, \", offset %li\", (long) adj->offset);"}, {"sha": "2fb00afcac226f7f769a963e418f3e0c407e00af", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=31519c38639cf4317f5c4bb905f907c3a325d230", "patch": "@@ -609,6 +609,27 @@ extern alloc_pool ipcp_values_pool;\n extern alloc_pool ipcp_sources_pool;\n extern alloc_pool ipcp_agg_lattice_pool;\n \n+/* Operation to be performed for the parameter in ipa_parm_adjustment\n+   below.  */\n+enum ipa_parm_op {\n+  IPA_PARM_OP_NONE,\n+\n+  /* This describes a brand new parameter.\n+\n+     The field `type' should be set to the new type, `arg_prefix'\n+     should be set to the string prefix for the new DECL_NAME, and\n+     `new_decl' will ultimately hold the newly created argument.  */\n+  IPA_PARM_OP_NEW,\n+\n+  /* This new parameter is an unmodified parameter at index base_index. */\n+  IPA_PARM_OP_COPY,\n+\n+  /* This adjustment describes a parameter that is about to be removed\n+     completely.  Most users will probably need to book keep those so that they\n+     don't leave behinfd any non default def ssa names belonging to them.  */\n+  IPA_PARM_OP_REMOVE\n+};\n+\n /* Structure to describe transformations of formal parameters and actual\n    arguments.  Each instance describes one new parameter and they are meant to\n    be stored in a vector.  Additionally, most users will probably want to store\n@@ -632,10 +653,11 @@ struct ipa_parm_adjustment\n      arguments.  */\n   tree alias_ptr_type;\n \n-  /* The new declaration when creating/replacing a parameter.  Created by\n-     ipa_modify_formal_parameters, useful for functions modifying the body\n-     accordingly. */\n-  tree reduction;\n+  /* The new declaration when creating/replacing a parameter.  Created\n+     by ipa_modify_formal_parameters, useful for functions modifying\n+     the body accordingly.  For brand new arguments, this is the newly\n+     created argument.  */\n+  tree new_decl;\n \n   /* New declaration of a substitute variable that we may use to replace all\n      non-default-def ssa names when a parm decl is going away.  */\n@@ -645,22 +667,19 @@ struct ipa_parm_adjustment\n      is NULL), this is going to be its nonlocalized vars value.  */\n   tree nonlocal_value;\n \n+  /* This holds the prefix to be used for the new DECL_NAME.  */\n+  const char *arg_prefix;\n+\n   /* Offset into the original parameter (for the cases when the new parameter\n      is a component of an original one).  */\n   HOST_WIDE_INT offset;\n \n-  /* Zero based index of the original parameter this one is based on.  (ATM\n-     there is no way to insert a new parameter out of the blue because there is\n-     no need but if it arises the code can be easily exteded to do so.)  */\n+  /* Zero based index of the original parameter this one is based on.  */\n   int base_index;\n \n-  /* This new parameter is an unmodified parameter at index base_index. */\n-  unsigned copy_param : 1;\n-\n-  /* This adjustment describes a parameter that is about to be removed\n-     completely.  Most users will probably need to book keep those so that they\n-     don't leave behinfd any non default def ssa names belonging to them.  */\n-  unsigned remove_param : 1;\n+  /* Whether this parameter is a new parameter, a copy of an old one,\n+     or one about to be removed.  */\n+  enum ipa_parm_op op;\n \n   /* The parameter is to be passed by reference.  */\n   unsigned by_ref : 1;\n@@ -671,8 +690,8 @@ typedef struct ipa_parm_adjustment ipa_parm_adjustment_t;\n typedef vec<ipa_parm_adjustment_t> ipa_parm_adjustment_vec;\n \n vec<tree> ipa_get_vector_of_formal_parms (tree fndecl);\n-void ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec,\n-\t\t\t\t   const char *);\n+vec<tree> ipa_get_vector_of_formal_parm_types (tree fntype);\n+void ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec);\n void ipa_modify_call_arguments (struct cgraph_edge *, gimple,\n \t\t\t\tipa_parm_adjustment_vec);\n ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n@@ -690,6 +709,10 @@ tree ipa_value_from_jfunc (struct ipa_node_params *info,\n \t\t\t   struct ipa_jump_func *jfunc);\n unsigned int ipcp_transform_function (struct cgraph_node *node);\n void ipa_dump_param (FILE *, struct ipa_node_params *info, int i);\n+bool ipa_modify_expr (tree *, bool, ipa_parm_adjustment_vec);\n+ipa_parm_adjustment *ipa_get_adjustment_candidate (tree **, bool *,\n+\t\t\t\t\t\t   ipa_parm_adjustment_vec,\n+\t\t\t\t\t\t   bool);\n \n \n /* From tree-sra.c:  */"}, {"sha": "70b1d01873fd9fa1a541ec5906a825018756ac27", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=31519c38639cf4317f5c4bb905f907c3a325d230", "patch": "@@ -246,7 +246,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n      hope calls to them will be devirtualized. \n \n      Again we remove them after inlining.  In late optimization some\n-     devirtualization may happen, but it is not importnat since we won't inline\n+     devirtualization may happen, but it is not important since we won't inline\n      the call. In theory early opts and IPA should work out all important cases.\n \n    - virtual clones needs bodies of their origins for later materialization;\n@@ -274,7 +274,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n    by reachable symbols or origins of clones).  The queue is represented\n    as linked list by AUX pointer terminated by 1.\n \n-   A the end we keep all reachable symbols. For symbols in boundary we always\n+   At the end we keep all reachable symbols. For symbols in boundary we always\n    turn definition into a declaration, but we may keep function body around\n    based on body_needed_for_clonning\n "}, {"sha": "0890613852b138c2e796909cdb45497c6c6ac47b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 15, "deletions": 91, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31519c38639cf4317f5c4bb905f907c3a325d230/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=31519c38639cf4317f5c4bb905f907c3a325d230", "patch": "@@ -4281,9 +4281,10 @@ turn_representatives_into_adjustments (vec<access_p> representatives,\n \t  adj.base_index = get_param_index (parm, parms);\n \t  adj.base = parm;\n \t  if (!repr)\n-\t    adj.copy_param = 1;\n+\t    adj.op = IPA_PARM_OP_COPY;\n \t  else\n-\t    adj.remove_param = 1;\n+\t    adj.op = IPA_PARM_OP_REMOVE;\n+\t  adj.arg_prefix = \"ISRA\";\n \t  adjustments.quick_push (adj);\n \t}\n       else\n@@ -4303,6 +4304,7 @@ turn_representatives_into_adjustments (vec<access_p> representatives,\n \t      adj.by_ref = (POINTER_TYPE_P (TREE_TYPE (repr->base))\n \t\t\t    && (repr->grp_maybe_modified\n \t\t\t\t|| repr->grp_not_necessarilly_dereferenced));\n+\t      adj.arg_prefix = \"ISRA\";\n \t      adjustments.quick_push (adj);\n \t    }\n \t}\n@@ -4433,7 +4435,7 @@ get_adjustment_for_base (ipa_parm_adjustment_vec adjustments, tree base)\n       struct ipa_parm_adjustment *adj;\n \n       adj = &adjustments[i];\n-      if (!adj->copy_param && adj->base == base)\n+      if (adj->op != IPA_PARM_OP_COPY && adj->base == base)\n \treturn adj;\n     }\n \n@@ -4497,84 +4499,6 @@ replace_removed_params_ssa_names (gimple stmt,\n   return true;\n }\n \n-/* If the expression *EXPR should be replaced by a reduction of a parameter, do\n-   so.  ADJUSTMENTS is a pointer to a vector of adjustments.  CONVERT\n-   specifies whether the function should care about type incompatibility the\n-   current and new expressions.  If it is false, the function will leave\n-   incompatibility issues to the caller.  Return true iff the expression\n-   was modified. */\n-\n-static bool\n-sra_ipa_modify_expr (tree *expr, bool convert,\n-\t\t     ipa_parm_adjustment_vec adjustments)\n-{\n-  int i, len;\n-  struct ipa_parm_adjustment *adj, *cand = NULL;\n-  HOST_WIDE_INT offset, size, max_size;\n-  tree base, src;\n-\n-  len = adjustments.length ();\n-\n-  if (TREE_CODE (*expr) == BIT_FIELD_REF\n-      || TREE_CODE (*expr) == IMAGPART_EXPR\n-      || TREE_CODE (*expr) == REALPART_EXPR)\n-    {\n-      expr = &TREE_OPERAND (*expr, 0);\n-      convert = true;\n-    }\n-\n-  base = get_ref_base_and_extent (*expr, &offset, &size, &max_size);\n-  if (!base || size == -1 || max_size == -1)\n-    return false;\n-\n-  if (TREE_CODE (base) == MEM_REF)\n-    {\n-      offset += mem_ref_offset (base).low * BITS_PER_UNIT;\n-      base = TREE_OPERAND (base, 0);\n-    }\n-\n-  base = get_ssa_base_param (base);\n-  if (!base || TREE_CODE (base) != PARM_DECL)\n-    return false;\n-\n-  for (i = 0; i < len; i++)\n-    {\n-      adj = &adjustments[i];\n-\n-      if (adj->base == base\n-\t  && (adj->offset == offset || adj->remove_param))\n-\t{\n-\t  cand = adj;\n-\t  break;\n-\t}\n-    }\n-  if (!cand || cand->copy_param || cand->remove_param)\n-    return false;\n-\n-  if (cand->by_ref)\n-    src = build_simple_mem_ref (cand->reduction);\n-  else\n-    src = cand->reduction;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"About to replace expr \");\n-      print_generic_expr (dump_file, *expr, 0);\n-      fprintf (dump_file, \" with \");\n-      print_generic_expr (dump_file, src, 0);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  if (convert && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n-    {\n-      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n-      *expr = vce;\n-    }\n-  else\n-    *expr = src;\n-  return true;\n-}\n-\n /* If the statement pointed to by STMT_PTR contains any expressions that need\n    to replaced with a different one as noted by ADJUSTMENTS, do so.  Handle any\n    potential type incompatibilities (GSI is used to accommodate conversion\n@@ -4595,8 +4519,8 @@ sra_ipa_modify_assign (gimple *stmt_ptr, gimple_stmt_iterator *gsi,\n   rhs_p = gimple_assign_rhs1_ptr (stmt);\n   lhs_p = gimple_assign_lhs_ptr (stmt);\n \n-  any = sra_ipa_modify_expr (rhs_p, false, adjustments);\n-  any |= sra_ipa_modify_expr (lhs_p, false, adjustments);\n+  any = ipa_modify_expr (rhs_p, false, adjustments);\n+  any |= ipa_modify_expr (lhs_p, false, adjustments);\n   if (any)\n     {\n       tree new_rhs = NULL_TREE;\n@@ -4642,7 +4566,7 @@ sra_ipa_modify_assign (gimple *stmt_ptr, gimple_stmt_iterator *gsi,\n /* Traverse the function body and all modifications as described in\n    ADJUSTMENTS.  Return true iff the CFG has been changed.  */\n \n-static bool\n+bool\n ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n {\n   bool cfg_changed = false;\n@@ -4668,7 +4592,7 @@ ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n \t    case GIMPLE_RETURN:\n \t      t = gimple_return_retval_ptr (stmt);\n \t      if (*t != NULL_TREE)\n-\t\tmodified |= sra_ipa_modify_expr (t, true, adjustments);\n+\t\tmodified |= ipa_modify_expr (t, true, adjustments);\n \t      break;\n \n \t    case GIMPLE_ASSIGN:\n@@ -4681,13 +4605,13 @@ ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n \t      for (i = 0; i < gimple_call_num_args (stmt); i++)\n \t\t{\n \t\t  t = gimple_call_arg_ptr (stmt, i);\n-\t\t  modified |= sra_ipa_modify_expr (t, true, adjustments);\n+\t\t  modified |= ipa_modify_expr (t, true, adjustments);\n \t\t}\n \n \t      if (gimple_call_lhs (stmt))\n \t\t{\n \t\t  t = gimple_call_lhs_ptr (stmt);\n-\t\t  modified |= sra_ipa_modify_expr (t, false, adjustments);\n+\t\t  modified |= ipa_modify_expr (t, false, adjustments);\n \t\t  modified |= replace_removed_params_ssa_names (stmt,\n \t\t\t\t\t\t\t\tadjustments);\n \t\t}\n@@ -4697,12 +4621,12 @@ ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n \t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n \t\t{\n \t\t  t = &TREE_VALUE (gimple_asm_input_op (stmt, i));\n-\t\t  modified |= sra_ipa_modify_expr (t, true, adjustments);\n+\t\t  modified |= ipa_modify_expr (t, true, adjustments);\n \t\t}\n \t      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n \t\t{\n \t\t  t = &TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t\t  modified |= sra_ipa_modify_expr (t, false, adjustments);\n+\t\t  modified |= ipa_modify_expr (t, false, adjustments);\n \t\t}\n \t      break;\n \n@@ -4748,7 +4672,7 @@ sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n       use_operand_p use_p;\n \n       adj = &adjustments[i];\n-      if (adj->copy_param || !is_gimple_reg (adj->base))\n+      if (adj->op == IPA_PARM_OP_COPY || !is_gimple_reg (adj->base))\n \tcontinue;\n       name = ssa_default_def (cfun, adj->base);\n       vexpr = NULL;\n@@ -4931,7 +4855,7 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n   redirect_callers.release ();\n \n   push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));\n-  ipa_modify_formal_parameters (current_function_decl, adjustments, \"ISRA\");\n+  ipa_modify_formal_parameters (current_function_decl, adjustments);\n   cfg_changed = ipa_sra_modify_function_body (adjustments);\n   sra_ipa_reset_debug_stmts (adjustments);\n   convert_callers (new_node, node->decl, adjustments);"}]}