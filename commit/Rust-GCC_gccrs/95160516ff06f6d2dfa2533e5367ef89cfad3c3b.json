{"sha": "95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUxNjA1MTZmZjA2ZjZkMmRmYTI1MzNlNTM2N2VmODljZmFkM2MzYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-23T10:54:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-23T10:54:21Z"}, "message": "[multiple changes]\n\n2011-11-23  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb, par-ch6.adb, sem_res.adb, par-util.adb: Minor\n\treformatting.\n\n2011-11-23  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Place error on\n\tline of precondition/ postcondition/invariant.\n2011-11-23  Pascal Obry  <obry@adacore.com>\n\n\t* g-exptty.ads, g-exptty.adb, g-tty.ads, g-tty.adb,\n\tterminals.c: New files.\n\tMakefile.rtl: Add these new files.\n\t* gnat_rm.texi: Add documentation for GNAT.Expect.TTY.\n\t* gcc-interface/Makefile.in: Add g-exptty, g-tty, terminals.o\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\nFrom-SVN: r181655", "tree": {"sha": "18c81dda2bbaf7209f58f9c7ba13bce69933bfb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18c81dda2bbaf7209f58f9c7ba13bce69933bfb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/comments", "author": null, "committer": null, "parents": [{"sha": "bd8aaa863de6c4818913188a26f2b9b89b69d6ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8aaa863de6c4818913188a26f2b9b89b69d6ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8aaa863de6c4818913188a26f2b9b89b69d6ca"}], "stats": {"total": 2278, "additions": 2259, "deletions": 19}, "files": [{"sha": "fdb85f290b7fdbcee8081147eaec7dfcad8080e3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -1,7 +1,24 @@\n+2011-11-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb, par-ch6.adb, sem_res.adb, par-util.adb: Minor\n+\treformatting.\n+\n+2011-11-23  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Place error on\n+\tline of precondition/ postcondition/invariant.\n+2011-11-23  Pascal Obry  <obry@adacore.com>\n+\n+\t* g-exptty.ads, g-exptty.adb, g-tty.ads, g-tty.adb,\n+\tterminals.c: New files.\n+\tMakefile.rtl: Add these new files.\n+\t* gnat_rm.texi: Add documentation for GNAT.Expect.TTY.\n+\t* gcc-interface/Makefile.in: Add g-exptty, g-tty, terminals.o\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n 2011-11-21  Robert Dewar  <dewar@adacore.com>\n \n-\t* exp_imgv.adb (Expand_Width_Attribute): Handle case of\n-\tDiscard_Names.\n+\t* exp_imgv.adb (Expand_Width_Attribute): Handle case of Discard_Names.\n \t* sem_attr.adb (Eval_Attribute, case Width): Ditto.\n \n 2011-11-21  Thomas Quinot  <quinot@adacore.com>"}, {"sha": "73ef0e74fe718be82f0f3e428340305e3eb40f9b", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -404,6 +404,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-except$(objext) \\\n   g-exctra$(objext) \\\n   g-expect$(objext) \\\n+  g-exptty$(objext) \\\n   g-flocon$(objext) \\\n   g-heasor$(objext) \\\n   g-hesora$(objext) \\\n@@ -450,6 +451,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-timsta$(objext) \\\n   g-traceb$(objext) \\\n   g-trasym$(objext) \\\n+  g-tty$(objext) \\\n   g-u3spch$(objext) \\\n   g-utf_32$(objext) \\\n   g-wispch$(objext) \\"}, {"sha": "c0396b4c7d0040f843f5b3a5670f9da0d7a76046", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -6425,13 +6425,12 @@ package body Exp_Util is\n       --  a run-time issue, and the removal is required only to get proper\n       --  behavior at run-time.\n \n-      --  In the Alfa case, we don't need to remove side effects because we\n-      --  only perform formal verification is performed only on expressions\n-      --  that are provably side-effect free. If we tried to remove side\n-      --  effects in the Alfa case, we would get into a mess since in the case\n-      --  of limited types in particular, removal of side effects involves the\n-      --  use of access types or references which are not permitted in Alfa\n-      --  mode.\n+      --  In the Alfa case, we don't need to remove side effects because formal\n+      --  verification is performed only on expressions that are provably\n+      --  side-effect free. If we tried to remove side effects in the Alfa\n+      --  case, we would get into a mess since in the case of limited types in\n+      --  particular, removal of side effects involves the use of access types\n+      --  or references which are not permitted in Alfa mode.\n \n       if not Full_Expander_Active then\n          return;"}, {"sha": "7ec04727d072504c474329926a3c924bab73d0c4", "filename": "gcc/ada/g-exptty.adb", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-exptty.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-exptty.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-exptty.adb?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -0,0 +1,309 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      G N A T . E X P E C T . T T Y                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                    Copyright (C) 2000-2011, AdaCore                      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+with System; use System;\n+\n+package body GNAT.Expect.TTY is\n+\n+   On_Windows : constant Boolean := Directory_Separator = '\\';\n+   --  True when on Windows\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   overriding procedure Close\n+     (Descriptor : in out TTY_Process_Descriptor;\n+      Status     : out Integer)\n+   is\n+      procedure Terminate_Process (Process : System.Address);\n+      pragma Import (C, Terminate_Process, \"__gnat_terminate_process\");\n+\n+      function Waitpid (Process : System.Address) return Integer;\n+      pragma Import (C, Waitpid, \"__gnat_waitpid\");\n+      --  Wait for a specific process id, and return its exit code\n+\n+      procedure Free_Process (Process : System.Address);\n+      pragma Import (C, Free_Process, \"__gnat_free_process\");\n+\n+      procedure Close_TTY (Process : System.Address);\n+      pragma Import (C, Close_TTY, \"__gnat_close_tty\");\n+\n+   begin\n+      --  If we haven't already closed the process\n+\n+      if Descriptor.Process = System.Null_Address then\n+         Status := -1;\n+\n+      else\n+         if Descriptor.Input_Fd /= Invalid_FD then\n+            Close (Descriptor.Input_Fd);\n+         end if;\n+\n+         if Descriptor.Error_Fd /= Descriptor.Output_Fd\n+           and then Descriptor.Error_Fd /= Invalid_FD\n+         then\n+            Close (Descriptor.Error_Fd);\n+         end if;\n+\n+         if Descriptor.Output_Fd /= Invalid_FD then\n+            Close (Descriptor.Output_Fd);\n+         end if;\n+\n+         --  Send a Ctrl-C to the process first. This way, if the\n+         --  launched process is a \"sh\" or \"cmd\", the child processes\n+         --  will get terminated as well. Otherwise, terminating the\n+         --  main process brutally will leave the children running.\n+\n+         Interrupt (Descriptor);\n+         delay 0.05;\n+\n+         Terminate_Process (Descriptor.Process);\n+         Status := Waitpid (Descriptor.Process);\n+\n+         if not On_Windows then\n+            Close_TTY (Descriptor.Process);\n+         end if;\n+\n+         Free_Process (Descriptor.Process'Address);\n+         Descriptor.Process := System.Null_Address;\n+\n+         GNAT.OS_Lib.Free (Descriptor.Buffer);\n+         Descriptor.Buffer_Size := 0;\n+      end if;\n+   end Close;\n+\n+   overriding procedure Close (Descriptor : in out TTY_Process_Descriptor) is\n+      Status : Integer;\n+   begin\n+      Close (Descriptor, Status);\n+   end Close;\n+\n+   -----------------------------\n+   -- Close_Pseudo_Descriptor --\n+   -----------------------------\n+\n+   procedure Close_Pseudo_Descriptor\n+     (Descriptor : in out TTY_Process_Descriptor)\n+   is\n+   begin\n+      Descriptor.Buffer_Size := 0;\n+      GNAT.OS_Lib.Free (Descriptor.Buffer);\n+   end Close_Pseudo_Descriptor;\n+\n+   ---------------\n+   -- Interrupt --\n+   ---------------\n+\n+   overriding procedure Interrupt\n+     (Descriptor : in out TTY_Process_Descriptor)\n+   is\n+      procedure Internal (Process : System.Address);\n+      pragma Import (C, Internal, \"__gnat_interrupt_process\");\n+   begin\n+      if Descriptor.Process /= System.Null_Address then\n+         Internal (Descriptor.Process);\n+      end if;\n+   end Interrupt;\n+\n+   procedure Interrupt (Pid : Integer) is\n+      procedure Internal (Pid : Integer);\n+      pragma Import (C, Internal, \"__gnat_interrupt_pid\");\n+   begin\n+      Internal (Pid);\n+   end Interrupt;\n+\n+   -----------------------\n+   -- Pseudo_Descriptor --\n+   -----------------------\n+\n+   procedure Pseudo_Descriptor\n+     (Descriptor  : out TTY_Process_Descriptor'Class;\n+      TTY         : GNAT.TTY.TTY_Handle;\n+      Buffer_Size : Natural := 4096) is\n+   begin\n+      Descriptor.Input_Fd  := GNAT.TTY.TTY_Descriptor (TTY);\n+      Descriptor.Output_Fd := Descriptor.Input_Fd;\n+\n+      --  Create the buffer\n+\n+      Descriptor.Buffer_Size := Buffer_Size;\n+\n+      if Buffer_Size /= 0 then\n+         Descriptor.Buffer := new String (1 .. Positive (Buffer_Size));\n+      end if;\n+   end Pseudo_Descriptor;\n+\n+   ----------\n+   -- Send --\n+   ----------\n+\n+   overriding procedure Send\n+     (Descriptor   : in out TTY_Process_Descriptor;\n+      Str          : String;\n+      Add_LF       : Boolean := True;\n+      Empty_Buffer : Boolean := False)\n+   is\n+      Header : String (1 .. 5);\n+      Length : Natural;\n+      Ret    : Natural;\n+\n+      procedure Internal\n+        (Process : System.Address;\n+         S       : in out String;\n+         Length  : Natural;\n+         Ret     : out Natural);\n+      pragma Import (C, Internal, \"__gnat_send_header\");\n+\n+   begin\n+      Length := Str'Length;\n+\n+      if Add_LF then\n+         Length := Length + 1;\n+      end if;\n+\n+      Internal (Descriptor.Process, Header, Length, Ret);\n+\n+      if Ret = 1 then\n+\n+         --  Need to use the header\n+\n+         GNAT.Expect.Send\n+           (Process_Descriptor (Descriptor),\n+            Header & Str, Add_LF, Empty_Buffer);\n+\n+      else\n+         GNAT.Expect.Send\n+           (Process_Descriptor (Descriptor),\n+            Str, Add_LF, Empty_Buffer);\n+      end if;\n+   end Send;\n+\n+   --------------\n+   -- Set_Size --\n+   --------------\n+\n+   procedure Set_Size\n+     (Descriptor : in out TTY_Process_Descriptor'Class;\n+      Rows       : Natural;\n+      Columns    : Natural)\n+   is\n+      procedure Internal (Process : System.Address; R, C : Integer);\n+      pragma Import (C, Internal, \"__gnat_setup_winsize\");\n+   begin\n+      if Descriptor.Process /= System.Null_Address then\n+         Internal (Descriptor.Process, Rows, Columns);\n+      end if;\n+   end Set_Size;\n+\n+   ---------------------------\n+   -- Set_Up_Communications --\n+   ---------------------------\n+\n+   overriding procedure Set_Up_Communications\n+     (Pid        : in out TTY_Process_Descriptor;\n+      Err_To_Out : Boolean;\n+      Pipe1      : access Pipe_Type;\n+      Pipe2      : access Pipe_Type;\n+      Pipe3      : access Pipe_Type)\n+   is\n+      pragma Unreferenced (Err_To_Out, Pipe1, Pipe2, Pipe3);\n+\n+      function Internal (Process : System.Address) return Integer;\n+      pragma Import (C, Internal, \"__gnat_setup_communication\");\n+\n+   begin\n+      if Internal (Pid.Process'Address) /= 0 then\n+         raise Invalid_Process with \"cannot setup communication.\";\n+      end if;\n+   end Set_Up_Communications;\n+\n+   ---------------------------------\n+   -- Set_Up_Child_Communications --\n+   ---------------------------------\n+\n+   overriding procedure Set_Up_Child_Communications\n+     (Pid   : in out TTY_Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type;\n+      Cmd   : String;\n+      Args  : System.Address)\n+   is\n+      pragma Unreferenced (Pipe1, Pipe2, Pipe3, Cmd);\n+      function Internal\n+        (Process : System.Address; Argv : System.Address; Use_Pipes : Integer)\n+         return Process_Id;\n+      pragma Import (C, Internal, \"__gnat_setup_child_communication\");\n+\n+   begin\n+      Pid.Pid := Internal (Pid.Process, Args, Boolean'Pos (Pid.Use_Pipes));\n+   end Set_Up_Child_Communications;\n+\n+   ----------------------------------\n+   -- Set_Up_Parent_Communications --\n+   ----------------------------------\n+\n+   overriding procedure Set_Up_Parent_Communications\n+     (Pid   : in out TTY_Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type)\n+   is\n+      pragma Unreferenced (Pipe1, Pipe2, Pipe3);\n+\n+      procedure Internal\n+        (Process  : System.Address;\n+         Inputfp  : out File_Descriptor;\n+         Outputfp : out File_Descriptor;\n+         Errorfp  : out File_Descriptor;\n+         Pid      : out Process_Id);\n+      pragma Import (C, Internal, \"__gnat_setup_parent_communication\");\n+\n+   begin\n+      Internal\n+        (Pid.Process, Pid.Input_Fd, Pid.Output_Fd, Pid.Error_Fd, Pid.Pid);\n+   end Set_Up_Parent_Communications;\n+\n+   -------------------\n+   -- Set_Use_Pipes --\n+   -------------------\n+\n+   procedure Set_Use_Pipes\n+     (Descriptor : in out TTY_Process_Descriptor;\n+      Use_Pipes  : Boolean) is\n+   begin\n+      Descriptor.Use_Pipes := Use_Pipes;\n+   end Set_Use_Pipes;\n+\n+end GNAT.Expect.TTY;"}, {"sha": "878f784fc6a9479382263024ad17fcffba4e3cbe", "filename": "gcc/ada/g-exptty.ads", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-exptty.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-exptty.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-exptty.ads?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                      G N A T . E X P E C T . T T Y                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                    Copyright (C) 2000-2011, AdaCore                      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.TTY;\n+\n+with System;\n+\n+package GNAT.Expect.TTY is\n+\n+   ------------------\n+   --  TTY_Process --\n+   ------------------\n+\n+   type TTY_Process_Descriptor is new Process_Descriptor with private;\n+   --  Similar to Process_Descriptor, with the parent set up as a full terminal\n+   --  (Unix sense, see tty(4)).\n+\n+   procedure Pseudo_Descriptor\n+     (Descriptor  : out TTY_Process_Descriptor'Class;\n+      TTY         : GNAT.TTY.TTY_Handle;\n+      Buffer_Size : Natural := 4096);\n+   --  Given a terminal descriptor (TTY), create a pseudo process descriptor\n+   --  to be used with GNAT.Expect.\n+   --\n+   --  Note that it is invalid to call Close, Interrupt, Send_Signal on the\n+   --  resulting descriptor. To deallocate memory associated with Process,\n+   --  call Close_Pseudo_Descriptor instead.\n+\n+   procedure Close_Pseudo_Descriptor\n+     (Descriptor : in out TTY_Process_Descriptor);\n+   --  Free memory and ressources associated with Descriptor. Will *not*\n+   --  close the associated TTY, it is the caller's responsibility to call\n+   --  GNAT.TTY.Close_TTY.\n+\n+   procedure Interrupt (Pid : Integer);\n+   --  Interrupt a process given its pid\n+\n+   overriding procedure Send\n+     (Descriptor   : in out TTY_Process_Descriptor;\n+      Str          : String;\n+      Add_LF       : Boolean := True;\n+      Empty_Buffer : Boolean := False);\n+   --  See parent\n+   --  What does that comment mean??? what is \"parent\" here\n+\n+   procedure Set_Use_Pipes\n+     (Descriptor : in out TTY_Process_Descriptor;\n+      Use_Pipes  : Boolean);\n+   --  Tell Expect.TTY whether to use Pipes or Console (on windows). Needs to\n+   --  be set before spawning the process. Default is to use Pipes.\n+\n+   procedure Set_Size\n+     (Descriptor : in out TTY_Process_Descriptor'Class;\n+      Rows       : Natural;\n+      Columns    : Natural);\n+   --  Sets up the size of the terminal as reported to the spawned process\n+\n+private\n+\n+   --  All declarations in the private part must be fully commented ???\n+\n+   overriding procedure Close\n+     (Descriptor : in out TTY_Process_Descriptor;\n+      Status     : out Integer);\n+\n+   overriding procedure Close\n+     (Descriptor : in out TTY_Process_Descriptor);\n+\n+   overriding procedure Interrupt (Descriptor : in out TTY_Process_Descriptor);\n+   --  When we use pseudo-terminals, we do not need to use signals to\n+   --  interrupt the debugger, we can simply send the appropriate character.\n+   --  This provides a better support for remote debugging for instance.\n+\n+   procedure Set_Up_Communications\n+     (Pid        : in out TTY_Process_Descriptor;\n+      Err_To_Out : Boolean;\n+      Pipe1      : access Pipe_Type;\n+      Pipe2      : access Pipe_Type;\n+      Pipe3      : access Pipe_Type);\n+\n+   procedure Set_Up_Parent_Communications\n+     (Pid   : in out TTY_Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type);\n+\n+   procedure Set_Up_Child_Communications\n+     (Pid   : in out TTY_Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type;\n+      Cmd   : String;\n+      Args  : System.Address);\n+\n+   type TTY_Process_Descriptor is new Process_Descriptor with record\n+      Process   : System.Address;  --  Underlying structure used in C\n+      Use_Pipes : Boolean := True;\n+   end record;\n+\n+end GNAT.Expect.TTY;"}, {"sha": "43c1bea5469a7e4dc1fb651dad7748b1f8c76ff5", "filename": "gcc/ada/g-tty.adb", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-tty.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-tty.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-tty.adb?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -0,0 +1,134 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                             G N A T . T T Y                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2002-2011, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C.Strings; use Interfaces.C.Strings;\n+\n+package body GNAT.TTY is\n+\n+   use System;\n+\n+   procedure Check_TTY (Handle : TTY_Handle);\n+   --  Check the validity of Handle. Raise Program_Error if ttys are not\n+   --  supported. Raise Constraint_Error if Handle is an invalid handle.\n+\n+   ------------------\n+   -- Allocate_TTY --\n+   ------------------\n+\n+   procedure Allocate_TTY (Handle : out TTY_Handle) is\n+      function Internal return System.Address;\n+      pragma Import (C, Internal, \"__gnat_new_tty\");\n+\n+   begin\n+      if not TTY_Supported then\n+         raise Program_Error;\n+      end if;\n+\n+      Handle.Handle := Internal;\n+   end Allocate_TTY;\n+\n+   ---------------\n+   -- Check_TTY --\n+   ---------------\n+\n+   procedure Check_TTY (Handle : TTY_Handle) is\n+   begin\n+      if not TTY_Supported then\n+         raise Program_Error;\n+      elsif Handle.Handle = System.Null_Address then\n+         raise Constraint_Error;\n+      end if;\n+   end Check_TTY;\n+\n+   ---------------\n+   -- Close_TTY --\n+   ---------------\n+\n+   procedure Close_TTY (Handle : in out TTY_Handle) is\n+      procedure Internal (Handle : System.Address);\n+      pragma Import (C, Internal, \"__gnat_close_tty\");\n+   begin\n+      Check_TTY (Handle);\n+      Internal (Handle.Handle);\n+      Handle.Handle := System.Null_Address;\n+   end Close_TTY;\n+\n+   ---------------\n+   -- Reset_TTY --\n+   ---------------\n+\n+   procedure Reset_TTY (Handle : TTY_Handle) is\n+      procedure Internal (Handle : System.Address);\n+      pragma Import (C, Internal, \"__gnat_reset_tty\");\n+   begin\n+      Check_TTY (Handle);\n+      Internal (Handle.Handle);\n+   end Reset_TTY;\n+\n+   --------------------\n+   -- TTY_Descriptor --\n+   --------------------\n+\n+   function TTY_Descriptor\n+     (Handle : TTY_Handle) return GNAT.OS_Lib.File_Descriptor\n+   is\n+      function Internal\n+        (Handle : System.Address) return GNAT.OS_Lib.File_Descriptor;\n+      pragma Import (C, Internal, \"__gnat_tty_fd\");\n+   begin\n+      Check_TTY (Handle);\n+      return Internal (Handle.Handle);\n+   end TTY_Descriptor;\n+\n+   --------------\n+   -- TTY_Name --\n+   --------------\n+\n+   function TTY_Name (Handle : TTY_Handle) return String is\n+      function Internal (Handle : System.Address) return chars_ptr;\n+      pragma Import (C, Internal, \"__gnat_tty_name\");\n+   begin\n+      Check_TTY (Handle);\n+      return Value (Internal (Handle.Handle));\n+   end TTY_Name;\n+\n+   -------------------\n+   -- TTY_Supported --\n+   -------------------\n+\n+   function TTY_Supported return Boolean is\n+      function Internal return Integer;\n+      pragma Import (C, Internal, \"__gnat_tty_supported\");\n+   begin\n+      return Internal /= 0;\n+   end TTY_Supported;\n+\n+end GNAT.TTY;"}, {"sha": "12aaba760f10053ebef3849495276761d05f17f3", "filename": "gcc/ada/g-tty.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-tty.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fg-tty.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-tty.ads?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -0,0 +1,73 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                             G N A T . T T Y                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2002-2011, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides control over pseudo terminals (ttys)\n+\n+--  This package is only supported on unix systems. See function TTY_Supported\n+--  to test dynamically whether other functions of this package can be called.\n+\n+with System;\n+\n+with GNAT.OS_Lib;\n+\n+package GNAT.TTY is\n+\n+   type TTY_Handle is private;\n+   --  Handle for a tty descriptor\n+\n+   function TTY_Supported return Boolean;\n+   --  If True, the other functions of this package can be called. Otherwise,\n+   --  all functions in this package will raise Program_Error if called.\n+\n+   procedure Allocate_TTY (Handle : out TTY_Handle);\n+   --  Allocate a new tty\n+\n+   procedure Reset_TTY (Handle : TTY_Handle);\n+   --  Reset settings of a given tty\n+\n+   procedure Close_TTY (Handle : in out TTY_Handle);\n+   --  Close a given tty\n+\n+   function TTY_Name (Handle : TTY_Handle) return String;\n+   --  Return the external name of a tty. The name depends on the tty handling\n+   --  on the given target. It will typically look like: \"/dev/ptya1\"\n+\n+   function TTY_Descriptor\n+     (Handle : TTY_Handle) return GNAT.OS_Lib.File_Descriptor;\n+   --  Return the low level descriptor associated with Handle\n+\n+private\n+\n+   type TTY_Handle is record\n+      Handle : System.Address := System.Null_Address;\n+   end record;\n+\n+end GNAT.TTY;"}, {"sha": "436b1a52b99042ffd02f7c25a1ba102a9222d79e", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -2617,9 +2617,9 @@ ada/exp_util.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-load.ads \\\n    ada/lib-sort.adb ada/lib-util.ads ada/lib-xref.ads ada/namet.ads \\\n    ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n-   ada/opt.ads ada/output.ads ada/put_alfa.ads ada/restrict.ads \\\n-   ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n-   ada/sem.ads ada/sem.adb ada/sem_attr.ads ada/sem_aux.ads \\\n+   ada/opt.ads ada/opt.adb ada/output.ads ada/put_alfa.ads \\\n+   ada/restrict.ads ada/restrict.adb ada/rident.ads ada/rtsfind.ads \\\n+   ada/scans.ads ada/sem.ads ada/sem.adb ada/sem_attr.ads ada/sem_aux.ads \\\n    ada/sem_aux.adb ada/sem_cat.ads ada/sem_ch10.ads ada/sem_ch11.ads \\\n    ada/sem_ch12.ads ada/sem_ch13.ads ada/sem_ch2.ads ada/sem_ch3.ads \\\n    ada/sem_ch4.ads ada/sem_ch5.ads ada/sem_ch6.ads ada/sem_ch7.ads \\"}, {"sha": "f281c90fe693776775423538b0961e88f86f1e09", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -2213,12 +2213,13 @@ LIBGNAT_SRCS = adadecode.c adadecode.h adaint.c adaint.h\t\\\n   argv.c cio.c cstreams.c errno.c exit.c cal.c ctrl_c.c env.c env.h\t\\\n   arit64.c raise.h raise.c sysdep.c aux-io.c init.c initialize.c\t\\\n   locales.c seh_init.c final.c tracebak.c tb-alvms.c tb-alvxw.c         \\\n-  tb-gcc.c expect.c mkdir.c socket.c gsocket.h targext.c $(EXTRA_LIBGNAT_SRCS)\n+  tb-gcc.c expect.c mkdir.c socket.c gsocket.h targext.c \\\n+  terminals.c $(EXTRA_LIBGNAT_SRCS)\n \n LIBGNAT_OBJS = adadecode.o adaint.o argv.o cio.o cstreams.o ctrl_c.o\t\\\n   errno.o exit.o env.o raise.o sysdep.o aux-io.o init.o initialize.o\t\\\n   locales.o seh_init.o cal.o arit64.o final.o tracebak.o expect.o       \\\n-  mkdir.o socket.o targext.o $(EXTRA_LIBGNAT_OBJS)\n+  mkdir.o socket.o targext.o terminals.o $(EXTRA_LIBGNAT_OBJS)\n \n # NOTE ??? - when the -I option for compiling Ada code is made to work,\n #  the library installation will change and there will be a\n@@ -2859,6 +2860,7 @@ socket.o  : socket.c gsocket.h\n sysdep.o  : sysdep.c\n raise.o   : raise.c raise.h\n sigtramp-ppcvxw.o : sigtramp-ppcvxw.c sigtramp.h\n+terminals.o : terminals.c\n vx_stack_info.o : vx_stack_info.c\n \n raise-gcc.o : raise-gcc.c raise.h"}, {"sha": "8a51161a8faa215fc541e11a5862edf44fb194c5", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -374,6 +374,7 @@ The GNAT Library\n * GNAT.Exception_Traces (g-exctra.ads)::\n * GNAT.Exceptions (g-except.ads)::\n * GNAT.Expect (g-expect.ads)::\n+* GNAT.Expect.TTY (g-exptty.ads)::\n * GNAT.Float_Control (g-flocon.ads)::\n * GNAT.Heap_Sort (g-heasor.ads)::\n * GNAT.Heap_Sort_A (g-hesora.ads)::\n@@ -14187,6 +14188,7 @@ of GNAT, and will generate a warning message.\n * GNAT.Exception_Traces (g-exctra.ads)::\n * GNAT.Exceptions (g-except.ads)::\n * GNAT.Expect (g-expect.ads)::\n+* GNAT.Expect.TTY (g-exptty.ads)::\n * GNAT.Float_Control (g-flocon.ads)::\n * GNAT.Heap_Sort (g-heasor.ads)::\n * GNAT.Heap_Sort_A (g-hesora.ads)::\n@@ -15054,6 +15056,16 @@ is implemented on all native GNAT ports except for OpenVMS@.\n It is not implemented for cross ports, and in particular is not\n implemented for VxWorks or LynxOS@.\n \n+@node GNAT.Expect.TTY (g-exptty.ads)\n+@section @code{GNAT.Expect.TTY} (@file{g-exptty.ads})\n+@cindex @code{GNAT.Expect.TTY} (@file{g-exptty.ads})\n+\n+@noindent\n+As GNAT.Expect but using pseudo-terminal.\n+Currently @code{GNAT.Expect.TTY} is implemented on all native GNAT\n+ports except for OpenVMS@. It is not implemented for cross ports, and\n+in particular is not implemented for VxWorks or LynxOS@.\n+\n @node GNAT.Float_Control (g-flocon.ads)\n @section @code{GNAT.Float_Control} (@file{g-flocon.ads})\n @cindex @code{GNAT.Float_Control} (@file{g-flocon.ads})"}, {"sha": "36691f34d28e76dda009ce895cc1d3f0c6df1830", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -1681,7 +1681,7 @@ package body Ch6 is\n \n          if Ada_Version < Ada_2012 then\n             Error_Msg_SC -- CODEFIX\n-              (\"ALIASED not allowed in extended return in Ada2012?\");\n+              (\"ALIASED not allowed in extended return in Ada 2012?\");\n          else\n             Error_Msg_SC -- CODEFIX\n               (\"ALIASED not allowed in extended return\");"}, {"sha": "f281c7964f0bfbca9fb462862bec2de236bee6c2", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -174,7 +174,7 @@ package body Util is\n \n    procedure Check_Future_Keyword is\n    begin\n-      --  Ada 2005 (AI-284): Compiling in Ada95 mode we warn that INTERFACE,\n+      --  Ada 2005 (AI-284): Compiling in Ada 95 mode we warn that INTERFACE,\n       --  OVERRIDING, and SYNCHRONIZED are new reserved words.\n \n       if Ada_Version = Ada_95"}, {"sha": "a38cd5993a2f4e1561d6110aa54f408e2026fc0e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -728,8 +728,9 @@ package body Sem_Ch13 is\n             A_Id : constant Aspect_Id  := Get_Aspect_Id (Nam);\n             Anod : Node_Id;\n \n-            Eloc : Source_Ptr := Sloc (Expr);\n-            --  Source location of expression, modified when we split PPC's\n+            Eloc : Source_Ptr := No_Location;\n+            --  Source location of expression, modified when we split PPC's. It\n+            --  is set below when Expr is present.\n \n             procedure Check_False_Aspect_For_Derived_Type;\n             --  This procedure checks for the case of a false aspect for a\n@@ -804,6 +805,18 @@ package body Sem_Ch13 is\n                goto Continue;\n             end if;\n \n+            --  Set the source location of expression, used in the case of\n+            --  a failed precondition/postcondition or invariant. Note that\n+            --  the source location of the expression is not usually the best\n+            --  choice here. For example, it gets located on the last AND\n+            --  keyword in a chain of boolean expressiond AND'ed together.\n+            --  It is best to put the message on the first character of the\n+            --  assertion, which is the effect of the First_Node call here.\n+\n+            if Present (Expr) then\n+               Eloc := Sloc (First_Node (Expr));\n+            end if;\n+\n             --  Check restriction No_Implementation_Aspect_Specifications\n \n             if Impl_Defined_Aspects (A_Id) then"}, {"sha": "a240781dc8aaad143b24e51acc6e2bf39060fbe9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -2811,7 +2811,7 @@ package body Sem_Res is\n          --  default expression mode (the Freeze_Expression routine tests this\n          --  flag and only freezes static types if it is set).\n \n-         --  AI05-177 (Ada2012): Expression functions do not freeze. Only\n+         --  Ada 2012 (AI05-177): Expression functions do not freeze. Only\n          --  their use (in an expanded call) freezes.\n \n          if Ekind (Current_Scope) /= E_Function"}, {"sha": "464e60a28aa5b5b935b0d9ed85868c1cb53428a9", "filename": "gcc/ada/terminals.c", "status": "added", "additions": 1551, "deletions": 0, "changes": 1551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fterminals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95160516ff06f6d2dfa2533e5367ef89cfad3c3b/gcc%2Fada%2Fterminals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fterminals.c?ref=95160516ff06f6d2dfa2533e5367ef89cfad3c3b", "patch": "@@ -0,0 +1,1551 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT RUN-TIME COMPONENTS                         *\n+ *                                                                          *\n+ *                            T E R M I N A L S                             *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                     Copyright (C) 2008-2011, AdaCore                     *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * You should have received a copy of the GNU General Public License and    *\n+ * a copy of the GCC Runtime Library Exception along with this program;     *\n+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* First all usupported platforms. Add stubs for exported routines. */\n+\n+#if defined (VMS) || defined (__vxworks) || defined (__Lynx__)\n+\n+void * __gnat_new_tty (void) { return (void*)0; }\n+char * __gnat_tty_name (void* t) { return (char*)0; }\n+int    __gnat_interrupt_pid (int pid) { return -1; }\n+int    __gnat_interrupt_process (void* desc) { return -1; }\n+int    __gnat_setup_communication (void** desc) { return -1; }\n+void   __gnat_setup_parent_communication\n+         (void* d, int* i, int* o, int*e, int*p) { return -1; }\n+int    __gnat_setup_child_communication\n+         (void* d, char **n, int u) { return -1; }\n+int    __gnat_terminate_process (void *desc) { return -1; }\n+int    __gnat_tty_fd (void* t) { return -1; }\n+int    __gnat_tty_supported (void) { return 0; }\n+int    __gnat_tty_waitpid (void *desc) { return 1; }\n+void   __gnat_close_tty (void* t) {}\n+void   __gnat_free_process (void** process) {}\n+void   __gnat_reset_tty (void* t) {}\n+void   __gnat_send_header (void* d, char h[5], int s, int *r) {}\n+void   __gnat_setup_winsize (void *desc, int rows, int columns) {}\n+\n+/* For Windows platforms. */\n+\n+#elif defined(_WIN32)\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <windows.h>\n+\n+#define MAXPATHLEN 1024\n+\n+#define NILP(x) ((x) == 0)\n+#define Qnil 0\n+#define report_file_error(x, y) fprintf (stderr, \"Error: %s\\n\", x);\n+#define INTEGERP(x) 1\n+#define XINT(x) x\n+\n+struct TTY_Process {\n+  int pid;           /* Number of this process */\n+  PROCESS_INFORMATION procinfo;\n+  HANDLE w_infd, w_outfd;\n+  HANDLE w_forkin, w_forkout;\n+  BOOL usePipe;\n+};\n+\n+/* Control whether create_child cause the process to inherit GPS'\n+   error mode setting.  The default is 1, to minimize the possibility of\n+   subprocesses blocking when accessing unmounted drives.  */\n+static int Vw32_start_process_inherit_error_mode = 1;\n+\n+/* Control whether spawnve quotes arguments as necessary to ensure\n+   correct parsing by child process.  Because not all uses of spawnve\n+   are careful about constructing argv arrays, we make this behaviour\n+   conditional (off by default, since a similar operation is already done\n+   in g-expect.adb by calling Normalize_Argument). */\n+static int Vw32_quote_process_args = 0;\n+\n+static DWORD AbsoluteSeek(HANDLE, DWORD);\n+static VOID  ReadBytes(HANDLE, LPVOID, DWORD);\n+\n+#define XFER_BUFFER_SIZE 2048\n+\n+/* This tell if the executable we're about to launch uses a GUI interface. */\n+/* if we can't determine it, we will return true */\n+static int\n+is_gui_app (char *exe)\n+{\n+  HANDLE hImage;\n+\n+  DWORD  bytes;\n+  DWORD  iSection;\n+  DWORD  SectionOffset;\n+  DWORD  CoffHeaderOffset;\n+  DWORD  MoreDosHeader[16];\n+  CHAR   *file;\n+  size_t nlen;\n+\n+  ULONG  ntSignature;\n+\n+  IMAGE_DOS_HEADER      image_dos_header;\n+  IMAGE_FILE_HEADER     image_file_header;\n+  IMAGE_OPTIONAL_HEADER image_optional_header;\n+  IMAGE_SECTION_HEADER  image_section_header;\n+\n+  /*\n+   *  Open the reference file.\n+  */\n+  nlen = strlen (exe);\n+  file = exe;\n+  if (nlen > 2) {\n+    if (exe[0] == '\"') {\n+      /* remove quotes */\n+      nlen -= 2;\n+      file = malloc ((nlen + 1) * sizeof (char));\n+      memcpy (file, &exe[1], nlen);\n+      file [nlen] = '\\0';\n+    }\n+  }\n+  hImage = CreateFile(file,\n+                      GENERIC_READ,\n+                      FILE_SHARE_READ,\n+                      NULL,\n+                      OPEN_EXISTING,\n+                      FILE_ATTRIBUTE_NORMAL,\n+                      NULL);\n+\n+  if (file != exe) {\n+    free (file);\n+  }\n+\n+  if (INVALID_HANDLE_VALUE == hImage)\n+    {\n+      report_file_error (\"Could not open exe: \", Qnil);\n+      report_file_error (exe, Qnil);\n+      report_file_error (\"\\n\", Qnil);\n+      CloseHandle (hImage);\n+      return -1;\n+    }\n+\n+  /*\n+   *  Read the MS-DOS image header.\n+   */\n+  ReadBytes(hImage, &image_dos_header, sizeof(IMAGE_DOS_HEADER));\n+\n+  if (IMAGE_DOS_SIGNATURE != image_dos_header.e_magic)\n+    {\n+      report_file_error(\"Sorry, I do not understand this file.\\n\", Qnil);\n+      CloseHandle (hImage);\n+      return -1;\n+    }\n+\n+  /*\n+   *  Read more MS-DOS header.       */\n+  ReadBytes(hImage, MoreDosHeader, sizeof(MoreDosHeader));\n+   /*\n+   *  Get actual COFF header.\n+   */\n+  CoffHeaderOffset = AbsoluteSeek(hImage, image_dos_header.e_lfanew) +\n+                     sizeof(ULONG);\n+  if (CoffHeaderOffset < 0) {\n+    CloseHandle (hImage);\n+    return -1;\n+  }\n+\n+  ReadBytes (hImage, &ntSignature, sizeof(ULONG));\n+\n+  if (IMAGE_NT_SIGNATURE != ntSignature)\n+    {\n+      report_file_error (\"Missing NT signature. Unknown file type.\\n\", Qnil);\n+      CloseHandle (hImage);\n+      return -1;\n+    }\n+\n+  SectionOffset = CoffHeaderOffset + IMAGE_SIZEOF_FILE_HEADER +\n+    IMAGE_SIZEOF_NT_OPTIONAL_HEADER;\n+\n+  ReadBytes(hImage, &image_file_header, IMAGE_SIZEOF_FILE_HEADER);\n+\n+  /*\n+   *  Read optional header.\n+   */\n+  ReadBytes(hImage,\n+            &image_optional_header,\n+            IMAGE_SIZEOF_NT_OPTIONAL_HEADER);\n+\n+  CloseHandle (hImage);\n+\n+  switch (image_optional_header.Subsystem)\n+    {\n+    case IMAGE_SUBSYSTEM_UNKNOWN:\n+        return 1;\n+        break;\n+\n+    case IMAGE_SUBSYSTEM_NATIVE:\n+        return 1;\n+        break;\n+\n+    case IMAGE_SUBSYSTEM_WINDOWS_GUI:\n+        return 1;\n+        break;\n+\n+    case IMAGE_SUBSYSTEM_WINDOWS_CUI:\n+        return 0;\n+        break;\n+\n+    case IMAGE_SUBSYSTEM_OS2_CUI:\n+        return 0;\n+        break;\n+\n+    case IMAGE_SUBSYSTEM_POSIX_CUI:\n+        return 0;\n+        break;\n+\n+    default:\n+        /* Unknown, return GUI app to be preservative: if yes, it will be\n+           correctly launched, if no, it will be launched, and a console will\n+           be also displayed, which is not a big deal */\n+        return 1;\n+        break;\n+    }\n+\n+}\n+\n+static DWORD\n+AbsoluteSeek (HANDLE hFile, DWORD offset)\n+{\n+    DWORD newOffset;\n+\n+    newOffset = SetFilePointer (hFile, offset, NULL, FILE_BEGIN);\n+\n+    if (newOffset == 0xFFFFFFFF)\n+      return -1;\n+    else\n+      return newOffset;\n+}\n+\n+static VOID\n+ReadBytes (HANDLE hFile, LPVOID buffer, DWORD size)\n+{\n+  DWORD bytes;\n+\n+  if (!ReadFile(hFile, buffer, size, &bytes, NULL))\n+    {\n+      size = 0;\n+      return;\n+    }\n+  else if (size != bytes)\n+    {\n+      return;\n+    }\n+}\n+\n+static int\n+nt_spawnve (char *exe, char **argv, char *env, struct TTY_Process *process)\n+{\n+  STARTUPINFO start;\n+  SECURITY_ATTRIBUTES sec_attrs;\n+  SECURITY_DESCRIPTOR sec_desc;\n+  DWORD flags;\n+  char dir[ MAXPATHLEN ];\n+  int pid;\n+  int is_gui, use_cmd;\n+  char *cmdline, *parg, **targ;\n+  int do_quoting = 0;\n+  char escape_char;\n+  int arglen;\n+\n+  /* we have to do some conjuring here to put argv and envp into the\n+     form CreateProcess wants...  argv needs to be a space separated/null\n+     terminated list of parameters, and envp is a null\n+     separated/double-null terminated list of parameters.\n+\n+     Additionally, zero-length args and args containing whitespace or\n+     quote chars need to be wrapped in double quotes - for this to work,\n+     embedded quotes need to be escaped as well.  The aim is to ensure\n+     the child process reconstructs the argv array we start with\n+     exactly, so we treat quotes at the beginning and end of arguments\n+     as embedded quotes.\n+\n+     Note that using backslash to escape embedded quotes requires\n+     additional special handling if an embedded quote is already\n+     preceeded by backslash, or if an arg requiring quoting ends with\n+     backslash.  In such cases, the run of escape characters needs to be\n+     doubled.  For consistency, we apply this special handling as long\n+     as the escape character is not quote.\n+\n+     Since we have no idea how large argv and envp are likely to be we\n+     figure out list lengths on the fly and allocate them.  */\n+\n+  if (!NILP (Vw32_quote_process_args))\n+    {\n+      do_quoting = 1;\n+      /* Override escape char by binding w32-quote-process-args to\n+\t desired character, or use t for auto-selection.  */\n+      if (INTEGERP (Vw32_quote_process_args))\n+\tescape_char = XINT (Vw32_quote_process_args);\n+      else\n+\tescape_char = '\\\\';\n+    }\n+\n+  /* do argv...  */\n+  arglen = 0;\n+  targ = argv;\n+  while (*targ)\n+    {\n+      char *p = *targ;\n+      int need_quotes = 0;\n+      int escape_char_run = 0;\n+\n+      if (*p == 0)\n+\tneed_quotes = 1;\n+      for ( ; *p; p++)\n+\t{\n+\t  if (*p == '\"')\n+\t    {\n+\t      /* allow for embedded quotes to be escaped */\n+\t      arglen++;\n+\t      need_quotes = 1;\n+\t      /* handle the case where the embedded quote is already escaped */\n+\t      if (escape_char_run > 0)\n+\t\t{\n+\t\t  /* To preserve the arg exactly, we need to double the\n+\t\t     preceding escape characters (plus adding one to\n+\t\t     escape the quote character itself).  */\n+\t\t  arglen += escape_char_run;\n+\t\t}\n+\t    }\n+\t  else if (*p == ' ' || *p == '\\t')\n+\t    {\n+\t      need_quotes = 1;\n+\t    }\n+\n+\t  if (*p == escape_char && escape_char != '\"')\n+\t    escape_char_run++;\n+\t  else\n+\t    escape_char_run = 0;\n+\t}\n+      if (need_quotes)\n+\t{\n+\t  arglen += 2;\n+\t  /* handle the case where the arg ends with an escape char - we\n+\t     must not let the enclosing quote be escaped.  */\n+\t  if (escape_char_run > 0)\n+\t    arglen += escape_char_run;\n+\t}\n+      arglen += strlen (*targ) + 1;\n+      targ++;\n+    }\n+\n+  is_gui = is_gui_app (argv[0]);\n+  use_cmd = FALSE;\n+\n+  if (is_gui == -1) {\n+    /* could not determine application type. Try launching with \"cmd /c\" */\n+    is_gui = FALSE;\n+    arglen += 7;\n+    use_cmd = TRUE;\n+  }\n+\n+  cmdline = (char*)malloc (arglen + 1);\n+  targ = argv;\n+  parg = cmdline;\n+\n+  if (use_cmd == TRUE) {\n+    strcpy (parg, \"cmd /c \");\n+    parg += 7;\n+  }\n+\n+  while (*targ)\n+    {\n+      char * p = *targ;\n+      int need_quotes = 0;\n+\n+      if (*p == 0)\n+\tneed_quotes = 1;\n+\n+      if (do_quoting)\n+\t{\n+\t  for ( ; *p; p++)\n+\t    if (*p == ' ' || *p == '\\t' || *p == '\"')\n+\t      need_quotes = 1;\n+\t}\n+      if (need_quotes)\n+\t{\n+\t  int escape_char_run = 0;\n+\t  char * first;\n+\t  char * last;\n+\n+\t  p = *targ;\n+\t  first = p;\n+\t  last = p + strlen (p) - 1;\n+\t  *parg++ = '\"';\n+\t  for ( ; *p; p++)\n+\t    {\n+\t      if (*p == '\"')\n+\t\t{\n+\t\t  /* double preceding escape chars if any */\n+\t\t  while (escape_char_run > 0)\n+\t\t    {\n+\t\t      *parg++ = escape_char;\n+\t\t      escape_char_run--;\n+\t\t    }\n+\t\t  /* escape all quote chars, even at beginning or end */\n+\t\t  *parg++ = escape_char;\n+\t\t}\n+\t      *parg++ = *p;\n+\n+\t      if (*p == escape_char && escape_char != '\"')\n+\t\tescape_char_run++;\n+\t      else\n+\t\tescape_char_run = 0;\n+\t    }\n+\t  /* double escape chars before enclosing quote */\n+\t  while (escape_char_run > 0)\n+\t    {\n+\t      *parg++ = escape_char;\n+\t      escape_char_run--;\n+\t    }\n+\t  *parg++ = '\"';\n+\t}\n+      else\n+\t{\n+\t  strcpy (parg, *targ);\n+\t  parg += strlen (*targ);\n+\t}\n+      *parg++ = ' ';\n+      targ++;\n+    }\n+  *--parg = '\\0';\n+\n+  memset (&start, 0, sizeof (start));\n+  start.cb = sizeof (start);\n+\n+  if (process->usePipe == TRUE) {\n+    start.dwFlags = STARTF_USESTDHANDLES;\n+    start.hStdInput = process->w_forkin;\n+    start.hStdOutput = process->w_forkout;\n+    /* child's stderr is always redirected to outfd */\n+    start.hStdError = process->w_forkout;\n+  } else {\n+    start.dwFlags = STARTF_USESTDHANDLES;\n+    /* We only need to redirect stderr/stdout here. Stdin will be forced to\n+       the spawned process console by explaunch */\n+    start.hStdInput = NULL;\n+    start.hStdOutput = process->w_forkout;\n+    start.hStdError = process->w_forkout;\n+  }\n+\n+  /* Explicitly specify no security */\n+  if (!InitializeSecurityDescriptor (&sec_desc, SECURITY_DESCRIPTOR_REVISION))\n+    goto EH_Fail;\n+  if (!SetSecurityDescriptorDacl (&sec_desc, TRUE, NULL, FALSE))\n+    goto EH_Fail;\n+  sec_attrs.nLength = sizeof (sec_attrs);\n+  sec_attrs.lpSecurityDescriptor = &sec_desc;\n+  sec_attrs.bInheritHandle = FALSE;\n+\n+  /* creating a new console allow easier close. Do not use\n+     CREATE_NEW_PROCESS_GROUP as this results in disabling Ctrl+C */\n+  flags = CREATE_NEW_CONSOLE;\n+  if (NILP (Vw32_start_process_inherit_error_mode))\n+    flags |= CREATE_DEFAULT_ERROR_MODE;\n+\n+  /* if app is not a gui application, hide the console */\n+  if (is_gui == FALSE) {\n+    start.dwFlags |= STARTF_USESHOWWINDOW;\n+    start.wShowWindow = SW_HIDE;\n+  }\n+\n+  /* Set initial directory to null character to use current directory */\n+  if (!CreateProcess (NULL, cmdline, &sec_attrs, NULL, TRUE,\n+\t\t      flags, env, NULL, &start, &process->procinfo))\n+    goto EH_Fail;\n+\n+  pid = (int) process->procinfo.hProcess;\n+  process->pid=pid;\n+\n+  return pid;\n+\n+ EH_Fail:\n+  return -1;\n+}\n+\n+/*************************\n+ ** __gnat_send_header ()\n+ *************************/\n+\n+#define EXP_SLAVE_CREATE 'c'\n+#define EXP_SLAVE_KEY    'k'\n+#define EXP_SLAVE_MOUSE  'm'\n+#define EXP_SLAVE_WRITE  'w'\n+#define EXP_SLAVE_KILL   'x'\n+\n+#define EXP_KILL_TERMINATE  0x1\n+#define EXP_KILL_CTRL_C     0x2\n+#define EXP_KILL_CTRL_BREAK 0x4\n+\n+void\n+__gnat_send_header (struct TTY_Process* p, char header[5], int size, int *ret)\n+{\n+  if (p->usePipe == FALSE) {\n+    header[0] = EXP_SLAVE_WRITE;\n+    header[1] = size & 0xff;\n+    header[2] = (size & 0xff00) >> 8;\n+    header[3] = (size & 0xff0000) >> 16;\n+    header[4] = (size & 0xff000000) >> 24;\n+    *ret = 1;\n+  } else {\n+    *ret = 0;\n+  }\n+}\n+\n+/**********************************\n+ **  __gnat_setup_communication ()\n+ **********************************/\n+\n+int\n+__gnat_setup_communication (struct TTY_Process** process_out) /* output param */\n+{\n+  struct TTY_Process* process;\n+\n+  process = (struct TTY_Process*)malloc (sizeof (struct TTY_Process));\n+  ZeroMemory (process, sizeof (struct TTY_Process));\n+  *process_out = process;\n+\n+  return 0;\n+}\n+\n+#define EXP_PIPE_BASENAME \"\\\\\\\\.\\\\pipe\\\\ExpectPipe\"\n+\n+int\n+__gnat_setup_child_communication\n+  (struct TTY_Process* process,\n+   char** argv,\n+   int Use_Pipes)\n+{\n+  int cpid;\n+  HANDLE parent;\n+  SECURITY_ATTRIBUTES sec_attrs;\n+  char slavePath [MAX_PATH];\n+  char **nargv;\n+  int argc;\n+  int i;\n+  char pipeNameIn[100];\n+  HANDLE hSlaveInDrv = NULL; /* Handle to communicate with slave driver */\n+\n+  parent = GetCurrentProcess ();\n+\n+  /* Set inheritance for the pipe handles */\n+  sec_attrs.nLength = sizeof (SECURITY_ATTRIBUTES);\n+  sec_attrs.bInheritHandle = TRUE;\n+  sec_attrs.lpSecurityDescriptor = NULL;\n+\n+  if (Use_Pipes) {\n+    /* Create in and out pipes */\n+    if (!CreatePipe (&process->w_forkin, &process->w_infd, &sec_attrs, 0))\n+      report_file_error (\"Creation of child's IN handle\", Qnil);\n+    if (!CreatePipe (&process->w_outfd, &process->w_forkout, &sec_attrs, 0))\n+      report_file_error (\"Creation of child's OUT handle\", Qnil);\n+\n+    /* Do not inherit the parent's side of the pipes */\n+    SetHandleInformation (&process->w_infd, HANDLE_FLAG_INHERIT, 0);\n+    SetHandleInformation (&process->w_outfd, HANDLE_FLAG_INHERIT, 0);\n+\n+    /* use native argv */\n+    nargv = argv;\n+    process->usePipe = TRUE;\n+\n+  } else {\n+    static int pipeNameId = 0;\n+\n+    process->w_infd = NULL;\n+\n+    /* We create a named pipe for Input, as we handle input by sending special\n+       commands to the explaunch process, that uses it to feed the actual input\n+       of the process */\n+    sprintf(pipeNameIn, \"%sIn%08x_%08x\", EXP_PIPE_BASENAME,\n+\t    GetCurrentProcessId(), pipeNameId);\n+    pipeNameId++;\n+\n+    hSlaveInDrv = CreateNamedPipe(pipeNameIn,\n+\t\t\t\t  PIPE_ACCESS_OUTBOUND,\n+\t\t\t\t  PIPE_TYPE_BYTE | PIPE_WAIT, 1, 8192, 8192,\n+\t\t\t\t  20000, NULL);\n+    if (hSlaveInDrv == NULL)  goto end;\n+\n+    if (!CreatePipe (&process->w_outfd, &process->w_forkout, &sec_attrs, 0))\n+      report_file_error (\"Creation of child's OUT handle\", Qnil);\n+\n+    if (SearchPath (NULL, \"explaunch.exe\", NULL,\n+                    MAX_PATH, slavePath, NULL) == 0) goto end;\n+\n+    for (argc=0; argv[argc] != NULL; argc++) ;\n+    nargv = (char **) malloc (sizeof (char*) * (argc + 3));\n+    nargv[0] = slavePath;\n+    nargv[1] = pipeNameIn;\n+\n+    for (i = 0; i <= argc; i++) nargv[i + 2] = argv[i];\n+    process->usePipe = FALSE;\n+  }\n+\n+  /* Spawn the child. */\n+  cpid = nt_spawnve (nargv[0], nargv, NULL, process);\n+\n+  /* close the duplicated handles passed to the child */\n+  CloseHandle (process->w_forkout);\n+\n+  if (process->usePipe == TRUE) {\n+    CloseHandle (process->w_forkin);\n+\n+  } else {\n+    UCHAR buf[8];\t\t/* enough space for child status info */\n+    DWORD count;\n+    BOOL bRet;\n+    DWORD dwRet;\n+\n+    /*\n+     * Wait for connection with the slave driver\n+     */\n+    bRet = ConnectNamedPipe(hSlaveInDrv, NULL);\n+    if (bRet == FALSE) {\n+      dwRet = GetLastError();\n+      if (dwRet == ERROR_PIPE_CONNECTED) {\n+\t;\n+      } else {\n+\tgoto end;\n+      }\n+    }\n+\n+    process->w_infd = hSlaveInDrv;\n+\n+    /*\n+     * wait for slave driver to initialize before allowing user to send to it\n+     */\n+    bRet = ReadFile(process->w_outfd, buf, 8, &count, NULL);\n+    if (bRet == FALSE) {\n+      cpid = -1;\n+    }\n+\n+    dwRet = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n+    if (dwRet != 0) {\n+      cpid = -1;\n+    }\n+\n+    cpid = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\n+    process->pid = cpid;\n+  }\n+\n+  if (cpid == -1)\n+    /* An error occurred while trying to spawn the process.  */\n+    report_file_error (\"Spawning child process\", Qnil);\n+\n+  return cpid;\n+ end:\n+  if (hSlaveInDrv != NULL)\n+    CloseHandle (hSlaveInDrv);\n+  return -1;\n+}\n+\n+void\n+__gnat_setup_parent_communication\n+  (struct TTY_Process* process,\n+   int* in,\n+   int* out,\n+   int* err,\n+   int* pid)\n+{\n+  *in = _open_osfhandle ((long) process->w_infd, 0);\n+  *out = _open_osfhandle ((long) process->w_outfd, 0);\n+  /* child's stderr is always redirected to outfd */\n+  *err = *out;\n+  *pid = process->pid;\n+}\n+\n+typedef struct _child_process\n+{\n+  HWND                 hwnd;\n+  PROCESS_INFORMATION *procinfo;\n+} child_process;\n+\n+/* The major and minor versions of NT.  */\n+static int w32_major_version;\n+static int w32_minor_version;\n+\n+/* Distinguish between Windows NT and Windows 95.  */\n+static enum {OS_UNKNOWN, OS_WIN95, OS_NT} os_subtype = OS_UNKNOWN;\n+\n+/* Cache information describing the NT system for later use.  */\n+static void\n+cache_system_info (void)\n+{\n+  union\n+    {\n+      struct info\n+        {\n+          char  major;\n+          char  minor;\n+          short platform;\n+        } info;\n+      DWORD data;\n+    } version;\n+\n+  /* Cache the version of the operating system.  */\n+  version.data = GetVersion ();\n+  w32_major_version = version.info.major;\n+  w32_minor_version = version.info.minor;\n+\n+  if (version.info.platform & 0x8000)\n+    os_subtype = OS_WIN95;\n+  else\n+    os_subtype = OS_NT;\n+}\n+\n+static BOOL CALLBACK\n+find_child_console (HWND hwnd, child_process * cp)\n+{\n+  DWORD thread_id;\n+  DWORD process_id;\n+\n+  thread_id = GetWindowThreadProcessId (hwnd, &process_id);\n+  if (process_id == cp->procinfo->dwProcessId)\n+    {\n+      char window_class[32];\n+\n+      GetClassName (hwnd, window_class, sizeof (window_class));\n+      if (strcmp (window_class,\n+                  (os_subtype == OS_WIN95)\n+                  ? \"tty\"\n+                  : \"ConsoleWindowClass\") == 0)\n+        {\n+          cp->hwnd = hwnd;\n+          return FALSE;\n+        }\n+    }\n+  /* keep looking */\n+  return TRUE;\n+}\n+\n+int\n+__gnat_interrupt_process (struct TTY_Process* p)\n+{\n+  char buf[2];\n+  DWORD written;\n+  BOOL bret;\n+\n+  if (p->usePipe == TRUE) {\n+    bret = FALSE;\n+  } else {\n+    buf[0] = EXP_SLAVE_KILL;\n+    buf[1] = EXP_KILL_CTRL_C;\n+    bret = WriteFile (p->w_infd, buf, 2, &written, NULL);\n+  }\n+\n+  if (bret == FALSE) {\n+    return __gnat_interrupt_pid (p->procinfo.dwProcessId);\n+  }\n+  return 0;\n+}\n+\n+int\n+__gnat_interrupt_pid (int pid)\n+{\n+  volatile child_process cp;\n+  int rc = 0;\n+\n+  cp.procinfo = (LPPROCESS_INFORMATION) malloc (sizeof (PROCESS_INFORMATION));\n+  cp.procinfo->dwProcessId = pid;\n+\n+  if (os_subtype == OS_UNKNOWN)\n+    cache_system_info ();\n+\n+  /* Try to locate console window for process. */\n+  EnumWindows ((WNDENUMPROC) find_child_console, (LPARAM) &cp);\n+\n+  if (cp.hwnd)\n+    {\n+      BYTE control_scan_code = (BYTE) MapVirtualKey (VK_CONTROL, 0);\n+      /* Retrieve Ctrl-C scancode */\n+      BYTE vk_break_code = 'C';\n+      BYTE break_scan_code = (BYTE) MapVirtualKey (vk_break_code, 0);\n+      HWND foreground_window;\n+\n+      foreground_window = GetForegroundWindow ();\n+      if (foreground_window)\n+        {\n+          /* NT 5.0, and apparently also Windows 98, will not allow\n+             a Window to be set to foreground directly without the\n+             user's involvement. The workaround is to attach\n+             ourselves to the thread that owns the foreground\n+             window, since that is the only thread that can set the\n+             foreground window.  */\n+          DWORD foreground_thread, child_thread;\n+\n+          foreground_thread =\n+            GetWindowThreadProcessId (foreground_window, NULL);\n+          if (foreground_thread == GetCurrentThreadId ()\n+              || !AttachThreadInput (GetCurrentThreadId (),\n+                                     foreground_thread, TRUE))\n+            foreground_thread = 0;\n+\n+          child_thread = GetWindowThreadProcessId (cp.hwnd, NULL);\n+          if (child_thread == GetCurrentThreadId ()\n+              || !AttachThreadInput (GetCurrentThreadId (),\n+                                     child_thread, TRUE))\n+            child_thread = 0;\n+\n+          /* Set the foreground window to the child.  */\n+          if (SetForegroundWindow (cp.hwnd))\n+            {\n+              /* Generate keystrokes as if user had typed Ctrl-Break or\n+                 Ctrl-C.  */\n+              keybd_event (VK_CONTROL, control_scan_code, 0, 0);\n+              keybd_event (vk_break_code, break_scan_code,\n+                (vk_break_code == 'C' ? 0 : KEYEVENTF_EXTENDEDKEY), 0);\n+              keybd_event (vk_break_code, break_scan_code,\n+                (vk_break_code == 'C' ? 0 : KEYEVENTF_EXTENDEDKEY)\n+                 | KEYEVENTF_KEYUP, 0);\n+              keybd_event (VK_CONTROL, control_scan_code, KEYEVENTF_KEYUP, 0);\n+\n+              /* Sleep for a bit to give time for the main frame to respond\n+              to focus change events.  */\n+              Sleep (100);\n+\n+              SetForegroundWindow (foreground_window);\n+            }\n+          /* Detach from the foreground and child threads now that\n+             the foreground switching is over.  */\n+          if (foreground_thread)\n+\t    AttachThreadInput (GetCurrentThreadId (), foreground_thread, FALSE);\n+\t  if (child_thread)\n+            AttachThreadInput (GetCurrentThreadId (), child_thread, FALSE);\n+        }\n+    }\n+  /* Ctrl-Break is NT equivalent of SIGINT.  */\n+  else if (!GenerateConsoleCtrlEvent\n+             (CTRL_BREAK_EVENT, cp.procinfo->dwProcessId))\n+    {\n+      errno = EINVAL;\n+      rc = -1;\n+    }\n+\n+  free (cp.procinfo);\n+  return rc;\n+}\n+\n+/* kill a process, as this implementation use CreateProcess on Win32 we need\n+   to use Win32 TerminateProcess API */\n+int\n+__gnat_terminate_process (struct TTY_Process* p)\n+{\n+  char buf[2];\n+  DWORD written;\n+  BOOL bret;\n+\n+  if (p->usePipe == TRUE) {\n+    bret = FALSE;\n+  } else {\n+    buf[0] = EXP_SLAVE_KILL;\n+    buf[1] = EXP_KILL_TERMINATE;\n+    bret = WriteFile (p->w_infd, buf, 2, &written, NULL);\n+  }\n+\n+  if (bret == FALSE) {\n+    if (!TerminateProcess (p->procinfo.hProcess, 1))\n+      return -1;\n+    else\n+      return 0;\n+  } else\n+    return 0;\n+}\n+\n+/* wait for process pid to terminate and return the process status. This\n+   implementation is different from the adaint.c one for Windows as it uses\n+   the Win32 API instead of the C one. */\n+\n+int\n+__gnat_tty_waitpid (struct TTY_Process* p)\n+{\n+  DWORD exitcode;\n+  DWORD res;\n+  HANDLE proc_hand = p->procinfo.hProcess;\n+\n+  res = WaitForSingleObject (proc_hand, 0);\n+  GetExitCodeProcess (proc_hand, &exitcode);\n+\n+  CloseHandle (p->procinfo.hThread);\n+  CloseHandle (p->procinfo.hProcess);\n+\n+  /* No need to close the handles: they were closed on the ada side */\n+\n+  return (int) exitcode;\n+}\n+\n+/********************************\n+ **  __gnat_free_process ()\n+ ********************************/\n+\n+void\n+__gnat_free_process (struct TTY_Process** process)\n+{\n+  free (*process);\n+  *process = NULL;\n+}\n+\n+/* TTY handling */\n+\n+typedef struct {\n+  int tty_fd;        /* descriptor for the tty */\n+  char tty_name[24]; /* Name of TTY device */\n+} TTY_Handle;\n+\n+int\n+__gnat_tty_supported (void)\n+{\n+  return 0;\n+}\n+\n+/* Return the tty name associated with p */\n+\n+char *\n+__gnat_tty_name (TTY_Handle* t)\n+{\n+  return t->tty_name;\n+}\n+\n+int\n+__gnat_tty_fd (TTY_Handle* t)\n+{\n+  return t->tty_fd;\n+}\n+\n+TTY_Handle*\n+__gnat_new_tty (void)\n+{\n+  return (TTY_Handle*)0;\n+}\n+\n+void\n+__gnat_reset_tty (TTY_Handle* t)\n+{\n+  return;\n+}\n+\n+void\n+__gnat_close_tty (TTY_Handle* t)\n+{\n+  free (t);\n+}\n+\n+void\n+__gnat_setup_winsize (void *desc, int rows, int columns)\n+{\n+}\n+\n+#else /* defined(_WIN32, implementatin for all UNIXes */\n+\n+/* First defined some macro to identify easily some systems */\n+#if defined (__FreeBSD__) \\\n+ || defined (__OpenBSD__) \\\n+ || defined (__NetBSD__)  \\\n+ || defined (__DragonFly__)\n+#   define FREEBSD\n+#endif\n+#if defined (__alpha__) && defined (__osf__)\n+#   define OSF1\n+#endif\n+#if defined (__mips) && defined (__sgi)\n+#   define IRIX\n+#endif\n+\n+/* Include every system header we need */\n+#define _GNU_SOURCE\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+/* On some system termio is either absent or including it will disable termios\n+   (HP-UX) */\n+#if ! defined (__hpux__) && ! defined (FREEBSD) && ! defined (__APPLE__)\n+#   include <termio.h>\n+#endif\n+\n+#include <sys/ioctl.h>\n+#include <termios.h>\n+#include <fcntl.h>\n+#include <string.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/wait.h>\n+#include <unistd.h>\n+#if defined (sun)\n+#   include <sys/stropts.h>\n+#endif\n+#if defined (FREEBSD) || defined (sun)\n+#   include <sys/signal.h>\n+#endif\n+#if defined (__hpux__)\n+#   include <sys/termio.h>\n+#   include <sys/stropts.h>\n+#endif\n+\n+#define CDISABLE _POSIX_VDISABLE\n+\n+/* On HP-UX and Sun system, there is a bzero function but with a different\n+   signature. Use memset instead */\n+#if defined (__hpux__) || defined (sun) || defined (_AIX)\n+#   define bzero(s,n) memset (s,0,n)\n+#endif\n+\n+/* POSIX does not specify how to open the master side of a terminal.Several\n+   methods are available (system specific):\n+      1- using a cloning device (USE_CLONE_DEVICE)\n+      2- getpt                  (USE_GETPT)\n+      3- openpty                (USE_OPENPTY)\n+      4- _getpty                (USE_GETPTY)\n+\n+   When using the cloning device method, the macro USE_CLONE_DEVICE should\n+   contains a full path to the adequate device.\n+\n+   When a new system is about to be supported, one of the previous macro should\n+   be set otherwise allocate_pty_desc will return an error\n+*/\n+\n+/* Configurable part */\n+#if defined (__APPLE__) || defined (FREEBSD)\n+#define USE_OPENPTY\n+#elif defined (IRIX)\n+#define USE_GETPTY\n+#elif defined (linux)\n+#define USE_GETPT\n+#elif defined (sun)\n+#define USE_CLONE_DEVICE \"/dev/ptmx\"\n+#elif defined (_AIX)\n+#define USE_CLONE_DEVICE \"/dev/ptc\"\n+#elif defined (OSF1)\n+/* On Tru64, the systems offers various interfaces to open a terminal:\n+    - /dev/ptmx: this the system V driver (stream based),\n+    - /dev/ptmx_bsd: the non stream based clone device,\n+    - the openpty function which use BSD interface.\n+\n+   Using directly /dev/ptmx_bsd on Tru64 5.1B seems to consume all the\n+   available slave ptys (why ?). When using openpty it seems that the function\n+   handles the creation of entries in /dev/pts when necessary and so avoid this\n+   starvation issue. The pty man entry suggests also to use openpty.\n+*/\n+#define USE_OPENPTY\n+#elif defined (__hpux__)\n+/* On HP-UX we use the streamed version. Using the non streamed version is not\n+   recommanded (through \"/dev/ptym/clone\"). Indeed it seems that there are\n+   issues to detect process terminations. */\n+#define USE_CLONE_DEVICE \"/dev/ptmx\"\n+#endif\n+\n+/* structure that holds information about the terminal used and the process\n+   connected on the slave side */\n+typedef struct pty_desc_struct {\n+   int  master_fd;     /* fd of the master side if the terminal */\n+   int  slave_fd;      /* fd of the slave side */\n+   char slave_name[32];   /* filename of the slave side */\n+   int  child_pid;     /* PID of the child process connected to the slave side\n+                         of the terminal */\n+} pty_desc;\n+\n+/* allocate_pty_desc - allocate a pseudo terminal\n+ *\n+ * PARAMETERS\n+ *   out desc  returned pointer to a pty_desc structure containing information\n+ *             about the opened pseudo terminal\n+ * RETURN VALUE\n+ *   -1        if failed\n+ *    0        if ok\n+ * COMMENTS\n+ *   If the function is successful we should have at least the master side fd\n+ *   and the slave side filename. On some system, the slave side will also be\n+ *   opened. If this is not the case the slave side will be open once we are in\n+ *   the child process (note that opening the slave side at this stage will\n+ *   failed...).\n+ */\n+\n+extern char* ptsname (int);\n+\n+static int\n+allocate_pty_desc (pty_desc **desc) {\n+\n+   pty_desc *result;\n+   int  status      =  0;\n+   int  slave_fd    = -1;\n+   int  master_fd   = -1;\n+   char *slave_name = NULL;\n+\n+#ifdef USE_GETPT\n+  master_fd = getpt ();\n+#elif defined (USE_OPENPTY)\n+  status = openpty (&master_fd, &slave_fd, NULL, NULL, NULL);\n+#elif defined (USE_GETPTY)\n+  slave_name = _getpty (&master_fd, O_RDWR | O_NDELAY, 0600, 0);\n+  if (slave_name == NULL) status = -1;\n+#elif defined (USE_CLONE_DEVICE)\n+  master_fd = open (USE_CLONE_DEVICE, O_RDWR | O_NONBLOCK, 0);\n+#else\n+  printf (\"[error]: terminal support is not configured\\n\");\n+  return -1;\n+#endif\n+\n+  /* at this stage we should have the master side fd and status should be 0 */\n+  if (status != 0 || master_fd < 0)\n+    {\n+      /* If this is not the case close all opened files and return -1 */\n+      printf (\"[error]: cannot allocate master side of the pty\\n\");\n+      if (master_fd >= 0) close (master_fd);\n+      if (slave_fd  >= 0) close (slave_fd);\n+      *desc = NULL;\n+      return -1;\n+    }\n+\n+  /* retrieve the file name of the slave side if necessary */\n+  if (slave_name == NULL) slave_name = (char *) ptsname (master_fd);\n+\n+  /* Now we should have slave file name */\n+  if (slave_name == NULL)\n+    {\n+      /* If not the case close any opened file and return - 1 */\n+      printf (\"[error]: cannot allocate slave side of the pty\\n\");\n+      if (master_fd >= 0) close (master_fd);\n+      if (slave_fd  >= 0) close (slave_fd);\n+      *desc = NULL;\n+      return -1;\n+    }\n+\n+  /* grant access to the slave side */\n+  grantpt (master_fd);\n+  /* unlock the terminal */\n+  unlockpt (master_fd);\n+\n+  /* set desc and return 0 */\n+  result = malloc (sizeof (pty_desc));\n+  result->master_fd  = master_fd;\n+  result->slave_fd   = slave_fd;\n+  /* the string returned by ptsname or _getpty is a static allocated string. So\n+     we should make a copy */\n+  strncpy (result->slave_name, slave_name, sizeof (result->slave_name));\n+  result->slave_name[sizeof (result->slave_name) - 1] = '\\0';\n+  result->child_pid  = -1;\n+  *desc=result;\n+  return 0;\n+}\n+\n+/* some utility macro that make the code of child_setup_tty easier to read */\n+#define __enable(a, b) ((a) |= (b))\n+#define __disable(a, b) ((a) &= ~(b))\n+\n+/* some properties do not exist on all systems. Set their value to 0 in that\n+   case */\n+#ifndef IUCLC\n+#define IUCLC 0\n+#endif\n+#ifndef OLCUC\n+#define OLCUC 0\n+#endif\n+#ifndef NLDLY\n+#define NLDLY 0\n+#define CRDLY 0\n+#define TABDLY 0\n+#define BSDLY 0\n+#define VTDLY 0\n+#define FFDLY 0\n+#endif\n+\n+/* child_setup_tty - set terminal properties\n+ *\n+ * PARAMETERS\n+ *   file descriptor of the slave side of the terminal\n+ *\n+ * RETURN VALUE\n+ *   0 if success, any other value if failed.\n+ *\n+ * COMMENTS\n+ *   None\n+ */\n+static int\n+child_setup_tty (int fd)\n+{\n+  struct termios s;\n+  int    status;\n+\n+  /* ensure that s is filled with 0 */\n+  bzero (&s, sizeof (&s));\n+\n+  /* Get the current terminal settings */\n+  status = tcgetattr (fd, &s);\n+  if (status != 0) return -1;\n+\n+  /* Adjust input modes */\n+  __disable (s.c_iflag, IUCLC);    /* don't transform to lower case */\n+  __disable (s.c_iflag, ISTRIP);   /* don't delete 8th bit */\n+\n+  /* Adjust output modes */\n+  __enable  (s.c_oflag, OPOST);    /* enable postprocessing */\n+  __disable (s.c_oflag, ONLCR);    /* don't map LF to CR-LF */\n+  __disable (s.c_oflag, NLDLY|CRDLY|TABDLY|BSDLY|VTDLY|FFDLY);\n+                                   /* disable delays */\n+  __disable (s.c_oflag, OLCUC);    /* don't transform to upper case */\n+\n+  /* Adjust control modes */\n+  s.c_cflag = (s.c_cflag & ~CSIZE) | CS8; /* Don't strip 8th bit */\n+\n+  /* Adjust local modes */\n+  __disable (s.c_lflag, ECHO);     /* disable echo */\n+  __enable  (s.c_lflag, ISIG);     /* enable signals */\n+  __enable  (s.c_lflag, ICANON);   /* erase/kill/eof processing */\n+\n+  /* Adjust control characters */\n+  /* IMPORTANT: we need to ensure that Ctrl-C will trigger an interrupt signal\n+     otherwise send_signal_via_characters will fail */\n+  s.c_cc[VEOF]   = 04;         /* insure that EOF is Control-D */\n+  s.c_cc[VERASE] = CDISABLE;   /* disable erase processing */\n+  s.c_cc[VKILL]  = CDISABLE;   /* disable kill processing */\n+  s.c_cc[VQUIT]  = 28;         /* Control-\\ */\n+  s.c_cc[VINTR]  = 03;         /* Control-C */\n+  s.c_cc[VEOL]   = CDISABLE;\n+  s.c_cc[VSUSP]  = 26;         /* Control-Z */\n+\n+  /* push our changes */\n+  status = tcsetattr (fd, TCSADRAIN, &s);\n+  return status;\n+}\n+\n+/* __gnat_setup_communication - interface to the external world. Should be\n+ * called before forking. On Unixes this function only call allocate_pty_desc.\n+ * The Windows implementation (in different part of this file) is very\n+ * different.\n+ *\n+ * PARAMETERS\n+ *  out desc   returned pointer to a pty_desc structure\n+ * RETURN VALUE\n+ *  0 if success, -1 otherwise\n+ */\n+int __gnat_setup_communication (pty_desc** desc) {\n+  return allocate_pty_desc (desc);\n+}\n+\n+/* __gnat_setup_parent_communication - interface to the external world. Should\n+ * be called after forking in the parent process\n+ *\n+ * PARAMETERS\n+ *   out in_fd\n+     out out_fd\n+     out err_fd fds corresponding to the parent side of the\n+                terminal\n+     in pid_out child process pid\n+ * RETRUN VALUE\n+ *  0\n+ */\n+void\n+__gnat_setup_parent_communication\n+  (pty_desc *desc,\n+   int*     in_fd,  /* input */\n+   int*     out_fd, /* output */\n+   int*     err_fd, /* error */\n+   int*     pid_out)\n+{\n+\n+  *in_fd = desc->master_fd;\n+  *out_fd= desc->master_fd;\n+  *err_fd= desc->master_fd;\n+  desc->child_pid = *pid_out;\n+}\n+\n+/* __gnat_setup_winsize - Sets up the size of the terminal\n+ * This lets the process know the size of the terminal\n+ */\n+\n+void __gnat_setup_winsize (pty_desc *desc, int rows, int columns) {\n+#ifdef TIOCGWINSZ\n+  struct winsize s;\n+  s.ws_row = (unsigned short)rows;\n+  s.ws_col = (unsigned short)columns;\n+  s.ws_xpixel = 0;\n+  s.ws_ypixel = 0;\n+  ioctl (desc->master_fd, TIOCSWINSZ, &s);\n+#ifdef SIGWINCH\n+  if (desc->child_pid > 0) {\n+     /* Let the process know about the change in size */\n+     kill (desc->child_pid, SIGWINCH);\n+  }\n+#endif\n+#endif\n+}\n+\n+/* __gnat_setup_child_communication - interface to external world. Should be\n+ * called after forking in the child process. On Unixes, this function\n+ * first adjust the line setting, set standard output, input and error and\n+ * then spawn the program.\n+ *\n+ * PARAMETERS\n+ *   desc      a pty_desc structure containing the pty parameters\n+ *   new_argv  argv of the program to be spawned\n+ * RETURN VALUE\n+ *   this function should not return\n+ */\n+int\n+__gnat_setup_child_communication\n+   (pty_desc *desc,\n+    char **new_argv,\n+    int Use_Pipes)\n+{\n+  int status;\n+  int pid = getpid ();\n+\n+  setsid ();\n+\n+  /* open the slave side of the terminal if necessary */\n+  if (desc->slave_fd == -1)\n+#if defined (_AIX)\n+    /* On AIX, if the slave process is not opened with O_NDELAY or O_NONBLOCK\n+       then we might have some processes hanging on I/O system calls. Not sure\n+       we can do that for all platforms so do it only on AIX for the moment.\n+       On AIX O_NONBLOCK and O_NDELAY have slightly different meanings. When\n+       reading on the slave fd, in case there is no data available, if O_NDELAY\n+       is set then 0 is returned. If O_NON_BLOCK is -1 is returned. It seems\n+       that interactive programs such as GDB prefer the O_NDELAY behavior.\n+       We chose O_NONBLOCK because it allows us to make the distinction\n+       between a true EOF and an EOF returned because there is no data\n+       available to be read.  */\n+    desc->slave_fd = open (desc->slave_name, O_RDWR | O_NONBLOCK, 0);\n+#else\n+    desc->slave_fd = open (desc->slave_name, O_RDWR, 0);\n+#endif\n+\n+#if defined (sun) || defined (__hpux__)\n+  /* On systems such as Solaris we are using stream. We need to push the right\n+     \"modules\" in order to get the expected terminal behaviors. Otherwise\n+     functionalities such as termios are not available.  */\n+  ioctl (desc->slave_fd, I_PUSH, \"ptem\");\n+  ioctl (desc->slave_fd, I_PUSH, \"ldterm\");\n+  ioctl (desc->slave_fd, I_PUSH, \"ttcompat\");\n+#endif\n+\n+#ifdef TIOCSCTTY\n+  /* make the tty the controling terminal */\n+  status = ioctl (desc->slave_fd, TIOCSCTTY, 0);\n+#endif\n+\n+  /* adjust tty settings */\n+  child_setup_tty (desc->slave_fd);\n+  __gnat_setup_winsize (desc, 24, 80); /* To prevent errors in some shells */\n+\n+  /* stdin, stdout and stderr should be now our tty */\n+  dup2 (desc->slave_fd, 0);\n+  dup2 (desc->slave_fd, 1);\n+  dup2 (desc->slave_fd, 2);\n+  if (desc->slave_fd > 2) close (desc->slave_fd);\n+\n+  /* adjust process group settings */\n+  status = setpgid (pid, pid);\n+  status = tcsetpgrp (0, pid);\n+\n+  /* launch the program */\n+  execvp (new_argv[0], new_argv);\n+\n+  /* return the pid */\n+  return pid;\n+}\n+\n+/* send_signal_via_characters - Send a characters that will trigger a signal\n+ * in the child process.\n+ *\n+ * PARAMETERS\n+ *  desc  a pty_desc structure containing terminal information\n+ *  int   a signal number\n+ * RETURN VALUE\n+ *  None\n+ */\n+static void\n+send_signal_via_characters\n+  (pty_desc *desc,\n+   int signal_number)\n+{\n+  char ctrl_c         = 03;\n+  char ctrl_backslash = 28;\n+  char ctrl_Z         = 26;\n+\n+  switch (signal_number)\n+    {\n+      case SIGINT:\n+\twrite (desc->master_fd, &ctrl_c, 1); return;\n+      case SIGQUIT:\n+\twrite (desc->master_fd, &ctrl_backslash, 1); return;\n+      case SIGTSTP:\n+\twrite (desc->master_fd, &ctrl_Z, 1); return;\n+    }\n+}\n+\n+/* __gnat_interrupt_process - interrupt the child process\n+ *\n+ * PARAMETERS\n+ *   desc a pty_desc structure\n+ */\n+int\n+__gnat_interrupt_process (pty_desc *desc)\n+{\n+  send_signal_via_characters (desc, SIGINT);\n+  return 0;\n+}\n+\n+/* __gnat_interrupt_pid - interrupt a process group\n+ *\n+ * PARAMETERS\n+ *   pid  pid of the process to interrupt\n+ */\n+int\n+__gnat_interrupt_pid (int pid)\n+{\n+  kill (-pid, SIGINT);\n+  return 0;\n+}\n+\n+/* __gnat_terminate_process - kill a child process\n+ *\n+ * PARAMETERS\n+ *   desc pty_desc structure\n+ */\n+int __gnat_terminate_process (pty_desc *desc)\n+{\n+  return kill (desc->child_pid, SIGKILL);\n+}\n+\n+/* __gnat_tty_waitpid - wait for the child proces to die\n+ *\n+ * PARAMETERS\n+ *   desc pty_desc structure\n+ * RETURN VALUE\n+ *   exit status of the child process\n+ */\n+int\n+__gnat_tty_waitpid (pty_desc *desc)\n+{\n+  int status = 0;\n+  waitpid (desc->child_pid, &status, 0);\n+  return WEXITSTATUS (status);\n+}\n+\n+/* __gnat_tty_supported - Are tty supported ?\n+ *\n+ * RETURN VALUE\n+ *   always 1 on Unix systems\n+ */\n+int\n+__gnat_tty_supported (void)\n+{\n+  return 1;\n+}\n+\n+/* __gnat_free_process - free a pty_desc structure\n+ *\n+ * PARAMETERS\n+ *   in out desc: a pty desc structure\n+ */\n+void\n+__gnat_free_process (pty_desc** desc)\n+{\n+  free (*desc);\n+  *desc = NULL;\n+}\n+\n+/* __gnat_send_header - dummy function. this interface is only used on Windows */\n+void\n+__gnat_send_header (pty_desc* desc, char header[5], int size, int *ret)\n+{\n+  *ret = 0;\n+}\n+\n+/* __gnat_reset_tty - reset line setting\n+ *\n+ * PARAMETERS\n+ *   desc: a pty_desc structure\n+ */\n+void\n+__gnat_reset_tty (pty_desc* desc)\n+{\n+  child_setup_tty (desc->master_fd);\n+}\n+\n+/* __gnat_new_tty - allocate a new terminal\n+ *\n+ * RETURN VALUE\n+ *   a pty_desc structure\n+ */\n+pty_desc *\n+__gnat_new_tty (void)\n+{\n+  int status;\n+  pty_desc* desc;\n+  status = allocate_pty_desc (&desc);\n+  child_setup_tty (desc->master_fd);\n+  return desc;\n+}\n+\n+/* __gnat_close_tty - close a terminal\n+ *\n+ * PARAMETERS\n+ *   desc  a pty_desc strucure\n+ */\n+void __gnat_close_tty (pty_desc* desc)\n+{\n+  if (desc->master_fd >= 0) close (desc->master_fd);\n+  if (desc->slave_fd  >= 0) close (desc->slave_fd);\n+}\n+\n+/* __gnat_tty_name - return slave side device name\n+ *\n+ * PARAMETERS\n+ *   desc  a pty_desc strucure\n+ * RETURN VALUE\n+ *   a string\n+ */\n+char *\n+__gnat_tty_name (pty_desc* desc)\n+{\n+  return desc->slave_name;\n+}\n+\n+/* __gnat_tty_name - return master side fd\n+ *\n+ * PARAMETERS\n+ *   desc  a pty_desc strucure\n+ * RETURN VALUE\n+ *   a fd\n+ */\n+int\n+__gnat_tty_fd (pty_desc* desc)\n+{\n+  return desc->master_fd;\n+}\n+\n+#endif /* WIN32 */"}]}