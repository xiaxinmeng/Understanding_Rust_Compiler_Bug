{"sha": "8b415b271e9a1be0634b2c9ec4114fea7f32ceb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI0MTViMjcxZTlhMWJlMDYzNGIyYzllYzQxMTRmZWE3ZjMyY2ViOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-09-10T18:45:29Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-09-10T18:45:29Z"}, "message": "re PR bootstrap/58386 (libstdc++.so.6: undefined symbol: htab_hash_pointer)\n\n2013-09-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR bootstrap/58386\n\tRevert:\n\n\t2013-09-10  Gary Benson  <gbenson@redhat.com>\n\n\t* cp-demangle.c: Include hashtab.h.\n\t(struct d_print_info): New field saved_scopes.\n\t(d_print_init): Initialize the above.\n\t(d_print_free): New function.\n\t(cplus_demangle_print_callback): Call the above.\n\t(struct d_saved_scope): New structure.\n\t(d_store_scope): New function.\n\t(d_free_scope) Likewise.\n\t(d_restore_scope) Likewise.\n\t(d_hash_saved_scope) Likewise.\n\t(d_equal_saved_scope) Likewise.\n\t(d_print_comp): New variable saved_scope.\n\t[DEMANGLE_COMPONENT_REFERENCE,\n\tDEMANGLE_COMPONENT_RVALUE_REFERENCE]: Capture scope the first\n\ttime the component is traversed, and use the captured scope for\n\tsubsequent traversals.\n\nFrom-SVN: r202480", "tree": {"sha": "4750ae2d7442502518818658630a3bbcd3c9fe56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4750ae2d7442502518818658630a3bbcd3c9fe56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8/comments", "author": null, "committer": null, "parents": [{"sha": "d742ff4ba1609fe71d0a9396483b95d375e4599a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d742ff4ba1609fe71d0a9396483b95d375e4599a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d742ff4ba1609fe71d0a9396483b95d375e4599a"}], "stats": {"total": 196, "additions": 26, "deletions": 170}, "files": [{"sha": "3ebf3c17662ab86e151b501ba5b9667da565c6f8", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=8b415b271e9a1be0634b2c9ec4114fea7f32ceb8", "patch": "@@ -1,3 +1,27 @@\n+2013-09-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR bootstrap/58386\n+\tRevert:\n+\n+\t2013-09-10  Gary Benson  <gbenson@redhat.com>\n+\n+\t* cp-demangle.c: Include hashtab.h.\n+\t(struct d_print_info): New field saved_scopes.\n+\t(d_print_init): Initialize the above.\n+\t(d_print_free): New function.\n+\t(cplus_demangle_print_callback): Call the above.\n+\t(struct d_saved_scope): New structure.\n+\t(d_store_scope): New function.\n+\t(d_free_scope) Likewise.\n+\t(d_restore_scope) Likewise.\n+\t(d_hash_saved_scope) Likewise.\n+\t(d_equal_saved_scope) Likewise.\n+\t(d_print_comp): New variable saved_scope.\n+\t[DEMANGLE_COMPONENT_REFERENCE,\n+\tDEMANGLE_COMPONENT_RVALUE_REFERENCE]: Capture scope the first\n+\ttime the component is traversed, and use the captured scope for\n+\tsubsequent traversals.\n+\n 2013-09-10  Gary Benson  <gbenson@redhat.com>\n \n \t* cp-demangle.c: Include hashtab.h."}, {"sha": "70f54389c892957a113f627c4cfc806a79f63afb", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 2, "deletions": 167, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=8b415b271e9a1be0634b2c9ec4114fea7f32ceb8", "patch": "@@ -128,7 +128,6 @@ extern char *alloca ();\n #include \"libiberty.h\"\n #include \"demangle.h\"\n #include \"cp-demangle.h\"\n-#include \"hashtab.h\"\n \n /* If IN_GLIBCPP_V3 is defined, some functions are made static.  We\n    also rename them via #define to avoid compiler errors when the\n@@ -303,10 +302,6 @@ struct d_print_info\n   int pack_index;\n   /* Number of d_print_flush calls so far.  */\n   unsigned long int flush_count;\n-  /* Table mapping demangle components to scopes saved when first\n-     traversing those components.  These are used while evaluating\n-     substitutions.  */\n-  htab_t saved_scopes;\n };\n \n #ifdef CP_DEMANGLE_DEBUG\n@@ -3670,17 +3665,6 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n   dpi->opaque = opaque;\n \n   dpi->demangle_failure = 0;\n-\n-  dpi->saved_scopes = NULL;\n-}\n-\n-/* Free a print information structure.  */\n-\n-static void\n-d_print_free (struct d_print_info *dpi)\n-{\n-  if (dpi->saved_scopes != NULL)\n-    htab_delete (dpi->saved_scopes);\n }\n \n /* Indicate that an error occurred during printing, and test for error.  */\n@@ -3765,17 +3749,14 @@ cplus_demangle_print_callback (int options,\n                                demangle_callbackref callback, void *opaque)\n {\n   struct d_print_info dpi;\n-  int success;\n \n   d_print_init (&dpi, callback, opaque);\n \n   d_print_comp (&dpi, options, dc);\n \n   d_print_flush (&dpi);\n \n-  success = ! d_print_saw_error (&dpi);\n-  d_print_free (&dpi);\n-  return success;\n+  return ! d_print_saw_error (&dpi);\n }\n \n /* Turn components into a human readable string.  OPTIONS is the\n@@ -3932,114 +3913,6 @@ d_print_subexpr (struct d_print_info *dpi, int options,\n     d_append_char (dpi, ')');\n }\n \n-/* A demangle component and some scope captured when it was first\n-   traversed.  */\n-\n-struct d_saved_scope\n-{\n-  /* The component whose scope this is.  Used as the key for the\n-     saved_scopes hashtable in d_print_info.  May be NULL if this\n-     scope will not be inserted into that table.  */\n-  const struct demangle_component *container;\n-  /* Nonzero if the below items are copies and require freeing\n-     when this scope is freed.  */\n-  int is_copy;\n-  /* The list of templates, if any, that was current when this\n-     scope was captured.  */\n-  struct d_print_template *templates;\n-};\n-\n-/* Allocate a scope and populate it with the current values from DPI.\n-   CONTAINER is the demangle component to which the scope refers, and\n-   is used as the key for the saved_scopes hashtable in d_print_info.\n-   CONTAINER may be NULL if this scope will not be inserted into that\n-   table.  If COPY is nonzero then items that may have been allocated\n-   on the stack will be copied before storing.  */\n-\n-static struct d_saved_scope *\n-d_store_scope (const struct d_print_info *dpi,\n-\t       const struct demangle_component *container, int copy)\n-{\n-  struct d_saved_scope *scope = XNEW (struct d_saved_scope);\n-\n-  scope->container = container;\n-  scope->is_copy = copy;\n-\n-  if (copy)\n-    {\n-      struct d_print_template *ts, **tl = &scope->templates;\n-\n-      for (ts = dpi->templates; ts != NULL; ts = ts->next)\n-\t{\n-\t  struct d_print_template *td = XNEW (struct d_print_template);\n-\n-\t  *tl = td;\n-\t  tl = &td->next;\n-\t  td->template_decl = ts->template_decl;\n-\t}\n-      *tl = NULL;\n-    }\n-  else\n-    scope->templates = dpi->templates;\n-\n-  return scope;\n-}\n-\n-/* Free a scope allocated by d_store_scope.  */\n-\n-static void\n-d_free_scope (void *p)\n-{\n-  struct d_saved_scope *scope = (struct d_saved_scope *) p;\n-\n-  if (scope->is_copy)\n-    {\n-      struct d_print_template *ts, *tn;\n-\n-      for (ts = scope->templates; ts != NULL; ts = tn)\n-\t{\n-\t  tn = ts->next;\n-\t  free (ts);\n-\t}\n-    }\n-\n-  free (scope);\n-}\n-\n-/* Restore a stored scope to DPI, optionally freeing it afterwards.  */\n-\n-static void\n-d_restore_scope (struct d_print_info *dpi, struct d_saved_scope *scope,\n-\t\t int free_after)\n-{\n-  dpi->templates = scope->templates;\n-\n-  if (free_after)\n-    d_free_scope (scope);\n-}\n-\n-/* Returns a hash code for the saved scope referenced by p.  */\n-\n-static hashval_t\n-d_hash_saved_scope (const void *p)\n-{\n-  const struct d_saved_scope *s = (const struct d_saved_scope *) p;\n-\n-  return htab_hash_pointer (s->container);\n-}\n-\n-/* Returns non-zero if the saved scopes referenced by p1 and p2\n-   are equal.  */\n-\n-static int\n-d_equal_saved_scope (const void *p1, const void *p2)\n-{\n-  const struct d_saved_scope *s1 = (const struct d_saved_scope *) p1;\n-  const struct d_saved_scope *s2 = (const struct d_saved_scope *) p2;\n-\n-  return s1->container == s2->container;\n-}\n-\n /* Subroutine to handle components.  */\n \n static void\n@@ -4050,10 +3923,6 @@ d_print_comp (struct d_print_info *dpi, int options,\n      without needing to modify *dc.  */\n   const struct demangle_component *mod_inner = NULL;\n \n-  /* Variable used to store the current scope while a previously\n-     captured scope is used.  */\n-  struct d_saved_scope *saved_scope = NULL;\n-\n   if (dc == NULL)\n     {\n       d_print_error (dpi);\n@@ -4422,43 +4291,12 @@ d_print_comp (struct d_print_info *dpi, int options,\n \tconst struct demangle_component *sub = d_left (dc);\n \tif (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n \t  {\n-\t    struct demangle_component *a;\n-\t    struct d_saved_scope lookup;\n-\t    void **slot;\n-\n-\t    if (dpi->saved_scopes == NULL)\n-\t      dpi->saved_scopes = htab_create_alloc (1,\n-\t\t\t\t\t\t     d_hash_saved_scope,\n-\t\t\t\t\t\t     d_equal_saved_scope,\n-\t\t\t\t\t\t     d_free_scope,\n-\t\t\t\t\t\t     xcalloc, free);\n-\n-\t    lookup.container = sub;\n-\t    slot = htab_find_slot (dpi->saved_scopes, &lookup, INSERT);\n-\t    if (*slot == HTAB_EMPTY_ENTRY)\n-\t      {\n-\t\t/* This is the first time SUB has been traversed.\n-\t\t   We need to capture some scope so it can be\n-\t\t   restored if SUB is reentered as a substitution.  */\n-\t\t*slot = d_store_scope (dpi, sub, 1);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* This traversal is reentering SUB as a substition.\n-\t\t   Restore the original scope temporarily.  */\n-\t\tsaved_scope = d_store_scope (dpi, NULL, 0);\n-\t\td_restore_scope (dpi, (struct d_saved_scope *) *slot, 0);\n-\t      }\n-\n-\t    a = d_lookup_template_argument (dpi, sub);\n+\t    struct demangle_component *a = d_lookup_template_argument (dpi, sub);\n \t    if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n \t      a = d_index_template_argument (a, dpi->pack_index);\n \n \t    if (a == NULL)\n \t      {\n-\t\tif (saved_scope != NULL)\n-\t\t  d_restore_scope (dpi, saved_scope, 1);\n-\n \t\td_print_error (dpi);\n \t\treturn;\n \t      }\n@@ -4506,9 +4344,6 @@ d_print_comp (struct d_print_info *dpi, int options,\n \n \tdpi->modifiers = dpm.next;\n \n-\tif (saved_scope != NULL)\n-\t  d_restore_scope (dpi, saved_scope, 1);\n-\n \treturn;\n       }\n "}, {"sha": "1259e4a9f495fe2dcff1cda674ed6cc8270fa577", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b415b271e9a1be0634b2c9ec4114fea7f32ceb8/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=8b415b271e9a1be0634b2c9ec4114fea7f32ceb8", "patch": "@@ -4291,6 +4291,3 @@ void m<void () &&>(void (A::*)() &&)\n --format=gnu-v3\n _Z1nIM1AKFvvREEvT_\n void n<void (A::*)() const &>(void (A::*)() const &)\n---format=gnu-v3\n-_ZSt7forwardIRN1x14refobjiteratorINS0_3refINS0_4mime30multipart_section_processorObjIZ15get_body_parserIZZN14mime_processor21make_section_iteratorERKNS2_INS3_10sectionObjENS0_10ptrrefBaseEEEbENKUlvE_clEvEUlSB_bE_ZZNS6_21make_section_iteratorESB_bENKSC_clEvEUlSB_E0_ENS1_INS2_INS0_20outputrefiteratorObjIiEES8_EEEERKSsSB_OT_OT0_EUlmE_NS3_32make_multipart_default_discarderISP_EEEES8_EEEEEOT_RNSt16remove_referenceISW_E4typeE\n-x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >& std::forward<x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >&>(std::remove_reference<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> > >::type&)"}]}