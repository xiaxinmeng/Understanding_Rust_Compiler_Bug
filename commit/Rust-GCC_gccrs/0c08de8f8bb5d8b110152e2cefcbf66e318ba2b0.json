{"sha": "0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMwOGRlOGY4YmI1ZDhiMTEwMTUyZTJjZWZjYmY2NmUzMThiYTJiMA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:31:19Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:31:19Z"}, "message": "re PR fortran/43829 (Scalarization of reductions)\n\n\tPR fortran/43829\n\t* trans-array.c (gfc_conv_expr_descriptor): Accept the inline intrinsic\n\tcase in the assertion.\n\t* trans-intrinsic (enter_nested_loop): New function.\n\t(gfc_conv_intrinsic_arith): Support non-scalar cases.\n\t(nest_loop_dimension, walk_inline_intrinsic_arith): New functions.\n\t(walk_inline_intrinsic_function): Handle sum and product.\n\t(gfc_inline_intrinsic_function_p): Ditto.\n\t* trans.h (gfc_get_loopinfo): New macro.\n\nFrom-SVN: r180920", "tree": {"sha": "7ac5a93345f05859b44e7b6e108725ac0433cba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ac5a93345f05859b44e7b6e108725ac0433cba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/comments", "author": null, "committer": null, "parents": [{"sha": "44d23d9e74ffcb55fb87ffa0a1c9a36a5308d3d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d23d9e74ffcb55fb87ffa0a1c9a36a5308d3d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d23d9e74ffcb55fb87ffa0a1c9a36a5308d3d3"}], "stats": {"total": 251, "additions": 217, "deletions": 34}, "files": [{"sha": "5b1d41071e9e213c32976c184aa52438ee2fe8bf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "patch": "@@ -1,3 +1,15 @@\n+2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/43829\n+\t* trans-array.c (gfc_conv_expr_descriptor): Accept the inline intrinsic\n+\tcase in the assertion.\n+\t* trans-intrinsic (enter_nested_loop): New function.\n+\t(gfc_conv_intrinsic_arith): Support non-scalar cases.\n+\t(nest_loop_dimension, walk_inline_intrinsic_arith): New functions.\n+\t(walk_inline_intrinsic_function): Handle sum and product.\n+\t(gfc_inline_intrinsic_function_p): Ditto.\n+\t* trans.h (gfc_get_loopinfo): New macro.\n+\n 2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-intrinsic.c (gfc_conv_intrinsic_arith): Introduce parent"}, {"sha": "262743d0d3779b4f02a63d604bd9a621401ae84e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "patch": "@@ -6187,7 +6187,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    gcc_assert ((expr->value.function.esym != NULL\n \t\t\t && expr->value.function.esym->attr.elemental)\n \t\t\t|| (expr->value.function.isym != NULL\n-\t\t\t    && expr->value.function.isym->elemental));\n+\t\t\t    && expr->value.function.isym->elemental)\n+\t\t\t|| gfc_inline_intrinsic_function_p (expr));\n \t  else\n \t    gcc_assert (ss_type == GFC_SS_INTRINSIC);\n "}, {"sha": "4244570a7e9645d1d0becb661cf58e49b0f7d6ba", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 202, "deletions": 33, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "patch": "@@ -2557,6 +2557,20 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   se->expr = resvar;\n }\n \n+\n+/* Update given gfc_se to have ss component pointing to the nested gfc_ss\n+   struct and return the corresponding loopinfo.  */\n+\n+static gfc_loopinfo *\n+enter_nested_loop (gfc_se *se)\n+{\n+  se->ss = se->ss->nested_ss;\n+  gcc_assert (se->ss == se->ss->loop->ss);\n+\n+  return se->ss->loop;\n+}\n+\n+\n /* Inline implementation of the sum and product intrinsics.  */\n static void\n gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n@@ -2570,18 +2584,18 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n   tree tmp;\n   gfc_loopinfo loop, *ploop;\n   gfc_actual_arglist *arg_array, *arg_mask;\n-  gfc_ss *arrayss;\n-  gfc_ss *maskss;\n+  gfc_ss *arrayss = NULL;\n+  gfc_ss *maskss = NULL;\n   gfc_se arrayse;\n   gfc_se maskse;\n   gfc_se *parent_se;\n   gfc_expr *arrayexpr;\n   gfc_expr *maskexpr;\n \n-  if (se->ss)\n+  if (expr->rank > 0)\n     {\n-      gfc_conv_intrinsic_funcall (se, expr);\n-      return;\n+      gcc_assert (gfc_inline_intrinsic_function_p (expr));\n+      parent_se = se;\n     }\n   else\n     parent_se = NULL;\n@@ -2613,10 +2627,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n \n   arg_array = expr->value.function.actual;\n \n-  /* Walk the arguments.  */\n   arrayexpr = arg_array->expr;\n-  arrayss = gfc_walk_expr (arrayexpr);\n-  gcc_assert (arrayss != gfc_ss_terminator);\n \n   if (op == NE_EXPR || norm2)\n     /* PARITY and NORM2.  */\n@@ -2628,29 +2639,42 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n       maskexpr = arg_mask->expr;\n     }\n \n-  if (maskexpr && maskexpr->rank > 0)\n+  if (expr->rank == 0)\n     {\n-      maskss = gfc_walk_expr (maskexpr);\n-      gcc_assert (maskss != gfc_ss_terminator);\n-    }\n-  else\n-    maskss = NULL;\n+      /* Walk the arguments.  */\n+      arrayss = gfc_walk_expr (arrayexpr);\n+      gcc_assert (arrayss != gfc_ss_terminator);\n \n-  /* Initialize the scalarizer.  */\n-  gfc_init_loopinfo (&loop);\n-  gfc_add_ss_to_loop (&loop, arrayss);\n-  if (maskexpr && maskexpr->rank > 0)\n-    gfc_add_ss_to_loop (&loop, maskss);\n+      if (maskexpr && maskexpr->rank > 0)\n+\t{\n+\t  maskss = gfc_walk_expr (maskexpr);\n+\t  gcc_assert (maskss != gfc_ss_terminator);\n+\t}\n+      else\n+\tmaskss = NULL;\n \n-  /* Initialize the loop.  */\n-  gfc_conv_ss_startstride (&loop);\n-  gfc_conv_loop_setup (&loop, &expr->where);\n+      /* Initialize the scalarizer.  */\n+      gfc_init_loopinfo (&loop);\n+      gfc_add_ss_to_loop (&loop, arrayss);\n+      if (maskexpr && maskexpr->rank > 0)\n+\tgfc_add_ss_to_loop (&loop, maskss);\n \n-  gfc_mark_ss_chain_used (arrayss, 1);\n-  if (maskexpr && maskexpr->rank > 0)\n-    gfc_mark_ss_chain_used (maskss, 1);\n+      /* Initialize the loop.  */\n+      gfc_conv_ss_startstride (&loop);\n+      gfc_conv_loop_setup (&loop, &expr->where);\n+\n+      gfc_mark_ss_chain_used (arrayss, 1);\n+      if (maskexpr && maskexpr->rank > 0)\n+\tgfc_mark_ss_chain_used (maskss, 1);\n+\n+      ploop = &loop;\n+    }\n+  else\n+    /* All the work has been done in the parent loops.  */\n+    ploop = enter_nested_loop (se);\n+\n+  gcc_assert (ploop);\n \n-  ploop = &loop;\n   /* Generate the loop body.  */\n   gfc_start_scalarized_body (ploop, &body);\n \n@@ -2659,7 +2683,8 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n     {\n       gfc_init_se (&maskse, parent_se);\n       gfc_copy_loopinfo_to_se (&maskse, ploop);\n-      maskse.ss = maskss;\n+      if (expr->rank == 0)\n+\tmaskse.ss = maskss;\n       gfc_conv_expr_val (&maskse, maskexpr);\n       gfc_add_block_to_block (&body, &maskse.pre);\n \n@@ -2671,7 +2696,8 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n   /* Do the actual summation/product.  */\n   gfc_init_se (&arrayse, parent_se);\n   gfc_copy_loopinfo_to_se (&arrayse, ploop);\n-  arrayse.ss = arrayss;\n+  if (expr->rank == 0)\n+    arrayse.ss = arrayss;\n   gfc_conv_expr_val (&arrayse, arrayexpr);\n   gfc_add_block_to_block (&block, &arrayse.pre);\n \n@@ -2763,25 +2789,38 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n   /* For a scalar mask, enclose the loop in an if statement.  */\n   if (maskexpr && maskexpr->rank == 0)\n     {\n-      gfc_init_se (&maskse, NULL);\n-      gfc_conv_expr_val (&maskse, maskexpr);\n       gfc_init_block (&block);\n       gfc_add_block_to_block (&block, &ploop->pre);\n       gfc_add_block_to_block (&block, &ploop->post);\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n-\t\t      build_empty_stmt (input_location));\n+      if (expr->rank > 0)\n+\t{\n+\t  tmp = build3_v (COND_EXPR, se->ss->info->data.scalar.value, tmp,\n+\t\t\t  build_empty_stmt (input_location));\n+\t  gfc_advance_se_ss_chain (se);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (expr->rank == 0);\n+\t  gfc_init_se (&maskse, NULL);\n+\t  gfc_conv_expr_val (&maskse, maskexpr);\n+\t  tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t\t  build_empty_stmt (input_location));\n+\t}\n+\n       gfc_add_expr_to_block (&block, tmp);\n       gfc_add_block_to_block (&se->pre, &block);\n+      gcc_assert (se->post.head == NULL);\n     }\n   else\n     {\n       gfc_add_block_to_block (&se->pre, &ploop->pre);\n       gfc_add_block_to_block (&se->pre, &ploop->post);\n     }\n \n-  gfc_cleanup_loop (ploop);\n+  if (expr->rank == 0)\n+    gfc_cleanup_loop (ploop);\n \n   if (norm2)\n     {\n@@ -6801,12 +6840,127 @@ walk_inline_intrinsic_transpose (gfc_ss *ss, gfc_expr *expr)\n }\n \n \n+/* Move the given dimension of the given gfc_ss list to a nested gfc_ss list.\n+   This has the side effect of reversing the nested list, so there is no\n+   need to call gfc_reverse_ss on it (the given list is assumed not to be\n+   reversed yet).   */\n+\n+static gfc_ss *\n+nest_loop_dimension (gfc_ss *ss, int dim)\n+{\n+  int ss_dim, i;\n+  gfc_ss *new_ss, *prev_ss = gfc_ss_terminator;\n+  gfc_loopinfo *new_loop;\n+\n+  gcc_assert (ss != gfc_ss_terminator);\n+\n+  for (; ss != gfc_ss_terminator; ss = ss->next)\n+    {\n+      new_ss = gfc_get_ss ();\n+      new_ss->next = prev_ss;\n+      new_ss->parent = ss;\n+      new_ss->info = ss->info;\n+      new_ss->info->refcount++;\n+      if (ss->dimen != 0)\n+\t{\n+\t  gcc_assert (ss->info->type != GFC_SS_SCALAR\n+\t\t      && ss->info->type != GFC_SS_REFERENCE);\n+\n+\t  new_ss->dimen = 1;\n+\t  new_ss->dim[0] = ss->dim[dim];\n+\n+\t  gcc_assert (dim < ss->dimen);\n+\n+\t  ss_dim = --ss->dimen;\n+\t  for (i = dim; i < ss_dim; i++)\n+\t    ss->dim[i] = ss->dim[i + 1];\n+\n+\t  ss->dim[ss_dim] = 0;\n+\t}\n+      prev_ss = new_ss;\n+\n+      if (ss->nested_ss)\n+\t{\n+\t  ss->nested_ss->parent = new_ss;\n+\t  new_ss->nested_ss = ss->nested_ss;\n+\t}\n+      ss->nested_ss = new_ss;\n+    }\n+\n+  new_loop = gfc_get_loopinfo ();\n+  gfc_init_loopinfo (new_loop);\n+\n+  gcc_assert (prev_ss != NULL);\n+  gcc_assert (prev_ss != gfc_ss_terminator);\n+  gfc_add_ss_to_loop (new_loop, prev_ss);\n+  return new_ss->parent;\n+}\n+\n+\n+/* Create the gfc_ss list for the SUM/PRODUCT arguments when the function\n+   is to be inlined.  */\n+\n+static gfc_ss *\n+walk_inline_intrinsic_arith (gfc_ss *ss, gfc_expr *expr)\n+{\n+  gfc_ss *tmp_ss, *tail, *array_ss;\n+  gfc_actual_arglist *arg1, *arg2, *arg3;\n+  int sum_dim;\n+  bool scalar_mask = false;\n+\n+  /* The rank of the result will be determined later.  */\n+  arg1 = expr->value.function.actual;\n+  arg2 = arg1->next;\n+  arg3 = arg2->next;\n+  gcc_assert (arg3 != NULL);\n+\n+  if (expr->rank == 0)\n+    return ss;\n+\n+  tmp_ss = gfc_ss_terminator;\n+\n+  if (arg3->expr)\n+    {\n+      gfc_ss *mask_ss;\n+\n+      mask_ss = gfc_walk_subexpr (tmp_ss, arg3->expr);\n+      if (mask_ss == tmp_ss)\n+\tscalar_mask = 1;\n+\n+      tmp_ss = mask_ss;\n+    }\n+\n+  array_ss = gfc_walk_subexpr (tmp_ss, arg1->expr);\n+  gcc_assert (array_ss != tmp_ss);\n+\n+  /* Odd thing: If the mask is scalar, it is used by the frontend after\n+     the array (to make an if around the nested loop). Thus it shall\n+     be after array_ss once the gfc_ss list is reversed.  */\n+  if (scalar_mask)\n+    tmp_ss = gfc_get_scalar_ss (array_ss, arg3->expr);\n+  else\n+    tmp_ss = array_ss;\n+\n+  /* \"Hide\" the dimension on which we will sum in the first arg's scalarization\n+     chain.  */\n+  sum_dim = mpz_get_si (arg2->expr->value.integer) - 1;\n+  tail = nest_loop_dimension (tmp_ss, sum_dim);\n+  tail->next = ss;\n+\n+  return tmp_ss;\n+}\n+\n+\n static gfc_ss *\n walk_inline_intrinsic_function (gfc_ss * ss, gfc_expr * expr)\n {\n \n   switch (expr->value.function.isym->id)\n     {\n+      case GFC_ISYM_PRODUCT:\n+      case GFC_ISYM_SUM:\n+\treturn walk_inline_intrinsic_arith (ss, expr);\n+\n       case GFC_ISYM_TRANSPOSE:\n \treturn walk_inline_intrinsic_transpose (ss, expr);\n \n@@ -6868,11 +7022,26 @@ gfc_walk_intrinsic_libfunc (gfc_ss * ss, gfc_expr * expr)\n bool\n gfc_inline_intrinsic_function_p (gfc_expr *expr)\n {\n+  gfc_actual_arglist *args;\n+\n   if (!expr->value.function.isym)\n     return false;\n \n   switch (expr->value.function.isym->id)\n     {\n+    case GFC_ISYM_PRODUCT:\n+    case GFC_ISYM_SUM:\n+      /* Disable inline expansion if code size matters.  */\n+      if (optimize_size)\n+\treturn false;\n+\n+      args = expr->value.function.actual;\n+      /* We need to be able to subset the SUM argument at compile-time.  */\n+      if (args->next->expr && args->next->expr->expr_type != EXPR_CONSTANT)\n+\treturn false;\n+\n+      return true;\n+\n     case GFC_ISYM_TRANSPOSE:\n       return true;\n "}, {"sha": "22033d38d157f5c85eba6fcb8ee92ab28dc22535", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0c08de8f8bb5d8b110152e2cefcbf66e318ba2b0", "patch": "@@ -310,6 +310,7 @@ typedef struct gfc_loopinfo\n }\n gfc_loopinfo;\n \n+#define gfc_get_loopinfo() XCNEW (gfc_loopinfo)\n \n /* Information about a symbol that has been shadowed by a temporary.  */\n typedef struct"}]}