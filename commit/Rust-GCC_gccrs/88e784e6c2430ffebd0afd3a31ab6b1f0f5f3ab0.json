{"sha": "88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlNzg0ZTZjMjQzMGZmZWJkMGFmZDNhMzFhYjZiMWYwZjVmM2FiMA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-01-16T07:10:21Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-01-16T07:10:21Z"}, "message": "emit-rtl.c (need_atomic_barrier_p): Mask memory model argument with MEMMODEL_MASK before comparing with MEMMODEL_*...\n\n\t* emit-rtl.c (need_atomic_barrier_p): Mask memory model argument\n\twith MEMMODEL_MASK before comparing with MEMMODEL_* memory types.\n\t* optabs.c (maybe_emit_sync_lock_test_and_set): Ditto.\n\t(expand_mem_thread_fence): Ditto.\n\t(expand_mem_signal_fence): Ditto.\n\t(expand_atomic_load): Ditto.\n\t(expand_atomic_store): Ditto.\n\nFrom-SVN: r195228", "tree": {"sha": "9477e573e8737008d7fa38034cbb5298d49d4610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9477e573e8737008d7fa38034cbb5298d49d4610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0/comments", "author": null, "committer": null, "parents": [{"sha": "5147bf6a236993578d316dfe7c7e7182da1cdf90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5147bf6a236993578d316dfe7c7e7182da1cdf90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5147bf6a236993578d316dfe7c7e7182da1cdf90"}], "stats": {"total": 32, "additions": 21, "deletions": 11}, "files": [{"sha": "1f66518ee45cdf3db9d8d92611a6c5c382a26a09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0", "patch": "@@ -1,3 +1,13 @@\n+2013-01-15  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* emit-rtl.c (need_atomic_barrier_p): Mask memory model argument\n+\twith MEMMODEL_MASK before comparing with MEMMODEL_* memory types.\n+\t* optabs.c (maybe_emit_sync_lock_test_and_set): Ditto.\n+\t(expand_mem_thread_fence): Ditto.\n+\t(expand_mem_signal_fence): Ditto.\n+\t(expand_atomic_load): Ditto.\n+\t(expand_atomic_store): Ditto.\n+\n 2013-01-16  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR rtl-optimization/55547\n@@ -120,8 +130,8 @@\n \n 2013-01-14  Tejas Belagod  <tejas.belagod@arm.com>\n \n-\t* config/aarch64/aarch64-simd.md (*aarch64_simd_ld1r<mode>): New. \n-\t* config/aarch64/iterators.md (VALLDI): New. \n+\t* config/aarch64/aarch64-simd.md (*aarch64_simd_ld1r<mode>): New.\n+\t* config/aarch64/iterators.md (VALLDI): New.\n \n 2012-01-14  Uros Bizjak  <ubizjak@gmail.com>\n \t    Andi Kleen  <ak@linux.intel.com>"}, {"sha": "f997e5d319bcd6051cf6e2fc9daa2ce8582193de", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0", "patch": "@@ -6019,7 +6019,7 @@ insn_file (const_rtx insn)\n bool\n need_atomic_barrier_p (enum memmodel model, bool pre)\n {\n-  switch (model)\n+  switch (model & MEMMODEL_MASK)\n     {\n     case MEMMODEL_RELAXED:\n     case MEMMODEL_CONSUME:"}, {"sha": "8a3d3a921abb49ec9aa839006eb5c556f309f7ed", "filename": "gcc/optabs.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=88e784e6c2430ffebd0afd3a31ab6b1f0f5f3ab0", "patch": "@@ -7008,9 +7008,9 @@ maybe_emit_sync_lock_test_and_set (rtx target, rtx mem, rtx val,\n      exists, and the memory model is stronger than acquire, add a release \n      barrier before the instruction.  */\n \n-  if (model == MEMMODEL_SEQ_CST\n-      || model == MEMMODEL_RELEASE\n-      || model == MEMMODEL_ACQ_REL)\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST\n+      || (model & MEMMODEL_MASK) == MEMMODEL_RELEASE\n+      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n     expand_mem_thread_fence (model);\n \n   if (icode != CODE_FOR_nothing)\n@@ -7388,7 +7388,7 @@ expand_mem_thread_fence (enum memmodel model)\n {\n   if (HAVE_mem_thread_fence)\n     emit_insn (gen_mem_thread_fence (GEN_INT (model)));\n-  else if (model != MEMMODEL_RELAXED)\n+  else if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED)\n     {\n       if (HAVE_memory_barrier)\n \temit_insn (gen_memory_barrier ());\n@@ -7412,7 +7412,7 @@ expand_mem_signal_fence (enum memmodel model)\n {\n   if (HAVE_mem_signal_fence)\n     emit_insn (gen_mem_signal_fence (GEN_INT (model)));\n-  else if (model != MEMMODEL_RELAXED)\n+  else if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED)\n     {\n       /* By default targets are coherent between a thread and the signal\n \t handler running on the same thread.  Thus this really becomes a\n@@ -7467,7 +7467,7 @@ expand_atomic_load (rtx target, rtx mem, enum memmodel model)\n     target = gen_reg_rtx (mode);\n \n   /* For SEQ_CST, emit a barrier before the load.  */\n-  if (model == MEMMODEL_SEQ_CST)\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n     expand_mem_thread_fence (model);\n \n   emit_move_insn (target, mem);\n@@ -7513,7 +7513,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n \t  if (maybe_expand_insn (icode, 2, ops))\n \t    {\n \t      /* lock_release is only a release barrier.  */\n-\t      if (model == MEMMODEL_SEQ_CST)\n+\t      if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n \t\texpand_mem_thread_fence (model);\n \t      return const0_rtx;\n \t    }\n@@ -7540,7 +7540,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n   emit_move_insn (mem, val);\n \n   /* For SEQ_CST, also emit a barrier after the store.  */\n-  if (model == MEMMODEL_SEQ_CST)\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n     expand_mem_thread_fence (model);\n \n   return const0_rtx;"}]}