{"sha": "f62511da91a80f2737bafb9ff984e88065a68ce2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyNTExZGE5MWE4MGYyNzM3YmFmYjlmZjk4NGU4ODA2NWE2OGNlMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-05-22T20:14:29Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-05-22T20:14:29Z"}, "message": "extend.texi (PowerPC AltiVec/VSX Built-in Functions): Add documentation for the power8 crypto builtins.\n\n[gcc]\n2013-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Pat Haugen <pthaugen@us.ibm.com>\n\t    Peter Bergner <bergner@vnet.ibm.com>\n\n\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions): Add\n\tdocumentation for the power8 crypto builtins.\n\n\t* config/rs6000/t-rs6000 (MD_INCLUDES): Add crypto.md.\n\n\t* config/rs6000/rs6000-builtin.def (BU_P8V_AV_1): Add support\n\tmacros for defining power8 builtin functions.\n\t(BU_P8V_AV_2): Likewise.\n\t(BU_P8V_AV_P): Likewise.\n\t(BU_P8V_VSX_1): Likewise.\n\t(BU_P8V_OVERLOAD_1): Likewise.\n\t(BU_P8V_OVERLOAD_2): Likewise.\n\t(BU_CRYPTO_1): Likewise.\n\t(BU_CRYPTO_2): Likewise.\n\t(BU_CRYPTO_3): Likewise.\n\t(BU_CRYPTO_OVERLOAD_1): Likewise.\n\t(BU_CRYPTO_OVERLOAD_2): Likewise.\n\t(XSCVSPDP): Fix typo, point to the correct instruction.\n\t(VCIPHER): Add power8 crypto builtins.\n\t(VCIPHERLAST): Likewise.\n\t(VNCIPHER): Likewise.\n\t(VNCIPHERLAST): Likewise.\n\t(VPMSUMB): Likewise.\n\t(VPMSUMH): Likewise.\n\t(VPMSUMW): Likewise.\n\t(VPERMXOR_V2DI): Likewise.\n\t(VPERMXOR_V4SI: Likewise.\n\t(VPERMXOR_V8HI: Likewise.\n\t(VPERMXOR_V16QI: Likewise.\n\t(VSHASIGMAW): Likewise.\n\t(VSHASIGMAD): Likewise.\n\t(VPMSUM): Likewise.\n\t(VPERMXOR): Likewise.\n\t(VSHASIGMA): Likewise.\n\n\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Define\n\t__CRYPTO__ if the crypto instructions are available.\n\t(altivec_overloaded_builtins): Add support for overloaded power8\n\tbuiltins.\n\n\t* config/rs6000/rs6000.c (rs6000_expand_ternop_builtin): Add\n\tsupport for power8 crypto builtins.\n\t(builtin_function_type): Likewise.\n\t(altivec_init_builtins): Add support for builtins that take vector\n\tlong long (V2DI) arguments.\n\n\t* config/rs6000/crypto.md: New file, define power8 crypto\n\tinstructions.\n\n2013-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Pat Haugen <pthaugen@us.ibm.com>\n\t    Peter Bergner <bergner@vnet.ibm.com>\n\n\t* doc/invoke.texi (Option Summary): Add power8 options.\n\t(RS/6000 and PowerPC Options): Likewise.\n\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Update to use\n\tconstraints.md instead of rs6000.h.  Reorder w* constraints.  Add\n\twm, wn, wr documentation.\n\n\t* gcc/config/rs6000/constraints.md (wm): New constraint for VSX\n\tregisters if direct move instructions are enabled.\n\t(wn): New constraint for no registers.\n\t(wq): New constraint for quad word even GPR registers.\n\t(wr): New constraint if 64-bit instructions are enabled.\n\t(wv): New constraint if power8 vector instructions are enabled.\n\t(wQ): New constraint for quad word memory locations.\n\n\t* gcc/config/rs6000/predicates.md (const_0_to_15_operand): New\n\tconstraint for 0..15 for crypto instructions.\n\t(gpc_reg_operand): If VSX allow registers in VSX registers as well\n\tas GPR and floating point registers.\n\t(int_reg_operand): New predicate to match only GPR registers.\n\t(base_reg_operand): New predicate to match base registers.\n\t(quad_int_reg_operand): New predicate to match even GPR registers\n\tfor quad memory operations.\n\t(vsx_reg_or_cint_operand): New predicate to allow vector logical\n\toperations in both GPR and VSX registers.\n\t(quad_memory_operand): New predicate for quad memory operations.\n\t(reg_or_indexed_operand): New predicate for direct move support.\n\n\t* gcc/config/rs6000/rs6000-cpus.def (ISA_2_5_MASKS_EMBEDDED):\n\tInherit from ISA_2_4_MASKS, not ISA_2_2_MASKS.\n\t(ISA_2_7_MASKS_SERVER): New mask for ISA 2.07 (i.e. power8).\n\t(POWERPC_MASKS): Add power8 options.\n\t(power8 cpu): Use ISA_2_7_MASKS_SERVER instead of specifying the\n\tvarious options.\n\n\t* gcc/config/rs6000/rs6000-c.c (rs6000_target_modify_macros):\n\tDefine _ARCH_PWR8 and __POWER8_VECTOR__ for power8.\n\n\t* gcc/config/rs6000/rs6000.opt (-mvsx-timode): Add documentation.\n\t(-mpower8-fusion): New power8 options.\n\t(-mpower8-fusion-sign): Likewise.\n\t(-mpower8-vector): Likewise.\n\t(-mcrypto): Likewise.\n\t(-mdirect-move): Likewise.\n\t(-mquad-memory): Likewise.\n\n\t* gcc/config/rs6000/rs6000.c (power8_cost): Initial definition for\n\tpower8.\n\t(rs6000_hard_regno_mode_ok): Make PTImode only match even GPR\n\tregisters.\n\t(rs6000_debug_reg_print): Print the base register class if\n\t-mdebug=reg.\n\t(rs6000_debug_vector_unit): Add p8_vector.\n\t(rs6000_debug_reg_global): If -mdebug=reg, print power8 constraint\n\tdefinitions.  Also print fusion state.\n\t(rs6000_init_hard_regno_mode_ok): Set up power8 constraints.\n\t(rs6000_builtin_mask_calculate): Add power8 builtin support.\n\t(rs6000_option_override_internal): Add support for power8.\n\t(rs6000_common_init_builtins): Add debugging for skipped builtins\n\tif -mdebug=builtin.\n\t(rs6000_adjust_cost): Add power8 support.\n\t(rs6000_issue_rate): Likewise.\n\t(insn_must_be_first_in_group): Likewise.\n\t(insn_must_be_last_in_group): Likewise.\n\t(force_new_group): Likewise.\n\t(rs6000_register_move_cost): Likewise.\n\t(rs6000_opt_masks): Likewise.\n\n\t* config/rs6000/rs6000.h (ASM_CPU_POWER8_SPEC): If we don't have a\n\tpower8 capable assembler, default to power7 options.\n\t(TARGET_DIRECT_MOVE): Likewise.\n\t(TARGET_CRYPTO): Likewise.\n\t(TARGET_P8_VECTOR): Likewise.\n\t(VECTOR_UNIT_P8_VECTOR_P): Define power8 vector support.\n\t(VECTOR_UNIT_VSX_OR_P8_VECTOR_P): Likewise.\n\t(VECTOR_MEM_P8_VECTOR_P): Likewise.\n\t(VECTOR_MEM_VSX_OR_P8_VECTOR_P): Likewise.\n\t(VECTOR_MEM_ALTIVEC_OR_VSX_P): Likewise.\n\t(TARGET_XSCVDPSPN): Likewise.\n\t(TARGET_XSCVSPDPN): Likewsie.\n\t(TARGET_SYNC_HI_QI): Likewise.\n\t(TARGET_SYNC_TI): Likewise.\n\t(MASK_CRYPTO): Likewise.\n\t(MASK_DIRECT_MOVE): Likewise.\n\t(MASK_P8_FUSION): Likewise.\n\t(MASK_P8_VECTOR): Likewise.\n\t(REG_ALLOC_ORDER): Move fr13 to be lower in priority so that the\n\tTFmode temporary used by some of the direct move instructions to\n\tget two FP temporary registers does not force creation of a stack\n\tframe.\n\t(VLOGICAL_REGNO_P): Allow vector logical operations in GPRs.\n\t(MODES_TIEABLE_P): Move the VSX tests above the Altivec tests so\n\tthat any VSX registers are tieable, even if they are also an\n\tAltivec vector mode.\n\t(r6000_reg_class_enum): Add wm, wr, wv constraints.\n\t(RS6000_BTM_P8_VECTOR): Power8 builtin support.\n\t(RS6000_BTM_CRYPTO): Likewise.\n\t(RS6000_BTM_COMMON): Likewise.\n\n\t* config/rs6000/rs6000.md (cpu attribute): Add power8.\n\t* config/rs6000/rs6000-opts.h (PROCESSOR_POWER8): Likewise.\n\t(enum rs6000_vector): Add power8 vector support.\n\n[gcc/testsuite]\n2013-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Pat Haugen <pthaugen@us.ibm.com>\n\t    Peter Bergner <bergner@vnet.ibm.com>\n\n\t* gcc.target/powerpc/crypto-builtin-1.c: New file, test for power8\n\tcrypto builtins.\n\n\nCo-Authored-By: Pat Haugen <pthaugen@us.ibm.com>\nCo-Authored-By: Peter Bergner <bergner@vnet.ibm.com>\n\nFrom-SVN: r199217", "tree": {"sha": "1ac043384950f4c85ad7b5bcd3c4d312a13485cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac043384950f4c85ad7b5bcd3c4d312a13485cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f62511da91a80f2737bafb9ff984e88065a68ce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62511da91a80f2737bafb9ff984e88065a68ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62511da91a80f2737bafb9ff984e88065a68ce2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62511da91a80f2737bafb9ff984e88065a68ce2/comments", "author": null, "committer": null, "parents": [{"sha": "bbf38bcf2d9afa8d34e2fa8e2a2609fa47e13920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf38bcf2d9afa8d34e2fa8e2a2609fa47e13920", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf38bcf2d9afa8d34e2fa8e2a2609fa47e13920"}], "stats": {"total": 1163, "additions": 1109, "deletions": 54}, "files": [{"sha": "585ba03951a667fee1a457e26c6bc422bd845374", "filename": "gcc/ChangeLog", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -1,3 +1,163 @@\n+2013-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen <pthaugen@us.ibm.com>\n+\t    Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions): Add\n+\tdocumentation for the power8 crypto builtins.\n+\n+\t* config/rs6000/t-rs6000 (MD_INCLUDES): Add crypto.md.\n+\n+\t* config/rs6000/rs6000-builtin.def (BU_P8V_AV_1): Add support\n+\tmacros for defining power8 builtin functions.\n+\t(BU_P8V_AV_2): Likewise.\n+\t(BU_P8V_AV_P): Likewise.\n+\t(BU_P8V_VSX_1): Likewise.\n+\t(BU_P8V_OVERLOAD_1): Likewise.\n+\t(BU_P8V_OVERLOAD_2): Likewise.\n+\t(BU_CRYPTO_1): Likewise.\n+\t(BU_CRYPTO_2): Likewise.\n+\t(BU_CRYPTO_3): Likewise.\n+\t(BU_CRYPTO_OVERLOAD_1): Likewise.\n+\t(BU_CRYPTO_OVERLOAD_2): Likewise.\n+\t(XSCVSPDP): Fix typo, point to the correct instruction.\n+\t(VCIPHER): Add power8 crypto builtins.\n+\t(VCIPHERLAST): Likewise.\n+\t(VNCIPHER): Likewise.\n+\t(VNCIPHERLAST): Likewise.\n+\t(VPMSUMB): Likewise.\n+\t(VPMSUMH): Likewise.\n+\t(VPMSUMW): Likewise.\n+\t(VPERMXOR_V2DI): Likewise.\n+\t(VPERMXOR_V4SI: Likewise.\n+\t(VPERMXOR_V8HI: Likewise.\n+\t(VPERMXOR_V16QI: Likewise.\n+\t(VSHASIGMAW): Likewise.\n+\t(VSHASIGMAD): Likewise.\n+\t(VPMSUM): Likewise.\n+\t(VPERMXOR): Likewise.\n+\t(VSHASIGMA): Likewise.\n+\n+\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Define\n+\t__CRYPTO__ if the crypto instructions are available.\n+\t(altivec_overloaded_builtins): Add support for overloaded power8\n+\tbuiltins.\n+\n+\t* config/rs6000/rs6000.c (rs6000_expand_ternop_builtin): Add\n+\tsupport for power8 crypto builtins.\n+\t(builtin_function_type): Likewise.\n+\t(altivec_init_builtins): Add support for builtins that take vector\n+\tlong long (V2DI) arguments.\n+\n+\t* config/rs6000/crypto.md: New file, define power8 crypto\n+\tinstructions.\n+\n+2013-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen <pthaugen@us.ibm.com>\n+\t    Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* doc/invoke.texi (Option Summary): Add power8 options.\n+\t(RS/6000 and PowerPC Options): Likewise.\n+\n+\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Update to use\n+\tconstraints.md instead of rs6000.h.  Reorder w* constraints.  Add\n+\twm, wn, wr documentation.\n+\n+\t* gcc/config/rs6000/constraints.md (wm): New constraint for VSX\n+\tregisters if direct move instructions are enabled.\n+\t(wn): New constraint for no registers.\n+\t(wq): New constraint for quad word even GPR registers.\n+\t(wr): New constraint if 64-bit instructions are enabled.\n+\t(wv): New constraint if power8 vector instructions are enabled.\n+\t(wQ): New constraint for quad word memory locations.\n+\n+\t* gcc/config/rs6000/predicates.md (const_0_to_15_operand): New\n+\tconstraint for 0..15 for crypto instructions.\n+\t(gpc_reg_operand): If VSX allow registers in VSX registers as well\n+\tas GPR and floating point registers.\n+\t(int_reg_operand): New predicate to match only GPR registers.\n+\t(base_reg_operand): New predicate to match base registers.\n+\t(quad_int_reg_operand): New predicate to match even GPR registers\n+\tfor quad memory operations.\n+\t(vsx_reg_or_cint_operand): New predicate to allow vector logical\n+\toperations in both GPR and VSX registers.\n+\t(quad_memory_operand): New predicate for quad memory operations.\n+\t(reg_or_indexed_operand): New predicate for direct move support.\n+\n+\t* gcc/config/rs6000/rs6000-cpus.def (ISA_2_5_MASKS_EMBEDDED):\n+\tInherit from ISA_2_4_MASKS, not ISA_2_2_MASKS.\n+\t(ISA_2_7_MASKS_SERVER): New mask for ISA 2.07 (i.e. power8).\n+\t(POWERPC_MASKS): Add power8 options.\n+\t(power8 cpu): Use ISA_2_7_MASKS_SERVER instead of specifying the\n+\tvarious options.\n+\n+\t* gcc/config/rs6000/rs6000-c.c (rs6000_target_modify_macros):\n+\tDefine _ARCH_PWR8 and __POWER8_VECTOR__ for power8.\n+\n+\t* gcc/config/rs6000/rs6000.opt (-mvsx-timode): Add documentation.\n+\t(-mpower8-fusion): New power8 options.\n+\t(-mpower8-fusion-sign): Likewise.\n+\t(-mpower8-vector): Likewise.\n+\t(-mcrypto): Likewise.\n+\t(-mdirect-move): Likewise.\n+\t(-mquad-memory): Likewise.\n+\n+\t* gcc/config/rs6000/rs6000.c (power8_cost): Initial definition for\n+\tpower8.\n+\t(rs6000_hard_regno_mode_ok): Make PTImode only match even GPR\n+\tregisters.\n+\t(rs6000_debug_reg_print): Print the base register class if\n+\t-mdebug=reg.\n+\t(rs6000_debug_vector_unit): Add p8_vector.\n+\t(rs6000_debug_reg_global): If -mdebug=reg, print power8 constraint\n+\tdefinitions.  Also print fusion state.\n+\t(rs6000_init_hard_regno_mode_ok): Set up power8 constraints.\n+\t(rs6000_builtin_mask_calculate): Add power8 builtin support.\n+\t(rs6000_option_override_internal): Add support for power8.\n+\t(rs6000_common_init_builtins): Add debugging for skipped builtins\n+\tif -mdebug=builtin.\n+\t(rs6000_adjust_cost): Add power8 support.\n+\t(rs6000_issue_rate): Likewise.\n+\t(insn_must_be_first_in_group): Likewise.\n+\t(insn_must_be_last_in_group): Likewise.\n+\t(force_new_group): Likewise.\n+\t(rs6000_register_move_cost): Likewise.\n+\t(rs6000_opt_masks): Likewise.\n+\n+\t* config/rs6000/rs6000.h (ASM_CPU_POWER8_SPEC): If we don't have a\n+\tpower8 capable assembler, default to power7 options.\n+\t(TARGET_DIRECT_MOVE): Likewise.\n+\t(TARGET_CRYPTO): Likewise.\n+\t(TARGET_P8_VECTOR): Likewise.\n+\t(VECTOR_UNIT_P8_VECTOR_P): Define power8 vector support.\n+\t(VECTOR_UNIT_VSX_OR_P8_VECTOR_P): Likewise.\n+\t(VECTOR_MEM_P8_VECTOR_P): Likewise.\n+\t(VECTOR_MEM_VSX_OR_P8_VECTOR_P): Likewise.\n+\t(VECTOR_MEM_ALTIVEC_OR_VSX_P): Likewise.\n+\t(TARGET_XSCVDPSPN): Likewise.\n+\t(TARGET_XSCVSPDPN): Likewsie.\n+\t(TARGET_SYNC_HI_QI): Likewise.\n+\t(TARGET_SYNC_TI): Likewise.\n+\t(MASK_CRYPTO): Likewise.\n+\t(MASK_DIRECT_MOVE): Likewise.\n+\t(MASK_P8_FUSION): Likewise.\n+\t(MASK_P8_VECTOR): Likewise.\n+\t(REG_ALLOC_ORDER): Move fr13 to be lower in priority so that the\n+\tTFmode temporary used by some of the direct move instructions to\n+\tget two FP temporary registers does not force creation of a stack\n+\tframe.\n+\t(VLOGICAL_REGNO_P): Allow vector logical operations in GPRs.\n+\t(MODES_TIEABLE_P): Move the VSX tests above the Altivec tests so\n+\tthat any VSX registers are tieable, even if they are also an\n+\tAltivec vector mode.\n+\t(r6000_reg_class_enum): Add wm, wr, wv constraints.\n+\t(RS6000_BTM_P8_VECTOR): Power8 builtin support.\n+\t(RS6000_BTM_CRYPTO): Likewise.\n+\t(RS6000_BTM_COMMON): Likewise.\n+\n+\t* config/rs6000/rs6000.md (cpu attribute): Add power8.\n+\t* config/rs6000/rs6000-opts.h (PROCESSOR_POWER8): Likewise.\n+\t(enum rs6000_vector): Add power8 vector support.\n+\n 2013-05-22  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/19599"}, {"sha": "fa53cbb9de7b3d9fd5a2751057d3b8bc828513d6", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -79,12 +79,31 @@\n (define_register_constraint \"wl\" \"rs6000_constraints[RS6000_CONSTRAINT_wl]\"\n   \"Floating point register if the LFIWAX instruction is enabled or NO_REGS.\")\n \n+(define_register_constraint \"wm\" \"rs6000_constraints[RS6000_CONSTRAINT_wm]\"\n+  \"VSX register if direct move instructions are enabled, or NO_REGS.\")\n+\n+(define_register_constraint \"wr\" \"rs6000_constraints[RS6000_CONSTRAINT_wr]\"\n+  \"General purpose register if 64-bit instructions are enabled or NO_REGS.\")\n+\n+(define_register_constraint \"wv\" \"rs6000_constraints[RS6000_CONSTRAINT_wv]\"\n+  \"Altivec register if -mpower8-vector is used or NO_REGS.\")\n+\n (define_register_constraint \"wx\" \"rs6000_constraints[RS6000_CONSTRAINT_wx]\"\n   \"Floating point register if the STFIWX instruction is enabled or NO_REGS.\")\n \n (define_register_constraint \"wz\" \"rs6000_constraints[RS6000_CONSTRAINT_wz]\"\n   \"Floating point register if the LFIWZX instruction is enabled or NO_REGS.\")\n \n+;; NO_REGs register constraint, used to merge mov{sd,sf}, since movsd can use\n+;; direct move directly, and movsf can't to move between the register sets.\n+;; There is a mode_attr that resolves to wm for SDmode and wn for SFmode\n+(define_register_constraint \"wn\" \"NO_REGS\")\n+\n+;; Lq/stq validates the address for load/store quad\n+(define_memory_constraint \"wQ\"\n+  \"Memory operand suitable for the load/store quad instructions\"\n+  (match_operand 0 \"quad_memory_operand\"))\n+\n ;; Altivec style load/store that ignores the bottom bits of the address\n (define_memory_constraint \"wZ\"\n   \"Indexed or indirect memory operand, ignoring the bottom 4 bits\""}, {"sha": "078c9387350cfc3dda31cce6486f2956e2cb0c7a", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -166,6 +166,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 2, 3)\")))\n \n+;; Match op = 0..15\n+(define_predicate \"const_0_to_15_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 15)\")))\n+\n ;; Return 1 if op is a register that is not special.\n (define_predicate \"gpc_reg_operand\"\n   (match_operand 0 \"register_operand\")\n@@ -182,9 +187,68 @@\n   if (REGNO (op) >= ARG_POINTER_REGNUM && !CA_REGNO_P (REGNO (op)))\n     return 1;\n \n+  if (TARGET_VSX && VSX_REGNO_P (REGNO (op)))\n+    return 1;\n+\n   return INT_REGNO_P (REGNO (op)) || FP_REGNO_P (REGNO (op));\n })\n \n+;; Return 1 if op is a general purpose register.  Unlike gpc_reg_operand, don't\n+;; allow floating point or vector registers.\n+(define_predicate \"int_reg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) >= ARG_POINTER_REGNUM && !CA_REGNO_P (REGNO (op)))\n+    return 1;\n+\n+  return INT_REGNO_P (REGNO (op));\n+})\n+\n+;; Like int_reg_operand, but only return true for base registers\n+(define_predicate \"base_reg_operand\"\n+  (match_operand 0 \"int_reg_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  return (REGNO (op) != FIRST_GPR_REGNO);\n+})\n+\n+;; Return 1 if op is a general purpose register that is an even register\n+;; which suitable for a load/store quad operation\n+(define_predicate \"quad_int_reg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  HOST_WIDE_INT r;\n+\n+  if (!TARGET_QUAD_MEMORY)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  r = REGNO (op);\n+  if (r >= FIRST_PSEUDO_REGISTER)\n+    return 1;\n+\n+  return (INT_REGNO_P (r) && ((r & 1) == 0));\n+})\n+\n ;; Return 1 if op is a register that is a condition register field.\n (define_predicate \"cc_reg_operand\"\n   (match_operand 0 \"register_operand\")\n@@ -302,6 +366,11 @@\n \t\t      & (~ (unsigned HOST_WIDE_INT) 0xffffffff)) == 0)\")\n     (match_operand 0 \"gpc_reg_operand\")))\n \n+;; Like reg_or_logical_cint_operand, but allow vsx registers\n+(define_predicate \"vsx_reg_or_cint_operand\"\n+  (ior (match_operand 0 \"vsx_register_operand\")\n+       (match_operand 0 \"reg_or_logical_cint_operand\")))\n+\n ;; Return 1 if operand is a CONST_DOUBLE that can be set in a register\n ;; with no more than one instruction per word.\n (define_predicate \"easy_fp_constant\"\n@@ -507,6 +576,54 @@\n   (and (match_operand 0 \"memory_operand\")\n        (match_test \"offsettable_nonstrict_memref_p (op)\")))\n \n+;; Return 1 if the operand is suitable for load/store quad memory.\n+(define_predicate \"quad_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  rtx addr, op0, op1;\n+  int ret;\n+\n+  if (!TARGET_QUAD_MEMORY)\n+    ret = 0;\n+\n+  else if (!memory_operand (op, mode))\n+    ret = 0;\n+\n+  else if (GET_MODE_SIZE (GET_MODE (op)) != 16)\n+    ret = 0;\n+\n+  else if (MEM_ALIGN (op) < 128)\n+    ret = 0;\n+\n+  else\n+    {\n+      addr = XEXP (op, 0);\n+      if (int_reg_operand (addr, Pmode))\n+\tret = 1;\n+\n+      else if (GET_CODE (addr) != PLUS)\n+\tret = 0;\n+\n+      else\n+\t{\n+\t  op0 = XEXP (addr, 0);\n+\t  op1 = XEXP (addr, 1);\n+\t  ret = (int_reg_operand (op0, Pmode)\n+\t\t && GET_CODE (op1) == CONST_INT\n+\t\t && IN_RANGE (INTVAL (op1), -32768, 32767)\n+\t\t && (INTVAL (op1) & 15) == 0);\n+\t}\n+    }\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr, \"\\nquad_memory_operand, ret = %s\\n\", ret ? \"true\" : \"false\");\n+      debug_rtx (op);\n+    }\n+\n+  return ret;\n+})\n+\n ;; Return 1 if the operand is an indexed or indirect memory operand.\n (define_predicate \"indexed_or_indirect_operand\"\n   (match_code \"mem\")\n@@ -521,6 +638,19 @@\n   return indexed_or_indirect_address (op, mode);\n })\n \n+;; Like indexed_or_indirect_operand, but also allow a GPR register if direct\n+;; moves are supported.\n+(define_predicate \"reg_or_indexed_operand\"\n+  (match_code \"mem,reg\")\n+{\n+  if (MEM_P (op))\n+    return indexed_or_indirect_operand (op, mode);\n+  else if (TARGET_DIRECT_MOVE)\n+    return register_operand (op, mode);\n+  return\n+    0;\n+})\n+\n ;; Return 1 if the operand is an indexed or indirect memory operand with an\n ;; AND -16 in it, used to recognize when we need to switch to Altivec loads\n ;; to realign loops instead of VSX (altivec silently ignores the bottom bits,"}, {"sha": "b41f53314c642e390132aa7410fb03b5af0840a6", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 133, "deletions": 2, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -30,7 +30,7 @@\n    RS6000_BUILTIN_A -- ABS builtins\n    RS6000_BUILTIN_D -- DST builtins\n    RS6000_BUILTIN_E -- SPE EVSEL builtins.\n-   RS6000_BUILTIN_P -- Altivec and VSX predicate builtins\n+   RS6000_BUILTIN_P -- Altivec, VSX, Power8 vector predicate builtins\n    RS6000_BUILTIN_Q -- Paired floating point VSX predicate builtins\n    RS6000_BUILTIN_S -- SPE predicate builtins\n    RS6000_BUILTIN_X -- special builtins\n@@ -301,6 +301,108 @@\n \t\t     | RS6000_BTC_SPECIAL),\t\t\t\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n \n+/* Power8 vector convenience macros.  */\n+/* For the instructions that are encoded as altivec instructions use\n+   __builtin_altivec_ as the builtin name.  */\n+#define BU_P8V_AV_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_1 (P8V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P8V_AV_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (P8V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P8V_AV_P(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_P (P8V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_PREDICATE),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+/* For the instructions encoded as VSX instructions use __builtin_vsx as the\n+   builtin name.  */\n+#define BU_P8V_VSX_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_1 (P8V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P8V_OVERLOAD_1(ENUM, NAME)\t\t\t\t\t\\\n+  RS6000_BUILTIN_1 (P8V_BUILTIN_VEC_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+#define BU_P8V_OVERLOAD_2(ENUM, NAME)\t\t\t\t\t\\\n+  RS6000_BUILTIN_2 (P8V_BUILTIN_VEC_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+/* Crypto convenience macros.  */\n+#define BU_CRYPTO_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_1 (CRYPTO_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_crypto_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_CRYPTO,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_CRYPTO_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (CRYPTO_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_crypto_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_CRYPTO,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_CRYPTO_3(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_3 (CRYPTO_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_crypto_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_CRYPTO,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_CRYPTO_OVERLOAD_1(ENUM, NAME)\t\t\t\t\\\n+  RS6000_BUILTIN_1 (CRYPTO_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_crypto_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_CRYPTO,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+#define BU_CRYPTO_OVERLOAD_2(ENUM, NAME)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (CRYPTO_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_crypto_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_CRYPTO,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+#define BU_CRYPTO_OVERLOAD_3(ENUM, NAME)\t\t\t\t\\\n+  RS6000_BUILTIN_3 (CRYPTO_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_crypto_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_CRYPTO,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n /* SPE convenience macros.  */\n #define BU_SPE_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n   RS6000_BUILTIN_1 (SPE_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n@@ -1012,7 +1114,7 @@ BU_VSX_1 (XVTSQRTSP_FG,\t      \"xvtsqrtsp_fg\",\tCONST,\tvsx_tsqrtv4sf2_fg)\n BU_VSX_1 (XVRESP,\t      \"xvresp\",\t\tCONST,\tvsx_frev4sf2)\n \n BU_VSX_1 (XSCVDPSP,\t      \"xscvdpsp\",\tCONST,\tvsx_xscvdpsp)\n-BU_VSX_1 (XSCVSPDP,\t      \"xscvspdp\",\tCONST,\tvsx_xscvdpsp)\n+BU_VSX_1 (XSCVSPDP,\t      \"xscvspdp\",\tCONST,\tvsx_xscvspdp)\n BU_VSX_1 (XVCVDPSP,\t      \"xvcvdpsp\",\tCONST,\tvsx_xvcvdpsp)\n BU_VSX_1 (XVCVSPDP,\t      \"xvcvspdp\",\tCONST,\tvsx_xvcvspdp)\n BU_VSX_1 (XSTSQRTDP_FE,\t      \"xstsqrtdp_fe\",\tCONST,\tvsx_tsqrtdf2_fe)\n@@ -1131,6 +1233,35 @@ BU_VSX_OVERLOAD_2 (XXSPLTW,  \"xxspltw\")\n /* VSX builtins that are handled as special cases.  */\n BU_VSX_OVERLOAD_X (LD,\t     \"ld\")\n BU_VSX_OVERLOAD_X (ST,\t     \"st\")\n+\f\n+/* 1 argument crypto functions.  */\n+BU_CRYPTO_1 (VSBOX,\t\t\"vsbox\",\t  CONST, crypto_vsbox)\n+\n+/* 2 argument crypto functions.  */\n+BU_CRYPTO_2 (VCIPHER,\t\t\"vcipher\",\t  CONST, crypto_vcipher)\n+BU_CRYPTO_2 (VCIPHERLAST,\t\"vcipherlast\",\t  CONST, crypto_vcipherlast)\n+BU_CRYPTO_2 (VNCIPHER,\t\t\"vncipher\",\t  CONST, crypto_vncipher)\n+BU_CRYPTO_2 (VNCIPHERLAST,\t\"vncipherlast\",\t  CONST, crypto_vncipherlast)\n+BU_CRYPTO_2 (VPMSUMB,\t\t\"vpmsumb\",\t  CONST, crypto_vpmsumb)\n+BU_CRYPTO_2 (VPMSUMH,\t\t\"vpmsumh\",\t  CONST, crypto_vpmsumh)\n+BU_CRYPTO_2 (VPMSUMW,\t\t\"vpmsumw\",\t  CONST, crypto_vpmsumw)\n+BU_CRYPTO_2 (VPMSUMD,\t\t\"vpmsumd\",\t  CONST, crypto_vpmsumd)\n+\n+/* 3 argument crypto functions.  */\n+BU_CRYPTO_3 (VPERMXOR_V2DI,\t\"vpermxor_v2di\",  CONST, crypto_vpermxor_v2di)\n+BU_CRYPTO_3 (VPERMXOR_V4SI,\t\"vpermxor_v4si\",  CONST, crypto_vpermxor_v4si)\n+BU_CRYPTO_3 (VPERMXOR_V8HI,\t\"vpermxor_v8hi\",  CONST, crypto_vpermxor_v8hi)\n+BU_CRYPTO_3 (VPERMXOR_V16QI,\t\"vpermxor_v16qi\", CONST, crypto_vpermxor_v16qi)\n+BU_CRYPTO_3 (VSHASIGMAW,\t\"vshasigmaw\",\t  CONST, crypto_vshasigmaw)\n+BU_CRYPTO_3 (VSHASIGMAD,\t\"vshasigmad\",\t  CONST, crypto_vshasigmad)\n+\n+/* 2 argument crypto overloaded functions.  */\n+BU_CRYPTO_OVERLOAD_2 (VPMSUM,\t \"vpmsum\")\n+\n+/* 3 argument crypto overloaded functions.  */\n+BU_CRYPTO_OVERLOAD_3 (VPERMXOR,\t \"vpermxor\")\n+BU_CRYPTO_OVERLOAD_3 (VSHASIGMA, \"vshasigma\")\n+\n \f\n /* 3 argument paired floating point builtins.  */\n BU_PAIRED_3 (MSUB,            \"msub\",           FP, \tfmsv2sf4)"}, {"sha": "c6c584d81836f2107313c39affd7253d16373e09", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -315,6 +315,8 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n     rs6000_define_or_undefine_macro (define_p, \"_ARCH_PWR6X\");\n   if ((flags & OPTION_MASK_POPCNTD) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"_ARCH_PWR7\");\n+  if ((flags & OPTION_MASK_DIRECT_MOVE) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"_ARCH_PWR8\");\n   if ((flags & OPTION_MASK_SOFT_FLOAT) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"_SOFT_FLOAT\");\n   if ((flags & OPTION_MASK_RECIP_PRECISION) != 0)\n@@ -331,6 +333,10 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n     }\n   if ((flags & OPTION_MASK_VSX) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"__VSX__\");\n+  if ((flags & OPTION_MASK_P8_VECTOR) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"__POWER8_VECTOR__\");\n+  if ((flags & OPTION_MASK_CRYPTO) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"__CRYPTO__\");\n \n   /* options from the builtin masks.  */\n   if ((bu_mask & RS6000_BTM_SPE) != 0)\n@@ -3377,6 +3383,40 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, VSX_BUILTIN_XVCMPGEDP_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DF, RS6000_BTI_V2DF },\n \n+  /* Crypto builtins.  */\n+  { CRYPTO_BUILTIN_VPERMXOR, CRYPTO_BUILTIN_VPERMXOR_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI },\n+  { CRYPTO_BUILTIN_VPERMXOR, CRYPTO_BUILTIN_VPERMXOR_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI },\n+  { CRYPTO_BUILTIN_VPERMXOR, CRYPTO_BUILTIN_VPERMXOR_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI },\n+  { CRYPTO_BUILTIN_VPERMXOR, CRYPTO_BUILTIN_VPERMXOR_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },\n+\n+  { CRYPTO_BUILTIN_VPMSUM, CRYPTO_BUILTIN_VPMSUMB,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+  { CRYPTO_BUILTIN_VPMSUM, CRYPTO_BUILTIN_VPMSUMH,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_unsigned_V8HI, 0 },\n+  { CRYPTO_BUILTIN_VPMSUM, CRYPTO_BUILTIN_VPMSUMW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+  { CRYPTO_BUILTIN_VPMSUM, CRYPTO_BUILTIN_VPMSUMD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { CRYPTO_BUILTIN_VSHASIGMA, CRYPTO_BUILTIN_VSHASIGMAW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI },\n+  { CRYPTO_BUILTIN_VSHASIGMA, CRYPTO_BUILTIN_VSHASIGMAD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI },\n+\n   { (enum rs6000_builtins) 0, (enum rs6000_builtins) 0, 0, 0, 0, 0 }\n };\n \f\n@@ -3824,7 +3864,8 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t&& (desc->op2 == RS6000_BTI_NOT_OPAQUE\n \t    || rs6000_builtin_type_compatible (types[1], desc->op2))\n \t&& (desc->op3 == RS6000_BTI_NOT_OPAQUE\n-\t    || rs6000_builtin_type_compatible (types[2], desc->op3)))\n+\t    || rs6000_builtin_type_compatible (types[2], desc->op3))\n+\t&& rs6000_builtin_decls[desc->overloaded_code] != NULL_TREE)\n       return altivec_build_resolved_builtin (args, n, desc);\n \n  bad:"}, {"sha": "25a0ed27fe78cc47e42221ad17b030425394a1b3", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -28,7 +28,7 @@\n      ALTIVEC, since in general it isn't a win on power6.  In ISA 2.04, fsel,\n      fre, fsqrt, etc. were no longer documented as optional.  Group masks by\n      server and embedded. */\n-#define ISA_2_5_MASKS_EMBEDDED\t(ISA_2_2_MASKS\t\t\t\t\\\n+#define ISA_2_5_MASKS_EMBEDDED\t(ISA_2_4_MASKS\t\t\t\t\\\n \t\t\t\t | OPTION_MASK_CMPB\t\t\t\\\n \t\t\t\t | OPTION_MASK_RECIP_PRECISION\t\t\\\n \t\t\t\t | OPTION_MASK_PPC_GFXOPT\t\t\\\n@@ -45,6 +45,14 @@\n \t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n \t\t\t\t | OPTION_MASK_VSX_TIMODE)\n \n+/* For now, don't provide an embedded version of ISA 2.07.  */\n+#define ISA_2_7_MASKS_SERVER\t(ISA_2_6_MASKS_SERVER\t\t\t\\\n+\t\t\t\t | OPTION_MASK_P8_FUSION\t\t\\\n+\t\t\t\t | OPTION_MASK_P8_VECTOR\t\t\\\n+\t\t\t\t | OPTION_MASK_CRYPTO\t\t\t\\\n+\t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n+\t\t\t\t | OPTION_MASK_QUAD_MEMORY)\n+\n #define POWERPC_7400_MASK\t(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)\n \n /* Deal with ports that do not have -mstrict-align.  */\n@@ -61,19 +69,24 @@\n /* Mask of all options to set the default isa flags based on -mcpu=<xxx>.  */\n #define POWERPC_MASKS\t\t(OPTION_MASK_ALTIVEC\t\t\t\\\n \t\t\t\t | OPTION_MASK_CMPB\t\t\t\\\n+\t\t\t\t | OPTION_MASK_CRYPTO\t\t\t\\\n \t\t\t\t | OPTION_MASK_DFP\t\t\t\\\n+\t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n \t\t\t\t | OPTION_MASK_DLMZB\t\t\t\\\n \t\t\t\t | OPTION_MASK_FPRND\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFCRF\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFPGPR\t\t\t\\\n \t\t\t\t | OPTION_MASK_MULHW\t\t\t\\\n \t\t\t\t | OPTION_MASK_NO_UPDATE\t\t\\\n+\t\t\t\t | OPTION_MASK_P8_FUSION\t\t\\\n+\t\t\t\t | OPTION_MASK_P8_VECTOR\t\t\\\n \t\t\t\t | OPTION_MASK_POPCNTB\t\t\t\\\n \t\t\t\t | OPTION_MASK_POPCNTD\t\t\t\\\n \t\t\t\t | OPTION_MASK_POWERPC64\t\t\\\n \t\t\t\t | OPTION_MASK_PPC_GFXOPT\t\t\\\n \t\t\t\t | OPTION_MASK_PPC_GPOPT\t\t\\\n+\t\t\t\t | OPTION_MASK_QUAD_MEMORY\t\t\\\n \t\t\t\t | OPTION_MASK_RECIP_PRECISION\t\t\\\n \t\t\t\t | OPTION_MASK_SOFT_FLOAT\t\t\\\n \t\t\t\t | OPTION_MASK_STRICT_ALIGN_OPTIONAL\t\\\n@@ -168,10 +181,7 @@ RS6000_CPU (\"power7\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n \t    POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n \t    | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n \t    | MASK_VSX | MASK_RECIP_PRECISION | MASK_VSX_TIMODE)\n-RS6000_CPU (\"power8\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n-\t    POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n-\t    | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t    | MASK_VSX | MASK_RECIP_PRECISION | MASK_VSX_TIMODE)\n+RS6000_CPU (\"power8\", PROCESSOR_POWER7, MASK_POWERPC64 | ISA_2_7_MASKS_SERVER)\n RS6000_CPU (\"powerpc\", PROCESSOR_POWERPC, 0)\n RS6000_CPU (\"powerpc64\", PROCESSOR_POWERPC64, MASK_PPC_GFXOPT | MASK_POWERPC64)\n RS6000_CPU (\"rs64\", PROCESSOR_RS64A, MASK_PPC_GFXOPT | MASK_POWERPC64)"}, {"sha": "e143a4ca20371762d49a6c827dbae30497a9dfe5", "filename": "gcc/config/rs6000/rs6000-opts.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -59,7 +59,8 @@ enum processor_type\n    PROCESSOR_POWER7,\n    PROCESSOR_CELL,\n    PROCESSOR_PPCA2,\n-   PROCESSOR_TITAN\n+   PROCESSOR_TITAN,\n+   PROCESSOR_POWER8\n };\n \n /* FP processor type.  */\n@@ -131,11 +132,14 @@ enum rs6000_cmodel {\n   CMODEL_LARGE\n };\n \n-/* Describe which vector unit to use for a given machine mode.  */\n+/* Describe which vector unit to use for a given machine mode.  The\n+   VECTOR_MEM_* and VECTOR_UNIT_* macros assume that Altivec, VSX, and\n+   P8_VECTOR are contiguous.  */\n enum rs6000_vector {\n   VECTOR_NONE,\t\t\t/* Type is not  a vector or not supported */\n   VECTOR_ALTIVEC,\t\t/* Use altivec for vector processing */\n   VECTOR_VSX,\t\t\t/* Use VSX for vector processing */\n+  VECTOR_P8_VECTOR,\t\t/* Use ISA 2.07 VSX for vector processing */\n   VECTOR_PAIRED,\t\t/* Use paired floating point for vectors */\n   VECTOR_SPE,\t\t\t/* Use SPE for vector processing */\n   VECTOR_OTHER\t\t\t/* Some other vector unit */"}, {"sha": "7963bf4d5c2e5331a60e74637eac6ff559a270be", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 236, "deletions": 22, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -831,6 +831,25 @@ struct processor_costs power7_cost = {\n   12,\t\t\t/* prefetch streams */\n };\n \n+/* Instruction costs on POWER8 processors.  */\n+static const\n+struct processor_costs power8_cost = {\n+  COSTS_N_INSNS (3),\t/* mulsi */\n+  COSTS_N_INSNS (3),\t/* mulsi_const */\n+  COSTS_N_INSNS (3),\t/* mulsi_const9 */\n+  COSTS_N_INSNS (3),\t/* muldi */\n+  COSTS_N_INSNS (19),\t/* divsi */\n+  COSTS_N_INSNS (35),\t/* divdi */\n+  COSTS_N_INSNS (3),\t/* fp */\n+  COSTS_N_INSNS (3),\t/* dmul */\n+  COSTS_N_INSNS (14),\t/* sdiv */\n+  COSTS_N_INSNS (17),\t/* ddiv */\n+  128,\t\t\t/* cache line size */\n+  32,\t\t\t/* l1 cache */\n+  256,\t\t\t/* l2 cache */\n+  12,\t\t\t/* prefetch streams */\n+};\n+\n /* Instruction costs on POWER A2 processors.  */\n static const\n struct processor_costs ppca2_cost = {\n@@ -1547,6 +1566,15 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   int last_regno = regno + rs6000_hard_regno_nregs[mode][regno] - 1;\n \n+  /* PTImode can only go in GPRs.  Quad word memory operations require even/odd\n+     register combinations, and use PTImode where we need to deal with quad\n+     word memory operations.  Don't allow quad words in the argument or frame\n+     pointer registers, just registers 0..31.  */\n+  if (mode == PTImode)\n+    return (IN_RANGE (regno, FIRST_GPR_REGNO, LAST_GPR_REGNO)\n+\t    && IN_RANGE (last_regno, FIRST_GPR_REGNO, LAST_GPR_REGNO)\n+\t    && ((regno & 1) == 0));\n+\n   /* VSX registers that overlap the FPR registers are larger than for non-VSX\n      implementations.  Don't allow an item to be split between a FP register\n      and an Altivec register.  */\n@@ -1672,6 +1700,16 @@ rs6000_debug_reg_print (int first_regno, int last_regno, const char *reg_name)\n \t  comma = \", \";\n \t}\n \n+      if (len > 70)\n+\t{\n+\t  fprintf (stderr, \",\\n\\t\");\n+\t  comma = \"\";\n+\t}\n+\n+      len += fprintf (stderr, \"%sreg-class = %s\", comma,\n+\t\t      reg_class_names[(int)rs6000_regno_regclass[r]]);\n+      comma = \", \";\n+\n       if (len > 70)\n \t{\n \t  fprintf (stderr, \",\\n\\t\");\n@@ -1710,6 +1748,7 @@ rs6000_debug_reg_global (void)\n     \"none\",\n     \"altivec\",\n     \"vsx\",\n+    \"p8_vector\",\n     \"paired\",\n     \"spe\",\n     \"other\"\n@@ -1802,8 +1841,11 @@ rs6000_debug_reg_global (void)\n \t   \"wf reg_class = %s\\n\"\n \t   \"wg reg_class = %s\\n\"\n \t   \"wl reg_class = %s\\n\"\n+\t   \"wm reg_class = %s\\n\"\n+\t   \"wr reg_class = %s\\n\"\n \t   \"ws reg_class = %s\\n\"\n \t   \"wt reg_class = %s\\n\"\n+\t   \"wv reg_class = %s\\n\"\n \t   \"wx reg_class = %s\\n\"\n \t   \"wz reg_class = %s\\n\"\n \t   \"\\n\",\n@@ -1815,8 +1857,11 @@ rs6000_debug_reg_global (void)\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wf]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wg]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wl]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wm]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wr]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_ws]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wt]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wv]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wx]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wz]]);\n \n@@ -2050,6 +2095,10 @@ rs6000_debug_reg_global (void)\n   if (targetm.lra_p ())\n     fprintf (stderr, DEBUG_FMT_S, \"lra\", \"true\");\n \n+  if (TARGET_P8_FUSION)\n+    fprintf (stderr, DEBUG_FMT_S, \"p8 fusion\",\n+\t     (TARGET_P8_FUSION_SIGN) ? \"zero+sign\" : \"zero\");\n+\n   fprintf (stderr, DEBUG_FMT_S, \"plt-format\",\n \t   TARGET_SECURE_PLT ? \"secure\" : \"bss\");\n   fprintf (stderr, DEBUG_FMT_S, \"struct-return\",\n@@ -2240,6 +2289,15 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_LFIWAX)\n     rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;\n \n+  if (TARGET_DIRECT_MOVE)\n+    rs6000_constraints[RS6000_CONSTRAINT_wm] = VSX_REGS;\n+\n+  if (TARGET_POWERPC64)\n+    rs6000_constraints[RS6000_CONSTRAINT_wr] = GENERAL_REGS;\n+\n+  if (TARGET_P8_VECTOR)\n+    rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n+\n   if (TARGET_STFIWX)\n     rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;\n \n@@ -2520,16 +2578,18 @@ darwin_rs6000_override_options (void)\n HOST_WIDE_INT\n rs6000_builtin_mask_calculate (void)\n {\n-  return (((TARGET_ALTIVEC)\t\t    ? RS6000_BTM_ALTIVEC  : 0)\n-\t  | ((TARGET_VSX)\t\t    ? RS6000_BTM_VSX\t  : 0)\n-\t  | ((TARGET_SPE)\t\t    ? RS6000_BTM_SPE\t  : 0)\n-\t  | ((TARGET_PAIRED_FLOAT)\t    ? RS6000_BTM_PAIRED\t  : 0)\n-\t  | ((TARGET_FRE)\t\t    ? RS6000_BTM_FRE\t  : 0)\n-\t  | ((TARGET_FRES)\t\t    ? RS6000_BTM_FRES\t  : 0)\n-\t  | ((TARGET_FRSQRTE)\t\t    ? RS6000_BTM_FRSQRTE  : 0)\n-\t  | ((TARGET_FRSQRTES)\t\t    ? RS6000_BTM_FRSQRTES : 0)\n-\t  | ((TARGET_POPCNTD)\t\t    ? RS6000_BTM_POPCNTD  : 0)\n-\t  | ((rs6000_cpu == PROCESSOR_CELL) ? RS6000_BTM_CELL     : 0));\n+  return (((TARGET_ALTIVEC)\t\t    ? RS6000_BTM_ALTIVEC   : 0)\n+\t  | ((TARGET_VSX)\t\t    ? RS6000_BTM_VSX\t   : 0)\n+\t  | ((TARGET_SPE)\t\t    ? RS6000_BTM_SPE\t   : 0)\n+\t  | ((TARGET_PAIRED_FLOAT)\t    ? RS6000_BTM_PAIRED\t   : 0)\n+\t  | ((TARGET_FRE)\t\t    ? RS6000_BTM_FRE\t   : 0)\n+\t  | ((TARGET_FRES)\t\t    ? RS6000_BTM_FRES\t   : 0)\n+\t  | ((TARGET_FRSQRTE)\t\t    ? RS6000_BTM_FRSQRTE   : 0)\n+\t  | ((TARGET_FRSQRTES)\t\t    ? RS6000_BTM_FRSQRTES  : 0)\n+\t  | ((TARGET_POPCNTD)\t\t    ? RS6000_BTM_POPCNTD   : 0)\n+\t  | ((rs6000_cpu == PROCESSOR_CELL) ? RS6000_BTM_CELL      : 0)\n+\t  | ((TARGET_P8_VECTOR)\t\t    ? RS6000_BTM_P8_VECTOR : 0)\n+\t  | ((TARGET_CRYPTO)\t\t    ? RS6000_BTM_CRYPTO\t   : 0));\n }\n \n /* Override command line options.  Mostly we process the processor type and\n@@ -2803,7 +2863,9 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* For the newer switches (vsx, dfp, etc.) set some of the older options,\n      unless the user explicitly used the -mno-<option> to disable the code.  */\n-  if (TARGET_VSX)\n+  if (TARGET_P8_VECTOR || TARGET_DIRECT_MOVE || TARGET_CRYPTO)\n+    rs6000_isa_flags |= (ISA_2_7_MASKS_SERVER & ~rs6000_isa_flags_explicit);\n+  else if (TARGET_VSX)\n     rs6000_isa_flags |= (ISA_2_6_MASKS_SERVER & ~rs6000_isa_flags_explicit);\n   else if (TARGET_POPCNTD)\n     rs6000_isa_flags |= (ISA_2_6_MASKS_EMBEDDED & ~rs6000_isa_flags_explicit);\n@@ -2818,6 +2880,34 @@ rs6000_option_override_internal (bool global_init_p)\n   else if (TARGET_ALTIVEC)\n     rs6000_isa_flags |= (OPTION_MASK_PPC_GFXOPT & ~rs6000_isa_flags_explicit);\n \n+  if (TARGET_CRYPTO && !TARGET_ALTIVEC)\n+    {\n+      if (rs6000_isa_flags_explicit & OPTION_MASK_CRYPTO)\n+\terror (\"-mcrypto requires -maltivec\");\n+      rs6000_isa_flags &= ~OPTION_MASK_CRYPTO;\n+    }\n+\n+  if (TARGET_DIRECT_MOVE && !TARGET_VSX)\n+    {\n+      if (rs6000_isa_flags_explicit & OPTION_MASK_DIRECT_MOVE)\n+\terror (\"-mdirect-move requires -mvsx\");\n+      rs6000_isa_flags &= ~OPTION_MASK_DIRECT_MOVE;\n+    }\n+\n+  if (TARGET_P8_VECTOR && !TARGET_ALTIVEC)\n+    {\n+      if (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)\n+\terror (\"-mpower8-vector requires -maltivec\");\n+      rs6000_isa_flags &= ~OPTION_MASK_P8_VECTOR;\n+    }\n+\n+  if (TARGET_P8_VECTOR && !TARGET_VSX)\n+    {\n+      if (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)\n+\terror (\"-mpower8-vector requires -mvsx\");\n+      rs6000_isa_flags &= ~OPTION_MASK_P8_VECTOR;\n+    }\n+\n   if (TARGET_VSX_TIMODE && !TARGET_VSX)\n     {\n       if (rs6000_isa_flags_explicit & OPTION_MASK_VSX_TIMODE)\n@@ -3019,16 +3109,19 @@ rs6000_option_override_internal (bool global_init_p)\n \t\t\t&& rs6000_cpu != PROCESSOR_POWER5\n \t\t\t&& rs6000_cpu != PROCESSOR_POWER6\n \t\t\t&& rs6000_cpu != PROCESSOR_POWER7\n+\t\t\t&& rs6000_cpu != PROCESSOR_POWER8\n \t\t\t&& rs6000_cpu != PROCESSOR_PPCA2\n \t\t\t&& rs6000_cpu != PROCESSOR_CELL\n \t\t\t&& rs6000_cpu != PROCESSOR_PPC476);\n   rs6000_sched_groups = (rs6000_cpu == PROCESSOR_POWER4\n \t\t\t || rs6000_cpu == PROCESSOR_POWER5\n-\t\t\t || rs6000_cpu == PROCESSOR_POWER7);\n+\t\t\t || rs6000_cpu == PROCESSOR_POWER7\n+\t\t\t || rs6000_cpu == PROCESSOR_POWER8);\n   rs6000_align_branch_targets = (rs6000_cpu == PROCESSOR_POWER4\n \t\t\t\t || rs6000_cpu == PROCESSOR_POWER5\n \t\t\t\t || rs6000_cpu == PROCESSOR_POWER6\n \t\t\t\t || rs6000_cpu == PROCESSOR_POWER7\n+\t\t\t\t || rs6000_cpu == PROCESSOR_POWER8\n \t\t\t\t || rs6000_cpu == PROCESSOR_PPCE500MC\n \t\t\t\t || rs6000_cpu == PROCESSOR_PPCE500MC64\n \t\t\t\t || rs6000_cpu == PROCESSOR_PPCE5500\n@@ -3272,6 +3365,10 @@ rs6000_option_override_internal (bool global_init_p)\n \trs6000_cost = &power7_cost;\n \tbreak;\n \n+      case PROCESSOR_POWER8:\n+\trs6000_cost = &power8_cost;\n+\tbreak;\n+\n       case PROCESSOR_PPCA2:\n \trs6000_cost = &ppca2_cost;\n \tbreak;\n@@ -3444,7 +3541,8 @@ rs6000_loop_align (rtx label)\n       && (rs6000_cpu == PROCESSOR_POWER4\n \t  || rs6000_cpu == PROCESSOR_POWER5\n \t  || rs6000_cpu == PROCESSOR_POWER6\n-\t  || rs6000_cpu == PROCESSOR_POWER7))\n+\t  || rs6000_cpu == PROCESSOR_POWER7\n+\t  || rs6000_cpu == PROCESSOR_POWER8))\n     return 5;\n   else\n     return align_loops_log;\n@@ -10578,6 +10676,27 @@ rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n \t  return const0_rtx;\n \t}\n     }\n+  else if (icode == CODE_FOR_crypto_vshasigmaw\n+\t   || icode == CODE_FOR_crypto_vshasigmad)\n+    {\n+      /* Check whether the 2nd and 3rd arguments are integer constants and in\n+\t range and prepare arguments.  */\n+      STRIP_NOPS (arg1);\n+      if (TREE_CODE (arg1) != INTEGER_CST\n+\t  || !IN_RANGE (TREE_INT_CST_LOW (arg1), 0, 1))\n+\t{\n+\t  error (\"argument 2 must be 0 or 1\");\n+\t  return const0_rtx;\n+\t}\n+\n+      STRIP_NOPS (arg2);\n+      if (TREE_CODE (arg2) != INTEGER_CST\n+\t  || !IN_RANGE (TREE_INT_CST_LOW (arg2), 0, 15))\n+\t{\n+\t  error (\"argument 3 must be in the range 0..15\");\n+\t  return const0_rtx;\n+\t}\n+    }\n \n   if (target == 0\n       || GET_MODE (target) != tmode\n@@ -12268,6 +12387,10 @@ altivec_init_builtins (void)\n     = build_function_type_list (integer_type_node,\n \t\t\t\tinteger_type_node, V4SI_type_node,\n \t\t\t\tV4SI_type_node, NULL_TREE);\n+  tree int_ftype_int_v2di_v2di\n+    = build_function_type_list (integer_type_node,\n+\t\t\t\tinteger_type_node, V2DI_type_node,\n+\t\t\t\tV2DI_type_node, NULL_TREE);\n   tree void_ftype_v4si\n     = build_function_type_list (void_type_node, V4SI_type_node, NULL_TREE);\n   tree v8hi_ftype_void\n@@ -12350,6 +12473,8 @@ altivec_init_builtins (void)\n     = build_function_type_list (integer_type_node,\n \t\t\t\tinteger_type_node, V2DF_type_node,\n \t\t\t\tV2DF_type_node, NULL_TREE);\n+  tree v2di_ftype_v2di\n+    = build_function_type_list (V2DI_type_node, V2DI_type_node, NULL_TREE);\n   tree v4si_ftype_v4si\n     = build_function_type_list (V4SI_type_node, V4SI_type_node, NULL_TREE);\n   tree v8hi_ftype_v8hi\n@@ -12485,6 +12610,9 @@ altivec_init_builtins (void)\n \tcase VOIDmode:\n \t  type = int_ftype_int_opaque_opaque;\n \t  break;\n+\tcase V2DImode:\n+\t  type = int_ftype_int_v2di_v2di;\n+\t  break;\n \tcase V4SImode:\n \t  type = int_ftype_int_v4si_v4si;\n \t  break;\n@@ -12518,6 +12646,9 @@ altivec_init_builtins (void)\n \n       switch (mode0)\n \t{\n+\tcase V2DImode:\n+\t  type = v2di_ftype_v2di;\n+\t  break;\n \tcase V4SImode:\n \t  type = v4si_ftype_v4si;\n \t  break;\n@@ -12723,11 +12854,26 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n      are type correct.  */\n   switch (builtin)\n     {\n+      /* unsigned 1 argument functions.  */\n+    case CRYPTO_BUILTIN_VSBOX:\n+      h.uns_p[0] = 1;\n+      h.uns_p[1] = 1;\n+      break;\n+\n       /* unsigned 2 argument functions.  */\n     case ALTIVEC_BUILTIN_VMULEUB_UNS:\n     case ALTIVEC_BUILTIN_VMULEUH_UNS:\n     case ALTIVEC_BUILTIN_VMULOUB_UNS:\n     case ALTIVEC_BUILTIN_VMULOUH_UNS:\n+    case CRYPTO_BUILTIN_VCIPHER:\n+    case CRYPTO_BUILTIN_VCIPHERLAST:\n+    case CRYPTO_BUILTIN_VNCIPHER:\n+    case CRYPTO_BUILTIN_VNCIPHERLAST:\n+    case CRYPTO_BUILTIN_VPMSUMB:\n+    case CRYPTO_BUILTIN_VPMSUMH:\n+    case CRYPTO_BUILTIN_VPMSUMW:\n+    case CRYPTO_BUILTIN_VPMSUMD:\n+    case CRYPTO_BUILTIN_VPMSUM:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       h.uns_p[2] = 1;\n@@ -12750,6 +12896,14 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n     case VSX_BUILTIN_XXSEL_8HI_UNS:\n     case VSX_BUILTIN_XXSEL_4SI_UNS:\n     case VSX_BUILTIN_XXSEL_2DI_UNS:\n+    case CRYPTO_BUILTIN_VPERMXOR:\n+    case CRYPTO_BUILTIN_VPERMXOR_V2DI:\n+    case CRYPTO_BUILTIN_VPERMXOR_V4SI:\n+    case CRYPTO_BUILTIN_VPERMXOR_V8HI:\n+    case CRYPTO_BUILTIN_VPERMXOR_V16QI:\n+    case CRYPTO_BUILTIN_VSHASIGMAW:\n+    case CRYPTO_BUILTIN_VSHASIGMAD:\n+    case CRYPTO_BUILTIN_VSHASIGMA:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       h.uns_p[2] = 1;\n@@ -12891,8 +13045,23 @@ rs6000_common_init_builtins (void)\n       else\n \t{\n \t  enum insn_code icode = d->icode;\n-          if (d->name == 0 || icode == CODE_FOR_nothing)\n-\t    continue;\n+\t  if (d->name == 0)\n+\t    {\n+\t      if (TARGET_DEBUG_BUILTIN)\n+\t\tfprintf (stderr, \"rs6000_builtin, bdesc_3arg[%ld] no name\\n\",\n+\t\t\t (long unsigned)i);\n+\n+\t      continue;\n+\t    }\n+\n+          if (icode == CODE_FOR_nothing)\n+\t    {\n+\t      if (TARGET_DEBUG_BUILTIN)\n+\t\tfprintf (stderr, \"rs6000_builtin, skip ternary %s (no code)\\n\",\n+\t\t\t d->name);\n+\n+\t      continue;\n+\t    }\n \n \t  type = builtin_function_type (insn_data[icode].operand[0].mode,\n \t\t\t\t\tinsn_data[icode].operand[1].mode,\n@@ -12931,8 +13100,23 @@ rs6000_common_init_builtins (void)\n       else\n \t{\n \t  enum insn_code icode = d->icode;\n-          if (d->name == 0 || icode == CODE_FOR_nothing)\n-\t    continue;\n+\t  if (d->name == 0)\n+\t    {\n+\t      if (TARGET_DEBUG_BUILTIN)\n+\t\tfprintf (stderr, \"rs6000_builtin, bdesc_2arg[%ld] no name\\n\",\n+\t\t\t (long unsigned)i);\n+\n+\t      continue;\n+\t    }\n+\n+          if (icode == CODE_FOR_nothing)\n+\t    {\n+\t      if (TARGET_DEBUG_BUILTIN)\n+\t\tfprintf (stderr, \"rs6000_builtin, skip binary %s (no code)\\n\",\n+\t\t\t d->name);\n+\n+\t      continue;\n+\t    }\n \n           mode0 = insn_data[icode].operand[0].mode;\n           mode1 = insn_data[icode].operand[1].mode;\n@@ -12993,8 +13177,23 @@ rs6000_common_init_builtins (void)\n       else\n         {\n \t  enum insn_code icode = d->icode;\n-          if (d->name == 0 || icode == CODE_FOR_nothing)\n-\t    continue;\n+\t  if (d->name == 0)\n+\t    {\n+\t      if (TARGET_DEBUG_BUILTIN)\n+\t\tfprintf (stderr, \"rs6000_builtin, bdesc_1arg[%ld] no name\\n\",\n+\t\t\t (long unsigned)i);\n+\n+\t      continue;\n+\t    }\n+\n+          if (icode == CODE_FOR_nothing)\n+\t    {\n+\t      if (TARGET_DEBUG_BUILTIN)\n+\t\tfprintf (stderr, \"rs6000_builtin, skip unary %s (no code)\\n\",\n+\t\t\t d->name);\n+\n+\t      continue;\n+\t    }\n \n           mode0 = insn_data[icode].operand[0].mode;\n           mode1 = insn_data[icode].operand[1].mode;\n@@ -22951,6 +23150,7 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n                  || rs6000_cpu_attr == CPU_POWER4\n                  || rs6000_cpu_attr == CPU_POWER5\n \t\t || rs6000_cpu_attr == CPU_POWER7\n+\t\t || rs6000_cpu_attr == CPU_POWER8\n                  || rs6000_cpu_attr == CPU_CELL)\n                 && recog_memoized (dep_insn)\n                 && (INSN_CODE (dep_insn) >= 0))\n@@ -23537,6 +23737,8 @@ rs6000_issue_rate (void)\n   case CPU_POWER6:\n   case CPU_POWER7:\n     return 5;\n+  case CPU_POWER8:\n+    return 7;\n   default:\n     return 1;\n   }\n@@ -24130,6 +24332,7 @@ insn_must_be_first_in_group (rtx insn)\n         }\n       break;\n     case PROCESSOR_POWER7:\n+    case PROCESSOR_POWER8:\t/* FIXME */\n       type = get_attr_type (insn);\n \n       switch (type)\n@@ -24226,6 +24429,7 @@ insn_must_be_last_in_group (rtx insn)\n     }\n     break;\n   case PROCESSOR_POWER7:\n+  case PROCESSOR_POWER8:\t/* FIXME */\n     type = get_attr_type (insn);\n \n     switch (type)\n@@ -24332,7 +24536,8 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns,\n \tcan_issue_more--;\n \n       /* Power6 and Power7 have special group ending nop. */\n-      if (rs6000_cpu_attr == CPU_POWER6 || rs6000_cpu_attr == CPU_POWER7)\n+      if (rs6000_cpu_attr == CPU_POWER6 || rs6000_cpu_attr == CPU_POWER7\n+\t  || rs6000_cpu_attr == CPU_POWER8)\n \t{\n \t  nop = gen_group_ending_nop ();\n \t  emit_insn_before (nop, next_insn);\n@@ -26513,7 +26718,8 @@ rs6000_register_move_cost (enum machine_mode mode,\n       /* For those processors that have slow LR/CTR moves, make them more\n          expensive than memory in order to bias spills to memory .*/\n       else if ((rs6000_cpu == PROCESSOR_POWER6\n-\t\t|| rs6000_cpu == PROCESSOR_POWER7)\n+\t\t|| rs6000_cpu == PROCESSOR_POWER7\n+\t\t|| rs6000_cpu == PROCESSOR_POWER8)\n \t       && reg_classes_intersect_p (rclass, LINK_OR_CTR_REGS))\n         ret = 6 * hard_regno_nregs[0][mode];\n \n@@ -27742,6 +27948,8 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n {\n   { \"altivec\",\t\t\tOPTION_MASK_ALTIVEC,\t\tfalse, true  },\n   { \"cmpb\",\t\t\tOPTION_MASK_CMPB,\t\tfalse, true  },\n+  { \"crypto\",\t\t\tOPTION_MASK_CRYPTO,\t\tfalse, true  },\n+  { \"direct-move\",\t\tOPTION_MASK_DIRECT_MOVE,\tfalse, true  },\n   { \"dlmzb\",\t\t\tOPTION_MASK_DLMZB,\t\tfalse, true  },\n   { \"fprnd\",\t\t\tOPTION_MASK_FPRND,\t\tfalse, true  },\n   { \"hard-dfp\",\t\t\tOPTION_MASK_DFP,\t\tfalse, true  },\n@@ -27750,13 +27958,17 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"mfpgpr\",\t\t\tOPTION_MASK_MFPGPR,\t\tfalse, true  },\n   { \"mulhw\",\t\t\tOPTION_MASK_MULHW,\t\tfalse, true  },\n   { \"multiple\",\t\t\tOPTION_MASK_MULTIPLE,\t\tfalse, true  },\n-  { \"update\",\t\t\tOPTION_MASK_NO_UPDATE,\t\ttrue , true  },\n   { \"popcntb\",\t\t\tOPTION_MASK_POPCNTB,\t\tfalse, true  },\n   { \"popcntd\",\t\t\tOPTION_MASK_POPCNTD,\t\tfalse, true  },\n+  { \"power8-fusion\",\t\tOPTION_MASK_P8_FUSION,\t\tfalse, true  },\n+  { \"power8-fusion-sign\",\tOPTION_MASK_P8_FUSION_SIGN,\tfalse, true  },\n+  { \"power8-vector\",\t\tOPTION_MASK_P8_VECTOR,\t\tfalse, true  },\n   { \"powerpc-gfxopt\",\t\tOPTION_MASK_PPC_GFXOPT,\t\tfalse, true  },\n   { \"powerpc-gpopt\",\t\tOPTION_MASK_PPC_GPOPT,\t\tfalse, true  },\n+  { \"quad-memory\",\t\tOPTION_MASK_QUAD_MEMORY,\tfalse, true  },\n   { \"recip-precision\",\t\tOPTION_MASK_RECIP_PRECISION,\tfalse, true  },\n   { \"string\",\t\t\tOPTION_MASK_STRING,\t\tfalse, true  },\n+  { \"update\",\t\t\tOPTION_MASK_NO_UPDATE,\t\ttrue , true  },\n   { \"vsx\",\t\t\tOPTION_MASK_VSX,\t\tfalse, true  },\n   { \"vsx-timode\",\t\tOPTION_MASK_VSX_TIMODE,\t\tfalse, true  },\n #ifdef OPTION_MASK_64BIT\n@@ -27798,6 +28010,8 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n   { \"frsqrtes\",\t\t RS6000_BTM_FRSQRTES,\tfalse, false },\n   { \"popcntd\",\t\t RS6000_BTM_POPCNTD,\tfalse, false },\n   { \"cell\",\t\t RS6000_BTM_CELL,\tfalse, false },\n+  { \"power8-vector\",\t RS6000_BTM_P8_VECTOR,\tfalse, false },\n+  { \"crypto\",\t\t RS6000_BTM_CRYPTO,\tfalse, false },\n };\n \n /* Option variables that we want to support inside attribute((target)) and"}, {"sha": "76f3bf9925057d2654bc173aaac8c9a7cf103c70", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -92,7 +92,7 @@\n #ifdef HAVE_AS_POWER8\n #define ASM_CPU_POWER8_SPEC \"-mpower8\"\n #else\n-#define ASM_CPU_POWER8_SPEC \"-mpower4 -maltivec\"\n+#define ASM_CPU_POWER8_SPEC ASM_CPU_POWER7_SPEC\n #endif\n \n #ifdef HAVE_AS_DCI\n@@ -164,6 +164,7 @@\n %{mcpu=e6500: -me6500} \\\n %{maltivec: -maltivec} \\\n %{mvsx: -mvsx %{!maltivec: -maltivec} %{!mcpu*: %(asm_cpu_power7)}} \\\n+%{mpower8-vector|mcrypto|mdirect-move: %{!mcpu*: %(asm_cpu_power8)}} \\\n -many\"\n \n #define CPP_DEFAULT_SPEC \"\"\n@@ -277,6 +278,19 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_POPCNTD 0\n #endif\n \n+/* Define the ISA 2.07 flags as 0 if the target assembler does not support the\n+   waitasecond instruction.  Allow -mpower8-fusion, since it does not add new\n+   instructions.  */\n+\n+#ifndef HAVE_AS_POWER8\n+#undef  TARGET_DIRECT_MOVE\n+#undef  TARGET_CRYPTO\n+#undef  TARGET_P8_VECTOR\n+#define TARGET_DIRECT_MOVE 0\n+#define TARGET_CRYPTO 0\n+#define TARGET_P8_VECTOR 0\n+#endif\n+\n /* Define TARGET_LWSYNC_INSTRUCTION if the assembler knows about lwsync.  If\n    not, generate the lwsync code as an integer constant.  */\n #ifdef HAVE_AS_LWSYNC\n@@ -386,6 +400,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_DEBUG_TARGET\t(rs6000_debug & MASK_DEBUG_TARGET)\n #define TARGET_DEBUG_BUILTIN\t(rs6000_debug & MASK_DEBUG_BUILTIN)\n \n+/* Describe the vector unit used for arithmetic operations.  */\n extern enum rs6000_vector rs6000_vector_unit[];\n \n #define VECTOR_UNIT_NONE_P(MODE)\t\t\t\\\n@@ -394,12 +409,25 @@ extern enum rs6000_vector rs6000_vector_unit[];\n #define VECTOR_UNIT_VSX_P(MODE)\t\t\t\t\\\n   (rs6000_vector_unit[(MODE)] == VECTOR_VSX)\n \n+#define VECTOR_UNIT_P8_VECTOR_P(MODE)\t\t\t\\\n+  (rs6000_vector_unit[(MODE)] == VECTOR_P8_VECTOR)\n+\n #define VECTOR_UNIT_ALTIVEC_P(MODE)\t\t\t\\\n   (rs6000_vector_unit[(MODE)] == VECTOR_ALTIVEC)\n \n+#define VECTOR_UNIT_VSX_OR_P8_VECTOR_P(MODE)\t\t\\\n+  (IN_RANGE ((int)rs6000_vector_unit[(MODE)],\t\t\\\n+\t     (int)VECTOR_VSX,\t\t\t\t\\\n+\t     (int)VECTOR_P8_VECTOR))\n+\n+/* VECTOR_UNIT_ALTIVEC_OR_VSX_P is used in places where we are using either\n+   altivec (VMX) or VSX vector instructions.  P8 vector support is upwards\n+   compatible, so allow it as well, rather than changing all of the uses of the\n+   macro.  */\n #define VECTOR_UNIT_ALTIVEC_OR_VSX_P(MODE)\t\t\\\n-  (rs6000_vector_unit[(MODE)] == VECTOR_ALTIVEC \t\\\n-   || rs6000_vector_unit[(MODE)] == VECTOR_VSX)\n+  (IN_RANGE ((int)rs6000_vector_unit[(MODE)],\t\t\\\n+\t     (int)VECTOR_ALTIVEC,\t\t\t\\\n+\t     (int)VECTOR_P8_VECTOR))\n \n /* Describe whether to use VSX loads or Altivec loads.  For now, just use the\n    same unit as the vector unit we are using, but we may want to migrate to\n@@ -412,12 +440,21 @@ extern enum rs6000_vector rs6000_vector_mem[];\n #define VECTOR_MEM_VSX_P(MODE)\t\t\t\t\\\n   (rs6000_vector_mem[(MODE)] == VECTOR_VSX)\n \n+#define VECTOR_MEM_P8_VECTOR_P(MODE)\t\t\t\\\n+  (rs6000_vector_mem[(MODE)] == VECTOR_VSX)\n+\n #define VECTOR_MEM_ALTIVEC_P(MODE)\t\t\t\\\n   (rs6000_vector_mem[(MODE)] == VECTOR_ALTIVEC)\n \n+#define VECTOR_MEM_VSX_OR_P8_VECTOR_P(MODE)\t\t\\\n+  (IN_RANGE ((int)rs6000_vector_mem[(MODE)],\t\t\\\n+\t     (int)VECTOR_VSX,\t\t\t\t\\\n+\t     (int)VECTOR_P8_VECTOR))\n+\n #define VECTOR_MEM_ALTIVEC_OR_VSX_P(MODE)\t\t\\\n-  (rs6000_vector_mem[(MODE)] == VECTOR_ALTIVEC \t\\\n-   || rs6000_vector_mem[(MODE)] == VECTOR_VSX)\n+  (IN_RANGE ((int)rs6000_vector_mem[(MODE)],\t\t\\\n+\t     (int)VECTOR_ALTIVEC,\t\t\t\\\n+\t     (int)VECTOR_P8_VECTOR))\n \n /* Return the alignment of a given vector type, which is set based on the\n    vector unit use.  VSX for instance can load 32 or 64 bit aligned words\n@@ -479,6 +516,15 @@ extern int rs6000_vector_align[];\n #define TARGET_FCTIDUZ\tTARGET_POPCNTD\n #define TARGET_FCTIWUZ\tTARGET_POPCNTD\n \n+#define TARGET_XSCVDPSPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n+#define TARGET_XSCVSPDPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n+\n+/* Byte/char syncs were added as phased in for ISA 2.06B, but are not present\n+   in power7, so conditionalize them on p8 features.  TImode syncs need quad\n+   memory support.  */\n+#define TARGET_SYNC_HI_QI\t(TARGET_QUAD_MEMORY || TARGET_DIRECT_MOVE)\n+#define TARGET_SYNC_TI\t\tTARGET_QUAD_MEMORY\n+\n /* Power7 has both 32-bit load and store integer for the FPRs, so we don't need\n    to allocate the SDmode stack slot to get the value into the proper location\n    in the register.  */\n@@ -489,17 +535,21 @@ extern int rs6000_vector_align[];\n    OPTION_MASK_<xxx> back into MASK_<xxx>.  */\n #define MASK_ALTIVEC\t\t\tOPTION_MASK_ALTIVEC\n #define MASK_CMPB\t\t\tOPTION_MASK_CMPB\n+#define MASK_CRYPTO\t\t\tOPTION_MASK_CRYPTO\n #define MASK_DFP\t\t\tOPTION_MASK_DFP\n+#define MASK_DIRECT_MOVE\t\tOPTION_MASK_DIRECT_MOVE\n #define MASK_DLMZB\t\t\tOPTION_MASK_DLMZB\n #define MASK_EABI\t\t\tOPTION_MASK_EABI\n #define MASK_FPRND\t\t\tOPTION_MASK_FPRND\n+#define MASK_P8_FUSION\t\t\tOPTION_MASK_P8_FUSION\n #define MASK_HARD_FLOAT\t\t\tOPTION_MASK_HARD_FLOAT\n #define MASK_ISEL\t\t\tOPTION_MASK_ISEL\n #define MASK_MFCRF\t\t\tOPTION_MASK_MFCRF\n #define MASK_MFPGPR\t\t\tOPTION_MASK_MFPGPR\n #define MASK_MULHW\t\t\tOPTION_MASK_MULHW\n #define MASK_MULTIPLE\t\t\tOPTION_MASK_MULTIPLE\n #define MASK_NO_UPDATE\t\t\tOPTION_MASK_NO_UPDATE\n+#define MASK_P8_VECTOR\t\t\tOPTION_MASK_P8_VECTOR\n #define MASK_POPCNTB\t\t\tOPTION_MASK_POPCNTB\n #define MASK_POPCNTD\t\t\tOPTION_MASK_POPCNTD\n #define MASK_PPC_GFXOPT\t\t\tOPTION_MASK_PPC_GFXOPT\n@@ -1002,7 +1052,9 @@ extern unsigned rs6000_pointer_size;\n \n #define REG_ALLOC_ORDER\t\t\t\t\t\t\\\n   {32,\t\t\t\t\t\t\t\t\\\n-   45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34,\t\t\\\n+   /* move fr13 (ie 45) later, so if we need TFmode, it does */\t\\\n+   /* not use fr14 which is a saved register.  */\t\t\\\n+   44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 45,\t\t\\\n    33,\t\t\t\t\t\t\t\t\\\n    63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,\t\t\\\n    50, 49, 48, 47, 46,\t\t\t\t\t\t\\\n@@ -1062,8 +1114,14 @@ extern unsigned rs6000_pointer_size;\n #define VINT_REGNO_P(N) ALTIVEC_REGNO_P (N)\n \n /* Alternate name for any vector register supporting logical operations, no\n-   matter which instruction set(s) are available.  */\n-#define VLOGICAL_REGNO_P(N) VFLOAT_REGNO_P (N)\n+   matter which instruction set(s) are available.  Under VSX, we allow GPRs as\n+   well as vector registers on 64-bit systems.  We don't allow 32-bit systems,\n+   due to the number of registers involved, and the number of instructions to\n+   load/store the values..  */\n+#define VLOGICAL_REGNO_P(N)\t\t\t\t\t\t\\\n+  (ALTIVEC_REGNO_P (N)\t\t\t\t\t\t\t\\\n+   || (TARGET_VSX && FP_REGNO_P (N))\t\t\t\t\t\\\n+   || (TARGET_VSX && TARGET_POWERPC64 && INT_REGNO_P (N)))\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.  */\n@@ -1124,7 +1182,7 @@ extern unsigned rs6000_pointer_size;\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n   (SCALAR_FLOAT_MODE_P (MODE1)\t\t\t\\\n    ? SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n    : SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n@@ -1137,14 +1195,14 @@ extern unsigned rs6000_pointer_size;\n    ? SPE_VECTOR_MODE (MODE2)\t\t\t\\\n    : SPE_VECTOR_MODE (MODE2)\t\t\t\\\n    ? SPE_VECTOR_MODE (MODE1)\t\t\t\\\n-   : ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n-   ? ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n-   : ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n-   ? ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n    : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n    ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n    : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n    ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n+   : ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n+   ? ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n+   : ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n+   ? ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n    : 1)\n \n /* Post-reload, we can't use any new AltiVec registers, as we already\n@@ -1337,8 +1395,11 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_wg,\t\t/* FPR register for -mmfpgpr */\n   RS6000_CONSTRAINT_wf,\t\t/* VSX register for V4SF */\n   RS6000_CONSTRAINT_wl,\t\t/* FPR register for LFIWAX */\n+  RS6000_CONSTRAINT_wm,\t\t/* VSX register for direct move */\n+  RS6000_CONSTRAINT_wr,\t\t/* GPR register if 64-bit  */\n   RS6000_CONSTRAINT_ws,\t\t/* VSX register for DF */\n   RS6000_CONSTRAINT_wt,\t\t/* VSX register for TImode */\n+  RS6000_CONSTRAINT_wv,\t\t/* Altivec register for power8 vector */\n   RS6000_CONSTRAINT_wx,\t\t/* FPR register for STFIWX */\n   RS6000_CONSTRAINT_wz,\t\t/* FPR register for LFIWZX */\n   RS6000_CONSTRAINT_MAX\n@@ -2372,6 +2433,8 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_ALWAYS\t0\t\t/* Always enabled.  */\n #define RS6000_BTM_ALTIVEC\tMASK_ALTIVEC\t/* VMX/altivec vectors.  */\n #define RS6000_BTM_VSX\t\tMASK_VSX\t/* VSX (vector/scalar).  */\n+#define RS6000_BTM_P8_VECTOR\tMASK_P8_VECTOR\t/* ISA 2.07 vector.  */\n+#define RS6000_BTM_CRYPTO\tMASK_CRYPTO\t/* crypto funcs.  */\n #define RS6000_BTM_SPE\t\tMASK_STRING\t/* E500 */\n #define RS6000_BTM_PAIRED\tMASK_MULHW\t/* 750CL paired insns.  */\n #define RS6000_BTM_FRE\t\tMASK_POPCNTB\t/* FRE instruction.  */\n@@ -2383,6 +2446,8 @@ extern int frame_pointer_needed;\n \n #define RS6000_BTM_COMMON\t(RS6000_BTM_ALTIVEC\t\t\t\\\n \t\t\t\t | RS6000_BTM_VSX\t\t\t\\\n+\t\t\t\t | RS6000_BTM_P8_VECTOR\t\t\t\\\n+\t\t\t\t | RS6000_BTM_CRYPTO\t\t\t\\\n \t\t\t\t | RS6000_BTM_FRE\t\t\t\\\n \t\t\t\t | RS6000_BTM_FRES\t\t\t\\\n \t\t\t\t | RS6000_BTM_FRSQRTE\t\t\t\\"}, {"sha": "013a0e38551f2d722844ac0e148b8639f0f24cf6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -146,7 +146,7 @@\n \f\n ;; Define an insn type attribute.  This is used in function unit delay\n ;; computations.\n-(define_attr \"type\" \"integer,two,three,load,load_ext,load_ext_u,load_ext_ux,load_ux,load_u,store,store_ux,store_u,fpload,fpload_ux,fpload_u,fpstore,fpstore_ux,fpstore_u,vecload,vecstore,imul,imul2,imul3,lmul,idiv,ldiv,insert_word,branch,cmp,fast_compare,compare,var_delayed_compare,delayed_compare,imul_compare,lmul_compare,fpcompare,cr_logical,delayed_cr,mfcr,mfcrf,mtcr,mfjmpr,mtjmpr,fp,fpsimple,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg,brinc,vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,vecfloat,vecfdiv,vecdouble,isync,sync,load_l,store_c,shift,trap,insert_dword,var_shift_rotate,cntlz,exts,mffgpr,mftgpr,isel,popcnt\"\n+(define_attr \"type\" \"integer,two,three,load,load_ext,load_ext_u,load_ext_ux,load_ux,load_u,store,store_ux,store_u,fpload,fpload_ux,fpload_u,fpstore,fpstore_ux,fpstore_u,vecload,vecstore,imul,imul2,imul3,lmul,idiv,ldiv,insert_word,branch,cmp,fast_compare,compare,var_delayed_compare,delayed_compare,imul_compare,lmul_compare,fpcompare,cr_logical,delayed_cr,mfcr,mfcrf,mtcr,mfjmpr,mtjmpr,fp,fpsimple,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg,brinc,vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,vecfloat,vecfdiv,vecdouble,isync,sync,load_l,store_c,shift,trap,insert_dword,var_shift_rotate,cntlz,exts,mffgpr,mftgpr,isel,popcnt,crypto\"\n   (const_string \"integer\"))\n \n ;; Define floating point instruction sub-types for use with Xfpu.md\n@@ -168,7 +168,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rs64a,mpccore,ppc403,ppc405,ppc440,ppc476,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,ppc8548,ppce300c2,ppce300c3,ppce500mc,ppce500mc64,ppce5500,ppce6500,power4,power5,power6,power7,cell,ppca2,titan\"\n+(define_attr \"cpu\" \"rs64a,mpccore,ppc403,ppc405,ppc440,ppc476,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,ppc8548,ppce300c2,ppce300c3,ppce500mc,ppce500mc64,ppce5500,ppce6500,power4,power5,power6,power7,cell,ppca2,titan,power8\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n \n@@ -14788,7 +14788,7 @@\n \t\t   (match_operand:P 2 \"gpc_reg_operand\" \"r\")] UNSPEC_BPERM))]\n   \"TARGET_POPCNTD\"\n   \"bpermd %0,%1,%2\"\n-  [(set_attr \"type\" \"integer\")])\n+  [(set_attr \"type\" \"popcnt\")])\n \n \f\n ;; Builtin fma support.  Handle \n@@ -14931,3 +14931,4 @@\n (include \"spe.md\")\n (include \"dfp.md\")\n (include \"paired.md\")\n+(include \"crypto.md\")"}, {"sha": "9a0781981306e93095cc28dba719108393393245", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -517,4 +517,28 @@ Control whether we save the TOC in the prologue for indirect calls or generate t\n \n mvsx-timode\n Target Undocumented Mask(VSX_TIMODE) Var(rs6000_isa_flags)\n-; Allow/disallow TImode in VSX registers\n+Allow 128-bit integers in VSX registers\n+\n+mpower8-fusion\n+Target Report Mask(P8_FUSION) Var(rs6000_isa_flags)\n+Fuse certain integer operations together for better performance on power8\n+\n+mpower8-fusion-sign\n+Target Undocumented Mask(P8_FUSION_SIGN) Var(rs6000_isa_flags)\n+Allow sign extension in fusion operations\n+\n+mpower8-vector\n+Target Report Mask(P8_VECTOR) Var(rs6000_isa_flags)\n+Use/do not use vector and scalar instructions added in ISA 2.07.\n+\n+mcrypto\n+Target Report Mask(CRYPTO) Var(rs6000_isa_flags)\n+Use ISA 2.07 crypto instructions\n+\n+mdirect-move\n+Target Report Mask(DIRECT_MOVE) Var(rs6000_isa_flags)\n+Use ISA 2.07 direct move between GPR & VSX register instructions\n+\n+mquad-memory\n+Target Report Mask(QUAD_MEMORY) Var(rs6000_isa_flags)\n+Generate the quad word memory instructions (lq/stq/lqarx/stqcx)."}, {"sha": "ecfdf0eee62c267e29717305f4039b5c7f6e1cc2", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -70,6 +70,7 @@ MD_INCLUDES = $(srcdir)/config/rs6000/rs64.md \\\n \t$(srcdir)/config/rs6000/vector.md \\\n \t$(srcdir)/config/rs6000/vsx.md \\\n \t$(srcdir)/config/rs6000/altivec.md \\\n+\t$(srcdir)/config/rs6000/crypto.md \\\n \t$(srcdir)/config/rs6000/spe.md \\\n \t$(srcdir)/config/rs6000/dfp.md \\\n \t$(srcdir)/config/rs6000/paired.md"}, {"sha": "5c5b4b44fd7f03d8c93236c65a2e866a910ef60a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -13937,6 +13937,66 @@ if the VSX instruction set is available.  The @samp{vec_vsx_ld} and\n @samp{vec_vsx_st} built-in functions always generate the VSX @samp{LXVD2X},\n @samp{LXVW4X}, @samp{STXVD2X}, and @samp{STXVW4X} instructions.\n \n+If the cryptographic instructions are enabled (@option{-mcrypto} or\n+@option{-mcpu=power8}), the following builtins are enabled.\n+\n+@smallexample\n+vector unsigned long long __builtin_crypto_vsbox (vector unsigned long long);\n+\n+vector unsigned long long __builtin_crypto_vcipher (vector unsigned long long,\n+                                                    vector unsigned long long);\n+\n+vector unsigned long long __builtin_crypto_vcipherlast\n+                                     (vector unsigned long long,\n+                                      vector unsigned long long);\n+\n+vector unsigned long long __builtin_crypto_vncipher (vector unsigned long long,\n+                                                     vector unsigned long long);\n+\n+vector unsigned long long __builtin_crypto_vncipherlast\n+                                     (vector unsigned long long,\n+                                      vector unsigned long long);\n+\n+vector unsigned char __builtin_crypto_vpermxor (vector unsigned char,\n+                                                vector unsigned char,\n+                                                vector unsigned char);\n+\n+vector unsigned short __builtin_crypto_vpermxor (vector unsigned short,\n+                                                 vector unsigned short,\n+                                                 vector unsigned short);\n+\n+vector unsigned int __builtin_crypto_vpermxor (vector unsigned int,\n+                                               vector unsigned int,\n+                                               vector unsigned int);\n+\n+vector unsigned long long __builtin_crypto_vpermxor (vector unsigned long long,\n+                                                     vector unsigned long long,\n+                                                     vector unsigned long long);\n+\n+vector unsigned char __builtin_crypto_vpmsumb (vector unsigned char,\n+                                               vector unsigned char);\n+\n+vector unsigned short __builtin_crypto_vpmsumb (vector unsigned short,\n+                                                vector unsigned short);\n+\n+vector unsigned int __builtin_crypto_vpmsumb (vector unsigned int,\n+                                              vector unsigned int);\n+\n+vector unsigned long long __builtin_crypto_vpmsumb (vector unsigned long long,\n+                                                    vector unsigned long long);\n+\n+vector unsigned long long __builtin_crypto_vshasigmad\n+                               (vector unsigned long long, int, int);\n+\n+vector unsigned int __builtin_crypto_vshasigmaw (vector unsigned int,\n+                                                 int, int);\n+@end smallexample\n+\n+The second argument to the @var{__builtin_crypto_vshasigmad} and\n+@var{__builtin_crypto_vshasigmaw} builtin functions must be a constant\n+integer that is 0 or 1.  The third argument to these builtin functions\n+must be a constant integer in the range of 0 to 15.\n+\n @node RX Built-in Functions\n @subsection RX Built-in Functions\n GCC supports some of the RX instructions which cannot be expressed in"}, {"sha": "5ca55d9e58b6c9f8daafda2387b1ddb2d3fd0868", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -860,7 +860,10 @@ See RS/6000 and PowerPC Options.\n -mno-recip-precision @gol\n -mveclibabi=@var{type} -mfriz -mno-friz @gol\n -mpointers-to-nested-functions -mno-pointers-to-nested-functions @gol\n--msave-toc-indirect -mno-save-toc-indirect}\n+-msave-toc-indirect -mno-save-toc-indirect @gol\n+-mpower8-fusion -mno-mpower8-fusion -mpower8-vector -mno-power8-vector @gol\n+-mcrypto -mno-crypto -mdirect-move -mno-direct-move @gol\n+-mquad-memory -mno-quad-memory}\n \n @emph{RX Options}\n @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n@@ -17341,7 +17344,8 @@ following options:\n @gccoptlist{-maltivec  -mfprnd  -mhard-float  -mmfcrf  -mmultiple @gol\n -mpopcntb -mpopcntd  -mpowerpc64 @gol\n -mpowerpc-gpopt  -mpowerpc-gfxopt  -msingle-float -mdouble-float @gol\n--msimple-fpu -mstring  -mmulhw  -mdlmzb  -mmfpgpr -mvsx}\n+-msimple-fpu -mstring  -mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol\n+-mcrypto -mdirect-move -mpower8-fusion -mpower8-vector -mquad-memory}\n \n The particular options set for any particular CPU varies between\n compiler versions, depending on what setting seems to produce optimal\n@@ -17459,6 +17463,47 @@ Generate code that uses (does not use) vector/scalar (VSX)\n instructions, and also enable the use of built-in functions that allow\n more direct access to the VSX instruction set.\n \n+@item -mcrypto\n+@itemx -mno-crypto\n+@opindex mcrypto\n+@opindex mno-crypto\n+Enable the use (disable) of the built-in functions that allow direct\n+access to the cryptographic instructions that were added in version\n+2.07 of the PowerPC ISA.\n+\n+@item -mdirect-move\n+@itemx -mno-direct-move\n+@opindex mdirect-move\n+@opindex mno-direct-move\n+Generate code that uses (does not use) the instructions to move data\n+between the general purpose registers and the vector/scalar (VSX)\n+registers that were added in version 2.07 of the PowerPC ISA.\n+\n+@item -mpower8-fusion\n+@itemx -mno-power8-fusion\n+@opindex mpower8-fusion\n+@opindex mno-power8-fusion\n+Generate code that keeps (does not keeps) some integer operations\n+adjacent so that the instructions can be fused together on power8 and\n+later processors.\n+\n+@item -mpower8-vector\n+@itemx -mno-power8-vector\n+@opindex mpower8-vector\n+@opindex mno-power8-vector\n+Generate code that uses (does not use) the vector and scalar\n+instructions that were added in version 2.07 of the PowerPC ISA.  Also\n+enable the use of built-in functions that allow more direct access to\n+the vector instructions.\n+\n+@item -mquad-memory\n+@itemx -mno-quad-memory\n+@opindex mquad-memory\n+@opindex mno-quad-memory\n+Generate code that uses (does not use) the quad word memory\n+instructions.  The @option{-mquad-memory} option requires use of\n+64-bit mode.\n+\n @item -mfloat-gprs=@var{yes/single/double/no}\n @itemx -mfloat-gprs\n @opindex mfloat-gprs"}, {"sha": "3d65a53c8920fac0521eed0a6fafb92d9f90ebe3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -2055,7 +2055,7 @@ Any constant whose absolute value is no greater than 4-bits.\n \n @end table\n \n-@item PowerPC and IBM RS6000---@file{config/rs6000/rs6000.h}\n+@item PowerPC and IBM RS6000---@file{config/rs6000/constraints.md}\n @table @code\n @item b\n Address base register\n@@ -2069,6 +2069,9 @@ Floating point register (containing 32-bit value)\n @item v\n Altivec vector register\n \n+@item wa\n+Any VSX register\n+\n @item wd\n VSX vector register to hold vector double data\n \n@@ -2081,6 +2084,15 @@ If @option{-mmfpgpr} was used, a floating point register\n @item wl\n If the LFIWAX instruction is enabled, a floating point register\n \n+@item wm\n+If direct moves are enabled, a VSX register.\n+\n+@item wn\n+No register.\n+\n+@item wr\n+General purpose register if 64-bit mode is used\n+\n @item ws\n VSX vector register to hold scalar float data\n \n@@ -2093,8 +2105,9 @@ If the STFIWX instruction is enabled, a floating point register\n @item wz\n If the LFIWZX instruction is enabled, a floating point register\n \n-@item wa\n-Any VSX register\n+@item wQ\n+A memory address that will work with the @code{lq} and @code{stq}\n+instructions.\n \n @item h\n @samp{MQ}, @samp{CTR}, or @samp{LINK} register"}, {"sha": "80c6b0bfa22ec6b361f70c5d2a3b346a23e9a686", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -1,3 +1,10 @@\n+2013-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen <pthaugen@us.ibm.com>\n+\t    Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/crypto-builtin-1.c: New file, test for power8\n+\tcrypto builtins.\n+\n 2013-05-22  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/57364"}, {"sha": "8fd4f079567bdea8b6d940e11165490402456f51", "filename": "gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcrypto-builtin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62511da91a80f2737bafb9ff984e88065a68ce2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcrypto-builtin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcrypto-builtin-1.c?ref=f62511da91a80f2737bafb9ff984e88065a68ce2", "patch": "@@ -0,0 +1,130 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model -fno-unroll-loops -fno-unroll-all-loops\" } */\n+\n+typedef vector unsigned long long\tcrypto_t;\n+typedef vector unsigned long long\tv2di_t;\n+typedef vector unsigned int\t\tv4si_t;\n+typedef vector unsigned short\t\tv8hi_t;\n+typedef vector unsigned char\t\tv16qi_t;\n+\n+crypto_t crpyto1 (crypto_t a)\n+{\n+  return __builtin_crypto_vsbox (a);\n+}\n+\n+crypto_t crypto2 (crypto_t a, crypto_t b)\n+{\n+  return __builtin_crypto_vcipher (a, b);\n+}\n+\n+crypto_t crypto3 (crypto_t a, crypto_t b)\n+{\n+  return __builtin_crypto_vcipherlast (a, b);\n+}\n+\n+crypto_t crypto4 (crypto_t a, crypto_t b)\n+{\n+  return __builtin_crypto_vncipher (a, b);\n+}\n+\n+crypto_t crypto5 (crypto_t a, crypto_t b)\n+{\n+  return __builtin_crypto_vncipherlast (a, b);\n+}\n+\n+v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)\n+{\n+  return __builtin_crypto_vpermxor (a, b, c);\n+}\n+\n+v8hi_t crypto6b (v8hi_t a, v8hi_t b, v8hi_t c)\n+{\n+  return __builtin_crypto_vpermxor (a, b, c);\n+}\n+\n+v4si_t crypto6c (v4si_t a, v4si_t b, v4si_t c)\n+{\n+  return __builtin_crypto_vpermxor (a, b, c);\n+}\n+\n+v2di_t crypto6d (v2di_t a, v2di_t b, v2di_t c)\n+{\n+  return __builtin_crypto_vpermxor (a, b, c);\n+}\n+\n+v16qi_t crypto7a (v16qi_t a, v16qi_t b)\n+{\n+  return __builtin_crypto_vpmsumb (a, b);\n+}\n+\n+v16qi_t crypto7b (v16qi_t a, v16qi_t b)\n+{\n+  return __builtin_crypto_vpmsum (a, b);\n+}\n+\n+v8hi_t crypto7c (v8hi_t a, v8hi_t b)\n+{\n+  return __builtin_crypto_vpmsumh (a, b);\n+}\n+\n+v8hi_t crypto7d (v8hi_t a, v8hi_t b)\n+{\n+  return __builtin_crypto_vpmsum (a, b);\n+}\n+\n+v4si_t crypto7e (v4si_t a, v4si_t b)\n+{\n+  return __builtin_crypto_vpmsumw (a, b);\n+}\n+\n+v4si_t crypto7f (v4si_t a, v4si_t b)\n+{\n+  return __builtin_crypto_vpmsum (a, b);\n+}\n+\n+v2di_t crypto7g (v2di_t a, v2di_t b)\n+{\n+  return __builtin_crypto_vpmsumd (a, b);\n+}\n+\n+v2di_t crypto7h (v2di_t a, v2di_t b)\n+{\n+  return __builtin_crypto_vpmsum (a, b);\n+}\n+\n+v2di_t crypto8a (v2di_t a)\n+{\n+  return __builtin_crypto_vshasigmad (a, 0, 8);\n+}\n+\n+v2di_t crypto8b (v2di_t a)\n+{\n+  return __builtin_crypto_vshasigma (a, 0, 8);\n+}\n+\n+v4si_t crypto8c (v4si_t a)\n+{\n+  return __builtin_crypto_vshasigmaw (a, 1, 15);\n+}\n+\n+v4si_t crypto8d (v4si_t a)\n+{\n+  return __builtin_crypto_vshasigma (a, 1, 15);\n+}\n+\n+/* Note space is used after the instruction so that vcipherlast does not match\n+   vcipher.  */\n+/* { dg-final { scan-assembler-times \"vcipher \"      1 } } */\n+/* { dg-final { scan-assembler-times \"vcipherlast \"  1 } } */\n+/* { dg-final { scan-assembler-times \"vncipher \"     1 } } */\n+/* { dg-final { scan-assembler-times \"vncipherlast \" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpermxor \"     4 } } */\n+/* { dg-final { scan-assembler-times \"vpmsumb \"      2 } } */\n+/* { dg-final { scan-assembler-times \"vpmsumd \"      2 } } */\n+/* { dg-final { scan-assembler-times \"vpmsumh \"      2 } } */\n+/* { dg-final { scan-assembler-times \"vpmsumw \"      2 } } */\n+/* { dg-final { scan-assembler-times \"vsbox \"        1 } } */\n+/* { dg-final { scan-assembler-times \"vshasigmad \"   2 } } */\n+/* { dg-final { scan-assembler-times \"vshasigmaw \"   2 } } */"}]}