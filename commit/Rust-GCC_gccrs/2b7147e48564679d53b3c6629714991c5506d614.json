{"sha": "2b7147e48564679d53b3c6629714991c5506d614", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI3MTQ3ZTQ4NTY0Njc5ZDUzYjNjNjYyOTcxNDk5MWM1NTA2ZDYxNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-16T14:14:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-16T14:19:48Z"}, "message": "c++: Break out actual instantiation from instantiate_decl\n\nThis refactors instantiate_decl, breaking out the actual instantiation\nwork to instantiate_body.  That'll allow me to address the OMP UDR\nissue, but it also means we have slightly neater code in\ninstantiate_decl anyway.\n\n\tgcc/cp/\n\t* pt.c (instantiate_body): New, broken out of ..\n\t(instantiate_decl): ... here.  Call it.", "tree": {"sha": "c8384909fae9d6821f829dbe44359a47675bbdb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8384909fae9d6821f829dbe44359a47675bbdb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b7147e48564679d53b3c6629714991c5506d614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b7147e48564679d53b3c6629714991c5506d614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b7147e48564679d53b3c6629714991c5506d614", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b7147e48564679d53b3c6629714991c5506d614/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "052204fac580b21c967e57e6285d99a9828b8fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/052204fac580b21c967e57e6285d99a9828b8fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/052204fac580b21c967e57e6285d99a9828b8fac"}], "stats": {"total": 305, "additions": 157, "deletions": 148}, "files": [{"sha": "e8aa950b8fa704dc7bb76f007e66ff9b5cec3809", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 157, "deletions": 148, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7147e48564679d53b3c6629714991c5506d614/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7147e48564679d53b3c6629714991c5506d614/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2b7147e48564679d53b3c6629714991c5506d614", "patch": "@@ -25447,6 +25447,158 @@ register_parameter_specializations (tree pattern, tree inst)\n   gcc_assert (!spec_parm);\n }\n \n+/* Instantiate the body of D using PATTERN with ARGS.  We have\n+   already determined PATTERN is the correct template to use.  */\n+\n+static void\n+instantiate_body (tree pattern, tree args, tree d)\n+{\n+  gcc_checking_assert (TREE_CODE (pattern) == TEMPLATE_DECL);\n+  \n+  tree td = pattern;\n+  tree code_pattern = DECL_TEMPLATE_RESULT (td);\n+\n+  tree fn_context = decl_function_context (d);\n+  if (LAMBDA_FUNCTION_P (d))\n+    /* tsubst_lambda_expr resolved any references to enclosing functions.  */\n+    fn_context = NULL_TREE;\n+  bool nested = current_function_decl != NULL_TREE;\n+  bool push_to_top = !(nested && fn_context == current_function_decl);\n+\n+  vec<tree> omp_privatization_save;\n+  if (nested)\n+    save_omp_privatization_clauses (omp_privatization_save);\n+\n+  if (push_to_top)\n+    push_to_top_level ();\n+  else\n+    {\n+      gcc_assert (!processing_template_decl);\n+      push_function_context ();\n+      cp_unevaluated_operand = 0;\n+      c_inhibit_evaluation_warnings = 0;\n+    }\n+\n+  if (VAR_P (d))\n+    {\n+      /* The variable might be a lambda's extra scope, and that\n+\t lambda's visibility depends on D's.  */\n+      maybe_commonize_var (d);\n+      determine_visibility (d);\n+    }\n+\n+  /* Mark D as instantiated so that recursive calls to\n+     instantiate_decl do not try to instantiate it again.  */\n+  DECL_TEMPLATE_INSTANTIATED (d) = 1;\n+\n+  /* Regenerate the declaration in case the template has been modified\n+     by a subsequent redeclaration.  */\n+  regenerate_decl_from_template (d, td, args);\n+\n+  /* We already set the file and line above.  Reset them now in case\n+     they changed as a result of calling regenerate_decl_from_template.  */\n+  input_location = DECL_SOURCE_LOCATION (d);\n+\n+  if (VAR_P (d))\n+    {\n+      tree init;\n+      bool const_init = false;\n+\n+      /* Clear out DECL_RTL; whatever was there before may not be right\n+\t since we've reset the type of the declaration.  */\n+      SET_DECL_RTL (d, NULL);\n+      DECL_IN_AGGR_P (d) = 0;\n+\n+      /* The initializer is placed in DECL_INITIAL by\n+\t regenerate_decl_from_template so we don't need to\n+\t push/pop_access_scope again here.  Pull it out so that\n+\t cp_finish_decl can process it.  */\n+      init = DECL_INITIAL (d);\n+      DECL_INITIAL (d) = NULL_TREE;\n+      DECL_INITIALIZED_P (d) = 0;\n+\n+      /* Clear DECL_EXTERNAL so that cp_finish_decl will process the\n+\t initializer.  That function will defer actual emission until\n+\t we have a chance to determine linkage.  */\n+      DECL_EXTERNAL (d) = 0;\n+\n+      /* Enter the scope of D so that access-checking works correctly.  */\n+      bool enter_context = DECL_CLASS_SCOPE_P (d);\n+      if (enter_context)\n+        push_nested_class (DECL_CONTEXT (d));\n+\n+      const_init = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (code_pattern);\n+      cp_finish_decl (d, init, const_init, NULL_TREE, 0);\n+\n+      if (enter_context)\n+        pop_nested_class ();\n+    }\n+  else if (TREE_CODE (d) == FUNCTION_DECL && DECL_DEFAULTED_FN (code_pattern))\n+    synthesize_method (d);\n+  else if (TREE_CODE (d) == FUNCTION_DECL)\n+    {\n+      /* Set up the list of local specializations.  */\n+      local_specialization_stack lss (push_to_top ? lss_blank : lss_copy);\n+      tree block = NULL_TREE;\n+\n+      /* Set up context.  */\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern)\n+\t  && TREE_CODE (DECL_CONTEXT (code_pattern)) == FUNCTION_DECL)\n+\tblock = push_stmt_list ();\n+      else\n+\tstart_preparsed_function (d, NULL_TREE, SF_PRE_PARSED);\n+\n+      perform_instantiation_time_access_checks (code_pattern, args);\n+\n+      /* Create substitution entries for the parameters.  */\n+      register_parameter_specializations (code_pattern, d);\n+\n+      /* Substitute into the body of the function.  */\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern))\n+\ttsubst_omp_udr (DECL_SAVED_TREE (code_pattern), args,\n+\t\t\ttf_warning_or_error, DECL_TI_TEMPLATE (d));\n+      else\n+\t{\n+\t  tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n+\t\t       tf_warning_or_error, DECL_TI_TEMPLATE (d),\n+\t\t       /*integral_constant_expression_p=*/false);\n+\n+\t  /* Set the current input_location to the end of the function\n+\t     so that finish_function knows where we are.  */\n+\t  input_location\n+\t    = DECL_STRUCT_FUNCTION (code_pattern)->function_end_locus;\n+\n+\t  /* Remember if we saw an infinite loop in the template.  */\n+\t  current_function_infinite_loop\n+\t    = DECL_STRUCT_FUNCTION (code_pattern)->language->infinite_loop;\n+\t}\n+\n+      /* Finish the function.  */\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern)\n+\t  && TREE_CODE (DECL_CONTEXT (code_pattern)) == FUNCTION_DECL)\n+\tDECL_SAVED_TREE (d) = pop_stmt_list (block);\n+      else\n+\t{\n+\t  d = finish_function (/*inline_p=*/false);\n+\t  expand_or_defer_fn (d);\n+\t}\n+\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern))\n+\tcp_check_omp_declare_reduction (d);\n+    }\n+\n+  /* We're not deferring instantiation any more.  */\n+  TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (d)) = 0;\n+\n+  if (push_to_top)\n+    pop_from_top_level ();\n+  else\n+    pop_function_context ();\n+\n+  if (nested)\n+    restore_omp_privatization_clauses (omp_privatization_save);\n+}\n+\n /* Produce the definition of D, a _DECL generated from a template.  If\n    DEFER_OK is true, then we don't have to actually do the\n    instantiation now; we just have to do it sometime.  Normally it is\n@@ -25684,162 +25836,19 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n       /* If we're in unevaluated context, we just wanted to get the\n \t constant value; this isn't an odr use, so don't queue\n \t a full instantiation.  */\n-      if (cp_unevaluated_operand != 0)\n-\tgoto out;\n-      /* ??? Historically, we have instantiated inline functions, even\n-\t when marked as \"extern template\".  */\n-      if (!(external_p && VAR_P (d)))\n+      if (!cp_unevaluated_operand\n+\t  /* ??? Historically, we have instantiated inline functions, even\n+\t     when marked as \"extern template\".  */\n+\t  && !(external_p && VAR_P (d)))\n \tadd_pending_template (d);\n-      goto out;\n     }\n-\n-  bool push_to_top, nested;\n-  tree fn_context;\n-  fn_context = decl_function_context (d);\n-  if (LAMBDA_FUNCTION_P (d))\n-    /* tsubst_lambda_expr resolved any references to enclosing functions.  */\n-    fn_context = NULL_TREE;\n-  nested = current_function_decl != NULL_TREE;\n-  push_to_top = !(nested && fn_context == current_function_decl);\n-\n-  vec<tree> omp_privatization_save;\n-  if (nested)\n-    save_omp_privatization_clauses (omp_privatization_save);\n-\n-  if (push_to_top)\n-    push_to_top_level ();\n   else\n     {\n-      gcc_assert (!processing_template_decl);\n-      push_function_context ();\n-      cp_unevaluated_operand = 0;\n-      c_inhibit_evaluation_warnings = 0;\n-    }\n-\n-  if (VAR_P (d))\n-    {\n-      /* The variable might be a lambda's extra scope, and that\n-\t lambda's visibility depends on D's.  */\n-      maybe_commonize_var (d);\n-      determine_visibility (d);\n-    }\n-\n-  /* Mark D as instantiated so that recursive calls to\n-     instantiate_decl do not try to instantiate it again.  */\n-  DECL_TEMPLATE_INSTANTIATED (d) = 1;\n-\n-  /* Regenerate the declaration in case the template has been modified\n-     by a subsequent redeclaration.  */\n-  regenerate_decl_from_template (d, td, args);\n-\n-  /* We already set the file and line above.  Reset them now in case\n-     they changed as a result of calling regenerate_decl_from_template.  */\n-  input_location = DECL_SOURCE_LOCATION (d);\n-\n-  if (VAR_P (d))\n-    {\n-      tree init;\n-      bool const_init = false;\n-\n-      /* Clear out DECL_RTL; whatever was there before may not be right\n-\t since we've reset the type of the declaration.  */\n-      SET_DECL_RTL (d, NULL);\n-      DECL_IN_AGGR_P (d) = 0;\n-\n-      /* The initializer is placed in DECL_INITIAL by\n-\t regenerate_decl_from_template so we don't need to\n-\t push/pop_access_scope again here.  Pull it out so that\n-\t cp_finish_decl can process it.  */\n-      init = DECL_INITIAL (d);\n-      DECL_INITIAL (d) = NULL_TREE;\n-      DECL_INITIALIZED_P (d) = 0;\n-\n-      /* Clear DECL_EXTERNAL so that cp_finish_decl will process the\n-\t initializer.  That function will defer actual emission until\n-\t we have a chance to determine linkage.  */\n-      DECL_EXTERNAL (d) = 0;\n-\n-      /* Enter the scope of D so that access-checking works correctly.  */\n-      bool enter_context = DECL_CLASS_SCOPE_P (d);\n-      if (enter_context)\n-        push_nested_class (DECL_CONTEXT (d));\n-\n-      const_init = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (code_pattern);\n-      cp_finish_decl (d, init, const_init, NULL_TREE, 0);\n-\n-      if (enter_context)\n-        pop_nested_class ();\n-\n       if (variable_template_p (gen_tmpl))\n \tnote_variable_template_instantiation (d);\n-    }\n-  else if (TREE_CODE (d) == FUNCTION_DECL && DECL_DEFAULTED_FN (code_pattern))\n-    synthesize_method (d);\n-  else if (TREE_CODE (d) == FUNCTION_DECL)\n-    {\n-      /* Set up the list of local specializations.  */\n-      local_specialization_stack lss (push_to_top ? lss_blank : lss_copy);\n-      tree block = NULL_TREE;\n-\n-      /* Set up context.  */\n-      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern)\n-\t  && TREE_CODE (DECL_CONTEXT (code_pattern)) == FUNCTION_DECL)\n-\tblock = push_stmt_list ();\n-      else\n-\tstart_preparsed_function (d, NULL_TREE, SF_PRE_PARSED);\n-\n-      perform_instantiation_time_access_checks (DECL_TEMPLATE_RESULT (td),\n-\t\t\t\t\t\targs);\n-\n-      /* Create substitution entries for the parameters.  */\n-      register_parameter_specializations (code_pattern, d);\n-\n-      /* Substitute into the body of the function.  */\n-      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern))\n-\ttsubst_omp_udr (DECL_SAVED_TREE (code_pattern), args,\n-\t\t\ttf_warning_or_error, tmpl);\n-      else\n-\t{\n-\t  tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n-\t\t       tf_warning_or_error, tmpl,\n-\t\t       /*integral_constant_expression_p=*/false);\n-\n-\t  /* Set the current input_location to the end of the function\n-\t     so that finish_function knows where we are.  */\n-\t  input_location\n-\t    = DECL_STRUCT_FUNCTION (code_pattern)->function_end_locus;\n-\n-\t  /* Remember if we saw an infinite loop in the template.  */\n-\t  current_function_infinite_loop\n-\t    = DECL_STRUCT_FUNCTION (code_pattern)->language->infinite_loop;\n-\t}\n-\n-      /* Finish the function.  */\n-      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern)\n-\t  && TREE_CODE (DECL_CONTEXT (code_pattern)) == FUNCTION_DECL)\n-\tDECL_SAVED_TREE (d) = pop_stmt_list (block);\n-      else\n-\t{\n-\t  d = finish_function (/*inline_p=*/false);\n-\t  expand_or_defer_fn (d);\n-\t}\n-\n-      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern))\n-\tcp_check_omp_declare_reduction (d);\n+      instantiate_body (td, args, d);\n     }\n \n-  /* We're not deferring instantiation any more.  */\n-  TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (d)) = 0;\n-\n-  if (push_to_top)\n-    pop_from_top_level ();\n-  else\n-    pop_function_context ();\n-\n-  if (nested)\n-    restore_omp_privatization_clauses (omp_privatization_save);\n-\n-out:\n   pop_deferring_access_checks ();\n   timevar_pop (TV_TEMPLATE_INST);\n   pop_tinst_level ();"}]}