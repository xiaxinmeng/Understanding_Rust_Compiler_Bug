{"sha": "539ca5ec98443a3140523337f1dc131fd709f17a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5Y2E1ZWM5ODQ0M2EzMTQwNTIzMzM3ZjFkYzEzMWZkNzA5ZjE3YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:17:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:17:17Z"}, "message": "[multiple changes]\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): In GNATprove\n\tmode, collect inherited class-wide conditions to generate the\n\tcorresponding pragmas.\n\t* sem_prag.ads (Build_Pragma_Check_Equivalent): Moved from contracts\n\t* contracts.adb (Collect_Inherited_Class_Wide_Conditions): New\n\tprocedure for overriding subprograms, used to generate the pragmas\n\tcorresponding to an inherited class- wide pre- or postcondition.\n\t* sem_prag.adb (Build_Pragma_Check_Equivalent): moved here\n\tfrom contracts.adb (Replace_Condition_Entities): Subsidiary\n\tBuild_Pragma_Check_Equivalent, to implement the proper semantics\n\tof inherited class-wide conditions, as given in AI12-0113.\n\t(Process_Class_Wide_Condition): Removed.\n\t(Collect_Inherited_Class_Wide_Conditions): Iterate over pragmas\n\tin contract of subprogram, to collect inherited class-wide\n\tconditions.\n\t(Build_Pragma_Check_Equivalent): Moved to sem_prag.adb\n\n2016-04-18  Yannick Moy  <moy@adacore.com>\n\n\t* a-calend.adb (Ada.Calendar): Mark package body as SPARK_Mode Off.\n\t* a-calend.ads (Ada.Calendar): Mark package spec as\n\tSPARK_Mode and add synchronous external abstract state Clock_Time.\n\nFrom-SVN: r235113", "tree": {"sha": "207360cf2657a7089f40a548444d592842c182af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/207360cf2657a7089f40a548444d592842c182af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/539ca5ec98443a3140523337f1dc131fd709f17a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539ca5ec98443a3140523337f1dc131fd709f17a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539ca5ec98443a3140523337f1dc131fd709f17a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539ca5ec98443a3140523337f1dc131fd709f17a/comments", "author": null, "committer": null, "parents": [{"sha": "fd22e260b5d48a245411c09858fa42b1614a89c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd22e260b5d48a245411c09858fa42b1614a89c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd22e260b5d48a245411c09858fa42b1614a89c7"}], "stats": {"total": 732, "additions": 418, "deletions": 314}, "files": [{"sha": "3e329a87b494f7248c2399354af2a255457e05c0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=539ca5ec98443a3140523337f1dc131fd709f17a", "patch": "@@ -1,3 +1,28 @@\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): In GNATprove\n+\tmode, collect inherited class-wide conditions to generate the\n+\tcorresponding pragmas.\n+\t* sem_prag.ads (Build_Pragma_Check_Equivalent): Moved from contracts\n+\t* contracts.adb (Collect_Inherited_Class_Wide_Conditions): New\n+\tprocedure for overriding subprograms, used to generate the pragmas\n+\tcorresponding to an inherited class- wide pre- or postcondition.\n+\t* sem_prag.adb (Build_Pragma_Check_Equivalent): moved here\n+\tfrom contracts.adb (Replace_Condition_Entities): Subsidiary\n+\tBuild_Pragma_Check_Equivalent, to implement the proper semantics\n+\tof inherited class-wide conditions, as given in AI12-0113.\n+\t(Process_Class_Wide_Condition): Removed.\n+\t(Collect_Inherited_Class_Wide_Conditions): Iterate over pragmas\n+\tin contract of subprogram, to collect inherited class-wide\n+\tconditions.\n+\t(Build_Pragma_Check_Equivalent): Moved to sem_prag.adb\n+\n+2016-04-18  Yannick Moy  <moy@adacore.com>\n+\n+\t* a-calend.adb (Ada.Calendar): Mark package body as SPARK_Mode Off.\n+\t* a-calend.ads (Ada.Calendar): Mark package spec as\n+\tSPARK_Mode and add synchronous external abstract state Clock_Time.\n+\n 2016-04-18  Yannick Moy  <moy@adacore.com>\n \n \t* sem_res.adb (Resolve_Call): Prevent inlining of"}, {"sha": "f5076f23277f276ff2201c4f7e7a14059812d3fc", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=539ca5ec98443a3140523337f1dc131fd709f17a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,7 +35,9 @@ with Interfaces.C;\n \n with System.OS_Primitives;\n \n-package body Ada.Calendar is\n+package body Ada.Calendar with\n+  SPARK_Mode => Off\n+is\n \n    --------------------------\n    -- Implementation Notes --"}, {"sha": "0eed8badf49aa3017730b066592c7516e25d048c", "filename": "gcc/ada/a-calend.ads", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=539ca5ec98443a3140523337f1dc131fd709f17a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -33,7 +33,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package Ada.Calendar is\n+package Ada.Calendar with\n+  SPARK_Mode,\n+  Abstract_State => (Clock_Time with Synchronous,\n+                                     External => (Async_Readers,\n+                                                  Async_Writers))\n+is\n \n    type Time is private;\n \n@@ -49,7 +54,9 @@ package Ada.Calendar is\n \n    subtype Day_Duration is Duration range 0.0 .. 86_400.0;\n \n-   function Clock return Time;\n+   function Clock return Time with\n+     Volatile_Function,\n+     Global => Clock_Time;\n    --  The returned time value is the number of nanoseconds since the start\n    --  of Ada time (1901-01-01 00:00:00.0 UTC). If leap seconds are enabled,\n    --  the result will contain all elapsed leap seconds since the start of\n@@ -108,6 +115,10 @@ package Ada.Calendar is\n    Time_Error : exception;\n \n private\n+   --  Mark private part as SPARK_Mode Off to avoid accounting for variable\n+   --  Invalid_Time_Zone_Offset in abstract state.\n+   pragma SPARK_Mode (Off);\n+\n    pragma Inline (Clock);\n \n    pragma Inline (Year);"}, {"sha": "4eb6d26adbad59009e0b781807d5e39df9b5fbeb", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=539ca5ec98443a3140523337f1dc131fd709f17a", "patch": "@@ -1432,15 +1432,6 @@ package body Contracts is\n       --  of statements to be checked on exit. Parameter Result is the entity\n       --  of parameter _Result when Subp_Id denotes a function.\n \n-      function Build_Pragma_Check_Equivalent\n-        (Prag     : Node_Id;\n-         Subp_Id  : Entity_Id := Empty;\n-         Inher_Id : Entity_Id := Empty) return Node_Id;\n-      --  Transform a [refined] pre- or postcondition denoted by Prag into an\n-      --  equivalent pragma Check. When the pre- or postcondition is inherited,\n-      --  the routine corrects the references of all formals of Inher_Id to\n-      --  point to the formals of Subp_Id.\n-\n       procedure Process_Contract_Cases (Stmts : in out List_Id);\n       --  Process pragma Contract_Cases. This routine prepends items to the\n       --  body declarations and appends items to list Stmts.\n@@ -1860,155 +1851,6 @@ package body Contracts is\n          Analyze (Proc_Bod);\n       end Build_Postconditions_Procedure;\n \n-      -----------------------------------\n-      -- Build_Pragma_Check_Equivalent --\n-      -----------------------------------\n-\n-      function Build_Pragma_Check_Equivalent\n-        (Prag     : Node_Id;\n-         Subp_Id  : Entity_Id := Empty;\n-         Inher_Id : Entity_Id := Empty) return Node_Id\n-      is\n-         function Suppress_Reference (N : Node_Id) return Traverse_Result;\n-         --  Detect whether node N references a formal parameter subject to\n-         --  pragma Unreferenced. If this is the case, set Comes_From_Source\n-         --  to False to suppress the generation of a reference when analyzing\n-         --  N later on.\n-\n-         ------------------------\n-         -- Suppress_Reference --\n-         ------------------------\n-\n-         function Suppress_Reference (N : Node_Id) return Traverse_Result is\n-            Formal : Entity_Id;\n-\n-         begin\n-            if Is_Entity_Name (N) and then Present (Entity (N)) then\n-               Formal := Entity (N);\n-\n-               --  The formal parameter is subject to pragma Unreferenced.\n-               --  Prevent the generation of a reference by resetting the\n-               --  Comes_From_Source flag.\n-\n-               if Is_Formal (Formal)\n-                 and then Has_Pragma_Unreferenced (Formal)\n-               then\n-                  Set_Comes_From_Source (N, False);\n-               end if;\n-            end if;\n-\n-            return OK;\n-         end Suppress_Reference;\n-\n-         procedure Suppress_References is\n-           new Traverse_Proc (Suppress_Reference);\n-\n-         --  Local variables\n-\n-         Loc          : constant Source_Ptr := Sloc (Prag);\n-         Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n-         Check_Prag   : Node_Id;\n-         Formals_Map  : Elist_Id;\n-         Inher_Formal : Entity_Id;\n-         Msg_Arg      : Node_Id;\n-         Nam          : Name_Id;\n-         Subp_Formal  : Entity_Id;\n-\n-      --  Start of processing for Build_Pragma_Check_Equivalent\n-\n-      begin\n-         Formals_Map := No_Elist;\n-\n-         --  When the pre- or postcondition is inherited, map the formals of\n-         --  the inherited subprogram to those of the current subprogram.\n-\n-         if Present (Inher_Id) then\n-            pragma Assert (Present (Subp_Id));\n-\n-            Formals_Map := New_Elmt_List;\n-\n-            --  Create a relation <inherited formal> => <subprogram formal>\n-\n-            Inher_Formal := First_Formal (Inher_Id);\n-            Subp_Formal  := First_Formal (Subp_Id);\n-            while Present (Inher_Formal) and then Present (Subp_Formal) loop\n-               Append_Elmt (Inher_Formal, Formals_Map);\n-               Append_Elmt (Subp_Formal, Formals_Map);\n-\n-               Next_Formal (Inher_Formal);\n-               Next_Formal (Subp_Formal);\n-            end loop;\n-         end if;\n-\n-         --  Copy the original pragma while performing substitutions (if\n-         --  applicable).\n-\n-         Check_Prag :=\n-           New_Copy_Tree\n-             (Source    => Prag,\n-              Map       => Formals_Map,\n-              New_Scope => Current_Scope);\n-\n-         --  Mark the pragma as being internally generated and reset the\n-         --  Analyzed flag.\n-\n-         Set_Analyzed          (Check_Prag, False);\n-         Set_Comes_From_Source (Check_Prag, False);\n-\n-         --  The tree of the original pragma may contain references to the\n-         --  formal parameters of the related subprogram. At the same time\n-         --  the corresponding body may mark the formals as unreferenced:\n-\n-         --     procedure Proc (Formal : ...)\n-         --       with Pre => Formal ...;\n-\n-         --     procedure Proc (Formal : ...) is\n-         --        pragma Unreferenced (Formal);\n-         --     ...\n-\n-         --  This creates problems because all pragma Check equivalents are\n-         --  analyzed at the end of the body declarations. Since all source\n-         --  references have already been accounted for, reset any references\n-         --  to such formals in the generated pragma Check equivalent.\n-\n-         Suppress_References (Check_Prag);\n-\n-         if Present (Corresponding_Aspect (Prag)) then\n-            Nam := Chars (Identifier (Corresponding_Aspect (Prag)));\n-         else\n-            Nam := Prag_Nam;\n-         end if;\n-\n-         --  Convert the copy into pragma Check by correcting the name and\n-         --  adding a check_kind argument.\n-\n-         Set_Pragma_Identifier\n-           (Check_Prag, Make_Identifier (Loc, Name_Check));\n-\n-         Prepend_To (Pragma_Argument_Associations (Check_Prag),\n-           Make_Pragma_Argument_Association (Loc,\n-             Expression => Make_Identifier (Loc, Nam)));\n-\n-         --  Update the error message when the pragma is inherited\n-\n-         if Present (Inher_Id) then\n-            Msg_Arg := Last (Pragma_Argument_Associations (Check_Prag));\n-\n-            if Chars (Msg_Arg) = Name_Message then\n-               String_To_Name_Buffer (Strval (Expression (Msg_Arg)));\n-\n-               --  Insert \"inherited\" to improve the error message\n-\n-               if Name_Buffer (1 .. 8) = \"failed p\" then\n-                  Insert_Str_In_Name_Buffer (\"inherited \", 8);\n-                  Set_Strval (Expression (Msg_Arg), String_From_Name_Buffer);\n-               end if;\n-            end if;\n-         end if;\n-\n-         return Check_Prag;\n-      end Build_Pragma_Check_Equivalent;\n-\n       ----------------------------\n       -- Process_Contract_Cases --\n       ----------------------------"}, {"sha": "c1e57471c793ecc9e9d6fbec45b65e0ae7995b4a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=539ca5ec98443a3140523337f1dc131fd709f17a", "patch": "@@ -3754,6 +3754,17 @@ package body Sem_Ch6 is\n          Build_Body_To_Inline (N, Spec_Id);\n       end if;\n \n+      --  When generating code, inherited pre/postconditions are handled\n+      --  when expanding the corresponding contract. If GNATprove mode we\n+      --  must process them when the body is analyzed.\n+\n+      if GNATprove_Mode\n+        and then Present (Spec_Id)\n+        and then Present (Overridden_Operation (Spec_Id))\n+      then\n+         Collect_Inherited_Class_Wide_Conditions (Spec_Id, N);\n+      end if;\n+\n       --  Ada 2005 (AI-262): In library subprogram bodies, after the analysis\n       --  of the specification we have to install the private withed units.\n       --  This holds for child units as well."}, {"sha": "01f498847bfd2efa42c363b88bc58ad850e43462", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 347, "deletions": 151, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=539ca5ec98443a3140523337f1dc131fd709f17a", "patch": "@@ -23141,151 +23141,6 @@ package body Sem_Prag is\n      (N         : Node_Id;\n       Freeze_Id : Entity_Id := Empty)\n    is\n-      procedure Process_Class_Wide_Condition\n-        (Expr      : Node_Id;\n-         Spec_Id   : Entity_Id;\n-         Subp_Decl : Node_Id);\n-      --  Replace the type of all references to the controlling formal of\n-      --  subprogram Spec_Id found in expression Expr with the corresponding\n-      --  class-wide type. Subp_Decl is the subprogram [body] declaration\n-      --  where the pragma resides.\n-\n-      ----------------------------------\n-      -- Process_Class_Wide_Condition --\n-      ----------------------------------\n-\n-      procedure Process_Class_Wide_Condition\n-        (Expr      : Node_Id;\n-         Spec_Id   : Entity_Id;\n-         Subp_Decl : Node_Id)\n-      is\n-         Disp_Typ : constant Entity_Id := Find_Dispatching_Type (Spec_Id);\n-\n-         ACW : Entity_Id := Empty;\n-         --  Access to Disp_Typ'Class, created if there is a controlling formal\n-         --  that is an access parameter.\n-\n-         function Access_Class_Wide_Type return Entity_Id;\n-         --  If expression Expr contains a reference to a controlling access\n-         --  parameter, create an access to Disp_Typ'Class for the necessary\n-         --  conversions if one does not exist.\n-\n-         function Replace_Type (N : Node_Id) return Traverse_Result;\n-         --  ARM 6.1.1: Within the expression for a Pre'Class or Post'Class\n-         --  aspect for a primitive subprogram of a tagged type Disp_Typ, a\n-         --  name that denotes a formal parameter of type Disp_Typ is treated\n-         --  as having type Disp_Typ'Class. Similarly, a name that denotes a\n-         --  formal access parameter of type access-to-Disp_Typ is interpreted\n-         --  as with type access-to-Disp_Typ'Class. This ensures the expression\n-         --  is well defined for a primitive subprogram of a type descended\n-         --  from Disp_Typ.\n-\n-         ----------------------------\n-         -- Access_Class_Wide_Type --\n-         ----------------------------\n-\n-         function Access_Class_Wide_Type return Entity_Id is\n-            Loc : constant Source_Ptr := Sloc (N);\n-\n-         begin\n-            if No (ACW) then\n-               ACW := Make_Temporary (Loc, 'T');\n-\n-               Insert_Before_And_Analyze (Subp_Decl,\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => ACW,\n-                   Type_Definition     =>\n-                      Make_Access_To_Object_Definition (Loc,\n-                        Subtype_Indication =>\n-                          New_Occurrence_Of (Class_Wide_Type (Disp_Typ), Loc),\n-                        All_Present        => True)));\n-\n-               Freeze_Before (Subp_Decl, ACW);\n-            end if;\n-\n-            return ACW;\n-         end Access_Class_Wide_Type;\n-\n-         ------------------\n-         -- Replace_Type --\n-         ------------------\n-\n-         function Replace_Type (N : Node_Id) return Traverse_Result is\n-            Context : constant Node_Id    := Parent (N);\n-            Loc     : constant Source_Ptr := Sloc (N);\n-            CW_Typ  : Entity_Id := Empty;\n-            Ent     : Entity_Id;\n-            Typ     : Entity_Id;\n-\n-         begin\n-            if Is_Entity_Name (N)\n-              and then Present (Entity (N))\n-              and then Is_Formal (Entity (N))\n-            then\n-               Ent := Entity (N);\n-               Typ := Etype (Ent);\n-\n-               --  Do not perform the type replacement for selector names in\n-               --  parameter associations. These carry an entity for reference\n-               --  purposes, but semantically they are just identifiers.\n-\n-               if Nkind (Context) = N_Type_Conversion then\n-                  null;\n-\n-               elsif Nkind (Context) = N_Parameter_Association\n-                 and then Selector_Name (Context) = N\n-               then\n-                  null;\n-\n-               elsif Typ = Disp_Typ then\n-                  CW_Typ := Class_Wide_Type (Typ);\n-\n-               elsif Is_Access_Type (Typ)\n-                 and then Designated_Type (Typ) = Disp_Typ\n-               then\n-                  CW_Typ := Access_Class_Wide_Type;\n-               end if;\n-\n-               if Present (CW_Typ) then\n-                  Rewrite (N,\n-                    Make_Type_Conversion (Loc,\n-                      Subtype_Mark => New_Occurrence_Of (CW_Typ, Loc),\n-                      Expression   => New_Occurrence_Of (Ent, Loc)));\n-                  Set_Etype (N, CW_Typ);\n-               end if;\n-            end if;\n-\n-            return OK;\n-         end Replace_Type;\n-\n-         procedure Replace_Types is new Traverse_Proc (Replace_Type);\n-\n-      --  Start of processing for Process_Class_Wide_Condition\n-\n-      begin\n-         --  The subprogram subject to Pre'Class/Post'Class does not have a\n-         --  dispatching type, therefore the aspect/pragma is illegal.\n-\n-         if No (Disp_Typ) then\n-            Error_Msg_Name_1 := Original_Aspect_Pragma_Name (N);\n-\n-            if From_Aspect_Specification (N) then\n-               Error_Msg_N\n-                 (\"aspect % can only be specified for a primitive operation \"\n-                  & \"of a tagged type\", Corresponding_Aspect (N));\n-\n-            --  The pragma is a source construct\n-\n-            else\n-               Error_Msg_N\n-                 (\"pragma % can only be specified for a primitive operation \"\n-                  & \"of a tagged type\", N);\n-            end if;\n-         end if;\n-\n-         Replace_Types (Expr);\n-      end Process_Class_Wide_Condition;\n-\n       --  Local variables\n \n       Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n@@ -23295,6 +23150,7 @@ package body Sem_Prag is\n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n       Errors        : Nat;\n+      Disp_Typ      : Entity_Id;\n       Restore_Scope : Boolean := False;\n \n    --  Start of processing for Analyze_Pre_Post_Condition_In_Decl_Part\n@@ -23340,13 +23196,29 @@ package body Sem_Prag is\n          Contract_Freeze_Error (Spec_Id, Freeze_Id);\n       end if;\n \n-      --  For a class-wide condition, a reference to a controlling formal must\n-      --  be interpreted as having the class-wide type (or an access to such)\n-      --  so that the inherited condition can be properly applied to any\n-      --  overriding operation (see ARM12 6.6.1 (7)).\n-\n       if Class_Present (N) then\n-         Process_Class_Wide_Condition (Expr, Spec_Id, Subp_Decl);\n+\n+         --  Verify that a class-wide condition is legal, i.e. the operation\n+         --  is a primitive of a tagged type.\n+\n+         Disp_Typ := Find_Dispatching_Type (Spec_Id);\n+\n+         if No (Disp_Typ) then\n+            Error_Msg_Name_1 := Original_Aspect_Pragma_Name (N);\n+\n+            if From_Aspect_Specification (N) then\n+               Error_Msg_N\n+                 (\"aspect % can only be specified for a primitive operation \"\n+                  & \"of a tagged type\", Corresponding_Aspect (N));\n+\n+            --  The pragma is a source construct\n+\n+            else\n+               Error_Msg_N\n+                 (\"pragma % can only be specified for a primitive operation \"\n+                  & \"of a tagged type\", N);\n+            end if;\n+         end if;\n       end if;\n \n       if Restore_Scope then\n@@ -26164,6 +26036,294 @@ package body Sem_Prag is\n       return False;\n    end Appears_In;\n \n+   -----------------------------------\n+   -- Build_Pragma_Check_Equivalent --\n+   -----------------------------------\n+\n+   function Build_Pragma_Check_Equivalent\n+     (Prag     : Node_Id;\n+      Subp_Id  : Entity_Id := Empty;\n+      Inher_Id : Entity_Id := Empty) return Node_Id\n+   is\n+      function Suppress_Reference (N : Node_Id) return Traverse_Result;\n+      --  Detect whether node N references a formal parameter subject to\n+      --  pragma Unreferenced. If this is the case, set Comes_From_Source\n+      --  to False to suppress the generation of a reference when analyzing\n+      --  N later on.\n+\n+      ------------------------\n+      -- Suppress_Reference --\n+      ------------------------\n+\n+      function Suppress_Reference (N : Node_Id) return Traverse_Result is\n+         Formal : Entity_Id;\n+\n+      begin\n+         if Is_Entity_Name (N) and then Present (Entity (N)) then\n+            Formal := Entity (N);\n+\n+            --  The formal parameter is subject to pragma Unreferenced.\n+            --  Prevent the generation of a reference by resetting the\n+            --  Comes_From_Source flag.\n+\n+            if Is_Formal (Formal)\n+              and then Has_Pragma_Unreferenced (Formal)\n+            then\n+               Set_Comes_From_Source (N, False);\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Suppress_Reference;\n+\n+      procedure Suppress_References is\n+        new Traverse_Proc (Suppress_Reference);\n+\n+      --  Local variables\n+\n+      Loc          : constant Source_Ptr := Sloc (Prag);\n+      Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n+      Check_Prag   : Node_Id;\n+      Formals_Map  : Elist_Id;\n+      Inher_Formal : Entity_Id;\n+      Msg_Arg      : Node_Id;\n+      Nam          : Name_Id;\n+      Subp_Formal  : Entity_Id;\n+\n+      function Replace_Entity (N : Node_Id) return Traverse_Result;\n+      --  Replace reference to formal of inherited operation or to primitive\n+      --  operation of root type, with corresponding entity for derived type.\n+\n+      --------------------\n+      -- Replace_Entity --\n+      --------------------\n+\n+      function Replace_Entity (N : Node_Id) return Traverse_Result\n+      is\n+         Elmt  : Elmt_Id;\n+         New_E : Entity_Id;\n+\n+      begin\n+         if Nkind (N) = N_Identifier\n+           and then Present (Entity (N))\n+           and then\n+             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n+           and then\n+             (Nkind (Parent (N)) /= N_Attribute_Reference\n+               or else Attribute_Name (Parent (N)) /= Name_Class)\n+         then\n+            --  The replacement does not apply to dispatching calls within\n+            --  the condition, but only to calls whose static tag is that\n+            --  of the parent type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+              and then Present (Controlling_Argument (Parent (N)))\n+            then\n+               return OK;\n+            end if;\n+\n+            --  Loop to find out if entity has a renaming\n+\n+            New_E := Empty;\n+            Elmt := First_Elmt (Formals_Map);\n+            while Present (Elmt) loop\n+               if Node (Elmt) = Entity (N) then\n+                  New_E := Node (Next_Elmt (Elmt));\n+                  exit;\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+\n+            if Present (New_E) then\n+               Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n+            end if;\n+         end if;\n+\n+         if not Is_Abstract_Subprogram (Inher_Id)\n+           and then  Nkind (N) = N_Function_Call\n+           and then Present (Entity (Name (N)))\n+           and then Is_Abstract_Subprogram (Entity (Name (N)))\n+         then\n+            Error_Msg_N (\"cannot call abstract subprogram\", N);\n+\n+         --  The whole expression will be reanalyzed\n+\n+         elsif Nkind (N) in N_Has_Etype then\n+            Set_Analyzed (N, False);\n+         end if;\n+\n+         return OK;\n+      end Replace_Entity;\n+\n+      procedure Replace_Condition_Entities is\n+        new Traverse_Proc (Replace_Entity);\n+\n+   --  Start of processing for Build_Pragma_Check_Equivalent\n+\n+   begin\n+      Formals_Map := No_Elist;\n+\n+      --  When the pre- or postcondition is inherited, map the formals of\n+      --  the inherited subprogram to those of the current subprogram.\n+      --  In addition, map primitive operations of the parent type into the\n+      --  corresponding primitive operations of the descendant.\n+\n+      if Present (Inher_Id) then\n+         pragma Assert (Present (Subp_Id));\n+\n+         Formals_Map := New_Elmt_List;\n+\n+         --  Create a mapping  <inherited formal> => <subprogram formal>\n+\n+         Inher_Formal := First_Formal (Inher_Id);\n+         Subp_Formal  := First_Formal (Subp_Id);\n+         while Present (Inher_Formal) and then Present (Subp_Formal) loop\n+            Append_Elmt (Inher_Formal, Formals_Map);\n+            Append_Elmt (Subp_Formal, Formals_Map);\n+\n+            Next_Formal (Inher_Formal);\n+            Next_Formal (Subp_Formal);\n+         end loop;\n+\n+      --  Map primitive operations of the parent type into the corresponding\n+      --  operations of the descendant. The descendant type might not be\n+      --  frozen yet, so we cannot use the dispatch table directly.\n+\n+         declare\n+            T     : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n+            Old_T : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n+            D     : Node_Id;\n+            E     : Entity_Id;\n+            Old_E : Entity_Id;\n+\n+         begin\n+            D := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n+\n+            --  Look for primitive operations of the current type that have\n+            --  overridden an operation of the type related to the original\n+            --  class-wide precondition. There may be several intermediate\n+            --  overridings between them.\n+\n+            while Present (D) loop\n+               if Nkind (D) = N_Subprogram_Declaration then\n+                  E := Defining_Entity (D);\n+                  if Is_Subprogram (E)\n+                    and then Present (Overridden_Operation (E))\n+                    and then Find_Dispatching_Type (E) = T\n+                  then\n+                     Old_E := Overridden_Operation (E);\n+                     while Present (Overridden_Operation (Old_E))\n+                       and then Scope (Old_E) /= Scope (Inher_Id)\n+                     loop\n+                        Old_E := Overridden_Operation (Old_E);\n+                     end loop;\n+\n+                     Append_Elmt (Old_E, Formals_Map);\n+                     Append_Elmt (E, Formals_Map);\n+                  end if;\n+               end if;\n+\n+               Next (D);\n+            end loop;\n+\n+            E := First_Entity (Scope (Subp_Id));\n+            while Present (E) loop\n+               if not Comes_From_Source (E)\n+                 and then Ekind (E) = E_Function\n+                 and then Present (Alias (E))\n+               then\n+                  Old_E := Alias (E);\n+                  while Present (Alias (Old_E))\n+                    and then Scope (Old_E) /= Scope (Inher_Id)\n+                  loop\n+                     Old_E := Alias (Old_E);\n+                  end loop;\n+\n+                  Append_Elmt (Old_E, Formals_Map);\n+                  Append_Elmt (E, Formals_Map);\n+               end if;\n+               Next_Entity (E);\n+            end loop;\n+\n+            if Formals_Map /= No_Elist then\n+               Append_Elmt (Old_T, Formals_Map);\n+               Append_Elmt (T, Formals_Map);\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Copy the original pragma while performing substitutions (if\n+      --  applicable).\n+\n+      Check_Prag := New_Copy_Tree (Source    => Prag);\n+\n+      if Formals_Map /= No_Elist then\n+         Replace_Condition_Entities (Check_Prag);\n+      end if;\n+\n+      --  Mark the pragma as being internally generated and reset the\n+      --  Analyzed flag.\n+\n+      Set_Analyzed          (Check_Prag, False);\n+      Set_Comes_From_Source (Check_Prag, False);\n+      Set_Class_Present     (Check_Prag, False);\n+\n+      --  The tree of the original pragma may contain references to the\n+      --  formal parameters of the related subprogram. At the same time\n+      --  the corresponding body may mark the formals as unreferenced:\n+\n+      --     procedure Proc (Formal : ...)\n+      --       with Pre => Formal ...;\n+\n+      --     procedure Proc (Formal : ...) is\n+      --        pragma Unreferenced (Formal);\n+      --     ...\n+\n+      --  This creates problems because all pragma Check equivalents are\n+      --  analyzed at the end of the body declarations. Since all source\n+      --  references have already been accounted for, reset any references\n+      --  to such formals in the generated pragma Check equivalent.\n+\n+      Suppress_References (Check_Prag);\n+\n+      if Present (Corresponding_Aspect (Prag)) then\n+         Nam := Chars (Identifier (Corresponding_Aspect (Prag)));\n+      else\n+         Nam := Prag_Nam;\n+      end if;\n+\n+      --  Convert the copy into pragma Check by correcting the name and\n+      --  adding a check_kind argument.\n+\n+      Set_Pragma_Identifier\n+        (Check_Prag, Make_Identifier (Loc, Name_Check));\n+\n+      Prepend_To (Pragma_Argument_Associations (Check_Prag),\n+        Make_Pragma_Argument_Association (Loc,\n+          Expression => Make_Identifier (Loc, Nam)));\n+\n+      --  Update the error message when the pragma is inherited\n+\n+      if Present (Inher_Id) then\n+         Msg_Arg := Last (Pragma_Argument_Associations (Check_Prag));\n+\n+         if Chars (Msg_Arg) = Name_Message then\n+            String_To_Name_Buffer (Strval (Expression (Msg_Arg)));\n+\n+            --  Insert \"inherited\" to improve the error message\n+\n+            if Name_Buffer (1 .. 8) = \"failed p\" then\n+               Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+               Set_Strval (Expression (Msg_Arg), String_From_Name_Buffer);\n+            end if;\n+         end if;\n+      end if;\n+\n+      return Check_Prag;\n+   end Build_Pragma_Check_Equivalent;\n+\n    -----------------------------\n    -- Check_Applicable_Policy --\n    -----------------------------\n@@ -26626,6 +26786,42 @@ package body Sem_Prag is\n       end loop;\n    end Check_State_And_Constituent_Use;\n \n+   ---------------------------------------------\n+   -- Collect_Inherited_Class_Wide_Conditions --\n+   ---------------------------------------------\n+\n+   procedure Collect_Inherited_Class_Wide_Conditions\n+     (Subp : Entity_Id;\n+      Bod  : Node_Id)\n+   is\n+      Parent_Subp : constant Entity_Id := Overridden_Operation (Subp);\n+      Prags       : constant Node_Id := Contract (Parent_Subp);\n+      Prag        : Node_Id;\n+\n+   begin\n+      --  Iterate over the contract to find inherited class-wide pre- and\n+      --  postconditions.\n+\n+      if Present (Prags) then\n+         Prag := Pre_Post_Conditions (Prags);\n+\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Precondition\n+              or else Pragma_Name (Prag) = Name_Postcondition\n+            then\n+               if No (Declarations (Bod)) then\n+                  Set_Declarations (Bod, Empty_List);\n+               end if;\n+\n+               Append (Build_Pragma_Check_Equivalent (Prag, Subp, Parent_Subp),\n+                 To => Declarations (Bod));\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+   end Collect_Inherited_Class_Wide_Conditions;\n+\n    ---------------------------------------\n    -- Collect_Subprogram_Inputs_Outputs --\n    ---------------------------------------"}, {"sha": "063e7df528fb72d2d1857d3f8fb4bcc2ac7e594e", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539ca5ec98443a3140523337f1dc131fd709f17a/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=539ca5ec98443a3140523337f1dc131fd709f17a", "patch": "@@ -244,6 +244,16 @@ package Sem_Prag is\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case\n \n+   function Build_Pragma_Check_Equivalent\n+     (Prag     : Node_Id;\n+      Subp_Id  : Entity_Id := Empty;\n+      Inher_Id : Entity_Id := Empty) return Node_Id;\n+   --  Transform a [refined] pre- or postcondition denoted by Prag into an\n+   --  equivalent pragma Check. When the pre- or postcondition is inherited,\n+   --  the routine replaces the references of all formals of Inher_Id and\n+   --  primitive operations of its controlling type by references to the\n+   --  corresponding entities of Subp_Id and the descendant type.\n+\n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If\n    --  the name of the aspect or pragma is not one of those recognized as\n@@ -301,6 +311,13 @@ package Sem_Prag is\n    --  state, variable or package instantiation denoted by Item_Id requires the\n    --  use of indicator/option Part_Of. If this is the case, emit an error.\n \n+   procedure Collect_Inherited_Class_Wide_Conditions\n+     (Subp : Entity_Id;\n+      Bod  : Node_Id);\n+   --  When analyzing an overriding subprogram, check whether the overridden\n+   --  operations have class-wide pre/postconditions, and generate the\n+   --  corresponding pragmas.\n+\n    procedure Collect_Subprogram_Inputs_Outputs\n      (Subp_Id      : Entity_Id;\n       Synthesize   : Boolean := False;"}]}