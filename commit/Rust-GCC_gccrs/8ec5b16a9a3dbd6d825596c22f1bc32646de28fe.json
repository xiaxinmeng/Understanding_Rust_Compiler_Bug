{"sha": "8ec5b16a9a3dbd6d825596c22f1bc32646de28fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVjNWIxNmE5YTNkYmQ2ZDgyNTU5NmMyMmYxYmMzMjY0NmRlMjhmZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-06T12:29:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-06T12:29:47Z"}, "message": "Check the VF is small enough for an epilogue loop\n\nThe number of iterations of an epilogue loop is always smaller than the\nVF of the main loop.  vect_analyze_loop_costing was taking this into\naccount when deciding whether the loop is cheap enough to vectorise,\nbut that has no effect with the unlimited cost model.  We need to use\na separate check for correctness as well.\n\nThis can happen if the sizes returned by autovectorize_vector_sizes\nhappen to be out of order, e.g. because the target prefers smaller\nvectors.  It can also happen with later patches if two vectorisation\nattempts happen to end up with the same VF.\n\n2019-11-06  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vect_analyze_loop_2): When vectorizing an\n\tepilogue loop, make sure that the VF is small enough or that\n\tthe epilogue loop can be fully-masked.\n\nFrom-SVN: r277880", "tree": {"sha": "be1152f63c2f69541e90e1c894d5b1089a6adbac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be1152f63c2f69541e90e1c894d5b1089a6adbac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72d6aeecd95ec49fff1d258e4631167a03351cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d6aeecd95ec49fff1d258e4631167a03351cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d6aeecd95ec49fff1d258e4631167a03351cbb"}], "stats": {"total": 16, "additions": 16, "deletions": 0}, "files": [{"sha": "d04b6bea18bcf44817c5dff2386a7028eb8c23c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ec5b16a9a3dbd6d825596c22f1bc32646de28fe", "patch": "@@ -1,3 +1,9 @@\n+2019-11-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_2): When vectorizing an\n+\tepilogue loop, make sure that the VF is small enough or that\n+\tthe epilogue loop can be fully-masked.\n+\n 2019-11-06  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-loop.c (vect_analyze_loop): Break out of the main"}, {"sha": "ec0bd2c3875a5d9ec5e7522b01c325ac0ab3c369", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec5b16a9a3dbd6d825596c22f1bc32646de28fe/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=8ec5b16a9a3dbd6d825596c22f1bc32646de28fe", "patch": "@@ -2143,6 +2143,16 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t\t\t\t       \" support peeling for gaps.\\n\");\n     }\n \n+  /* If we're vectorizing an epilogue loop, we either need a fully-masked\n+     loop or a loop that has a lower VF than the main loop.  */\n+  if (LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n+      && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+      && maybe_ge (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+\t\t   LOOP_VINFO_VECT_FACTOR (orig_loop_vinfo)))\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"Vectorization factor too high for\"\n+\t\t\t\t   \" epilogue loop.\\n\");\n+\n   /* Check the costings of the loop make vectorizing worthwhile.  */\n   res = vect_analyze_loop_costing (loop_vinfo);\n   if (res < 0)"}]}