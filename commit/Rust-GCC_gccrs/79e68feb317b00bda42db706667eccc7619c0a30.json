{"sha": "79e68feb317b00bda42db706667eccc7619c0a30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzllNjhmZWIzMTdiMDBiZGE0MmRiNzA2NjY3ZWNjYzc2MTljMGEzMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-06T00:04:16Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-06T00:04:16Z"}, "message": "Initial revision\n\nFrom-SVN: r281", "tree": {"sha": "89a242274ea9e6be586f06b43657887bf9cc5513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89a242274ea9e6be586f06b43657887bf9cc5513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79e68feb317b00bda42db706667eccc7619c0a30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e68feb317b00bda42db706667eccc7619c0a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e68feb317b00bda42db706667eccc7619c0a30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e68feb317b00bda42db706667eccc7619c0a30/comments", "author": null, "committer": null, "parents": [{"sha": "174486901a530129618626d18cfaff33543b15b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174486901a530129618626d18cfaff33543b15b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174486901a530129618626d18cfaff33543b15b0"}], "stats": {"total": 6823, "additions": 6823, "deletions": 0}, "files": [{"sha": "c50362d93acfd622175c0b1ed989c61eeabfa5e4", "filename": "gcc/config/m68k/m68k.c", "status": "added", "additions": 1834, "deletions": 0, "changes": 1834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e68feb317b00bda42db706667eccc7619c0a30/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e68feb317b00bda42db706667eccc7619c0a30/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=79e68feb317b00bda42db706667eccc7619c0a30", "patch": "@@ -0,0 +1,1834 @@\n+/* Subroutines for insn-output.c for Motorola 68000 family.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Some output-actions in m68k.md need these.  */\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+/* Needed for use_return_insn.  */\n+#include \"flags.h\"\n+\n+#ifdef SUPPORT_SUN_FPA\n+\n+/* Index into this array by (register number >> 3) to find the\n+   smallest class which contains that register.  */\n+enum reg_class regno_reg_class[]\n+  = { DATA_REGS, ADDR_REGS, FP_REGS,\n+      LO_FPA_REGS, LO_FPA_REGS, FPA_REGS, FPA_REGS };\n+\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+static rtx find_addr_reg ();\n+rtx legitimize_pic_address ();\n+\f\n+\n+/* Emit a (use pic_offset_table_rtx) if we used PIC relocation in the \n+   function at any time during the compilation process.  In the future \n+   we should try and eliminate the USE if we can easily deterine that \n+   all PIC references were deleted from the current function.  That would \n+   save an address register */\n+   \n+finalize_pic()\n+{\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+}\n+\n+\f\n+/* This function generates the assembly code for function entry.\n+   STREAM is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This function is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+\n+/* Note that the order of the bit mask for fmovem is the opposite\n+   of the order for movem!  */\n+\n+\n+void\n+output_function_prologue (stream, size)\n+     FILE *stream;\n+     int size;\n+{\n+  register int regno;\n+  register int mask = 0;\n+  int num_saved_regs = 0;\n+  extern char call_used_regs[];\n+  int fsize = (size + 3) & -4;\n+  \n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Adding negative number is faster on the 68040.  */\n+      if (fsize < 0x8000 && !TARGET_68040)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tlink.w %s,%I%d\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+#else\n+\t  asm_fprintf (stream, \"\\tlink %s,%I%d\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+#endif\n+\t}\n+      else if (TARGET_68020)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tlink.l %s,%I%d\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+#else\n+\t  asm_fprintf (stream, \"\\tlink %s,%I%d\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tlink.w %s,%I0\\n\\tadd.l %I%d,%Rsp\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+#else\n+\t  asm_fprintf (stream, \"\\tlink %s,%I0\\n\\taddl %I%d,%Rsp\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);\n+#endif\n+\t}\n+    }\n+  else if (fsize)\n+    {\n+      /* Adding negative number is faster on the 68040.  */\n+      if (fsize + 4 < 0x8000)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tadd.w %I%d,%Rsp\\n\", - (fsize + 4));\n+#else\n+\t  asm_fprintf (stream, \"\\taddw %I%d,%Rsp\\n\", - (fsize + 4));\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tadd.l %I%d,%Rsp\\n\", - (fsize + 4));\n+#else\n+\t  asm_fprintf (stream, \"\\taddl %I%d,%Rsp\\n\", - (fsize + 4));\n+#endif\n+\t}\n+    }\n+#ifdef SUPPORT_SUN_FPA\n+  for (regno = 24; regno < 56; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+#ifdef MOTOROLA\n+\tasm_fprintf (stream, \"\\tfpmovd %s,-(%Rsp)\\n\",\n+\t\t     reg_names[regno]);\n+#else\n+\tasm_fprintf (stream, \"\\tfpmoved %s,%Rsp@-\\n\",\n+\t\t     reg_names[regno]);\n+#endif\n+      }\n+#endif\n+  for (regno = 16; regno < 24; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+       mask |= 1 << (regno - 16);\n+  if ((mask & 0xff) != 0)\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (stream, \"\\tfmovm %I0x%x,-(%Rsp)\\n\", mask & 0xff);\n+#else\n+      asm_fprintf (stream, \"\\tfmovem %I0x%x,%Rsp@-\\n\", mask & 0xff);\n+#endif\n+    }\n+  mask = 0;\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+        mask |= 1 << (15 - regno);\n+        num_saved_regs++;\n+      }\n+  if (frame_pointer_needed)\n+    {\n+      mask &= ~ (1 << (15 - FRAME_POINTER_REGNUM));\n+      num_saved_regs--;\n+    }\n+  if (num_saved_regs <= 2)\n+    {\n+      /* Store each separately in the same order moveml uses.\n+         Using two movel instructions instead of a single moveml\n+         is about 15% faster for the 68020 and 68030 at no expense\n+         in code size */\n+\n+      int i;\n+\n+      /* Undo the work from above. */\n+      for (i = 0; i< 16; i++)\n+        if (mask & (1 << i))\n+          asm_fprintf (stream,\n+#ifdef MOTOROLA\n+\t\t       \"\\tmov.l %s,-(%Rsp)\\n\",\n+#else\n+\t\t       \"\\tmovel %s,%Rsp@-\\n\",\n+#endif\n+\t\t       reg_names[15 - i]);\n+    }\n+  else if (mask)\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (stream, \"\\tmovm.l %I0x%x,-(%Rsp)\\n\", mask);\n+#else\n+      asm_fprintf (stream, \"\\tmoveml %I0x%x,%Rsp@-\\n\", mask);\n+#endif\n+    }\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (stream, \"\\tmov.l %I__GLOBAL_OFFSET_TABLE_, %s\\n\",\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+      asm_fprintf (stream, \"\\tlea.l (%Rpc,%s.l),%s\\n\",\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+#else\n+      asm_fprintf (stream, \"\\tmovel %I__GLOBAL_OFFSET_TABLE_, %s\\n\",\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+      asm_fprintf (stream, \"\\tlea %Rpc@(0,%s:l),%s\\n\",\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+#endif\n+    }\n+}\n+\f\n+/* Return true if this function's epilogue can be output as RTL.  */\n+\n+int\n+use_return_insn ()\n+{\n+  int regno;\n+\n+  if (!reload_completed || frame_pointer_needed || get_frame_size () != 0)\n+    return 0;\n+  \n+  /* Copied from output_function_epilogue ().  We should probably create a\n+     separate layout routine to perform the common work.  */\n+  \n+  for (regno = 0 ; regno < FIRST_PSEUDO_REGISTER ; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      return 0;\n+  \n+  return 1;\n+}\n+\n+/* This function generates the assembly code for function exit,\n+   on machines that need it.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only, if there is a frame pointer.\n+   This is mandatory because of alloca; we also take advantage of it to\n+   omit stack adjustments before returning.  */\n+\n+void\n+output_function_epilogue (stream, size)\n+     FILE *stream;\n+     int size;\n+{\n+  register int regno;\n+  register int mask, fmask;\n+  register int nregs;\n+  int offset, foffset, fpoffset;\n+  extern char call_used_regs[];\n+  int fsize = (size + 3) & -4;\n+  int big = 0;\n+  rtx insn = get_last_insn ();\n+  \n+  /* If the last insn was a BARRIER, we don't have to write any code.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn && GET_CODE (insn) == BARRIER)\n+    return;\n+\n+#ifdef FUNCTION_EXTRA_EPILOGUE\n+  FUNCTION_EXTRA_EPILOGUE (stream, size);\n+#endif\n+  nregs = 0;  fmask = 0; fpoffset = 0;\n+#ifdef SUPPORT_SUN_FPA\n+  for (regno = 24 ; regno < 56 ; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      nregs++;\n+  fpoffset = nregs * 8;\n+#endif\n+  nregs = 0;\n+  for (regno = 16; regno < 24; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+        nregs++;\n+\tfmask |= 1 << (23 - regno);\n+      }\n+  foffset = fpoffset + nregs * 12;\n+  nregs = 0;  mask = 0;\n+  if (frame_pointer_needed)\n+    regs_ever_live[FRAME_POINTER_REGNUM] = 0;\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+        nregs++;\n+\tmask |= 1 << regno;\n+      }\n+  offset = foffset + nregs * 4;\n+  if (offset + fsize >= 0x8000\n+      && frame_pointer_needed\n+      && (mask || fmask || fpoffset))\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (stream, \"\\tmov.l %I%d,%Ra0\\n\", -fsize);\n+#else\n+      asm_fprintf (stream, \"\\tmovel %I%d,%Ra0\\n\", -fsize);\n+#endif\n+      fsize = 0, big = 1;\n+    }\n+  if (nregs <= 2)\n+    {\n+      /* Restore each separately in the same order moveml does.\n+         Using two movel instructions instead of a single moveml\n+         is about 15% faster for the 68020 and 68030 at no expense\n+         in code size. */\n+\n+      int i;\n+\n+      /* Undo the work from above. */\n+      for (i = 0; i< 16; i++)\n+        if (mask & (1 << i))\n+          {\n+            if (big)\n+\t      {\n+#ifdef MOTOROLA\n+\t\tasm_fprintf (stream, \"\\tmov.l -%d(%s,%Ra0.l),%s\\n\",\n+\t\t\t     offset + fsize,\n+\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     reg_names[i]);\n+#else\n+\t\tasm_fprintf (stream, \"\\tmovel %s@(-%d,%Ra0:l),%s\\n\",\n+\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     offset + fsize, reg_names[i]);\n+#endif\n+\t      }\n+            else if (! frame_pointer_needed)\n+\t      {\n+#ifdef MOTOROLA\n+\t\tasm_fprintf (stream, \"\\tmov.l (%Rsp)+,%s\\n\",\n+\t\t\t     reg_names[i]);\n+#else\n+\t\tasm_fprintf (stream, \"\\tmovel %Rsp@+,%s\\n\",\n+\t\t\t     reg_names[i]);\n+#endif\n+\t      }\n+            else\n+\t      {\n+#ifdef MOTOROLA\n+\t\tasm_fprintf (stream, \"\\tmov.l -%d(%s),%s\\n\",\n+\t\t\t     offset + fsize,\n+\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     reg_names[i]);\n+#else\n+\t\tasm_fprintf (stream, \"\\tmovel %s@(-%d),%s\\n\",\n+\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     offset + fsize, reg_names[i]);\n+#endif\n+\t      }\n+            offset = offset - 4;\n+          }\n+    }\n+  else if (mask)\n+    {\n+      if (big)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tmovm.l -%d(%s,%Ra0.l),%I0x%x\\n\",\n+\t\t       offset + fsize,\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       mask);\n+#else\n+\t  asm_fprintf (stream, \"\\tmoveml %s@(-%d,%Ra0:l),%I0x%x\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       offset + fsize, mask);\n+#endif\n+\t}\n+      else if (! frame_pointer_needed)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tmovm.l (%Rsp)+,%I0x%x\\n\", mask);\n+#else\n+\t  asm_fprintf (stream, \"\\tmoveml %Rsp@+,%I0x%x\\n\", mask);\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tmovm.l -%d(%s),%I0x%x\\n\",\n+\t\t       offset + fsize,\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       mask);\n+#else\n+\t  asm_fprintf (stream, \"\\tmoveml %s@(-%d),%I0x%x\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       offset + fsize, mask);\n+#endif\n+\t}\n+    }\n+  if (fmask)\n+    {\n+      if (big)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tfmovm -%d(%s,%Ra0.l),%I0x%x\\n\",\n+\t\t       foffset + fsize,\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       fmask);\n+#else\n+\t  asm_fprintf (stream, \"\\tfmovem %s@(-%d,%Ra0:l),%I0x%x\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       foffset + fsize, fmask);\n+#endif\n+\t}\n+      else if (! frame_pointer_needed)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tfmovm (%Rsp)+,%I0x%x\\n\", fmask);\n+#else\n+\t  asm_fprintf (stream, \"\\tfmovem %Rsp@+,%I0x%x\\n\", fmask);\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tfmovm -%d(%s),%I0x%x\\n\",\n+\t\t       foffset + fsize,\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       fmask);\n+#else\n+\t  asm_fprintf (stream, \"\\tfmovem %s@(-%d),%I0x%x\\n\",\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       foffset + fsize, fmask);\n+#endif\n+\t}\n+    }\n+  if (fpoffset != 0)\n+    for (regno = 55; regno >= 24; regno--)\n+      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+        {\n+\t  if (big)\n+\t    {\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tfpmovd -%d(%s,%Ra0.l), %s\\n\",\n+\t\t\t   fpoffset + fsize,\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   reg_names[regno]);\n+#else\n+\t      asm_fprintf (stream, \"\\tfpmoved %s@(-%d,%Ra0:l), %s\\n\",\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   fpoffset + fsize, reg_names[regno]);\n+#endif\n+\t    }\n+\t  else if (! frame_pointer_needed)\n+\t    {\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tfpmovd (%Rsp)+,%s\\n\",\n+\t\t\t   reg_names[regno]);\n+#else\n+\t      asm_fprintf (stream, \"\\tfpmoved %Rsp@+, %s\\n\",\n+\t\t\t   reg_names[regno]);\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+#ifdef MOTOROLA\n+\t      asm_fprintf (stream, \"\\tfpmovd -%d(%s), %s\\n\",\n+\t\t\t   fpoffset + fsize,\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   reg_names[regno]);\n+#else\n+\t      asm_fprintf (stream, \"\\tfpmoved %s@(-%d), %s\\n\",\n+\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t   fpoffset + fsize, reg_names[regno]);\n+#endif\n+\t    }\n+\t  fpoffset -= 8;\n+\t}\n+  if (frame_pointer_needed)\n+    fprintf (stream, \"\\tunlk %s\\n\",\n+\t     reg_names[FRAME_POINTER_REGNUM]);\n+  else if (fsize)\n+    {\n+      if (fsize + 4 < 0x8000)\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tadd.w %I%d,%Rsp\\n\", fsize + 4);\n+#else\n+\t  asm_fprintf (stream, \"\\taddw %I%d,%Rsp\\n\", fsize + 4);\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef MOTOROLA\n+\t  asm_fprintf (stream, \"\\tadd.l %I%d,%Rsp\\n\", fsize + 4);\n+#else\n+\t  asm_fprintf (stream, \"\\taddl %I%d,%Rsp\\n\", fsize + 4);\n+#endif\n+\t}\n+    }\n+  if (current_function_pops_args)\n+    asm_fprintf (stream, \"\\trtd %I%d\\n\", current_function_pops_args);\n+  else\n+    fprintf (stream, \"\\trts\\n\");\n+}\n+\f\n+/* Similar to general_operand, but exclude stack_pointer_rtx.  */\n+\n+int\n+not_sp_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return op != stack_pointer_rtx && general_operand (op, mode);\n+}\n+\n+char *\n+output_btst (operands, countop, dataop, insn, signpos)\n+     rtx *operands;\n+     rtx countop, dataop;\n+     rtx insn;\n+     int signpos;\n+{\n+  operands[0] = countop;\n+  operands[1] = dataop;\n+\n+  if (GET_CODE (countop) == CONST_INT)\n+    {\n+      register int count = INTVAL (countop);\n+      /* If COUNT is bigger than size of storage unit in use,\n+\t advance to the containing unit of same size.  */\n+      if (count > signpos)\n+\t{\n+\t  int offset = (count & ~signpos) / 8;\n+\t  count = count & signpos;\n+\t  operands[1] = dataop = adj_offsettable_operand (dataop, offset);\n+\t}\n+      if (count == signpos)\n+\tcc_status.flags = CC_NOT_POSITIVE | CC_Z_IN_NOT_N;\n+      else\n+\tcc_status.flags = CC_NOT_NEGATIVE | CC_Z_IN_NOT_N;\n+\n+      /* These three statements used to use next_insns_test_no...\n+\t but it appears that this should do the same job.  */\n+      if (count == 31\n+\t  && next_insn_tests_no_inequality (insn))\n+\treturn \"tst%.l %1\";\n+      if (count == 15\n+\t  && next_insn_tests_no_inequality (insn))\n+\treturn \"tst%.w %1\";\n+      if (count == 7\n+\t  && next_insn_tests_no_inequality (insn))\n+\treturn \"tst%.b %1\";\n+\n+      cc_status.flags = CC_NOT_NEGATIVE;\n+    }\n+  return \"btst %0,%1\";\n+}\n+\f\n+/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n+   reference and a constant.  */\n+\n+int\n+symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+\n+#if 0 /* Deleted, with corresponding change in m68k.h,\n+\t so as to fit the specs.  No CONST_DOUBLE is ever symbolic.  */\n+    case CONST_DOUBLE:\n+      return GET_MODE (op) == mode;\n+#endif\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+\f\n+/* Legitimize PIC addresses.  If the address is already\n+   position-independent, we return ORIG.  Newly generated\n+   position-independent addresses go to REG.  If we need more\n+   than one register, we lose.  \n+\n+   An address is legitimized by making an indirect reference\n+   through the Global Offset Table with the name of the symbol\n+   used as an offset.  \n+\n+   The assembler and linker are responsible for placing the \n+   address of the symbol in the GOT.  The function prologue\n+   is responsible for initializing a5 to the starting address\n+   of the GOT.\n+\n+   The assembler is also responsible for translating a symbol name\n+   into a constant displacement from the start of the GOT.  \n+\n+   A quick example may make things a little clearer:\n+\n+   When not generating PIC code to store the value 12345 into _foo\n+   we would generate the following code:\n+\n+\tmovel #12345, _foo\n+\n+   When generating PIC two transformations are made.  First, the compiler\n+   loads the address of foo into a register.  So the first transformation makes:\n+\n+\tlea\t_foo, a0\n+\tmovel   #12345, a0@\n+\n+   The code in movsi will intercept the lea instruction and call this\n+   routine which will transform the instructions into:\n+\n+\tmovel   a5@(_foo:w), a0\n+\tmovel   #12345, a0@\n+   \n+\n+   That (in a nutshell) is how *all* symbol and label references are \n+   handled.  */\n+\n+rtx\n+legitimize_pic_address (orig, mode, reg)\n+     rtx orig, reg;\n+     enum machine_mode mode;\n+{\n+  rtx pic_ref = orig;\n+\n+  /* First handle a simple SYMBOL_REF or LABEL_REF */\n+  if (GET_CODE (orig) == SYMBOL_REF || GET_CODE (orig) == LABEL_REF)\n+    {\n+      if (reg == 0)\n+\tabort ();\n+\n+      pic_ref = gen_rtx (MEM, Pmode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  pic_offset_table_rtx, orig));\n+      current_function_uses_pic_offset_table = 1;\n+      RTX_UNCHANGING_P (pic_ref) = 1;\n+      emit_move_insn (reg, pic_ref);\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      rtx base, offset;\n+\n+      /* Make sure this is CONST has not already been legitimized */\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\tabort ();\n+\n+      /* legitimize both operands of the PLUS */\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+\t{\n+\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+\t  orig = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t\t base == reg ? 0 : reg);\n+\t}\n+      else abort ();\n+\n+      if (GET_CODE (orig) == CONST_INT)\n+\treturn plus_constant_for_output (base, INTVAL (orig));\n+      pic_ref = gen_rtx (PLUS, Pmode, base, orig);\n+      /* Likewise, should we set special REG_NOTEs here?  */\n+    }\n+  return pic_ref;\n+}\n+\n+\f\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+#ifdef SUPPORT_SUN_FPA\n+  if (FPA_REG_P (operands[0]) || FPA_REG_P (operands[1]))\n+    return \"fpmoves %1,%0\";\n+#endif\n+  if (DATA_REG_P (operands[0])\n+      && GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) < 128\n+      && INTVAL (operands[1]) >= -128)\n+    {\n+#if defined(MOTOROLA) && !defined(CRDS)\n+      return \"moveq%.l %1,%0\";\n+#else\n+      return \"moveq %1,%0\";\n+#endif\n+    }\n+  if (operands[1] != const0_rtx)\n+    return \"move%.l %1,%0\";\n+  if (! ADDRESS_REG_P (operands[0]))\n+    return \"clr%.l %0\";\n+  return \"sub%.l %0,%0\";\n+}\n+\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    optype0 = POPOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    optype0 = PUSHOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    optype1 = POPOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+    optype1 = PUSHOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If one operand is decrementing and one is incrementing\n+     decrement the former register explicitly\n+     and change that operand into ordinary indexing.  */\n+\n+  if (optype0 == PUSHOP && optype1 == POPOP)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      output_asm_insn (\"subq%.l %#8,%0\", operands);\n+      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      optype0 = OFFSOP;\n+    }\n+  if (optype0 == POPOP && optype1 == PUSHOP)\n+    {\n+      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+      output_asm_insn (\"subq%.l %#8,%1\", operands);\n+      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      optype1 = OFFSOP;\n+    }\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    split_double (operands[1], &operands[1], &latehalf[1]);\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If insn is effectively movd N(sp),-(sp) then we will do the\n+     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n+     for the low word as well, to compensate for the first decrement of sp.  */\n+  if (optype0 == PUSHOP\n+      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+    operands[1] = latehalf[1];\n+\n+  /* If one or both operands autodecrementing,\n+     do the two words, high-numbered first.  */\n+\n+  /* Likewise,  the first move would clobber the source of the second one,\n+     do them in the other order.  This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.  */\n+\n+  if (optype0 == PUSHOP || optype1 == PUSHOP\n+      || (optype0 == REGOP && optype1 == REGOP\n+\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"addql %#4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"addql %#4,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"subql %#4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"subql %#4,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"addql %#4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"addql %#4,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"subql %#4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"subql %#4,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+}\n+\f\n+/* Store in cc_status the expressions that the condition codes will\n+   describe after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+/* On the 68000, all the insns to store in an address register fail to\n+   set the cc's.  However, in some cases these instructions can make it\n+   possibly invalid to use the saved cc's.  In those cases we clear out\n+   some or all of the saved cc's so they won't be used.  */\n+\n+notice_update_cc (exp, insn)\n+     rtx exp;\n+     rtx insn;\n+{\n+  /* If the cc is being set from the fpa and the expression is not an\n+     explicit floating point test instruction (which has code to deal with\n+     this), reinit the CC.  */\n+  if (((cc_status.value1 && FPA_REG_P (cc_status.value1))\n+       || (cc_status.value2 && FPA_REG_P (cc_status.value2)))\n+      && !(GET_CODE (exp) == PARALLEL\n+\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET\n+\t   && XEXP (XVECEXP (exp, 0, 0), 0) == cc0_rtx))\n+    {\n+      CC_STATUS_INIT; \n+    }\n+  else if (GET_CODE (exp) == SET)\n+    {\n+      if (GET_CODE (SET_SRC (exp)) == CALL)\n+\t{\n+\t  CC_STATUS_INIT; \n+\t}\n+      else if (ADDRESS_REG_P (SET_DEST (exp)))\n+\t{\n+\t  if (cc_status.value1\n+\t      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1))\n+\t    cc_status.value1 = 0;\n+\t  if (cc_status.value2\n+\t      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2))\n+\t    cc_status.value2 = 0; \n+\t}\n+      else if (!FP_REG_P (SET_DEST (exp))\n+\t       && SET_DEST (exp) != cc0_rtx\n+\t       && (FP_REG_P (SET_SRC (exp))\n+\t\t   || GET_CODE (SET_SRC (exp)) == FIX\n+\t\t   || GET_CODE (SET_SRC (exp)) == FLOAT_TRUNCATE\n+\t\t   || GET_CODE (SET_SRC (exp)) == FLOAT_EXTEND))\n+\t{\n+\t  CC_STATUS_INIT; \n+\t}\n+      /* A pair of move insns doesn't produce a useful overall cc.  */\n+      else if (!FP_REG_P (SET_DEST (exp))\n+\t       && !FP_REG_P (SET_SRC (exp))\n+\t       && GET_MODE_SIZE (GET_MODE (SET_SRC (exp))) > 4\n+\t       && (GET_CODE (SET_SRC (exp)) == REG\n+\t\t   || GET_CODE (SET_SRC (exp)) == MEM\n+\t\t   || GET_CODE (SET_SRC (exp)) == CONST_DOUBLE))\n+\t{\n+\t  CC_STATUS_INIT; \n+\t}\n+      else if (GET_CODE (SET_SRC (exp)) == CALL)\n+\t{\n+\t  CC_STATUS_INIT; \n+\t}\n+      else if (XEXP (exp, 0) != pc_rtx)\n+\t{\n+\t  cc_status.flags = 0;\n+\t  cc_status.value1 = XEXP (exp, 0);\n+\t  cc_status.value2 = XEXP (exp, 1);\n+\t}\n+    }\n+  else if (GET_CODE (exp) == PARALLEL\n+\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n+    {\n+      if (ADDRESS_REG_P (XEXP (XVECEXP (exp, 0, 0), 0)))\n+\tCC_STATUS_INIT;\n+      else if (XEXP (XVECEXP (exp, 0, 0), 0) != pc_rtx)\n+\t{\n+\t  cc_status.flags = 0;\n+\t  cc_status.value1 = XEXP (XVECEXP (exp, 0, 0), 0);\n+\t  cc_status.value2 = XEXP (XVECEXP (exp, 0, 0), 1);\n+\t}\n+    }\n+  else\n+    CC_STATUS_INIT;\n+  if (cc_status.value2 != 0\n+      && ADDRESS_REG_P (cc_status.value2)\n+      && GET_MODE (cc_status.value2) == QImode)\n+    CC_STATUS_INIT;\n+  if (cc_status.value2 != 0\n+      && !(cc_status.value1 && FPA_REG_P (cc_status.value1)))\n+    switch (GET_CODE (cc_status.value2))\n+      {\n+      case PLUS: case MINUS: case MULT:\n+      case DIV: case UDIV: case MOD: case UMOD: case NEG:\n+      case ASHIFT: case LSHIFT: case ASHIFTRT: case LSHIFTRT:\n+      case ROTATE: case ROTATERT:\n+\tif (GET_MODE (cc_status.value2) != VOIDmode)\n+\t  cc_status.flags |= CC_NO_OVERFLOW;\n+\tbreak;\n+      case ZERO_EXTEND:\n+\t/* (SET r1 (ZERO_EXTEND r2)) on this machine\n+\t   ends with a move insn moving r2 in r2's mode.\n+\t   Thus, the cc's are set for r2.\n+\t   This can set N bit spuriously. */\n+\tcc_status.flags |= CC_NOT_NEGATIVE; \n+      }\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\n+      && cc_status.value2\n+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n+    cc_status.value2 = 0;\n+  if (((cc_status.value1 && FP_REG_P (cc_status.value1))\n+       || (cc_status.value2 && FP_REG_P (cc_status.value2)))\n+      && !((cc_status.value1 && FPA_REG_P (cc_status.value1))\n+\t   || (cc_status.value2 && FPA_REG_P (cc_status.value2))))\n+    cc_status.flags = CC_IN_68881;\n+}\n+\f\n+char *\n+output_move_const_double (operands)\n+     rtx *operands;\n+{\n+#ifdef SUPPORT_SUN_FPA\n+  if (TARGET_FPA && FPA_REG_P(operands[0]))\n+    {\n+      int code = standard_sun_fpa_constant_p (operands[1]);\n+\n+      if (code != 0)\n+\t{\n+\t  static char buf[40];\n+\n+\t  sprintf (buf, \"fpmove%%.d %%%%%d,%%0\", code & 0x1ff);\n+\t  return buf;\n+\t}\n+      return \"fpmove%.d %1,%0\";\n+    }\n+  else\n+#endif\n+    {\n+      int code = standard_68881_constant_p (operands[1]);\n+\n+      if (code != 0)\n+\t{\n+\t  static char buf[40];\n+\n+\t  sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n+\t  return buf;\n+\t}\n+      return \"fmove%.d %1,%0\";\n+    }\n+}\n+\n+char *\n+output_move_const_single (operands)\n+     rtx *operands;\n+{\n+#ifdef SUPPORT_SUN_FPA\n+  if (TARGET_FPA)\n+    {\n+      int code = standard_sun_fpa_constant_p (operands[1]);\n+\n+      if (code != 0)\n+\t{\n+\t  static char buf[40];\n+\n+\t  sprintf (buf, \"fpmove%%.s %%%%%d,%%0\", code & 0x1ff);\n+\t  return buf;\n+\t}\n+      return \"fpmove%.s %1,%0\";\n+    }\n+  else\n+#endif /* defined SUPPORT_SUN_FPA */\n+    {\n+      int code = standard_68881_constant_p (operands[1]);\n+\n+      if (code != 0)\n+\t{\n+\t  static char buf[40];\n+\n+\t  sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n+\t  return buf;\n+\t}\n+      return \"fmove%.s %f1,%0\";\n+    }\n+}\n+\n+/* Return nonzero if X, a CONST_DOUBLE, has a value that we can get\n+   from the \"fmovecr\" instruction.\n+   The value, anded with 0xff, gives the code to use in fmovecr\n+   to get the desired constant.  */\n+\n+/* ??? This code should be fixed for cross-compilation. */\n+\n+int\n+standard_68881_constant_p (x)\n+     rtx x;\n+{\n+  union {double d; int i[2];} u;\n+  register double d;\n+\n+  /* fmovecr must be emulated on the 68040, so it shoudn't be used at all. */\n+  if (TARGET_68040)\n+    return 0;\n+\n+#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+  if (! flag_pretend_float)\n+    return 0;\n+#endif\n+\n+#ifdef HOST_WORDS_BIG_ENDIAN\n+  u.i[0] = CONST_DOUBLE_LOW (x);\n+  u.i[1] = CONST_DOUBLE_HIGH (x);\n+#else\n+  u.i[0] = CONST_DOUBLE_HIGH (x);\n+  u.i[1] = CONST_DOUBLE_LOW (x);\n+#endif \n+  d = u.d;\n+\n+  if (d == 0)\n+    return 0x0f;\n+  /* Note: there are various other constants available\n+     but it is a nuisance to put in their values here.  */\n+  if (d == 1)\n+    return 0x32;\n+  if (d == 10)\n+    return 0x33;\n+  if (d == 100)\n+    return 0x34;\n+  if (d == 10000)\n+    return 0x35;\n+  if (d == 1e8)\n+    return 0x36;\n+  if (GET_MODE (x) == SFmode)\n+    return 0;\n+  if (d == 1e16)\n+    return 0x37;\n+  /* larger powers of ten in the constants ram are not used\n+     because they are not equal to a `double' C constant.  */\n+  return 0;\n+}\n+\n+/* If X is a floating-point constant, return the logarithm of X base 2,\n+   or 0 if X is not a power of 2.  */\n+\n+int\n+floating_exact_log2 (x)\n+     rtx x;\n+{\n+  union {double d; int i[2];} u;\n+  register double d, d1;\n+  int i;\n+\n+#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+  if (! flag_pretend_float)\n+    return 0;\n+#endif\n+\n+#ifdef HOST_WORDS_BIG_ENDIAN\n+  u.i[0] = CONST_DOUBLE_LOW (x);\n+  u.i[1] = CONST_DOUBLE_HIGH (x);\n+#else\n+  u.i[0] = CONST_DOUBLE_HIGH (x);\n+  u.i[1] = CONST_DOUBLE_LOW (x);\n+#endif \n+  d = u.d;\n+\n+  if (! (d > 0))\n+    return 0;\n+\n+  for (d1 = 1.0, i = 0; d1 < d; d1 *= 2.0, i++)\n+    ;\n+\n+  if (d == d1)\n+    return i;\n+\n+  return 0;\n+}\n+\f\n+#ifdef SUPPORT_SUN_FPA\n+/* Return nonzero if X, a CONST_DOUBLE, has a value that we can get\n+   from the Sun FPA's constant RAM.\n+   The value returned, anded with 0x1ff, gives the code to use in fpmove\n+   to get the desired constant. */\n+#define S_E (2.718281745910644531)\n+#define D_E (2.718281828459045091)\n+#define S_PI (3.141592741012573242)\n+#define D_PI (3.141592653589793116)\n+#define S_SQRT2 (1.414213538169860840)\n+#define D_SQRT2 (1.414213562373095145)\n+#define S_LOG2ofE (1.442695021629333496)\n+#define D_LOG2ofE (1.442695040888963387)\n+#define S_LOG2of10 (3.321928024291992188)\n+#define D_LOG2of10 (3.321928024887362182)\n+#define S_LOGEof2 (0.6931471824645996094)\n+#define D_LOGEof2 (0.6931471805599452862)\n+#define S_LOGEof10 (2.302585124969482442)\n+#define D_LOGEof10 (2.302585092994045901)\n+#define S_LOG10of2 (0.3010300099849700928)\n+#define D_LOG10of2 (0.3010299956639811980)\n+#define S_LOG10ofE (0.4342944920063018799)\n+#define D_LOG10ofE (0.4342944819032518167)\n+\n+/* This code should be fixed for cross-compilation. */\n+\n+int\n+standard_sun_fpa_constant_p (x)\n+     rtx x;\n+{\n+  union {double d; int i[2];} u;\n+  register double d;\n+\n+#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+  if (! flag_pretend_float)\n+    return 0;\n+#endif\n+\n+\n+  u.i[0] = CONST_DOUBLE_LOW (x);\n+  u.i[1] = CONST_DOUBLE_HIGH (x);\n+  d = u.d;\n+\n+  if (d == 0.0)\n+    return 0x200;\t\t/* 0 once 0x1ff is anded with it */\n+  if (d == 1.0)\n+    return 0xe;\n+  if (d == 0.5)\n+    return 0xf;\n+  if (d == -1.0)\n+    return 0x10;\n+  if (d == 2.0)\n+    return 0x11;\n+  if (d == 3.0)\n+    return 0xB1;\n+  if (d == 4.0)\n+    return 0x12;\n+  if (d == 8.0)\n+    return 0x13;\n+  if (d == 0.25)\n+    return 0x15;\n+  if (d == 0.125)\n+    return 0x16;\n+  if (d == 10.0)\n+    return 0x17;\n+  if (d == -(1.0/2.0))\n+    return 0x2E;\n+\n+/*\n+ * Stuff that looks different if it's single or double\n+ */\n+  if (GET_MODE(x) == SFmode)\n+    {\n+      if (d == S_E)\n+\treturn 0x8;\n+      if (d == (2*S_PI))\n+\treturn 0x9;\n+      if (d == S_PI)\n+\treturn 0xA;\n+      if (d == (S_PI / 2.0))\n+\treturn 0xB;\n+      if (d == S_SQRT2)\n+\treturn 0xC;\n+      if (d == (1.0 / S_SQRT2))\n+\treturn 0xD;\n+      /* Large powers of 10 in the constant \n+\t ram are not used because they are\n+\t not equal to a C double constant  */\n+      if (d == -(S_PI / 2.0))\n+\treturn 0x27;\n+      if (d == S_LOG2ofE)\n+\treturn 0x28;\n+      if (d == S_LOG2of10)\n+\treturn 0x29;\n+      if (d == S_LOGEof2)\n+\treturn 0x2A;\n+      if (d == S_LOGEof10)\n+\treturn 0x2B;\n+      if (d == S_LOG10of2)\n+\treturn 0x2C;\n+      if (d == S_LOG10ofE)\n+\treturn 0x2D;\n+    }\n+  else\n+    {\n+      if (d == D_E)\n+\treturn 0x8;\n+      if (d == (2*D_PI))\n+\treturn 0x9;\n+      if (d == D_PI)\n+\treturn 0xA;\n+      if (d == (D_PI / 2.0))\n+\treturn 0xB;\n+      if (d == D_SQRT2)\n+\treturn 0xC;\n+      if (d == (1.0 / D_SQRT2))\n+\treturn 0xD;\n+      /* Large powers of 10 in the constant \n+\t ram are not used because they are\n+\t not equal to a C double constant  */\n+      if (d == -(D_PI / 2.0))\n+\treturn 0x27;\n+      if (d == D_LOG2ofE)\n+\treturn 0x28;\n+      if (d == D_LOG2of10)\n+\treturn 0x29;\n+      if (d == D_LOGEof2)\n+\treturn 0x2A;\n+      if (d == D_LOGEof10)\n+\treturn 0x2B;\n+      if (d == D_LOG10of2)\n+\treturn 0x2C;\n+      if (d == D_LOG10ofE)\n+\treturn 0x2D;\n+    }\n+  return 0x0;\n+}\n+#endif /* define SUPPORT_SUN_FPA */\n+\f\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand X.  X is an RTL\n+   expression.\n+\n+   CODE is a value that can be used to specify one of several ways\n+   of printing the operand.  It is used when identical operands\n+   must be printed differently depending on the context.  CODE\n+   comes from the `%' specification that was used to request\n+   printing of the operand.  If the specification was just `%DIGIT'\n+   then CODE is 0; if the specification was `%LTR DIGIT' then CODE\n+   is the ASCII code for LTR.\n+\n+   If X is a register, this macro should print the register's name.\n+   The names can be found in an array `reg_names' whose type is\n+   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n+\n+   When the machine description has a specification `%PUNCT' (a `%'\n+   followed by a punctuation character), this macro is called with\n+   a null pointer for X and the punctuation character for CODE.\n+\n+   The m68k specific codes are:\n+\n+   '.' for dot needed in Motorola-style opcode names.\n+   '-' for an operand pushing on the stack:\n+       sp@-, -(sp) or -(%sp) depending on the style of syntax.\n+   '+' for an operand pushing on the stack:\n+       sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n+   '@' for a reference to the top word on the stack:\n+       sp@, (sp) or (%sp) depending on the style of syntax.\n+   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n+       but & in SGS syntax).\n+   '!' for the cc register (used in an `and to cc' insn).\n+   '$' for the letter `s' in an op code, but only on the 68040.\n+   '&' for the letter `d' in an op code, but only on the 68040.\n+\n+   'b' for byte insn (no effect, on the Sun; this is for the ISI).\n+   'd' to force memory addressing to be absolute, not relative.\n+   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n+       than directly).  Second part of 'y' below.\n+   'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n+       or print pair of registers as rx:ry.\n+   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n+       CONST_DOUBLE's as SunFPA constant RAM registers if\n+       possible, so it should not be used except for the SunFPA.\n+\n+   */\n+\n+void\n+print_operand (file, op, letter)\n+     FILE *file;\t\t/* file to write to */\n+     rtx op;\t\t\t/* operand to print */\n+     int letter;\t\t/* %<letter> or 0 */\n+{\n+  int i;\n+\n+  if (letter == '.')\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (file, \".\");\n+#endif\n+    }\n+  else if (letter == '#')\n+    {\n+      asm_fprintf (file, \"%I\");\n+    }\n+  else if (letter == '-')\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (file, \"-(%Rsp)\");\n+#else\n+      asm_fprintf (file, \"%Rsp@-\");\n+#endif\n+    }\n+  else if (letter == '+')\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (file, \"(%Rsp)+\");\n+#else\n+      asm_fprintf (file, \"%Rsp@+\");\n+#endif\n+    }\n+  else if (letter == '@')\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (file, \"(%Rsp)\");\n+#else\n+      asm_fprintf (file, \"%Rsp@\");\n+#endif\n+    }\n+  else if (letter == '!')\n+    {\n+#ifdef MOTOROLA\n+      asm_fprintf (file, \"(%Rcc)\");\n+#else\n+      asm_fprintf (file, \"%Rcc\");\n+#endif\n+    }\n+  else if (letter == '$')\n+    {\n+      if (TARGET_68040_ONLY)\n+\t{\n+\t  fprintf (file, \"s\");\n+\t}\n+    }\n+  else if (letter == '&')\n+    {\n+      if (TARGET_68040_ONLY)\n+\t{\n+\t  fprintf (file, \"d\");\n+\t}\n+    }\n+  else if (GET_CODE (op) == REG)\n+    {\n+      if (REGNO (op) < 16\n+\t  && (letter == 'y' || letter == 'x')\n+\t  && GET_MODE (op) == DFmode)\n+\t{\n+\t  fprintf (file, \"%s:%s\", reg_names[REGNO (op)],\n+\t\t   reg_names[REGNO (op)+1]);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"%s\", reg_names[REGNO (op)]);\n+\t}\n+    }\n+  else if (GET_CODE (op) == MEM)\n+    {\n+      output_address (XEXP (op, 0));\n+      if (letter == 'd' && ! TARGET_68020\n+\t  && CONSTANT_ADDRESS_P (XEXP (op, 0))\n+\t  && !(GET_CODE (XEXP (op, 0)) == CONST_INT\n+\t       && INTVAL (XEXP (op, 0)) < 0x8000\n+\t       && INTVAL (XEXP (op, 0)) >= -0x8000))\n+\t{\n+\t  fprintf (file, \":l\");\n+\t}\n+    }\n+#ifdef SUPPORT_SUN_FPA\n+  else if ((letter == 'y' || letter == 'w')\n+\t   && GET_CODE(op) == CONST_DOUBLE\n+\t   && (i = standard_sun_fpa_constant_p (op)))\n+    {\n+      fprintf (file, \"%%%d\", i & 0x1ff);\n+    }\n+#endif\n+  else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == SFmode)\n+    {\n+      union { double d; int i[2]; } u;\n+      union { float f; int i; } u1;\n+      PRINT_OPERAND_EXTRACT_FLOAT (op);\n+      u1.f = u.d;\n+      PRINT_OPERAND_PRINT_FLOAT (letter, file);\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) != DImode)\n+    {\n+      union { double d; int i[2]; } u;\n+      PRINT_OPERAND_EXTRACT_FLOAT (op);\n+      ASM_OUTPUT_DOUBLE_OPERAND (file, u.d);\n+    }\n+  else\n+    {\n+      asm_fprintf (file, \"%I\"); output_addr_const (file, op);\n+    }\n+}\n+\n+\f\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is ADDR.  ADDR is an RTL expression.\n+\n+   Note that this contains a kludge that knows that the only reason\n+   we have an address (plus (label_ref...) (reg...)) when not generating\n+   PIC code is in the insn before a tablejump, and we know that m68k.md\n+   generates a label LInnn: on such an insn.\n+\n+   It is possible for PIC to generate a (plus (label_ref...) (reg...))\n+   and we handle that just like we would a (plus (symbol_ref...) (reg...)).\n+\n+   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n+   fails to assemble.  Luckily \"Lnnn(pc,d0.l*2)\" produces the results\n+   we want.  This difference can be accommodated by using an assembler\n+   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n+   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n+   macro.  See m68ksgs.h for an example; for versions without the bug.\n+\n+   They also do not like things like \"pea 1.w\", so we simple leave off\n+   the .w on small constants. \n+\n+   This routine is responsible for distinguishing between -fpic and -fPIC \n+   style relocations in an address.  When generating -fpic code the\n+   offset is output in word mode (eg movel a5@(_foo:w), a0).  When generating\n+   -fPIC code the offset is output in long mode (eg movel a5@(_foo:l), a0) */\n+\n+void\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  register rtx reg1, reg2, breg, ireg;\n+  rtx offset;\n+\n+  switch (GET_CODE (addr))\n+    {\n+      case REG:\n+#ifdef MOTOROLA\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (addr)]);\n+#else\n+\tfprintf (file, \"%s@\", reg_names[REGNO (addr)]);\n+#endif\n+\tbreak;\n+      case PRE_DEC:\n+#ifdef MOTOROLA\n+\tfprintf (file, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\n+#else\n+\tfprintf (file, \"%s@-\", reg_names[REGNO (XEXP (addr, 0))]);\n+#endif\n+\tbreak;\n+      case POST_INC:\n+#ifdef MOTOROLA\n+\tfprintf (file, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\n+#else\n+\tfprintf (file, \"%s@+\", reg_names[REGNO (XEXP (addr, 0))]);\n+#endif\n+\tbreak;\n+      case PLUS:\n+\treg1 = reg2 = ireg = breg = offset = 0;\n+\tif (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\n+\t  {\n+\t    offset = XEXP (addr, 0);\n+\t    addr = XEXP (addr, 1);\n+\t  }\n+\telse if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n+\t  {\n+\t    offset = XEXP (addr, 1);\n+\t    addr = XEXP (addr, 0);\n+\t  }\n+\tif (GET_CODE (addr) != PLUS)\n+\t  {\n+\t    ;\n+\t  }\n+\telse if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\n+\t  {\n+\t    reg1 = XEXP (addr, 0);\n+\t    addr = XEXP (addr, 1);\n+\t  }\n+\telse if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\n+\t  {\n+\t    reg1 = XEXP (addr, 1);\n+\t    addr = XEXP (addr, 0);\n+\t  }\n+\telse if (GET_CODE (XEXP (addr, 0)) == MULT)\n+\t  {\n+\t    reg1 = XEXP (addr, 0);\n+\t    addr = XEXP (addr, 1);\n+\t  }\n+\telse if (GET_CODE (XEXP (addr, 1)) == MULT)\n+\t  {\n+\t    reg1 = XEXP (addr, 1);\n+\t    addr = XEXP (addr, 0);\n+\t  }\n+\telse if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t  {\n+\t    reg1 = XEXP (addr, 0);\n+\t    addr = XEXP (addr, 1);\n+\t  }\n+\telse if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t  {\n+\t    reg1 = XEXP (addr, 1);\n+\t    addr = XEXP (addr, 0);\n+\t  }\n+\tif (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\n+\t    || GET_CODE (addr) == SIGN_EXTEND)\n+\t  {\n+\t    if (reg1 == 0)\n+\t      {\n+\t\treg1 = addr;\n+\t      }\n+\t    else\n+\t      {\n+\t\treg2 = addr;\n+\t      }\n+\t    addr = 0;\n+\t  }\n+#if 0\t/* for OLD_INDEXING */\n+\telse if (GET_CODE (addr) == PLUS)\n+\t  {\n+\t    if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t      {\n+\t\treg2 = XEXP (addr, 0);\n+\t\taddr = XEXP (addr, 1);\n+\t      }\n+\t    else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t      {\n+\t\treg2 = XEXP (addr, 1);\n+\t\taddr = XEXP (addr, 0);\n+\t      }\n+\t  }\n+#endif\n+\tif (offset != 0)\n+\t  {\n+\t    if (addr != 0)\n+\t      {\n+\t\tabort ();\n+\t      }\n+\t    addr = offset;\n+\t  }\n+\tif ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\n+\t\t      || GET_CODE (reg1) == MULT))\n+\t    || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\n+\t  {\n+\t    breg = reg2;\n+\t    ireg = reg1;\n+\t  }\n+\telse if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\n+\t  {\n+\t    breg = reg1;\n+\t    ireg = reg2;\n+\t  }\n+\tif (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF\n+ \t  && ! (flag_pic && ireg == pic_offset_table_rtx))\n+\t  {\n+\t    int scale = 1;\n+\t    if (GET_CODE (ireg) == MULT)\n+\t      {\n+\t\tscale = INTVAL (XEXP (ireg, 1));\n+\t\tireg = XEXP (ireg, 0);\n+\t      }\n+\t    if (GET_CODE (ireg) == SIGN_EXTEND)\n+\t      {\n+#ifdef MOTOROLA\n+#ifdef SGS\n+\t\tasm_fprintf (file, \"%LLD%d(%Rpc,%s.w\",\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     reg_names[REGNO (XEXP (ireg, 0))]);\n+#else\n+\t\tasm_fprintf (file, \"%LL%d-%LLI%d-2.b(%Rpc,%s.w\",\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     reg_names[REGNO (XEXP (ireg, 0))]);\n+#endif\n+#else\n+\t\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:w\",\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     reg_names[REGNO (XEXP (ireg, 0))]);\n+#endif\n+\t      }\n+\t    else\n+\t      {\n+#ifdef MOTOROLA\n+#ifdef SGS\n+\t\tasm_fprintf (file, \"%LLD%d(%Rpc,%s.l\",\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     reg_names[REGNO (ireg)]);\n+#else\n+\t\tasm_fprintf (file, \"%LL%d-%LLI%d-2.b(%Rpc,%s.l\",\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     reg_names[REGNO (ireg)]);\n+#endif\n+#else\n+\t\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:l\",\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t     reg_names[REGNO (ireg)]);\n+#endif\n+\t      }\n+\t    if (scale != 1)\n+\t      {\n+#ifdef MOTOROLA\n+\t\tfprintf (file, \"*%d\", scale);\n+#else\n+\t\tfprintf (file, \":%d\", scale);\n+#endif\n+\t      }\n+\t    putc (')', file);\n+\t    break;\n+\t  }\n+\tif (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF\n+ \t  && ! (flag_pic && breg == pic_offset_table_rtx))\n+\t  {\n+#ifdef MOTOROLA\n+#ifdef SGS\n+\t    asm_fprintf (file, \"%LLD%d(%Rpc,%s.l\",\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t reg_names[REGNO (breg)]);\n+#else\n+\t    asm_fprintf (file, \"%LL%d-%LLI%d-2.b(%Rpc,%s.l\",\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t reg_names[REGNO (breg)]);\n+#endif\n+#else\n+\t    asm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:l\",\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t reg_names[REGNO (breg)]);\n+#endif\n+\t    putc (')', file);\n+\t    break;\n+\t  }\n+\tif (ireg != 0 || breg != 0)\n+\t  {\n+\t    int scale = 1;\n+\t    if (breg == 0)\n+\t      {\n+\t\tabort ();\n+\t      }\n+\t    if (! flag_pic && addr && GET_CODE (addr) == LABEL_REF)\n+\t      {\n+\t\tabort ();\n+\t      }\n+#ifdef MOTOROLA\n+\t    if (addr != 0)\n+\t      {\n+\t\toutput_addr_const (file, addr);\n+\t        if ((flag_pic == 1) && (breg == pic_offset_table_rtx))\n+\t          fprintf (file, \":w\");\n+\t        if ((flag_pic == 2) && (breg == pic_offset_table_rtx))\n+\t          fprintf (file, \":l\");\n+\t      }\n+\t    fprintf (file, \"(%s\", reg_names[REGNO (breg)]);\n+\t    if (ireg != 0)\n+\t      {\n+\t\tputc (',', file);\n+\t      }\n+#else\n+\t    fprintf (file, \"%s@(\", reg_names[REGNO (breg)]);\n+\t    if (addr != 0)\n+\t      {\n+\t\toutput_addr_const (file, addr);\n+\t        if ((flag_pic == 1) && (breg == pic_offset_table_rtx))\n+\t          fprintf (file, \":w\");\n+\t        if ((flag_pic == 2) && (breg == pic_offset_table_rtx))\n+\t          fprintf (file, \":l\");\n+\t      }\n+\t    if (addr != 0 && ireg != 0)\n+\t      {\n+\t\tputc (',', file);\n+\t      }\n+#endif\n+\t    if (ireg != 0 && GET_CODE (ireg) == MULT)\n+\t      {\n+\t\tscale = INTVAL (XEXP (ireg, 1));\n+\t\tireg = XEXP (ireg, 0);\n+\t      }\n+\t    if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\n+\t      {\n+#ifdef MOTOROLA\n+\t\tfprintf (file, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\n+#else\n+\t\tfprintf (file, \"%s:w\", reg_names[REGNO (XEXP (ireg, 0))]);\n+#endif\n+\t      }\n+\t    else if (ireg != 0)\n+\t      {\n+#ifdef MOTOROLA\n+\t\tfprintf (file, \"%s.l\", reg_names[REGNO (ireg)]);\n+#else\n+\t\tfprintf (file, \"%s:l\", reg_names[REGNO (ireg)]);\n+#endif\n+\t      }\n+\t    if (scale != 1)\n+\t      {\n+#ifdef MOTOROLA\n+\t\tfprintf (file, \"*%d\", scale);\n+#else\n+\t\tfprintf (file, \":%d\", scale);\n+#endif\n+\t      }\n+\t    putc (')', file);\n+\t    break;\n+\t  }\n+\telse if (reg1 != 0 && GET_CODE (addr) == LABEL_REF\n+ \t       && ! (flag_pic && reg1 == pic_offset_table_rtx))\t\n+\t  {\n+#ifdef MOTOROLA\n+#ifdef SGS\n+\t    asm_fprintf (file, \"%LLD%d(%Rpc,%s.l)\",\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t reg_names[REGNO (reg1)]);\n+#else\n+\t    asm_fprintf (file, \"%LL%d-%LLI%d-2.b(%Rpc,%s.l)\",\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t reg_names[REGNO (reg1)]);\n+#endif\n+#else\n+\t    asm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:l)\",\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t reg_names[REGNO (reg1)]);\n+#endif\n+\t    break;\n+\t  }\n+\t/* FALL-THROUGH (is this really what we want? */\n+      default:\n+        if (GET_CODE (addr) == CONST_INT\n+\t    && INTVAL (addr) < 0x8000\n+\t    && INTVAL (addr) >= -0x8000)\n+\t  {\n+#ifdef MOTOROLA\n+#ifdef SGS\n+\t    /* Many SGS assemblers croak on size specifiers for constants. */\n+\t    fprintf (file, \"%d\", INTVAL (addr));\n+#else\n+\t    fprintf (file, \"%d.w\", INTVAL (addr));\n+#endif\n+#else\n+\t    fprintf (file, \"%d:w\", INTVAL (addr));\n+#endif\n+\t  }\n+\telse\n+\t  {\n+\t    output_addr_const (file, addr);\n+\t  }\n+\tbreak;\n+    }\n+}"}, {"sha": "fb285829839c4b345e72d85a60585f2e509b27d9", "filename": "gcc/config/m88k/m88k.h", "status": "added", "additions": 2223, "deletions": 0, "changes": 2223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e68feb317b00bda42db706667eccc7619c0a30/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e68feb317b00bda42db706667eccc7619c0a30/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=79e68feb317b00bda42db706667eccc7619c0a30", "patch": "@@ -0,0 +1,2223 @@\n+/* Definitions of target machine for GNU compiler.\n+   Motorola m88100 in an 88open OCS/BCS environment.\n+   Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@mcc.com)\n+   Enhanced by Michael Meissner (meissner@osf.org)\n+   Currently supported by Tom Wood (wood@dg-rtp.dg.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* The m88100 port of GNU CC adheres to the various standards from 88open.\n+   These documents are available by writing:\n+\n+\t88open Consortium Ltd.\n+\t100 Homeland Court, Suite 800\n+\tSan Jose, CA  95112\n+\t(408) 436-6600\n+\n+   In brief, the current standards are:\n+\n+   Binary Compatibility Standard, Release 1.1A, May 1991\n+\tThis provides for portability of application-level software at the\n+\texecutable level for AT&T System V Release 3.2.\n+\n+   Object Compatibility Standard, Release 1.1A, May 1991\n+\tThis provides for portability of application-level software at the\n+\tobject file and library level for C, Fortran, and Cobol, and again,\n+\tlargely for SVR3.\n+\n+   Under development are standards for AT&T System V Release 4, based on the\n+   [generic] System V Application Binary Interface from AT&T.  These include:\n+\n+   System V Application Binary Interface, Motorola 88000 Processor Supplement\n+\tAnother document from AT&T for SVR4 specific to the m88100.\n+\tAvailable from Prentice Hall.\n+\n+   System V Application Binary Interface, Motorola 88000 Processor Supplement,\n+   Release 1.1, Draft H, May 6, 1991\n+\tA proposed update to the AT&T document from 88open.\n+\n+   System V ABI Implementation Guide for the M88000 Processor,\n+   Release 1.0, January 1991\n+\tA companion ABI document from 88open.  */\n+\n+/* Other m88k*.h files include this one and override certain items.\n+   At present, these are m88kv3.h, m88kv4.h, m88kdgux.h, and m88kluna.h.\n+   Additionally, m88kv4.h and m88kdgux.h include svr4.h first.  All other\n+   m88k targets except m88kluna.h are based on svr3.h.  */\n+\n+/* Choose SVR3 as the default.  */\n+#if !defined(DBX_DEBUGGING_INFO) && !defined(DWARF_DEBUGGING_INFO)\n+#include \"svr3.h\"\n+#endif\n+\f\n+/* External types used.  */\n+\n+/* What instructions are needed to manufacture an integer constant.  */\n+enum m88k_instruction {\n+  m88k_zero,\n+  m88k_or,\n+  m88k_subu,\n+  m88k_or_lo16,\n+  m88k_or_lo8,\n+  m88k_set,\n+  m88k_oru_hi16,\n+  m88k_oru_or\n+};\n+\n+/* External variables/functions defined in m88k.c.  */\n+\n+extern char *m88k_pound_sign;\n+extern char *m88k_short_data;\n+\n+extern int m88k_gp_threshold;\n+extern int m88k_prologue_done;\n+extern int m88k_function_number;\n+extern int m88k_fp_offset;\n+extern int m88k_stack_size;\n+extern int m88k_case_index;\n+\n+extern struct rtx_def *m88k_compare_reg;\n+extern struct rtx_def *m88k_compare_op0;\n+extern struct rtx_def *m88k_compare_op1;\n+\n+extern int null_epilogue ();\n+extern int integer_ok_for_set ();\n+extern int m88k_debugger_offset ();\n+extern void m88k_handle_pragma_token ();\n+\n+extern void emit_bcnd ();\n+extern void expand_block_move ();\n+extern void check_float_value ();\n+extern void m88k_layout_frame ();\n+extern void m88k_output_prologue ();\n+extern void m88k_output_epilogue ();\n+extern void output_function_profiler ();\n+extern void output_function_block_profiler ();\n+extern void output_block_profiler ();\n+extern void output_file_start ();\n+extern void output_ascii ();\n+extern void output_label ();\n+extern void print_operand ();\n+extern void print_operand_address ();\n+\n+extern char *output_load_const_int ();\n+extern char *output_load_const_float ();\n+extern char *output_load_const_double ();\n+extern char *output_load_const_dimode ();\n+extern char *output_and ();\n+extern char *output_ior ();\n+extern char *output_xor ();\n+extern char *output_call ();\n+\n+extern struct rtx_def *emit_test ();\n+extern struct rtx_def *legitimize_address ();\n+extern struct rtx_def *legitimize_operand ();\n+extern struct rtx_def *m88k_function_arg ();\n+extern struct rtx_def *m88k_builtin_saveregs ();\n+\n+extern enum m88k_instruction classify_integer ();\n+\n+/* external variables defined elsewhere in the compiler */\n+\n+extern int target_flags;\t\t\t/* -m compiler switches */\n+extern int frame_pointer_needed;\t\t/* current function has a FP */\n+extern int current_function_pretend_args_size;\t/* args size without ... */\n+extern int flag_delayed_branch;\t\t\t/* -fdelayed-branch */\n+extern int flag_pic;\t\t\t\t/* -fpic */\n+extern char * reg_names[];\n+\n+/* Specify the default monitors.  The meaning of these values can\n+   be obtained by doing \"grep MONITOR_GCC *m88k*\".  Generally, the\n+   values downward from 0x8000 are tests that will soon go away.\n+   values upward from 0x1 are generally useful tests that will remain.  */\n+\n+#ifndef MONITOR_GCC\n+#define MONITOR_GCC 0\n+#endif\n+\f\n+/*** Controlling the Compilation Driver, `gcc' ***/\n+\n+/* Some machines may desire to change what optimizations are performed for\n+   various optimization levels.   This macro, if defined, is executed once\n+   just after the optimization level is determined and before the remainder\n+   of the command options have been parsed.  Values set in this macro are\n+   used as the default values for the other command line options.\n+\n+   LEVEL is the optimization level specified; 2 if -O2 is specified,\n+   1 if -O is specified, and 0 if neither is specified.  */\n+\n+/* This macro used to store 0 in flag_signed_bitfields.\n+   Not only is that misuse of this macro; the whole idea is wrong.\n+\n+   The GNU C dialect makes bitfields signed by default,\n+   regardless of machine type.  Making any machine inconsistent in this\n+   regard is bad for portability.\n+\n+   I chose to make bitfields signed by default because this is consistent\n+   with the way ordinary variables are handled: `int' equals `signed int'.\n+   If there is a good reason to prefer making bitfields unsigned by default,\n+   it cannot have anything to do with the choice of machine.\n+   If the reason is good enough, we should change the convention for all machines.\n+\n+   -- rms, 20 July 1991.  */\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (LEVEL)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tflag_omit_frame_pointer = 1;\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* LIB_SPEC, LINK_SPEC, and STARTFILE_SPEC defined in svr3.h.\n+   ASM_SPEC, ASM_FINAL_SPEC, LIB_SPEC, LINK_SPEC, and STARTFILE_SPEC redefined\n+   in svr4.h.\n+   CPP_SPEC, ASM_SPEC, ASM_FINAL_SPEC, LIB_SPEC, LINK_SPEC, and\n+   STARTFILE_SPEC redefined in m88kdgux.h.  */\n+\f\n+/*** Run-time Target Specification ***/\n+\n+/* Names to predefine in the preprocessor for this target machine.\n+   Redefined in m88kv3.h, m88kv4.h, m88kdgux.h, and m88kluna.h.  */\n+#define CPP_PREDEFINES \"-Dm88000 -Dm88k -Dunix -D__CLASSIFY_TYPE__=2\"\n+\n+#define TARGET_VERSION fprintf (stderr, \" (%s%s)\", \\\n+\t\t\t\tVERSION_INFO1, VERSION_INFO2)\n+\n+/* Print subsidiary information on the compiler version in use.\n+   Redefined in m88kv4.h, and m88kluna.h.  */\n+#define VERSION_INFO1\t\"88open OCS/BCS, \"\n+#define VERSION_INFO2\t\"03 Feb 1992\"\n+#define VERSION_STRING\tversion_string\n+#define\tTM_SCCS_ID\t\"@(#)m88k.h\t1.96.5.3 03 Feb 1992 09:39:25\"\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define MASK_88100\t\t0x00000001 /* Target m88100 */\n+#define MASK_88110\t\t0x00000002 /* Target m88110 */\n+#define MASK_OCS_DEBUG_INFO\t0x00000004 /* Emit .tdesc info */\n+#define MASK_OCS_FRAME_POSITION\t0x00000008 /* Debug frame = CFA, not r30 */\n+#define MASK_SVR4\t\t0x00000010 /* Target is AT&T System V.4 */\n+#define MASK_VERSION_0300\t0x00000020 /* Use version 03.00 syntax */\n+#define MASK_NO_UNDERSCORES\t0x00000040 /* Don't emit a leading `_' */\n+#define MASK_BIG_PIC\t\t0x00000080 /* PIC with large got-rel's -fPIC */\n+#define MASK_TRAP_LARGE_SHIFT\t0x00000100 /* Trap if shift not <= 31 */\n+#define MASK_HANDLE_LARGE_SHIFT\t0x00000200 /* Handle shift count >= 32 */\n+#define MASK_CHECK_ZERO_DIV\t0x00000400 /* Check for int div. by 0 */\n+#define MASK_USE_DIV\t\t0x00000800 /* No signed div. checks */\n+#define MASK_IDENTIFY_REVISION\t0x00001000 /* Emit ident, with GCC rev */\n+#define MASK_WARN_PASS_STRUCT\t0x00002000 /* Warn about passed structs */\n+#define MASK_OPTIMIZE_ARG_AREA\t0x00004000 /* Save stack space */\n+\n+#define MASK_88000 (MASK_88100 | MASK_88110)\n+#define MASK_EITHER_LARGE_SHIFT\t(MASK_TRAP_LARGE_SHIFT | \\\n+\t\t\t\t MASK_HANDLE_LARGE_SHIFT)\n+\n+#define TARGET_88100   \t\t ((target_flags & MASK_88000) == MASK_88100)\n+#define TARGET_88110\t\t ((target_flags & MASK_88000) == MASK_88110)\n+#define TARGET_88000\t\t ((target_flags & MASK_88000) == MASK_88000)\n+\n+#define TARGET_OCS_DEBUG_INFO\t  (target_flags & MASK_OCS_DEBUG_INFO)\n+#define TARGET_OCS_FRAME_POSITION (target_flags & MASK_OCS_FRAME_POSITION)\n+#define TARGET_SVR4\t\t  (target_flags & MASK_SVR4)\n+#define TARGET_VERSION_0300\t  (target_flags & MASK_VERSION_0300)\n+#define TARGET_NO_UNDERSCORES\t  (target_flags & MASK_NO_UNDERSCORES)\n+#define TARGET_BIG_PIC\t\t  (target_flags & MASK_BIG_PIC)\n+#define TARGET_TRAP_LARGE_SHIFT   (target_flags & MASK_TRAP_LARGE_SHIFT)\n+#define TARGET_HANDLE_LARGE_SHIFT (target_flags & MASK_HANDLE_LARGE_SHIFT)\n+#define TARGET_CHECK_ZERO_DIV\t  (target_flags & MASK_CHECK_ZERO_DIV)\n+#define\tTARGET_USE_DIV\t\t  (target_flags & MASK_USE_DIV)\n+#define TARGET_IDENTIFY_REVISION  (target_flags & MASK_IDENTIFY_REVISION)\n+#define TARGET_WARN_PASS_STRUCT   (target_flags & MASK_WARN_PASS_STRUCT)\n+#define TARGET_OPTIMIZE_ARG_AREA  (target_flags & MASK_OPTIMIZE_ARG_AREA)\n+\n+#define TARGET_EITHER_LARGE_SHIFT (target_flags & MASK_EITHER_LARGE_SHIFT)\n+\n+/*  Redefined in m88kv3.h,m88kv4.h, and m88kdgux.h.  */\n+#define TARGET_DEFAULT\t(MASK_CHECK_ZERO_DIV)\n+#define CPU_DEFAULT MASK_88100\n+\n+#define TARGET_SWITCHES \\\n+  { \\\n+    { \"88110\",\t\t\t\t MASK_88110 }, \\\n+    { \"88100\",\t\t\t\t MASK_88100 }, \\\n+    { \"88000\",\t\t\t         MASK_88000 }, \\\n+    { \"ocs-debug-info\",\t\t\t MASK_OCS_DEBUG_INFO }, \\\n+    { \"no-ocs-debug-info\",\t\t-MASK_OCS_DEBUG_INFO }, \\\n+    { \"ocs-frame-position\",\t\t MASK_OCS_FRAME_POSITION }, \\\n+    { \"no-ocs-frame-position\",\t\t-MASK_OCS_FRAME_POSITION }, \\\n+    { \"svr4\",\t\t\t         MASK_SVR4 }, \\\n+    { \"svr3\",\t\t\t        -MASK_SVR4 }, \\\n+    { \"version-03.00\",\t\t         MASK_VERSION_0300 }, \\\n+    { \"no-underscores\",\t\t\t MASK_NO_UNDERSCORES }, \\\n+    { \"big-pic\",\t\t\t MASK_BIG_PIC }, \\\n+    { \"trap-large-shift\",\t\t MASK_TRAP_LARGE_SHIFT }, \\\n+    { \"handle-large-shift\",\t\t MASK_HANDLE_LARGE_SHIFT }, \\\n+    { \"check-zero-division\",\t\t MASK_CHECK_ZERO_DIV }, \\\n+    { \"no-check-zero-division\",\t\t-MASK_CHECK_ZERO_DIV }, \\\n+    { \"use-div-instruction\",\t\t MASK_USE_DIV }, \\\n+    { \"identify-revision\",\t\t MASK_IDENTIFY_REVISION }, \\\n+    { \"warn-passed-structs\",\t\t MASK_WARN_PASS_STRUCT }, \\\n+    { \"optimize-arg-area\",\t\t MASK_OPTIMIZE_ARG_AREA }, \\\n+    { \"no-optimize-arg-area\",\t\t-MASK_OPTIMIZE_ARG_AREA }, \\\n+    SUBTARGET_SWITCHES \\\n+    /* Default switches */ \\\n+    { \"\",\t\t\t\t TARGET_DEFAULT }, \\\n+  }\n+\n+/* Redefined in m88kdgux.h.  */\n+#define SUBTARGET_SWITCHES\n+\n+/* Macro to define table for command options with values.  */\n+\n+#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }\n+\n+/* Do any checking or such that is needed after processing the -m switches.  */\n+\n+#define OVERRIDE_OPTIONS\t\t\t\t\t\t     \\\n+  do {\t\t\t\t\t\t\t\t\t     \\\n+    register int i;\t\t\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+    if ((target_flags & MASK_88000) == 0)\t\t\t\t     \\\n+      target_flags |= CPU_DEFAULT;\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+    if (TARGET_BIG_PIC)\t\t\t\t\t\t\t     \\\n+      flag_pic = 2;\t\t\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+    if ((target_flags & MASK_EITHER_LARGE_SHIFT) == MASK_EITHER_LARGE_SHIFT) \\\n+      error (\"-mtrap-large-shift and -mhandle-large-shift are incompatible\");\\\n+\t\t\t\t\t\t\t\t\t     \\\n+    if (VERSION_0300_SYNTAX)\t\t\t\t\t\t     \\\n+      {\t\t\t\t\t\t\t\t\t     \\\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t     \\\n+\t  reg_names[i]--;\t\t\t\t\t\t     \\\n+\tm88k_pound_sign = \"#\";\t\t\t\t\t\t     \\\n+      }\t\t\t\t\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+    if (m88k_short_data)\t\t\t\t\t\t     \\\n+      {\t\t\t\t\t\t\t\t\t     \\\n+\tchar *p = m88k_short_data;\t\t\t\t\t     \\\n+\twhile (*p)\t\t\t\t\t\t\t     \\\n+\t  if (*p >= '0' && *p <= '9')\t\t\t\t\t     \\\n+\t    p++;\t\t\t\t\t\t\t     \\\n+\t  else\t\t\t\t\t\t\t\t     \\\n+\t    {\t\t\t\t\t\t\t\t     \\\n+\t      error (\"Invalid option `-mshort-data-%s'\", m88k_short_data);   \\\n+\t      break;\t\t\t\t\t\t\t     \\\n+\t    }\t\t\t\t\t\t\t\t     \\\n+\tm88k_gp_threshold = atoi (m88k_short_data);\t\t\t     \\\n+\tif (flag_pic)\t\t\t\t\t\t\t     \\\n+\t  error (\"-mshort-data-%s and PIC are incompatible\", m88k_short_data); \\\n+      }\t\t\t\t\t\t\t\t\t     \\\n+  } while (0)\n+\f\n+/*** Storage Layout ***/\n+\n+/* Sizes in bits of the various types.  */\n+#define CHAR_TYPE_SIZE\t\t 8\n+#define SHORT_TYPE_SIZE\t\t16\n+#define INT_TYPE_SIZE\t\t32\n+#define LONG_TYPE_SIZE\t\t32\n+#define LONG_LONG_TYPE_SIZE\t64\n+#define FLOAT_TYPE_SIZE\t\t32\n+#define\tDOUBLE_TYPE_SIZE\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   Somewhat arbitrary.  It matches the bit field patterns.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.\n+   That is true on the m88000.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.\n+   For the m88000 we can decide arbitrarily since there are no machine\n+   instructions for them.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Largest alignment for stack parameters (if greater than PARM_BOUNDARY).  */\n+#define MAX_PARM_BOUNDARY 64\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 128\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 128\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Alignment of field after `int : 0' in a structure.\n+   Ignored with PCC_BITFIELD_TYPE_MATTERS.  */\n+/* #define EMPTY_FIELD_BOUNDARY 8 */\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Maximum size (in bits) to use for the largest integral type that\n+   replaces a BLKmode type. */\n+/* #define MAX_FIXED_MODE_SIZE 0 */\n+\n+/* Report errors on floating point, if we are given NaN's, or such.  Leave\n+   the number as is, though, since we output the number in hex, and the\n+   assemble won't choak on it.  */\n+#define CHECK_FLOAT_VALUE(MODE,VALUE) check_float_value (MODE, VALUE)\n+\n+/* A code distinguishing the floating point format of the target machine.  */\n+/* #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT */\n+\f\n+/*** Register Usage ***/\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   The m88100 has 32 fullword registers.\n+\n+   The pseudo argument pointer is said to be register 0.  This prohibits\n+   the use of r0 as a general register and causes no trouble.\n+   Using register 0 is useful, in that it keeps the number of\n+   registers down to 32, and GNU can use a long as a bitmask\n+   for the registers.  */\n+#define FIRST_PSEUDO_REGISTER 32\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   Registers 14-25 are expected to be preserved across\n+   function calls.\n+\n+   On the 88000, these are:\n+   Reg 0\t= Pseudo argument pointer (hardware fixed to 0).\n+   Reg 1\t= Subroutine return pointer (hardware).\n+   Reg 2-9\t= Parameter registers (OCS).\n+   Reg 10\t= OCS reserved temporary.\n+   Reg 11\t= Static link if needed [OCS reserved temporary].\n+   Reg 12\t= Address of structure return (OCS).\n+   Reg 13\t= OCS reserved temporary.\n+   Reg 14-25\t= Preserved register set.\n+   Reg 26-29\t= Reserved by OCS and ABI.\n+   Reg 30\t= Frame pointer (Common use).\n+   Reg 31\t= Stack pointer.  */\n+\n+#define FIXED_REGISTERS \\\n+ {1, 1, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n+  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 1, 1,  1, 1, 1, 1,   1, 1, 1, 1,  1, 1, 0, 0, \\\n+  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1}\n+\n+/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+\tglobal_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+/* These interfaces that don't apply to the m88000.  */\n+/* OVERLAPPING_REGNO_P(REGNO) 0 */\n+/* INSN_CLOBBERS_REGNO_P(INSN, REGNO) 0 */\n+/* PRESERVE_DEATH_INFO_REGNO_P(REGNO) 0 */\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the m88000, ordinary registers hold 32 bits worth;\n+   a single floating point register is always enough for\n+   anything that can be stored in them at all.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+\n+   For double integers, we never put the value into an odd register so that\n+   the operators don't run into the situation where the high part of one of\n+   the inputs is the low part of the result register (it's ok if the output\n+   registers are the same as the input registers.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n+  (((MODE) != DImode && (MODE) != DFmode && (MODE) != DCmode) ||\t\\\n+   ((REGNO) & 1) == 0)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  (((MODE1) == DFmode || (MODE1) == DCmode || (MODE1) == DImode) \\\n+   == ((MODE2) == DFmode || (MODE2) == DCmode || (MODE2) == DImode))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* the m88000 pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 31\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 30\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 0\n+\n+/* Register used in cases where a temporary is known to be safe to use.  */\n+#define TEMP_REGNUM 10\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 11\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 12\n+\n+/* Register to hold the addressing base for position independent\n+   code access to data items.  */\n+#define PIC_OFFSET_TABLE_REGNUM 25\n+\n+/* Order in which registers are preferred (most to least).  Use temp\n+   registers, then param registers top down.  Preserve registers are\n+   top down to maximize use of double memory ops for register save.\n+   The 88open reserved registers (26-29) may commonly be used in most\n+   environments with the -fcall-used- or -fcall-saved- options.  */\n+#define REG_ALLOC_ORDER \\\n+ {13, 12, 11, 10, 29, 28, 27, 26, \\\n+   1,  9,  8,  7,  6,  5,  4,  3, \\\n+   2, 25, 24, 23, 22, 21, 20, 19, \\\n+  18, 17, 16, 15, 14, 30, 31, 0}\n+\f\n+/*** Register Classes ***/\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The m88100 hardware has one kind of register.  However, we denote\n+   the arg pointer as a separate class.  */\n+\n+enum reg_class { NO_REGS, AP_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+#define REG_CLASS_NAMES {\"NO_REGS\", \"AP_REG\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+#define REG_CLASS_CONTENTS {0, 1, -2, -1}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+#define REGNO_REG_CLASS(REGNO) ((REGNO) ? GENERAL_REGS : AP_REG)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define BASE_REG_CLASS ALL_REGS\n+#define INDEX_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+\n+/* Macros to check register numbers against specific register classes.\n+   These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+  ((REGNO) < FIRST_PSEUDO_REGISTER || \\\n+   (unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER)\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+  (((REGNO) && (REGNO) < FIRST_PSEUDO_REGISTER) || \\\n+   (unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+   Double constants should be in a register iff they can be made cheaply.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Letters in the range `I' through `P' in a register constraint string can\n+   be used to stand for particular ranges of immediate operands.  The C\n+   expression is true iff C is a known letter and VALUE is appropriate for\n+   that letter.\n+\n+   For the m88000,  the following contraints are used:\n+   `I' requires a non-negative 16-bit value.\n+   `J' requires a non-positive 16-bit value.\n+   `K' is unused.\n+   `L' requires a constant with only the upper 16-bits set.\n+   `M' requires constant values that can be formed with `set'.\n+   `N' requires a negative value.\n+   `O' requires zero.\n+   `P' requires a non-negative value.  */\n+\n+/* Quick tests for certain values.  */\n+#define SMALL_INT(X) (SMALL_INTVAL (INTVAL (X)))\n+#define SMALL_INTVAL(I) ((unsigned) (I) < 0x10000)\n+#define ADD_INT(X) (ADD_INTVAL (INTVAL (X)))\n+#define ADD_INTVAL(I) ((unsigned) (I) + 0xffff < 0x1ffff)\n+#define POWER_OF_2(I) ((I) && POWER_OF_2_or_0(I))\n+#define POWER_OF_2_or_0(I) (((I) & ((unsigned)(I) - 1)) == 0)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\\\n+  ((C) == 'I' ? SMALL_INTVAL (VALUE)\t\t\t\\\n+   : (C) == 'J' ? SMALL_INTVAL (-(VALUE))\t\t\\\n+   : (C) == 'L' ? ((VALUE) & 0xffff) == 0\t\t\\\n+   : (C) == 'M' ? integer_ok_for_set (VALUE)\t\t\\\n+   : (C) == 'N' ? (VALUE) < 0\t\t\t\t\\\n+   : (C) == 'O' ? (VALUE) == 0\t\t\t\t\\\n+   : (C) == 'P' ? (VALUE) >= 0\t\t\t\t\\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  For the m88000, the\n+   constraints are:  `G' requires zero, and `H' requires one or two.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'G' ? (CONST_DOUBLE_HIGH (VALUE) == 0\t\t\t\t\\\n+\t\t && CONST_DOUBLE_LOW (VALUE) == 0)\t\t\t\\\n+   : 0)\n+\n+/* Letters in the range `Q' through `U' in a register constraint string\n+   may be defined in a machine-dependent fashion to stand for arbitrary\n+   operand types.\n+\n+   For the m88k, `Q' handles addresses in a call context.  */\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ? symbolic_address_p (OP) : 0)\n+\f\n+/*** Describing Stack Layout ***/\n+\n+/* Define this if pushing a word on the stack moves the stack pointer\n+   to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the addresses of local variable slots are at negative\n+   offsets from the frame pointer.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset from the frame pointer to the first local variable slot to be\n+   allocated. For the m88k, the debugger wants the return address (r1)\n+   stored at location r30+4, and the previous frame pointer stored at\n+   location r30.  */\n+#define STARTING_FRAME_OFFSET 8\n+\n+/* If we generate an insn to push BYTES bytes, this says how many the\n+   stack pointer really advances by.  The m88k has no push instruction.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* If defined, the maximum amount of space required for outgoing arguments\n+   will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Offset from the stack pointer register to the first location at which\n+   outgoing arguments are placed.  Use the default value zero.  */\n+/* #define STACK_POINTER_OFFSET 0 */\n+\n+/* Offset of first parameter from the argument pointer register value.\n+   Using an argument pointer, this is 0 for the m88k.  GCC knows\n+   how to eliminate the argument pointer references if necessary.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Define this if functions should assume that stack space has been\n+   allocated for arguments even when their values are passed in\n+   registers.\n+\n+   The value of this macro is the size, in bytes, of the area reserved for\n+   arguments passed in registers.\n+\n+   This space can either be allocated by the caller or be a part of the\n+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'\n+   says which.  */\n+#define REG_PARM_STACK_SPACE(FNDECL) 32\n+\n+/* Define this macro if REG_PARM_STACK_SPACE is defined but stack\n+   parameters don't skip the area specified by REG_PARM_STACK_SPACE.\n+   Normally, when a parameter is not passed in registers, it is placed on\n+   the stack beyond the REG_PARM_STACK_SPACE area.  Defining this macro\n+   suppresses this behavior and causes the parameter to be passed on the\n+   stack in its natural location.  */\n+#define STACK_PARMS_IN_REG_PARM_AREA\n+\n+/* Define this if it is the responsibility of the caller to allocate the\n+   area reserved for arguments passed in registers.  If\n+   `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect of this\n+   macro is to determine whether the space is included in\n+   `current_function_outgoing_args_size'.  */\n+/* #define OUTGOING_REG_PARM_STACK_SPACE */\n+\n+/* Offset from the stack pointer register to an item dynamically allocated\n+   on the stack, e.g., by `alloca'.\n+\n+   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n+   length of the outgoing arguments.  The default is correct for most\n+   machines.  See `function.c' for details.  */\n+/* #define STACK_DYNAMIC_OFFSET(FUNDECL) ... */\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  gen_rtx (REG, \\\n+\t   TYPE_MODE (VALTYPE) == BLKmode ? SImode : TYPE_MODE (VALTYPE), \\\n+\t   2)\n+\n+/* Define this if it differs from FUNCTION_VALUE.  */\n+/* #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC) ... */\n+\n+/* Disable the promotion of some structures and unions to registers. */\n+#define RETURN_IN_MEMORY(TYPE) \\\n+  ((TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE(TYPE) == UNION_TYPE) \\\n+   && !(TYPE_MODE (TYPE) == SImode \\\n+\t|| (TYPE_MODE (TYPE) == BLKmode \\\n+\t    && TYPE_ALIGN (TYPE) == BITS_PER_WORD \\\n+\t    && int_size_in_bytes (TYPE) == UNITS_PER_WORD)))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 2)\n+\n+/* True if N is a possible register number for a function value\n+   as seen by the caller.  */\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 2)\n+\n+/* Determine whether a function argument is passed in a register, and\n+   which register.  See m88k.c.  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  m88k_function_arg (CUM, MODE, TYPE, NAMED)\n+\n+/* Define this if it differs from FUNCTION_ARG.  */\n+/* #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) ... */\n+\n+/* A C expression for the number of words, at the beginning of an\n+   argument, must be put in registers.  The value must be zero for\n+   arguments that are passed entirely in registers or that are entirely\n+   pushed on the stack.  */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)\n+\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of the\n+   argument itself.  The pointer is passed in whatever way is appropriate\n+   for passing a pointer to that type.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) (0)\n+\n+/* A C type for declaring a variable that is used as the first argument\n+   of `FUNCTION_ARG' and other related values.  It suffices to count\n+   the number of words of argument so far.  */\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n+   function whose data type is FNTYPE.  For a library call, FNTYPE is 0. */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) ((CUM) = 0)\n+\n+/* A C statement (sans semicolon) to update the summarizer variable\n+   CUM to advance past an argument in the argument list.  The values\n+   MODE, TYPE and NAMED describe that argument.  Once this is done,\n+   the variable CUM is suitable for analyzing the *following* argument\n+   with `FUNCTION_ARG', etc.  (TYPE is null for libcalls where that\n+   information may not be available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    enum machine_mode __mode = (TYPE) ? TYPE_MODE (TYPE) : (MODE);\t\\\n+    if ((CUM & 1)\t\t\t\t\t\t\t\\\n+\t&& (__mode == DImode || __mode == DFmode\t\t\t\\\n+\t    || ((TYPE) && TYPE_ALIGN (TYPE) > BITS_PER_WORD)))\t\t\\\n+      CUM++;\t\t\t\t\t\t\t\t\\\n+    CUM += (((__mode != BLKmode)\t\t\t\t\t\\\n+\t     ? GET_MODE_SIZE (MODE) : int_size_in_bytes (TYPE))\t\t\\\n+\t    + 3) / 4;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* True if N is a possible register number for function argument passing.\n+   On the m88000, these are registers 2 through 9.  */\n+#define FUNCTION_ARG_REGNO_P(N) ((N) <= 9 && (N) >= 2)\n+\n+/* A C expression which determines whether, and in which direction,\n+   to pad out an argument with extra space.  The value should be of\n+   type `enum direction': either `upward' to pad above the argument,\n+   `downward' to pad below, or `none' to inhibit padding.\n+\n+   This macro does not control the *amount* of padding; that is always\n+   just enough to reach the next multiple of `FUNCTION_ARG_BOUNDARY'.  */\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n+  ((MODE) == BLKmode \\\n+   || ((TYPE) && (TREE_CODE (TYPE) == RECORD_TYPE \\\n+\t\t  || TREE_CODE (TYPE) == UNION_TYPE)) \\\n+   ? upward : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY ? downward : none)\n+\n+/* If defined, a C expression that gives the alignment boundary, in bits,\n+   of an argument with the specified mode and type.  If it is not defined,\n+   `PARM_BOUNDARY' is used for all arguments.  */\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+  (((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_SIZE (MODE)) <= PARM_BOUNDARY \\\n+    ? PARM_BOUNDARY : 2 * PARM_BOUNDARY)\n+\n+/* Generate necessary RTL for __builtin_saveregs().\n+   ARGLIST is the argument list; see expr.c.  */\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) m88k_builtin_saveregs (ARGLIST)\n+\n+/* Generate the assembly code for function entry. */\n+#define FUNCTION_PROLOGUE(FILE, SIZE) m88k_output_prologue(FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  Redefined in m88kv3.h, m88kv4.h and\n+   m88kdgux.h.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+  output_function_profiler (FILE, LABELNO, \"mcount\", 1)\n+\n+/* Output assembler code to FILE to initialize basic-block profiling for\n+   the current module.  LABELNO is unique to each instance.  */\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO) \\\n+  output_function_block_profiler (FILE, LABELNO)\n+\n+/* Output assembler code to FILE to increment the count associated with\n+   the basic block number BLOCKNO.  */\n+#define BLOCK_PROFILER(FILE, BLOCKNO) output_block_profiler (FILE, BLOCKNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+#define EXIT_IGNORE_STACK (1)\n+\n+/* Generate the assembly code for function exit. */\n+#define FUNCTION_EPILOGUE(FILE, SIZE) m88k_output_epilogue(FILE, SIZE)\n+\n+/* Define the number of delay slots needed for the function epilogue.\n+   These are used for scheduling the function epilogue and depend on\n+   what the epilogue looks like.  */\n+#define DELAY_SLOTS_FOR_EPILOGUE delay_slots_for_epilogue ()\n+\n+/* Define whether INSN can be placed in delay slot N for the epilogue.  */\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN,N) \\\n+  eligible_for_epilogue_delay (INSN)\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED \\\n+  (frame_pointer_needed \\\n+   || (write_symbols != NO_DEBUG && !TARGET_OCS_FRAME_POSITION))\n+\n+/* Definitions for register eliminations.\n+\n+   We have two registers that can be eliminated on the m88k.  First, the\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer.  */\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+/* Given FROM and TO register numbers, say whether this elimination\n+   is allowed.  */\n+#define CAN_ELIMINATE(FROM, TO) \\\n+  (!((FROM) == FRAME_POINTER_REGNUM && FRAME_POINTER_REQUIRED))\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t \\\n+{ m88k_layout_frame ();\t\t\t\t\t\t\t \\\n+  if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t \\\n+      (OFFSET) = m88k_fp_offset;\t\t\t\t\t \\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM) \\\n+    (OFFSET) = m88k_stack_size - m88k_fp_offset;\t\t\t \\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n+    (OFFSET) = m88k_stack_size;\t\t\t\t\t\t \\\n+  else\t\t\t\t\t\t\t\t\t \\\n+    abort ();\t\t\t\t\t\t\t\t \\\n+}\n+\f\n+/*** Trampolines for Nested Functions ***/\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   This block is placed on the stack and filled in.  It is aligned\n+   0 mod 128 and those portions that are executed are constant.\n+   This should work for instruction caches that have cache lines up\n+   to the aligned amount (128 is arbitrary), provided no other code\n+   producer is attempting to play the same game.  This of course is\n+   in violation of any number of 88open standards.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* Save the return address (r1) in the static chain reg (r11).  */\t\\\n+  fprintf (FILE, \"\\tor\\t %s,%s,0\\n\", reg_names[11], reg_names[1]);\t\\\n+  /* Locate this block; transfer to the next instruction.  */\t\t\\\n+  fprintf (FILE, \"\\tbsr\\t 1\\n\");\t\t\t\t\t\\\n+  /* Save r10; use it as the relative pointer; restore r1.  */\t\t\\\n+  fprintf (FILE, \"\\tst\\t %s,%s,24\\n\", reg_names[10], reg_names[1]);\t\\\n+  fprintf (FILE, \"\\tor\\t %s,%s,0\\n\", reg_names[10], reg_names[1]);\t\\\n+  fprintf (FILE, \"\\tor\\t %s,%s,0\\n\", reg_names[1], reg_names[11]);\t\\\n+  /* Load the function's address and go there.  */\t\t\t\\\n+  fprintf (FILE, \"\\tld\\t %s,%s,32\\n\", reg_names[11], reg_names[10]);\t\\\n+  fprintf (FILE, \"\\tjmp.n\\t %s\\n\", reg_names[11]);\t\t\t\\\n+  /* Restore r10 and load the static chain register.  */\t\t\\\n+  fprintf (FILE, \"\\tld.d\\t %s,%s,24\\n\", reg_names[10], reg_names[10]);\t\\\n+  /* Storage: r10 save area, static chain, function address.  */\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.\n+   This is really two components.  The first 32 bytes are fixed and\n+   must be copied; the last 12 bytes are just storage that's filled\n+   in later.  So for allocation purposes, it's 32+12 bytes, but for\n+   initializaiton purposes, it's 32 bytes.  */\n+\n+#define TRAMPOLINE_SIZE (32+12)\n+\n+/* Alignment required for a trampoline.  128 is used to find the\n+   beginning of a line in the instruction cache and to allow for\n+   instruction cache lines of up to 128 bytes.  */\n+\n+#define TRAMPOLINE_ALIGNMENT 128\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 40)), FNADDR); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 36)), CXT); \\\n+}\n+\n+/*** Library Subroutine Names ***/\n+\n+/* Define this macro if GNU CC should generate calls to the System V\n+   (and ANSI C) library functions `memcpy' and `memset' rather than\n+   the BSD functions `bcopy' and `bzero'.  */\n+#define TARGET_MEM_FUNCTIONS\n+\f\n+/*** Addressing Modes ***/\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X) (CONSTANT_P (X))\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* The condition for memory shift insns.  */\n+#define SCALED_ADDRESS_P(ADDR)\t\t\t\\\n+  (GET_CODE (ADDR) == PLUS\t\t\t\\\n+   && (GET_CODE (XEXP (ADDR, 0)) == MULT\t\\\n+       || GET_CODE (XEXP (ADDR, 1)) == MULT))\n+\n+/* Can the reference to X be made short?  */\n+#define SHORT_ADDRESS_P(X,TEMP) \\\n+  ((TEMP) = (GET_CODE (X) == CONST ? get_related_value (X) : X), \\\n+   ((TEMP) && GET_CODE (TEMP) == SYMBOL_REF && SYMBOL_REF_FLAG (TEMP)))\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the m88000, a legitimate address has the form REG, REG+REG,\n+   REG+SMALLINT, REG+(REG*modesize) (REG[REG]), or SMALLINT.\n+\n+   The register elimination process should deal with the argument\n+   pointer and frame pointer changing to REG+SMALLINT.  */\n+\n+#define LEGITIMATE_INDEX_P(X, MODE)\t\t\t\\\n+   ((GET_CODE (X) == CONST_INT\t\t\t\t\\\n+     && SMALL_INT (X))\t\t\t\t\t\\\n+    || (REG_P (X)\t\t\t\t\t\\\n+\t&& REG_OK_FOR_INDEX_P (X))\t\t\t\\\n+    || (GET_CODE (X) == MULT\t\t\t\t\\\n+\t&& REG_P (XEXP (X, 0))\t\t\t\t\\\n+\t&& REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n+\t&& INTVAL (XEXP (X, 1)) == GET_MODE_SIZE (MODE)))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  register rtx _x;\t\t\t\t\t\\\n+  if (REG_P (X))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (REG_OK_FOR_BASE_P (X))\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      register rtx _x0 = XEXP (X, 0);\t\t\t\\\n+      register rtx _x1 = XEXP (X, 1);\t\t\t\\\n+      if ((flag_pic\t\t\t\t\t\\\n+\t   && _x0 == pic_offset_table_rtx\t\t\\\n+\t   && (flag_pic == 2\t\t\t\t\\\n+\t       ? REG_P (_x1)\t\t\t\t\\\n+\t       : (GET_CODE (_x1) == SYMBOL_REF\t\t\\\n+\t\t  || GET_CODE (_x1) == LABEL_REF)))\t\\\n+\t  || (REG_P (_x0)\t\t\t\t\\\n+\t      && (REG_OK_FOR_BASE_P (_x0)\t\t\\\n+\t\t  && LEGITIMATE_INDEX_P (_x1, MODE)))\t\\\n+\t  || (REG_P (_x1)\t\t\t\t\\\n+\t      && (REG_OK_FOR_BASE_P (_x1)\t\t\\\n+\t\t  && LEGITIMATE_INDEX_P (_x0, MODE))))\t\\\n+\tgoto ADDR;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      register rtx _x0 = XEXP (X, 0);\t\t\t\\\n+      register rtx _x1 = XEXP (X, 1);\t\t\t\\\n+      if (((REG_P (_x0)\t\t\t\t\t\\\n+\t    && REG_OK_FOR_BASE_P (_x0))\t\t\t\\\n+\t   || (GET_CODE (_x0) == SUBREG\t\t\t\\\n+\t       && REG_P (SUBREG_REG (_x0))\t\t\\\n+\t       && REG_OK_FOR_BASE_P (SUBREG_REG (_x0)))) \\\n+\t  && CONSTANT_P (_x1))\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_INT\t\t\t\\\n+\t   && SMALL_INT (X))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  else if (SHORT_ADDRESS_P (X, _x))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  Not the argument pointer.  */\n+#define REG_OK_FOR_INDEX_P(X) (X)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (1)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+/* On the m88000, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n+  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+  if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n+\t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n+    (X) = legitimize_address (flag_pic, X, gen_reg_rtx (Pmode)); \\\n+  if (memory_address_p (MODE, X))\t\t\t\t\\\n+    goto WIN; }\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the the m88000 this is never true.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+#define LEGITIMATE_CONSTANT_P(X) (1)\n+\f\n+/*** Condition Code Information ***/\n+\n+/* C code for a data type which is used for declaring the `mdep'\n+   component of `cc_status'.  It defaults to `int'.  */\n+/* #define CC_STATUS_MDEP int */\n+\n+/* A C expression to initialize the `mdep' field to \"empty\".  */\n+/* #define CC_STATUS_MDEP_INIT (cc_status.mdep = 0) */\n+\n+/* Macro to zap the normal portions of CC_STATUS, but leave the\n+   machine dependent parts (ie, literal synthesis) alone.  */\n+/* #define CC_STATUS_INIT_NO_MDEP \\\n+  (cc_status.flags = 0, cc_status.value1 = 0, cc_status.value2 = 0) */\n+\n+/* When using a register to hold the condition codes, the cc_status\n+   mechanism cannot be used.  */\n+#define NOTICE_UPDATE_CC(EXP, INSN) (0)\n+\f\n+/*** Miscellaneous Parameters ***/\n+\n+/* Define the codes that are matched by predicates in m88k.c.  */\n+#define PREDICATE_CODES\t  \t\t\t\t\t\t\\\n+  {\"move_operand\", {SUBREG, REG, CONST_INT, LO_SUM, MEM}},\t\t\\\n+  {\"call_address_operand\", {SUBREG, REG, SYMBOL_REF, LABEL_REF, CONST}}, \\\n+  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"arith5_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"arith32_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"arith64_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"int5_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"int32_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"reg_or_bbx_mask_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"real_or_0_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"relop\", {EQ, NE, LT, LE, GE, GT, LTU, LEU, GEU, GTU}},\t\t\\\n+  {\"relop_no_unsigned\", {EQ, NE, LT, LE, GE, GT}},\t\t\t\\\n+  {\"equality_op\", {EQ, NE}},\t\t\t\t\t\t\\\n+  {\"pc_or_label_ref\", {PC, LABEL_REF}},\n+\n+/* An alias for a machine mode name.  This is the machine mode that\n+   elements of a jump-table should have.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this macro if jump-tables should contain relative addresses.  */\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* Define this if control falls through a `case' insn when the index\n+   value is out of range.  This means the specified default-label is\n+   actually ignored by the `case' insn proper.  */\n+/* #define CASE_DROPS_THROUGH */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* The 88open ABI says size_t is unsigned int.  */\n+#define SIZE_TYPE \"unsigned int\"\n+\n+/* Allow and ignore #sccs directives */\n+#define SCCS_DIRECTIVE\n+\n+/* Code to handle #pragma directives.  The interface is a bit messy,\n+   but there's no simpler way to do this while still using yylex.  */\n+#define HANDLE_PRAGMA(FILE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    while (c == ' ' || c == '\\t')\t\t\t\t\\\n+      c = getc (FILE);\t\t\t\t\t\t\\\n+    if (c == '\\n' || c == EOF)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tm88k_handle_pragma_token (0, 0);\t\t\t\\\n+\treturn c;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    ungetc (c, FILE);\t\t\t\t\t\t\\\n+    switch (yylex ())\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+      case IDENTIFIER:\t\t\t\t\t\t\\\n+      case TYPENAME:\t\t\t\t\t\t\\\n+      case STRING:\t\t\t\t\t\t\\\n+      case CONSTANT:\t\t\t\t\t\t\\\n+\tm88k_handle_pragma_token (token_buffer, yylval.ttype);\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\\\n+\tm88k_handle_pragma_token (token_buffer, 0);\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (nextchar >= 0)\t\t\t\t\t\t\\\n+      c = nextchar, nextchar = -1;\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      c = getc (FILE);\t\t\t\t\t\t\\\n+  } while (1)\n+\n+/* Tell when to handle #pragma weak.  This is only done for V.4.  */\n+#define HANDLE_PRAGMA_WEAK TARGET_SVR4\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 64\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.  */\n+#define BYTE_LOADS_ZERO_EXTEND\n+\n+/* Zero if access to memory by bytes is faster.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Define this macro if an argument declared as `char' or\n+   `short' in a prototype should actually be passed as an\n+   `int'.  In addition to avoiding errors in certain cases of\n+   mismatch, it also makes for better code on certain machines.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* Define this macro if a float function always returns float\n+   (even in traditional mode).  Redefined in m88kluna.h.  */\n+#define TRADITIONAL_RETURN_FLOAT\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+#define STORE_FLAG_VALUE -1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a word address (for indexing purposes)\n+   so give the MEM rtx word mode.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.\n+\n+   We assume that any 16 bit integer can easily be recreated, so we\n+   indicate 0 cost, in an attempt to get GCC not to optimize things\n+   like comparison against a constant.\n+\n+   The cost of CONST_DOUBLE is zero (if it can be placed in an insn, it\n+   is as good as a register; since it can't be placed in any insn, it\n+   won't do anything in cse, but it will cause expand_binop to pass the\n+   constant to the define_expands).  */\n+#define CONST_COSTS(RTX,CODE)\t\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\\\n+    if (SMALL_INT (RTX))\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\\\n+    else if (SMALL_INTVAL (- INTVAL (RTX)))\t\t\\\n+      return 2;\t\t\t\t\t\t\\\n+    else if (classify_integer (SImode, INTVAL (RTX)) != m88k_oru_or) \\\n+      return 4;\t\t\t\t\t\t\\\n+    return 7;\t\t\t\t\t\t\\\n+  case HIGH:\t\t\t\t\t\t\\\n+    return 2;\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\\\n+      return (flag_pic == 2) ? 11 : 8;\t\t\t\\\n+    return 5;\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\\\n+    return 0;\n+\n+/* Provide the costs of an addressing mode that contains ADDR.\n+   If ADDR is not a valid address, it's cost is irrelavent.\n+   REG+REG is made slightly more expensive because it might keep\n+   a register live for longer than we might like.  */\n+#define ADDRESS_COST(ADDR)\t\t\t\t\\\n+  (GET_CODE (ADDR) == REG ? 1 :\t\t\t\t\\\n+   GET_CODE (ADDR) == LO_SUM ? 1 :\t\t\t\\\n+   GET_CODE (ADDR) == HIGH ? 2 :\t\t\t\\\n+   GET_CODE (ADDR) == MULT ? 1 :\t\t\t\\\n+   GET_CODE (ADDR) != PLUS ? 4 :\t\t\t\\\n+   (REG_P (XEXP (ADDR, 0)) && REG_P (XEXP (ADDR, 1))) ? 2 : 1)\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  */\n+#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (2);\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (3);\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (38);\n+\n+/* A C expressions returning the cost of moving data of MODE from a register\n+   to or from memory.  This is more costly than between registers.  */\n+#define MEMORY_MOVE_COST(MODE) 4\n+\n+/* Provide the cost of a branch.  Exact meaning under development.  */\n+#define BRANCH_COST (TARGET_88100 ? 1 : 2)\n+\n+/* Define this to be nonzero if the character `$' should be allowed\n+   by default in identifier names.  */\n+#define\tDOLLARS_IN_IDENTIFIERS\t1\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\f\n+/*** Output of Assembler Code ***/\n+\n+/* Control the assembler format that we output.  */\n+\n+/* Which assembler syntax.  Redefined in m88kdgux.h.  */\n+#define VERSION_0300_SYNTAX TARGET_SVR4\n+\n+/* Allow pseudo-ops to be overridden.  Override these in svr[34].h.  */\n+#undef\tINT_ASM_OP\n+#undef\tASCII_DATA_ASM_OP\n+#undef\tINIT_SECTION_ASM_OP\n+#undef\tCONST_SECTION_ASM_OP\n+#undef\tCTORS_SECTION_ASM_OP\n+#undef\tDTORS_SECTION_ASM_OP\n+#undef\tINIT_SECTION_ASM_OP\n+#undef\tFINI_SECTION_ASM_OP\n+#undef\tTYPE_ASM_OP\n+#undef\tSIZE_ASM_OP\n+\n+/* These are used in varasm.c as well.  */\n+#define TEXT_SECTION_ASM_OP\t\"\\ttext\"\n+#define DATA_SECTION_ASM_OP\t\"\\tdata\"\n+\n+/* Other sections.  */\n+#define CONST_SECTION_ASM_OP (VERSION_0300_SYNTAX\t\t\\\n+\t\t\t      ? \"\\tsection\\t .rodata,\\\"a\\\"\\n\"\t\\\n+\t\t\t      : \"\\tsection\\t .rodata,\\\"x\\\"\\n\")\n+#define TDESC_SECTION_ASM_OP (VERSION_0300_SYNTAX\t\t\\\n+\t\t\t      ? \"\\tsection\\t .tdesc,\\\"a\\\"\"\t\\\n+\t\t\t      : \"\\tsection\\t .tdesc,\\\"x\\\"\")\n+\n+/* These must be constant strings for crtstuff.c.  */\n+#define CTORS_SECTION_ASM_OP \"\\tsection\\t .ctors,\\\"d\\\"\\n\"\n+#define DTORS_SECTION_ASM_OP \"\\tsection\\t .dtors,\\\"d\\\"\\n\"\n+#define INIT_SECTION_ASM_OP\t\"\\tsection\\t .init,\\\"x\\\"\"\n+#define FINI_SECTION_ASM_OP\t\"\\tsection\\t .fini,\\\"x\\\"\"\n+\n+/* These are pretty much common to all assemblers.  */\n+#define IDENT_ASM_OP\t\t\"\\tident\"\n+#define FILE_ASM_OP\t\t\"\\tfile\"\n+#define SECTION_ASM_OP\t\t\"\\tsection\"\n+#define DEF_ASM_OP\t\t\"\\tdef\"\n+#define GLOBAL_ASM_OP\t\t\"\\tglobal\"\n+#define ALIGN_ASM_OP\t\t\"\\talign\"\n+#define SKIP_ASM_OP\t\t\"\\tzero\"\n+#define COMMON_ASM_OP\t\t\"\\tcomm\"\n+#define LOCAL_ASM_OP\t\t\"\\tbss\"\n+#define FLOAT_ASM_OP\t\t\"\\tfloat\"\n+#define DOUBLE_ASM_OP\t\t\"\\tdouble\"\n+#define INT_ASM_OP\t\t\"\\tword\"\n+#define ASM_LONG\t\tINT_ASM_OP\n+#define SHORT_ASM_OP\t\t\"\\thalf\"\n+#define CHAR_ASM_OP\t\t\"\\tbyte\"\n+#define ASCII_DATA_ASM_OP\t\"\\tstring\"\n+\n+/* These are particular to the global pool optimization.  */\n+#define SBSS_ASM_OP\t\t\"\\tsbss\"\n+#define SCOMM_ASM_OP\t\t\"\\tscomm\"\n+#define SDATA_SECTION_ASM_OP\t\"\\tsdata\"\n+\n+/* These are specific to PIC.  */\n+#define TYPE_ASM_OP\t\t\"\\ttype\"\n+#define SIZE_ASM_OP\t\t\"\\tsize\"\n+#define WEAK_ASM_OP\t\t\"\\tweak\"\n+#ifndef AS_BUG_POUND_TYPE /* Faulty assemblers require @ rather than #.  */\n+#undef\tTYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT\t\"#%s\"\n+#endif\n+\n+/* These are specific to version 03.00 assembler syntax.  */\n+#define INTERNAL_ASM_OP\t\t\"\\tlocal\"\n+#define VERSION_ASM_OP\t\t\"\\tversion\"\n+#define ASM_DWARF_POP_SECTION(FILE) fputs (\"\\tprevious\\n\", FILE)\n+#define UNALIGNED_SHORT_ASM_OP\t\"\\tuahalf\"\n+#define UNALIGNED_INT_ASM_OP\t\"\\tuaword\"\n+\n+/* Output any initial stuff to the assembly file.  Always put out\n+   a file directive, even if not debugging.\n+\n+   Immediately after putting out the file, put out a \"sem.<value>\"\n+   declaration.  This should be harmless on other systems, and\n+   is used in DG/UX by the debuggers to suppliment COFF.  The\n+   fields in the integer value are as follows:\n+\n+   Bits\tValue\tMeaning\n+   ----\t-----\t-------\n+   0-1\t0\tNo information about stack locations\n+\t1\tAuto/param locations are based on r30\n+\t2\tAuto/param locations are based on CFA\n+\n+   3-2\t0\tNo information on dimension order\n+\t1\tArray dims in sym table matches source language\n+\t2\tArray dims in sym table is in reverse order\n+\n+   5-4\t0\tNo information about the case of global names\n+\t1\tGlobal names appear in the symbol table as in the source\n+\t2\tGlobal names have been converted to lower case\n+\t3\tGlobal names have been converted to upper case.  */\n+\n+#ifdef SDB_DEBUGGING_INFO\n+#define ASM_COFFSEM(FILE)\t\t\t\t\t\t\\\n+    if (write_symbols == SDB_DEBUG)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\nsem.%x:\\t\\t; %s\\n\",\t\t\t\t\\\n+\t\t (((TARGET_OCS_FRAME_POSITION) ? 2 : 1) << 0) + (1 << 2) + (1 << 4),\\\n+\t\t (TARGET_OCS_FRAME_POSITION)\t\t\t\t\\\n+\t\t\t? \"frame is CFA, normal array dims, case unchanged\" \\\n+\t\t\t: \"frame is r30, normal array dims, case unchanged\"); \\\n+      }\n+#else\n+#define ASM_COFFSEM(FILE)\n+#endif\n+\n+/* Output the first line of the assembly file.  Redefined in m88kdgux.h.  */\n+\n+#define ASM_FIRST_LINE(FILE)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (VERSION_0300_SYNTAX)\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\\t \\\"03.00\\\"\\n\", VERSION_ASM_OP);\t\t\\\n+  } while (0)\n+\n+/* Override svr[34].h.  */\n+#undef\tASM_FILE_START\n+#define ASM_FILE_START(FILE) \\\n+  output_file_start (FILE, f_options, sizeof f_options / sizeof f_options[0], \\\n+\t\t     W_options, sizeof W_options / sizeof W_options[0])\n+\n+#undef\tASM_FILE_END\n+\n+#define ASM_OUTPUT_SOURCE_FILENAME(FILE, NAME) \\\n+  fprintf (FILE, \"%s\\t \\\"%s\\\"\\n\", FILE_ASM_OP, NAME)\n+\n+#ifdef SDB_DEBUGGING_INFO\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE)\t\t\t\\\n+  if (m88k_prologue_done)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\\tln\\t %d\\t\\t\\t\\t; Real source line %d\\n\",\\\n+\t     LINE - sdb_begin_function_line, LINE)\n+#endif\n+\n+/* Code to handle #ident directives.  Override svr[34].h definition.  */\n+#undef\tASM_OUTPUT_IDENT\n+#ifdef DBX_DEBUGGING_INFO\n+#define ASM_OUTPUT_IDENT(FILE, NAME)\n+#else\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf(FILE, \"%s\\t \\\"%s\\\"\\n\", IDENT_ASM_OP, NAME)\n+#endif\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+#define ASM_APP_OFF \"\"\n+\n+/* Format the assembly opcode so that the arguments are all aligned.\n+   The maximum instruction size is 8 characters (fxxx.xxx), so a tab and a\n+   space will do to align the output.  Abandon the output if a `%' is\n+   encountered.  */\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int ch;\t\t\t\t\t\t\t\t\\\n+    char *orig_ptr;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    for (orig_ptr = (PTR);\t\t\t\t\t\t\\\n+\t (ch = *(PTR)) && ch != ' ' && ch != '\\t' && ch != '\\n' && ch != '%'; \\\n+\t (PTR)++)\t\t\t\t\t\t\t\\\n+      putc (ch, STREAM);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (ch == ' ' && orig_ptr != (PTR) && (PTR) - orig_ptr < 8)\t\t\\\n+      putc ('\\t', STREAM);\t\t\t\t\t\t\\\n+  }\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number.\n+   Updated by OVERRIDE_OPTIONS to include the # for version 03.00 syntax.  */\n+\n+#define REGISTER_NAMES \\\n+  {\"#r0\"+1, \"#r1\"+1, \"#r2\"+1, \"#r3\"+1, \"#r4\"+1, \"#r5\"+1, \"#r6\"+1, \"#r7\"+1, \\\n+   \"#r8\"+1, \"#r9\"+1, \"#r10\"+1,\"#r11\"+1,\"#r12\"+1,\"#r13\"+1,\"#r14\"+1,\"#r15\"+1,\\\n+   \"#r16\"+1,\"#r17\"+1,\"#r18\"+1,\"#r19\"+1,\"#r20\"+1,\"#r21\"+1,\"#r22\"+1,\"#r23\"+1,\\\n+   \"#r24\"+1,\"#r25\"+1,\"#r26\"+1,\"#r27\"+1,\"#r28\"+1,\"#r29\"+1,\"#r30\"+1,\"#r31\"+1}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Tell when to declare ASM names.  Override svr4.h to provide this hook.  */\n+#undef\tDECLARE_ASM_NAME\n+#define DECLARE_ASM_NAME TARGET_SVR4\n+\n+/* Write the extra assembler code needed to declare a function properly.  */\n+#undef\tASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (DECLARE_ASM_NAME)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tputc (',', FILE);\t\t\t\t\t\t\\\n+\tfprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+#undef\tASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (DECLARE_ASM_NAME)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tputc (',', FILE);\t\t\t\t\t\t\\\n+\tfprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+\tif (!flag_inhibit_size_directive)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\\\n+\t    assemble_name (FILE, NAME);\t\t\t\t\t\\\n+\t    fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (decl))); \\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to declare the size of a function.  */\n+#undef\tASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (DECLARE_ASM_NAME)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (!flag_inhibit_size_directive)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    char label[256];\t\t\t\t\t\t\\\n+\t    static int labelno;\t\t\t\t\t\t\\\n+\t    labelno++;\t\t\t\t\t\t\t\\\n+\t    ASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\\\n+\t    ASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n+\t    fprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\\\n+\t    assemble_name (FILE, (FNAME));\t\t\t\t\\\n+\t    fprintf (FILE, \",%s-\", &label[1]);\t\t\t\t\\\n+\t    assemble_name (FILE, (FNAME));\t\t\t\t\\\n+\t    putc ('\\n', FILE);\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", GLOBAL_ASM_OP);\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   Override svr[34].h.  */\n+#undef\tASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (! TARGET_NO_UNDERSCORES && ! VERSION_0300_SYNTAX) \\\n+      fputc ('_', FILE);\t\t\t\t\\\n+    fputs (NAME, FILE);\t\t\t\t\t\\\n+  }\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   For V.4, labels use `.' rather than `@'.  */\n+\n+#ifdef AS_BUG_DOT_LABELS /* The assembler requires a declaration of local.  */\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\t\t\\\n+  fprintf (FILE, VERSION_0300_SYNTAX ? \".%s%d:\\n%s\\t .%s%d\\n\" : \"@%s%d:\\n\", \\\n+\t   PREFIX, NUM, INTERNAL_ASM_OP, PREFIX, NUM)\n+#else\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\t\t\\\n+  fprintf (FILE, VERSION_0300_SYNTAX ? \".%s%d:\\n\" : \"@%s%d:\\n\", PREFIX, NUM)\n+#endif /* AS_BUG_DOT_LABELS */\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  This must agree\n+   with ASM_OUTPUT_INTERNAL_LABEL above, except for being prefixed\n+   with an `*'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\t\t\\\n+  sprintf (LABEL, VERSION_0300_SYNTAX ? \"*.%s%d\" : \"*@%s%d\", PREFIX, NUM)\n+\n+/* Internal macro to get a single precision floating point value into\n+   an int, so we can print it's value in hex.  */\n+#define FLOAT_TO_INT_INTERNAL( FVALUE, IVALUE )\t\t\t\t\\\n+  { union {\t\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TYPE d;\t\t\t\t\t\t\\\n+      struct {\t\t\t\t\t\t\t\t\\\n+\tunsigned sign      :  1;\t\t\t\t\t\\\n+\tunsigned exponent1 :  1;\t\t\t\t\t\\\n+\tunsigned exponent2 :  3;\t\t\t\t\t\\\n+\tunsigned exponent3 :  7;\t\t\t\t\t\\\n+\tunsigned mantissa1 : 20;\t\t\t\t\t\\\n+\tunsigned mantissa2 :  3;\t\t\t\t\t\\\n+\tunsigned mantissa3 : 29;\t\t\t\t\t\\\n+      } s;\t\t\t\t\t\t\t\t\\\n+    } _u;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    union {\t\t\t\t\t\t\t\t\\\n+      int i;\t\t\t\t\t\t\t\t\\\n+      struct {\t\t\t\t\t\t\t\t\\\n+        unsigned sign      :  1;\t\t\t\t\t\\\n+\tunsigned exponent1 :  1;\t\t\t\t\t\\\n+\tunsigned exponent3 :  7;\t\t\t\t\t\\\n+        unsigned mantissa1 : 20;\t\t\t\t\t\\\n+        unsigned mantissa2 :  3;\t\t\t\t\t\\\n+      } s;\t\t\t\t\t\t\t\t\\\n+    } _u2;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    _u.d = REAL_VALUE_TRUNCATE (SFmode, FVALUE);\t\t\t\\\n+    _u2.s.sign = _u.s.sign;\t\t\t\t\t\t\\\n+    _u2.s.exponent1 = _u.s.exponent1;\t\t\t\t\t\\\n+    _u2.s.exponent3 = _u.s.exponent3;\t\t\t\t\t\\\n+    _u2.s.mantissa1 = _u.s.mantissa1;\t\t\t\t\t\\\n+    _u2.s.mantissa2 = _u.s.mantissa2;\t\t\t\t\t\\\n+    IVALUE = _u2.i;\t\t\t\t\t\t\t\\\n+  }\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   Use \"word\" pseudos to avoid printing NaNs, infinity, etc.  */\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union { REAL_VALUE_TYPE d; long l[2]; } x;\t\t\t\t\\\n+    x.d = (VALUE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t 0x%.8x, 0x%.8x\\n\", INT_ASM_OP,\t\t\t\\\n+\t     x.l[0], x.l[1]);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    FLOAT_TO_INT_INTERNAL (VALUE, i);\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t 0x%.8x\\n\", INT_ASM_OP, i);\t\t\t\\\n+  } while (0)\n+\n+/* Likewise for `int', `short', and `char' constants.  */\n+#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\t\\\n+( fprintf (FILE, \"%s\\t \", INT_ASM_OP),\t\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)\t\t\t\t\t\\\n+( fprintf (FILE, \"%s\\t \", SHORT_ASM_OP),\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)\t\t\t\t\t\\\n+( fprintf (FILE, \"%s\\t \", CHAR_ASM_OP),\t\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"%s\\t 0x%x\\n\", CHAR_ASM_OP, (VALUE))\n+\n+/* The singl-byte pseudo-op is the default.  Override svr[34].h.  */\n+#undef\tASM_BYTE_OP\n+#define ASM_BYTE_OP \"\\tbyte\"\n+#undef\tASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n+  output_ascii ((FILE), (P), (SIZE))\n+\n+/* Epilogue for case labels.  This jump instruction is called by casesi\n+   to transfer to the appropriate branch instruction within the table.\n+   The label `@L<n>e' is coined to mark the end of the table.  */\n+#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    char label[256];\t\t\t\t\t\t\t\\\n+    ASM_GENERATE_INTERNAL_LABEL (label, \"L\", NUM);\t\t\t\\\n+    fprintf (FILE, \"%se:\\n\", &label[1]);\t\t\t\t\\\n+    if (! flag_delayed_branch)\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tlda\\t %s,%s[%s]\\n\", reg_names[1], reg_names[1],\t\\\n+\t       reg_names[m88k_case_index]);\t\t\t\t\\\n+    fprintf (FILE, \"\\tjmp\\t %s\\n\", reg_names[1]);\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    char buffer[256];\t\t\t\t\t\t\t\\\n+    ASM_GENERATE_INTERNAL_LABEL (buffer, \"L\", VALUE);\t\t\t\\\n+    fprintf (FILE, \"\\tbr\\t %s\\n\", &buffer[1]);\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  ASM_OUTPUT_ADDR_VEC_ELT (FILE, VALUE)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"%s\\t %d\\n\", ALIGN_ASM_OP, 1<<(LOG))\n+\n+/* Align the text address to half a cache boundary when it can only be\n+   reached by jumping.  */\n+#define ASM_OUTPUT_ALIGN_CODE(FILE) ASM_OUTPUT_ALIGN (FILE, 3)\n+\n+/* Override svr[34].h.  */\n+#undef\tASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"%s\\t %u\\n\", SKIP_ASM_OP, (SIZE))\n+\n+/* Override svr4.h.  */\n+#undef\tASM_OUTPUT_EXTERNAL_LIBCALL\n+\n+/* This says how to output an assembler line to define a global common\n+   symbol.  Size can be zero for the unusual case of a `struct { int : 0; }'.\n+   Override svr[34].h.  */\n+#undef\tASM_OUTPUT_COMMON\n+#undef\tASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+( fprintf ((FILE), \"%s\\t \",\t\t\t\t\\\n+\t   (ROUNDED) <= m88k_gp_threshold ? SCOMM_ASM_OP : COMMON_ASM_OP), \\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE) ? (SIZE) : 1))\n+\n+/* This says how to output an assember line to define a local common\n+   symbol.  Override svr[34].h.  */\n+#undef\tASM_OUTPUT_LOCAL\n+#undef\tASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+( fprintf ((FILE), \"%s\\t \",\t\t\t\t\\\n+\t   (ROUNDED) <= m88k_gp_threshold ? SBSS_ASM_OP : LOCAL_ASM_OP), \\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%u,%d\\n\", (SIZE) ? (SIZE) : 1, (SIZE) <= 4 ? 4 : 8))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tsubu\\t %s,%s,%d\\n\\tst\\t %s,%s,0\\n\",\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   (STACK_BOUNDARY / BITS_PER_UNIT),\t\t\\\n+\t   reg_names[REGNO],\t\t\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM])\n+\n+/* This is how to output an insn to pop a register from the stack.  */\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tld\\t %s,%s,0\\n\\taddu\\t %s,%s,%d\\n\",\t\\\n+\t   reg_names[REGNO],\t\t\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   (STACK_BOUNDARY / BITS_PER_UNIT))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\f\n+/* Macros to deal with OCS debug information */\n+\n+#define OCS_START_PREFIX\t\"Ltb\"\n+#define OCS_END_PREFIX\t\t\"Lte\"\n+\n+#define PUT_OCS_FUNCTION_START(FILE) \\\n+  { ASM_OUTPUT_INTERNAL_LABEL (FILE, OCS_START_PREFIX, m88k_function_number); }\n+\n+#define PUT_OCS_FUNCTION_END(FILE) \\\n+  { ASM_OUTPUT_INTERNAL_LABEL (FILE, OCS_END_PREFIX, m88k_function_number); }\n+\n+/* Macros for debug information */\n+#define DEBUGGER_AUTO_OFFSET(X) \\\n+  (m88k_debugger_offset (X, 0) \\\n+   + (TARGET_OCS_FRAME_POSITION ? 0 : m88k_stack_size - m88k_fp_offset))\n+\n+#define DEBUGGER_ARG_OFFSET(OFFSET, X) \\\n+  (m88k_debugger_offset (X, OFFSET) \\\n+   + (TARGET_OCS_FRAME_POSITION ? 0 : m88k_stack_size - m88k_fp_offset))\n+\n+/* Macros to deal with SDB debug information */\n+#ifdef SDB_DEBUGGING_INFO\n+\n+/* Output structure tag names even when it causes a forward reference. */\n+#define SDB_ALLOW_FORWARD_REFERENCES\n+\n+/* Print out extra debug information in the assembler file */\n+#define PUT_SDB_SCL(a)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    register int s = (a);\t\t\t\t\t\\\n+    register char *scl;\t\t\t\t\t\t\\\n+    switch (s)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+      case C_EFCN:\tscl = \"end of function\";\tbreak;\t\\\n+      case C_NULL:\tscl = \"NULL storage class\";\tbreak;\t\\\n+      case C_AUTO:\tscl = \"automatic\";\t\tbreak;\t\\\n+      case C_EXT:\tscl = \"external\";\t\tbreak;\t\\\n+      case C_STAT:\tscl = \"static\";\t\t\tbreak;\t\\\n+      case C_REG:\tscl = \"register\";\t\tbreak;\t\\\n+      case C_EXTDEF:\tscl = \"external definition\";\tbreak;\t\\\n+      case C_LABEL:\tscl = \"label\";\t\t\tbreak;\t\\\n+      case C_ULABEL:\tscl = \"undefined label\";\tbreak;\t\\\n+      case C_MOS:\tscl = \"structure member\";\tbreak;\t\\\n+      case C_ARG:\tscl = \"argument\";\t\tbreak;\t\\\n+      case C_STRTAG:\tscl = \"structure tag\";\t\tbreak;\t\\\n+      case C_MOU:\tscl = \"union member\";\t\tbreak;\t\\\n+      case C_UNTAG:\tscl = \"union tag\";\t\tbreak;\t\\\n+      case C_TPDEF:\tscl = \"typedef\";\t\tbreak;\t\\\n+      case C_USTATIC:\tscl = \"uninitialized static\";\tbreak;\t\\\n+      case C_ENTAG:\tscl = \"enumeration tag\";\tbreak;\t\\\n+      case C_MOE:\tscl = \"member of enumeration\";\tbreak;\t\\\n+      case C_REGPARM:\tscl = \"register parameter\";\tbreak;\t\\\n+      case C_FIELD:\tscl = \"bit field\";\t\tbreak;\t\\\n+      case C_BLOCK:\tscl = \"block start/end\";\tbreak;\t\\\n+      case C_FCN:\tscl = \"function start/end\";\tbreak;\t\\\n+      case C_EOS:\tscl = \"end of structure\";\tbreak;\t\\\n+      case C_FILE:\tscl = \"filename\";\t\tbreak;\t\\\n+      case C_LINE:\tscl = \"line\";\t\t\tbreak;\t\\\n+      case C_ALIAS:\tscl = \"duplicated tag\";\t\tbreak;\t\\\n+      case C_HIDDEN:\tscl = \"hidden\";\t\t\tbreak;\t\\\n+      default:\t\tscl = \"unknown\";\t\tbreak;\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    fprintf(asm_out_file, \"\\tscl\\t %d\\t\\t\\t\\t; %s\\n\", s, scl);\t\\\n+  } while (0)\n+\n+#define PUT_SDB_TYPE(a)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    register int t = (a);\t\t\t\t\t\\\n+    static char buffer[100];\t\t\t\t\t\\\n+    register char *p = buffer, *q;\t\t\t\t\\\n+    register int typ = t;\t\t\t\t\t\\\n+    register int i,d;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    for (i = 0; i <= 5; i++)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tswitch ((typ >> ((i*N_TSHIFT) + N_BTSHFT)) & 03)\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t  case DT_PTR:\t\t\t\t\t\t\\\n+\t    strcpy (p, \"ptr to \");\t\t\t\t\\\n+\t    p += sizeof(\"ptr to\");\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  case DT_ARY:\t\t\t\t\t\t\\\n+\t    strcpy (p, \"array of \");\t\t\t\t\\\n+\t    p += sizeof(\"array of\");\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  case DT_FCN:\t\t\t\t\t\t\\\n+\t    strcpy (p, \"func ret \");\t\t\t\t\\\n+\t    p += sizeof(\"func ret\");\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  switch (typ & N_BTMASK)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+    case T_NULL:\tq = \"<no type>\";\tbreak;\t\t\\\n+    case T_CHAR:\tq = \"char\";\t\tbreak;\t\t\\\n+    case T_SHORT:\tq = \"short\";\t\tbreak;\t\t\\\n+    case T_INT:\t\tq = \"int\";\t\tbreak;\t\t\\\n+    case T_LONG:\tq = \"long\";\t\tbreak;\t\t\\\n+    case T_FLOAT:\tq = \"float\";\t\tbreak;\t\t\\\n+    case T_DOUBLE:\tq = \"double\";\t\tbreak;\t\t\\\n+    case T_STRUCT:\tq = \"struct\";\t\tbreak;\t\t\\\n+    case T_UNION:\tq = \"union\";\t\tbreak;\t\t\\\n+    case T_ENUM:\tq = \"enum\";\t\tbreak;\t\t\\\n+    case T_MOE:\t\tq = \"enum member\";\tbreak;\t\t\\\n+    case T_UCHAR:\tq = \"unsigned char\";\tbreak;\t\t\\\n+    case T_USHORT:\tq = \"unsigned short\";\tbreak;\t\t\\\n+    case T_UINT:\tq = \"unsigned int\";\tbreak;\t\t\\\n+    case T_ULONG:\tq = \"unsigned long\";\tbreak;\t\t\\\n+    default:\t\tq = \"void\";\t\tbreak;\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    strcpy (p, q);\t\t\t\t\t\t\\\n+    fprintf(asm_out_file, \"\\ttype\\t %d\\t\\t\\t\\t; %s\\n\",\t\t\\\n+\t    t, buffer);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define PUT_SDB_INT_VAL(a) \\\n+  fprintf (asm_out_file, \"\\tval\\t %d\\n\", (a))\n+\n+#define PUT_SDB_VAL(a)\t\t\t\t\t\\\n+( fprintf (asm_out_file, \"\\tval\\t \"),\t\t\t\\\n+  output_addr_const (asm_out_file, (a)),\t\t\\\n+  fputc ('\\n', asm_out_file))\n+\n+#define PUT_SDB_DEF(a)\t\t\t\t\t\t\\\n+  do { fprintf (asm_out_file, \"\\tsdef\\t \");\t\t\t\\\n+    ASM_OUTPUT_LABELREF (asm_out_file, a);\t\t\t\\\n+    fputc ('\\n', asm_out_file);\t\t\t\t\t\\\n+  } while (0)\n+\n+#define PUT_SDB_PLAIN_DEF(a) \\\n+  fprintf(asm_out_file,\"\\tsdef\\t .%s\\n\", a)\n+\n+/* Simply and endef now.  */\n+#define PUT_SDB_ENDEF \\\n+  fputs(\"\\tendef\\n\\n\", asm_out_file)\n+\n+#define PUT_SDB_SIZE(a) \\\n+  fprintf (asm_out_file, \"\\tsize\\t %d\\n\", (a))\n+\n+/* Max dimensions to store for debug information (limited by COFF).  */\n+#define SDB_MAX_DIM 6\n+\n+/* New method for dim operations.  */\n+#define PUT_SDB_START_DIM \\\n+  fputs(\"\\tdim\\t \", asm_out_file)\n+\n+/* How to end the DIM sequence.  */\n+#define PUT_SDB_LAST_DIM(a) \\\n+  fprintf(asm_out_file, \"%d\\n\", a)\n+\n+#define PUT_SDB_TAG(a)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    fprintf (asm_out_file, \"\\ttag\\t \");\t\t\t\t\\\n+    ASM_OUTPUT_LABELREF (asm_out_file, a);\t\t\t\\\n+    fputc ('\\n', asm_out_file);\t\t\t\t\t\\\n+  } while( 0 )\n+\n+#define PUT_SDB_BLOCK_OR_FUNCTION(NAME, SCL, LINE)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    fprintf (asm_out_file, \"\\n\\tsdef\\t %s\\n\\tval\\t .\\n\",\t\\\n+\t     NAME);\t\t\t\t\t\t\\\n+    PUT_SDB_SCL( SCL );\t\t\t\t\t\t\\\n+    fprintf (asm_out_file, \"\\tline\\t %d\\n\\tendef\\n\\n\",\t\t\\\n+\t     (LINE));\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define PUT_SDB_BLOCK_START(LINE) \\\n+  PUT_SDB_BLOCK_OR_FUNCTION (\".bb\", C_BLOCK, (LINE))\n+\n+#define PUT_SDB_BLOCK_END(LINE) \\\n+  PUT_SDB_BLOCK_OR_FUNCTION (\".eb\", C_BLOCK, (LINE))\n+\n+#define PUT_SDB_FUNCTION_START(LINE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    fprintf (asm_out_file, \"\\tln\\t 1\\n\");\t\t\t\\\n+    PUT_SDB_BLOCK_OR_FUNCTION (\".bf\", C_FCN, (LINE));\t\t\\\n+  } while (0)\n+\n+#define PUT_SDB_FUNCTION_END(LINE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    PUT_SDB_BLOCK_OR_FUNCTION (\".ef\", C_FCN, (LINE));\t\t\\\n+  } while (0)\n+\n+#define PUT_SDB_EPILOGUE_END(NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    text_section ();\t\t\t\t\t\t\\\n+    fprintf (asm_out_file, \"\\n\\tsdef\\t \");\t\t\t\\\n+    ASM_OUTPUT_LABELREF(asm_out_file, (NAME));\t\t\t\\\n+    fputc('\\n', asm_out_file);\t\t\t\t\t\\\n+    PUT_SDB_SCL( C_EFCN );\t\t\t\t\t\\\n+    fprintf (asm_out_file, \"\\tendef\\n\\n\");\t\t\t\\\n+  } while (0)\n+\n+#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n+  sprintf ((BUFFER), \".%dfake\", (NUMBER));\n+\n+#endif /* SDB_DEBUGGING_INFO */\n+\f\n+/* Support const and tdesc sections.  Generally, a const section will\n+   be distinct from the text section whenever we do V.4-like things\n+   and so follows DECLARE_ASM_NAME.  Note that strings go in text\n+   rather than const.  Override svr[34].h.  */\n+\n+#undef\tUSE_CONST_SECTION\n+#undef\tEXTRA_SECTIONS\n+\n+#define USE_CONST_SECTION DECLARE_ASM_NAME\n+\n+#if defined(CTORS_SECTION_FUNCTION) /* SVR4 */\n+\n+#define EXTRA_SECTIONS in_const, in_tdesc, in_sdata, in_ctors, in_dtors\n+#define INIT_SECTION_FUNCTION\n+#define FINI_SECTION_FUNCTION\n+\n+#elif defined(FINI_SECTION_FUNCTION) /* SVR3 */\n+\n+#define EXTRA_SECTIONS in_const, in_tdesc, in_sdata, in_init, in_fini\n+#define CTORS_SECTION_FUNCTION\n+#define DTORS_SECTION_FUNCTION\n+\n+#else /* m88kluna or other not based on svr[34].h.  */\n+\n+#define EXTRA_SECTIONS in_const, in_tdesc, in_sdata\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  text_section();\t\t\t\t\t\t\t\\\n+}\n+#define CTORS_SECTION_FUNCTION\n+#define DTORS_SECTION_FUNCTION\n+#define INIT_SECTION_FUNCTION\n+#define FINI_SECTION_FUNCTION\n+\n+#endif /* CTORS_SECTION_FUNCTION */\n+\n+#undef\tEXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+tdesc_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_tdesc)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", TDESC_SECTION_ASM_OP);\t\t\\\n+      in_section = in_tdesc;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+sdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_sdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", SDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_sdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  INIT_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+  FINI_SECTION_FUNCTION\n+\n+#undef READONLY_DATA_SECTION\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.\n+\n+   For strings, the section is selected before the segment info is encoded.  */\n+#undef\tSELECT_SECTION\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else if (m88k_gp_threshold > 0\t\t\t\t\t\\\n+\t       && TREE_STRING_LENGTH (DECL) <= m88k_gp_threshold)\t\\\n+\tsdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)))\t\t\t\\\n+\tsdata_section ();\t\t\t\t\t\t\\\n+      else if ((flag_pic && RELOC)\t\t\t\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL))\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* Define this macro if references to a symbol must be treated differently\n+   depending on something about the variable or function named by the\n+   symbol (such as what section it is in).\n+\n+   The macro definition, if any, is executed immediately after the rtl for\n+   DECL has been created and stored in `DECL_RTL (DECL)'.  The value of the\n+   rtl will be a `mem' whose address is a `symbol_ref'.\n+\n+   For the m88k, determine if the item should go in the global pool.  */\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (m88k_gp_threshold > 0)\t\t\t\t\t\t\\\n+      if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (!TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL))\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      int size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      if (size > 0 && size <= m88k_gp_threshold)\t\t\\\n+\t\tSYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (DECL) == STRING_CST\t\t\t\t\\\n+\t       && flag_writable_strings\t\t\t\t\t\\\n+\t       && TREE_STRING_LENGTH (DECL) <= m88k_gp_threshold)\t\\\n+\tSYMBOL_REF_FLAG (XEXP (TREE_CST_RTL (DECL), 0)) = 1;\t\t\\\n+  } while (0)\n+\f\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+#define PRINT_OPERAND_PUNCT_VALID_P(c) \\\n+  ((c) == '#' || (c) == '.' || (c) == '!' || (c) == '*' || (c) == ';')\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)"}, {"sha": "23964c0230d34f3c5c3438c4279f3252c082adbd", "filename": "gcc/varasm.c", "status": "added", "additions": 2766, "deletions": 0, "changes": 2766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79e68feb317b00bda42db706667eccc7619c0a30/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79e68feb317b00bda42db706667eccc7619c0a30/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=79e68feb317b00bda42db706667eccc7619c0a30", "patch": "@@ -0,0 +1,2766 @@\n+/* Output variables, constants and external declarations, for GNU compiler.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file handles generation of all the assembler code\n+   *except* the instructions of a function.\n+   This includes declarations of variables and their initial values.\n+\n+   We also output the assembler code for constants stored in memory\n+   and are responsible for combining constants with the same value.  */\n+\n+#include <stdio.h>\n+#include <setjmp.h>\n+/* #include <stab.h> */\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"hard-reg-set.h\"\n+#include \"regs.h\"\n+\n+#include \"obstack.h\"\n+\n+#ifndef ASM_STABS_OP\n+#define ASM_STABS_OP \".stabs\"\n+#endif\n+\n+/* File in which assembler code is being written.  */\n+\n+extern FILE *asm_out_file;\n+\n+/* The (assembler) name of the first globally-visible object output.  */\n+char *first_global_object_name;\n+\n+extern struct obstack *current_obstack;\n+extern struct obstack *saveable_obstack;\n+extern struct obstack permanent_obstack;\n+#define obstack_chunk_alloc xmalloc\n+extern int xmalloc ();\n+\n+/* Number for making the label on the next\n+   constant that is stored in memory.  */\n+\n+int const_labelno;\n+\n+/* Number for making the label on the next\n+   static variable internal to a function.  */\n+\n+int var_labelno;\n+\n+/* Nonzero if at least one function definition has been seen.  */\n+static int function_defined;\n+\n+extern FILE *asm_out_file;\n+\n+static char *compare_constant_1 ();\n+static void record_constant_1 ();\n+void output_constant_pool ();\n+void assemble_name ();\n+int output_addressed_constants ();\n+void output_constant ();\n+void output_constructor ();\n+\f\n+#ifdef EXTRA_SECTIONS\n+static enum in_section {no_section, in_text, in_data, EXTRA_SECTIONS} in_section\n+  = no_section;\n+#else\n+static enum in_section {no_section, in_text, in_data} in_section\n+  = no_section;\n+#endif\n+\n+/* Define functions like text_section for any extra sections.  */\n+#ifdef EXTRA_SECTION_FUNCTIONS\n+EXTRA_SECTION_FUNCTIONS\n+#endif\n+\n+/* Tell assembler to switch to text section.  */\n+\n+void\n+text_section ()\n+{\n+  if (in_section != in_text)\n+    {\n+      fprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n+      in_section = in_text;\n+    }\n+}\n+\n+/* Tell assembler to switch to read-only data section.  This is normally\n+   the text section.  */\n+\n+void\n+readonly_data_section ()\n+{\n+#ifdef READONLY_DATA_SECTION\n+  READONLY_DATA_SECTION ();\n+#else\n+  text_section ();\n+#endif\n+}\n+\n+/* Tell assembler to switch to data section.  */\n+\n+void\n+data_section ()\n+{\n+  if (in_section != in_data)\n+    {\n+      if (flag_shared_data)\n+\t{\n+#ifdef SHARED_SECTION_ASM_OP\n+\t  fprintf (asm_out_file, \"%s\\n\", SHARED_SECTION_ASM_OP);\n+#else\n+\t  fprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n+#endif\n+\t}\n+      else\n+\tfprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n+\n+      in_section = in_data;\n+    }\n+}\n+\n+/* Determine if we're in the text section. */\n+\n+int\n+in_text_section ()\n+{\n+  return in_section == in_text;\n+}\n+\f\n+/* Create the rtl to represent a function, for a function definition.\n+   DECL is a FUNCTION_DECL node which describes which function.\n+   The rtl is stored into DECL.  */\n+\n+void\n+make_function_rtl (decl)\n+     tree decl;\n+{\n+  char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  /* Rename a nested function to avoid conflicts.  */\n+  if (decl_function_context (decl) != 0\n+      && DECL_INITIAL (decl) != 0\n+      && DECL_RTL (decl) == 0)\n+    {\n+      char *label;\n+\n+      name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n+      name = obstack_copy0 (saveable_obstack, label, strlen (label));\n+      var_labelno++;\n+    }\n+\n+  if (DECL_RTL (decl) == 0)\n+    {\n+      DECL_RTL (decl)\n+\t= gen_rtx (MEM, DECL_MODE (decl),\n+\t\t   gen_rtx (SYMBOL_REF, Pmode, name));\n+\n+      /* Optionally set flags or add text to the name to record information\n+\t such as that it is a function name.  If the name is changed, the macro\n+\t ASM_OUTPUT_LABELREF will have to know how to strip this information.\n+\t And if it finds a * at the beginning after doing so, it must handle\n+\t that too.  */\n+#ifdef ENCODE_SECTION_INFO\n+      ENCODE_SECTION_INFO (decl);\n+#endif\n+    }\n+\n+  /* Record at least one function has been defined.  */\n+  function_defined = 1;\n+}\n+\n+/* Decode an `asm' spec for a declaration as a register name.\n+   Return the register number, or -1 if nothing specified,\n+   or -2 if the name is not a register.  */\n+\n+int\n+decode_reg_name (asmspec)\n+     char *asmspec;\n+{\n+  if (asmspec != 0)\n+    {\n+      int i;\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (reg_names[i][0] && ! strcmp (asmspec, reg_names[i]))\n+\t  return i;\n+\n+      if (asmspec[0] == '%')\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t  if (reg_names[i][0] && ! strcmp (asmspec + 1, reg_names[i]))\n+\t    return i;\n+\n+#ifdef ADDITIONAL_REGISTER_NAMES\n+      {\n+\tstatic struct { char *name; int number; } table[]\n+\t  = ADDITIONAL_REGISTER_NAMES;\n+\n+\tfor (i = 0; i < sizeof (table) / sizeof (table[0]); i++)\n+\t  if (! strcmp (asmspec, table[i].name))\n+\t    return table[i].number;\n+\n+\tif (asmspec[0] == '%')\n+\t  for (i = 0; i < sizeof (table) / sizeof (table[0]); i++)\n+\t    if (! strcmp (asmspec + 1, table[i].name))\n+\t      return table[i].number;\n+      }\n+#endif /* ADDITIONAL_REGISTER_NAMES */\n+\n+      return -2;\n+    }\n+\n+  return -1;\n+}\n+\f\n+/* Create the DECL_RTL for a declaration for a static or external variable\n+   or static or external function.\n+   ASMSPEC, if not 0, is the string which the user specified\n+   as the assembler symbol name.\n+   TOP_LEVEL is nonzero if this is a file-scope variable.\n+\n+   This is never called for PARM_DECL nodes.  */\n+\n+void\n+make_decl_rtl (decl, asmspec, top_level)\n+     tree decl;\n+     char *asmspec;\n+     int top_level;\n+{\n+  register char *name;\n+  int reg_number = decode_reg_name (asmspec);\n+\n+  if (DECL_ASSEMBLER_NAME (decl) != NULL_TREE)\n+    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  if (reg_number == -2)\n+    {\n+      /* ASMSPEC is given, and not the name of a register.  */\n+      name = (char *) obstack_alloc (saveable_obstack,\n+\t\t\t\t     strlen (asmspec) + 2);\n+      name[0] = '*';\n+      strcpy (&name[1], asmspec);\n+    }\n+\n+  /* For a duplicate declaration, we can be called twice on the\n+     same DECL node.  Don't alter the RTL already made\n+     unless the old mode is wrong (which can happen when\n+     the previous rtl was made when the type was incomplete).  */\n+  if (DECL_RTL (decl) == 0\n+      || GET_MODE (DECL_RTL (decl)) != DECL_MODE (decl))\n+    {\n+      DECL_RTL (decl) = 0;\n+\n+      /* First detect errors in declaring global registers.  */\n+      if (TREE_REGDECL (decl) && reg_number == -1)\n+\terror_with_decl (decl,\n+\t\t\t \"register name not specified for `%s'\");\n+      else if (TREE_REGDECL (decl) && reg_number == -2)\n+\terror_with_decl (decl,\n+\t\t\t \"invalid register name for `%s'\");\n+      else if (reg_number >= 0 && ! TREE_REGDECL (decl))\n+\terror_with_decl (decl,\n+\t\t\t \"register name given for non-register variable `%s'\");\n+      else if (TREE_REGDECL (decl) && TREE_CODE (decl) == FUNCTION_DECL)\n+\terror (\"function declared `register'\");\n+      else if (TREE_REGDECL (decl) && TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n+\terror_with_decl (decl, \"data type of `%s' isn't suitable for a register\");\n+      /* Now handle properly declared static register variables.  */\n+      else if (TREE_REGDECL (decl))\n+\t{\n+\t  int nregs;\n+#if 0 /* yylex should print the warning for this */\n+\t  if (pedantic)\n+\t    pedwarn (\"ANSI C forbids global register variables\");\n+#endif\n+\t  if (DECL_INITIAL (decl) != 0 && top_level)\n+\t    {\n+\t      DECL_INITIAL (decl) = 0;\n+\t      error (\"global register variable has initial value\");\n+\t    }\n+\t  if (fixed_regs[reg_number] == 0\n+\t      && function_defined && top_level)\n+\t    error (\"global register variable follows a function definition\");\n+\t  if (TREE_THIS_VOLATILE (decl))\n+\t    warning (\"volatile register variables don't work as you might wish\");\n+\t  DECL_RTL (decl) = gen_rtx (REG, DECL_MODE (decl), reg_number);\n+\t  REG_USERVAR_P (DECL_RTL (decl)) = 1;\n+\n+\t  if (top_level)\n+\t    {\n+\t      /* Make this register fixed, so not usable for anything else.  */\n+\t      nregs = HARD_REGNO_NREGS (reg_number, DECL_MODE (decl));\n+\t      while (nregs > 0)\n+\t\tglobal_regs[reg_number + --nregs] = 1;\n+\t      init_reg_sets_1 ();\n+\t    }\n+\t}\n+\n+      /* Now handle ordinary static variables and functions (in memory).\n+\t Also handle vars declared register invalidly.  */\n+      if (DECL_RTL (decl) == 0)\n+\t{\n+\t  /* Can't use just the variable's own name for a variable\n+\t     whose scope is less than the whole file.\n+\t     Concatenate a distinguishing number.  */\n+\t  if (!top_level && !TREE_EXTERNAL (decl) && asmspec == 0)\n+\t    {\n+\t      char *label;\n+\n+\t      ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n+\t      name = obstack_copy0 (saveable_obstack, label, strlen (label));\n+\t      var_labelno++;\n+\t    }\n+\n+\t  DECL_RTL (decl) = gen_rtx (MEM, DECL_MODE (decl),\n+\t\t\t\t     gen_rtx (SYMBOL_REF, Pmode, name));\n+\t  if (TREE_THIS_VOLATILE (decl))\n+\t    MEM_VOLATILE_P (DECL_RTL (decl)) = 1;\n+\t  if (TREE_READONLY (decl))\n+\t    RTX_UNCHANGING_P (DECL_RTL (decl)) = 1;\n+\t  MEM_IN_STRUCT_P (DECL_RTL (decl))\n+\t    = (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n+\t       || TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n+\t       || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE);\n+\n+\t  /* Optionally set flags or add text to the name to record information\n+\t     such as that it is a function name.\n+\t     If the name is changed, the macro ASM_OUTPUT_LABELREF\n+\t     will have to know how to strip this information.\n+\t     And if it finds a * at the beginning after doing so,\n+\t     it must handle that too.  */\n+#ifdef ENCODE_SECTION_INFO\n+\t  ENCODE_SECTION_INFO (decl);\n+#endif\n+\t}\n+    }\n+}\n+\f\n+/* Output a string of literal assembler code\n+   for an `asm' keyword used between functions.  */\n+\n+void\n+assemble_asm (string)\n+     tree string;\n+{\n+  app_enable ();\n+\n+  if (TREE_CODE (string) == ADDR_EXPR)\n+    string = TREE_OPERAND (string, 0);\n+\n+  fprintf (asm_out_file, \"\\t%s\\n\", TREE_STRING_POINTER (string));\n+}\n+\n+/* Tiemann: please get rid of this conditional and put appropriate\n+   definitions in each of the files that should have them.\n+   The type of debugging format is not the right parameter to\n+   control how some other aspect of assembler output is done.  */\n+\n+#if !(defined(DBX_DEBUGGING_INFO) && !defined(FASCIST_ASSEMBLER))\n+#ifndef ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(file, name)\n+#endif\n+#ifndef ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(file, name)\n+#endif\n+#endif\n+\n+/* Record an element in the table of global destructors.\n+   How this is done depends on what sort of assembler and linker\n+   are in use.\n+\n+   NAME should be the name of a global function to be called\n+   at exit time.  This name is output using assemble_name.  */\n+\n+void\n+assemble_destructor (name)\n+     char *name;\n+{\n+#ifdef ASM_OUTPUT_DESTRUCTOR\n+  ASM_OUTPUT_DESTRUCTOR (asm_out_file, name);\n+#else\n+  if (flag_gnu_linker)\n+    {\n+      /* Now tell GNU LD that this is part of the static destructor set.  */\n+      /* This code works for any machine provided you use GNU as/ld.  */\n+      fprintf (asm_out_file, \"%s \\\"___DTOR_LIST__\\\",22,0,0,\", ASM_STABS_OP);\n+      assemble_name (asm_out_file, name);\n+      fputc ('\\n', asm_out_file);\n+    }\n+#endif\n+}\n+\n+/* Likewise for global constructors.  */\n+\n+void\n+assemble_constructor (name)\n+     char *name;\n+{\n+#ifdef ASM_OUTPUT_CONSTRUCTOR\n+  ASM_OUTPUT_CONSTRUCTOR (asm_out_file, name);\n+#else\n+  if (flag_gnu_linker)\n+    {\n+      /* Now tell GNU LD that this is part of the static constructor set.  */\n+      /* This code works for any machine provided you use GNU as/ld.  */\n+      fprintf (asm_out_file, \"%s \\\"___CTOR_LIST__\\\",22,0,0,\", ASM_STABS_OP);\n+      assemble_name (asm_out_file, name);\n+      fputc ('\\n', asm_out_file);\n+    }\n+#endif\n+}\n+\n+/* Likewise for entries we want to record for garbage collection.\n+   Garbage collection is still under development.  */\n+\n+void\n+assemble_gc_entry (name)\n+     char *name;\n+{\n+#ifdef ASM_OUTPUT_GC_ENTRY\n+  ASM_OUTPUT_GC_ENTRY (asm_out_file, name);\n+#else\n+  if (flag_gnu_linker)\n+    {\n+      /* Now tell GNU LD that this is part of the static constructor set.  */\n+      fprintf (asm_out_file, \"%s \\\"___PTR_LIST__\\\",22,0,0,\", ASM_STABS_OP);\n+      assemble_name (asm_out_file, name);\n+      fputc ('\\n', asm_out_file);\n+    }\n+#endif\n+}\n+\f\n+/* Output assembler code for the constant pool of a function and associated\n+   with defining the name of the function.  DECL describes the function.\n+   NAME is the function's name.  For the constant pool, we use the current\n+   constant pool data.  */\n+\n+void\n+assemble_start_function (decl, fnname)\n+     tree decl;\n+     char *fnname;\n+{\n+  int align;\n+\n+  /* The following code does not need preprocessing in the assembler.  */\n+\n+  app_disable ();\n+\n+  output_constant_pool (fnname, decl);\n+\n+  text_section ();\n+\n+\n+  /* Tell assembler to move to target machine's alignment for functions.  */\n+  align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n+  if (align > 0)\n+    ASM_OUTPUT_ALIGN (asm_out_file, align);\n+\n+#ifdef ASM_OUTPUT_FUNCTION_PREFIX\n+  ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);\n+#endif\n+\n+#ifdef SDB_DEBUGGING_INFO\n+  /* Output SDB definition of the function.  */\n+  if (write_symbols == SDB_DEBUG)\n+    sdbout_mark_begin_function ();\n+#endif\n+\n+#ifdef DBX_DEBUGGING_INFO\n+  /* Output SDB definition of the function.  */\n+  if (write_symbols == DBX_DEBUG)\n+    dbxout_begin_function ();\n+#endif\n+\n+  /* Make function name accessible from other files, if appropriate.  */\n+\n+  if (TREE_PUBLIC (decl))\n+    {\n+      if (!first_global_object_name)\n+\tfirst_global_object_name = fnname + (fnname[0] == '*');\n+      ASM_GLOBALIZE_LABEL (asm_out_file, fnname);\n+    }\n+\n+  /* Do any machine/system dependent processing of the function name */\n+#ifdef ASM_DECLARE_FUNCTION_NAME\n+  ASM_DECLARE_FUNCTION_NAME (asm_out_file, fnname, current_function_decl);\n+#else\n+  /* Standard thing is just output label for the function.  */\n+  ASM_OUTPUT_LABEL (asm_out_file, fnname);\n+#endif /* ASM_DECLARE_FUNCTION_NAME */\n+}\n+\n+/* Output assembler code associated with defining the size of the\n+   function.  DECL describes the function.  NAME is the function's name.  */\n+\n+void\n+assemble_end_function (decl, fnname)\n+     tree decl;\n+     char *fnname;\n+{\n+#ifdef ASM_DECLARE_FUNCTION_SIZE\n+  ASM_DECLARE_FUNCTION_SIZE (asm_out_file, fnname, decl);\n+#endif\n+}\n+\f\n+/* Assemble code to leave SIZE bytes of zeros.  */\n+\n+void\n+assemble_zeros (size)\n+     int size;\n+{\n+#ifdef ASM_NO_SKIP_IN_TEXT\n+  /* The `space' pseudo in the text section outputs nop insns rather than 0s,\n+     so we must output 0s explicitly in the text section.  */\n+  if (ASM_NO_SKIP_IN_TEXT && in_text_section ())\n+    {\n+      int i;\n+\n+      for (i = 0; i < size - 20; i += 20)\n+\t{\n+#ifdef ASM_BYTE_OP\n+\t  fprintf (asm_out_file,\n+\t\t   \"%s 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\n\", ASM_BYTE_OP);\n+#else\n+\t  fprintf (asm_out_file,\n+\t\t   \"\\tbyte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\n\");\n+#endif\n+\t}\n+      if (i < size)\n+        {\n+#ifdef ASM_BYTE_OP\n+\t  fprintf (asm_out_file, \"%s 0\", ASM_BYTE_OP);\n+#else\n+\t  fprintf (asm_out_file, \"\\tbyte 0\");\n+#endif\n+\t  i++;\n+\t  for (; i < size; i++)\n+\t    fprintf (asm_out_file, \",0\");\n+\t  fprintf (asm_out_file, \"\\n\");\n+\t}\n+    }\n+  else\n+#endif\n+    ASM_OUTPUT_SKIP (asm_out_file, size);\n+}\n+\n+/* Assemble a string constant with the specified C string as contents.  */\n+\n+void\n+assemble_string (p, size)\n+     unsigned char *p;\n+     int size;\n+{\n+  register int i;\n+  int pos = 0;\n+  int maximum = 2000;\n+\n+  /* If the string is very long, split it up.  */\n+\n+  while (pos < size)\n+    {\n+      int thissize = size - pos;\n+      if (thissize > maximum)\n+\tthissize = maximum;\n+\n+#ifdef ASM_OUTPUT_ASCII\n+      ASM_OUTPUT_ASCII (asm_out_file, p, thissize);\n+#else\n+      fprintf (asm_out_file, \"\\t.ascii \\\"\");\n+\n+      for (i = 0; i < thissize; i++)\n+\t{\n+\t  register int c = p[i];\n+\t  if (c == '\\\"' || c == '\\\\')\n+\t    putc ('\\\\', asm_out_file);\n+\t  if (c >= ' ' && c < 0177)\n+\t    putc (c, asm_out_file);\n+\t  else\n+\t    {\n+\t      fprintf (asm_out_file, \"\\\\%o\", c);\n+\t      /* After an octal-escape, if a digit follows,\n+\t\t terminate one string constant and start another.\n+\t\t The Vax assembler fails to stop reading the escape\n+\t\t after three digits, so this is the only way we\n+\t\t can get it to parse the data properly.  */\n+\t      if (i < thissize - 1\n+\t\t  && p[i + 1] >= '0' && p[i + 1] <= '9')\n+\t\tfprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");\n+\t    }\n+\t}\n+      fprintf (asm_out_file, \"\\\"\\n\");\n+#endif /* no ASM_OUTPUT_ASCII */\n+\n+      pos += thissize;\n+      p += thissize;\n+    }\n+}\n+\f\n+/* Assemble everything that is needed for a variable or function declaration.\n+   Not used for automatic variables, and not used for function definitions.\n+   Should not be called for variables of incomplete structure type.\n+\n+   TOP_LEVEL is nonzero if this variable has file scope.\n+   AT_END is nonzero if this is the special handling, at end of compilation,\n+   to define things that have had only tentative definitions.  */\n+\n+void\n+assemble_variable (decl, top_level, at_end)\n+     tree decl;\n+     int top_level;\n+     int at_end;\n+{\n+  register char *name;\n+  int align;\n+  tree size_tree;\n+  int reloc = 0;\n+\n+  if (GET_CODE (DECL_RTL (decl)) == REG)\n+    {\n+      /* Do output symbol info for global register variables, but do nothing\n+\t else for them.  */\n+\n+      if (TREE_ASM_WRITTEN (decl))\n+\treturn;\n+      TREE_ASM_WRITTEN (decl) = 1;\n+\n+#ifdef DBX_DEBUGGING_INFO\n+      /* File-scope global variables are output here.  */\n+      if (write_symbols == DBX_DEBUG && top_level)\n+\tdbxout_symbol (decl, 0);\n+#endif\n+#ifdef SDB_DEBUGGING_INFO\n+      if (write_symbols == SDB_DEBUG && top_level\n+\t  /* Leave initialized global vars for end of compilation;\n+\t     see comment in compile_file.  */\n+\t  && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n+\tsdbout_symbol (decl, 0);\n+#endif\n+\n+      /* Don't output any DWARF debugging information for variables here.\n+\t In the case of local variables, the information for them is output\n+\t when we do our recursive traversal of the tree representation for\n+\t the entire containing function.  In the case of file-scope variables,\n+\t we output information for all of them at the very end of compilation\n+\t while we are doing our final traversal of the chain of file-scope\n+\t declarations.  */\n+\n+      return;\n+    }\n+\n+  /* Normally no need to say anything for external references,\n+     since assembler considers all undefined symbols external.  */\n+\n+  if (TREE_EXTERNAL (decl))\n+    return;\n+\n+  /* Output no assembler code for a function declaration.\n+     Only definitions of functions output anything.  */\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    return;\n+\n+  /* If type was incomplete when the variable was declared,\n+     see if it is complete now.  */\n+\n+  if (DECL_SIZE (decl) == 0)\n+    layout_decl (decl, 0);\n+\n+  /* Still incomplete => don't allocate it; treat the tentative defn\n+     (which is what it must have been) as an `extern' reference.  */\n+\n+  if (DECL_SIZE (decl) == 0)\n+    {\n+      error_with_file_and_line (DECL_SOURCE_FILE (decl),\n+\t\t\t\tDECL_SOURCE_LINE (decl),\n+\t\t\t\t\"storage size of static var `%s' isn't known\",\n+\t\t\t\tIDENTIFIER_POINTER (DECL_NAME (decl)));\n+      return;\n+    }\n+\n+  /* The first declaration of a variable that comes through this function\n+     decides whether it is global (in C, has external linkage)\n+     or local (in C, has internal linkage).  So do nothing more\n+     if this function has already run.  */\n+\n+  if (TREE_ASM_WRITTEN (decl))\n+    return;\n+\n+  TREE_ASM_WRITTEN (decl) = 1;\n+\n+#ifdef DBX_DEBUGGING_INFO\n+  /* File-scope global variables are output here.  */\n+  if (write_symbols == DBX_DEBUG && top_level)\n+    dbxout_symbol (decl, 0);\n+#endif\n+#ifdef SDB_DEBUGGING_INFO\n+  if (write_symbols == SDB_DEBUG && top_level\n+      /* Leave initialized global vars for end of compilation;\n+\t see comment in compile_file.  */\n+      && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n+    sdbout_symbol (decl, 0);\n+#endif\n+\n+  /* Don't output any DWARF debugging information for variables here.\n+     In the case of local variables, the information for them is output\n+     when we do our recursive traversal of the tree representation for\n+     the entire containing function.  In the case of file-scope variables,\n+     we output information for all of them at the very end of compilation\n+     while we are doing our final traversal of the chain of file-scope\n+     declarations.  */\n+\n+  /* If storage size is erroneously variable, just continue.\n+     Error message was already made.  */\n+\n+  if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+    return;\n+\n+  app_disable ();\n+\n+  /* This is better than explicit arithmetic, since it avoids overflow.  */\n+  size_tree = size_binop (CEIL_DIV_EXPR,\n+\t\t\t  DECL_SIZE (decl), size_int (BITS_PER_UNIT));\n+\n+  if (TREE_INT_CST_HIGH (size_tree) != 0)\n+    {\n+      error_with_decl (decl, \"size of variable `%s' is too large\");\n+      return;\n+    }\n+\n+  name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+\n+  /* Handle uninitialized definitions.  */\n+\n+  /* ANSI specifies that a tentative definition which is not merged with\n+     a non-tentative definition behaves exactly like a definition with an\n+     initializer equal to zero.  (Section 3.7.2)\n+     -fno-common gives strict ANSI behavior.  Usually you don't want it.  */\n+  if (! flag_no_common\n+      && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))\n+    {\n+      int size = TREE_INT_CST_LOW (size_tree);\n+      int rounded = size;\n+\n+      if (TREE_INT_CST_HIGH (size_tree) != 0)\n+\terror_with_decl (decl, \"size of variable `%s' is too large\");\n+      /* Don't allocate zero bytes of common,\n+\t since that means \"undefined external\" in the linker.  */\n+      if (size == 0) rounded = 1;\n+      /* Round size up to multiple of BIGGEST_ALIGNMENT bits\n+\t so that each uninitialized object starts on such a boundary.  */\n+      rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n+      rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+\t\t * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+#if 0\n+      if (flag_shared_data)\n+\tdata_section ();\n+#endif\n+      if (TREE_PUBLIC (decl))\n+\t{\n+#ifdef ASM_OUTPUT_SHARED_COMMON\n+\t  if (flag_shared_data)\n+\t    ASM_OUTPUT_SHARED_COMMON (asm_out_file, name, size, rounded);\n+\t  else\n+#endif\n+#ifdef ASM_OUTPUT_ALIGNED_COMMON\n+\t    ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size,\n+\t\t\t\t       DECL_ALIGN (decl));\n+#else\n+\t    ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded);\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef ASM_OUTPUT_SHARED_LOCAL\n+\t  if (flag_shared_data)\n+\t    ASM_OUTPUT_SHARED_LOCAL (asm_out_file, name, size, rounded);\n+\t  else\n+#endif\n+#ifdef ASM_OUTPUT_ALIGNED_LOCAL\n+\t    ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size,\n+\t\t\t\t      DECL_ALIGN (decl));\n+#else\n+\t    ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+#endif\n+\t}\n+      return;\n+    }\n+\n+  /* Handle initialized definitions.  */\n+\n+  /* First make the assembler name(s) global if appropriate.  */\n+  if (TREE_PUBLIC (decl) && DECL_NAME (decl))\n+    {\n+      if (!first_global_object_name)\n+\tfirst_global_object_name = name + (name[0] == '*');\n+      ASM_GLOBALIZE_LABEL (asm_out_file, name);\n+    }\n+#if 0\n+  for (d = equivalents; d; d = TREE_CHAIN (d))\n+    {\n+      tree e = TREE_VALUE (d);\n+      if (TREE_PUBLIC (e) && DECL_NAME (e))\n+\tASM_GLOBALIZE_LABEL (asm_out_file,\n+\t\t\t     XSTR (XEXP (DECL_RTL (e), 0), 0));\n+    }\n+#endif\n+\n+  /* Output any data that we will need to use the address of.  */\n+  if (DECL_INITIAL (decl))\n+    reloc = output_addressed_constants (DECL_INITIAL (decl));\n+\n+  /* Switch to the proper section for this data.  */\n+#ifdef SELECT_SECTION\n+  SELECT_SECTION (decl, reloc);\n+#else\n+  if (TREE_READONLY (decl)\n+      && ! TREE_THIS_VOLATILE (decl)\n+      && ! (flag_pic && reloc))\n+    readonly_data_section ();\n+  else\n+    data_section ();\n+#endif\n+\n+  /* Compute and output the alignment of this data.  */\n+\n+  align = DECL_ALIGN (decl);\n+  /* Some object file formats have a maximum alignment which they support.\n+     In particular, a.out format supports a maximum alignment of 4.  */\n+#ifndef MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT\n+#endif\n+  if (align > MAX_OFILE_ALIGNMENT)\n+    {\n+      warning_with_decl (decl,\n+\t  \"alignment of `%s' is greater than maximum object file alignment\");\n+      align = MAX_OFILE_ALIGNMENT;\n+    }\n+#ifdef DATA_ALIGNMENT\n+  /* On some machines, it is good to increase alignment sometimes.  */\n+  align = DATA_ALIGNMENT (TREE_TYPE (decl), align);\n+#endif\n+#ifdef CONSTANT_ALIGNMENT\n+  if (DECL_INITIAL (decl))\n+    align = CONSTANT_ALIGNMENT (DECL_INITIAL (decl), align);\n+#endif\n+\n+  /* Reset the alignment in case we have made it tighter, so we can benefit\n+     from it in get_pointer_alignment.  */\n+  DECL_ALIGN (decl) = align;\n+\n+  if (align > BITS_PER_UNIT)\n+    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+\n+  /* Do any machine/system dependent processing of the object.  */\n+#ifdef ASM_DECLARE_OBJECT_NAME\n+  ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);\n+#else\n+  /* Standard thing is just output label for the object.  */\n+  ASM_OUTPUT_LABEL (asm_out_file, name);\n+#endif /* ASM_DECLARE_OBJECT_NAME */\n+\n+#if 0\n+  for (d = equivalents; d; d = TREE_CHAIN (d))\n+    {\n+      tree e = TREE_VALUE (d);\n+      ASM_OUTPUT_LABEL (asm_out_file, XSTR (XEXP (DECL_RTL (e), 0), 0));\n+    }\n+#endif\n+\n+  if (DECL_INITIAL (decl))\n+    /* Output the actual data.  */\n+    output_constant (DECL_INITIAL (decl),\n+\t\t     int_size_in_bytes (TREE_TYPE (decl)));\n+  else\n+    /* Leave space for it.  */\n+    assemble_zeros (int_size_in_bytes (TREE_TYPE (decl)));\n+}\n+\n+/* Output something to declare an external symbol to the assembler.\n+   (Most assemblers don't need this, so we normally output nothing.)  */\n+\n+void\n+assemble_external (decl)\n+     tree decl;\n+{\n+  rtx rtl = DECL_RTL (decl);\n+\n+#ifdef ASM_OUTPUT_EXTERNAL\n+  if (TREE_PUBLIC (decl)\n+      && GET_CODE (rtl) == MEM && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF\n+      && ! SYMBOL_REF_USED (XEXP (rtl, 0)))\n+    {\n+      /* Some systems do require some output.  */\n+      SYMBOL_REF_USED (XEXP (rtl, 0)) = 1;\n+      ASM_OUTPUT_EXTERNAL (asm_out_file, decl, XSTR (XEXP (rtl, 0), 0));\n+    }\n+#endif\n+}\n+\n+/* Similar, for calling a library function FUN.  */\n+\n+void\n+assemble_external_libcall (fun)\n+     rtx fun;\n+{\n+#ifdef ASM_OUTPUT_EXTERNAL_LIBCALL\n+  /* Declare library function name external when first used, if nec.  */\n+  if (! SYMBOL_REF_USED (fun))\n+    {\n+      SYMBOL_REF_USED (fun) = 1;\n+      ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);\n+    }\n+#endif\n+}\n+\n+/* Declare the label NAME global.  */\n+\n+void\n+assemble_global (name)\n+     char *name;\n+{\n+  ASM_GLOBALIZE_LABEL (asm_out_file, name);\n+}\n+\n+/* Assemble a label named NAME.  */\n+\n+void\n+assemble_label (name)\n+     char *name;\n+{\n+  ASM_OUTPUT_LABEL (asm_out_file, name);\n+}\n+\n+/* Output to FILE a reference to the assembler name of a C-level name NAME.\n+   If NAME starts with a *, the rest of NAME is output verbatim.\n+   Otherwise NAME is transformed in an implementation-defined way\n+   (usually by the addition of an underscore).\n+   Many macros in the tm file are defined to call this function.  */\n+\n+void\n+assemble_name (file, name)\n+     FILE *file;\n+     char *name;\n+{\n+  if (name[0] == '*')\n+    fputs (&name[1], file);\n+  else\n+    ASM_OUTPUT_LABELREF (file, name);\n+}\n+\n+/* Allocate SIZE bytes writable static space with a gensym name\n+   and return an RTX to refer to its address.  */\n+\n+rtx\n+assemble_static_space (size)\n+     int size;\n+{\n+  char name[12];\n+  char *namestring;\n+  rtx x;\n+  /* Round size up to multiple of BIGGEST_ALIGNMENT bits\n+     so that each uninitialized object starts on such a boundary.  */\n+  int rounded = ((size + (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1)\n+\t\t / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+\t\t * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+\n+#if 0\n+  if (flag_shared_data)\n+    data_section ();\n+#endif\n+\n+  ASM_GENERATE_INTERNAL_LABEL (name, \"LF\", const_labelno);\n+  ++const_labelno;\n+\n+  namestring = (char *) obstack_alloc (saveable_obstack,\n+\t\t\t\t       strlen (name) + 2);\n+  strcpy (namestring, name);\n+\n+  x = gen_rtx (SYMBOL_REF, Pmode, namestring);\n+#ifdef ASM_OUTPUT_ALIGNED_LOCAL\n+  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, BIGGEST_ALIGNMENT);\n+#else\n+  ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+#endif\n+  return x;\n+}\n+\n+/* Assemble the static constant template for function entry trampolines.\n+   This is done at most once per compilation.\n+   Returns an RTX for the address of the template.  */\n+\n+rtx\n+assemble_trampoline_template ()\n+{\n+  char label[256];\n+  char *name;\n+  int align;\n+\n+  /* Write the assembler code to define one.  */\n+  align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n+  if (align > 0)\n+    ASM_OUTPUT_ALIGN (asm_out_file, align);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LTRAMP\", 0);\n+  TRAMPOLINE_TEMPLATE (asm_out_file);\n+\n+  /* Record the rtl to refer to it.  */\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LTRAMP\", 0);\n+  name\n+    = (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n+  return gen_rtx (SYMBOL_REF, Pmode, name);\n+}\n+\f\n+/* Assemble the integer constant X into an object of SIZE bytes.\n+   X must be either a CONST_INT or CONST_DOUBLE.\n+\n+   Return 1 if we were able to output the constant, otherwise 0.  If FORCE is\n+   non-zero, abort if we can't output the constant.  */\n+\n+int\n+assemble_integer (x, size, force)\n+     rtx x;\n+     int size;\n+     int force;\n+{\n+  /* First try to use the standard 1, 2, 4, 8, and 16 byte\n+     ASM_OUTPUT... macros. */\n+\n+  switch (size)\n+    {\n+#ifdef ASM_OUTPUT_CHAR\n+    case 1:\n+      ASM_OUTPUT_CHAR (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+#ifdef ASM_OUTPUT_SHORT\n+    case 2:\n+      ASM_OUTPUT_SHORT (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+#ifdef ASM_OUTPUT_INT\n+    case 4:\n+      ASM_OUTPUT_INT (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+#ifdef ASM_OUTPUT_DOUBLE_INT\n+    case 8:\n+      ASM_OUTPUT_DOUBLE_INT (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+#ifdef ASM_OUTPUT_QUADRUPLE_INT\n+    case 16:\n+      ASM_OUTPUT_QUADRUPLE_INT (asm_out_file, x);\n+      return 1;\n+#endif\n+    }\n+\n+  /* If we couldn't do it that way, there are two other possibilities: First,\n+     if the machine can output an explicit byte and this is a 1 byte constant,\n+     we can use ASM_OUTPUT_BYTE.  */\n+\n+#ifdef ASM_OUTPUT_BYTE\n+  if (size == 1 && GET_CODE (x) == CONST_INT)\n+    {\n+      ASM_OUTPUT_BYTE (asm_out_file, INTVAL (x));\n+      return 1;\n+    }\n+#endif\n+\n+  /* Finally, if SIZE is larger than a single word, try to output the constant\n+     one word at a time.  */\n+\n+  if (size > UNITS_PER_WORD)\n+    {\n+      int i;\n+      enum machine_mode mode\n+\t= mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+      rtx word;\n+\n+      for (i = 0; i < size / UNITS_PER_WORD; i++)\n+\t{\n+\t  word = operand_subword (x, i, 0, mode);\n+\n+\t  if (word == 0)\n+\t    break;\n+\n+\t  assemble_integer (word, UNITS_PER_WORD);\n+\t}\n+\n+      if (i == size / UNITS_PER_WORD)\n+\treturn 1;\n+    }\n+\n+  if (force)\n+    abort ();\n+\n+  return 0;\n+}\n+\f\n+/* Assemble the floating-point constant D into an object of size MODE.  */\n+\n+void\n+assemble_real (d, mode)\n+     REAL_VALUE_TYPE d;\n+     enum machine_mode mode;\n+{\n+  jmp_buf output_constant_handler;\n+\n+  if (setjmp (output_constant_handler))\n+    {\n+      error (\"floating point trap outputting a constant\");\n+#ifdef REAL_IS_NOT_DOUBLE\n+      bzero (&d, sizeof d);\n+      d = dconst0;\n+#else\n+      d = 0;\n+#endif\n+    }\n+\n+  set_float_handler (output_constant_handler);\n+\n+  switch (mode)\n+    {\n+#ifdef ASM_OUTPUT_FLOAT\n+    case SFmode:\n+      ASM_OUTPUT_FLOAT (asm_out_file, d);\n+      break;\n+#endif\n+\n+#ifdef ASM_OUTPUT_DOUBLE\n+    case DFmode:\n+      ASM_OUTPUT_DOUBLE (asm_out_file, d);\n+      break;\n+#endif\n+\n+#ifdef ASM_OUTPUT_LONG_DOUBLE\n+    case TFmode:\n+      ASM_OUTPUT_LONG_DOUBLE (asm_out_file, d);\n+      break;\n+#endif\n+\n+    default:\n+      abort ();\n+    }\n+\n+  set_float_handler (0);\n+}\n+\f\n+/* Here we combine duplicate floating constants to make\n+   CONST_DOUBLE rtx's, and force those out to memory when necessary.  */\n+\n+/* Chain of all CONST_DOUBLE rtx's constructed for the current function.\n+   They are chained through the CONST_DOUBLE_CHAIN.\n+   A CONST_DOUBLE rtx has CONST_DOUBLE_MEM != cc0_rtx iff it is on this chain.\n+   In that case, CONST_DOUBLE_MEM is either a MEM,\n+   or const0_rtx if no MEM has been made for this CONST_DOUBLE yet.  */\n+\n+static rtx const_double_chain;\n+\n+/* Return a CONST_DOUBLE for a value specified as a pair of ints.\n+   For an integer, I0 is the low-order word and I1 is the high-order word.\n+   For a real number, I0 is the word with the low address\n+   and I1 is the word with the high address.  */\n+\n+rtx\n+immed_double_const (i0, i1, mode)\n+     int i0, i1;\n+     enum machine_mode mode;\n+{\n+  register rtx r;\n+  int in_current_obstack;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      /* We clear out all bits that don't belong in MODE, unless they and our\n+\t sign bit are all one.  So we get either a reasonable negative value\n+\t or a reasonable unsigned value for this mode.  */\n+      int width = GET_MODE_BITSIZE (mode);\n+      if (width < HOST_BITS_PER_INT\n+\t  && ((i0 & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n+\ti0 &= (1 << width) - 1, i1 = 0;\n+      else if (width == HOST_BITS_PER_INT\n+\t       && ! (i1 == ~0 && i0 < 0))\n+\ti1 = 0;\n+      else if (width > 2 * HOST_BITS_PER_INT)\n+\t/* We cannot represent this value as a constant.  */\n+\tabort ();\n+\n+      /* If MODE fits within HOST_BITS_PER_INT, always use a CONST_INT.\n+\n+\t ??? Strictly speaking, this is wrong if we create a CONST_INT\n+\t for a large unsigned constant with the size of MODE being\n+\t HOST_BITS_PER_INT and later try to interpret that constant in a wider\n+\t mode.  In that case we will mis-interpret it as a negative number.\n+\n+\t Unfortunately, the only alternative is to make a CONST_DOUBLE\n+\t for any constant in any mode if it is an unsigned constant larger\n+\t than the maximum signed integer in an int on the host.  However,\n+\t doing this will break everyone that always expects to see a CONST_INT\n+\t for SImode and smaller.\n+\n+\t We have always been making CONST_INTs in this case, so nothing new\n+\t is being broken.  */\n+\n+      if (width <= HOST_BITS_PER_INT)\n+\ti1 = (i0 < 0) ? ~0 : 0;\n+\n+      /* If this integer fits in one word, return a CONST_INT.  */\n+      if ((i1 == 0 && i0 >= 0)\n+\t  || (i1 == ~0 && i0 < 0))\n+\treturn gen_rtx (CONST_INT, VOIDmode, i0);\n+\n+      /* We use VOIDmode for integers.  */\n+      mode = VOIDmode;\n+    }\n+\n+  /* Search the chain for an existing CONST_DOUBLE with the right value.\n+     If one is found, return it.  */\n+\n+  for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n+    if (CONST_DOUBLE_LOW (r) == i0 && CONST_DOUBLE_HIGH (r) == i1\n+\t&& GET_MODE (r) == mode)\n+      return r;\n+\n+  /* No; make a new one and add it to the chain.\n+\n+     We may be called by an optimizer which may be discarding any memory\n+     allocated during its processing (such as combine and loop).  However,\n+     we will be leaving this constant on the chain, so we cannot tolerate\n+     freed memory.  So switch to saveable_obstack for this allocation\n+     and then switch back if we were in current_obstack.  */\n+\n+  in_current_obstack = rtl_in_saveable_obstack ();\n+  r = gen_rtx (CONST_DOUBLE, mode, 0, i0, i1);\n+  if (in_current_obstack)\n+    rtl_in_current_obstack ();\n+\n+  CONST_DOUBLE_CHAIN (r) = const_double_chain;\n+  const_double_chain = r;\n+\n+  /* Store const0_rtx in mem-slot since this CONST_DOUBLE is on the chain.\n+     Actual use of mem-slot is only through force_const_mem.  */\n+\n+  CONST_DOUBLE_MEM (r) = const0_rtx;\n+\n+  return r;\n+}\n+\n+/* Return a CONST_DOUBLE for a specified `double' value\n+   and machine mode.  */\n+\n+rtx\n+immed_real_const_1 (d, mode)\n+     REAL_VALUE_TYPE d;\n+     enum machine_mode mode;\n+{\n+  union real_extract u;\n+  register rtx r;\n+  int in_current_obstack;\n+\n+  /* Get the desired `double' value as a sequence of ints\n+     since that is how they are stored in a CONST_DOUBLE.  */\n+\n+  u.d = d;\n+\n+  /* Detect special cases.  */\n+\n+  if (REAL_VALUES_EQUAL (dconst0, d))\n+    return CONST0_RTX (mode);\n+  else if (REAL_VALUES_EQUAL (dconst1, d))\n+    return CONST1_RTX (mode);\n+\n+  if (sizeof u == 2 * sizeof (int))\n+    return immed_double_const (u.i[0], u.i[1], mode);\n+\n+  /* The rest of this function handles the case where\n+     a float value requires more than 2 ints of space.\n+     It will be deleted as dead code on machines that don't need it.  */\n+\n+  /* Search the chain for an existing CONST_DOUBLE with the right value.\n+     If one is found, return it.  */\n+\n+  for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n+    if (! bcmp (&CONST_DOUBLE_LOW (r), &u, sizeof u)\n+\t&& GET_MODE (r) == mode)\n+      return r;\n+\n+  /* No; make a new one and add it to the chain.\n+\n+     We may be called by an optimizer which may be discarding any memory\n+     allocated during its processing (such as combine and loop).  However,\n+     we will be leaving this constant on the chain, so we cannot tolerate\n+     freed memory.  So switch to saveable_obstack for this allocation\n+     and then switch back if we were in current_obstack.  */\n+\n+  in_current_obstack = rtl_in_saveable_obstack ();\n+  r = rtx_alloc (CONST_DOUBLE);\n+  PUT_MODE (r, mode);\n+  bcopy (&u, &CONST_DOUBLE_LOW (r), sizeof u);\n+  if (in_current_obstack)\n+    rtl_in_current_obstack ();\n+\n+  CONST_DOUBLE_CHAIN (r) = const_double_chain;\n+  const_double_chain = r;\n+\n+  /* Store const0_rtx in CONST_DOUBLE_MEM since this CONST_DOUBLE is on the\n+     chain, but has not been allocated memory.  Actual use of CONST_DOUBLE_MEM\n+     is only through force_const_mem.  */\n+\n+  CONST_DOUBLE_MEM (r) = const0_rtx;\n+\n+  return r;\n+}\n+\n+/* Return a CONST_DOUBLE rtx for a value specified by EXP,\n+   which must be a REAL_CST tree node.  */\n+\n+rtx\n+immed_real_const (exp)\n+     tree exp;\n+{\n+  return immed_real_const_1 (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)));\n+}\n+\n+/* At the end of a function, forget the memory-constants\n+   previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.\n+   Also clear out real_constant_chain and clear out all the chain-pointers.  */\n+\n+void\n+clear_const_double_mem ()\n+{\n+  register rtx r, next;\n+\n+  for (r = const_double_chain; r; r = next)\n+    {\n+      next = CONST_DOUBLE_CHAIN (r);\n+      CONST_DOUBLE_CHAIN (r) = 0;\n+      CONST_DOUBLE_MEM (r) = cc0_rtx;\n+    }\n+  const_double_chain = 0;\n+}\n+\f\n+/* Given an expression EXP with a constant value,\n+   reduce it to the sum of an assembler symbol and an integer.\n+   Store them both in the structure *VALUE.\n+   Abort if EXP does not reduce.  */\n+\n+struct addr_const\n+{\n+  rtx base;\n+  int offset;\n+};\n+\n+static void\n+decode_addr_const (exp, value)\n+     tree exp;\n+     struct addr_const *value;\n+{\n+  register tree target = TREE_OPERAND (exp, 0);\n+  register int offset = 0;\n+  register rtx x;\n+\n+  while (1)\n+    {\n+      if (TREE_CODE (target) == COMPONENT_REF\n+\t  && (TREE_CODE (DECL_FIELD_BITPOS (TREE_OPERAND (target, 1)))\n+\t      == INTEGER_CST))\n+\t{\n+\t  offset += TREE_INT_CST_LOW (DECL_FIELD_BITPOS (TREE_OPERAND (target, 1))) / BITS_PER_UNIT;\n+\t  target = TREE_OPERAND (target, 0);\n+\t}\n+      else if (TREE_CODE (target) == ARRAY_REF)\n+\t{\n+\t  if (TREE_CODE (TREE_OPERAND (target, 1)) != INTEGER_CST\n+\t      || TREE_CODE (TYPE_SIZE (TREE_TYPE (target))) != INTEGER_CST)\n+\t    abort ();\n+\t  offset += ((TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (target)))\n+\t\t      * TREE_INT_CST_LOW (TREE_OPERAND (target, 1)))\n+\t\t     / BITS_PER_UNIT);\n+\t  target = TREE_OPERAND (target, 0);\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  switch (TREE_CODE (target))\n+    {\n+    case VAR_DECL:\n+    case FUNCTION_DECL:\n+      x = DECL_RTL (target);\n+      break;\n+\n+    case LABEL_DECL:\n+      x = gen_rtx (MEM, FUNCTION_MODE,\n+\t\t   gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t    label_rtx (TREE_OPERAND (exp, 0))));\n+      break;\n+\n+    case REAL_CST:\n+    case STRING_CST:\n+    case COMPLEX_CST:\n+    case CONSTRUCTOR:\n+      x = TREE_CST_RTL (target);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (GET_CODE (x) != MEM)\n+    abort ();\n+  x = XEXP (x, 0);\n+\n+  value->base = x;\n+  value->offset = offset;\n+}\n+\f\n+/* Uniquize all constants that appear in memory.\n+   Each constant in memory thus far output is recorded\n+   in `const_hash_table' with a `struct constant_descriptor'\n+   that contains a polish representation of the value of\n+   the constant.\n+\n+   We cannot store the trees in the hash table\n+   because the trees may be temporary.  */\n+\n+struct constant_descriptor\n+{\n+  struct constant_descriptor *next;\n+  char *label;\n+  char contents[1];\n+};\n+\n+#define HASHBITS 30\n+#define MAX_HASH_TABLE 1009\n+static struct constant_descriptor *const_hash_table[MAX_HASH_TABLE];\n+\n+/* Compute a hash code for a constant expression.  */\n+\n+int\n+const_hash (exp)\n+     tree exp;\n+{\n+  register char *p;\n+  register int len, hi, i;\n+  register enum tree_code code = TREE_CODE (exp);\n+\n+  if (code == INTEGER_CST)\n+    {\n+      p = (char *) &TREE_INT_CST_LOW (exp);\n+      len = 2 * sizeof TREE_INT_CST_LOW (exp);\n+    }\n+  else if (code == REAL_CST)\n+    {\n+      p = (char *) &TREE_REAL_CST (exp);\n+      len = sizeof TREE_REAL_CST (exp);\n+    }\n+  else if (code == STRING_CST)\n+    p = TREE_STRING_POINTER (exp), len = TREE_STRING_LENGTH (exp);\n+  else if (code == COMPLEX_CST)\n+    return const_hash (TREE_REALPART (exp)) * 5\n+      + const_hash (TREE_IMAGPART (exp));\n+  else if (code == CONSTRUCTOR)\n+    {\n+      register tree link;\n+\n+      /* For record type, include the type in the hashing.\n+\t We do not do so for array types\n+\t because (1) the sizes of the elements are sufficient\n+\t and (2) distinct array types can have the same constructor.  */\n+      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n+\thi = ((int) TREE_TYPE (exp) & ((1 << HASHBITS) - 1)) % MAX_HASH_TABLE;\n+      else\n+\thi = 5;\n+\n+      for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\thi = (hi * 603 + const_hash (TREE_VALUE (link))) % MAX_HASH_TABLE;\n+\n+      return hi;\n+    }\n+  else if (code == ADDR_EXPR)\n+    {\n+      struct addr_const value;\n+      decode_addr_const (exp, &value);\n+      if (GET_CODE (value.base) == SYMBOL_REF)\n+\t{\n+\t  /* Don't hash the address of the SYMBOL_REF;\n+\t     only use the offset and the symbol name.  */\n+\t  hi = value.offset;\n+\t  p = XSTR (value.base, 0);\n+\t  for (i = 0; p[i] != 0; i++)\n+\t    hi = ((hi * 613) + (unsigned)(p[i]));\n+\t}\n+      else if (GET_CODE (value.base) == LABEL_REF)\n+\thi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;\n+\n+      hi &= (1 << HASHBITS) - 1;\n+      hi %= MAX_HASH_TABLE;\n+      return hi;\n+    }\n+  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n+    return const_hash (TREE_OPERAND (exp, 0)) * 9\n+      +  const_hash (TREE_OPERAND (exp, 1));\n+  else if (code == NOP_EXPR || code == CONVERT_EXPR)\n+    return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;\n+\n+  /* Compute hashing function */\n+  hi = len;\n+  for (i = 0; i < len; i++)\n+    hi = ((hi * 613) + (unsigned)(p[i]));\n+\n+  hi &= (1 << HASHBITS) - 1;\n+  hi %= MAX_HASH_TABLE;\n+  return hi;\n+}\n+\f\n+/* Compare a constant expression EXP with a constant-descriptor DESC.\n+   Return 1 if DESC describes a constant with the same value as EXP.  */\n+\n+static int\n+compare_constant (exp, desc)\n+     tree exp;\n+     struct constant_descriptor *desc;\n+{\n+  return 0 != compare_constant_1 (exp, desc->contents);\n+}\n+\n+/* Compare constant expression EXP with a substring P of a constant descriptor.\n+   If they match, return a pointer to the end of the substring matched.\n+   If they do not match, return 0.\n+\n+   Since descriptors are written in polish prefix notation,\n+   this function can be used recursively to test one operand of EXP\n+   against a subdescriptor, and if it succeeds it returns the\n+   address of the subdescriptor for the next operand.  */\n+\n+static char *\n+compare_constant_1 (exp, p)\n+     tree exp;\n+     char *p;\n+{\n+  register char *strp;\n+  register int len;\n+  register enum tree_code code = TREE_CODE (exp);\n+\n+  if (code != (enum tree_code) *p++)\n+    return 0;\n+\n+  if (code == INTEGER_CST)\n+    {\n+      /* Integer constants are the same only if the same width of type.  */\n+      if (*p++ != TYPE_PRECISION (TREE_TYPE (exp)))\n+\treturn 0;\n+      strp = (char *) &TREE_INT_CST_LOW (exp);\n+      len = 2 * sizeof TREE_INT_CST_LOW (exp);\n+    }\n+  else if (code == REAL_CST)\n+    {\n+      /* Real constants are the same only if the same width of type.  */\n+      if (*p++ != TYPE_PRECISION (TREE_TYPE (exp)))\n+\treturn 0;\n+      strp = (char *) &TREE_REAL_CST (exp);\n+      len = sizeof TREE_REAL_CST (exp);\n+    }\n+  else if (code == STRING_CST)\n+    {\n+      if (flag_writable_strings)\n+\treturn 0;\n+      strp = TREE_STRING_POINTER (exp);\n+      len = TREE_STRING_LENGTH (exp);\n+      if (bcmp (&TREE_STRING_LENGTH (exp), p,\n+\t\tsizeof TREE_STRING_LENGTH (exp)))\n+\treturn 0;\n+      p += sizeof TREE_STRING_LENGTH (exp);\n+    }\n+  else if (code == COMPLEX_CST)\n+    {\n+      p = compare_constant_1 (TREE_REALPART (exp), p);\n+      if (p == 0) return 0;\n+      p = compare_constant_1 (TREE_IMAGPART (exp), p);\n+      return p;\n+    }\n+  else if (code == CONSTRUCTOR)\n+    {\n+      register tree link;\n+      int length = list_length (CONSTRUCTOR_ELTS (exp));\n+      tree type;\n+\n+      if (bcmp (&length, p, sizeof length))\n+\treturn 0;\n+      p += sizeof length;\n+\n+      /* For record constructors, insist that the types match.\n+\t For arrays, just verify both constructors are for arrays.  */\n+      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n+\ttype = TREE_TYPE (exp);\n+      else\n+\ttype = 0;\n+      if (bcmp (&type, p, sizeof type))\n+\treturn 0;\n+      p += sizeof type;\n+\n+      for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\tif ((p = compare_constant_1 (TREE_VALUE (link), p)) == 0)\n+\t  return 0;\n+      return p;\n+    }\n+  else if (code == ADDR_EXPR)\n+    {\n+      struct addr_const value;\n+      decode_addr_const (exp, &value);\n+      strp = (char *) &value.offset;\n+      len = sizeof value.offset;\n+      /* Compare the offset.  */\n+      while (--len >= 0)\n+\tif (*p++ != *strp++)\n+\t  return 0;\n+      /* Compare symbol name.  */\n+      strp = XSTR (value.base, 0);\n+      len = strlen (strp) + 1;\n+    }\n+  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n+    {\n+      p = compare_constant_1 (TREE_OPERAND (exp, 0), p);\n+      if (p == 0) return 0;\n+      p = compare_constant_1 (TREE_OPERAND (exp, 1), p);\n+      return p;\n+    }\n+  else if (code == NOP_EXPR || code == CONVERT_EXPR)\n+    {\n+      p = compare_constant_1 (TREE_OPERAND (exp, 0), p);\n+      return p;\n+    }\n+\n+  /* Compare constant contents.  */\n+  while (--len >= 0)\n+    if (*p++ != *strp++)\n+      return 0;\n+\n+  return p;\n+}\n+\f\n+/* Construct a constant descriptor for the expression EXP.\n+   It is up to the caller to enter the descriptor in the hash table.  */\n+\n+static struct constant_descriptor *\n+record_constant (exp)\n+     tree exp;\n+{\n+  struct constant_descriptor *ptr = 0;\n+  int buf;\n+\n+  obstack_grow (&permanent_obstack, &ptr, sizeof ptr);\n+  obstack_grow (&permanent_obstack, &buf, sizeof buf);\n+  record_constant_1 (exp);\n+  return (struct constant_descriptor *) obstack_finish (&permanent_obstack);\n+}\n+\n+/* Add a description of constant expression EXP\n+   to the object growing in `permanent_obstack'.\n+   No need to return its address; the caller will get that\n+   from the obstack when the object is complete.  */\n+\n+static void\n+record_constant_1 (exp)\n+     tree exp;\n+{\n+  register char *strp;\n+  register int len;\n+  register enum tree_code code = TREE_CODE (exp);\n+\n+  obstack_1grow (&permanent_obstack, (unsigned int) code);\n+\n+  if (code == INTEGER_CST)\n+    {\n+      obstack_1grow (&permanent_obstack, TYPE_PRECISION (TREE_TYPE (exp)));\n+      strp = (char *) &TREE_INT_CST_LOW (exp);\n+      len = 2 * sizeof TREE_INT_CST_LOW (exp);\n+    }\n+  else if (code == REAL_CST)\n+    {\n+      obstack_1grow (&permanent_obstack, TYPE_PRECISION (TREE_TYPE (exp)));\n+      strp = (char *) &TREE_REAL_CST (exp);\n+      len = sizeof TREE_REAL_CST (exp);\n+    }\n+  else if (code == STRING_CST)\n+    {\n+      if (flag_writable_strings)\n+\treturn;\n+      strp = TREE_STRING_POINTER (exp);\n+      len = TREE_STRING_LENGTH (exp);\n+      obstack_grow (&permanent_obstack, (char *) &TREE_STRING_LENGTH (exp),\n+\t\t    sizeof TREE_STRING_LENGTH (exp));\n+    }\n+  else if (code == COMPLEX_CST)\n+    {\n+      record_constant_1 (TREE_REALPART (exp));\n+      record_constant_1 (TREE_IMAGPART (exp));\n+      return;\n+    }\n+  else if (code == CONSTRUCTOR)\n+    {\n+      register tree link;\n+      int length = list_length (CONSTRUCTOR_ELTS (exp));\n+      tree type;\n+\n+      obstack_grow (&permanent_obstack, (char *) &length, sizeof length);\n+\n+      /* For record constructors, insist that the types match.\n+\t For arrays, just verify both constructors are for arrays.  */\n+      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n+\ttype = TREE_TYPE (exp);\n+      else\n+\ttype = 0;\n+      obstack_grow (&permanent_obstack, (char *) &type, sizeof type);\n+\n+      for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\trecord_constant_1 (TREE_VALUE (link));\n+      return;\n+    }\n+  else if (code == ADDR_EXPR)\n+    {\n+      struct addr_const value;\n+      decode_addr_const (exp, &value);\n+      /* Record the offset.  */\n+      obstack_grow (&permanent_obstack,\n+\t\t    (char *) &value.offset, sizeof value.offset);\n+      /* Record the symbol name.  */\n+      obstack_grow (&permanent_obstack, XSTR (value.base, 0),\n+\t\t    strlen (XSTR (value.base, 0)) + 1);\n+      return;\n+    }\n+  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n+    {\n+      record_constant_1 (TREE_OPERAND (exp, 0));\n+      record_constant_1 (TREE_OPERAND (exp, 1));\n+      return;\n+    }\n+  else if (code == NOP_EXPR || code == CONVERT_EXPR)\n+    {\n+      record_constant_1 (TREE_OPERAND (exp, 0));\n+      return;\n+    }\n+\n+  /* Record constant contents.  */\n+  obstack_grow (&permanent_obstack, strp, len);\n+}\n+\f\n+/* Return an rtx representing a reference to constant data in memory\n+   for the constant expression EXP.\n+   If assembler code for such a constant has already been output,\n+   return an rtx to refer to it.\n+   Otherwise, output such a constant in memory and generate\n+   an rtx for it.  The TREE_CST_RTL of EXP is set up to point to that rtx.\n+   The const_hash_table records which constants already have label strings.  */\n+\n+rtx\n+output_constant_def (exp)\n+     tree exp;\n+{\n+  register int hash, align;\n+  register struct constant_descriptor *desc;\n+  char label[256];\n+  char *found = 0;\n+  int reloc;\n+  register rtx def;\n+\n+  if (TREE_CODE (exp) == INTEGER_CST)\n+    abort ();\t\t\t/* No TREE_CST_RTL slot in these.  */\n+\n+  if (TREE_CST_RTL (exp))\n+    return TREE_CST_RTL (exp);\n+\n+  /* Make sure any other constants whose addresses appear in EXP\n+     are assigned label numbers.  */\n+\n+  reloc = output_addressed_constants (exp);\n+\n+  /* Compute hash code of EXP.  Search the descriptors for that hash code\n+     to see if any of them describes EXP.  If yes, the descriptor records\n+     the label number already assigned.  */\n+\n+  hash = const_hash (exp) % MAX_HASH_TABLE;\n+\n+  for (desc = const_hash_table[hash]; desc; desc = desc->next)\n+    if (compare_constant (exp, desc))\n+      {\n+\tfound = desc->label;\n+\tbreak;\n+      }\n+\n+  if (found == 0)\n+    {\n+      /* No constant equal to EXP is known to have been output.\n+\t Make a constant descriptor to enter EXP in the hash table.\n+\t Assign the label number and record it in the descriptor for\n+\t future calls to this function to find.  */\n+\n+      /* Create a string containing the label name, in LABEL.  */\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n+\n+      desc = record_constant (exp);\n+      desc->next = const_hash_table[hash];\n+      desc->label\n+\t= (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n+      const_hash_table[hash] = desc;\n+    }\n+\n+  /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n+\n+  push_obstacks_nochange ();\n+  if (TREE_PERMANENT (exp))\n+    end_temporary_allocation ();\n+\n+  def = gen_rtx (SYMBOL_REF, Pmode, desc->label);\n+\n+  TREE_CST_RTL (exp)\n+    = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)), def);\n+  RTX_UNCHANGING_P (TREE_CST_RTL (exp)) = 1;\n+\n+  pop_obstacks ();\n+\n+  /* Optionally set flags or add text to the name to record information\n+     such as that it is a function name.  If the name is changed, the macro\n+     ASM_OUTPUT_LABELREF will have to know how to strip this information.\n+     And if it finds a * at the beginning after doing so, it must handle\n+     that too.  */\n+#ifdef ENCODE_SECTION_INFO\n+  ENCODE_SECTION_INFO (exp);\n+#endif\n+\n+  if (found == 0)\n+    {\n+      /* Now output assembler code to define that label\n+\t and follow it with the data of EXP.  */\n+\n+      /* First switch to text section, except for writable strings.  */\n+#ifdef SELECT_SECTION\n+      SELECT_SECTION (exp, reloc);\n+#else\n+      if (((TREE_CODE (exp) == STRING_CST) && flag_writable_strings)\n+\t  || (flag_pic && reloc))\n+\tdata_section ();\n+      else\n+\treadonly_data_section ();\n+#endif\n+\n+      /* Align the location counter as required by EXP's data type.  */\n+      align = TYPE_ALIGN (TREE_TYPE (exp));\n+#ifdef CONSTANT_ALIGNMENT\n+      align = CONSTANT_ALIGNMENT (exp, align);\n+#endif\n+\n+      if (align > BITS_PER_UNIT)\n+\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+\n+      /* Output the label itself.  */\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LC\", const_labelno);\n+\n+      /* Output the value of EXP.  */\n+      output_constant (exp,\n+\t\t       (TREE_CODE (exp) == STRING_CST\n+\t\t\t? TREE_STRING_LENGTH (exp)\n+\t\t\t: int_size_in_bytes (TREE_TYPE (exp))));\n+\n+      ++const_labelno;\n+    }\n+\n+  return TREE_CST_RTL (exp);\n+}\n+\f\n+/* Similar hash facility for making memory-constants\n+   from constant rtl-expressions.  It is used on RISC machines\n+   where immediate integer arguments and constant addresses are restricted\n+   so that such constants must be stored in memory.\n+\n+   This pool of constants is reinitialized for each function\n+   so each function gets its own constants-pool that comes right before it.\n+\n+   All structures allocated here are discarded when functions are saved for\n+   inlining, so they do not need to be allocated permanently.  */\n+\n+#define MAX_RTX_HASH_TABLE 61\n+static struct constant_descriptor *const_rtx_hash_table[MAX_RTX_HASH_TABLE];\n+\n+/* Structure to represent sufficient information about a constant so that\n+   it can be output when the constant pool is output, so that function\n+   integration can be done, and to simplify handling on machines that reference\n+   constant pool as base+displacement.  */\n+\n+struct pool_constant\n+{\n+  struct constant_descriptor *desc;\n+  struct pool_constant *next;\n+  enum machine_mode mode;\n+  rtx constant;\n+  int labelno;\n+  int align;\n+  int offset;\n+};\n+\n+/* Pointers to first and last constant in pool.  */\n+\n+static struct pool_constant *first_pool, *last_pool;\n+\n+/* Current offset in constant pool (does not include any machine-specific\n+   header.  */\n+\n+static int pool_offset;\n+\n+/* Structure used to maintain hash table mapping symbols used to their\n+   corresponding constants.  */\n+\n+struct pool_sym\n+{\n+  char *label;\n+  struct pool_constant *pool;\n+  struct pool_sym *next;\n+};\n+\n+static struct pool_sym *const_rtx_sym_hash_table[MAX_RTX_HASH_TABLE];\n+\n+/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.\n+   The argument is XSTR (... , 0)  */\n+\n+#define SYMHASH(LABEL)\t\\\n+  ((((int) (LABEL)) & ((1 << HASHBITS) - 1))  % MAX_RTX_HASH_TABLE)\n+\f\n+/* Initialize constant pool hashing for next function.  */\n+\n+void\n+init_const_rtx_hash_table ()\n+{\n+  bzero (const_rtx_hash_table, sizeof const_rtx_hash_table);\n+  bzero (const_rtx_sym_hash_table, sizeof const_rtx_sym_hash_table);\n+\n+  first_pool = last_pool = 0;\n+  pool_offset = 0;\n+}\n+\n+enum kind { RTX_DOUBLE, RTX_INT };\n+\n+struct rtx_const\n+{\n+#ifdef ONLY_INT_FIELDS\n+  unsigned int kind : 16;\n+  unsigned int mode : 16;\n+#else\n+  enum kind kind : 16;\n+  enum machine_mode mode : 16;\n+#endif\n+  union {\n+    union real_extract du;\n+    struct addr_const addr;\n+  } un;\n+};\n+\n+/* Express an rtx for a constant integer (perhaps symbolic)\n+   as the sum of a symbol or label plus an explicit integer.\n+   They are stored into VALUE.  */\n+\n+static void\n+decode_rtx_const (mode, x, value)\n+     enum machine_mode mode;\n+     rtx x;\n+     struct rtx_const *value;\n+{\n+  /* Clear the whole structure, including any gaps.  */\n+\n+  {\n+    int *p = (int *) value;\n+    int *end = (int *) (value + 1);\n+    while (p < end)\n+      *p++ = 0;\n+  }\n+\n+  value->kind = RTX_INT;\t/* Most usual kind. */\n+  value->mode = mode;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_DOUBLE:\n+      value->kind = RTX_DOUBLE;\n+      value->mode = GET_MODE (x);\n+      bcopy (&CONST_DOUBLE_LOW (x), &value->un.du, sizeof value->un.du);\n+      break;\n+\n+    case CONST_INT:\n+      value->un.addr.offset = INTVAL (x);\n+      break;\n+\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      value->un.addr.base = x;\n+      break;\n+\n+    case CONST:\n+      x = XEXP (x, 0);\n+      if (GET_CODE (x) == PLUS)\n+\t{\n+\t  value->un.addr.base = XEXP (x, 0);\n+\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t    abort ();\n+\t  value->un.addr.offset = INTVAL (XEXP (x, 1));\n+\t}\n+      else if (GET_CODE (x) == MINUS)\n+\t{\n+\t  value->un.addr.base = XEXP (x, 0);\n+\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t    abort ();\n+\t  value->un.addr.offset = - INTVAL (XEXP (x, 1));\n+\t}\n+      else\n+\tabort ();\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (value->kind == RTX_INT && value->un.addr.base != 0)\n+    switch (GET_CODE (value->un.addr.base))\n+      {\n+      case SYMBOL_REF:\n+      case LABEL_REF:\n+\t/* Use the string's address, not the SYMBOL_REF's address,\n+\t   for the sake of addresses of library routines.\n+\t   For a LABEL_REF, compare labels.  */\n+\tvalue->un.addr.base = XEXP (value->un.addr.base, 0);\n+      }\n+}\n+\n+/* Compute a hash code for a constant RTL expression.  */\n+\n+int\n+const_hash_rtx (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  register int hi, i;\n+\n+  struct rtx_const value;\n+  decode_rtx_const (mode, x, &value);\n+\n+  /* Compute hashing function */\n+  hi = 0;\n+  for (i = 0; i < sizeof value / sizeof (int); i++)\n+    hi += ((int *) &value)[i];\n+\n+  hi &= (1 << HASHBITS) - 1;\n+  hi %= MAX_RTX_HASH_TABLE;\n+  return hi;\n+}\n+\n+/* Compare a constant rtl object X with a constant-descriptor DESC.\n+   Return 1 if DESC describes a constant with the same value as X.  */\n+\n+static int\n+compare_constant_rtx (mode, x, desc)\n+     enum machine_mode mode;\n+     rtx x;\n+     struct constant_descriptor *desc;\n+{\n+  register int *p = (int *) desc->contents;\n+  register int *strp;\n+  register int len;\n+  struct rtx_const value;\n+\n+  decode_rtx_const (mode, x, &value);\n+  strp = (int *) &value;\n+  len = sizeof value / sizeof (int);\n+\n+  /* Compare constant contents.  */\n+  while (--len >= 0)\n+    if (*p++ != *strp++)\n+      return 0;\n+\n+  return 1;\n+}\n+\n+/* Construct a constant descriptor for the rtl-expression X.\n+   It is up to the caller to enter the descriptor in the hash table.  */\n+\n+static struct constant_descriptor *\n+record_constant_rtx (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  struct constant_descriptor *ptr;\n+  char *label;\n+  struct rtx_const value;\n+\n+  decode_rtx_const (mode, x, &value);\n+\n+  obstack_grow (current_obstack, &ptr, sizeof ptr);\n+  obstack_grow (current_obstack, &label, sizeof label);\n+\n+  /* Record constant contents.  */\n+  obstack_grow (current_obstack, &value, sizeof value);\n+\n+  return (struct constant_descriptor *) obstack_finish (current_obstack);\n+}\n+\f\n+/* Given a constant rtx X, make (or find) a memory constant for its value\n+   and return a MEM rtx to refer to it in memory.  */\n+\n+rtx\n+force_const_mem (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  register int hash;\n+  register struct constant_descriptor *desc;\n+  char label[256];\n+  char *found = 0;\n+  rtx def;\n+\n+  /* If we want this CONST_DOUBLE in the same mode as it is in memory\n+     (this will always be true for floating CONST_DOUBLEs that have been\n+     placed in memory, but not for VOIDmode (integer) CONST_DOUBLEs),\n+     use the previous copy.  Otherwise, make a new one.  Note that in\n+     the unlikely event that this same CONST_DOUBLE is used in two different\n+     modes in an alternating fashion, we will allocate a lot of different\n+     memory locations, but this should be extremely rare.  */\n+\n+  if (GET_CODE (x) == CONST_DOUBLE\n+      && GET_CODE (CONST_DOUBLE_MEM (x)) == MEM\n+      && GET_MODE (CONST_DOUBLE_MEM (x)) == mode)\n+    return CONST_DOUBLE_MEM (x);\n+\n+  /* Compute hash code of X.  Search the descriptors for that hash code\n+     to see if any of them describes X.  If yes, the descriptor records\n+     the label number already assigned.  */\n+\n+  hash = const_hash_rtx (mode, x);\n+\n+  for (desc = const_rtx_hash_table[hash]; desc; desc = desc->next)\n+    if (compare_constant_rtx (mode, x, desc))\n+      {\n+\tfound = desc->label;\n+\tbreak;\n+      }\n+\n+  if (found == 0)\n+    {\n+      register struct pool_constant *pool;\n+      register struct pool_sym *sym;\n+      int align;\n+\n+      /* No constant equal to X is known to have been output.\n+\t Make a constant descriptor to enter X in the hash table.\n+\t Assign the label number and record it in the descriptor for\n+\t future calls to this function to find.  */\n+\n+      desc = record_constant_rtx (mode, x);\n+      desc->next = const_rtx_hash_table[hash];\n+      const_rtx_hash_table[hash] = desc;\n+\n+      /* Align the location counter as required by EXP's data type.  */\n+      align = (mode == VOIDmode) ? UNITS_PER_WORD : GET_MODE_SIZE (mode);\n+      if (align > BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+\talign = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+\n+      pool_offset += align - 1;\n+      pool_offset &= ~ (align - 1);\n+\n+      /* Allocate a pool constant descriptor, fill it in, and chain it in.  */\n+\n+      pool = (struct pool_constant *) oballoc (sizeof (struct pool_constant));\n+      pool->desc = desc;\n+      pool->constant = x;\n+      pool->mode = mode;\n+      pool->labelno = const_labelno;\n+      pool->align = align;\n+      pool->offset = pool_offset;\n+      pool->next = 0;\n+\n+      if (last_pool == 0)\n+\tfirst_pool = pool;\n+      else\n+\tlast_pool->next = pool;\n+\n+      last_pool = pool;\n+      pool_offset += GET_MODE_SIZE (mode);\n+\n+      /* Create a string containing the label name, in LABEL.  */\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n+\n+      ++const_labelno;\n+\n+      desc->label = found\n+\t= (char *) obstack_copy0 (saveable_obstack, label, strlen (label));\n+\n+      /* Add label to symbol hash table.  */\n+      hash = SYMHASH (found);\n+      sym = (struct pool_sym *) oballoc (sizeof (struct pool_sym));\n+      sym->label = found;\n+      sym->pool = pool;\n+      sym->next = const_rtx_sym_hash_table[hash];\n+      const_rtx_sym_hash_table[hash] = sym;\n+    }\n+\n+  /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n+\n+  def = gen_rtx (MEM, mode, gen_rtx (SYMBOL_REF, Pmode, found));\n+\n+  RTX_UNCHANGING_P (def) = 1;\n+  /* Mark the symbol_ref as belonging to this constants pool.  */\n+  CONSTANT_POOL_ADDRESS_P (XEXP (def, 0)) = 1;\n+  current_function_uses_const_pool = 1;\n+\n+  if (GET_CODE (x) == CONST_DOUBLE)\n+    {\n+      if (CONST_DOUBLE_MEM (x) == cc0_rtx)\n+\t{\n+\t  CONST_DOUBLE_CHAIN (x) = const_double_chain;\n+\t  const_double_chain = x;\n+\t}\n+      CONST_DOUBLE_MEM (x) = def;\n+    }\n+\n+  return def;\n+}\n+\f\n+/* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to\n+   the corresponding pool_constant structure.  */\n+\n+static struct pool_constant *\n+find_pool_constant (addr)\n+     rtx addr;\n+{\n+  struct pool_sym *sym;\n+  char *label = XSTR (addr, 0);\n+\n+  for (sym = const_rtx_sym_hash_table[SYMHASH (label)]; sym; sym = sym->next)\n+    if (sym->label == label)\n+      return sym->pool;\n+\n+  abort ();\n+}\n+\n+/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */\n+\n+rtx\n+get_pool_constant (addr)\n+     rtx addr;\n+{\n+  return (find_pool_constant (addr))->constant;\n+}\n+\n+/* Similar, return the mode.  */\n+\n+enum machine_mode\n+get_pool_mode (addr)\n+     rtx addr;\n+{\n+  return (find_pool_constant (addr))->mode;\n+}\n+\n+/* Similar, return the offset in the constant pool.  */\n+\n+int\n+get_pool_offset (addr)\n+     rtx addr;\n+{\n+  return (find_pool_constant (addr))->offset;\n+}\n+\n+/* Return the size of the constant pool.  */\n+\n+int\n+get_pool_size ()\n+{\n+  return pool_offset;\n+}\n+\f\n+/* Write all the constants in the constant pool.  */\n+\n+void\n+output_constant_pool (fnname, fndecl)\n+     char *fnname;\n+     tree fndecl;\n+{\n+  struct pool_constant *pool;\n+  rtx x;\n+  union real_extract u;\n+\n+#ifdef ASM_OUTPUT_POOL_PROLOGUE\n+  ASM_OUTPUT_POOL_PROLOGUE (asm_out_file, fnname, fndecl, pool_offset);\n+#endif\n+\n+  for (pool = first_pool; pool; pool = pool->next)\n+    {\n+      x = pool->constant;\n+\n+      /* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF)\n+\t whose CODE_LABEL has been deleted.  This can occur if a jump table\n+\t is eliminated by optimization.  If so, write a constant of zero\n+\t instead.  */\n+      if ((GET_CODE (x) == LABEL_REF && INSN_DELETED_P (XEXP (x, 0)))\n+\t  || (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n+\t      && INSN_DELETED_P (XEXP (XEXP (XEXP (x, 0), 0), 0))))\n+\tx = const0_rtx;\n+\n+      /* First switch to correct section.  */\n+#ifdef SELECT_RTX_SECTION\n+      SELECT_RTX_SECTION (pool->mode, x);\n+#else\n+      readonly_data_section ();\n+#endif\n+\n+#ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n+      ASM_OUTPUT_SPECIAL_POOL_ENTRY (asm_out_file, x, pool->mode,\n+\t\t\t\t     pool->align, pool->labelno, done);\n+#endif\n+\n+      if (pool->align > 1)\n+\tASM_OUTPUT_ALIGN (asm_out_file, exact_log2 (pool->align));\n+\n+      /* Output the label.  */\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LC\", pool->labelno);\n+\n+      /* Output the value of the constant itself.  */\n+      switch (GET_MODE_CLASS (pool->mode))\n+\t{\n+\tcase MODE_FLOAT:\n+\t  if (GET_CODE (x) != CONST_DOUBLE)\n+\t    abort ();\n+\n+\t  bcopy (&CONST_DOUBLE_LOW (x), &u, sizeof u);\n+\t  assemble_real (u.d, pool->mode);\n+\t  break;\n+\n+\tcase MODE_INT:\n+\t  assemble_integer (x, GET_MODE_SIZE (pool->mode), 1);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+    done: ;\n+    }\n+\n+  /* Done with this pool.  */\n+  first_pool = last_pool = 0;\n+}\n+\f\n+/* Find all the constants whose addresses are referenced inside of EXP,\n+   and make sure assembler code with a label has been output for each one.\n+   Indicate whether an ADDR_EXPR has been encountered.  */\n+\n+int\n+output_addressed_constants (exp)\n+     tree exp;\n+{\n+  int reloc = 0;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case ADDR_EXPR:\n+      {\n+\tregister tree constant = TREE_OPERAND (exp, 0);\n+\n+\twhile (TREE_CODE (constant) == COMPONENT_REF)\n+\t  {\n+\t    constant = TREE_OPERAND (constant, 0);\n+\t  }\n+\n+\tif (TREE_CODE_CLASS (TREE_CODE (constant)) == 'c'\n+\t    || TREE_CODE (constant) == CONSTRUCTOR)\n+\t  /* No need to do anything here\n+\t     for addresses of variables or functions.  */\n+\t  output_constant_def (constant);\n+      }\n+      reloc = 1;\n+      break;\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      reloc = output_addressed_constants (TREE_OPERAND (exp, 0));\n+      reloc |= output_addressed_constants (TREE_OPERAND (exp, 1));\n+      break;\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      reloc = output_addressed_constants (TREE_OPERAND (exp, 0));\n+      break;\n+\n+    case CONSTRUCTOR:\n+      {\n+\tregister tree link;\n+\tfor (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\t  if (TREE_VALUE (link) != 0)\n+\t    reloc |= output_addressed_constants (TREE_VALUE (link));\n+      }\n+      break;\n+\n+    case ERROR_MARK:\n+      break;\n+    }\n+  return reloc;\n+}\n+\f\n+/* Output assembler code for constant EXP to FILE, with no label.\n+   This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n+   Assumes output_addressed_constants has been done on EXP already.\n+\n+   Generate exactly SIZE bytes of assembler data, padding at the end\n+   with zeros if necessary.  SIZE must always be specified.\n+\n+   SIZE is important for structure constructors,\n+   since trailing members may have been omitted from the constructor.\n+   It is also important for initialization of arrays from string constants\n+   since the full length of the string constant might not be wanted.\n+   It is also needed for initialization of unions, where the initializer's\n+   type is just one member, and that may not be as long as the union.\n+\n+   There a case in which we would fail to output exactly SIZE bytes:\n+   for a structure constructor that wants to produce more than SIZE bytes.\n+   But such constructors will never be generated for any possible input.  */\n+\n+void\n+output_constant (exp, size)\n+     register tree exp;\n+     register int size;\n+{\n+  register enum tree_code code = TREE_CODE (TREE_TYPE (exp));\n+  rtx x;\n+\n+  if (size == 0)\n+    return;\n+\n+  /* Eliminate the NOP_EXPR that makes a cast not be an lvalue.\n+     That way we get the constant (we hope) inside it.  */\n+  if (TREE_CODE (exp) == NOP_EXPR\n+      && TREE_TYPE (exp) == TREE_TYPE (TREE_OPERAND (exp, 0)))\n+    exp = TREE_OPERAND (exp, 0);\n+\n+  switch (code)\n+    {\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      /* ??? What about       (int)((float)(int)&foo + 4)    */\n+      while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR\n+\t     || TREE_CODE (exp) == NON_LVALUE_EXPR)\n+\texp = TREE_OPERAND (exp, 0);\n+\n+      if (! assemble_integer (expand_expr (exp, 0, VOIDmode,\n+\t\t\t\t\t   EXPAND_INITIALIZER),\n+\t\t\t      size, 0))\n+\terror (\"initializer for integer value is too complicated\");\n+      size = 0;\n+      break;\n+\n+    case REAL_TYPE:\n+      if (TREE_CODE (exp) != REAL_CST)\n+\terror (\"initializer for floating value is not a floating constant\");\n+\n+      assemble_real (TREE_REAL_CST (exp),\n+\t\t     mode_for_size (size * BITS_PER_UNIT, MODE_FLOAT, 0));\n+      size = 0;\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      output_constant (TREE_REALPART (exp), size / 2);\n+      output_constant (TREE_IMAGPART (exp), size / 2);\n+      size -= (size / 2) * 2;\n+      break;\n+\n+    case ARRAY_TYPE:\n+      if (TREE_CODE (exp) == CONSTRUCTOR)\n+\t{\n+\t  output_constructor (exp, size);\n+\t  return;\n+\t}\n+      else if (TREE_CODE (exp) == STRING_CST)\n+\t{\n+\t  int excess = 0;\n+\n+\t  if (size > TREE_STRING_LENGTH (exp))\n+\t    {\n+\t      excess = size - TREE_STRING_LENGTH (exp);\n+\t      size = TREE_STRING_LENGTH (exp);\n+\t    }\n+\n+\t  assemble_string (TREE_STRING_POINTER (exp), size);\n+\t  size = excess;\n+\t}\n+      else\n+\tabort ();\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      if (TREE_CODE (exp) == CONSTRUCTOR)\n+\toutput_constructor (exp, size);\n+      else\n+\tabort ();\n+      return;\n+    }\n+\n+  if (size > 0)\n+    assemble_zeros (size);\n+}\n+\f\n+/* Subroutine of output_constant, used for CONSTRUCTORs\n+   (aggregate constants).\n+   Generate at least SIZE bytes, padding if necessary.  */\n+\n+void\n+output_constructor (exp, size)\n+     tree exp;\n+     int size;\n+{\n+  register tree link, field = 0;\n+  /* Number of bytes output or skipped so far.\n+     In other words, current position within the constructor.  */\n+  int total_bytes = 0;\n+  /* Non-zero means BYTE contains part of a byte, to be output.  */\n+  int byte_buffer_in_use = 0;\n+  register int byte;\n+\n+  if (HOST_BITS_PER_INT < BITS_PER_UNIT)\n+    abort ();\n+\n+  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n+    field = TYPE_FIELDS (TREE_TYPE (exp));\n+\n+  /* As LINK goes through the elements of the constant,\n+     FIELD goes through the structure fields, if the constant is a structure.\n+     if the constant is a union, then we override this,\n+     by getting the field from the TREE_LIST element.\n+     But the constant could also be an array.  Then FIELD is zero.  */\n+  for (link = CONSTRUCTOR_ELTS (exp);\n+       link;\n+       link = TREE_CHAIN (link),\n+       field = field ? TREE_CHAIN (field) : 0)\n+    {\n+      tree val = TREE_VALUE (link);\n+      /* the element in a union constructor specifies the proper field.  */\n+      if (TREE_PURPOSE (link) != 0)\n+\tfield = TREE_PURPOSE (link);\n+\n+      /* Eliminate the marker that makes a cast not be an lvalue.  */\n+      if (val != 0 && TREE_CODE (val) == NON_LVALUE_EXPR)\n+\tval = TREE_OPERAND (val, 0);\n+\n+      if (field == 0 || !DECL_BIT_FIELD (field))\n+\t{\n+\t  register int fieldsize;\n+\t  /* Since this structure is static,\n+\t     we know the positions are constant.  */\n+\t  int bitpos = (field ? (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n+\t\t\t\t / BITS_PER_UNIT)\n+\t\t\t: 0);\n+\n+\t  /* An element that is not a bit-field.\n+\t     Output any buffered-up bit-fields preceding it.  */\n+\t  if (byte_buffer_in_use)\n+\t    {\n+\t      ASM_OUTPUT_BYTE (asm_out_file, byte);\n+\t      total_bytes++;\n+\t      byte_buffer_in_use = 0;\n+\t    }\n+\n+\t  /* Advance to offset of this element.\n+\t     Note no alignment needed in an array, since that is guaranteed\n+\t     if each element has the proper size.  */\n+\t  if (field != 0 && bitpos != total_bytes)\n+\t    {\n+\t      assemble_zeros (bitpos - total_bytes);\n+\t      total_bytes = bitpos;\n+\t    }\n+\n+\t  /* Determine size this element should occupy.  */\n+\t  if (field)\n+\t    {\n+\t      if (TREE_CODE (DECL_SIZE (field)) != INTEGER_CST)\n+\t\tabort ();\n+\t      if (TREE_INT_CST_LOW (DECL_SIZE (field)) > 100000)\n+\t\t{\n+\t\t  /* This avoids overflow trouble.  */\n+\t\t  tree size_tree = size_binop (CEIL_DIV_EXPR,\n+\t\t\t\t\t       DECL_SIZE (field),\n+\t\t\t\t\t       size_int (BITS_PER_UNIT));\n+\t\t  fieldsize = TREE_INT_CST_LOW (size_tree);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fieldsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t\t  fieldsize = (fieldsize + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+\t\t}\n+\t    }\n+\t  else\n+\t    fieldsize = int_size_in_bytes (TREE_TYPE (TREE_TYPE (exp)));\n+\n+\t  /* Output the element's initial value.  */\n+\t  if (val == 0)\n+\t    assemble_zeros (fieldsize);\n+\t  else\n+\t    output_constant (val, fieldsize);\n+\n+\t  /* Count its size.  */\n+\t  total_bytes += fieldsize;\n+\t}\n+      else if (val != 0 && TREE_CODE (val) != INTEGER_CST)\n+\terror (\"invalid initial value for member `%s'\",\n+\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n+      else\n+\t{\n+\t  /* Element that is a bit-field.  */\n+\n+\t  int next_offset = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  int end_offset\n+\t    = (next_offset + TREE_INT_CST_LOW (DECL_SIZE (field)));\n+\n+\t  if (val == 0)\n+\t    val = integer_zero_node;\n+\n+\t  /* If this field does not start in this (or, next) byte,\n+\t     skip some bytes.  */\n+\t  if (next_offset / BITS_PER_UNIT != total_bytes)\n+\t    {\n+\t      /* Output remnant of any bit field in previous bytes.  */\n+\t      if (byte_buffer_in_use)\n+\t\t{\n+\t\t  ASM_OUTPUT_BYTE (asm_out_file, byte);\n+\t\t  total_bytes++;\n+\t\t  byte_buffer_in_use = 0;\n+\t\t}\n+\n+\t      /* If still not at proper byte, advance to there.  */\n+\t      if (next_offset / BITS_PER_UNIT != total_bytes)\n+\t\t{\n+\t\t  assemble_zeros (next_offset / BITS_PER_UNIT - total_bytes);\n+\t\t  total_bytes = next_offset / BITS_PER_UNIT;\n+\t\t}\n+\t    }\n+\n+\t  if (! byte_buffer_in_use)\n+\t    byte = 0;\n+\n+\t  /* We must split the element into pieces that fall within\n+\t     separate bytes, and combine each byte with previous or\n+\t     following bit-fields.  */\n+\n+\t  /* next_offset is the offset n fbits from the begining of\n+\t     the structure to the next bit of this element to be processed.\n+\t     end_offset is the offset of the first bit past the end of\n+\t     this element.  */\n+\t  while (next_offset < end_offset)\n+\t    {\n+\t      int this_time;\n+\t      int shift, value;\n+\t      int next_byte = next_offset / BITS_PER_UNIT;\n+\t      int next_bit = next_offset % BITS_PER_UNIT;\n+\n+\t      /* Advance from byte to byte\n+\t\t within this element when necessary.  */\n+\t      while (next_byte != total_bytes)\n+\t\t{\n+\t\t  ASM_OUTPUT_BYTE (asm_out_file, byte);\n+\t\t  total_bytes++;\n+\t\t  byte = 0;\n+\t\t}\n+\n+\t      /* Number of bits we can process at once\n+\t\t (all part of the same byte).  */\n+\t      this_time = MIN (end_offset - next_offset,\n+\t\t\t       BITS_PER_UNIT - next_bit);\n+#if BYTES_BIG_ENDIAN\n+\t      /* On big-endian machine, take the most significant bits\n+\t\t first (of the bits that are significant)\n+\t\t and put them into bytes from the most significant end.  */\n+\t      shift = end_offset - next_offset - this_time;\n+\t      /* Don't try to take a bunch of bits that cross\n+\t\t the word boundary in the INTEGER_CST.  */\n+\t      if (shift < HOST_BITS_PER_INT\n+\t\t  && shift + this_time > HOST_BITS_PER_INT)\n+\t\t{\n+\t\t  this_time -= (HOST_BITS_PER_INT - shift);\n+\t\t  shift = HOST_BITS_PER_INT;\n+\t\t}\n+\n+\t      /* Now get the bits from the appropriate constant word.  */\n+\t      if (shift < HOST_BITS_PER_INT)\n+\t\t{\n+\t\t  value = TREE_INT_CST_LOW (val);\n+\t\t}\n+\t      else if (shift < 2 * HOST_BITS_PER_INT)\n+\t\t{\n+\t\t  value = TREE_INT_CST_HIGH (val);\n+\t\t  shift -= HOST_BITS_PER_INT;\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t      byte |= (((value >> shift) & ((1 << this_time) - 1))\n+\t\t       << (BITS_PER_UNIT - this_time - next_bit));\n+#else\n+\t      /* On little-endian machines,\n+\t\t take first the least significant bits of the value\n+\t\t and pack them starting at the least significant\n+\t\t bits of the bytes.  */\n+\t      shift = (next_offset\n+\t\t       - TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)));\n+\t      /* Don't try to take a bunch of bits that cross\n+\t\t the word boundary in the INTEGER_CST.  */\n+\t      if (shift < HOST_BITS_PER_INT\n+\t\t  && shift + this_time > HOST_BITS_PER_INT)\n+\t\t{\n+\t\t  this_time -= (HOST_BITS_PER_INT - shift);\n+\t\t  shift = HOST_BITS_PER_INT;\n+\t\t}\n+\n+\t      /* Now get the bits from the appropriate constant word.  */\n+\t      if (shift < HOST_BITS_PER_INT)\n+\t\tvalue = TREE_INT_CST_LOW (val);\n+\t      else if (shift < 2 * HOST_BITS_PER_INT)\n+\t\t{\n+\t\t  value = TREE_INT_CST_HIGH (val);\n+\t\t  shift -= HOST_BITS_PER_INT;\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t      byte |= ((value >> shift) & ((1 << this_time) - 1)) << next_bit;\n+#endif\n+\t      next_offset += this_time;\n+\t      byte_buffer_in_use = 1;\n+\t    }\n+\t}\n+    }\n+  if (byte_buffer_in_use)\n+    {\n+      ASM_OUTPUT_BYTE (asm_out_file, byte);\n+      total_bytes++;\n+    }\n+  if (total_bytes < size)\n+    assemble_zeros (size - total_bytes);\n+}"}]}