{"sha": "05058b6e31ec87bb08cb9457b22080afbd2c4723", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwNThiNmUzMWVjODdiYjA4Y2I5NDU3YjIyMDgwYWZiZDJjNDcyMw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-10-11T18:28:49Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-10-11T18:28:49Z"}, "message": "re PR target/50447 ([avr] Better support of AND, OR, XOR and PLUS with constant integers for 16- and 32-bit values)\n\n\tPR target/50447\n\t* config/avr/avr.md (cc): Add out_plus attribute alternative.\n\t(addsi3): Use it.  Adapt avr_out_plus to new prototype.  Use\n\tavr_out_plus for all CONST_INT addends.\n\t* config/avr/avr-protos.h (avr_out_plus): Change prototype.\n\t* config/avr/avr.c (notice_update_cc): Call avr_out_plus on\n\tCC_OUT_PLUS.\n\t(avr_out_plus_1): Change prototype and report effect on cc0.\n\t(avr_out_plus): Ditto.\n\t(adjust_insn_length): Adapt call to avr_out_plus to new prototype.\n\nFrom-SVN: r179816", "tree": {"sha": "014074a311e4c9e316bbded0457287a7e8b7df50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/014074a311e4c9e316bbded0457287a7e8b7df50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05058b6e31ec87bb08cb9457b22080afbd2c4723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05058b6e31ec87bb08cb9457b22080afbd2c4723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05058b6e31ec87bb08cb9457b22080afbd2c4723", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05058b6e31ec87bb08cb9457b22080afbd2c4723/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4474a3854f4fec4bfccad91706f95a6737e6a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4474a3854f4fec4bfccad91706f95a6737e6a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4474a3854f4fec4bfccad91706f95a6737e6a79"}], "stats": {"total": 120, "additions": 93, "deletions": 27}, "files": [{"sha": "2fabe682c149875e7419ba65384fd6e6a9d0f6dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05058b6e31ec87bb08cb9457b22080afbd2c4723", "patch": "@@ -1,3 +1,16 @@\n+2011-10-11  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50447\n+\t* config/avr/avr.md (cc): Add out_plus attribute alternative.\n+\t(addsi3): Use it.  Adapt avr_out_plus to new prototype.  Use\n+\tavr_out_plus for all CONST_INT addends.\n+\t* config/avr/avr-protos.h (avr_out_plus): Change prototype.\n+\t* config/avr/avr.c (notice_update_cc): Call avr_out_plus on\n+\tCC_OUT_PLUS.\n+\t(avr_out_plus_1): Change prototype and report effect on cc0.\n+\t(avr_out_plus): Ditto.\n+\t(adjust_insn_length): Adapt call to avr_out_plus to new prototype.\n+\n 2011-10-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (ix86_expand_special_args_builtin): Remove"}, {"sha": "06e412c96e53a5546324040281ff0cd3898f7a44", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=05058b6e31ec87bb08cb9457b22080afbd2c4723", "patch": "@@ -82,7 +82,7 @@ extern void avr_output_bld (rtx operands[], int bit_nr);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);\n extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n extern const char* avr_out_bitop (rtx, rtx*, int*);\n-extern const char* avr_out_plus (rtx*, int*);\n+extern const char* avr_out_plus (rtx*, int*, int*);\n extern const char* avr_out_addto_sp (rtx*, int*);\n extern bool avr_popcount_each_byte (rtx, int, int);\n "}, {"sha": "afc3d61851c46262d73bc546ad84f20156baffd3", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 65, "deletions": 11, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=05058b6e31ec87bb08cb9457b22080afbd2c4723", "patch": "@@ -1630,9 +1630,37 @@ void\n notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn)\n {\n   rtx set;\n+  enum attr_cc cc = get_attr_cc (insn);\n   \n-  switch (get_attr_cc (insn))\n+  switch (cc)\n     {\n+    default:\n+      break;\n+\n+    case CC_OUT_PLUS:\n+      {\n+        rtx *op = recog_data.operand;\n+        int len_dummy, icc;\n+        \n+        /* Extract insn's operands.  */\n+        extract_constrain_insn_cached (insn);\n+        \n+        avr_out_plus (op, &len_dummy, &icc);\n+        cc = (enum attr_cc) icc;\n+        \n+        break;\n+      }\n+    }\n+\n+  switch (cc)\n+    {\n+    default:\n+      /* Special values like CC_OUT_PLUS from above have been\n+         mapped to \"standard\" CC_* values so we never come here.  */\n+      \n+      gcc_unreachable();\n+      break;\n+      \n     case CC_NONE:\n       /* Insn does not affect CC at all.  */\n       break;\n@@ -4673,10 +4701,11 @@ lshrsi3_out (rtx insn, rtx operands[], int *len)\n    addition; otherwise, set *PLEN to the length of the instruction sequence (in\n    words) printed with PLEN == NULL.  XOP[3] is an 8-bit scratch register.\n    CODE == PLUS:  perform addition by using ADD instructions.\n-   CODE == MINUS: perform addition by using SUB instructions.  */\n+   CODE == MINUS: perform addition by using SUB instructions.\n+   Set *PCC to effect on cc0 according to respective CC_* insn attribute.  */\n \n static void\n-avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code)\n+avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n {\n   /* MODE of the operation.  */\n   enum machine_mode mode = GET_MODE (xop[0]);\n@@ -4700,6 +4729,10 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code)\n   /* Value to add.  There are two ways to add VAL: R += VAL and R -= -VAL.  */\n   rtx xval = xop[2];\n \n+  /* Addition does not set cc0 in a usable way.  */\n+  \n+  *pcc = (MINUS == code) ? CC_SET_CZN : CC_CLOBBER;\n+\n   if (MINUS == code)\n     xval = gen_int_mode (-UINTVAL (xval), mode);\n \n@@ -4722,6 +4755,11 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code)\n \n       op[0] = reg8;\n       op[1] = GEN_INT (val8);\n+\n+      /* To get usable cc0 no low-bytes must have been skipped.  */\n+      \n+      if (i && !started)\n+        *pcc = CC_CLOBBER;\n       \n       if (!started && i % 2 == 0\n           && test_hard_reg_class (ADDW_REGS, reg8))\n@@ -4794,6 +4832,11 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code)\n       started = true;\n \n     } /* for all sub-bytes */\n+\n+  /* No output doesn't change cc0.  */\n+  \n+  if (plen && *plen == 0)\n+    *pcc = CC_NONE;\n }\n \n \n@@ -4803,24 +4846,35 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code)\n \n    and return \"\".  If PLEN == NULL, print assembler instructions to perform the\n    addition; otherwise, set *PLEN to the length of the instruction sequence (in\n-   words) printed with PLEN == NULL.  */\n+   words) printed with PLEN == NULL.\n+   If PCC != 0 then set *PCC to the the instruction sequence's effect on the\n+   condition code (with respect to XOP[0]).  */\n \n const char*\n-avr_out_plus (rtx *xop, int *plen)\n+avr_out_plus (rtx *xop, int *plen, int *pcc)\n {\n   int len_plus, len_minus;\n+  int cc_plus, cc_minus, cc_dummy;\n \n+  if (!pcc)\n+    pcc = &cc_dummy;\n+                                   \n   /* Work out if  XOP[0] += XOP[2]  is better or  XOP[0] -= -XOP[2].  */\n   \n-  avr_out_plus_1 (xop, &len_plus, PLUS);\n-  avr_out_plus_1 (xop, &len_minus, MINUS);\n+  avr_out_plus_1 (xop, &len_plus, PLUS, &cc_plus);\n+  avr_out_plus_1 (xop, &len_minus, MINUS, &cc_minus);\n \n+  /* Prefer MINUS over PLUS if size is equal because it sets cc0.  */\n+  \n   if (plen)\n-    *plen = (len_minus <= len_plus) ? len_minus : len_plus;\n+    {\n+      *plen = (len_minus <= len_plus) ? len_minus : len_plus;\n+      *pcc  = (len_minus <= len_plus) ? cc_minus : cc_plus;\n+    }\n   else if (len_minus <= len_plus)\n-    avr_out_plus_1 (xop, NULL, MINUS);\n+    avr_out_plus_1 (xop, NULL, MINUS, pcc);\n   else\n-    avr_out_plus_1 (xop, NULL, PLUS);\n+    avr_out_plus_1 (xop, NULL, PLUS, pcc);\n \n   return \"\";\n }\n@@ -5209,7 +5263,7 @@ adjust_insn_length (rtx insn, int len)\n       \n     case ADJUST_LEN_OUT_BITOP: avr_out_bitop (insn, op, &len); break;\n       \n-    case ADJUST_LEN_OUT_PLUS: avr_out_plus (op, &len); break;\n+    case ADJUST_LEN_OUT_PLUS: avr_out_plus (op, &len, NULL); break;\n \n     case ADJUST_LEN_ADDTO_SP: avr_out_addto_sp (op, &len); break;\n       "}, {"sha": "b7fe77040d27c589b7ad27f06840ecb2704093aa", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05058b6e31ec87bb08cb9457b22080afbd2c4723/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=05058b6e31ec87bb08cb9457b22080afbd2c4723", "patch": "@@ -77,7 +77,8 @@\n (include \"constraints.md\")\n   \n ;; Condition code settings.\n-(define_attr \"cc\" \"none,set_czn,set_zn,set_n,compare,clobber\"\n+(define_attr \"cc\" \"none,set_czn,set_zn,set_n,compare,clobber,\n+                   out_plus\"\n   (const_string \"none\"))\n \n (define_attr \"type\" \"branch,branch1,arith,xcall\"\n@@ -786,30 +787,28 @@\n    (set_attr \"cc\" \"set_n,set_czn,set_czn,set_czn,set_n,set_n\")])\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"          \"=r,!w,!w,d,l,l ,d,r\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0 ,0 ,0,0,0 ,0,0\")\n-                 (match_operand:SI 2 \"nonmemory_operand\" \"r,I ,J ,s,P,N ,n,n\")))\n-   (clobber (match_scratch:QI 3                         \"=X,X ,X ,X,X,X ,X,&d\"))]\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,d ,d,r\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0 ,0,0\")\n+                 (match_operand:SI 2 \"nonmemory_operand\" \"r,s ,n,n\")))\n+   (clobber (match_scratch:QI 3                         \"=X,X ,X,&d\"))]\n   \"\"\n   {\n     static const char * const asm_code[] =\n       {\n         \"add %A0,%A2\\;adc %B0,%B2\\;adc %C0,%C2\\;adc %D0,%D2\",\n-        \"adiw %0,%2\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\",\n-        \"sbiw %0,%n2\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\",\n         \"subi %0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\\;sbci %C0,hlo8(-(%2))\\;sbci %D0,hhi8(-(%2))\",\n-        \"sec\\;adc %A0,__zero_reg__\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\",\n-        \"sec\\;sbc %A0,__zero_reg__\\;sbc %B0,__zero_reg__\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\"\n+        \"\",\n+        \"\"\n       };\n \n-    if (which_alternative >= (signed) (sizeof (asm_code) / sizeof (*asm_code)))\n-      return avr_out_plus (operands, NULL);\n+    if (*asm_code[which_alternative])\n+      return asm_code [which_alternative];\n \n-    return asm_code [which_alternative];\n+    return avr_out_plus (operands, NULL, NULL);\n   }\n-  [(set_attr \"length\" \"4,3,3,4,5,5,8,8\")\n-   (set_attr \"adjust_len\" \"*,*,*,*,*,*,out_plus,out_plus\")\n-   (set_attr \"cc\" \"set_n,set_n,set_czn,set_czn,set_n,set_n,clobber,clobber\")])\n+  [(set_attr \"length\" \"4,4,4,8\")\n+   (set_attr \"adjust_len\" \"*,*,out_plus,out_plus\")\n+   (set_attr \"cc\" \"set_n,set_czn,out_plus,out_plus\")])\n \n (define_insn \"*addsi3_zero_extend\"\n   [(set (match_operand:SI 0 \"register_operand\"                         \"=r\")"}]}