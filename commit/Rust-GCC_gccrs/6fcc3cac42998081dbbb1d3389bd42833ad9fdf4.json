{"sha": "6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZjYzNjYWM0Mjk5ODA4MWRiYmIxZDMzODliZDQyODMzYWQ5ZmRmNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-12T20:38:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-12T20:38:04Z"}, "message": "openmp: Implement allocate clause in omp lowering.\n\nFor now, task/taskloop constructs aren't handled and C/C++ array reductions\nand reductions with task or inscan modifiers need further work.\nInstead of calling omp_alloc/omp_free (where the former doesn't have\nalignment argument and omp_aligned_alloc is 5.1 only feature), this calls\nGOMP_alloc/GOMP_free, so that the library can fail if it would fall back\ninto NULL (exception is zero length allocations).\n\n2020-11-12  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* builtin-types.def (BT_FN_PTR_SIZE_SIZE_PTRMODE): New function type.\n\t* omp-builtins.def (BUILT_IN_GOACC_DECLARE): Move earlier.\n\t(BUILT_IN_GOMP_ALLOC, BUILT_IN_GOMP_FREE): New builtins.\n\t* gimplify.c (gimplify_scan_omp_clauses): Force allocator into a\n\tdecl if it is not NULL, INTEGER_CST or decl.\n\t(gimplify_adjust_omp_clauses): Clear GOVD_EXPLICIT on explicit clauses\n\twhich are being removed.  Remove allocate clauses for variables not seen\n\tif they are private, firstprivate or linear too.  Call\n\tomp_notice_variable on the allocator otherwise.\n\t(gimplify_omp_for): Handle iterator vars mentioned in allocate clauses\n\tsimilarly to non-is_gimple_reg iterators.\n\t* omp-low.c (struct omp_context): Add allocate_map field.\n\t(delete_omp_context): Delete it.\n\t(scan_sharing_clauses): Fill it from allocate clauses.  Remove it\n\tif mentioned also in shared clause.\n\t(lower_private_allocate): New function.\n\t(lower_rec_input_clauses): Handle allocate clause for privatized\n\tvariables, except for task/taskloop, C/C++ array reductions for now\n\tand task/inscan variables.\n\t(lower_send_shared_vars): Don't consider variables in allocate_map\n\tas shared.\n\t* omp-expand.c (expand_omp_for_generic, expand_omp_for_static_nochunk,\n\texpand_omp_for_static_chunk): Use expand_omp_build_assign instead of\n\tgimple_build_assign + gsi_insert_after.\n\t* builtins.c (builtin_fnspec): Handle BUILTIN_GOMP_ALLOC and\n\tBUILTIN_GOMP_FREE.\n\t* tree-ssa-ccp.c (evaluate_stmt): Handle BUILTIN_GOMP_ALLOC.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Handle\n\tBUILTIN_GOMP_ALLOC.\n\t(mark_all_reaching_defs_necessary_1): Handle BUILTIN_GOMP_ALLOC\n\tand BUILTIN_GOMP_FREE.\n\t(propagate_necessity): Likewise.\ngcc/fortran/\n\t* f95-lang.c (ATTR_ALLOC_WARN_UNUSED_RESULT_SIZE_2_NOTHROW_LIST):\n\tDefine.\n\t(gfc_init_builtin_functions): Add alloc_size and warn_unused_result\n\tattributes to __builtin_GOMP_alloc.\n\t* types.def (BT_PTRMODE): New primitive type.\n\t(BT_FN_VOID_PTR_PTRMODE, BT_FN_PTR_SIZE_SIZE_PTRMODE): New function\n\ttypes.\nlibgomp/\n\t* libgomp.map (GOMP_alloc, GOMP_free): Export at GOMP_5.0.1.\n\t* omp.h.in (omp_alloc): Add malloc and alloc_size attributes.\n\t* libgomp_g.h (GOMP_alloc, GOMP_free): Declare.\n\t* allocator.c (omp_aligned_alloc): New for now static function,\n\tadd alignment argument and handle it.\n\t(omp_alloc): Reimplement using omp_aligned_alloc.\n\t(GOMP_alloc, GOMP_free): New functions.\n\t(omp_free): Add ialias.\n\t* testsuite/libgomp.c-c++-common/allocate-1.c: New test.\n\t* testsuite/libgomp.c++/allocate-1.C: New test.", "tree": {"sha": "47f7063a9e3e929251e4859ae718688b08cbfceb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f7063a9e3e929251e4859ae718688b08cbfceb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9106c51e57c06e88a0dddf994fb5432b4bbe68c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9106c51e57c06e88a0dddf994fb5432b4bbe68c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9106c51e57c06e88a0dddf994fb5432b4bbe68c0"}], "stats": {"total": 792, "additions": 739, "deletions": 53}, "files": [{"sha": "4a82ee421bef42154ccd88e52f7a19f48b340c73", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -637,6 +637,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_SIZE_SIZE_PTR, BT_VOID, BT_SIZE, BT_SIZE,\n DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_PTR_PTR, BT_UINT, BT_UINT, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_CONST_SIZE_BOOL,\n \t\t     BT_PTR, BT_PTR, BT_CONST_SIZE, BT_BOOL)\n+DEF_FUNCTION_TYPE_3 (BT_FN_PTR_SIZE_SIZE_PTRMODE,\n+\t\t     BT_PTR, BT_SIZE, BT_SIZE, BT_PTRMODE)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)"}, {"sha": "42c52a1925ec1a6c012ee0f7d4eb08f341345aea", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -13023,6 +13023,7 @@ builtin_fnspec (tree callee)\n       case BUILT_IN_MALLOC:\n       case BUILT_IN_ALIGNED_ALLOC:\n       case BUILT_IN_CALLOC:\n+      case BUILT_IN_GOMP_ALLOC:\n \treturn \"mC\";\n       CASE_BUILT_IN_ALLOCA:\n \treturn \"mc\";\n@@ -13044,6 +13045,7 @@ builtin_fnspec (tree callee)\n \t across it.  */\n       case BUILT_IN_STACK_RESTORE:\n       case BUILT_IN_FREE:\n+      case BUILT_IN_GOMP_FREE:\n \treturn \".co \";\n       case BUILT_IN_VA_END:\n \treturn \".cO \";"}, {"sha": "1a05144ac5682e2fa0517bdcf796cd2a8849855e", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -531,7 +531,7 @@ gfc_builtin_function (tree decl)\n   return decl;\n }\n \n-/* So far we need just these 7 attribute types.  */\n+/* So far we need just these 8 attribute types.  */\n #define ATTR_NULL\t\t\t0\n #define ATTR_LEAF_LIST\t\t\t(ECF_LEAF)\n #define ATTR_NOTHROW_LEAF_LIST\t\t(ECF_NOTHROW | ECF_LEAF)\n@@ -540,6 +540,8 @@ gfc_builtin_function (tree decl)\n #define ATTR_PURE_NOTHROW_LEAF_LIST\t(ECF_NOTHROW | ECF_LEAF | ECF_PURE)\n #define ATTR_NOTHROW_LIST\t\t(ECF_NOTHROW)\n #define ATTR_CONST_NOTHROW_LIST\t\t(ECF_NOTHROW | ECF_CONST)\n+#define ATTR_ALLOC_WARN_UNUSED_RESULT_SIZE_2_NOTHROW_LIST \\\n+\t\t\t\t\t(ECF_NOTHROW)\n \n static void\n gfc_define_builtin (const char *name, tree type, enum built_in_function code,\n@@ -1236,6 +1238,13 @@ gfc_init_builtin_functions (void)\n #undef DEF_GOACC_BUILTIN\n #undef DEF_GOACC_BUILTIN_COMPILER\n #undef DEF_GOMP_BUILTIN\n+      tree gomp_alloc = builtin_decl_explicit (BUILT_IN_GOMP_ALLOC);\n+      tree two = build_int_cst (integer_type_node, 2);\n+      DECL_ATTRIBUTES (gomp_alloc)\n+\t= tree_cons (get_identifier (\"warn_unused_result\"), NULL_TREE,\n+\t\t     tree_cons (get_identifier (\"alloc_size\"),\n+\t\t\t\tbuild_tree_list (NULL_TREE, two),\n+\t\t\t\tDECL_ATTRIBUTES (gomp_alloc)));\n     }\n \n   gfc_define_builtin (\"__builtin_trap\", builtin_types[BT_FN_VOID],"}, {"sha": "5736bbab6017a27d538078378ef298980789cea7", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -70,6 +70,7 @@ DEF_PRIMITIVE_TYPE (BT_CONST_VOLATILE_PTR,\n \t\t    build_pointer_type\n \t\t     (build_qualified_type (void_type_node,\n \t\t\t\t\t  TYPE_QUAL_VOLATILE|TYPE_QUAL_CONST)))\n+DEF_PRIMITIVE_TYPE (BT_PTRMODE, (*lang_hooks.types.type_for_mode)(ptr_mode, 0))\n DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n DEF_POINTER_TYPE (BT_PTR_ULONGLONG, BT_ULONGLONG)\n DEF_POINTER_TYPE (BT_PTR_PTR, BT_PTR)\n@@ -117,6 +118,8 @@ DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_INT_BOOL, BT_BOOL, BT_INT, BT_BOOL)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_UINT, BT_VOID, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTRMODE,\n+\t\t     BT_VOID, BT_PTR, BT_PTRMODE)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -149,6 +152,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16,\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_SIZE_SIZE_PTR, BT_VOID, BT_SIZE, BT_SIZE,\n \t\t     BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_PTR_PTR, BT_UINT, BT_UINT, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_PTR_SIZE_SIZE_PTRMODE,\n+\t\t     BT_PTR, BT_SIZE, BT_SIZE, BT_PTRMODE)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)"}, {"sha": "b861e17d8aead9dce8f782b93383c0cb6932b224", "filename": "gcc/gimplify.c", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -9904,10 +9904,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      remove = true;\n \t      break;\n \t    }\n+\t  else if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) == NULL_TREE\n+\t\t   || (TREE_CODE (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c))\n+\t\t       == INTEGER_CST))\n+\t    ;\n \t  else if (code == OMP_TASKLOOP\n-\t\t   && OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n-\t\t   && (TREE_CODE (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c))\n-\t\t       != INTEGER_CST))\n+\t\t   || !DECL_P (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)))\n \t    OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n \t      = get_initialized_tmp_var (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c),\n \t\t\t\t\t pre_p, NULL, false);\n@@ -10475,6 +10477,8 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t\t       && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n \t\tomp_mark_stores (gimplify_omp_ctxp->outer_context, decl);\n \t    }\n+\t  else\n+\t    n->value &= ~GOVD_EXPLICIT;\n \t  break;\n \n \tcase OMP_CLAUSE_LASTPRIVATE:\n@@ -10774,6 +10778,41 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t      && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n \t    omp_mark_stores (gimplify_omp_ctxp->outer_context, decl);\n \t  break;\n+\n+\tcase OMP_CLAUSE_ALLOCATE:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t  if (n != NULL && !(n->value & GOVD_SEEN))\n+\t    {\n+\t      if ((n->value & (GOVD_PRIVATE | GOVD_FIRSTPRIVATE | GOVD_LINEAR))\n+\t\t  != 0\n+\t\t  && (n->value & (GOVD_REDUCTION | GOVD_LASTPRIVATE)) == 0)\n+\t\tremove = true;\n+\t    }\n+\t  if (!remove\n+\t      && OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n+\t      && TREE_CODE (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)) != INTEGER_CST\n+\t      && ((ctx->region_type & (ORT_PARALLEL | ORT_TARGET)) != 0\n+\t\t  || (ctx->region_type & ORT_TASKLOOP) == ORT_TASK\n+\t\t  || (ctx->region_type & ORT_HOST_TEAMS) == ORT_HOST_TEAMS))\n+\t    {\n+\t      tree allocator = OMP_CLAUSE_ALLOCATE_ALLOCATOR (c);\n+\t      n = splay_tree_lookup (ctx->variables, (splay_tree_key) allocator);\n+\t      if (n == NULL)\n+\t\t{\n+\t\t  enum omp_clause_default_kind default_kind\n+\t\t    = ctx->default_kind;\n+\t\t  ctx->default_kind = OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;\n+\t\t  omp_notice_variable (ctx, OMP_CLAUSE_ALLOCATE_ALLOCATOR (c),\n+\t\t\t\t       true);\n+\t\t  ctx->default_kind = default_kind;\n+\t\t}\n+\t      else\n+\t\tomp_notice_variable (ctx, OMP_CLAUSE_ALLOCATE_ALLOCATOR (c),\n+\t\t\t\t     true);\n+\t    }\n+\t  break;\n+\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_IF:\n@@ -10823,7 +10862,6 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_FINALIZE:\n \tcase OMP_CLAUSE_INCLUSIVE:\n \tcase OMP_CLAUSE_EXCLUSIVE:\n-\tcase OMP_CLAUSE_ALLOCATE:\n \t  break;\n \n \tdefault:\n@@ -11623,6 +11661,15 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   c = omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_TILE);\n   if (c)\n     tile = list_length (OMP_CLAUSE_TILE_LIST (c));\n+  c = omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_ALLOCATE);\n+  hash_set<tree> *allocate_uids = NULL;\n+  if (c)\n+    {\n+      allocate_uids = new hash_set<tree>;\n+      for (; c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ALLOCATE)\n+\t  allocate_uids->add (OMP_CLAUSE_DECL (c));\n+    }\n   for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n     {\n       t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n@@ -11949,12 +11996,13 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t as an iteration counter.  This is valid, since DECL cannot be\n \t modified in the body of the loop.  Similarly for any iteration vars\n \t in simd with collapse > 1 where the iterator vars must be\n-\t lastprivate.  */\n+\t lastprivate.  And similarly for vars mentioned in allocate clauses.  */\n       if (orig_for_stmt != for_stmt)\n \tvar = decl;\n       else if (!is_gimple_reg (decl)\n \t       || (ort == ORT_SIMD\n-\t\t   && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1))\n+\t\t   && TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1)\n+\t       || (allocate_uids && allocate_uids->contains (decl)))\n \t{\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n \t  /* Make sure omp_add_variable is not called on it prematurely.\n@@ -12181,6 +12229,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     }\n \n   BITMAP_FREE (has_decl_expr);\n+  delete allocate_uids;\n \n   if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP\n       || (loop_p && orig_for_stmt == for_stmt))"}, {"sha": "f9b78ed812fd933b0a4a99b06cdd10ee910ee4e9", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -47,6 +47,8 @@ DEF_GOACC_BUILTIN (BUILT_IN_GOACC_UPDATE, \"GOACC_update\",\n DEF_GOACC_BUILTIN (BUILT_IN_GOACC_WAIT, \"GOACC_wait\",\n \t\t   BT_FN_VOID_INT_INT_VAR,\n \t\t   ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_DECLARE, \"GOACC_declare\",\n+\t\t   BT_FN_VOID_INT_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n \n DEF_GOACC_BUILTIN_COMPILER (BUILT_IN_ACC_ON_DEVICE, \"acc_on_device\",\n \t\t\t    BT_FN_INT_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -444,5 +446,8 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK_REDUCTION_REMAP,\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_WORKSHARE_TASK_REDUCTION_UNREGISTER,\n \t\t  \"GOMP_workshare_task_reduction_unregister\",\n \t\t  BT_FN_VOID_BOOL, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOACC_BUILTIN (BUILT_IN_GOACC_DECLARE, \"GOACC_declare\",\n-\t\t   BT_FN_VOID_INT_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ALLOC,\n+\t\t  \"GOMP_alloc\", BT_FN_PTR_SIZE_SIZE_PTRMODE,\n+\t\t  ATTR_ALLOC_WARN_UNUSED_RESULT_SIZE_2_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_FREE,\n+\t\t  \"GOMP_free\", BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)"}, {"sha": "ddca3d33bdd3fbadcb7af9308a9a2dddf3de7343", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -4255,8 +4255,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\t   : POINTER_PLUS_EXPR, TREE_TYPE (t), v, a);\n \t  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n-\t  assign_stmt = gimple_build_assign (dest, t);\n-\t  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+\t  expand_omp_build_assign (&gsi, dest, t, true);\n \t}\n   if (fd->collapse > 1)\n     expand_omp_for_init_vars (fd, &gsi, counts, NULL, inner_stmt, startvar);\n@@ -5250,8 +5249,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t   : POINTER_PLUS_EXPR, TREE_TYPE (t), t, a);\n \t  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n-\t  assign_stmt = gimple_build_assign (dest, t);\n-\t  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+\t  expand_omp_build_assign (&gsi, dest, t, true);\n \t}\n   if (fd->collapse > 1)\n     {\n@@ -5974,8 +5972,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t\t\t   : POINTER_PLUS_EXPR, TREE_TYPE (t), v, a);\n \t  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n-\t  assign_stmt = gimple_build_assign (dest, t);\n-\t  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+\t  expand_omp_build_assign (&gsi, dest, t, true);\n \t}\n   if (fd->collapse > 1)\n     expand_omp_for_init_vars (fd, &gsi, counts, NULL, inner_stmt, startvar);"}, {"sha": "ed805e2e6d2af97b28eb9c9d82dc2a03775641a9", "filename": "gcc/omp-low.c", "status": "modified", "additions": 135, "deletions": 13, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -126,6 +126,10 @@ struct omp_context\n      corresponding tracking loop iteration variables.  */\n   hash_map<tree, tree> *lastprivate_conditional_map;\n \n+  /* And a hash map from the allocate variables to their corresponding\n+     allocators.  */\n+  hash_map<tree, tree> *allocate_map;\n+\n   /* A tree_list of the reduction clauses in this context. This is\n     only used for checking the consistency of OpenACC reduction\n     clauses in scan_omp_for and is not guaranteed to contain a valid\n@@ -1043,6 +1047,7 @@ delete_omp_context (splay_tree_value value)\n     }\n \n   delete ctx->lastprivate_conditional_map;\n+  delete ctx->allocate_map;\n \n   XDELETE (ctx);\n }\n@@ -1114,6 +1119,22 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n   tree c, decl;\n   bool scan_array_reductions = false;\n \n+  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ALLOCATE\n+\t&& (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) == NULL_TREE\n+\t    /* omp_default_mem_alloc is 1 */\n+\t    || !integer_onep (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c))))\n+      {\n+\tif (is_task_ctx (ctx))\n+\t  continue; /* For now.  */\n+\tif (ctx->allocate_map == NULL)\n+\t  ctx->allocate_map = new hash_map<tree, tree>;\n+\tctx->allocate_map->put (OMP_CLAUSE_DECL (c),\n+\t\t\t\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n+\t\t\t\t? OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n+\t\t\t\t: integer_zero_node);\n+      }\n+\n   for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n     {\n       bool by_ref;\n@@ -1130,6 +1151,8 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \n \tcase OMP_CLAUSE_SHARED:\n \t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (ctx->allocate_map && ctx->allocate_map->get (decl))\n+\t    ctx->allocate_map->remove (decl);\n \t  /* Ignore shared directives in teams construct inside of\n \t     target construct.  */\n \t  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS\n@@ -4358,6 +4381,68 @@ task_reduction_read (gimple_seq *ilist, tree tskred_temp, tree type,\n   return v;\n }\n \n+/* Lower early initialization of privatized variable NEW_VAR\n+   if it needs an allocator (has allocate clause).  */\n+\n+static bool\n+lower_private_allocate (tree var, tree new_var, tree &allocator,\n+\t\t\ttree &allocate_ptr, gimple_seq *ilist,\n+\t\t\tomp_context *ctx, bool is_ref, tree size)\n+{\n+  if (allocator)\n+    return false;\n+  gcc_assert (allocate_ptr == NULL_TREE);\n+  if (ctx->allocate_map && DECL_P (new_var))\n+    if (tree *allocatorp = ctx->allocate_map->get (var))\n+      allocator = *allocatorp;\n+  if (allocator == NULL_TREE)\n+    return false;\n+  if (!is_ref && omp_is_reference (var))\n+    return false;\n+\n+  if (TREE_CODE (allocator) != INTEGER_CST)\n+    allocator = build_outer_var_ref (allocator, ctx);\n+  allocator = fold_convert (pointer_sized_int_node, allocator);\n+  if (TREE_CODE (allocator) != INTEGER_CST)\n+    {\n+      tree var = create_tmp_var (TREE_TYPE (allocator));\n+      gimplify_assign (var, allocator, ilist);\n+      allocator = var;\n+    }\n+\n+  tree ptr_type, align, sz;\n+  if (is_ref)\n+    {\n+      ptr_type = build_pointer_type (TREE_TYPE (TREE_TYPE (new_var)));\n+      align = build_int_cst (size_type_node,\n+\t\t\t     TYPE_ALIGN_UNIT (TREE_TYPE (ptr_type)));\n+      sz = size;\n+    }\n+  else\n+    {\n+      ptr_type = build_pointer_type (TREE_TYPE (new_var));\n+      align = build_int_cst (size_type_node, DECL_ALIGN_UNIT (new_var));\n+      sz = fold_convert (size_type_node, DECL_SIZE_UNIT (new_var));\n+    }\n+  if (TREE_CODE (sz) != INTEGER_CST)\n+    {\n+      tree szvar = create_tmp_var (size_type_node);\n+      gimplify_assign (szvar, sz, ilist);\n+      sz = szvar;\n+    }\n+  allocate_ptr = create_tmp_var (ptr_type);\n+  tree a = builtin_decl_explicit (BUILT_IN_GOMP_ALLOC);\n+  gimple *g = gimple_build_call (a, 3, align, sz, allocator);\n+  gimple_call_set_lhs (g, allocate_ptr);\n+  gimple_seq_add_stmt (ilist, g);\n+  if (!is_ref)\n+    {\n+      SET_DECL_VALUE_EXPR (new_var, build_simple_mem_ref (allocate_ptr));\n+      DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n+    }\n+  return true;\n+}\n+\n /* Generate code to implement the input clauses, FIRSTPRIVATE and COPYIN,\n    from the receiver (aka child) side and initializers for REFERENCE_TYPE\n    private variables.  Initialization statements go in ILIST, while calls\n@@ -4523,6 +4608,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  bool task_reduction_p = false;\n \t  bool task_reduction_needs_orig_p = false;\n \t  tree cond = NULL_TREE;\n+\t  tree allocator, allocate_ptr;\n \n \t  switch (c_kind)\n \t    {\n@@ -4659,6 +4745,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  if (task_reduction_p != (pass >= 2))\n \t    continue;\n \n+\t  allocator = NULL_TREE;\n+\t  allocate_ptr = NULL_TREE;\n \t  new_var = var = OMP_CLAUSE_DECL (c);\n \t  if ((c_kind == OMP_CLAUSE_REDUCTION\n \t       || c_kind == OMP_CLAUSE_IN_REDUCTION)\n@@ -5195,25 +5283,33 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t      if (c_kind != OMP_CLAUSE_FIRSTPRIVATE || !is_task_ctx (ctx))\n \t\t{\n-\t\t  gcall *stmt;\n-\t\t  tree tmp, atmp;\n+\t\t  tree tmp;\n \n \t\t  ptr = DECL_VALUE_EXPR (new_var);\n \t\t  gcc_assert (TREE_CODE (ptr) == INDIRECT_REF);\n \t\t  ptr = TREE_OPERAND (ptr, 0);\n \t\t  gcc_assert (DECL_P (ptr));\n \t\t  x = TYPE_SIZE_UNIT (TREE_TYPE (new_var));\n \n-\t\t  /* void *tmp = __builtin_alloca */\n-\t\t  atmp = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n-\t\t  stmt = gimple_build_call (atmp, 2, x,\n-\t\t\t\t\t    size_int (DECL_ALIGN (var)));\n-\t\t  cfun->calls_alloca = 1;\n-\t\t  tmp = create_tmp_var_raw (ptr_type_node);\n-\t\t  gimple_add_tmp_var (tmp);\n-\t\t  gimple_call_set_lhs (stmt, tmp);\n-\n-\t\t  gimple_seq_add_stmt (ilist, stmt);\n+\t\t  if (lower_private_allocate (var, new_var, allocator,\n+\t\t\t\t\t      allocate_ptr, ilist, ctx,\n+\t\t\t\t\t      false, x))\n+\t\t    tmp = allocate_ptr;\n+\t\t  else\n+\t\t    {\n+\t\t      /* void *tmp = __builtin_alloca */\n+\t\t      tree atmp\n+\t\t\t= builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n+\t\t      gcall *stmt\n+\t\t\t= gimple_build_call (atmp, 2, x,\n+\t\t\t\t\t     size_int (DECL_ALIGN (var)));\n+\t\t      cfun->calls_alloca = 1;\n+\t\t      tmp = create_tmp_var_raw (ptr_type_node);\n+\t\t      gimple_add_tmp_var (tmp);\n+\t\t      gimple_call_set_lhs (stmt, tmp);\n+\n+\t\t      gimple_seq_add_stmt (ilist, stmt);\n+\t\t    }\n \n \t\t  x = fold_convert_loc (clause_loc, TREE_TYPE (ptr), tmp);\n \t\t  gimplify_assign (ptr, x, ilist);\n@@ -5237,6 +5333,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  x = build_receiver_ref (var, false, ctx);\n \t\t  x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t}\n+\t      else if (lower_private_allocate (var, new_var, allocator,\n+\t\t\t\t\t       allocate_ptr,\n+\t\t\t\t\t       ilist, ctx, true, x))\n+\t\tx = allocate_ptr;\n \t      else if (TREE_CONSTANT (x))\n \t\t{\n \t\t  /* For reduction in SIMD loop, defer adding the\n@@ -5349,6 +5449,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      tree nx;\n \t      bool copy_ctor;\n \t      copy_ctor = false;\n+\t      lower_private_allocate (var, new_var, allocator, allocate_ptr,\n+\t\t\t\t      ilist, ctx, false, NULL_TREE);\n \t      nx = unshare_expr (new_var);\n \t      if (is_simd\n \t\t  && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n@@ -5494,6 +5596,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      x = lang_hooks.decls.omp_clause_dtor (c, new_var);\n \t      if (x)\n \t\tgimplify_and_add (x, dlist);\n+\t      if (allocator)\n+\t\t{\n+\t\t  tree f = builtin_decl_explicit (BUILT_IN_GOMP_FREE);\n+\t\t  gimple *g\n+\t\t    = gimple_build_call (f, 2, allocate_ptr, allocator);\n+\t\t  gimple_seq_add_stmt (dlist, g);\n+\t\t}\n \t      break;\n \n \t    case OMP_CLAUSE_LINEAR:\n@@ -5535,6 +5644,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  goto do_dtor;\n \t\t}\n \t    do_firstprivate:\n+\t      lower_private_allocate (var, new_var, allocator, allocate_ptr,\n+\t\t\t\t      ilist, ctx, false, NULL_TREE);\n \t      x = build_outer_var_ref (var, ctx);\n \t      if (is_simd)\n \t\t{\n@@ -5722,6 +5833,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    }\n \t\t  else\n \t\t    {\n+\t\t      lower_private_allocate (var, new_var, allocator,\n+\t\t\t\t\t      allocate_ptr, ilist, ctx, false,\n+\t\t\t\t\t      NULL_TREE);\n \t\t      x = build_outer_var_ref (var, ctx);\n \n \t\t      if (omp_is_reference (var)\n@@ -6118,6 +6232,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    }\n \t\t  else\n \t\t    {\n+\t\t      lower_private_allocate (var, new_var, allocator,\n+\t\t\t\t\t      allocate_ptr, ilist, ctx,\n+\t\t\t\t\t      false, NULL_TREE);\n \t\t      if (omp_is_reference (var) && is_simd)\n \t\t\thandle_simd_reference (clause_loc, new_vard, ilist);\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n@@ -6132,6 +6249,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t  ref = build_outer_var_ref (var, ctx);\n \t\t\t  gimplify_assign (ref, x, dlist);\n \t\t\t}\n+\t\t      if (allocator)\n+\t\t\tgoto do_dtor;\n \t\t    }\n \t\t}\n \t      break;\n@@ -7488,7 +7607,10 @@ lower_send_shared_vars (gimple_seq *ilist, gimple_seq *olist, omp_context *ctx)\n \tcontinue;\n \n       nvar = maybe_lookup_decl (ovar, ctx);\n-      if (!nvar || !DECL_HAS_VALUE_EXPR_P (nvar))\n+      if (!nvar\n+\t  || !DECL_HAS_VALUE_EXPR_P (nvar)\n+\t  || (ctx->allocate_map\n+\t      && ctx->allocate_map->get (ovar)))\n \tcontinue;\n \n       /* If CTX is a nested parallel directive.  Find the immediately"}, {"sha": "9a2ff6227b4627ecce05560c54ff070ad3d01e47", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -1972,6 +1972,7 @@ evaluate_stmt (gimple *stmt)\n \t      break;\n \n \t    case BUILT_IN_ALIGNED_ALLOC:\n+\t    case BUILT_IN_GOMP_ALLOC:\n \t      {\n \t\ttree align = get_constant_value (gimple_call_arg (stmt, 0));\n \t\tif (align"}, {"sha": "9fb156c120d937f0fd43fbf5ff4192cda6f55e8f", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -239,6 +239,7 @@ mark_stmt_if_obviously_necessary (gimple *stmt, bool aggressive)\n \t    CASE_BUILT_IN_ALLOCA:\n \t    case BUILT_IN_STRDUP:\n \t    case BUILT_IN_STRNDUP:\n+\t    case BUILT_IN_GOMP_ALLOC:\n \t      return;\n \n \t    default:;\n@@ -605,6 +606,8 @@ mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n \t  case BUILT_IN_CALLOC:\n \t  CASE_BUILT_IN_ALLOCA:\n \t  case BUILT_IN_FREE:\n+\t  case BUILT_IN_GOMP_ALLOC:\n+\t  case BUILT_IN_GOMP_FREE:\n \t    return false;\n \n \t  default:;\n@@ -879,7 +882,8 @@ propagate_necessity (bool aggressive)\n \t       && gimple_call_from_new_or_delete (as_a <gcall *> (stmt))\n \t       && gimple_call_operator_delete_p (as_a <gcall *> (stmt)));\n \t  if (is_delete_operator\n-\t      || gimple_call_builtin_p (stmt, BUILT_IN_FREE))\n+\t      || gimple_call_builtin_p (stmt, BUILT_IN_FREE)\n+\t      || gimple_call_builtin_p (stmt, BUILT_IN_GOMP_FREE))\n \t    {\n \t      tree ptr = gimple_call_arg (stmt, 0);\n \t      gcall *def_stmt;\n@@ -892,27 +896,26 @@ propagate_necessity (bool aggressive)\n \t\t  && ((DECL_BUILT_IN_CLASS (def_callee) == BUILT_IN_NORMAL\n \t\t       && (DECL_FUNCTION_CODE (def_callee) == BUILT_IN_ALIGNED_ALLOC\n \t\t\t   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_MALLOC\n-\t\t\t   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC))\n+\t\t\t   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC\n+\t\t\t   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_GOMP_ALLOC))\n \t\t      || (DECL_IS_REPLACEABLE_OPERATOR_NEW_P (def_callee)\n \t\t\t  && gimple_call_from_new_or_delete (def_stmt))))\n \t\t{\n-\t\t  if (is_delete_operator)\n-\t\t    {\n-\t\t      if (!valid_new_delete_pair_p (def_stmt, stmt))\n-\t\t\tmark_operand_necessary (gimple_call_arg (stmt, 0));\n-\n-\t\t      /* Delete operators can have alignment and (or) size\n-\t\t\t as next arguments.  When being a SSA_NAME, they\n-\t\t\t must be marked as necessary.  */\n-\t\t      if (gimple_call_num_args (stmt) >= 2)\n-\t\t\tfor (unsigned i = 1; i < gimple_call_num_args (stmt);\n-\t\t\t     i++)\n-\t\t\t  {\n-\t\t\t    tree arg = gimple_call_arg (stmt, i);\n-\t\t\t    if (TREE_CODE (arg) == SSA_NAME)\n-\t\t\t      mark_operand_necessary (arg);\n-\t\t\t  }\n-\t\t    }\n+\t\t  if (is_delete_operator\n+\t\t      && !valid_new_delete_pair_p (def_stmt, stmt))\n+\t\t    mark_operand_necessary (gimple_call_arg (stmt, 0));\n+\n+\t\t  /* Delete operators can have alignment and (or) size\n+\t\t     as next arguments.  When being a SSA_NAME, they\n+\t\t     must be marked as necessary.  Similarly GOMP_free.  */\n+\t\t  if (gimple_call_num_args (stmt) >= 2)\n+\t\t    for (unsigned i = 1; i < gimple_call_num_args (stmt);\n+\t\t\t i++)\n+\t\t      {\n+\t\t\ttree arg = gimple_call_arg (stmt, i);\n+\t\t\tif (TREE_CODE (arg) == SSA_NAME)\n+\t\t\t  mark_operand_necessary (arg);\n+\t\t      }\n \n \t\t  continue;\n \t\t}"}, {"sha": "279073309a0c6dd7629954b3b0a190f5f52e4a06", "filename": "libgomp/allocator.c", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Fallocator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Fallocator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fallocator.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -205,11 +205,12 @@ omp_destroy_allocator (omp_allocator_handle_t allocator)\n ialias (omp_init_allocator)\n ialias (omp_destroy_allocator)\n \n-void *\n-omp_alloc (size_t size, omp_allocator_handle_t allocator)\n+static void *\n+omp_aligned_alloc (size_t alignment, size_t size,\n+\t\t   omp_allocator_handle_t allocator)\n {\n   struct omp_allocator_data *allocator_data;\n-  size_t alignment, new_size;\n+  size_t new_size;\n   void *ptr, *ret;\n \n   if (__builtin_expect (size == 0, 0))\n@@ -227,12 +228,14 @@ omp_alloc (size_t size, omp_allocator_handle_t allocator)\n   if (allocator > omp_max_predefined_alloc)\n     {\n       allocator_data = (struct omp_allocator_data *) allocator;\n-      alignment = allocator_data->alignment;\n+      if (alignment < allocator_data->alignment)\n+\talignment = allocator_data->alignment;\n     }\n   else\n     {\n       allocator_data = NULL;\n-      alignment = sizeof (void *);\n+      if (alignment < sizeof (void *))\n+\talignment = sizeof (void *);\n     }\n \n   new_size = sizeof (struct omp_mem_header);\n@@ -339,6 +342,27 @@ omp_alloc (size_t size, omp_allocator_handle_t allocator)\n   return NULL;\n }\n \n+void *\n+omp_alloc (size_t size, omp_allocator_handle_t allocator)\n+{\n+  return omp_aligned_alloc (1, size, allocator);\n+}\n+\n+/* Like omp_aligned_alloc, but apply on top of that:\n+   \"For allocations that arise from this ... the null_fb value of the\n+   fallback allocator trait behaves as if the abort_fb had been specified.\"  */\n+\n+void *\n+GOMP_alloc (size_t alignment, size_t size, uintptr_t allocator)\n+{\n+  void *ret = omp_aligned_alloc (alignment, size,\n+\t\t\t\t (omp_allocator_handle_t) allocator);\n+  if (__builtin_expect (ret == NULL, 0) && size)\n+    gomp_fatal (\"Out of memory allocating %lu bytes\",\n+\t\t(unsigned long) size);\n+  return ret;\n+}\n+\n void\n omp_free (void *ptr, omp_allocator_handle_t allocator)\n {\n@@ -366,3 +390,11 @@ omp_free (void *ptr, omp_allocator_handle_t allocator)\n     }\n   free (data->ptr);\n }\n+\n+ialias (omp_free)\n+\n+void\n+GOMP_free (void *ptr, uintptr_t allocator)\n+{\n+  return omp_free (ptr, (omp_allocator_handle_t) allocator);\n+}"}, {"sha": "2c95f781fd5c70f5ace28cc5ad5814a044171600", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -359,6 +359,12 @@ GOMP_5.0 {\n \tGOMP_workshare_task_reduction_unregister;\n } GOMP_4.5;\n \n+GOMP_5.0.1 {\n+  global:\n+\tGOMP_alloc;\n+\tGOMP_free;\n+} GOMP_5.0;\n+\n OACC_2.0 {\n   global:\n \tacc_get_num_devices;"}, {"sha": "b20e186c02f9b367bf16d723fb90994f2cff79bf", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -357,6 +357,11 @@ extern void GOMP_teams (unsigned int, unsigned int);\n extern void GOMP_teams_reg (void (*) (void *), void *, unsigned, unsigned,\n \t\t\t    unsigned);\n \n+/* allocator.c */\n+\n+extern void *GOMP_alloc (size_t, size_t, uintptr_t);\n+extern void GOMP_free (void *, uintptr_t);\n+\n /* oacc-async.c */\n \n extern void GOACC_wait (int, int, ...);"}, {"sha": "4424a16b40d37ef26850063c22356123c0e7ddb9", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -281,7 +281,7 @@ extern void omp_set_default_allocator (omp_allocator_handle_t) __GOMP_NOTHROW;\n extern omp_allocator_handle_t omp_get_default_allocator (void) __GOMP_NOTHROW;\n extern void *omp_alloc (__SIZE_TYPE__,\n \t\t\tomp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR)\n-  __GOMP_NOTHROW;\n+  __GOMP_NOTHROW __attribute__((__malloc__, __alloc_size__ (1)));\n extern void omp_free (void *,\n \t\t      omp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR)\n   __GOMP_NOTHROW;"}, {"sha": "ee89f31b6b3563a9be3ac076a3763e070505aeb2", "filename": "libgomp/testsuite/libgomp.c++/allocate-1.C", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fallocate-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fallocate-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fallocate-1.C?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -0,0 +1,194 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+\n+void\n+foo (int &x, int &y, int &r, int &l, int (&l2)[4], int &l3, int &n, omp_allocator_handle_t h, int fl)\n+{\n+  int i;\n+  typedef int T[x];\n+  T v, w;\n+  T &v2 = v;\n+  T &w2 = w;\n+  int xo = x;\n+  for (i = 0; i < x; i++)\n+    w[i] = i;\n+  #pragma omp parallel private (y, v2) firstprivate (x) allocate (x, y, v2)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    v2[0] = 7;\n+    v2[41] = 8;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+    if (v2[0] != 7 || v2[41] != 8)\n+      abort ();\n+    if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p2\n+\t| (uintptr_t) &v2[0]) & 63) != 0)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp teams\n+  #pragma omp parallel private (y) firstprivate (x, w2) allocate (h: x, y, w2)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42 || w2[17] != 17 || w2[41] != 41)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    w2[19]++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1 || w2[19] != 20)\n+      abort ();\n+    if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p2\n+\t\t      | (uintptr_t) &w2[0]) & 63) != 0)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp parallel for private (y) firstprivate (x) allocate (h: x, y, r, l, n) reduction(+: r) lastprivate (l) linear (n: 16)\n+  for (i = 0; i < 64; i++)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      y = 1;\n+      l = i;\n+      n += y + 15;\n+      r += i;\n+      if ((fl & 1) && (((uintptr_t) &x | (uintptr_t) &y | (uintptr_t) &r\n+\t\t\t| (uintptr_t) &l | (uintptr_t) &n) & 63) != 0)\n+\tabort ();\n+    }\n+  #pragma omp parallel\n+  {\n+    #pragma omp for lastprivate (l2) allocate (h: l2, l3) lastprivate (conditional: l3)\n+    for (i = 0; i < 64; i++)\n+      {\n+\tl2[0] = i;\n+\tl2[1] = i + 1;\n+\tl2[2] = i + 2;\n+\tl2[3] = i + 3;\n+\tif (i < 37)\n+\t  l3 = i;\n+\tif ((fl & 1) && (((uintptr_t) &l2[0] | (uintptr_t) &l3) & 63) != 0)\n+\t  abort ();\n+      }\n+  }\n+  if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n+    abort ();\n+  if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n+    abort ();\n+}\n+\n+void\n+bar (int &x, int &y, int &r, int &l, int (&l2)[4], int &l3, int &n, omp_allocator_handle_t h)\n+{\n+  int i;\n+  typedef int T[x];\n+  T v, w;\n+  T &v2 = v;\n+  T &w2 = w;\n+  int xo = x;\n+  for (i = 0; i < x; i++)\n+    w[i] = i;\n+  #pragma omp parallel private (y, v2) firstprivate (x) allocate (x, y, v2)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    v2[0] = 7;\n+    v2[41] = 8;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+    if (v2[0] != 7 || v2[41] != 8)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp teams\n+  #pragma omp parallel private (y) firstprivate (x, w2) allocate (h: x, y, w2)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42 || w2[17] != 17 || w2[41] != 41)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp parallel for private (y) firstprivate (x) allocate (h: x, y, r, l, n) reduction(+: r) lastprivate (l) linear (n: 16)\n+  for (i = 0; i < 64; i++)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      y = 1;\n+      l = i;\n+      n += y + 15;\n+      r += i;\n+    }\n+  #pragma omp parallel\n+  {\n+    #pragma omp for lastprivate (l2) allocate (h: l2, l3) lastprivate (conditional: l3)\n+    for (i = 0; i < 64; i++)\n+      {\n+\tl2[0] = i;\n+\tl2[1] = i + 1;\n+\tl2[2] = i + 2;\n+\tl2[3] = i + 3;\n+\tif (i < 37)\n+\t  l3 = i;\n+      }\n+  }\n+  if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n+    abort ();\n+  if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  omp_alloctrait_t traits[3]\n+    = { { omp_atk_alignment, 64 },\n+\t{ omp_atk_fallback, omp_atv_null_fb } };\n+  omp_allocator_handle_t a\n+    = omp_init_allocator (omp_default_mem_space, 2, traits);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  omp_set_default_allocator (omp_default_mem_alloc);\n+  int x = 42, y = 0, r = 0, l, l2[4], l3, n = 8;\n+  foo (x, y, r, l, l2, l3, n, omp_null_allocator, 0);\n+  x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n+  l2[2] = -1; l2[3] = -1; n = 8;\n+  foo (x, y, r, l, l2, l3, n, omp_default_mem_alloc, 0);\n+  x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n+  l2[2] = -1; l2[3] = -1; n = 8;\n+  foo (x, y, r, l, l2, l3, n, a, 1);\n+  x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n+  l2[2] = -1; l2[3] = -1; n = 8;\n+  omp_set_default_allocator (a);\n+  foo (x, y, r, l, l2, l3, n, omp_null_allocator, 3);\n+  x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n+  l2[2] = -1; l2[3] = -1; n = 8;\n+  foo (x, y, r, l, l2, l3, n, omp_default_mem_alloc, 2);\n+  x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n+  l2[2] = -1; l2[3] = -1; n = 8;\n+  bar (x, y, r, l, l2, l3, n, a);\n+  omp_destroy_allocator (a);\n+  return 0;\n+}"}, {"sha": "532795f06f146b359cf9aee13df8dc5a3dd53dcb", "filename": "libgomp/testsuite/libgomp.c-c++-common/allocate-1.c", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fcc3cac42998081dbbb1d3389bd42833ad9fdf4/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c?ref=6fcc3cac42998081dbbb1d3389bd42833ad9fdf4", "patch": "@@ -0,0 +1,254 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+\n+void\n+foo (int x, omp_allocator_handle_t h, int fl)\n+{\n+  int y = 0, r = 0, i, i1, l, l2[4], l3, n = 8;\n+  int i2, j2, n2 = 9, l4;\n+  int i3, j3, n3 = 10, l5;\n+  int i4, j4, n4 = 11, l6;\n+  int i5;\n+  int v[x], w[x];\n+  int xo = x;\n+  for (i = 0; i < x; i++)\n+    w[i] = i;\n+  #pragma omp parallel private (y, v) firstprivate (x) allocate (x, y, v)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    v[0] = 7;\n+    v[41] = 8;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+    if (v[0] != 7 || v[41] != 8)\n+      abort ();\n+    if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p2\n+\t| (uintptr_t) &v[0]) & 63) != 0)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp teams\n+  #pragma omp parallel private (y) firstprivate (x, w) allocate (h: x, y, w)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42 || w[17] != 17 || w[41] != 41)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    w[19]++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1 || w[19] != 20)\n+      abort ();\n+    if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p2\n+\t\t      | (uintptr_t) &w[0]) & 63) != 0)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp parallel for private (y) firstprivate (x) allocate (h: x, y, r, l, n) reduction(+: r) lastprivate (l) linear (n: 16)\n+  for (i = 0; i < 64; i++)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      y = 1;\n+      l = i;\n+      n += y + 15;\n+      r += i;\n+      if ((fl & 1) && (((uintptr_t) &x | (uintptr_t) &y | (uintptr_t) &r\n+\t\t\t| (uintptr_t) &l | (uintptr_t) &n) & 63) != 0)\n+\tabort ();\n+    }\n+  #pragma omp parallel\n+  {\n+    #pragma omp for lastprivate (l2) private (i1) allocate (h: l2, l3, i1) lastprivate (conditional: l3)\n+    for (i1 = 0; i1 < 64; i1++)\n+      {\n+\tl2[0] = i1;\n+\tl2[1] = i1 + 1;\n+\tl2[2] = i1 + 2;\n+\tl2[3] = i1 + 3;\n+\tif (i1 < 37)\n+\t  l3 = i1;\n+\tif ((fl & 1) && (((uintptr_t) &l2[0] | (uintptr_t) &l3 | (uintptr_t) &i1) & 63) != 0)\n+\t  abort ();\n+      }\n+    #pragma omp for collapse(2) lastprivate(l4, i2, j2) linear (n2:17) allocate (h: n2, l4, i2, j2)\n+    for (i2 = 3; i2 < 5; i2++)\n+      for (j2 = 17; j2 < 22; j2 += 2)\n+\t{\n+\t  n2 += 17;\n+\t  l4 = i2 * 31 + j2;\n+\t  if ((fl & 1) && (((uintptr_t) &l4 | (uintptr_t) &n2\n+\t\t\t    | (uintptr_t) &i2 | (uintptr_t) &j2) & 63) != 0)\n+\t    abort ();\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l5, i3, j3) linear (n3:17) schedule (static, 3) allocate (n3, l5, i3, j3)\n+    for (i3 = 3; i3 < 5; i3++)\n+      for (j3 = 17; j3 < 23; j3 += 2)\n+\t{\n+\t  n3 += 17;\n+\t  l5 = i3 * 31 + j3;\n+\t  if ((fl & 2) && (((uintptr_t) &l5 | (uintptr_t) &n3\n+\t\t\t    | (uintptr_t) &i3 | (uintptr_t) &j3) & 63) != 0)\n+\t    abort ();\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l6, i4, j4) linear (n4:17) schedule (dynamic) allocate (h: n4, l6, i4, j4)\n+    for (i4 = 3; i4 < 5; i4++)\n+      for (j4 = 17; j4 < 22; j4 += 2)\n+\t{\n+\t  n4 += 17;\n+\t  l6 = i4 * 31 + j4;\n+\t  if ((fl & 1) && (((uintptr_t) &l6 | (uintptr_t) &n4\n+\t\t\t    | (uintptr_t) &i4 | (uintptr_t) &j4) & 63) != 0)\n+\t    abort ();\n+\t}\n+    #pragma omp for lastprivate (i5) allocate (i5)\n+    for (i5 = 1; i5 < 17; i5 += 3)\n+      {\n+\tif ((fl & 2) && (((uintptr_t) &i5) & 63) != 0)\n+\t  abort ();\n+      }\n+  }\n+  if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n+    abort ();\n+  if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n+    abort ();\n+  if (i2 != 5 || j2 != 23 || n2 != 9 + 6 * 17 || l4 != 4 * 31 + 21)\n+    abort ();\n+  if (i3 != 5 || j3 != 23 || n3 != 10 + 6 * 17 || l5 != 4 * 31 + 21)\n+    abort ();\n+  if (i4 != 5 || j4 != 23 || n4 != 11 + 6 * 17 || l6 != 4 * 31 + 21)\n+    abort ();\n+  if (i5 != 19)\n+    abort ();\n+}\n+\n+void\n+bar (int x, omp_allocator_handle_t h)\n+{\n+  int y = 0, r = 0, i, i1, l, l2[4], l3, n = 8;\n+  int i2, j2, n2 = 9, l4;\n+  int i3, j3, n3 = 10, l5;\n+  int i4, j4, n4 = 11, l6;\n+  int i5;\n+  int xo = x;\n+  #pragma omp parallel private (y) firstprivate (x) allocate (x, y)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp teams\n+  #pragma omp parallel private (y) firstprivate (x) allocate (h: x, y)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp parallel for private (y) firstprivate (x) allocate (h: x, y, r, l, n) reduction(+: r) lastprivate (l) linear (n: 16)\n+  for (i = 0; i < 64; i++)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      y = 1;\n+      l = i;\n+      n += y + 15;\n+      r += i;\n+    }\n+  #pragma omp parallel\n+  {\n+    #pragma omp for lastprivate (l2) private (i1) allocate (h: l2, l3, i1) lastprivate (conditional: l3)\n+    for (i1 = 0; i1 < 64; i1++)\n+      {\n+\tl2[0] = i1;\n+\tl2[1] = i1 + 1;\n+\tl2[2] = i1 + 2;\n+\tl2[3] = i1 + 3;\n+\tif (i1 < 37)\n+\t  l3 = i1;\n+      }\n+    #pragma omp for collapse(2) lastprivate(l4, i2, j2) linear (n2:17) allocate (h: n2, l4, i2, j2)\n+    for (i2 = 3; i2 < 5; i2++)\n+      for (j2 = 17; j2 < 22; j2 += 2)\n+\t{\n+\t  n2 += 17;\n+\t  l4 = i2 * 31 + j2;\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l5, i3, j3) linear (n3:17) schedule (static, 3) allocate (n3, l5, i3, j3)\n+    for (i3 = 3; i3 < 5; i3++)\n+      for (j3 = 17; j3 < 23; j3 += 2)\n+\t{\n+\t  n3 += 17;\n+\t  l5 = i3 * 31 + j3;\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l6, i4, j4) linear (n4:17) schedule (dynamic) allocate (h: n4, l6, i4, j4)\n+    for (i4 = 3; i4 < 5; i4++)\n+      for (j4 = 17; j4 < 22; j4 += 2)\n+\t{\n+\t  n4 += 17;\n+\t  l6 = i4 * 31 + j4;\n+\t}\n+    #pragma omp for lastprivate (i5) allocate (i5)\n+    for (i5 = 1; i5 < 17; i5 += 3)\n+      ;\n+  }\n+  if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n+    abort ();\n+  if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n+    abort ();\n+  if (i2 != 5 || j2 != 23 || n2 != 9 + 6 * 17 || l4 != 4 * 31 + 21)\n+    abort ();\n+  if (i3 != 5 || j3 != 23 || n3 != 10 + 6 * 17 || l5 != 4 * 31 + 21)\n+    abort ();\n+  if (i4 != 5 || j4 != 23 || n4 != 11 + 6 * 17 || l6 != 4 * 31 + 21)\n+    abort ();\n+  if (i5 != 19)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  omp_alloctrait_t traits[3]\n+    = { { omp_atk_alignment, 64 },\n+\t{ omp_atk_fallback, omp_atv_null_fb } };\n+  omp_allocator_handle_t a\n+    = omp_init_allocator (omp_default_mem_space, 2, traits);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  omp_set_default_allocator (omp_default_mem_alloc);\n+  foo (42, omp_null_allocator, 0);\n+  foo (42, omp_default_mem_alloc, 0);\n+  foo (42, a, 1);\n+  omp_set_default_allocator (a);\n+  foo (42, omp_null_allocator, 3);\n+  foo (42, omp_default_mem_alloc, 2);\n+  bar (42, a);\n+  omp_destroy_allocator (a);\n+  return 0;\n+}"}]}