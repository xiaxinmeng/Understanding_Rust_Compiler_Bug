{"sha": "a187ac959abfbe030c4733315820aa4a038ff1bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4N2FjOTU5YWJmYmUwMzBjNDczMzMxNTgyMGFhNGEwMzhmZjFiYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-30T03:11:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-30T03:11:04Z"}, "message": "Initial revision\n\nFrom-SVN: r1357", "tree": {"sha": "6ee585808376992092b4441b5667391817c1fe2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ee585808376992092b4441b5667391817c1fe2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a187ac959abfbe030c4733315820aa4a038ff1bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a187ac959abfbe030c4733315820aa4a038ff1bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a187ac959abfbe030c4733315820aa4a038ff1bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a187ac959abfbe030c4733315820aa4a038ff1bc/comments", "author": null, "committer": null, "parents": [{"sha": "d3414ccbd1d1e56b9376e1d317c223ed162c8d72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3414ccbd1d1e56b9376e1d317c223ed162c8d72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3414ccbd1d1e56b9376e1d317c223ed162c8d72"}], "stats": {"total": 219, "additions": 219, "deletions": 0}, "files": [{"sha": "4cfd0905b1e9db57d048b150b9f3530d10d2a59a", "filename": "gcc/c-pragma.c", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187ac959abfbe030c4733315820aa4a038ff1bc/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187ac959abfbe030c4733315820aa4a038ff1bc/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=a187ac959abfbe030c4733315820aa4a038ff1bc", "patch": "@@ -0,0 +1,219 @@\n+/* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifdef HANDLE_SYSV_PRAGMA\n+\n+/* When structure field packing is in effect, this variable is the\n+   number of bits to use as the maximum alignment.  When packing is not\n+   in effect, this is zero. */\n+\n+extern int maximum_field_alignment;\n+\n+/* Handle a #pragma directive.  INPUT is the current input stream,\n+   and C is a character to reread.\n+   Returns a character for the caller to reread,\n+   or -1 meaning there isn't one.  */\n+\n+int\n+handle_sysv_pragma (input, c)\n+     FILE *input;\n+     int c;\n+{\n+  while (c == ' ' || c == '\\t')\n+    c = getc (input);\n+  if (c == '\\n' || c == EOF)\n+    {\n+      handle_pragma_token (0, 0);\n+      return c;\n+    }\n+  ungetc (c, input);\n+  switch (yylex ())\n+    {\n+    case IDENTIFIER:\n+    case TYPENAME:\n+    case STRING:\n+    case CONSTANT:\n+      handle_pragma_token (token_buffer, yylval.ttype);\n+      break;\n+    default:\n+      handle_pragma_token (token_buffer, 0);\n+    }\n+  return -1;\n+}\n+\n+/* Handle one token of a pragma directive.  TOKEN is the\n+   current token, and STRING is its printable form.  */\n+\n+void\n+handle_pragma_token (string, token)\n+     char *string;\n+     tree token;\n+{\n+  static enum pragma_state\n+    {\n+      ps_start,\n+      ps_done,\n+      ps_bad,\n+      ps_weak,\n+      ps_name,\n+      ps_equals,\n+      ps_value,\n+      ps_pack,\n+      ps_left,\n+      ps_align,\n+      ps_right\n+      } state = ps_start, type;\n+  static char *name;\n+  static char *value;\n+  static int align;\n+\n+  if (string == 0)\n+    {\n+      if (type == ps_pack)\n+\t{\n+\t  if (state == ps_right)\n+\t    maximum_field_alignment = align * 8;\n+\t  else\n+\t    warning (\"malformed `#pragma pack'\");\n+\t}\n+#ifdef WEAK_ASM_OP\n+      else if (type == ps_weak)\n+\t{\n+\t  if (state == ps_name || state == ps_value)\n+\t    {\n+\t      fprintf (asm_out_file, \"\\t%s\\t\", WEAK_ASM_OP);\n+\t      ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t      fputc ('\\n', asm_out_file);\n+\t      if (state == ps_value)\n+\t\t{\n+\t\t  fprintf (asm_out_file, \"\\t%s\\t\", SET_ASM_OP);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t\t  fputc (',', asm_out_file);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, value);\n+\t\t  fputc ('\\n', asm_out_file);\n+\t\t}\n+\t    }\n+\t  else if (! (state == ps_done || state == ps_start))\n+\t    warning (\"malformed `#pragma weak'\");\n+\t}\n+#endif /* WEAK_ASM_OP */\n+\n+      type = state = ps_start;\n+      return;\n+    }\n+\n+  switch (state)\n+    {\n+    case ps_start:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  if (strcmp (IDENTIFIER_POINTER (token), \"pack\") == 0)\n+\t    type = state = ps_pack;\n+#ifdef WEAK_ASM_OP\n+\t  else if (strcmp (IDENTIFIER_POINTER (token), \"weak\") == 0)\n+\t    type = state = ps_weak;\n+#endif\n+\t  else\n+\t    type = state = ps_done;\n+\t}\n+      else\n+\ttype = state = ps_done;\n+      break;\n+\n+#ifdef WEAK_ASM_OP\n+    case ps_weak:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  name = IDENTIFIER_POINTER (token);\n+\t  state = ps_name;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_name:\n+      state = (strcmp (string, \"=\") ? ps_bad : ps_equals);\n+      break;\n+\n+    case ps_equals:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  value = IDENTIFIER_POINTER (token);\n+\t  state = ps_value;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_value:\n+      state = ps_bad;\n+      break;\n+#endif /* WEAK_ASM_OP */\n+\n+    case ps_pack:\n+      if (strcmp (string, \"(\") == 0)\n+\tstate = ps_left;\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_left:\n+      if (token && TREE_CODE (token) == INTEGER_CST\n+\t  && TREE_INT_CST_HIGH (token) == 0)\n+\tswitch (TREE_INT_CST_LOW (token))\n+\t  {\n+\t  case 1:\n+\t  case 2:\n+\t  case 4:\n+\t    align = TREE_INT_CST_LOW (token);\n+\t    state = ps_align;\n+\t    break;\n+\n+\t  default:\n+\t    state = ps_bad;\n+\t  }\n+      else if (! token && strcmp (string, \")\") == 0)\n+\t{\n+\t  align = 0;\n+\t  state = ps_right;\n+\t}\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_align:\n+      if (strcmp (string, \")\") == 0)\n+\tstate = ps_right;\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_right:\n+      state = ps_bad;\n+      break;\n+\n+    case ps_bad:\n+    case ps_done:\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+#endif /* HANDLE_SYSV_PRAGMA */"}]}