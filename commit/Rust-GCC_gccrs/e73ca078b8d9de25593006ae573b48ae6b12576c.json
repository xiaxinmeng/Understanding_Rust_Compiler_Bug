{"sha": "e73ca078b8d9de25593006ae573b48ae6b12576c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczY2EwNzhiOGQ5ZGUyNTU5MzAwNmFlNTczYjQ4YWU2YjEyNTc2Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-11-15T23:44:47Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-15T23:44:47Z"}, "message": "libstdc++: Fix <stop_token> and improve tests\n\n\t* include/std/stop_token: Reduce header dependencies by including\n\tinternal headers.\n\t(stop_token::swap(stop_token&), swap(stop_token&, stop_token&)):\n\tDefine.\n\t(operator!=(const stop_token&, const stop_token&)): Fix return value.\n\t(stop_token::_Stop_cb::_Stop_cb(Cb&&)): Use std::forward instead of\n\t(stop_token::_Stop_state_t) [_GLIBCXX_HAS_GTHREADS]: Use lock_guard\n\tinstead of unique_lock.\n\t[!_GLIBCXX_HAS_GTHREADS]: Do not use mutex.\n\t(stop_token::stop_token(_Stop_state)): Change parameter to lvalue\n\treference.\n\t(stop_source): Remove unnecessary using-declarations for names only\n\tused once.\n\t(swap(stop_source&, stop_source&)): Define.\n\t(stop_callback(const stop_token&, _Cb&&))\n\t(stop_callback(stop_token&&, _Cb&&)): Replace lambdas with a named\n\tfunction. Use std::forward instead of std::move. Run callbacks if a\n\tstop request has already been made.\n\t(stop_source::_M_execute()): Remove.\n\t(stop_source::_S_execute(_Stop_cb*)): Define.\n\t* include/std/version (__cpp_lib_jthread): Define conditionally.\n\t* testsuite/30_threads/stop_token/stop_callback.cc: New test.\n\t* testsuite/30_threads/stop_token/stop_source.cc: New test.\n\t* testsuite/30_threads/stop_token/stop_token.cc: Enable test for\n\timmediate execution of callback.\n\nFrom-SVN: r278325", "tree": {"sha": "40a58633577e8773f091cf2c351fbaacc9b42cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40a58633577e8773f091cf2c351fbaacc9b42cf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e73ca078b8d9de25593006ae573b48ae6b12576c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73ca078b8d9de25593006ae573b48ae6b12576c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73ca078b8d9de25593006ae573b48ae6b12576c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73ca078b8d9de25593006ae573b48ae6b12576c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5fbe5e014bc9fc803604eec805392c21ff4da16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fbe5e014bc9fc803604eec805392c21ff4da16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5fbe5e014bc9fc803604eec805392c21ff4da16"}], "stats": {"total": 435, "additions": 353, "deletions": 82}, "files": [{"sha": "0db99e412399d42fcb847e4eac59be11b125b6b9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e73ca078b8d9de25593006ae573b48ae6b12576c", "patch": "@@ -1,3 +1,31 @@\n+2019-11-15  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/stop_token: Reduce header dependencies by including\n+\tinternal headers.\n+\t(stop_token::swap(stop_token&), swap(stop_token&, stop_token&)):\n+\tDefine.\n+\t(operator!=(const stop_token&, const stop_token&)): Fix return value.\n+\t(stop_token::_Stop_cb::_Stop_cb(Cb&&)): Use std::forward instead of\n+\t(stop_token::_Stop_state_t) [_GLIBCXX_HAS_GTHREADS]: Use lock_guard\n+\tinstead of unique_lock.\n+\t[!_GLIBCXX_HAS_GTHREADS]: Do not use mutex.\n+\t(stop_token::stop_token(_Stop_state)): Change parameter to lvalue\n+\treference.\n+\t(stop_source): Remove unnecessary using-declarations for names only\n+\tused once.\n+\t(swap(stop_source&, stop_source&)): Define.\n+\t(stop_callback(const stop_token&, _Cb&&))\n+\t(stop_callback(stop_token&&, _Cb&&)): Replace lambdas with a named\n+\tfunction. Use std::forward instead of std::move. Run callbacks if a\n+\tstop request has already been made.\n+\t(stop_source::_M_execute()): Remove.\n+\t(stop_source::_S_execute(_Stop_cb*)): Define.\n+\t* include/std/version (__cpp_lib_jthread): Define conditionally.\n+\t* testsuite/30_threads/stop_token/stop_callback.cc: New test.\n+\t* testsuite/30_threads/stop_token/stop_source.cc: New test.\n+\t* testsuite/30_threads/stop_token/stop_token.cc: Enable test for\n+\timmediate execution of callback.\n+\n 2019-11-15  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tImplement the default_searcher part of C++20 p1032 Misc constexpr bits."}, {"sha": "bb082431d7fae16421dddc97f44384bb45be96b8", "filename": "libstdc++-v3/include/std/stop_token", "status": "modified", "additions": 98, "deletions": 77, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token?ref=e73ca078b8d9de25593006ae573b48ae6b12576c", "patch": "@@ -31,24 +31,25 @@\n \n #if __cplusplus > 201703L\n \n-#include <type_traits>\n-#include <memory>\n-#include <mutex>\n #include <atomic>\n+#include <bits/std_mutex.h>\n+#include <ext/concurrence.h>\n+#include <bits/unique_ptr.h>\n+#include <bits/shared_ptr.h>\n \n-#define __cpp_lib_jthread 201907L\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+# define __cpp_lib_jthread 201907L\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  class stop_source;\n-  template<typename _Callback>\n-  class stop_callback;\n-\n+  /// Tag type indicating a stop_source should have no shared-stop-state.\n   struct nostopstate_t { explicit nostopstate_t() = default; };\n   inline constexpr nostopstate_t nostopstate{};\n \n+  /// Allow testing whether a stop request has been made on a `stop_source`.\n   class stop_token\n   {\n   public:\n@@ -63,7 +64,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator=(const stop_token& __rhs) noexcept = default;\n \n     stop_token&\n-    operator=(stop_token&& __rhs) noexcept;\n+    operator=(stop_token&& __rhs) noexcept = default;\n \n     [[nodiscard]]\n     bool\n@@ -79,6 +80,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return stop_possible() && _M_state->_M_stop_requested();\n     }\n \n+    void\n+    swap(stop_token& __rhs) noexcept\n+    { _M_state.swap(__rhs._M_state); }\n+\n     [[nodiscard]]\n     friend bool\n     operator==(const stop_token& __a, const stop_token& __b)\n@@ -90,26 +95,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     friend bool\n     operator!=(const stop_token& __a, const stop_token& __b)\n     {\n-      return __a._M_state == __b._M_state;\n+      return __a._M_state != __b._M_state;\n     }\n \n+    friend void\n+    swap(stop_token& __lhs, stop_token& __rhs) noexcept\n+    { __lhs.swap(__rhs); }\n+\n   private:\n-    friend stop_source;\n+    friend class stop_source;\n     template<typename _Callback>\n-    friend class stop_callback;\n+      friend class stop_callback;\n \n-    struct _Stop_cb {\n+    struct _Stop_cb\n+    {\n       void(*_M_callback)(_Stop_cb*);\n       _Stop_cb* _M_prev = nullptr;\n       _Stop_cb* _M_next = nullptr;\n \n       template<typename _Cb>\n-      _Stop_cb(_Cb&& __cb)\n-        : _M_callback(std::move(__cb))\n-      { }\n+\t_Stop_cb(_Cb&& __cb)\n+\t: _M_callback(std::forward<_Cb>(__cb))\n+\t{ }\n \n       bool\n-      _M_linked() const\n+      _M_linked() const noexcept\n       {\n         return (_M_prev != nullptr)\n           || (_M_next != nullptr);\n@@ -123,17 +133,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n-    struct _Stop_state_t {\n-      std::atomic<bool> _M_stopped;\n-      std::mutex _M_mtx;\n+    struct _Stop_state_t\n+    {\n+      std::atomic<bool> _M_stopped{false};\n       _Stop_cb* _M_head = nullptr;\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+      std::mutex _M_mtx;\n+#endif\n \n-      _Stop_state_t()\n-        : _M_stopped{false}\n-      { }\n+      _Stop_state_t() = default;\n \n       bool\n-      _M_stop_requested()\n+      _M_stop_requested() noexcept\n       {\n         return _M_stopped;\n       }\n@@ -144,7 +155,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         bool __stopped = false;\n         if (_M_stopped.compare_exchange_strong(__stopped, true))\n           {\n-            std::unique_lock<std::mutex> __lck{_M_mtx};\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+            std::lock_guard<std::mutex> __lck{_M_mtx};\n+#endif\n             while (_M_head)\n               {\n                 auto __p = _M_head;\n@@ -159,7 +172,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_register_callback(_Stop_cb* __cb)\n       {\n-        std::unique_lock<std::mutex> __lck{_M_mtx};\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+        std::lock_guard<std::mutex> __lck{_M_mtx};\n+#endif\n         if (_M_stopped)\n           return false;\n \n@@ -169,13 +184,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n             _M_head->_M_prev = __cb;\n           }\n         _M_head = __cb;\n-         return true;\n+        return true;\n       }\n \n       void\n       _M_remove_callback(_Stop_cb* __cb)\n       {\n-        std::unique_lock<std::mutex> __lck{_M_mtx};\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+        std::lock_guard<std::mutex> __lck{_M_mtx};\n+#endif\n         if (__cb == _M_head)\n           {\n             _M_head = _M_head->_M_next;\n@@ -202,18 +219,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using _Stop_state = std::shared_ptr<_Stop_state_t>;\n     _Stop_state _M_state;\n \n-    explicit stop_token(_Stop_state __state)\n-      : _M_state{std::move(__state)}\n+    explicit\n+    stop_token(const _Stop_state& __state) noexcept\n+    : _M_state{__state}\n     { }\n   };\n \n-  class stop_source {\n-    using _Stop_state_t = stop_token::_Stop_state_t;\n-    using _Stop_state = stop_token::_Stop_state;\n-\n+  /// A type that allows a stop request to be made.\n+  class stop_source\n+  {\n   public:\n     stop_source()\n-      : _M_state(std::make_shared<_Stop_state_t>())\n+      : _M_state(std::make_shared<stop_token::_Stop_state_t>())\n     { }\n \n     explicit stop_source(std::nostopstate_t) noexcept\n@@ -274,7 +291,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     swap(stop_source& __other) noexcept\n     {\n-      std::swap(_M_state, __other._M_state);\n+      _M_state.swap(__other._M_state);\n     }\n \n     [[nodiscard]]\n@@ -291,59 +308,63 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __a._M_state != __b._M_state;\n     }\n \n+    friend void\n+    swap(stop_source& __lhs, stop_source& __rhs) noexcept\n+    {\n+      __lhs.swap(__rhs);\n+    }\n+\n   private:\n-    _Stop_state _M_state;\n+    stop_token::_Stop_state _M_state;\n   };\n \n+  /// A wrapper for callbacks to be run when a stop request is made.\n   template<typename _Callback>\n     class [[nodiscard]] stop_callback\n       : private stop_token::_Stop_cb\n     {\n-      using _Stop_cb = stop_token::_Stop_cb;\n-      using _Stop_state = stop_token::_Stop_state;\n     public:\n       using callback_type = _Callback;\n \n       template<typename _Cb,\n-               std::enable_if_t<std::is_constructible_v<_Callback, _Cb>, int> = 0>\n-        explicit stop_callback(const stop_token& __token, _Cb&& __cb)\n-        noexcept(std::is_nothrow_constructible_v<_Callback, _Cb>)\n-        : _Stop_cb([](_Stop_cb* __that) noexcept\n-                   {\n-                     static_cast<stop_callback*>(__that)->_M_execute();\n-                   }),\n-        _M_cb(std::move(__cb))\n+               enable_if_t<is_constructible_v<_Callback, _Cb>, int> = 0>\n+        explicit\n+\tstop_callback(const stop_token& __token, _Cb&& __cb)\n+        noexcept(is_nothrow_constructible_v<_Callback, _Cb>)\n+        : _Stop_cb(&_S_execute), _M_cb(std::forward<_Cb>(__cb))\n         {\n-          auto res = __token._M_state->_M_register_callback(this);\n-          if (__token._M_state && res)\n-            {\n-              _M_state = __token._M_state;\n-            }\n+\t  if (auto __state = __token._M_state)\n+\t    {\n+\t      if (__state->_M_stop_requested())\n+\t\t_S_execute(this); // ensures std::terminate on throw\n+\t      else if (__state->_M_register_callback(this))\n+\t\t_M_state.swap(__state);\n+\t    }\n         }\n \n       template<typename _Cb,\n-               std::enable_if_t<std::is_constructible_v<_Callback, _Cb>, int> = 0>\n-        explicit stop_callback(stop_token&& __token, _Cb&& __cb)\n-        noexcept(std::is_nothrow_constructible_v<_Callback, _Cb>)\n-        : _Stop_cb([](_Stop_cb* __that) noexcept\n-                   {\n-                     static_cast<stop_callback*>(__that)->_M_execute();\n-                   }),\n-          _M_cb(std::move(__cb))\n-          {\n-            if (__token._M_state && __token._M_state->_M_register_callback(this))\n-              {\n-                std::swap(_M_state, __token._M_state);\n-              }\n-          }\n+               enable_if_t<is_constructible_v<_Callback, _Cb>, int> = 0>\n+        explicit\n+\tstop_callback(stop_token&& __token, _Cb&& __cb)\n+        noexcept(is_nothrow_constructible_v<_Callback, _Cb>)\n+        : _Stop_cb(&_S_execute), _M_cb(std::forward<_Cb>(__cb))\n+\t{\n+\t  if (auto& __state = __token._M_state)\n+\t    {\n+\t      if (__state->_M_stop_requested())\n+\t\t_S_execute(this); // ensures std::terminate on throw\n+\t      else if (__state->_M_register_callback(this))\n+\t\t_M_state.swap(__state);\n+\t    }\n+\t}\n \n       ~stop_callback()\n-        {\n-          if (_M_state)\n-            {\n-              _M_state->_M_remove_callback(this);\n-            }\n-        }\n+      {\n+\tif (_M_state)\n+\t  {\n+\t    _M_state->_M_remove_callback(this);\n+\t  }\n+      }\n \n       stop_callback(const stop_callback&) = delete;\n       stop_callback& operator=(const stop_callback&) = delete;\n@@ -352,12 +373,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       _Callback _M_cb;\n-      _Stop_state _M_state = nullptr;\n+      stop_token::_Stop_state _M_state = nullptr;\n \n-      void\n-        _M_execute() noexcept\n+      static void\n+      _S_execute(_Stop_cb* __that) noexcept\n       {\n-        _M_cb();\n+\tstatic_cast<stop_callback*>(__that)->_M_cb();\n       }\n     };\n \n@@ -366,5 +387,5 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n-#endif // __cplusplus >= 201703L\n+#endif // __cplusplus > 201703L\n #endif // _GLIBCXX_STOP_TOKEN"}, {"sha": "8e08dc99049a693a9c1341fa6cda38bafb62e0b2", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=e73ca078b8d9de25593006ae573b48ae6b12576c", "patch": "@@ -184,10 +184,12 @@\n #define __cpp_lib_constexpr_invoke 201907L\n #define __cpp_lib_erase_if 201900L\n #define __cpp_lib_interpolate 201902L\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+# define __cpp_lib_jthread 201907L\n+#endif\n #define __cpp_lib_list_remove_return_type 201806L\n #define __cpp_lib_math_constants 201907L\n #define __cpp_lib_span 201902L\n-#define __cpp_lib_jthread 201907L\n #if __cpp_impl_three_way_comparison >= 201907L\n # define __cpp_lib_three_way_comparison 201711L\n #endif"}, {"sha": "beb155d494ac76fad9a9c0f2ffe93bb2bf6a111b", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_callback.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback.cc?ref=e73ca078b8d9de25593006ae573b48ae6b12576c", "patch": "@@ -0,0 +1,128 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <stop_token>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool called = false;\n+  std::function<void()> f = [&called]{ called = true; };\n+  std::stop_source ssrc;\n+  ssrc.request_stop();\n+  std::stop_token tok = ssrc.get_token();\n+  std::stop_callback cb1(tok, f);\n+  VERIFY( tok.stop_possible() );\n+  VERIFY( f != nullptr );\n+  VERIFY( called == true );\n+\n+  called = false;\n+  std::stop_callback cb2(std::move(tok), f);\n+  // when callback is executed immediately, no change in ownership:\n+  VERIFY( tok.stop_possible() );\n+  VERIFY( f != nullptr );\n+  VERIFY( called == true );\n+\n+  std::stop_token sink(std::move(tok)); // leave tok empty\n+\n+  called = false;\n+  std::stop_callback cb3(tok, f);\n+  VERIFY( f != nullptr );\n+  VERIFY( called == false );\n+\n+  called = false;\n+  std::stop_callback cb4(std::move(tok), f);\n+  VERIFY( f != nullptr );\n+  VERIFY( called == false );\n+}\n+\n+void\n+test02()\n+{\n+  bool called = false;\n+  std::function<void()> f0 = [&called]{ called = true; };\n+  std::function<void()> f = f0;\n+  std::stop_source ssrc;\n+  ssrc.request_stop();\n+  std::stop_token tok = ssrc.get_token();\n+\n+  std::stop_callback cb1(tok, std::move(f));\n+  VERIFY( tok.stop_possible() );\n+  VERIFY( f == nullptr );\n+  VERIFY( called == true );\n+\n+  called = false;\n+  f = f0;\n+  std::stop_callback cb2(std::move(tok), std::move(f));\n+  // when callback is executed immediately, no change in ownership:\n+  VERIFY( tok.stop_possible() );\n+  VERIFY( f == nullptr );\n+  VERIFY( called == true );\n+\n+  std::stop_token sink(std::move(tok)); // leave tok empty\n+\n+  called = false;\n+  f = f0;\n+  std::stop_callback cb3(tok, std::move(f));\n+  VERIFY( f == nullptr );\n+  VERIFY( called == false );\n+\n+  called = false;\n+  f = f0;\n+  std::stop_callback cb4(std::move(tok), std::move(f));\n+  VERIFY( f == nullptr );\n+  VERIFY( called == false );\n+}\n+\n+void\n+test03()\n+{\n+  bool called[4] = { };\n+  std::stop_source ssrc;\n+  std::stop_token tok = ssrc.get_token();\n+  std::stop_callback cb1(tok, [&]{ called[0] = true; });\n+  VERIFY( tok.stop_possible() );\n+  VERIFY( called[0] == false );\n+\n+  std::stop_callback cb2(std::move(tok), [&]{ called[1] = true; });\n+  VERIFY( !tok.stop_possible() );\n+  VERIFY( called[1] == false );\n+\n+  std::stop_callback cb3(tok, [&]{ called[2] = true; });\n+  VERIFY( called[2] == false );\n+\n+  std::stop_callback cb4(std::move(tok), [&]{ called[3] = true; });\n+  VERIFY( called[3] == false );\n+\n+  ssrc.request_stop();\n+  VERIFY( called[0] == true );\n+  VERIFY( called[1] == true );\n+  VERIFY( called[2] == false );\n+  VERIFY( called[3] == false );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "3fe76143bd03334084ff03d2ef36cf068e49376b", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_source.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_source.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_source.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_source.cc?ref=e73ca078b8d9de25593006ae573b48ae6b12576c", "patch": "@@ -68,8 +68,27 @@ test02()\n   VERIFY( !ssrc.stop_requested() );\n }\n \n+void\n+test03()\n+{\n+  std::stop_source s1;\n+  s1.request_stop();\n+  std::stop_source s2(std::nostopstate);\n+  s1.swap(s2);\n+  VERIFY( !s1.stop_possible() );\n+  VERIFY( !s1.stop_requested() );\n+  VERIFY( s2.stop_possible() );\n+  VERIFY( s2.stop_requested() );\n+  swap(s1, s2);\n+  VERIFY( s1.stop_possible() );\n+  VERIFY( s1.stop_requested() );\n+  VERIFY( !s2.stop_possible() );\n+  VERIFY( !s2.stop_requested() );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n }"}, {"sha": "6dc850c64412c42cb50658192151bdd0bb3b3ccb", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_token.cc", "status": "modified", "additions": 77, "deletions": 4, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73ca078b8d9de25593006ae573b48ae6b12576c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token.cc?ref=e73ca078b8d9de25593006ae573b48ae6b12576c", "patch": "@@ -21,7 +21,76 @@\n #include <stop_token>\n #include <testsuite_hooks.h>\n \n-int main()\n+void\n+test01()\n+{\n+  std::stop_source ssrc;\n+  std::stop_token tok = ssrc.get_token();\n+  VERIFY(tok.stop_possible());\n+  VERIFY(!tok.stop_requested());\n+\n+  std::stop_token copy(tok);\n+  VERIFY(copy == tok);\n+  VERIFY(copy.stop_possible());\n+  VERIFY(!copy.stop_requested());\n+  VERIFY(tok.stop_possible());\n+  VERIFY(!tok.stop_requested());\n+\n+  std::stop_token move(std::move(tok));\n+  VERIFY(move != tok);\n+  VERIFY(move == copy);\n+  VERIFY(move.stop_possible());\n+  VERIFY(!move.stop_requested());\n+  VERIFY(!tok.stop_possible());\n+  VERIFY(!tok.stop_requested());\n+  VERIFY(copy.stop_possible());\n+  VERIFY(!copy.stop_requested());\n+\n+  ssrc.request_stop();\n+  VERIFY(move.stop_possible());\n+  VERIFY(move.stop_requested());\n+  VERIFY(!tok.stop_possible());\n+  VERIFY(!tok.stop_requested());\n+  VERIFY(copy.stop_possible());\n+  VERIFY(copy.stop_requested());\n+\n+  tok.swap(move);\n+  VERIFY(tok == copy);\n+  VERIFY(!move.stop_possible());\n+  VERIFY(!move.stop_requested());\n+  VERIFY(tok.stop_possible());\n+  VERIFY(tok.stop_requested());\n+  VERIFY(copy.stop_possible());\n+  VERIFY(copy.stop_requested());\n+\n+  swap(move, copy);\n+  VERIFY(tok == move);\n+  VERIFY(move.stop_possible());\n+  VERIFY(move.stop_requested());\n+  VERIFY(tok.stop_possible());\n+  VERIFY(tok.stop_requested());\n+  VERIFY(!copy.stop_possible());\n+  VERIFY(!copy.stop_requested());\n+}\n+\n+void\n+test02()\n+{\n+  std::stop_source src1, src2;\n+  std::stop_token tok = src1.get_token();\n+  VERIFY(tok.stop_possible());\n+  VERIFY(!tok.stop_requested());\n+\n+  std::stop_token copy = src2.get_token();\n+  VERIFY(copy != tok);\n+  copy = tok;\n+  VERIFY(copy == tok);\n+  copy = src2.get_token();\n+  VERIFY(copy != tok);\n+}\n+\n+void\n+test03()\n {\n   // create stop_source\n   std::stop_source ssrc;\n@@ -77,8 +146,6 @@ int main()\n   b = ssrc.request_stop();\n   VERIFY(!b);\n \n-  // TODO verify the standard requires this\n-#if 0\n   // register another callback\n   bool cb3called{false};\n   std::stop_callback scb3{stok, [&]\n@@ -92,5 +159,11 @@ int main()\n   VERIFY(!cb1called);\n   VERIFY(cb2called);\n   VERIFY(cb3called);\n-#endif\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n }"}]}