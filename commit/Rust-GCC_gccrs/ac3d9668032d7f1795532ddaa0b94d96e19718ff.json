{"sha": "ac3d9668032d7f1795532ddaa0b94d96e19718ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMzZDk2NjgwMzJkN2YxNzk1NTMyZGRhYTBiOTRkOTZlMTk3MThmZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-05-20T16:03:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-20T16:03:41Z"}, "message": "alias.c: Clarify some comments.\n\n\t* alias.c: Clarify some comments.\n\t(record_base_value): REGNO is unsigned.\n\t* rtl.h (record_base_value): Likewise.\n\nFrom-SVN: r34051", "tree": {"sha": "36883636db7072f8b0eb62a5d29d93634fa5ac1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36883636db7072f8b0eb62a5d29d93634fa5ac1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac3d9668032d7f1795532ddaa0b94d96e19718ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3d9668032d7f1795532ddaa0b94d96e19718ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac3d9668032d7f1795532ddaa0b94d96e19718ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3d9668032d7f1795532ddaa0b94d96e19718ff/comments", "author": null, "committer": null, "parents": [{"sha": "dc1618bcad7b750f862a01b1a620c49390e578e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1618bcad7b750f862a01b1a620c49390e578e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc1618bcad7b750f862a01b1a620c49390e578e5"}], "stats": {"total": 70, "additions": 37, "deletions": 33}, "files": [{"sha": "18e8dfb67870e4ddcfad64723fc3d42b0fca947b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3d9668032d7f1795532ddaa0b94d96e19718ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3d9668032d7f1795532ddaa0b94d96e19718ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac3d9668032d7f1795532ddaa0b94d96e19718ff", "patch": "@@ -1,5 +1,9 @@\n Sat May 20 09:30:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* alias.c: Clarify some comments.\n+\t(record_base_value): REGNO is unsigned.\n+\t* rtl.h (record_base_value): Likewise.\n+\n \t* alias.c (aliases_everything_p): Don't special-case QImode here.\n \t* c-common.c (c_get_alias_set): Do it here.\n \tHandle BIT_FIELD_REF by getting alias info for arg."}, {"sha": "2f0392b83889a85d059fc8ec97161eed91d3d245", "filename": "gcc/alias.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3d9668032d7f1795532ddaa0b94d96e19718ff/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3d9668032d7f1795532ddaa0b94d96e19718ff/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ac3d9668032d7f1795532ddaa0b94d96e19718ff", "patch": "@@ -38,8 +38,8 @@ Boston, MA 02111-1307, USA.  */\n \n /* The alias sets assigned to MEMs assist the back-end in determining\n    which MEMs can alias which other MEMs.  In general, two MEMs in\n-   different alias sets to not alias each other.  There is one\n-   exception, however.  Consider something like:\n+   different alias sets cannot alias each other, with one important\n+   exception.  Consider something like:\n \n      struct S {int i; double d; };\n \n@@ -53,12 +53,14 @@ Boston, MA 02111-1307, USA.  */\n          |/_     _\\|\n          int    double\n \n-   (The arrows are directed and point downwards.)  If, when comparing\n-   two alias sets, we can hold one set fixed,  trace the other set\n-   downwards, and at some point find the first set, the two MEMs can\n-   alias one another.  In this situation we say the alias set for\n-   `struct S' is the `superset' and that those for `int' and `double'\n-   are `subsets'.  \n+   (The arrows are directed and point downwards.)\n+    In this situation we say the alias set for `struct S' is the\n+   `superset' and that those for `int' and `double' are `subsets'.\n+\n+   To see whether two alias sets can point to the same memory, we must go\n+   down the list of decendents of each and see if there is some alias set\n+   in common.  We need not trace past immediate decendents, however, since\n+   we propagate all grandchildren up one level.\n \n    Alias set zero is implicitly a superset of all other alias sets.\n    However, this is no actual entry for alias set zero.  It is an\n@@ -70,7 +72,7 @@ typedef struct alias_set_entry\n   int alias_set;\n \n   /* The children of the alias set.  These are not just the immediate\n-     children, but, in fact, all children.  So, if we have:\n+     children, but, in fact, all decendents.  So, if we have:\n \n        struct T { struct S s; float f; } \n \n@@ -111,9 +113,7 @@ static int nonlocal_reference_p         PARAMS ((rtx));\n   mems_in_disjoint_alias_sets_p (MEM1, MEM2)\n \n /* Cap the number of passes we make over the insns propagating alias\n-   information through set chains.\n-\n-   10 is a completely arbitrary choice.  */\n+   information through set chains.   10 is a completely arbitrary choice.  */\n #define MAX_ALIAS_LOOP_PASSES 10\n    \n /* reg_base_value[N] gives an address to which register N is related.\n@@ -164,25 +164,24 @@ static unsigned int reg_known_value_size;\n /* Vector recording for each reg_known_value whether it is due to a\n    REG_EQUIV note.  Future passes (viz., reload) may replace the\n    pseudo with the equivalent expression and so we account for the\n-   dependences that would be introduced if that happens. */\n-/* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in\n-   assign_parms mention the arg pointer, and there are explicit insns in the\n-   RTL that modify the arg pointer.  Thus we must ensure that such insns don't\n-   get scheduled across each other because that would invalidate the REG_EQUIV\n-   notes.  One could argue that the REG_EQUIV notes are wrong, but solving\n-   the problem in the scheduler will likely give better code, so we do it\n-   here.  */\n+   dependences that would be introduced if that happens.\n+\n+   The REG_EQUIV notes created in assign_parms may mention the arg\n+   pointer, and there are explicit insns in the RTL that modify the\n+   arg pointer.  Thus we must ensure that such insns don't get\n+   scheduled across each other because that would invalidate the\n+   REG_EQUIV notes.  One could argue that the REG_EQUIV notes are\n+   wrong, but solving the problem in the scheduler will likely give\n+   better code, so we do it here.  */\n char *reg_known_equiv_p;\n \n /* True when scanning insns from the start of the rtl to the\n    NOTE_INSN_FUNCTION_BEG note.  */\n-\n static int copying_arguments;\n \n /* The splay-tree used to store the various alias set entries.  */\n-\n static splay_tree alias_sets;\n-\n+\f\n /* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n    such an entry, or NULL otherwise.  */\n \n@@ -196,8 +195,8 @@ get_alias_set_entry (alias_set)\n   return sn != 0 ? ((alias_set_entry) sn->value) : 0;\n }\n \n-/* Returns nonzero value if the alias sets for MEM1 and MEM2 are such\n-   that the two MEMs cannot alias each other.  */\n+/* Returns nonzero if the alias sets for MEM1 and MEM2 are such that\n+   the two MEMs cannot alias each other.  */\n \n static int \n mems_in_disjoint_alias_sets_p (mem1, mem2)\n@@ -515,26 +514,27 @@ record_set (dest, set, data)\n   reg_seen[regno] = 1;\n }\n \n-/* Called from loop optimization when a new pseudo-register is created.  */\n+/* Called from loop optimization when a new pseudo-register is\n+   created.  It indicates that REGNO is being set to VAL.  f INVARIANT\n+   is true then this value also describes an invariant relationship\n+   which can be used to deduce that two registers with unknown values\n+   are different.  */\n \n void\n record_base_value (regno, val, invariant)\n-     int regno;\n+     unsigned int regno;\n      rtx val;\n      int invariant;\n {\n-  if ((unsigned) regno >= reg_base_value_size)\n+  if (regno >= reg_base_value_size)\n     return;\n \n-  /* If INVARIANT is true then this value also describes an invariant\n-     relationship which can be used to deduce that two registers with\n-     unknown values are different.  */\n   if (invariant && alias_invariant)\n     alias_invariant[regno] = val;\n \n   if (GET_CODE (val) == REG)\n     {\n-      if ((unsigned) REGNO (val) < reg_base_value_size)\n+      if (REGNO (val) < reg_base_value_size)\n \treg_base_value[regno] = reg_base_value[REGNO (val)];\n \n       return;"}, {"sha": "2de4b0ed300613de479bde5bda151b9fb465cc24", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3d9668032d7f1795532ddaa0b94d96e19718ff/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3d9668032d7f1795532ddaa0b94d96e19718ff/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ac3d9668032d7f1795532ddaa0b94d96e19718ff", "patch": "@@ -1823,7 +1823,7 @@ extern void init_alias_once\t\tPARAMS ((void));\n extern void init_alias_analysis\t\tPARAMS ((void));\n extern void end_alias_analysis\t\tPARAMS ((void));\n \n-extern void record_base_value\t\tPARAMS ((int, rtx, int));\n+extern void record_base_value\t\tPARAMS ((unsigned int, rtx, int));\n extern void record_alias_subset         PARAMS ((int, int));\n extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n "}]}