{"sha": "73e48cb322152bf504ced8694fa748544ecaa6eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNlNDhjYjMyMjE1MmJmNTA0Y2VkODY5NGZhNzQ4NTQ0ZWNhYTZlYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-01-14T15:30:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-01-14T15:30:12Z"}, "message": "alias.c (compare_base_symbol_refs): New function.\n\n\t* alias.c (compare_base_symbol_refs): New function.\n\t(rtx_equal_for_memref_p, base_alias_check, memrefs_conflict_p): Use\n\tit.\n\nFrom-SVN: r232369", "tree": {"sha": "4f8b3c573f28dd982c7f7ab6aba60ef9b04fc2aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f8b3c573f28dd982c7f7ab6aba60ef9b04fc2aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73e48cb322152bf504ced8694fa748544ecaa6eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e48cb322152bf504ced8694fa748544ecaa6eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73e48cb322152bf504ced8694fa748544ecaa6eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e48cb322152bf504ced8694fa748544ecaa6eb/comments", "author": null, "committer": null, "parents": [{"sha": "0c9b32949ef61409db3615aa7fe55ce51069b2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9b32949ef61409db3615aa7fe55ce51069b2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9b32949ef61409db3615aa7fe55ce51069b2e6"}], "stats": {"total": 104, "additions": 72, "deletions": 32}, "files": [{"sha": "d82f084276d14ee7309ba8d8e212788cd0100741", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e48cb322152bf504ced8694fa748544ecaa6eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e48cb322152bf504ced8694fa748544ecaa6eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73e48cb322152bf504ced8694fa748544ecaa6eb", "patch": "@@ -1,3 +1,9 @@\n+2016-01-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* alias.c (compare_base_symbol_refs): New function.\n+\t(rtx_equal_for_memref_p, base_alias_check, memrefs_conflict_p): Use\n+\tit.\n+\n 2016-01-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/68146"}, {"sha": "352ae091194836dcbc47cf51fa8a32a2b01e2943", "filename": "gcc/alias.c", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e48cb322152bf504ced8694fa748544ecaa6eb/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e48cb322152bf504ced8694fa748544ecaa6eb/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=73e48cb322152bf504ced8694fa748544ecaa6eb", "patch": "@@ -158,6 +158,7 @@ static tree decl_for_component_ref (tree);\n static int write_dependence_p (const_rtx,\n \t\t\t       const_rtx, machine_mode, rtx,\n \t\t\t       bool, bool, bool);\n+static int compare_base_symbol_refs (const_rtx, const_rtx);\n \n static void memory_modified_1 (rtx, const_rtx, void *);\n \n@@ -1756,15 +1757,7 @@ rtx_equal_for_memref_p (const_rtx x, const_rtx y)\n       return LABEL_REF_LABEL (x) == LABEL_REF_LABEL (y);\n \n     case SYMBOL_REF:\n-      {\n-\ttree x_decl = SYMBOL_REF_DECL (x);\n-\ttree y_decl = SYMBOL_REF_DECL (y);\n-\n-\tif (!x_decl || !y_decl)\n-\t  return XSTR (x, 0) == XSTR (y, 0);\n-\telse\n-\t  return compare_base_decls (x_decl, y_decl) == 1;\n-      }\n+      return compare_base_symbol_refs (x, y) == 1;\n \n     case ENTRY_VALUE:\n       /* This is magic, don't go through canonicalization et al.  */\n@@ -2056,6 +2049,67 @@ compare_base_decls (tree base1, tree base2)\n   return ret;\n }\n \n+/* Same as compare_base_decls but for SYMBOL_REF.  */\n+\n+static int\n+compare_base_symbol_refs (const_rtx x_base, const_rtx y_base)\n+{\n+  tree x_decl = SYMBOL_REF_DECL (x_base);\n+  tree y_decl = SYMBOL_REF_DECL (y_base);\n+  bool binds_def = true;\n+\n+  if (XSTR (x_base, 0) == XSTR (y_base, 0))\n+    return 1;\n+  if (x_decl && y_decl)\n+    return compare_base_decls (x_decl, y_decl);\n+  if (x_decl || y_decl)\n+    {\n+      if (!x_decl)\n+\t{\n+\t  std::swap (x_decl, y_decl);\n+\t  std::swap (x_base, y_base);\n+\t}\n+      /* We handle specially only section anchors and assume that other\n+ \t labels may overlap with user variables in an arbitrary way.  */\n+      if (!SYMBOL_REF_HAS_BLOCK_INFO_P (y_base))\n+        return -1;\n+      /* Anchors contains static VAR_DECLs and CONST_DECLs.  We are safe\n+\t to ignore CONST_DECLs because they are readonly.  */\n+      if (TREE_CODE (x_decl) != VAR_DECL\n+\t  || (!TREE_STATIC (x_decl) && !TREE_PUBLIC (x_decl)))\n+\treturn 0;\n+\n+      symtab_node *x_node = symtab_node::get_create (x_decl)\n+\t\t\t    ->ultimate_alias_target ();\n+      /* External variable can not be in section anchor.  */\n+      if (!x_node->definition)\n+\treturn 0;\n+      x_base = XEXP (DECL_RTL (x_node->decl), 0);\n+      /* If not in anchor, we can disambiguate.  */\n+      if (!SYMBOL_REF_HAS_BLOCK_INFO_P (x_base))\n+\treturn 0;\n+\n+      /* We have an alias of anchored variable.  If it can be interposed;\n+ \t we must assume it may or may not alias its anchor.  */\n+      binds_def = decl_binds_to_current_def_p (x_decl);\n+    }\n+  /* If we have variable in section anchor, we can compare by offset.  */\n+  if (SYMBOL_REF_HAS_BLOCK_INFO_P (x_base)\n+      && SYMBOL_REF_HAS_BLOCK_INFO_P (y_base))\n+    {\n+      if (SYMBOL_REF_BLOCK (x_base) != SYMBOL_REF_BLOCK (y_base))\n+\treturn 0;\n+      if (SYMBOL_REF_BLOCK_OFFSET (x_base) == SYMBOL_REF_BLOCK_OFFSET (y_base))\n+\treturn binds_def ? 1 : -1;\n+      if (SYMBOL_REF_ANCHOR_P (x_base) != SYMBOL_REF_ANCHOR_P (y_base))\n+\treturn -1;\n+      return 0;\n+    }\n+  /* In general we assume that memory locations pointed to by different labels\n+     may overlap in undefined ways.  */\n+  return -1;\n+}\n+\n /* Return 0 if the addresses X and Y are known to point to different\n    objects, 1 if they might be pointers to the same object.  */\n \n@@ -2111,18 +2165,10 @@ base_alias_check (rtx x, rtx x_base, rtx y, rtx y_base,\n \t  || (int) GET_MODE_UNIT_SIZE (x_mode) < -INTVAL (XEXP (y, 1))))\n     return 1;\n \n+  /* Differing symbols not accessed via AND never alias.  */\n   if (GET_CODE (x_base) == SYMBOL_REF && GET_CODE (y_base) == SYMBOL_REF)\n-    {\n-      tree x_decl = SYMBOL_REF_DECL (x_base);\n-      tree y_decl = SYMBOL_REF_DECL (y_base);\n-\n-      /* We can assume that no stores are made to labels.  */\n-      if (!x_decl || !y_decl)\n-\treturn 0;\n-      return compare_base_decls (x_decl, y_decl) != 0;\n-    }\n+    return compare_base_symbol_refs (x_base, y_base) != 0;\n \n-  /* Differing symbols not accessed via AND never alias.  */\n   if (GET_CODE (x_base) != ADDRESS && GET_CODE (y_base) != ADDRESS)\n     return 0;\n \n@@ -2327,19 +2373,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \n   if (GET_CODE (x) == SYMBOL_REF && GET_CODE (y) == SYMBOL_REF)\n     {\n-      tree x_decl = SYMBOL_REF_DECL (x);\n-      tree y_decl = SYMBOL_REF_DECL (y);\n-      int cmp;\n-\n-      if (!x_decl || !y_decl)\n-\t{\n-\t  /* Label and normal symbol are never the same. */\n-\t  if (x_decl != y_decl)\n-\t    return 0;\n-\t  return offset_overlap_p (c, xsize, ysize);\n-\t}\n-      else\n-        cmp = compare_base_decls (x_decl, y_decl);\n+      int cmp = compare_base_symbol_refs (x,y);\n \n       /* If both decls are the same, decide by offsets.  */\n       if (cmp == 1)"}]}