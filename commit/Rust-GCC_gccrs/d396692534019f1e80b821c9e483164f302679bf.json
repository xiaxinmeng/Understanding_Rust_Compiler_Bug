{"sha": "d396692534019f1e80b821c9e483164f302679bf", "node_id": "C_kwDOANBUbNoAKGQzOTY2OTI1MzQwMTlmMWU4MGI4MjFjOWU0ODMxNjRmMzAyNjc5YmY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T16:59:27Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T16:59:27Z"}, "message": "Add missing hir lowering to function type-path segments", "tree": {"sha": "e8a2e8751695106dd6f67ee40447ee8a514e398c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8a2e8751695106dd6f67ee40447ee8a514e398c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d396692534019f1e80b821c9e483164f302679bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d396692534019f1e80b821c9e483164f302679bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d396692534019f1e80b821c9e483164f302679bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d396692534019f1e80b821c9e483164f302679bf/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e09dfb538db9af6eb312ecd0a5a4e5931db201e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e09dfb538db9af6eb312ecd0a5a4e5931db201e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e09dfb538db9af6eb312ecd0a5a4e5931db201e"}], "stats": {"total": 479, "additions": 269, "deletions": 210}, "files": [{"sha": "18a5ef5f759967c7f7882d40578fac1e1561778a", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=d396692534019f1e80b821c9e483164f302679bf", "patch": "@@ -89,6 +89,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-lower-item.o \\\n     rust/rust-ast-lower-expr.o \\\n+    rust/rust-ast-lower-type.o \\\n     rust/rust-early-name-resolver.o \\\n     rust/rust-name-resolver.o \\\n     rust/rust-ast-resolve.o \\"}, {"sha": "46430548c5687d6d0023b21dab145a02b0ae3a2f", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=d396692534019f1e80b821c9e483164f302679bf", "patch": "@@ -898,6 +898,8 @@ struct TypePathFunction\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n+\n+  Location get_locus () const { return locus; }\n };\n \n // Segment used in type path with a function argument"}, {"sha": "592d9e810f9819e27a6dc66844443635184ba58e", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=d396692534019f1e80b821c9e483164f302679bf", "patch": "@@ -658,119 +658,6 @@ ASTLoweringBase::lower_self (AST::SelfParam &self)\n \t\t\t self.get_locus ());\n }\n \n-void\n-ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n-{\n-  std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n-\n-  std::string segment_name = segment.get_ident_segment ().as_string ();\n-  bool has_separating_scope_resolution\n-    = segment.get_separating_scope_resolution ();\n-\n-  auto generic_args = lower_generic_args (segment.get_generic_args ());\n-\n-  auto crate_num = mappings->get_current_crate ();\n-  auto hirid = mappings->get_next_hir_id (crate_num);\n-  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n-\t\t\t\t UNKNOWN_LOCAL_DEFID);\n-\n-  translated_segment\n-    = new HIR::TypePathSegmentGeneric (std::move (mapping), segment_name,\n-\t\t\t\t       has_separating_scope_resolution,\n-\t\t\t\t       generic_args, segment.get_locus ());\n-}\n-\n-void\n-ASTLowerQualifiedPathInType::visit (AST::QualifiedPathInType &path)\n-{\n-  auto crate_num = mappings->get_current_crate ();\n-  auto hirid = mappings->get_next_hir_id (crate_num);\n-  Analysis::NodeMapping qual_mappings (\n-    crate_num, path.get_qualified_path_type ().get_node_id (), hirid,\n-    UNKNOWN_LOCAL_DEFID);\n-\n-  HIR::Type *qual_type = ASTLoweringType::translate (\n-    path.get_qualified_path_type ().get_type ().get ());\n-  HIR::TypePath *qual_trait = ASTLowerTypePath::translate (\n-    path.get_qualified_path_type ().get_as_type_path ());\n-\n-  HIR::QualifiedPathType qual_path_type (\n-    qual_mappings, std::unique_ptr<HIR::Type> (qual_type),\n-    std::unique_ptr<HIR::TypePath> (qual_trait),\n-    path.get_qualified_path_type ().get_locus ());\n-\n-  translated_segment = nullptr;\n-  path.get_associated_segment ()->accept_vis (*this);\n-  if (translated_segment == nullptr)\n-    {\n-      rust_fatal_error (path.get_associated_segment ()->get_locus (),\n-\t\t\t\"failed to translate AST TypePathSegment\");\n-      return;\n-    }\n-  std::unique_ptr<HIR::TypePathSegment> associated_segment (translated_segment);\n-\n-  std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n-  for (auto &seg : path.get_segments ())\n-    {\n-      translated_segment = nullptr;\n-      seg->accept_vis (*this);\n-      if (translated_segment == nullptr)\n-\t{\n-\t  rust_fatal_error (seg->get_locus (),\n-\t\t\t    \"failed to translte AST TypePathSegment\");\n-\t}\n-      translated_segments.push_back (\n-\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n-    }\n-\n-  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n-\t\t\t\t mappings->get_next_localdef_id (crate_num));\n-  translated = new HIR::QualifiedPathInType (std::move (mapping),\n-\t\t\t\t\t     std::move (qual_path_type),\n-\t\t\t\t\t     std::move (associated_segment),\n-\t\t\t\t\t     std::move (translated_segments),\n-\t\t\t\t\t     path.get_locus ());\n-}\n-\n-void\n-ASTLoweringType::visit (AST::TraitObjectTypeOneBound &type)\n-{\n-  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n-  HIR::TypeParamBound *translated_bound\n-    = ASTLoweringTypeBounds::translate (&type.get_trait_bound ());\n-  bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (translated_bound));\n-\n-  auto crate_num = mappings->get_current_crate ();\n-  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n-\t\t\t\t mappings->get_next_hir_id (crate_num),\n-\t\t\t\t mappings->get_next_localdef_id (crate_num));\n-\n-  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n-\t\t\t\t\t type.get_locus (), type.is_dyn ());\n-}\n-\n-void\n-ASTLoweringType::visit (AST::TraitObjectType &type)\n-{\n-  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n-\n-  for (auto &bound : type.get_type_param_bounds ())\n-    {\n-      HIR::TypeParamBound *translated_bound\n-\t= ASTLoweringTypeBounds::translate (bound.get ());\n-      bounds.push_back (\n-\tstd::unique_ptr<HIR::TypeParamBound> (translated_bound));\n-    }\n-\n-  auto crate_num = mappings->get_current_crate ();\n-  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n-\t\t\t\t mappings->get_next_hir_id (crate_num),\n-\t\t\t\t mappings->get_next_localdef_id (crate_num));\n-\n-  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n-\t\t\t\t\t type.get_locus (), type.is_dyn ());\n-}\n-\n HIR::Type *\n ASTLoweringBase::lower_type_no_bounds (AST::TypeNoBounds *type)\n {"}, {"sha": "92a14f4dacf1273c8fce4f09a32ecbbbd0cd51b3", "filename": "gcc/rust/hir/rust-ast-lower-type.cc", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Frust-ast-lower-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Frust-ast-lower-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.cc?ref=d396692534019f1e80b821c9e483164f302679bf", "patch": "@@ -0,0 +1,232 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-type.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+HIR::TypePath *\n+ASTLowerTypePath::translate (AST::TypePath &type)\n+{\n+  ASTLowerTypePath resolver;\n+  type.accept_vis (resolver);\n+  rust_assert (resolver.translated != nullptr);\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePathSegmentFunction &segment)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+\n+  AST::TypePathFunction &fn = segment.get_type_path_function ();\n+  std::vector<std::unique_ptr<HIR::Type>> inputs;\n+  for (auto &param : fn.get_params ())\n+    {\n+      HIR::Type *hir_type = ASTLoweringType::translate (param.get ());\n+      inputs.push_back (std::unique_ptr<HIR::Type> (hir_type));\n+    }\n+\n+  HIR::Type *result_type\n+    = fn.has_return_type ()\n+\t? ASTLoweringType::translate (fn.get_return_type ().get ())\n+\t: nullptr;\n+\n+  HIR::TypePathFunction function_path (std::move (inputs),\n+\t\t\t\t       std::unique_ptr<HIR::Type> (\n+\t\t\t\t\t result_type));\n+\n+  translated_segment = new HIR::TypePathSegmentFunction (\n+    mapping, std::move (ident), segment.get_separating_scope_resolution (),\n+    std::move (function_path), segment.get_locus ());\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePathSegment &segment)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+  translated_segment\n+    = new HIR::TypePathSegment (std::move (mapping), ident,\n+\t\t\t\tsegment.get_separating_scope_resolution (),\n+\t\t\t\tsegment.get_locus ());\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n+{\n+  std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n+\n+  std::string segment_name = segment.get_ident_segment ().as_string ();\n+  bool has_separating_scope_resolution\n+    = segment.get_separating_scope_resolution ();\n+\n+  auto generic_args = lower_generic_args (segment.get_generic_args ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated_segment\n+    = new HIR::TypePathSegmentGeneric (std::move (mapping), segment_name,\n+\t\t\t\t       has_separating_scope_resolution,\n+\t\t\t\t       generic_args, segment.get_locus ());\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePath &path)\n+{\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n+\n+  for (auto &seg : path.get_segments ())\n+    {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translate AST TypePathSegment\");\n+\t}\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n+\t\t\t path.get_locus (),\n+\t\t\t path.has_opening_scope_resolution_op ());\n+}\n+\n+HIR::QualifiedPathInType *\n+ASTLowerQualifiedPathInType::translate (AST::QualifiedPathInType &type)\n+{\n+  ASTLowerQualifiedPathInType resolver;\n+  type.accept_vis (resolver);\n+  rust_assert (resolver.translated != nullptr);\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLowerQualifiedPathInType::visit (AST::QualifiedPathInType &path)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping qual_mappings (\n+    crate_num, path.get_qualified_path_type ().get_node_id (), hirid,\n+    UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Type *qual_type = ASTLoweringType::translate (\n+    path.get_qualified_path_type ().get_type ().get ());\n+  HIR::TypePath *qual_trait = ASTLowerTypePath::translate (\n+    path.get_qualified_path_type ().get_as_type_path ());\n+\n+  HIR::QualifiedPathType qual_path_type (\n+    qual_mappings, std::unique_ptr<HIR::Type> (qual_type),\n+    std::unique_ptr<HIR::TypePath> (qual_trait),\n+    path.get_qualified_path_type ().get_locus ());\n+\n+  translated_segment = nullptr;\n+  path.get_associated_segment ()->accept_vis (*this);\n+  if (translated_segment == nullptr)\n+    {\n+      rust_fatal_error (path.get_associated_segment ()->get_locus (),\n+\t\t\t\"failed to translate AST TypePathSegment\");\n+      return;\n+    }\n+  std::unique_ptr<HIR::TypePathSegment> associated_segment (translated_segment);\n+\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n+  for (auto &seg : path.get_segments ())\n+    {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translte AST TypePathSegment\");\n+\t}\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+    }\n+\n+  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+  translated = new HIR::QualifiedPathInType (std::move (mapping),\n+\t\t\t\t\t     std::move (qual_path_type),\n+\t\t\t\t\t     std::move (associated_segment),\n+\t\t\t\t\t     std::move (translated_segments),\n+\t\t\t\t\t     path.get_locus ());\n+}\n+\n+void\n+ASTLoweringType::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n+  HIR::TypeParamBound *translated_bound\n+    = ASTLoweringTypeBounds::translate (&type.get_trait_bound ());\n+  bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (translated_bound));\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n+}\n+\n+void\n+ASTLoweringType::visit (AST::TraitObjectType &type)\n+{\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n+\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      HIR::TypeParamBound *translated_bound\n+\t= ASTLoweringTypeBounds::translate (bound.get ());\n+      bounds.push_back (\n+\tstd::unique_ptr<HIR::TypeParamBound> (translated_bound));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "d593b4808290600937d92506c08d557133d6a1c0", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 5, "deletions": 58, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=d396692534019f1e80b821c9e483164f302679bf", "patch": "@@ -32,59 +32,12 @@ class ASTLowerTypePath : public ASTLoweringBase\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n-  static HIR::TypePath *translate (AST::TypePath &type)\n-  {\n-    ASTLowerTypePath resolver;\n-    type.accept_vis (resolver);\n-    rust_assert (resolver.translated != nullptr);\n-    return resolver.translated;\n-  }\n-\n-  void visit (AST::TypePathSegmentFunction &) override { gcc_unreachable (); }\n-\n-  void visit (AST::TypePathSegment &segment) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    auto hirid = mappings->get_next_hir_id (crate_num);\n-    Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n-    translated_segment\n-      = new HIR::TypePathSegment (std::move (mapping), ident,\n-\t\t\t\t  segment.get_separating_scope_resolution (),\n-\t\t\t\t  segment.get_locus ());\n-  }\n+  static HIR::TypePath *translate (AST::TypePath &type);\n \n+  void visit (AST::TypePathSegmentFunction &segment) override;\n+  void visit (AST::TypePathSegment &segment) override;\n   void visit (AST::TypePathSegmentGeneric &segment) override;\n-\n-  void visit (AST::TypePath &path) override\n-  {\n-    std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n-\n-    for (auto &seg : path.get_segments ())\n-      {\n-\ttranslated_segment = nullptr;\n-\tseg->accept_vis (*this);\n-\tif (translated_segment == nullptr)\n-\t  {\n-\t    rust_fatal_error (seg->get_locus (),\n-\t\t\t      \"failed to translate AST TypePathSegment\");\n-\t  }\n-\ttranslated_segments.push_back (\n-\t  std::unique_ptr<HIR::TypePathSegment> (translated_segment));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    auto hirid = mappings->get_next_hir_id (crate_num);\n-    Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated\n-      = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n-\t\t\t   path.get_locus (),\n-\t\t\t   path.has_opening_scope_resolution_op ());\n-  }\n+  void visit (AST::TypePath &path) override;\n \n protected:\n   HIR::TypePathSegment *translated_segment;\n@@ -98,13 +51,7 @@ class ASTLowerQualifiedPathInType : public ASTLowerTypePath\n   using ASTLowerTypePath::visit;\n \n public:\n-  static HIR::QualifiedPathInType *translate (AST::QualifiedPathInType &type)\n-  {\n-    ASTLowerQualifiedPathInType resolver;\n-    type.accept_vis (resolver);\n-    rust_assert (resolver.translated != nullptr);\n-    return resolver.translated;\n-  }\n+  static HIR::QualifiedPathInType *translate (AST::QualifiedPathInType &type);\n \n   void visit (AST::QualifiedPathInType &path) override;\n "}, {"sha": "06f3acbf904880ade0fb82530e4e35d1d38585f3", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d396692534019f1e80b821c9e483164f302679bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=d396692534019f1e80b821c9e483164f302679bf", "patch": "@@ -529,56 +529,29 @@ class TypePathSegmentGeneric : public TypePathSegment\n struct TypePathFunction\n {\n private:\n-  // TODO: remove\n-  /*bool has_inputs;\n-  TypePathFnInputs inputs;*/\n-  // inlined from TypePathFnInputs\n   std::vector<std::unique_ptr<Type> > inputs;\n-\n-  // bool has_type;\n   std::unique_ptr<Type> return_type;\n \n-  // FIXME: think of better way to mark as invalid than taking up storage\n-  bool is_invalid;\n-\n-  // TODO: should this have location info?\n-\n-protected:\n-  // Constructor only used to create invalid type path functions.\n-  TypePathFunction (bool is_invalid) : is_invalid (is_invalid) {}\n-\n public:\n   // Returns whether the return type of the function has been specified.\n   bool has_return_type () const { return return_type != nullptr; }\n \n   // Returns whether the function has inputs.\n   bool has_inputs () const { return !inputs.empty (); }\n \n-  // Returns whether function is in an error state.\n-  bool is_error () const { return is_invalid; }\n-\n-  // Creates an error state function.\n-  static TypePathFunction create_error () { return TypePathFunction (true); }\n-\n-  // Constructor\n-  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n-\t\t    Type *type = nullptr)\n-    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n-  {}\n-  // FIXME: deprecated\n-\n   // Constructor\n   TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n-\t\t    std::unique_ptr<Type> type = nullptr)\n-    : inputs (std::move (inputs)), return_type (std::move (type)),\n-      is_invalid (false)\n+\t\t    std::unique_ptr<Type> type)\n+    : inputs (std::move (inputs)), return_type (std::move (type))\n   {}\n \n   // Copy constructor with clone\n   TypePathFunction (TypePathFunction const &other)\n-    : return_type (other.return_type->clone_type ()),\n-      is_invalid (other.is_invalid)\n   {\n+    return_type = other.has_return_type ()\n+\t\t    ? other.get_return_type ()->clone_type ()\n+\t\t    : nullptr;\n+\n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n       inputs.push_back (e->clone_type ());\n@@ -589,8 +562,9 @@ struct TypePathFunction\n   // Overloaded assignment operator to clone type\n   TypePathFunction &operator= (TypePathFunction const &other)\n   {\n-    return_type = other.return_type->clone_type ();\n-    is_invalid = other.is_invalid;\n+    return_type = other.has_return_type ()\n+\t\t    ? other.get_return_type ()->clone_type ()\n+\t\t    : nullptr;\n \n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n@@ -604,6 +578,23 @@ struct TypePathFunction\n   TypePathFunction &operator= (TypePathFunction &&other) = default;\n \n   std::string as_string () const;\n+\n+  const std::vector<std::unique_ptr<Type> > &get_params () const\n+  {\n+    return inputs;\n+  };\n+  std::vector<std::unique_ptr<Type> > &get_params () { return inputs; };\n+\n+  const std::unique_ptr<Type> &get_return_type () const\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  };\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  };\n };\n \n // Segment used in type path with a function argument\n@@ -638,10 +629,9 @@ class TypePathSegmentFunction : public TypePathSegment\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n-  virtual SegmentType get_type () const override final\n-  {\n-    return SegmentType::FUNCTION;\n-  }\n+  SegmentType get_type () const override final { return SegmentType::FUNCTION; }\n+\n+  TypePathFunction &get_function_path () { return function_path; }\n \n protected:\n   // Use covariance to override base class method"}]}