{"sha": "fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQwOWFjMGNmNzEyZTdkZmJkMjViY2NmZjFkYjgxMDE5M2NjN2IxNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-01-06T11:23:02Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-01-06T11:23:02Z"}, "message": "stl_bvector.h (vector<bool>::erase(iterator, iterator)): Just use _M_erase_at_end.\n\n2006-01-06  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_bvector.h (vector<bool>::erase(iterator,\n\titerator)): Just use _M_erase_at_end.\n\n2006-01-06  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_bvector.h (class vector<bool>): Move all the\n\thelpers under protected access mode, consistently with the primary\n\tvector template.\n\t(vector<bool>::_M_erase_at_end): Add.\n\t(erase(iterator, iterator), clear, resize, _M_fill_assign,\n\t_M_assign_aux): Use it.\n\t* testsuite/23_containers/vector/bool/modifiers/erase/1.cc: New.\n\n2006-01-06  Paolo Carlini  <pcarlini@suse.de>\n\n\tImplement Option 3 of DR 431 for vector<bool>.\n\t* include/bits/stl_bvector.h (class _Bvector_base): Change to\n\ta struct, consistently with the primary vector template.\n\t(class vector<bool>): Adjust to protected inheritance, tidy\n\ttypedefs.\n\t(_Bvector_base<>::_M_get_Bit_allocator): Add.\n\t(vector<bool>::vector(const vector&)): Use it.\n\t(_Bvector_base<>::get_allocator): Tidy.\n\t(vector<bool>::swap): Use __alloc_swap.\n\t* testsuite/23_containers/vector/bool/modifiers/swap/1.cc: New.\n\t* testsuite/23_containers/vector/bool/modifiers/swap/2.cc: New.\n\nFrom-SVN: r109415", "tree": {"sha": "5c5d68f67095396c65547723f5fcabeee009b783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c5d68f67095396c65547723f5fcabeee009b783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/comments", "author": null, "committer": null, "parents": [{"sha": "1b40bdc4abd63c203da2cf149e074bfa67f85533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b40bdc4abd63c203da2cf149e074bfa67f85533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b40bdc4abd63c203da2cf149e074bfa67f85533"}], "stats": {"total": 1135, "additions": 818, "deletions": 317}, "files": [{"sha": "963e6e4e95a32158dff3a61b088bca99d4ce227a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "patch": "@@ -1,3 +1,32 @@\n+2006-01-06  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_bvector.h (vector<bool>::erase(iterator,\n+\titerator)): Just use _M_erase_at_end.\n+\n+2006-01-06  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_bvector.h (class vector<bool>): Move all the\n+\thelpers under protected access mode, consistently with the primary\n+\tvector template.\n+\t(vector<bool>::_M_erase_at_end): Add.\n+\t(erase(iterator, iterator), clear, resize, _M_fill_assign,\n+\t_M_assign_aux): Use it.\n+\t* testsuite/23_containers/vector/bool/modifiers/erase/1.cc: New.\n+\n+2006-01-06  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tImplement Option 3 of DR 431 for vector<bool>.\n+\t* include/bits/stl_bvector.h (class _Bvector_base): Change to\n+\ta struct, consistently with the primary vector template.\n+\t(class vector<bool>): Adjust to protected inheritance, tidy\n+\ttypedefs.\n+\t(_Bvector_base<>::_M_get_Bit_allocator): Add.\n+\t(vector<bool>::vector(const vector&)): Use it.\n+\t(_Bvector_base<>::get_allocator): Tidy.\n+\t(vector<bool>::swap): Use __alloc_swap.\n+\t* testsuite/23_containers/vector/bool/modifiers/swap/1.cc: New.\n+\t* testsuite/23_containers/vector/bool/modifiers/swap/2.cc: New.\n+\n 2006-01-05  Paolo Carlini  <pcarlini@suse.de>\n \t\n \t* testsuite/testsuite_hooks.h (test_tm(unsigned)): Change to\n@@ -32,7 +61,7 @@\n \t* testsuite/22_locale/time_get/get_monthname/wchar_t/1.cc: Likewise.\n \t* testsuite/22_locale/time_get/get_monthname/wchar_t/2.cc: Likewise.\n \t* testsuite/22_locale/time_get/get_monthname/char/1.cc: Likewise.\n- \t* testsuite/22_locale/time_get/get_monthname/char/2.cc: Likewise.\n+\t* testsuite/22_locale/time_get/get_monthname/char/2.cc: Likewise.\n \t* testsuite/22_locale/time_get/get_weekday/wchar_t/1.cc: Likewise.\n \t* testsuite/22_locale/time_get/get_weekday/wchar_t/2.cc: Likewise.\n \t* testsuite/22_locale/time_get/get_weekday/wchar_t/3.cc: Likewise."}, {"sha": "ab65710a1fb1a233bd2f529fd295a0db6335e6a2", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 330, "deletions": 316, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "patch": "@@ -1,6 +1,7 @@\n // vector<bool> specialization -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -354,12 +355,13 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n   { return __x + __n; }\n \n   template<class _Alloc>\n-    class _Bvector_base\n+    struct _Bvector_base\n     {\n       typedef typename _Alloc::template rebind<_Bit_type>::other\n         _Bit_alloc_type;\n       \n-      struct _Bvector_impl : public _Bit_alloc_type\n+      struct _Bvector_impl\n+      : public _Bit_alloc_type\n       {\n \t_Bit_iterator \t_M_start;\n \t_Bit_iterator \t_M_finish;\n@@ -372,9 +374,17 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n     public:\n       typedef _Alloc allocator_type;\n \n+      _Bit_alloc_type&\n+      _M_get_Bit_allocator()\n+      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }\n+\n+      const _Bit_alloc_type&\n+      _M_get_Bit_allocator() const\n+      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }\n+\n       allocator_type\n       get_allocator() const\n-      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }\n+      { return allocator_type(_M_get_Bit_allocator()); }\n \n       _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }\n \n@@ -424,139 +434,96 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n    *  also provided as with C-style arrays.\n   */\n template<typename _Alloc>\n-  class vector<bool, _Alloc> : public _Bvector_base<_Alloc>\n+  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>\n   {\n-  public:\n-    typedef bool value_type;\n-    typedef size_t size_type;\n-    typedef ptrdiff_t difference_type;\n-    typedef _Bit_reference reference;\n-    typedef bool const_reference;\n-    typedef _Bit_reference* pointer;\n-    typedef const bool* const_pointer;\n-\n-    typedef _Bit_iterator                iterator;\n-    typedef _Bit_const_iterator          const_iterator;\n-\n-    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n-    typedef std::reverse_iterator<iterator> reverse_iterator;\n+    typedef _Bvector_base<_Alloc>\t\t\t _Base;\n \n-    typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;\n+  public:\n+    typedef bool                                         value_type;\n+    typedef size_t                                       size_type;\n+    typedef ptrdiff_t                                    difference_type;\n+    typedef _Bit_reference                               reference;\n+    typedef bool                                         const_reference;\n+    typedef _Bit_reference*                              pointer;\n+    typedef const bool*                                  const_pointer;\n+    typedef _Bit_iterator                                iterator;\n+    typedef _Bit_const_iterator                          const_iterator;\n+    typedef std::reverse_iterator<const_iterator>        const_reverse_iterator;\n+    typedef std::reverse_iterator<iterator>              reverse_iterator;\n+    typedef _Alloc                        \t\t allocator_type;\n \n     allocator_type get_allocator() const\n-    { return _Bvector_base<_Alloc>::get_allocator(); }\n+    { return _Base::get_allocator(); }\n \n   protected:\n-    using _Bvector_base<_Alloc>::_M_allocate;\n-    using _Bvector_base<_Alloc>::_M_deallocate;\n+    using _Base::_M_allocate;\n+    using _Base::_M_deallocate;\n+    using _Base::_M_get_Bit_allocator;\n \n-  protected:\n-    void\n-    _M_initialize(size_type __n)\n+  public:\n+    explicit\n+    vector(const allocator_type& __a = allocator_type())\n+    : _Base(__a) { }\n+\n+    explicit\n+    vector(size_type __n, const bool& __value = bool(), \n+\t   const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n     {\n-      _Bit_type* __q = this->_M_allocate(__n);\n-      this->_M_impl._M_end_of_storage = (__q\n-\t\t\t\t\t + ((__n + int(_S_word_bit) - 1)\n-\t\t\t\t\t    / int(_S_word_bit)));\n-      this->_M_impl._M_start = iterator(__q, 0);\n-      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);\n+      _M_initialize(__n);\n+      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, \n+\t\t__value ? ~0 : 0);\n     }\n \n-    void\n-    _M_insert_aux(iterator __position, bool __x)\n+    vector(const vector& __x)\n+    : _Base(__x._M_get_Bit_allocator())\n     {\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n-\t{\n-\t  std::copy_backward(__position, this->_M_impl._M_finish, \n-\t\t\t     this->_M_impl._M_finish + 1);\n-\t  *__position = __x;\n-\t  ++this->_M_impl._M_finish;\n-\t}\n-      else\n-\t{\n-\t  const size_type __len = size() ? 2 * size()\n-\t                                 : static_cast<size_type>(_S_word_bit);\n-\t  _Bit_type * __q = this->_M_allocate(__len);\n-\t  iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n-\t  *__i++ = __x;\n-\t  this->_M_impl._M_finish = std::copy(__position, end(), __i);\n-\t  this->_M_deallocate();\n-\t  this->_M_impl._M_end_of_storage = (__q + ((__len\n-\t\t\t\t\t\t     + int(_S_word_bit) - 1)\n-\t\t\t\t\t\t    / int(_S_word_bit)));\n-\t  this->_M_impl._M_start = iterator(__q, 0);\n-\t}\n+      _M_initialize(__x.size());\n+      std::copy(__x.begin(), __x.end(), this->_M_impl._M_start);\n     }\n \n     template<class _InputIterator>\n-      void\n-      _M_initialize_range(_InputIterator __first, _InputIterator __last,\n-\t\t\t  std::input_iterator_tag)\n+      vector(_InputIterator __first, _InputIterator __last,\n+\t     const allocator_type& __a = allocator_type())\n+      : _Base(__a)\n       {\n-\tthis->_M_impl._M_start = iterator();\n-\tthis->_M_impl._M_finish = iterator();\n-\tthis->_M_impl._M_end_of_storage = 0;\n-\tfor (; __first != __last; ++__first)\n-\t  push_back(*__first);\n+\ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+\t_M_initialize_dispatch(__first, __last, _Integral());\n       }\n \n-    template<class _ForwardIterator>\n-      void\n-      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t\t  std::forward_iterator_tag)\n-      {\n-\tconst size_type __n = std::distance(__first, __last);\n-\t_M_initialize(__n);\n-\tstd::copy(__first, __last, this->_M_impl._M_start);\n-      }\n+    ~vector() { }\n \n-    template<class _InputIterator>\n-      void\n-      _M_insert_range(iterator __pos, _InputIterator __first, \n-\t\t      _InputIterator __last, std::input_iterator_tag)\n-      {\n-\tfor (; __first != __last; ++__first)\n-\t  {\n-\t    __pos = insert(__pos, *__first);\n-\t    ++__pos;\n-\t  }\n-      }\n+    vector&\n+    operator=(const vector& __x)\n+    {\n+      if (&__x == this)\n+\treturn *this;\n+      if (__x.size() > capacity())\n+\t{\n+\t  this->_M_deallocate();\n+\t  _M_initialize(__x.size());\n+\t}\n+      std::copy(__x.begin(), __x.end(), begin());\n+      this->_M_impl._M_finish = begin() + difference_type(__x.size());\n+      return *this;\n+    }\n \n-    template<class _ForwardIterator>\n+    // assign(), a generalized assignment member function.  Two\n+    // versions: one that takes a count, and one that takes a range.\n+    // The range version is a member template, so we dispatch on whether\n+    // or not the type is an integer.\n+    void\n+    assign(size_type __n, const bool& __x)\n+    { _M_fill_assign(__n, __x); }\n+\n+    template<class _InputIterator>\n       void\n-      _M_insert_range(iterator __position, _ForwardIterator __first, \n-\t\t      _ForwardIterator __last, std::forward_iterator_tag)\n+      assign(_InputIterator __first, _InputIterator __last)\n       {\n-\tif (__first != __last)\n-\t  {\n-\t    size_type __n = std::distance(__first, __last);\n-\t    if (capacity() - size() >= __n)\n-\t      {\n-\t\tstd::copy_backward(__position, end(),\n-\t\t\t\t   this->_M_impl._M_finish\n-\t\t\t\t   + difference_type(__n));\n-\t\tstd::copy(__first, __last, __position);\n-\t\tthis->_M_impl._M_finish += difference_type(__n);\n-\t      }\n-\t    else\n-\t      {\n-\t\tconst size_type __len = size() + std::max(size(), __n);\n-\t\t_Bit_type * __q = this->_M_allocate(__len);\n-\t\titerator __i = std::copy(begin(), __position,\n-\t\t\t\t\t iterator(__q, 0));\n-\t\t__i = std::copy(__first, __last, __i);\n-\t\tthis->_M_impl._M_finish = std::copy(__position, end(), __i);\n-\t\tthis->_M_deallocate();\n-\t\tthis->_M_impl._M_end_of_storage = (__q\n-\t\t\t\t\t\t   + ((__len\n-\t\t\t\t\t\t       + int(_S_word_bit) - 1)\n-\t\t\t\t\t\t      / int(_S_word_bit)));\n-\t\tthis->_M_impl._M_start = iterator(__q, 0);\n-\t      }\n-\t  }\n+\ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+\t_M_assign_dispatch(__first, __last, _Integral());\n       }\n \n-  public:\n     iterator\n     begin()\n     { return this->_M_impl._M_start; }\n@@ -601,6 +568,7 @@ template<typename _Alloc>\n     capacity() const\n     { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)\n \t\t       - begin()); }\n+\n     bool\n     empty() const\n     { return begin() == end(); }\n@@ -613,13 +581,15 @@ template<typename _Alloc>\n     operator[](size_type __n) const\n     { return *(begin() + difference_type(__n)); }\n \n+  protected:\n     void\n     _M_range_check(size_type __n) const\n     {\n       if (__n >= this->size())\n         __throw_out_of_range(__N(\"vector<bool>::_M_range_check\"));\n     }\n \n+  public:\n     reference\n     at(size_type __n)\n     { _M_range_check(__n); return (*this)[__n]; }\n@@ -628,110 +598,196 @@ template<typename _Alloc>\n     at(size_type __n) const\n     { _M_range_check(__n); return (*this)[__n]; }\n \n-    explicit\n-    vector(const allocator_type& __a = allocator_type())\n-    : _Bvector_base<_Alloc>(__a) { }\n-\n-    vector(size_type __n, bool __value, \n-\t   const allocator_type& __a = allocator_type())\n-    : _Bvector_base<_Alloc>(__a)\n+    void\n+    reserve(size_type __n)\n     {\n-      _M_initialize(__n);\n-      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, \n-\t\t__value ? ~0 : 0);\n+      if (__n > this->max_size())\n+\t__throw_length_error(__N(\"vector::reserve\"));\n+      if (this->capacity() < __n)\n+\t{\n+\t  _Bit_type* __q = this->_M_allocate(__n);\n+\t  this->_M_impl._M_finish = std::copy(begin(), end(), \n+\t\t\t\t\t      iterator(__q, 0));\n+\t  this->_M_deallocate();\n+\t  this->_M_impl._M_start = iterator(__q, 0);\n+\t  this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)\n+\t\t\t\t\t     / int(_S_word_bit));\n+\t}\n     }\n \n-    explicit\n-    vector(size_type __n)\n-    : _Bvector_base<_Alloc>(allocator_type())\n+    reference\n+    front()\n+    { return *begin(); }\n+\n+    const_reference\n+    front() const\n+    { return *begin(); }\n+\n+    reference\n+    back()\n+    { return *(end() - 1); }\n+\n+    const_reference\n+    back() const\n+    { return *(end() - 1); }\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // DR 464. Suggestion for new member functions in standard containers.\n+    // N.B. DR 464 says nothing about vector<bool> but we need something\n+    // here due to the way we are implementing DR 464 in the debug-mode\n+    // vector class.\n+    void\n+    data() { }\n+\n+    void\n+    push_back(bool __x)\n     {\n-      _M_initialize(__n);\n-      std::fill(this->_M_impl._M_start._M_p, \n-\t\tthis->_M_impl._M_end_of_storage, 0);\n+      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n+        *this->_M_impl._M_finish++ = __x;\n+      else\n+        _M_insert_aux(end(), __x);\n     }\n \n-    vector(const vector& __x)\n-    : _Bvector_base<_Alloc>(__x.get_allocator())\n+    void\n+    swap(vector<bool, _Alloc>& __x)\n     {\n-      _M_initialize(__x.size());\n-      std::copy(__x.begin(), __x.end(), this->_M_impl._M_start);\n+      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n+      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n+      std::swap(this->_M_impl._M_end_of_storage, \n+\t\t__x._M_impl._M_end_of_storage);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<typename _Base::_Bit_alloc_type>::\n+\t_S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());\n     }\n \n-    // Check whether it's an integral type.  If so, it's not an iterator.\n-    template<class _Integer>\n-      void\n-      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n-      {\n-\t_M_initialize(__n);\n-\tstd::fill(this->_M_impl._M_start._M_p, \n-\t\t  this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n-      }\n+    // [23.2.5]/1, third-to-last entry in synopsis listing\n+    static void\n+    swap(reference __x, reference __y)\n+    {\n+      bool __tmp = __x;\n+      __x = __y;\n+      __y = __tmp;\n+    }\n \n-    template<class _InputIterator>\n-      void \n-      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n-\t\t\t     __false_type)\n-      { _M_initialize_range(__first, __last, \n-\t\t\t    std::__iterator_category(__first)); }\n+    iterator\n+    insert(iterator __position, const bool& __x = bool())\n+    {\n+      const difference_type __n = __position - begin();\n+      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage\n+\t  && __position == end())\n+        *this->_M_impl._M_finish++ = __x;\n+      else\n+        _M_insert_aux(__position, __x);\n+      return begin() + __n;\n+    }\n \n     template<class _InputIterator>\n-      vector(_InputIterator __first, _InputIterator __last,\n-\t     const allocator_type& __a = allocator_type())\n-      : _Bvector_base<_Alloc>(__a)\n+      void\n+      insert(iterator __position,\n+\t     _InputIterator __first, _InputIterator __last)\n       {\n \ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n-\t_M_initialize_dispatch(__first, __last, _Integral());\n+\t_M_insert_dispatch(__position, __first, __last, _Integral());\n       }\n \n-    ~vector() { }\n+    void\n+    insert(iterator __position, size_type __n, const bool& __x)\n+    { _M_fill_insert(__position, __n, __x); }\n \n-    vector&\n-    operator=(const vector& __x)\n-    {\n-      if (&__x == this)\n-\treturn *this;\n-      if (__x.size() > capacity())\n-\t{\n-\t  this->_M_deallocate();\n-\t  _M_initialize(__x.size());\n-\t}\n-      std::copy(__x.begin(), __x.end(), begin());\n-      this->_M_impl._M_finish = begin() + difference_type(__x.size());\n-      return *this;\n+    void\n+    pop_back()\n+    { --this->_M_impl._M_finish; }\n+\n+    iterator\n+    erase(iterator __position)\n+    {\n+      if (__position + 1 != end())\n+        std::copy(__position + 1, end(), __position);\n+      --this->_M_impl._M_finish;\n+      return __position;\n     }\n \n-    // assign(), a generalized assignment member function.  Two\n-    // versions: one that takes a count, and one that takes a range.\n-    // The range version is a member template, so we dispatch on whether\n-    // or not the type is an integer.\n+    iterator\n+    erase(iterator __first, iterator __last)\n+    {\n+      _M_erase_at_end(std::copy(__last, end(), __first));\n+      return __first;\n+    }\n \n     void\n-    _M_fill_assign(size_t __n, bool __x)\n+    resize(size_type __new_size, bool __x = bool())\n     {\n-      if (__n > size())\n-\t{\n-\t  std::fill(this->_M_impl._M_start._M_p, \n-\t\t    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n-\t  insert(end(), __n - size(), __x);\n-\t}\n+      if (__new_size < size())\n+        _M_erase_at_end(begin() + difference_type(__new_size));\n       else\n-\t{\n-\t  erase(begin() + __n, end());\n-\t  std::fill(this->_M_impl._M_start._M_p, \n-\t\t    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n-\t}\n+        insert(end(), __new_size - size(), __x);\n     }\n \n     void\n-    assign(size_t __n, bool __x)\n-    { _M_fill_assign(__n, __x); }\n+    flip()\n+    {\n+      for (_Bit_type * __p = this->_M_impl._M_start._M_p;\n+\t   __p != this->_M_impl._M_end_of_storage; ++__p)\n+        *__p = ~*__p;\n+    }\n+\n+    void\n+    clear()\n+    { _M_erase_at_end(begin()); }\n+\n+   \n+  protected:\n+\n+    void\n+    _M_initialize(size_type __n)\n+    {\n+      _Bit_type* __q = this->_M_allocate(__n);\n+      this->_M_impl._M_end_of_storage = (__q\n+\t\t\t\t\t + ((__n + int(_S_word_bit) - 1)\n+\t\t\t\t\t    / int(_S_word_bit)));\n+      this->_M_impl._M_start = iterator(__q, 0);\n+      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);\n+    }\n+\n+    // Check whether it's an integral type.  If so, it's not an iterator.\n+    template<class _Integer>\n+      void\n+      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+      {\n+\t_M_initialize(__n);\n+\tstd::fill(this->_M_impl._M_start._M_p, \n+\t\t  this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n+      }\n+\n+    template<class _InputIterator>\n+      void \n+      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t     __false_type)\n+      { _M_initialize_range(__first, __last, \n+\t\t\t    std::__iterator_category(__first)); }\n \n     template<class _InputIterator>\n       void\n-      assign(_InputIterator __first, _InputIterator __last)\n+      _M_initialize_range(_InputIterator __first, _InputIterator __last,\n+\t\t\t  std::input_iterator_tag)\n       {\n-\ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n-\t_M_assign_dispatch(__first, __last, _Integral());\n+\tthis->_M_impl._M_start = iterator();\n+\tthis->_M_impl._M_finish = iterator();\n+\tthis->_M_impl._M_end_of_storage = 0;\n+\tfor (; __first != __last; ++__first)\n+\t  push_back(*__first);\n+      }\n+\n+    template<class _ForwardIterator>\n+      void\n+      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\t  std::forward_iterator_tag)\n+      {\n+\tconst size_type __n = std::distance(__first, __last);\n+\t_M_initialize(__n);\n+\tstd::copy(__first, __last, this->_M_impl._M_start);\n       }\n \n     template<class _Integer>\n@@ -745,6 +801,23 @@ template<typename _Alloc>\n \t\t\t __false_type)\n       { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n \n+    void\n+    _M_fill_assign(size_t __n, bool __x)\n+    {\n+      if (__n > size())\n+\t{\n+\t  std::fill(this->_M_impl._M_start._M_p, \n+\t\t    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n+\t  insert(end(), __n - size(), __x);\n+\t}\n+      else\n+\t{\n+\t  _M_erase_at_end(begin() + __n);\n+\t  std::fill(this->_M_impl._M_start._M_p, \n+\t\t    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n+\t}\n+    }\n+\n     template<class _InputIterator>\n       void\n       _M_assign_aux(_InputIterator __first, _InputIterator __last,\n@@ -754,7 +827,7 @@ template<typename _Alloc>\n \tfor (; __first != __last && __cur != end(); ++__cur, ++__first)\n \t  *__cur = *__first;\n \tif (__first == __last)\n-\t  erase(__cur, end());\n+\t  _M_erase_at_end(__cur);\n \telse\n \t  insert(end(), __first, __last);\n       }\n@@ -766,7 +839,7 @@ template<typename _Alloc>\n       {\n \tconst size_type __len = std::distance(__first, __last);\n \tif (__len < size())\n-\t  erase(std::copy(__first, __last, begin()), end());\n+\t  _M_erase_at_end(std::copy(__first, __last, begin()));\n \telse\n \t  {\n \t    _ForwardIterator __mid = __first;\n@@ -776,88 +849,7 @@ template<typename _Alloc>\n \t  }\n       }\n \n-    void\n-    reserve(size_type __n)\n-    {\n-      if (__n > this->max_size())\n-\t__throw_length_error(__N(\"vector::reserve\"));\n-      if (this->capacity() < __n)\n-\t{\n-\t  _Bit_type* __q = this->_M_allocate(__n);\n-\t  this->_M_impl._M_finish = std::copy(begin(), end(), \n-\t\t\t\t\t      iterator(__q, 0));\n-\t  this->_M_deallocate();\n-\t  this->_M_impl._M_start = iterator(__q, 0);\n-\t  this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)\n-\t\t\t\t\t     / int(_S_word_bit));\n-\t}\n-    }\n-\n-    reference\n-    front()\n-    { return *begin(); }\n-\n-    const_reference\n-    front() const\n-    { return *begin(); }\n-\n-    reference\n-    back()\n-    { return *(end() - 1); }\n-\n-    const_reference\n-    back() const\n-    { return *(end() - 1); }\n-\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // DR 464. Suggestion for new member functions in standard containers.\n-    // N.B. DR 464 says nothing about vector<bool> but we need something\n-    // here due to the way we are implementing DR 464 in the debug-mode\n-    // vector class.\n-    void\n-    data() { }\n-\n-    void\n-    push_back(bool __x)\n-    {\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n-        *this->_M_impl._M_finish++ = __x;\n-      else\n-        _M_insert_aux(end(), __x);\n-    }\n-\n-    void\n-    swap(vector<bool, _Alloc>& __x)\n-    {\n-      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n-      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n-      std::swap(this->_M_impl._M_end_of_storage, \n-\t\t__x._M_impl._M_end_of_storage);\n-    }\n-\n-    // [23.2.5]/1, third-to-last entry in synopsis listing\n-    static void\n-    swap(reference __x, reference __y)\n-    {\n-      bool __tmp = __x;\n-      __x = __y;\n-      __y = __tmp;\n-    }\n-\n-    iterator\n-    insert(iterator __position, bool __x = bool())\n-    {\n-      const difference_type __n = __position - begin();\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage\n-\t  && __position == end())\n-        *this->_M_impl._M_finish++ = __x;\n-      else\n-        _M_insert_aux(__position, __x);\n-      return begin() + __n;\n-    }\n-\n     // Check whether it's an integral type.  If so, it's not an iterator.\n-\n     template<class _Integer>\n       void\n       _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n@@ -872,15 +864,6 @@ template<typename _Alloc>\n       { _M_insert_range(__pos, __first, __last,\n \t\t\tstd::__iterator_category(__first)); }\n \n-    template<class _InputIterator>\n-      void\n-      insert(iterator __position,\n-\t     _InputIterator __first, _InputIterator __last)\n-      {\n-\ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n-\t_M_insert_dispatch(__position, __first, __last, _Integral());\n-      }\n-\n     void\n     _M_fill_insert(iterator __position, size_type __n, bool __x)\n     {\n@@ -909,50 +892,81 @@ template<typename _Alloc>\n \t}\n     }\n \n-    void\n-    insert(iterator __position, size_type __n, bool __x)\n-    { _M_fill_insert(__position, __n, __x); }\n-\n-    void\n-    pop_back()\n-    { --this->_M_impl._M_finish; }\n-\n-    iterator\n-    erase(iterator __position)\n-    {\n-      if (__position + 1 != end())\n-        std::copy(__position + 1, end(), __position);\n-      --this->_M_impl._M_finish;\n-      return __position;\n-    }\n+    template<class _InputIterator>\n+      void\n+      _M_insert_range(iterator __pos, _InputIterator __first, \n+\t\t      _InputIterator __last, std::input_iterator_tag)\n+      {\n+\tfor (; __first != __last; ++__first)\n+\t  {\n+\t    __pos = insert(__pos, *__first);\n+\t    ++__pos;\n+\t  }\n+      }\n \n-    iterator\n-    erase(iterator __first, iterator __last)\n-    {\n-      this->_M_impl._M_finish = std::copy(__last, end(), __first);\n-      return __first;\n-    }\n+    template<class _ForwardIterator>\n+      void\n+      _M_insert_range(iterator __position, _ForwardIterator __first, \n+\t\t      _ForwardIterator __last, std::forward_iterator_tag)\n+      {\n+\tif (__first != __last)\n+\t  {\n+\t    size_type __n = std::distance(__first, __last);\n+\t    if (capacity() - size() >= __n)\n+\t      {\n+\t\tstd::copy_backward(__position, end(),\n+\t\t\t\t   this->_M_impl._M_finish\n+\t\t\t\t   + difference_type(__n));\n+\t\tstd::copy(__first, __last, __position);\n+\t\tthis->_M_impl._M_finish += difference_type(__n);\n+\t      }\n+\t    else\n+\t      {\n+\t\tconst size_type __len = size() + std::max(size(), __n);\n+\t\t_Bit_type * __q = this->_M_allocate(__len);\n+\t\titerator __i = std::copy(begin(), __position,\n+\t\t\t\t\t iterator(__q, 0));\n+\t\t__i = std::copy(__first, __last, __i);\n+\t\tthis->_M_impl._M_finish = std::copy(__position, end(), __i);\n+\t\tthis->_M_deallocate();\n+\t\tthis->_M_impl._M_end_of_storage = (__q\n+\t\t\t\t\t\t   + ((__len\n+\t\t\t\t\t\t       + int(_S_word_bit) - 1)\n+\t\t\t\t\t\t      / int(_S_word_bit)));\n+\t\tthis->_M_impl._M_start = iterator(__q, 0);\n+\t      }\n+\t  }\n+      }\n \n     void\n-    resize(size_type __new_size, bool __x = bool())\n+    _M_insert_aux(iterator __position, bool __x)\n     {\n-      if (__new_size < size())\n-        erase(begin() + difference_type(__new_size), end());\n+      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n+\t{\n+\t  std::copy_backward(__position, this->_M_impl._M_finish, \n+\t\t\t     this->_M_impl._M_finish + 1);\n+\t  *__position = __x;\n+\t  ++this->_M_impl._M_finish;\n+\t}\n       else\n-        insert(end(), __new_size - size(), __x);\n-    }\n-\n-    void\n-    flip()\n-    {\n-      for (_Bit_type * __p = this->_M_impl._M_start._M_p;\n-\t   __p != this->_M_impl._M_end_of_storage; ++__p)\n-        *__p = ~*__p;\n+\t{\n+\t  const size_type __len = size() ? 2 * size()\n+\t                                 : static_cast<size_type>(_S_word_bit);\n+\t  _Bit_type * __q = this->_M_allocate(__len);\n+\t  iterator __i = std::copy(begin(), __position, iterator(__q, 0));\n+\t  *__i++ = __x;\n+\t  this->_M_impl._M_finish = std::copy(__position, end(), __i);\n+\t  this->_M_deallocate();\n+\t  this->_M_impl._M_end_of_storage = (__q + ((__len\n+\t\t\t\t\t\t     + int(_S_word_bit) - 1)\n+\t\t\t\t\t\t    / int(_S_word_bit)));\n+\t  this->_M_impl._M_start = iterator(__q, 0);\n+\t}\n     }\n \n     void\n-    clear()\n-    { erase(begin(), end()); }\n+    _M_erase_at_end(iterator __pos)\n+    { this->_M_impl._M_finish = __pos; }\n   };\n \n _GLIBCXX_END_NESTED_NAMESPACE"}, {"sha": "a6706a5c9c8b2c9d9dbfcdb67a07c6b26b9a6bb1", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/modifiers/erase/1.cc", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Ferase%2F1.cc?ref=fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "patch": "@@ -0,0 +1,137 @@\n+// 2005-12-23  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.5 vector<bool> modifiers\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+const bool  A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n+const bool A1[] = {0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n+const bool A2[] = {0, 0, 1, 0, 0, 1, 0, 1, 0, 1};\n+const bool A3[] = {0, 0, 1, 0, 0, 1};\n+const bool A4[] = {0, 0, 1};\n+const bool A5[] = {0, 0};\n+\n+const unsigned  N = sizeof(A)  / sizeof(bool);\n+const unsigned N1 = sizeof(A1) / sizeof(bool);\n+const unsigned N2 = sizeof(A2) / sizeof(bool);\n+const unsigned N3 = sizeof(A3) / sizeof(bool);\n+const unsigned N4 = sizeof(A4) / sizeof(bool);\n+const unsigned N5 = sizeof(A5) / sizeof(bool);\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::vector<bool>  vec_type;\n+  typedef vec_type::iterator iterator_type;\n+\n+  vec_type v(A, A + N);\n+\n+  iterator_type it1 = v.erase(v.begin() + 1);\n+  VERIFY( it1 == v.begin() + 1 );\n+  VERIFY( v.size() == N1 );\n+  VERIFY( std::equal(v.begin(), v.end(), A1) );\n+  \n+  iterator_type it2 = v.erase(v.begin() + 4, v.begin() + 9);\n+  VERIFY( it2 == v.begin() + 4 );\n+  VERIFY( v.size() == N2 );\n+  VERIFY( std::equal(v.begin(), v.end(), A2) );\n+  \n+  iterator_type it3 = v.erase(v.begin() + 6, v.end());\n+  VERIFY( it3 == v.begin() + 6 );\n+  VERIFY( v.size() == N3 );\n+  VERIFY( std::equal(v.begin(), v.end(), A3) );\n+\n+  iterator_type it4 = v.erase(v.begin(), v.begin() + 3);\n+  VERIFY( it4 == v.begin() );\n+  VERIFY( v.size() == N4 );\n+  VERIFY( std::equal(v.begin(), v.end(), A4) );\n+\n+  iterator_type it5 = v.erase(v.begin() + 2);\n+  VERIFY( it5 == v.begin() + 2 );\n+  VERIFY( v.size() == N5 );\n+  VERIFY( std::equal(v.begin(), v.end(), A5) );\n+\n+  iterator_type it6 = v.erase(v.begin(), v.end());\n+  VERIFY( it6 == v.begin() );\n+  VERIFY( v.empty() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::vector<std::vector<bool> >  vec_type;\n+  typedef vec_type::iterator          iterator_type;\n+\n+  vec_type v, v1, v2, v3, v4, v5;\n+  for (unsigned i = 0; i < N; ++i)\n+    v.push_back(std::vector<bool>(1, A[i]));\n+  for (unsigned i = 0; i < N1; ++i)\n+    v1.push_back(std::vector<bool>(1, A1[i]));\n+  for (unsigned i = 0; i < N2; ++i)\n+    v2.push_back(std::vector<bool>(1, A2[i]));\n+  for (unsigned i = 0; i < N3; ++i)\n+    v3.push_back(std::vector<bool>(1, A3[i]));\n+  for (unsigned i = 0; i < N4; ++i)\n+    v4.push_back(std::vector<bool>(1, A4[i]));\n+  for (unsigned i = 0; i < N5; ++i)\n+    v5.push_back(std::vector<bool>(1, A5[i]));\n+  \n+  iterator_type it1 = v.erase(v.begin() + 1);\n+  VERIFY( it1 == v.begin() + 1 );\n+  VERIFY( v.size() == N1 );\n+  VERIFY( std::equal(v.begin(), v.end(), v1.begin()) );\n+  \n+  iterator_type it2 = v.erase(v.begin() + 4, v.begin() + 9);\n+  VERIFY( it2 == v.begin() + 4 );\n+  VERIFY( v.size() == N2 );\n+  VERIFY( std::equal(v.begin(), v.end(), v2.begin()) );\n+  \n+  iterator_type it3 = v.erase(v.begin() + 6, v.end());\n+  VERIFY( it3 == v.begin() + 6 );\n+  VERIFY( v.size() == N3 );\n+  VERIFY( std::equal(v.begin(), v.end(), v3.begin()) );\n+\n+  iterator_type it4 = v.erase(v.begin(), v.begin() + 3);\n+  VERIFY( it4 == v.begin() );\n+  VERIFY( v.size() == N4 );\n+  VERIFY( std::equal(v.begin(), v.end(), v4.begin()) );\n+\n+  iterator_type it5 = v.erase(v.begin() + 2);\n+  VERIFY( it5 == v.begin() + 2 );\n+  VERIFY( v.size() == N5 );\n+  VERIFY( std::equal(v.begin(), v.end(), v5.begin()) );\n+\n+  iterator_type it6 = v.erase(v.begin(), v.end());\n+  VERIFY( it6 == v.begin() );\n+  VERIFY( v.empty() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "48f764040bfa773cc12b3750dead4051580c1896", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/modifiers/swap/1.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2F1.cc?ref=fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "patch": "@@ -0,0 +1,146 @@\n+// 2005-12-23  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.5 vector<bool>::swap\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<bool> my_alloc;\n+  typedef vector<bool, my_alloc> my_vector;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  vector<bool> vec01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    vec01_ref.push_back(bool(title01[i] > 96 ? 1 : 0));\n+  vector<bool> vec02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    vec02_ref.push_back(bool(title02[i] > 96 ? 1 : 0));\n+  vector<bool> vec03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    vec03_ref.push_back(bool(title03[i] > 96 ? 1 : 0));\n+  vector<bool> vec04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    vec04_ref.push_back(bool(title04[i] > 96 ? 1 : 0));\n+\n+  my_vector::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_vector vec01(alloc01);\n+  size01 = vec01.size();\n+  my_vector vec02(alloc01);\n+  size02 = vec02.size();\n+  \n+  vec01.swap(vec02);\n+  VERIFY( vec01.size() == size02 );\n+  VERIFY( vec01.empty() );\n+  VERIFY( vec02.size() == size01 );\n+  VERIFY( vec02.empty() );\n+\n+  my_vector vec03(alloc01);\n+  size01 = vec03.size();\n+  my_vector vec04(vec02_ref.begin(), vec02_ref.end(), alloc01);\n+  size02 = vec04.size();\n+  \n+  vec03.swap(vec04);\n+  VERIFY( vec03.size() == size02 );\n+  VERIFY( equal(vec03.begin(), vec03.end(), vec02_ref.begin()) );\n+  VERIFY( vec04.size() == size01 );\n+  VERIFY( vec04.empty() );\n+  \n+  my_vector vec05(vec01_ref.begin(), vec01_ref.end(), alloc01);\n+  size01 = vec05.size();\n+  my_vector vec06(vec02_ref.begin(), vec02_ref.end(), alloc01);\n+  size02 = vec06.size();\n+  \n+  vec05.swap(vec06);\n+  VERIFY( vec05.size() == size02 );\n+  VERIFY( equal(vec05.begin(), vec05.end(), vec02_ref.begin()) );\n+  VERIFY( vec06.size() == size01 );\n+  VERIFY( equal(vec06.begin(), vec06.end(), vec01_ref.begin()) );\n+\n+  my_vector vec07(vec01_ref.begin(), vec01_ref.end(), alloc01);\n+  size01 = vec07.size();\n+  my_vector vec08(vec03_ref.begin(), vec03_ref.end(), alloc01);\n+  size02 = vec08.size();\n+\n+  vec07.swap(vec08);\n+  VERIFY( vec07.size() == size02 );\n+  VERIFY( equal(vec07.begin(), vec07.end(), vec03_ref.begin()) );\n+  VERIFY( vec08.size() == size01 );\n+  VERIFY( equal(vec08.begin(), vec08.end(), vec01_ref.begin()) );\n+\n+  my_vector vec09(vec03_ref.begin(), vec03_ref.end(), alloc01);\n+  size01 = vec09.size();\n+  my_vector vec10(vec04_ref.begin(), vec04_ref.end(), alloc01);\n+  size02 = vec10.size();\n+\n+  vec09.swap(vec10);\n+  VERIFY( vec09.size() == size02 );\n+  VERIFY( equal(vec09.begin(), vec09.end(), vec04_ref.begin()) );\n+  VERIFY( vec10.size() == size01 );\n+  VERIFY( equal(vec10.begin(), vec10.end(), vec03_ref.begin()) );\n+\n+  my_vector vec11(vec04_ref.begin(), vec04_ref.end(), alloc01);\n+  size01 = vec11.size();\n+  my_vector vec12(vec01_ref.begin(), vec01_ref.end(), alloc01);\n+  size02 = vec12.size();\n+\n+  vec11.swap(vec12);\n+  VERIFY( vec11.size() == size02 );\n+  VERIFY( equal(vec11.begin(), vec11.end(), vec01_ref.begin()) );\n+  VERIFY( vec12.size() == size01 );\n+  VERIFY( equal(vec12.begin(), vec12.end(), vec04_ref.begin()) );\n+\n+  my_vector vec13(vec03_ref.begin(), vec03_ref.end(), alloc01);\n+  size01 = vec13.size();\n+  my_vector vec14(vec03_ref.begin(), vec03_ref.end(), alloc01);\n+  size02 = vec14.size();\n+\n+  vec13.swap(vec14);\n+  VERIFY( vec13.size() == size02 );\n+  VERIFY( equal(vec13.begin(), vec13.end(), vec03_ref.begin()) );\n+  VERIFY( vec14.size() == size01 );\n+  VERIFY( equal(vec14.begin(), vec14.end(), vec03_ref.begin()) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "606254bad7c7a0f219a0afe7d96f0128d7f8e3bb", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/modifiers/swap/2.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd09ac0cf712e7dfbd25bccff1db810193cc7b17/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2F2.cc?ref=fd09ac0cf712e7dfbd25bccff1db810193cc7b17", "patch": "@@ -0,0 +1,175 @@\n+// 2005-12-23  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.5 vector<bool>::swap\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<bool> my_alloc;\n+  typedef vector<bool, my_alloc> my_vector;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  vector<bool> vec01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    vec01_ref.push_back(bool(title01[i] > 96 ? 1 : 0));\n+  vector<bool> vec02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    vec02_ref.push_back(bool(title02[i] > 96 ? 1 : 0));\n+  vector<bool> vec03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    vec03_ref.push_back(bool(title03[i] > 96 ? 1 : 0));\n+  vector<bool> vec04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    vec04_ref.push_back(bool(title04[i] > 96 ? 1 : 0));\n+\n+  my_vector::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_vector vec01(alloc01);\n+  size01 = vec01.size();\n+  personality01 = vec01.get_allocator().get_personality();\n+  my_vector vec02(alloc02);\n+  size02 = vec02.size();\n+  personality02 = vec02.get_allocator().get_personality();\n+\n+  vec01.swap(vec02);\n+  VERIFY( vec01.size() == size02 );\n+  VERIFY( vec01.empty() );\n+  VERIFY( vec02.size() == size01 );\n+  VERIFY( vec02.empty() );\n+  VERIFY( vec01.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec02.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec03(alloc02);\n+  size01 = vec03.size();\n+  personality01 = vec03.get_allocator().get_personality();\n+  my_vector vec04(vec02_ref.begin(), vec02_ref.end(), alloc01);\n+  size02 = vec04.size();\n+  personality02 = vec04.get_allocator().get_personality();\n+\n+  vec03.swap(vec04);\n+  VERIFY( vec03.size() == size02 );\n+  VERIFY( equal(vec03.begin(), vec03.end(), vec02_ref.begin()) );\n+  VERIFY( vec04.size() == size01 );\n+  VERIFY( vec04.empty() );\n+  VERIFY( vec03.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec04.get_allocator().get_personality() == personality01 );\n+  \n+  my_vector vec05(vec01_ref.begin(), vec01_ref.end(), alloc01);\n+  size01 = vec05.size();\n+  personality01 = vec05.get_allocator().get_personality();\n+  my_vector vec06(vec02_ref.begin(), vec02_ref.end(), alloc02);\n+  size02 = vec06.size();\n+  personality02 = vec06.get_allocator().get_personality();\n+\n+  vec05.swap(vec06);\n+  VERIFY( vec05.size() == size02 );\n+  VERIFY( equal(vec05.begin(), vec05.end(), vec02_ref.begin()) );\n+  VERIFY( vec06.size() == size01 );\n+  VERIFY( equal(vec06.begin(), vec06.end(), vec01_ref.begin()) );\n+  VERIFY( vec05.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec06.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec07(vec01_ref.begin(), vec01_ref.end(), alloc02);\n+  size01 = vec07.size();\n+  personality01 = vec07.get_allocator().get_personality();\n+  my_vector vec08(vec03_ref.begin(), vec03_ref.end(), alloc01);\n+  size02 = vec08.size();\n+  personality02 = vec08.get_allocator().get_personality();\n+\n+  vec07.swap(vec08);\n+  VERIFY( vec07.size() == size02 );\n+  VERIFY( equal(vec07.begin(), vec07.end(), vec03_ref.begin()) );\n+  VERIFY( vec08.size() == size01 );\n+  VERIFY( equal(vec08.begin(), vec08.end(), vec01_ref.begin()) );\n+  VERIFY( vec07.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec08.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec09(vec03_ref.begin(), vec03_ref.end(), alloc01);\n+  size01 = vec09.size();\n+  personality01 = vec09.get_allocator().get_personality();\n+  my_vector vec10(vec04_ref.begin(), vec04_ref.end(), alloc02);\n+  size02 = vec10.size();\n+  personality02 = vec10.get_allocator().get_personality();\n+\n+  vec09.swap(vec10);\n+  VERIFY( vec09.size() == size02 );\n+  VERIFY( equal(vec09.begin(), vec09.end(), vec04_ref.begin()) );\n+  VERIFY( vec10.size() == size01 );\n+  VERIFY( equal(vec10.begin(), vec10.end(), vec03_ref.begin()) );\n+  VERIFY( vec09.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec10.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec11(vec04_ref.begin(), vec04_ref.end(), alloc02);\n+  size01 = vec11.size();\n+  personality01 = vec11.get_allocator().get_personality();\n+  my_vector vec12(vec01_ref.begin(), vec01_ref.end(), alloc01);\n+  size02 = vec12.size();\n+  personality02 = vec12.get_allocator().get_personality();\n+\n+  vec11.swap(vec12);\n+  VERIFY( vec11.size() == size02 );\n+  VERIFY( equal(vec11.begin(), vec11.end(), vec01_ref.begin()) );\n+  VERIFY( vec12.size() == size01 );\n+  VERIFY( equal(vec12.begin(), vec12.end(), vec04_ref.begin()) );\n+  VERIFY( vec11.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec12.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec13(vec03_ref.begin(), vec03_ref.end(), alloc01);\n+  size01 = vec13.size();\n+  personality01 = vec13.get_allocator().get_personality();\n+  my_vector vec14(vec03_ref.begin(), vec03_ref.end(), alloc02);\n+  size02 = vec14.size();\n+  personality02 = vec14.get_allocator().get_personality();\n+\n+  vec13.swap(vec14);\n+  VERIFY( vec13.size() == size02 );\n+  VERIFY( equal(vec13.begin(), vec13.end(), vec03_ref.begin()) );\n+  VERIFY( vec14.size() == size01 );\n+  VERIFY( equal(vec14.begin(), vec14.end(), vec03_ref.begin()) );\n+  VERIFY( vec13.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}]}