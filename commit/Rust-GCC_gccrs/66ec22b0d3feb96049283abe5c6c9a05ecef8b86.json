{"sha": "66ec22b0d3feb96049283abe5c6c9a05ecef8b86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZlYzIyYjBkM2ZlYjk2MDQ5MjgzYWJlNWM2YzlhMDVlY2VmOGI4Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-30T19:00:52Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-30T19:00:52Z"}, "message": "cse: Use simplify_replace_fn_rtx to process notes [PR94740]\n\ncse_process_notes did a very simple substitution, which in the wrong\ncircumstances could create non-canonical RTL and invalid MEMs.\nVarious sticking plasters have been applied to cse_process_notes_1\nto handle cases like ZERO_EXTEND, SIGN_EXTEND and UNSIGNED_FLOAT,\nbut I think this PR is a plaster too far.\n\nThe code is trying hard to avoid creating unnecessary rtl, which of\ncourse is a good thing.  If we continue to do that, then we can end\nup changing subexpressions while keeping the containing rtx.\nThis in turn means that validate_change will be a no-op on the\ncontaining rtx, even if its contents have changed.  So in these\ncases we have to apply validate_change to the individual subexpressions.\n\nOn the other hand, if we always apply validate_change to the\nindividual subexpressions, we'll end up calling validate_change\non something before it has been simplified and canonicalised.\nAnd that's one of the situations we're trying to avoid.\n\nThere might be a middle ground in which we queue the validate_changes\nas part of a group, and so can cancel the pending validate_changes\nfor subexpressions if there's a change in the outer expression.\nBut that seems even more ad-hoc than the current code.\nIt would also be quite an invasive change.\n\nI think the best thing is just to hook into the existing\nsimplify_replace_fn_rtx function, keeping the REG and MEM handling\nfrom cse_process_notes_1 essentially unchanged.  It can generate\nmore redundant rtl when a simplification takes place, but it has\nthe advantage of being relative well-used code (both directly\nand via simplify_replace_rtx).\n\n2020-04-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR rtl-optimization/94740\n\t* cse.c (cse_process_notes_1): Replace with...\n\t(cse_process_note_1): ...this new function, acting as a\n\tsimplify_replace_fn_rtx callback to process_note.  Handle only\n\tREGs and MEMs directly.  Validate the MEM if cse_process_note\n\tchanges its address.\n\t(cse_process_notes): Replace with...\n\t(cse_process_note): ...this new function.\n\t(cse_extended_basic_block): Update accordingly, iterating over\n\tthe register notes and passing individual notes to cse_process_note.", "tree": {"sha": "e355fa10616046c2bf09b27edeed7bb85f6e42ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e355fa10616046c2bf09b27edeed7bb85f6e42ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66ec22b0d3feb96049283abe5c6c9a05ecef8b86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ec22b0d3feb96049283abe5c6c9a05ecef8b86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66ec22b0d3feb96049283abe5c6c9a05ecef8b86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ec22b0d3feb96049283abe5c6c9a05ecef8b86/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "870b7834f068ef6fd11970491548aef27760dcde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870b7834f068ef6fd11970491548aef27760dcde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870b7834f068ef6fd11970491548aef27760dcde"}], "stats": {"total": 131, "additions": 47, "deletions": 84}, "files": [{"sha": "cb0b632f2aa95c752cc3fb97f70f54731968be17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ec22b0d3feb96049283abe5c6c9a05ecef8b86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ec22b0d3feb96049283abe5c6c9a05ecef8b86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66ec22b0d3feb96049283abe5c6c9a05ecef8b86", "patch": "@@ -1,3 +1,16 @@\n+2020-04-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/94740\n+\t* cse.c (cse_process_notes_1): Replace with...\n+\t(cse_process_note_1): ...this new function, acting as a\n+\tsimplify_replace_fn_rtx callback to process_note.  Handle only\n+\tREGs and MEMs directly.  Validate the MEM if cse_process_note\n+\tchanges its address.\n+\t(cse_process_notes): Replace with...\n+\t(cse_process_note): ...this new function.\n+\t(cse_extended_basic_block): Update accordingly, iterating over\n+\tthe register notes and passing individual notes to cse_process_note.\n+\n 2020-04-30  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/emmintrin.h (_mm_movemask_epi8): Fix comment."}, {"sha": "36bcfc354d8140fecb7e0776bd4a755b2a1ee3c7", "filename": "gcc/cse.c", "status": "modified", "additions": 34, "deletions": 84, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ec22b0d3feb96049283abe5c6c9a05ecef8b86/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ec22b0d3feb96049283abe5c6c9a05ecef8b86/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=66ec22b0d3feb96049283abe5c6c9a05ecef8b86", "patch": "@@ -585,7 +585,6 @@ static void cse_insn (rtx_insn *);\n static void cse_prescan_path (struct cse_basic_block_data *);\n static void invalidate_from_clobbers (rtx_insn *);\n static void invalidate_from_sets_and_clobbers (rtx_insn *);\n-static rtx cse_process_notes (rtx, rtx, bool *);\n static void cse_extended_basic_block (struct cse_basic_block_data *);\n extern void dump_class (struct table_elt*);\n static void get_cse_reg_info_1 (unsigned int regno);\n@@ -6222,75 +6221,28 @@ invalidate_from_sets_and_clobbers (rtx_insn *insn)\n     }\n }\n \f\n-/* Process X, part of the REG_NOTES of an insn.  Look at any REG_EQUAL notes\n-   and replace any registers in them with either an equivalent constant\n-   or the canonical form of the register.  If we are inside an address,\n-   only do this if the address remains valid.\n+static rtx cse_process_note (rtx);\n \n-   OBJECT is 0 except when within a MEM in which case it is the MEM.\n+/* A simplify_replace_fn_rtx callback for cse_process_note.  Process X,\n+   part of the REG_NOTES of an insn.  Replace any registers with either\n+   an equivalent constant or the canonical form of the register.\n+   Only replace addresses if the containing MEM remains valid.\n \n-   Return the replacement for X.  */\n+   Return the replacement for X, or null if it should be simplified\n+   recursively.  */\n \n static rtx\n-cse_process_notes_1 (rtx x, rtx object, bool *changed)\n+cse_process_note_1 (rtx x, const_rtx, void *)\n {\n-  enum rtx_code code = GET_CODE (x);\n-  const char *fmt = GET_RTX_FORMAT (code);\n-  int i;\n-\n-  switch (code)\n+  if (MEM_P (x))\n     {\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    CASE_CONST_ANY:\n-    case PC:\n-    case CC0:\n-    case LO_SUM:\n+      validate_change (x, &XEXP (x, 0), cse_process_note (XEXP (x, 0)), false);\n       return x;\n+    }\n \n-    case MEM:\n-      validate_change (x, &XEXP (x, 0),\n-\t\t       cse_process_notes (XEXP (x, 0), x, changed), 0);\n-      return x;\n-\n-    case EXPR_LIST:\n-      if (REG_NOTE_KIND (x) == REG_EQUAL)\n-\tXEXP (x, 0) = cse_process_notes (XEXP (x, 0), NULL_RTX, changed);\n-      /* Fall through.  */\n-\n-    case INSN_LIST:\n-    case INT_LIST:\n-      if (XEXP (x, 1))\n-\tXEXP (x, 1) = cse_process_notes (XEXP (x, 1), NULL_RTX, changed);\n-      return x;\n-\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-    case SUBREG:\n-      {\n-\trtx new_rtx = cse_process_notes (XEXP (x, 0), object, changed);\n-\t/* We don't substitute VOIDmode constants into these rtx,\n-\t   since they would impede folding.  */\n-\tif (GET_MODE (new_rtx) != VOIDmode)\n-\t  validate_change (object, &XEXP (x, 0), new_rtx, 0);\n-\treturn x;\n-      }\n-\n-    case UNSIGNED_FLOAT:\n-      {\n-\trtx new_rtx = cse_process_notes (XEXP (x, 0), object, changed);\n-\t/* We don't substitute negative VOIDmode constants into these rtx,\n-\t   since they would impede folding.  */\n-\tif (GET_MODE (new_rtx) != VOIDmode\n-\t    || (CONST_INT_P (new_rtx) && INTVAL (new_rtx) >= 0)\n-\t    || (CONST_DOUBLE_P (new_rtx) && CONST_DOUBLE_HIGH (new_rtx) >= 0))\n-\t  validate_change (object, &XEXP (x, 0), new_rtx, 0);\n-\treturn x;\n-      }\n-\n-    case REG:\n-      i = REG_QTY (REGNO (x));\n+  if (REG_P (x))\n+    {\n+      int i = REG_QTY (REGNO (x));\n \n       /* Return a constant or a constant register.  */\n       if (REGNO_QTY_VALID_P (REGNO (x)))\n@@ -6309,26 +6261,19 @@ cse_process_notes_1 (rtx x, rtx object, bool *changed)\n \n       /* Otherwise, canonicalize this register.  */\n       return canon_reg (x, NULL);\n-\n-    default:\n-      break;\n     }\n \n-  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n-    if (fmt[i] == 'e')\n-      validate_change (object, &XEXP (x, i),\n-\t\t       cse_process_notes (XEXP (x, i), object, changed), 0);\n-\n-  return x;\n+  return NULL_RTX;\n }\n \n+/* Process X, part of the REG_NOTES of an insn.  Replace any registers in it\n+   with either an equivalent constant or the canonical form of the register.\n+   Only replace addresses if the containing MEM remains valid.  */\n+\n static rtx\n-cse_process_notes (rtx x, rtx object, bool *changed)\n+cse_process_note (rtx x)\n {\n-  rtx new_rtx = cse_process_notes_1 (x, object, changed);\n-  if (new_rtx != x)\n-    *changed = true;\n-  return new_rtx;\n+  return simplify_replace_fn_rtx (x, NULL_RTX, cse_process_note_1, NULL);\n }\n \n \f\n@@ -6623,14 +6568,19 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t    {\n \t      /* Process notes first so we have all notes in canonical forms\n \t\t when looking for duplicate operations.  */\n-\t      if (REG_NOTES (insn))\n-\t\t{\n-\t\t  bool changed = false;\n-\t\t  REG_NOTES (insn) = cse_process_notes (REG_NOTES (insn),\n-\t\t\t\t\t\t        NULL_RTX, &changed);\n-\t\t  if (changed)\n-\t\t    df_notes_rescan (insn);\n-\t\t}\n+\t      bool changed = false;\n+\t      for (rtx note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t\tif (REG_NOTE_KIND (note) == REG_EQUAL)\n+\t\t  {\n+\t\t    rtx newval = cse_process_note (XEXP (note, 0));\n+\t\t    if (newval != XEXP (note, 0))\n+\t\t      {\n+\t\t\tXEXP (note, 0) = newval;\n+\t\t\tchanged = true;\n+\t\t      }\n+\t\t  }\n+\t      if (changed)\n+\t\tdf_notes_rescan (insn);\n \n \t      cse_insn (insn);\n "}]}