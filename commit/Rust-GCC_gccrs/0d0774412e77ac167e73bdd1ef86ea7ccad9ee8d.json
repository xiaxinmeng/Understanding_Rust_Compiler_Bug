{"sha": "0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQwNzc0NDEyZTc3YWMxNjdlNzNiZGQxZWY4NmVhN2NjYWQ5ZWU4ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-10-27T20:19:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-10-27T20:19:24Z"}, "message": "parser.c (cp_parser_omp_clause_name): Add auto, gang, seq, vector, worker.\n\n\tgcc/cp/\n\t* parser.c (cp_parser_omp_clause_name): Add auto, gang, seq,\n\tvector, worker.\n\t(cp_parser_oacc_simple_clause): New.\n\t(cp_parser_oacc_shape_clause): New.\n\t(cp_parser_oacc_all_clauses): Add auto, gang, seq, vector, worker.\n\t(OACC_LOOP_CLAUSE_MASK): Likewise.\n\t* semantics.c (finish_omp_clauses): Add auto, gang, seq, vector,\n\tworker. Unify the handling of teams, tasks and vector_length with\n\tthe other loop shape clauses.\n\n\tgcc/testsuite/\n\t* g++.dg/g++.dg/gomp/pr33372-1.C: Adjust diagnostic.\n\t* gcc/testsuite/g++.dg/gomp/pr33372-3.C: Likewise.\n\nFrom-SVN: r229460", "tree": {"sha": "bc4d1f9c4508250442becfc8b0d42e51b0a61c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc4d1f9c4508250442becfc8b0d42e51b0a61c63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/comments", "author": null, "committer": null, "parents": [{"sha": "8ab78162c0dfc65aef769516ba77560566577113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab78162c0dfc65aef769516ba77560566577113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ab78162c0dfc65aef769516ba77560566577113"}], "stats": {"total": 378, "additions": 299, "deletions": 79}, "files": [{"sha": "c7aaa2771a186c412f806933043d58f658d2c462", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "patch": "@@ -1,3 +1,21 @@\n+2015-10-27  Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Thomas Schwinge  <thomas@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Nathan Sidwell <nathan@codesourcery.com>\n+\t    Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\t* parser.c (cp_parser_omp_clause_name): Add auto, gang, seq,\n+\tvector, worker.\n+\t(cp_parser_oacc_simple_clause): New.\n+\t(cp_parser_oacc_shape_clause): New.\n+\t(cp_parser_oacc_all_clauses): Add auto, gang, seq, vector, worker.\n+\t(OACC_LOOP_CLAUSE_MASK): Likewise.\n+\t* semantics.c (finish_omp_clauses): Add auto, gang, seq, vector,\n+\tworker. Unify the handling of teams, tasks and vector_length with\n+\tthe other loop shape clauses.\n+\n 2015-10-27  Thomas Schwinge  <thomas@codesourcery.com>\n \t    James Norris  <jnorris@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>"}, {"sha": "169c17dc7788839ab071882c24d304bb660cca0b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 183, "deletions": 3, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "patch": "@@ -29064,7 +29064,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n {\n   pragma_omp_clause result = PRAGMA_OMP_CLAUSE_NONE;\n \n-  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_IF))\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AUTO))\n+    result = PRAGMA_OACC_CLAUSE_AUTO;\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_IF))\n     result = PRAGMA_OMP_CLAUSE_IF;\n   else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DEFAULT))\n     result = PRAGMA_OMP_CLAUSE_DEFAULT;\n@@ -29122,7 +29124,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_FROM;\n \t  break;\n \tcase 'g':\n-\t  if (!strcmp (\"grainsize\", p))\n+\t  if (!strcmp (\"gang\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_GANG;\n+\t  else if (!strcmp (\"grainsize\", p))\n \t    result = PRAGMA_OMP_CLAUSE_GRAINSIZE;\n \t  break;\n \tcase 'h':\n@@ -29212,6 +29216,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_SECTIONS;\n \t  else if (!strcmp (\"self\", p))\n \t    result = PRAGMA_OACC_CLAUSE_SELF;\n+\t  else if (!strcmp (\"seq\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_SEQ;\n \t  else if (!strcmp (\"shared\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SHARED;\n \t  else if (!strcmp (\"simd\", p))\n@@ -29238,14 +29244,18 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR;\n \t  break;\n \tcase 'v':\n-\t  if (!strcmp (\"vector_length\", p))\n+\t  if (!strcmp (\"vector\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_VECTOR;\n+\t  else if (!strcmp (\"vector_length\", p))\n \t    result = PRAGMA_OACC_CLAUSE_VECTOR_LENGTH;\n \t  else if (flag_cilkplus && !strcmp (\"vectorlength\", p))\n \t    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n \t  break;\n \tcase 'w':\n \t  if (!strcmp (\"wait\", p))\n \t    result = PRAGMA_OACC_CLAUSE_WAIT;\n+\t  else if (!strcmp (\"worker\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_WORKER;\n \t  break;\n \t}\n     }\n@@ -29582,6 +29592,146 @@ cp_parser_oacc_data_clause_deviceptr (cp_parser *parser, tree list)\n   return list;\n }\n \n+/* OpenACC 2.0:\n+   auto\n+   independent\n+   nohost\n+   seq */\n+\n+static tree\n+cp_parser_oacc_simple_clause (cp_parser * /* parser  */,\n+\t\t\t      enum omp_clause_code code,\n+\t\t\t      tree list, location_t location)\n+{\n+  check_no_duplicate_clause (list, code, omp_clause_code_name[code], location);\n+  tree c = build_omp_clause (location, code);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+/* OpenACC:\n+\n+    gang [( gang-arg-list )]\n+    worker [( [num:] int-expr )]\n+    vector [( [length:] int-expr )]\n+\n+  where gang-arg is one of:\n+\n+    [num:] int-expr\n+    static: size-expr\n+\n+  and size-expr may be:\n+\n+    *\n+    int-expr\n+*/\n+\n+static tree\n+cp_parser_oacc_shape_clause (cp_parser *parser, omp_clause_code kind,\n+\t\t\t     const char *str, tree list)\n+{\n+  const char *id = \"num\";\n+  cp_lexer *lexer = parser->lexer;\n+  tree ops[2] = { NULL_TREE, NULL_TREE }, c;\n+  location_t loc = cp_lexer_peek_token (lexer)->location;\n+\n+  if (kind == OMP_CLAUSE_VECTOR)\n+    id = \"length\";\n+\n+  if (cp_lexer_next_token_is (lexer, CPP_OPEN_PAREN))\n+    {\n+      cp_lexer_consume_token (lexer);\n+\n+      do\n+\t{\n+\t  cp_token *next = cp_lexer_peek_token (lexer);\n+\t  int idx = 0;\n+\n+\t  /* Gang static argument.  */\n+\t  if (kind == OMP_CLAUSE_GANG\n+\t      && cp_lexer_next_token_is_keyword (lexer, RID_STATIC))\n+\t    {\n+\t      cp_lexer_consume_token (lexer);\n+\n+\t      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+\t\tgoto cleanup_error;\n+\n+\t      idx = 1;\n+\t      if (ops[idx] != NULL)\n+\t\t{\n+\t\t  cp_parser_error (parser, \"too many %<static%> arguments\");\n+\t\t  goto cleanup_error;\n+\t\t}\n+\n+\t      /* Check for the '*' argument.  */\n+\t      if (cp_lexer_next_token_is (lexer, CPP_MULT))\n+\t\t{\n+\t\t  cp_lexer_consume_token (lexer);\n+\t\t  ops[idx] = integer_minus_one_node;\n+\n+\t\t  if (cp_lexer_next_token_is (lexer, CPP_COMMA))\n+\t\t    {\n+\t\t      cp_lexer_consume_token (lexer);\n+\t\t      continue;\n+\t\t    }\n+\t\t  else break;\n+\t\t}\n+\t    }\n+\t  /* Worker num: argument and vector length: arguments.  */\n+\t  else if (cp_lexer_next_token_is (lexer, CPP_NAME)\n+\t\t   && strcmp (id, IDENTIFIER_POINTER (next->u.value)) == 0\n+\t\t   && cp_lexer_nth_token_is (lexer, 2, CPP_COLON))\n+\t    {\n+\t      cp_lexer_consume_token (lexer);  /* id  */\n+\t      cp_lexer_consume_token (lexer);  /* ':'  */\n+\t    }\n+\n+\t  /* Now collect the actual argument.  */\n+\t  if (ops[idx] != NULL_TREE)\n+\t    {\n+\t      cp_parser_error (parser, \"unexpected argument\");\n+\t      goto cleanup_error;\n+\t    }\n+\n+\t  tree expr = cp_parser_assignment_expression (parser, NULL, false,\n+\t\t\t\t\t\t       false);\n+\t  if (expr == error_mark_node)\n+\t    goto cleanup_error;\n+\n+\t  mark_exp_read (expr);\n+\t  ops[idx] = expr;\n+\n+\t  if (kind == OMP_CLAUSE_GANG\n+\t      && cp_lexer_next_token_is (lexer, CPP_COMMA))\n+\t    {\n+\t      cp_lexer_consume_token (lexer);\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+      while (1);\n+\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\tgoto cleanup_error;\n+    }\n+\n+  check_no_duplicate_clause (list, kind, str, loc);\n+\n+  c = build_omp_clause (loc, kind);\n+\n+  if (ops[1])\n+    OMP_CLAUSE_OPERAND (c, 1) = ops[1];\n+\n+  OMP_CLAUSE_OPERAND (c, 0) = ops[0];\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+\n+ cleanup_error:\n+  cp_parser_skip_to_closing_parenthesis (parser, false, false, true);\n+  return list;\n+}\n+\n /* OpenACC:\n    vector_length ( expression ) */\n \n@@ -31306,6 +31456,11 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  clauses = cp_parser_oacc_clause_async (parser, clauses);\n \t  c_name = \"async\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_AUTO:\n+\t  clauses = cp_parser_oacc_simple_clause (parser, OMP_CLAUSE_AUTO,\n+\t\t\t\t\t\t clauses, here);\n+\t  c_name = \"auto\";\n+\t  break;\n \tcase PRAGMA_OACC_CLAUSE_COLLAPSE:\n \t  clauses = cp_parser_omp_clause_collapse (parser, clauses, here);\n \t  c_name = \"collapse\";\n@@ -31338,6 +31493,11 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  clauses = cp_parser_oacc_data_clause_deviceptr (parser, clauses);\n \t  c_name = \"deviceptr\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_GANG:\n+\t  c_name = \"gang\";\n+\t  clauses = cp_parser_oacc_shape_clause (parser, OMP_CLAUSE_GANG,\n+\t\t\t\t\t\t c_name, clauses);\n+\t  break;\n \tcase PRAGMA_OACC_CLAUSE_HOST:\n \t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n \t  c_name = \"host\";\n@@ -31382,6 +31542,16 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n \t  c_name = \"self\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_SEQ:\n+\t  clauses = cp_parser_oacc_simple_clause (parser, OMP_CLAUSE_SEQ,\n+\t\t\t\t\t\t clauses, here);\n+\t  c_name = \"seq\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_VECTOR:\n+\t  c_name = \"vector\";\n+\t  clauses = cp_parser_oacc_shape_clause (parser, OMP_CLAUSE_VECTOR,\n+\t\t\t\t\t\t c_name, clauses);\n+\t  break;\n \tcase PRAGMA_OACC_CLAUSE_VECTOR_LENGTH:\n \t  clauses = cp_parser_oacc_clause_vector_length (parser, clauses);\n \t  c_name = \"vector_length\";\n@@ -31390,6 +31560,11 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  clauses = cp_parser_oacc_clause_wait (parser, clauses);\n \t  c_name = \"wait\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_WORKER:\n+\t  c_name = \"worker\";\n+\t  clauses = cp_parser_oacc_shape_clause (parser, OMP_CLAUSE_WORKER,\n+\t\t\t\t\t\t c_name, clauses);\n+\t  break;\n \tdefault:\n \t  cp_parser_error (parser, \"expected %<#pragma acc%> clause\");\n \t  goto saw_error;\n@@ -34303,6 +34478,11 @@ cp_parser_oacc_enter_exit_data (cp_parser *parser, cp_token *pragma_tok,\n \n #define OACC_LOOP_CLAUSE_MASK\t\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COLLAPSE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_GANG)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_VECTOR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WORKER)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_AUTO)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_SEQ)\t\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_REDUCTION) )\n \n static tree"}, {"sha": "a6d7e361d0546a0c84ac4544c2e9a24462cd035a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 89, "deletions": 73, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "patch": "@@ -5965,14 +5965,76 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t  OMP_CLAUSE_FINAL_EXPR (c) = t;\n \t  break;\n \n+\tcase OMP_CLAUSE_GANG:\n+\t  /* Operand 1 is the gang static: argument.  */\n+\t  t = OMP_CLAUSE_OPERAND (c, 1);\n+\t  if (t != NULL_TREE)\n+\t    {\n+\t      if (t == error_mark_node)\n+\t\tremove = true;\n+\t      else if (!type_dependent_expression_p (t)\n+\t\t       && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t\t{\n+\t\t  error (\"%<gang%> static expression must be integral\");\n+\t\t  remove = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  t = mark_rvalue_use (t);\n+\t\t  if (!processing_template_decl)\n+\t\t    {\n+\t\t      t = maybe_constant_value (t);\n+\t\t      if (TREE_CODE (t) == INTEGER_CST\n+\t\t\t  && tree_int_cst_sgn (t) != 1\n+\t\t\t  && t != integer_minus_one_node)\n+\t\t\t{\n+\t\t\t  warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t      \"%<gang%> static value must be\"\n+\t\t\t\t      \"positive\");\n+\t\t\t  t = integer_one_node;\n+\t\t\t}\n+\t\t    }\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n+\t      OMP_CLAUSE_OPERAND (c, 1) = t;\n+\t    }\n+\t  /* Check operand 0, the num argument.  */\n+\n+\tcase OMP_CLAUSE_WORKER:\n+\tcase OMP_CLAUSE_VECTOR:\n+\t  if (OMP_CLAUSE_OPERAND (c, 0) == NULL_TREE)\n+\t    break;\n+\n+\tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_NUM_THREADS:\n-\t  t = OMP_CLAUSE_NUM_THREADS_EXPR (c);\n+\tcase OMP_CLAUSE_NUM_GANGS:\n+\tcase OMP_CLAUSE_NUM_WORKERS:\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n+\t  t = OMP_CLAUSE_OPERAND (c, 0);\n \t  if (t == error_mark_node)\n \t    remove = true;\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"num_threads expression must be integral\");\n+\t     switch (OMP_CLAUSE_CODE (c))\n+\t\t{\n+\t\tcase OMP_CLAUSE_GANG:\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<gang%> num expression must be integral\"); break;\n+\t\tcase OMP_CLAUSE_VECTOR:\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<vector%> length expression must be integral\");\n+\t\t  break;\n+\t\tcase OMP_CLAUSE_WORKER:\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<worker%> num expression must be integral\");\n+\t\t  break;\n+\t\tdefault:\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qs expression must be integral\",\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t}\n \t      remove = true;\n \t    }\n \t  else\n@@ -5984,13 +6046,33 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t\t  if (TREE_CODE (t) == INTEGER_CST\n \t\t      && tree_int_cst_sgn (t) != 1)\n \t\t    {\n-\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n-\t\t\t\t  \"%<num_threads%> value must be positive\");\n+\t\t      switch (OMP_CLAUSE_CODE (c))\n+\t\t\t{\n+\t\t\tcase OMP_CLAUSE_GANG:\n+\t\t\t  warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t      \"%<gang%> num value must be positive\");\n+\t\t\t  break;\n+\t\t\tcase OMP_CLAUSE_VECTOR:\n+\t\t\t  warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t      \"%<vector%> length value must be\"\n+\t\t\t\t      \"positive\");\n+\t\t\t  break;\n+\t\t\tcase OMP_CLAUSE_WORKER:\n+\t\t\t  warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t      \"%<worker%> num value must be\"\n+\t\t\t\t      \"positive\");\n+\t\t\t  break;\n+\t\t\tdefault:\n+\t\t\t  warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t\t      \"%qs value must be positive\",\n+\t\t\t\t      omp_clause_code_name\n+\t\t\t\t      [OMP_CLAUSE_CODE (c)]);\n+\t\t\t}\n \t\t      t = integer_one_node;\n \t\t    }\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n \t\t}\n-\t      OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;\n+\t      OMP_CLAUSE_OPERAND (c, 0) = t;\n \t    }\n \t  break;\n \n@@ -6062,35 +6144,6 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t    }\n \t  break;\n \n-\tcase OMP_CLAUSE_NUM_TEAMS:\n-\t  t = OMP_CLAUSE_NUM_TEAMS_EXPR (c);\n-\t  if (t == error_mark_node)\n-\t    remove = true;\n-\t  else if (!type_dependent_expression_p (t)\n-\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      error (\"%<num_teams%> expression must be integral\");\n-\t      remove = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      t = mark_rvalue_use (t);\n-\t      if (!processing_template_decl)\n-\t\t{\n-\t\t  t = maybe_constant_value (t);\n-\t\t  if (TREE_CODE (t) == INTEGER_CST\n-\t\t      && tree_int_cst_sgn (t) != 1)\n-\t\t    {\n-\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n-\t\t\t\t  \"%<num_teams%> value must be positive\");\n-\t\t      t = integer_one_node;\n-\t\t    }\n-\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n-\t\t}\n-\t      OMP_CLAUSE_NUM_TEAMS_EXPR (c) = t;\n-\t    }\n-\t  break;\n-\n \tcase OMP_CLAUSE_ASYNC:\n \t  t = OMP_CLAUSE_ASYNC_EXPR (c);\n \t  if (t == error_mark_node)\n@@ -6110,16 +6163,6 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t    }\n \t  break;\n \n-\tcase OMP_CLAUSE_VECTOR_LENGTH:\n-\t  t = OMP_CLAUSE_VECTOR_LENGTH_EXPR (c);\n-\t  t = maybe_convert_cond (t);\n-\t  if (t == error_mark_node)\n-\t    remove = true;\n-\t  else if (!processing_template_decl)\n-\t    t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n-\t  OMP_CLAUSE_VECTOR_LENGTH_EXPR (c) = t;\n-\t  break;\n-\n \tcase OMP_CLAUSE_WAIT:\n \t  t = OMP_CLAUSE_WAIT_EXPR (c);\n \t  if (t == error_mark_node)\n@@ -6547,35 +6590,6 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \t    }\n \t  goto check_dup_generic;\n \n-\tcase OMP_CLAUSE_NUM_TASKS:\n-\t  t = OMP_CLAUSE_NUM_TASKS_EXPR (c);\n-\t  if (t == error_mark_node)\n-\t    remove = true;\n-\t  else if (!type_dependent_expression_p (t)\n-\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      error (\"%<num_tasks%> expression must be integral\");\n-\t      remove = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      t = mark_rvalue_use (t);\n-\t      if (!processing_template_decl)\n-\t\t{\n-\t\t  t = maybe_constant_value (t);\n-\t\t  if (TREE_CODE (t) == INTEGER_CST\n-\t\t      && tree_int_cst_sgn (t) != 1)\n-\t\t    {\n-\t\t      warning_at (OMP_CLAUSE_LOCATION (c), 0,\n-\t\t\t\t  \"%<num_tasks%> value must be positive\");\n-\t\t      t = integer_one_node;\n-\t\t    }\n-\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n-\t\t}\n-\t      OMP_CLAUSE_NUM_TASKS_EXPR (c) = t;\n-\t    }\n-\t  break;\n-\n \tcase OMP_CLAUSE_GRAINSIZE:\n \t  t = OMP_CLAUSE_GRAINSIZE_EXPR (c);\n \t  if (t == error_mark_node)\n@@ -6694,6 +6708,8 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n \t  break;\n \n \tcase OMP_CLAUSE_INBRANCH:"}, {"sha": "f8ef47d8b502d3b375ba3b101100e87a0d6e344c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "patch": "@@ -1,3 +1,9 @@\n+2015-10-27  Nathan Sidwell <nathan@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* g++.dg/g++.dg/gomp/pr33372-1.C: Adjust diagnostic.\n+\t* gcc/testsuite/g++.dg/gomp/pr33372-3.C: Likewise.\n+\n 2015-10-27  Richard Henderson  <rth@redhat.com>\n \n \tPR rtl-opt/67609\n@@ -24,7 +30,7 @@\n \t* gfortran.dg/goacc/cray.f95: Likewise.\n \t* gfortran.dg/goacc/parameter.f95: Likewise.\n \n- 2015-10-27  Steven G. Kargl  <kargl@gcc.gnu.org>\n+2015-10-27  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68108\n \t* gfortran.dg/pr67805_2.f90: New test."}, {"sha": "e9da25956879737ba371ea7a43b64916b9796614", "filename": "gcc/testsuite/g++.dg/gomp/pr33372-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-1.C?ref=0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "patch": "@@ -6,7 +6,7 @@ template <typename T>\n void f ()\n {\n   extern T n ();\n-#pragma omp parallel num_threads(n)\t// { dg-error \"num_threads expression must be integral\" }\n+#pragma omp parallel num_threads(n)\t// { dg-error \"'num_threads' expression must be integral\" }\n   ;\n #pragma omp parallel for schedule(static, n)\n   for (int i = 0; i < 10; i++)\t\t// { dg-error \"chunk size expression must be integral\" }"}, {"sha": "f0a1910bf42ea8ad35468a2f951ffe4c92750c23", "filename": "gcc/testsuite/g++.dg/gomp/pr33372-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-3.C?ref=0d0774412e77ac167e73bdd1ef86ea7ccad9ee8d", "patch": "@@ -6,7 +6,7 @@ template <typename T>\n void f ()\n {\n   T n = 6;\n-#pragma omp parallel num_threads(n)\t// { dg-error \"num_threads expression must be integral\" }\n+#pragma omp parallel num_threads(n)\t// { dg-error \"'num_threads' expression must be integral\" }\n   ;\n #pragma omp parallel for schedule(static, n)\n   for (int i = 0; i < 10; i++)\t\t// { dg-error \"chunk size expression must be integral\" }"}]}