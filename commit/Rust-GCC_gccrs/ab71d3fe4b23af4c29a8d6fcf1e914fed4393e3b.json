{"sha": "ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "node_id": "C_kwDOANBUbNoAKGFiNzFkM2ZlNGIyM2FmNGMyOWE4ZDZmY2YxZTkxNGZlZDQzOTNlM2I", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T19:57:59Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T19:57:59Z"}, "message": "c++: ICE with non-constant satisfaction value [PR98644]\n\nHere during satisfaction, the expression of the atomic constraint after\nsubstitution is (int *) NON_LVALUE_EXPR <1> != 0B, which is not a C++\nconstant expression due to the reinterpret_cast, but TREE_CONSTANT is\nset since its value is otherwise effectively constant.  We then call\nmaybe_constant_value on it, which proceeds via its fail-fast path to\nexit early without clearing TREE_CONSTANT.  But satisfy_atom relies\non checking TREE_CONSTANT of the result of maybe_constant_value in order\nto detect non-constant satisfaction.\n\nThis patch fixes this by making the fail-fast path of maybe_constant_value\nclear TREE_CONSTANT in this case, like cxx_eval_outermost_constant_expr\nin the normal path would have done.\n\n\tPR c++/98644\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (mark_non_constant): Define, split out from ...\n\t(cxx_eval_outermost_constant_expr): ... here.\n\t(maybe_constant_value): Use it.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-pr98644.C: New test.\n\t* g++.dg/parse/array-size2.C: Remove expected diagnostic about a\n\tnarrowing conversion.\n\nCo-authored-by: Jason Merrill <jason@redhat.com>", "tree": {"sha": "eab2725dae7837806ea93326fa20eed2ec493e70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eab2725dae7837806ea93326fa20eed2ec493e70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b/comments", "author": null, "committer": null, "parents": [{"sha": "28750ac2765e808aa4f45a73c630e53575834efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28750ac2765e808aa4f45a73c630e53575834efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28750ac2765e808aa4f45a73c630e53575834efd"}], "stats": {"total": 55, "additions": 34, "deletions": 21}, "files": [{"sha": "bbb6cd99b3cefde307f7c216952620e192b35926", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "patch": "@@ -7579,6 +7579,29 @@ find_immediate_fndecl (tree *tp, int */*walk_subtrees*/, void */*data*/)\n   return NULL_TREE;\n }\n \n+/* T has TREE_CONSTANT set but has been deemed not a valid C++ constant\n+   expression.  Return a version of T that has TREE_CONSTANT cleared.  */\n+\n+static tree\n+mark_non_constant (tree t)\n+{\n+  gcc_checking_assert (TREE_CONSTANT (t));\n+\n+  /* This isn't actually constant, so unset TREE_CONSTANT.\n+     Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires\n+     it to be set if it is invariant address, even when it is not\n+     a valid C++ constant expression.  Wrap it with a NOP_EXPR\n+     instead.  */\n+  if (EXPR_P (t) && TREE_CODE (t) != ADDR_EXPR)\n+    t = copy_node (t);\n+  else if (TREE_CODE (t) == CONSTRUCTOR)\n+    t = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (t), t);\n+  else\n+    t = build_nop (TREE_TYPE (t), t);\n+  TREE_CONSTANT (t) = false;\n+  return t;\n+}\n+\n /* ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n    STRICT has the same sense as for constant_value_1: true if we only allow\n    conforming C++ constant expressions, or false if we want a constant value\n@@ -7801,20 +7824,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   else if (constexpr_dtor)\n     return r;\n   else if (non_constant_p && TREE_CONSTANT (r))\n-    {\n-      /* This isn't actually constant, so unset TREE_CONSTANT.\n-\t Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires\n-\t it to be set if it is invariant address, even when it is not\n-\t a valid C++ constant expression.  Wrap it with a NOP_EXPR\n-\t instead.  */\n-      if (EXPR_P (r) && TREE_CODE (r) != ADDR_EXPR)\n-\tr = copy_node (r);\n-      else if (TREE_CODE (r) == CONSTRUCTOR)\n-\tr = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (r), r);\n-      else\n-\tr = build_nop (TREE_TYPE (r), r);\n-      TREE_CONSTANT (r) = false;\n-    }\n+    r = mark_non_constant (r);\n   else if (non_constant_p)\n     return t;\n \n@@ -7965,11 +7975,9 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n \n   if (!is_nondependent_constant_expression (t))\n     {\n-      if (TREE_OVERFLOW_P (t))\n-\t{\n-\t  t = build_nop (TREE_TYPE (t), t);\n-\t  TREE_CONSTANT (t) = false;\n-\t}\n+      if (TREE_OVERFLOW_P (t)\n+\t  || (!processing_template_decl && TREE_CONSTANT (t)))\n+\tt = mark_non_constant (t);\n       return t;\n     }\n   else if (CONSTANT_CLASS_P (t))"}, {"sha": "6772f72a3ce8cf7d82d99de7e5449871110068fa", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr98644.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr98644.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr98644.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr98644.C?ref=ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/98644\n+// { dg-do compile { target c++20 } }\n+\n+template<class T> concept Signed = bool(T(1)); // { dg-error \"reinterpret_cast\" }\n+static_assert(Signed<int*>); // { dg-error \"non-constant\" }\n+\n+constexpr bool B = requires { requires bool((char *)1); }; // { dg-error \"reinterpret_cast\" }"}, {"sha": "e58fe266e77154cfad8089ada733955de9662874", "filename": "gcc/testsuite/g++.dg/parse/array-size2.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Farray-size2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Farray-size2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Farray-size2.C?ref=ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "patch": "@@ -15,8 +15,6 @@ void\n foo (void)\n {\n   char g[(char *) &((struct S *) 0)->b - (char *) 0]; // { dg-error \"40:size of array .g. is not an integral constant-expression\" }\n-\t\t\t\t\t\t      // { dg-error \"narrowing conversion\" \"\" { target c++11 } .-1 }\n-\t\t\t\t\t\t      // { dg-message \"expression has a constant value but is not a C.. constant-expression\" \"\" { target c++11 } .-2 }\n   char h[(__SIZE_TYPE__) &((struct S *) 8)->b];\t      // { dg-error \"10:size of array .h. is not an integral constant-expression\" }\n   bar (g, h);\n }"}]}