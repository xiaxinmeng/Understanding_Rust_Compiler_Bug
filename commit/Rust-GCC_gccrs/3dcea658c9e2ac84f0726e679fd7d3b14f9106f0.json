{"sha": "3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjZWE2NThjOWUyYWM4NGYwNzI2ZTY3OWZkN2QzYjE0ZjkxMDZmMA==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-02-03T18:22:57Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-06-12T03:45:19Z"}, "message": "x86: Add UNSPECV_PATCHABLE_AREA\n\nCurrently patchable area is at the wrong place.  It is placed immediately\nafter function label, before both .cfi_startproc and ENDBR.  This patch\nadds UNSPECV_PATCHABLE_AREA for pseudo patchable area instruction and\nchanges ENDBR insertion pass to also insert patchable area instruction.\nTARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY is defined to avoid placing\npatchable area before .cfi_startproc and ENDBR.\n\ngcc/\n\n\tPR target/93492\n\t* config/i386/i386-features.c (rest_of_insert_endbranch):\n\tRenamed to ...\n\t(rest_of_insert_endbr_and_patchable_area): Change return type\n\tto void. Add need_endbr and patchable_area_size arguments.\n\tDon't call timevar_push nor timevar_pop.  Replace\n\tendbr_queued_at_entrance with insn_queued_at_entrance.  Insert\n\tUNSPECV_PATCHABLE_AREA for patchable area.\n\t(pass_data_insert_endbranch): Renamed to ...\n\t(pass_data_insert_endbr_and_patchable_area): This.  Change\n\tpass name to endbr_and_patchable_area.\n\t(pass_insert_endbranch): Renamed to ...\n\t(pass_insert_endbr_and_patchable_area): This.  Add need_endbr\n\tand patchable_area_size;.\n\t(pass_insert_endbr_and_patchable_area::gate): Set and check\n\tneed_endbr and patchable_area_size.\n\t(pass_insert_endbr_and_patchable_area::execute): Call\n\ttimevar_push and timevar_pop.  Pass need_endbr and\n\tpatchable_area_size to rest_of_insert_endbr_and_patchable_area.\n\t(make_pass_insert_endbranch): Renamed to ...\n\t(make_pass_insert_endbr_and_patchable_area): This.\n\t* config/i386/i386-passes.def: Replace pass_insert_endbranch\n\twith pass_insert_endbr_and_patchable_area.\n\t* config/i386/i386-protos.h (ix86_output_patchable_area): New.\n\t(make_pass_insert_endbranch): Renamed to ...\n\t(make_pass_insert_endbr_and_patchable_area): This.\n\t* config/i386/i386.c (ix86_asm_output_function_label): Set\n\tfunction_label_emitted to true.\n\t(ix86_print_patchable_function_entry): New function.\n\t(ix86_output_patchable_area): Likewise.\n\t(x86_function_profiler): Replace endbr_queued_at_entrance with\n\tinsn_queued_at_entrance.  Generate ENDBR only for TYPE_ENDBR.\n\tCall ix86_output_patchable_area to generate patchable area if\n\tneeded.\n\t(TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY): New.\n\t* config/i386/i386.h (queued_insn_type): New.\n\t(machine_function): Add function_label_emitted.  Replace\n\tendbr_queued_at_entrance with insn_queued_at_entrance.\n\t* config/i386/i386.md (UNSPECV_PATCHABLE_AREA): New.\n\t(patchable_area): New.\n\ngcc/testsuite/\n\n\tPR target/93492\n\t* gcc.target/i386/pr93492-1.c: New test.\n\t* gcc.target/i386/pr93492-2.c: Likewise.\n\t* gcc.target/i386/pr93492-3.c: Likewise.\n\t* gcc.target/i386/pr93492-4.c: Likewise.\n\t* gcc.target/i386/pr93492-5.c: Likewise.", "tree": {"sha": "8d46980f42dd2aa7d8ab08541276d2ebe7398bed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d46980f42dd2aa7d8ab08541276d2ebe7398bed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e68e80c8ddb961130b59528d1b865a7143c40537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68e80c8ddb961130b59528d1b865a7143c40537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68e80c8ddb961130b59528d1b865a7143c40537"}], "stats": {"total": 352, "additions": 296, "deletions": 56}, "files": [{"sha": "535fc7e981da3c4414512643618679693a13e7ce", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 92, "deletions": 50, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -1946,48 +1946,83 @@ make_pass_stv (gcc::context *ctxt)\n   return new pass_stv (ctxt);\n }\n \n-/* Inserting ENDBRANCH instructions.  */\n+/* Inserting ENDBR and pseudo patchable-area instructions.  */\n \n-static unsigned int\n-rest_of_insert_endbranch (void)\n+static void\n+rest_of_insert_endbr_and_patchable_area (bool need_endbr,\n+\t\t\t\t\t unsigned int patchable_area_size)\n {\n-  timevar_push (TV_MACH_DEP);\n-\n-  rtx cet_eb;\n+  rtx endbr;\n   rtx_insn *insn;\n+  rtx_insn *endbr_insn = NULL;\n   basic_block bb;\n \n-  /* Currently emit EB if it's a tracking function, i.e. 'nocf_check' is\n-     absent among function attributes.  Later an optimization will be\n-     introduced to make analysis if an address of a static function is\n-     taken.  A static function whose address is not taken will get a\n-     nocf_check attribute.  This will allow to reduce the number of EB.  */\n-\n-  if (!lookup_attribute (\"nocf_check\",\n-\t\t\t TYPE_ATTRIBUTES (TREE_TYPE (cfun->decl)))\n-      && (!flag_manual_endbr\n-\t  || lookup_attribute (\"cf_check\",\n-\t\t\t       DECL_ATTRIBUTES (cfun->decl)))\n-      && (!cgraph_node::get (cfun->decl)->only_called_directly_p ()\n-\t  || ix86_cmodel == CM_LARGE\n-\t  || ix86_cmodel == CM_LARGE_PIC\n-\t  || flag_force_indirect_call\n-\t  || (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-\t      && DECL_DLLIMPORT_P (cfun->decl))))\n-    {\n-      /* Queue ENDBR insertion to x86_function_profiler.  */\n+  if (need_endbr)\n+    {\n+      /* Currently emit EB if it's a tracking function, i.e. 'nocf_check'\n+\t is absent among function attributes.  Later an optimization will\n+\t be introduced to make analysis if an address of a static function\n+\t is taken.  A static function whose address is not taken will get\n+\t a nocf_check attribute.  This will allow to reduce the number of\n+\t EB.  */\n+      if (!lookup_attribute (\"nocf_check\",\n+\t\t\t     TYPE_ATTRIBUTES (TREE_TYPE (cfun->decl)))\n+\t  && (!flag_manual_endbr\n+\t      || lookup_attribute (\"cf_check\",\n+\t\t\t\t   DECL_ATTRIBUTES (cfun->decl)))\n+\t  && (!cgraph_node::get (cfun->decl)->only_called_directly_p ()\n+\t      || ix86_cmodel == CM_LARGE\n+\t      || ix86_cmodel == CM_LARGE_PIC\n+\t      || flag_force_indirect_call\n+\t      || (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\t\t  && DECL_DLLIMPORT_P (cfun->decl))))\n+\t{\n+\t  if (crtl->profile && flag_fentry)\n+\t    {\n+\t      /* Queue ENDBR insertion to x86_function_profiler.\n+\t\t NB: Any patchable-area insn will be inserted after\n+\t\t ENDBR.  */\n+\t      cfun->machine->insn_queued_at_entrance = TYPE_ENDBR;\n+\t    }\n+\t  else\n+\t    {\n+\t      endbr = gen_nop_endbr ();\n+\t      bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n+\t      rtx_insn *insn = BB_HEAD (bb);\n+\t      endbr_insn = emit_insn_before (endbr, insn);\n+\t    }\n+\t}\n+    }\n+\n+  if (patchable_area_size)\n+    {\n       if (crtl->profile && flag_fentry)\n-\tcfun->machine->endbr_queued_at_entrance = true;\n+\t{\n+\t  /* Queue patchable-area insertion to x86_function_profiler.\n+\t     NB: If there is a queued ENDBR, x86_function_profiler\n+\t     will also handle patchable-area.  */\n+\t  if (!cfun->machine->insn_queued_at_entrance)\n+\t    cfun->machine->insn_queued_at_entrance = TYPE_PATCHABLE_AREA;\n+\t}\n       else\n \t{\n-\t  cet_eb = gen_nop_endbr ();\n-\n-\t  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n-\t  insn = BB_HEAD (bb);\n-\t  emit_insn_before (cet_eb, insn);\n+\t  rtx patchable_area\n+\t    = gen_patchable_area (GEN_INT (patchable_area_size),\n+\t\t\t\t  GEN_INT (crtl->patch_area_entry == 0));\n+\t  if (endbr_insn)\n+\t    emit_insn_after (patchable_area, endbr_insn);\n+\t  else\n+\t    {\n+\t      bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n+\t      insn = BB_HEAD (bb);\n+\t      emit_insn_before (patchable_area, insn);\n+\t    }\n \t}\n     }\n \n+  if (!need_endbr)\n+    return;\n+\n   bb = 0;\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -1996,7 +2031,6 @@ rest_of_insert_endbranch (void)\n \t{\n \t  if (CALL_P (insn))\n \t    {\n-\t      bool need_endbr;\n \t      need_endbr = find_reg_note (insn, REG_SETJMP, NULL) != NULL;\n \t      if (!need_endbr && !SIBLING_CALL_P (insn))\n \t\t{\n@@ -2027,8 +2061,8 @@ rest_of_insert_endbranch (void)\n \t      /* Generate ENDBRANCH after CALL, which can return more than\n \t\t twice, setjmp-like functions.  */\n \n-\t      cet_eb = gen_nop_endbr ();\n-\t      emit_insn_after_setloc (cet_eb, insn, INSN_LOCATION (insn));\n+\t      endbr = gen_nop_endbr ();\n+\t      emit_insn_after_setloc (endbr, insn, INSN_LOCATION (insn));\n \t      continue;\n \t    }\n \n@@ -2058,31 +2092,30 @@ rest_of_insert_endbranch (void)\n \t\t  dest_blk = e->dest;\n \t\t  insn = BB_HEAD (dest_blk);\n \t\t  gcc_assert (LABEL_P (insn));\n-\t\t  cet_eb = gen_nop_endbr ();\n-\t\t  emit_insn_after (cet_eb, insn);\n+\t\t  endbr = gen_nop_endbr ();\n+\t\t  emit_insn_after (endbr, insn);\n \t\t}\n \t      continue;\n \t    }\n \n \t  if (LABEL_P (insn) && LABEL_PRESERVE_P (insn))\n \t    {\n-\t      cet_eb = gen_nop_endbr ();\n-\t      emit_insn_after (cet_eb, insn);\n+\t      endbr = gen_nop_endbr ();\n+\t      emit_insn_after (endbr, insn);\n \t      continue;\n \t    }\n \t}\n     }\n \n-  timevar_pop (TV_MACH_DEP);\n-  return 0;\n+  return;\n }\n \n namespace {\n \n-const pass_data pass_data_insert_endbranch =\n+const pass_data pass_data_insert_endbr_and_patchable_area =\n {\n   RTL_PASS, /* type.  */\n-  \"cet\", /* name.  */\n+  \"endbr_and_patchable_area\", /* name.  */\n   OPTGROUP_NONE, /* optinfo_flags.  */\n   TV_MACH_DEP, /* tv_id.  */\n   0, /* properties_required.  */\n@@ -2092,32 +2125,41 @@ const pass_data pass_data_insert_endbranch =\n   0, /* todo_flags_finish.  */\n };\n \n-class pass_insert_endbranch : public rtl_opt_pass\n+class pass_insert_endbr_and_patchable_area : public rtl_opt_pass\n {\n public:\n-  pass_insert_endbranch (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_insert_endbranch, ctxt)\n+  pass_insert_endbr_and_patchable_area (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_insert_endbr_and_patchable_area, ctxt)\n   {}\n \n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return ((flag_cf_protection & CF_BRANCH));\n+      need_endbr = (flag_cf_protection & CF_BRANCH) != 0;\n+      patchable_area_size = crtl->patch_area_size - crtl->patch_area_entry;\n+      return need_endbr || patchable_area_size;\n     }\n \n   virtual unsigned int execute (function *)\n     {\n-      return rest_of_insert_endbranch ();\n+      timevar_push (TV_MACH_DEP);\n+      rest_of_insert_endbr_and_patchable_area (need_endbr,\n+\t\t\t\t\t       patchable_area_size);\n+      timevar_pop (TV_MACH_DEP);\n+      return 0;\n     }\n \n-}; // class pass_insert_endbranch\n+private:\n+  bool need_endbr;\n+  unsigned int patchable_area_size;\n+}; // class pass_insert_endbr_and_patchable_area\n \n } // anon namespace\n \n rtl_opt_pass *\n-make_pass_insert_endbranch (gcc::context *ctxt)\n+make_pass_insert_endbr_and_patchable_area (gcc::context *ctxt)\n {\n-  return new pass_insert_endbranch (ctxt);\n+  return new pass_insert_endbr_and_patchable_area (ctxt);\n }\n \n /* At entry of the nearest common dominator for basic blocks with"}, {"sha": "d83c7b956b1d2e9b96e3405f0062168e3c1c68e5", "filename": "gcc/config/i386/i386-passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-passes.def?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -30,6 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n      CONSTM1_RTX generated by the STV pass can be CSEed.  */\n   INSERT_PASS_BEFORE (pass_cse2, 1, pass_stv, true /* timode_p */);\n \n-  INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_endbranch);\n+  INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_endbr_and_patchable_area);\n \n   INSERT_PASS_AFTER (pass_combine, 1, pass_remove_partial_avx_dependency);"}, {"sha": "e5574496bb7ed5591f4488178eab5ae7b73318cb", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -89,6 +89,8 @@ extern const char *output_fp_compare (rtx_insn *, rtx*, bool, bool);\n extern const char *output_adjust_stack_and_probe (rtx);\n extern const char *output_probe_stack_range (rtx, rtx);\n \n+extern void ix86_output_patchable_area (unsigned int, bool);\n+\n extern void ix86_expand_clear (rtx);\n extern void ix86_expand_move (machine_mode, rtx[]);\n extern void ix86_expand_vector_move (machine_mode, rtx[]);\n@@ -378,6 +380,7 @@ class rtl_opt_pass;\n \n extern rtl_opt_pass *make_pass_insert_vzeroupper (gcc::context *);\n extern rtl_opt_pass *make_pass_stv (gcc::context *);\n-extern rtl_opt_pass *make_pass_insert_endbranch (gcc::context *);\n+extern rtl_opt_pass *make_pass_insert_endbr_and_patchable_area\n+  (gcc::context *);\n extern rtl_opt_pass *make_pass_remove_partial_avx_dependency\n   (gcc::context *);"}, {"sha": "3b776c08a2208cbc14beb9e4f4b35fa60e778f72", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -1562,6 +1562,9 @@ ix86_asm_output_function_label (FILE *asm_out_file, const char *fname,\n {\n   bool is_ms_hook = ix86_function_ms_hook_prologue (decl);\n \n+  if (cfun)\n+    cfun->machine->function_label_emitted = true;\n+\n   if (is_ms_hook)\n     {\n       int i, filler_count = (TARGET_64BIT ? 32 : 16);\n@@ -9367,6 +9370,38 @@ ix86_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED)\n     }\n }\n \n+/* Implement TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY.  */\n+\n+void\n+ix86_print_patchable_function_entry (FILE *file,\n+\t\t\t\t     unsigned HOST_WIDE_INT patch_area_size,\n+\t\t\t\t     bool record_p)\n+{\n+  if (cfun->machine->function_label_emitted)\n+    {\n+      /* NB: When ix86_print_patchable_function_entry is called after\n+\t function table has been emitted, we have inserted or queued\n+\t a pseudo UNSPECV_PATCHABLE_AREA instruction at the proper\n+\t place.  There is nothing to do here.  */\n+      return;\n+    }\n+\n+  default_print_patchable_function_entry (file, patch_area_size,\n+\t\t\t\t\t  record_p);\n+}\n+\n+/* Output patchable area.  NB: default_print_patchable_function_entry\n+   isn't available in i386.md.  */\n+\n+void\n+ix86_output_patchable_area (unsigned int patch_area_size,\n+\t\t\t    bool record_p)\n+{\n+  default_print_patchable_function_entry (asm_out_file,\n+\t\t\t\t\t  patch_area_size,\n+\t\t\t\t\t  record_p);\n+}\n+\n /* Return a scratch register to use in the split stack prologue.  The\n    split stack prologue is used for -fsplit-stack.  It is the first\n    instructions in the function, even before the regular prologue.\n@@ -20418,8 +20453,16 @@ current_fentry_section (const char **name)\n void\n x86_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)\n {\n-  if (cfun->machine->endbr_queued_at_entrance)\n-    fprintf (file, \"\\t%s\\n\", TARGET_64BIT ? \"endbr64\" : \"endbr32\");\n+  if (cfun->machine->insn_queued_at_entrance)\n+    {\n+      if (cfun->machine->insn_queued_at_entrance == TYPE_ENDBR)\n+\tfprintf (file, \"\\t%s\\n\", TARGET_64BIT ? \"endbr64\" : \"endbr32\");\n+      unsigned int patch_area_size\n+\t= crtl->patch_area_size - crtl->patch_area_entry;\n+      if (patch_area_size)\n+\tix86_output_patchable_area (patch_area_size,\n+\t\t\t\t    crtl->patch_area_entry == 0);\n+    }\n \n   const char *mcount_name = MCOUNT_NAME;\n \n@@ -23019,6 +23062,10 @@ ix86_run_selftests (void)\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE ix86_output_function_epilogue\n \n+#undef TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY\n+#define TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY \\\n+  ix86_print_patchable_function_entry\n+\n #undef TARGET_ENCODE_SECTION_INFO\n #ifndef SUBTARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO ix86_encode_section_info"}, {"sha": "5d0ea16a0bb68a3cae9046a27535b6a13428ccbc", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -2761,6 +2761,13 @@ enum function_type\n   TYPE_EXCEPTION\n };\n \n+enum queued_insn_type\n+{\n+  TYPE_NONE = 0,\n+  TYPE_ENDBR,\n+  TYPE_PATCHABLE_AREA\n+};\n+\n struct GTY(()) machine_function {\n   struct stack_local_entry *stack_locals;\n   int varargs_gpr_size;\n@@ -2851,8 +2858,11 @@ struct GTY(()) machine_function {\n   /* Nonzero if the function places outgoing arguments on stack.  */\n   BOOL_BITFIELD outgoing_args_on_stack : 1;\n \n-  /* If true, ENDBR is queued at function entrance.  */\n-  BOOL_BITFIELD endbr_queued_at_entrance : 1;\n+  /* If true, ENDBR or patchable area is queued at function entrance.  */\n+  ENUM_BITFIELD(queued_insn_type) insn_queued_at_entrance : 2;\n+\n+  /* If true, the function label has been emitted.  */\n+  BOOL_BITFIELD function_label_emitted : 1;\n \n   /* True if the function needs a stack frame.  */\n   BOOL_BITFIELD stack_frame_required : 1;"}, {"sha": "4d455584f09424e602459e5ced1890e5e1ab9f26", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -307,6 +307,9 @@\n \n   ;; For SERIALIZE support\n   UNSPECV_SERIALIZE\n+\n+  ;; For patchable area support\n+  UNSPECV_PATCHABLE_AREA\n ])\n \n ;; Constants to represent rounding modes in the ROUND instruction\n@@ -21529,6 +21532,20 @@\n   [(set_attr \"type\" \"other\")\n    (set_attr \"length\" \"3\")])\n \n+(define_insn \"patchable_area\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\")\n+\t\t     (match_operand 1 \"const_int_operand\")]\n+\t\t    UNSPECV_PATCHABLE_AREA)]\n+  \"\"\n+{\n+  ix86_output_patchable_area (INTVAL (operands[0]),\n+\t\t\t      INTVAL (operands[1]) != 0);\n+  return \"\";\n+}\n+  [(set (attr \"length\") (symbol_ref \"INTVAL (operands[0])\"))\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"modrm\" \"0\")])\n+\n (include \"mmx.md\")\n (include \"sse.md\")\n (include \"sync.md\")"}, {"sha": "f978d2e5220d31d6bec095789f8341cbc0ae8552", "filename": "gcc/testsuite/gcc.target/i386/pr93492-1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-1.c?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do \"compile\" } */\n+/* { dg-options \"-O1 -fcf-protection -mmanual-endbr\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/* Note: this test only checks the instructions in the function bodies,\n+   not the placement of the patch label or nops before the function.  */\n+\n+/*\n+**f10_none:\n+**\tnop\n+**\tret\n+*/\n+void\n+__attribute__ ((nocf_check,patchable_function_entry (1, 0)))\n+f10_none (void)\n+{\n+}\n+\n+/*\n+**f10_endbr:\n+**\tendbr(32|64)\n+**\tnop\n+**\tret\n+*/\n+void\n+__attribute__ ((cf_check,patchable_function_entry (1, 0)))\n+f10_endbr (void)\n+{\n+}\n+\n+/*\n+**f11_none:\n+**\tret\n+*/\n+void\n+__attribute__ ((nocf_check,patchable_function_entry (1, 1)))\n+f11_none (void)\n+{\n+}\n+\n+/*\n+**f11_endbr:\n+**\tendbr(32|64)\n+**\tret\n+*/\n+void\n+__attribute__ ((cf_check,patchable_function_entry (1, 1)))\n+f11_endbr (void)\n+{\n+}\n+\n+/*\n+**f21_none:\n+**\tnop\n+**\tret\n+*/\n+void\n+__attribute__ ((nocf_check,patchable_function_entry (2, 1)))\n+f21_none (void)\n+{\n+}\n+\n+/*\n+**f21_endbr:\n+**\tendbr(32|64)\n+**\tnop\n+**\tret\n+*/\n+void\n+__attribute__ ((cf_check,patchable_function_entry (2, 1)))\n+f21_endbr (void)\n+{\n+}"}, {"sha": "ec26d4cc3674d2b547eb3ed1ed434c60f8fe0ba6", "filename": "gcc/testsuite/gcc.target/i386/pr93492-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-2.c?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do \"compile\" } */\n+/* { dg-options \"-O1 -fcf-protection -mmanual-endbr -fasynchronous-unwind-tables\" } */\n+\n+/* Test the placement of the .LPFE1 label.  */\n+\n+void\n+__attribute__ ((cf_check,patchable_function_entry (1, 0)))\n+f10_endbr (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler \"\\t\\.cfi_startproc\\n\\tendbr(32|64)\\n.*\\.LPFE1:\\n\\tnop\\n\\tret\\n\" } } */"}, {"sha": "1f03c6271202b8bf64bdafe9a9a478a87b285127", "filename": "gcc/testsuite/gcc.target/i386/pr93492-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-3.c?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do \"compile\" } */\n+/* { dg-require-effective-target mfentry } */\n+/* { dg-options \"-O1 -fcf-protection -mmanual-endbr -mfentry -pg -fasynchronous-unwind-tables\" } */\n+\n+/* Test the placement of the .LPFE1 label.  */\n+\n+void\n+__attribute__ ((cf_check,patchable_function_entry (1, 0)))\n+f10_endbr (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler \"\\t\\.cfi_startproc\\n\\tendbr(32|64)\\n.*\\.LPFE1:\\n\\tnop\\n1:\\tcall\\t__fentry__\\n\\tret\\n\" } } */"}, {"sha": "d193df8e66d968ffb37fc2a48d99349438e0856e", "filename": "gcc/testsuite/gcc.target/i386/pr93492-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-4.c?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do \"compile\" } */\n+/* { dg-options \"-O1 -fpatchable-function-entry=1 -fasynchronous-unwind-tables\" } */\n+\n+/* Test the placement of the .LPFE1 label.  */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler \"\\t\\.cfi_startproc\\n.*\\.LPFE1:\\n\\tnop\\n\\tret\\n\" } } */"}, {"sha": "d04077c6007a95ccfbedf35e69306dacbc93305a", "filename": "gcc/testsuite/gcc.target/i386/pr93492-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcea658c9e2ac84f0726e679fd7d3b14f9106f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93492-5.c?ref=3dcea658c9e2ac84f0726e679fd7d3b14f9106f0", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do \"compile\" } */\n+/* { dg-require-effective-target mfentry } */\n+/* { dg-options \"-O1 -fpatchable-function-entry=1 -mfentry -pg -fasynchronous-unwind-tables\" } */\n+\n+/* Test the placement of the .LPFE1 label.  */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler \"\\t\\.cfi_startproc\\n.*\\.LPFE1:\\n\\tnop\\n1:\\tcall\\t__fentry__\\n\\tret\\n\" } } */"}]}