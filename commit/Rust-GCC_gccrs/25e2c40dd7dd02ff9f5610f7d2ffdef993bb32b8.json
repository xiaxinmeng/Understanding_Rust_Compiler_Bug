{"sha": "25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlMmM0MGRkN2RkMDJmZjlmNTYxMGY3ZDJmZmRlZjk5M2JiMzJiOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-10-21T11:04:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-10-21T11:04:20Z"}, "message": "cgraph.c (dump_cgraph_node): Dump alias flag.\n\n\t* cgraph.c (dump_cgraph_node): Dump alias flag.\n\t* cgraphunit.c (handle_alias_pairs): Handle weakrefs with no destination.\n\t(get_alias_symbol): New function.\n\t(output_weakrefs): Output also weakrefs with no destinatoin.\n\t(lto_output_node): Output weakref alias flag when at function boundary.\n\nFrom-SVN: r180292", "tree": {"sha": "29bdffd75d1c506f358ffd6cda8765372ce7fae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29bdffd75d1c506f358ffd6cda8765372ce7fae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/comments", "author": null, "committer": null, "parents": [{"sha": "49008cb98e890a588788661fb00763910a891b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49008cb98e890a588788661fb00763910a891b38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49008cb98e890a588788661fb00763910a891b38"}], "stats": {"total": 62, "additions": 55, "deletions": 7}, "files": [{"sha": "235016536ba7e542d6b3de76b70448bc888eabb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "patch": "@@ -1,3 +1,11 @@\n+2011-10-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (dump_cgraph_node): Dump alias flag.\n+\t* cgraphunit.c (handle_alias_pairs): Handle weakrefs with no destination.\n+\t(get_alias_symbol): New function.\n+\t(output_weakrefs): Output also weakrefs with no destinatoin.\n+\t(lto_output_node): Output weakref alias flag when at function boundary.\n+\n 2011-10-21  Andrew Stubbs  <ams@codesourcery.com>\n \n \tPR target/50809"}, {"sha": "f056d3db58e6eefdfa0c566c456df565bb9ad8b9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "patch": "@@ -1838,6 +1838,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" only_called_at_startup\");\n   if (node->only_called_at_exit)\n     fprintf (f, \" only_called_at_exit\");\n+  else if (node->alias)\n+    fprintf (f, \" alias\");\n \n   fprintf (f, \"\\n\");\n \n@@ -2567,7 +2569,7 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n   for (e = node->callers; e; e = e->next_caller)\n     if (e->caller->thunk.thunk_p\n \t&& (include_overwritable\n-\t    || cgraph_function_body_availability (e->caller)))\n+\t    || cgraph_function_body_availability (e->caller) > AVAIL_OVERWRITABLE))\n       if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n \t\t\t\t\t      include_overwritable))\n \treturn true;"}, {"sha": "25d7561cbdbf37fb18f3e22a836084e98f217be4", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "patch": "@@ -1249,6 +1249,21 @@ handle_alias_pairs (void)\n \t  varpool_create_variable_alias (p->decl, target_vnode->decl);\n \t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n \t}\n+      /* Weakrefs with target not defined in current unit are easy to handle; they\n+\t behave just as external variables except we need to note the alias flag\n+\t to later output the weakref pseudo op into asm file.  */\n+      else if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)) != NULL\n+\t       && (TREE_CODE (p->decl) == FUNCTION_DECL\n+\t\t   ? (varpool_node_for_asm (p->target) == NULL)\n+\t\t   : (cgraph_node_for_asm (p->target) == NULL)))\n+\t{\n+\t  if (TREE_CODE (p->decl) == FUNCTION_DECL)\n+\t    cgraph_get_create_node (p->decl)->alias = true;\n+\t  else\n+\t    varpool_get_node (p->decl)->alias = true;\n+\t  DECL_EXTERNAL (p->decl) = 1;\n+\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t}\n       else\n \t{\n \t  if (dump_file)\n@@ -2064,6 +2079,18 @@ ipa_passes (void)\n   bitmap_obstack_release (NULL);\n }\n \n+\n+/* Return string alias is alias of.  */\n+\n+static tree\n+get_alias_symbol (tree decl)\n+{\n+  tree alias = lookup_attribute (\"alias\", DECL_ATTRIBUTES (decl));\n+  return get_identifier (TREE_STRING_POINTER\n+\t\t\t  (TREE_VALUE (TREE_VALUE (alias))));\n+}\n+\n+\n /* Weakrefs may be associated to external decls and thus not output\n    at expansion time.  Emit all neccesary aliases.  */\n \n@@ -2073,15 +2100,17 @@ output_weakrefs (void)\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->alias && node->thunk.alias && DECL_EXTERNAL (node->decl)\n+    if (node->alias && DECL_EXTERNAL (node->decl)\n         && !TREE_ASM_WRITTEN (node->decl))\n       assemble_alias (node->decl,\n-\t\t      DECL_ASSEMBLER_NAME (node->thunk.alias));\n+\t\t      node->thunk.alias ? DECL_ASSEMBLER_NAME (node->thunk.alias)\n+\t\t      : get_alias_symbol (node->decl));\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    if (vnode->alias && vnode->alias_of && DECL_EXTERNAL (vnode->decl)\n+    if (vnode->alias && DECL_EXTERNAL (vnode->decl)\n         && !TREE_ASM_WRITTEN (vnode->decl))\n       assemble_alias (vnode->decl,\n-\t\t      DECL_ASSEMBLER_NAME (vnode->alias_of));\n+\t\t      vnode->alias_of ? DECL_ASSEMBLER_NAME (vnode->alias_of)\n+\t\t      : get_alias_symbol (vnode->decl));\n }\n \n "}, {"sha": "98ae19b4aab5385c3a6475d473085f32d7401e14", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "patch": "@@ -512,7 +512,13 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t\t     || referenced_from_other_partition_p (&node->ref_list, set, vset)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n-  bp_pack_value (&bp, node->alias && !boundary_p, 1);\n+  /* Real aliases in a boundary become non-aliases. However we still stream\n+     alias info on weakrefs. \n+     TODO: We lose a bit of information here - when we know that variable is\n+     defined in other unit, we may use the info on aliases to resolve \n+     symbol1 != symbol2 type tests that we can do only for locally defined objects\n+     otherwise.  */\n+  bp_pack_value (&bp, node->alias && (!boundary_p || DECL_EXTERNAL (node->decl)), 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n@@ -530,7 +536,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n     }\n-  if ((node->alias || node->thunk.thunk_p) && !boundary_p)\n+  if ((node->alias || node->thunk.thunk_p)\n+      && (!boundary_p || (node->alias && DECL_EXTERNAL (node->decl))))\n     {\n       streamer_write_hwi_in_range (ob->main_stream, 0, 1,\n \t\t\t\t\tnode->thunk.alias != NULL);"}, {"sha": "c50a97ec20539e7b4f80ed3c10152fee8f8cfee9", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=25e2c40dd7dd02ff9f5610f7d2ffdef993bb32b8", "patch": "@@ -1481,6 +1481,8 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n {\n   varpool_node_set_iterator vsi;\n \n+  vnode = varpool_variable_node (vnode, NULL);\n+\n   /* If NODE is already there, we have nothing to do.  */\n   vsi = varpool_node_set_find (part->varpool_set, vnode);\n   if (!vsi_end_p (vsi))"}]}