{"sha": "6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNjNmVkNTBlMjUxMDAzMWY1ZjNhYTRmYzA2NmM2N2QwNDZkM2YwZA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-04-03T12:50:54Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-04-03T12:50:54Z"}, "message": "re PR target/70416 ([SH]: error: 'asm' operand requires impossible reload when building ruby2.3)\n\ngcc/\n\tPR target/70416\n\tPR target/67391\n\t* config/sh/sh.md (*addsi3): Allow pattern when reload_in_progress is\n\tset, but not for SP_REG operands.\n\ngcc/testsuite/\n\tPR target/70416\n\tPR target/67391\n\t* gcc.target/sh/torture/pr70416.c: New.\n\nFrom-SVN: r234702", "tree": {"sha": "0f5bfb80150be0b576ac3d522b85309d4797ece2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f5bfb80150be0b576ac3d522b85309d4797ece2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/comments", "author": null, "committer": null, "parents": [{"sha": "34d40e88a9c177dff4c6c30a642fd80efd0209b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d40e88a9c177dff4c6c30a642fd80efd0209b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d40e88a9c177dff4c6c30a642fd80efd0209b4"}], "stats": {"total": 164, "additions": 161, "deletions": 3}, "files": [{"sha": "40c0f46d30abef87e753d70e5322b80486c9d03b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "patch": "@@ -1,3 +1,10 @@\n+2016-04-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/70416\n+\tPR target/67391\n+\t* config/sh/sh.md (*addsi3): Allow pattern when reload_in_progress is\n+\tset, but not for SP_REG operands.\n+\n 2016-04-02  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/67376"}, {"sha": "0bb0f2b3038402c09cf0844a1099d2e30a51b515", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "patch": "@@ -2242,14 +2242,23 @@\n   [(set_attr \"type\" \"arith\")])\n \n ;; Old reload might generate add insns directly (not through the expander) for\n-;; the memory address of complex insns like atomic insns when reloading.\n+;; address register calculations when reloading, in which case it won't try\n+;; the addsi_scr pattern.  Because reload will sometimes try to validate\n+;; the generated insns and their constraints, this pattern must be\n+;; recognizable during and after reload.  However, when reload generates\n+;; address register calculations for the stack pointer, we don't allow this\n+;; pattern.  This will make reload prefer using indexed @(reg + reg) address\n+;; modes when the displacement of a @(disp + reg) doesn't fit.\n (define_insn_and_split \"*addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n \t\t (match_operand:SI 2 \"arith_or_int_operand\" \"rn\")))]\n   \"TARGET_SH1 && !sh_lra_p ()\n-   && reload_completed\n-   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n+   && (reload_completed || reload_in_progress)\n+   && !reg_overlap_mentioned_p (operands[0], operands[1])\n+   && (!reload_in_progress\n+       || ((!REG_P (operands[1]) || REGNO (operands[1]) != SP_REG)\n+\t   && (!REG_P (operands[2]) || REGNO (operands[2]) != SP_REG)))\"\n   \"#\"\n   \"&& 1\"\n   [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))]"}, {"sha": "ffee4f7fa25458d714f37d3f4a501d759e56a3c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "patch": "@@ -1,3 +1,9 @@\n+2016-04-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/70416\n+\tPR target/67391\n+\t* gcc.target/sh/torture/pr70416.c: New.\n+\n 2016-04-02  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/67376"}, {"sha": "b1123bee029a76553b0d6794f091b36537c22975", "filename": "gcc/testsuite/gcc.target/sh/torture/pr70416.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr70416.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr70416.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr70416.c?ref=6cc6ed50e2510031f5f3aa4fc066c67d046d3f0d", "patch": "@@ -0,0 +1,136 @@\n+/* { dg-additional-options \"-std=gnu99 -fpic\" }  */\n+/* { dg-do compile }  */\n+\n+typedef unsigned long VALUE;\n+typedef unsigned long ID;\n+\n+typedef struct rb_callable_method_entry_struct\n+{\n+  ID called_id;\n+  const VALUE owner;\n+} rb_callable_method_entry_t;\n+\n+typedef struct rb_iseq_struct rb_iseq_t;\n+\n+struct __jmp_buf_tag { int xx; };\n+typedef struct __jmp_buf_tag jmp_buf[1];\n+\n+struct rb_iseq_struct\n+{\n+  const struct iseq_catch_table *catch_table;\n+};\n+\n+typedef struct rb_control_frame_struct\n+{\n+  const VALUE *pc;\n+  VALUE *sp;\n+  const rb_iseq_t *iseq;\n+  VALUE flag;\n+  VALUE *ep;\n+} rb_control_frame_t;\n+\n+typedef jmp_buf rb_jmpbuf_t;\n+struct rb_vm_tag\n+{\n+  rb_jmpbuf_t buf;\n+}rb_ensure_list_t;\n+\n+typedef struct rb_thread_struct\n+{\n+  rb_control_frame_t *cfp;\n+  struct rb_vm_tag *tag;\n+} rb_thread_t;\n+\n+struct iseq_catch_table_entry\n+{\n+  const rb_iseq_t *iseq;\n+};\n+\n+struct iseq_catch_table\n+{\n+  unsigned int size;\n+};\n+\n+extern unsigned long long __sdt_unsp;\n+extern unsigned short ruby_cmethod__return_semaphore;\n+\n+struct ruby_dtrace_method_hook_args\n+{\n+  const char *classname;\n+  const char *methodname;\n+  const char *filename;\n+  int line_no;\n+};\n+\n+int ruby_th_dtrace_setup(rb_thread_t *th, VALUE klass, ID id, struct ruby_dtrace_method_hook_args *args);\n+int rb_threadptr_tag_state (rb_thread_t *th);\n+VALUE vm_exec_core (rb_thread_t *th, VALUE initial);\n+const rb_callable_method_entry_t *rb_vm_frame_method_entry (const rb_control_frame_t *cfp);\n+\n+struct vm_throw_data;\n+const rb_control_frame_t * THROW_DATA_CATCH_FRAME(const struct vm_throw_data *obj);\n+rb_control_frame_t * vm_push_frame(rb_thread_t *th, const rb_iseq_t *iseq, VALUE type, VALUE self, VALUE specval, VALUE cref_or_me, const VALUE *pc, VALUE *sp, int local_size, int stack_max);\n+\n+\n+VALUE vm_exec(rb_thread_t *th)\n+{\n+  int state;\n+  VALUE result;\n+  VALUE initial = 0;\n+  struct vm_throw_data *err;\n+  rb_thread_t * const _th = (th);\n+  struct rb_vm_tag _tag;\n+\n+  if ((state = (__builtin_setjmp((_tag.buf)) ? rb_threadptr_tag_state((_th)) : ((void)(_th->tag = &_tag), 0))) == 0)\n+  {\n+    result = vm_exec_core(th, initial);\n+  }\n+  else\n+  {\n+    unsigned int i;\n+    const struct iseq_catch_table_entry *entry;\n+    const struct iseq_catch_table *ct;\n+    unsigned long epc, cont_pc, cont_sp;\n+    const rb_iseq_t *catch_iseq;\n+    rb_control_frame_t *cfp;\n+    const rb_control_frame_t *escape_cfp;\n+\n+    while (th->cfp->pc == 0 || th->cfp->iseq == 0)\n+    {\n+      if (ruby_cmethod__return_semaphore)\n+      {\n+        struct ruby_dtrace_method_hook_args args;\n+        if (ruby_th_dtrace_setup(th, rb_vm_frame_method_entry(th->cfp)->owner, rb_vm_frame_method_entry(th->cfp)->called_id, &args))\n+        {\n+          __asm__ __volatile__ (\n+             \".asciz \\\"%n[_SDT_S1]@%[_SDT_A1] %n[_SDT_S2]@%[_SDT_A2] %n[_SDT_S3]@%[_SDT_A3] %n[_SDT_S4]@%[_SDT_A4]\\\"\\n\"\n+             :\n+             : [_SDT_S1] \"n\" (((!__extension__ (__builtin_constant_p ((((unsigned long long) (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.classname ) + 3) & -4) == 4, ( args.classname ), 0U))) __sdt_unsp) & ((unsigned long long)1 << (sizeof (unsigned long long) * 8 - 1))) == 0) || (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.classname ) + 3) & -4) == 4, ( args.classname ), 0U))) -1 > (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.classname ) + 3) & -4) == 4, ( args.classname ), 0U))) 0)) ? 1 : -1) * (int) ((__builtin_classify_type ( args.classname ) == 14 || __builtin_classify_type ( args.classname ) == 5) ? sizeof (void *) : sizeof ( args.classname ))),\n+               [_SDT_A1] \"nor\" (( args.classname )),\n+               [_SDT_S2] \"n\" (((!__extension__ (__builtin_constant_p ((((unsigned long long) (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.methodname ) + 3) & -4) == 4, ( args.methodname ), 0U))) __sdt_unsp) & ((unsigned long long)1 << (sizeof (unsigned long long) * 8 - 1))) == 0) || (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.methodname ) + 3) & -4) == 4, ( args.methodname ), 0U))) -1 > (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.methodname ) + 3) & -4) == 4, ( args.methodname ), 0U))) 0)) ? 1 : -1) * (int) ((__builtin_classify_type ( args.methodname ) == 14 || __builtin_classify_type ( args.methodname ) == 5) ? sizeof (void *) : sizeof ( args.methodname ))),\n+               [_SDT_A2] \"nor\" (( args.methodname )),\n+               [_SDT_S3] \"n\" (((!__extension__ (__builtin_constant_p ((((unsigned long long) (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.filename ) + 3) & -4) == 4, ( args.filename ), 0U))) __sdt_unsp) & ((unsigned long long)1 << (sizeof (unsigned long long) * 8 - 1))) == 0) || (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.filename ) + 3) & -4) == 4, ( args.filename ), 0U))) -1 > (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.filename ) + 3) & -4) == 4, ( args.filename ), 0U))) 0)) ? 1 : -1) * (int) ((__builtin_classify_type ( args.filename ) == 14 || __builtin_classify_type ( args.filename ) == 5) ? sizeof (void *) : sizeof ( args.filename ))),\n+               [_SDT_A3] \"nor\" (( args.filename )),\n+               [_SDT_S4] \"n\" (((!__extension__ (__builtin_constant_p ((((unsigned long long) (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.line_no ) + 3) & -4) == 4, ( args.line_no ), 0U))) __sdt_unsp) & ((unsigned long long)1 << (sizeof (unsigned long long) * 8 - 1))) == 0) || (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.line_no ) + 3) & -4) == 4, ( args.line_no ), 0U))) -1 > (__typeof (__builtin_choose_expr (((__builtin_classify_type ( args.line_no ) + 3) & -4) == 4, ( args.line_no ), 0U))) 0)) ? 1 : -1) * (int) ((__builtin_classify_type ( args.line_no ) == 14 || __builtin_classify_type ( args.line_no ) == 5) ? sizeof (void *) : sizeof ( args.line_no ))),\n+               [_SDT_A4] \"nor\" (( args.line_no ))\n+          );\n+        }\n+      }\n+    }\n+\n+    if (cfp == escape_cfp && !(((cfp)->flag & 0x0200) != 0))\n+      catch_iseq = entry->iseq;\n+\n+    if (state == 6)\n+    {\n+      escape_cfp = THROW_DATA_CATCH_FRAME(err);\n+\n+      if (ct)\n+        for (i = 0; i < ct->size; i++) { }\n+    }\n+    else\n+      ct = cfp->iseq->catch_table;\n+\n+    vm_push_frame(th, catch_iseq, 0xb1, 0, 1, 0, 0, 0, 5, 123);\n+  }\n+}"}]}