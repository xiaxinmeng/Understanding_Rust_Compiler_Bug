{"sha": "0dca9cd86cfd8221fb282b3fd858196065c10712", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjYTljZDg2Y2ZkODIyMWZiMjgyYjNmZDg1ODE5NjA2NWMxMDcxMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-11-06T10:55:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-11-06T10:55:13Z"}, "message": "i386.c (ix86_expand_prologue): Optimize stack checking for leaf functions without dynamic stack allocation.\n\n\t* config/i386/i386.c (ix86_expand_prologue): Optimize stack checking for\n\tleaf functions without dynamic stack allocation.\n\t* config/ia64/ia64.c (ia64_emit_probe_stack_range): Adjust.\n\t(ia64_expand_prologue): Likewise.\n\t* config/mips/mips.c (mips_expand_prologue): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n\t* config/sparc/sparc.c (sparc_expand_prologue): Likewise.\n\t(sparc_flat_expand_prologue): Likewise.\n\nFrom-SVN: r204450", "tree": {"sha": "22d0f3f446a2947d5bd7b23b793e89adfcf55670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22d0f3f446a2947d5bd7b23b793e89adfcf55670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dca9cd86cfd8221fb282b3fd858196065c10712", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dca9cd86cfd8221fb282b3fd858196065c10712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dca9cd86cfd8221fb282b3fd858196065c10712", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dca9cd86cfd8221fb282b3fd858196065c10712/comments", "author": null, "committer": null, "parents": [{"sha": "f054ff5b7c6afa260a9a3d07e8b59649dcf978f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f054ff5b7c6afa260a9a3d07e8b59649dcf978f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f054ff5b7c6afa260a9a3d07e8b59649dcf978f7"}], "stats": {"total": 262, "additions": 169, "deletions": 93}, "files": [{"sha": "677fba92c59b8b76106a9e2bd928aa0227d1f5e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dca9cd86cfd8221fb282b3fd858196065c10712", "patch": "@@ -1,3 +1,14 @@\n+2013-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/i386/i386.c (ix86_expand_prologue): Optimize stack checking for\n+\tleaf functions without dynamic stack allocation.\n+\t* config/ia64/ia64.c (ia64_emit_probe_stack_range): Adjust.\n+\t(ia64_expand_prologue): Likewise.\n+\t* config/mips/mips.c (mips_expand_prologue): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n+\t* config/sparc/sparc.c (sparc_expand_prologue): Likewise.\n+\t(sparc_flat_expand_prologue): Likewise.\n+\n 2013-11-06  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/arm_neon.h\n@@ -28,12 +39,12 @@\n \n 2013-11-06  Christian Bruel  <christian.bruel@st.com>\n \n-\t* gcc/config/sh/sh-mem.cc (sh_expand_cmpnstr, sh_expand_cmpstr):\n+\t* config/sh/sh-mem.cc (sh_expand_cmpnstr, sh_expand_cmpstr):\n \tFactorize probabilities, Use adjust_address instead of\n \tadjust_automodify_address when possible. Enable for optimize.\n \t(sh_expand_strlen): New function.\n-\t* gcc/config/sh/sh-protos.h (sh_expand_strlen): Declare.\n-\t* gcc/config/sh/sh.md (strlensi): New pattern.\n+\t* config/sh/sh-protos.h (sh_expand_strlen): Declare.\n+\t* config/sh/sh.md (strlensi): New pattern.\n \t(UNSPEC_BUILTIN_STRLEN): Define.\n \n 2013-11-06  Jakub Jelinek  <jakub@redhat.com>\n@@ -305,19 +316,19 @@\n \n 2013-11-04  Wei Mi  <wmi@google.com>\n \n-\t* gcc/config/i386/i386.c (memory_address_length): Extract a part\n+\t* config/i386/i386.c (memory_address_length): Extract a part\n \tof code to rip_relative_addr_p.\n \t(rip_relative_addr_p): New Function.\n \t(ix86_macro_fusion_p): Ditto.\n \t(ix86_macro_fusion_pair_p): Ditto.\n-\t* gcc/config/i386/i386.h: Add new tune features about macro-fusion.\n-\t* gcc/config/i386/x86-tune.def (DEF_TUNE): Ditto.\n-\t* gcc/doc/tm.texi: Generated.\n-\t* gcc/doc/tm.texi.in: Ditto.\n-\t* gcc/haifa-sched.c (try_group_insn): New Function.\n+\t* config/i386/i386.h: Add new tune features about macro-fusion.\n+\t* config/i386/x86-tune.def (DEF_TUNE): Ditto.\n+\t* doc/tm.texi: Generated.\n+\t* doc/tm.texi.in: Ditto.\n+\t* haifa-sched.c (try_group_insn): New Function.\n \t(group_insns_for_macro_fusion): Ditto.\n \t(sched_init): Call group_insns_for_macro_fusion.\n-\t* gcc/target.def: Add two hooks: macro_fusion_p and\n+\t* target.def: Add two hooks: macro_fusion_p and\n \tmacro_fusion_pair_p.\n \n 2013-11-04  Kostya Serebryany  <kcc@google.com>\n@@ -337,17 +348,17 @@\n \n 2013-11-04  Wei Mi  <wmi@google.com>\n \n-\t* gcc/config/i386/i386-c.c (ix86_target_macros_internal): Separate\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Separate\n \tPROCESSOR_COREI7_AVX out from PROCESSOR_COREI7.\n-\t* gcc/config/i386/i386.c (ix86_option_override_internal): Ditto.\n+\t* config/i386/i386.c (ix86_option_override_internal): Ditto.\n \t(ix86_issue_rate): Ditto.\n \t(ix86_adjust_cost): Ditto.\n \t(ia32_multipass_dfa_lookahead): Ditto.\n \t(ix86_sched_init_global): Ditto.\n \t(get_builtin_code_for_version): Ditto.\n-\t* gcc/config/i386/i386.h (enum target_cpu_default): Ditto.\n+\t* config/i386/i386.h (enum target_cpu_default): Ditto.\n \t(enum processor_type): Ditto.\n-\t* gcc/config/i386/x86-tune.def (DEF_TUNE): Ditto.\n+\t* config/i386/x86-tune.def (DEF_TUNE): Ditto.\n \n 2013-11-04  Vladimir Makarov  <vmakarov@redhat.com>\n \n@@ -903,7 +914,7 @@\n 2013-10-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR other/33426\n-\t* gcc/tree-cfg.c (replace_loop_annotate): Replace warning by\n+\t* tree-cfg.c (replace_loop_annotate): Replace warning by\n \twarning_at.\n \n 2013-10-30  Jason Merrill  <jason@redhat.com>\n@@ -1024,10 +1035,10 @@\n \n 2013-10-30  Christian Bruel  <christian.bruel@st.com>\n \n-\t* gcc/config/sh/sh-mem.cc (sh_expand_cmpnstr): New function.\n+\t* config/sh/sh-mem.cc (sh_expand_cmpnstr): New function.\n \t(sh_expand_cmpstr): Handle known align and schedule improvements.\n-\t* gcc/config/sh/sh-protos.h (sh_expand_cmpstrn): Declare.\n-\t* gcc/config/sh/sh.md (cmpstrnsi): New pattern.\n+\t* config/sh/sh-protos.h (sh_expand_cmpstrn): Declare.\n+\t* config/sh/sh.md (cmpstrnsi): New pattern.\n \n 2013-10-30  Martin Jambor  <mjambor@suse.cz>\n \n@@ -2303,7 +2314,7 @@\n \n 2013-10-24  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n-\t* gcc/config/arc/arc.c (arc_ccfsm_post_advance): Also handle\n+\t* config/arc/arc.c (arc_ccfsm_post_advance): Also handle\n \tTYPE_UNCOND_BRANCH.\n \t(arc_ifcvt) <case 1 and 2>: Check that arc_ccfsm_post_advance\n \tchanges statep->state.\n@@ -2335,12 +2346,12 @@\n 2013-10-25  Christian Bruel  <christian.bruel@st.com>\n \n \t* config.gcc (sh-*): Add sh-mem.o to extra_obj.\n-\t* gcc/config/sh/t-sh (sh-mem.o): New rule.\n-\t* gcc/config/sh/sh-mem.cc (expand_block_move): Moved here.\n+\t* config/sh/t-sh (sh-mem.o): New rule.\n+\t* config/sh/sh-mem.cc (expand_block_move): Moved here.\n \t(sh_expand_cmpstr): New function.\n-\t* gcc/config/sh/sh.c (force_into, expand_block_move): Move to sh-mem.c.\n-\t* gcc/config/sh/sh-protos.h (sh_expand_cmpstr): Declare.\n-\t* gcc/config/sh/sh.md (cmpstrsi, cmpstr_t): New patterns.\n+\t* config/sh/sh.c (force_into, expand_block_move): Move to sh-mem.c.\n+\t* config/sh/sh-protos.h (sh_expand_cmpstr): Declare.\n+\t* config/sh/sh.md (cmpstrsi, cmpstr_t): New patterns.\n \t(rotlhi3_8): Rename.\n \n 2013-10-24  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n@@ -3184,7 +3195,7 @@\n \n 2013-10-16  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n-\t* gcc/config/rs6000/vector.md (vec_unpacks_hi_v4sf): Correct for\n+\t* config/rs6000/vector.md (vec_unpacks_hi_v4sf): Correct for\n \tendianness.\n \t(vec_unpacks_lo_v4sf): Likewise.\n \t(vec_unpacks_float_hi_v4si): Likewise.\n@@ -3970,8 +3981,8 @@\n \t(anddi3_insn): Update type attribute.\n \t(xordi3_insn): Likewise.\n \t(one_cmpldi2): Likewise.\n-\t* gcc/config/arm/vfp.md (movhf_vfp_neon): Update type attribute.\n-\t* gcc/config/arm/neon.md (neon_mov): Update type attribute.\n+\t* config/arm/vfp.md (movhf_vfp_neon): Update type attribute.\n+\t* config/arm/neon.md (neon_mov): Update type attribute.\n \t(*movmisalign<mode>_neon_store): Likewise.\n \t(*movmisalign<mode>_neon_load): Likewise.\n \t(vec_set<mode>_internal): Likewise."}, {"sha": "0680dea7d62a7b34f459b44000a845bc1677b1c8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0dca9cd86cfd8221fb282b3fd858196065c10712", "patch": "@@ -10657,8 +10657,12 @@ ix86_expand_prologue (void)\n \n       if (STACK_CHECK_MOVING_SP)\n \t{\n-\t  ix86_adjust_stack_and_probe (allocate);\n-\t  allocate = 0;\n+\t  if (!(crtl->is_leaf && !cfun->calls_alloca\n+\t\t&& allocate <= PROBE_INTERVAL))\n+\t    {\n+\t      ix86_adjust_stack_and_probe (allocate);\n+\t      allocate = 0;\n+\t    }\n \t}\n       else\n \t{\n@@ -10668,9 +10672,26 @@ ix86_expand_prologue (void)\n \t    size = 0x80000000 - STACK_CHECK_PROTECT - 1;\n \n \t  if (TARGET_STACK_PROBE)\n-\t    ix86_emit_probe_stack_range (0, size + STACK_CHECK_PROTECT);\n+\t    {\n+\t      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t\t{\n+\t\t  if (size > PROBE_INTERVAL)\n+\t\t    ix86_emit_probe_stack_range (0, size);\n+\t\t}\n+\t      else\n+\t\tix86_emit_probe_stack_range (0, size + STACK_CHECK_PROTECT);\n+\t    }\n \t  else\n-\t    ix86_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\t    {\n+\t      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t\t{\n+\t\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t\t    ix86_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\t\t size - STACK_CHECK_PROTECT);\n+\t\t}\n+\t      else\n+\t\tix86_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\t    }\n \t}\n     }\n "}, {"sha": "971fe2f818917b42be8b9e4dbd8965f7d4bbff6f", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=0dca9cd86cfd8221fb282b3fd858196065c10712", "patch": "@@ -3206,61 +3206,54 @@ gen_fr_restore_x (rtx dest, rtx src, rtx offset ATTRIBUTE_UNUSED)\n #define BACKING_STORE_SIZE(N) ((N) > 0 ? ((N) + (N)/63 + 1) * 8 : 0)\n \n /* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n-   inclusive.  These are offsets from the current stack pointer.  SOL is the\n-   size of local registers.  ??? This clobbers r2 and r3.  */\n+   inclusive.  These are offsets from the current stack pointer.  BS_SIZE\n+   is the size of the backing store.  ??? This clobbers r2 and r3.  */\n \n static void\n-ia64_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size, int sol)\n+ia64_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size,\n+\t\t\t     int bs_size)\n {\n- /* On the IA-64 there is a second stack in memory, namely the Backing Store\n-    of the Register Stack Engine.  We also need to probe it after checking\n-    that the 2 stacks don't overlap.  */\n-  const int bs_size = BACKING_STORE_SIZE (sol);\n   rtx r2 = gen_rtx_REG (Pmode, GR_REG (2));\n   rtx r3 = gen_rtx_REG (Pmode, GR_REG (3));\n-\n-  /* Detect collision of the 2 stacks if necessary.  */\n-  if (bs_size > 0 || size > 0)\n-    {\n-      rtx p6 = gen_rtx_REG (BImode, PR_REG (6));\n-\n-      emit_insn (gen_bsp_value (r3));\n-      emit_move_insn (r2, GEN_INT (-(first + size)));\n-\n-      /* Compare current value of BSP and SP registers.  */\n-      emit_insn (gen_rtx_SET (VOIDmode, p6,\n-\t\t\t      gen_rtx_fmt_ee (LTU, BImode,\n-\t\t\t\t\t      r3, stack_pointer_rtx)));\n-\n-      /* Compute the address of the probe for the Backing Store (which grows\n-\t towards higher addresses).  We probe only at the first offset of\n-\t the next page because some OS (eg Linux/ia64) only extend the\n-\t backing store when this specific address is hit (but generate a SEGV\n-\t on other address).  Page size is the worst case (4KB).  The reserve\n-\t size is at least 4096 - (96 + 2) * 8 = 3312 bytes, which is enough.\n-\t Also compute the address of the last probe for the memory stack\n-\t (which grows towards lower addresses).  */\n-      emit_insn (gen_rtx_SET (VOIDmode, r3, plus_constant (Pmode, r3, 4095)));\n-      emit_insn (gen_rtx_SET (VOIDmode, r2,\n-\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx, r2)));\n-\n-      /* Compare them and raise SEGV if the former has topped the latter.  */\n-      emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n-\t\t\t\t    gen_rtx_fmt_ee (NE, VOIDmode, p6,\n-\t\t\t\t\t\t    const0_rtx),\n-\t\t\t\t    gen_rtx_SET (VOIDmode, p6,\n-\t\t\t\t\t\t gen_rtx_fmt_ee (GEU, BImode,\n-\t\t\t\t\t\t\t\t r3, r2))));\n-      emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      gen_rtx_ZERO_EXTRACT (DImode, r3, GEN_INT (12),\n-\t\t\t\t\t\t    const0_rtx),\n-\t\t\t      const0_rtx));\n-      emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n-\t\t\t\t    gen_rtx_fmt_ee (NE, VOIDmode, p6,\n-\t\t\t\t\t\t    const0_rtx),\n-\t\t\t\t    gen_rtx_TRAP_IF (VOIDmode, const1_rtx,\n-\t\t\t\t\t\t     GEN_INT (11))));\n-    }\n+  rtx p6 = gen_rtx_REG (BImode, PR_REG (6));\n+\n+  /* On the IA-64 there is a second stack in memory, namely the Backing Store\n+     of the Register Stack Engine.  We also need to probe it after checking\n+     that the 2 stacks don't overlap.  */\n+  emit_insn (gen_bsp_value (r3));\n+  emit_move_insn (r2, GEN_INT (-(first + size)));\n+\n+  /* Compare current value of BSP and SP registers.  */\n+  emit_insn (gen_rtx_SET (VOIDmode, p6,\n+\t\t\t  gen_rtx_fmt_ee (LTU, BImode,\n+\t\t\t\t\t  r3, stack_pointer_rtx)));\n+\n+  /* Compute the address of the probe for the Backing Store (which grows\n+     towards higher addresses).  We probe only at the first offset of\n+     the next page because some OS (eg Linux/ia64) only extend the\n+     backing store when this specific address is hit (but generate a SEGV\n+     on other address).  Page size is the worst case (4KB).  The reserve\n+     size is at least 4096 - (96 + 2) * 8 = 3312 bytes, which is enough.\n+     Also compute the address of the last probe for the memory stack\n+     (which grows towards lower addresses).  */\n+  emit_insn (gen_rtx_SET (VOIDmode, r3, plus_constant (Pmode, r3, 4095)));\n+  emit_insn (gen_rtx_SET (VOIDmode, r2,\n+\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx, r2)));\n+\n+  /* Compare them and raise SEGV if the former has topped the latter.  */\n+  emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n+\t\t\t\tgen_rtx_fmt_ee (NE, VOIDmode, p6, const0_rtx),\n+\t\t\t\tgen_rtx_SET (VOIDmode, p6,\n+\t\t\t\t\t     gen_rtx_fmt_ee (GEU, BImode,\n+\t\t\t\t\t\t\t     r3, r2))));\n+  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t  gen_rtx_ZERO_EXTRACT (DImode, r3, GEN_INT (12),\n+\t\t\t\t\t\tconst0_rtx),\n+\t\t\t  const0_rtx));\n+  emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n+\t\t\t\tgen_rtx_fmt_ee (NE, VOIDmode, p6, const0_rtx),\n+\t\t\t\tgen_rtx_TRAP_IF (VOIDmode, const1_rtx,\n+\t\t\t\t\t\t GEN_INT (11))));\n \n   /* Probe the Backing Store if necessary.  */\n   if (bs_size > 0)\n@@ -3444,10 +3437,23 @@ ia64_expand_prologue (void)\n     current_function_static_stack_size = current_frame_info.total_size;\n \n   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n-    ia64_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t current_frame_info.total_size,\n-\t\t\t\t current_frame_info.n_input_regs\n-\t\t\t\t   + current_frame_info.n_local_regs);\n+    {\n+      HOST_WIDE_INT size = current_frame_info.total_size;\n+      int bs_size = BACKING_STORE_SIZE (current_frame_info.n_input_regs\n+\t\t\t\t\t  + current_frame_info.n_local_regs);\n+\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t    ia64_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\t size - STACK_CHECK_PROTECT,\n+\t\t\t\t\t bs_size);\n+\t  else if (size + bs_size > STACK_CHECK_PROTECT)\n+\t    ia64_emit_probe_stack_range (STACK_CHECK_PROTECT, 0, bs_size);\n+\t}\n+      else if (size + bs_size > 0)\n+\tia64_emit_probe_stack_range (STACK_CHECK_PROTECT, size, bs_size);\n+    }\n \n   if (dump_file) \n     {"}, {"sha": "c1d8f3a0ade7aee6f98e16fa56ab996748860aaa", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0dca9cd86cfd8221fb282b3fd858196065c10712", "patch": "@@ -10994,8 +10994,17 @@ mips_expand_prologue (void)\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = size;\n \n-  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)\n-    mips_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    {\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t    mips_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\t size - STACK_CHECK_PROTECT);\n+\t}\n+      else if (size > 0)\n+\tmips_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+    }\n \n   /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP\n      bytes beforehand; this is enough to cover the register save area"}, {"sha": "fce8f317c6a6868d0ad19afee860a0d117adc693", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0dca9cd86cfd8221fb282b3fd858196065c10712", "patch": "@@ -21538,8 +21538,19 @@ rs6000_emit_prologue (void)\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = info->total_size;\n \n-  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)\n-    rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, info->total_size);\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    {\n+      HOST_WIDE_INT size = info->total_size;\n+\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t    rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\t   size - STACK_CHECK_PROTECT);\n+\t}\n+      else if (size > 0)\n+\trs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+    }\n \n   if (TARGET_FIX_AND_CONTINUE)\n     {"}, {"sha": "0eabd5b2b726f469ee084ea9e011dc556271b576", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dca9cd86cfd8221fb282b3fd858196065c10712/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0dca9cd86cfd8221fb282b3fd858196065c10712", "patch": "@@ -5362,8 +5362,17 @@ sparc_expand_prologue (void)\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = size;\n \n-  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)\n-    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    {\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\t  size - STACK_CHECK_PROTECT);\n+\t}\n+      else if (size > 0)\n+\tsparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+    }\n \n   if (size == 0)\n     ; /* do nothing.  */\n@@ -5464,8 +5473,17 @@ sparc_flat_expand_prologue (void)\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = size;\n \n-  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)\n-    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    {\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\t  size - STACK_CHECK_PROTECT);\n+\t}\n+      else if (size > 0)\n+\tsparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+    }\n \n   if (sparc_save_local_in_regs_p)\n     emit_save_or_restore_local_in_regs (stack_pointer_rtx, SPARC_STACK_BIAS,"}]}