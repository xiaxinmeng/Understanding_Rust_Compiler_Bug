{"sha": "283cb9ea6293e813e48a1b769e1e0779918ea20a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgzY2I5ZWE2MjkzZTgxM2U0OGExYjc2OWUxZTA3Nzk5MThlYTIwYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-04-27T12:45:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-07T10:12:12Z"}, "message": "tree-optimization/57359 - rewrite SM code\n\nThis rewrites store-motion to process candidates where we can\nensure order preserving separately and with no need to disambiguate\nagainst all stores.  Those candidates we cannot handle this way\nare validated to be independent on all stores (w/o TBAA) and then\nprocessed as \"unordered\" (all conditionally executed stores are so\nas well).\n\nThis will necessary cause\n  FAIL: gcc.dg/graphite/pr80906.c scan-tree-dump graphite \"isl AST to Gimple succeeded\"\nbecause the SM previously performed is not valid for exactly the PR57359\nreason, we still perform SM of qc for the innermost loop but that's not enough.\n\nThere is still room for improvements because we still check some constraints\nfor the order preserving cases that are only necessary in the current\nstrict way for the unordered ones.  Leaving that for the furture.\n\n2020-05-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/57359\n\t* tree-ssa-loop-im.c (im_mem_ref::indep_loop): Remove.\n\t(in_mem_ref::dep_loop): Repurpose.\n\t(LOOP_DEP_BIT): Remove.\n\t(enum dep_kind): New.\n\t(enum dep_state): Likewise.\n\t(record_loop_dependence): New function to populate the\n\tdependence cache.\n\t(query_loop_dependence): New function to query the dependence\n\tcache.\n\t(memory_accesses::refs_in_loop): Rename to ...\n\t(memory_accesses::refs_loaded_in_loop): ... this and change to\n\tonly record loads.\n\t(outermost_indep_loop): Adjust.\n\t(mem_ref_alloc): Likewise.\n\t(gather_mem_refs_stmt): Likewise.\n\t(mem_refs_may_alias_p): Add tbaa_p parameter and pass it down.\n\t(struct sm_aux): New.\n\t(execute_sm): Split code generation on exits, record state\n\tinto new hash-map.\n\t(enum sm_kind): New.\n\t(execute_sm_exit): Exit code generation part.\n\t(sm_seq_push_down): Helper for sm_seq_valid_bb performing\n\tdependence checking on stores reached from exits.\n\t(sm_seq_valid_bb): New function gathering SM stores on exits.\n\t(hoist_memory_references): Re-implement.\n\t(refs_independent_p): Add tbaa_p parameter and pass it down.\n\t(record_dep_loop): Remove.\n\t(ref_indep_loop_p_1): Fold into ...\n\t(ref_indep_loop_p): ... this and generalize for three kinds\n\tof dependence queries.\n\t(can_sm_ref_p): Adjust according to hoist_memory_references\n\tchanges.\n\t(store_motion_loop): Don't do anything if the set of SM\n\tcandidates is empty.\n\t(tree_ssa_lim_initialize): Adjust.\n\t(tree_ssa_lim_finalize): Likewise.\n\n\t* gcc.dg/torture/pr57359-1.c: New testcase.\n\t* gcc.dg/torture/pr57359-1.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-lim-14.c: Likewise.\n\t* gcc.dg/graphite/pr80906.c: XFAIL.", "tree": {"sha": "6fd6955e6590764697b06118bb1c7aca6705546c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fd6955e6590764697b06118bb1c7aca6705546c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/283cb9ea6293e813e48a1b769e1e0779918ea20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283cb9ea6293e813e48a1b769e1e0779918ea20a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/283cb9ea6293e813e48a1b769e1e0779918ea20a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283cb9ea6293e813e48a1b769e1e0779918ea20a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "359b19e9904bd63caf1797cc07355938fae82fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359b19e9904bd63caf1797cc07355938fae82fd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/359b19e9904bd63caf1797cc07355938fae82fd3"}], "stats": {"total": 717, "additions": 600, "deletions": 117}, "files": [{"sha": "c1bda34878f99e0b343771ec26c02690bcf37593", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=283cb9ea6293e813e48a1b769e1e0779918ea20a", "patch": "@@ -1,3 +1,43 @@\n+2020-05-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/57359\n+\t* tree-ssa-loop-im.c (im_mem_ref::indep_loop): Remove.\n+\t(in_mem_ref::dep_loop): Repurpose.\n+\t(LOOP_DEP_BIT): Remove.\n+\t(enum dep_kind): New.\n+\t(enum dep_state): Likewise.\n+\t(record_loop_dependence): New function to populate the\n+\tdependence cache.\n+\t(query_loop_dependence): New function to query the dependence\n+\tcache.\n+\t(memory_accesses::refs_in_loop): Rename to ...\n+\t(memory_accesses::refs_loaded_in_loop): ... this and change to\n+\tonly record loads.\n+\t(outermost_indep_loop): Adjust.\n+\t(mem_ref_alloc): Likewise.\n+\t(gather_mem_refs_stmt): Likewise.\n+\t(mem_refs_may_alias_p): Add tbaa_p parameter and pass it down.\n+\t(struct sm_aux): New.\n+\t(execute_sm): Split code generation on exits, record state\n+\tinto new hash-map.\n+\t(enum sm_kind): New.\n+\t(execute_sm_exit): Exit code generation part.\n+\t(sm_seq_push_down): Helper for sm_seq_valid_bb performing\n+\tdependence checking on stores reached from exits.\n+\t(sm_seq_valid_bb): New function gathering SM stores on exits.\n+\t(hoist_memory_references): Re-implement.\n+\t(refs_independent_p): Add tbaa_p parameter and pass it down.\n+\t(record_dep_loop): Remove.\n+\t(ref_indep_loop_p_1): Fold into ...\n+\t(ref_indep_loop_p): ... this and generalize for three kinds\n+\tof dependence queries.\n+\t(can_sm_ref_p): Adjust according to hoist_memory_references\n+\tchanges.\n+\t(store_motion_loop): Don't do anything if the set of SM\n+\tcandidates is empty.\n+\t(tree_ssa_lim_initialize): Adjust.\n+\t(tree_ssa_lim_finalize): Likewise.\n+\n 2020-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n             Pierre-Marie de Rodat  <derodat@adacore.com>\n "}, {"sha": "e226435f159ac603bb22e31ca73c904d40aa2c9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=283cb9ea6293e813e48a1b769e1e0779918ea20a", "patch": "@@ -1,3 +1,11 @@\n+2020-05-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/57359\n+\t* gcc.dg/torture/pr57359-1.c: New testcase.\n+\t* gcc.dg/torture/pr57359-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-lim-14.c: Likewise.\n+\t* gcc.dg/graphite/pr80906.c: XFAIL.\n+\n 2020-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/debug16.adb: New test."}, {"sha": "85981b1c587adf5322f89a6126d4e09a22160265", "filename": "gcc/testsuite/gcc.dg/graphite/pr80906.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr80906.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr80906.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr80906.c?ref=283cb9ea6293e813e48a1b769e1e0779918ea20a", "patch": "@@ -25,4 +25,5 @@ ec (int lh[][2])\n   return c5 + m3;\n }\n \n-/* { dg-final { scan-tree-dump \"isl AST to Gimple succeeded\" \"graphite\" } } */\n+/* We cannot perform a required store motion.  */\n+/* { dg-final { scan-tree-dump \"isl AST to Gimple succeeded\" \"graphite\" { xfail *-*-* } } } */"}, {"sha": "f5a406a34d632d0e0565710752d7ed7c47511cff", "filename": "gcc/testsuite/gcc.dg/torture/pr57359-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57359-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57359-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57359-1.c?ref=283cb9ea6293e813e48a1b769e1e0779918ea20a", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+\n+extern void abort();\n+\n+typedef int A;\n+typedef float B;\n+\n+void __attribute__((noinline,noclone))\n+foo(A *p, B *q, long unk)\n+{\n+  for (long i = 0; i < unk; ++i) {\n+      *p = 1;\n+      q[i] = 42;\n+  }\n+}\n+\n+int main(void)\n+{\n+  union { A x; B f; } u;\n+  foo(&u.x, &u.f, 1);\n+  if (u.f != 42) abort();\n+  return 0;\n+}"}, {"sha": "ce7d9890af46d35a9c9023c4f16288bfe9f3e4a0", "filename": "gcc/testsuite/gcc.dg/torture/pr57359-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57359-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57359-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57359-2.c?ref=283cb9ea6293e813e48a1b769e1e0779918ea20a", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fstrict-aliasing\" } */\n+\n+extern void abort();\n+\n+typedef int A;\n+typedef float B;\n+\n+void __attribute__((noipa))\n+foo(A * p, B *r, long unk, long oh)\n+{\n+  for (long i = 0; i < unk; ++i) {\n+      *p = 1;\n+      *r = 2;\n+      if (oh & i)\n+\tbreak;\n+      *r = 3;\n+      *p = 4;\n+  }\n+}\n+\n+int main(void)\n+{\n+  union { A x; B f; } u;\n+  foo(&u.x, &u.f, 1, 1);\n+  if (u.x != 4) abort();\n+  foo(&u.x, &u.f, 2, 1);\n+  if (u.f != 2) abort ();\n+  return 0;\n+}"}, {"sha": "3eb5be8b23f0322c5ca3c10bdeb6d3eb8a0e9613", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-14.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-14.c?ref=283cb9ea6293e813e48a1b769e1e0779918ea20a", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim-details\" } */\n+\n+extern void abort();\n+\n+typedef int A;\n+typedef float B;\n+\n+void __attribute__((noinline,noclone))\n+foo(A * p, B *r, long unk, long oh)\n+{\n+  for (long i = 0; i < unk; ++i) {\n+      *p = 1;\n+      *r = 2;\n+      if (oh & i)\n+\tbreak;\n+      *r = 3;\n+      *p = 4;\n+  }\n+}\n+\n+int main(void)\n+{\n+  union { A x; B f; } u;\n+  foo(&u.x, &u.f, 1, 1);\n+  if (u.x != 4) abort();\n+  foo(&u.x, &u.f, 2, 1);\n+  if (u.f != 2) abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Executing store motion of \\\\*p\" \"lim2\" } } */\n+/* { dg-final { scan-tree-dump \"Executing store motion of \\\\*r\" \"lim2\" } } */"}, {"sha": "2aabb54c98d072373188792196b122b46ca1142a", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 464, "deletions": 116, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283cb9ea6293e813e48a1b769e1e0779918ea20a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=283cb9ea6293e813e48a1b769e1e0779918ea20a", "patch": "@@ -133,24 +133,41 @@ class im_mem_ref\n \t\t\t\t/* The locations of the accesses.  Vector\n \t\t\t\t   indexed by the loop number.  */\n \n-  /* The following sets are computed on demand.  We keep both set and\n-     its complement, so that we know whether the information was\n-     already computed or not.  */\n-  bitmap_head indep_loop;\t/* The set of loops in that the memory\n-\t\t\t\t   reference is independent, meaning:\n-\t\t\t\t   If it is stored in the loop, this store\n-\t\t\t\t     is independent on all other loads and\n-\t\t\t\t     stores.\n-\t\t\t\t   If it is only loaded, then it is independent\n-\t\t\t\t     on all stores in the loop.  */\n-  bitmap_head dep_loop;\t\t/* The complement of INDEP_LOOP.  */\n+  /* The following set is computed on demand.  */\n+  bitmap_head dep_loop;\t\t/* The set of loops in that the memory\n+\t\t\t\t   reference is {in,}dependent in\n+\t\t\t\t   different modes.  */\n };\n \n-/* We use two bits per loop in the ref->{in,}dep_loop bitmaps, the first\n-   to record (in)dependence against stores in the loop and its subloops, the\n-   second to record (in)dependence against all references in the loop\n-   and its subloops.  */\n-#define LOOP_DEP_BIT(loopnum, storedp) (2 * (loopnum) + (storedp ? 1 : 0))\n+/* We use six bits per loop in the ref->dep_loop bitmap to record\n+   the dep_kind x dep_state combinations.  */\n+\n+enum dep_kind { lim_raw, sm_war, sm_waw };\n+enum dep_state { dep_unknown, dep_independent, dep_dependent };\n+\n+/* Populate the loop dependence cache of REF for LOOP, KIND with STATE.  */\n+\n+static void\n+record_loop_dependence (class loop *loop, im_mem_ref *ref,\n+\t\t\tdep_kind kind, dep_state state)\n+{\n+  gcc_assert (state != dep_unknown);\n+  unsigned bit = 6 * loop->num + kind * 2 + state == dep_dependent ? 1 : 0;\n+  bitmap_set_bit (&ref->dep_loop, bit);\n+}\n+\n+/* Query the loop dependence cache of REF for LOOP, KIND.  */\n+\n+static dep_state\n+query_loop_dependence (class loop *loop, im_mem_ref *ref, dep_kind kind)\n+{\n+  unsigned first_bit = 6 * loop->num + kind * 2;\n+  if (bitmap_bit_p (&ref->dep_loop, first_bit))\n+    return dep_independent;\n+  else if (bitmap_bit_p (&ref->dep_loop, first_bit + 1))\n+    return dep_dependent;\n+  return dep_unknown;\n+}\n \n /* Mem_ref hashtable helpers.  */\n \n@@ -211,7 +228,7 @@ static struct\n   vec<im_mem_ref *> refs_list;\n \n   /* The set of memory references accessed in each loop.  */\n-  vec<bitmap_head> refs_in_loop;\n+  vec<bitmap_head> refs_loaded_in_loop;\n \n   /* The set of memory references stored in each loop.  */\n   vec<bitmap_head> refs_stored_in_loop;\n@@ -227,8 +244,9 @@ static struct\n static bitmap_obstack lim_bitmap_obstack;\n static obstack mem_ref_obstack;\n \n-static bool ref_indep_loop_p (class loop *, im_mem_ref *);\n+static bool ref_indep_loop_p (class loop *, im_mem_ref *, dep_kind);\n static bool ref_always_accessed_p (class loop *, im_mem_ref *, bool);\n+static bool refs_independent_p (im_mem_ref *, im_mem_ref *, bool = true);\n \n /* Minimum cost of an expensive expression.  */\n #define LIM_EXPENSIVE ((unsigned) param_lim_expensive)\n@@ -573,10 +591,10 @@ outermost_indep_loop (class loop *outer, class loop *loop, im_mem_ref *ref)\n        aloop != loop;\n        aloop = superloop_at_depth (loop, loop_depth (aloop) + 1))\n     if ((!ref->stored || !bitmap_bit_p (ref->stored, aloop->num))\n-\t&& ref_indep_loop_p (aloop, ref))\n+\t&& ref_indep_loop_p (aloop, ref, lim_raw))\n       return aloop;\n \n-  if (ref_indep_loop_p (loop, ref))\n+  if (ref_indep_loop_p (loop, ref, lim_raw))\n     return loop;\n   else\n     return NULL;\n@@ -1398,7 +1416,6 @@ mem_ref_alloc (ao_ref *mem, unsigned hash, unsigned id)\n   ref->hash = hash;\n   ref->stored = NULL;\n   ref->loaded = NULL;\n-  bitmap_initialize (&ref->indep_loop, &lim_bitmap_obstack);\n   bitmap_initialize (&ref->dep_loop, &lim_bitmap_obstack);\n   ref->accesses_in_loop.create (1);\n \n@@ -1589,14 +1606,17 @@ gather_mem_refs_stmt (class loop *loop, gimple *stmt)\n \n       record_mem_ref_loc (ref, stmt, mem);\n     }\n-  bitmap_set_bit (&memory_accesses.refs_in_loop[loop->num], ref->id);\n   if (is_stored)\n     {\n       bitmap_set_bit (&memory_accesses.refs_stored_in_loop[loop->num], ref->id);\n       mark_ref_stored (ref, loop);\n     }\n-  else\n-    mark_ref_loaded (ref, loop);\n+  /* A not simple memory op is also a read when it is a write.  */\n+  if (!is_stored || id == UNANALYZABLE_MEM_ID)\n+    {\n+      bitmap_set_bit (&memory_accesses.refs_loaded_in_loop[loop->num], ref->id);\n+      mark_ref_loaded (ref, loop);\n+    }\n   init_lim_data (stmt)->ref = ref->id;\n   return;\n }\n@@ -1698,7 +1718,8 @@ analyze_memory_references (void)\n \n static bool\n mem_refs_may_alias_p (im_mem_ref *mem1, im_mem_ref *mem2,\n-\t\t      hash_map<tree, name_expansion *> **ttae_cache)\n+\t\t      hash_map<tree, name_expansion *> **ttae_cache,\n+\t\t      bool tbaa_p)\n {\n   /* Perform BASE + OFFSET analysis -- if MEM1 and MEM2 are based on the same\n      object and their offset differ in such a way that the locations cannot\n@@ -1707,7 +1728,7 @@ mem_refs_may_alias_p (im_mem_ref *mem1, im_mem_ref *mem2,\n   aff_tree off1, off2;\n \n   /* Perform basic offset and type-based disambiguation.  */\n-  if (!refs_may_alias_p_1 (&mem1->mem, &mem2->mem, true))\n+  if (!refs_may_alias_p_1 (&mem1->mem, &mem2->mem, tbaa_p))\n     return false;\n \n   /* The expansion of addresses may be a bit expensive, thus we only do\n@@ -2094,23 +2115,28 @@ execute_sm_if_changed_flag_set (class loop *loop, im_mem_ref *ref,\n   return flag;\n }\n \n+struct sm_aux\n+{\n+  tree tmp_var;\n+  tree store_flag;\n+  hash_set <basic_block> flag_bbs;\n+};\n+\n /* Executes store motion of memory reference REF from LOOP.\n    Exits from the LOOP are stored in EXITS.  The initialization of the\n    temporary variable is put to the preheader of the loop, and assignments\n    to the reference from the temporary variable are emitted to exits.  */\n \n static void\n-execute_sm (class loop *loop, vec<edge> exits, im_mem_ref *ref)\n+execute_sm (class loop *loop, im_mem_ref *ref,\n+\t    hash_map<im_mem_ref *, sm_aux *> &aux_map)\n {\n-  tree tmp_var, store_flag = NULL_TREE;\n-  unsigned i;\n   gassign *load;\n   struct fmt_data fmt_data;\n-  edge ex;\n   struct lim_aux_data *lim_data;\n   bool multi_threaded_model_p = false;\n   gimple_stmt_iterator gsi;\n-  hash_set<basic_block> flag_bbs;\n+  sm_aux *aux = new sm_aux;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2119,8 +2145,8 @@ execute_sm (class loop *loop, vec<edge> exits, im_mem_ref *ref)\n       fprintf (dump_file, \" from loop %d\\n\", loop->num);\n     }\n \n-  tmp_var = create_tmp_reg (TREE_TYPE (ref->mem.ref),\n-\t\t\t    get_lsm_tmp_name (ref->mem.ref, ~0));\n+  aux->tmp_var = create_tmp_reg (TREE_TYPE (ref->mem.ref),\n+\t\t\t\t get_lsm_tmp_name (ref->mem.ref, ~0));\n \n   fmt_data.loop = loop;\n   fmt_data.orig_loop = loop;\n@@ -2132,9 +2158,15 @@ execute_sm (class loop *loop, vec<edge> exits, im_mem_ref *ref)\n     multi_threaded_model_p = true;\n \n   if (multi_threaded_model_p)\n-    store_flag = execute_sm_if_changed_flag_set (loop, ref, &flag_bbs);\n+    aux->store_flag\n+      = execute_sm_if_changed_flag_set (loop, ref, &aux->flag_bbs);\n+  else\n+    aux->store_flag = NULL_TREE;\n+\n+  /* Remember variable setup.  */\n+  aux_map.put (ref, aux);\n \n-  rewrite_mem_refs (loop, ref, tmp_var);\n+  rewrite_mem_refs (loop, ref, aux->tmp_var);\n \n   /* Emit the load code on a random exit edge or into the latch if\n      the loop does not exit, so that we are sure it will be processed\n@@ -2147,14 +2179,14 @@ execute_sm (class loop *loop, vec<edge> exits, im_mem_ref *ref)\n      store then.  */\n   if ((!always_stored && !multi_threaded_model_p)\n       || (ref->loaded && bitmap_bit_p (ref->loaded, loop->num)))\n-    load = gimple_build_assign (tmp_var, unshare_expr (ref->mem.ref));\n+    load = gimple_build_assign (aux->tmp_var, unshare_expr (ref->mem.ref));\n   else\n     {\n       /* If not emitting a load mark the uninitialized state on the\n \t loop entry as not to be warned for.  */\n-      tree uninit = create_tmp_reg (TREE_TYPE (tmp_var));\n+      tree uninit = create_tmp_reg (TREE_TYPE (aux->tmp_var));\n       TREE_NO_WARNING (uninit) = 1;\n-      load = gimple_build_assign (tmp_var, uninit);\n+      load = gimple_build_assign (aux->tmp_var, uninit);\n     }\n   lim_data = init_lim_data (load);\n   lim_data->max_loop = loop;\n@@ -2163,24 +2195,269 @@ execute_sm (class loop *loop, vec<edge> exits, im_mem_ref *ref)\n \n   if (multi_threaded_model_p)\n     {\n-      load = gimple_build_assign (store_flag, boolean_false_node);\n+      load = gimple_build_assign (aux->store_flag, boolean_false_node);\n       lim_data = init_lim_data (load);\n       lim_data->max_loop = loop;\n       lim_data->tgt_loop = loop;\n       gsi_insert_before (&gsi, load, GSI_SAME_STMT);\n     }\n+}\n \n-  /* Sink the store to every exit from the loop.  */\n-  FOR_EACH_VEC_ELT (exits, i, ex)\n-    if (!multi_threaded_model_p)\n+/* sm_ord is used for ordinary stores we can retain order with respect\n+       to other stores\n+   sm_unord is used for conditional executed stores which need to be\n+       able to execute in arbitrary order with respect to other stores\n+   sm_other is used for stores we do not try to apply store motion to.  */\n+enum sm_kind { sm_ord, sm_unord, sm_other };\n+typedef std::pair<unsigned, sm_kind> seq_entry;\n+\n+static void\n+execute_sm_exit (class loop *loop, edge ex, vec<seq_entry> &seq,\n+\t\t hash_map<im_mem_ref *, sm_aux *> &aux_map, sm_kind kind)\n+{\n+  /* Sink the stores to exit from the loop.  */\n+  for (unsigned i = seq.length (); i > 0; --i)\n+    {\n+      if (seq[i-1].second != kind)\n+\tcontinue;\n+      im_mem_ref *ref = memory_accesses.refs_list[seq[i-1].first];\n+      sm_aux *aux = *aux_map.get (ref);\n+      if (!aux->store_flag)\n+\t{\n+\t  gassign *store;\n+\t  store = gimple_build_assign (unshare_expr (ref->mem.ref),\n+\t\t\t\t       aux->tmp_var);\n+\t  gsi_insert_on_edge (ex, store);\n+\t}\n+      else\n+\texecute_sm_if_changed (ex, ref->mem.ref, aux->tmp_var, aux->store_flag,\n+\t\t\t       loop_preheader_edge (loop), &aux->flag_bbs);\n+    }\n+}\n+\n+/* Push the SM candidate at index PTR in the sequence SEQ down until\n+   we hit the next SM candidate.  Return true if that went OK and\n+   false if we could not disambiguate agains another unrelated ref.  */\n+\n+static bool\n+sm_seq_push_down (vec<seq_entry> &seq, unsigned ptr)\n+{\n+  for (; ptr > 0; --ptr)\n+    {\n+      seq_entry &new_cand = seq[ptr];\n+      seq_entry &against = seq[ptr-1];\n+      if (against.second == sm_ord)\n+\t/* Found the tail of the sequence.  */\n+\tbreak;\n+      if (!refs_independent_p (memory_accesses.refs_list[new_cand.first],\n+\t\t\t       memory_accesses.refs_list[against.first],\n+\t\t\t       false))\n+\t/* ???  Prune new_cand from the list of refs to apply SM to.  */\n+\treturn false;\n+      std::swap (new_cand, against);\n+    }\n+  return true;\n+}\n+\n+/* Computes the sequence of stores from candidates in REFS_NOT_IN_SEQ to SEQ\n+   walking backwards from VDEF (or the end of BB if VDEF is NULL).  */\n+\n+static int\n+sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n+\t\t vec<seq_entry> &seq, bitmap refs_not_in_seq,\n+\t\t bitmap refs_not_supported, bool forked)\n+{\n+  if (!vdef)\n+    for (gimple_stmt_iterator gsi = gsi_last_bb (bb); !gsi_end_p (gsi);\n+\t gsi_prev (&gsi))\n       {\n-\tgassign *store;\n-\tstore = gimple_build_assign (unshare_expr (ref->mem.ref), tmp_var);\n-\tgsi_insert_on_edge (ex, store);\n+\tvdef = gimple_vdef (gsi_stmt (gsi));\n+\tif (vdef)\n+\t  break;\n       }\n-    else\n-      execute_sm_if_changed (ex, ref->mem.ref, tmp_var, store_flag,\n-\t\t\t     loop_preheader_edge (loop), &flag_bbs);\n+  if (!vdef)\n+    {\n+      gphi *vphi = get_virtual_phi (bb);\n+      if (vphi)\n+\tvdef = gimple_phi_result (vphi);\n+    }\n+  if (!vdef)\n+    {\n+      if (single_pred_p (bb))\n+\t/* This handles the perfect nest case.  */\n+\treturn sm_seq_valid_bb (loop, single_pred (bb), vdef,\n+\t\t\t\tseq, refs_not_in_seq, refs_not_supported,\n+\t\t\t\tforked);\n+      return 0;\n+    }\n+  do\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (vdef);\n+      if (gimple_bb (def) != bb)\n+\t{\n+\t  /* If we forked by processing a PHI do not allow our walk to\n+\t     merge again until we handle that robustly.  */\n+\t  if (forked)\n+\t    {\n+\t      /* Mark refs_not_in_seq as unsupported.  */\n+\t      bitmap_ior_into (refs_not_supported, refs_not_in_seq);\n+\t      return 1;\n+\t    }\n+\t  /* Otherwise it doesn't really matter if we end up in different\n+\t     BBs.  */\n+\t  bb = gimple_bb (def);\n+\t}\n+      if (gphi *phi = dyn_cast <gphi *> (def))\n+\t{\n+\t  /* Handle CFG merges.  Until we handle forks (gimple_bb (def) != bb)\n+\t     this is still linear.\n+\t     Eventually we want to cache intermediate results per BB\n+\t     (but we can't easily cache for different exits?).  */\n+\t  /* Stop at PHIs with possible backedges.  */\n+\t  if (bb == bb->loop_father->header\n+\t      || bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t    {\n+\t      /* Mark refs_not_in_seq as unsupported.  */\n+\t      bitmap_ior_into (refs_not_supported, refs_not_in_seq);\n+\t      return 1;\n+\t    }\n+\t  if (gimple_phi_num_args (phi) == 1)\n+\t    return sm_seq_valid_bb (loop, gimple_phi_arg_edge (phi, 0)->src,\n+\t\t\t\t    gimple_phi_arg_def (phi, 0), seq,\n+\t\t\t\t    refs_not_in_seq, refs_not_supported,\n+\t\t\t\t    false);\n+\t  auto_vec<seq_entry> first_edge_seq;\n+\t  auto_bitmap tem_refs_not_in_seq (&lim_bitmap_obstack);\n+\t  int eret;\n+\t  bitmap_copy (tem_refs_not_in_seq, refs_not_in_seq);\n+\t  eret = sm_seq_valid_bb (loop, gimple_phi_arg_edge (phi, 0)->src,\n+\t\t\t\t  gimple_phi_arg_def (phi, 0),\n+\t\t\t\t  first_edge_seq,\n+\t\t\t\t  tem_refs_not_in_seq, refs_not_supported,\n+\t\t\t\t  true);\n+\t  if (eret != 1)\n+\t    return -1;\n+\t  /* Simplify our lives by pruning the sequence of !sm_ord.  */\n+\t  while (!first_edge_seq.is_empty ()\n+\t\t && first_edge_seq.last ().second != sm_ord)\n+\t    first_edge_seq.pop ();\n+\t  for (unsigned int i = 1; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      tree vuse = gimple_phi_arg_def (phi, i);\n+\t      edge e = gimple_phi_arg_edge (phi, i);\n+\t      auto_vec<seq_entry> edge_seq;\n+\t      bitmap_copy (tem_refs_not_in_seq, refs_not_in_seq);\n+\t      eret = sm_seq_valid_bb (loop, e->src, vuse, edge_seq,\n+\t\t\t\t      tem_refs_not_in_seq, refs_not_supported,\n+\t\t\t\t      true);\n+\t      if (eret != 1)\n+\t\treturn -1;\n+\t      /* Simplify our lives by pruning the sequence of !sm_ord.  */\n+\t      while (!edge_seq.is_empty ()\n+\t\t     && edge_seq.last ().second != sm_ord)\n+\t\tedge_seq.pop ();\n+\t      unsigned min_len = MIN(first_edge_seq.length (),\n+\t\t\t\t     edge_seq.length ());\n+\t      /* Incrementally merge seqs into first_edge_seq.  */\n+\t      for (unsigned int i = 0; i < min_len; ++i)\n+\t\t{\n+\t\t  /* ???  We can more intelligently merge when we face different\n+\t\t     order by additional sinking operations in one sequence.\n+\t\t     For now we simply mark them as to be processed by the\n+\t\t     not order-preserving SM code.  */\n+\t\t  if (first_edge_seq[i].first != edge_seq[i].first)\n+\t\t    {\n+\t\t      bitmap_set_bit (refs_not_supported,\n+\t\t\t\t      first_edge_seq[i].first);\n+\t\t      bitmap_set_bit (refs_not_supported, edge_seq[i].first);\n+\t\t      first_edge_seq[i].second = sm_unord;\n+\t\t    }\n+\t\t  /* sm_unord prevails.  */\n+\t\t  else if (first_edge_seq[i].second != edge_seq[i].second)\n+\t\t    {\n+\t\t      /* This is just an optimization.  */\n+\t\t      gcc_assert (bitmap_bit_p (refs_not_supported,\n+\t\t\t\t\t\tfirst_edge_seq[i].first));\n+\t\t      first_edge_seq[i].second = sm_unord;\n+\t\t    }\n+\t\t}\n+\t      /* Any excess elements become sm_unord since they are now\n+\t\t coonditionally executed.  */\n+\t      if (first_edge_seq.length () > edge_seq.length ())\n+\t\t{\n+\t\t  for (unsigned i = edge_seq.length ();\n+\t\t       i < first_edge_seq.length (); ++i)\n+\t\t    {\n+\t\t      bitmap_set_bit (refs_not_supported,\n+\t\t\t\t      first_edge_seq[i].first);\n+\t\t      first_edge_seq[i].second = sm_unord;\n+\t\t    }\n+\t\t}\n+\t      else if (edge_seq.length () > first_edge_seq.length ())\n+\t\t{\n+\t\t  for (unsigned i = first_edge_seq.length ();\n+\t\t       i < edge_seq.length (); ++i)\n+\t\t    bitmap_set_bit (refs_not_supported, edge_seq[i].first);\n+\t\t}\n+\t    }\n+\t  /* Use the sequence from the first edge and push SMs down.  */\n+\t  for (unsigned i = 0; i < first_edge_seq.length (); ++i)\n+\t    {\n+\t      if (first_edge_seq[i].second == sm_other)\n+\t\tbreak;\n+\t      unsigned id = first_edge_seq[i].first;\n+\t      seq.safe_push (first_edge_seq[i]);\n+\t      if (first_edge_seq[i].second == sm_ord\n+\t\t  && !sm_seq_push_down (seq, seq.length () - 1))\n+\t\t{\n+\t\t  bitmap_set_bit (refs_not_supported, id);\n+\t\t  /* ???  Mark it sm_unord but it's now \"somewhere\" ... */\n+\t\t  for (unsigned i = seq.length (); i != 0; --i)\n+\t\t    if (seq[i - 1].first == id)\n+\t\t      {\n+\t\t\tseq[i - 1].second = sm_unord;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n+\t  return 1;\n+\t}\n+      lim_aux_data *data = get_lim_data (def);\n+      gcc_assert (data);\n+      if (data->ref == UNANALYZABLE_MEM_ID)\n+\treturn -1;\n+      /* One of the stores we want to apply SM to and we've not yet seen.  */\n+      else if (bitmap_clear_bit (refs_not_in_seq, data->ref))\n+\t{\n+\t  seq.safe_push (std::make_pair (data->ref, sm_ord));\n+\n+\t  /* 1) push it down the queue until a SMed\n+\t     and not ignored ref is reached, skipping all not SMed refs\n+\t     and ignored refs via non-TBAA disambiguation.  */\n+\t  if (!sm_seq_push_down (seq, seq.length () - 1))\n+\t    {\n+\t      bitmap_set_bit (refs_not_supported, data->ref);\n+\t      /* ???  Mark it sm_unord but it's now \"somewhere\" ... */\n+\t      for (unsigned i = seq.length (); i != 0; --i)\n+\t\tif (seq[i - 1].first == data->ref)\n+\t\t  {\n+\t\t    seq[i - 1].second = sm_unord;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\n+\t  /* 2) check whether we've seen all refs we want to SM and if so\n+\t     declare success for the active exit  */\n+\t  if (bitmap_empty_p (refs_not_in_seq))\n+\t    return 1;\n+\t}\n+      else\n+\t/* Another store not part of the final sequence.  Simply push it.  */\n+\tseq.safe_push (std::make_pair (data->ref, sm_other));\n+\n+      vdef = gimple_vuse (def);\n+    }\n+  while (1);\n }\n \n /* Hoists memory references MEM_REFS out of LOOP.  EXITS is the list of exit\n@@ -2194,11 +2471,104 @@ hoist_memory_references (class loop *loop, bitmap mem_refs,\n   unsigned  i;\n   bitmap_iterator bi;\n \n+  /* To address PR57359 before actually applying store-motion check\n+     the candidates found for validity with regards to reordering\n+     relative to other stores which we until here disambiguated using\n+     TBAA which isn't valid.\n+     What matters is the order of the last stores to the mem_refs\n+     with respect to the other stores of the loop at the point of the\n+     loop exits.  */\n+\n+  /* For each exit compute the store order, pruning from mem_refs\n+     on the fly.  */\n+  /* The complexity of this is at least\n+     O(number of exits * number of SM refs) but more approaching\n+     O(number of exits * number of SM refs * number of stores).  */\n+  /* ???  Somehow do this in a single sweep over the loop body.  */\n+  auto_vec<std::pair<edge, vec<seq_entry> > > sms;\n+  auto_bitmap refs_not_supported (&lim_bitmap_obstack);\n+  edge e;\n+  FOR_EACH_VEC_ELT (exits, i, e)\n+    {\n+      vec<seq_entry> seq;\n+      seq.create (4);\n+      auto_bitmap refs_not_in_seq (&lim_bitmap_obstack);\n+      bitmap_copy (refs_not_in_seq, mem_refs);\n+      int res = sm_seq_valid_bb (loop, e->src, NULL_TREE,\n+\t\t\t\t seq, refs_not_in_seq,\n+\t\t\t\t refs_not_supported, false);\n+      if (res != 1)\n+\t{\n+\t  bitmap_copy (refs_not_supported, mem_refs);\n+\t  break;\n+\t}\n+      sms.safe_push (std::make_pair (e, seq));\n+    }\n+\n+  /* Prune pruned mem_refs from earlier processed exits.  */\n+  bool changed = !bitmap_empty_p (refs_not_supported);\n+  while (changed)\n+    {\n+      changed = false;\n+      std::pair<edge, vec<seq_entry> > *seq;\n+      FOR_EACH_VEC_ELT (sms, i, seq)\n+\t{\n+\t  for (unsigned i = 0; i < seq->second.length (); ++i)\n+\t    {\n+\t      if (seq->second[i].second == sm_other)\n+\t\tbreak;\n+\t      unsigned id = seq->second[i].first;\n+\t      if (bitmap_bit_p (refs_not_supported, id))\n+\t\tseq->second[i].second = sm_other;\n+\t      else if (!sm_seq_push_down (seq->second, i))\n+\t\t{\n+\t\t  if (bitmap_set_bit (refs_not_supported, id))\n+\t\t    changed = true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Verify dependence for refs we cannot handle with the order preserving\n+     code (refs_not_supported) or prune them from mem_refs.  */\n+  auto_vec<seq_entry> unord_refs;\n+  EXECUTE_IF_SET_IN_BITMAP (refs_not_supported, 0, i, bi)\n+    {\n+      ref = memory_accesses.refs_list[i];\n+      if (!ref_indep_loop_p (loop, ref, sm_waw))\n+\tbitmap_clear_bit (mem_refs, i);\n+      /* We've now verified store order for ref with respect to all other\n+\t stores in the loop does not matter.  */\n+      else\n+\tunord_refs.safe_push (std::make_pair (i, sm_unord));\n+    }\n+\n+  hash_map<im_mem_ref *, sm_aux *> aux_map;\n+\n+  /* Execute SM but delay the store materialization for ordered\n+     sequences on exit.  */\n   EXECUTE_IF_SET_IN_BITMAP (mem_refs, 0, i, bi)\n     {\n       ref = memory_accesses.refs_list[i];\n-      execute_sm (loop, exits, ref);\n+      execute_sm (loop, ref, aux_map);\n     }\n+\n+  /* Materialize ordered store sequences on exits.  */\n+  FOR_EACH_VEC_ELT (exits, i, e)\n+    {\n+      if (i < sms.length ())\n+\t{\n+\t  gcc_assert (sms[i].first == e);\n+\t  execute_sm_exit (loop, e, sms[i].second, aux_map, sm_ord);\n+\t  sms[i].second.release ();\n+\t}\n+      if (!unord_refs.is_empty ())\n+\texecute_sm_exit (loop, e, unord_refs, aux_map, sm_unord);\n+    }\n+\n+  for (hash_map<im_mem_ref *, sm_aux *>::iterator iter = aux_map.begin ();\n+       iter != aux_map.end (); ++iter)\n+    delete (*iter).second;\n }\n \n class ref_always_accessed\n@@ -2254,7 +2624,7 @@ ref_always_accessed_p (class loop *loop, im_mem_ref *ref, bool stored_p)\n /* Returns true if REF1 and REF2 are independent.  */\n \n static bool\n-refs_independent_p (im_mem_ref *ref1, im_mem_ref *ref2)\n+refs_independent_p (im_mem_ref *ref1, im_mem_ref *ref2, bool tbaa_p)\n {\n   if (ref1 == ref2)\n     return true;\n@@ -2263,7 +2633,7 @@ refs_independent_p (im_mem_ref *ref1, im_mem_ref *ref2)\n     fprintf (dump_file, \"Querying dependency of refs %u and %u: \",\n \t     ref1->id, ref2->id);\n \n-  if (mem_refs_may_alias_p (ref1, ref2, &memory_accesses.ttae_cache))\n+  if (mem_refs_may_alias_p (ref1, ref2, &memory_accesses.ttae_cache, tbaa_p))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"dependent.\\n\");\n@@ -2277,48 +2647,39 @@ refs_independent_p (im_mem_ref *ref1, im_mem_ref *ref2)\n     }\n }\n \n-/* Mark REF dependent on stores or loads (according to STORED_P) in LOOP\n-   and its super-loops.  */\n-\n-static void\n-record_dep_loop (class loop *loop, im_mem_ref *ref, bool stored_p)\n-{\n-  /* We can propagate dependent-in-loop bits up the loop\n-     hierarchy to all outer loops.  */\n-  while (loop != current_loops->tree_root\n-\t && bitmap_set_bit (&ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n-    loop = loop_outer (loop);\n-}\n-\n-/* Returns true if REF is independent on all other memory\n-   references in LOOP.  */\n+/* Returns true if REF is independent on all other accessess in LOOP.\n+   KIND specifies the kind of dependence to consider.\n+     lim_raw assumes REF is not stored in LOOP and disambiguates RAW\n+\t     dependences so if true REF can be hoisted out of LOOP\n+     sm_war disambiguates a store REF against all other loads to see\n+\t    whether the store can be sunk across loads out of LOOP\n+     sm_waw disambiguates a store REF against all other stores to see\n+\t    whether the store can be sunk across stores out of LOOP.  */\n \n static bool\n-ref_indep_loop_p_1 (class loop *loop, im_mem_ref *ref, bool stored_p)\n+ref_indep_loop_p (class loop *loop, im_mem_ref *ref, dep_kind kind)\n {\n-  stored_p |= (ref->stored && bitmap_bit_p (ref->stored, loop->num));\n-\n   bool indep_p = true;\n   bitmap refs_to_check;\n \n-  if (stored_p)\n-    refs_to_check = &memory_accesses.refs_in_loop[loop->num];\n+  if (kind == sm_war)\n+    refs_to_check = &memory_accesses.refs_loaded_in_loop[loop->num];\n   else\n     refs_to_check = &memory_accesses.refs_stored_in_loop[loop->num];\n \n   if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID))\n     indep_p = false;\n   else\n     {\n-      if (bitmap_bit_p (&ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n-\treturn true;\n-      if (bitmap_bit_p (&ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n-\treturn false;\n+      /* tri-state, { unknown, independent, dependent }  */\n+      dep_state state = query_loop_dependence (loop, ref, kind);\n+      if (state != dep_unknown)\n+\treturn state == dep_independent ? true : false;\n \n       class loop *inner = loop->inner;\n       while (inner)\n \t{\n-\t  if (!ref_indep_loop_p_1 (inner, ref, stored_p))\n+\t  if (!ref_indep_loop_p (inner, ref, kind))\n \t    {\n \t      indep_p = false;\n \t      break;\n@@ -2333,7 +2694,7 @@ ref_indep_loop_p_1 (class loop *loop, im_mem_ref *ref, bool stored_p)\n \t  EXECUTE_IF_SET_IN_BITMAP (refs_to_check, 0, i, bi)\n \t    {\n \t      im_mem_ref *aref = memory_accesses.refs_list[i];\n-\t      if (!refs_independent_p (ref, aref))\n+\t      if (!refs_independent_p (ref, aref, kind != sm_waw))\n \t\t{\n \t\t  indep_p = false;\n \t\t  break;\n@@ -2343,44 +2704,17 @@ ref_indep_loop_p_1 (class loop *loop, im_mem_ref *ref, bool stored_p)\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Querying dependencies of ref %u in loop %d: %s\\n\",\n+    fprintf (dump_file, \"Querying %s dependencies of ref %u in loop %d: %s\\n\",\n+\t     kind == lim_raw ? \"RAW\" : (kind == sm_war ? \"SM WAR\" : \"SM WAW\"),\n \t     ref->id, loop->num, indep_p ? \"independent\" : \"dependent\");\n \n   /* Record the computed result in the cache.  */\n-  if (indep_p)\n-    {\n-      if (bitmap_set_bit (&ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p))\n-\t  && stored_p)\n-\t{\n-\t  /* If it's independend against all refs then it's independent\n-\t     against stores, too.  */\n-\t  bitmap_set_bit (&ref->indep_loop, LOOP_DEP_BIT (loop->num, false));\n-\t}\n-    }\n-  else\n-    {\n-      record_dep_loop (loop, ref, stored_p);\n-      if (!stored_p)\n-\t{\n-\t  /* If it's dependent against stores it's dependent against\n-\t     all refs, too.  */\n-\t  record_dep_loop (loop, ref, true);\n-\t}\n-    }\n+  record_loop_dependence (loop, ref, kind,\n+\t\t\t  indep_p ? dep_independent : dep_dependent);\n \n   return indep_p;\n }\n \n-/* Returns true if REF is independent on all other memory references in\n-   LOOP.  */\n-\n-static bool\n-ref_indep_loop_p (class loop *loop, im_mem_ref *ref)\n-{\n-  gcc_checking_assert (MEM_ANALYZABLE (ref));\n-\n-  return ref_indep_loop_p_1 (loop, ref, false);\n-}\n \n /* Returns true if we can perform store motion of REF from LOOP.  */\n \n@@ -2410,12 +2744,25 @@ can_sm_ref_p (class loop *loop, im_mem_ref *ref)\n   base = get_base_address (ref->mem.ref);\n   if ((tree_could_trap_p (ref->mem.ref)\n        || (DECL_P (base) && TREE_READONLY (base)))\n+      /* ???  We can at least use false here, allowing loads?  We\n+\t are forcing conditional stores if the ref is not always\n+\t stored to later anyway.  So this would only guard\n+\t the load we need to emit.  Thus when the ref is not\n+\t loaded we can elide this completely?  */\n       && !ref_always_accessed_p (loop, ref, true))\n     return false;\n \n-  /* And it must be independent on all other memory references\n-     in LOOP.  */\n-  if (!ref_indep_loop_p (loop, ref))\n+  /* Verify all loads of ref can be hoisted.  */\n+  if (ref->loaded\n+      && bitmap_bit_p (ref->loaded, loop->num)\n+      && !ref_indep_loop_p (loop, ref, lim_raw))\n+    return false;\n+\n+  /* Verify the candidate can be disambiguated against all loads,\n+     that is, we can elide all in-loop stores.  Disambiguation\n+     against stores is done later when we cannot guarantee preserving\n+     the order of stores.  */\n+  if (!ref_indep_loop_p (loop, ref, sm_war))\n     return false;\n \n   return true;\n@@ -2473,7 +2820,8 @@ store_motion_loop (class loop *loop, bitmap sm_executed)\n   if (loop_suitable_for_sm (loop, exits))\n     {\n       find_refs_for_sm (loop, sm_executed, sm_in_loop);\n-      hoist_memory_references (loop, sm_in_loop, exits);\n+      if (!bitmap_empty_p (sm_in_loop))\n+\thoist_memory_references (loop, sm_in_loop, exits);\n     }\n   exits.release ();\n \n@@ -2629,16 +2977,16 @@ tree_ssa_lim_initialize (void)\n   memory_accesses.refs_list.quick_push\n     (mem_ref_alloc (NULL, 0, UNANALYZABLE_MEM_ID));\n \n-  memory_accesses.refs_in_loop.create (number_of_loops (cfun));\n-  memory_accesses.refs_in_loop.quick_grow (number_of_loops (cfun));\n+  memory_accesses.refs_loaded_in_loop.create (number_of_loops (cfun));\n+  memory_accesses.refs_loaded_in_loop.quick_grow (number_of_loops (cfun));\n   memory_accesses.refs_stored_in_loop.create (number_of_loops (cfun));\n   memory_accesses.refs_stored_in_loop.quick_grow (number_of_loops (cfun));\n   memory_accesses.all_refs_stored_in_loop.create (number_of_loops (cfun));\n   memory_accesses.all_refs_stored_in_loop.quick_grow (number_of_loops (cfun));\n \n   for (i = 0; i < number_of_loops (cfun); i++)\n     {\n-      bitmap_initialize (&memory_accesses.refs_in_loop[i],\n+      bitmap_initialize (&memory_accesses.refs_loaded_in_loop[i],\n \t\t\t &lim_bitmap_obstack);\n       bitmap_initialize (&memory_accesses.refs_stored_in_loop[i],\n \t\t\t &lim_bitmap_obstack);\n@@ -2681,7 +3029,7 @@ tree_ssa_lim_finalize (void)\n   memory_accesses.refs_list.release ();\n   obstack_free (&mem_ref_obstack, NULL);\n \n-  memory_accesses.refs_in_loop.release ();\n+  memory_accesses.refs_loaded_in_loop.release ();\n   memory_accesses.refs_stored_in_loop.release ();\n   memory_accesses.all_refs_stored_in_loop.release ();\n "}]}