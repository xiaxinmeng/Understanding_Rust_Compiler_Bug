{"sha": "fa3d2d38107033fc7620171474fbb7e2894cc79e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEzZDJkMzgxMDcwMzNmYzc2MjAxNzE0NzRmYmI3ZTI4OTRjYzc5ZQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-08-21T19:36:13Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-08-21T19:36:13Z"}, "message": "Unconditionally use MAX_EXPR/MIN_EXPR for MAX/MIN intrinsics\n\nFor floating point types, the question is what MAX(a, NaN) or MIN(a,\nNaN) should return (where \"a\" is a normal number).  There are valid\nusecases for returning either one, but the Fortran standard doesn't\nspecify which one should be chosen.  Also, there is no consensus among\nother tested compilers.  In short, it's a mess.  So lets just do\nwhatever is fastest, which is using MAX_EXPR/MIN_EXPR which are not\ndefined to do anything in particular if one of the operands is a NaN.\n\ngcc/fortran/ChangeLog:\n\n2018-08-21  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmax): Use\n\tMAX_EXPR/MIN_EXPR unconditionally for real arguments.\n\t* gfortran.texi (Compiler Characteristics): Document MAX/MIN\n\tbehavior wrt NaN.\n\ngcc/testsuite/ChangeLog:\n\n2018-08-21  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* gfortran.dg/nan_1.f90: Remove tests that test MAX/MIN with NaNs.\n\nFrom-SVN: r263751", "tree": {"sha": "b106cd8075ae04792a2c458ffd2dbbe9d9711385", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b106cd8075ae04792a2c458ffd2dbbe9d9711385"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa3d2d38107033fc7620171474fbb7e2894cc79e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa3d2d38107033fc7620171474fbb7e2894cc79e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa3d2d38107033fc7620171474fbb7e2894cc79e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa3d2d38107033fc7620171474fbb7e2894cc79e/comments", "author": null, "committer": null, "parents": [{"sha": "2b4c90656132abb8b8ad155d345c7d4fbf1687c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4c90656132abb8b8ad155d345c7d4fbf1687c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b4c90656132abb8b8ad155d345c7d4fbf1687c9"}], "stats": {"total": 117, "additions": 37, "deletions": 80}, "files": [{"sha": "c91ffc93493ef7f8fcd74224cd9c5a1858134e5d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fa3d2d38107033fc7620171474fbb7e2894cc79e", "patch": "@@ -1,3 +1,10 @@\n+2018-08-21  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmax): Use\n+\tMAX_EXPR/MIN_EXPR unconditionally for real arguments.\n+\t* gfortran.texi (Compiler Characteristics): Document MAX/MIN\n+\tbehavior wrt NaN.\n+\n 2018-08-21  Nicolas Koenig  <koenigni@gcc.gnu.org>\n \tThomas Koenig <tkoenig@gcc.gnu.org>\n "}, {"sha": "0f3f454ff83692a9c0008817d697cf55fbed33f2", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=fa3d2d38107033fc7620171474fbb7e2894cc79e", "patch": "@@ -1177,6 +1177,7 @@ might in some way or another become visible to the programmer.\n * KIND Type Parameters::\n * Internal representation of LOGICAL variables::\n * Evaluation of logical expressions::\n+* MAX and MIN intrinsics with REAL NaN arguments::\n * Thread-safety of the runtime library::\n * Data consistency and durability::\n * Files opened without an explicit ACTION= specifier::\n@@ -1265,6 +1266,21 @@ program flow and subsequent results, GNU Fortran throws warnings for such\n situations with the @option{-Wfunction-elimination} flag.\n \n \n+@node MAX and MIN intrinsics with REAL NaN arguments\n+@section MAX and MIN intrinsics with REAL NaN arguments\n+@cindex MAX, MIN, NaN\n+\n+The Fortran standard does not specify what the result of the\n+@code{MAX} and @code{MIN} intrinsics are if one of the arguments is a\n+@code{NaN}.  Accordingly, the GNU Fortran compiler does not specify\n+that either, as this allows for faster and more compact code to be\n+generated.  If the programmer wishes to take some specific action in\n+case one of the arguments is a @code{NaN}, it is necessary to\n+explicitly test the arguments before calling @code{MAX} or @code{MIN},\n+e.g. with the @code{IEEE_IS_NAN} function from the intrinsic module\n+@code{IEEE_ARITHMETIC}.\n+\n+\n @node Thread-safety of the runtime library\n @section Thread-safety of the runtime library\n @cindex thread-safety, threads"}, {"sha": "387cf80b921fad90c3c6f93d7a95e4ff07d66712", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 10, "deletions": 45, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=fa3d2d38107033fc7620171474fbb7e2894cc79e", "patch": "@@ -3914,8 +3914,6 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   mvar = gfc_create_var (type, \"M\");\n   gfc_add_modify (&se->pre, mvar, args[0]);\n \n-  internal_fn ifn = op == GT_EXPR ? IFN_FMAX : IFN_FMIN;\n-\n   for (i = 1, argexpr = argexpr->next; i < nargs; i++, argexpr = argexpr->next)\n     {\n       tree cond = NULL_TREE;\n@@ -3936,49 +3934,16 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \tval = gfc_evaluate_now (val, &se->pre);\n \n       tree calc;\n-      /* If we dealing with integral types or we don't care about NaNs\n-\t just do a MIN/MAX_EXPR.  */\n-      if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (type))\n-\t{\n-\n-\t  tree_code code = op == GT_EXPR ? MAX_EXPR : MIN_EXPR;\n-\t  calc = fold_build2_loc (input_location, code, type,\n-\t\t\t\t  convert (type, val), mvar);\n-\t  tmp = build2_v (MODIFY_EXPR, mvar, calc);\n-\n-\t}\n-      /* If we care about NaNs and we have internal functions available for\n-\t fmin/fmax to perform the comparison, use those.  */\n-      else if (SCALAR_FLOAT_TYPE_P (type)\n-\t      && direct_internal_fn_supported_p (ifn, type, OPTIMIZE_FOR_SPEED))\n-\t{\n-\t  calc = build_call_expr_internal_loc (input_location, ifn, type,\n-\t\t\t\t\t\t2, mvar, convert (type, val));\n-\t  tmp = build2_v (MODIFY_EXPR, mvar, calc);\n-\n-\t}\n-      /* Otherwise expand to:\n-\tmvar = a1;\n-\tif (a2 .op. mvar || isnan (mvar))\n-\t  mvar = a2;\n-\tif (a3 .op. mvar || isnan (mvar))\n-\t  mvar = a3;\n-\t...  */\n-      else\n-\t{\n-\t  tree isnan = build_call_expr_loc (input_location,\n-\t\t\t\t\tbuiltin_decl_explicit (BUILT_IN_ISNAN),\n-\t\t\t\t\t1, mvar);\n-\t  tmp = fold_build2_loc (input_location, op, logical_type_node,\n-\t\t\t\t convert (type, val), mvar);\n-\n-\t  tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t  logical_type_node, tmp,\n-\t\t\t\t  fold_convert (logical_type_node, isnan));\n-\t  tmp = build3_v (COND_EXPR, tmp,\n-\t\t\t  build2_v (MODIFY_EXPR, mvar, convert (type, val)),\n-\t\t\t  build_empty_stmt (input_location));\n-\t}\n+      /* For floating point types, the question is what MAX(a, NaN) or\n+\t MIN(a, NaN) should return (where \"a\" is a normal number).\n+\t There are valid usecase for returning either one, but the\n+\t Fortran standard doesn't specify which one should be chosen.\n+\t Also, there is no consensus among other tested compilers.  In\n+\t short, it's a mess.  So lets just do whatever is fastest.  */\n+      tree_code code = op == GT_EXPR ? MAX_EXPR : MIN_EXPR;\n+      calc = fold_build2_loc (input_location, code, type,\n+\t\t\t      convert (type, val), mvar);\n+      tmp = build2_v (MODIFY_EXPR, mvar, calc);\n \n       if (cond != NULL_TREE)\n \ttmp = build3_v (COND_EXPR, cond, tmp,"}, {"sha": "f0a5ff50877dec2e93bcab66dc93328641a0f59b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa3d2d38107033fc7620171474fbb7e2894cc79e", "patch": "@@ -1,3 +1,7 @@\n+2018-08-21  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* gfortran.dg/nan_1.f90: Remove tests that test MAX/MIN with NaNs.\n+\n 2018-08-21  Nicolas Koenig  <koenigni@gcc.gnu.org>\n \tThomas Koenig <tkoenig@gcc.gnu.org>\n "}, {"sha": "1b39cc1f21caaa11e8e9ce6974ba1e65e1e580dd", "filename": "gcc/testsuite/gfortran.dg/nan_1.f90", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa3d2d38107033fc7620171474fbb7e2894cc79e/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnan_1.f90?ref=fa3d2d38107033fc7620171474fbb7e2894cc79e", "patch": "@@ -66,35 +66,12 @@ program test\n   if (isinf(-nan) .or. isinf(-large) .or. .not. isinf(-inf)) STOP 4\n \n   ! Check that MIN and MAX behave correctly\n-  if (max(2.0, nan) /= 2.0) STOP 5\n-  if (min(2.0, nan) /= 2.0) STOP 6\n-  if (max(nan, 2.0) /= 2.0) STOP 7\n-  if (min(nan, 2.0) /= 2.0) STOP 8\n-\n-  if (max(2.d0, nan) /= 2.d0) STOP 9! { dg-warning \"Extension: Different type kinds\" }\n-  if (min(2.d0, nan) /= 2.d0) STOP 10! { dg-warning \"Extension: Different type kinds\" }\n-  if (max(nan, 2.d0) /= 2.d0) STOP 11! { dg-warning \"Extension: Different type kinds\" }\n-  if (min(nan, 2.d0) /= 2.d0) STOP 12! { dg-warning \"Extension: Different type kinds\" }\n \n   if (.not. isnan(min(nan,nan))) STOP 13\n   if (.not. isnan(max(nan,nan))) STOP 14\n \n   ! Same thing, with more arguments\n \n-  if (max(3.0, 2.0, nan) /= 3.0) STOP 15\n-  if (min(3.0, 2.0, nan) /= 2.0) STOP 16\n-  if (max(3.0, nan, 2.0) /= 3.0) STOP 17\n-  if (min(3.0, nan, 2.0) /= 2.0) STOP 18\n-  if (max(nan, 3.0, 2.0) /= 3.0) STOP 19\n-  if (min(nan, 3.0, 2.0) /= 2.0) STOP 20\n-\n-  if (max(3.d0, 2.d0, nan) /= 3.d0) STOP 21! { dg-warning \"Extension: Different type kinds\" }\n-  if (min(3.d0, 2.d0, nan) /= 2.d0) STOP 22! { dg-warning \"Extension: Different type kinds\" }\n-  if (max(3.d0, nan, 2.d0) /= 3.d0) STOP 23! { dg-warning \"Extension: Different type kinds\" }\n-  if (min(3.d0, nan, 2.d0) /= 2.d0) STOP 24! { dg-warning \"Extension: Different type kinds\" }\n-  if (max(nan, 3.d0, 2.d0) /= 3.d0) STOP 25! { dg-warning \"Extension: Different type kinds\" }\n-  if (min(nan, 3.d0, 2.d0) /= 2.d0) STOP 26! { dg-warning \"Extension: Different type kinds\" }\n-\n   if (.not. isnan(min(nan,nan,nan))) STOP 27\n   if (.not. isnan(max(nan,nan,nan))) STOP 28\n   if (.not. isnan(min(nan,nan,nan,nan))) STOP 29\n@@ -105,20 +82,8 @@ program test\n   ! Large values, INF and NaNs\n   if (.not. isinf(max(large, inf))) STOP 33\n   if (isinf(min(large, inf))) STOP 34\n-  if (.not. isinf(max(nan, large, inf))) STOP 35\n-  if (isinf(min(nan, large, inf))) STOP 36\n-  if (.not. isinf(max(large, nan, inf))) STOP 37\n-  if (isinf(min(large, nan, inf))) STOP 38\n-  if (.not. isinf(max(large, inf, nan))) STOP 39\n-  if (isinf(min(large, inf, nan))) STOP 40\n \n   if (.not. isinf(min(-large, -inf))) STOP 41\n   if (isinf(max(-large, -inf))) STOP 42\n-  if (.not. isinf(min(nan, -large, -inf))) STOP 43\n-  if (isinf(max(nan, -large, -inf))) STOP 44\n-  if (.not. isinf(min(-large, nan, -inf))) STOP 45\n-  if (isinf(max(-large, nan, -inf))) STOP 46\n-  if (.not. isinf(min(-large, -inf, nan))) STOP 47\n-  if (isinf(max(-large, -inf, nan))) STOP 48\n \n end program test"}]}