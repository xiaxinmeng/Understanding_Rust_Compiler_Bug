{"sha": "7565a035be546e2a97a4377a92fe89ed15e3b1de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU2NWEwMzViZTU0NmUyYTk3YTQzNzdhOTJmZTg5ZWQxNWUzYjFkZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-20T13:13:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-20T13:13:06Z"}, "message": "(expand_builtin, case BUILT_IN_SETJMP): Call \"setjmp\" pattern, if any.\n\nCall dummy function pointed to by static chain pointer.\n(expand_builtin, case BUILT_IN_LONJMP): Ignore second expression.\nSet address of __dummy into static chain pointer.\nCopy the label to return to into a pseudo earlier.\n\nFrom-SVN: r11576", "tree": {"sha": "4f0b2a5e5a036f62abaea592fe21453f862d5c72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f0b2a5e5a036f62abaea592fe21453f862d5c72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7565a035be546e2a97a4377a92fe89ed15e3b1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7565a035be546e2a97a4377a92fe89ed15e3b1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7565a035be546e2a97a4377a92fe89ed15e3b1de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7565a035be546e2a97a4377a92fe89ed15e3b1de/comments", "author": null, "committer": null, "parents": [{"sha": "c4124c29e0b3803ff78cd69644f8ef259bc99f7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4124c29e0b3803ff78cd69644f8ef259bc99f7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4124c29e0b3803ff78cd69644f8ef259bc99f7b"}], "stats": {"total": 61, "additions": 52, "deletions": 9}, "files": [{"sha": "bcfcf972808f1d8023138f4691169559b2612ed7", "filename": "gcc/expr.c", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7565a035be546e2a97a4377a92fe89ed15e3b1de/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7565a035be546e2a97a4377a92fe89ed15e3b1de/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7565a035be546e2a97a4377a92fe89ed15e3b1de", "patch": "@@ -8526,6 +8526,11 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \trtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n \tenum machine_mode sa_mode = Pmode;\n \trtx stack_save;\n+\tint old_inhibit_defer_pop = inhibit_defer_pop;\n+\tint return_pops = RETURN_POPS_ARGS (get_identifier (\"__dummy\"),\n+\t\t\t\t\t    get_identifier (\"__dummy\"), 0);\n+\trtx next_arg_reg;\n+\tCUMULATIVE_ARGS args_so_far;\n \tint i;\n \n \tif (target == 0 || GET_CODE (target) != REG\n@@ -8558,6 +8563,11 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t\t\t\t\t     2 * GET_MODE_SIZE (Pmode)));\n \temit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n \n+#ifdef HAVE_setjmp\n+\tif (HAVE_setjmp)\n+\t  emit_insn (gen_setjmp ());\n+#endif\n+\n \t/* Set TARGET to zero and branch around the other case.  */\n \temit_move_insn (target, const0_rtx);\n \temit_jump_insn (gen_jump (lab2));\n@@ -8605,18 +8615,44 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  }\n #endif\n \n-\t/* The result to return is in the static chain pointer.  */\n-\tif (GET_MODE (static_chain_rtx) == GET_MODE (target))\n-\t  emit_move_insn (target, static_chain_rtx);\n+\t/* The static chain pointer contains the address of dummy function.\n+\t   We need to call it here to handle some PIC cases of restoring\n+\t   a global pointer.  Then return 1.  */\n+\top0 = copy_to_mode_reg (Pmode, static_chain_rtx);\n+\n+\t/* We can't actually call emit_library_call here, so do everything\n+\t   it does, which isn't much for a libfunc with no args.  */\n+\top0 = memory_address (FUNCTION_MODE, op0);\n+\n+\tINIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE,\n+\t\t\t      gen_rtx (SYMBOL_REF, Pmode, \"__dummy\"));\n+\tnext_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n+\n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#ifdef HAVE_call_pop\n+\tif (HAVE_call_pop)\n+\t  emit_call_insn (gen_call_pop (gen_rtx (MEM, FUNCTION_MODE, op0),\n+\t\t\t\t\tconst0_rtx, next_arg_reg,\n+\t\t\t\t\tGEN_INT (return_pops)));\n+\telse\n+#endif\n+#endif\n+\n+#ifdef HAVE_call\n+\tif (HAVE_call)\n+\t  emit_call_insn (gen_call (gen_rtx (MEM, FUNCTION_MODE, op0),\n+\t\t\t\t    const0_rtx, next_arg_reg, const0_rtx));\n \telse\n-\t  convert_move (target, static_chain_rtx, 0);\n+#endif\n+\t    abort ();\n \n+\temit_move_insn (target, const1_rtx);\n \temit_label (lab2);\n \treturn target;\n       }\n \n       /* __builtin_longjmp is passed a pointer to an array of five words\n-\t and a value to return.  It's similar to the C library longjmp\n+\t and a value, which is a dummy.  It's similar to the C library longjmp\n \t function but works with __builtin_setjmp above.  */\n     case BUILT_IN_LONGJMP:\n       if (arglist == 0 || TREE_CHAIN (arglist) == 0\n@@ -8641,8 +8677,13 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \trtx stack = gen_rtx (MEM, sa_mode,\n \t\t\t     plus_constant (buf_addr,\n \t\t\t\t\t    2 * GET_MODE_SIZE (Pmode)));\n-\trtx value = expand_expr (TREE_VALUE (TREE_CHAIN (arglist)), NULL_RTX,\n-\t\t\t\t VOIDmode, 0);\n+\trtx value = gen_rtx (SYMBOL_REF, Pmode, \"__dummy\");\n+\n+\t/* Expand the second expression just for side-effects.  */\n+\texpand_expr (TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t     const0_rtx, VOIDmode, 0);\n+\n+\tassemble_external_libcall (value);\n \n \t/* Pick up FP, label, and SP from the block and jump.  This code is\n \t   from expand_goto in stmt.c; see there for detailed comments.  */\n@@ -8652,15 +8693,17 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       else\n #endif\n \t{\n+\t  lab = copy_to_reg (lab);\n \t  emit_move_insn (hard_frame_pointer_rtx, fp);\n \t  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n \n-\t  /* Put in the static chain register the return value.  */\n+\t  /* Put in the static chain register the address of the dummy\n+\t     function.  */\n \t  emit_move_insn (static_chain_rtx, value);\n \t  emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));\n \t  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n \t  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n-\t  emit_indirect_jump (copy_to_reg (lab));\n+\t  emit_indirect_jump (lab);\n \t}\n \n \treturn const0_rtx;"}]}