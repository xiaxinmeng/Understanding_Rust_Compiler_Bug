{"sha": "2845f02a6f36e198848fc90a266dd75c9842bcc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg0NWYwMmE2ZjM2ZTE5ODg0OGZjOTBhMjY2ZGQ3NWM5ODQyYmNjMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-25T17:12:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-25T17:12:49Z"}, "message": "tree-ssa-alias.c (fieldoff_t): Remove.\n\n\t* tree-ssa-alias.c (fieldoff_t): Remove.\n\t(fieldoff_s): typedef the structure itself.  Create a vector of\n\tobjects.\n\t(push_fields_onto_fieldstack): Return count of fields pushed.\n\tRemove peeling of first field.  Adjust.\n\t(fieldoff_compare): Adjust.\n\t(create_overlap_variables_for): Adjust.\n\nFrom-SVN: r98723", "tree": {"sha": "7bd93d7712b58e9912903be796beabb0598f2c52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bd93d7712b58e9912903be796beabb0598f2c52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2845f02a6f36e198848fc90a266dd75c9842bcc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2845f02a6f36e198848fc90a266dd75c9842bcc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2845f02a6f36e198848fc90a266dd75c9842bcc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2845f02a6f36e198848fc90a266dd75c9842bcc0/comments", "author": null, "committer": null, "parents": [{"sha": "9821b2576f3d4b473687b827f8d0eab1c282f097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9821b2576f3d4b473687b827f8d0eab1c282f097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9821b2576f3d4b473687b827f8d0eab1c282f097"}], "stats": {"total": 172, "additions": 75, "deletions": 97}, "files": [{"sha": "f8784dbc5cfeaadc8a9545d2036dd65301b39315", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2845f02a6f36e198848fc90a266dd75c9842bcc0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2845f02a6f36e198848fc90a266dd75c9842bcc0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2845f02a6f36e198848fc90a266dd75c9842bcc0", "patch": "@@ -1,3 +1,13 @@\n+2005-04-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree-ssa-alias.c (fieldoff_t): Remove.\n+\t(fieldoff_s): typedef the structure itself.  Create a vector of\n+\tobjects.\n+\t(push_fields_onto_fieldstack): Return count of fields pushed.\n+\tRemove peeling of first field.  Adjust.\n+\t(fieldoff_compare): Adjust.\n+\t(create_overlap_variables_for): Adjust.\n+\n 2005-04-25  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* doc/invoke.texi (Blackfin Options): Avoid empty @opindex line."}, {"sha": "a723e2ad0a0264b345b895e08bc20b1bc47b07cc", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 65, "deletions": 97, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2845f02a6f36e198848fc90a266dd75c9842bcc0/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2845f02a6f36e198848fc90a266dd75c9842bcc0/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=2845f02a6f36e198848fc90a266dd75c9842bcc0", "patch": "@@ -2789,11 +2789,10 @@ typedef struct fieldoff\n {\n   tree field;\n   HOST_WIDE_INT offset;  \n-} *fieldoff_t;\n+} fieldoff_s;\n \n-DEF_VEC_P (fieldoff_t);  /* FIXME: This can be a vector of struct\n-\t\t\t    fieldoff objects (nathan 2005/04/15)  */\n-DEF_VEC_ALLOC_P(fieldoff_t,heap);\n+DEF_VEC_O (fieldoff_s);\n+DEF_VEC_ALLOC_O(fieldoff_s,heap);\n \n /* Return the position, in bits, of FIELD_DECL from the beginning of its\n    structure. \n@@ -2815,71 +2814,52 @@ bitpos_of_field (const tree fdecl)\n /* Given a TYPE, and a vector of field offsets FIELDSTACK, push all the fields\n    of TYPE onto fieldstack, recording their offsets along the way.\n    OFFSET is used to keep track of the offset in this entire structure, rather\n-   than just the immediately containing structure.  */\n+   than just the immediately containing structure.  Returns the number\n+   of fields pushed. */\n \n-static void\n-push_fields_onto_fieldstack (tree type, VEC(fieldoff_t,heap) **fieldstack, \n+static int\n+push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack, \n \t\t\t     HOST_WIDE_INT offset)\n {\n-  fieldoff_t pair;\n-  tree field = TYPE_FIELDS (type);\n-  if (!field)\n-    return;\n-  if (var_can_have_subvars (field)\n-      && TREE_CODE (field) == FIELD_DECL)\n-    {\n-      size_t before = VEC_length (fieldoff_t, *fieldstack);\n-      /* Empty structures may have actual size, like in C++. So see if we\n-\t actually end up pushing a field, and if not, if the size is nonzero,\n-\t push the field onto the stack */\n-      push_fields_onto_fieldstack (TREE_TYPE (field), fieldstack, offset);\n-      if (before == VEC_length (fieldoff_t, *fieldstack)\n-\t  && DECL_SIZE (field)\n-\t  && !integer_zerop (DECL_SIZE (field)))\n-\t{\n-\t  pair = xmalloc (sizeof (struct fieldoff));\n-\t  pair->field = field;\n-\t  pair->offset = offset;\n-\t  VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n-\t}\n-    }\n-  else if (TREE_CODE (field) == FIELD_DECL)\n-    {\n-      pair = xmalloc (sizeof (struct fieldoff));\n-      pair->field = field;\n-      pair->offset = offset + bitpos_of_field (field);\n-      VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n-    }\n-  for (field = TREE_CHAIN (field); field; field = TREE_CHAIN (field))\n-    {\n-      if (TREE_CODE (field) != FIELD_DECL)\n-\tcontinue;\n-      if (var_can_have_subvars (field))\n-\t{\n-\t  size_t before = VEC_length (fieldoff_t, *fieldstack);\n-\t  push_fields_onto_fieldstack (TREE_TYPE (field), fieldstack, \n-\t\t\t\t       offset + bitpos_of_field (field));\n-      /* Empty structures may have actual size, like in C++. So see if we\n-\t actually end up pushing a field, and if not, if the size is nonzero,\n-\t push the field onto the stack */\n-\t  if (before == VEC_length (fieldoff_t, *fieldstack)\n-\t      && DECL_SIZE (field)\n-\t      && !integer_zerop (DECL_SIZE (field)))\n-\t    {\n-\t      pair = xmalloc (sizeof (struct fieldoff));\n-\t      pair->field = field;\n-\t      pair->offset = offset + bitpos_of_field (field);\n-\t      VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  pair = xmalloc (sizeof (struct fieldoff));\n-\t  pair->field = field;\n-\t  pair->offset = offset + bitpos_of_field (field);\n-\t  VEC_safe_push (fieldoff_t, heap, *fieldstack, pair);\n-\t}\n-    }\n+  tree field;\n+  int count = 0;\n+\n+  /* Although there is nothing wrong per se with a structure whose\n+     first field does not start at offset 0, there appeared to be an\n+     Ada bug where the first field's offset was not zero, but the\n+     field itself was at offset zero.  Make sure that doesn't\n+     reoccur.  */\n+  gcc_assert (!TYPE_FIELDS (type)\n+\t      || TREE_CODE (TYPE_FIELDS (type)) != FIELD_DECL\n+\t      || !bitpos_of_field (TYPE_FIELDS (type)));\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL)\n+      {\n+\tbool push = false;\n+      \n+\tif (!var_can_have_subvars (field))\n+\t  push = true;\n+\telse if (!(push_fields_onto_fieldstack\n+\t\t   (TREE_TYPE (field), fieldstack,\n+\t\t    offset + bitpos_of_field (field)))\n+\t\t && DECL_SIZE (field)\n+\t\t && !integer_zerop (DECL_SIZE (field)))\n+\t  /* Empty structures may have actual size, like in C++. So\n+\t     see if we didn't push any subfields and the size is\n+\t     nonzero, push the field onto the stack */\n+\t  push = true;\n+\t\n+\tif (push)\n+\t  {\n+\t    fieldoff_s *pair;\n+\n+\t    pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n+\t    pair->field = field;\n+\t    pair->offset = offset + bitpos_of_field (field);\n+\t    count++;\n+\t  }\n+      }\n+  return count;\n }\n \n \n@@ -2922,22 +2902,21 @@ get_or_create_used_part_for (size_t uid)\n   return up;\n }\n \n-/* qsort comparison function for two fieldoff_t's PA and PB */\n+/* qsort comparison function for two fieldoff's PA and PB */\n \n static int \n fieldoff_compare (const void *pa, const void *pb)\n {\n-  const fieldoff_t foa = *(fieldoff_t *)pa;\n-  const fieldoff_t fob = *(fieldoff_t *)pb;\n+  const fieldoff_s *foa = (const fieldoff_s *)pa;\n+  const fieldoff_s *fob = (const fieldoff_s *)pb;\n   HOST_WIDE_INT foasize, fobsize;\n+  \n   if (foa->offset != fob->offset)\n     return foa->offset - fob->offset;\n \n   foasize = TREE_INT_CST_LOW (DECL_SIZE (foa->field));\n   fobsize = TREE_INT_CST_LOW (DECL_SIZE (fob->field));\n-  if (foasize != fobsize)\n-    return foasize - fobsize;\n-  return 0;\n+  return foasize - fobsize;\n }\n \n /* Given an aggregate VAR, create the subvariables that represent its\n@@ -2946,7 +2925,7 @@ fieldoff_compare (const void *pa, const void *pb)\n static void\n create_overlap_variables_for (tree var)\n {\n-  VEC(fieldoff_t,heap) *fieldstack = NULL;\n+  VEC(fieldoff_s,heap) *fieldstack = NULL;\n   used_part_t up;\n   size_t uid = var_ann (var)->uid;\n \n@@ -2955,10 +2934,10 @@ create_overlap_variables_for (tree var)\n \n   up = used_portions[uid];\n   push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0);\n-  if (VEC_length (fieldoff_t, fieldstack) != 0)\n+  if (VEC_length (fieldoff_s, fieldstack) != 0)\n     {\n       subvar_t *subvars;\n-      fieldoff_t fo;\n+      fieldoff_s *fo;\n       bool notokay = false;\n       int fieldcount = 0;\n       int i;\n@@ -2975,7 +2954,7 @@ create_overlap_variables_for (tree var)\n \t currently don't.  Doing so would require some extra changes to\n \t tree-ssa-operands.c.  */\n \n-      for (i = 0; VEC_iterate (fieldoff_t, fieldstack, i, fo); i++)\n+      for (i = 0; VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n \t{\n \t  if (!DECL_SIZE (fo->field) \n \t      || TREE_CODE (DECL_SIZE (fo->field)) != INTEGER_CST\n@@ -3012,34 +2991,29 @@ create_overlap_variables_for (tree var)\n \t  notokay = true;\n \t}\n       \n-    \n-      /* Cleanup after ourselves if we can't create overlap variables.  */\n+      /* Bail out, if we can't create overlap variables.  */\n       if (notokay)\n \t{\n-\t  while (VEC_length (fieldoff_t, fieldstack) != 0)\n-\t    {\n-\t      fo = VEC_pop (fieldoff_t, fieldstack);\n-\t      free (fo);\n-\t    }\n-\t  VEC_free (fieldoff_t, heap, fieldstack);\n+\t  VEC_free (fieldoff_s, heap, fieldstack);\n \t  return;\n \t}\n+      \n       /* Otherwise, create the variables.  */\n       subvars = lookup_subvars_for_var (var);\n       \n-      qsort (VEC_address (fieldoff_t, fieldstack), \n-\t     VEC_length (fieldoff_t, fieldstack), \n-\t     sizeof (fieldoff_t),\n+      qsort (VEC_address (fieldoff_s, fieldstack), \n+\t     VEC_length (fieldoff_s, fieldstack), \n+\t     sizeof (fieldoff_s),\n \t     fieldoff_compare);\n \n-      while (VEC_length (fieldoff_t, fieldstack) != 0)\n+      for (i = VEC_length (fieldoff_s, fieldstack);\n+\t   VEC_iterate (fieldoff_s, fieldstack, --i, fo);)\n \t{\n \t  subvar_t sv;\n \t  HOST_WIDE_INT fosize;\n \t  var_ann_t ann;\n \t  tree currfotype;\n \n-\t  fo = VEC_pop (fieldoff_t, fieldstack);\t  \n \t  fosize = TREE_INT_CST_LOW (DECL_SIZE (fo->field));\n \t  currfotype = TREE_TYPE (fo->field);\n \n@@ -3053,10 +3027,7 @@ create_overlap_variables_for (tree var)\n \t      || (fo->offset == lastfooffset\n \t\t  && fosize == lastfosize\n \t\t  && currfotype == lastfotype))\n-\t    {\n-\t      free (fo);\n-\t      continue;\n-\t    }\n+\t    continue;\n \t  sv = ggc_alloc (sizeof (struct subvar));\n \t  sv->offset = fo->offset;\n \t  sv->size = fosize;\n@@ -3071,7 +3042,6 @@ create_overlap_variables_for (tree var)\n \t      fprintf (dump_file, \" size \" HOST_WIDE_INT_PRINT_DEC,\n \t\t       sv->size);\n \t      fprintf (dump_file, \"\\n\");\n-\t      \n \t    }\n \t  \n \t  /* We need to copy the various flags from var to sv->var, so that\n@@ -3097,7 +3067,6 @@ create_overlap_variables_for (tree var)\n \t  lastfooffset = fo->offset;\n \t  lastfosize = fosize;\n \t  *subvars = sv;\n-\t  free (fo);\n \t}\n \n       /* Once we have created subvars, the original is no longer call\n@@ -3108,10 +3077,9 @@ create_overlap_variables_for (tree var)\n \t marking subvars of global variables as call clobbered for us\n \t to start, since they are global as well.  */\n       clear_call_clobbered (var);\n-\n     }\n \n-  VEC_free (fieldoff_t, heap, fieldstack);\n+  VEC_free (fieldoff_s, heap, fieldstack);\n }\n \n "}]}