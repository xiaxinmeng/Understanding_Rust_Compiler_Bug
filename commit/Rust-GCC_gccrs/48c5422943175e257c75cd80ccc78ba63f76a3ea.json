{"sha": "48c5422943175e257c75cd80ccc78ba63f76a3ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhjNTQyMjk0MzE3NWUyNTdjNzVjZDgwY2NjNzhiYTYzZjc2YTNlYQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-16T17:55:42Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-16T17:55:42Z"}, "message": "c-pch.c (get_ident): Avoid C++ keywords.\n\n\t* c-pch.c (get_ident): Avoid C++ keywords.\n\t* combine-stack-adj.c (single_set_for_csa): Likewise.\n\t* final.c (asm_insn_count, final_scan_insn, alter_subreg,\n\toutput_asm_insn): Likewise.\n\t* reload.c (push_secondary_reload, find_reusable_reload,\n\tpush_reload, combine_reloads, find_reloads,\n\tdebug_reload_to_stream): Likewise.\n\t* reload.h (struct reload): Likewise.\n\t* reload1.c (reload_reg_class_lower, find_reg, find_reload_regs,\n\tallocate_reload_reg, choose_reload_regs, emit_input_reload_insns,\n\temit_output_reload_insns): Likewise.\n\t* targhooks.c (default_secondary_reload): Likewise.\n\t* varasm.c (section_entry_eq, object_block_entry_eq): Likewise.\n\nFrom-SVN: r137895", "tree": {"sha": "082bfe0730bc1523dda8ece43db227bc392857ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/082bfe0730bc1523dda8ece43db227bc392857ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48c5422943175e257c75cd80ccc78ba63f76a3ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c5422943175e257c75cd80ccc78ba63f76a3ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c5422943175e257c75cd80ccc78ba63f76a3ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c5422943175e257c75cd80ccc78ba63f76a3ea/comments", "author": null, "committer": null, "parents": [{"sha": "55d796dacbdfb6133311e06027360066c0fce95f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d796dacbdfb6133311e06027360066c0fce95f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d796dacbdfb6133311e06027360066c0fce95f"}], "stats": {"total": 200, "additions": 108, "deletions": 92}, "files": [{"sha": "fc14b40be79059f7a1f559ed993a9e02dcf1851e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -1,3 +1,19 @@\n+2008-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-pch.c (get_ident): Avoid C++ keywords.\n+\t* combine-stack-adj.c (single_set_for_csa): Likewise.\n+\t* final.c (asm_insn_count, final_scan_insn, alter_subreg,\n+\toutput_asm_insn): Likewise.\n+\t* reload.c (push_secondary_reload, find_reusable_reload,\n+\tpush_reload, combine_reloads, find_reloads,\n+\tdebug_reload_to_stream): Likewise.\n+\t* reload.h (struct reload): Likewise.\n+\t* reload1.c (reload_reg_class_lower, find_reg, find_reload_regs,\n+\tallocate_reload_reg, choose_reload_regs, emit_input_reload_insns,\n+\temit_output_reload_insns): Likewise.\n+\t* targhooks.c (default_secondary_reload): Likewise.\n+\t* varasm.c (section_entry_eq, object_block_entry_eq): Likewise.\n+\n 2008-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* recog.c (validate_change_1, validate_change,"}, {"sha": "8273914f1443df3d814027761519c0a2fe82ef2f", "filename": "gcc/c-pch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -93,10 +93,10 @@ static const char *\n get_ident (void)\n {\n   static char result[IDENT_LENGTH];\n-  static const char template[IDENT_LENGTH] = \"gpch.013\";\n+  static const char templ[IDENT_LENGTH] = \"gpch.013\";\n   static const char c_language_chars[] = \"Co+O\";\n \n-  memcpy (result, template, IDENT_LENGTH);\n+  memcpy (result, templ, IDENT_LENGTH);\n   result[4] = c_language_chars[c_language];\n \n   return result;"}, {"sha": "c678a607c660184f8f2872de9f0d2539b78b6678", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -143,14 +143,14 @@ single_set_for_csa (rtx insn)\n \n   for (i = 1; i < XVECLEN (tmp, 0); ++i)\n     {\n-      rtx this = XVECEXP (tmp, 0, i);\n+      rtx this_rtx = XVECEXP (tmp, 0, i);\n \n       /* The special case is allowing a no-op set.  */\n-      if (GET_CODE (this) == SET\n-\t  && SET_SRC (this) == SET_DEST (this))\n+      if (GET_CODE (this_rtx) == SET\n+\t  && SET_SRC (this_rtx) == SET_DEST (this_rtx))\n \t;\n-      else if (GET_CODE (this) != CLOBBER\n-\t       && GET_CODE (this) != USE)\n+      else if (GET_CODE (this_rtx) != CLOBBER\n+\t       && GET_CODE (this_rtx) != USE)\n \treturn NULL_RTX;\n     }\n "}, {"sha": "f27e430874126133f5a8a0ffe3ef42da8ee12640", "filename": "gcc/final.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -1377,20 +1377,20 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n static int\n asm_insn_count (rtx body)\n {\n-  const char *template;\n+  const char *templ;\n   int count = 1;\n \n   if (GET_CODE (body) == ASM_INPUT)\n-    template = XSTR (body, 0);\n+    templ = XSTR (body, 0);\n   else\n-    template = decode_asm_operands (body, NULL, NULL, NULL, NULL, NULL);\n+    templ = decode_asm_operands (body, NULL, NULL, NULL, NULL, NULL);\n \n-  if (!*template)\n+  if (!*templ)\n     return 0;\n \n-  for (; *template; template++)\n-    if (IS_ASM_LOGICAL_LINE_SEPARATOR (*template, template)\n-\t|| *template == '\\n')\n+  for (; *templ; templ++)\n+    if (IS_ASM_LOGICAL_LINE_SEPARATOR (*templ, templ)\n+\t|| *templ == '\\n')\n       count++;\n \n   return count;\n@@ -2039,7 +2039,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n       {\n \trtx body = PATTERN (insn);\n \tint insn_code_number;\n-\tconst char *template;\n+\tconst char *templ;\n \n #ifdef HAVE_conditional_execution\n \t/* Reset this early so it is correct for ASM statements.  */\n@@ -2556,12 +2556,12 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n #endif\n \n \t/* Find the proper template for this insn.  */\n-\ttemplate = get_insn_template (insn_code_number, insn);\n+\ttempl = get_insn_template (insn_code_number, insn);\n \n \t/* If the C code returns 0, it means that it is a jump insn\n \t   which follows a deleted test insn, and that test insn\n \t   needs to be reinserted.  */\n-\tif (template == 0)\n+\tif (templ == 0)\n \t  {\n \t    rtx prev;\n \n@@ -2584,12 +2584,12 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \n \t/* If the template is the string \"#\", it means that this insn must\n \t   be split.  */\n-\tif (template[0] == '#' && template[1] == '\\0')\n+\tif (templ[0] == '#' && templ[1] == '\\0')\n \t  {\n-\t    rtx new = try_split (body, insn, 0);\n+\t    rtx new_rtx = try_split (body, insn, 0);\n \n \t    /* If we didn't split the insn, go away.  */\n-\t    if (new == insn && PATTERN (new) == body)\n+\t    if (new_rtx == insn && PATTERN (new_rtx) == body)\n \t      fatal_insn (\"could not split insn\", insn);\n \n #ifdef HAVE_ATTR_length\n@@ -2599,7 +2599,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t    gcc_unreachable ();\n #endif\n \n-\t    return new;\n+\t    return new_rtx;\n \t  }\n \n #ifdef TARGET_UNWIND_INFO\n@@ -2610,7 +2610,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n #endif\n \n \t/* Output assembler code from the template.  */\n-\toutput_asm_insn (template, recog_data.operand);\n+\toutput_asm_insn (templ, recog_data.operand);\n \n \t/* If necessary, report the effect that the instruction has on\n \t   the unwind info.   We've already done this for delay slots\n@@ -2739,11 +2739,11 @@ alter_subreg (rtx *xp)\n     }\n   else\n     {\n-      rtx new = simplify_subreg (GET_MODE (x), y, GET_MODE (y),\n+      rtx new_rtx = simplify_subreg (GET_MODE (x), y, GET_MODE (y),\n \t\t\t\t SUBREG_BYTE (x));\n \n-      if (new != 0)\n-\t*xp = new;\n+      if (new_rtx != 0)\n+\t*xp = new_rtx;\n       else if (REG_P (y))\n \t{\n \t  /* Simplify_subreg can't handle some REG cases, but we have to.  */\n@@ -3097,7 +3097,7 @@ output_asm_operand_names (rtx *operands, int *oporder, int nops)\n       of the operand, with no other punctuation.  */\n \n void\n-output_asm_insn (const char *template, rtx *operands)\n+output_asm_insn (const char *templ, rtx *operands)\n {\n   const char *p;\n   int c;\n@@ -3110,11 +3110,11 @@ output_asm_insn (const char *template, rtx *operands)\n \n   /* An insn may return a null string template\n      in a case where no assembler code is needed.  */\n-  if (*template == 0)\n+  if (*templ == 0)\n     return;\n \n   memset (opoutput, 0, sizeof opoutput);\n-  p = template;\n+  p = templ;\n   putc ('\\t', asm_out_file);\n \n #ifdef ASM_OUTPUT_OPCODE"}, {"sha": "a391c457191848ec6b694b9a700662cc2f767477", "filename": "gcc/reload.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -428,8 +428,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n   /* See if we can reuse an existing secondary reload.  */\n   for (s_reload = 0; s_reload < n_reloads; s_reload++)\n     if (rld[s_reload].secondary_p\n-\t&& (reg_class_subset_p (rclass, rld[s_reload].class)\n-\t    || reg_class_subset_p (rld[s_reload].class, rclass))\n+\t&& (reg_class_subset_p (rclass, rld[s_reload].rclass)\n+\t    || reg_class_subset_p (rld[s_reload].rclass, rclass))\n \t&& ((in_p && rld[s_reload].inmode == mode)\n \t    || (! in_p && rld[s_reload].outmode == mode))\n \t&& ((in_p && rld[s_reload].secondary_in_reload == t_reload)\n@@ -445,8 +445,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \tif (! in_p)\n \t  rld[s_reload].outmode = mode;\n \n-\tif (reg_class_subset_p (rclass, rld[s_reload].class))\n-\t  rld[s_reload].class = rclass;\n+\tif (reg_class_subset_p (rclass, rld[s_reload].rclass))\n+\t  rld[s_reload].rclass = rclass;\n \n \trld[s_reload].opnum = MIN (rld[s_reload].opnum, opnum);\n \trld[s_reload].optional &= optional;\n@@ -479,7 +479,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n       /* We need to make a new secondary reload for this register class.  */\n       rld[s_reload].in = rld[s_reload].out = 0;\n-      rld[s_reload].class = rclass;\n+      rld[s_reload].rclass = rclass;\n \n       rld[s_reload].inmode = in_p ? mode : VOIDmode;\n       rld[s_reload].outmode = ! in_p ? mode : VOIDmode;\n@@ -732,8 +732,8 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n      than we otherwise would.  */\n \n   for (i = 0; i < n_reloads; i++)\n-    if ((reg_class_subset_p (rclass, rld[i].class)\n-\t || reg_class_subset_p (rld[i].class, rclass))\n+    if ((reg_class_subset_p (rclass, rld[i].rclass)\n+\t || reg_class_subset_p (rld[i].rclass, rclass))\n \t/* If the existing reload has a register, it must fit our class.  */\n \t&& (rld[i].reg_rtx == 0\n \t    || TEST_HARD_REG_BIT (reg_class_contents[(int) rclass],\n@@ -753,8 +753,8 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n      the preincrementation as happening before any ref in this insn\n      to that register.  */\n   for (i = 0; i < n_reloads; i++)\n-    if ((reg_class_subset_p (rclass, rld[i].class)\n-\t || reg_class_subset_p (rld[i].class, rclass))\n+    if ((reg_class_subset_p (rclass, rld[i].rclass)\n+\t || reg_class_subset_p (rld[i].rclass, rclass))\n \t/* If the existing reload has a register, it must fit our\n \t   class.  */\n \t&& (rld[i].reg_rtx == 0\n@@ -1327,7 +1327,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       i = n_reloads;\n       rld[i].in = in;\n       rld[i].out = out;\n-      rld[i].class = rclass;\n+      rld[i].rclass = rclass;\n       rld[i].inmode = inmode;\n       rld[i].outmode = outmode;\n       rld[i].reg_rtx = 0;\n@@ -1411,8 +1411,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  rld[i].out = out;\n \t  rld[i].out_reg = outloc ? *outloc : 0;\n \t}\n-      if (reg_class_subset_p (rclass, rld[i].class))\n-\trld[i].class = rclass;\n+      if (reg_class_subset_p (rclass, rld[i].rclass))\n+\trld[i].rclass = rclass;\n       rld[i].optional &= optional;\n       if (MERGE_TO_OTHER (type, rld[i].when_needed,\n \t\t\t  opnum, rld[i].opnum))\n@@ -1484,7 +1484,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n     {\n       rld[i].reg_rtx = find_dummy_reload (in, out, inloc, outloc,\n \t\t\t\t\t  inmode, outmode,\n-\t\t\t\t\t  rld[i].class, i,\n+\t\t\t\t\t  rld[i].rclass, i,\n \t\t\t\t\t  earlyclobber_operand_p (out));\n \n       /* If the outgoing register already contains the same value\n@@ -1730,8 +1730,8 @@ combine_reloads (void)\n \t&& rld[i].when_needed != RELOAD_FOR_OUTPUT_ADDRESS\n \t&& rld[i].when_needed != RELOAD_FOR_OUTADDR_ADDRESS\n \t&& rld[i].when_needed != RELOAD_OTHER\n-\t&& (CLASS_MAX_NREGS (rld[i].class, rld[i].inmode)\n-\t    == CLASS_MAX_NREGS (rld[output_reload].class,\n+\t&& (CLASS_MAX_NREGS (rld[i].rclass, rld[i].inmode)\n+\t    == CLASS_MAX_NREGS (rld[output_reload].rclass,\n \t\t\t\trld[output_reload].outmode))\n \t&& rld[i].inc == 0\n \t&& rld[i].reg_rtx == 0\n@@ -1744,11 +1744,11 @@ combine_reloads (void)\n \t\t\t    secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum]))\n #endif\n \t&& (SMALL_REGISTER_CLASSES\n-\t    ? (rld[i].class == rld[output_reload].class)\n-\t    : (reg_class_subset_p (rld[i].class,\n-\t\t\t\t   rld[output_reload].class)\n-\t       || reg_class_subset_p (rld[output_reload].class,\n-\t\t\t\t      rld[i].class)))\n+\t    ? (rld[i].rclass == rld[output_reload].rclass)\n+\t    : (reg_class_subset_p (rld[i].rclass,\n+\t\t\t\t   rld[output_reload].rclass)\n+\t       || reg_class_subset_p (rld[output_reload].rclass,\n+\t\t\t\t      rld[i].rclass)))\n \t&& (MATCHES (rld[i].in, rld[output_reload].out)\n \t    /* Args reversed because the first arg seems to be\n \t       the one that we imagine being modified\n@@ -1766,7 +1766,7 @@ combine_reloads (void)\n \t\t\t\t\t\t\t     rld[output_reload].out))))\n \t&& ! reload_inner_reg_of_subreg (rld[i].in, rld[i].inmode,\n \t\t\t\t\t rld[i].when_needed != RELOAD_FOR_INPUT)\n-\t&& (reg_class_size[(int) rld[i].class]\n+\t&& (reg_class_size[(int) rld[i].rclass]\n \t    || SMALL_REGISTER_CLASSES)\n \t/* We will allow making things slightly worse by combining an\n \t   input and an output, but no worse than that.  */\n@@ -1799,9 +1799,9 @@ combine_reloads (void)\n \t    = secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum];\n #endif\n \t/* If required, minimize the register class.  */\n-\tif (reg_class_subset_p (rld[output_reload].class,\n-\t\t\t\trld[i].class))\n-\t  rld[i].class = rld[output_reload].class;\n+\tif (reg_class_subset_p (rld[output_reload].rclass,\n+\t\t\t\trld[i].rclass))\n+\t  rld[i].rclass = rld[output_reload].rclass;\n \n \t/* Transfer all replacements from the old reload to the combined.  */\n \tfor (j = 0; j < n_replacements; j++)\n@@ -1835,18 +1835,18 @@ combine_reloads (void)\n \t\t\t\t\t\trld[output_reload].out)\n \t&& (regno = REGNO (XEXP (note, 0))) < FIRST_PSEUDO_REGISTER\n \t&& HARD_REGNO_MODE_OK (regno, rld[output_reload].outmode)\n-\t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].class],\n+\t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].rclass],\n \t\t\t      regno)\n \t&& (hard_regno_nregs[regno][rld[output_reload].outmode]\n \t    <= hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))])\n \t/* Ensure that a secondary or tertiary reload for this output\n \t   won't want this register.  */\n \t&& ((secondary_out = rld[output_reload].secondary_out_reload) == -1\n \t    || (!(TEST_HARD_REG_BIT\n-\t\t  (reg_class_contents[(int) rld[secondary_out].class], regno))\n+\t\t  (reg_class_contents[(int) rld[secondary_out].rclass], regno))\n \t\t&& ((secondary_out = rld[secondary_out].secondary_out_reload) == -1\n \t\t    || !(TEST_HARD_REG_BIT\n-\t\t\t (reg_class_contents[(int) rld[secondary_out].class],\n+\t\t\t (reg_class_contents[(int) rld[secondary_out].rclass],\n \t\t\t  regno)))))\n \t&& !fixed_regs[regno]\n \t/* Check that a former pseudo is valid; see find_dummy_reload.  */\n@@ -4184,7 +4184,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t&& rld[i].out == 0)\n       {\n \trld[i].reg_rtx\n-\t  = find_equiv_reg (rld[i].in, insn, rld[i].class, -1,\n+\t  = find_equiv_reg (rld[i].in, insn, rld[i].rclass, -1,\n \t\t\t    static_reload_reg_p, 0, rld[i].inmode);\n \t/* Prevent generation of insn to load the value\n \t   because the one we found already has the value.  */\n@@ -4453,7 +4453,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \tif (i != j && rld[j].in != 0 && rld[j].out == 0\n \t    && rld[j].when_needed == rld[i].when_needed\n \t    && MATCHES (rld[i].in, rld[j].in)\n-\t    && rld[i].class == rld[j].class\n+\t    && rld[i].rclass == rld[j].rclass\n \t    && !rld[i].nocombine && !rld[j].nocombine\n \t    && rld[i].reg_rtx == rld[j].reg_rtx)\n \t  {\n@@ -4482,7 +4482,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t       > GET_MODE_SIZE (rld[i].inmode)))\n \t  ? rld[i].outmode : rld[i].inmode;\n \n-      rld[i].nregs = CLASS_MAX_NREGS (rld[i].class, rld[i].mode);\n+      rld[i].nregs = CLASS_MAX_NREGS (rld[i].rclass, rld[i].mode);\n     }\n \n   /* Special case a simple move with an input reload and a\n@@ -4499,14 +4499,14 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \tunsigned int regno = REGNO (dest);\n \n \tif (regno < FIRST_PSEUDO_REGISTER\n-\t    && TEST_HARD_REG_BIT (reg_class_contents[rld[i].class], regno)\n+\t    && TEST_HARD_REG_BIT (reg_class_contents[rld[i].rclass], regno)\n \t    && HARD_REGNO_MODE_OK (regno, rld[i].mode))\n \t  {\n \t    int nr = hard_regno_nregs[regno][rld[i].mode];\n \t    int ok = 1, nri;\n \n \t    for (nri = 1; nri < nr; nri ++)\n-\t      if (! TEST_HARD_REG_BIT (reg_class_contents[rld[i].class], regno + nri))\n+\t      if (! TEST_HARD_REG_BIT (reg_class_contents[rld[i].rclass], regno + nri))\n \t\tok = 0;\n \n \t    if (ok)\n@@ -7262,7 +7262,7 @@ debug_reload_to_stream (FILE *f)\n \t  fprintf (f, \"\\n\\t\");\n \t}\n \n-      fprintf (f, \"%s, \", reg_class_names[(int) rld[r].class]);\n+      fprintf (f, \"%s, \", reg_class_names[(int) rld[r].rclass]);\n \n       fprintf (f, \"%s (opnum = %d)\",\n \t       reload_when_needed_name[(int) rld[r].when_needed],"}, {"sha": "3873f5c974678820cdf82e3b319d5cf16a7f55eb", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -83,7 +83,7 @@ struct reload\n   rtx out;\n \n   /* The class of registers to reload into.  */\n-  enum reg_class class;\n+  enum reg_class rclass;\n \n   /* The mode this operand should have when reloaded, on input.  */\n   enum machine_mode inmode;"}, {"sha": "f28b01c27142ce04c0633d424cda193ce715e0a8", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -1637,8 +1637,8 @@ reload_reg_class_lower (const void *r1p, const void *r2p)\n     return t;\n \n   /* Count all solitary classes before non-solitary ones.  */\n-  t = ((reg_class_size[(int) rld[r2].class] == 1)\n-       - (reg_class_size[(int) rld[r1].class] == 1));\n+  t = ((reg_class_size[(int) rld[r2].rclass] == 1)\n+       - (reg_class_size[(int) rld[r1].rclass] == 1));\n   if (t != 0)\n     return t;\n \n@@ -1648,7 +1648,7 @@ reload_reg_class_lower (const void *r1p, const void *r2p)\n     return t;\n \n   /* Consider reloads in order of increasing reg-class number.  */\n-  t = (int) rld[r1].class - (int) rld[r2].class;\n+  t = (int) rld[r1].rclass - (int) rld[r2].rclass;\n   if (t != 0)\n     return t;\n \n@@ -1777,7 +1777,7 @@ find_reg (struct insn_chain *chain, int order)\n \n   COPY_HARD_REG_SET (not_usable, bad_spill_regs);\n   IOR_HARD_REG_SET (not_usable, bad_spill_regs_global);\n-  IOR_COMPL_HARD_REG_SET (not_usable, reg_class_contents[rl->class]);\n+  IOR_COMPL_HARD_REG_SET (not_usable, reg_class_contents[rl->rclass]);\n \n   CLEAR_HARD_REG_SET (used_by_other_reload);\n   for (k = 0; k < order; k++)\n@@ -1918,7 +1918,7 @@ find_reload_regs (struct insn_chain *chain)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \"reload failure for reload %d\\n\", r);\n-\t    spill_failure (chain->insn, rld[r].class);\n+\t    spill_failure (chain->insn, rld[r].rclass);\n \t    failure = 1;\n \t    return;\n \t  }\n@@ -5474,7 +5474,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \n       for (count = 0; count < n_spills; count++)\n \t{\n-\t  int rclass = (int) rld[r].class;\n+\t  int rclass = (int) rld[r].rclass;\n \t  int regnum;\n \n \t  i++;\n@@ -5647,7 +5647,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t{\n \t  max_group_size = MAX (rld[j].nregs, max_group_size);\n \t  group_class\n-\t    = reg_class_superunion[(int) rld[j].class][(int) group_class];\n+\t    = reg_class_superunion[(int) rld[j].rclass][(int) group_class];\n \t}\n \n       save_reload_reg_rtx[j] = rld[j].reg_rtx;\n@@ -5793,7 +5793,7 @@ choose_reload_regs (struct insn_chain *chain)\n #endif\n \t\t  )\n \t\t{\n-\t\t  enum reg_class rclass = rld[r].class, last_class;\n+\t\t  enum reg_class rclass = rld[r].rclass, last_class;\n \t\t  rtx last_reg = reg_last_reload_reg[regno];\n \t\t  enum machine_mode need_mode;\n \n@@ -5857,7 +5857,7 @@ choose_reload_regs (struct insn_chain *chain)\n \n \t\t\t  bad_for_class = 0;\n \t\t\t  for (k = 0; k < nr; k++)\n-\t\t\t    bad_for_class |= ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class],\n+\t\t\t    bad_for_class |= ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].rclass],\n \t\t\t\t\t\t\t\t  i+k);\n \n \t\t\t  /* We found a register that contains the\n@@ -5939,7 +5939,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t  || REG_P (rld[r].in)\n \t\t  || MEM_P (rld[r].in))\n \t      && (rld[r].nregs == max_group_size\n-\t\t  || ! reg_classes_intersect_p (rld[r].class, group_class)))\n+\t\t  || ! reg_classes_intersect_p (rld[r].rclass, group_class)))\n \t    search_equiv = rld[r].in;\n \t  /* If this is an output reload from a simple move insn, look\n \t     if an equivalence for the input is available.  */\n@@ -5956,7 +5956,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t  if (search_equiv)\n \t    {\n \t      rtx equiv\n-\t\t= find_equiv_reg (search_equiv, insn, rld[r].class,\n+\t\t= find_equiv_reg (search_equiv, insn, rld[r].rclass,\n \t\t\t\t  -1, NULL, 0, rld[r].mode);\n \t      int regno = 0;\n \n@@ -5997,7 +5997,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t    {\n \t\t      regs_used |= TEST_HARD_REG_BIT (reload_reg_used_at_all,\n \t\t\t\t\t\t      i);\n-\t\t      bad_for_class |= ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class],\n+\t\t      bad_for_class |= ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].rclass],\n \t\t\t\t\t\t\t   i);\n \t\t    }\n \n@@ -6135,9 +6135,9 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t  || rld[s].optional)\n \t\tcontinue;\n \n-\t      if ((rld[s].class != rld[r].class\n-\t\t   && reg_classes_intersect_p (rld[r].class,\n-\t\t\t\t\t       rld[s].class))\n+\t      if ((rld[s].rclass != rld[r].rclass\n+\t\t   && reg_classes_intersect_p (rld[r].rclass,\n+\t\t\t\t\t       rld[s].rclass))\n \t\t  || rld[s].nregs < rld[r].nregs)\n \t\tbreak;\n \t    }\n@@ -6818,7 +6818,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \n \t  sri.icode = CODE_FOR_nothing;\n \t  sri.prev_sri = NULL;\n-\t  new_class = targetm.secondary_reload (1, real_oldequiv, rl->class,\n+\t  new_class = targetm.secondary_reload (1, real_oldequiv, rl->rclass,\n \t\t\t\t\t\tmode, &sri);\n \n \t  if (new_class == NO_REGS && sri.icode == CODE_FOR_nothing)\n@@ -7008,7 +7008,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t  && reg_equiv_mem[REGNO (old)] != 0)\n \treal_old = reg_equiv_mem[REGNO (old)];\n \n-      if (secondary_reload_class (0, rl->class, mode, real_old) != NO_REGS)\n+      if (secondary_reload_class (0, rl->rclass, mode, real_old) != NO_REGS)\n \t{\n \t  rtx second_reloadreg = reloadreg;\n \t  reloadreg = rld[secondary_reload].reg_rtx;"}, {"sha": "4064ad47411aa2ca34ab059b6e47a796f2ead836", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -581,7 +581,7 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \t\t\t  enum machine_mode reload_mode ATTRIBUTE_UNUSED,\n \t\t\t  secondary_reload_info *sri)\n {\n-  enum reg_class class = NO_REGS;\n+  enum reg_class rclass = NO_REGS;\n \n   if (sri->prev_sri && sri->prev_sri->t_icode != CODE_FOR_nothing)\n     {\n@@ -590,13 +590,13 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n     }\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n   if (in_p)\n-    class = SECONDARY_INPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n+    rclass = SECONDARY_INPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n #endif\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n   if (! in_p)\n-    class = SECONDARY_OUTPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n+    rclass = SECONDARY_OUTPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n #endif\n-  if (class != NO_REGS)\n+  if (rclass != NO_REGS)\n     {\n       enum insn_code icode = (in_p ? reload_in_optab[(int) reload_mode]\n \t\t\t      : reload_out_optab[(int) reload_mode]);\n@@ -648,19 +648,19 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \n \t  if (reg_class_subset_p (reload_class, insn_class))\n \t    {\n-\t      gcc_assert (scratch_class == class);\n-\t      class = NO_REGS;\n+\t      gcc_assert (scratch_class == rclass);\n+\t      rclass = NO_REGS;\n \t    }\n \t  else\n-\t    class = insn_class;\n+\t    rclass = insn_class;\n \n         }\n-      if (class == NO_REGS)\n+      if (rclass == NO_REGS)\n \tsri->icode = icode;\n       else\n \tsri->t_icode = icode;\n     }\n-  return class;\n+  return rclass;\n }\n \n bool"}, {"sha": "ad2421298ba87d5c13d5592ead5d0c81e1001e7c", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c5422943175e257c75cd80ccc78ba63f76a3ea/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=48c5422943175e257c75cd80ccc78ba63f76a3ea", "patch": "@@ -470,9 +470,9 @@ static int\n section_entry_eq (const void *p1, const void *p2)\n {\n   const section *old = (const section *) p1;\n-  const char *new = (const char *) p2;\n+  const char *new_name = (const char *) p2;\n \n-  return strcmp (old->named.name, new) == 0;\n+  return strcmp (old->named.name, new_name) == 0;\n }\n \n static hashval_t\n@@ -498,9 +498,9 @@ static int\n object_block_entry_eq (const void *p1, const void *p2)\n {\n   const struct object_block *old = (const struct object_block *) p1;\n-  const section *new = (const section *) p2;\n+  const section *new_section = (const section *) p2;\n \n-  return old->sect == new;\n+  return old->sect == new_section;\n }\n \n static hashval_t"}]}