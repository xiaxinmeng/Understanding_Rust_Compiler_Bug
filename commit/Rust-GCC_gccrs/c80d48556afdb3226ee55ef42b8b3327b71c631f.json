{"sha": "c80d48556afdb3226ee55ef42b8b3327b71c631f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwZDQ4NTU2YWZkYjMyMjZlZTU1ZWY0MmI4YjMzMjdiNzFjNjMxZg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:27:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:27:58Z"}, "message": "g-spchge.ads, [...]: New files.\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\n\t* g-spchge.ads, g-spchge.adb, g-u3spch.adb, g-u3spch.ads,\n\tg-wispch.adb, g-wispch.ads, g-zspche.adb, g-zspche.ads,\n\tnamet-sp.adb, namet-sp.ads: New files.\n\n\t* g-speche.adb: Use generic routine in g-spchge\n\n\t* s-wchcnv.ads, s-wchcnv.adb: \n\tMinor code cleanup (make formal type consistent with spec)\n\n\t* namet.adb: Update comments.\n\n\t* par-endh.adb (Evaluate_End_Entry): Use new\n\tNamet.Sp.Is_Bad_Spelling_Of function\n\n\t* par-load.adb (Load): Use new Namet.Sp.Is_Bad_Spelling_Of function\n\n\t* sem_aggr.adb (Resolve_Record_Aggregate): If a component of an\n\tancestor is an access type initialized with a box, set its type\n\texplicitly, for use in subsequent expansion.\n\t(Check_Misspelled_Component): Use new Namet.Sp.Is_Bad_Spelling_Of\n\tfunction\n\nFrom-SVN: r130843", "tree": {"sha": "507d79df94d7670b6e5e13cfbfac98aa4c16fd86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/507d79df94d7670b6e5e13cfbfac98aa4c16fd86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c80d48556afdb3226ee55ef42b8b3327b71c631f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80d48556afdb3226ee55ef42b8b3327b71c631f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c80d48556afdb3226ee55ef42b8b3327b71c631f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80d48556afdb3226ee55ef42b8b3327b71c631f/comments", "author": null, "committer": null, "parents": [{"sha": "1fdc61b5655590ecc6352866204174c093589df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fdc61b5655590ecc6352866204174c093589df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fdc61b5655590ecc6352866204174c093589df3"}], "stats": {"total": 1078, "additions": 888, "deletions": 190}, "files": [{"sha": "2e4c7c786fbecdd3ef7e65a13142b463a0065d9a", "filename": "gcc/ada/g-spchge.adb", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-spchge.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-spchge.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spchge.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,165 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          G N A T . S P E L L I N G _ C H E C K E R _ G E N E R I C       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Warnings (Off);\n+pragma Compiler_Unit;\n+pragma Warnings (On);\n+\n+package body GNAT.Spelling_Checker_Generic is\n+\n+   ------------------------\n+   -- Is_Bad_Spelling_Of --\n+   ------------------------\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : String_Type;\n+      Expect : String_Type) return Boolean\n+   is\n+      FN : constant Natural := Found'Length;\n+      FF : constant Natural := Found'First;\n+      FL : constant Natural := Found'Last;\n+\n+      EN : constant Natural := Expect'Length;\n+      EF : constant Natural := Expect'First;\n+      EL : constant Natural := Expect'Last;\n+\n+      Letter_o : constant Char_Type := Char_Type'Val (Character'Pos ('o'));\n+      Digit_0  : constant Char_Type := Char_Type'Val (Character'Pos ('0'));\n+      Digit_9  : constant Char_Type := Char_Type'Val (Character'Pos ('9'));\n+\n+   begin\n+      --  If both strings null, then we consider this a match, but if one\n+      --  is null and the other is not, then we definitely do not match\n+\n+      if FN = 0 then\n+         return (EN = 0);\n+\n+      elsif EN = 0 then\n+         return False;\n+\n+         --  If first character does not match, then we consider that this is\n+         --  definitely not a misspelling. An exception is when we expect a\n+         --  letter O and found a zero.\n+\n+      elsif Found (FF) /= Expect (EF)\n+        and then (Found (FF) /= Digit_0 or else Expect (EF) /= Letter_o)\n+      then\n+         return False;\n+\n+      --  Not a bad spelling if both strings are 1-2 characters long\n+\n+      elsif FN < 3 and then EN < 3 then\n+         return False;\n+\n+      --  Lengths match. Execute loop to check for a single error, single\n+      --  transposition or exact match (we only fall through this loop if\n+      --  one of these three conditions is found).\n+\n+      elsif FN = EN then\n+         for J in 1 .. FN - 2 loop\n+            if Expect (EF + J) /= Found (FF + J) then\n+\n+               --  If both mismatched characters are digits, then we do\n+               --  not consider it a misspelling (e.g. B345 is not a\n+               --  misspelling of B346, it is something quite different)\n+\n+               if Expect (EF + J) in Digit_0 .. Digit_9\n+                 and then Found (FF + J) in Digit_0 .. Digit_9\n+               then\n+                  return False;\n+\n+               elsif Expect (EF + J + 1) = Found (FF + J + 1)\n+                 and then Expect (EF + J + 2 .. EL) = Found (FF + J + 2 .. FL)\n+               then\n+                  return True;\n+\n+               elsif Expect (EF + J) = Found (FF + J + 1)\n+                 and then Expect (EF + J + 1) = Found (FF + J)\n+                 and then Expect (EF + J + 2 .. EL) = Found (FF + J + 2 .. FL)\n+               then\n+                  return True;\n+\n+               else\n+                  return False;\n+               end if;\n+            end if;\n+         end loop;\n+\n+         --  At last character. Test digit case as above, otherwise we\n+         --  have a match since at most this last character fails to match.\n+\n+         if Expect (EL) in Digit_0 .. Digit_9\n+           and then Found (FL) in Digit_0 .. Digit_9\n+           and then Expect (EL) /= Found (FL)\n+         then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+\n+      --  Length is 1 too short. Execute loop to check for single deletion\n+\n+      elsif FN = EN - 1 then\n+         for J in 1 .. FN - 1 loop\n+            if Found (FF + J) /= Expect (EF + J) then\n+               return Found (FF + J .. FL) = Expect (EF + J + 1 .. EL);\n+            end if;\n+         end loop;\n+\n+         --  If we fall through then the last character was missing, which\n+         --  we consider to be a match (e.g. found xyz, expected xyza).\n+\n+         return True;\n+\n+      --  Length is 1 too long. Execute loop to check for single insertion\n+\n+      elsif FN = EN + 1 then\n+         for J in 1 .. EN - 1 loop\n+            if Found (FF + J) /= Expect (EF + J) then\n+               return Found (FF + J + 1 .. FL) = Expect (EF + J .. EL);\n+            end if;\n+         end loop;\n+\n+         --  If we fall through then the last character was an additional\n+         --  character, which is a match (e.g. found xyza, expected xyz).\n+\n+         return True;\n+\n+      --  Length is completely wrong\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Bad_Spelling_Of;\n+\n+end GNAT.Spelling_Checker_Generic;"}, {"sha": "0a29c589a214d12ec32af7c5b879d4bcdb189d39", "filename": "gcc/ada/g-spchge.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-spchge.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-spchge.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spchge.ads?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          G N A T . S P E L L I N G _ C H E C K E R _ G E N E R I C       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Spelling checker\n+\n+--  This package provides a utility generic routine for checking for bad\n+--  spellings. This routine must be instantiated with an appropriate array\n+--  element type, which must represent a character encoding in which the\n+--  codes for ASCII characters in the range 16#20#..16#7F# have their normal\n+--  expected encoding values (e.g. the Pos value 16#31# must be digit 1).\n+\n+pragma Warnings (Off);\n+pragma Compiler_Unit;\n+pragma Warnings (On);\n+\n+package GNAT.Spelling_Checker_Generic is\n+   pragma Pure;\n+\n+   generic\n+      type Char_Type is (<>);\n+      --  See above for restrictions on what types can be used here\n+\n+      type String_Type is array (Positive range <>) of Char_Type;\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : String_Type;\n+      Expect : String_Type) return Boolean;\n+   --  Determines if the string Found is a plausible misspelling of the string\n+   --  Expect. Returns True for an exact match or a probably misspelling, False\n+   --  if no near match is detected. This routine is case sensitive, so the\n+   --  caller should fold both strings to get a case insensitive match if the\n+   --  character encoding represents upper/lower case.\n+   --\n+   --  Note: the spec of this routine is deliberately rather vague. This\n+   --  routine is the one used by GNAT itself to detect misspelled keywords\n+   --  and identifiers, and is heuristically adjusted to be appropriate to\n+   --  this usage. It will work well in any similar case of named entities.\n+\n+end GNAT.Spelling_Checker_Generic;"}, {"sha": "841eef8ddfe25ec5c6dcb63c0cfa0a91c069a314", "filename": "gcc/ada/g-speche.adb", "status": "modified", "additions": 7, "deletions": 114, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-speche.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-speche.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-speche.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -35,128 +35,21 @@ pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);\n \n+with GNAT.Spelling_Checker_Generic;\n+\n package body GNAT.Spelling_Checker is\n \n+   function IBS is new\n+     GNAT.Spelling_Checker_Generic.Is_Bad_Spelling_Of\n+       (Character, String);\n+\n    ------------------------\n    -- Is_Bad_Spelling_Of --\n    ------------------------\n \n    function Is_Bad_Spelling_Of\n      (Found  : String;\n       Expect : String) return Boolean\n-   is\n-      FN : constant Natural := Found'Length;\n-      FF : constant Natural := Found'First;\n-      FL : constant Natural := Found'Last;\n-\n-      EN : constant Natural := Expect'Length;\n-      EF : constant Natural := Expect'First;\n-      EL : constant Natural := Expect'Last;\n-\n-   begin\n-      --  If both strings null, then we consider this a match, but if one\n-      --  is null and the other is not, then we definitely do not match\n-\n-      if FN = 0 then\n-         return (EN = 0);\n-\n-      elsif EN = 0 then\n-         return False;\n-\n-         --  If first character does not match, then we consider that this is\n-         --  definitely not a misspelling. An exception is when we expect a\n-         --  letter O and found a zero.\n-\n-      elsif Found (FF) /= Expect (EF)\n-        and then (Found (FF) /= '0'\n-                    or else (Expect (EF) /= 'o' and then Expect (EF) /= 'O'))\n-      then\n-         return False;\n-\n-      --  Not a bad spelling if both strings are 1-2 characters long\n-\n-      elsif FN < 3 and then EN < 3 then\n-         return False;\n-\n-      --  Lengths match. Execute loop to check for a single error, single\n-      --  transposition or exact match (we only fall through this loop if\n-      --  one of these three conditions is found).\n-\n-      elsif FN = EN then\n-         for J in 1 .. FN - 2 loop\n-            if Expect (EF + J) /= Found (FF + J) then\n-\n-               --  If both mismatched characters are digits, then we do\n-               --  not consider it a misspelling (e.g. B345 is not a\n-               --  misspelling of B346, it is something quite different)\n-\n-               if Expect (EF + J) in '0' .. '9'\n-                 and then Found (FF + J) in '0' .. '9'\n-               then\n-                  return False;\n-\n-               elsif Expect (EF + J + 1) = Found (FF + J + 1)\n-                 and then Expect (EF + J + 2 .. EL) = Found (FF + J + 2 .. FL)\n-               then\n-                  return True;\n-\n-               elsif Expect (EF + J) = Found (FF + J + 1)\n-                 and then Expect (EF + J + 1) = Found (FF + J)\n-                 and then Expect (EF + J + 2 .. EL) = Found (FF + J + 2 .. FL)\n-               then\n-                  return True;\n-\n-               else\n-                  return False;\n-               end if;\n-            end if;\n-         end loop;\n-\n-         --  At last character. Test digit case as above, otherwise we\n-         --  have a match since at most this last character fails to match.\n-\n-         if Expect (EL) in '0' .. '9'\n-           and then Found (FL) in '0' .. '9'\n-           and then Expect (EL) /= Found (FL)\n-         then\n-            return False;\n-         else\n-            return True;\n-         end if;\n-\n-      --  Length is 1 too short. Execute loop to check for single deletion\n-\n-      elsif FN = EN - 1 then\n-         for J in 1 .. FN - 1 loop\n-            if Found (FF + J) /= Expect (EF + J) then\n-               return Found (FF + J .. FL) = Expect (EF + J + 1 .. EL);\n-            end if;\n-         end loop;\n-\n-         --  If we fall through then the last character was missing, which\n-         --  we consider to be a match (e.g. found xyz, expected xyza).\n-\n-         return True;\n-\n-      --  Length is 1 too long. Execute loop to check for single insertion\n-\n-      elsif FN = EN + 1 then\n-         for J in 1 .. EN - 1 loop\n-            if Found (FF + J) /= Expect (EF + J) then\n-               return Found (FF + J + 1 .. FL) = Expect (EF + J .. EL);\n-            end if;\n-         end loop;\n-\n-         --  If we fall through then the last character was an additional\n-         --  character, which is a match (e.g. found xyza, expected xyz).\n-\n-         return True;\n-\n-      --  Length is completely wrong\n-\n-      else\n-         return False;\n-      end if;\n-   end Is_Bad_Spelling_Of;\n+   renames IBS;\n \n end GNAT.Spelling_Checker;"}, {"sha": "3e7ede843f259e4b7c51f093e83dc822fd10689d", "filename": "gcc/ada/g-u3spch.adb", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-u3spch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-u3spch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-u3spch.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          G N A T . U T F _ 3 2 _ S P E L L I N G _ C H E C K E R         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Warnings (Off);\n+pragma Compiler_Unit;\n+pragma Warnings (On);\n+\n+with GNAT.Spelling_Checker_Generic;\n+\n+package body GNAT.UTF_32_Spelling_Checker is\n+\n+   function IBS is new\n+     GNAT.Spelling_Checker_Generic.Is_Bad_Spelling_Of\n+       (System.WCh_Cnv.UTF_32_Code, System.WCh_Cnv.UTF_32_String);\n+\n+   ------------------------\n+   -- Is_Bad_Spelling_Of --\n+   ------------------------\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : System.WCh_Cnv.UTF_32_String;\n+      Expect : System.WCh_Cnv.UTF_32_String) return Boolean\n+   renames IBS;\n+\n+end GNAT.UTF_32_Spelling_Checker;"}, {"sha": "90ab66d978f7a9936ed2d477f2ae2515ead925ee", "filename": "gcc/ada/g-u3spch.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-u3spch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-u3spch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-u3spch.ads?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          G N A T . U T F _ 3 2 _ S P E L L I N G _ C H E C K E R         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Spelling checker\n+\n+--  This package provides a utility routine for checking for bad spellings\n+--  for the case of System.WCh_Cnv.UTF_32_String arguments.\n+\n+pragma Warnings (Off);\n+pragma Compiler_Unit;\n+pragma Warnings (On);\n+\n+with System.WCh_Cnv;\n+\n+package GNAT.UTF_32_Spelling_Checker is\n+   pragma Pure;\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : System.WCh_Cnv.UTF_32_String;\n+      Expect : System.WCh_Cnv.UTF_32_String) return Boolean;\n+   --  Determines if the string Found is a plausible misspelling of the string\n+   --  Expect. Returns True for an exact match or a probably misspelling, False\n+   --  if no near match is detected. This routine is case sensitive, so the\n+   --  caller should fold both strings to get a case insensitive match.\n+   --\n+   --  Note: the spec of this routine is deliberately rather vague. It is used\n+   --  by GNAT itself to detect misspelled keywords and identifiers, and is\n+   --  heuristically adjusted to be appropriate to this usage. It will work\n+   --  well in any similar case of named entities.\n+\n+end GNAT.UTF_32_Spelling_Checker;"}, {"sha": "0fc0ff6f22734ed80385f0732705740025db7a6e", "filename": "gcc/ada/g-wispch.adb", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-wispch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-wispch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-wispch.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . W I D E _ S P E L L I N G _ C H E C K E R           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.Spelling_Checker_Generic;\n+\n+package body GNAT.Wide_Spelling_Checker is\n+\n+   function IBS is new\n+     GNAT.Spelling_Checker_Generic.Is_Bad_Spelling_Of\n+       (Wide_Character, Wide_String);\n+\n+   ------------------------\n+   -- Is_Bad_Spelling_Of --\n+   ------------------------\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : Wide_String;\n+      Expect : Wide_String) return Boolean\n+   renames IBS;\n+\n+end GNAT.Wide_Spelling_Checker;"}, {"sha": "09c57ed41c876ae476e80578aeef9291b133e452", "filename": "gcc/ada/g-wispch.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-wispch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-wispch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-wispch.ads?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . W I D E _ S P E L L I N G _ C H E C K E R           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Spelling checker\n+\n+--  This package provides a utility routine for checking for bad spellings\n+--  for the case of Wide_String arguments.\n+\n+package GNAT.Wide_Spelling_Checker is\n+   pragma Pure;\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : Wide_String;\n+      Expect : Wide_String) return Boolean;\n+   --  Determines if the string Found is a plausible misspelling of the string\n+   --  Expect. Returns True for an exact match or a probably misspelling, False\n+   --  if no near match is detected. This routine is case sensitive, so the\n+   --  caller should fold both strings to get a case insensitive match.\n+   --\n+   --  Note: the spec of this routine is deliberately rather vague. It is used\n+   --  by GNAT itself to detect misspelled keywords and identifiers, and is\n+   --  heuristically adjusted to be appropriate to this usage. It will work\n+   --  well in any similar case of named entities.\n+\n+end GNAT.Wide_Spelling_Checker;"}, {"sha": "1b7b3ff29d8d77a06e61495834305e097b8f61f1", "filename": "gcc/ada/g-zspche.adb", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-zspche.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-zspche.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-zspche.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--       G N A T . W I D E _W I D E _ S P E L L I N G _ C H E C K E R       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.Spelling_Checker_Generic;\n+\n+package body GNAT.Wide_Wide_Spelling_Checker is\n+\n+   function IBS is new\n+     GNAT.Spelling_Checker_Generic.Is_Bad_Spelling_Of\n+       (Wide_Wide_Character, Wide_Wide_String);\n+\n+   ------------------------\n+   -- Is_Bad_Spelling_Of --\n+   ------------------------\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : Wide_Wide_String;\n+      Expect : Wide_Wide_String) return Boolean\n+   renames IBS;\n+\n+end GNAT.Wide_Wide_Spelling_Checker;"}, {"sha": "217eab6f5283b640cfe56a4099349ebf1363f2d4", "filename": "gcc/ada/g-zspche.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-zspche.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fg-zspche.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-zspche.ads?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--       G N A T . W I D E _ W I D E _ S P E L L I N G _ C H E C K E R      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1998-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Spelling checker\n+\n+--  This package provides a utility routine for checking for bad spellings\n+--  for the case of Wide_Wide_String arguments.\n+\n+package GNAT.Wide_Wide_Spelling_Checker is\n+   pragma Pure;\n+\n+   function Is_Bad_Spelling_Of\n+     (Found  : Wide_Wide_String;\n+      Expect : Wide_Wide_String) return Boolean;\n+   --  Determines if the string Found is a plausible misspelling of the string\n+   --  Expect. Returns True for an exact match or a probably misspelling, False\n+   --  if no near match is detected. This routine is case sensitive, so the\n+   --  caller should fold both strings to get a case insensitive match.\n+   --\n+   --  Note: the spec of this routine is deliberately rather vague. It is used\n+   --  by GNAT itself to detect misspelled keywords and identifiers, and is\n+   --  heuristically adjusted to be appropriate to this usage. It will work\n+   --  well in any similar case of named entities.\n+\n+end GNAT.Wide_Wide_Spelling_Checker;"}, {"sha": "fd19d4991c5cc3fdf8a9aff6f9bfe8c3a7d309bb", "filename": "gcc/ada/namet-sp.adb", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fnamet-sp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fnamet-sp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet-sp.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,196 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             N A M E T . S P                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2007, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.WCh_Cnv; use System.WCh_Cnv;\n+\n+with GNAT.UTF_32_Spelling_Checker;\n+\n+package body Namet.Sp is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Get_Name_String_UTF_32\n+     (Id     : Name_Id;\n+      Result : out UTF_32_String;\n+      Length : out Natural);\n+   --  This procedure is similar to Get_Decoded_Name except that the output\n+   --  is stored in the given Result array as single codes, so in particular\n+   --  any Uhh, Whhhh, or WWhhhhhhhh sequences are decoded to appear as a\n+   --  single value in the output. This call does not affect the contents of\n+   --  either Name_Buffer or Name_Len. The result is in Result (1 .. Length).\n+   --  The caller must ensure that the result buffer is long enough.\n+\n+   ----------------------------\n+   -- Get_Name_String_UTF_32 --\n+   ----------------------------\n+\n+   procedure Get_Name_String_UTF_32\n+     (Id     : Name_Id;\n+      Result : out UTF_32_String;\n+      Length : out Natural)\n+   is\n+      pragma Assert (Result'First = 1);\n+\n+      SPtr : Int := Name_Entries.Table (Id).Name_Chars_Index + 1;\n+      --  Index through characters of name in Name_Chars table. Initial value\n+      --  points to first character of the name.\n+\n+      SLen : constant Nat := Nat (Name_Entries.Table (Id).Name_Len);\n+      --  Length of the name\n+\n+      SLast : constant Int := SPtr + SLen - 1;\n+      --  Last index in Name_Chars table for name\n+\n+      C : Character;\n+      --  Current character from Name_Chars table\n+\n+      procedure Store_Hex (N : Natural);\n+      --  Read and store next N characters starting at SPtr and store result\n+      --  in next character of Result. Update SPtr past characters read.\n+\n+      ---------------\n+      -- Store_Hex --\n+      ---------------\n+\n+      procedure Store_Hex (N : Natural) is\n+         T : UTF_32_Code;\n+         C : Character;\n+\n+      begin\n+         T := 0;\n+         for J in 1 .. N loop\n+            C := Name_Chars.Table (SPtr);\n+            SPtr := SPtr + 1;\n+\n+            if C in '0' .. '9' then\n+               T := 16 * T + Character'Pos (C) - Character'Pos ('0');\n+            else\n+               pragma Assert (C in 'a' .. 'f');\n+\n+               T := 16 * T + Character'Pos (C) - (Character'Pos ('a') - 10);\n+            end if;\n+         end loop;\n+\n+         Length := Length + 1;\n+         pragma Assert (Length <= Result'Length);\n+         Result (Length) := T;\n+      end Store_Hex;\n+\n+   --  Start of processing for Get_Name_String_UTF_32\n+\n+   begin\n+      Length := 0;\n+      while SPtr <= SLast loop\n+         C := Name_Chars.Table (SPtr);\n+\n+         --  Uhh encoding\n+\n+         if C = 'U'\n+           and then SPtr <= SLast - 2\n+           and then Name_Chars.Table (SPtr + 1) not in 'A' .. 'Z'\n+         then\n+            SPtr := SPtr + 1;\n+            Store_Hex (2);\n+\n+         --  Whhhh encoding\n+\n+         elsif C = 'W'\n+           and then SPtr <= SLast - 4\n+           and then Name_Chars.Table (SPtr + 1) not in 'A' .. 'Z'\n+         then\n+            SPtr := SPtr + 1;\n+            Store_Hex (4);\n+\n+         --  WWhhhhhhhh encoding\n+\n+         elsif C = 'W'\n+           and then SPtr <= SLast - 8\n+           and then Name_Chars.Table (SPtr + 1) = 'W'\n+         then\n+            SPtr := SPtr + 2;\n+            Store_Hex (8);\n+\n+         --  Q encoding (character literal)\n+\n+         elsif C = 'Q' and then SPtr < SLast then\n+\n+            --  Put apostrophes around character\n+\n+            pragma Assert (Length <= Result'Last - 3);\n+            Result (Length + 1) := UTF_32_Code'Val (Character'Pos ('''));\n+            Result (Length + 2) :=\n+              UTF_32_Code (Get_Char_Code (Name_Chars.Table (SPtr + 1)));\n+            Result (Length + 3) := UTF_32_Code'Val (Character'Pos ('''));\n+            SPtr := SPtr + 2;\n+            Length := Length + 3;\n+\n+         --  Unencoded case\n+\n+         else\n+            SPtr := SPtr + 1;\n+            Length := Length + 1;\n+            pragma Assert (Length <= Result'Last);\n+            Result (Length) := UTF_32_Code (Get_Char_Code (C));\n+         end if;\n+      end loop;\n+   end Get_Name_String_UTF_32;\n+\n+   ------------------------\n+   -- Is_Bad_Spelling_Of --\n+   ------------------------\n+\n+   function Is_Bad_Spelling_Of (Found, Expect : Name_Id) return Boolean is\n+      FL : constant Natural := Natural (Length_Of_Name (Found));\n+      EL : constant Natural := Natural (Length_Of_Name (Expect));\n+      --  Length of input names\n+\n+      FB : UTF_32_String (1 .. 2 * FL);\n+      EB : UTF_32_String (1 .. 2 * EL);\n+      --  Buffers for results, a factor of 2 is more than enough, the only\n+      --  sequence which expands is Q (character literal) by 1.5 times.\n+\n+      FBL : Natural;\n+      EBL : Natural;\n+      --  Length of decoded names\n+\n+   begin\n+      Get_Name_String_UTF_32 (Found, FB, FBL);\n+      Get_Name_String_UTF_32 (Expect, EB, EBL);\n+      return\n+        GNAT.UTF_32_Spelling_Checker.Is_Bad_Spelling_Of\n+          (FB (1 .. FBL), EB (1 .. EBL));\n+   end Is_Bad_Spelling_Of;\n+\n+end Namet.Sp;"}, {"sha": "014c9357d18cdcecea8643b956029098d68cdd95", "filename": "gcc/ada/namet-sp.ads", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fnamet-sp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fnamet-sp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet-sp.ads?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             N A M E T - S P                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This child package contains a spell checker for Name_Id values. It is\n+--  separated off as a child package, because of the extra dependencies,\n+--  in particular on GNAT.UTF_32_ Spelling_Checker. There are a number of\n+--  packages that use Namet that do not need the spell checking feature,\n+--  and this separation helps in dealing with older versions of GNAT.\n+\n+package Namet.Sp is\n+\n+   function Is_Bad_Spelling_Of (Found, Expect : Name_Id) return Boolean;\n+   --  Compares two identifier names from the names table, and returns True if\n+   --  Found is a plausible misspelling of Expect. This function properly deals\n+   --  with wide and wide wide character encodings in the input names.\n+\n+end Namet.Sp;"}, {"sha": "7d5c28b745d7ff0b7c2f6a227ba74b28d2ec3c16", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -32,7 +32,7 @@\n ------------------------------------------------------------------------------\n \n --  WARNING: There is a C version of this package. Any changes to this\n---  source file must be properly reflected in the C header file a-namet.h\n+--  source file must be properly reflected in the C header file namet.h\n --  which is created manually from namet.ads and namet.adb.\n \n with Debug;    use Debug;\n@@ -444,7 +444,7 @@ package body Namet is\n \n                   --  Search the map. Note that this loop must terminate, if\n                   --  not we have some kind of internal error, and a constraint\n-                  --  constraint error may be raised.\n+                  --  error may be raised.\n \n                   J := Map'First;\n                   loop"}, {"sha": "59fa37fc73aa585fa28ff75f81bf93bc9b058d49", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -23,8 +23,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Stringt; use Stringt;\n-with Uintp;   use Uintp;\n+with Namet.Sp; use Namet.Sp;\n+with Stringt;  use Stringt;\n+with Uintp;    use Uintp;\n \n with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n \n@@ -711,25 +712,15 @@ package body Endh is\n               and then Chars (End_Labl) > Error_Name\n               and then Chars (Nam) > Error_Name\n             then\n-               Get_Name_String (Chars (End_Labl));\n                Error_Msg_Name_1 := Chars (Nam);\n \n                if Error_Msg_Name_1 > Error_Name then\n-                  declare\n-                     S : constant String (1 .. Name_Len) :=\n-                           Name_Buffer (1 .. Name_Len);\n-\n-                  begin\n-                     Get_Name_String (Error_Msg_Name_1);\n-\n-                     if Is_Bad_Spelling_Of\n-                         (Name_Buffer (1 .. Name_Len), S)\n-                     then\n-                        Error_Msg_N (\"misspelling of %\", End_Labl);\n-                        Syntax_OK := True;\n-                        return;\n-                     end if;\n-                  end;\n+                  if Is_Bad_Spelling_Of (Chars (Nam), Chars (End_Labl)) then\n+                     Error_Msg_Name_1 := Chars (Nam);\n+                     Error_Msg_N (\"misspelling of %\", End_Labl);\n+                     Syntax_OK := True;\n+                     return;\n+                  end if;\n                end if;\n             end if;\n          end;"}, {"sha": "4f77f7d32b9d12836518b16989d87aca51bd1aa6", "filename": "gcc/ada/par-load.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -31,6 +31,7 @@\n \n with Fname.UF; use Fname.UF;\n with Lib.Load; use Lib.Load;\n+with Namet.Sp; use Namet.Sp;\n with Uname;    use Uname;\n with Osint;    use Osint;\n with Sinput.L; use Sinput.L;\n@@ -225,8 +226,7 @@ begin\n             --  unit name is indeed a plausible misspelling of the one we got.\n \n             if Is_Bad_Spelling_Of\n-              (Found  => Get_Name_String (Expect_Name),\n-               Expect => Get_Name_String (Actual_Name))\n+              (Name_Id (Expect_Name), Name_Id (Actual_Name))\n             then\n                Error_Msg_Unit_1 := Actual_Name;\n                Error_Msg (\"possible misspelling of $$!\", Loc);"}, {"sha": "3e877aaec984699d647bbde545db07aca52f8258", "filename": "gcc/ada/s-wchcnv.adb", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fs-wchcnv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fs-wchcnv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcnv.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -47,7 +47,7 @@ package body System.WCh_Cnv is\n \n    function Char_Sequence_To_UTF_32\n      (C  : Character;\n-      EM : WC_Encoding_Method) return UTF_32_Code\n+      EM : System.WCh_Con.WC_Encoding_Method) return UTF_32_Code\n    is\n       B1 : Unsigned_32;\n       C1 : Character;\n@@ -94,7 +94,7 @@ package body System.WCh_Cnv is\n             raise Constraint_Error;\n          end if;\n \n-         W := Shift_Left (W, 6)  or (U and 2#00111111#);\n+         W := Shift_Left (W, 6) or (U and 2#00111111#);\n       end Get_UTF_Byte;\n \n    --  Start of processing for Char_Sequence_To_Wide\n@@ -151,15 +151,8 @@ package body System.WCh_Cnv is\n             --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n \n             elsif (U and 2#11100000#) = 2#110_00000# then\n-               W := Shift_Left (U and 2#00011111#, 6);\n-               U := Unsigned_32 (Character'Pos (In_Char));\n-\n-               if (U and 2#11000000#) /= 2#10_000000# then\n-                  raise Constraint_Error;\n-               end if;\n-\n-               W := W or (U and 2#00111111#);\n-\n+               W := U and 2#00011111#;\n+               Get_UTF_Byte;\n                return UTF_32_Code (W);\n \n             --  16#00_0800#-16#00_ffff#: 1110xxxx 10xxxxxx 10xxxxxx\n@@ -210,7 +203,6 @@ package body System.WCh_Cnv is\n             end if;\n \n          when WCEM_Brackets =>\n-\n             if C /= '[' then\n                return Character'Pos (C);\n             end if;"}, {"sha": "3679b881a567d6497f70d985ab035fe94ad583a9", "filename": "gcc/ada/s-wchcnv.ads", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fs-wchcnv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fs-wchcnv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcnv.ads?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -32,8 +32,15 @@\n ------------------------------------------------------------------------------\n \n --  This package contains generic subprograms used for converting between\n---  sequences of Character and Wide_Character. All access to wide character\n---  sequences is isolated in this unit.\n+--  sequences of Character and Wide_Character. Wide_Wide_Character values\n+--  are also handled, but represented using integer range types defined in\n+--  this package, so that this package can be used from applications that\n+--  are restricted to Ada 95 compatibility (such as the compiler itself).\n+\n+--  All the algorithms for encoding and decoding are isolated in this package\n+--  and in System.WCh_JIS and should not be duplicated elsewhere. The only\n+--  exception to this is that GNAT.Decode_String and GNAT.Encode_String have\n+--  their own circuits for UTF-8 conversions, for improved efficiency.\n \n --  This unit may be used directly from an application program by providing\n --  an appropriate WITH, and the interface can be expected to remain stable.\n@@ -51,6 +58,8 @@ package System.WCh_Cnv is\n    for UTF_32_Code'Size use 32;\n    --  Range of allowed UTF-32 encoding values\n \n+   type UTF_32_String is array (Positive range <>) of UTF_32_Code;\n+\n    generic\n       with function In_Char return Character;\n    function Char_Sequence_To_Wide_Char\n@@ -62,6 +71,16 @@ package System.WCh_Cnv is\n    --  corresponding wide character value. Constraint_Error is raised if the\n    --  sequence of characters encountered is not a valid wide character\n    --  sequence for the given encoding method.\n+   --\n+   --  Note on the use of brackets encoding (WCEM_Brackets). The brackets\n+   --  encoding method is ambiguous in the context of this function, since\n+   --  there is no way to tell if [\"1234\"] is eight unencoded characters or\n+   --  one encoded character. In the context of Ada sources, any sequence\n+   --  starting [\" must be the start of an encoding (since that sequence is\n+   --  not valid in Ada source otherwise). The routines in this package use\n+   --  the same approach. If the input string contains the sequence [\" then\n+   --  this is assumed to be the start of a brackets encoding sequence, and\n+   --  if it does not match the syntax, an error is raised.\n \n    generic\n       with function In_Char return Character;\n@@ -82,6 +101,11 @@ package System.WCh_Cnv is\n    --  more characters, calling the given Out_Char procedure for each.\n    --  Constraint_Error is raised if the given wide character value is\n    --  not a valid value for the given encoding method.\n+   --\n+   --  Note on brackets encoding (WCEM_Brackets). For the input routines above,\n+   --  upper half characters can be represented as [\"hh\"] but this procedure\n+   --  will only use brackets encodings for codes higher than 16#FF#, so upper\n+   --  half characters will be output as single Character values.\n \n    generic\n       with procedure Out_Char (C : Character);"}, {"sha": "f6ae6e56276c4e546bcb34fef8c9bde06b95ac06", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d48556afdb3226ee55ef42b8b3327b71c631f/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c80d48556afdb3226ee55ef42b8b3327b71c631f", "patch": "@@ -35,6 +35,7 @@ with Itypes;   use Itypes;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n+with Namet.Sp; use Namet.Sp;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n@@ -55,8 +56,6 @@ with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n-with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n-\n package body Sem_Aggr is\n \n    type Case_Bounds is record\n@@ -730,44 +729,37 @@ package body Sem_Aggr is\n       --  misspellings, these misspellings will be suggested as\n       --  possible correction.\n \n-      Get_Name_String (Chars (Component));\n-\n-      declare\n-         S  : constant String (1 .. Name_Len) :=\n-                Name_Buffer (1 .. Name_Len);\n-\n-      begin\n-         Component_Elmt := First_Elmt (Elements);\n-         while Nr_Of_Suggestions <= Max_Suggestions\n-            and then Present (Component_Elmt)\n-         loop\n-            Get_Name_String (Chars (Node (Component_Elmt)));\n-\n-            if Is_Bad_Spelling_Of (Name_Buffer (1 .. Name_Len), S) then\n-               Nr_Of_Suggestions := Nr_Of_Suggestions + 1;\n+      Component_Elmt := First_Elmt (Elements);\n+      while Nr_Of_Suggestions <= Max_Suggestions\n+        and then Present (Component_Elmt)\n+      loop\n+         if Is_Bad_Spelling_Of\n+              (Chars (Node (Component_Elmt)),\n+               Chars (Component))\n+         then\n+            Nr_Of_Suggestions := Nr_Of_Suggestions + 1;\n \n-               case Nr_Of_Suggestions is\n-                  when 1      => Suggestion_1 := Node (Component_Elmt);\n-                  when 2      => Suggestion_2 := Node (Component_Elmt);\n-                  when others => exit;\n-               end case;\n-            end if;\n+            case Nr_Of_Suggestions is\n+               when 1      => Suggestion_1 := Node (Component_Elmt);\n+               when 2      => Suggestion_2 := Node (Component_Elmt);\n+               when others => exit;\n+            end case;\n+         end if;\n \n-            Next_Elmt (Component_Elmt);\n-         end loop;\n+         Next_Elmt (Component_Elmt);\n+      end loop;\n \n-         --  Report at most two suggestions\n+      --  Report at most two suggestions\n \n-         if Nr_Of_Suggestions = 1 then\n-            Error_Msg_NE (\"\\possible misspelling of&\",\n-               Component, Suggestion_1);\n+      if Nr_Of_Suggestions = 1 then\n+         Error_Msg_NE\n+           (\"\\possible misspelling of&\", Component, Suggestion_1);\n \n-         elsif Nr_Of_Suggestions = 2 then\n-            Error_Msg_Node_2 := Suggestion_2;\n-            Error_Msg_NE (\"\\possible misspelling of& or&\",\n-              Component, Suggestion_1);\n-         end if;\n-      end;\n+      elsif Nr_Of_Suggestions = 2 then\n+         Error_Msg_Node_2 := Suggestion_2;\n+         Error_Msg_NE\n+           (\"\\possible misspelling of& or&\", Component, Suggestion_1);\n+      end if;\n    end Check_Misspelled_Component;\n \n    ----------------------------------------\n@@ -3029,15 +3021,18 @@ package body Sem_Aggr is\n \n                --  A box-defaulted access component gets the value null. Also\n                --  included are components of private types whose underlying\n-               --  type is an access type.\n+               --  type is an access type. In either case set the type of the\n+               --  literal, for subsequent use in semantic checks.\n \n                elsif Present (Underlying_Type (Ctyp))\n                  and then Is_Access_Type (Underlying_Type (Ctyp))\n                then\n                   if not Is_Private_Type (Ctyp) then\n+                     Expr := Make_Null (Sloc (N));\n+                     Set_Etype (Expr, Ctyp);\n                      Add_Association\n                        (Component => Component,\n-                        Expr      => Make_Null (Sloc (N)));\n+                        Expr      => Expr);\n \n                   --  If the component's type is private with an access type as\n                   --  its underlying type then we have to create an unchecked\n@@ -3184,9 +3179,7 @@ package body Sem_Aggr is\n             --  Ignore hidden components associated with the position of the\n             --  interface tags: these are initialized dynamically.\n \n-            if Present (Related_Interface (Component)) then\n-               null;\n-            else\n+            if not Present (Related_Type (Component)) then\n                Error_Msg_NE\n                  (\"no value supplied for component &!\", N, Component);\n             end if;"}]}