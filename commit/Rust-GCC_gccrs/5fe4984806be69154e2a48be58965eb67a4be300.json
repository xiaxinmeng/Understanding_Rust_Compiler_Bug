{"sha": "5fe4984806be69154e2a48be58965eb67a4be300", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZlNDk4NDgwNmJlNjkxNTRlMmE0OGJlNTg5NjVlYjY3YTRiZTMwMA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-10T14:31:14Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-12T21:39:45Z"}, "message": "Add path probe for inherent impl item candidates\n\nWhen performing PathInExpression resolution we need to probe for candidates\nin impl blocks which can_eq to the Self type. This could be reused to clean\nup Method resolution and implement PathInExpression resolution properly.", "tree": {"sha": "289967fff36c9247053ebb3a5b6a4aacefeb0e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/289967fff36c9247053ebb3a5b6a4aacefeb0e58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fe4984806be69154e2a48be58965eb67a4be300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe4984806be69154e2a48be58965eb67a4be300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fe4984806be69154e2a48be58965eb67a4be300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe4984806be69154e2a48be58965eb67a4be300/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f98ccb3a0bcf6a49b4e1f2080f7f58fe39794fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98ccb3a0bcf6a49b4e1f2080f7f58fe39794fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98ccb3a0bcf6a49b4e1f2080f7f58fe39794fdf"}], "stats": {"total": 162, "additions": 162, "deletions": 0}, "files": [{"sha": "a838565161369a8ecf1780ec7d245f0e07fc7ed4", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe4984806be69154e2a48be58965eb67a4be300/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe4984806be69154e2a48be58965eb67a4be300/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=5fe4984806be69154e2a48be58965eb67a4be300", "patch": "@@ -0,0 +1,162 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATH_PROBE_H\n+#define RUST_HIR_PATH_PROBE_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-substitution-mapper.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+struct PathProbeCandidate\n+{\n+  HIR::InherentImplItem *impl_item;\n+  TyTy::BaseType *ty;\n+};\n+\n+class PathProbeType : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static std::vector<PathProbeCandidate>\n+  Probe (TyTy::BaseType *receiver, const HIR::PathIdentSegment &segment_name)\n+  {\n+    PathProbeType probe (receiver, segment_name);\n+    probe.mappings->iterate_impl_items (\n+      [&] (HirId id, HIR::InherentImplItem *item,\n+\t   HIR::InherentImpl *impl) mutable -> bool {\n+\tprobe.process_candidate (id, item, impl);\n+\treturn true;\n+      });\n+    return probe.candidates;\n+  }\n+\n+  void process_candidate (HirId id, HIR::InherentImplItem *item,\n+\t\t\t  HIR::InherentImpl *impl)\n+  {\n+    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_block_ty = nullptr;\n+    bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n+    rust_assert (ok);\n+\n+    if (!receiver->can_eq (impl_block_ty))\n+      return;\n+\n+    // lets visit the impl_item\n+    item->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    Identifier name = constant.get_identifier ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = constant.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate candidate{&constant, ty};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    Identifier name = function.get_function_name ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = function.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate candidate{&function, ty};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    Identifier name = method.get_method_name ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = method.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate candidate{&method, ty};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+private:\n+  PathProbeType (TyTy::BaseType *receiver, const HIR::PathIdentSegment &query)\n+    : TypeCheckBase (), receiver (receiver), search (query)\n+  {}\n+\n+  TyTy::BaseType *receiver;\n+  const HIR::PathIdentSegment &search;\n+  std::vector<PathProbeCandidate> candidates;\n+};\n+\n+class ReportMultipleCandidateError : private TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static void Report (std::vector<PathProbeCandidate> &candidates,\n+\t\t      const HIR::PathIdentSegment &query, Location query_locus)\n+  {\n+    rust_error_at (query_locus, \"multiple applicable items in scope for: %s\",\n+\t\t   query.as_string ().c_str ());\n+\n+    ReportMultipleCandidateError visitor;\n+    for (auto &c : candidates)\n+      c.impl_item->accept_vis (visitor);\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    rust_error_at (constant.get_locus (), \"possible candidate\");\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    rust_error_at (function.get_locus (), \"possible candidate\");\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    rust_error_at (method.get_locus (), \"possible candidate\");\n+  }\n+\n+private:\n+  ReportMultipleCandidateError () : TypeCheckBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_PATH_PROBE_H"}]}