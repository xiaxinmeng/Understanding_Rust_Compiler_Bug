{"sha": "622f91baa80861cf721cc364652b7ce47707a6e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIyZjkxYmFhODA4NjFjZjcyMWNjMzY0NjUyYjdjZTQ3NzA3YTZlNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-12-14T16:15:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-12-14T16:15:53Z"}, "message": "tree-ssa-ccp.c (fold_stmt_r): DATA argument is now a pointer to a structure containing state rather than a...\n\n\n\t* tree-ssa-ccp.c (fold_stmt_r): DATA argument is now a pointer\n\tto a structure containing state rather than a pointer to bool.\n\t(case ARRAY_REF): New code to handle folding some array references.\n\t(case ADDR_EXPR): Note when we are processing expressions found\n\twithin an ADDRE_EXPR.\n\t(fold_stmt, fold_stmt_inplace): Pass in a structure to fold_stmt_r\n\tfor state variables rather than just a pointer to a boolean.\n\t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Remove\n\thandling of constant string references.\n\n\t* gcc.dg/tree-ssa/foldstring-1.c: New test.\n\nFrom-SVN: r108519", "tree": {"sha": "508d1e36512ecd1b4e57698cc4a555112ed60e53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/508d1e36512ecd1b4e57698cc4a555112ed60e53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/622f91baa80861cf721cc364652b7ce47707a6e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/622f91baa80861cf721cc364652b7ce47707a6e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/622f91baa80861cf721cc364652b7ce47707a6e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/622f91baa80861cf721cc364652b7ce47707a6e7/comments", "author": null, "committer": null, "parents": [{"sha": "08a5aaa2e3b0384f72b118ec42d6fb64d22ca891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a5aaa2e3b0384f72b118ec42d6fb64d22ca891", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08a5aaa2e3b0384f72b118ec42d6fb64d22ca891"}], "stats": {"total": 76, "additions": 62, "deletions": 14}, "files": [{"sha": "1051c70e7e0439c2f2c30bec92b006a0437ac1cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=622f91baa80861cf721cc364652b7ce47707a6e7", "patch": "@@ -1,3 +1,15 @@\n+2005-12-14  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-ccp.c (fold_stmt_r): DATA argument is now a pointer\n+\tto a structure containing state rather than a pointer to bool.\n+\t(case ARRAY_REF): New code to handle folding some array references.\n+\t(case ADDR_EXPR): Note when we are processing expressions found\n+\twithin an ADDRE_EXPR.\n+\t(fold_stmt, fold_stmt_inplace): Pass in a structure to fold_stmt_r\n+\tfor state variables rather than just a pointer to a boolean.\n+\t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Remove\n+\thandling of constant string references.\n+\n 2005-12-14  Adrian Straetling  <straetling@de.ibm.com>\n \n \t* config/s390/s390.md (\"*tstdi_extimm\", \"*tstsi_extimm\"): Merge."}, {"sha": "c8402373d310d4ec38acdc17efe53b9d82d84e72", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=622f91baa80861cf721cc364652b7ce47707a6e7", "patch": "@@ -1,3 +1,7 @@\n+2005-12-14  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/foldstring-1.c: New test.\n+\n 2005-12-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/25254"}, {"sha": "25a7ef49f8ae260c4743c5e4beeba3896cded274", "filename": "gcc/testsuite/gcc.dg/tree-ssa/foldstring-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldstring-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldstring-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldstring-1.c?ref=622f91baa80861cf721cc364652b7ce47707a6e7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-useless\" } */\n+\n+void\n+arf ()\n+{\n+  if (\"\"[0] == 0)\n+    blah ();\n+}\n+/* { dg-final { scan-tree-dump-times \"= 0;\" 1 \"useless\"} } */ \n+/* { dg-final { cleanup-tree-dump \"useless\" } } */"}, {"sha": "9037b6e1d37b13bc941471b4eae4839af679e3a9", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=622f91baa80861cf721cc364652b7ce47707a6e7", "patch": "@@ -1922,13 +1922,24 @@ maybe_fold_stmt_addition (tree expr)\n   return t;\n }\n \n+/* For passing state through walk_tree into fold_stmt_r and its\n+   children.  */\n+\n+struct fold_stmt_r_data\n+{\n+    bool *changed_p;\n+    bool *inside_addr_expr_p;\n+};\n+\n /* Subroutine of fold_stmt called via walk_tree.  We perform several\n    simplifications of EXPR_P, mostly having to do with pointer arithmetic.  */\n \n static tree\n fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n {\n-  bool *changed_p = data;\n+  struct fold_stmt_r_data *fold_stmt_r_data = data;\n+  bool *inside_addr_expr_p = fold_stmt_r_data->inside_addr_expr_p;\n+  bool *changed_p = fold_stmt_r_data->changed_p;\n   tree expr = *expr_p, t;\n \n   /* ??? It'd be nice if walk_tree had a pre-order option.  */\n@@ -1944,13 +1955,23 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n \t\t\t\t    integer_zero_node);\n       break;\n \n-      /* ??? Could handle ARRAY_REF here, as a variant of INDIRECT_REF.\n+      /* ??? Could handle more ARRAY_REFs here, as a variant of INDIRECT_REF.\n \t We'd only want to bother decomposing an existing ARRAY_REF if\n \t the base array is found to have another offset contained within.\n \t Otherwise we'd be wasting time.  */\n+    case ARRAY_REF:\n+      /* If we are not processing expressions found within an\n+\t ADDR_EXPR, then we can fold constant array references.  */\n+      if (!*inside_addr_expr_p)\n+\tt = fold_read_from_constant_string (expr);\n+      else\n+\tt = NULL;\n+      break;\n \n     case ADDR_EXPR:\n+      *inside_addr_expr_p = true;\n       t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n+      *inside_addr_expr_p = false;\n       if (t)\n \treturn t;\n       *walk_subtrees = 0;\n@@ -2290,13 +2311,18 @@ bool\n fold_stmt (tree *stmt_p)\n {\n   tree rhs, result, stmt;\n+  struct fold_stmt_r_data fold_stmt_r_data;\n   bool changed = false;\n+  bool inside_addr_expr = false;\n+\n+  fold_stmt_r_data.changed_p = &changed;\n+  fold_stmt_r_data.inside_addr_expr_p = &inside_addr_expr;\n \n   stmt = *stmt_p;\n \n   /* If we replaced constants and the statement makes pointer dereferences,\n      then we may need to fold instances of *&VAR into VAR, etc.  */\n-  if (walk_tree (stmt_p, fold_stmt_r, &changed, NULL))\n+  if (walk_tree (stmt_p, fold_stmt_r, &fold_stmt_r_data, NULL))\n     {\n       *stmt_p\n \t= build_function_call_expr (implicit_built_in_decls[BUILT_IN_TRAP],\n@@ -2375,9 +2401,14 @@ bool\n fold_stmt_inplace (tree stmt)\n {\n   tree old_stmt = stmt, rhs, new_rhs;\n+  struct fold_stmt_r_data fold_stmt_r_data;\n   bool changed = false;\n+  bool inside_addr_expr = false;\n+\n+  fold_stmt_r_data.changed_p = &changed;\n+  fold_stmt_r_data.inside_addr_expr_p = &inside_addr_expr;\n \n-  walk_tree (&stmt, fold_stmt_r, &changed, NULL);\n+  walk_tree (&stmt, fold_stmt_r, &fold_stmt_r_data, NULL);\n   gcc_assert (stmt == old_stmt);\n \n   rhs = get_rhs (stmt);"}, {"sha": "683e134cdd8da9c0dd117699e1ac8113e6fc39dc", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/622f91baa80861cf721cc364652b7ce47707a6e7/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=622f91baa80861cf721cc364652b7ce47707a6e7", "patch": "@@ -1837,16 +1837,6 @@ simplify_rhs_and_lookup_avail_expr (tree stmt, int insert)\n \t}\n     }\n \n-  /* Optimize *\"foo\" into 'f'.  This is done here rather than\n-     in fold to avoid problems with stuff like &*\"foo\".  */\n-  if (TREE_CODE (rhs) == INDIRECT_REF || TREE_CODE (rhs) == ARRAY_REF)\n-    {\n-      tree t = fold_read_from_constant_string (rhs);\n-\n-      if (t)\n-        result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n-    }\n-\n   return result;\n }\n "}]}