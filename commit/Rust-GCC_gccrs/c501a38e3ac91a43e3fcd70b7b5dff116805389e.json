{"sha": "c501a38e3ac91a43e3fcd70b7b5dff116805389e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUwMWEzOGUzYWM5MWE0M2UzZmNkNzBiN2I1ZGZmMTE2ODA1Mzg5ZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-07T12:15:59Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-07T12:15:59Z"}, "message": "i386.c (enum upper_128bits_state): Remove.\n\n\t* config/i386/i386.c (enum upper_128bits_state): Remove.\n\t(check_avx256_store): Use bool pointer argument.\n\t(ix86_avx_u128_mode_needed): Use note_stores also for CALL insns.\n\t* config/i386/predicates.md (vzeroupper_operation): Use match_test.\n\nFrom-SVN: r193294", "tree": {"sha": "ae7c3835a79796f6e77236cb00871869c416903c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae7c3835a79796f6e77236cb00871869c416903c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c501a38e3ac91a43e3fcd70b7b5dff116805389e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c501a38e3ac91a43e3fcd70b7b5dff116805389e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c501a38e3ac91a43e3fcd70b7b5dff116805389e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c501a38e3ac91a43e3fcd70b7b5dff116805389e/comments", "author": null, "committer": null, "parents": [{"sha": "e1dfe00531385492850be7b5d8f2aa32b3b32f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1dfe00531385492850be7b5d8f2aa32b3b32f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1dfe00531385492850be7b5d8f2aa32b3b32f1c"}], "stats": {"total": 107, "additions": 44, "deletions": 63}, "files": [{"sha": "18f8c7e718a0d8b4d81a01b0635a18e5ff4ac04f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c501a38e3ac91a43e3fcd70b7b5dff116805389e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c501a38e3ac91a43e3fcd70b7b5dff116805389e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c501a38e3ac91a43e3fcd70b7b5dff116805389e", "patch": "@@ -1,3 +1,10 @@\n+2012-11-07  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (enum upper_128bits_state): Remove.\n+\t(check_avx256_store): Use bool pointer argument.\n+\t(ix86_avx_u128_mode_needed): Use note_stores also for CALL insns.\n+\t* config/i386/predicates.md (vzeroupper_operation): Use match_test.\n+\n 2012-11-07  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_expand_prologue): For the\n@@ -23,19 +30,18 @@\n 2012-11-07  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline-analysis.c (true_predicate, single_cond_predicate,\n-\treset_inline_edge_summary): Fix\n-\tformatting.\n-\t(account_size_time): Bump up the limit on number of size/time entries to\n-\t256.\n+\treset_inline_edge_summary): Fix formatting.\n+\t(account_size_time): Bump up the limit on number of size/time\n+\tentries to 256.\n \t(estimate_function_body_sizes): Work in reverse postorder.\n \n 2012-11-07  David S. Miller  <davem@davemloft.net>\n \n \tPR bootstrap/55211\n \tRevert:\n-    \t* config/sparc/constraints.md (\"U\"): Delete.\n-    \t* config/sparc/sparc.md: Use 'r' constraint instead of 'U'.\n-    \t* config/sparc/sync.md: Likewise.\n+\t* config/sparc/constraints.md (\"U\"): Delete.\n+\t* config/sparc/sparc.md: Use 'r' constraint instead of 'U'.\n+\t* config/sparc/sync.md: Likewise.\n \tAnd revert parts of:\n \t* doc/md.texi: Sync sparc constraint documentation with reality.\n \n@@ -55,7 +61,7 @@\n \t* dwarf2out.c (output_comdat_type_unit): Check for OBJECT_FORMAT_ELF.\n \n 2012-11-06  Aldy Hernandez  <aldyh@redhat.com>\n-            Richard Henderson  <rth@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n \n \t* cfg-flags.def (TM_UNINSTRUMENTED, TM_ABORT): New.\n \t* trans-mem.c (PROB_VERY_LIKELY, PROB_UNLIKELY, PROB_LIKELY): New."}, {"sha": "2386017eb6c31623216ce087e101b4ad40bbc5e3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 28, "deletions": 51, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c501a38e3ac91a43e3fcd70b7b5dff116805389e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c501a38e3ac91a43e3fcd70b7b5dff116805389e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c501a38e3ac91a43e3fcd70b7b5dff116805389e", "patch": "@@ -65,27 +65,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-flow.h\"\n \n-enum upper_128bits_state\n-{\n-  unknown = 0,\n-  unused,\n-  used\n-};\n-\n /* Check if a 256bit AVX register is referenced in stores.   */\n \n static void\n check_avx256_stores (rtx dest, const_rtx set, void *data)\n {\n-  if (((REG_P (dest) || MEM_P(dest))\n+  if (((REG_P (dest) || MEM_P (dest))\n        && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (dest)))\n       || (GET_CODE (set) == SET\n \t  && (REG_P (SET_SRC (set)) || MEM_P (SET_SRC (set)))\n \t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (SET_SRC (set)))))\n     {\n-      enum upper_128bits_state *state\n-\t= (enum upper_128bits_state *) data;\n-      *state = used;\n+      bool *used = (bool *) data;\n+      *used = true;\n     }\n }\n \n@@ -14967,23 +14959,24 @@ output_387_binary_op (rtx insn, rtx *operands)\n static int\n ix86_avx_u128_mode_needed (rtx insn)\n {\n-  rtx pat = PATTERN (insn);\n-  rtx arg;\n-  enum upper_128bits_state state;\n+  bool avx_u128_used;\n \n   if (CALL_P (insn))\n     {\n+      rtx link;\n+\n       /* Needed mode is set to AVX_U128_CLEAN if there are\n \t no 256bit modes used in function arguments.  */\n-      for (arg = CALL_INSN_FUNCTION_USAGE (insn); arg;\n-\t   arg = XEXP (arg, 1))\n+      for (link = CALL_INSN_FUNCTION_USAGE (insn);\n+\t   link;\n+\t   link = XEXP (link, 1))\n \t{\n-\t  if (GET_CODE (XEXP (arg, 0)) == USE)\n+\t  if (GET_CODE (XEXP (link, 0)) == USE)\n \t    {\n-\t      rtx reg = XEXP (XEXP (arg, 0), 0);\n+\t      rtx arg = XEXP (XEXP (link, 0), 0);\n \n-\t      if (reg && REG_P (reg)\n-\t\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n+\t      if (REG_P (arg)\n+\t\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (arg)))\n \t\treturn AVX_U128_ANY;\n \t    }\n \t}\n@@ -14992,10 +14985,11 @@ ix86_avx_u128_mode_needed (rtx insn)\n     }\n \n   /* Check if a 256bit AVX register is referenced in stores.  */\n-  state = unused;\n-  note_stores (pat, check_avx256_stores, &state);\n-  if (state == used)\n+  avx_u128_used = false;\n+  note_stores (PATTERN (insn), check_avx256_stores, &avx_u128_used);\n+  if (avx_u128_used)\n     return AVX_U128_DIRTY;\n+\n   return AVX_U128_ANY;\n }\n \n@@ -15079,39 +15073,21 @@ static int\n ix86_avx_u128_mode_after (int mode, rtx insn)\n {\n   rtx pat = PATTERN (insn);\n-  rtx reg = NULL;\n-  int i;\n-  enum upper_128bits_state state;\n-\n-  /* Check for CALL instruction.  */\n-  if (CALL_P (insn))\n-    {\n-      if (GET_CODE (pat) == SET)\n-\treg = SET_DEST (pat);\n-      else if (GET_CODE (pat) == PARALLEL)\n-\tfor (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n-\t  {\n-\t    rtx x = XVECEXP (pat, 0, i);\n-\t    if (GET_CODE(x) == SET)\n-\t      reg = SET_DEST (x);\n-\t  }\n-      /* Mode after call is set to AVX_U128_DIRTY if there are\n-\t 256bit modes used in the function return register.  */\n-      if (reg && REG_P (reg) && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n-\treturn AVX_U128_DIRTY;\n-      else\n-\treturn AVX_U128_CLEAN;\n-    }\n+  bool avx_u128_used;\n \n   if (vzeroupper_operation (pat, VOIDmode)\n       || vzeroall_operation (pat, VOIDmode))\n     return AVX_U128_CLEAN;\n \n   /* Check if a 256bit AVX register is referenced in stores.  */\n-  state = unused;\n-  note_stores (pat, check_avx256_stores, &state);\n-  if (state == used)\n+  avx_u128_used = false;\n+  note_stores (pat, check_avx256_stores, &avx_u128_used);\n+  if (avx_u128_used)\n     return AVX_U128_DIRTY;\n+  /* We know that state is clean after CALL insn if there are no\n+     256bit modes used in the function return register.  */\n+  else if (CALL_P (insn))\n+    return AVX_U128_CLEAN;\n \n   return mode;\n }\n@@ -15145,9 +15121,10 @@ ix86_avx_u128_mode_entry (void)\n   for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n        arg = TREE_CHAIN (arg))\n     {\n-      rtx reg = DECL_INCOMING_RTL (arg);\n+      rtx incoming = DECL_INCOMING_RTL (arg);\n \n-      if (reg && REG_P (reg) && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n+      if (incoming && REG_P (incoming)\n+\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (incoming)))\n \treturn AVX_U128_DIRTY;\n     }\n "}, {"sha": "485fc63c7382838923bf1ef2a20d5794f5dad2c0", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c501a38e3ac91a43e3fcd70b7b5dff116805389e/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c501a38e3ac91a43e3fcd70b7b5dff116805389e/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=c501a38e3ac91a43e3fcd70b7b5dff116805389e", "patch": "@@ -1231,10 +1231,8 @@\n \n ;; return true if OP is a vzeroupper operation.\n (define_predicate \"vzeroupper_operation\"\n-  (match_code \"unspec_volatile\")\n-{\n-  return XINT (op, 1) == UNSPECV_VZEROUPPER;\n-})\n+  (and (match_code \"unspec_volatile\")\n+       (match_test \"XINT (op, 1) == UNSPECV_VZEROUPPER\")))\n \n ;; Return true if OP is a parallel for a vbroadcast permute.\n "}]}