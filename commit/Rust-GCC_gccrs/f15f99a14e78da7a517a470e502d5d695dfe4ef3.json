{"sha": "f15f99a14e78da7a517a470e502d5d695dfe4ef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE1Zjk5YTE0ZTc4ZGE3YTUxN2E0NzBlNTAyZDVkNjk1ZGZlNGVmMw==", "commit": {"author": {"name": "Stefan Olsson", "email": "stefan@snon.net", "date": "2004-01-28T17:50:34Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-01-28T17:50:34Z"}, "message": "mt_allocator.h: Replaced all malloc() calls with operator new().\n\n\n2004-01-28  Stefan Olsson  <stefan@snon.net>\n\n \t* include/ext/mt_allocator.h: Replaced all malloc() calls with\n\toperator new(). Added support for the env variable\n\tGLIBCXX_FORCE_NEW (this required the _S_init call to be the first\n\tone in allocate() as well). Fix typos.\n\nFrom-SVN: r76795", "tree": {"sha": "fb7c47b564019d2ae9f84f47ac6e06cc12c7e7d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb7c47b564019d2ae9f84f47ac6e06cc12c7e7d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f15f99a14e78da7a517a470e502d5d695dfe4ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15f99a14e78da7a517a470e502d5d695dfe4ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15f99a14e78da7a517a470e502d5d695dfe4ef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15f99a14e78da7a517a470e502d5d695dfe4ef3/comments", "author": null, "committer": null, "parents": [{"sha": "796e87a2b0920bc337c275b404abcb9a79fa4a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/796e87a2b0920bc337c275b404abcb9a79fa4a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/796e87a2b0920bc337c275b404abcb9a79fa4a41"}], "stats": {"total": 88, "additions": 62, "deletions": 26}, "files": [{"sha": "64ea1fff58fbff8c5ac8cb777fbe2c82f76e3946", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15f99a14e78da7a517a470e502d5d695dfe4ef3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15f99a14e78da7a517a470e502d5d695dfe4ef3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f15f99a14e78da7a517a470e502d5d695dfe4ef3", "patch": "@@ -1,3 +1,10 @@\n+2004-01-28  Stefan Olsson  <stefan@snon.net>\n+\n+ \t* include/ext/mt_allocator.h: Replaced all malloc() calls with\n+\toperator new(). Added support for the env variable\n+\tGLIBCXX_FORCE_NEW (this required the _S_init call to be the first\n+\tone in allocate() as well). Fix typos.\n+\n 2004-01-28  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/basic_string.h (_S_create(size_t,"}, {"sha": "bd0945afe22f59208cd324f1aa7ed5b1ae553a04", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15f99a14e78da7a517a470e502d5d695dfe4ef3/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15f99a14e78da7a517a470e502d5d695dfe4ef3/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=f15f99a14e78da7a517a470e502d5d695dfe4ef3", "patch": "@@ -124,6 +124,12 @@ namespace __gnu_cxx\n #endif\n       static bool volatile _S_initialized;\n \n+      /*\n+       * If the env var GLIBCXX_FORCE_NEW is set during _S_init()\n+       * we set this var to true which causes all allocations to use new()\n+       */\n+      static bool _S_force_new;\n+\n       /*\n        * Using short int as type for the binmap implies we are never caching\n        * blocks larger than 65535 with this allocator\n@@ -226,18 +232,6 @@ namespace __gnu_cxx\n       pointer\n       allocate(size_t __n, std::allocator<void>::const_pointer __h = 0)\n       {\n-        /*\n-         * Requests larger than _S_max_bytes are handled by\n-         * new/delete directly\n-         */\n-        if (__n * sizeof(_Tp) > _S_max_bytes)\n-          {\n-            void* __ret = malloc(__n * sizeof(_Tp));\n-            if (!__ret)\n-              __throw_bad_alloc();\n-            return static_cast<_Tp*>(__ret);\n-          }\n-\t\n         /*\n          * Although the test in __gthread_once() would suffice, we\n          * wrap test of the once condition in our own unlocked\n@@ -258,6 +252,18 @@ namespace __gnu_cxx\n               }\n           }\n \n+        /*\n+         * Requests larger than _S_max_bytes are handled by\n+         * new/delete directly\n+         */\n+        if (__n * sizeof(_Tp) > _S_max_bytes || _S_force_new)\n+          {\n+            void* __ret = ::operator new(__n * sizeof(_Tp));\n+            if (!__ret)\n+              __throw_bad_alloc();\n+            return static_cast<_Tp*>(__ret);\n+          }\n+\n         /*\n          * Round up to power of 2 and figure out which bin to use\n          */\n@@ -308,7 +314,7 @@ namespace __gnu_cxx\n                     __gthread_mutex_unlock(_S_bin[bin].mutex);\n \n                     _S_bin[bin].first[thread_id] =\n-                      (block_record*)malloc(_S_chunk_size);\n+                      static_cast<block_record*>(::operator new(_S_chunk_size));\n \n                     if (!_S_bin[bin].first[thread_id])\n                       __throw_bad_alloc();\n@@ -375,7 +381,8 @@ namespace __gnu_cxx\n             else\n #endif\n               {\n-                _S_bin[bin].first[0] = (block_record*)malloc(_S_chunk_size);\n+                _S_bin[bin].first[0] = \n+                  static_cast<block_record*>(::operator new(_S_chunk_size));\n \n                 if (!_S_bin[bin].first[0])\n                   __throw_bad_alloc();\n@@ -425,7 +432,8 @@ namespace __gnu_cxx\n #endif\n           }\n \n-        return static_cast<_Tp*>(static_cast<void*>((char*)block + sizeof(block_record)));\n+        return static_cast<_Tp*>(static_cast<void*>((char*)block + \n+                                                    sizeof(block_record)));\n       }\n \n       void\n@@ -435,7 +443,7 @@ namespace __gnu_cxx\n          * Requests larger than _S_max_bytes are handled by\n          * malloc/free directly\n          */\n-        if (__n * sizeof(_Tp) > _S_max_bytes)\n+        if (__n * sizeof(_Tp) > _S_max_bytes || _S_force_new)\n           {\n             free(__p);\n             return;\n@@ -546,6 +554,19 @@ namespace __gnu_cxx\n     __mt_alloc<_Tp>::\n     _S_init()\n     {\n+      if (getenv(\"GLIBCXX_FORCE_NEW\"))\n+        {\n+          _S_force_new = true;\n+          _S_initialized = true;\n+\n+          /*\n+           * Since none of the code in allocate/deallocate ever will be \n+           * executed due to that the GLIBCXX_FORCE_NEW flag is set\n+           * there is no need to create the internal structures either.\n+           */\n+          return;\n+        }\n+\n       /*\n        * Calculate the number of bins required based on _S_max_bytes,\n        * _S_no_of_bins is initialized to 1 below.\n@@ -590,7 +611,8 @@ namespace __gnu_cxx\n       if (__gthread_active_p())\n         {\n           _S_thread_freelist_first =\n-            (thread_record*)malloc(sizeof(thread_record) * _S_max_threads);\n+            static_cast<thread_record*>(::operator \n+              new(sizeof(thread_record) * _S_max_threads));\n \n           if (!_S_thread_freelist_first)\n             __throw_bad_alloc();\n@@ -625,7 +647,8 @@ namespace __gnu_cxx\n       /*\n        * Initialize _S_bin and its members\n        */\n-      _S_bin = (bin_record*)malloc(sizeof(bin_record) * _S_no_of_bins);\n+      _S_bin = static_cast<bin_record*>(::operator \n+        new(sizeof(bin_record) * _S_no_of_bins));\n \n       if (!_S_bin)\n         __throw_bad_alloc();\n@@ -639,32 +662,35 @@ namespace __gnu_cxx\n \n       for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n         {\n-          _S_bin[bin].first = (block_record**) \n-            malloc(sizeof(block_record*) * __n);\n+          _S_bin[bin].first = static_cast<block_record**>(::operator \n+            new(sizeof(block_record*) * __n));\n \n           if (!_S_bin[bin].first)\n             __throw_bad_alloc();\n \n-          _S_bin[bin].last = (block_record**) \n-            malloc(sizeof(block_record*) * __n);\n+          _S_bin[bin].last = static_cast<block_record**>(::operator \n+            new(sizeof(block_record*) * __n));\n \n           if (!_S_bin[bin].last)\n             __throw_bad_alloc();\n \n #ifdef __GTHREADS\n           if (__gthread_active_p())\n             {\n-              _S_bin[bin].free = (size_t*) malloc(sizeof(size_t) * __n);\n+              _S_bin[bin].free = static_cast<size_t*>(::operator \n+                new(sizeof(size_t) * __n));\n \n               if (!_S_bin[bin].free)\n                 __throw_bad_alloc();\n \n-              _S_bin[bin].used = (size_t*) malloc(sizeof(size_t) * __n);\n+              _S_bin[bin].used = static_cast<size_t*>(::operator \n+                new(sizeof(size_t) * __n));\n \n               if (!_S_bin[bin].used)\n                 __throw_bad_alloc();\n \n-              _S_bin[bin].mutex =(__gthread_mutex_t*) malloc(sizeof(__gthread_mutex_t));\n+              _S_bin[bin].mutex = static_cast<__gthread_mutex_t*>(::operator \n+                new(sizeof(__gthread_mutex_t)));\n \n #ifdef __GTHREAD_MUTEX_INIT\n               {\n@@ -758,6 +784,9 @@ namespace __gnu_cxx\n   template<typename _Tp> bool\n   volatile __mt_alloc<_Tp>::_S_initialized = false;\n \n+  template<typename _Tp> bool\n+  __mt_alloc<_Tp>::_S_force_new = false;\n+\n   template<typename _Tp> typename __mt_alloc<_Tp>::binmap_type*\n   __mt_alloc<_Tp>::_S_binmap = NULL;\n \n@@ -770,7 +799,7 @@ namespace __gnu_cxx\n   __mt_alloc<_Tp>::_S_max_bytes = 128;\n \n   /*\n-   * In order to avoid fragmenting and minimize the number of malloc()\n+   * In order to avoid fragmenting and minimize the number of new()\n    * calls we always request new memory using this value. Based on\n    * previous discussions on the libstdc++ mailing list we have\n    * choosen the value below. See"}]}