{"sha": "d133777f5d4f838c9828865086192ed55a3d1c57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEzMzc3N2Y1ZDRmODM4Yzk4Mjg4NjUwODYxOTJlZDU1YTNkMWM1Nw==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2001-11-25T11:30:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-25T11:30:17Z"}, "message": "vms-ld.c, vms-cc.c: New files.\n\n\t* config/alpha/vms-ld.c, config/alpha/vms-cc.c: New files.\n\t* config/alpha/x-vms: New file, to compile the above.\n\t* config.gcc (alpha*-dec-vms*): Add x-vms.\n\nFrom-SVN: r47312", "tree": {"sha": "f8602e6f5645ca1dd21295515032f0ff4a3ca627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8602e6f5645ca1dd21295515032f0ff4a3ca627"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d133777f5d4f838c9828865086192ed55a3d1c57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d133777f5d4f838c9828865086192ed55a3d1c57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d133777f5d4f838c9828865086192ed55a3d1c57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d133777f5d4f838c9828865086192ed55a3d1c57/comments", "author": null, "committer": null, "parents": [{"sha": "a319614e1325b54b872ccb66a64e29e3feacc86a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a319614e1325b54b872ccb66a64e29e3feacc86a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a319614e1325b54b872ccb66a64e29e3feacc86a"}], "stats": {"total": 1159, "additions": 1159, "deletions": 0}, "files": [{"sha": "a324088cdcc133a2cdd2e843ebe55efbd4accc85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d133777f5d4f838c9828865086192ed55a3d1c57", "patch": "@@ -1,3 +1,9 @@\n+Sun Nov 25 06:22:09 2001  Douglas B. Rupp  <rupp@gnat.com>\n+\n+\t* config/alpha/vms-ld.c, config/alpha/vms-cc.c: New files.\n+\t* config/alpha/x-vms: New file, to compile the above.\n+\t* config.gcc (alpha*-dec-vms*): Add x-vms.\n+\n 2001-11-24  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* genextract.c (main): Set ro_loc for peepholes."}, {"sha": "bf262a6c2014a8106c1af2d0e76aad549cf041fb", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=d133777f5d4f838c9828865086192ed55a3d1c57", "patch": "@@ -524,6 +524,7 @@ alpha*-dec-vms*)\n \ttm_file=alpha/vms.h\n \txm_file=alpha/xm-vms.h\n \ttmake_file=\"alpha/t-alpha alpha/t-vms alpha/t-ieee\"\n+\txmake_file=alpha/x-vms\n \t;;\n arc-*-elf*)\n \ttm_file=\"elfos.h svr4.h ${tm_file}\""}, {"sha": "a95a82eead75a802ecbe3183ffdab8486d518007", "filename": "gcc/config/alpha/vms-cc.c", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig%2Falpha%2Fvms-cc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig%2Falpha%2Fvms-cc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-cc.c?ref=d133777f5d4f838c9828865086192ed55a3d1c57", "patch": "@@ -0,0 +1,379 @@\n+/* VMS DEC C wrapper.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Douglas B. Rupp (rupp@gnat.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* This program is a wrapper around the VMS DEC C compiler.\n+   It translates Unix style command line options into corresponding\n+   VMS style qualifiers and then spawns the DEC C compiler.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#undef PATH_SEPARATOR\n+#undef PATH_SEPARATOR_STR\n+#define PATH_SEPARATOR ','\n+#define PATH_SEPARATOR_STR \",\"\n+\n+/* These can be set by command line arguments */\n+int verbose = 0;\n+int save_temps = 0;\n+\n+int comp_arg_max = -1;\n+const char **comp_args = 0;\n+int comp_arg_index = -1;\n+char *objfilename = 0;\n+\n+char *system_search_dirs = (char *) \"\";\n+char *search_dirs;\n+\n+char *default_defines = (char *) \"\";\n+char *defines;\n+\n+/* Translate a Unix syntax directory specification into VMS syntax.\n+   If indicators of VMS syntax found, return input string. */\n+static char *to_host_dir_spec PARAMS ((char *));\n+\n+/* Translate a Unix syntax file specification into VMS syntax.\n+   If indicators of VMS syntax found, return input string. */\n+static char *to_host_file_spec PARAMS ((char *));\n+\n+/* Add a translated arg to the list to be passed to DEC CC */\n+static void addarg PARAMS ((const char *));\n+\n+/* Preprocess the number of args in P_ARGC and contained in ARGV.\n+   Look for special flags, etc. that must be handled first. */\n+static void preprocess_args PARAMS ((*, **));\n+\n+/* Process the number of args in P_ARGC and contained in ARGV. Look\n+   for special flags, etc. that must be handled for the VMS compiler. */\n+static void process_args PARAMS ((int *, char **));\n+\n+/* Action routine called by decc$to_vms */\n+static int translate_unix PARAMS ((char *, int));\n+\n+int main PARAMS ((int, char **));\n+\f\n+/* Add the argument contained in STR to the list of arguments to pass to the\n+   compiler.  */\n+\n+static void\n+addarg (str)\n+     const char *str;\n+{\n+  int i;\n+\n+  if (++comp_arg_index >= comp_arg_max)\n+    {\n+      const char **new_comp_args\n+\t= (const char **) xcalloc (comp_arg_max + 1000, sizeof (char *));\n+\n+      for (i = 0; i <= comp_arg_max; i++)\n+\tnew_comp_args [i] = comp_args [i];\n+\n+      if (comp_args)\n+\tfree (comp_args);\n+\n+      comp_arg_max += 1000;\n+      comp_args = new_comp_args;\n+    }\n+\n+  comp_args [comp_arg_index] = str;\n+}\n+\n+static void\n+preprocess_args (p_argc, argv)\n+     int *p_argc;\n+     char *argv[];\n+{\n+  int i;\n+\n+  for (i = 1; i < *p_argc; i++)\n+    {\n+      if (strcmp (argv[i], \"-o\") == 0)\n+\t{\n+\t  char *buff, *ptr;\n+\t  int out_len;\n+\n+\t  i++;\n+\t  ptr = to_host_file_spec (argv[i]);\n+\t  objfilename = xstrdup (ptr);\n+\t  out_len = strlen (ptr);\n+\t  buff = xmalloc (out_len + 6);\n+\n+\t  strcpy (buff, \"/obj=\");\n+\t  strcat (buff, ptr);\n+\t  addarg (buff);\n+\t}\n+    }\n+}\n+\n+static void\n+process_args (p_argc, argv)\n+     int *p_argc;\n+     char *argv[];\n+{\n+  int i;\n+\n+  for (i = 1; i < *p_argc; i++)\n+    {\n+      if (strlen (argv[i]) < 2)\n+\tcontinue;\n+\n+      if (strncmp (argv[i], \"-I\", 2) == 0)\n+\t{\n+\t  char *ptr;\n+\t  int new_len, search_dirs_len;\n+\n+\t  ptr = to_host_dir_spec (&argv[i][2]);\n+\t  new_len = strlen (ptr);\n+\t  search_dirs_len = strlen (search_dirs);\n+\n+\t  search_dirs = xrealloc (search_dirs, search_dirs_len + new_len + 2);\n+\t  if (search_dirs_len > 0)\n+\t    strcat (search_dirs, PATH_SEPARATOR_STR);\n+\t  strcat (search_dirs, ptr);\n+\t}\n+      else if (strncmp (argv[i], \"-D\", 2) == 0)\n+\t{\n+\t  char *ptr;\n+\t  int new_len, defines_len;\n+\n+\t  ptr = &argv[i][2];\n+\t  new_len = strlen (ptr);\n+\t  defines_len = strlen (defines);\n+\n+\t  defines = xrealloc (defines, defines_len + new_len + 4);\n+\t  if (defines_len > 0)\n+\t    strcat (defines, \",\");\n+\n+\t  strcat (defines, \"\\\"\");\n+\t  strcat (defines, ptr);\n+\t  strcat (defines, \"\\\"\");\n+\t}\n+      else if (strcmp (argv[i], \"-v\") == 0)\n+\tverbose = 1;\n+      else if (strcmp (argv[i], \"-g0\") == 0)\n+\taddarg (\"/nodebug\");\n+      else if (strcmp (argv[i], \"-O0\") == 0)\n+\taddarg (\"/noopt\");\n+      else if (strncmp (argv[i], \"-g\", 2) == 0)\n+\taddarg (\"/debug\");\n+      else if (strcmp (argv[i], \"-E\") == 0)\n+\taddarg (\"/preprocess\");\n+      else if (strcmp (argv[i], \"-save-temps\") == 0)\n+\tsave_temps = 1;\n+    }\n+}\n+\n+/* The main program.  Spawn the VMS DEC C compiler after fixing up the\n+   Unix-like flags and args to be what VMS DEC C wants.  */\n+\n+typedef struct dsc {unsigned short len, mbz; char *adr; } Descr;\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int i;\n+  char cwdev [128], *devptr;\n+  int devlen;\n+  char *cwd = getcwd (0, 1024);\n+\n+  devptr = strchr (cwd, ':');\n+  devlen = (devptr - cwd) + 1;\n+  strncpy (cwdev, cwd, devlen);\n+  cwdev [devlen] = '\\0';\n+\n+  search_dirs = xmalloc (strlen (system_search_dirs) + 1);\n+  strcpy (search_dirs, system_search_dirs);\n+\n+  defines = xmalloc (strlen (default_defines) + 1);\n+  strcpy (defines, default_defines);\n+\n+  addarg (\"cc\");\n+  preprocess_args (&argc , argv);\n+  process_args (&argc , argv);\n+\n+  if (strlen (search_dirs) > 0)\n+    {\n+      addarg (\"/include=(\");\n+      addarg (search_dirs);\n+      addarg (\")\");\n+    }\n+\n+  if (strlen (defines) > 0)\n+    {\n+      addarg (\"/define=(\");\n+      addarg (defines);\n+      addarg (\")\");\n+    }\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      int arg_len = strlen (argv[i]);\n+\n+      if (strcmp (argv[i], \"-o\") == 0)\n+\ti++;\n+      else if (strcmp (argv[i], \"-v\" ) == 0\n+\t       || strcmp (argv[i], \"-E\") == 0\n+\t       || strcmp (argv[i], \"-c\") == 0\n+\t       || strncmp (argv[i], \"-g\", 2 ) == 0\n+\t       || strncmp (argv[i], \"-O\", 2 ) == 0\n+\t       || strcmp (argv[i], \"-save-temps\") == 0\n+\t       || (arg_len > 2 && strncmp (argv[i], \"-I\", 2) == 0)\n+\t       || (arg_len > 2 && strncmp (argv[i], \"-D\", 2) == 0))\n+\t;\n+\n+      /* Unix style file specs and VMS style switches look alike, so assume\n+\t an arg consisting of one and only one slash, and that being first, is\n+\t really a switch.  */\n+      else if ((argv[i][0] == '/') && (strchr (&argv[i][1], '/') == 0))\n+\taddarg (argv[i]);\n+      else\n+\t{\n+\t  /* Assume filename arg */\n+\t  char buff [256], *ptr;\n+\t  int buff_len;\n+\n+\t  ptr = to_host_file_spec (argv[i]);\n+\t  arg_len = strlen (ptr);\n+\n+\t  if (ptr[0] == '[')\n+\t    sprintf (buff, \"%s%s\", cwdev, ptr);\n+\t  else if (strchr (ptr, ':'))\n+\t    sprintf (buff, \"%s\", ptr);\n+\t  else\n+\t    sprintf (buff, \"%s%s\", cwd, ptr);\n+\n+\t  buff_len = strlen (buff);\n+\t  ptr = xmalloc (buff_len + 1);\n+\n+\t  strcpy (ptr, buff);\n+\t  addarg (ptr);\n+\t}\n+    }\n+\n+  addarg (NULL);\n+\n+  if (verbose)\n+    {\n+      int i;\n+\n+      for (i = 0; i < comp_arg_index; i++)\n+\tprintf (\"%s \", comp_args [i]);\n+\n+      putchar ('\\n');\n+    }\n+\n+  {\n+    int i;\n+    int len = 0;\n+\n+    for (i = 0; comp_args[i]; i++)\n+      len = len + strlen (comp_args[i]) + 1;\n+\n+    {\n+      char *allargs = (char *) alloca (len + 1);\n+      Descr cmd;\n+      int status;\n+      int status1 = 1;\n+\n+      for (i = 0; i < len + 1; i++)\n+\tallargs [i] = 0;\n+\n+      for (i = 0; comp_args [i]; i++)\n+\t{\n+\t  strcat (allargs, comp_args [i]);\n+\t  strcat (allargs, \" \");\n+\t}\n+\n+      cmd.adr = allargs;\n+      cmd.len = len;\n+      cmd.mbz = 0;\n+\n+      i = LIB$SPAWN (&cmd, 0, 0, 0, 0, 0, &status);\n+\n+      if ((i & 1) != 1)\n+\t{\n+\t  LIB$SIGNAL (i);\n+\t  exit (1);\n+\t}\n+\n+      if ((status & 1) == 1 && (status1 & 1) == 1)\n+\texit (0);\n+\n+      exit (1);\n+    }\n+  }\n+}\n+\n+static char new_host_filespec [255];\n+static char new_host_dirspec [255];\n+static char filename_buff [256];\n+\n+static int\n+translate_unix (name, type)\n+     char *name;\n+     int type ATTRIBUTE_UNUSED;\n+{\n+  strcpy (filename_buff, name);\n+  return 0;\n+}\n+\n+static char *\n+to_host_dir_spec (dirspec)\n+     char *dirspec;\n+{\n+  int len = strlen (dirspec);\n+\n+  strcpy (new_host_dirspec, dirspec);\n+\n+  if (strchr (new_host_dirspec, ']') || strchr (new_host_dirspec, ':'))\n+    return new_host_dirspec;\n+\n+  while (len > 1 && new_host_dirspec [len-1] == '/')\n+    {\n+      new_host_dirspec [len-1] = 0;\n+      len--;\n+    }\n+\n+  decc$to_vms (new_host_dirspec, translate_unix, 1, 2);\n+  strcpy (new_host_dirspec, filename_buff);\n+\n+  return new_host_dirspec;\n+\n+}\n+\n+static char *\n+to_host_file_spec (filespec)\n+     char *filespec;\n+{\n+  strcpy (new_host_filespec, \"\");\n+  if (strchr (filespec, ']') || strchr (filespec, ':'))\n+    strcpy (new_host_filespec, filespec);\n+  else\n+    {\n+      decc$to_vms (filespec, translate_unix, 1, 1);\n+      strcpy (new_host_filespec, filename_buff);\n+    }\n+\n+  return new_host_filespec;\n+}"}, {"sha": "f28b7c7968784cd58516ad48a2f63e8b547048eb", "filename": "gcc/config/alpha/vms-ld.c", "status": "added", "additions": 762, "deletions": 0, "changes": 762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-ld.c?ref=d133777f5d4f838c9828865086192ed55a3d1c57", "patch": "@@ -0,0 +1,762 @@\n+/* VMS linker wrapper.\n+   Copyright (C) 1996-2001 Free Software Foundation, Inc.\n+   Contributed by Douglas B. Rupp (rupp@gnat.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* This program is a wrapper around the VMS linker.\n+   It translates Unix style command line options into corresponding\n+   VMS style qualifiers and then spawns the VMS linker.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+typedef struct dsc {unsigned short len, mbz; char *adr; } Descr;\n+\n+#undef PATH_SEPARATOR\n+#undef PATH_SEPARATOR_STR\n+#define PATH_SEPARATOR ','\n+#define PATH_SEPARATOR_STR \",\"\n+\n+/* Local variable declarations.  */\n+\n+/* File specification for vms-dwarf2.o.  */\n+static char *vmsdwarf2spec = 0;\n+\n+/* verbose = 1 if -v passed.   */\n+static int verbose = 0;\n+\n+/* save_temps = 1 if -save-temps passed.  */\n+static int save_temps = 0;\n+\n+/* By default don't generate executable file if there are errors\n+   in the link. Override with --noinhibit-exec.  */\n+static int inhibit_exec = 1;\n+\n+/* debug = 1 if -g passed.  */\n+static int debug = 0;\n+\n+/* By default prefer to link with shareable image libraries.\n+   Override with -static.  */\n+static int staticp = 0;\n+\n+/* By default generate an executable, not a shareable image library.\n+   Override with -shared.  */\n+static int share = 0;\n+\n+/* Remember if IDENTIFICATION given on command line.  */\n+static int ident = 0;\n+\n+/* Keep track of arg translations.  */\n+static int link_arg_max = -1;\n+static const char **link_args = 0;\n+static int link_arg_index = -1;\n+\n+/* Keep track of filenames */\n+static char optfilefullname [267];\n+static char *sharefilename = 0;\n+static char *exefilename = 0;\n+\n+/* System search dir list. Leave blank since link handles this\n+   internally.  */\n+static char *system_search_dirs = \"\";\n+\n+/* Search dir list passed on command line (with -L).  */\n+static char *search_dirs;\n+\n+/* Local function declarations.  */\n+\n+/* Add STR to the list of arguments to pass to the linker. Expand the list as\n+   necessary to accomodate.  */\n+static void addarg PARAMS ((const char *));\n+\n+/* Check to see if NAME is a regular file, i.e. not a directory */\n+static int is_regular_file PARAMS ((char *));\n+\n+/* Translate a Unix syntax file specification FILESPEC into VMS syntax.\n+   If indicators of VMS syntax found, return input string. */\n+static char *to_host_file_spec PARAMS ((char *));\n+\n+/* Locate the library named LIB_NAME in the set of paths PATH_VAL. */\n+static char *locate_lib PARAMS ((char *, char *));\n+\n+/* Given a library name NAME, i.e. foo,  Look for libfoo.lib and then\n+   libfoo.a in the set of directories we are allowed to search in.  */\n+static const char *expand_lib PARAMS ((char *));\n+\n+/* Preprocess the number of args P_ARGC in ARGV.\n+   Look for special flags, etc. that must be handled first. */\n+static void preprocess_args PARAMS ((int *, char **));\n+\n+/* Preprocess the number of args P_ARGC in ARGV.  Look for\n+   special flags, etc. that must be handled for the VMS linker. */\n+static void process_args PARAMS ((int *, char **));\n+\n+/* Action routine called by decc$to_vms. NAME is a file name or\n+   directory name. TYPE is unused. */\n+static int translate_unix PARAMS ((char *, int));\n+\n+int main PARAMS ((int, char **));\n+\f\n+static void\n+addarg (str)\n+     const char *str;\n+{\n+  int i;\n+\n+  if (++link_arg_index >= link_arg_max)\n+    {\n+      const char **new_link_args\n+\t= (const char **) xcalloc (link_arg_max + 1000, sizeof (char *));\n+\n+      for (i = 0; i <= link_arg_max; i++)\n+\tnew_link_args [i] = link_args [i];\n+\n+      if (link_args)\n+\tfree (link_args);\n+\n+      link_arg_max += 1000;\n+      link_args = new_link_args;\n+    }\n+\n+  link_args [link_arg_index] = str;\n+}\n+\n+static char *\n+locate_lib (lib_name, path_val)\n+     char *lib_name;\n+     char *path_val;\n+{\n+  int lib_len = strlen (lib_name);\n+  char *eptr, *sptr;\n+\n+  for (sptr = path_val; *sptr; sptr = eptr)\n+    {\n+      char *buf, *ptr;\n+\n+      while (*sptr == PATH_SEPARATOR)\n+\tsptr ++;\n+\n+      eptr = strchr (sptr, PATH_SEPARATOR);\n+      if (eptr == 0)\n+\teptr = strchr (sptr, 0);\n+\n+      buf = alloca ((eptr-sptr) + lib_len + 4 + 2);\n+      strncpy (buf, sptr, eptr-sptr);\n+      buf [eptr-sptr] = 0;\n+      strcat (buf, \"/\");\n+      strcat (buf, lib_name);\n+      ptr = strchr (buf, 0);\n+\n+      if (debug || staticp)\n+\t{\n+\t  /* For debug or static links, look for shareable image libraries\n+\t     last.  */\n+\t  strcpy (ptr, \".a\");\n+\t  if (is_regular_file (buf))\n+\t    return xstrdup (to_host_file_spec (buf));\n+\n+\t  strcpy (ptr, \".olb\");\n+\t  if (is_regular_file (buf))\n+\t    return xstrdup (to_host_file_spec (buf));\n+\n+\t  strcpy (ptr, \".exe\");\n+\t  if (is_regular_file (buf))\n+\t    return xstrdup (to_host_file_spec (buf));\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise look for shareable image libraries first.  */\n+\t  strcpy (ptr, \".exe\");\n+\t  if (is_regular_file (buf))\n+\t    return xstrdup (to_host_file_spec (buf));\n+\n+\t  strcpy (ptr, \".a\");\n+\t  if (is_regular_file (buf))\n+\t    return xstrdup (to_host_file_spec (buf));\n+\n+\t  strcpy (ptr, \".olb\");\n+\t  if (is_regular_file (buf))\n+\t    return xstrdup (to_host_file_spec (buf));\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static const char *\n+expand_lib (name)\n+     char *name;\n+{\n+  char *lib, *lib_path;\n+\n+  if (strcmp (name, \"c\") == 0)\n+    /* IEEE VAX C compatible library for non-prefixed (e.g. no DECC$)\n+       C RTL functions.  */\n+    return \"sys$library:vaxcrtltx.olb\";\n+\n+  else if (strcmp (name, \"m\") == 0)\n+    /* No separate library for math functions */\n+    return \"\";\n+\n+  else\n+    {\n+      lib = xmalloc (strlen (name) + 14);\n+\n+      strcpy (lib, \"lib\");\n+      strcat (lib, name);\n+      lib_path = locate_lib (lib, search_dirs);\n+\n+      if (lib_path)\n+\treturn lib_path;\n+    }\n+\n+  fprintf (stderr,\n+\t   \"Couldn't locate library: lib%s.exe, lib%s.a or lib%s.olb\\n\",\n+\t   name, name, name);\n+\n+  exit (1);\n+}\n+\n+static int\n+is_regular_file (name)\n+     char *name;\n+{\n+  int ret;\n+  struct stat statbuf;\n+\n+  ret = stat (name, &statbuf);\n+  return !ret && S_ISREG (statbuf.st_mode);\n+}\n+\n+static void\n+preprocess_args (p_argc, argv)\n+     int *p_argc;\n+     char **argv;\n+{\n+  int i;\n+\n+  for (i = 1; i < *p_argc; i++)\n+    if (strlen (argv[i]) >= 6 && strncmp (argv[i], \"-shared\", 7) == 0)\n+      share = 1;\n+\n+  for (i = 1; i < *p_argc; i++)\n+    if (strcmp (argv[i], \"-o\") == 0)\n+      {\n+\tchar *buff, *ptr;\n+\tint out_len;\n+\tint len;\n+\n+\ti++;\n+\tptr = to_host_file_spec (argv[i]);\n+\texefilename = xstrdup (ptr);\n+\tout_len = strlen (ptr);\n+\tbuff = xmalloc (out_len + 18);\n+\n+\tif (share)\n+\t  strcpy (buff, \"/share=\");\n+\telse\n+\t  strcpy (buff, \"/exe=\");\n+\n+\tstrcat (buff, ptr);\n+\taddarg (buff);\n+\n+\tif (share)\n+\t  {\n+\t    sharefilename = xmalloc (out_len+5);\n+\t    if (ptr == strchr (argv[i], ']'))\n+\t      strcpy (sharefilename, ++ptr);\n+\t    else if (ptr == strchr (argv[i], ':'))\n+\t      strcpy (sharefilename, ++ptr);\n+\t    else if (ptr == strrchr (argv[i], '/'))\n+\t      strcpy (sharefilename, ++ptr);\n+\t    else\n+\t      strcpy (sharefilename, argv[i]);\n+\n+\t    len = strlen (sharefilename);\n+\t    if (strncasecmp (&sharefilename[len-4], \".exe\", 4) == 0)\n+\t      sharefilename[len-4] = 0;\n+\n+\t    for (ptr = sharefilename; *ptr; ptr++)\n+\t      *ptr = TOUPPER (*ptr);\n+\t  }\n+      }\n+}\n+\n+static void\n+process_args (p_argc, argv)\n+     int *p_argc;\n+     char **argv;\n+{\n+  int i;\n+\n+  for (i = 1; i < *p_argc; i++)\n+    {\n+      if (strlen (argv[i]) < 2)\n+\tcontinue;\n+\n+      if (strncmp (argv[i], \"-L\", 2) == 0)\n+\t{\n+\t  char *nbuff, *ptr;\n+\t  int new_len, search_dirs_len;\n+\n+\t  ptr = &argv[i][2];\n+\t  new_len = strlen (ptr);\n+\t  search_dirs_len = strlen (search_dirs);\n+\n+\t  nbuff = xmalloc (new_len + 1);\n+\t  strcpy (nbuff, ptr);\n+\n+\t  /* Remove trailing slashes.  */\n+\t  while (new_len > 1 && nbuff [new_len - 1] == '/')\n+\t    {\n+\t      nbuff [new_len - 1] = 0;\n+\t      new_len--;\n+\t    }\n+\n+\t  search_dirs = xrealloc (search_dirs, search_dirs_len + new_len + 2);\n+\t  if (search_dirs_len > 0)\n+\t    strcat (search_dirs, PATH_SEPARATOR_STR);\n+\n+\t  strcat (search_dirs, nbuff);\n+\t  free (nbuff);\n+\t}\n+\n+      /* -v turns on verbose option here and is passed on to gcc.  */\n+      else if (strcmp (argv[i], \"-v\") == 0)\n+\tverbose = 1;\n+      else if (strcmp (argv[i], \"-g0\") == 0)\n+\taddarg (\"/notraceback\");\n+      else if (strncmp (argv[i], \"-g\", 2) == 0)\n+\t{\n+\t  addarg (\"/debug\");\n+\t  debug = 1;\n+\t}\n+      else if (strcmp (argv[i], \"-static\") == 0)\n+\tstaticp = 1;\n+      else if (strcmp (argv[i], \"-map\") == 0)\n+\t{\n+\t  char *buff, *ptr;\n+\n+\t  buff = xmalloc (strlen (exefilename) + 5);\n+\t  strcpy (buff, exefilename);\n+\t  ptr = strchr (buff, '.');\n+\t  if (ptr)\n+\t    *ptr = 0;\n+\n+\t  strcat (buff, \".map\");\n+\t  addarg (\"/map=\");\n+\t  addarg (buff);\n+\t  addarg (\"/full\");\n+\t}\n+      else if (strcmp (argv[i], \"-save-temps\") == 0)\n+\tsave_temps = 1;\n+      else if (strcmp (argv[i], \"--noinhibit-exec\") == 0)\n+\tinhibit_exec = 0;\n+    }\n+}\n+\n+/* The main program.  Spawn the VMS linker after fixing up the Unix-like flags\n+   and args to be what the VMS linker wants.  */\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int i;\n+  char cwdev [128], *devptr;\n+  int devlen;\n+  int optfd;\n+  FILE *optfile;\n+  char *cwd = getcwd (0, 1024);\n+  char *optfilename;\n+\n+  devptr = strchr (cwd, ':');\n+  devlen = (devptr - cwd) + 1;\n+  strncpy (cwdev, cwd, devlen);\n+  cwdev [devlen] = '\\0';\n+\n+  search_dirs = xmalloc (strlen (system_search_dirs) + 1);\n+  strcpy (search_dirs, system_search_dirs);\n+\n+  addarg (\"link\");\n+\n+  /* Pass to find args that have to be append first.  */\n+  preprocess_args (&argc , argv);\n+\n+  /* Pass to find the rest of the args.  */\n+  process_args (&argc , argv);\n+\n+  /* Create a temp file to hold args, otherwise we can easily exceed the VMS\n+     command line length limits.  */\n+  optfilename = alloca (strlen (\"LDXXXXXX\") + 1);\n+  strcpy (optfilename, \"LDXXXXXX\");\n+  optfd = mkstemp (optfilename);\n+  getcwd (optfilefullname, 256, 1); /* VMS style cwd.  */\n+  strcat (optfilefullname, optfilename);\n+  strcat (optfilefullname, \".\");\n+  optfile = fdopen (optfd, \"w\");\n+\n+  /* Write out the IDENTIFICATION argument first so that it can be overridden\n+     by an options file.  */\n+  for (i = 1; i < argc; i++)\n+    {\n+      int arg_len = strlen (argv[i]);\n+\n+      if (arg_len > 6 && strncasecmp (argv[i], \"IDENT=\", 6) == 0)\n+\t{\n+\t  /* Comes from command line. If present will always appear before\n+\t     IDENTIFICATION=... and will override.  */\n+\n+\t  if (!ident)\n+\t    ident = 1;\n+\t}\n+      else if (arg_len > 15\n+\t       && strncasecmp (argv[i], \"IDENTIFICATION=\", 15) == 0)\n+\t{\n+\t  /* Comes from pragma Ident ().  */\n+\n+\t  if (!ident)\n+\t    {\n+\t      fprintf (optfile, \"case_sensitive=yes\\n\");\n+\t      fprintf (optfile, \"IDENTIFICATION=\\\"%15.15s\\\"\\n\", &argv[i][15]);\n+\t      fprintf (optfile, \"case_sensitive=NO\\n\");\n+\t      ident = 1;\n+\t    }\n+\t}\n+    }\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      int arg_len = strlen (argv[i]);\n+\n+      if (strcmp (argv[i], \"-o\") == 0)\n+\ti++;\n+      else if (arg_len > 2 && strncmp (argv[i], \"-l\", 2) == 0)\n+\t{\n+\t  const char *libname = expand_lib (&argv[i][2]);\n+\t  const char *ext;\n+\t  int len;\n+\n+\t  if ((len = strlen (libname)) > 0)\n+\t    {\n+\t      char buff [256];\n+\n+\t      if (len > 4 && strcasecmp (&libname [len-4], \".exe\") == 0)\n+\t\text = \"/shareable\";\n+\t      else\n+\t\text = \"/library\";\n+\n+\t      if (libname[0] == '[')\n+\t\tsprintf (buff, \"%s%s\", cwdev, libname);\n+\t      else\n+\t\tsprintf (buff, \"%s\", libname);\n+\n+\t      fprintf (optfile, \"%s%s\\n\", buff, ext);\n+\t    }\n+\t}\n+\n+      else if (strcmp (argv[i], \"-v\" ) == 0\n+\t       || strncmp (argv[i], \"-g\", 2 ) == 0\n+\t       || strcmp (argv[i], \"-static\" ) == 0\n+\t       || strcmp (argv[i], \"-map\" ) == 0\n+\t       || strcmp (argv[i], \"-save-temps\") == 0\n+\t       || strcmp (argv[i], \"--noinhibit-exec\") == 0\n+\t       || (arg_len > 2 && strncmp (argv[i], \"-L\", 2) == 0)\n+\t       || (arg_len >= 6 && strncmp (argv[i], \"-share\", 6) == 0))\n+\t;\n+      else if (arg_len > 1 && argv[i][0] == '@')\n+\t{\n+\t  FILE *atfile;\n+\t  char *ptr, *ptr1;\n+\t  struct stat statbuf;\n+\t  char *buff;\n+\t  int len;\n+\n+\t  if (stat (&argv[i][1], &statbuf))\n+\t    {\n+\t      fprintf (stderr, \"Couldn't open linker response file: %s\\n\",\n+\t\t       &argv[i][1]);\n+\t      exit (1);\n+\t    }\n+\n+\t  buff = xmalloc (statbuf.st_size + 1);\n+\t  atfile = fopen (&argv[i][1], \"r\");\n+\t  fgets (buff, statbuf.st_size + 1, atfile);\n+\t  fclose (atfile);\n+\n+\t  len = strlen (buff);\n+\t  if (buff [len - 1] == '\\n')\n+\t    {\n+\t      buff [len - 1] = 0;\n+\t      len--;\n+\t    }\n+\n+\t  ptr = buff;\n+\n+\t  do\n+\t  {\n+\t     ptr1 = strchr (ptr, ' ');\n+\t     if (ptr1)\n+\t       *ptr1 = 0;\n+\t     ptr = to_host_file_spec (ptr);\n+\t     if (ptr[0] == '[')\n+\t       fprintf (optfile, \"%s%s\\n\", cwdev, ptr);\n+\t     else\n+\t       fprintf (optfile, \"%s\\n\", ptr);\n+\t     ptr = ptr1 + 1;\n+\t  } while (ptr1);\n+\t}\n+\n+      /* Unix style file specs and VMS style switches look alike, so assume an\n+\t arg consisting of one and only one slash, and that being first, is\n+\t really a switch.  */\n+      else if ((argv[i][0] == '/') && (strchr (&argv[i][1], '/') == 0))\n+\taddarg (argv[i]);\n+      else if (arg_len > 4\n+\t       && strncasecmp (&argv[i][arg_len-4], \".OPT\", 4) == 0)\n+\t{\n+\t  FILE *optfile1;\n+\t  char buff [256];\n+\n+\t  optfile1 = fopen (argv[i], \"r\");\n+\t  while (fgets (buff, 256, optfile1))\n+\t    fputs (buff, optfile);\n+\n+\t  fclose (optfile1);\n+\t}\n+      else if (arg_len > 7 && strncasecmp (argv[i], \"GSMATCH\", 7) == 0)\n+\tfprintf (optfile, \"%s\\n\", argv[i]);\n+      else if (arg_len > 6 && strncasecmp (argv[i], \"IDENT=\", 6) == 0)\n+\t{\n+\t  /* Comes from command line and will override pragma.  */\n+\t  fprintf (optfile, \"case_sensitive=yes\\n\");\n+\t  fprintf (optfile, \"IDENT=\\\"%15.15s\\\"\\n\", &argv[i][6]);\n+\t  fprintf (optfile, \"case_sensitive=NO\\n\");\n+\t  ident = 1;\n+\t}\n+      else if (arg_len > 15\n+\t       && strncasecmp (argv[i], \"IDENTIFICATION=\", 15) == 0)\n+\t;\n+      else\n+\t{\n+\t  /* Assume filename arg.  */\n+\t  const char *addswitch = \"\";\n+\t  char buff [256];\n+\t  int buff_len;\n+\t  int is_cld = 0;\n+\n+\t  argv[i] = to_host_file_spec (argv[i]);\n+\t  arg_len = strlen (argv[i]);\n+\n+\t  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], \".exe\") == 0)\n+\t    addswitch = \"/shareable\";\n+\n+\t  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], \".cld\") == 0)\n+\t    {\n+\t      addswitch = \"/shareable\";\n+\t      is_cld = 1;\n+\t    }\n+\n+\t  if (arg_len > 2 && strcasecmp (&argv[i][arg_len-2], \".a\") == 0)\n+\t    addswitch = \"/lib\";\n+\n+\t  if (arg_len > 4 && strcasecmp (&argv[i][arg_len-4], \".olb\") == 0)\n+\t    addswitch = \"/lib\";\n+\n+\t  if (argv[i][0] == '[')\n+\t    sprintf (buff, \"%s%s%s\\n\", cwdev, argv[i], addswitch);\n+\t  else if (strchr (argv[i], ':'))\n+\t    sprintf (buff, \"%s%s\\n\", argv[i], addswitch);\n+\t  else\n+\t    sprintf (buff, \"%s%s%s\\n\", cwd, argv[i], addswitch);\n+\n+\t  buff_len = strlen (buff);\n+\n+\t  if (buff_len >= 13\n+\t      && strcasecmp (&buff[buff_len-13],\"vms-dwarf2.o\\n\") == 0)\n+\t    vmsdwarf2spec = xstrdup (buff);\n+\t  else if (is_cld)\n+\t    {\n+\t      addarg (buff);\n+\t      addarg (\",\");\n+\t    }\n+\t  else\n+\t    fprintf (optfile, buff);\n+\t}\n+    }\n+\n+#if 0\n+  if (share)\n+    fprintf (optfile, \"symbol_vector=(main=procedure)\\n\");\n+#endif\n+\n+  if (debug && vmsdwarf2spec)\n+    {\n+      fprintf (optfile, \"case_sensitive=yes\\n\");\n+      fprintf (optfile, \"cluster=DWARF2debug,,,%s\", vmsdwarf2spec);\n+      fprintf (optfile, \"collect=DWARF2debug,debug_abbrev,debug_aranges,-\\n\");\n+      fprintf (optfile, \" debug_frame,debug_info,debug_line,debug_loc,-\\n\");\n+      fprintf (optfile,\n+\t       \" debug_macinfo,debug_pubnames,debug_str,debug_zzzzzz\\n\");\n+      fprintf (optfile, \"case_sensitive=NO\\n\");\n+    }\n+\n+  if (debug && share)\n+    {\n+      fprintf (optfile, \"case_sensitive=yes\\n\");\n+      fprintf (optfile, \"symbol_vector=(-\\n\");\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_ABBREV/$dwarf2.debug_abbrev=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_ARANGES/$dwarf2.debug_aranges=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_FRAME/$dwarf2.debug_frame=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_INFO/$dwarf2.debug_info=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_LINE/$dwarf2.debug_line=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_LOC/$dwarf2.debug_loc=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_MACINFO/$dwarf2.debug_macinfo=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_PUBNAMES/$dwarf2.debug_pubnames=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_STR/$dwarf2.debug_str=DATA,-\\n\",\n+\t       sharefilename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_ZZZZZZ/$dwarf2.debug_zzzzzz=DATA)\\n\",\n+\t       sharefilename);\n+      fprintf (optfile, \"case_sensitive=NO\\n\");\n+    }\n+\n+  fclose (optfile);\n+  addarg (optfilefullname);\n+  addarg (\"/opt\");\n+\n+  addarg (NULL);\n+\n+  if (verbose)\n+    {\n+      int i;\n+\n+      for (i = 0; i < link_arg_index; i++)\n+\tprintf (\"%s \", link_args [i]);\n+      putchar ('\\n');\n+    }\n+\n+  {\n+    int i;\n+    int len = 0;\n+\n+    for (i = 0; link_args[i]; i++)\n+      len = len + strlen (link_args[i]) + 1;\n+\n+    {\n+      char *allargs = (char *) alloca (len + 1);\n+      Descr cmd;\n+      int status;\n+      int status1 = 1;\n+\n+      for (i = 0; i < len + 1; i++)\n+\tallargs [i] = 0;\n+\n+      for (i = 0; link_args [i]; i++)\n+\t{\n+\t  strcat (allargs, link_args [i]);\n+\t  strcat (allargs, \" \");\n+\t}\n+\n+      cmd.adr = allargs;\n+      cmd.len = len;\n+      cmd.mbz = 0;\n+\n+      i = LIB$SPAWN (&cmd, 0, 0, 0, 0, 0, &status);\n+      if ((i & 1) != 1)\n+\t{\n+\t  LIB$SIGNAL (i);\n+\t  exit (1);\n+\t}\n+\n+      if (debug && !share)\n+\t{\n+\t  strcpy (allargs, \"@gnu:[bin]set_exe \");\n+\t  strcat (allargs, exefilename);\n+\t  strcat (allargs, \" /nodebug /silent\");\n+\t  len = strlen (allargs);\n+\t  cmd.adr = allargs;\n+\t  cmd.len = len;\n+\t  cmd.mbz = 0;\n+\n+\t  if (verbose)\n+\t    printf (allargs);\n+\n+\t  i = LIB$SPAWN (&cmd, 0, 0, 0, 0, 0, &status1);\n+\n+\t  if ((i & 1) != 1)\n+\t    {\n+\t      LIB$SIGNAL (i);\n+\t      exit (1);\n+\t    }\n+\t}\n+\n+      if (!save_temps)\n+\tremove (optfilefullname);\n+\n+      if ((status & 1) == 1 && (status1 & 1) == 1)\n+\texit (0);\n+\n+      if (exefilename && inhibit_exec == 1)\n+\tremove (exefilename);\n+\n+      exit (1);\n+    }\n+  }\n+}\n+\n+static char new_host_filespec [255];\n+static char filename_buff [256];\n+\n+static int\n+translate_unix (name, type)\n+     char *name;\n+     int type ATTRIBUTE_UNUSED;\n+{\n+  strcpy (filename_buff, name);\n+  return 0;\n+}\n+\n+static char *\n+to_host_file_spec (filespec)\n+     char *filespec;\n+{\n+  strcpy (new_host_filespec, \"\");\n+  if (strchr (filespec, ']') || strchr (filespec, ':'))\n+    strcpy (new_host_filespec, filespec);\n+  else\n+    {\n+      decc$to_vms (filespec, translate_unix, 1, 1);\n+      strcpy (new_host_filespec, filename_buff);\n+    }\n+\n+  return new_host_filespec;\n+}"}, {"sha": "49338c152b635851df072038e8a2dc092815918e", "filename": "gcc/config/alpha/x-vms", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig%2Falpha%2Fx-vms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d133777f5d4f838c9828865086192ed55a3d1c57/gcc%2Fconfig%2Falpha%2Fx-vms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fx-vms?ref=d133777f5d4f838c9828865086192ed55a3d1c57", "patch": "@@ -0,0 +1,11 @@\n+vms-ld.o : $(srcdir)/config/alpha/vms-ld.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+ld.exe : vms-ld.o\n+\t$(CC) -o $@ vms-ld.o ../libiberty/libiberty.a\n+\n+vms-cc.o : $(srcdir)/config/alpha/vms-cc.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+decc.exe : vms-cc.o\n+\t$(CC) -o $@ vms-cc.o ../libiberty/libiberty.a\n+\n+EXTRA_PROGRAMS=ld.exe decc.exe"}]}