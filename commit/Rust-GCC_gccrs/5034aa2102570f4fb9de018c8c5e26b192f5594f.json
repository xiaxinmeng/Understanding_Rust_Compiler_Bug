{"sha": "5034aa2102570f4fb9de018c8c5e26b192f5594f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAzNGFhMjEwMjU3MGY0ZmI5ZGUwMThjOGM1ZTI2YjE5MmY1NTk0Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-07-30T18:13:15Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-07-30T18:13:15Z"}, "message": "2013-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tRevert last commit.\n\nFrom-SVN: r201348", "tree": {"sha": "82af70bc7df065ad38707ff2e93639da96eb034e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82af70bc7df065ad38707ff2e93639da96eb034e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5034aa2102570f4fb9de018c8c5e26b192f5594f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5034aa2102570f4fb9de018c8c5e26b192f5594f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5034aa2102570f4fb9de018c8c5e26b192f5594f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5034aa2102570f4fb9de018c8c5e26b192f5594f/comments", "author": null, "committer": null, "parents": [{"sha": "bd459a6121641c159e7830e7e3905842e1e5a20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd459a6121641c159e7830e7e3905842e1e5a20a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd459a6121641c159e7830e7e3905842e1e5a20a"}], "stats": {"total": 610, "additions": 206, "deletions": 404}, "files": [{"sha": "29b98e4ae7fd4dbae1c0a607d5197f3c90e42d27", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -1,3 +1,7 @@\n+2013-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tRevert last commit.\n+\n 2013-07-30  Tim Shen  <timshen91@gmail.com>\n \n \tThompson matcher refactored. Fix grouping problem.\n@@ -12,8 +16,8 @@\n \tFor both matchers.\n \t* testsuite/28_regex/algorithms/regex_match/extended/57173.cc:\n \tFor both matchers.\n-\t* testsuite/28_regex/algorithms/regex_match/extended/string_dispatch_01.cc:\n-\tNew.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tstring_dispatch_01.cc: New.\n \n 2013-07-29  Nathan Froyd  <froydnj@gcc.gnu.org>\n "}, {"sha": "569284847855936afb8ebbdd4322f06b22413c4f", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -2175,7 +2175,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool\n     regex_match(_Bi_iter                                 __s,\n                 _Bi_iter                                 __e,\n-                match_results<_Bi_iter, _Alloc>&         __m,\n+                match_results<_Bi_iter, _Alloc>&     __m,\n                 const basic_regex<_Ch_type, _Rx_traits>& __re,\n                 regex_constants::match_flag_type         __flags\n                                = regex_constants::match_default)\n@@ -2184,7 +2184,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __detail::_Automaton::_SizeT __sz = __a->_M_sub_count();\n       __detail::_SpecializedCursor<_Bi_iter> __cs(__s, __e);\n       __detail::_SpecializedResults<_Bi_iter, _Alloc> __r(__sz, __cs, __m);\n-      return __a->_M_get_matcher(__cs, __r, __a, __flags)->_M_match();\n+      __detail::_Grep_matcher __matcher(__cs, __r, __a, __flags);\n+      return __matcher._M_dfs_match();\n     }\n \n   /**\n@@ -2335,8 +2336,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       for (auto __cur = __first; __cur != __last; ++__cur) // Any KMP-like algo?\n         {\n           __detail::_SpecializedCursor<_Bi_iter> __curs(__cur, __last);\n-          auto __matcher = __a->_M_get_matcher(__curs, __r, __a, __flags);\n-          if (__matcher->_M_search_from_first())\n+          __detail::_Grep_matcher __matcher(__curs, __r, __a, __flags);\n+          if (__matcher._M_dfs_search_from_first())\n             {\n               __r._M_set_range(__m.size(),\n                                __detail::_SpecializedCursor<_Bi_iter>"}, {"sha": "dae0948404c7c2ad64b7a639775409862d1c6d7c", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -936,8 +936,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (_M_match_token(_ScannerT::_S_token_backref))\n \t{\n \t  // __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n-          _M_state_store._M_set_back_ref(true);\n-\t  //return true;\n+\t  return true;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n \t{"}, {"sha": "8686cc933be38e1243bfbd17b8eca28c078a9527", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.h", "status": "modified", "additions": 25, "deletions": 126, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -60,19 +60,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t  const _SpecializedCursor<_FwdIterT>& __cursor,\n \t\t\t  match_results<_FwdIterT, _Alloc>& __m);\n \n-      ~_SpecializedResults()\n-      {\n-        if (_M_managed)\n-          delete &_M_results;\n-      }\n-\n-    private:\n-      _SpecializedResults(const _SpecializedResults& __rhs)\n-      : _M_results(*new match_results<_FwdIterT, _Alloc>(__rhs._M_results)),\n-      _M_managed(true)\n-      { }\n-\n-    public:\n       void\n       _M_set_pos(int __i, int __j, const _PatternCursor& __pc);\n \n@@ -89,28 +76,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_set_matched(int __i, bool __is_matched)\n       { _M_results.at(__i).matched = __is_matched; }\n \n-      std::unique_ptr<_Results>\n-      _M_clone() const\n-      { return unique_ptr<_Results>(new _SpecializedResults(*this)); }\n-\n-      void\n-      _M_assign(const _Results& __rhs)\n-      {\n-        auto __r = static_cast<const _SpecializedResults*>(&__rhs);\n-        _M_results = __r->_M_results;\n-      }\n-\n     private:\n       match_results<_FwdIterT, _Alloc>& _M_results;\n-      bool                              _M_managed;\n     };\n \n   template<typename _FwdIterT, typename _Alloc>\n     _SpecializedResults<_FwdIterT, _Alloc>::\n     _SpecializedResults(const _Automaton::_SizeT __size,\n     \t\t\tconst _SpecializedCursor<_FwdIterT>& __cursor,\n                         match_results<_FwdIterT, _Alloc>& __m)\n-    : _M_results(__m), _M_managed(false)\n+    : _M_results(__m)\n     {\n       _M_results.clear();\n       _M_results.reserve(__size + 2);\n@@ -130,11 +105,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef const _SpecializedCursor<_FwdIterT>& _CursorT;\n       _CursorT __c = static_cast<_CursorT>(__pc);\n       if (__j == 0)\n-        _M_results.at(__i).first = __c._M_pos();\n+\t_M_results.at(__i).first = __c._M_pos();\n       else\n         _M_results.at(__i).second = __c._M_pos();\n     }\n \n+  /// A stack of states used in evaluating the NFA.\n+  typedef std::stack<_StateIdT, std::vector<_StateIdT> > _StateStack;\n+\n   /// Executes a regular expression NFA/DFA over a range using a\n   /// variant of the parallel execution algorithm featured in the grep\n   /// utility, modified to use Laurikari tags.\n@@ -146,126 +124,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                   const _AutomatonPtr&              __automaton,\n                   regex_constants::match_flag_type  __flags)\n     : _M_nfa(static_pointer_cast<_Nfa>(__automaton)),\n-      _M_str_cur(__p), _M_results(__r)\n-    { }\n-\n-    virtual\n-    ~_Grep_matcher()\n+      _M_pattern(__p), _M_results(__r)\n     { }\n \n     // Set matched when string exactly match the pattern.\n-    virtual bool\n-    _M_match() = 0;\n+    void\n+    _M_match();\n \n     // Set matched when some prefix of the string matches the pattern.\n-    virtual bool\n-    _M_search_from_first() = 0;\n-\n-  protected:\n-    const std::shared_ptr<_Nfa>        _M_nfa;\n-    _PatternCursor&                    _M_str_cur;\n-    _Results&                          _M_results;\n-  };\n-\n-  // Time complexity: exponential\n-  // Space complexity: O(_M_str_cur.size())\n-  // _M_dfs() take a state, along with current string cursor(_M_str_cur),\n-  // trying to match current state with current character.\n-  // Only _S_opcode_match will consume a character.\n-  class _DFSMatcher\n-  : public _Grep_matcher\n-  {\n-  public:\n-    _DFSMatcher(_PatternCursor&                   __p,\n-                _Results&                         __r,\n-                const _AutomatonPtr&              __automaton,\n-                regex_constants::match_flag_type  __flags)\n-    : _Grep_matcher(__p, __r, __automaton, __flags)\n-    { }\n+    void\n+    _M_search_from_first();\n \n+    // TODO: in the future this function will be _M_match, in another class.\n     bool\n-    _M_match()\n+    _M_dfs_match()\n     { return _M_dfs<true>(_M_nfa->_M_start()); }\n \n+    // TODO: in the future this function will be _M_search_from_first,\n+    // in another class.\n     bool\n-    _M_search_from_first()\n+    _M_dfs_search_from_first()\n     { return _M_dfs<false>(_M_nfa->_M_start()); }\n \n   private:\n-    template<bool __match_mode>\n-      bool\n-      _M_dfs(_StateIdT __i);\n-  };\n-\n-  // It's essentially a variant of Single-Source-Shortest-Path problem, where,\n-  // the matching results is the final distance and should be minimized.\n-  // Instead of using Dijkstra Algorithm, I pick up the queue-optimizaed\n-  // (BFS-like) Bellman-Ford algorithm,\n-  // SPFA(http://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm).\n-  //\n-  // Every entry of _M_current saves the solution(grouping status) for every\n-  // matching head. When states transfer, solutions will be compared and\n-  // deduplicated(based on which greedy mode we have).\n-  //\n-  // Time complexity: O(_M_str_cur.size() * _M_nfa.size())\n-  // Space complexity: O(_M_nfa.size() * _M_nfa.mark_count())\n-  class _BFSMatcher\n-  : public _Grep_matcher\n-  {\n-  public:\n-    _BFSMatcher(_PatternCursor&                   __p,\n-                _Results&                         __r,\n-                const _AutomatonPtr&              __automaton,\n-                regex_constants::match_flag_type  __flags)\n-    : _Grep_matcher(__p, __r, __automaton, __flags)\n-    {\n-      if (_M_nfa->_M_start() != _S_invalid_state_id)\n-        _M_current[_M_nfa->_M_start()] = _M_results._M_clone();\n-      _M_e_closure();\n-    }\n+    _StateSet\n+    _M_e_closure(_StateIdT __i);\n \n-    bool\n-    _M_match()\n-    { return _M_main_loop<true>(); }\n+    _StateSet\n+    _M_e_closure(const _StateSet& __s);\n \n-    bool\n-    _M_search_from_first()\n-    { return _M_main_loop<false>(); }\n+    _StateSet\n+    _M_e_closure(_StateStack& __stack, const _StateSet& __s);\n \n-  private:\n     template<bool __match_mode>\n       bool\n-      _M_main_loop();\n-\n-    void\n-    _M_e_closure();\n-\n-    void\n-    _M_move();\n-\n-    bool\n-    _M_match_less_than(_StateIdT __u, _StateIdT __v) const;\n-\n-    bool\n-    _M_includes_some() const;\n+      _M_dfs(_StateIdT __i);\n \n-    std::map<_StateIdT, std::unique_ptr<_Results>>     _M_current;\n+    const std::shared_ptr<_Nfa>        _M_nfa;\n+    _PatternCursor&                    _M_pattern;\n+    _Results&                          _M_results;\n   };\n \n-  std::unique_ptr<_Grep_matcher> _Nfa::\n-  _M_get_matcher(_PatternCursor&                   __p,\n-                 _Results&                         __r,\n-                 const _AutomatonPtr&              __a,\n-                 regex_constants::match_flag_type  __flags)\n-  {\n-    if (_M_has_back_ref)\n-      return unique_ptr<_Grep_matcher>(\n-        new _DFSMatcher(__p, __r, __a, __flags));\n-    else\n-      return unique_ptr<_Grep_matcher>(\n-        new _BFSMatcher(__p, __r, __a, __flags));\n-  }\n-\n  //@} regex-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail"}, {"sha": "dccdfda0bc18651611c95ffac7ec1ae6a7a08bf8", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.tcc", "status": "modified", "additions": 141, "deletions": 117, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -32,13 +32,83 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n+namespace\n+{\n+  // A stack of states used in evaluating the NFA.\n+  typedef std::stack<std::__detail::_StateIdT,\n+                     std::vector<std::__detail::_StateIdT>\n+\t\t     > _StateStack;\n+\n+  // Obtains the next state set given the current state set __s and the current\n+  // input character.\n+  inline std::__detail::_StateSet\n+  __move(const std::__detail::_PatternCursor& __p,\n+         const std::__detail::_Nfa& __nfa,\n+         const std::__detail::_StateSet& __s)\n+  {\n+    std::__detail::_StateSet __m;\n+    for (std::__detail::_StateSet::const_iterator __i = __s.begin();\n+\t __i != __s.end(); ++__i)\n+      {\n+\tif (*__i == std::__detail::_S_invalid_state_id)\n+\t  continue;\n+\n+\tconst std::__detail::_State& __state = __nfa[*__i];\n+\tif (__state._M_opcode == std::__detail::_S_opcode_match\n+\t    && __state._M_matches(__p))\n+\t  __m.insert(__state._M_next);\n+      }\n+    return __m;\n+  }\n+\n+  // returns true if (__s intersect __t) is not empty\n+  inline bool\n+  __includes_some(const std::__detail::_StateSet& __s,\n+                  const std::__detail::_StateSet& __t)\n+  {\n+    if (__s.size() > 0 && __t.size() > 0)\n+      {\n+\tstd::__detail::_StateSet::const_iterator __first = __s.begin();\n+\tstd::__detail::_StateSet::const_iterator __second = __t.begin();\n+\twhile (__first != __s.end() && __second != __t.end())\n+\t  {\n+\t    if (*__first < *__second)\n+\t      ++__first;\n+\t    else if (*__second < *__first)\n+\t      ++__second;\n+\t    else\n+\t      return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  // If an identified state __u is not already in the current state set __e,\n+  // insert it and push it on the current state stack __s.\n+  inline void\n+  __add_visited_state(const std::__detail::_StateIdT __u,\n+                      _StateStack&                  __s,\n+                      std::__detail::_StateSet&      __e)\n+  {\n+    if (__e.count(__u) == 0)\n+      {\n+\t__e.insert(__u);\n+\t__s.push(__u);\n+      }\n+  }\n+\n+} // anonymous namespace\n+\n namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  // _M_dfs() take a state, along with current string cursor(_M_pattern),\n+  // trying to match current state with current character.\n+  // Only _S_opcode_match will consume a character.\n   // TODO: This is too slow. Try to compile the NFA to a DFA.\n   template<bool __match_mode>\n-    bool _DFSMatcher::\n+    bool _Grep_matcher::\n     _M_dfs(_StateIdT __i)\n     {\n       if (__i == _S_invalid_state_id)\n@@ -56,162 +126,116 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n             || _M_dfs<__match_mode>(__state._M_next);\n           break;\n         case _S_opcode_subexpr_begin:\n-          __state._M_tagger(_M_str_cur, _M_results);\n+          __state._M_tagger(_M_pattern, _M_results);\n           __ret = _M_dfs<__match_mode>(__state._M_next);\n           break;\n         case _S_opcode_subexpr_end:\n-          __state._M_tagger(_M_str_cur, _M_results);\n+          __state._M_tagger(_M_pattern, _M_results);\n           __ret = _M_dfs<__match_mode>(__state._M_next);\n           _M_results._M_set_matched(__state._M_subexpr, __ret);\n           break;\n         case _S_opcode_match:\n-          if (!_M_str_cur._M_at_end() && __state._M_matches(_M_str_cur))\n+          if (!_M_pattern._M_at_end() && __state._M_matches(_M_pattern))\n             {\n-              _M_str_cur._M_next();\n+              _M_pattern._M_next();\n               __ret = _M_dfs<__match_mode>(__state._M_next);\n-              _M_str_cur._M_prev();\n+              _M_pattern._M_prev();\n             }\n           break;\n         case _S_opcode_accept:\n           if (__match_mode)\n-            __ret = _M_str_cur._M_at_end();\n+            __ret = _M_pattern._M_at_end();\n           else\n             __ret = true;\n           break;\n         default:\n-          _GLIBCXX_DEBUG_ASSERT(false);\n+          _GLIBCXX_DEBUG_ASSERT( false );\n         }\n       return __ret;\n     }\n \n-  template<bool __match_mode>\n-    bool _BFSMatcher::\n-    _M_main_loop()\n-    {\n-      while (!_M_str_cur._M_at_end())\n-        {\n-          if (!__match_mode)\n-            if (_M_includes_some())\n-              return true;\n-          _M_move();\n-          _M_str_cur._M_next();\n-          _M_e_closure();\n-        }\n-      return _M_includes_some();\n-    }\n-\n-  // The SPFA approach.\n-  void _BFSMatcher::\n-  _M_e_closure()\n+  inline void _Grep_matcher::\n+  _M_match()\n   {\n-    std::queue<_StateIdT> __q;\n-    std::vector<bool> __in_q(_M_nfa->size(), false);\n-    for (auto& __it : _M_current)\n-      {\n-        __in_q[__it.first] = true;\n-        __q.push(__it.first);\n-      }\n-    while (!__q.empty())\n-      {\n-        auto __u = __q.front();\n-        __q.pop();\n-        __in_q[__u] = false;\n-        const auto& __state = (*_M_nfa)[__u];\n+    __detail::_StateSet __t = this->_M_e_closure(_M_nfa->_M_start());\n+    for (; !_M_pattern._M_at_end(); _M_pattern._M_next())\n+      __t = this->_M_e_closure(__move(_M_pattern, *_M_nfa, __t));\n \n-        // Can be implemented using method, but there're too much arguments.\n-        auto __add_visited_state = [&](_StateIdT __v)\n-        {\n-          if (__v == _S_invalid_state_id)\n-            return;\n-          if (_M_match_less_than(__u, __v))\n-            {\n-              _M_current[__v] = _M_current[__u]->_M_clone();\n-              // if a state is updated, it's outgoing neighbors should be\n-              // reconsidered too. Push them to the queue.\n-              if (!__in_q[__v])\n-                {\n-                  __in_q[__v] = true;\n-                  __q.push(__v);\n-                }\n-            }\n-        };\n+    _M_results._M_set_matched(0,\n+                              __includes_some(_M_nfa->_M_final_states(), __t));\n+  }\n \n-        switch (__state._M_opcode)\n+  inline void _Grep_matcher::\n+  _M_search_from_first()\n+  {\n+    __detail::_StateSet __t = this->_M_e_closure(_M_nfa->_M_start());\n+    for (; !_M_pattern._M_at_end(); _M_pattern._M_next())\n+      {\n+        if (__includes_some(_M_nfa->_M_final_states(), __t)) // KISS\n           {\n-            case _S_opcode_alternative:\n-              __add_visited_state(__state._M_next);\n-              __add_visited_state(__state._M_alt);\n-              break;\n-            case _S_opcode_subexpr_begin:\n-              __state._M_tagger(_M_str_cur, *_M_current[__u]);\n-              __add_visited_state(__state._M_next);\n-              break;\n-            case _S_opcode_subexpr_end:\n-              __state._M_tagger(_M_str_cur, *_M_current[__u]);\n-              _M_current[__u]->_M_set_matched(__state._M_subexpr, true);\n-              __add_visited_state(__state._M_next);\n-              break;\n-            case _S_opcode_match:\n-              break;\n-            case _S_opcode_accept:\n-              __add_visited_state(__state._M_next);\n-              break;\n-            default:\n-              _GLIBCXX_DEBUG_ASSERT(false);\n+            _M_results._M_set_matched(0, true);\n+            return;\n           }\n+        __t = this->_M_e_closure(__move(_M_pattern, *_M_nfa, __t));\n       }\n+    _M_results._M_set_matched(0, false);\n   }\n \n-  void _BFSMatcher::\n-  _M_move()\n+  // Creates the e-closure set for the initial state __i.\n+  inline _StateSet _Grep_matcher::\n+  _M_e_closure(_StateIdT __i)\n   {\n-    decltype(_M_current) __next;\n-    for (auto& __it : _M_current)\n-      {\n-        const auto& __state = (*_M_nfa)[__it.first];\n-        if (__state._M_opcode == _S_opcode_match\n-            && __state._M_matches(_M_str_cur))\n-          if (_M_match_less_than(__it.first, __state._M_next)\n-              && __state._M_next != _S_invalid_state_id)\n-            __next[__state._M_next] = __it.second->_M_clone();\n-      }\n-    _M_current = move(__next);\n+    _StateSet __s;\n+    __s.insert(__i);\n+    _StateStack __stack;\n+    __stack.push(__i);\n+    return this->_M_e_closure(__stack, __s);\n   }\n \n-  bool _BFSMatcher::\n-  _M_match_less_than(_StateIdT __u, _StateIdT __v) const\n+  // Creates the e-closure set for an arbitrary state set __s.\n+  inline _StateSet _Grep_matcher::\n+  _M_e_closure(const _StateSet& __s)\n   {\n-    if (_M_current.count(__u) == 0)\n-      return false;\n-    if (_M_current.count(__v) > 0)\n-      return true;\n-    // TODO: Greedy and Non-greedy support\n-    return true;\n+    _StateStack __stack;\n+    for (_StateSet::const_iterator __i = __s.begin(); __i != __s.end(); ++__i)\n+      __stack.push(*__i);\n+    return this->_M_e_closure(__stack, __s);\n   }\n \n-  bool _BFSMatcher::\n-  _M_includes_some() const\n+  inline _StateSet _Grep_matcher::\n+  _M_e_closure(_StateStack& __stack, const _StateSet& __s)\n   {\n-    auto& __s = _M_nfa->_M_final_states();\n-    auto& __t = _M_current;\n-    if (__s.size() > 0 && __t.size() > 0)\n+    _StateSet __e = __s;\n+    while (!__stack.empty())\n       {\n-\tauto __first = __s.begin();\n-\tauto __second = __t.begin();\n-\twhile (__first != __s.end() && __second != __t.end())\n+\t_StateIdT __t = __stack.top(); __stack.pop();\n+\tif (__t == _S_invalid_state_id)\n+\t  continue;\n+\t// for each __u with edge from __t to __u labeled e do ...\n+\tconst _State& __state = _M_nfa->operator[](__t);\n+\tswitch (__state._M_opcode)\n \t  {\n-\t    if (*__first < __second->first)\n-\t      ++__first;\n-\t    else if (__second->first < *__first)\n-\t      ++__second;\n-\t    else\n-              {\n-                _M_results._M_assign(*__second->second);\n-                return true;\n-              }\n+\t  case _S_opcode_alternative:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    __add_visited_state(__state._M_alt, __stack, __e);\n+\t    break;\n+\t  case _S_opcode_subexpr_begin:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    __state._M_tagger(_M_pattern, _M_results);\n+\t    break;\n+\t  case _S_opcode_subexpr_end:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    __state._M_tagger(_M_pattern, _M_results);\n+\t    _M_results._M_set_matched(__state._M_subexpr, true);\n+\t    break;\n+\t  case _S_opcode_accept:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    break;\n+\t  default:\n+\t    break;\n \t  }\n       }\n-    return false;\n+    return __e;\n   }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "fc30237436a7c271e5e262193658a2c3994850f6", "filename": "libstdc++-v3/include/bits/regex_nfa.h", "status": "modified", "additions": 12, "deletions": 38, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -39,24 +39,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-  /// Provides a generic facade for a templated match_results.\n-  struct _Results\n-  {\n-    virtual\n-    ~_Results()\n-    { }\n-    virtual void _M_set_pos(int __i, int __j, const _PatternCursor& __p) = 0;\n-    virtual void _M_set_matched(int __i, bool __is_matched) = 0;\n-    virtual std::unique_ptr<_Results> _M_clone() const = 0;\n-    virtual void _M_assign(const _Results& __rhs) = 0;\n-  };\n-\n-  class _Grep_matcher;\n-  class _Automaton;\n-\n-  /// Generic shared pointer to an automaton.\n-  typedef std::shared_ptr<_Automaton> _AutomatonPtr;\n-\n   /// Base class for, um, automata.  Could be an NFA or a DFA.  Your choice.\n   class _Automaton\n   {\n@@ -70,18 +52,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     virtual _SizeT\n     _M_sub_count() const = 0;\n \n-    virtual std::unique_ptr<_Grep_matcher>\n-    _M_get_matcher(_PatternCursor&                   __p,\n-                   _Results&                         __r,\n-                   const _AutomatonPtr&              __automaton,\n-                   regex_constants::match_flag_type  __flags) = 0;\n-\n #ifdef _GLIBCXX_DEBUG\n     virtual std::ostream&\n     _M_dot(std::ostream& __ostr) const = 0;\n #endif\n   };\n \n+  /// Generic shared pointer to an automaton.  \n+  typedef std::shared_ptr<_Automaton> _AutomatonPtr;\n+\n   /// Operation codes that define the type of transitions within the base NFA\n   /// that represents the regular expression.\n   enum _Opcode\n@@ -94,6 +73,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _S_opcode_accept        = 255\n   };\n \n+  /// Provides a generic facade for a templated match_results.\n+  struct _Results\n+  {\n+    virtual void _M_set_pos(int __i, int __j, const _PatternCursor& __p) = 0;\n+    virtual void _M_set_matched(int __i, bool __is_matched) = 0;\n+  };\n+\n   /// Tags current state (for subexpr begin/end).\n   typedef std::function<void (const _PatternCursor&, _Results&)> _Tagger;\n \n@@ -127,6 +113,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { __r._M_set_pos(_M_index, 1, __pc); }\n \n       int       _M_index;\n+      _FwdIterT _M_pos;\n     };\n \n   /// Indicates if current state matches cursor current.\n@@ -288,9 +275,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typedef regex_constants::syntax_option_type _FlagT;\n \n     _Nfa(_FlagT __f)\n-    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n-    // TODO: BFS by default. Your choice. Need to be set by the compiler.\n-    _M_has_back_ref(false)\n+    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0)\n     { }\n \n     ~_Nfa()\n@@ -349,16 +334,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return this->size()-1;\n     }\n \n-    void\n-    _M_set_back_ref(bool __b)\n-    { _M_has_back_ref = __b; }\n-\n-    std::unique_ptr<_Grep_matcher>\n-    _M_get_matcher(_PatternCursor&                   __p,\n-                   _Results&                         __r,\n-                   const _AutomatonPtr&              __automaton,\n-                   regex_constants::match_flag_type  __flags);\n-\n #ifdef _GLIBCXX_DEBUG\n     std::ostream&\n     _M_dot(std::ostream& __ostr) const;\n@@ -369,7 +344,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _StateIdT  _M_start_state;\n     _StateSet  _M_accepting_states;\n     _SizeT     _M_subexpr_count;\n-    bool       _M_has_back_ref;\n   };\n \n   /// Describes a sequence of one or more %_State, its current start"}, {"sha": "907f5bb65d89d92713b0ccb58c45769803ba2c4f", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -44,8 +44,6 @@\n #include <iterator>\n #include <locale>\n #include <memory>\n-#include <map>\n-#include <queue>\n #include <set>\n #include <sstream>\n #include <stack>"}, {"sha": "383ed054a9073095fab3c9a0c710e877d3f1f3e8", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/53622.cc", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -32,31 +32,16 @@ test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  {\n-    std::regex  re(\"zxcv/(one.*)abc\", std::regex::extended);\n-    std::string target(\"zxcv/onetwoabc\");\n-    std::smatch m;\n-\n-    VERIFY( std::regex_search(target, m, re) );\n-    VERIFY( m.size() == 2 );\n-    VERIFY( m[0].matched == true );\n-    VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );\n-    VERIFY( m[1].matched == true );\n-    VERIFY( std::string(m[1].first, m[1].second) == \"onetwo\" );\n-  }\n-\n-  {\n-    std::regex  re(\"zxcv/(one.*)abc()\\\\2\", std::regex::extended);\n-    std::string target(\"zxcv/onetwoabc\");\n-    std::smatch m;\n-\n-    VERIFY( std::regex_search(target, m, re) );\n-    VERIFY( m.size() == 3 );\n-    VERIFY( m[0].matched == true );\n-    VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );\n-    VERIFY( m[1].matched == true );\n-    VERIFY( std::string(m[1].first, m[1].second) == \"onetwo\" );\n-  }\n+  std::regex  re(\"zxcv/(one.*)abc\", std::regex::extended);\n+  std::string target(\"zxcv/onetwoabc\");\n+  std::smatch m;\n+\n+  VERIFY( std::regex_search(target, m, re) );\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m[0].matched == true );\n+  VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );\n+  VERIFY( m[1].matched == true );\n+  VERIFY( std::string(m[1].first, m[1].second) == \"onetwo\" );\n }\n \n int"}, {"sha": "3031c43d188bb392da6de4d2399b9f45ad78ceb5", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/57173.cc", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F57173.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F57173.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F57173.cc?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -33,24 +33,13 @@ test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  {\n-    std::regex  re(\"/asdf(/.*)\", std::regex::extended);\n-    std::string target(\"/asdf/qwerty\");\n-    std::smatch m;\n+  std::regex  re(\"/asdf(/.*)\", std::regex::extended);\n+  std::string target(\"/asdf/qwerty\");\n+  std::smatch m;\n \n-    VERIFY( std::regex_match(target, m, re) );\n-    VERIFY( m.size() == 2 );\n-    VERIFY( std::string(m[1].first, m[1].second) == \"/qwerty\");\n-  }\n-  {\n-    std::regex  re(\"/asdf(/.*)()\\\\2\", std::regex::extended);\n-    std::string target(\"/asdf/qwerty\");\n-    std::smatch m;\n-\n-    VERIFY( std::regex_match(target, m, re) );\n-    VERIFY( m.size() == 3 );\n-    VERIFY( std::string(m[1].first, m[1].second) == \"/qwerty\");\n-  }\n+  VERIFY( std::regex_match(target, m, re) );\n+  VERIFY( m.size() == 2 );\n+  VERIFY( std::string(m[1].first, m[1].second) == \"/qwerty\");\n }\n \n int"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/string_dispatch_01.cc", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5034aa2102570f4fb9de018c8c5e26b192f5594f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc?ref=5034aa2102570f4fb9de018c8c5e26b192f5594f", "patch": "@@ -1,71 +0,0 @@\n-// { dg-options \"-std=gnu++11\" }\n-\n-//\n-// 2013-07-29  Tim Shen <timshen91@gmail.com>\n-//\n-// Copyright (C) 2013 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-//\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-//\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// 28.11.2 regex_match\n-// Tests Extended automatic matcher dispatching against a std::string target.\n-\n-#include <regex>\n-#include <testsuite_hooks.h>\n-\n-using namespace std;\n-\n-template<typename _Bi_iter, typename _Alloc,\n-         typename _Ch_type, typename _Rx_traits>\n-  void\n-  fake_match(_Bi_iter                                 __s,\n-             _Bi_iter                                 __e,\n-             match_results<_Bi_iter, _Alloc>&         __m,\n-             const basic_regex<_Ch_type, _Rx_traits>& __re,\n-             regex_constants::match_flag_type         __flags\n-                            = regex_constants::match_default)\n-  {\n-    __detail::_AutomatonPtr __a = __re._M_get_automaton();\n-    __detail::_Automaton::_SizeT __sz = __a->_M_sub_count();\n-    __detail::_SpecializedCursor<_Bi_iter> __cs(__s, __e);\n-    __detail::_SpecializedResults<_Bi_iter, _Alloc> __r(__sz, __cs, __m);\n-    VERIFY( dynamic_cast<__detail::_DFSMatcher *>(\n-              &*__a->_M_get_matcher(__cs, __r, __a, __flags)) != nullptr );\n-  }\n-\n-void\n-test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  regex  re(\"()(one(.*))abc\\\\1\"); // backref cause DFS\n-  const string target(\"onetwoabc\");\n-  smatch m;\n-  fake_match(target.begin(), target.end(), m, re);\n-\n-  regex_match(target, m, re);\n-  VERIFY( m[2].matched );\n-  VERIFY( m[3].matched );\n-  VERIFY( std::string(m[2].first, m[2].second) == \"onetwo\" );\n-  VERIFY( std::string(m[3].first, m[3].second) == \"two\" );\n-}\n-\n-int\n-main()\n-{\n-  test01();\n-  return 0;\n-}"}]}