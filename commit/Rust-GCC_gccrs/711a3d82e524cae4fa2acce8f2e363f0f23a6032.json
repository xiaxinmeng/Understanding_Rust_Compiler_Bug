{"sha": "711a3d82e524cae4fa2acce8f2e363f0f23a6032", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExYTNkODJlNTI0Y2FlNGZhMmFjY2U4ZjJlMzYzZjBmMjNhNjAzMg==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2011-10-17T14:43:37Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2011-10-17T14:43:37Z"}, "message": "Use MADV_DONTNEED for freeing in garbage collector\n\nUse the Linux MADV_DONTNEED call to unmap free pages in the garbage\ncollector.Then keep the unmapped pages in the free list. This avoid\nexcessive memory fragmentation on large LTO bulds, which can lead\nto gcc bumping into the Linux vm_max_map limit per process.\n\ngcc/:\n\n2011-10-08  Andi Kleen  <ak@linux.intel.com>\n\n\tPR other/50636\n\t* config.in, configure: Regenerate.\n\t* configure.ac (madvise): Add to AC_CHECK_FUNCS.\n\t* ggc-page.c (USING_MADVISE): Add.\n\t(page_entry): Add discarded field.\n\t(alloc_page): Check for discarded pages.\n\t(release_pages): Add USING_MADVISE branch.\n\nFrom-SVN: r180093", "tree": {"sha": "b0f5ec12dbc9d0cd2f36e94c063c914fbfe5bb72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0f5ec12dbc9d0cd2f36e94c063c914fbfe5bb72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/711a3d82e524cae4fa2acce8f2e363f0f23a6032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711a3d82e524cae4fa2acce8f2e363f0f23a6032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711a3d82e524cae4fa2acce8f2e363f0f23a6032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711a3d82e524cae4fa2acce8f2e363f0f23a6032/comments", "author": null, "committer": null, "parents": [{"sha": "411f92de7a3e15a42d3d640e5f7a0bc4cfc3e049", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/411f92de7a3e15a42d3d640e5f7a0bc4cfc3e049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/411f92de7a3e15a42d3d640e5f7a0bc4cfc3e049"}], "stats": {"total": 68, "additions": 65, "deletions": 3}, "files": [{"sha": "3c8b7b55c72d61558e60d2dbc866b8494ef711ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=711a3d82e524cae4fa2acce8f2e363f0f23a6032", "patch": "@@ -1,3 +1,13 @@\n+2011-10-08  Andi Kleen  <ak@linux.intel.com>\n+\n+\tPR other/50636\n+\t* config.in, configure: Regenerate.\n+\t* configure.ac (madvise): Add to AC_CHECK_FUNCS.\n+\t* ggc-page.c (USING_MADVISE): Add.\n+\t(page_entry): Add discarded field.\n+\t(alloc_page): Check for discarded pages.\n+\t(release_pages): Add USING_MADVISE branch.\n+\n 2011-10-17  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50729"}, {"sha": "e8148b6d571457eef33ec5927dde22ce348138ad", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=711a3d82e524cae4fa2acce8f2e363f0f23a6032", "patch": "@@ -1276,6 +1276,12 @@\n #endif\n \n \n+/* Define to 1 if you have the `madvise' function. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_MADVISE\n+#endif\n+\n+\n /* Define to 1 if you have the <malloc.h> header file. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_MALLOC_H"}, {"sha": "4a54adfe3e80badce09733694fc77a59540989f5", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=711a3d82e524cae4fa2acce8f2e363f0f23a6032", "patch": "@@ -9001,7 +9001,7 @@ fi\n for ac_func in times clock kill getrlimit setrlimit atoll atoq \\\n \tsysconf strsignal getrusage nl_langinfo \\\n \tgettimeofday mbstowcs wcswidth mmap setlocale \\\n-\tclearerr_unlocked feof_unlocked   ferror_unlocked fflush_unlocked fgetc_unlocked fgets_unlocked   fileno_unlocked fprintf_unlocked fputc_unlocked fputs_unlocked   fread_unlocked fwrite_unlocked getchar_unlocked getc_unlocked   putchar_unlocked putc_unlocked\n+\tclearerr_unlocked feof_unlocked   ferror_unlocked fflush_unlocked fgetc_unlocked fgets_unlocked   fileno_unlocked fprintf_unlocked fputc_unlocked fputs_unlocked   fread_unlocked fwrite_unlocked getchar_unlocked getc_unlocked   putchar_unlocked putc_unlocked madvise\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\""}, {"sha": "357902e8a916db0c196cc7aaa4e740878257bd61", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=711a3d82e524cae4fa2acce8f2e363f0f23a6032", "patch": "@@ -1027,7 +1027,7 @@ define(gcc_UNLOCKED_FUNCS, clearerr_unlocked feof_unlocked dnl\n AC_CHECK_FUNCS(times clock kill getrlimit setrlimit atoll atoq \\\n \tsysconf strsignal getrusage nl_langinfo \\\n \tgettimeofday mbstowcs wcswidth mmap setlocale \\\n-\tgcc_UNLOCKED_FUNCS)\n+\tgcc_UNLOCKED_FUNCS madvise)\n \n if test x$ac_cv_func_mbstowcs = xyes; then\n   AC_CACHE_CHECK(whether mbstowcs works, gcc_cv_func_mbstowcs_works,"}, {"sha": "9b352913eb43adf643e724e6d88ec2216e6dc786", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711a3d82e524cae4fa2acce8f2e363f0f23a6032/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=711a3d82e524cae4fa2acce8f2e363f0f23a6032", "patch": "@@ -50,6 +50,10 @@ along with GCC; see the file COPYING3.  If not see\n #define USING_MALLOC_PAGE_GROUPS\n #endif\n \n+#if defined(HAVE_MADVISE) && defined(MADV_DONTNEED)\n+# define USING_MADVISE\n+#endif\n+\n /* Strategy:\n \n    This garbage-collecting allocator allocates objects on one of a set\n@@ -277,6 +281,9 @@ typedef struct page_entry\n   /* The lg of size of objects allocated from this page.  */\n   unsigned char order;\n \n+  /* Discarded page? */\n+  bool discarded;\n+\n   /* A bit vector indicating whether or not objects are in use.  The\n      Nth bit is one if the Nth object on this page is allocated.  This\n      array is dynamically sized.  */\n@@ -740,6 +747,10 @@ alloc_page (unsigned order)\n \n   if (p != NULL)\n     {\n+      if (p->discarded)\n+        G.bytes_mapped += p->bytes;\n+      p->discarded = false;\n+\n       /* Recycle the allocated memory from this page ...  */\n       *pp = p->next;\n       page = p->page;\n@@ -956,7 +967,42 @@ free_page (page_entry *entry)\n static void\n release_pages (void)\n {\n-#ifdef USING_MMAP\n+#ifdef USING_MADVISE\n+  page_entry *p, *start_p;\n+  char *start;\n+  size_t len;\n+\n+  for (p = G.free_pages; p; )\n+    {\n+      if (p->discarded)\n+        {\n+          p = p->next;\n+          continue;\n+        }\n+      start = p->page;\n+      len = p->bytes;\n+      start_p = p;\n+      p = p->next;\n+      while (p && p->page == start + len)\n+        {\n+          len += p->bytes;\n+          p = p->next;\n+        }\n+      /* Give the page back to the kernel, but don't free the mapping.\n+         This avoids fragmentation in the virtual memory map of the \n+ \t process. Next time we can reuse it by just touching it. */\n+      madvise (start, len, MADV_DONTNEED);\n+      /* Don't count those pages as mapped to not touch the garbage collector\n+         unnecessarily. */\n+      G.bytes_mapped -= len;\n+      while (start_p != p)\n+        {\n+          start_p->discarded = true;\n+          start_p = start_p->next;\n+        }\n+    }\n+#endif\n+#if defined(USING_MMAP) && !defined(USING_MADVISE)\n   page_entry *p, *next;\n   char *start;\n   size_t len;"}]}