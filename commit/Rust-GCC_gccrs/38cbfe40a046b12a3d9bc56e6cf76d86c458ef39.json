{"sha": "38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhjYmZlNDBhMDQ2YjEyYTNkOWJjNTZlNmNmNzZkODZjNDU4ZWYzOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:18:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:18:40Z"}, "message": "New Language: Ada\n\nFrom-SVN: r45955", "tree": {"sha": "6570bc15069492ca4f53a85c5d09a36d099fd63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6570bc15069492ca4f53a85c5d09a36d099fd63f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/comments", "author": null, "committer": null, "parents": [{"sha": "70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}], "stats": {"total": 82060, "additions": 82060, "deletions": 0}, "files": [{"sha": "7811caec00b960608a831f400498c31b4f1bb15f", "filename": "gcc/ada/g-awk.adb", "status": "added", "additions": 1296, "deletions": 0, "changes": 1296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-awk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-awk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-awk.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,1296 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              G N A T . A W K                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--            Copyright (C) 2000-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off alpha ordering check for subprograms, since we cannot\n+--  Put Finalize and Initialize in alpha order (see comments).\n+\n+with Ada.Exceptions;\n+with Ada.Text_IO;\n+with Ada.Strings.Unbounded;\n+with Ada.Strings.Fixed;\n+with Ada.Strings.Maps;\n+with Ada.Unchecked_Deallocation;\n+\n+with GNAT.Directory_Operations;\n+with GNAT.Dynamic_Tables;\n+with GNAT.OS_Lib;\n+\n+package body GNAT.AWK is\n+\n+   use Ada;\n+   use Ada.Strings.Unbounded;\n+\n+   ----------------\n+   -- Split mode --\n+   ----------------\n+\n+   package Split is\n+\n+      type Mode is abstract tagged null record;\n+      --  This is the main type which is declared abstract. This type must be\n+      --  derived for each split style.\n+\n+      type Mode_Access is access Mode'Class;\n+\n+      procedure Current_Line (S : Mode; Session : Session_Type)\n+        is abstract;\n+      --  Split Session's current line using split mode.\n+\n+      ------------------------\n+      -- Split on separator --\n+      ------------------------\n+\n+      type Separator (Size : Positive) is new Mode with record\n+         Separators : String (1 .. Size);\n+      end record;\n+\n+      procedure Current_Line\n+        (S       : Separator;\n+         Session : Session_Type);\n+\n+      ---------------------\n+      -- Split on column --\n+      ---------------------\n+\n+      type Column (Size : Positive) is new Mode with record\n+         Columns : Widths_Set (1 .. Size);\n+      end record;\n+\n+      procedure Current_Line (S : Column; Session : Session_Type);\n+\n+   end Split;\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Split.Mode'Class, Split.Mode_Access);\n+\n+   ----------------\n+   -- File_Table --\n+   ----------------\n+\n+   type AWK_File is access String;\n+\n+   package File_Table is\n+      new Dynamic_Tables (AWK_File, Natural, 1, 5, 50);\n+   --  List of filename associated with a Session.\n+\n+   procedure Free is new Unchecked_Deallocation (String, AWK_File);\n+\n+   -----------------\n+   -- Field_Table --\n+   -----------------\n+\n+   type Field_Slice is record\n+      First : Positive;\n+      Last  : Natural;\n+   end record;\n+   --  This is a field slice (First .. Last) in session's current line.\n+\n+   package Field_Table is\n+      new Dynamic_Tables (Field_Slice, Natural, 1, 10, 100);\n+   --  List of fields for the current line.\n+\n+   --------------\n+   -- Patterns --\n+   --------------\n+\n+   --  Define all patterns style : exact string, regular expression, boolean\n+   --  function.\n+\n+   package Patterns is\n+\n+      type Pattern is abstract tagged null record;\n+      --  This is the main type which is declared abstract. This type must be\n+      --  derived for each patterns style.\n+\n+      type Pattern_Access is access Pattern'Class;\n+\n+      function Match\n+        (P       : Pattern;\n+         Session : Session_Type)\n+         return    Boolean\n+      is abstract;\n+      --  Returns True if P match for the current session and False otherwise.\n+\n+      procedure Release (P : in out Pattern);\n+      --  Release memory used by the pattern structure.\n+\n+      --------------------------\n+      -- Exact string pattern --\n+      --------------------------\n+\n+      type String_Pattern is new Pattern with record\n+         Str  : Unbounded_String;\n+         Rank : Count;\n+      end record;\n+\n+      function Match\n+        (P       : String_Pattern;\n+         Session : Session_Type)\n+         return    Boolean;\n+\n+      --------------------------------\n+      -- Regular expression pattern --\n+      --------------------------------\n+\n+      type Pattern_Matcher_Access is access Regpat.Pattern_Matcher;\n+\n+      type Regexp_Pattern is new Pattern with record\n+         Regx : Pattern_Matcher_Access;\n+         Rank : Count;\n+      end record;\n+\n+      function Match\n+        (P       : Regexp_Pattern;\n+         Session : Session_Type)\n+         return    Boolean;\n+\n+      procedure Release (P : in out Regexp_Pattern);\n+\n+      ------------------------------\n+      -- Boolean function pattern --\n+      ------------------------------\n+\n+      type Callback_Pattern is new Pattern with record\n+         Pattern : Pattern_Callback;\n+      end record;\n+\n+      function Match\n+        (P       : Callback_Pattern;\n+         Session : Session_Type)\n+         return    Boolean;\n+\n+   end Patterns;\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Patterns.Pattern'Class, Patterns.Pattern_Access);\n+\n+   -------------\n+   -- Actions --\n+   -------------\n+\n+   --  Define all action style : simple call, call with matches\n+\n+   package Actions is\n+\n+      type Action is abstract tagged null record;\n+      --  This is the main type which is declared abstract. This type must be\n+      --  derived for each action style.\n+\n+      type Action_Access is access Action'Class;\n+\n+      procedure Call\n+        (A       : Action;\n+         Session : Session_Type)\n+         is abstract;\n+      --  Call action A as required.\n+\n+      -------------------\n+      -- Simple action --\n+      -------------------\n+\n+      type Simple_Action is new Action with record\n+         Proc : Action_Callback;\n+      end record;\n+\n+      procedure Call\n+        (A       : Simple_Action;\n+         Session : Session_Type);\n+\n+      -------------------------\n+      -- Action with matches --\n+      -------------------------\n+\n+      type Match_Action is new Action with record\n+         Proc : Match_Action_Callback;\n+      end record;\n+\n+      procedure Call\n+        (A       : Match_Action;\n+         Session : Session_Type);\n+\n+   end Actions;\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Actions.Action'Class, Actions.Action_Access);\n+\n+   --------------------------\n+   -- Pattern/Action table --\n+   --------------------------\n+\n+   type Pattern_Action is record\n+      Pattern : Patterns.Pattern_Access;  -- If Pattern is True\n+      Action  : Actions.Action_Access;    -- Action will be called\n+   end record;\n+\n+   package Pattern_Action_Table is\n+      new Dynamic_Tables (Pattern_Action, Natural, 1, 5, 50);\n+\n+   ------------------\n+   -- Session Data --\n+   ------------------\n+\n+   type Session_Data is record\n+      Current_File : Text_IO.File_Type;\n+      Current_Line : Unbounded_String;\n+      Separators   : Split.Mode_Access;\n+      Files        : File_Table.Instance;\n+      File_Index   : Natural := 0;\n+      Fields       : Field_Table.Instance;\n+      Filters      : Pattern_Action_Table.Instance;\n+      NR           : Natural := 0;\n+      FNR          : Natural := 0;\n+      Matches      : Regpat.Match_Array (0 .. 100);\n+      --  latest matches for the regexp pattern\n+   end record;\n+\n+   procedure Free is\n+      new Unchecked_Deallocation (Session_Data, Session_Data_Access);\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Session : in out Session_Type) is\n+   begin\n+      Session.Data := new Session_Data;\n+\n+      --  Initialize separators\n+\n+      Session.Data.Separators :=\n+        new Split.Separator'(Default_Separators'Length, Default_Separators);\n+\n+      --  Initialize all tables\n+\n+      File_Table.Init  (Session.Data.Files);\n+      Field_Table.Init (Session.Data.Fields);\n+      Pattern_Action_Table.Init (Session.Data.Filters);\n+   end Initialize;\n+\n+   -----------------------\n+   -- Session Variables --\n+   -----------------------\n+\n+   --  These must come after the body of Initialize, since they make\n+   --  implicit calls to Initialize at elaboration time.\n+\n+   Def_Session : Session_Type;\n+   Cur_Session : Session_Type;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   --  Note: Finalize must come after Initialize and the definition\n+   --  of the Def_Session and Cur_Session variables, since it references\n+   --  the latter.\n+\n+   procedure Finalize (Session : in out Session_Type) is\n+   begin\n+      --  We release the session data only if it is not the default session.\n+\n+      if Session.Data /= Def_Session.Data then\n+         Free (Session.Data);\n+\n+         --  Since we have closed the current session, set it to point\n+         --  now to the default session.\n+\n+         Cur_Session.Data := Def_Session.Data;\n+      end if;\n+   end Finalize;\n+\n+   ----------------------\n+   -- Private Services --\n+   ----------------------\n+\n+   function Always_True return Boolean;\n+   --  A function that always returns True.\n+\n+   function Apply_Filters\n+     (Session : Session_Type := Current_Session)\n+      return    Boolean;\n+   --  Apply any filters for which the Pattern is True for Session. It returns\n+   --  True if a least one filters has been applied (i.e. associated action\n+   --  callback has been called).\n+\n+   procedure Open_Next_File\n+     (Session : Session_Type := Current_Session);\n+   pragma Inline (Open_Next_File);\n+   --  Open next file for Session closing current file if needed. It raises\n+   --  End_Error if there is no more file in the table.\n+\n+   procedure Raise_With_Info\n+     (E       : Exceptions.Exception_Id;\n+      Message : String;\n+      Session : Session_Type);\n+   pragma No_Return (Raise_With_Info);\n+   --  Raises exception E with the message prepended with the current line\n+   --  number and the filename if possible.\n+\n+   procedure Read_Line (Session : Session_Type);\n+   --  Read a line for the Session and set Current_Line.\n+\n+   procedure Split_Line (Session : Session_Type);\n+   --  Split session's Current_Line according to the session separators and\n+   --  set the Fields table. This procedure can be called at any time.\n+\n+   ----------------------\n+   -- Private Packages --\n+   ----------------------\n+\n+   -------------\n+   -- Actions --\n+   -------------\n+\n+   package body Actions is\n+\n+      ----------\n+      -- Call --\n+      ----------\n+\n+      procedure Call\n+        (A       : Simple_Action;\n+         Session : Session_Type)\n+      is\n+      begin\n+         A.Proc.all;\n+      end Call;\n+\n+      ----------\n+      -- Call --\n+      ----------\n+\n+      procedure Call\n+        (A       : Match_Action;\n+         Session : Session_Type)\n+      is\n+      begin\n+         A.Proc (Session.Data.Matches);\n+      end Call;\n+\n+   end Actions;\n+\n+   --------------\n+   -- Patterns --\n+   --------------\n+\n+   package body Patterns is\n+\n+      -----------\n+      -- Match --\n+      -----------\n+\n+      function Match\n+        (P       : String_Pattern;\n+         Session : Session_Type)\n+         return    Boolean\n+      is\n+      begin\n+         return P.Str = Field (P.Rank, Session);\n+      end Match;\n+\n+      -----------\n+      -- Match --\n+      -----------\n+\n+      function Match\n+        (P       : Regexp_Pattern;\n+         Session : Session_Type)\n+         return    Boolean\n+      is\n+         use type Regpat.Match_Location;\n+\n+      begin\n+         Regpat.Match\n+           (P.Regx.all, Field (P.Rank, Session), Session.Data.Matches);\n+         return Session.Data.Matches (0) /= Regpat.No_Match;\n+      end Match;\n+\n+      -----------\n+      -- Match --\n+      -----------\n+\n+      function Match\n+        (P       : Callback_Pattern;\n+         Session : Session_Type)\n+         return    Boolean\n+      is\n+      begin\n+         return P.Pattern.all;\n+      end Match;\n+\n+      -------------\n+      -- Release --\n+      -------------\n+\n+      procedure Release (P : in out Pattern) is\n+      begin\n+         null;\n+      end Release;\n+\n+      -------------\n+      -- Release --\n+      -------------\n+\n+      procedure Release (P : in out Regexp_Pattern) is\n+         procedure Free is new Unchecked_Deallocation\n+           (Regpat.Pattern_Matcher, Pattern_Matcher_Access);\n+\n+      begin\n+         Free (P.Regx);\n+      end Release;\n+\n+   end Patterns;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   package body Split is\n+\n+      use Ada.Strings;\n+\n+      ------------------\n+      -- Current_Line --\n+      ------------------\n+\n+      procedure Current_Line (S : Separator; Session : Session_Type) is\n+         Line   : constant String := To_String (Session.Data.Current_Line);\n+         Fields : Field_Table.Instance renames Session.Data.Fields;\n+\n+         Start : Positive;\n+         Stop  : Natural;\n+\n+         Seps  : Maps.Character_Set := Maps.To_Set (S.Separators);\n+\n+      begin\n+         --  First field start here\n+\n+         Start := Line'First;\n+\n+         --  Record the first field start position which is the first character\n+         --  in the line.\n+\n+         Field_Table.Increment_Last (Fields);\n+         Fields.Table (Field_Table.Last (Fields)).First := Start;\n+\n+         loop\n+            --  Look for next separator\n+\n+            Stop := Fixed.Index\n+              (Source  => Line (Start .. Line'Last),\n+               Set     => Seps);\n+\n+            exit when Stop = 0;\n+\n+            Fields.Table (Field_Table.Last (Fields)).Last := Stop - 1;\n+\n+            --  if separators are set to the default (space and tab) we skip\n+            --  all spaces and tabs following current field.\n+\n+            if S.Separators = Default_Separators then\n+               Start := Fixed.Index\n+                 (Line (Stop + 1 .. Line'Last),\n+                  Maps.To_Set (Default_Separators),\n+                  Outside,\n+                  Strings.Forward);\n+            else\n+               Start := Stop + 1;\n+            end if;\n+\n+            --  Record in the field table the start of this new field\n+\n+            Field_Table.Increment_Last (Fields);\n+            Fields.Table (Field_Table.Last (Fields)).First := Start;\n+\n+         end loop;\n+\n+         Fields.Table (Field_Table.Last (Fields)).Last := Line'Last;\n+      end Current_Line;\n+\n+      ------------------\n+      -- Current_Line --\n+      ------------------\n+\n+      procedure Current_Line (S : Column; Session : Session_Type) is\n+         Line   : constant String := To_String (Session.Data.Current_Line);\n+         Fields : Field_Table.Instance renames Session.Data.Fields;\n+         Start  : Positive := Line'First;\n+\n+      begin\n+         --  Record the first field start position which is the first character\n+         --  in the line.\n+\n+         for C in 1 .. S.Columns'Length loop\n+\n+            Field_Table.Increment_Last (Fields);\n+\n+            Fields.Table (Field_Table.Last (Fields)).First := Start;\n+\n+            Start := Start + S.Columns (C);\n+\n+            Fields.Table (Field_Table.Last (Fields)).Last := Start - 1;\n+\n+         end loop;\n+\n+         --  If there is some remaining character on the line, add them in a\n+         --  new field.\n+\n+         if Start - 1 < Line'Length then\n+\n+            Field_Table.Increment_Last (Fields);\n+\n+            Fields.Table (Field_Table.Last (Fields)).First := Start;\n+\n+            Fields.Table (Field_Table.Last (Fields)).Last := Line'Last;\n+         end if;\n+      end Current_Line;\n+\n+   end Split;\n+\n+   --------------\n+   -- Add_File --\n+   --------------\n+\n+   procedure Add_File\n+     (Filename : String;\n+      Session  : Session_Type := Current_Session)\n+   is\n+      Files : File_Table.Instance renames Session.Data.Files;\n+\n+   begin\n+      if OS_Lib.Is_Regular_File (Filename) then\n+         File_Table.Increment_Last (Files);\n+         Files.Table (File_Table.Last (Files)) := new String'(Filename);\n+      else\n+         Raise_With_Info\n+           (File_Error'Identity,\n+            \"File \" & Filename & \" not found.\",\n+            Session);\n+      end if;\n+   end Add_File;\n+\n+   ---------------\n+   -- Add_Files --\n+   ---------------\n+\n+   procedure Add_Files\n+     (Directory             : String;\n+      Filenames             : String;\n+      Number_Of_Files_Added : out Natural;\n+      Session               : Session_Type := Current_Session)\n+   is\n+      use Directory_Operations;\n+\n+      Dir      : Dir_Type;\n+      Filename : String (1 .. 200);\n+      Last     : Natural;\n+\n+   begin\n+      Number_Of_Files_Added := 0;\n+\n+      Open (Dir, Directory);\n+\n+      loop\n+         Read (Dir, Filename, Last);\n+         exit when Last = 0;\n+\n+         Add_File (Filename (1 .. Last), Session);\n+         Number_Of_Files_Added := Number_Of_Files_Added + 1;\n+      end loop;\n+\n+      Close (Dir);\n+\n+   exception\n+      when others =>\n+         Raise_With_Info\n+           (File_Error'Identity,\n+            \"Error scaning directory \" & Directory\n+            & \" for files \" & Filenames & '.',\n+            Session);\n+   end Add_Files;\n+\n+   -----------------\n+   -- Always_True --\n+   -----------------\n+\n+   function Always_True return Boolean is\n+   begin\n+      return True;\n+   end Always_True;\n+\n+   -------------------\n+   -- Apply_Filters --\n+   -------------------\n+\n+   function Apply_Filters\n+     (Session : Session_Type := Current_Session)\n+      return    Boolean\n+   is\n+      Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n+      Results : Boolean := False;\n+\n+   begin\n+      --  Iterate throught the filters table, if pattern match call action.\n+\n+      for F in 1 .. Pattern_Action_Table.Last (Filters) loop\n+         if Patterns.Match (Filters.Table (F).Pattern.all, Session) then\n+            Results := True;\n+            Actions.Call (Filters.Table (F).Action.all, Session);\n+         end if;\n+      end loop;\n+\n+      return Results;\n+   end Apply_Filters;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Session : Session_Type) is\n+      Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n+      Files   : File_Table.Instance renames Session.Data.Files;\n+\n+   begin\n+      --  Close current file if needed\n+\n+      if Text_IO.Is_Open (Session.Data.Current_File) then\n+         Text_IO.Close (Session.Data.Current_File);\n+      end if;\n+\n+      --  Release separators\n+\n+      Free (Session.Data.Separators);\n+\n+      --  Release Filters table\n+\n+      for F in 1 .. Pattern_Action_Table.Last (Filters) loop\n+         Patterns.Release (Filters.Table (F).Pattern.all);\n+         Free (Filters.Table (F).Pattern);\n+         Free (Filters.Table (F).Action);\n+      end loop;\n+\n+      for F in 1 .. File_Table.Last (Files) loop\n+         Free (Files.Table (F));\n+      end loop;\n+\n+      File_Table.Set_Last (Session.Data.Files, 0);\n+      Field_Table.Set_Last (Session.Data.Fields, 0);\n+      Pattern_Action_Table.Set_Last (Session.Data.Filters, 0);\n+\n+      Session.Data.NR := 0;\n+      Session.Data.FNR := 0;\n+      Session.Data.File_Index := 0;\n+      Session.Data.Current_Line := Null_Unbounded_String;\n+   end Close;\n+\n+   ---------------------\n+   -- Current_Session --\n+   ---------------------\n+\n+   function Current_Session return Session_Type is\n+   begin\n+      return Cur_Session;\n+   end Current_Session;\n+\n+   ---------------------\n+   -- Default_Session --\n+   ---------------------\n+\n+   function Default_Session return Session_Type is\n+   begin\n+      return Def_Session;\n+   end Default_Session;\n+\n+   --------------------\n+   -- Discrete_Field --\n+   --------------------\n+\n+   function Discrete_Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    Discrete\n+   is\n+   begin\n+      return Discrete'Value (Field (Rank, Session));\n+   end Discrete_Field;\n+\n+   -----------------\n+   -- End_Of_Data --\n+   -----------------\n+\n+   function End_Of_Data\n+     (Session : Session_Type := Current_Session)\n+      return    Boolean\n+   is\n+   begin\n+      return Session.Data.File_Index = File_Table.Last (Session.Data.Files)\n+        and then End_Of_File (Session);\n+   end End_Of_Data;\n+\n+   -----------------\n+   -- End_Of_File --\n+   -----------------\n+\n+   function End_Of_File\n+     (Session : Session_Type := Current_Session)\n+      return    Boolean\n+   is\n+   begin\n+      return Text_IO.End_Of_File (Session.Data.Current_File);\n+   end End_Of_File;\n+\n+   -----------\n+   -- Field --\n+   -----------\n+\n+   function Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    String\n+   is\n+      Fields : Field_Table.Instance renames Session.Data.Fields;\n+\n+   begin\n+      if Rank > Number_Of_Fields (Session) then\n+         Raise_With_Info\n+           (Field_Error'Identity,\n+            \"Field number\" & Count'Image (Rank) & \" does not exist.\",\n+            Session);\n+\n+      elsif Rank = 0 then\n+\n+         --  Returns the whole line, this is what $0 does under Session_Type.\n+\n+         return To_String (Session.Data.Current_Line);\n+\n+      else\n+         return Slice (Session.Data.Current_Line,\n+                       Fields.Table (Positive (Rank)).First,\n+                       Fields.Table (Positive (Rank)).Last);\n+      end if;\n+   end Field;\n+\n+   function Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    Integer\n+   is\n+   begin\n+      return Integer'Value (Field (Rank, Session));\n+\n+   exception\n+      when Constraint_Error =>\n+         Raise_With_Info\n+           (Field_Error'Identity,\n+            \"Field number\" & Count'Image (Rank)\n+            & \" cannot be converted to an integer.\",\n+            Session);\n+   end Field;\n+\n+   function Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    Float\n+   is\n+   begin\n+      return Float'Value (Field (Rank, Session));\n+\n+   exception\n+      when Constraint_Error =>\n+         Raise_With_Info\n+           (Field_Error'Identity,\n+            \"Field number\" & Count'Image (Rank)\n+            & \" cannot be converted to a float.\",\n+            Session);\n+   end Field;\n+\n+   ----------\n+   -- File --\n+   ----------\n+\n+   function File\n+     (Session : Session_Type := Current_Session)\n+      return    String\n+   is\n+      Files : File_Table.Instance renames Session.Data.Files;\n+\n+   begin\n+      if Session.Data.File_Index = 0 then\n+         return \"??\";\n+      else\n+         return Files.Table (Session.Data.File_Index).all;\n+      end if;\n+   end File;\n+\n+   --------------------\n+   -- For_Every_Line --\n+   --------------------\n+\n+   procedure For_Every_Line\n+     (Separators : String        := Use_Current;\n+      Filename   : String        := Use_Current;\n+      Callbacks  : Callback_Mode := None;\n+      Session    : Session_Type  := Current_Session)\n+   is\n+      Filter_Active : Boolean;\n+      Quit          : Boolean;\n+\n+   begin\n+      Open (Separators, Filename, Session);\n+\n+      while not End_Of_Data (Session) loop\n+         Read_Line (Session);\n+         Split_Line (Session);\n+\n+         if Callbacks in Only .. Pass_Through then\n+            Filter_Active := Apply_Filters (Session);\n+         end if;\n+\n+         if Callbacks /= Only then\n+            Quit := False;\n+            Action (Quit);\n+            exit when Quit;\n+         end if;\n+      end loop;\n+\n+      Close (Session);\n+   end For_Every_Line;\n+\n+   --------------\n+   -- Get_Line --\n+   --------------\n+\n+   procedure Get_Line\n+     (Callbacks : Callback_Mode := None;\n+      Session   : Session_Type := Current_Session)\n+   is\n+      Filter_Active : Boolean;\n+\n+   begin\n+      if not Text_IO.Is_Open (Session.Data.Current_File) then\n+         raise File_Error;\n+      end if;\n+\n+      loop\n+         Read_Line (Session);\n+         Split_Line (Session);\n+\n+         if Callbacks in Only .. Pass_Through then\n+            Filter_Active := Apply_Filters (Session);\n+         end if;\n+\n+         exit when Callbacks = None\n+           or else Callbacks = Pass_Through\n+           or else (Callbacks = Only and then not Filter_Active);\n+\n+      end loop;\n+   end Get_Line;\n+\n+   ----------------------\n+   -- Number_Of_Fields --\n+   ----------------------\n+\n+   function Number_Of_Fields\n+     (Session : Session_Type := Current_Session)\n+      return    Count\n+   is\n+   begin\n+      return Count (Field_Table.Last (Session.Data.Fields));\n+   end Number_Of_Fields;\n+\n+   --------------------------\n+   -- Number_Of_File_Lines --\n+   --------------------------\n+\n+   function Number_Of_File_Lines\n+     (Session : Session_Type := Current_Session)\n+      return    Count\n+   is\n+   begin\n+      return Count (Session.Data.FNR);\n+   end Number_Of_File_Lines;\n+\n+   ---------------------\n+   -- Number_Of_Files --\n+   ---------------------\n+\n+   function Number_Of_Files\n+     (Session : Session_Type := Current_Session)\n+      return    Natural\n+   is\n+      Files : File_Table.Instance renames Session.Data.Files;\n+\n+   begin\n+      return File_Table.Last (Files);\n+   end Number_Of_Files;\n+\n+   ---------------------\n+   -- Number_Of_Lines --\n+   ---------------------\n+\n+   function Number_Of_Lines\n+     (Session : Session_Type := Current_Session)\n+      return    Count\n+   is\n+   begin\n+      return Count (Session.Data.NR);\n+   end Number_Of_Lines;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (Separators : String       := Use_Current;\n+      Filename   : String       := Use_Current;\n+      Session    : Session_Type := Current_Session)\n+   is\n+   begin\n+      if Text_IO.Is_Open (Session.Data.Current_File) then\n+         raise Session_Error;\n+      end if;\n+\n+      if Filename /= Use_Current then\n+         File_Table.Init (Session.Data.Files);\n+         Add_File (Filename, Session);\n+      end if;\n+\n+      if Separators /= Use_Current then\n+         Set_Field_Separators (Separators, Session);\n+      end if;\n+\n+      Open_Next_File (Session);\n+\n+   exception\n+      when End_Error =>\n+         raise File_Error;\n+   end Open;\n+\n+   --------------------\n+   -- Open_Next_File --\n+   --------------------\n+\n+   procedure Open_Next_File\n+     (Session : Session_Type := Current_Session)\n+   is\n+      Files : File_Table.Instance renames Session.Data.Files;\n+\n+   begin\n+      if Text_IO.Is_Open (Session.Data.Current_File) then\n+         Text_IO.Close (Session.Data.Current_File);\n+      end if;\n+\n+      Session.Data.File_Index := Session.Data.File_Index + 1;\n+\n+      --  If there are no mores file in the table, raise End_Error\n+\n+      if Session.Data.File_Index > File_Table.Last (Files) then\n+         raise End_Error;\n+      end if;\n+\n+      Text_IO.Open\n+        (File => Session.Data.Current_File,\n+         Name => Files.Table (Session.Data.File_Index).all,\n+         Mode => Text_IO.In_File);\n+   end Open_Next_File;\n+\n+   -----------\n+   -- Parse --\n+   -----------\n+\n+   procedure Parse\n+     (Separators : String       := Use_Current;\n+      Filename   : String       := Use_Current;\n+      Session    : Session_Type := Current_Session)\n+   is\n+      Filter_Active : Boolean;\n+   begin\n+      Open (Separators, Filename, Session);\n+\n+      while not End_Of_Data (Session) loop\n+         Get_Line (None, Session);\n+         Filter_Active := Apply_Filters (Session);\n+      end loop;\n+\n+      Close (Session);\n+   end Parse;\n+\n+   ---------------------\n+   -- Raise_With_Info --\n+   ---------------------\n+\n+   procedure Raise_With_Info\n+     (E       : Exceptions.Exception_Id;\n+      Message : String;\n+      Session : Session_Type)\n+   is\n+      function Filename return String;\n+      --  Returns current filename and \"??\" if the informations is not\n+      --  available.\n+\n+      function Line return String;\n+      --  Returns current line number without the leading space\n+\n+      --------------\n+      -- Filename --\n+      --------------\n+\n+      function Filename return String is\n+         File : constant String := AWK.File (Session);\n+\n+      begin\n+         if File = \"\" then\n+            return \"??\";\n+         else\n+            return File;\n+         end if;\n+      end Filename;\n+\n+      ----------\n+      -- Line --\n+      ----------\n+\n+      function Line return String is\n+         L : constant String := Natural'Image (Session.Data.FNR);\n+\n+      begin\n+         return L (2 .. L'Last);\n+      end Line;\n+\n+   --  Start of processing for Raise_With_Info\n+\n+   begin\n+      Exceptions.Raise_Exception\n+        (E,\n+         '[' & Filename & ':' & Line & \"] \" & Message);\n+      raise Constraint_Error; -- to please GNAT as this is a No_Return proc\n+   end Raise_With_Info;\n+\n+   ---------------\n+   -- Read_Line --\n+   ---------------\n+\n+   procedure Read_Line (Session : Session_Type) is\n+\n+      function Read_Line return String;\n+      --  Read a line in the current file. This implementation is recursive\n+      --  and does not have a limitation on the line length.\n+\n+      NR  : Natural renames Session.Data.NR;\n+      FNR : Natural renames Session.Data.FNR;\n+\n+      function Read_Line return String is\n+         Buffer : String (1 .. 1_024);\n+         Last   : Natural;\n+\n+      begin\n+         Text_IO.Get_Line (Session.Data.Current_File, Buffer, Last);\n+\n+         if Last = Buffer'Last then\n+            return Buffer & Read_Line;\n+         else\n+            return Buffer (1 .. Last);\n+         end if;\n+      end Read_Line;\n+\n+   --  Start of processing for Read_Line\n+\n+   begin\n+      if End_Of_File (Session) then\n+         Open_Next_File (Session);\n+         FNR := 0;\n+      end if;\n+\n+      Session.Data.Current_Line := To_Unbounded_String (Read_Line);\n+\n+      NR := NR + 1;\n+      FNR := FNR + 1;\n+   end Read_Line;\n+\n+   --------------\n+   -- Register --\n+   --------------\n+\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : String;\n+      Action  : Action_Callback;\n+      Session : Session_Type := Current_Session)\n+   is\n+      Filters   : Pattern_Action_Table.Instance renames Session.Data.Filters;\n+      U_Pattern : constant Unbounded_String := To_Unbounded_String (Pattern);\n+\n+   begin\n+      Pattern_Action_Table.Increment_Last (Filters);\n+\n+      Filters.Table (Pattern_Action_Table.Last (Filters)) :=\n+        (Pattern => new Patterns.String_Pattern'(U_Pattern, Field),\n+         Action  => new Actions.Simple_Action'(Proc => Action));\n+   end Register;\n+\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Action_Callback;\n+      Session : Session_Type := Current_Session)\n+   is\n+      Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n+\n+      A_Pattern : Patterns.Pattern_Matcher_Access :=\n+                    new Regpat.Pattern_Matcher'(Pattern);\n+   begin\n+      Pattern_Action_Table.Increment_Last (Filters);\n+\n+      Filters.Table (Pattern_Action_Table.Last (Filters)) :=\n+        (Pattern => new Patterns.Regexp_Pattern'(A_Pattern, Field),\n+         Action  => new Actions.Simple_Action'(Proc => Action));\n+   end Register;\n+\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Match_Action_Callback;\n+      Session : Session_Type := Current_Session)\n+   is\n+      Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n+\n+      A_Pattern : Patterns.Pattern_Matcher_Access :=\n+                    new Regpat.Pattern_Matcher'(Pattern);\n+   begin\n+      Pattern_Action_Table.Increment_Last (Filters);\n+\n+      Filters.Table (Pattern_Action_Table.Last (Filters)) :=\n+        (Pattern => new Patterns.Regexp_Pattern'(A_Pattern, Field),\n+         Action  => new Actions.Match_Action'(Proc => Action));\n+   end Register;\n+\n+   procedure Register\n+     (Pattern : Pattern_Callback;\n+      Action  : Action_Callback;\n+      Session : Session_Type := Current_Session)\n+   is\n+      Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n+\n+   begin\n+      Pattern_Action_Table.Increment_Last (Filters);\n+\n+      Filters.Table (Pattern_Action_Table.Last (Filters)) :=\n+        (Pattern => new Patterns.Callback_Pattern'(Pattern => Pattern),\n+         Action  => new Actions.Simple_Action'(Proc => Action));\n+   end Register;\n+\n+   procedure Register\n+     (Action  : Action_Callback;\n+      Session : Session_Type := Current_Session)\n+   is\n+   begin\n+      Register (Always_True'Access, Action, Session);\n+   end Register;\n+\n+   -----------------\n+   -- Set_Current --\n+   -----------------\n+\n+   procedure Set_Current (Session : Session_Type) is\n+   begin\n+      Cur_Session.Data := Session.Data;\n+   end Set_Current;\n+\n+   --------------------------\n+   -- Set_Field_Separators --\n+   --------------------------\n+\n+   procedure Set_Field_Separators\n+     (Separators : String       := Default_Separators;\n+      Session    : Session_Type := Current_Session)\n+   is\n+   begin\n+      Free (Session.Data.Separators);\n+\n+      Session.Data.Separators :=\n+        new Split.Separator'(Separators'Length, Separators);\n+\n+      --  If there is a current line read, split it according to the new\n+      --  separators.\n+\n+      if Session.Data.Current_Line /= Null_Unbounded_String then\n+         Split_Line (Session);\n+      end if;\n+   end Set_Field_Separators;\n+\n+   ----------------------\n+   -- Set_Field_Widths --\n+   ----------------------\n+\n+   procedure Set_Field_Widths\n+     (Field_Widths : Widths_Set;\n+      Session      : Session_Type := Current_Session) is\n+\n+   begin\n+      Free (Session.Data.Separators);\n+\n+      Session.Data.Separators :=\n+        new Split.Column'(Field_Widths'Length, Field_Widths);\n+\n+      --  If there is a current line read, split it according to\n+      --  the new separators.\n+\n+      if Session.Data.Current_Line /= Null_Unbounded_String then\n+         Split_Line (Session);\n+      end if;\n+   end Set_Field_Widths;\n+\n+   ----------------\n+   -- Split_Line --\n+   ----------------\n+\n+   procedure Split_Line (Session : Session_Type) is\n+      Fields : Field_Table.Instance renames Session.Data.Fields;\n+\n+   begin\n+      Field_Table.Init (Fields);\n+\n+      Split.Current_Line (Session.Data.Separators.all, Session);\n+   end Split_Line;\n+\n+begin\n+   --  We have declared two sessions but both should share the same data.\n+   --  The current session must point to the default session as its initial\n+   --  value. So first we release the session data then we set current\n+   --  session data to point to default session data.\n+\n+   Free (Cur_Session.Data);\n+   Cur_Session.Data := Def_Session.Data;\n+end GNAT.AWK;"}, {"sha": "9ac484f6e8242057c1272d2d2b115f8953cdbd6e", "filename": "gcc/ada/g-awk.ads", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-awk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-awk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-awk.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,589 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              G N A T . A W K                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--              Copyright (C) 2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--\n+--  This is an AWK-like unit. It provides an easy interface for parsing one\n+--  or more files containing formatted data. The file can be viewed seen as\n+--  a database where each record is a line and a field is a data element in\n+--  this line. In this implementation an AWK record is a line. This means\n+--  that a record cannot span multiple lines. The operating procedure is to\n+--  read files line by line, with each line being presented to the user of\n+--  the package. The interface provides services to access specific fields\n+--  in the line. Thus it is possible to control actions takn on a line based\n+--  on values of some fields. This can be achieved directly or by registering\n+--  callbacks triggered on programmed conditions.\n+--\n+--  The state of an AWK run is recorded in an object of type session.\n+--  The following is the procedure for using a session to control an\n+--  AWK run:\n+--\n+--     1) Specify which session is to be used. It is possible to use the\n+--        default session or to create a new one by declaring an object of\n+--        type Session_Type. For example:\n+--\n+--           Computers : Session_Type;\n+--\n+--     2) Specify how to cut a line into fields. There are two modes: using\n+--        character fields separators or column width. This is done by using\n+--        Set_Fields_Separators or Set_Fields_Width. For example by:\n+--\n+--           AWK.Set_Field_Separators (\";,\", Computers);\n+--\n+--        or by using iterators' Separators parameter.\n+--\n+--     3) Specify which files to parse. This is done with Add_File/Add_Files\n+--        services, or by using the iterators' Filename parameter. For\n+--        example:\n+--\n+--           AWK.Add_File (\"myfile.db\", Computers);\n+--\n+--     4) Run the AWK session using one of the provided iterators.\n+--\n+--           Parse\n+--              This is the most automated iterator. You can gain control on\n+--              the session only by registering one or more callbacks (see\n+--              Register).\n+--\n+--           Get_Line/End_Of_Data\n+--              This is a manual iterator to be used with a loop. You have\n+--              complete control on the session. You can use callbacks but\n+--              this is not required.\n+--\n+--           For_Every_Line\n+--              This provides a mixture of manual/automated iterator action.\n+--\n+--        Examples of these three approaches appear below\n+--\n+--  There is many ways to use this package. The following discussion shows\n+--  three approaches, using the three iterator forms, to using this package.\n+--  All examples will use the following file (computer.db):\n+--\n+--     Pluton;Windows-NT;Pentium III\n+--     Mars;Linux;Pentium Pro\n+--     Venus;Solaris;Sparc\n+--     Saturn;OS/2;i486\n+--     Jupiter;MacOS;PPC\n+--\n+--  1) Using Parse iterator\n+--\n+--     Here the first step is to register some action associated to a pattern\n+--     and then to call the Parse iterator (this is the simplest way to use\n+--     this unit). The default session is used here. For example to output the\n+--     second field (the OS) of computer \"Saturn\".\n+--\n+--           procedure Action is\n+--           begin\n+--              Put_Line (AWK.Field (2));\n+--           end Action;\n+--\n+--        begin\n+--           AWK.Register (1, \"Saturn\", Action'Access);\n+--           AWK.Parse (\";\", \"computer.db\");\n+--\n+--\n+--  2) Using the Get_Line/End_Of_Data iterator\n+--\n+--     Here you have full control. For example to do the same as\n+--     above but using a specific session, you could write:\n+--\n+--           Computer_File : Session_Type;\n+--\n+--        begin\n+--           AWK.Set_Current (Computer_File);\n+--           AWK.Open (Separators => \";\",\n+--                     Filename   => \"computer.db\");\n+--\n+--           --  Display Saturn OS\n+--\n+--           while not AWK.End_Of_File loop\n+--              AWK.Get_Line;\n+--\n+--              if AWK.Field (1) = \"Saturn\" then\n+--                 Put_Line (AWK.Field (2));\n+--              end if;\n+--           end loop;\n+--\n+--           AWK.Close (Computer_File);\n+--\n+--\n+--  3) Using For_Every_Line iterator\n+--\n+--     In this case you use a provided iterator and you pass the procedure\n+--     that must be called for each record. You could code the previous\n+--     example could be coded as follows (using the iterator quick interface\n+--     but without using the current session):\n+--\n+--           Computer_File : Session_Type;\n+--\n+--           procedure Action (Quit : in out Boolean) is\n+--           begin\n+--              if AWK.Field (1, Computer_File) = \"Saturn\" then\n+--                 Put_Line (AWK.Field (2, Computer_File));\n+--              end if;\n+--           end Action;\n+--\n+--           procedure Look_For_Saturn is\n+--              new AWK.For_Every_Line (Action);\n+--\n+--        begin\n+--           Look_For_Saturn (Separators => \";\",\n+--                            Filename   => \"computer.db\",\n+--                            Session    => Computer_File);\n+--\n+--           Integer_Text_IO.Put\n+--             (Integer (AWK.NR (Session => Computer_File)));\n+--           Put_Line (\" line(s) have been processed.\");\n+--\n+--  You can also use a regular expression for the pattern. Let us output\n+--  the computer name for all computer for which the OS has a character\n+--  O in its name.\n+--\n+--           Regexp   : String := \".*O.*\";\n+--\n+--           Matcher  : Regpat.Pattern_Matcher := Regpat.Compile (Regexp);\n+--\n+--           procedure Action is\n+--           begin\n+--              Text_IO.Put_Line (AWK.Field (2));\n+--           end Action;\n+--\n+--        begin\n+--           AWK.Register (2, Matcher, Action'Unrestricted_Access);\n+--           AWK.Parse (\";\", \"computer.db\");\n+--\n+\n+with Ada.Finalization;\n+with GNAT.Regpat;\n+\n+package GNAT.AWK is\n+\n+   Session_Error : exception;\n+   --  Raised when a Session is reused but is not closed.\n+\n+   File_Error : exception;\n+   --  Raised when there is a file problem (see below).\n+\n+   End_Error : exception;\n+   --  Raised when an attempt is made to read beyond the end of the last\n+   --  file of a session.\n+\n+   Field_Error : exception;\n+   --  Raised when accessing a field value which does not exist.\n+\n+   Data_Error : exception;\n+   --  Raised when it is not possible to convert a field value to a specific\n+   --  type.\n+\n+   type Count is new Natural;\n+\n+   type Widths_Set is array (Positive range <>) of Positive;\n+   --  Used to store a set of columns widths.\n+\n+   Default_Separators : constant String := \" \" & ASCII.HT;\n+\n+   Use_Current : constant String := \"\";\n+   --  Value used when no separator or filename is specified in iterators.\n+\n+   type Session_Type is limited private;\n+   --  This is the main exported type. A session is used to keep the state of\n+   --  a full AWK run. The state comprises a list of files, the current file,\n+   --  the number of line processed, the current line, the number of fields in\n+   --  the current line... A default session is provided (see Set_Current,\n+   --  Current_Session and Default_Session above).\n+\n+   ----------------------------\n+   -- Package initialization --\n+   ----------------------------\n+\n+   --  To be thread safe it is not possible to use the default provided\n+   --  session. Each task must used a specific session and specify it\n+   --  explicitly for every services.\n+\n+   procedure Set_Current (Session : Session_Type);\n+   --  Set the session to be used by default. This file will be used when the\n+   --  Session parameter in following services is not specified.\n+\n+   function Current_Session return Session_Type;\n+   --  Returns the session used by default by all services. This is the\n+   --  latest session specified by Set_Current service or the session\n+   --  provided by default with this implementation.\n+\n+   function Default_Session return Session_Type;\n+   --  Returns the default session provided by this package. Note that this is\n+   --  the session return by Current_Session if Set_Current has not been used.\n+\n+   procedure Set_Field_Separators\n+     (Separators : String       := Default_Separators;\n+      Session    : Session_Type := Current_Session);\n+   --  Set the field separators. Each character in the string is a field\n+   --  separator. When a line is read it will be split by field using the\n+   --  separators set here. Separators can be changed at any point and in this\n+   --  case the current line is split according to the new separators. In the\n+   --  special case that Separators is a space and a tabulation\n+   --  (Default_Separators), fields are separated by runs of spaces and/or\n+   --  tabs.\n+\n+   procedure Set_FS\n+     (Separators : String       := Default_Separators;\n+      Session    : Session_Type := Current_Session)\n+     renames Set_Field_Separators;\n+   --  FS is the AWK abbreviation for above service.\n+\n+   procedure Set_Field_Widths\n+     (Field_Widths : Widths_Set;\n+      Session      : Session_Type := Current_Session);\n+   --  This is another way to split a line by giving the length (in number of\n+   --  characters) of each field in a line. Field widths can be changed at any\n+   --  point and in this case the current line is split according to the new\n+   --  field lengths. A line split with this method must have a length equal or\n+   --  greater to the total of the field widths. All characters remaining on\n+   --  the line after the latest field are added to a new automatically\n+   --  created field.\n+\n+   procedure Add_File\n+     (Filename : String;\n+      Session  : Session_Type := Current_Session);\n+   --  Add Filename to the list of file to be processed. There is no limit on\n+   --  the number of files that can be added. Files are processed in the order\n+   --  they have been added (i.e. the filename list is FIFO). If Filename does\n+   --  not exist or if it is not readable, File_Error is raised.\n+\n+   procedure Add_Files\n+     (Directory             : String;\n+      Filenames             : String;\n+      Number_Of_Files_Added : out Natural;\n+      Session               : Session_Type := Current_Session);\n+   --  Add all files matching the regular expression Filenames in the specified\n+   --  directory to the list of file to be processed. There is no limit on\n+   --  the number of files that can be added. Each file is processed in\n+   --  the same order they have been added (i.e. the filename list is FIFO).\n+   --  The number of files (possibly 0) added is returned in\n+   --  Number_Of_Files_Added.\n+\n+   -------------------------------------\n+   -- Information about current state --\n+   -------------------------------------\n+\n+   function Number_Of_Fields\n+     (Session : Session_Type := Current_Session)\n+      return    Count;\n+   --  Returns the number of fields in the current record. It returns 0 when\n+   --  no file is being processed.\n+\n+   function NF\n+     (Session : Session_Type := Current_Session)\n+      return    Count\n+     renames Number_Of_Fields;\n+   --  AWK abbreviation for above service.\n+\n+   function Number_Of_File_Lines\n+     (Session : Session_Type := Current_Session)\n+      return    Count;\n+   --  Returns the current line number in the processed file. It returns 0 when\n+   --  no file is being processed.\n+\n+   function FNR\n+     (Session : Session_Type := Current_Session)\n+      return    Count renames Number_Of_File_Lines;\n+   --  AWK abbreviation for above service.\n+\n+   function Number_Of_Lines\n+     (Session : Session_Type := Current_Session)\n+      return    Count;\n+   --  Returns the number of line processed until now. This is equal to number\n+   --  of line in each already processed file plus FNR. It returns 0 when\n+   --  no file is being processed.\n+\n+   function NR\n+     (Session : Session_Type := Current_Session)\n+      return    Count\n+     renames Number_Of_Lines;\n+   --  AWK abbreviation for above service.\n+\n+   function Number_Of_Files\n+     (Session : Session_Type := Current_Session)\n+      return    Natural;\n+   --  Returns the number of files associated with Session. This is the total\n+   --  number of files added with Add_File and Add_Files services.\n+\n+   function File\n+     (Session : Session_Type := Current_Session)\n+      return    String;\n+   --  Returns the name of the file being processed. It returns the empty\n+   --  string when no file is being processed.\n+\n+   ---------------------\n+   -- Field accessors --\n+   ---------------------\n+\n+   function Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    String;\n+   --  Returns field number Rank value of the current record. If Rank = 0 it\n+   --  returns the current record (i.e. the line as read in the file). It\n+   --  raises Field_Error if Rank > NF or if Session is not open.\n+\n+   function Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    Integer;\n+   --  Returns field number Rank value of the current record as an integer. It\n+   --  raises Field_Error if Rank > NF or if Session is not open. It\n+   --  raises Data_Error if the field value cannot be converted to an integer.\n+\n+   function Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    Float;\n+   --  Returns field number Rank value of the current record as a float. It\n+   --  raises Field_Error if Rank > NF or if Session is not open. It\n+   --  raises Data_Error if the field value cannot be converted to a float.\n+\n+   generic\n+      type Discrete is (<>);\n+   function Discrete_Field\n+     (Rank    : Count;\n+      Session : Session_Type := Current_Session)\n+      return    Discrete;\n+   --  Returns field number Rank value of the current record as a type\n+   --  Discrete. It raises Field_Error if Rank > NF. It raises Data_Error if\n+   --  the field value cannot be converted to type Discrete.\n+\n+   --------------------\n+   -- Pattern/Action --\n+   --------------------\n+\n+   --  AWK defines rules like \"PATTERN { ACTION }\". Which means that ACTION\n+   --  will be executed if PATTERN match. A pattern in this implementation can\n+   --  be a simple string (match function is equality), a regular expression,\n+   --  a function returning a boolean. An action is associated to a pattern\n+   --  using the Register services.\n+   --\n+   --  Each procedure Register will add a rule to the set of rules for the\n+   --  session. Rules are examined in the order they have been added.\n+\n+   type Pattern_Callback is access function return Boolean;\n+   --  This is a pattern function pointer. When it returns True the associated\n+   --  action will be called.\n+\n+   type Action_Callback is access procedure;\n+   --  A simple action pointer\n+\n+   type Match_Action_Callback is\n+     access procedure (Matches : GNAT.Regpat.Match_Array);\n+   --  An advanced action pointer used with a regular expression pattern. It\n+   --  returns an array of all the matches. See GNAT.Regpat for further\n+   --  information.\n+\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : String;\n+      Action  : Action_Callback;\n+      Session : Session_Type := Current_Session);\n+   --  Register an Action associated with a Pattern. The pattern here is a\n+   --  simple string that must match exactly the field number specified.\n+\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Action_Callback;\n+      Session : Session_Type := Current_Session);\n+   --  Register an Action associated with a Pattern. The pattern here is a\n+   --  simple regular expression which must match the field number specified.\n+\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Match_Action_Callback;\n+      Session : Session_Type := Current_Session);\n+   --  Same as above but it pass the set of matches to the action\n+   --  procedure. This is useful to analyse further why and where a regular\n+   --  expression did match.\n+\n+   procedure Register\n+     (Pattern : Pattern_Callback;\n+      Action  : Action_Callback;\n+      Session : Session_Type := Current_Session);\n+   --  Register an Action associated with a Pattern. The pattern here is a\n+   --  function that must return a boolean. Action callback will be called if\n+   --  the pattern callback returns True and nothing will happen if it is\n+   --  False. This version is more general, the two other register services\n+   --  trigger an action based on the value of a single field only.\n+\n+   procedure Register\n+     (Action  : Action_Callback;\n+      Session : Session_Type := Current_Session);\n+   --  Register an Action that will be called for every line. This is\n+   --  equivalent to a Pattern_Callback function always returning True.\n+\n+   --------------------\n+   -- Parse iterator --\n+   --------------------\n+\n+   procedure Parse\n+     (Separators : String := Use_Current;\n+      Filename   : String := Use_Current;\n+      Session    : Session_Type := Current_Session);\n+   --  Launch the iterator, it will read every line in all specified\n+   --  session's files. Registered callbacks are then called if the associated\n+   --  pattern match. It is possible to specify a filename and a set of\n+   --  separators directly. This offer a quick way to parse a single\n+   --  file. These parameters will override those specified by Set_FS and\n+   --  Add_File. The Session will be opened and closed automatically.\n+   --  File_Error is raised if there is no file associated with Session, or if\n+   --  a file associated with Session is not longer readable. It raises\n+   --  Session_Error is Session is already open.\n+\n+   -----------------------------------\n+   -- Get_Line/End_Of_Data Iterator --\n+   -----------------------------------\n+\n+   type Callback_Mode is (None, Only, Pass_Through);\n+   --  These mode are used for Get_Line/End_Of_Data and For_Every_Line\n+   --  iterators. The associated semantic is:\n+   --\n+   --    None\n+   --       callbacks are not active. This is the default mode for\n+   --       Get_Line/End_Of_Data and For_Every_Line iterators.\n+   --\n+   --    Only\n+   --       callbacks are active, if at least one pattern match, the associated\n+   --       action is called and this line will not be passed to the user. In\n+   --       the Get_Line case the next line will be read (if there is some\n+   --       line remaining), in the For_Every_Line case Action will\n+   --       not be called for this line.\n+   --\n+   --    Pass_Through\n+   --       callbacks are active, for patterns which match the associated\n+   --       action is called. Then the line is passed to the user. It means\n+   --       that Action procedure is called in the For_Every_Line case and\n+   --       that Get_Line returns with the current line active.\n+   --\n+\n+   procedure Open\n+     (Separators : String := Use_Current;\n+      Filename   : String := Use_Current;\n+      Session    : Session_Type := Current_Session);\n+   --  Open the first file and initialize the unit. This must be called once\n+   --  before using Get_Line. It is possible to specify a filename and a set of\n+   --  separators directly. This offer a quick way to parse a single file.\n+   --  These parameters will override those specified by Set_FS and Add_File.\n+   --  File_Error is raised if there is no file associated with Session, or if\n+   --  the first file associated with Session is no longer readable. It raises\n+   --  Session_Error is Session is already open.\n+\n+   procedure Get_Line\n+     (Callbacks : Callback_Mode := None;\n+      Session   : Session_Type  := Current_Session);\n+   --  Read a line from the current input file. If the file index is at the\n+   --  end of the current input file (i.e. End_Of_File is True) then the\n+   --  following file is opened. If there is no more file to be processed,\n+   --  exception End_Error will be raised. File_Error will be raised if Open\n+   --  has not been called. Next call to Get_Line will return the following\n+   --  line in the file. By default the registered callbacks are not called by\n+   --  Get_Line, this can activated by setting Callbacks (see Callback_Mode\n+   --  description above). File_Error may be raised if a file associated with\n+   --  Session is not readable.\n+   --\n+   --  When Callbacks is not None, it is possible to exhaust all the lines\n+   --  of all the files associated with Session. In this case, File_Error\n+   --  is not raised.\n+   --\n+   --  This procedure can be used from a subprogram called by procedure Parse\n+   --  or by an instantiation of For_Every_Line (see below).\n+\n+\n+   function End_Of_Data\n+     (Session : Session_Type := Current_Session)\n+      return    Boolean;\n+   --  Returns True if there is no more data to be processed in Session. It\n+   --  means that the latest session's file is being processed and that\n+   --  there is no more data to be read in this file (End_Of_File is True).\n+\n+   function End_Of_File\n+     (Session : Session_Type := Current_Session)\n+      return    Boolean;\n+   --  Returns True when there is no more data to be processed on the current\n+   --  session's file.\n+\n+   procedure Close (Session : Session_Type);\n+   --  Release all associated data with Session. All memory allocated will\n+   --  be freed, the current file will be closed if needed, the callbacks\n+   --  will be unregistered. Close is convenient in reestablishing a session\n+   --  for new use. Get_Line is no longer usable (will raise File_Error)\n+   --  except after a successful call to Open, Parse or an instantiation\n+   --  of For_Every_Line.\n+\n+   -----------------------------\n+   -- For_Every_Line iterator --\n+   -----------------------------\n+\n+   generic\n+      with procedure Action (Quit : in out Boolean);\n+   procedure For_Every_Line\n+     (Separators : String := Use_Current;\n+      Filename   : String := Use_Current;\n+      Callbacks  : Callback_Mode := None;\n+      Session    : Session_Type := Current_Session);\n+   --  This is another iterator. Action will be called for each new\n+   --  record. The iterator's termination can be controlled by setting Quit\n+   --  to True. It is by default set to False. It is possible to specify a\n+   --  filename and a set of separators directly. This offer a quick way to\n+   --  parse a single file. These parameters will override those specified by\n+   --  Set_FS and Add_File. By default the registered callbacks are not called\n+   --  by For_Every_Line, this can activated by setting Callbacks (see\n+   --  Callback_Mode description above). The Session will be opened and\n+   --  closed automatically. File_Error is raised if there is no file\n+   --  associated with Session. It raises Session_Error is Session is already\n+   --  open.\n+\n+private\n+   pragma Inline (End_Of_File);\n+   pragma Inline (End_Of_Data);\n+   pragma Inline (Number_Of_Fields);\n+   pragma Inline (Number_Of_Lines);\n+   pragma Inline (Number_Of_Files);\n+   pragma Inline (Number_Of_File_Lines);\n+\n+   type Session_Data;\n+   type Session_Data_Access is access Session_Data;\n+\n+   type Session_Type is new Ada.Finalization.Limited_Controlled with record\n+      Data : Session_Data_Access;\n+   end record;\n+\n+   procedure Initialize (Session : in out Session_Type);\n+   procedure Finalize   (Session : in out Session_Type);\n+\n+end GNAT.AWK;"}, {"sha": "9c6c539c06f516b168e1fd78d6d513175341d040", "filename": "gcc/ada/g-busora.adb", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busora.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busora.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-busora.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                   G N A T . B U B B L E _ S O R T _ A                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1998 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Bubble_Sort_A is\n+\n+   ----------\n+   -- Sort --\n+   ----------\n+\n+   procedure Sort (N : Natural; Move : Move_Procedure; Lt : Lt_Function) is\n+      Switched : Boolean;\n+\n+   begin\n+      loop\n+         Switched := False;\n+\n+         for J in 1 .. N - 1 loop\n+            if Lt (J + 1, J) then\n+               Move (J, 0);\n+               Move (J + 1, J);\n+               Move (0, J + 1);\n+               Switched := True;\n+            end if;\n+         end loop;\n+\n+         exit when not Switched;\n+      end loop;\n+   end Sort;\n+\n+end GNAT.Bubble_Sort_A;"}, {"sha": "6c693c89ef35e83726e5a51c9fae25770cfd9ca2", "filename": "gcc/ada/g-busora.ads", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busora.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busora.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-busora.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,68 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                   G N A T . B U B B L E _ S O R T _ A                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $\n+--                                                                          --\n+--           Copyright (C) 1995-2000 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Bubblesort using access to procedure parameters\n+\n+--  This package provides a bubblesort routine that works with access to\n+--  subprogram parameters, so that it can be used with different types with\n+--  shared sorting code. See also GNAT.Bubble_Sort_G, the generic version\n+--  which is a little more efficient, but does not allow code sharing.\n+--  The generic version is also Pure, while the access version can\n+--  only be Preelaborate.\n+\n+package GNAT.Bubble_Sort_A is\n+pragma Preelaborate (Bubble_Sort_A);\n+\n+   --  The data to be sorted is assumed to be indexed by integer values from\n+   --  1 to N, where N is the number of items to be sorted. In addition, the\n+   --  index value zero is used for a temporary location used during the sort.\n+\n+   type Move_Procedure is access procedure (From : Natural; To : Natural);\n+   --  A pointer to a procedure that moves the data item with index From to\n+   --  the data item with index To. An index value of zero is used for moves\n+   --  from and to the single temporary location used by the sort.\n+\n+   type Lt_Function is access function (Op1, Op2 : Natural) return Boolean;\n+   --  A pointer to a function that compares two items and returns True if\n+   --  the item with index Op1 is less than the item with index Op2, and False\n+   --  if the Op2 item is greater than or equal to the Op1 item.\n+\n+   procedure Sort (N : Natural; Move : Move_Procedure; Lt : Lt_Function);\n+   --  This procedures sorts items in the range from 1 to N into ascending\n+   --  order making calls to Lt to do required comparisons, and Move to move\n+   --  items around. Note that, as described above, both Move and Lt use a\n+   --  single temporary location with index value zero. This sort is not\n+   --  stable, i.e. the order of equal elements in the input is not preserved.\n+\n+end GNAT.Bubble_Sort_A;"}, {"sha": "f16b6ef488b9a4dd947269b4802cab2479224558", "filename": "gcc/ada/g-busorg.adb", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busorg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busorg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-busorg.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                   G N A T . B U B B L E _ S O R T _ G                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1998 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Bubble_Sort_G is\n+\n+   ----------\n+   -- Sort --\n+   ----------\n+\n+   procedure Sort (N : Natural) is\n+      Switched : Boolean;\n+\n+   begin\n+      loop\n+         Switched := False;\n+\n+         for J in 1 .. N - 1 loop\n+            if Lt (J + 1, J) then\n+               Move (J, 0);\n+               Move (J + 1, J);\n+               Move (0, J + 1);\n+               Switched := True;\n+            end if;\n+         end loop;\n+\n+         exit when not Switched;\n+      end loop;\n+   end Sort;\n+\n+end GNAT.Bubble_Sort_G;"}, {"sha": "54183a724da3a762528a1a9b377b10e7831d7d80", "filename": "gcc/ada/g-busorg.ads", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busorg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-busorg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-busorg.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,68 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                   G N A T . B U B B L E _ S O R T _ G                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $\n+--                                                                          --\n+--           Copyright (C) 1995-2000 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Bubblesort generic package using formal procedures\n+\n+--  This package provides a generic bubble sort routine that can be used with\n+--  different types of data. See also GNAT.Bubble_Sort_A, a version that works\n+--  with subprogram parameters, allowing code sharing. The generic version\n+--  is slightly more efficient but does not allow code sharing. The generic\n+--  version is also Pure, while the access version can only be Preelaborate.\n+\n+generic\n+   --  The data to be sorted is assumed to be indexed by integer values from\n+   --  1 to N, where N is the number of items to be sorted. In addition, the\n+   --  index value zero is used for a temporary location used during the sort.\n+\n+   with procedure Move (From : Natural; To : Natural);\n+   --  A procedure that moves the data item with index From to the data item\n+   --  with Index To. An index value of zero is used for moves from and to a\n+   --  single temporary location used by the sort.\n+\n+   with function Lt (Op1, Op2 : Natural) return Boolean;\n+   --  A function that compares two items and returns True if the item with\n+   --  index Op1 is less than the item with Index Op2, and False if the Op2\n+   --  item is greater than or equal to the Op1 item.\n+\n+package GNAT.Bubble_Sort_G is\n+pragma Pure (Bubble_Sort_G);\n+\n+   procedure Sort (N : Natural);\n+   --  This procedures sorts items in the range from 1 to N into ascending\n+   --  order making calls to Lt to do required comparisons, and Move to move\n+   --  items around. Note that, as described above, both Move and Lt use a\n+   --  single temporary location with index value zero. This sort is not\n+   --  stable, i.e. the order of equal elements in the input is not preserved.\n+\n+end GNAT.Bubble_Sort_G;"}, {"sha": "76252ad7dbf3369384b5b1518340d5a397d7bd03", "filename": "gcc/ada/g-calend.adb", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-calend.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,319 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         G N A T . C A L E N D A R                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $\n+--                                                                          --\n+--           Copyright (C) 1999-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Calendar is\n+\n+   use Ada.Calendar;\n+   use Interfaces;\n+\n+   -----------------\n+   -- Day_In_Year --\n+   -----------------\n+\n+   function Day_In_Year (Date : Time) return Day_In_Year_Number is\n+      Year  : Year_Number;\n+      Month : Month_Number;\n+      Day   : Day_Number;\n+      Dsecs : Day_Duration;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Dsecs);\n+\n+      return Julian_Day (Year, Month, Day) - Julian_Day (Year, 1, 1) + 1;\n+   end Day_In_Year;\n+\n+   -----------------\n+   -- Day_Of_Week --\n+   -----------------\n+\n+   function Day_Of_Week (Date : Time) return Day_Name is\n+      Year  : Year_Number;\n+      Month : Month_Number;\n+      Day   : Day_Number;\n+      Dsecs : Day_Duration;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Dsecs);\n+\n+      return Day_Name'Val ((Julian_Day (Year, Month, Day)) mod 7);\n+   end Day_Of_Week;\n+\n+   ----------\n+   -- Hour --\n+   ----------\n+\n+   function Hour (Date : Time) return Hour_Number is\n+      Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n+      return Hour;\n+   end Hour;\n+\n+   ----------------\n+   -- Julian_Day --\n+   ----------------\n+\n+   --  Julian_Day is used to by Day_Of_Week and Day_In_Year. Note\n+   --  that this implementation is not expensive.\n+\n+   function Julian_Day\n+     (Year  : Year_Number;\n+      Month : Month_Number;\n+      Day   : Day_Number)\n+      return  Integer\n+   is\n+      Internal_Year  : Integer;\n+      Internal_Month : Integer;\n+      Internal_Day   : Integer;\n+      Julian_Date    : Integer;\n+      C              : Integer;\n+      Ya             : Integer;\n+\n+   begin\n+      Internal_Year  := Integer (Year);\n+      Internal_Month := Integer (Month);\n+      Internal_Day   := Integer (Day);\n+\n+      if Internal_Month > 2 then\n+         Internal_Month := Internal_Month - 3;\n+      else\n+         Internal_Month := Internal_Month + 9;\n+         Internal_Year  := Internal_Year - 1;\n+      end if;\n+\n+      C  := Internal_Year / 100;\n+      Ya := Internal_Year - (100 * C);\n+\n+      Julian_Date := (146_097 * C) / 4 +\n+        (1_461 * Ya) / 4 +\n+        (153 * Internal_Month + 2) / 5 +\n+        Internal_Day + 1_721_119;\n+\n+      return Julian_Date;\n+   end Julian_Day;\n+\n+   ------------\n+   -- Minute --\n+   ------------\n+\n+   function Minute (Date : Time) return Minute_Number is\n+      Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n+      return Minute;\n+   end Minute;\n+\n+   ------------\n+   -- Second --\n+   ------------\n+\n+   function Second (Date : Time) return Second_Number is\n+      Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n+      return Second;\n+   end Second;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   procedure Split\n+     (Date       : Time;\n+      Year       : out Year_Number;\n+      Month      : out Month_Number;\n+      Day        : out Day_Number;\n+      Hour       : out Hour_Number;\n+      Minute     : out Minute_Number;\n+      Second     : out Second_Number;\n+      Sub_Second : out Second_Duration)\n+   is\n+      Dsecs : Day_Duration;\n+      Secs  : Natural;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Dsecs);\n+\n+      if Dsecs = 0.0 then\n+         Secs := 0;\n+      else\n+         Secs := Natural (Dsecs - 0.5);\n+      end if;\n+\n+      Sub_Second := Second_Duration (Dsecs - Day_Duration (Secs));\n+      Hour       := Hour_Number (Secs / 3600);\n+      Secs       := Secs mod 3600;\n+      Minute     := Minute_Number (Secs / 60);\n+      Second     := Second_Number (Secs mod 60);\n+   end Split;\n+\n+   ----------------\n+   -- Sub_Second --\n+   ----------------\n+\n+   function Sub_Second (Date : Time) return Second_Duration is\n+      Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n+      return Sub_Second;\n+   end Sub_Second;\n+\n+   -------------\n+   -- Time_Of --\n+   -------------\n+\n+   function Time_Of\n+     (Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration := 0.0)\n+      return Time\n+   is\n+      Dsecs : constant Day_Duration :=\n+                Day_Duration (Hour * 3600 + Minute * 60 + Second) +\n+                                                             Sub_Second;\n+   begin\n+      return Time_Of (Year, Month, Day, Dsecs);\n+   end Time_Of;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (T : access timeval) return Duration is\n+\n+      procedure timeval_to_duration\n+        (T    : access timeval;\n+         sec  : access C.long;\n+         usec : access C.long);\n+      pragma Import (C, timeval_to_duration, \"__gnat_timeval_to_duration\");\n+\n+      Micro : constant := 10**6;\n+      sec   : aliased C.long;\n+      usec  : aliased C.long;\n+\n+\n+   begin\n+      timeval_to_duration (T, sec'Access, usec'Access);\n+      return Duration (sec) + Duration (usec) / Micro;\n+   end To_Duration;\n+\n+   ----------------\n+   -- To_Timeval --\n+   ----------------\n+\n+   function To_Timeval  (D : Duration) return timeval is\n+\n+      procedure duration_to_timeval (Sec, Usec : C.long; T : access timeval);\n+      pragma Import (C, duration_to_timeval, \"__gnat_duration_to_timeval\");\n+\n+      Micro  : constant := 10**6;\n+      Result : aliased timeval;\n+      sec    : C.long;\n+      usec   : C.long;\n+\n+   begin\n+      if D = 0.0 then\n+         sec  := 0;\n+         usec := 0;\n+      else\n+         sec  := C.long (D - 0.5);\n+         usec := C.long ((D - Duration (sec)) * Micro - 0.5);\n+      end if;\n+\n+      duration_to_timeval (sec, usec, Result'Access);\n+\n+      return Result;\n+   end To_Timeval;\n+\n+   ------------------\n+   -- Week_In_Year --\n+   ------------------\n+\n+   function Week_In_Year\n+     (Date : Ada.Calendar.Time)\n+      return Week_In_Year_Number\n+   is\n+      Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration;\n+      Offset     : Natural;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n+\n+      --  Day offset number for the first week of the year.\n+\n+      Offset := Julian_Day (Year, 1, 1) mod 7;\n+\n+      return 1 + ((Day_In_Year (Date) - 1) + Offset) / 7;\n+   end Week_In_Year;\n+\n+end GNAT.Calendar;"}, {"sha": "16548db37064a63d59e445d594256ee243f4216f", "filename": "gcc/ada/g-calend.ads", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-calend.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,131 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         G N A T . C A L E N D A R                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package extends Ada.Calendar to handle Hour, Minute, Second,\n+--  Second_Duration and Day_Of_Week and Day_In_Year from Calendar.Time.\n+--  Second_Duration precision depends on the target clock precision.\n+--\n+--  GNAT.Calendar provides the same kind of abstraction found in\n+--  Ada.Calendar. It provides Split and Time_Of to build and split a Time\n+--  data. And it provides accessor functions to get only one of Hour, Minute,\n+--  Second, Second_Duration. Other functions are to access more advanced\n+--  valueas like Day_Of_Week, Day_In_Year and Week_In_Year.\n+\n+with Ada.Calendar;\n+with Interfaces.C;\n+\n+package GNAT.Calendar is\n+\n+   type Day_Name is\n+     (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday);\n+\n+   subtype Hour_Number         is Natural range 0 .. 23;\n+   subtype Minute_Number       is Natural range 0 .. 59;\n+   subtype Second_Number       is Natural range 0 .. 59;\n+   subtype Second_Duration     is Ada.Calendar.Day_Duration range 0.0 .. 1.0;\n+   subtype Day_In_Year_Number  is Positive range 1 .. 366;\n+   subtype Week_In_Year_Number is Positive range 1 .. 53;\n+\n+   function Hour       (Date : Ada.Calendar.Time) return Hour_Number;\n+   function Minute     (Date : Ada.Calendar.Time) return Minute_Number;\n+   function Second     (Date : Ada.Calendar.Time) return Second_Number;\n+   function Sub_Second (Date : Ada.Calendar.Time) return Second_Duration;\n+   --  Hour, Minute, Sedond and Sub_Second returns the complete time data for\n+   --  the Date (H:M:S.SS). See Ada.Calendar for Year, Month, Day accessors.\n+   --  Second_Duration precision depends on the target clock precision.\n+\n+   function Day_Of_Week (Date : Ada.Calendar.Time) return Day_Name;\n+   --  Return the day name.\n+\n+   function Day_In_Year (Date : Ada.Calendar.Time) return Day_In_Year_Number;\n+   --  Returns the day number in the year. (1st January is day 1 and 31st\n+   --  December is day 365 or 366 for leap year).\n+\n+   function Week_In_Year (Date : Ada.Calendar.Time) return Week_In_Year_Number;\n+   --  Returns the week number in the year with Monday as first day of week\n+\n+   procedure Split\n+     (Date       : Ada.Calendar.Time;\n+      Year       : out Ada.Calendar.Year_Number;\n+      Month      : out Ada.Calendar.Month_Number;\n+      Day        : out Ada.Calendar.Day_Number;\n+      Hour       : out Hour_Number;\n+      Minute     : out Minute_Number;\n+      Second     : out Second_Number;\n+      Sub_Second : out Second_Duration);\n+   --  Split the standard Ada.Calendar.Time data in date data (Year, Month,\n+   --  Day) and Time data (Hour, Minute, Second, Sub_Second)\n+\n+   function Time_Of\n+     (Year       : Ada.Calendar.Year_Number;\n+      Month      : Ada.Calendar.Month_Number;\n+      Day        : Ada.Calendar.Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration := 0.0)\n+      return Ada.Calendar.Time;\n+   --  Returns an Ada.Calendar.Time data built from the date and time values.\n+\n+   --  C timeval conversion\n+\n+   --  C timeval represent a duration (used in Select for example). This\n+   --  structure is composed of a number of seconds and a number of micro\n+   --  seconds. The timeval structure is not exposed here because its\n+   --  definition is target dependent. Interface to C programs is done via a\n+   --  pointer to timeval structure.\n+\n+   type timeval is private;\n+\n+   function To_Duration (T : access timeval) return Duration;\n+   function To_Timeval  (D : Duration) return timeval;\n+\n+private\n+   --  This is a dummy declaration that should be the largest possible timeval\n+   --  structure of all supported targets.\n+\n+   type timeval is array (1 .. 2) of Interfaces.C.long;\n+\n+   function Julian_Day\n+     (Year  : Ada.Calendar.Year_Number;\n+      Month : Ada.Calendar.Month_Number;\n+      Day   : Ada.Calendar.Day_Number)\n+      return  Integer;\n+   --  Compute Julian day number.\n+   --\n+   --  The code of this function is a modified version of algorithm\n+   --  199 from the Collected Algorithms of the ACM.\n+   --  The author of algorithm 199 is Robert G. Tantzen.\n+end GNAT.Calendar;"}, {"sha": "dcedebecb43d3841af6f14c8c0d6019dbeb06836", "filename": "gcc/ada/g-casuti.adb", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-casuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-casuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-casuti.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,106 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                       G N A T . C A S E _ U T I L                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1999 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Case_Util is\n+\n+   --------------\n+   -- To_Lower --\n+   --------------\n+\n+   function To_Lower (A : Character) return Character is\n+      A_Val : constant Natural := Character'Pos (A);\n+\n+   begin\n+      if A in 'A' .. 'Z'\n+        or else A_Val in 16#C0# .. 16#D6#\n+        or else A_Val in 16#D8# .. 16#DE#\n+      then\n+         return Character'Val (A_Val + 16#20#);\n+      else\n+         return A;\n+      end if;\n+   end To_Lower;\n+\n+   procedure To_Lower (A : in out String) is\n+   begin\n+      for J in A'Range loop\n+         A (J) := To_Lower (A (J));\n+      end loop;\n+   end To_Lower;\n+\n+   --------------\n+   -- To_Mixed --\n+   --------------\n+\n+   procedure To_Mixed (A : in out String) is\n+      Ucase : Boolean := True;\n+\n+   begin\n+      for J in A'Range loop\n+         if Ucase then\n+            A (J) := To_Upper (A (J));\n+         else\n+            A (J) := To_Lower (A (J));\n+         end if;\n+\n+         Ucase := A (J) = '_';\n+      end loop;\n+   end To_Mixed;\n+\n+   --------------\n+   -- To_Upper --\n+   --------------\n+\n+   function To_Upper (A : Character) return Character is\n+      A_Val : constant Natural := Character'Pos (A);\n+\n+   begin\n+      if A in 'a' .. 'z'\n+        or else A_Val in 16#E0# .. 16#F6#\n+        or else A_Val in 16#F8# .. 16#FE#\n+      then\n+         return Character'Val (A_Val - 16#20#);\n+      else\n+         return A;\n+      end if;\n+   end To_Upper;\n+\n+   procedure To_Upper (A : in out String) is\n+   begin\n+      for J in A'Range loop\n+         A (J) := To_Upper (A (J));\n+      end loop;\n+   end To_Upper;\n+\n+end GNAT.Case_Util;"}, {"sha": "fb0959a6fcc69aa971927df0d257ec514db605ad", "filename": "gcc/ada/g-casuti.ads", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-casuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-casuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-casuti.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,64 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                       G N A T . C A S E _ U T I L                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1998 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Simple casing functions\n+\n+--  This package provides simple casing functions that do not require the\n+--  overhead of the full casing tables found in Ada.Characters.Handling.\n+\n+package GNAT.Case_Util is\n+pragma Pure (Case_Util);\n+\n+   --  Note: all the following functions handle the full Latin-1 set\n+\n+   function To_Upper (A : Character) return Character;\n+   --  Converts A to upper case if it is a lower case letter, otherwise\n+   --  returns the input argument unchanged.\n+\n+   procedure To_Upper (A : in out String);\n+   --  Folds all characters of string A to upper csae\n+\n+   function To_Lower (A : Character) return Character;\n+   --  Converts A to lower case if it is an upper case letter, otherwise\n+   --  returns the input argument unchanged.\n+\n+   procedure To_Lower (A : in out String);\n+   --  Folds all characters of string A to lower case\n+\n+   procedure To_Mixed (A : in out String);\n+   --  Converts A to mixed case (i.e. lower case, except for initial\n+   --  character and any character after an underscore, which are\n+   --  converted to upper case.\n+\n+end GNAT.Case_Util;"}, {"sha": "8f52cc3e8e114cb9ecb3b443ccaf78879126ae1d", "filename": "gcc/ada/g-catiio.adb", "status": "added", "additions": 465, "deletions": 0, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-catiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-catiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-catiio.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,465 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . C A L E N D A R . T I M E _ I O                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $\n+--                                                                          --\n+--            Copyright (C) 1999-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;            use Ada.Calendar;\n+with Ada.Characters.Handling;\n+with Ada.Strings.Unbounded;   use Ada.Strings.Unbounded;\n+with Ada.Text_IO;\n+\n+package body GNAT.Calendar.Time_IO is\n+\n+   type Month_Name is\n+     (January,\n+      Febuary,\n+      March,\n+      April,\n+      May,\n+      June,\n+      July,\n+      August,\n+      September,\n+      October,\n+      November,\n+      December);\n+\n+   type Padding_Mode is (None, Zero, Space);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Am_Pm (H : Natural) return String;\n+   --  return AM or PM depending on the hour H\n+\n+   function Hour_12 (H : Natural) return Positive;\n+   --  Convert a 1-24h format to a 0-12 hour format.\n+\n+   function Image (Str : String; Length : Natural := 0) return String;\n+   --  Return Str capitalized and cut to length number of characters. If\n+   --  length is set to 0 it does not cut it.\n+\n+   function Image\n+     (N       : Long_Integer;\n+      Padding : Padding_Mode := Zero;\n+      Length  : Natural := 0)\n+      return    String;\n+   --  Return image of N. This number is eventually padded with zeros or\n+   --  spaces depending of the length required. If length is 0 then no padding\n+   --  occurs.\n+\n+   function Image\n+     (N       : Integer;\n+      Padding : Padding_Mode := Zero;\n+      Length  : Natural := 0)\n+      return    String;\n+   --  As above with N provided in Integer format.\n+\n+   -----------\n+   -- Am_Pm --\n+   -----------\n+\n+   function Am_Pm (H : Natural) return String is\n+   begin\n+      if H = 0 or else H > 12 then\n+         return \"PM\";\n+      else\n+         return \"AM\";\n+      end if;\n+   end Am_Pm;\n+\n+   -------------\n+   -- Hour_12 --\n+   -------------\n+\n+   function Hour_12 (H : Natural) return Positive is\n+   begin\n+      if H = 0 then\n+         return 12;\n+      elsif H <= 12 then\n+         return H;\n+      else --  H > 12\n+         return H - 12;\n+      end if;\n+   end Hour_12;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image\n+     (Str    : String;\n+      Length : Natural := 0)\n+      return   String\n+   is\n+      use Ada.Characters.Handling;\n+      Local : String := To_Upper (Str (1)) & To_Lower (Str (2 .. Str'Last));\n+\n+   begin\n+      if Length = 0 then\n+         return Local;\n+      else\n+         return Local (1 .. Length);\n+      end if;\n+   end Image;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image\n+     (N       : Integer;\n+      Padding : Padding_Mode := Zero;\n+      Length  : Natural := 0)\n+      return    String\n+   is\n+   begin\n+      return Image (Long_Integer (N), Padding, Length);\n+   end Image;\n+\n+   function Image\n+     (N       : Long_Integer;\n+      Padding : Padding_Mode := Zero;\n+      Length  : Natural := 0)\n+      return    String\n+   is\n+      function Pad_Char return String;\n+\n+      function Pad_Char return String is\n+      begin\n+         case Padding is\n+            when None  => return \"\";\n+            when Zero  => return \"00\";\n+            when Space => return \"  \";\n+         end case;\n+      end Pad_Char;\n+\n+      NI  : constant String := Long_Integer'Image (N);\n+      NIP : constant String := Pad_Char & NI (2 .. NI'Last);\n+\n+   --  Start of processing for Image\n+\n+   begin\n+      if Length = 0 or else Padding = None then\n+         return NI (2 .. NI'Last);\n+\n+      else\n+         return NIP (NIP'Last - Length + 1 .. NIP'Last);\n+      end if;\n+   end Image;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image\n+     (Date    : Ada.Calendar.Time;\n+      Picture : Picture_String)\n+      return    String\n+   is\n+      Padding    : Padding_Mode := Zero;\n+      --  Padding is set for one directive\n+\n+      Result     : Unbounded_String;\n+\n+      Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration;\n+\n+      P : Positive := Picture'First;\n+\n+   begin\n+      Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n+\n+      loop\n+         --  A directive has the following format \"%[-_].\"\n+\n+         if Picture (P) = '%' then\n+\n+            Padding := Zero;\n+\n+            if P = Picture'Last then\n+               raise Picture_Error;\n+            end if;\n+\n+            --  Check for GNU extension to change the padding\n+\n+            if Picture (P + 1) = '-' then\n+               Padding := None;\n+               P := P + 1;\n+            elsif Picture (P + 1) = '_' then\n+               Padding := Space;\n+               P := P + 1;\n+            end if;\n+\n+            if P = Picture'Last then\n+               raise Picture_Error;\n+            end if;\n+\n+            case Picture (P + 1) is\n+\n+               --  Literal %\n+\n+               when '%' =>\n+                  Result := Result & '%';\n+\n+               --  A newline\n+\n+               when 'n' =>\n+                  Result := Result & ASCII.LF;\n+\n+               --  A horizontal tab\n+\n+               when 't' =>\n+                  Result := Result & ASCII.HT;\n+\n+               --  Hour (00..23)\n+\n+               when 'H' =>\n+                  Result := Result & Image (Hour, Padding, 2);\n+\n+               --  Hour (01..12)\n+\n+               when 'I' =>\n+                  Result := Result & Image (Hour_12 (Hour), Padding, 2);\n+\n+               --  Hour ( 0..23)\n+\n+               when 'k' =>\n+                  Result := Result & Image (Hour, Space, 2);\n+\n+               --  Hour ( 1..12)\n+\n+               when 'l' =>\n+                  Result := Result & Image (Hour_12 (Hour), Space, 2);\n+\n+               --  Minute (00..59)\n+\n+               when 'M' =>\n+                  Result := Result & Image (Minute, Padding, 2);\n+\n+               --  AM/PM\n+\n+               when 'p' =>\n+                  Result := Result & Am_Pm (Hour);\n+\n+               --  Time, 12-hour (hh:mm:ss [AP]M)\n+\n+               when 'r' =>\n+                  Result := Result &\n+                    Image (Hour_12 (Hour), Padding, Length => 2) & ':' &\n+                    Image (Minute, Padding, Length => 2) & ':' &\n+                    Image (Second, Padding, Length => 2) & ' ' &\n+                    Am_Pm (Hour);\n+\n+               --   Seconds  since 1970-01-01  00:00:00 UTC\n+               --   (a nonstandard extension)\n+\n+               when 's' =>\n+                  declare\n+                     Sec : constant Long_Integer :=\n+                             Long_Integer\n+                               ((Julian_Day (Year, Month, Day) -\n+                                  Julian_Day (1970, 1, 1)) * 86_400 +\n+                                Hour * 3_600 + Minute * 60 + Second);\n+\n+                  begin\n+                     Result := Result & Image (Sec, None);\n+                  end;\n+\n+               --  Second (00..59)\n+\n+               when 'S' =>\n+                  Result := Result & Image (Second, Padding, Length => 2);\n+\n+               --  Time, 24-hour (hh:mm:ss)\n+\n+               when 'T' =>\n+                  Result := Result &\n+                    Image (Hour, Padding, Length => 2) & ':' &\n+                    Image (Minute, Padding, Length => 2) & ':' &\n+                    Image (Second, Padding, Length => 2);\n+\n+               --  Locale's abbreviated weekday name (Sun..Sat)\n+\n+               when 'a' =>\n+                  Result := Result &\n+                    Image (Day_Name'Image (Day_Of_Week (Date)), 3);\n+\n+               --  Locale's full weekday name, variable length\n+               --  (Sunday..Saturday)\n+\n+               when 'A' =>\n+                  Result := Result &\n+                    Image (Day_Name'Image (Day_Of_Week (Date)));\n+\n+               --  Locale's abbreviated month name (Jan..Dec)\n+\n+               when 'b' | 'h' =>\n+                  Result := Result &\n+                    Image (Month_Name'Image (Month_Name'Val (Month - 1)), 3);\n+\n+               --  Locale's full month name, variable length\n+               --  (January..December)\n+\n+               when 'B' =>\n+                  Result := Result &\n+                    Image (Month_Name'Image (Month_Name'Val (Month - 1)));\n+\n+               --  Locale's date and time (Sat Nov 04 12:02:33 EST 1989)\n+\n+               when 'c' =>\n+                  case Padding is\n+                     when Zero =>\n+                        Result := Result & Image (Date, \"%a %b %d %T %Y\");\n+                     when Space =>\n+                        Result := Result & Image (Date, \"%a %b %_d %_T %Y\");\n+                     when None =>\n+                        Result := Result & Image (Date, \"%a %b %-d %-T %Y\");\n+                  end case;\n+\n+               --   Day of month (01..31)\n+\n+               when 'd' =>\n+                  Result := Result & Image (Day, Padding, 2);\n+\n+               --  Date (mm/dd/yy)\n+\n+               when 'D' | 'x' =>\n+                  Result := Result &\n+                    Image (Month, Padding, 2) & '/' &\n+                    Image (Day, Padding, 2) & '/' &\n+                    Image (Year, Padding, 2);\n+\n+               --  Day of year (001..366)\n+\n+               when 'j' =>\n+                  Result := Result & Image (Day_In_Year (Date), Padding, 3);\n+\n+               --  Month (01..12)\n+\n+               when 'm' =>\n+                  Result := Result & Image (Month, Padding, 2);\n+\n+               --  Week number of year with Sunday as first day of week\n+               --  (00..53)\n+\n+               when 'U' =>\n+                  declare\n+                     Offset : constant Natural :=\n+                                (Julian_Day (Year, 1, 1) + 1) mod 7;\n+\n+                     Week : constant Natural :=\n+                              1 + ((Day_In_Year (Date) - 1) + Offset) / 7;\n+\n+                  begin\n+                     Result := Result & Image (Week, Padding, 2);\n+                  end;\n+\n+               --  Day of week (0..6) with 0 corresponding to Sunday\n+\n+               when 'w' =>\n+                  declare\n+                     DOW : Natural range 0 .. 6;\n+\n+                  begin\n+                     if Day_Of_Week (Date) = Sunday then\n+                        DOW := 0;\n+                     else\n+                        DOW := Day_Name'Pos (Day_Of_Week (Date));\n+                     end if;\n+\n+                     Result := Result & Image (DOW, Length => 1);\n+                  end;\n+\n+               --  Week number of year with Monday as first day of week\n+               --  (00..53)\n+\n+               when 'W' =>\n+                  Result := Result & Image (Week_In_Year (Date), Padding, 2);\n+\n+               --  Last two digits of year (00..99)\n+\n+               when 'y' =>\n+                  declare\n+                     Y : constant Natural := Year - (Year / 100) * 100;\n+\n+                  begin\n+                     Result := Result & Image (Y, Padding, 2);\n+                  end;\n+\n+               --   Year (1970...)\n+\n+               when 'Y' =>\n+                  Result := Result & Image (Year, None, 4);\n+\n+               when others =>\n+                  raise Picture_Error;\n+            end case;\n+\n+            P := P + 2;\n+\n+         else\n+            Result := Result & Picture (P);\n+            P := P + 1;\n+         end if;\n+\n+         exit when P > Picture'Last;\n+\n+      end loop;\n+\n+      return To_String (Result);\n+   end Image;\n+\n+   --------------\n+   -- Put_Time --\n+   --------------\n+\n+   procedure Put_Time\n+     (Date    : Ada.Calendar.Time;\n+      Picture : Picture_String)\n+   is\n+   begin\n+      Ada.Text_IO.Put (Image (Date, Picture));\n+   end Put_Time;\n+\n+end GNAT.Calendar.Time_IO;"}, {"sha": "59f0520becc63a4e8222e957179a5ed9e55a6542", "filename": "gcc/ada/g-catiio.ads", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-catiio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-catiio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-catiio.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,131 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . C A L E N D A R . T I M E _ I O                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--            Copyright (C) 1999-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package augments standard Ada.Text_IO with facilities for input\n+--  and output of time values in standardized format.\n+\n+package GNAT.Calendar.Time_IO is\n+\n+   Picture_Error : exception;\n+\n+   type Picture_String is new String;\n+\n+   --  This is a string to describe date and time output format. The string is\n+   --  a set of standard character and special tag that are replaced by the\n+   --  corresponding values. It follows the GNU Date specification. Here are\n+   --  the recognized directives :\n+   --\n+   --          %    a literal %\n+   --          n    a newline\n+   --          t    a horizontal tab\n+   --\n+   --          Time fields:\n+   --\n+   --          %H   hour (00..23)\n+   --          %I   hour (01..12)\n+   --          %k   hour ( 0..23)\n+   --          %l   hour ( 1..12)\n+   --          %M   minute (00..59)\n+   --          %p   locale's AM or PM\n+   --          %r   time, 12-hour (hh:mm:ss [AP]M)\n+   --          %s   seconds  since 1970-01-01  00:00:00 UTC\n+   --                (a nonstandard extension)\n+   --          %S   second (00..59)\n+   --          %T   time, 24-hour (hh:mm:ss)\n+   --\n+   --          Date fields:\n+   --\n+   --          %a   locale's abbreviated weekday name (Sun..Sat)\n+   --          %A   locale's    full   weekday   name,    variable   length\n+   --                  (Sunday..Saturday)\n+   --          %b   locale's abbreviated month name (Jan..Dec)\n+   --          %B   locale's    full    month    name,   variable    length\n+   --                  (January..December)\n+   --          %c   locale's date and time (Sat Nov 04 12:02:33 EST 1989)\n+   --          %d   day of month (01..31)\n+   --          %D   date (mm/dd/yy)\n+   --          %h   same as %b\n+   --          %j   day of year (001..366)\n+   --          %m   month (01..12)\n+   --          %U   week number  of year with  Sunday as first day  of week\n+   --                  (00..53)\n+   --          %w   day of week (0..6) with 0 corresponding to Sunday\n+   --          %W   week number  of year with  Monday as first day  of week\n+   --                  (00..53)\n+   --          %x   locale's date representation (mm/dd/yy)\n+   --          %y   last two digits of year (00..99)\n+   --          %Y   year (1970...)\n+   --\n+   --          By default,  date pads numeric fields with zeroes.  GNU date\n+   --          recognizes the following nonstandard numeric modifiers:\n+   --\n+   --          -    (hyphen) do not pad the field\n+   --          _    (underscore) pad the field with spaces\n+\n+   ISO_Date      : constant Picture_String;\n+   --  This format follow the ISO 8601 standard. The format is \"YYYY-MM-DD\",\n+   --  four digits year, month and day number separated by minus.\n+\n+   US_Date       : constant Picture_String;\n+   --  This format is the common US date format: \"MM/DD/YY\",\n+   --  month and day number, two digits year separated by slashes.\n+\n+   European_Date : constant Picture_String;\n+   --  This format is the common European date format: \"DD/MM/YY\",\n+   --  day and month number, two digits year separated by slashes.\n+\n+   function Image\n+     (Date    : Ada.Calendar.Time;\n+      Picture : Picture_String)\n+      return    String;\n+   --  Return Date as a string with format Picture.\n+   --  raise Picture_Error if picture string is wrong\n+\n+   procedure Put_Time\n+     (Date    : Ada.Calendar.Time;\n+      Picture : Picture_String);\n+   --  Put Date with format Picture.\n+   --  raise Picture_Error if picture string is wrong\n+\n+private\n+   ISO_Date      : constant Picture_String := \"%Y-%m-%d\";\n+   US_Date       : constant Picture_String := \"%m/%d/%y\";\n+   European_Date : constant Picture_String := \"%d/%m/%y\";\n+\n+end GNAT.Calendar.Time_IO;"}, {"sha": "1cd910028dcf516aea8065fe76401f6c7d87fbfd", "filename": "gcc/ada/g-cgi.adb", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgi.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,491 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             G N A T . C G I                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $\n+--                                                                          --\n+--              Copyright (C) 2001 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+with Ada.Strings.Fixed;\n+with Ada.Characters.Handling;\n+with Ada.Strings.Maps;\n+\n+with GNAT.OS_Lib;\n+with GNAT.Table;\n+\n+package body GNAT.CGI is\n+\n+   use Ada;\n+\n+   Valid_Environment : Boolean := True;\n+   --  This boolean will be set to False if the initialization was not\n+   --  completed correctly. It must be set to true there because the\n+   --  Initialize routine (called during elaboration) will use some of the\n+   --  services exported by this unit.\n+\n+   Current_Method : Method_Type;\n+   --  This is the current method used to pass CGI parameters.\n+\n+   Header_Sent : Boolean := False;\n+   --  Will be set to True when the header will be sent.\n+\n+   --  Key/Value table declaration\n+\n+   type String_Access is access String;\n+\n+   type Key_Value is record\n+      Key   : String_Access;\n+      Value : String_Access;\n+   end record;\n+\n+   package Key_Value_Table is new Table (Key_Value, Positive, 1, 1, 50);\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   procedure Check_Environment;\n+   pragma Inline (Check_Environment);\n+   --  This procedure will raise Data_Error if Valid_Environment is False.\n+\n+   procedure Initialize;\n+   --  Initialize CGI package by reading the runtime environment. This\n+   --  procedure is called during elaboration. All exceptions raised during\n+   --  this procedure are deferred.\n+\n+   --------------------\n+   -- Argument_Count --\n+   --------------------\n+\n+   function Argument_Count return Natural is\n+   begin\n+      Check_Environment;\n+      return Key_Value_Table.Last;\n+   end Argument_Count;\n+\n+   -----------------------\n+   -- Check_Environment --\n+   -----------------------\n+\n+   procedure Check_Environment is\n+   begin\n+      if not Valid_Environment then\n+         raise Data_Error;\n+      end if;\n+   end Check_Environment;\n+\n+   ------------\n+   -- Decode --\n+   ------------\n+\n+   function Decode (S : String) return String is\n+      Result : String (S'Range);\n+      K      : Positive := S'First;\n+      J      : Positive := Result'First;\n+\n+   begin\n+      while K <= S'Last loop\n+         if K + 2 <= S'Last\n+           and then  S (K) = '%'\n+           and then Characters.Handling.Is_Hexadecimal_Digit (S (K + 1))\n+           and then Characters.Handling.Is_Hexadecimal_Digit (S (K + 2))\n+         then\n+            --  Here we have '%HH' which is an encoded character where 'HH' is\n+            --  the character number in hexadecimal.\n+\n+            Result (J) := Character'Val\n+              (Natural'Value (\"16#\" & S (K + 1 .. K + 2) & '#'));\n+            K := K + 3;\n+\n+         else\n+            Result (J) := S (K);\n+            K := K + 1;\n+         end if;\n+\n+         J := J + 1;\n+      end loop;\n+\n+      return Result (Result'First .. J - 1);\n+   end Decode;\n+\n+   -------------------------\n+   -- For_Every_Parameter --\n+   -------------------------\n+\n+   procedure For_Every_Parameter is\n+      Quit : Boolean;\n+\n+   begin\n+      Check_Environment;\n+\n+      for K in 1 .. Key_Value_Table.Last loop\n+\n+         Quit := False;\n+\n+         Action (Key_Value_Table.Table (K).Key.all,\n+                 Key_Value_Table.Table (K).Value.all,\n+                 K,\n+                 Quit);\n+\n+         exit when Quit;\n+\n+      end loop;\n+   end For_Every_Parameter;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+\n+      Request_Method : constant String :=\n+                         Characters.Handling.To_Upper\n+                           (Metavariable (CGI.Request_Method));\n+\n+      procedure Initialize_GET;\n+      --  Read CGI parameters for a GET method. In this case the parameters\n+      --  are passed into QUERY_STRING environment variable.\n+\n+      procedure Initialize_POST;\n+      --  Read CGI parameters for a POST method. In this case the parameters\n+      --  are passed with the standard input. The total number of characters\n+      --  for the data is passed in CONTENT_LENGTH environment variable.\n+\n+      procedure Set_Parameter_Table (Data : String);\n+      --  Parse the parameter data and set the parameter table.\n+\n+      --------------------\n+      -- Initialize_GET --\n+      --------------------\n+\n+      procedure Initialize_GET is\n+         Data : constant String := Metavariable (Query_String);\n+      begin\n+         Current_Method := Get;\n+         if Data /= \"\" then\n+            Set_Parameter_Table (Data);\n+         end if;\n+      end Initialize_GET;\n+\n+      ---------------------\n+      -- Initialize_POST --\n+      ---------------------\n+\n+      procedure Initialize_POST is\n+         Content_Length : constant Natural :=\n+                            Natural'Value (Metavariable (CGI.Content_Length));\n+         Data : String (1 .. Content_Length);\n+\n+      begin\n+         Current_Method := Post;\n+\n+         if Content_Length /= 0 then\n+            Text_IO.Get (Data);\n+            Set_Parameter_Table (Data);\n+         end if;\n+      end Initialize_POST;\n+\n+      -------------------------\n+      -- Set_Parameter_Table --\n+      -------------------------\n+\n+      procedure Set_Parameter_Table (Data : String) is\n+\n+         procedure Add_Parameter (K : Positive; P : String);\n+         --  Add a single parameter into the table at index K. The parameter\n+         --  format is \"key=value\".\n+\n+         Count : constant Positive :=\n+                   1 + Strings.Fixed.Count (Data, Strings.Maps.To_Set (\"&\"));\n+         --  Count is the number of parameters in the string. Parameters are\n+         --  separated by ampersand character.\n+\n+         Index : Positive := Data'First;\n+         Amp   : Natural;\n+\n+         -------------------\n+         -- Add_Parameter --\n+         -------------------\n+\n+         procedure Add_Parameter (K : Positive; P : String) is\n+            Equal : constant Natural := Strings.Fixed.Index (P, \"=\");\n+\n+         begin\n+            if Equal = 0 then\n+               raise Data_Error;\n+\n+            else\n+               Key_Value_Table.Table (K) :=\n+                 Key_Value'(new String'(Decode (P (P'First .. Equal - 1))),\n+                            new String'(Decode (P (Equal + 1 .. P'Last))));\n+            end if;\n+         end Add_Parameter;\n+\n+      --  Start of processing for Set_Parameter_Table\n+\n+      begin\n+         Key_Value_Table.Set_Last (Count);\n+\n+         for K in 1 .. Count - 1 loop\n+            Amp := Strings.Fixed.Index (Data (Index .. Data'Last), \"&\");\n+\n+            Add_Parameter (K, Data (Index .. Amp - 1));\n+\n+            Index := Amp + 1;\n+         end loop;\n+\n+         --  add last parameter\n+\n+         Add_Parameter (Count, Data (Index .. Data'Last));\n+      end Set_Parameter_Table;\n+\n+   --  Start of processing for Initialize\n+\n+   begin\n+      if Request_Method = \"GET\" then\n+         Initialize_GET;\n+\n+      elsif Request_Method = \"POST\" then\n+         Initialize_POST;\n+\n+      else\n+         Valid_Environment := False;\n+      end if;\n+\n+   exception\n+      when others =>\n+\n+         --  If we have an exception during initialization of this unit we\n+         --  just declare it invalid.\n+\n+         Valid_Environment := False;\n+   end Initialize;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Position : Positive) return String is\n+   begin\n+      Check_Environment;\n+\n+      if Position <= Key_Value_Table.Last then\n+         return Key_Value_Table.Table (Position).Key.all;\n+      else\n+         raise Parameter_Not_Found;\n+      end if;\n+   end Key;\n+\n+   ----------------\n+   -- Key_Exists --\n+   ----------------\n+\n+   function Key_Exists (Key : String) return Boolean is\n+   begin\n+      Check_Environment;\n+\n+      for K in 1 .. Key_Value_Table.Last loop\n+         if Key_Value_Table.Table (K).Key.all = Key then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Key_Exists;\n+\n+   ------------------\n+   -- Metavariable --\n+   ------------------\n+\n+   function Metavariable\n+     (Name     : Metavariable_Name;\n+      Required : Boolean := False) return String\n+   is\n+      function Get_Environment (Variable_Name : String) return String;\n+      --  Returns the environment variable content.\n+\n+      ---------------------\n+      -- Get_Environment --\n+      ---------------------\n+\n+      function Get_Environment (Variable_Name : String) return String is\n+         Value : OS_Lib.String_Access := OS_Lib.Getenv (Variable_Name);\n+         Result : constant String := Value.all;\n+\n+      begin\n+         OS_Lib.Free (Value);\n+         return Result;\n+      end Get_Environment;\n+\n+      Result : constant String :=\n+                 Get_Environment (Metavariable_Name'Image (Name));\n+\n+   --  Start of processing for Metavariable\n+\n+   begin\n+      Check_Environment;\n+\n+      if Result = \"\" and then Required then\n+         raise Parameter_Not_Found;\n+      else\n+         return Result;\n+      end if;\n+   end Metavariable;\n+\n+   -------------------------\n+   -- Metavariable_Exists --\n+   -------------------------\n+\n+   function Metavariable_Exists (Name : Metavariable_Name) return Boolean is\n+   begin\n+      Check_Environment;\n+\n+      if Metavariable (Name) = \"\" then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Metavariable_Exists;\n+\n+   ------------\n+   -- Method --\n+   ------------\n+\n+   function Method return Method_Type is\n+   begin\n+      Check_Environment;\n+      return Current_Method;\n+   end Method;\n+\n+   --------\n+   -- Ok --\n+   --------\n+\n+   function Ok return Boolean is\n+   begin\n+      return Valid_Environment;\n+   end Ok;\n+\n+   ----------------\n+   -- Put_Header --\n+   ----------------\n+\n+   procedure Put_Header\n+     (Header : String  := Default_Header;\n+      Force  : Boolean := False)\n+   is\n+   begin\n+      if Header_Sent = False or else Force then\n+         Check_Environment;\n+         Text_IO.Put_Line (Header);\n+         Text_IO.New_Line;\n+         Header_Sent := True;\n+      end if;\n+   end Put_Header;\n+\n+   ---------\n+   -- URL --\n+   ---------\n+\n+   function URL return String is\n+\n+      function Exists_And_Not_80 (Server_Port : String) return String;\n+      --  Returns ':' & Server_Port if Server_Port is not \"80\" and the empty\n+      --  string otherwise (80 is the default sever port).\n+\n+      -----------------------\n+      -- Exists_And_Not_80 --\n+      -----------------------\n+\n+      function Exists_And_Not_80 (Server_Port : String) return String is\n+      begin\n+         if Server_Port = \"80\" then\n+            return \"\";\n+         else\n+            return ':' & Server_Port;\n+         end if;\n+      end Exists_And_Not_80;\n+\n+   --  Start of processing for URL\n+\n+   begin\n+      Check_Environment;\n+\n+      return \"http://\"\n+        & Metavariable (Server_Name)\n+        & Exists_And_Not_80 (Metavariable (Server_Port))\n+        & Metavariable (Script_Name);\n+   end URL;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value\n+     (Key      : String;\n+      Required : Boolean := False)\n+      return     String\n+   is\n+   begin\n+      Check_Environment;\n+\n+      for K in 1 .. Key_Value_Table.Last loop\n+         if Key_Value_Table.Table (K).Key.all = Key then\n+            return Key_Value_Table.Table (K).Value.all;\n+         end if;\n+      end loop;\n+\n+      if Required then\n+         raise Parameter_Not_Found;\n+      else\n+         return \"\";\n+      end if;\n+   end Value;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Position : Positive) return String is\n+   begin\n+      Check_Environment;\n+\n+      if Position <= Key_Value_Table.Last then\n+         return Key_Value_Table.Table (Position).Value.all;\n+      else\n+         raise Parameter_Not_Found;\n+      end if;\n+   end Value;\n+\n+begin\n+\n+   Initialize;\n+\n+end GNAT.CGI;"}, {"sha": "10e4907d6e582be28002d735d9f24f2f691b7f9d", "filename": "gcc/ada/g-cgi.ads", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgi.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,260 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             G N A T . C G I                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $\n+--                                                                          --\n+--              Copyright (C) 2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a package to interface a GNAT program with a Web server via the\n+--  Common Gateway Interface (CGI).\n+\n+--  Other related packages are:\n+\n+--     GNAT.CGI.Cookie which deal with Web HTTP Cookies.\n+--     GNAT.CGI.Debug  which output complete CGI runtime environment\n+\n+--  Basically this package parse the CGI parameter which are a set of key/value\n+--  pairs. It builds a table whose index is the key and provides some services\n+--  to deal with this table.\n+\n+--  Example:\n+\n+--     Consider the following simple HTML form to capture a client name:\n+\n+--        <!DOCTYPE HTML PUBLIC \"-//W3C//DTD W3 HTML 3.2//EN\">\n+--        <html>\n+--        <head>\n+--        <title>My Web Page</title>\n+--        </head>\n+\n+--        <body>\n+--        <form action=\"/cgi-bin/new_client\" method=\"POST\">\n+--        <input type=text name=client_name>\n+--        <input type=submit name=\"Enter\">\n+--        </form>\n+--        </body>\n+--        </html>\n+\n+--     The following program will retrieve the client's name:\n+\n+--        with GNAT.CGI;\n+\n+--        procedure New_Client is\n+--           use GNAT;\n+\n+--           procedure Add_Client_To_Database (Name : in String) is\n+--           begin\n+--              ...\n+--           end Add_Client_To_Database;\n+\n+--        begin\n+--           --  Check that we have 2 arguments (there is two inputs tag in\n+--           --  the HTML form) and that one of them is called \"client_name\".\n+\n+--           if CGI.Argument_Count = 2\n+--             and the CGI.Key_Exists (\"client_name\")\n+--           then\n+--              Add_Client_To_Database (CGI.Value (\"client_name\"));\n+--           end if;\n+\n+--           ...\n+\n+--           CGI.Put_Header;\n+--           Text_IO.Put_Line (\"<html><body>< ... Ok ... >\");\n+\n+--        exception\n+--           when CGI.Data_Error =>\n+--              CGI.Put_Header (\"Location: /htdocs/error.html\");\n+--              --  This returns the address of a Web page to be displayed\n+--              --  using a \"Location:\" header style.\n+--        end New_Client;\n+\n+--  Note that the names in this package interface have been designed so that\n+--  they read nicely with the CGI prefix. The recommended style is to avoid\n+--  a use clause for GNAT.CGI, but to include a use clause for GNAT.\n+\n+--  This package builds up a table of CGI parameters whose memory is not\n+--  released. A CGI program is expected to be a short lived program and\n+--  so it is adequate to have the underlying OS free the program on exit.\n+\n+package GNAT.CGI is\n+\n+   Data_Error : exception;\n+   --  This is raised when there is a problem with the CGI protocol. Either\n+   --  the data could not be retrieved or the CGI environment is invalid.\n+   --\n+   --  The package will initialize itself by parsing the runtime CGI\n+   --  environment during elaboration but we do not want to raise an\n+   --  exception at this time, so the exception Data_Error is deferred\n+   --  and will be raised when calling any services below (except for Ok).\n+\n+   Parameter_Not_Found : exception;\n+   --  This exception is raised when a specific parameter is not found.\n+\n+   Default_Header : constant String := \"Content-type: text/html\";\n+   --  This is the default header returned by Put_Header. If the CGI program\n+   --  returned data is not an HTML page, this header must be change to a\n+   --  valid MIME type.\n+\n+   type Method_Type is (Get, Post);\n+   --  The method used to pass parameter from the Web client to the\n+   --  server. With the GET method parameters are passed via the command\n+   --  line, with the POST method parameters are passed via environment\n+   --  variables. Others methods are not supported by this implementation.\n+\n+   type Metavariable_Name is\n+     (Auth_Type,\n+      Content_Length,\n+      Content_Type,\n+      Document_Root,          --  Web server dependant\n+      Gateway_Interface,\n+      HTTP_Accept,\n+      HTTP_Accept_Encoding,\n+      HTTP_Accept_Language,\n+      HTTP_Connection,\n+      HTTP_Cookie,\n+      HTTP_Extension,\n+      HTTP_From,\n+      HTTP_Host,\n+      HTTP_Referer,\n+      HTTP_User_Agent,\n+      Path,\n+      Path_Info,\n+      Path_Translated,\n+      Query_String,\n+      Remote_Addr,\n+      Remote_Host,\n+      Remote_Port,            --  Web server dependant\n+      Remote_Ident,\n+      Remote_User,\n+      Request_Method,\n+      Request_URI,            --  Web server dependant\n+      Script_Filename,        --  Web server dependant\n+      Script_Name,\n+      Server_Addr,            --  Web server dependant\n+      Server_Admin,           --  Web server dependant\n+      Server_Name,\n+      Server_Port,\n+      Server_Protocol,\n+      Server_Signature,       --  Web server dependant\n+      Server_Software);\n+   --  CGI metavariables that are set by the Web server during program\n+   --  execution. All these variables are part of the restricted CGI runtime\n+   --  environment and can be read using Metavariable service. The detailed\n+   --  meanings of these metavariables are out of the scope of this\n+   --  description. Please refer to http://www.w3.org/CGI/ for a description\n+   --  of the CGI specification. Some metavariables are Web server dependant\n+   --  and are not described in the cited document.\n+\n+   procedure Put_Header\n+     (Header : String  := Default_Header;\n+      Force  : Boolean := False);\n+   --  Output standard CGI header by default. The header string is followed by\n+   --  an empty line. This header must be the first answer sent back to the\n+   --  server. Do nothing if this function has already been called and Force\n+   --  is False.\n+\n+   function Ok return Boolean;\n+   --  Returns True if the CGI environment is valid and False otherwise.\n+   --  Every service used when the CGI environment is not valid will raise\n+   --  the exception Data_Error.\n+\n+   function Method return Method_Type;\n+   --  Returns the method used to call the CGI.\n+\n+   function Metavariable\n+     (Name     : Metavariable_Name;\n+      Required : Boolean := False)\n+      return     String;\n+   --  Returns parameter Name value. Returns the null string if Name\n+   --  environment variable is not defined or raises Data_Error if\n+   --  Required is set to True.\n+\n+   function Metavariable_Exists (Name : Metavariable_Name) return Boolean;\n+   --  Returns True if the environment variable Name is defined in\n+   --  the CGI runtime environment and False otherwise.\n+\n+   function URL return String;\n+   --  Returns the URL used to call this script without the parameters.\n+   --  The URL form is: http://<server_name>[:<server_port>]<script_name>\n+\n+   function Argument_Count return Natural;\n+   --  Returns the number of parameters passed to the client. This is the\n+   --  number of input tags in a form or the number of parameters passed to\n+   --  the CGI via the command line.\n+\n+   ---------------------------------------------------\n+   -- Services to retrieve key/value CGI parameters --\n+   ---------------------------------------------------\n+\n+   function Value\n+     (Key      : String;\n+      Required : Boolean := False)\n+      return     String;\n+   --  Returns the parameter value associated to the parameter named Key.\n+   --  If parameter does not exist, returns an empty string if Required\n+   --  is False and raises the exception Parameter_Not_Found otherwise.\n+\n+   function Value (Position : Positive) return String;\n+   --  Returns the parameter value associated with the CGI parameter number\n+   --  Position. Raises Parameter_Not_Found if there is no such parameter\n+   --  (i.e. Position > Argument_Count)\n+\n+   function Key_Exists (Key : String) return Boolean;\n+   --  Returns True if the parameter named Key existx and False otherwise.\n+\n+   function Key (Position : Positive) return String;\n+   --  Returns the parameter key associated with the CGI parameter number\n+   --  Position. Raises the exception Parameter_Not_Found if there is no\n+   --  such parameter (i.e. Position > Argument_Count)\n+\n+   generic\n+     with procedure\n+       Action\n+         (Key      : String;\n+          Value    : String;\n+          Position : Positive;\n+          Quit     : in out Boolean);\n+   procedure For_Every_Parameter;\n+   --  Iterate through all existing key/value pairs and call the Action\n+   --  supplied procedure. The Key and Value are set appropriately, Position\n+   --  is the parameter order in the list, Quit is set to True by default.\n+   --  Quit can be set to False to control the iterator termination.\n+\n+private\n+\n+   function Decode (S : String) return String;\n+   --  Decode Web string S. A string when passed to a CGI is encoded,\n+   --  this function will decode the string to return the original\n+   --  string's content. Every triplet of the form %HH (where H is an\n+   --  hexadecimal number) is translated into the character such that:\n+   --  Hex (Character'Pos (C)) = HH.\n+\n+end GNAT.CGI;"}, {"sha": "f28832a0d361b7ffec7b9750ce6921619ca24dca", "filename": "gcc/ada/g-cgicoo.adb", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgicoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgicoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgicoo.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,405 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       G N A T . C G I . C O O K I E                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--            Copyright (C) 2000-2001 Ada Core Technologies, Inc.\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Fixed;\n+with Ada.Strings.Maps;\n+with Ada.Text_IO;\n+with Ada.Integer_Text_IO;\n+\n+with GNAT.Table;\n+\n+package body GNAT.CGI.Cookie is\n+\n+   use Ada;\n+\n+   Valid_Environment : Boolean := False;\n+   --  This boolean will be set to True if the initialization was fine.\n+\n+   Header_Sent : Boolean := False;\n+   --  Will be set to True when the header will be sent.\n+\n+   --  Cookie data that have been added.\n+\n+   type String_Access is access String;\n+\n+   type Cookie_Data is record\n+      Key     : String_Access;\n+      Value   : String_Access;\n+      Comment : String_Access;\n+      Domain  : String_Access;\n+      Max_Age : Natural;\n+      Path    : String_Access;\n+      Secure  : Boolean := False;\n+   end record;\n+\n+   type Key_Value is record\n+      Key, Value : String_Access;\n+   end record;\n+\n+   package Cookie_Table is new Table (Cookie_Data, Positive, 1, 5, 50);\n+   --  This is the table to keep all cookies to be sent back to the server.\n+\n+   package Key_Value_Table is new Table (Key_Value, Positive, 1, 1, 50);\n+   --  This is the table to keep all cookies received from the server.\n+\n+   procedure Check_Environment;\n+   pragma Inline (Check_Environment);\n+   --  This procedure will raise Data_Error if Valid_Environment is False.\n+\n+   procedure Initialize;\n+   --  Initialize CGI package by reading the runtime environment. This\n+   --  procedure is called during elaboration. All exceptions raised during\n+   --  this procedure are deferred.\n+\n+   -----------------------\n+   -- Check_Environment --\n+   -----------------------\n+\n+   procedure Check_Environment is\n+   begin\n+      if not Valid_Environment then\n+         raise Data_Error;\n+      end if;\n+   end Check_Environment;\n+\n+   -----------\n+   -- Count --\n+   -----------\n+\n+   function Count return Natural is\n+   begin\n+      return Key_Value_Table.Last;\n+   end Count;\n+\n+   ------------\n+   -- Exists --\n+   ------------\n+\n+   function Exists (Key : String) return Boolean is\n+   begin\n+      Check_Environment;\n+\n+      for K in 1 .. Key_Value_Table.Last loop\n+         if Key_Value_Table.Table (K).Key.all = Key then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Exists;\n+\n+   ----------------------\n+   -- For_Every_Cookie --\n+   ----------------------\n+\n+   procedure For_Every_Cookie is\n+      Quit : Boolean;\n+\n+   begin\n+      Check_Environment;\n+\n+      for K in 1 .. Key_Value_Table.Last loop\n+         Quit := False;\n+\n+         Action (Key_Value_Table.Table (K).Key.all,\n+                 Key_Value_Table.Table (K).Value.all,\n+                 K,\n+                 Quit);\n+\n+         exit when Quit;\n+      end loop;\n+   end For_Every_Cookie;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+\n+      HTTP_COOKIE : constant String := Metavariable (CGI.HTTP_Cookie);\n+\n+      procedure Set_Parameter_Table (Data : String);\n+      --  Parse Data and insert information in Key_Value_Table.\n+\n+      -------------------------\n+      -- Set_Parameter_Table --\n+      -------------------------\n+\n+      procedure Set_Parameter_Table (Data : String) is\n+\n+         procedure Add_Parameter (K : Positive; P : String);\n+         --  Add a single parameter into the table at index K. The parameter\n+         --  format is \"key=value\".\n+\n+         Count : constant Positive\n+           := 1 + Strings.Fixed.Count (Data, Strings.Maps.To_Set (\";\"));\n+         --  Count is the number of parameters in the string. Parameters are\n+         --  separated by ampersand character.\n+\n+         Index : Positive := Data'First;\n+         Sep   : Natural;\n+\n+         -------------------\n+         -- Add_Parameter --\n+         -------------------\n+\n+         procedure Add_Parameter (K : Positive; P : String) is\n+            Equal : constant Natural := Strings.Fixed.Index (P, \"=\");\n+         begin\n+            if Equal = 0 then\n+               raise Data_Error;\n+            else\n+               Key_Value_Table.Table (K) :=\n+                 Key_Value'(new String'(Decode (P (P'First .. Equal - 1))),\n+                            new String'(Decode (P (Equal + 1 .. P'Last))));\n+            end if;\n+         end Add_Parameter;\n+\n+      begin\n+         Key_Value_Table.Set_Last (Count);\n+\n+         for K in 1 .. Count - 1 loop\n+            Sep := Strings.Fixed.Index (Data (Index .. Data'Last), \";\");\n+\n+            Add_Parameter (K, Data (Index .. Sep - 1));\n+\n+            Index := Sep + 2;\n+         end loop;\n+\n+         --  add last parameter\n+\n+         Add_Parameter (Count, Data (Index .. Data'Last));\n+      end Set_Parameter_Table;\n+\n+   begin\n+      if HTTP_COOKIE /= \"\" then\n+         Set_Parameter_Table (HTTP_COOKIE);\n+      end if;\n+\n+      Valid_Environment := True;\n+\n+   exception\n+      when others =>\n+         Valid_Environment := False;\n+   end Initialize;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Position : Positive) return String is\n+   begin\n+      Check_Environment;\n+\n+      if Position <= Key_Value_Table.Last then\n+         return Key_Value_Table.Table (Position).Key.all;\n+      else\n+         raise Cookie_Not_Found;\n+      end if;\n+   end Key;\n+\n+   --------\n+   -- Ok --\n+   --------\n+\n+   function Ok return Boolean is\n+   begin\n+      return Valid_Environment;\n+   end Ok;\n+\n+   ----------------\n+   -- Put_Header --\n+   ----------------\n+\n+   procedure Put_Header\n+     (Header : String  := Default_Header;\n+      Force  : Boolean := False)\n+   is\n+\n+      procedure Output_Cookies;\n+      --  Iterate through the list of cookies to be sent to the server\n+      --  and output them.\n+\n+      --------------------\n+      -- Output_Cookies --\n+      --------------------\n+\n+      procedure Output_Cookies is\n+\n+         procedure Output_One_Cookie\n+           (Key     : String;\n+            Value   : String;\n+            Comment : String;\n+            Domain  : String;\n+            Max_Age : Natural;\n+            Path    : String;\n+            Secure  : Boolean);\n+         --  Output one cookie in the CGI header.\n+\n+         -----------------------\n+         -- Output_One_Cookie --\n+         -----------------------\n+\n+         procedure Output_One_Cookie\n+           (Key     : String;\n+            Value   : String;\n+            Comment : String;\n+            Domain  : String;\n+            Max_Age : Natural;\n+            Path    : String;\n+            Secure  : Boolean)\n+         is\n+         begin\n+            Text_IO.Put (\"Set-Cookie: \");\n+            Text_IO.Put (Key & '=' & Value);\n+\n+            if Comment /= \"\" then\n+               Text_IO.Put (\"; Comment=\" & Comment);\n+            end if;\n+\n+            if Domain /= \"\" then\n+               Text_IO.Put (\"; Domain=\" & Domain);\n+            end if;\n+\n+            if Max_Age /= Natural'Last then\n+               Text_IO.Put (\"; Max-Age=\");\n+               Integer_Text_IO.Put (Max_Age, Width => 0);\n+            end if;\n+\n+            if Path /= \"\" then\n+               Text_IO.Put (\"; Path=\" & Path);\n+            end if;\n+\n+            if Secure then\n+               Text_IO.Put (\"; Secure\");\n+            end if;\n+\n+            Text_IO.New_Line;\n+         end Output_One_Cookie;\n+\n+      --  Start of processing for Output_Cookies\n+\n+      begin\n+         for C in 1 .. Cookie_Table.Last loop\n+            Output_One_Cookie (Cookie_Table.Table (C).Key.all,\n+                               Cookie_Table.Table (C).Value.all,\n+                               Cookie_Table.Table (C).Comment.all,\n+                               Cookie_Table.Table (C).Domain.all,\n+                               Cookie_Table.Table (C).Max_Age,\n+                               Cookie_Table.Table (C).Path.all,\n+                               Cookie_Table.Table (C).Secure);\n+         end loop;\n+      end Output_Cookies;\n+\n+   --  Start of processing for Put_Header\n+\n+   begin\n+      if Header_Sent = False or else Force then\n+         Check_Environment;\n+         Text_IO.Put_Line (Header);\n+         Output_Cookies;\n+         Text_IO.New_Line;\n+         Header_Sent := True;\n+      end if;\n+   end Put_Header;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set\n+     (Key     : String;\n+      Value   : String;\n+      Comment : String   := \"\";\n+      Domain  : String   := \"\";\n+      Max_Age : Natural  := Natural'Last;\n+      Path    : String   := \"/\";\n+      Secure  : Boolean  := False) is\n+   begin\n+      Cookie_Table.Increment_Last;\n+\n+      Cookie_Table.Table (Cookie_Table.Last) :=\n+        Cookie_Data'(new String'(Key),\n+                     new String'(Value),\n+                     new String'(Comment),\n+                     new String'(Domain),\n+                     Max_Age,\n+                     new String'(Path),\n+                     Secure);\n+   end Set;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value\n+     (Key      : String;\n+      Required : Boolean := False)\n+      return     String\n+   is\n+   begin\n+      Check_Environment;\n+\n+      for K in 1 .. Key_Value_Table.Last loop\n+         if Key_Value_Table.Table (K).Key.all = Key then\n+            return Key_Value_Table.Table (K).Value.all;\n+         end if;\n+      end loop;\n+\n+      if Required then\n+         raise Cookie_Not_Found;\n+      else\n+         return \"\";\n+      end if;\n+   end Value;\n+\n+   function Value (Position : Positive) return String is\n+   begin\n+      Check_Environment;\n+\n+      if Position <= Key_Value_Table.Last then\n+         return Key_Value_Table.Table (Position).Value.all;\n+      else\n+         raise Cookie_Not_Found;\n+      end if;\n+   end Value;\n+\n+--  Elaboration code for package\n+\n+begin\n+   --  Initialize unit by reading the HTTP_COOKIE metavariable and fill\n+   --  Key_Value_Table structure.\n+\n+   Initialize;\n+end GNAT.CGI.Cookie;"}, {"sha": "3d4d1b4bf5e2caebfc06d97c4eed11bd46988a5b", "filename": "gcc/ada/g-cgicoo.ads", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgicoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgicoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgicoo.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,124 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       G N A T . C G I . C O O K I E                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $\n+--                                                                          --\n+--            Copyright (C) 2000-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a package to interface a GNAT program with a Web server via the\n+--  Common Gateway Interface (CGI). It exports services to deal with Web\n+--  cookies (piece of information kept in the Web client software).\n+\n+--  The complete CGI Cookie specification can be found in the RFC2109 at:\n+--     http://www.ics.uci.edu/pub/ietf/http/rfc2109.txt\n+\n+--  This package builds up data tables whose memory is not released.\n+--  A CGI program is expected to be a short lived program and so it\n+--  is adequate to have the underlying OS free the program on exit.\n+\n+package GNAT.CGI.Cookie is\n+\n+   --  The package will initialize itself by parsing the HTTP_Cookie runtime\n+   --  CGI environment variable during elaboration but we do not want to raise\n+   --  an exception at this time, so the exception Data_Error is deferred and\n+   --  will be raised when calling any services below (except for Ok).\n+\n+   Cookie_Not_Found : exception;\n+   --  This exception is raised when a specific parameter is not found.\n+\n+   procedure Put_Header\n+     (Header : String  := Default_Header;\n+      Force  : Boolean := False);\n+   --  Output standard CGI header by default. This header must be returned\n+   --  back to the server at the very beginning and will be output only for\n+   --  the first call to Put_Header if Force is set to False. This procedure\n+   --  also outputs the Cookies that have been defined. If the program uses\n+   --  the GNAT.CGI.Put_Header service, cookies will not be set.\n+   --\n+   --  Cookies are passed back to the server in the header, the format is:\n+   --\n+   --    Set-Cookie: <key>=<value>; comment=<comment>; domain=<domain>;\n+   --     max_age=<max_age>; path=<path>[; secured]\n+\n+   function Ok return Boolean;\n+   --  Returns True if the CGI cookie environment is valid and False\n+   --  otherwise. Every service used when the CGI environment is not valid\n+   --  will raise the exception Data_Error.\n+\n+   function Count return Natural;\n+   --  Returns the number of cookies received by the CGI.\n+\n+   function Value\n+     (Key      : String;\n+      Required : Boolean := False)\n+      return     String;\n+   --  Returns the cookie value associated with the cookie named Key. If\n+   --  cookie does not exist, returns an empty string if Required is\n+   --  False and raises the exception Cookie_Not_Found otherwise.\n+\n+   function Value (Position : Positive) return String;\n+   --  Returns the value associated with the cookie number Position\n+   --  of the CGI. It raises Cookie_Not_Found if there is no such\n+   --  cookie (i.e. Position > Count)\n+\n+   function Exists (Key : String) return Boolean;\n+   --  Returns True if the cookie named Key exist and False otherwise.\n+\n+   function Key (Position : Positive) return String;\n+   --  Returns the key associated with the cookie number Position of\n+   --  the CGI. It raises Cookie_Not_Found if there is no such cookie\n+   --  (i.e. Position > Count)\n+\n+   procedure Set\n+     (Key     : String;\n+      Value   : String;\n+      Comment : String  := \"\";\n+      Domain  : String  := \"\";\n+      Max_Age : Natural := Natural'Last;\n+      Path    : String  := \"/\";\n+      Secure  : Boolean := False);\n+   --  Add a cookie to the list of cookies. This will be sent back\n+   --  to the server by the Put_Header service above.\n+\n+   generic\n+      with procedure\n+        Action\n+          (Key      : String;\n+           Value    : String;\n+           Position : Positive;\n+           Quit     : in out Boolean);\n+   procedure For_Every_Cookie;\n+   --  Iterate through all cookies received from the server and call\n+   --  the Action supplied procedure. The Key, Value parameters are set\n+   --  appropriately, Position is the cookie order in the list, Quit is set to\n+   --  True by default. Quit can be set to False to control the iterator\n+   --  termination.\n+\n+end GNAT.CGI.Cookie;"}, {"sha": "fb4ad490b276730c84901457338644a8278c1bed", "filename": "gcc/ada/g-cgideb.adb", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgideb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgideb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgideb.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,332 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        G N A T . C G I . D E B U G                       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $\n+--                                                                          --\n+--            Copyright (C) 2000-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Unbounded;\n+\n+package body GNAT.CGI.Debug is\n+\n+   use Ada.Strings.Unbounded;\n+\n+   --\n+   --  Define the abstract type which act as a template for all debug IO mode.\n+   --  To create a new IO mode you must:\n+   --     1. create a new package spec\n+   --     2. create a new type derived from IO.Format\n+   --     3. implement all the abstract rountines in IO\n+   --\n+\n+   package IO is\n+\n+      type Format is abstract tagged null record;\n+\n+      function Output (Mode : in Format'Class) return String;\n+\n+      function Variable\n+        (Mode  : Format;\n+         Name  : String;\n+         Value : String)\n+         return  String\n+      is abstract;\n+      --  Returns variable Name and its associated value.\n+\n+      function New_Line\n+        (Mode : Format)\n+         return String\n+      is abstract;\n+      --  Returns a new line such as this concatenated between two strings\n+      --  will display the strings on two lines.\n+\n+      function Title\n+        (Mode : Format;\n+         Str  : String)\n+         return String\n+      is abstract;\n+      --  Returns Str as a Title. A title must be alone and centered on a\n+      --  line. Next output will be on the following line.\n+\n+      function Header\n+        (Mode : Format;\n+         Str  : String)\n+         return String\n+      is abstract;\n+      --  Returns Str as an Header. An header must be alone on its line. Next\n+      --  output will be on the following line.\n+\n+   end IO;\n+\n+   --\n+   --  IO for HTML mode\n+   --\n+\n+   package HTML_IO is\n+\n+      --  see IO for comments about these routines.\n+\n+      type Format is new IO.Format with null record;\n+\n+      function Variable\n+        (IO    : Format;\n+         Name  : String;\n+         Value : String)\n+         return  String;\n+\n+      function New_Line (IO : in Format) return String;\n+\n+      function Title (IO : in Format; Str : in String) return String;\n+\n+      function Header (IO : in Format; Str : in String) return String;\n+\n+   end HTML_IO;\n+\n+   --\n+   --  IO for plain text mode\n+   --\n+\n+   package Text_IO is\n+\n+      --  See IO for comments about these routines\n+\n+      type Format is new IO.Format with null record;\n+\n+      function Variable\n+        (IO    : Format;\n+         Name  : String;\n+         Value : String)\n+         return  String;\n+\n+      function New_Line (IO : in Format) return String;\n+\n+      function Title (IO : in Format; Str : in String) return String;\n+\n+      function Header (IO : in Format; Str : in String) return String;\n+\n+   end Text_IO;\n+\n+   --------------\n+   -- Debug_IO --\n+   --------------\n+\n+   package body IO is\n+\n+      ------------\n+      -- Output --\n+      ------------\n+\n+      function Output (Mode : in Format'Class) return String is\n+         Result : Unbounded_String;\n+\n+      begin\n+         Result := Result\n+           & Title (Mode, \"CGI complete runtime environment\");\n+\n+         Result := Result\n+           & Header (Mode, \"CGI parameters:\")\n+           & New_Line (Mode);\n+\n+         for K in 1 .. Argument_Count loop\n+            Result := Result\n+              & Variable (Mode, Key (K), Value (K))\n+              & New_Line (Mode);\n+         end loop;\n+\n+         Result := Result\n+           & New_Line (Mode)\n+           & Header (Mode, \"CGI environment variables (Metavariables):\")\n+           & New_Line (Mode);\n+\n+         for P in Metavariable_Name'Range loop\n+            if Metavariable_Exists (P) then\n+               Result := Result\n+                 & Variable (Mode,\n+                             Metavariable_Name'Image (P),\n+                             Metavariable (P))\n+                 & New_Line (Mode);\n+            end if;\n+         end loop;\n+\n+         return To_String (Result);\n+      end Output;\n+\n+   end IO;\n+\n+   -------------\n+   -- HTML_IO --\n+   -------------\n+\n+   package body HTML_IO is\n+\n+      NL : constant String := (1 => ASCII.LF);\n+\n+      function Bold (S : in String) return String;\n+      --  Returns S as an HTML bold string.\n+\n+      function Italic (S : in String) return String;\n+      --  Returns S as an HTML italic string.\n+\n+      ----------\n+      -- Bold --\n+      ----------\n+\n+      function Bold (S : in String) return String is\n+      begin\n+         return \"<b>\" & S & \"</b>\";\n+      end Bold;\n+\n+      ------------\n+      -- Header --\n+      ------------\n+\n+      function Header (IO : in Format; Str : in String) return String is\n+      begin\n+         return \"<h2>\" & Str & \"</h2>\" & NL;\n+      end Header;\n+\n+      ------------\n+      -- Italic --\n+      ------------\n+\n+      function Italic (S : in String) return String is\n+      begin\n+         return \"<i>\" & S & \"</i>\";\n+      end Italic;\n+\n+      --------------\n+      -- New_Line --\n+      --------------\n+\n+      function New_Line (IO : in Format) return String is\n+      begin\n+         return \"<br>\" & NL;\n+      end New_Line;\n+\n+      -----------\n+      -- Title --\n+      -----------\n+\n+      function Title (IO : in Format; Str : in String) return String is\n+      begin\n+         return \"<p align=center><font size=+2>\" & Str & \"</font></p>\" & NL;\n+      end Title;\n+\n+      --------------\n+      -- Variable --\n+      --------------\n+\n+      function Variable\n+        (IO    : Format;\n+         Name  : String;\n+         Value : String)\n+         return  String\n+      is\n+      begin\n+         return Bold (Name) & \" = \" & Italic (Value);\n+      end Variable;\n+\n+   end HTML_IO;\n+\n+   -------------\n+   -- Text_IO --\n+   -------------\n+\n+   package body Text_IO is\n+\n+      ------------\n+      -- Header --\n+      ------------\n+\n+      function Header (IO : in Format; Str : in String) return String is\n+      begin\n+         return \"*** \" & Str & New_Line (IO);\n+      end Header;\n+\n+      --------------\n+      -- New_Line --\n+      --------------\n+\n+      function New_Line (IO : in Format) return String is\n+      begin\n+         return String'(1 => ASCII.LF);\n+      end New_Line;\n+\n+      -----------\n+      -- Title --\n+      -----------\n+\n+      function Title (IO : in Format; Str : in String) return String is\n+         Spaces : constant Natural := (80 - Str'Length) / 2;\n+         Indent : constant String (1 .. Spaces) := (others => ' ');\n+\n+      begin\n+         return Indent & Str & New_Line (IO);\n+      end Title;\n+\n+      --------------\n+      -- Variable --\n+      --------------\n+\n+      function Variable\n+        (IO    : Format;\n+         Name  : String;\n+         Value : String)\n+         return  String\n+      is\n+      begin\n+         return \"   \" & Name & \" = \" & Value;\n+      end Variable;\n+\n+   end Text_IO;\n+\n+   -----------------\n+   -- HTML_Output --\n+   -----------------\n+\n+   function HTML_Output return String is\n+      HTML : HTML_IO.Format;\n+\n+   begin\n+      return IO.Output (Mode => HTML);\n+   end HTML_Output;\n+\n+   -----------------\n+   -- Text_Output --\n+   -----------------\n+\n+   function Text_Output return String is\n+      Text : Text_IO.Format;\n+\n+   begin\n+      return IO.Output (Mode => Text);\n+   end Text_Output;\n+\n+end GNAT.CGI.Debug;"}, {"sha": "5c5c5e8f82c5928a7e416768482a0b45a6ea205b", "filename": "gcc/ada/g-cgideb.ads", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgideb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-cgideb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgideb.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,50 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        G N A T . C G I . D E B U G                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--              Copyright (C) 2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a package to help debugging CGI (Common Gateway Interface)\n+--  programs written in Ada.\n+\n+package GNAT.CGI.Debug is\n+\n+   --  Both functions below output all possible CGI parameters set. These\n+   --  are the form field and all CGI environment variables which make the\n+   --  CGI environment at runtime.\n+\n+   function Text_Output return String;\n+   --  Returns a plain text version of the CGI runtime environment\n+\n+   function HTML_Output return String;\n+   --  Returns an HTML version of the CGI runtime environment\n+\n+end GNAT.CGI.Debug;"}, {"sha": "f2ee9b8a0543410819fd57ad9c09b24b31112684", "filename": "gcc/ada/g-comlin.adb", "status": "added", "additions": 612, "deletions": 0, "changes": 612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,612 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . C O M M A N D _ L I N E                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.21 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Command_Line;\n+\n+package body GNAT.Command_Line is\n+\n+   package CL renames Ada.Command_Line;\n+\n+   type Section_Number is new Natural range 0 .. 65534;\n+   for Section_Number'Size use 16;\n+\n+   type Parameter_Type is\n+      record\n+         Arg_Num : Positive;\n+         First   : Positive;\n+         Last    : Positive;\n+      end record;\n+   The_Parameter : Parameter_Type;\n+   The_Switch    : Parameter_Type;\n+   --  This type and this variable are provided to store the current switch\n+   --  and parameter\n+\n+   type Is_Switch_Type is array (1 .. CL.Argument_Count) of Boolean;\n+   pragma Pack (Is_Switch_Type);\n+\n+   Is_Switch : Is_Switch_Type := (others => False);\n+   --  Indicates wich arguments on the command line are considered not be\n+   --  switches or parameters to switches (this leaves e.g. the filenames...)\n+\n+   type Section_Type is array (1 .. CL.Argument_Count + 1) of Section_Number;\n+   pragma Pack (Section_Type);\n+   Section : Section_Type := (others => 1);\n+   --  Contains the number of the section associated with the current\n+   --  switch.  If this number is 0, then it is a section delimiter, which\n+   --  is never returns by GetOpt.\n+   --  The last element of this array is set to 0 to avoid the need to test for\n+   --  if we have reached the end of the command line in loops.\n+\n+   Current_Argument : Natural := 1;\n+   --  Number of the current argument parsed on the command line\n+\n+   Current_Index : Natural := 1;\n+   --  Index in the current argument of the character to be processed\n+\n+   Current_Section : Section_Number := 1;\n+\n+   Expansion_It : aliased Expansion_Iterator;\n+   --  When Get_Argument is expanding a file name, this is the iterator used\n+\n+   In_Expansion : Boolean := False;\n+   --  True if we are expanding a file\n+\n+   Switch_Character : Character := '-';\n+   --  The character at the beginning of the command line arguments,\n+   --  indicating the beginning of a switch\n+\n+   Stop_At_First : Boolean := False;\n+   --  If it is True then Getopt stops at the first non-switch argument\n+\n+   procedure Set_Parameter\n+     (Variable : out Parameter_Type;\n+      Arg_Num  : Positive;\n+      First    : Positive;\n+      Last     : Positive);\n+   pragma Inline (Set_Parameter);\n+   --  Set the parameter that will be returned by Parameter below\n+\n+   function Goto_Next_Argument_In_Section return Boolean;\n+   --  Go to the next argument on the command line. If we are at the end\n+   --  of the current section, we want to make sure there is no other\n+   --  identical section on the command line (there might be multiple\n+   --  instances of -largs).\n+   --  Return True if there as another argument, False otherwise\n+\n+   ---------------\n+   -- Expansion --\n+   ---------------\n+\n+   function Expansion (Iterator : Expansion_Iterator) return String is\n+      use GNAT.Directory_Operations;\n+      type Pointer is access all Expansion_Iterator;\n+\n+      S    : String (1 .. 1024);\n+      Last : Natural;\n+      It   : Pointer := Iterator'Unrestricted_Access;\n+\n+   begin\n+      loop\n+         Read (It.Dir, S, Last);\n+\n+         if Last = 0 then\n+            Close (It.Dir);\n+            return String'(1 .. 0 => ' ');\n+         end if;\n+\n+         if GNAT.Regexp.Match (S (1 .. Last), Iterator.Regexp) then\n+            return S (1 .. Last);\n+         end if;\n+\n+      end loop;\n+\n+      return String'(1 .. 0 => ' ');\n+   end Expansion;\n+\n+   -----------------\n+   -- Full_Switch --\n+   -----------------\n+\n+   function Full_Switch return String is\n+   begin\n+      return CL.Argument (The_Switch.Arg_Num)\n+        (The_Switch.First .. The_Switch.Last);\n+   end Full_Switch;\n+\n+   ------------------\n+   -- Get_Argument --\n+   ------------------\n+\n+   function Get_Argument (Do_Expansion : Boolean := False) return String is\n+      Total : constant Natural := CL.Argument_Count;\n+\n+   begin\n+      if In_Expansion then\n+         declare\n+            S : String := Expansion (Expansion_It);\n+         begin\n+            if S'Length /= 0 then\n+               return S;\n+            else\n+               In_Expansion := False;\n+            end if;\n+\n+         end;\n+      end if;\n+\n+      if Current_Argument > Total then\n+\n+         --  If this is the first time this function is called\n+\n+         if Current_Index = 1 then\n+            Current_Argument := 1;\n+            while Current_Argument <= CL.Argument_Count\n+              and then Section (Current_Argument) /= Current_Section\n+            loop\n+               Current_Argument := Current_Argument + 1;\n+            end loop;\n+         else\n+            return String'(1 .. 0 => ' ');\n+         end if;\n+\n+      elsif Section (Current_Argument) = 0 then\n+         while Current_Argument <= CL.Argument_Count\n+           and then Section (Current_Argument) /= Current_Section\n+         loop\n+            Current_Argument := Current_Argument + 1;\n+         end loop;\n+      end if;\n+\n+      Current_Index := 2;\n+\n+      while Current_Argument <= Total\n+        and then Is_Switch (Current_Argument)\n+      loop\n+         Current_Argument := Current_Argument + 1;\n+      end loop;\n+\n+      if Current_Argument > Total then\n+         return String'(1 .. 0 => ' ');\n+      end if;\n+\n+      if Section (Current_Argument) = 0 then\n+         return Get_Argument (Do_Expansion);\n+      end if;\n+\n+      Current_Argument := Current_Argument + 1;\n+\n+      --  Could it be a file name with wild cards to expand ?\n+\n+      if Do_Expansion then\n+         declare\n+            Arg       : String renames CL.Argument (Current_Argument - 1);\n+            Index     : Positive := Arg'First;\n+\n+         begin\n+            while Index <= Arg'Last loop\n+\n+               if Arg (Index) = '*'\n+                 or else Arg (Index) = '?'\n+                 or else Arg (Index) = '['\n+               then\n+                  In_Expansion := True;\n+                  Start_Expansion (Expansion_It, Arg);\n+                  return Get_Argument (Do_Expansion);\n+               end if;\n+\n+               Index := Index + 1;\n+            end loop;\n+         end;\n+      end if;\n+\n+      return CL.Argument (Current_Argument - 1);\n+   end Get_Argument;\n+\n+   ------------\n+   -- Getopt --\n+   ------------\n+\n+   function Getopt (Switches : String) return Character is\n+      Dummy          : Boolean;\n+\n+   begin\n+      --  If we have finished to parse the current command line item (there\n+      --  might be multiple switches in a single item), then go to the next\n+      --  element\n+\n+      if Current_Argument > CL.Argument_Count\n+        or else (Current_Index > CL.Argument (Current_Argument)'Last\n+                 and then not Goto_Next_Argument_In_Section)\n+      then\n+         return ASCII.NUL;\n+      end if;\n+\n+      --  If we are on a new item, test if this might be a switch\n+\n+      if Current_Index = 1 then\n+         if CL.Argument (Current_Argument)(1) /= Switch_Character then\n+            if Switches (Switches'First) = '*' then\n+               Set_Parameter (The_Switch,\n+                              Arg_Num => Current_Argument,\n+                              First   => 1,\n+                              Last    => CL.Argument (Current_Argument)'Last);\n+               Is_Switch (Current_Argument) := True;\n+               Dummy := Goto_Next_Argument_In_Section;\n+               return '*';\n+            end if;\n+\n+            if Stop_At_First then\n+               Current_Argument := Positive'Last;\n+               return ASCII.NUL;\n+\n+            elsif not Goto_Next_Argument_In_Section then\n+               return ASCII.NUL;\n+\n+            else\n+               return Getopt (Switches);\n+            end if;\n+         end if;\n+\n+         Current_Index := 2;\n+         Is_Switch (Current_Argument) := True;\n+      end if;\n+\n+      declare\n+         Arg            : String renames CL.Argument (Current_Argument);\n+         Index_Switches : Natural := 0;\n+         Max_Length     : Natural := 0;\n+         Index          : Natural := Switches'First;\n+         Length         : Natural := 1;\n+         End_Index      : Natural;\n+\n+      begin\n+         while Index <= Switches'Last loop\n+\n+            --  Search the length of the parameter at this position in Switches\n+\n+            Length := Index;\n+            while Length <= Switches'Last\n+              and then Switches (Length) /= ' '\n+            loop\n+               Length := Length + 1;\n+            end loop;\n+\n+            if (Switches (Length - 1) = ':'\n+                or else Switches (Length - 1) = '?'\n+                or else Switches (Length - 1) = '!')\n+              and then Length > Index + 1\n+            then\n+               Length := Length - 1;\n+            end if;\n+\n+            --  If it is the one we searched, it may be a candidate\n+\n+            if Current_Index + Length - 1 - Index <= Arg'Last\n+              and then\n+              Switches (Index .. Length - 1) =\n+              Arg (Current_Index .. Current_Index + Length - 1 - Index)\n+              and then Length - Index > Max_Length\n+            then\n+               Index_Switches := Index;\n+               Max_Length     := Length - Index;\n+            end if;\n+\n+            --  Look for the next switch in Switches\n+            while Index <= Switches'Last\n+              and then Switches (Index) /= ' ' loop\n+               Index := Index + 1;\n+            end loop;\n+            Index := Index + 1;\n+\n+         end loop;\n+\n+         End_Index := Current_Index + Max_Length - 1;\n+\n+         --  If the switch is not accepted, skip it, unless we had a '*' in\n+         --  Switches\n+\n+         if Index_Switches = 0 then\n+            if Switches (Switches'First) = '*' then\n+               Set_Parameter (The_Switch,\n+                              Arg_Num => Current_Argument,\n+                              First   => 1,\n+                              Last    => CL.Argument (Current_Argument)'Last);\n+               Is_Switch (Current_Argument) := True;\n+               Dummy := Goto_Next_Argument_In_Section;\n+               return '*';\n+            end if;\n+\n+            Set_Parameter (The_Switch,\n+                           Arg_Num => Current_Argument,\n+                           First   => Current_Index,\n+                           Last    => Current_Index);\n+            Current_Index := Current_Index + 1;\n+            raise Invalid_Switch;\n+         end if;\n+\n+         Set_Parameter (The_Switch,\n+                        Arg_Num => Current_Argument,\n+                        First   => Current_Index,\n+                        Last    => End_Index);\n+\n+         --  If switch needs an argument\n+\n+         if Index_Switches + Max_Length <= Switches'Last then\n+\n+            case Switches (Index_Switches + Max_Length) is\n+\n+               when ':' =>\n+\n+                  if End_Index < Arg'Last then\n+                     Set_Parameter (The_Parameter,\n+                                    Arg_Num => Current_Argument,\n+                                    First   => End_Index + 1,\n+                                    Last    => Arg'Last);\n+                     Dummy := Goto_Next_Argument_In_Section;\n+\n+                  elsif Section (Current_Argument + 1) /= 0 then\n+                     Set_Parameter\n+                       (The_Parameter,\n+                        Arg_Num => Current_Argument + 1,\n+                        First   => 1,\n+                        Last    => CL.Argument (Current_Argument + 1)'Last);\n+                     Current_Argument := Current_Argument + 1;\n+                     Is_Switch (Current_Argument) := True;\n+                     Dummy := Goto_Next_Argument_In_Section;\n+\n+                  else\n+                     Current_Index := End_Index + 1;\n+                     raise Invalid_Parameter;\n+                  end if;\n+\n+               when '!' =>\n+\n+                  if End_Index < Arg'Last then\n+                     Set_Parameter (The_Parameter,\n+                                    Arg_Num => Current_Argument,\n+                                    First   => End_Index + 1,\n+                                    Last    => Arg'Last);\n+                     Dummy := Goto_Next_Argument_In_Section;\n+\n+                  else\n+                     Current_Index := End_Index + 1;\n+                     raise Invalid_Parameter;\n+                  end if;\n+\n+               when '?' =>\n+\n+                  if End_Index < Arg'Last then\n+                     Set_Parameter (The_Parameter,\n+                                    Arg_Num => Current_Argument,\n+                                    First   => End_Index + 1,\n+                                    Last    => Arg'Last);\n+\n+                  else\n+                     Set_Parameter (The_Parameter,\n+                                    Arg_Num => Current_Argument,\n+                                    First   => 2,\n+                                    Last    => 1);\n+                  end if;\n+                  Dummy := Goto_Next_Argument_In_Section;\n+\n+               when others =>\n+\n+                  Current_Index := End_Index + 1;\n+\n+            end case;\n+         else\n+            Current_Index := End_Index + 1;\n+         end if;\n+\n+         return Switches (Index_Switches);\n+      end;\n+   end Getopt;\n+\n+   -----------------------------------\n+   -- Goto_Next_Argument_In_Section --\n+   -----------------------------------\n+\n+   function Goto_Next_Argument_In_Section return Boolean is\n+   begin\n+      Current_Index := 1;\n+      Current_Argument := Current_Argument + 1;\n+\n+      if Section (Current_Argument) = 0 then\n+         loop\n+            if Current_Argument > CL.Argument_Count then\n+               return False;\n+            end if;\n+            Current_Argument := Current_Argument + 1;\n+            exit when Section (Current_Argument) = Current_Section;\n+         end loop;\n+      end if;\n+      return True;\n+   end Goto_Next_Argument_In_Section;\n+\n+   ------------------\n+   -- Goto_Section --\n+   ------------------\n+\n+   procedure Goto_Section (Name : String := \"\") is\n+      Index : Integer := 1;\n+\n+   begin\n+      In_Expansion := False;\n+\n+      if Name = \"\" then\n+         Current_Argument := 1;\n+         Current_Index    := 1;\n+         Current_Section  := 1;\n+         return;\n+      end if;\n+\n+      while Index <= CL.Argument_Count loop\n+\n+         if Section (Index) = 0\n+           and then CL.Argument (Index) = Switch_Character & Name\n+         then\n+            Current_Argument := Index + 1;\n+            Current_Index    := 1;\n+            if Current_Argument <= CL.Argument_Count then\n+               Current_Section := Section (Current_Argument);\n+            end if;\n+            return;\n+         end if;\n+\n+         Index := Index + 1;\n+      end loop;\n+      Current_Argument := Positive'Last;\n+      Current_Index := 2;   --  so that Get_Argument returns nothing\n+   end Goto_Section;\n+\n+   ----------------------------\n+   -- Initialize_Option_Scan --\n+   ----------------------------\n+\n+   procedure Initialize_Option_Scan\n+     (Switch_Char              : Character := '-';\n+      Stop_At_First_Non_Switch : Boolean := False;\n+      Section_Delimiters       : String := \"\")\n+   is\n+      Section_Num     : Section_Number := 1;\n+      Section_Index   : Integer        := Section_Delimiters'First;\n+      Last            : Integer;\n+      Delimiter_Found : Boolean;\n+\n+   begin\n+      Current_Argument := 0;\n+      Current_Index := 0;\n+      In_Expansion := False;\n+      Switch_Character := Switch_Char;\n+      Stop_At_First := Stop_At_First_Non_Switch;\n+\n+      --  If we are using sections, we have to preprocess the command line\n+      --  to delimit them. A section can be repeated, so we just give each\n+      --  item on the command line a section number\n+\n+      while Section_Index <= Section_Delimiters'Last loop\n+\n+         Last := Section_Index;\n+         while Last <= Section_Delimiters'Last\n+           and then Section_Delimiters (Last) /= ' '\n+         loop\n+            Last := Last + 1;\n+         end loop;\n+\n+         Delimiter_Found := False;\n+         Section_Num := Section_Num + 1;\n+\n+         for Index in 1 .. CL.Argument_Count loop\n+            if CL.Argument (Index)(1) = Switch_Character\n+              and then CL.Argument (Index) = Switch_Character\n+              & Section_Delimiters (Section_Index .. Last - 1)\n+            then\n+               Section (Index) := 0;\n+               Delimiter_Found := True;\n+\n+            elsif Section (Index) = 0 then\n+               Delimiter_Found := False;\n+\n+            elsif Delimiter_Found then\n+               Section (Index) := Section_Num;\n+            end if;\n+         end loop;\n+\n+         Section_Index := Last + 1;\n+         while Section_Index <= Section_Delimiters'Last\n+           and then Section_Delimiters (Section_Index) = ' '\n+         loop\n+            Section_Index := Section_Index + 1;\n+         end loop;\n+      end loop;\n+\n+      Delimiter_Found := Goto_Next_Argument_In_Section;\n+   end Initialize_Option_Scan;\n+\n+   ---------------\n+   -- Parameter --\n+   ---------------\n+\n+   function Parameter return String is\n+   begin\n+      if The_Parameter.First > The_Parameter.Last then\n+         return String'(1 .. 0 => ' ');\n+      else\n+         return CL.Argument (The_Parameter.Arg_Num)\n+           (The_Parameter.First .. The_Parameter.Last);\n+      end if;\n+   end Parameter;\n+\n+   -------------------\n+   -- Set_Parameter --\n+   -------------------\n+\n+   procedure Set_Parameter\n+     (Variable : out Parameter_Type;\n+      Arg_Num  : Positive;\n+      First    : Positive;\n+      Last     : Positive) is\n+   begin\n+      Variable.Arg_Num := Arg_Num;\n+      Variable.First   := First;\n+      Variable.Last    := Last;\n+   end Set_Parameter;\n+\n+   ---------------------\n+   -- Start_Expansion --\n+   ---------------------\n+\n+   procedure Start_Expansion\n+     (Iterator     : out Expansion_Iterator;\n+      Pattern      : String;\n+      Directory    : String := \"\";\n+      Basic_Regexp : Boolean := True)\n+   is\n+      Directory_Separator : Character;\n+      pragma Import (C, Directory_Separator, \"__gnat_dir_separator\");\n+\n+   begin\n+      if Directory = \"\" then\n+         GNAT.Directory_Operations.Open\n+           (Iterator.Dir, \".\" & Directory_Separator);\n+      else\n+         GNAT.Directory_Operations.Open (Iterator.Dir, Directory);\n+      end if;\n+\n+      Iterator.Regexp := GNAT.Regexp.Compile (Pattern, Basic_Regexp, True);\n+   end Start_Expansion;\n+\n+begin\n+   Section (CL.Argument_Count + 1) := 0;\n+end GNAT.Command_Line;"}, {"sha": "dedaefe8819df31b0809e3034fa53c31be0e1e7f", "filename": "gcc/ada/g-comlin.ads", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,272 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . C O M M A N D _ L I N E                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.24 $\n+--                                                                          --\n+--            Copyright (C) 1999-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  High level package for command line parsing\n+\n+--  This package provides an interface to Ada.Command_Line, to do the\n+--  parsing of command line arguments. Here is a small usage example:\n+--\n+--  begin\n+--     loop\n+--        case Getopt (\"a b: ad\") is  -- Accepts '-a', '-ad', or '-b argument'\n+--           when ASCII.NUL => exit;\n+--\n+--           when 'a' =>\n+--                 if Full_Switch = \"a\" then\n+--                    Put_Line (\"Got a\");\n+--                 else\n+--                    Put_Line (\"Got ad\");\n+--                 end if;\n+--\n+--           when 'b' =>\n+--              Put_Line (\"Got b + \" & Parameter);\n+--\n+--           when others =>\n+--              raise Program_Error;         -- cannot occur!\n+--        end case;\n+--     end loop;\n+--\n+--     loop\n+--        declare\n+--           S : constant String := Get_Argument (Do_Expansion => True);\n+\n+--        begin\n+--           exit when S'Length = 0;\n+--           Put_Line (\"Got \" & S);\n+--        end;\n+--     end loop;\n+--\n+--  exception\n+--     when Invalid_Switch    => Put_Line (\"Invalid Switch \" & Full_Switch);\n+--     when Invalid_Parameter => Put_Line (\"No parameter for \" & Full_Switch);\n+--  end;\n+--\n+--  A more complicated example would involve the use of sections for the\n+--  switches, as for instance in gnatmake. These sections are separated by\n+--  special switches, chosen by the programer. Each section act as a\n+--  command line of its own.\n+--\n+--  begin\n+--     Initialize_Option_Scan ('-', False, \"largs bargs cargs\");\n+--     loop\n+--        --  same loop as above to get switches and arguments\n+--     end loop;\n+--\n+--     Goto_Section (\"bargs\");\n+--     loop\n+--        --  same loop as above to get switches and arguments\n+--        --  The supports switches in Get_Opt might be different\n+--     end loop;\n+--\n+--     Goto_Section (\"cargs\");\n+--     loop\n+--        --  same loop as above to get switches and arguments\n+--        --  The supports switches in Get_Opt might be different\n+--     end loop;\n+--  end;\n+\n+\n+with GNAT.Directory_Operations;\n+with GNAT.Regexp;\n+\n+package GNAT.Command_Line is\n+\n+   procedure Initialize_Option_Scan\n+     (Switch_Char              : Character := '-';\n+      Stop_At_First_Non_Switch : Boolean := False;\n+      Section_Delimiters       : String := \"\");\n+   --  This procedure resets the internal state of the package to prepare\n+   --  to rescan the parameters. It need not (but may be) called before the\n+   --  first use of Getopt, but it must be called if you want to start\n+   --  rescanning the command line parameters from the start. The optional\n+   --  parameter Switch_Char can be used to reset the switch character,\n+   --  e.g. to '/' for use in DOS-like systems. The optional parameter\n+   --  Stop_At_First_Non_Switch indicates if Getopt is to look for switches\n+   --  on the whole command line, or if it has to stop as soon as a\n+   --  non-switch argument is found.\n+   --\n+   --  Example:\n+   --\n+   --      Arguments: my_application file1 -c\n+   --\n+   --      if Stop_At_First_Non_Switch is False, then -c will be considered\n+   --      as a switch (returned by getopt), otherwise it will be considered\n+   --      as a normal argument (returned by Get_Argument).\n+   --\n+   --  if SECTION_DELIMITERS is set, then every following subprogram\n+   --  (Getopt and Get_Argument) will only operate within a section, which\n+   --  is delimited by any of these delimiters or the end of the command line.\n+   --\n+   --  Example:\n+   --      Initialize_Option_Scan (\"largs bargs cargs\");\n+   --\n+   --      Arguments on command line : my_application -c -bargs -d -e -largs -f\n+   --      This line is made of three section, the first one is the default one\n+   --      and includes only the '-c' switch, the second one is between -bargs\n+   --      and -largs and includes '-d -e' and the last one includes '-f'\n+\n+   procedure Goto_Section (Name : String := \"\");\n+   --  Change the current section. The next Getopt of Get_Argument will\n+   --  start looking at the beginning of the section. An empty name (\"\")\n+   --  refers to the first section between the program name and the first\n+   --  section delimiter.\n+   --  If the section does not exist, then Invalid_Section is raised.\n+\n+   function Full_Switch return String;\n+   --  Returns the full name of the last switch found (Getopt only returns\n+   --  the first character)\n+\n+   function Getopt (Switches : String) return Character;\n+   --  This function moves to the next switch on the command line (defined\n+   --  as a switch character followed by a character within Switches,\n+   --  casing being significant). The result returned is the first\n+   --  character of the particular switch located. If there are no more\n+   --  switches in the current section, returns ASCII.NUL. The switches\n+   --  need not be separated by spaces (they can be concatenated if they do\n+   --  not require an argument, e.g. -ab is the same as two separate\n+   --  arguments -a -b).\n+   --\n+   --  Switches is a string of all the possible switches, separated by a\n+   --  space. A switch can be followed by one of the following characters :\n+   --\n+   --   ':'  The switch requires a parameter. There can optionally be a space\n+   --        on the command line between the switch and its parameter\n+   --   '!'  The switch requires a parameter, but there can be no space on the\n+   --        command line between the switch and its parameter\n+   --   '?'  The switch may have an optional parameter. There can no space\n+   --        between the switch and its argument\n+   --        ex/ if Switches has the following value : \"a? b\"\n+   --            The command line can be :\n+   --             -afoo    :  -a switch with 'foo' parameter\n+   --             -a foo   :  -a switch and another element on the\n+   --                           command line 'foo', returned by Get_Argument\n+   --\n+   --     Example: if Switches is \"-a: -aO:\", you can have the following\n+   --              command lines :\n+   --                -aarg    :  'a' switch with 'arg' parameter\n+   --                -a arg   :  'a' switch with 'arg' parameter\n+   --                -aOarg   :  'aO' switch with 'arg' parameter\n+   --                -aO arg  :  'aO' switch with 'arg' parameter\n+   --\n+   --    Example:\n+   --\n+   --       Getopt (\"a b: ac ad?\")\n+   --\n+   --         accept either 'a' or 'ac' with no argument,\n+   --         accept 'b' with a required argument\n+   --         accept 'ad' with an optional argument\n+   --\n+   --  If the first item in switches is '*', then Getopt will catch\n+   --  every element on the command line that was not caught by any other\n+   --  switch. The character returned by GetOpt is '*'\n+   --\n+   --    Example\n+   --       Getopt (\"* a b\")\n+   --       If the command line is '-a -c toto.o -b', GetOpt will return\n+   --       successively 'a', '*', '*' and 'b'. When '*' is returnd,\n+   --       Full_Switch returns the corresponding item on the command line.\n+   --\n+   --\n+   --  When Getopt encounters an invalid switch, it raises the exception\n+   --  Invalid_Switch and sets Full_Switch to return the invalid switch.\n+   --  When Getopt can not find the parameter associated with a switch, it\n+   --  raises Invalid_Parameter, and sets Full_Switch to return the invalid\n+   --  switch character.\n+   --\n+   --  Note: in case of ambiguity, e.g. switches a ab abc, then the longest\n+   --  matching switch is returned.\n+   --\n+   --  Arbitrary characters are allowed for switches, although it is\n+   --  strongly recommanded to use only letters and digits for portability\n+   --  reasons.\n+\n+   function Get_Argument (Do_Expansion : Boolean := False) return String;\n+   --  Returns the next element in the command line which is not a switch.\n+   --  This function should not be called before Getopt has returned\n+   --  ASCII.NUL.\n+   --\n+   --  If Expansion is True, then the parameter on the command\n+   --  line will considered as filename with wild cards, and will be\n+   --  expanded. The matching file names will be returned one at a time.\n+   --  When there are no more arguments on the command line, this function\n+   --  returns an empty string. This is useful in non-Unix systems for\n+   --  obtaining normal expansion of wild card references.\n+\n+   function Parameter return String;\n+   --  Returns parameter associated with the last switch returned by Getopt.\n+   --  If no parameter was associated with the last switch, or no previous\n+   --  call has been made to Get_Argument, raises Invalid_Parameter.\n+   --  If the last switch was associated with an optionnal argument and this\n+   --  argument was not found on the command line, Parameter returns an empty\n+   --  string\n+\n+   type Expansion_Iterator is limited private;\n+   --  Type used during expansion of file names\n+\n+   procedure Start_Expansion\n+     (Iterator     : out Expansion_Iterator;\n+      Pattern      : String;\n+      Directory    : String := \"\";\n+      Basic_Regexp : Boolean := True);\n+   --  Initialize an wild card expansion. The next calls to Expansion will\n+   --  return the next file name in Directory which match Pattern (Pattern\n+   --  is a regular expression, using only the Unix shell and DOS syntax if\n+   --  Basic_Regexp is True. When Directory is an empty string, the current\n+   --  directory is searched.\n+\n+   function Expansion (Iterator : Expansion_Iterator) return String;\n+   --  Return the next file in the directory matching the parameters given\n+   --  to Start_Expansion and updates Iterator to point to the next entry.\n+   --  Returns an empty string when there are no more files in the directory.\n+   --  If Expansion is called again after an empty string has been returned,\n+   --  then the exception GNAT.Directory_Operations.Directory_Error is raised.\n+\n+   Invalid_Section : exception;\n+   --  Raised when an invalid section is selected by Goto_Section\n+\n+   Invalid_Switch : exception;\n+   --  Raised when an invalid switch is detected in the command line\n+\n+   Invalid_Parameter : exception;\n+   --  Raised when a parameter is missing, or an attempt is made to obtain\n+   --  a parameter for a switch that does not allow a parameter\n+\n+private\n+\n+   type Expansion_Iterator is limited record\n+      Dir    : GNAT.Directory_Operations.Dir_Type;\n+      Regexp : GNAT.Regexp.Regexp;\n+   end record;\n+\n+end GNAT.Command_Line;"}, {"sha": "712da9640e5b5682ab9c61ddb90ac90c2b31e3ee", "filename": "gcc/ada/g-curexc.ads", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-curexc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-curexc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-curexc.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,114 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               G N A T . C U R R E N T _ E X C E P T I O N                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--         Copyright (C) 1996-2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides routines for obtaining the current exception\n+--  information in Ada 83 style. In Ada 83, there was no official method\n+--  for obtaining exception information, but a number of vendors supplied\n+--  routines for this purpose, and this package closely approximates the\n+--  interfaces supplied by DEC Ada 83 and VADS Ada.\n+\n+--  The routines in this package are associated with a particular exception\n+--  handler, and can only be called from within an exception handler. See\n+--  also the package GNAT.Most_Recent_Exception, which provides access to\n+--  the most recently raised exception, and is not limited to static calls\n+--  from an exception handler.\n+\n+package GNAT.Current_Exception is\n+pragma Pure (Current_Exception);\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   function Exception_Information return String;\n+   --  Returns the result of calling Ada.Exceptions.Exception_Information\n+   --  with an argument that is the Exception_Occurrence corresponding to\n+   --  the current exception. Returns the null string if called from outside\n+   --  an exception handler.\n+\n+   function Exception_Message return String;\n+   --  Returns the result of calling Ada.Exceptions.Exception_Message with\n+   --  an argument that is the Exception_Occurrence corresponding to the\n+   --  current exception. Returns the null string if called from outside an\n+   --  exception handler.\n+\n+   function Exception_Name return String;\n+   --  Returns the result of calling Ada.Exceptions.Exception_Name with\n+   --  an argument that is the Exception_Occurrence corresponding to the\n+   --  current exception. Returns the null string if called from outside\n+   --  an exception handler.\n+\n+   --  Note: all these functions return useful information only if\n+   --  called statically from within an exception handler, and they\n+   --  return information about the exception corresponding to the\n+   --  handler in which they appear. This is NOT the same as the most\n+   --  recently raised exception. Consider the example:\n+\n+   --     exception\n+   --        when Constraint_Error =>\n+   --          begin\n+   --             ...\n+   --          exception\n+   --             when Tasking_Error => ...\n+   --          end;\n+   --\n+   --          -- Exception_xxx at this point returns the information about\n+   --          -- the constraint error, not about any exception raised within\n+   --          -- the nested block since it is the static nesting that counts.\n+\n+   -----------------------------------\n+   -- Use of Library Level Renaming --\n+   -----------------------------------\n+\n+   --  For greater compatibility with existing legacy software, library\n+   --  level renaming may be used to create a function with a name matching\n+   --  one that is in use. For example, some versions of VADS Ada provided\n+   --  a functin called Current_Exception whose semantics was identical to\n+   --  that of GNAT. The following library level renaming declaration:\n+\n+   --    with GNAT.Current_Exception;\n+   --    function Current_Exception\n+   --      renames GNAT.Current_Exception.Exception_Name;\n+\n+   --  placed in a file called current_exception.ads and compiled into the\n+   --  application compilation environment, will make the function available\n+   --  in a manner exactly compatible with that in VADS Ada 83.\n+\n+private\n+   pragma Import (Intrinsic, Exception_Information);\n+   pragma Import (intrinsic, Exception_Message);\n+   pragma Import (Intrinsic, Exception_Name);\n+\n+end GNAT.Current_Exception;"}, {"sha": "d3d2e7468f839fb52aad56feb3bf9f989f772154", "filename": "gcc/ada/g-debpoo.adb", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,223 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      G N A T . D E B U G _ P O O L S                     --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--                            $Revision: 1.14 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Unchecked_Conversion;\n+with GNAT.HTable;\n+with System.Memory;\n+\n+pragma Elaborate_All (GNAT.HTable);\n+\n+package body GNAT.Debug_Pools is\n+   use System;\n+   use System.Memory;\n+   use System.Storage_Elements;\n+\n+   --  Definition of a H-table storing the status of each storage chunck\n+   --  used by this pool\n+\n+   type State is (Not_Allocated, Deallocated, Allocated);\n+\n+   type Header is range 1 .. 1023;\n+   function H (F : Address) return Header;\n+\n+   package Table is new GNAT.HTable.Simple_HTable (\n+     Header_Num => Header,\n+     Element    => State,\n+     No_Element => Not_Allocated,\n+     Key        => Address,\n+     Hash       => H,\n+     Equal      => \"=\");\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate\n+     (Pool                     : in out Debug_Pool;\n+      Storage_Address          : out Address;\n+      Size_In_Storage_Elements : Storage_Count;\n+      Alignment                : Storage_Count) is\n+   begin\n+      Storage_Address := Alloc (size_t (Size_In_Storage_Elements));\n+\n+      if Storage_Address = Null_Address then\n+         raise Storage_Error;\n+      else\n+         Table.Set (Storage_Address, Allocated);\n+         Pool.Allocated := Pool.Allocated + Size_In_Storage_Elements;\n+\n+         if Pool.Allocated - Pool.Deallocated >  Pool.High_Water then\n+            Pool.High_Water := Pool.Allocated - Pool.Deallocated;\n+         end if;\n+      end if;\n+   end Allocate;\n+\n+   ----------------\n+   -- Deallocate --\n+   ----------------\n+\n+   procedure Deallocate\n+     (Pool                     : in out Debug_Pool;\n+      Storage_Address          : Address;\n+      Size_In_Storage_Elements : Storage_Count;\n+      Alignment                : Storage_Count)\n+   is\n+      procedure Free (Address : System.Address; Siz : Storage_Count);\n+      --  Faked free, that reset all the deallocated storage to \"DEADBEEF\"\n+\n+      procedure Free (Address : System.Address; Siz : Storage_Count) is\n+         DB1 : constant Integer := 16#DEAD#;\n+         DB2 : constant Integer := 16#BEEF#;\n+\n+         type Dead_Memory is array (1 .. Siz / 4) of Integer;\n+         type Mem_Ptr is access all Dead_Memory;\n+\n+         function From_Ptr is\n+           new Unchecked_Conversion (System.Address, Mem_Ptr);\n+\n+         J : Storage_Offset;\n+\n+      begin\n+         J := Dead_Memory'First;\n+         while J < Dead_Memory'Last loop\n+            From_Ptr (Address) (J) := DB1;\n+            From_Ptr (Address) (J + 1) := DB2;\n+            J := J + 2;\n+         end loop;\n+\n+         if J = Dead_Memory'Last then\n+            From_Ptr (Address) (J) := DB1;\n+         end if;\n+      end Free;\n+\n+      S : State := Table.Get (Storage_Address);\n+\n+   --  Start of processing for Deallocate\n+\n+   begin\n+      case S is\n+         when Not_Allocated =>\n+            raise Freeing_Not_Allocated_Storage;\n+\n+         when Deallocated   =>\n+            raise  Freeing_Deallocated_Storage;\n+\n+         when Allocated =>\n+            Free (Storage_Address, Size_In_Storage_Elements);\n+            Table.Set (Storage_Address, Deallocated);\n+            Pool.Deallocated := Pool.Deallocated + Size_In_Storage_Elements;\n+      end case;\n+   end Deallocate;\n+\n+   -----------------\n+   -- Dereference --\n+   -----------------\n+\n+   procedure Dereference\n+     (Pool                     : in out Debug_Pool;\n+      Storage_Address          : Address;\n+      Size_In_Storage_Elements : Storage_Count;\n+      Alignment                : Storage_Count)\n+   is\n+      S       : State := Table.Get (Storage_Address);\n+      Max_Dim : constant := 3;\n+      Dim     : Integer  := 1;\n+\n+   begin\n+\n+      --  If this is not a known address, maybe it is because is is an\n+      --  unconstained array. In which case, the bounds have used the\n+      --  2 first words (per dimension) of the allocated spot.\n+\n+      while S = Not_Allocated and then Dim <= Max_Dim loop\n+         S := Table.Get (Storage_Address - Storage_Offset (Dim * 2 * 4));\n+         Dim := Dim + 1;\n+      end loop;\n+\n+      case S is\n+         when  Not_Allocated =>\n+            raise Accessing_Not_Allocated_Storage;\n+\n+         when Deallocated =>\n+            raise Accessing_Deallocated_Storage;\n+\n+         when Allocated =>\n+            null;\n+      end case;\n+   end Dereference;\n+\n+   -------\n+   -- H --\n+   -------\n+\n+   function H (F : Address) return Header is\n+   begin\n+      return\n+        Header (1 + (To_Integer (F) mod Integer_Address (Header'Last)));\n+   end H;\n+\n+   ----------------\n+   -- Print_Info --\n+   ----------------\n+\n+   procedure Print_Info (Pool : Debug_Pool) is\n+      use System.Storage_Elements;\n+\n+   begin\n+      Put_Line (\"Debug Pool info:\");\n+      Put_Line (\"  Total allocated bytes : \"\n+        & Storage_Offset'Image (Pool.Allocated));\n+\n+      Put_Line (\"  Total deallocated bytes : \"\n+        & Storage_Offset'Image (Pool.Deallocated));\n+\n+      Put_Line (\"  Current Water Mark: \"\n+        & Storage_Offset'Image (Pool.Allocated - Pool.Deallocated));\n+\n+      Put_Line (\"  High Water Mark: \"\n+        & Storage_Offset'Image (Pool.High_Water));\n+      Put_Line (\"\");\n+   end Print_Info;\n+\n+   ------------------\n+   -- Storage_Size --\n+   ------------------\n+\n+   function Storage_Size (Pool : Debug_Pool) return Storage_Count is\n+   begin\n+      return Storage_Count'Last;\n+   end Storage_Size;\n+\n+end GNAT.Debug_Pools;"}, {"sha": "bd61e77768c8b46bc6118c4553be73c641e0286e", "filename": "gcc/ada/g-debpoo.ads", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debpoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debpoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,105 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       G N A T . D E B U G _ P O O L S                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;                  use System;\n+with System.Storage_Elements; use System.Storage_Elements;\n+with System.Checked_Pools;\n+\n+package GNAT.Debug_Pools is\n+\n+   --  The debug pool is used to track down memory corruption due to use of\n+   --  deallocated memory or incorrect unchecked conversions. Allocation\n+   --  strategy :\n+\n+   --     - allocation:   . memory is normally allocated with malloc\n+   --                     . the allocated address is noted in a table\n+\n+   --     - deallocation: . memory is  filled with \"DEAD_BEEF\" patterns\n+   --                     . memory is not freed\n+   --                     . exceptions are raised if the memory was not\n+   --                       allocated or was already deallocated\n+\n+   --     - dereference:  . exceptions are raised if the memory was not\n+   --                        allocated or was already deallocated\n+\n+   Accessing_Not_Allocated_Storage : exception;\n+   Accessing_Deallocated_Storage   : exception;\n+   Freeing_Not_Allocated_Storage   : exception;\n+   Freeing_Deallocated_Storage     : exception;\n+\n+   type Debug_Pool is\n+     new System.Checked_Pools.Checked_Pool with private;\n+\n+   procedure Allocate\n+     (Pool                     : in out Debug_Pool;\n+      Storage_Address          : out Address;\n+      Size_In_Storage_Elements : Storage_Count;\n+      Alignment                : Storage_Count);\n+\n+   procedure Deallocate\n+     (Pool                     : in out Debug_Pool;\n+      Storage_Address          : Address;\n+      Size_In_Storage_Elements : Storage_Count;\n+      Alignment                : Storage_Count);\n+\n+   function Storage_Size\n+     (Pool : Debug_Pool)\n+      return System.Storage_Elements.Storage_Count;\n+\n+   procedure Dereference\n+     (Pool                     : in out Debug_Pool;\n+      Storage_Address          : System.Address;\n+      Size_In_Storage_Elements : Storage_Count;\n+      Alignment                : Storage_Count);\n+\n+   generic\n+      with procedure Put_Line (S : String);\n+   procedure Print_Info (Pool : Debug_Pool);\n+   --  Print out information about the High Water Mark, the current and\n+   --  total number of bytes allocated and the total number of bytes\n+   --  deallocated.\n+\n+private\n+   type Debug_Pool is new System.Checked_Pools.Checked_Pool with record\n+      Allocated   : Storage_Count := 0;\n+      --  Total number of bytes allocated in this pool\n+\n+      Deallocated : Storage_Count := 0;\n+      --  Total number of bytes deallocated in this pool\n+\n+      High_Water  : Storage_Count := 0;\n+      --  Maximum of during the time of Allocated - Deallocated\n+   end record;\n+end GNAT.Debug_Pools;"}, {"sha": "f92cffa47921bcade2724777de09f03230e64585", "filename": "gcc/ada/g-debuti.adb", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debuti.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,111 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 G N A T . D E B U G _ U T I L I T I E S                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--           Copyright (C) 1997-1998 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;                  use System;\n+with System.Storage_Elements; use System.Storage_Elements;\n+\n+package body GNAT.Debug_Utilities is\n+\n+   --------------------------\n+   -- Image (address case) --\n+   --------------------------\n+\n+   function Image (A : Address) return String is\n+      S : String (1 .. Address_Image_Length);\n+      P : Natural := S'Last - 1;\n+      N : Integer_Address := To_Integer (A);\n+      U : Natural := 0;\n+\n+      H : array (Integer range 0 .. 15) of Character := \"0123456789ABCDEF\";\n+\n+   begin\n+      S (S'Last) := '#';\n+\n+      while P > 3 loop\n+         if U = 4 then\n+            S (P) := '_';\n+            P := P - 1;\n+            U := 1;\n+\n+         else\n+            U := U + 1;\n+         end if;\n+\n+         S (P) := H (Integer (N mod 16));\n+         P := P - 1;\n+         N := N / 16;\n+      end loop;\n+\n+      S (1 .. 3) := \"16#\";\n+      return S;\n+   end Image;\n+\n+   -------------------------\n+   -- Image (string case) --\n+   -------------------------\n+\n+   function Image (S : String) return String is\n+      W : String (1 .. 2 * S'Length + 2);\n+      P : Positive := 1;\n+\n+   begin\n+      W (1) := '\"';\n+\n+      for J in S'Range loop\n+         if S (J) = '\"' then\n+            P := P + 1;\n+            W (P) := '\"';\n+         end if;\n+\n+         P := P + 1;\n+         W (P) := S (J);\n+      end loop;\n+\n+      P := P + 1;\n+      W (P) := '\"';\n+      return W (1 .. P);\n+   end Image;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (S : String) return System.Address is\n+      N : constant Integer_Address := Integer_Address'Value (S);\n+\n+   begin\n+      return To_Address (N);\n+   end Value;\n+\n+end GNAT.Debug_Utilities;"}, {"sha": "4a3d862faa10b8b518769b550dbc7ed6e5ffc100", "filename": "gcc/ada/g-debuti.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-debuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debuti.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                 G N A T . D E B U G _ U T I L I T I E S                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1998 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Debugging utilities\n+\n+--  This package provides some useful utility subprograms for use in writing\n+--  routines that generate debugging output.\n+\n+with System;\n+\n+package GNAT.Debug_Utilities is\n+pragma Pure (Debug_Utilities);\n+\n+   function Image (S : String) return String;\n+   --  Returns a string image of S, obtained by prepending and appending\n+   --  quote (\") characters and doubling any quote characters in the string.\n+   --  The maximum length of the result is thus 2 ** S'Length + 2.\n+\n+   Address_Image_Length : constant :=\n+                            13 + 10 * Boolean'Pos (Standard'Address_Size > 32);\n+   --  Length of string returned by Image function\n+\n+   function Image (A : System.Address) return String;\n+   --  Returns a string of the form 16#xxxx_xxxx# for 32-bit addresses\n+   --  or 16#xxxx_xxxx_xxxx_xxxx# for 64-bit addresses. Hex characters\n+   --  are in upper case.\n+\n+   function Value (S : String) return System.Address;\n+   --  Given a valid integer literal in any form, including the form returned\n+   --  by the Image function in this package, yields the corresponding address.\n+\n+end GNAT.Debug_Utilities;"}, {"sha": "d73d9a02005e9a3cf0379aa806e3246ac7bb841f", "filename": "gcc/ada/g-dirope.adb", "status": "added", "additions": 981, "deletions": 0, "changes": 981, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dirope.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dirope.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,981 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . D I R E C T O R Y _ O P E R A T I O N S             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.15 $\n+--                                                                          --\n+--            Copyright (C) 1998-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Handling;\n+with Ada.Strings.Fixed;\n+with Ada.Strings.Unbounded;\n+with Ada.Strings.Maps;\n+with Unchecked_Deallocation;\n+with Unchecked_Conversion;\n+with System;  use System;\n+\n+with GNAT.Regexp;\n+with GNAT.OS_Lib;\n+\n+package body GNAT.Directory_Operations is\n+\n+   use Ada;\n+\n+   type Dir_Type_Value is new System.Address;\n+   --  This is the low-level address directory structure as returned by the C\n+   --  opendir routine.\n+\n+   Dir_Seps : constant Strings.Maps.Character_Set :=\n+                Strings.Maps.To_Set (\"/\\\");\n+   --  UNIX and DOS style directory separators.\n+\n+   procedure Free is new\n+     Unchecked_Deallocation (Dir_Type_Value, Dir_Type);\n+\n+   ---------------\n+   -- Base_Name --\n+   ---------------\n+\n+   function Base_Name\n+     (Path   : Path_Name;\n+      Suffix : String    := \"\")\n+      return   String\n+   is\n+      function Get_File_Names_Case_Sensitive return Integer;\n+      pragma Import\n+        (C, Get_File_Names_Case_Sensitive,\n+         \"__gnat_get_file_names_case_sensitive\");\n+\n+      Case_Sensitive_File_Name : constant Boolean :=\n+                                   Get_File_Names_Case_Sensitive = 1;\n+\n+      function Basename\n+        (Path   : Path_Name;\n+         Suffix : String    := \"\")\n+         return String;\n+      --  This function does the job. The only difference between Basename\n+      --  and Base_Name (the parent function) is that the former is case\n+      --  sensitive, while the latter is not. Path and Suffix are adjusted\n+      --  appropriately before calling Basename under platforms where the\n+      --  file system is not case sensitive.\n+\n+      --------------\n+      -- Basename --\n+      --------------\n+\n+      function Basename\n+        (Path   : Path_Name;\n+         Suffix : String    := \"\")\n+         return   String\n+      is\n+         Cut_Start : Natural :=\n+                       Strings.Fixed.Index\n+                         (Path, Dir_Seps, Going => Strings.Backward);\n+         Cut_End : Natural;\n+\n+      begin\n+         --  Cut_Start point to the first basename character\n+\n+         if Cut_Start = 0 then\n+            Cut_Start := Path'First;\n+\n+         else\n+            Cut_Start := Cut_Start + 1;\n+         end if;\n+\n+         --  Cut_End point to the last basename character.\n+\n+         Cut_End := Path'Last;\n+\n+         --  If basename ends with Suffix, adjust Cut_End.\n+\n+         if Suffix /= \"\"\n+           and then Path (Path'Last - Suffix'Length + 1 .. Cut_End) = Suffix\n+         then\n+            Cut_End := Path'Last - Suffix'Length;\n+         end if;\n+\n+         Check_For_Standard_Dirs : declare\n+            BN : constant String := Base_Name.Path (Cut_Start .. Cut_End);\n+\n+         begin\n+            if BN = \".\" or else BN = \"..\" then\n+               return \"\";\n+\n+            elsif BN'Length > 2\n+              and then Characters.Handling.Is_Letter (BN (BN'First))\n+              and then BN (BN'First + 1) = ':'\n+            then\n+               --  We have a DOS drive letter prefix, remove it\n+\n+               return BN (BN'First + 2 .. BN'Last);\n+\n+            else\n+               return BN;\n+            end if;\n+         end Check_For_Standard_Dirs;\n+      end Basename;\n+\n+   --  Start processing for Base_Name\n+\n+   begin\n+      if Case_Sensitive_File_Name then\n+         return Basename (Path, Suffix);\n+\n+      else\n+         return Basename\n+           (Characters.Handling.To_Lower (Path),\n+            Characters.Handling.To_Lower (Suffix));\n+      end if;\n+   end Base_Name;\n+\n+   ----------------\n+   -- Change_Dir --\n+   ----------------\n+\n+   procedure Change_Dir (Dir_Name : Dir_Name_Str) is\n+      C_Dir_Name : String := Dir_Name & ASCII.NUL;\n+\n+      function chdir (Dir_Name : String) return Integer;\n+      pragma Import (C, chdir, \"chdir\");\n+\n+   begin\n+      if chdir (C_Dir_Name) /= 0 then\n+         raise Directory_Error;\n+      end if;\n+   end Change_Dir;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Dir : in out Dir_Type) is\n+\n+      function closedir (Directory : System.Address) return Integer;\n+      pragma Import (C, closedir, \"closedir\");\n+\n+      Discard : Integer;\n+\n+   begin\n+      if not Is_Open (Dir) then\n+         raise Directory_Error;\n+      end if;\n+\n+      Discard := closedir (System.Address (Dir.all));\n+      Free (Dir);\n+   end Close;\n+\n+   --------------\n+   -- Dir_Name --\n+   --------------\n+\n+   function Dir_Name (Path : Path_Name) return Dir_Name_Str is\n+      Last_DS : constant Natural :=\n+                  Strings.Fixed.Index\n+                    (Path, Dir_Seps, Going => Strings.Backward);\n+\n+   begin\n+      if Last_DS = 0 then\n+\n+         --  There is no directory separator, returns current working directory\n+\n+         return \".\" & Dir_Separator;\n+\n+      else\n+         return Path (Path'First .. Last_DS);\n+      end if;\n+   end Dir_Name;\n+\n+   -----------------\n+   -- Expand_Path --\n+   -----------------\n+\n+   function Expand_Path (Path : Path_Name) return String is\n+      use Ada.Strings.Unbounded;\n+\n+      procedure Read (K : in out Positive);\n+      --  Update Result while reading current Path starting at position K. If\n+      --  a variable is found, call Var below.\n+\n+      procedure Var (K : in out Positive);\n+      --  Translate variable name starting at position K with the associated\n+      --  environement value.\n+\n+      procedure Free is\n+         new Unchecked_Deallocation (String, OS_Lib.String_Access);\n+\n+      Result : Unbounded_String;\n+\n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read (K : in out Positive) is\n+      begin\n+         For_All_Characters : loop\n+            if Path (K) = '$' then\n+\n+               --  Could be a variable\n+\n+               if K < Path'Last then\n+\n+                  if Path (K + 1) = '$' then\n+\n+                     --  Not a variable after all, this is a double $, just\n+                     --  insert one in the result string.\n+\n+                     Append (Result, '$');\n+                     K := K + 1;\n+\n+                  else\n+                     --  Let's parse the variable\n+\n+                     K := K + 1;\n+                     Var (K);\n+                  end if;\n+\n+               else\n+                  --  We have an ending $ sign\n+\n+                  Append (Result, '$');\n+               end if;\n+\n+            else\n+               --  This is a standard character, just add it to the result\n+\n+               Append (Result, Path (K));\n+            end if;\n+\n+            --  Skip to next character\n+\n+            K := K + 1;\n+\n+            exit For_All_Characters when K > Path'Last;\n+         end loop For_All_Characters;\n+      end Read;\n+\n+      ---------\n+      -- Var --\n+      ---------\n+\n+      procedure Var (K : in out Positive) is\n+         E : Positive;\n+\n+      begin\n+         if Path (K) = '{' then\n+\n+            --  Look for closing } (curly bracket).\n+\n+            E := K;\n+\n+            loop\n+               E := E + 1;\n+               exit when Path (E) = '}' or else E = Path'Last;\n+            end loop;\n+\n+            if Path (E) = '}' then\n+\n+               --  OK found, translate with environement value\n+\n+               declare\n+                  Env : OS_Lib.String_Access :=\n+                          OS_Lib.Getenv (Path (K + 1 .. E - 1));\n+\n+               begin\n+                  Append (Result, Env.all);\n+                  Free (Env);\n+               end;\n+\n+            else\n+               --  No closing curly bracket, not a variable after all or a\n+               --  syntax error, ignore it, insert string as-is.\n+\n+               Append (Result, '$' & Path (K .. E));\n+            end if;\n+\n+         else\n+            --  The variable name is everything from current position to first\n+            --  non letter/digit character.\n+\n+            E := K;\n+\n+            --  Check that first chartacter is a letter\n+\n+            if Characters.Handling.Is_Letter (Path (E)) then\n+               E := E + 1;\n+\n+               Var_Name : loop\n+                  exit Var_Name when E = Path'Last;\n+\n+                  if Characters.Handling.Is_Letter (Path (E))\n+                    or else Characters.Handling.Is_Digit (Path (E))\n+                  then\n+                     E := E + 1;\n+                  else\n+                     E := E - 1;\n+                     exit Var_Name;\n+                  end if;\n+               end loop Var_Name;\n+\n+               declare\n+                  Env : OS_Lib.String_Access := OS_Lib.Getenv (Path (K .. E));\n+\n+               begin\n+                  Append (Result, Env.all);\n+                  Free (Env);\n+               end;\n+\n+            else\n+               --  This is not a variable after all\n+\n+               Append (Result, '$' & Path (E));\n+            end if;\n+\n+         end if;\n+\n+         K := E;\n+      end Var;\n+\n+   --  Start of processing for Expand_Path\n+\n+   begin\n+      declare\n+         K : Positive := Path'First;\n+\n+      begin\n+         Read (K);\n+         return To_String (Result);\n+      end;\n+   end Expand_Path;\n+\n+   --------------------\n+   -- File_Extension --\n+   --------------------\n+\n+   function File_Extension (Path : Path_Name) return String is\n+      First : Natural :=\n+                Strings.Fixed.Index\n+                  (Path, Dir_Seps, Going => Strings.Backward);\n+\n+      Dot : Natural;\n+\n+   begin\n+      if First = 0 then\n+         First := Path'First;\n+      end if;\n+\n+      Dot := Strings.Fixed.Index (Path (First .. Path'Last),\n+                                  \".\",\n+                                  Going => Strings.Backward);\n+\n+      if Dot = 0 or else Dot = Path'Last then\n+         return \"\";\n+      else\n+         return Path (Dot .. Path'Last);\n+      end if;\n+   end File_Extension;\n+\n+   ---------------\n+   -- File_Name --\n+   ---------------\n+\n+   function File_Name (Path : Path_Name) return String is\n+   begin\n+      return Base_Name (Path);\n+   end File_Name;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   procedure Find\n+     (Root_Directory : Dir_Name_Str;\n+      File_Pattern   : String)\n+   is\n+      File_Regexp : constant Regexp.Regexp := Regexp.Compile (File_Pattern);\n+      Index       : Natural := 0;\n+\n+      procedure Read_Directory (Directory : Dir_Name_Str);\n+      --  Open Directory and read all entries. This routine is called\n+      --  recursively for each sub-directories.\n+\n+      function Make_Pathname (Dir, File : String) return String;\n+      --  Returns the pathname for File by adding Dir as prefix.\n+\n+      -------------------\n+      -- Make_Pathname --\n+      -------------------\n+\n+      function Make_Pathname (Dir, File : String) return String is\n+      begin\n+         if Dir (Dir'Last) = '/' or else Dir (Dir'Last) = '\\' then\n+            return Dir & File;\n+         else\n+            return Dir & Dir_Separator & File;\n+         end if;\n+      end Make_Pathname;\n+\n+      --------------------\n+      -- Read_Directory --\n+      --------------------\n+\n+      procedure Read_Directory (Directory : Dir_Name_Str) is\n+         Dir    : Dir_Type;\n+         Buffer : String (1 .. 2_048);\n+         Last   : Natural;\n+         Quit   : Boolean;\n+\n+      begin\n+         Open (Dir, Directory);\n+\n+         loop\n+            Read (Dir, Buffer, Last);\n+            exit when Last = 0;\n+\n+            declare\n+               Dir_Entry : constant String := Buffer (1 .. Last);\n+               Pathname  : constant String\n+                 := Make_Pathname (Directory, Dir_Entry);\n+            begin\n+               if Regexp.Match (Dir_Entry, File_Regexp) then\n+                  Quit  := False;\n+                  Index := Index + 1;\n+\n+                  begin\n+                     Action (Pathname, Index, Quit);\n+                  exception\n+                     when others =>\n+                        Close (Dir);\n+                        raise;\n+                  end;\n+\n+                  exit when Quit;\n+               end if;\n+\n+               --  Recursively call for sub-directories, except for . and ..\n+\n+               if not (Dir_Entry = \".\" or else Dir_Entry = \"..\")\n+                 and then OS_Lib.Is_Directory (Pathname)\n+               then\n+                  Read_Directory (Pathname);\n+               end if;\n+            end;\n+         end loop;\n+\n+         Close (Dir);\n+      end Read_Directory;\n+\n+   begin\n+      Read_Directory (Root_Directory);\n+   end Find;\n+\n+   ---------------------\n+   -- Get_Current_Dir --\n+   ---------------------\n+\n+   Max_Path : Integer;\n+   pragma Import (C, Max_Path, \"max_path_len\");\n+\n+   function Get_Current_Dir return Dir_Name_Str is\n+      Current_Dir : String (1 .. Max_Path + 1);\n+      Last        : Natural;\n+\n+   begin\n+      Get_Current_Dir (Current_Dir, Last);\n+      return Current_Dir (1 .. Last);\n+   end Get_Current_Dir;\n+\n+   procedure Get_Current_Dir (Dir : out Dir_Name_Str; Last : out Natural) is\n+      Path_Len : Natural := Max_Path;\n+      Buffer   : String (Dir'First .. Dir'First + Max_Path + 1);\n+\n+      procedure Local_Get_Current_Dir\n+        (Dir    : System.Address;\n+         Length : System.Address);\n+      pragma Import (C, Local_Get_Current_Dir, \"__gnat_get_current_dir\");\n+\n+   begin\n+      Local_Get_Current_Dir (Buffer'Address, Path_Len'Address);\n+\n+      if Dir'Length > Path_Len then\n+         Last := Dir'First + Path_Len - 1;\n+      else\n+         Last := Dir'Last;\n+      end if;\n+\n+      Dir (Buffer'First .. Last) := Buffer (Buffer'First .. Last);\n+   end Get_Current_Dir;\n+\n+   -------------\n+   -- Is_Open --\n+   -------------\n+\n+   function Is_Open (Dir : Dir_Type) return Boolean is\n+   begin\n+      return Dir /= Null_Dir\n+        and then System.Address (Dir.all) /= System.Null_Address;\n+   end Is_Open;\n+\n+   --------------\n+   -- Make_Dir --\n+   --------------\n+\n+   procedure Make_Dir (Dir_Name : Dir_Name_Str) is\n+      C_Dir_Name : String := Dir_Name & ASCII.NUL;\n+\n+      function mkdir (Dir_Name : String) return Integer;\n+      pragma Import (C, mkdir, \"__gnat_mkdir\");\n+\n+   begin\n+      if mkdir (C_Dir_Name) /= 0 then\n+         raise Directory_Error;\n+      end if;\n+   end Make_Dir;\n+\n+   ------------------------\n+   -- Normalize_Pathname --\n+   ------------------------\n+\n+   function Normalize_Pathname\n+     (Path  : Path_Name;\n+      Style : Path_Style := System_Default)\n+      return  String\n+   is\n+      N_Path      : String := Path;\n+      K           : Positive := N_Path'First;\n+      Prev_Dirsep : Boolean := False;\n+\n+   begin\n+      for J in Path'Range loop\n+\n+         if Strings.Maps.Is_In (Path (J), Dir_Seps) then\n+            if not Prev_Dirsep then\n+\n+               case Style is\n+                  when UNIX           => N_Path (K) := '/';\n+                  when DOS            => N_Path (K) := '\\';\n+                  when System_Default => N_Path (K) := Dir_Separator;\n+               end case;\n+\n+               K := K + 1;\n+            end if;\n+\n+            Prev_Dirsep := True;\n+\n+         else\n+            N_Path (K) := Path (J);\n+            K := K + 1;\n+            Prev_Dirsep := False;\n+         end if;\n+      end loop;\n+\n+      return N_Path (N_Path'First .. K - 1);\n+   end Normalize_Pathname;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (Dir      : out Dir_Type;\n+      Dir_Name : Dir_Name_Str)\n+   is\n+      C_File_Name : String := Dir_Name & ASCII.NUL;\n+\n+      function opendir\n+        (File_Name : String)\n+         return      Dir_Type_Value;\n+      pragma Import (C, opendir, \"opendir\");\n+\n+   begin\n+      Dir := new Dir_Type_Value'(opendir (C_File_Name));\n+\n+      if not Is_Open (Dir) then\n+         Free (Dir);\n+         Dir := Null_Dir;\n+         raise Directory_Error;\n+      end if;\n+   end Open;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Dir  : in out Dir_Type;\n+      Str  : out String;\n+      Last : out Natural)\n+   is\n+      Filename_Addr : Address;\n+      Filename_Len  : Integer;\n+\n+      Buffer : array (0 .. 1024) of Character;\n+      --  1024 is the value of FILENAME_MAX in stdio.h\n+\n+      function readdir_gnat\n+        (Directory : System.Address;\n+         Buffer    : System.Address)\n+         return      System.Address;\n+      pragma Import (C, readdir_gnat, \"__gnat_readdir\");\n+\n+      function strlen (S : Address) return Integer;\n+      pragma Import (C, strlen, \"strlen\");\n+\n+   begin\n+      if not Is_Open (Dir) then\n+         raise Directory_Error;\n+      end if;\n+\n+      Filename_Addr :=\n+        readdir_gnat (System.Address (Dir.all), Buffer'Address);\n+\n+      if Filename_Addr = System.Null_Address then\n+         Last := 0;\n+         return;\n+      end if;\n+\n+      Filename_Len  := strlen (Filename_Addr);\n+\n+      if Str'Length > Filename_Len then\n+         Last := Str'First + Filename_Len - 1;\n+      else\n+         Last := Str'Last;\n+      end if;\n+\n+      declare\n+         subtype Path_String is String (1 .. Filename_Len);\n+         type    Path_String_Access is access Path_String;\n+\n+         function Address_To_Access is new\n+           Unchecked_Conversion\n+             (Source => Address,\n+              Target => Path_String_Access);\n+\n+         Path_Access : Path_String_Access := Address_To_Access (Filename_Addr);\n+\n+      begin\n+         for J in Str'First .. Last loop\n+            Str (J) := Path_Access (J - Str'First + 1);\n+         end loop;\n+      end;\n+   end Read;\n+\n+   -------------------------\n+   -- Read_Is_Thread_Sage --\n+   -------------------------\n+\n+   function Read_Is_Thread_Safe return Boolean is\n+\n+      function readdir_is_thread_safe return Integer;\n+      pragma Import\n+        (C, readdir_is_thread_safe, \"__gnat_readdir_is_thread_safe\");\n+\n+   begin\n+      return (readdir_is_thread_safe /= 0);\n+   end Read_Is_Thread_Safe;\n+\n+   ----------------\n+   -- Remove_Dir --\n+   ----------------\n+\n+   procedure Remove_Dir (Dir_Name : Dir_Name_Str) is\n+      C_Dir_Name : String := Dir_Name & ASCII.NUL;\n+\n+      procedure rmdir (Dir_Name : String);\n+      pragma Import (C, rmdir, \"rmdir\");\n+\n+   begin\n+      rmdir (C_Dir_Name);\n+   end Remove_Dir;\n+\n+   -----------------------\n+   -- Wildcard_Iterator --\n+   -----------------------\n+\n+   procedure Wildcard_Iterator (Path : Path_Name) is\n+\n+      Index : Natural := 0;\n+\n+      procedure Read\n+        (Directory      : String;\n+         File_Pattern   : String;\n+         Suffix_Pattern : String);\n+      --  Read entries in Directory and call user's callback if the entry\n+      --  match File_Pattern and Suffix_Pattern is empty otherwise it will go\n+      --  down one more directory level by calling Next_Level routine above.\n+\n+      procedure Next_Level\n+        (Current_Path : String;\n+         Suffix_Path  : String);\n+      --  Extract next File_Pattern from Suffix_Path and call Read routine\n+      --  above.\n+\n+      ----------------\n+      -- Next_Level --\n+      ----------------\n+\n+      procedure Next_Level\n+        (Current_Path : String;\n+         Suffix_Path  : String)\n+      is\n+         DS : Natural;\n+         SP : String renames Suffix_Path;\n+\n+      begin\n+         if SP'Length > 2\n+           and then SP (SP'First) = '.'\n+           and then Strings.Maps.Is_In (SP (SP'First + 1), Dir_Seps)\n+         then\n+            --  Starting with \"./\"\n+\n+            DS := Strings.Fixed.Index\n+              (SP (SP'First + 2 .. SP'Last),\n+               Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"./\"\n+\n+               Read (Current_Path & \".\", \"*\", \"\");\n+\n+            else\n+               --  We have \"./dir\"\n+\n+               Read (Current_Path & \".\",\n+                     SP (SP'First + 2 .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         elsif SP'Length > 3\n+           and then SP (SP'First .. SP'First + 1) = \"..\"\n+           and then Strings.Maps.Is_In (SP (SP'First + 2), Dir_Seps)\n+         then\n+            --  Starting with \"../\"\n+\n+            DS := Strings.Fixed.Index\n+              (SP (SP'First + 3 .. SP'Last),\n+               Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"../\"\n+\n+               Read (Current_Path & \"..\", \"*\", \"\");\n+\n+            else\n+               --  We have \"../dir\"\n+\n+               Read (Current_Path & \"..\",\n+                     SP (SP'First + 4 .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         elsif Current_Path = \"\"\n+           and then SP'Length > 1\n+           and then Characters.Handling.Is_Letter (SP (SP'First))\n+           and then SP (SP'First + 1) = ':'\n+         then\n+            --  Starting with \"<drive>:\"\n+\n+            if SP'Length > 2\n+              and then Strings.Maps.Is_In (SP (SP'First + 2), Dir_Seps)\n+            then\n+               --  Starting with \"<drive>:\\\"\n+\n+               DS :=  Strings.Fixed.Index\n+                        (SP (SP'First + 3 .. SP'Last), Dir_Seps);\n+\n+               if DS = 0 then\n+\n+                  --  Se have \"<drive>:\\dir\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 3 .. SP'Last),\n+                        \"\");\n+\n+               else\n+                  --  We have \"<drive>:\\dir\\kkk\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 3 .. DS - 1),\n+                        SP (DS .. SP'Last));\n+               end if;\n+\n+            else\n+               --  Starting with \"<drive>:\"\n+\n+               DS :=  Strings.Fixed.Index\n+                        (SP (SP'First + 2 .. SP'Last), Dir_Seps);\n+\n+               if DS = 0 then\n+\n+                  --  We have \"<drive>:dir\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 2 .. SP'Last),\n+                        \"\");\n+\n+               else\n+                  --  We have \"<drive>:dir/kkk\"\n+\n+                  Read (SP (SP'First .. SP'First + 1),\n+                        SP (SP'First + 2 .. DS - 1),\n+                        SP (DS .. SP'Last));\n+               end if;\n+\n+            end if;\n+\n+         elsif Strings.Maps.Is_In (SP (SP'First), Dir_Seps) then\n+\n+            --  Starting with a /\n+\n+            DS := Strings.Fixed.Index\n+              (SP (SP'First + 1 .. SP'Last),\n+               Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"/dir\"\n+\n+               Read (Current_Path,\n+                     SP (SP'First + 1 .. SP'Last),\n+                     \"\");\n+            else\n+               --  We have \"/dir/kkk\"\n+\n+               Read (Current_Path,\n+                     SP (SP'First + 1 .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         else\n+            --  Starting with a name\n+\n+            DS := Strings.Fixed.Index (SP, Dir_Seps);\n+\n+            if DS = 0 then\n+\n+               --  We have \"dir\"\n+\n+               Read (Current_Path & '.',\n+                     SP,\n+                     \"\");\n+            else\n+               --  We have \"dir/kkk\"\n+\n+               Read (Current_Path & '.',\n+                     SP (SP'First .. DS - 1),\n+                     SP (DS .. SP'Last));\n+            end if;\n+\n+         end if;\n+      end Next_Level;\n+\n+      ----------\n+      -- Read --\n+      ----------\n+\n+      Quit : Boolean := False;\n+      --  Global state to be able to exit all recursive calls.\n+\n+      procedure Read\n+        (Directory      : String;\n+         File_Pattern   : String;\n+         Suffix_Pattern : String)\n+      is\n+         File_Regexp : constant Regexp.Regexp :=\n+                         Regexp.Compile (File_Pattern, Glob => True);\n+         Dir    : Dir_Type;\n+         Buffer : String (1 .. 2_048);\n+         Last   : Natural;\n+\n+      begin\n+         if OS_Lib.Is_Directory (Directory) then\n+            Open (Dir, Directory);\n+\n+            Dir_Iterator : loop\n+               Read (Dir, Buffer, Last);\n+               exit Dir_Iterator when Last = 0;\n+\n+               declare\n+                  Dir_Entry : constant String := Buffer (1 .. Last);\n+                  Pathname  : constant String :=\n+                                Directory & Dir_Separator & Dir_Entry;\n+               begin\n+                  --  Handle \".\" and \"..\" only if explicit use in the\n+                  --  File_Pattern.\n+\n+                  if not\n+                    ((Dir_Entry = \".\" and then File_Pattern /= \".\")\n+                       or else\n+                     (Dir_Entry = \"..\" and then File_Pattern /= \"..\"))\n+                  then\n+                     if Regexp.Match (Dir_Entry, File_Regexp) then\n+\n+                        if Suffix_Pattern = \"\" then\n+\n+                           --  No more matching needed, call user's callback\n+\n+                           Index := Index + 1;\n+\n+                           begin\n+                              Action (Pathname, Index, Quit);\n+\n+                           exception\n+                              when others =>\n+                                 Close (Dir);\n+                                 raise;\n+                           end;\n+\n+                           exit Dir_Iterator when Quit;\n+\n+                        else\n+                           --  Down one level\n+\n+                           Next_Level\n+                             (Directory & Dir_Separator & Dir_Entry,\n+                              Suffix_Pattern);\n+                        end if;\n+                     end if;\n+                  end if;\n+               end;\n+\n+               exit Dir_Iterator when Quit;\n+\n+            end loop Dir_Iterator;\n+\n+            Close (Dir);\n+         end if;\n+      end Read;\n+\n+   begin\n+      Next_Level (\"\", Path);\n+   end Wildcard_Iterator;\n+\n+end GNAT.Directory_Operations;"}, {"sha": "8e6d005405e079f2ccc890cda9ca607a21e315df", "filename": "gcc/ada/g-dirope.ads", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dirope.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dirope.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,263 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . D I R E C T O R Y _ O P E R A T I O N S             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--            Copyright (C) 1998-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Directory operations\n+\n+--  This package provides routines for manipulating directories. A directory\n+--  can be treated as a file, using open and close routines, and a scanning\n+--  routine is provided for iterating through the entries in a directory.\n+\n+package GNAT.Directory_Operations is\n+\n+   subtype Dir_Name_Str is String;\n+   --  A subtype used in this package to represent string values that are\n+   --  directory names. A directory name is a prefix for files that appear\n+   --  with in the directory. This means that for UNIX systems, the string\n+   --  includes a final '/', and for DOS-like systems, it includes a final\n+   --  '\\' character. It can also include drive letters if the operating\n+   --  system provides for this. The final '/' or '\\' in a Dir_Name_Str is\n+   --  optional when passed as a procedure or function in parameter.\n+\n+   type Dir_Type is limited private;\n+   --  A value used to reference a directory. Conceptually this value includes\n+   --  the identity of the directory, and a sequential position within it.\n+\n+   Null_Dir : constant Dir_Type;\n+   --  Represent the value for an uninitialized or closed directory\n+\n+   Directory_Error : exception;\n+   --  Exception raised if the directory cannot be opened, read, closed,\n+   --  created or if it is not possible to change the current execution\n+   --  environment directory.\n+\n+   Dir_Separator : constant Character;\n+   --  Running system default directory separator\n+\n+   --------------------------------\n+   -- Basic Directory operations --\n+   --------------------------------\n+\n+   procedure Change_Dir (Dir_Name : Dir_Name_Str);\n+   --  Changes the working directory of the current execution environment\n+   --  to the directory named by Dir_Name. Raises Directory_Error if Dir_Name\n+   --  does not exist.\n+\n+   procedure Make_Dir (Dir_Name : Dir_Name_Str);\n+   --  Create a new directory named Dir_Name. Raises Directory_Error if\n+   --  Dir_Name cannot be created.\n+\n+   procedure Remove_Dir (Dir_Name : Dir_Name_Str);\n+   --  Remove the directory named Dir_Name. Raises Directory_Error if Dir_Name\n+   --  cannot be removed.\n+\n+   function Get_Current_Dir return Dir_Name_Str;\n+   --  Returns the current working directory for the execution environment.\n+\n+   procedure Get_Current_Dir (Dir : out Dir_Name_Str; Last : out Natural);\n+   --  Returns the current working directory for the execution environment\n+   --  The name is returned in Dir_Name. Last is the index in Dir_Name such\n+   --  that Dir_Name (Last) is the last character written. If Dir_Name is\n+   --  too small for the directory name, the name will be truncated before\n+   --  being copied to Dir_Name.\n+\n+   -------------------------\n+   -- Pathname Operations --\n+   -------------------------\n+\n+   subtype Path_Name is String;\n+   --  All routines using Path_Name handle both styles (UNIX and DOS) of\n+   --  directory separators (either slash or back slash).\n+\n+   function Dir_Name (Path : Path_Name) return Dir_Name_Str;\n+   --  Returns directory name for Path. This is similar to the UNIX dirname\n+   --  command. Everything after the last directory separator is removed. If\n+   --  there is no directory separator the current working directory is\n+   --  returned.\n+\n+   function Base_Name\n+     (Path   : Path_Name;\n+      Suffix : String    := \"\")\n+      return   String;\n+   --  Any directory prefix is removed. If Suffix is non-empty and is a\n+   --  suffix of Path, it is removed. This is equivalent to the UNIX basename\n+   --  command. The following rule is always true:\n+   --\n+   --    'Path' and 'Dir_Name (Path) & Directory_Separator & Base_Name (Path)'\n+   --    represent the same file.\n+   --\n+   --  This function is not case-sensitive on systems that have a non\n+   --  case-sensitive file system like Windows, OS/2 and VMS.\n+\n+   function File_Extension (Path : Path_Name) return String;\n+   --  Return the file extension. This is the string after the last dot\n+   --  character in File_Name (Path). It returns the empty string if no\n+   --  extension is found. The returned value does contains the file\n+   --  extension separator (dot character).\n+\n+   function File_Name (Path : Path_Name) return String;\n+   --  Returns the file name and the file extension if present. It removes all\n+   --  path information. This is equivalent to Base_Name with default Extension\n+   --  value.\n+\n+   type Path_Style is (UNIX, DOS, System_Default);\n+\n+   function Normalize_Pathname\n+     (Path  : Path_Name;\n+      Style : Path_Style := System_Default)\n+      return  Path_Name;\n+   --  Removes all double directory separator and converts all '\\' to '/' if\n+   --  Style is UNIX and converts all '/' to '\\' if Style is set to DOS. This\n+   --  function will help to provide a consistent naming scheme running for\n+   --  different environments. If style is set to System_Default the routine\n+   --  will use the default directory separator on the running environment.\n+\n+   function Expand_Path (Path : Path_Name) return Path_Name;\n+   --  Returns Path with environment variables (string preceded by a dollar\n+   --  sign) replaced by the current environment variable value. For example,\n+   --  $HOME/mydir will be replaced by /home/joe/mydir if $HOME environment\n+   --  variable is set to /home/joe. The variable can be surrounded by the\n+   --  characters '{' and '}' (curly bracket) if needed as in ${HOME}/mydir.\n+   --  If an environment variable does not exists the variable will be replaced\n+   --  by the empty string. Two dollar signs are replaced by a single dollar\n+   --  sign. Note that a variable must start with a letter. If there is no\n+   --  closing curly bracket for an opening one there is no translation done,\n+   --  so for example ${VAR/toto is returned as ${VAR/toto.\n+\n+   ---------------\n+   -- Iterators --\n+   ---------------\n+\n+   procedure Open (Dir : out Dir_Type; Dir_Name : Dir_Name_Str);\n+   --  Opens the directory named by Dir_Name and returns a Dir_Type value\n+   --  that refers to this directory, and is positioned at the first entry.\n+   --  Raises Directory_Error if Dir_Name cannot be accessed. In that case\n+   --  Dir will be set to Null_Dir.\n+\n+   procedure Close (Dir : in out Dir_Type);\n+   --  Closes the directory stream refered to by Dir. After calling Close\n+   --  Is_Open will return False. Dir will be set to Null_Dir.\n+   --  Raises Directory_Error if Dir has not be opened (Dir = Null_Dir).\n+\n+   function Is_Open (Dir : Dir_Type) return Boolean;\n+   --  Returns True if Dir is open, or False otherwise.\n+\n+   procedure Read\n+     (Dir  : in out Dir_Type;\n+      Str  : out String;\n+      Last : out Natural);\n+   --  Reads the next entry from the directory and sets Str to the name\n+   --  of that entry. Last is the index in Str such that Str (Last) is the\n+   --  last character written. Last is 0 when there are no more files in the\n+   --  directory. If Str is too small for the file name, the file name will\n+   --  be truncated before being copied to Str. The list of files returned\n+   --  includes directories in systems providing a hierarchical directory\n+   --  structure, including . (the current directory) and .. (the parent\n+   --  directory) in systems providing these entries. The directory is\n+   --  returned in target-OS form. Raises Directory_Error if Dir has not\n+   --  be opened (Dir = Null_Dir).\n+\n+   generic\n+      with procedure Action\n+        (Item  :        String;\n+         Index :        Positive;\n+         Quit  : in out Boolean);\n+   procedure Wildcard_Iterator (Path : Path_Name);\n+   --  Calls Action for each path matching Path. Path can include wildcards '*'\n+   --  and '?' and [...]. The rules are:\n+   --\n+   --     *       can be replaced by any sequence of characters\n+   --     ?       can be replaced by a single character\n+   --     [a-z]   match one character in the range 'a' through 'z'\n+   --     [abc]   match either character 'a', 'b' or 'c'\n+   --\n+   --  Item is the filename that has been matched. Index is set to one for the\n+   --  first call and is incremented by one at each call. The iterator's\n+   --  termination can be controlled by setting Quit to True. It is by default\n+   --  set to False.\n+   --\n+   --  For example, if we have the following directory structure:\n+   --     /boo/\n+   --        foo.ads\n+   --     /sed/\n+   --        foo.ads\n+   --        file/\n+   --          foo.ads\n+   --     /sid/\n+   --        foo.ads\n+   --        file/\n+   --          foo.ads\n+   --     /life/\n+   --\n+   --  A call with expression \"/s*/file/*\" will call Action for the following\n+   --  items:\n+   --     /sed/file/foo.ads\n+   --     /sid/file/foo.ads\n+\n+   generic\n+      with procedure Action\n+        (Item  :        String;\n+         Index :        Positive;\n+         Quit  : in out Boolean);\n+   procedure Find\n+     (Root_Directory : Dir_Name_Str;\n+      File_Pattern   : String);\n+   --  Recursively searches the directory structure rooted at Root_Directory.\n+   --  This provides functionality similar to the UNIX 'find' command.\n+   --  Action will be called for every item matching the regular expression\n+   --  File_Pattern (see GNAT.Regexp). Item is the full pathname to the file\n+   --  starting with Root_Directory that has been matched. Index is set to one\n+   --  for the first call and is incremented by one at each call. The iterator\n+   --  will pass in the value False on each call to Action. The iterator will\n+   --  terminate after passing the last matched path to Action or after\n+   --  returning from a call to Action which sets Quit to True.\n+   --  Raises GNAT.Regexp.Error_In_Regexp if File_Pattern is ill formed.\n+\n+   function Read_Is_Thread_Safe return Boolean;\n+   --  Indicates if procedure Read is thread safe. On systems where the\n+   --  target system supports this functionality, Read is thread safe,\n+   --  and this function returns True (e.g. this will be the case on any\n+   --  UNIX or UNIX-like system providing a correct implementation of the\n+   --  function readdir_r). If the system cannot provide a thread safe\n+   --  implementation of Read, then this function returns False.\n+\n+private\n+\n+   type Dir_Type_Value;\n+   type Dir_Type is access Dir_Type_Value;\n+\n+   Null_Dir : constant Dir_Type := null;\n+\n+   pragma Import (C, Dir_Separator, \"__gnat_dir_separator\");\n+\n+end GNAT.Directory_Operations;"}, {"sha": "02c1bc19636bef61be8f613fdba527cfa8fcd55c", "filename": "gcc/ada/g-dyntab.adb", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,246 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   G N A T . D Y N A M I C _ T A B L E S                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--           Copyright (C) 2000-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System; use System;\n+\n+package body GNAT.Dynamic_Tables is\n+\n+   Min : constant Integer := Integer (Table_Low_Bound);\n+   --  Subscript of the minimum entry in the currently allocated table\n+\n+   type size_t is new Integer;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Reallocate (T : in out Instance);\n+   --  Reallocate the existing table according to the current value stored\n+   --  in Max. Works correctly to do an initial allocation if the table\n+   --  is currently null.\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate\n+     (T   : in out Instance;\n+      Num : Integer := 1)\n+   is\n+   begin\n+      T.P.Last_Val := T.P.Last_Val + Num;\n+\n+      if T.P.Last_Val > T.P.Max then\n+         Reallocate (T);\n+      end if;\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append (T : in out Instance; New_Val : Table_Component_Type) is\n+   begin\n+      Increment_Last (T);\n+      T.Table (Table_Index_Type (T.P.Last_Val)) := New_Val;\n+   end Append;\n+\n+   --------------------\n+   -- Decrement_Last --\n+   --------------------\n+\n+   procedure Decrement_Last (T : in out Instance) is\n+   begin\n+      T.P.Last_Val := T.P.Last_Val - 1;\n+   end Decrement_Last;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (T : in out Instance) is\n+      procedure free (T : Table_Ptr);\n+      pragma Import (C, free);\n+\n+   begin\n+      free (T.Table);\n+      T.Table := null;\n+      T.P.Length := 0;\n+   end Free;\n+\n+   --------------------\n+   -- Increment_Last --\n+   --------------------\n+\n+   procedure Increment_Last (T : in out Instance) is\n+   begin\n+      T.P.Last_Val := T.P.Last_Val + 1;\n+\n+      if T.P.Last_Val > T.P.Max then\n+         Reallocate (T);\n+      end if;\n+   end Increment_Last;\n+\n+   ----------\n+   -- Init --\n+   ----------\n+\n+   procedure Init (T : in out Instance) is\n+      Old_Length : constant Integer := T.P.Length;\n+\n+   begin\n+      T.P.Last_Val := Min - 1;\n+      T.P.Max      := Min + Table_Initial - 1;\n+      T.P.Length   := T.P.Max - Min + 1;\n+\n+      --  If table is same size as before (happens when table is never\n+      --  expanded which is a common case), then simply reuse it. Note\n+      --  that this also means that an explicit Init call right after\n+      --  the implicit one in the package body is harmless.\n+\n+      if Old_Length = T.P.Length then\n+         return;\n+\n+      --  Otherwise we can use Reallocate to get a table of the right size.\n+      --  Note that Reallocate works fine to allocate a table of the right\n+      --  initial size when it is first allocated.\n+\n+      else\n+         Reallocate (T);\n+      end if;\n+   end Init;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (T : in Instance) return Table_Index_Type is\n+   begin\n+      return Table_Index_Type (T.P.Last_Val);\n+   end Last;\n+\n+   ----------------\n+   -- Reallocate --\n+   ----------------\n+\n+   procedure Reallocate (T : in out Instance) is\n+\n+      function realloc\n+        (memblock : Table_Ptr;\n+         size     : size_t)\n+         return     Table_Ptr;\n+      pragma Import (C, realloc);\n+\n+      function malloc\n+        (size     : size_t)\n+         return     Table_Ptr;\n+      pragma Import (C, malloc);\n+\n+      New_Size : size_t;\n+\n+   begin\n+      if T.P.Max < T.P.Last_Val then\n+         while T.P.Max < T.P.Last_Val loop\n+            T.P.Length := T.P.Length * (100 + Table_Increment) / 100;\n+            T.P.Max := Min + T.P.Length - 1;\n+         end loop;\n+      end if;\n+\n+      New_Size :=\n+        size_t ((T.P.Max - Min + 1) *\n+                (Table_Type'Component_Size / Storage_Unit));\n+\n+      if T.Table = null then\n+         T.Table := malloc (New_Size);\n+\n+      elsif New_Size > 0 then\n+         T.Table :=\n+           realloc\n+             (memblock => T.Table,\n+              size     => New_Size);\n+      end if;\n+\n+      if T.P.Length /= 0 and then T.Table = null then\n+         raise Storage_Error;\n+      end if;\n+\n+   end Reallocate;\n+\n+   -------------\n+   -- Release --\n+   -------------\n+\n+   procedure Release (T : in out Instance) is\n+   begin\n+      T.P.Length := T.P.Last_Val - Integer (Table_Low_Bound) + 1;\n+      T.P.Max    := T.P.Last_Val;\n+      Reallocate (T);\n+   end Release;\n+\n+   --------------\n+   -- Set_Item --\n+   --------------\n+\n+   procedure Set_Item\n+     (T     : in out Instance;\n+      Index : Table_Index_Type;\n+      Item  : Table_Component_Type)\n+   is\n+   begin\n+      if Integer (Index) > T.P.Max then\n+         Set_Last (T, Index);\n+      end if;\n+\n+      T.Table (Index) := Item;\n+   end Set_Item;\n+\n+   --------------\n+   -- Set_Last --\n+   --------------\n+\n+   procedure Set_Last (T : in out Instance; New_Val : Table_Index_Type) is\n+   begin\n+      if Integer (New_Val) < T.P.Last_Val then\n+         T.P.Last_Val := Integer (New_Val);\n+\n+      else\n+         T.P.Last_Val := Integer (New_Val);\n+\n+         if T.P.Last_Val > T.P.Max then\n+            Reallocate (T);\n+         end if;\n+      end if;\n+   end Set_Last;\n+\n+end GNAT.Dynamic_Tables;"}, {"sha": "65a25e758840a17736b57f40583f51e1af3d6e58", "filename": "gcc/ada/g-dyntab.ads", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dyntab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-dyntab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,195 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   G N A T . D Y N A M I C _ T A B L E S                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.11 $\n+--                                                                          --\n+--            Copyright (C) 2000-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Resizable one dimensional array support\n+\n+--  This package provides an implementation of dynamically resizable one\n+--  dimensional arrays. The idea is to mimic the normal Ada semantics for\n+--  arrays as closely as possible with the one additional capability of\n+--  dynamically modifying the value of the Last attribute.\n+\n+--  This package provides a facility similar to that of GNAT.Table, except\n+--  that this package declares a type that can be used to define dynamic\n+--  instances of the table, while an instantiation of GNAT.Table creates a\n+--  single instance of the table type.\n+\n+--  Note that this interface should remain synchronized with those in\n+--  GNAT.Table and the GNAT compiler source unit Table to keep as much\n+--  coherency as possible between these three related units.\n+\n+generic\n+   type Table_Component_Type is private;\n+   type Table_Index_Type     is range <>;\n+\n+   Table_Low_Bound : Table_Index_Type;\n+   Table_Initial   : Positive;\n+   Table_Increment : Natural;\n+\n+package GNAT.Dynamic_Tables is\n+\n+   --  Table_Component_Type and Table_Index_Type specify the type of the\n+   --  array, Table_Low_Bound is the lower bound. Index_type must be an\n+   --  integer type. The effect is roughly to declare:\n+\n+   --    Table : array (Table_Low_Bound .. <>) of Table_Component_Type;\n+\n+   --  Table_Component_Type may be any Ada type, except that controlled\n+   --  types are not supported. Note however that default initialization\n+   --  will NOT occur for array components.\n+\n+   --  The Table_Initial values controls the allocation of the table when\n+   --  it is first allocated, either by default, or by an explicit Init\n+   --  call.\n+\n+   --  The Table_Increment value controls the amount of increase, if the\n+   --  table has to be increased in size. The value given is a percentage\n+   --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n+\n+   --  The Last and Set_Last subprograms provide control over the current\n+   --  logical allocation. They are quite efficient, so they can be used\n+   --  freely (expensive reallocation occurs only at major granularity\n+   --  chunks controlled by the allocation parameters).\n+\n+   --  Note: we do not make the table components aliased, since this would\n+   --  restrict the use of table for discriminated types. If it is necessary\n+   --  to take the access of a table element, use Unrestricted_Access.\n+\n+   type Table_Type is\n+     array (Table_Index_Type range <>) of Table_Component_Type;\n+\n+   subtype Big_Table_Type is\n+     Table_Type (Table_Low_Bound .. Table_Index_Type'Last);\n+   --  We work with pointers to a bogus array type that is constrained\n+   --  with the maximum possible range bound. This means that the pointer\n+   --  is a thin pointer, which is more efficient. Since subscript checks\n+   --  in any case must be on the logical, rather than physical bounds,\n+   --  safety is not compromised by this approach.\n+\n+   type Table_Ptr is access all Big_Table_Type;\n+   --  The table is actually represented as a pointer to allow\n+   --  reallocation.\n+\n+   type Table_Private is private;\n+   --  table private data that is not exported in Instance.\n+\n+   type Instance is record\n+      Table : aliased Table_Ptr := null;\n+   --  The table itself. The lower bound is the value of Low_Bound.\n+   --  Logically the upper bound is the current value of Last (although\n+   --  the actual size of the allocated table may be larger than this).\n+   --  The program may only access and modify Table entries in the\n+   --  range First .. Last.\n+\n+      P : Table_Private;\n+   end record;\n+\n+   procedure Init (T : in out Instance);\n+   --  This procedure allocates a new table of size Initial (freeing any\n+   --  previously allocated larger table). Init must be called before using\n+   --  the table. Init is convenient in reestablishing a table for new use.\n+\n+   function Last (T : in Instance) return Table_Index_Type;\n+   pragma Inline (Last);\n+   --  Returns the current value of the last used entry in the table,\n+   --  which can then be used as a subscript for Table. Note that the\n+   --  only way to modify Last is to call the Set_Last procedure. Last\n+   --  must always be used to determine the logically last entry.\n+\n+   procedure Release (T : in out Instance);\n+   --  Storage is allocated in chunks according to the values given in the\n+   --  Initial and Increment parameters. A call to Release releases all\n+   --  storage that is allocated, but is not logically part of the current\n+   --  array value. Current array values are not affected by this call.\n+\n+   procedure Free (T : in out Instance);\n+   --  Free all allocated memory for the table. A call to init is required\n+   --  before any use of this table after calling Free.\n+\n+   First : constant Table_Index_Type := Table_Low_Bound;\n+   --  Export First as synonym for Low_Bound (parallel with use of Last)\n+\n+   procedure Set_Last (T : in out Instance; New_Val : Table_Index_Type);\n+   pragma Inline (Set_Last);\n+   --  This procedure sets Last to the indicated value. If necessary the\n+   --  table is reallocated to accomodate the new value (i.e. on return\n+   --  the allocated table has an upper bound of at least Last). If\n+   --  Set_Last reduces the size of the table, then logically entries are\n+   --  removed from the table. If Set_Last increases the size of the\n+   --  table, then new entries are logically added to the table.\n+\n+   procedure Increment_Last (T : in out Instance);\n+   pragma Inline (Increment_Last);\n+   --  Adds 1 to Last (same as Set_Last (Last + 1).\n+\n+   procedure Decrement_Last (T : in out Instance);\n+   pragma Inline (Decrement_Last);\n+   --  Subtracts 1 from Last (same as Set_Last (Last - 1).\n+\n+   procedure Append (T : in out Instance; New_Val : Table_Component_Type);\n+   pragma Inline (Append);\n+   --  Equivalent to:\n+   --    Increment_Last (T);\n+   --    T.Table (T.Last) := New_Val;\n+   --  i.e. the table size is increased by one, and the given new item\n+   --  stored in the newly created table element.\n+\n+   procedure Set_Item\n+     (T     : in out Instance;\n+      Index : Table_Index_Type;\n+      Item  : Table_Component_Type);\n+   pragma Inline (Set_Item);\n+   --  Put Item in the table at position Index. The table is expanded if\n+   --  current table length is less than Index and in that case Last is set to\n+   --  Index. Item will replace any value already present in the table at this\n+   --  position.\n+\n+   procedure Allocate (T : in out Instance; Num : Integer := 1);\n+   pragma Inline (Allocate);\n+   --  Adds Num to Last.\n+\n+private\n+\n+   type Table_Private is record\n+      Max : Integer;\n+      --  Subscript of the maximum entry in the currently allocated table\n+\n+      Length : Integer := 0;\n+      --  Number of entries in currently allocated table. The value of zero\n+      --  ensures that we initially allocate the table.\n+\n+      Last_Val : Integer;\n+      --  Current value of Last.\n+   end record;\n+\n+end GNAT.Dynamic_Tables;"}, {"sha": "b4c107c6a1273d2edc86e2ab8e373d2253031e79", "filename": "gcc/ada/g-except.ads", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-except.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,79 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      G N A T . E X C E P T I O N S                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $\n+--                                                                          --\n+--           Copyright (C) 2000-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface for raising predefined exceptions\n+--  with an exception message. It can be used from Pure units. This unit\n+--  is for internal use only, it is not generally available to applications.\n+\n+package GNAT.Exceptions is\n+pragma Pure (Exceptions);\n+\n+   type Exception_Type is limited null record;\n+   --  Type used to specify which exception to raise.\n+\n+   --  Really Exception_Type is Exception_Id, but Exception_Id can't be\n+   --  used directly since it is declared in the non-pure unit Ada.Exceptions,\n+\n+   --  Exception_Id is in fact simply a pointer to the type Exception_Data\n+   --  declared in System.Standard_Library (which is also non-pure). So what\n+   --  we do is to define it here as a by reference type (any by reference\n+   --  type would do), and then Import the definitions from Standard_Library.\n+   --  Since this is a by reference type, these will be passed by reference,\n+   --  which has the same effect as passing a pointer.\n+\n+   --  This type is not private because keeping it by reference would require\n+   --  defining it in a way (e.g a tagged type) that would drag other run time\n+   --  files, which is unwanted in the case of e.g ravenscar where we want to\n+   --  minimize the number of run time files needed by default.\n+\n+   CE : constant Exception_Type;  -- Constraint_Error\n+   PE : constant Exception_Type;  -- Program_Error\n+   SE : constant Exception_Type;  -- Storage_Error\n+   TE : constant Exception_Type;  -- Tasking_Error\n+   --  One of these constants is used in the call to specify the exception\n+\n+   procedure Raise_Exception (E : Exception_Type; Message : String);\n+   pragma Import (Ada, Raise_Exception, \"__gnat_raise_exception\");\n+   pragma No_Return (Raise_Exception);\n+   --  Raise specified exception with specified message\n+\n+private\n+   pragma Import (C, CE, \"constraint_error\");\n+   pragma Import (C, PE, \"program_error\");\n+   pragma Import (C, SE, \"storage_error\");\n+   pragma Import (C, TE, \"tasking_error\");\n+   --  References to the exception structures in the standard library\n+\n+end GNAT.Exceptions;"}, {"sha": "fb34ce223c72e6341432110438ee4796c0e7f692", "filename": "gcc/ada/g-exctra.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-exctra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-exctra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-exctra.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  G N A T . E X C E P T I O N _ T R A C E S               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $\n+--                                                                          --\n+--            Copyright (C) 2000-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Standard_Library; use System.Standard_Library;\n+with System.Soft_Links;       use System.Soft_Links;\n+\n+package body GNAT.Exception_Traces is\n+\n+   --  Calling the decorator directly from where it is needed would require\n+   --  introducing nasty dependencies upon the spec of this package (typically\n+   --  in a-except.adb). We also have to deal with the fact that the traceback\n+   --  array within an exception occurrence and the one the decorator shall\n+   --  accept are of different types. These are two reasons for which a wrapper\n+   --  with a System.Address argument is indeed used to call the decorator\n+   --  provided by the user of this package. This wrapper is called via a\n+   --  soft-link, which either is null when no decorator is in place or \"points\n+   --  to\" the following function otherwise.\n+\n+   function Decorator_Wrapper\n+     (Traceback : System.Address;\n+      Len       : Natural)\n+      return      String;\n+   --  The wrapper to be called when a decorator is in place for exception\n+   --  backtraces.\n+   --\n+   --  Traceback is the address of the call chain array as stored in the\n+   --  exception occurrence and Len is the number of significant addresses\n+   --  contained in this array.\n+\n+   Current_Decorator : Traceback_Decorator := null;\n+   --  The decorator to be called by the wrapper when it is not null, as set\n+   --  by Set_Trace_Decorator. When this access is null, the wrapper is null\n+   --  also and shall then not be called.\n+\n+   -----------------------\n+   -- Decorator_Wrapper --\n+   -----------------------\n+\n+   function Decorator_Wrapper\n+     (Traceback : System.Address;\n+      Len       : Natural)\n+      return      String\n+   is\n+      Decorator_Traceback : Tracebacks_Array (1 .. Len);\n+      for Decorator_Traceback'Address use Traceback;\n+\n+      --  Handle the \"transition\" from the array stored in the exception\n+      --  occurrence to the array expected by the decorator.\n+\n+      pragma Import (Ada, Decorator_Traceback);\n+\n+   begin\n+      return Current_Decorator.all (Decorator_Traceback);\n+   end Decorator_Wrapper;\n+\n+   -------------------------\n+   -- Set_Trace_Decorator --\n+   -------------------------\n+\n+   procedure Set_Trace_Decorator (Decorator : Traceback_Decorator) is\n+   begin\n+      Current_Decorator := Decorator;\n+\n+      if Current_Decorator /= null then\n+         Traceback_Decorator_Wrapper := Decorator_Wrapper'Access;\n+      else\n+         Traceback_Decorator_Wrapper := null;\n+      end if;\n+   end Set_Trace_Decorator;\n+\n+   --  Trace_On/Trace_Off control the kind of automatic output to occur\n+   --  by way of the global Exception_Trace variable.\n+\n+   ---------------\n+   -- Trace_Off --\n+   ---------------\n+\n+   procedure Trace_Off is\n+   begin\n+      Exception_Trace := RM_Convention;\n+   end Trace_Off;\n+\n+   --------------\n+   -- Trace_On --\n+   --------------\n+\n+   procedure Trace_On (Kind : in Trace_Kind) is\n+   begin\n+      case Kind is\n+         when Every_Raise =>\n+            Exception_Trace := Every_Raise;\n+         when Unhandled_Raise =>\n+            Exception_Trace := Unhandled_Raise;\n+      end case;\n+   end Trace_On;\n+\n+end GNAT.Exception_Traces;"}, {"sha": "854ff9d8a6044dfd36cc032d63d7dc8e2af87909", "filename": "gcc/ada/g-exctra.ads", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-exctra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-exctra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-exctra.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,94 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  G N A T . E X C E P T I O N _ T R A C E S               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--              Copyright (C) 2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface allowing to control *automatic* output\n+--  to standard error upon exception occurrences (as opposed to explicit\n+--  generation of traceback information using GNAT.Traceback).\n+--\n+--  This output includes the basic information associated with the exception\n+--  (name, message) as well as a backtrace of the call chain at the point\n+--  where the exception occured. This backtrace is only output if the call\n+--  chain information is available, depending if the binder switch dedicated\n+--  to that purpose has been used or not.\n+--\n+--  The default backtrace is in the form of absolute code locations which may\n+--  be converted to corresponding source locations using the addr2line utility\n+--  or from within GDB. Please refer to GNAT.Traceback for information about\n+--  what is necessary to be able to exploit thisg possibility.\n+--\n+--  The backtrace output can also be customized by way of a \"decorator\" which\n+--  may return any string output in association with a provided call chain.\n+\n+with GNAT.Traceback; use GNAT.Traceback;\n+\n+package GNAT.Exception_Traces is\n+\n+   --  The following defines the exact situations in which raises will\n+   --  cause automatic output of trace information.\n+\n+   type Trace_Kind is\n+     (Every_Raise,\n+      --  Denotes the initial raise event for any exception occurrence, either\n+      --  explicit or due to a specific language rule, within the context of a\n+      --  task or not.\n+\n+      Unhandled_Raise\n+      --  Denotes the raise events corresponding to exceptions for which there\n+      --  is no user defined handler, in particular, when a task dies due to an\n+      --  unhandled exception.\n+     );\n+\n+   --  The following procedures can be used to activate and deactivate\n+   --  traces identified by the above trace kind values.\n+\n+   procedure Trace_On (Kind : in Trace_Kind);\n+   --  Activate the traces denoted by Kind.\n+\n+   procedure Trace_Off;\n+   --  Stop the tracing requested by the last call to Trace_On.\n+   --  Has no effect if no such call has ever occurred.\n+\n+   --  The following provide the backtrace decorating facilities\n+\n+   type Traceback_Decorator is access\n+     function (Traceback : Tracebacks_Array) return String;\n+   --  A backtrace decorator is a function which returns the string to be\n+   --  output for a call chain provided by way of a tracebacks array.\n+\n+   procedure Set_Trace_Decorator (Decorator : Traceback_Decorator);\n+   --  Set the decorator to be used for future automatic outputs. Restore\n+   --  the default behavior (output of raw addresses) if the provided\n+   --  access value is null.\n+\n+end GNAT.Exception_Traces;"}, {"sha": "651b62014832a0156a525368f79dc1d17b3404bb", "filename": "gcc/ada/g-expect.adb", "status": "added", "additions": 1177, "deletions": 0, "changes": 1177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,1177 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . E X P E C T                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--           Copyright (C) 2000-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.IO;\n+with GNAT.OS_Lib;   use GNAT.OS_Lib;\n+with GNAT.Regpat;   use GNAT.Regpat;\n+with System;        use System;\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n+with Ada.Calendar;  use Ada.Calendar;\n+\n+package body GNAT.Expect is\n+\n+   function To_Pid is new\n+     Unchecked_Conversion (OS_Lib.Process_Id, Process_Id);\n+\n+   type Array_Of_Pd is array (Positive range <>) of Process_Descriptor_Access;\n+\n+   procedure Expect_Internal\n+     (Descriptors : in out Array_Of_Pd;\n+      Result      : out Expect_Match;\n+      Timeout     : Integer;\n+      Full_Buffer : Boolean);\n+   --  Internal function used to read from the process Descriptor.\n+   --\n+   --  Three outputs are possible:\n+   --     Result=Expect_Timeout, if no output was available before the timeout\n+   --        expired.\n+   --     Result=Expect_Full_Buffer, if Full_Buffer is True and some characters\n+   --        had to be discarded from the internal buffer of Descriptor.\n+   --     Result=<integer>, indicates how many characters were added to the\n+   --        internal buffer. These characters are from indexes\n+   --        Descriptor.Buffer_Index - Result + 1 .. Descriptor.Buffer_Index\n+   --  Process_Died is raised if the process is no longer valid.\n+\n+   procedure Reinitialize_Buffer\n+     (Descriptor : in out Process_Descriptor'Class);\n+   --  Reinitialize the internal buffer.\n+   --  The buffer is deleted up to the end of the last match.\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Pattern_Matcher, Pattern_Matcher_Access);\n+\n+   procedure Call_Filters\n+     (Pid       : Process_Descriptor'Class;\n+      Str       : String;\n+      Filter_On : Filter_Type);\n+   --  Call all the filters that have the appropriate type.\n+   --  This function does nothing if the filters are locked\n+\n+   ------------------------------\n+   -- Target dependent section --\n+   ------------------------------\n+\n+   function Dup (Fd : File_Descriptor) return File_Descriptor;\n+   pragma Import (C, Dup);\n+\n+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n+   pragma Import (C, Dup2);\n+\n+   procedure Kill (Pid : Process_Id; Sig_Num : Integer);\n+   pragma Import (C, Kill);\n+\n+   function Create_Pipe (Pipe : access Pipe_Type) return Integer;\n+   pragma Import (C, Create_Pipe, \"__gnat_pipe\");\n+\n+   function Read\n+     (Fd : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer;\n+   pragma Import (C, Read, \"read\");\n+   --  Read N bytes to address A from file referenced by FD. Returned value\n+   --  is count of bytes actually read, which can be less than N at EOF.\n+\n+   procedure Close (Fd : File_Descriptor);\n+   pragma Import (C, Close);\n+   --  Close a file given its file descriptor.\n+\n+   function Write\n+     (Fd : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer;\n+   pragma Import (C, Write, \"write\");\n+   --  Read N bytes to address A from file referenced by FD. Returned value\n+   --  is count of bytes actually read, which can be less than N at EOF.\n+\n+   function Poll\n+     (Fds     : System.Address;\n+      Num_Fds : Integer;\n+      Timeout : Integer;\n+      Is_Set  : System.Address) return Integer;\n+   pragma Import (C, Poll, \"__gnat_expect_poll\");\n+   --  Check whether there is any data waiting on the file descriptor\n+   --  Out_fd, and wait if there is none, at most Timeout milliseconds\n+   --  Returns -1 in case of error, 0 if the timeout expired before\n+   --  data became available.\n+   --\n+   --  Out_Is_Set is set to 1 if data was available, 0 otherwise.\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (S : String) return GNAT.OS_Lib.String_Access is\n+   begin\n+      return new String'(S);\n+   end \"+\";\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\"\n+     (P    : GNAT.Regpat.Pattern_Matcher)\n+      return Pattern_Matcher_Access\n+   is\n+   begin\n+      return new GNAT.Regpat.Pattern_Matcher'(P);\n+   end \"+\";\n+\n+   ----------------\n+   -- Add_Filter --\n+   ----------------\n+\n+   procedure Add_Filter\n+     (Descriptor : in out Process_Descriptor;\n+      Filter     : Filter_Function;\n+      Filter_On  : Filter_Type := Output;\n+      User_Data  : System.Address := System.Null_Address;\n+      After      : Boolean := False)\n+   is\n+      Current : Filter_List := Descriptor.Filters;\n+\n+   begin\n+      if After then\n+         while Current /= null and then Current.Next /= null loop\n+            Current := Current.Next;\n+         end loop;\n+\n+         if Current = null then\n+            Descriptor.Filters :=\n+              new Filter_List_Elem'\n+              (Filter => Filter, Filter_On => Filter_On,\n+               User_Data => User_Data, Next => null);\n+         else\n+            Current.Next :=\n+              new Filter_List_Elem'\n+              (Filter => Filter, Filter_On => Filter_On,\n+               User_Data => User_Data, Next => null);\n+         end if;\n+\n+      else\n+         Descriptor.Filters :=\n+           new Filter_List_Elem'\n+             (Filter => Filter, Filter_On => Filter_On,\n+              User_Data => User_Data, Next => Descriptor.Filters);\n+      end if;\n+   end Add_Filter;\n+\n+   ------------------\n+   -- Call_Filters --\n+   ------------------\n+\n+   procedure Call_Filters\n+     (Pid       : Process_Descriptor'Class;\n+      Str       : String;\n+      Filter_On : Filter_Type)\n+   is\n+      Current_Filter  : Filter_List;\n+\n+   begin\n+      if Pid.Filters_Lock = 0 then\n+         Current_Filter := Pid.Filters;\n+\n+         while Current_Filter /= null loop\n+            if Current_Filter.Filter_On = Filter_On then\n+               Current_Filter.Filter\n+                 (Pid, Str, Current_Filter.User_Data);\n+            end if;\n+\n+            Current_Filter := Current_Filter.Next;\n+         end loop;\n+      end if;\n+   end Call_Filters;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Descriptor : in out Process_Descriptor) is\n+      Success : Boolean;\n+      Pid     : OS_Lib.Process_Id;\n+\n+   begin\n+      Close (Descriptor.Input_Fd);\n+\n+      if Descriptor.Error_Fd /= Descriptor.Output_Fd then\n+         Close (Descriptor.Error_Fd);\n+      end if;\n+\n+      Close (Descriptor.Output_Fd);\n+\n+      --  ??? Should have timeouts for different signals, see ddd\n+      Kill (Descriptor.Pid, 9);\n+\n+      GNAT.OS_Lib.Free (Descriptor.Buffer);\n+      Descriptor.Buffer_Size := 0;\n+\n+      Wait_Process (Pid, Success);\n+      Descriptor.Pid := To_Pid (Pid);\n+   end Close;\n+\n+   ------------\n+   -- Expect --\n+   ------------\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : String;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+   begin\n+      if Regexp = \"\" then\n+         Expect (Descriptor, Result, Never_Match, Timeout, Full_Buffer);\n+      else\n+         Expect (Descriptor, Result, Compile (Regexp), Timeout, Full_Buffer);\n+      end if;\n+   end Expect;\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : String;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+   begin\n+      pragma Assert (Matched'First = 0);\n+      if Regexp = \"\" then\n+         Expect\n+           (Descriptor, Result, Never_Match, Matched, Timeout, Full_Buffer);\n+      else\n+         Expect\n+           (Descriptor, Result, Compile (Regexp), Matched, Timeout,\n+            Full_Buffer);\n+      end if;\n+   end Expect;\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : GNAT.Regpat.Pattern_Matcher;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      Matched : GNAT.Regpat.Match_Array (0 .. 0);\n+\n+   begin\n+      Expect (Descriptor, Result, Regexp, Matched, Timeout, Full_Buffer);\n+   end Expect;\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : GNAT.Regpat.Pattern_Matcher;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      N           : Expect_Match;\n+      Descriptors : Array_Of_Pd := (1 => Descriptor'Unrestricted_Access);\n+      Try_Until   : Time := Clock + Duration (Timeout) / 1000.0;\n+      Timeout_Tmp : Integer := Timeout;\n+\n+   begin\n+      pragma Assert (Matched'First = 0);\n+      Reinitialize_Buffer (Descriptor);\n+\n+      loop\n+         --  First, test if what is already in the buffer matches (This is\n+         --  required if this package is used in multi-task mode, since one of\n+         --  the tasks might have added something in the buffer, and we don't\n+         --  want other tasks to wait for new input to be available before\n+         --  checking the regexps).\n+\n+         Match\n+           (Regexp, Descriptor.Buffer (1 .. Descriptor.Buffer_Index), Matched);\n+\n+         if Descriptor.Buffer_Index >= 1 and then Matched (0).First /= 0 then\n+            Result := 1;\n+            Descriptor.Last_Match_Start := Matched (0).First;\n+            Descriptor.Last_Match_End := Matched (0).Last;\n+            return;\n+         end if;\n+\n+         --  Else try to read new input\n+\n+         Expect_Internal (Descriptors, N, Timeout_Tmp, Full_Buffer);\n+\n+         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n+            Result := N;\n+            return;\n+         end if;\n+\n+         --  Calculate the timeout for the next turn.\n+         --  Note that Timeout is, from the caller's perspective, the maximum\n+         --  time until a match, not the maximum time until some output is\n+         --  read, and thus can not be reused as is for Expect_Internal.\n+\n+         if Timeout /= -1 then\n+            Timeout_Tmp := Integer (Try_Until - Clock) * 1000;\n+\n+            if Timeout_Tmp < 0 then\n+               Result := Expect_Timeout;\n+               exit;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Even if we had the general timeout above, we have to test that the\n+      --  last test we read from the external process didn't match.\n+\n+      Match\n+        (Regexp, Descriptor.Buffer (1 .. Descriptor.Buffer_Index), Matched);\n+\n+      if Matched (0).First /= 0 then\n+         Result := 1;\n+         Descriptor.Last_Match_Start := Matched (0).First;\n+         Descriptor.Last_Match_End := Matched (0).Last;\n+         return;\n+      end if;\n+   end Expect;\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Regexp_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      Patterns : Compiled_Regexp_Array (Regexps'Range);\n+      Matched  : GNAT.Regpat.Match_Array (0 .. 0);\n+\n+   begin\n+      for J in Regexps'Range loop\n+         Patterns (J) := new Pattern_Matcher'(Compile (Regexps (J).all));\n+      end loop;\n+\n+      Expect (Descriptor, Result, Patterns, Matched, Timeout, Full_Buffer);\n+\n+      for J in Regexps'Range loop\n+         Free (Patterns (J));\n+      end loop;\n+   end Expect;\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Compiled_Regexp_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      Matched : GNAT.Regpat.Match_Array (0 .. 0);\n+\n+   begin\n+      Expect (Descriptor, Result, Regexps, Matched, Timeout, Full_Buffer);\n+   end Expect;\n+\n+   procedure Expect\n+     (Result      : out Expect_Match;\n+      Regexps     : Multiprocess_Regexp_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      Matched : GNAT.Regpat.Match_Array (0 .. 0);\n+\n+   begin\n+      Expect (Result, Regexps, Matched, Timeout, Full_Buffer);\n+   end Expect;\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Regexp_Array;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      Patterns : Compiled_Regexp_Array (Regexps'Range);\n+\n+   begin\n+      pragma Assert (Matched'First = 0);\n+\n+      for J in Regexps'Range loop\n+         Patterns (J) := new Pattern_Matcher'(Compile (Regexps (J).all));\n+      end loop;\n+\n+      Expect (Descriptor, Result, Patterns, Matched, Timeout, Full_Buffer);\n+\n+      for J in Regexps'Range loop\n+         Free (Patterns (J));\n+      end loop;\n+   end Expect;\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Compiled_Regexp_Array;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      N           : Expect_Match;\n+      Descriptors : Array_Of_Pd := (1 => Descriptor'Unrestricted_Access);\n+\n+   begin\n+      pragma Assert (Matched'First = 0);\n+\n+      Reinitialize_Buffer (Descriptor);\n+\n+      loop\n+         --  First, test if what is already in the buffer matches (This is\n+         --  required if this package is used in multi-task mode, since one of\n+         --  the tasks might have added something in the buffer, and we don't\n+         --  want other tasks to wait for new input to be available before\n+         --  checking the regexps).\n+\n+         if Descriptor.Buffer /= null then\n+            for J in Regexps'Range loop\n+               Match\n+                 (Regexps (J).all,\n+                  Descriptor.Buffer (1 .. Descriptor.Buffer_Index),\n+                  Matched);\n+\n+               if Matched (0) /= No_Match then\n+                  Result := Expect_Match (J);\n+                  Descriptor.Last_Match_Start := Matched (0).First;\n+                  Descriptor.Last_Match_End := Matched (0).Last;\n+                  return;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n+\n+         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n+            Result := N;\n+            return;\n+         end if;\n+      end loop;\n+   end Expect;\n+\n+   procedure Expect\n+     (Result      : out Expect_Match;\n+      Regexps     : Multiprocess_Regexp_Array;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False)\n+   is\n+      N           : Expect_Match;\n+      Descriptors : Array_Of_Pd (Regexps'Range);\n+\n+   begin\n+      pragma Assert (Matched'First = 0);\n+\n+      for J in Descriptors'Range loop\n+         Descriptors (J) := Regexps (J).Descriptor;\n+         Reinitialize_Buffer (Regexps (J).Descriptor.all);\n+      end loop;\n+\n+      loop\n+         --  First, test if what is already in the buffer matches (This is\n+         --  required if this package is used in multi-task mode, since one of\n+         --  the tasks might have added something in the buffer, and we don't\n+         --  want other tasks to wait for new input to be available before\n+         --  checking the regexps).\n+\n+         for J in Regexps'Range loop\n+            Match (Regexps (J).Regexp.all,\n+                   Regexps (J).Descriptor.Buffer\n+                     (1 .. Regexps (J).Descriptor.Buffer_Index),\n+                   Matched);\n+\n+            if Matched (0) /= No_Match then\n+               Result := Expect_Match (J);\n+               Regexps (J).Descriptor.Last_Match_Start := Matched (0).First;\n+               Regexps (J).Descriptor.Last_Match_End := Matched (0).Last;\n+               return;\n+            end if;\n+         end loop;\n+\n+         Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n+\n+         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n+            Result := N;\n+            return;\n+         end if;\n+      end loop;\n+   end Expect;\n+\n+   ---------------------\n+   -- Expect_Internal --\n+   ---------------------\n+\n+   procedure Expect_Internal\n+     (Descriptors : in out Array_Of_Pd;\n+      Result      : out Expect_Match;\n+      Timeout     : Integer;\n+      Full_Buffer : Boolean)\n+   is\n+      Num_Descriptors : Integer;\n+      Buffer_Size     : Integer := 0;\n+\n+      N               : Integer;\n+\n+      type File_Descriptor_Array is\n+        array (Descriptors'Range) of File_Descriptor;\n+      Fds : aliased File_Descriptor_Array;\n+\n+      type Integer_Array is array (Descriptors'Range) of Integer;\n+      Is_Set : aliased Integer_Array;\n+\n+   begin\n+      for J in Descriptors'Range loop\n+         Fds (J) := Descriptors (J).Output_Fd;\n+\n+         if Descriptors (J).Buffer_Size = 0 then\n+            Buffer_Size := Integer'Max (Buffer_Size, 4096);\n+         else\n+            Buffer_Size :=\n+              Integer'Max (Buffer_Size, Descriptors (J).Buffer_Size);\n+         end if;\n+      end loop;\n+\n+      declare\n+         Buffer : aliased String (1 .. Buffer_Size);\n+         --  Buffer used for input. This is allocated only once, not for\n+         --  every iteration of the loop\n+\n+      begin\n+         --  Loop until we match or we have a timeout\n+\n+         loop\n+            Num_Descriptors :=\n+              Poll (Fds'Address, Fds'Length, Timeout, Is_Set'Address);\n+\n+            case Num_Descriptors is\n+\n+               --  Error?\n+\n+               when -1 =>\n+                  raise Process_Died;\n+\n+               --  Timeout?\n+\n+               when 0  =>\n+                  Result := Expect_Timeout;\n+                  return;\n+\n+               --  Some input\n+\n+               when others =>\n+                  for J in Descriptors'Range loop\n+                     if Is_Set (J) = 1 then\n+                        Buffer_Size := Descriptors (J).Buffer_Size;\n+\n+                        if Buffer_Size = 0 then\n+                           Buffer_Size := 4096;\n+                        end if;\n+\n+                        N := Read (Descriptors (J).Output_Fd, Buffer'Address,\n+                                   Buffer_Size);\n+\n+                        --  Error or End of file\n+\n+                        if N <= 0 then\n+                           --  ??? Note that ddd tries again up to three times\n+                           --  in that case. See LiterateA.C:174\n+                           raise Process_Died;\n+\n+                        else\n+                           --  If there is no limit to the buffer size\n+\n+                           if Descriptors (J).Buffer_Size = 0 then\n+\n+                              declare\n+                                 Tmp : String_Access := Descriptors (J).Buffer;\n+\n+                              begin\n+                                 if Tmp /= null then\n+                                    Descriptors (J).Buffer :=\n+                                      new String (1 .. Tmp'Length + N);\n+                                    Descriptors (J).Buffer (1 .. Tmp'Length) :=\n+                                      Tmp.all;\n+                                    Descriptors (J).Buffer\n+                                      (Tmp'Length + 1 .. Tmp'Length + N) :=\n+                                      Buffer (1 .. N);\n+                                    Free (Tmp);\n+                                    Descriptors (J).Buffer_Index :=\n+                                      Descriptors (J).Buffer'Last;\n+\n+                                 else\n+                                    Descriptors (J).Buffer :=\n+                                      new String (1 .. N);\n+                                    Descriptors (J).Buffer.all :=\n+                                      Buffer (1 .. N);\n+                                    Descriptors (J).Buffer_Index := N;\n+                                 end if;\n+                              end;\n+\n+                           else\n+                              --  Add what we read to the buffer\n+\n+                              if Descriptors (J).Buffer_Index + N - 1 >\n+                                Descriptors (J).Buffer_Size\n+                              then\n+                                 --  If the user wants to know when we have\n+                                 --  read more than the buffer can contain.\n+\n+                                 if Full_Buffer then\n+                                    Result := Expect_Full_Buffer;\n+                                    return;\n+                                 end if;\n+\n+                                 --  Keep as much as possible from the buffer,\n+                                 --  and forget old characters.\n+\n+                                 Descriptors (J).Buffer\n+                                   (1 .. Descriptors (J).Buffer_Size - N) :=\n+                                  Descriptors (J).Buffer\n+                                   (N - Descriptors (J).Buffer_Size +\n+                                    Descriptors (J).Buffer_Index + 1 ..\n+                                    Descriptors (J).Buffer_Index);\n+                                 Descriptors (J).Buffer_Index :=\n+                                   Descriptors (J).Buffer_Size - N;\n+                              end if;\n+\n+                              --  Keep what we read in the buffer.\n+\n+                              Descriptors (J).Buffer\n+                                (Descriptors (J).Buffer_Index + 1 ..\n+                                 Descriptors (J).Buffer_Index + N) :=\n+                                Buffer (1 .. N);\n+                              Descriptors (J).Buffer_Index :=\n+                                Descriptors (J).Buffer_Index + N;\n+                           end if;\n+\n+                           --  Call each of the output filter with what we\n+                           --  read.\n+\n+                           Call_Filters\n+                             (Descriptors (J).all, Buffer (1 .. N), Output);\n+\n+                           Result := Expect_Match (N);\n+                           return;\n+                        end if;\n+                     end if;\n+                  end loop;\n+            end case;\n+         end loop;\n+      end;\n+   end Expect_Internal;\n+\n+   ----------------\n+   -- Expect_Out --\n+   ----------------\n+\n+   function Expect_Out (Descriptor : Process_Descriptor) return String is\n+   begin\n+      return Descriptor.Buffer (1 .. Descriptor.Last_Match_End);\n+   end Expect_Out;\n+\n+   ----------------------\n+   -- Expect_Out_Match --\n+   ----------------------\n+\n+   function Expect_Out_Match (Descriptor : Process_Descriptor) return String is\n+   begin\n+      return Descriptor.Buffer\n+        (Descriptor.Last_Match_Start .. Descriptor.Last_Match_End);\n+   end Expect_Out_Match;\n+\n+   -----------\n+   -- Flush --\n+   -----------\n+\n+   procedure Flush\n+     (Descriptor : in out Process_Descriptor;\n+      Timeout    : Integer := 0)\n+   is\n+      Num_Descriptors : Integer;\n+      N               : Integer;\n+      Is_Set          : aliased Integer;\n+      Buffer_Size     : Integer := 8192;\n+      Buffer          : aliased String (1 .. Buffer_Size);\n+\n+   begin\n+      --  Empty the current buffer\n+\n+      Descriptor.Last_Match_End := Descriptor.Buffer_Index;\n+      Reinitialize_Buffer (Descriptor);\n+\n+      --  Read everything from the process to flush its output\n+\n+      loop\n+         Num_Descriptors :=\n+           Poll (Descriptor.Output_Fd'Address, 1, Timeout, Is_Set'Address);\n+\n+         case Num_Descriptors is\n+\n+            --  Error ?\n+\n+            when -1 =>\n+               raise Process_Died;\n+\n+            --  Timeout => End of flush\n+\n+            when 0  =>\n+               return;\n+\n+            --  Some input\n+\n+            when others =>\n+               if Is_Set = 1 then\n+                  N := Read (Descriptor.Output_Fd, Buffer'Address,\n+                             Buffer_Size);\n+\n+                  if N = -1 then\n+                     raise Process_Died;\n+                  elsif N = 0 then\n+                     return;\n+                  end if;\n+               end if;\n+         end case;\n+      end loop;\n+\n+   end Flush;\n+\n+   ------------------\n+   -- Get_Error_Fd --\n+   ------------------\n+\n+   function Get_Error_Fd\n+     (Descriptor : Process_Descriptor)\n+      return       GNAT.OS_Lib.File_Descriptor\n+   is\n+   begin\n+      return Descriptor.Error_Fd;\n+   end Get_Error_Fd;\n+\n+   ------------------\n+   -- Get_Input_Fd --\n+   ------------------\n+\n+   function Get_Input_Fd\n+     (Descriptor : Process_Descriptor)\n+      return       GNAT.OS_Lib.File_Descriptor\n+   is\n+   begin\n+      return Descriptor.Input_Fd;\n+   end Get_Input_Fd;\n+\n+   -------------------\n+   -- Get_Output_Fd --\n+   -------------------\n+\n+   function Get_Output_Fd\n+     (Descriptor : Process_Descriptor)\n+      return       GNAT.OS_Lib.File_Descriptor\n+   is\n+   begin\n+      return Descriptor.Output_Fd;\n+   end Get_Output_Fd;\n+\n+   -------------\n+   -- Get_Pid --\n+   -------------\n+\n+   function Get_Pid\n+     (Descriptor : Process_Descriptor)\n+      return       Process_Id\n+   is\n+   begin\n+      return Descriptor.Pid;\n+   end Get_Pid;\n+\n+   ---------------\n+   -- Interrupt --\n+   ---------------\n+\n+   procedure Interrupt (Descriptor : in out Process_Descriptor) is\n+      SIGINT : constant := 2;\n+\n+   begin\n+      Send_Signal (Descriptor, SIGINT);\n+   end Interrupt;\n+\n+   ------------------\n+   -- Lock_Filters --\n+   ------------------\n+\n+   procedure Lock_Filters (Descriptor : in out Process_Descriptor) is\n+   begin\n+      Descriptor.Filters_Lock := Descriptor.Filters_Lock + 1;\n+   end Lock_Filters;\n+\n+   ------------------------\n+   -- Non_Blocking_Spawn --\n+   ------------------------\n+\n+   procedure Non_Blocking_Spawn\n+     (Descriptor  : out Process_Descriptor'Class;\n+      Command     : String;\n+      Args        : GNAT.OS_Lib.Argument_List;\n+      Buffer_Size : Natural := 4096;\n+      Err_To_Out  : Boolean := False)\n+   is\n+      function Fork return Process_Id;\n+      pragma Import (C, Fork, \"__gnat_expect_fork\");\n+      --  Starts a new process if possible.\n+      --  See the Unix command fork for more information. On systems that\n+      --  don't support this capability (Windows...), this command does\n+      --  nothing, and Fork will return Null_Pid.\n+\n+      Pipe1, Pipe2, Pipe3 : aliased Pipe_Type;\n+\n+      Arg      : String_Access;\n+      Arg_List : aliased array (1 .. Args'Length + 2) of System.Address;\n+\n+      Command_With_Path : String_Access;\n+\n+   begin\n+      --  Create the rest of the pipes\n+\n+      Set_Up_Communications\n+        (Descriptor, Err_To_Out, Pipe1'Access, Pipe2'Access, Pipe3'Access);\n+\n+      --  Fork a new process\n+\n+      Descriptor.Pid := Fork;\n+\n+      --  Are we now in the child (or, for Windows, still in the common\n+      --  process).\n+\n+      if Descriptor.Pid = Null_Pid then\n+\n+         Command_With_Path := Locate_Exec_On_Path (Command);\n+\n+         --  Prepare an array of arguments to pass to C\n+         Arg   := new String (1 .. Command_With_Path'Length + 1);\n+         Arg (1 .. Command_With_Path'Length) := Command_With_Path.all;\n+         Arg (Arg'Last)        := ASCII.Nul;\n+         Arg_List (1)          := Arg.all'Address;\n+\n+         for J in Args'Range loop\n+            Arg                     := new String (1 .. Args (J)'Length + 1);\n+            Arg (1 .. Args (J)'Length)  := Args (J).all;\n+            Arg (Arg'Last)              := ASCII.Nul;\n+            Arg_List (J + 2 - Args'First) := Arg.all'Address;\n+         end loop;\n+\n+         Arg_List (Arg_List'Last) := System.Null_Address;\n+\n+         --  This does not return on Unix systems\n+\n+         Set_Up_Child_Communications\n+           (Descriptor, Pipe1, Pipe2, Pipe3, Command_With_Path.all,\n+            Arg_List'Address);\n+\n+         Free (Command_With_Path);\n+      end if;\n+\n+      --  Did we have an error when spawning the child ?\n+\n+      if Descriptor.Pid < Null_Pid then\n+         null;\n+      else\n+         --  We are now in the parent process\n+\n+         Set_Up_Parent_Communications (Descriptor, Pipe1, Pipe2, Pipe3);\n+      end if;\n+\n+      --  Create the buffer\n+\n+      Descriptor.Buffer_Size := Buffer_Size;\n+\n+      if Buffer_Size /= 0 then\n+         Descriptor.Buffer := new String (1 .. Positive (Buffer_Size));\n+      end if;\n+   end Non_Blocking_Spawn;\n+\n+   -------------------------\n+   -- Reinitialize_Buffer --\n+   -------------------------\n+\n+   procedure Reinitialize_Buffer\n+     (Descriptor : in out Process_Descriptor'Class)\n+   is\n+   begin\n+      if Descriptor.Buffer_Size = 0 then\n+         declare\n+            Tmp : String_Access := Descriptor.Buffer;\n+\n+         begin\n+            Descriptor.Buffer :=\n+              new String\n+                (1 .. Descriptor.Buffer_Index - Descriptor.Last_Match_End);\n+\n+            if Tmp /= null then\n+               Descriptor.Buffer.all := Tmp\n+                 (Descriptor.Last_Match_End + 1 .. Descriptor.Buffer_Index);\n+               Free (Tmp);\n+            end if;\n+         end;\n+\n+         Descriptor.Buffer_Index := Descriptor.Buffer'Last;\n+\n+      else\n+         Descriptor.Buffer\n+           (1 .. Descriptor.Buffer_Index - Descriptor.Last_Match_End) :=\n+             Descriptor.Buffer\n+               (Descriptor.Last_Match_End + 1 .. Descriptor.Buffer_Index);\n+\n+         if Descriptor.Buffer_Index > Descriptor.Last_Match_End then\n+            Descriptor.Buffer_Index :=\n+              Descriptor.Buffer_Index - Descriptor.Last_Match_End;\n+         else\n+            Descriptor.Buffer_Index := 0;\n+         end if;\n+      end if;\n+\n+      Descriptor.Last_Match_Start := 0;\n+      Descriptor.Last_Match_End := 0;\n+   end Reinitialize_Buffer;\n+\n+   -------------------\n+   -- Remove_Filter --\n+   -------------------\n+\n+   procedure Remove_Filter\n+     (Descriptor : in out Process_Descriptor;\n+      Filter     : Filter_Function)\n+   is\n+      Previous : Filter_List := null;\n+      Current  : Filter_List := Descriptor.Filters;\n+\n+   begin\n+      while Current /= null loop\n+         if Current.Filter = Filter then\n+            if Previous = null then\n+               Descriptor.Filters := Current.Next;\n+            else\n+               Previous.Next := Current.Next;\n+            end if;\n+         end if;\n+\n+         Previous := Current;\n+         Current := Current.Next;\n+      end loop;\n+   end Remove_Filter;\n+\n+   ----------\n+   -- Send --\n+   ----------\n+\n+   procedure Send\n+     (Descriptor : in out Process_Descriptor;\n+      Str        : String;\n+      Add_LF     : Boolean := True;\n+      Empty_Buffer : Boolean := False)\n+   is\n+      N           : Natural;\n+      Full_Str    : constant String := Str & ASCII.LF;\n+      Last        : Natural;\n+      Result      : Expect_Match;\n+      Descriptors : Array_Of_Pd := (1 => Descriptor'Unrestricted_Access);\n+\n+   begin\n+      if Empty_Buffer then\n+\n+         --  Force a read on the process if there is anything waiting.\n+\n+         Expect_Internal (Descriptors, Result,\n+                          Timeout => 0, Full_Buffer => False);\n+         Descriptor.Last_Match_End := Descriptor.Buffer_Index;\n+\n+         --  Empty the buffer\n+\n+         Reinitialize_Buffer (Descriptor);\n+      end if;\n+\n+      if Add_LF then\n+         Last := Full_Str'Last;\n+      else\n+         Last := Full_Str'Last - 1;\n+      end if;\n+\n+      Call_Filters (Descriptor, Full_Str (Full_Str'First .. Last), Input);\n+\n+      N := Write (Descriptor.Input_Fd,\n+                  Full_Str'Address,\n+                  Last - Full_Str'First + 1);\n+   end Send;\n+\n+   -----------------\n+   -- Send_Signal --\n+   -----------------\n+\n+   procedure Send_Signal\n+     (Descriptor : Process_Descriptor;\n+      Signal     : Integer)\n+   is\n+   begin\n+      Kill (Descriptor.Pid, Signal);\n+      --  ??? Need to check process status here.\n+   end Send_Signal;\n+\n+   ---------------------------------\n+   -- Set_Up_Child_Communications --\n+   ---------------------------------\n+\n+   procedure Set_Up_Child_Communications\n+     (Pid   : in out Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type;\n+      Cmd   : in String;\n+      Args  : in System.Address)\n+   is\n+      Input, Output, Error : File_Descriptor;\n+\n+   begin\n+      --  Since Windows does not have a separate fork/exec, we need to\n+      --  perform the following actions:\n+      --    - save stdin, stdout, stderr\n+      --    - replace them by our pipes\n+      --    - create the child with process handle inheritance\n+      --    - revert to the previous stdin, stdout and stderr.\n+\n+      Input  := Dup (GNAT.OS_Lib.Standin);\n+      Output := Dup (GNAT.OS_Lib.Standout);\n+      Error  := Dup (GNAT.OS_Lib.Standerr);\n+\n+      --  Since we are still called from the parent process, there is no way\n+      --  currently we can cleanly close the unneeded ends of the pipes, but\n+      --  this doesn't really matter.\n+      --  We could close Pipe1.Output, Pipe2.Input, Pipe3.Input.\n+\n+      Dup2 (Pipe1.Input,  GNAT.OS_Lib.Standin);\n+      Dup2 (Pipe2.Output, GNAT.OS_Lib.Standout);\n+      Dup2 (Pipe3.Output, GNAT.OS_Lib.Standerr);\n+\n+      Portable_Execvp (Cmd & ASCII.Nul, Args);\n+\n+      --  The following commands are not executed on Unix systems, and are\n+      --  only required for Windows systems. We are now in the parent process.\n+\n+      --  Restore the old descriptors\n+\n+      Dup2 (Input,  GNAT.OS_Lib.Standin);\n+      Dup2 (Output, GNAT.OS_Lib.Standout);\n+      Dup2 (Error, GNAT.OS_Lib.Standerr);\n+      Close (Input);\n+      Close (Output);\n+      Close (Error);\n+   end Set_Up_Child_Communications;\n+\n+   ---------------------------\n+   -- Set_Up_Communications --\n+   ---------------------------\n+\n+   procedure Set_Up_Communications\n+     (Pid        : in out Process_Descriptor;\n+      Err_To_Out : Boolean;\n+      Pipe1      : access Pipe_Type;\n+      Pipe2      : access Pipe_Type;\n+      Pipe3      : access Pipe_Type) is\n+   begin\n+      --  Create the pipes\n+\n+      if Create_Pipe (Pipe1) /= 0 then\n+         return;\n+      end if;\n+\n+      if Create_Pipe (Pipe2) /= 0 then\n+         return;\n+      end if;\n+\n+      Pid.Input_Fd  := Pipe1.Output;\n+      Pid.Output_Fd := Pipe2.Input;\n+\n+      if Err_To_Out then\n+         Pipe3.all := Pipe2.all;\n+      else\n+         if Create_Pipe (Pipe3) /= 0 then\n+            return;\n+         end if;\n+      end if;\n+\n+      Pid.Error_Fd := Pipe3.Input;\n+   end Set_Up_Communications;\n+\n+   ----------------------------------\n+   -- Set_Up_Parent_Communications --\n+   ----------------------------------\n+\n+   procedure Set_Up_Parent_Communications\n+     (Pid   : in out Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type)\n+   is\n+   begin\n+      Close (Pipe1.Input);\n+      Close (Pipe2.Output);\n+      Close (Pipe3.Output);\n+   end Set_Up_Parent_Communications;\n+\n+   ------------------\n+   -- Trace_Filter --\n+   ------------------\n+\n+   procedure Trace_Filter\n+     (Descriptor : Process_Descriptor'Class;\n+      Str        : String;\n+      User_Data  : System.Address := System.Null_Address)\n+   is\n+   begin\n+      GNAT.IO.Put (Str);\n+   end Trace_Filter;\n+\n+   --------------------\n+   -- Unlock_Filters --\n+   --------------------\n+\n+   procedure Unlock_Filters (Descriptor : in out Process_Descriptor) is\n+   begin\n+      if Descriptor.Filters_Lock > 0 then\n+         Descriptor.Filters_Lock := Descriptor.Filters_Lock - 1;\n+      end if;\n+   end Unlock_Filters;\n+\n+end GNAT.Expect;"}, {"sha": "5df3e73d43b34813a135a88577ced8cc6c4cb6ce", "filename": "gcc/ada/g-expect.ads", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-expect.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-expect.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,589 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . E X P E C T                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $\n+--                                                                          --\n+--           Copyright (C) 2000-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Currently this package is implemented on all native GNAT ports except\n+--  for VMS. It is not yet implemented for any of the cross-ports (e.g. it\n+--  is not available for VxWorks or LynxOS).\n+--\n+--  Usage\n+--  =====\n+--\n+--  This package provides a set of subprograms similar to what is available\n+--  with the standard Tcl Expect tool.\n+\n+--  It allows you to easily spawn and communicate with an external process.\n+--  You can send commands or inputs to the process, and compare the output\n+--  with some expected regular expression.\n+--\n+--  Usage example:\n+--\n+--      Non_Blocking_Spawn (Fd, \"ftp machine@domaine\");\n+--      Timeout := 10000;  --  10 seconds\n+--      Expect (Fd, Result, Regexp_Array'(+\"\\(user\\)\", +\"\\(passwd\\)\"),\n+--              Timeout);\n+--      case Result is\n+--         when 1 => Send (Fd, \"my_name\");   --  matched \"user\"\n+--         when 2 => Send (Fd, \"my_passwd\"); --  matched \"passwd\"\n+--         when Expect_Timeout => null;      --  timeout\n+--         when others => null;\n+--      end case;\n+--      Close (Fd);\n+--\n+--  You can also combine multiple regular expressions together, and get the\n+--  specific string matching a parenthesis pair by doing something like. If you\n+--  expect either \"lang=optional ada\" or \"lang=ada\" from the external process,\n+--  you can group the two together, which is more efficient, and simply get the\n+--  name of the language by doing:\n+--\n+--      declare\n+--         Matched : Regexp_Array (0 .. 2);\n+--      begin\n+--         Expect (Fd, Result, \"lang=(optional)? ([a-z]+)\", Matched);\n+--         Put_Line (\"Seen: \" &\n+--                   Expect_Out (Fd) (Matched (2).First .. Matched (2).Last));\n+--      end;\n+--\n+--  Alternatively, you might choose to use a lower-level interface to the\n+--  processes, where you can give your own input and output filters every\n+--  time characters are read from or written to the process.\n+--\n+--      procedure My_Filter (Descriptor : Process_Descriptor; Str : String) is\n+--      begin\n+--         Put_Line (Str);\n+--      end;\n+--\n+--      Fd := Non_Blocking_Spawn (\"tail -f a_file\");\n+--      Add_Filter (Fd, My_Filter'Access, Output);\n+--      Expect (Fd, Result, \"\", 0);  --  wait forever\n+--\n+--  The above example should probably be run in a separate task, since it is\n+--  blocking on the call to Expect.\n+--\n+--  Both examples can be combined, for instance to systematically print the\n+--  output seen by expect, even though you still want to let Expect do the\n+--  filtering. You can use the Trace_Filter subprogram for such a filter.\n+--\n+--  If you want to get the output of a simple command, and ignore any previous\n+--  existing output, it is recommended to do something like:\n+--\n+--      Expect (Fd, Result, \".*\", Timeout => 0);\n+--            -- empty the buffer, by matching everything (after checking\n+--            -- if there was any input).\n+--      Send (Fd, \"command\");\n+--      Expect (Fd, Result, \"..\"); -- match only on the output of command\n+--\n+--  Task Safety\n+--  ===========\n+--\n+--  This package is not task-safe. However, you can easily make is task safe\n+--  by encapsulating the type Process_Descriptor in a protected record.\n+--  There should not be concurrent calls to Expect.\n+\n+with System;\n+with GNAT.OS_Lib;\n+with GNAT.Regpat;\n+\n+package GNAT.Expect is\n+\n+   type Process_Id is new Integer;\n+   Invalid_Pid : constant Process_Id := -1;\n+   Null_Pid    : constant Process_Id := 0;\n+\n+   type Filter_Type is (Output, Input, Died);\n+   --  The signals that are emitted by the Process_Descriptor upon state\n+   --  changed in the child. One can connect to any of this signal through\n+   --  the Add_Filter subprograms.\n+   --\n+   --     Output => Every time new characters are read from the process\n+   --               associated with Descriptor, the filter is called with\n+   --               these new characters in argument.\n+   --\n+   --               Note that output is only generated when the program is\n+   --               blocked in a call to Expect.\n+   --\n+   --     Input  => Every time new characters are written to the process\n+   --               associated with Descriptor, the filter is called with\n+   --               these new characters in argument.\n+   --               Note that input is only generated by calls to Send.\n+   --\n+   --     Died   => The child process has died, or was explicitly killed\n+\n+   type Process_Descriptor is tagged private;\n+   --  Contains all the components needed to describe a process handled\n+   --  in this package, including a process identifier, file descriptors\n+   --  associated with the standard input, output and error, and the buffer\n+   --  needed to handle the expect calls.\n+\n+   type Process_Descriptor_Access is access Process_Descriptor'Class;\n+\n+   ------------------------\n+   -- Spawning a process --\n+   ------------------------\n+\n+   procedure Non_Blocking_Spawn\n+     (Descriptor  : out Process_Descriptor'Class;\n+      Command     : String;\n+      Args        : GNAT.OS_Lib.Argument_List;\n+      Buffer_Size : Natural := 4096;\n+      Err_To_Out  : Boolean := False);\n+   --  This call spawns a new process and allows sending commands to\n+   --  the process and/or automatic parsing of the output.\n+   --\n+   --  The expect buffer associated with that process can contain at most\n+   --  Buffer_Size characters. Older characters are simply discarded when\n+   --  this buffer is full. Beware that if the buffer is too big, this could\n+   --  slow down the Expect calls if not output is matched, since Expect has\n+   --  to match all the regexp against all the characters in the buffer.\n+   --  If Buffer_Size is 0, there is no limit (ie all the characters are kept\n+   --  till Expect matches), but this is slower.\n+   --\n+   --  If Err_To_Out is True, then the standard error of the spawned process is\n+   --  connected to the standard output. This is the only way to get the\n+   --  Except subprograms also match on output on standard error.\n+   --\n+   --  Invalid_Process is raised if the process could not be spawned.\n+\n+   procedure Close (Descriptor : in out Process_Descriptor);\n+   --  Terminate the process and close the pipes to it. It implicitly\n+   --  does the 'wait' command required to clean up the process table.\n+   --  This also frees the buffer associated with the process id.\n+\n+   procedure Send_Signal\n+     (Descriptor : Process_Descriptor;\n+      Signal     : Integer);\n+   --  Send a given signal to the process.\n+\n+   procedure Interrupt (Descriptor : in out Process_Descriptor);\n+   --  Interrupt the process (the equivalent of Ctrl-C on unix and windows)\n+   --  and call close if the process dies.\n+\n+   function Get_Input_Fd\n+     (Descriptor : Process_Descriptor)\n+      return       GNAT.OS_Lib.File_Descriptor;\n+   --  Return the input file descriptor associated with Descriptor.\n+\n+   function Get_Output_Fd\n+     (Descriptor : Process_Descriptor)\n+      return       GNAT.OS_Lib.File_Descriptor;\n+   --  Return the output file descriptor associated with Descriptor.\n+\n+   function Get_Error_Fd\n+     (Descriptor : Process_Descriptor)\n+      return       GNAT.OS_Lib.File_Descriptor;\n+   --  Return the error output file descriptor associated with Descriptor.\n+\n+   function Get_Pid\n+     (Descriptor : Process_Descriptor)\n+      return       Process_Id;\n+   --  Return the process id assocated with a given process descriptor.\n+\n+   --------------------\n+   -- Adding filters --\n+   --------------------\n+\n+   --  This is a rather low-level interface to subprocesses, since basically\n+   --  the filtering is left entirely to the user. See the Expect subprograms\n+   --  below for higher level functions.\n+\n+   type Filter_Function is access\n+     procedure\n+       (Descriptor : Process_Descriptor'Class;\n+        Str        : String;\n+        User_Data  : System.Address := System.Null_Address);\n+   --  Function called every time new characters are read from or written\n+   --  to the process.\n+   --\n+   --  Str is a string of all these characters.\n+   --\n+   --  User_Data, if specified, is a user specific data that will be passed to\n+   --  the filter. Note that no checks are done on this parameter that should\n+   --  be used with cautiousness.\n+\n+   procedure Add_Filter\n+     (Descriptor : in out Process_Descriptor;\n+      Filter     : Filter_Function;\n+      Filter_On  : Filter_Type := Output;\n+      User_Data  : System.Address := System.Null_Address;\n+      After      : Boolean := False);\n+   --  Add a new filter for one of the filter type. This filter will be\n+   --  run before all the existing filters, unless After is set True,\n+   --  in which case it will be run after existing filters. User_Data\n+   --  is passed as is to the filter procedure.\n+\n+   procedure Remove_Filter\n+     (Descriptor : in out Process_Descriptor;\n+      Filter     : Filter_Function);\n+   --  Remove a filter from the list of filters (whatever the type of the\n+   --  filter).\n+\n+   procedure Trace_Filter\n+     (Descriptor : Process_Descriptor'Class;\n+      Str        : String;\n+      User_Data  : System.Address := System.Null_Address);\n+   --  Function that can be used a filter and that simply outputs Str on\n+   --  Standard_Output. This is mainly used for debugging purposes.\n+   --  User_Data is ignored.\n+\n+   procedure Lock_Filters (Descriptor : in out Process_Descriptor);\n+   --  Temporarily disables all output and input filters. They will be\n+   --  reactivated only when Unlock_Filters has been called as many times as\n+   --  Lock_Filters;\n+\n+   procedure Unlock_Filters (Descriptor : in out Process_Descriptor);\n+   --  Unlocks the filters. They are reactivated only if Unlock_Filters\n+   --  has been called as many times as Lock_Filters.\n+\n+   ------------------\n+   -- Sending data --\n+   ------------------\n+\n+   procedure Send\n+     (Descriptor   : in out Process_Descriptor;\n+      Str          : String;\n+      Add_LF       : Boolean := True;\n+      Empty_Buffer : Boolean := False);\n+   --  Send a string to the file descriptor.\n+   --\n+   --  The string is not formatted in any way, except if Add_LF is True,\n+   --  in which case an ASCII.LF is added at the end, so that Str is\n+   --  recognized as a command by the external process.\n+   --\n+   --  If Empty_Buffer is True, any input waiting from the process (or in the\n+   --  buffer) is first discarded before the command is sent. The output\n+   --  filters are of course called as usual.\n+\n+   -----------------------------------------------------------\n+   -- Working on the output (single process, simple regexp) --\n+   -----------------------------------------------------------\n+\n+   type Expect_Match is new Integer;\n+   Expect_Full_Buffer : constant Expect_Match := -1;\n+   --  If the buffer was full and some characters were discarded.\n+\n+   Expect_Timeout : constant Expect_Match := -2;\n+   --  If not output matching the regexps was found before the timeout.\n+\n+   function \"+\" (S : String) return GNAT.OS_Lib.String_Access;\n+   --  Allocate some memory for the string. This is merely a convenience\n+   --  convenience function to help create the array of regexps in the\n+   --  call to Expect.\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : String;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Wait till a string matching Fd can be read from Fd, and return 1\n+   --  if a match was found.\n+   --\n+   --  It consumes all the characters read from Fd until a match found, and\n+   --  then sets the return values for the subprograms Expect_Out and\n+   --  Expect_Out_Match.\n+   --\n+   --  The empty string \"\" will never match, and can be used if you only want\n+   --  to match after a specific timeout. Beware that if Timeout is -1 at the\n+   --  time, the current task will be blocked forever.\n+   --\n+   --  This command times out after Timeout milliseconds (or never if Timeout\n+   --  is -1). In that case, Expect_Timeout is returned. The value returned by\n+   --  Expect_Out and Expect_Out_Match are meaningless in that case.\n+   --\n+   --  Note that using a timeout of 0ms leads to unpredictable behavior, since\n+   --  the result depends on whether the process has already sent some output\n+   --  the first time Expect checks, and this depends on the operating system.\n+   --\n+   --  The regular expression must obey the syntax described in GNAT.Regpat.\n+   --\n+   --  If Full_Buffer is True, then Expect will match if the buffer was too\n+   --  small and some characters were about to be discarded. In that case,\n+   --  Expect_Full_Buffer is returned.\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : GNAT.Regpat.Pattern_Matcher;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as the previous one, but with a precompiled regular expression.\n+   --  This is more efficient however, especially if you are using this\n+   --  expression multiple times, since this package won't need to recompile\n+   --  the regexp every time.\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : String;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as above, but it is now possible to get the indexes of the\n+   --  substrings for the parentheses in the regexp (see the example at the\n+   --  top of this package, as well as the documentation in the package\n+   --  GNAT.Regpat).\n+   --\n+   --  Matched'First should be 0, and this index will contain the indexes for\n+   --  the whole string that was matched. The index 1 will contain the indexes\n+   --  for the first parentheses-pair, and so on.\n+\n+   ------------\n+   -- Expect --\n+   ------------\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexp      : GNAT.Regpat.Pattern_Matcher;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as above, but with a precompiled regular expression.\n+\n+   -------------------------------------------------------------\n+   -- Working on the output (single process, multiple regexp) --\n+   -------------------------------------------------------------\n+\n+   type Regexp_Array is array (Positive range <>) of GNAT.OS_Lib.String_Access;\n+\n+   type Pattern_Matcher_Access is access GNAT.Regpat.Pattern_Matcher;\n+   type Compiled_Regexp_Array is array (Positive range <>)\n+     of Pattern_Matcher_Access;\n+\n+   function \"+\"\n+     (P    : GNAT.Regpat.Pattern_Matcher)\n+      return Pattern_Matcher_Access;\n+   --  Allocate some memory for the pattern matcher.\n+   --  This is only a convenience function to help create the array of\n+   --  compiled regular expressoins.\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Regexp_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Wait till a string matching one of the regular expressions in Regexps\n+   --  is found. This function returns the index of the regexp that matched.\n+   --  This command is blocking, but will timeout after Timeout milliseconds.\n+   --  In that case, Timeout is returned.\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Compiled_Regexp_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as the previous one, but with precompiled regular expressions.\n+   --  This can be much faster if you are using them multiple times.\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Regexp_Array;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as above, except that you can also access the parenthesis\n+   --  groups inside the matching regular expression.\n+   --  The first index in Matched must be 0, or Constraint_Error will be\n+   --  raised. The index 0 contains the indexes for the whole string that was\n+   --  matched, the index 1 contains the indexes for the first parentheses\n+   --  pair, and so on.\n+\n+   procedure Expect\n+     (Descriptor  : in out Process_Descriptor;\n+      Result      : out Expect_Match;\n+      Regexps     : Compiled_Regexp_Array;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as above, but with precompiled regular expressions.\n+   --  The first index in Matched must be 0, or Constraint_Error will be\n+   --  raised.\n+\n+   -------------------------------------------\n+   -- Working on the output (multi-process) --\n+   -------------------------------------------\n+\n+   type Multiprocess_Regexp is record\n+      Descriptor : Process_Descriptor_Access;\n+      Regexp     : Pattern_Matcher_Access;\n+   end record;\n+   type Multiprocess_Regexp_Array is array (Positive range <>)\n+     of Multiprocess_Regexp;\n+\n+   procedure Expect\n+     (Result      : out Expect_Match;\n+      Regexps     : Multiprocess_Regexp_Array;\n+      Matched     : out GNAT.Regpat.Match_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as above, but for multi processes.\n+\n+   procedure Expect\n+     (Result      : out Expect_Match;\n+      Regexps     : Multiprocess_Regexp_Array;\n+      Timeout     : Integer := 10000;\n+      Full_Buffer : Boolean := False);\n+   --  Same as the previous one, but for multiple processes.\n+   --  This procedure finds the first regexp that match the associated process.\n+\n+   ------------------------\n+   -- Getting the output --\n+   ------------------------\n+\n+   procedure Flush\n+     (Descriptor : in out Process_Descriptor;\n+      Timeout    : Integer := 0);\n+   --  Discard all output waiting from the process.\n+   --\n+   --  This output is simply discarded, and no filter is called. This output\n+   --  will also not be visible by the next call to Expect, nor will any\n+   --  output currently buffered.\n+   --\n+   --  Timeout is the delay for which we wait for output to be available from\n+   --  the process. If 0, we only get what is immediately available.\n+\n+   function Expect_Out (Descriptor : Process_Descriptor) return String;\n+   --  Return the string matched by the last Expect call.\n+   --\n+   --  The returned string is in fact the concatenation of all the strings\n+   --  read from the file descriptor up to, and including, the characters\n+   --  that matched the regular expression.\n+   --\n+   --  For instance, with an input \"philosophic\", and a regular expression\n+   --  \"hi\" in the call to expect, the strings returned the first and second\n+   --  time would be respectively \"phi\" and \"losophi\".\n+\n+   function Expect_Out_Match (Descriptor : Process_Descriptor) return String;\n+   --  Return the string matched by the last Expect call.\n+   --\n+   --  The returned string includes only the character that matched the\n+   --  specific regular expression. All the characters that came before are\n+   --  simply discarded.\n+   --\n+   --  For instance, with an input \"philosophic\", and a regular expression\n+   --  \"hi\" in the call to expect, the strings returned the first and second\n+   --  time would both be \"hi\".\n+\n+   ----------------\n+   -- Exceptions --\n+   ----------------\n+\n+   Invalid_Process : exception;\n+   --  Raised by most subprograms above when the parameter Descriptor is not a\n+   --  valid process or is a closed process.\n+\n+   Process_Died : exception;\n+   --  Raised by all the expect subprograms if Descriptor was originally a\n+   --  valid process that died while Expect was executing. It is also raised\n+   --  when Expect receives an end-of-file.\n+\n+   ------------------------\n+   -- Internal functions --\n+   ------------------------\n+\n+   --  The following subprograms are provided so that it is easy to write\n+   --  extensions to this package. However, clients should not use these\n+   --  routines directly.\n+\n+   procedure Portable_Execvp (Cmd : String; Args : System.Address);\n+   --  Executes, in a portable way, the command Cmd (full path must be\n+   --  specified), with the given Args. Note that the first element in Args\n+   --  must be the executable name, and the last element must be a null\n+   --  pointer\n+\n+private\n+   type Filter_List_Elem;\n+   type Filter_List is access Filter_List_Elem;\n+   type Filter_List_Elem is record\n+      Filter    : Filter_Function;\n+      User_Data : System.Address;\n+      Filter_On : Filter_Type;\n+      Next      : Filter_List;\n+   end record;\n+\n+   type Pipe_Type is record\n+      Input, Output : GNAT.OS_Lib.File_Descriptor;\n+   end record;\n+   --  This type represents a pipe, used to communicate between two processes.\n+\n+   procedure Set_Up_Communications\n+     (Pid        : in out Process_Descriptor;\n+      Err_To_Out : Boolean;\n+      Pipe1      : access Pipe_Type;\n+      Pipe2      : access Pipe_Type;\n+      Pipe3      : access Pipe_Type);\n+   --  Set up all the communication pipes and file descriptors prior to\n+   --  spawning the child process.\n+\n+   procedure Set_Up_Parent_Communications\n+     (Pid   : in out Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type);\n+   --  Finish the set up of the pipes while in the parent process\n+\n+   procedure Set_Up_Child_Communications\n+     (Pid   : in out Process_Descriptor;\n+      Pipe1 : in out Pipe_Type;\n+      Pipe2 : in out Pipe_Type;\n+      Pipe3 : in out Pipe_Type;\n+      Cmd   : String;\n+      Args  : System.Address);\n+   --  Finish the set up of the pipes while in the child process\n+   --  This also spawns the child process (based on Cmd).\n+   --  On systems that support fork, this procedure is executed inside the\n+   --  newly created process.\n+\n+   type Process_Descriptor is tagged record\n+      Pid              : Process_Id := Invalid_Pid;\n+      Input_Fd         : GNAT.OS_Lib.File_Descriptor := GNAT.OS_Lib.Invalid_FD;\n+      Output_Fd        : GNAT.OS_Lib.File_Descriptor := GNAT.OS_Lib.Invalid_FD;\n+      Error_Fd         : GNAT.OS_Lib.File_Descriptor := GNAT.OS_Lib.Invalid_FD;\n+      Filters_Lock     : Integer := 0;\n+\n+      Filters          : Filter_List := null;\n+\n+      Buffer           : GNAT.OS_Lib.String_Access := null;\n+      Buffer_Size      : Natural := 0;\n+      Buffer_Index     : Natural := 0;\n+\n+      Last_Match_Start : Natural := 0;\n+      Last_Match_End   : Natural := 0;\n+   end record;\n+\n+   pragma Import (C, Portable_Execvp, \"__gnat_expect_portable_execvp\");\n+\n+end GNAT.Expect;"}, {"sha": "c5d0cb2d03d369b3ac266b0fec49fd5ac415e30f", "filename": "gcc/ada/g-flocon.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-flocon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-flocon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-flocon.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . F L O A T _ C O N T R O L                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--              Copyright (C) 2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Control functions for floating-point unit\n+\n+package GNAT.Float_Control is\n+\n+   procedure Reset;\n+   --  Reset the floating-point processor to the default state needed to get\n+   --  correct Ada semantics for the target. Some third party tools change\n+   --  the settings for the floating-point processor. Reset can be called\n+   --  to reset the floating-point processor into the mode required by GNAT\n+   --  for correct operation. Use this call after a call to foreign code if\n+   --  you suspect incorrect floating-point operation after the call.\n+   --\n+   --  For example under Windows NT some system DLL calls change the default\n+   --  FPU arithmetic to 64 bit precision mode. However, since in Ada 95 it\n+   --  is required to provide full access to the floating-point types of the\n+   --  architecture, GNAT requires full 80-bit precision mode, and Reset makes\n+   --  sure this mode is established.\n+   --\n+   --  Similarly on the PPC processor, it is important that overflow and\n+   --  underflow exceptions be disabled.\n+   --\n+   --  The call to Reset simply has no effect if the target environment\n+   --  does not give rise to such concerns.\n+\n+private\n+   pragma Import (C, Reset, \"__gnat_init_float\");\n+\n+end GNAT.Float_Control;"}, {"sha": "6657a9751829a23da04bcdd646e713acb2cd0130", "filename": "gcc/ada/g-hesora.adb", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesora.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesora.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-hesora.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,135 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     G N A T . H E A P _ S O R T _ A                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1999 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Heap_Sort_A is\n+\n+   ----------\n+   -- Sort --\n+   ----------\n+\n+   --  We are using the classical heapsort algorithm (i.e. Floyd's Treesort3)\n+   --  as described by Knuth (\"The Art of Programming\", Volume III, first\n+   --  edition, section 5.2.3, p. 145-147) with the modification that is\n+   --  mentioned in exercise 18. For more details on this algorithm, see\n+   --  Robert B. K. Dewar PhD thesis \"The use of Computers in the X-ray\n+   --  Phase Problem\". University of Chicago, 1968, which was the first\n+   --  publication of the modification, which reduces the number of compares\n+   --  from 2NlogN to NlogN.\n+\n+   procedure Sort (N : Natural; Move : Move_Procedure; Lt : Lt_Function) is\n+\n+      Max : Natural := N;\n+      --  Current Max index in tree being sifted\n+\n+      procedure Sift (S : Positive);\n+      --  This procedure sifts up node S, i.e. converts the subtree rooted\n+      --  at node S into a heap, given the precondition that any sons of\n+      --  S are already heaps. On entry, the contents of node S is found\n+      --  in the temporary (index 0), the actual contents of node S on\n+      --  entry are irrelevant. This is just a minor optimization to avoid\n+      --  what would otherwise be two junk moves in phase two of the sort.\n+\n+      procedure Sift (S : Positive) is\n+         C      : Positive := S;\n+         Son    : Positive;\n+         Father : Positive;\n+\n+      begin\n+         --  This is where the optimization is done, normally we would do a\n+         --  comparison at each stage between the current node and the larger\n+         --  of the two sons, and continue the sift only if the current node\n+         --  was less than this maximum. In this modified optimized version,\n+         --  we assume that the current node will be less than the larger\n+         --  son, and unconditionally sift up. Then when we get to the bottom\n+         --  of the tree, we check parents to make sure that we did not make\n+         --  a mistake. This roughly cuts the number of comparisions in half,\n+         --  since it is almost always the case that our assumption is correct.\n+\n+         --  Loop to pull up larger sons\n+\n+         loop\n+            Son := 2 * C;\n+            exit when Son > Max;\n+\n+            if Son < Max and then Lt (Son, Son + 1) then\n+               Son := Son + 1;\n+            end if;\n+\n+            Move (Son, C);\n+            C := Son;\n+         end loop;\n+\n+         --  Loop to check fathers\n+\n+         while C /= S loop\n+            Father := C / 2;\n+\n+            if Lt (Father, 0) then\n+               Move (Father, C);\n+               C := Father;\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n+         --  Last step is to pop the sifted node into place\n+\n+         Move (0, C);\n+      end Sift;\n+\n+   --  Start of processing for Sort\n+\n+   begin\n+      --  Phase one of heapsort is to build the heap. This is done by\n+      --  sifting nodes N/2 .. 1 in sequence.\n+\n+      for J in reverse 1 .. N / 2 loop\n+         Move (J, 0);\n+         Sift (J);\n+      end loop;\n+\n+      --  In phase 2, the largest node is moved to end, reducing the size\n+      --  of the tree by one, and the displaced node is sifted down from\n+      --  the top, so that the largest node is again at the top.\n+\n+      while Max > 1 loop\n+         Move (Max, 0);\n+         Move (1, Max);\n+         Max := Max - 1;\n+         Sift (1);\n+      end loop;\n+\n+   end Sort;\n+\n+end GNAT.Heap_Sort_A;"}, {"sha": "019c0d134ee61a160a05dfa3d4ddf5095654bc6b", "filename": "gcc/ada/g-hesora.ads", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesora.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesora.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-hesora.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,68 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     G N A T . H E A P _ S O R T _ A                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $\n+--                                                                          --\n+--           Copyright (C) 1995-2000 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Heapsort using access to procedure parameters\n+\n+--  This package provides a heapsort routine that works with access to\n+--  subprogram parameters, so that it can be used with different types with\n+--  shared sorting code. See also GNAT.Heap_Sort_G, the generic version,\n+--  which is a little more efficient but does not allow code sharing.\n+--  The generic version is also Pure, while the access version can\n+--  only be Preelaborate.\n+\n+package GNAT.Heap_Sort_A is\n+pragma Preelaborate (Heap_Sort_A);\n+\n+   --  The data to be sorted is assumed to be indexed by integer values from\n+   --  1 to N, where N is the number of items to be sorted. In addition, the\n+   --  index value zero is used for a temporary location used during the sort.\n+\n+   type Move_Procedure is access procedure (From : Natural; To : Natural);\n+   --  A pointer to a procedure that moves the data item with index From to\n+   --  the data item with index To. An index value of zero is used for moves\n+   --  from and to the single temporary location used by the sort.\n+\n+   type Lt_Function is access function (Op1, Op2 : Natural) return Boolean;\n+   --  A pointer to a function that compares two items and returns True if\n+   --  the item with index Op1 is less than the item with index Op2, and False\n+   --  if the Op1 item is greater than or equal to the Op2 item.\n+\n+   procedure Sort (N : Natural; Move : Move_Procedure; Lt : Lt_Function);\n+   --  This procedures sorts items in the range from 1 to N into ascending\n+   --  order making calls to Lt to do required comparisons, and Move to move\n+   --  items around. Note that, as described above, both Move and Lt use a\n+   --  single temporary location with index value zero. This sort is not\n+   --  stable, i.e. the order of equal elements in the input is not preserved.\n+\n+end GNAT.Heap_Sort_A;"}, {"sha": "45fb3d0321d1c01407d9a02b3e77c468c0f6ef94", "filename": "gcc/ada/g-hesorg.adb", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesorg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesorg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-hesorg.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,135 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     G N A T . H E A P _ S O R T _ G                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1999 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Heap_Sort_G is\n+\n+   ----------\n+   -- Sort --\n+   ----------\n+\n+   --  We are using the classical heapsort algorithm (i.e. Floyd's Treesort3)\n+   --  as described by Knuth (\"The Art of Programming\", Volume III, first\n+   --  edition, section 5.2.3, p. 145-147) with the modification that is\n+   --  mentioned in exercise 18. For more details on this algorithm, see\n+   --  Robert B. K. Dewar PhD thesis \"The use of Computers in the X-ray\n+   --  Phase Problem\". University of Chicago, 1968, which was the first\n+   --  publication of the modification, which reduces the number of compares\n+   --  from 2NlogN to NlogN.\n+\n+   procedure Sort (N : Natural) is\n+\n+      Max : Natural := N;\n+      --  Current Max index in tree being sifted\n+\n+      procedure Sift (S : Positive);\n+      --  This procedure sifts up node S, i.e. converts the subtree rooted\n+      --  at node S into a heap, given the precondition that any sons of\n+      --  S are already heaps. On entry, the contents of node S is found\n+      --  in the temporary (index 0), the actual contents of node S on\n+      --  entry are irrelevant. This is just a minor optimization to avoid\n+      --  what would otherwise be two junk moves in phase two of the sort.\n+\n+      procedure Sift (S : Positive) is\n+         C      : Positive := S;\n+         Son    : Positive;\n+         Father : Positive;\n+\n+      begin\n+         --  This is where the optimization is done, normally we would do a\n+         --  comparison at each stage between the current node and the larger\n+         --  of the two sons, and continue the sift only if the current node\n+         --  was less than this maximum. In this modified optimized version,\n+         --  we assume that the current node will be less than the larger\n+         --  son, and unconditionally sift up. Then when we get to the bottom\n+         --  of the tree, we check parents to make sure that we did not make\n+         --  a mistake. This roughly cuts the number of comparisions in half,\n+         --  since it is almost always the case that our assumption is correct.\n+\n+         --  Loop to pull up larger sons\n+\n+         loop\n+            Son := 2 * C;\n+            exit when Son > Max;\n+\n+            if Son < Max and then Lt (Son, Son + 1) then\n+               Son := Son + 1;\n+            end if;\n+\n+            Move (Son, C);\n+            C := Son;\n+         end loop;\n+\n+         --  Loop to check fathers\n+\n+         while C /= S loop\n+            Father := C / 2;\n+\n+            if Lt (Father, 0) then\n+               Move (Father, C);\n+               C := Father;\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n+         --  Last step is to pop the sifted node into place\n+\n+         Move (0, C);\n+      end Sift;\n+\n+   --  Start of processing for Sort\n+\n+   begin\n+      --  Phase one of heapsort is to build the heap. This is done by\n+      --  sifting nodes N/2 .. 1 in sequence.\n+\n+      for J in reverse 1 .. N / 2 loop\n+         Move (J, 0);\n+         Sift (J);\n+      end loop;\n+\n+      --  In phase 2, the largest node is moved to end, reducing the size\n+      --  of the tree by one, and the displaced node is sifted down from\n+      --  the top, so that the largest node is again at the top.\n+\n+      while Max > 1 loop\n+         Move (Max, 0);\n+         Move (1, Max);\n+         Max := Max - 1;\n+         Sift (1);\n+      end loop;\n+\n+   end Sort;\n+\n+end GNAT.Heap_Sort_G;"}, {"sha": "1611def563bac6caf5b9323df09c9316da00bfbd", "filename": "gcc/ada/g-hesorg.ads", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesorg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-hesorg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-hesorg.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,68 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                     G N A T . H E A P _ S O R T _ G                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $\n+--                                                                          --\n+--           Copyright (C) 1995-2000 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Heapsort generic package using formal procedures\n+\n+--  This package provides a generic heapsort routine that can be used with\n+--  different types of data. See also GNAT.Heap_Sort_A, a version that works\n+--  with subprogram parameters, allowing code sharing. The generic version\n+--  is slightly more efficient but does not allow code sharing. The generic\n+--  version is also Pure, while the access version can only be Preelaborate.\n+\n+generic\n+   --  The data to be sorted is assumed to be indexed by integer values from\n+   --  1 to N, where N is the number of items to be sorted. In addition, the\n+   --  index value zero is used for a temporary location used during the sort.\n+\n+   with procedure Move (From : Natural; To : Natural);\n+   --  A procedure that moves the data item with index From to the data item\n+   --  with Index To. An index value of zero is used for moves from and to a\n+   --  single temporary location used by the sort.\n+\n+   with function Lt (Op1, Op2 : Natural) return Boolean;\n+   --  A function that compares two items and returns True if the item with\n+   --  index Op1 is less than the item with Index Op2, and False if the Op1\n+   --  item is greater than or equal to the Op2 item.\n+\n+package GNAT.Heap_Sort_G is\n+pragma Pure (Heap_Sort_G);\n+\n+   procedure Sort (N : Natural);\n+   --  This procedures sorts items in the range from 1 to N into ascending\n+   --  order making calls to Lt to do required comparisons, and Move to move\n+   --  items around. Note that, as described above, both Move and Lt use a\n+   --  single temporary location with index value zero. This sort is not\n+   --  stable, i.e. the order of equal elements in the input is not preserved.\n+\n+end GNAT.Heap_Sort_G;"}, {"sha": "4560049518c393d958c51a1be2303bbecc8a7824", "filename": "gcc/ada/g-htable.adb", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-htable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-htable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-htable.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,362 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . H T A B L E                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.14 $\n+--                                                                          --\n+--           Copyright (C) 1995-1999 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+package body GNAT.HTable is\n+\n+   --------------------\n+   --  Static_HTable --\n+   --------------------\n+\n+   package body Static_HTable is\n+\n+      Table : array (Header_Num) of Elmt_Ptr;\n+\n+      Iterator_Index   : Header_Num;\n+      Iterator_Ptr     : Elmt_Ptr;\n+      Iterator_Started : Boolean := False;\n+\n+      function Get_Non_Null return Elmt_Ptr;\n+      --  Returns Null_Ptr if Iterator_Started is false of the Table is\n+      --  empty. Returns Iterator_Ptr if non null, or the next non null\n+      --  element in table if any.\n+\n+      ---------\n+      -- Get --\n+      ---------\n+\n+      function  Get (K : Key) return Elmt_Ptr is\n+         Elmt  : Elmt_Ptr;\n+\n+      begin\n+         Elmt := Table (Hash (K));\n+\n+         loop\n+            if Elmt = Null_Ptr then\n+               return Null_Ptr;\n+\n+            elsif Equal (Get_Key (Elmt), K) then\n+               return Elmt;\n+\n+            else\n+               Elmt := Next (Elmt);\n+            end if;\n+         end loop;\n+      end Get;\n+\n+      ---------------\n+      -- Get_First --\n+      ---------------\n+\n+      function Get_First return Elmt_Ptr is\n+      begin\n+         Iterator_Started := True;\n+         Iterator_Index := Table'First;\n+         Iterator_Ptr := Table (Iterator_Index);\n+         return Get_Non_Null;\n+      end Get_First;\n+\n+      --------------\n+      -- Get_Next --\n+      --------------\n+\n+      function Get_Next return Elmt_Ptr is\n+      begin\n+         if not Iterator_Started then\n+            return Null_Ptr;\n+         end if;\n+\n+         Iterator_Ptr := Next (Iterator_Ptr);\n+         return Get_Non_Null;\n+      end Get_Next;\n+\n+      ------------------\n+      -- Get_Non_Null --\n+      ------------------\n+\n+      function Get_Non_Null return Elmt_Ptr is\n+      begin\n+         while Iterator_Ptr = Null_Ptr  loop\n+            if Iterator_Index = Table'Last then\n+               Iterator_Started := False;\n+               return Null_Ptr;\n+            end if;\n+\n+            Iterator_Index := Iterator_Index + 1;\n+            Iterator_Ptr   := Table (Iterator_Index);\n+         end loop;\n+\n+         return Iterator_Ptr;\n+      end Get_Non_Null;\n+\n+      ------------\n+      -- Remove --\n+      ------------\n+\n+      procedure Remove  (K : Key) is\n+         Index     : constant Header_Num := Hash (K);\n+         Elmt      : Elmt_Ptr;\n+         Next_Elmt : Elmt_Ptr;\n+\n+      begin\n+         Elmt := Table (Index);\n+\n+         if Elmt = Null_Ptr then\n+            return;\n+\n+         elsif Equal (Get_Key (Elmt), K) then\n+            Table (Index) := Next (Elmt);\n+\n+         else\n+            loop\n+               Next_Elmt :=  Next (Elmt);\n+\n+               if Next_Elmt = Null_Ptr then\n+                  return;\n+\n+               elsif Equal (Get_Key (Next_Elmt), K) then\n+                  Set_Next (Elmt, Next (Next_Elmt));\n+                  return;\n+\n+               else\n+                  Elmt := Next_Elmt;\n+               end if;\n+            end loop;\n+         end if;\n+      end Remove;\n+\n+      -----------\n+      -- Reset --\n+      -----------\n+\n+      procedure Reset is\n+      begin\n+         for J in Table'Range loop\n+            Table (J) := Null_Ptr;\n+         end loop;\n+      end Reset;\n+\n+      ---------\n+      -- Set --\n+      ---------\n+\n+      procedure Set (E : Elmt_Ptr) is\n+         Index : Header_Num;\n+\n+      begin\n+         Index := Hash (Get_Key (E));\n+         Set_Next (E, Table (Index));\n+         Table (Index) := E;\n+      end Set;\n+\n+   end Static_HTable;\n+\n+   --------------------\n+   --  Simple_HTable --\n+   --------------------\n+\n+   package body Simple_HTable is\n+\n+      type Element_Wrapper;\n+      type Elmt_Ptr is access all Element_Wrapper;\n+      type Element_Wrapper is record\n+         K    : Key;\n+         E    : Element;\n+         Next : Elmt_Ptr;\n+      end record;\n+\n+      procedure Free is new\n+        Ada.Unchecked_Deallocation (Element_Wrapper, Elmt_Ptr);\n+\n+      procedure Set_Next (E : Elmt_Ptr; Next : Elmt_Ptr);\n+      function  Next     (E : Elmt_Ptr) return Elmt_Ptr;\n+      function  Get_Key  (E : Elmt_Ptr) return Key;\n+\n+      package Tab is new Static_HTable (\n+        Header_Num => Header_Num,\n+        Element    => Element_Wrapper,\n+        Elmt_Ptr   => Elmt_Ptr,\n+        Null_Ptr   => null,\n+        Set_Next   => Set_Next,\n+        Next       => Next,\n+        Key        => Key,\n+        Get_Key    => Get_Key,\n+        Hash       => Hash,\n+        Equal      => Equal);\n+\n+      ---------\n+      -- Get --\n+      ---------\n+\n+      function  Get (K : Key) return Element is\n+         Tmp : constant Elmt_Ptr := Tab.Get (K);\n+\n+      begin\n+         if Tmp = null then\n+            return No_Element;\n+         else\n+            return Tmp.E;\n+         end if;\n+      end Get;\n+\n+      ---------------\n+      -- Get_First --\n+      ---------------\n+\n+      function Get_First return Element is\n+         Tmp : constant Elmt_Ptr := Tab.Get_First;\n+\n+      begin\n+         if Tmp = null then\n+            return No_Element;\n+         else\n+            return Tmp.E;\n+         end if;\n+      end Get_First;\n+\n+      -------------\n+      -- Get_Key --\n+      -------------\n+\n+      function Get_Key (E : Elmt_Ptr) return Key is\n+      begin\n+         return E.K;\n+      end Get_Key;\n+\n+      --------------\n+      -- Get_Next --\n+      --------------\n+\n+      function Get_Next return Element is\n+         Tmp : constant Elmt_Ptr := Tab.Get_Next;\n+\n+      begin\n+         if Tmp = null then\n+            return No_Element;\n+         else\n+            return Tmp.E;\n+         end if;\n+      end Get_Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      function Next (E : Elmt_Ptr) return Elmt_Ptr is\n+      begin\n+         return E.Next;\n+      end Next;\n+\n+      ------------\n+      -- Remove --\n+      ------------\n+\n+      procedure Remove  (K : Key) is\n+         Tmp : Elmt_Ptr;\n+\n+      begin\n+         Tmp := Tab.Get (K);\n+\n+         if Tmp /= null then\n+            Tab.Remove (K);\n+            Free (Tmp);\n+         end if;\n+      end Remove;\n+\n+      -----------\n+      -- Reset --\n+      -----------\n+\n+      procedure Reset is\n+         E1, E2 : Elmt_Ptr;\n+\n+      begin\n+         E1 := Tab.Get_First;\n+         while E1 /= null loop\n+            E2 := Tab.Get_Next;\n+            Free (E1);\n+            E1 := E2;\n+         end loop;\n+\n+         Tab.Reset;\n+      end Reset;\n+\n+      ---------\n+      -- Set --\n+      ---------\n+\n+      procedure Set (K : Key; E : Element) is\n+         Tmp : constant Elmt_Ptr := Tab.Get (K);\n+\n+      begin\n+         if Tmp = null then\n+            Tab.Set (new Element_Wrapper'(K, E, null));\n+         else\n+            Tmp.E := E;\n+         end if;\n+      end Set;\n+\n+      --------------\n+      -- Set_Next --\n+      --------------\n+\n+      procedure Set_Next (E : Elmt_Ptr; Next : Elmt_Ptr) is\n+      begin\n+         E.Next := Next;\n+      end Set_Next;\n+   end Simple_HTable;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (Key : String) return Header_Num is\n+\n+      type Uns is mod 2 ** 32;\n+\n+      function Rotate_Left (Value : Uns; Amount : Natural) return Uns;\n+      pragma Import (Intrinsic, Rotate_Left);\n+\n+      Tmp : Uns := 0;\n+\n+   begin\n+      for J in Key'Range loop\n+         Tmp := Rotate_Left (Tmp, 1) + Character'Pos (Key (J));\n+      end loop;\n+\n+      return Header_Num'First +\n+               Header_Num'Base (Tmp mod Header_Num'Range_Length);\n+   end Hash;\n+\n+end GNAT.HTable;"}, {"sha": "3b93f2ea9e9bd4630b52803a8ff9f10c6a1d2fa2", "filename": "gcc/ada/g-htable.ads", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-htable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-htable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-htable.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,192 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . H T A B L E                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--           Copyright (C) 1995-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Hash table searching routines\n+\n+--  This package contains two separate packages. The Simple_Htable package\n+--  provides a very simple abstraction that asosicates one element to one\n+--  key values and takes care of all allocation automatically using the heap.\n+--  The Static_Htable package provides a more complex interface that allows\n+--  complete control over allocation.\n+\n+package GNAT.HTable is\n+pragma Preelaborate (HTable);\n+\n+   -------------------\n+   -- Simple_HTable --\n+   -------------------\n+\n+   --  A simple hash table abstraction, easy to instantiate, easy to use.\n+   --  The table associates one element to one key with the procedure Set.\n+   --  Get retrieves the Element stored for a given Key. The efficiency of\n+   --  retrieval is function of the size of the Table parameterized by\n+   --  Header_Num and the hashing function Hash.\n+\n+   generic\n+      type Header_Num is range <>;\n+      --  An integer type indicating the number and range of hash headers.\n+\n+      type Element is private;\n+      --  The type of element to be stored\n+\n+      No_Element : Element;\n+      --  The object that is returned by Get when no element has been set for\n+      --  a given key\n+\n+      type Key is private;\n+      with function Hash  (F : Key)      return Header_Num;\n+      with function Equal (F1, F2 : Key) return Boolean;\n+\n+   package Simple_HTable is\n+\n+      procedure Set (K : Key; E : Element);\n+      --  Associates an element with a given key. Overrides any previously\n+      --  associated element.\n+\n+      procedure Reset;\n+      --  Removes and frees all elements in the table\n+\n+      function Get (K : Key) return Element;\n+      --  Returns the Element associated with a key or No_Element if the\n+      --  given key has not associated element\n+\n+      procedure Remove (K : Key);\n+      --  Removes the latest inserted element pointer associated with the\n+      --  given key if any, does nothing if none.\n+\n+      function Get_First return Element;\n+      --  Returns No_Element if the Htable is empty, otherwise returns one\n+      --  non specified element. There is no guarantee that 2 calls to this\n+      --  function will return the same element.\n+\n+      function Get_Next return Element;\n+      --  Returns a non-specified element that has not been returned by the\n+      --  same function since the last call to Get_First or No_Element if\n+      --  there is no such element. If there is no call to 'Set' in between\n+      --  Get_Next calls, all the elements of the Htable will be traversed.\n+   end Simple_HTable;\n+\n+   -------------------\n+   -- Static_HTable --\n+   -------------------\n+\n+   --  A low-level Hash-Table abstraction, not as easy to instantiate as\n+   --  Simple_HTable but designed to allow complete control over the\n+   --  allocation of necessary data structures. Particularly useful when\n+   --  dynamic allocation is not desired. The model is that each Element\n+   --  contains its own Key that can be retrieved by Get_Key. Furthermore,\n+   --  Element provides a link that can be used by the HTable for linking\n+   --  elements with same hash codes:\n+\n+   --       Element\n+\n+   --         +-------------------+\n+   --         |       Key         |\n+   --         +-------------------+\n+   --         :    other data     :\n+   --         +-------------------+\n+   --         |     Next Elmt     |\n+   --         +-------------------+\n+\n+   generic\n+      type Header_Num is range <>;\n+      --  An integer type indicating the number and range of hash headers.\n+\n+      type Element (<>) is limited private;\n+      --  The type of element to be stored\n+\n+      type Elmt_Ptr is private;\n+      --  The type used to reference an element (will usually be an access\n+      --  type, but could be some other form of type such as an integer type).\n+\n+      Null_Ptr : Elmt_Ptr;\n+      --  The null value of the Elmt_Ptr type.\n+\n+      with procedure Set_Next (E : Elmt_Ptr; Next : Elmt_Ptr);\n+      with function  Next     (E : Elmt_Ptr) return Elmt_Ptr;\n+      --  The type must provide an internal link for the sake of the\n+      --  staticness of the HTable.\n+\n+      type Key is limited private;\n+      with function Get_Key (E : Elmt_Ptr) return Key;\n+      with function Hash    (F : Key)      return Header_Num;\n+      with function Equal   (F1, F2 : Key) return Boolean;\n+\n+   package Static_HTable is\n+\n+      procedure Reset;\n+      --  Resets the hash table by setting all its elements to Null_Ptr. The\n+      --  effect is to clear the hash table so that it can be reused. For the\n+      --  most common case where Elmt_Ptr is an access type, and Null_Ptr is\n+      --  null, this is only needed if the same table is reused in a new\n+      --  context. If Elmt_Ptr is other than an access type, or Null_Ptr is\n+      --  other than null, then Reset must be called before the first use\n+      --  of the hash table.\n+\n+      procedure Set (E : Elmt_Ptr);\n+      --  Insert the element pointer in the HTable\n+\n+      function Get (K : Key) return Elmt_Ptr;\n+      --  Returns the latest inserted element pointer with the given Key\n+      --  or null if none.\n+\n+      procedure Remove (K : Key);\n+      --  Removes the latest inserted element pointer associated with the\n+      --  given key if any, does nothing if none.\n+\n+      function Get_First return Elmt_Ptr;\n+      --  Returns Null_Ptr if the Htable is empty, otherwise returns one\n+      --  non specified element. There is no guarantee that 2 calls to this\n+      --  function will return the same element.\n+\n+      function Get_Next return Elmt_Ptr;\n+      --  Returns a non-specified element that has not been returned by the\n+      --  same function since the last call to Get_First or Null_Ptr if\n+      --  there is no such element or Get_First has bever been called. If\n+      --  there is no call to 'Set' in between Get_Next calls, all the\n+      --  elements of the Htable will be traversed.\n+\n+   end Static_HTable;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   --  A generic hashing function working on String keys\n+\n+   generic\n+      type Header_Num is range <>;\n+   function Hash (Key : String) return Header_Num;\n+\n+end GNAT.HTable;"}, {"sha": "561ebf22e215f7268c260a857fbc1805e368f936", "filename": "gcc/ada/g-io.adb", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-io.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,200 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                              G N A T . I O                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--           Copyright (C) 1995-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.IO is\n+\n+   Current_Out : File_Type := Stdout;\n+   pragma Atomic (Current_Out);\n+   --  Current output file (modified by Set_Output)\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get (X : out Integer) is\n+\n+      function Get_Int return Integer;\n+      pragma Import (C, Get_Int, \"get_int\");\n+\n+   begin\n+      X := Get_Int;\n+   end Get;\n+\n+   procedure Get (C : out Character) is\n+\n+      function Get_Char return Character;\n+      pragma Import (C, Get_Char, \"get_char\");\n+\n+   begin\n+      C := Get_Char;\n+   end Get;\n+\n+   --------------\n+   -- Get_Line --\n+   --------------\n+\n+   procedure Get_Line (Item : in out String; Last : out Natural) is\n+      C : Character;\n+\n+   begin\n+      for Nstore in Item'Range loop\n+         Get (C);\n+\n+         if C = ASCII.LF then\n+            Last := Nstore - 1;\n+            return;\n+\n+         else\n+            Item (Nstore) := C;\n+         end if;\n+      end loop;\n+\n+      Last := Item'Last;\n+   end Get_Line;\n+\n+   --------------\n+   -- New_Line --\n+   --------------\n+\n+   procedure New_Line (File : File_Type; Spacing : Positive := 1) is\n+   begin\n+      for J in 1 .. Spacing loop\n+         Put (File, ASCII.LF);\n+      end loop;\n+   end New_Line;\n+\n+   procedure New_Line (Spacing : Positive := 1) is\n+   begin\n+      New_Line (Current_Out, Spacing);\n+   end New_Line;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put (X : Integer) is\n+   begin\n+      Put (Current_Out, X);\n+   end Put;\n+\n+   procedure Put (File : File_Type; X : Integer) is\n+\n+      procedure Put_Int (X : Integer);\n+      pragma Import (C, Put_Int, \"put_int\");\n+\n+      procedure Put_Int_Stderr (X : Integer);\n+      pragma Import (C, Put_Int_Stderr, \"put_int_stderr\");\n+\n+   begin\n+      case File is\n+         when Stdout => Put_Int (X);\n+         when Stderr => Put_Int_Stderr (X);\n+      end case;\n+   end Put;\n+\n+   procedure Put (C : Character) is\n+   begin\n+      Put (Current_Out, C);\n+   end Put;\n+\n+   procedure Put (File : in File_Type; C : Character) is\n+\n+      procedure Put_Char (C : Character);\n+      pragma Import (C, Put_Char, \"put_char\");\n+\n+      procedure Put_Char_Stderr (C : Character);\n+      pragma Import (C, Put_Char_Stderr, \"put_char_stderr\");\n+\n+   begin\n+      case File is\n+         when Stdout => Put_Char (C);\n+         when Stderr => Put_Char_Stderr (C);\n+      end case;\n+   end Put;\n+\n+   procedure Put (S : String) is\n+   begin\n+      Put (Current_Out, S);\n+   end Put;\n+\n+   procedure Put (File : File_Type; S : String) is\n+   begin\n+      for J in S'Range loop\n+         Put (File, S (J));\n+      end loop;\n+   end Put;\n+\n+   --------------\n+   -- Put_Line --\n+   --------------\n+\n+   procedure Put_Line (S : String) is\n+   begin\n+      Put_Line (Current_Out, S);\n+   end Put_Line;\n+\n+   procedure Put_Line (File : File_Type; S : String) is\n+   begin\n+      Put (File, S);\n+      New_Line (File);\n+   end Put_Line;\n+\n+   ----------------\n+   -- Set_Output --\n+   ----------------\n+\n+   procedure Set_Output (File : in File_Type) is\n+   begin\n+      Current_Out := File;\n+   end Set_Output;\n+\n+   ---------------------\n+   -- Standard_Output --\n+   ---------------------\n+\n+   function Standard_Output return File_Type is\n+   begin\n+      return Stdout;\n+   end Standard_Output;\n+\n+   --------------------\n+   -- Standard_Error --\n+   --------------------\n+\n+   function Standard_Error return File_Type is\n+   begin\n+      return Stderr;\n+   end Standard_Error;\n+\n+end GNAT.IO;"}, {"sha": "9b91406e86477dadb1400dd2f1eb79b6d5b62577", "filename": "gcc/ada/g-io.ads", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-io.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,94 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                              G N A T . I O                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--           Copyright (C) 1995-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  A simple preelaborable subset of Text_IO capabilities\n+\n+--  A simple text I/O package that can be used for simple I/O functions in\n+--  user programs as required. This package is also preelaborated, unlike\n+--  Text_Io, and can thus be with'ed by preelaborated library units.\n+\n+--  Note that Data_Error is not raised by these subprograms for bad data.\n+--  If such checks are needed then the regular Text_IO package such be used.\n+\n+package GNAT.IO is\n+pragma Preelaborate (IO);\n+\n+   type File_Type is limited private;\n+   --  Specifies file to be used (the only possibilities are Standard_Output\n+   --  and Standard_Error). There is no Create or Open facility that would\n+   --  allow more general use of file names.\n+\n+   function Standard_Output return File_Type;\n+   function Standard_Error  return File_Type;\n+   --  These functions are the only way to get File_Type values\n+\n+   procedure Get (X : out Integer);\n+   procedure Get (C : out Character);\n+   procedure Get_Line (Item : in out String; Last : out Natural);\n+   --  These routines always read from Standard_Input\n+\n+   procedure Put (File : File_Type; X : Integer);\n+   procedure Put (X : Integer);\n+   --  Output integer to specified file, or to current output file, same\n+   --  output as if Ada.Text_IO.Integer_IO had been instantiated for Integer.\n+\n+   procedure Put (File : File_Type; C : Character);\n+   procedure Put (C : Character);\n+   --  Output character to specified file, or to current output file\n+\n+   procedure Put (File : File_Type; S : String);\n+   procedure Put (S : String);\n+   --  Output string to specified file, or to current output file\n+\n+   procedure Put_Line (File : File_Type; S : String);\n+   procedure Put_Line (S : String);\n+   --  Output string followed by new line to specified file, or to\n+   --  current output file.\n+\n+   procedure New_Line (File : File_Type; Spacing : Positive := 1);\n+   procedure New_Line (Spacing : Positive := 1);\n+   --  Output new line character to specified file, or to current output file\n+\n+   procedure Set_Output (File : File_Type);\n+   --  Set current output file, default is Standard_Output if no call to\n+   --  Set_Output is made.\n+\n+private\n+   type File_Type is (Stdout, Stderr);\n+   --  Stdout = Standard_Output, Stderr = Standard_Error\n+\n+   pragma Inline (Standard_Error);\n+   pragma Inline (Standard_Output);\n+\n+end GNAT.IO;"}, {"sha": "95afbc548a2d7b3865cba257dbda648c42312d46", "filename": "gcc/ada/g-io_aux.adb", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-io_aux.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,108 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . I O _ A U X                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--           Copyright (C) 1995-2000 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C_Streams; use Interfaces.C_Streams;\n+\n+package body GNAT.IO_Aux is\n+\n+   Buflen : constant := 2000;\n+   --  Buffer length. Works for any non-zero value, larger values take\n+   --  more stack space, smaller values require more recursion.\n+\n+   -----------------\n+   -- File_Exists --\n+   -----------------\n+\n+   function File_Exists (Name : String) return Boolean\n+   is\n+      Namestr : aliased String (1 .. Name'Length + 1);\n+      --  Name as given with ASCII.NUL appended\n+\n+   begin\n+      Namestr (1 .. Name'Length) := Name;\n+      Namestr (Name'Length + 1)  := ASCII.NUL;\n+      return file_exists (Namestr'Address) /= 0;\n+   end File_Exists;\n+\n+   --------------\n+   -- Get_Line --\n+   --------------\n+\n+   --  Current_Input case\n+\n+   function Get_Line return String is\n+      Buffer : String (1 .. Buflen);\n+      --  Buffer to read in chunks of remaining line. Will work with any\n+      --  size buffer. We choose a length so that most of the time no\n+      --  recursion will be required.\n+\n+      Last : Natural;\n+\n+   begin\n+      Ada.Text_IO.Get_Line (Buffer, Last);\n+\n+      --  If the buffer is not full, then we are all done\n+\n+      if Last < Buffer'Last then\n+         return Buffer (1 .. Last);\n+\n+      --  Otherwise, we still have characters left on the line. Note that\n+      --  as specified by (RM A.10.7(19)) the end of line is not skipped\n+      --  in this case, even if we are right at it now.\n+\n+      else\n+         return Buffer & GNAT.IO_Aux.Get_Line;\n+      end if;\n+   end Get_Line;\n+\n+   --  Case of reading from a specified file. Note that we could certainly\n+   --  share code between these two versions, but these are very short\n+   --  routines, and we may as well aim for maximum speed, cutting out an\n+   --  intermediate call (calls returning string may be somewhat slow)\n+\n+   function Get_Line (File : Ada.Text_IO.File_Type) return String is\n+      Buffer : String (1 .. Buflen);\n+      Last   : Natural;\n+\n+   begin\n+      Ada.Text_IO.Get_Line (File, Buffer, Last);\n+\n+      if Last < Buffer'Last then\n+         return Buffer (1 .. Last);\n+      else\n+         return Buffer & Get_Line (File);\n+      end if;\n+   end Get_Line;\n+\n+end GNAT.IO_Aux;"}, {"sha": "379d84abdf75b2ee596c529447420ba25273d458", "filename": "gcc/ada/g-io_aux.ads", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-io_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-io_aux.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . I O _ A U X                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+--           Copyright (C) 1995-1998 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Auxiliary functions or use with Text_IO\n+\n+--  This package provides some auxiliary functions for use with Text_IO,\n+--  including a test for an existing file, and a Get_Line function which\n+--  returns a string.\n+\n+with Ada.Text_IO;\n+\n+package GNAT.IO_Aux is\n+\n+   function File_Exists (Name : String) return Boolean;\n+   --  Test for existence of a file named Name\n+\n+   function Get_Line return String;\n+   --  Read Ada.Text_IO.Current_Input and return string that includes all\n+   --  characters from the current character up to the end of the line,\n+   --  with no limit on its length. Raises Ada.IO_Exceptions.End_Error if\n+   --  at end of file.\n+\n+   function Get_Line (File : Ada.Text_IO.File_Type) return String;\n+   --  Same, but reads from specified file\n+\n+end GNAT.IO_Aux;"}, {"sha": "3f263f7b6549c119d1c5fdd047e256f69741e5f1", "filename": "gcc/ada/g-locfil.adb", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-locfil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-locfil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-locfil.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,116 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      G N A T . L O C K _ F I L E S                       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--          Copyright (C) 1998-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+\n+package body GNAT.Lock_Files is\n+\n+   Dir_Separator : Character;\n+   pragma Import (C, Dir_Separator, \"__gnat_dir_separator\");\n+\n+   ---------------\n+   -- Lock_File --\n+   ---------------\n+\n+   procedure Lock_File\n+     (Directory      : String;\n+      Lock_File_Name : String;\n+      Wait           : Duration := 1.0;\n+      Retries        : Natural  := Natural'Last)\n+   is\n+      Dir  : aliased String := Directory & ASCII.NUL;\n+      File : aliased String := Lock_File_Name & ASCII.NUL;\n+\n+      function Try_Lock (Dir, File : System.Address) return Integer;\n+      pragma Import (C, Try_Lock, \"__gnat_try_lock\");\n+\n+   begin\n+      for I in 0 .. Retries loop\n+         if Try_Lock (Dir'Address, File'Address) = 1 then\n+            return;\n+         end if;\n+         exit when I = Retries;\n+         delay Wait;\n+      end loop;\n+      raise Lock_Error;\n+   end Lock_File;\n+\n+   ---------------\n+   -- Lock_File --\n+   ---------------\n+\n+   procedure Lock_File\n+     (Lock_File_Name : String;\n+      Wait           : Duration := 1.0;\n+      Retries        : Natural  := Natural'Last)\n+   is\n+   begin\n+      for J in reverse Lock_File_Name'Range loop\n+         if Lock_File_Name (J) = Dir_Separator then\n+            Lock_File\n+              (Lock_File_Name (Lock_File_Name'First .. J - 1),\n+               Lock_File_Name (J + 1 .. Lock_File_Name'Last),\n+               Wait,\n+               Retries);\n+            return;\n+         end if;\n+      end loop;\n+\n+      Lock_File (\".\", Lock_File_Name, Wait, Retries);\n+   end Lock_File;\n+\n+   -----------------\n+   -- Unlock_File --\n+   -----------------\n+\n+   procedure Unlock_File (Lock_File_Name : String) is\n+      S : aliased String := Lock_File_Name & ASCII.NUL;\n+\n+      procedure unlink (A : System.Address);\n+      pragma Import (C, unlink, \"unlink\");\n+\n+   begin\n+      unlink (S'Address);\n+   end Unlock_File;\n+\n+   -----------------\n+   -- Unlock_File --\n+   -----------------\n+\n+   procedure Unlock_File (Directory : String; Lock_File_Name : String) is\n+   begin\n+      Unlock_File (Directory & Dir_Separator & Lock_File_Name);\n+   end Unlock_File;\n+\n+end GNAT.Lock_Files;"}, {"sha": "47715c69bee14805e55995ccac47b8b19321070f", "filename": "gcc/ada/g-locfil.ads", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-locfil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-locfil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-locfil.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,67 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      G N A T . L O C K _ F I L E S                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--           Copyright (C) 1995-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+   --  This package contains the necessary routines for using files for the\n+   --  purpose of providing realiable system wide locking capability.\n+\n+package GNAT.Lock_Files is\n+pragma Preelaborate;\n+\n+   Lock_Error : exception;\n+   --  Exception raised if file cannot be locked\n+\n+   procedure Lock_File\n+     (Directory      : String;\n+      Lock_File_Name : String;\n+      Wait           : Duration := 1.0;\n+      Retries        : Natural  := Natural'Last);\n+   --  Create a lock file Lock_File_Name in directory Directory. If the file\n+   --  cannot be locked because someone already owns the lock, this procedure\n+   --  waits Wait seconds and retries at most Retries times. If the file\n+   --  still cannot be locked, Lock_Error is raised. The default is to try\n+   --  every second, almost forever (Natural'Last times).\n+\n+   procedure Lock_File\n+     (Lock_File_Name : String;\n+      Wait           : Duration := 1.0;\n+      Retries        : Natural  := Natural'Last);\n+   --  See above. The full lock file path is given as one string.\n+\n+   procedure Unlock_File (Directory : String; Lock_File_Name : String);\n+   --  Unlock a file\n+\n+   procedure Unlock_File (Lock_File_Name : String);\n+   --  Unlock a file whose full path is given in Lock_File_Name\n+\n+end GNAT.Lock_Files;"}, {"sha": "35f5601537084bba632280d73cae08d6b18cb359", "filename": "gcc/ada/g-moreex.adb", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-moreex.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-moreex.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-moreex.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,85 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--            G N A T . M O S T _ R E C E N T _ E X C E P T I O N           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--              Copyright (C) 2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Exceptions.Is_Null_Occurrence;\n+with System.Soft_Links;\n+\n+package body GNAT.Most_Recent_Exception is\n+\n+   ----------------\n+   -- Occurrence --\n+   ----------------\n+\n+   function Occurrence\n+     return Ada.Exceptions.Exception_Occurrence\n+   is\n+      EOA : constant Ada.Exceptions.Exception_Occurrence_Access :=\n+              GNAT.Most_Recent_Exception.Occurrence_Access;\n+\n+      use type Ada.Exceptions.Exception_Occurrence_Access;\n+\n+   begin\n+      if EOA = null then\n+         return Ada.Exceptions.Null_Occurrence;\n+      else\n+         return EOA.all;\n+      end if;\n+   end Occurrence;\n+\n+   -----------------------\n+   -- Occurrence_Access --\n+   -----------------------\n+\n+   function Occurrence_Access\n+     return Ada.Exceptions.Exception_Occurrence_Access\n+   is\n+      use Ada.Exceptions;\n+\n+      EOA : constant Exception_Occurrence_Access :=\n+              System.Soft_Links.Get_Current_Excep.all;\n+\n+   begin\n+      if EOA = null then\n+         return null;\n+\n+      elsif Is_Null_Occurrence (EOA.all) then\n+         return null;\n+\n+      else\n+         return EOA;\n+      end if;\n+   end Occurrence_Access;\n+\n+end GNAT.Most_Recent_Exception;"}, {"sha": "c5216076e0ff063a545568c1f66c0d16075fb56d", "filename": "gcc/ada/g-moreex.ads", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-moreex.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-moreex.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-moreex.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,79 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--            G N A T . M O S T _ R E C E N T _ E X C E P T I O N           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--              Copyright (C) 2000 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides routines for accessing the most recently raised\n+--  exception. This may be useful for certain logging activities. It may\n+--  also be useful for mimicing implementation dependent capabilities in\n+--  Ada 83 compilers, but see also GNAT.Current_Exceptions for this usage.\n+\n+with Ada.Exceptions;\n+package GNAT.Most_Recent_Exception is\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   function Occurrence\n+     return Ada.Exceptions.Exception_Occurrence;\n+   --  Returns the Exception_Occurrence for the most recently raised\n+   --  exception in the current task. If no exception has been raised\n+   --  in the current task prior to the call, returns Null_Occurrence.\n+\n+   function Occurrence_Access\n+     return Ada.Exceptions.Exception_Occurrence_Access;\n+   --  Similar to the above, but returns an access to the occurrence value.\n+   --  This value is in a task specific location, and may be validly accessed\n+   --  as long as no further exception is raised in the calling task.\n+\n+   --  Note: unlike the routines in GNAT.Current_Exception, these functions\n+   --  access the most recently raised exception, regardless of where they\n+   --  are called. Consider the following example:\n+\n+   --     exception\n+   --        when Constraint_Error =>\n+   --          begin\n+   --             ...\n+   --          exception\n+   --             when Tasking_Error => ...\n+   --          end;\n+   --\n+   --          --  Assuming a Tasking_Error was raised in the inner block,\n+   --          --  a call to GNAT.Most_Recent_Exception.Occurrence will\n+   --          --  return information about this Tasking_Error exception,\n+   --          --  not about the Constraint_Error exception being handled\n+   --          --  by the current handler code.\n+\n+\n+end GNAT.Most_Recent_Exception;"}, {"sha": "ef7968d9b73f7fbae4613e4be4315c34d83ca0e9", "filename": "gcc/ada/g-os_lib.adb", "status": "added", "additions": 1347, "deletions": 0, "changes": 1347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,1347 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G N A T . O S _ L I B                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.74 $\n+--                                                                          --\n+--           Copyright (C) 1995-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Soft_Links;\n+with Unchecked_Conversion;\n+with System; use System;\n+\n+package body GNAT.OS_Lib is\n+\n+   package SSL renames System.Soft_Links;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Args_Length (Args : Argument_List) return Natural;\n+   --  Returns total number of characters needed to create a string\n+   --  of all Args terminated by ASCII.NUL characters\n+\n+   function C_String_Length (S : Address) return Integer;\n+   --  Returns the length of a C string. Does check for null address\n+   --  (returns 0).\n+\n+   procedure Spawn_Internal\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Result       : out Integer;\n+      Pid          : out Process_Id;\n+      Blocking     : Boolean);\n+   --  Internal routine to implement the to Spawn (blocking and non blocking)\n+   --  routines. If Blocking is set to True then the spawn is blocking\n+   --  otherwise it is non blocking. In this latter case the Pid contains\n+   --  the process id number. The first three parameters are as in Spawn.\n+\n+   function To_Path_String_Access\n+     (Path_Addr : Address;\n+      Path_Len  : Integer)\n+      return      String_Access;\n+   --  Converts a C String to an Ada String. We could do this making use of\n+   --  Interfaces.C.Strings but we prefer not to import that entire package\n+\n+   -----------------\n+   -- Args_Length --\n+   -----------------\n+\n+   function Args_Length (Args : Argument_List) return Natural is\n+      Len : Natural := 0;\n+\n+   begin\n+      for J in Args'Range loop\n+         Len := Len + Args (J)'Length + 1; --  One extra for ASCII.NUL\n+      end loop;\n+\n+      return Len;\n+   end Args_Length;\n+\n+   -----------------------------\n+   -- Argument_String_To_List --\n+   -----------------------------\n+\n+   function Argument_String_To_List\n+     (Arg_String : String)\n+      return       Argument_List_Access\n+   is\n+      Max_Args : Integer := Arg_String'Length;\n+      New_Argv : Argument_List (1 .. Max_Args);\n+      New_Argc : Natural := 0;\n+      Idx      : Integer;\n+\n+   begin\n+      Idx := Arg_String'First;\n+\n+      loop\n+         declare\n+            Quoted   : Boolean := False;\n+            Backqd   : Boolean := False;\n+            Old_Idx  : Integer;\n+\n+         begin\n+            Old_Idx := Idx;\n+\n+            loop\n+               --  A vanilla space is the end of an argument\n+\n+               if not Backqd and then not Quoted\n+                 and then Arg_String (Idx) = ' '\n+               then\n+                  exit;\n+\n+               --  Start of a quoted string\n+\n+               elsif not Backqd and then not Quoted\n+                 and then Arg_String (Idx) = '\"'\n+               then\n+                  Quoted := True;\n+\n+               --  End of a quoted string and end of an argument\n+\n+               elsif not Backqd and then Quoted\n+                 and then Arg_String (Idx) = '\"'\n+               then\n+                  Idx := Idx + 1;\n+                  exit;\n+\n+               --  Following character is backquoted\n+\n+               elsif Arg_String (Idx) = '\\' then\n+                  Backqd := True;\n+\n+               --  Turn off backquoting after advancing one character\n+\n+               elsif Backqd then\n+                  Backqd := False;\n+\n+               end if;\n+\n+               Idx := Idx + 1;\n+               exit when Idx > Arg_String'Last;\n+            end loop;\n+\n+            --  Found an argument\n+\n+            New_Argc := New_Argc + 1;\n+            New_Argv (New_Argc) :=\n+              new String'(Arg_String (Old_Idx .. Idx - 1));\n+\n+            --  Skip extraneous spaces\n+\n+            while Idx <= Arg_String'Last and then Arg_String (Idx) = ' ' loop\n+               Idx := Idx + 1;\n+            end loop;\n+         end;\n+\n+         exit when Idx > Arg_String'Last;\n+      end loop;\n+\n+      return new Argument_List'(New_Argv (1 .. New_Argc));\n+   end Argument_String_To_List;\n+\n+   ---------------------\n+   -- C_String_Length --\n+   ---------------------\n+\n+   function C_String_Length (S : Address) return Integer is\n+      function Strlen (S : Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+\n+   begin\n+      if S = Null_Address then\n+         return 0;\n+      else\n+         return Strlen (S);\n+      end if;\n+   end C_String_Length;\n+\n+   -----------------\n+   -- Create_File --\n+   -----------------\n+\n+   function Create_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      function C_Create_File\n+        (Name  : C_File_Name;\n+         Fmode : Mode)\n+         return  File_Descriptor;\n+      pragma Import (C, C_Create_File, \"__gnat_open_create\");\n+\n+   begin\n+      return C_Create_File (Name, Fmode);\n+   end Create_File;\n+\n+   function Create_File\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Create_File (C_Name (C_Name'First)'Address, Fmode);\n+   end Create_File;\n+\n+   ---------------------\n+   -- Create_New_File --\n+   ---------------------\n+\n+   function Create_New_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      function C_Create_New_File\n+        (Name  : C_File_Name;\n+         Fmode : Mode)\n+         return  File_Descriptor;\n+      pragma Import (C, C_Create_New_File, \"__gnat_open_new\");\n+\n+   begin\n+      return C_Create_New_File (Name, Fmode);\n+   end Create_New_File;\n+\n+   function Create_New_File\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Create_New_File (C_Name (C_Name'First)'Address, Fmode);\n+   end Create_New_File;\n+\n+   ----------------------\n+   -- Create_Temp_File --\n+   ----------------------\n+\n+   procedure Create_Temp_File\n+     (FD   : out File_Descriptor;\n+      Name : out Temp_File_Name)\n+   is\n+      function Open_New_Temp\n+        (Name  : System.Address;\n+         Fmode : Mode)\n+         return  File_Descriptor;\n+      pragma Import (C, Open_New_Temp, \"__gnat_open_new_temp\");\n+\n+   begin\n+      FD := Open_New_Temp (Name'Address, Binary);\n+   end Create_Temp_File;\n+\n+   -----------------\n+   -- Delete_File --\n+   -----------------\n+\n+   procedure Delete_File (Name : Address; Success : out Boolean) is\n+      R : Integer;\n+\n+      function unlink (A : Address) return Integer;\n+      pragma Import (C, unlink, \"unlink\");\n+\n+   begin\n+      R := unlink (Name);\n+      Success := (R = 0);\n+   end Delete_File;\n+\n+   procedure Delete_File (Name : String; Success : out Boolean) is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+\n+      Delete_File (C_Name'Address, Success);\n+   end Delete_File;\n+\n+   ---------------------\n+   -- File_Time_Stamp --\n+   ---------------------\n+\n+   function File_Time_Stamp (FD : File_Descriptor) return OS_Time is\n+      function File_Time (FD    : File_Descriptor) return OS_Time;\n+      pragma Import (C, File_Time, \"__gnat_file_time_fd\");\n+\n+   begin\n+      return File_Time (FD);\n+   end File_Time_Stamp;\n+\n+   function File_Time_Stamp (Name : C_File_Name) return OS_Time is\n+      function File_Time (Name : Address) return OS_Time;\n+      pragma Import (C, File_Time, \"__gnat_file_time_name\");\n+\n+   begin\n+      return File_Time (Name);\n+   end File_Time_Stamp;\n+\n+   function File_Time_Stamp (Name : String) return OS_Time is\n+      F_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return File_Time_Stamp (F_Name'Address);\n+   end File_Time_Stamp;\n+\n+   ---------------------------\n+   -- Get_Debuggable_Suffix --\n+   ---------------------------\n+\n+   function Get_Debuggable_Suffix return String_Access is\n+      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_debuggable_suffix_ptr\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Suffix_Ptr    : Address;\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Debuggable_Suffix;\n+\n+   ---------------------------\n+   -- Get_Executable_Suffix --\n+   ---------------------------\n+\n+   function Get_Executable_Suffix return String_Access is\n+      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_executable_suffix_ptr\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Suffix_Ptr    : Address;\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Executable_Suffix;\n+\n+   -----------------------\n+   -- Get_Object_Suffix --\n+   -----------------------\n+\n+   function Get_Object_Suffix return String_Access is\n+      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_object_suffix_ptr\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Suffix_Ptr    : Address;\n+      Suffix_Length : Integer;\n+      Result        : String_Access;\n+\n+   begin\n+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n+\n+      Result := new String (1 .. Suffix_Length);\n+\n+      if Suffix_Length > 0 then\n+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n+      end if;\n+\n+      return Result;\n+   end Get_Object_Suffix;\n+\n+   ------------\n+   -- Getenv --\n+   ------------\n+\n+   function Getenv (Name : String) return String_Access is\n+      procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n+      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_get_env_value_ptr\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Env_Value_Ptr    : Address;\n+      Env_Value_Length : Integer;\n+      F_Name           : String (1 .. Name'Length + 1);\n+      Result           : String_Access;\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      Get_Env_Value_Ptr\n+        (F_Name'Address, Env_Value_Length'Address, Env_Value_Ptr'Address);\n+\n+      Result := new String (1 .. Env_Value_Length);\n+\n+      if Env_Value_Length > 0 then\n+         Strncpy (Result.all'Address, Env_Value_Ptr, Env_Value_Length);\n+      end if;\n+\n+      return Result;\n+   end Getenv;\n+\n+   ------------\n+   -- GM_Day --\n+   ------------\n+\n+   function GM_Day (Date : OS_Time) return Day_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return D;\n+   end GM_Day;\n+\n+   -------------\n+   -- GM_Hour --\n+   -------------\n+\n+   function GM_Hour (Date : OS_Time) return Hour_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return H;\n+   end GM_Hour;\n+\n+   ---------------\n+   -- GM_Minute --\n+   ---------------\n+\n+   function GM_Minute (Date : OS_Time) return Minute_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return Mn;\n+   end GM_Minute;\n+\n+   --------------\n+   -- GM_Month --\n+   --------------\n+\n+   function GM_Month (Date : OS_Time) return Month_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return Mo;\n+   end GM_Month;\n+\n+   ---------------\n+   -- GM_Second --\n+   ---------------\n+\n+   function GM_Second (Date : OS_Time) return Second_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return S;\n+   end GM_Second;\n+\n+   --------------\n+   -- GM_Split --\n+   --------------\n+\n+   procedure GM_Split\n+     (Date   : OS_Time;\n+      Year   : out Year_Type;\n+      Month  : out Month_Type;\n+      Day    : out Day_Type;\n+      Hour   : out Hour_Type;\n+      Minute : out Minute_Type;\n+      Second : out Second_Type)\n+   is\n+      procedure To_GM_Time\n+        (P_Time_T, P_Year, P_Month, P_Day, P_Hours, P_Mins, P_Secs : Address);\n+      pragma Import (C, To_GM_Time, \"__gnat_to_gm_time\");\n+\n+      T  : OS_Time := Date;\n+      Y  : Integer;\n+      Mo : Integer;\n+      D  : Integer;\n+      H  : Integer;\n+      Mn : Integer;\n+      S  : Integer;\n+\n+   begin\n+      --  Use the global lock because To_GM_Time is not thread safe.\n+\n+      Locked_Processing : begin\n+         SSL.Lock_Task.all;\n+         To_GM_Time\n+           (T'Address, Y'Address, Mo'Address, D'Address,\n+            H'Address, Mn'Address, S'Address);\n+         SSL.Unlock_Task.all;\n+\n+      exception\n+         when others =>\n+            SSL.Unlock_Task.all;\n+            raise;\n+      end Locked_Processing;\n+\n+      Year   := Y + 1900;\n+      Month  := Mo + 1;\n+      Day    := D;\n+      Hour   := H;\n+      Minute := Mn;\n+      Second := S;\n+   end GM_Split;\n+\n+   -------------\n+   -- GM_Year --\n+   -------------\n+\n+   function GM_Year (Date : OS_Time) return Year_Type is\n+      Y  : Year_Type;\n+      Mo : Month_Type;\n+      D  : Day_Type;\n+      H  : Hour_Type;\n+      Mn : Minute_Type;\n+      S  : Second_Type;\n+\n+   begin\n+      GM_Split (Date, Y, Mo, D, H, Mn, S);\n+      return Y;\n+   end GM_Year;\n+\n+   ----------------------\n+   -- Is_Absolute_Path --\n+   ----------------------\n+\n+   function Is_Absolute_Path (Name : String) return Boolean is\n+      function Is_Absolute_Path (Name : Address) return Integer;\n+      pragma Import (C, Is_Absolute_Path, \"__gnat_is_absolute_path\");\n+\n+      F_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      return Is_Absolute_Path (F_Name'Address) /= 0;\n+   end Is_Absolute_Path;\n+\n+   ------------------\n+   -- Is_Directory --\n+   ------------------\n+\n+   function Is_Directory (Name : C_File_Name) return Boolean is\n+      function Is_Directory (Name : Address) return Integer;\n+      pragma Import (C, Is_Directory, \"__gnat_is_directory\");\n+\n+   begin\n+      return Is_Directory (Name) /= 0;\n+   end Is_Directory;\n+\n+   function Is_Directory (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Directory (F_Name'Address);\n+   end Is_Directory;\n+\n+   ---------------------\n+   -- Is_Regular_File --\n+   ---------------------\n+\n+   function Is_Regular_File (Name : C_File_Name) return Boolean is\n+      function Is_Regular_File (Name : Address) return Integer;\n+      pragma Import (C, Is_Regular_File, \"__gnat_is_regular_file\");\n+\n+   begin\n+      return Is_Regular_File (Name) /= 0;\n+   end Is_Regular_File;\n+\n+   function Is_Regular_File (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Regular_File (F_Name'Address);\n+   end Is_Regular_File;\n+\n+   ----------------------\n+   -- Is_Writable_File --\n+   ----------------------\n+\n+   function Is_Writable_File (Name : C_File_Name) return Boolean is\n+      function Is_Writable_File (Name : Address) return Integer;\n+      pragma Import (C, Is_Writable_File, \"__gnat_is_writable_file\");\n+\n+   begin\n+      return Is_Writable_File (Name) /= 0;\n+   end Is_Writable_File;\n+\n+   function Is_Writable_File (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Writable_File (F_Name'Address);\n+   end Is_Writable_File;\n+\n+   -------------------------\n+   -- Locate_Exec_On_Path --\n+   -------------------------\n+\n+   function Locate_Exec_On_Path\n+     (Exec_Name : String)\n+      return      String_Access\n+   is\n+      function Locate_Exec_On_Path (C_Exec_Name : Address) return Address;\n+      pragma Import (C, Locate_Exec_On_Path, \"__gnat_locate_exec_on_path\");\n+\n+      procedure Free (Ptr : System.Address);\n+      pragma Import (C, Free, \"free\");\n+\n+      C_Exec_Name  : String (1 .. Exec_Name'Length + 1);\n+      Path_Addr    : Address;\n+      Path_Len     : Integer;\n+      Result       : String_Access;\n+\n+   begin\n+      C_Exec_Name (1 .. Exec_Name'Length)   := Exec_Name;\n+      C_Exec_Name (C_Exec_Name'Last)        := ASCII.NUL;\n+\n+      Path_Addr := Locate_Exec_On_Path (C_Exec_Name'Address);\n+      Path_Len  := C_String_Length (Path_Addr);\n+\n+      if Path_Len = 0 then\n+         return null;\n+\n+      else\n+         Result := To_Path_String_Access (Path_Addr, Path_Len);\n+         Free (Path_Addr);\n+         return Result;\n+      end if;\n+   end Locate_Exec_On_Path;\n+\n+   -------------------------\n+   -- Locate_Regular_File --\n+   -------------------------\n+\n+   function Locate_Regular_File\n+     (File_Name : C_File_Name;\n+      Path      : C_File_Name)\n+      return      String_Access\n+   is\n+      function Locate_Regular_File\n+        (C_File_Name, Path_Val : Address) return Address;\n+      pragma Import (C, Locate_Regular_File, \"__gnat_locate_regular_file\");\n+\n+      procedure Free (Ptr : System.Address);\n+      pragma Import (C, Free, \"free\");\n+\n+      Path_Addr    : Address;\n+      Path_Len     : Integer;\n+      Result       : String_Access;\n+\n+   begin\n+      Path_Addr := Locate_Regular_File (File_Name, Path);\n+      Path_Len  := C_String_Length (Path_Addr);\n+\n+      if Path_Len = 0 then\n+         return null;\n+      else\n+         Result := To_Path_String_Access (Path_Addr, Path_Len);\n+         Free (Path_Addr);\n+         return Result;\n+      end if;\n+   end Locate_Regular_File;\n+\n+   function Locate_Regular_File\n+     (File_Name : String;\n+      Path      : String)\n+      return      String_Access\n+   is\n+      C_File_Name : String (1 .. File_Name'Length + 1);\n+      C_Path      : String (1 .. Path'Length + 1);\n+\n+   begin\n+      C_File_Name (1 .. File_Name'Length)   := File_Name;\n+      C_File_Name (C_File_Name'Last)        := ASCII.NUL;\n+\n+      C_Path    (1 .. Path'Length)          := Path;\n+      C_Path    (C_Path'Last)               := ASCII.NUL;\n+\n+      return Locate_Regular_File (C_File_Name'Address, C_Path'Address);\n+   end Locate_Regular_File;\n+\n+   ------------------------\n+   -- Non_Blocking_Spawn --\n+   ------------------------\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List)\n+      return         Process_Id\n+   is\n+      Junk : Integer;\n+      Pid  : Process_Id;\n+\n+   begin\n+      Spawn_Internal (Program_Name, Args, Junk, Pid, Blocking => False);\n+      return Pid;\n+   end Non_Blocking_Spawn;\n+\n+   ------------------------\n+   -- Normalize_Pathname --\n+   ------------------------\n+\n+   function Normalize_Pathname\n+     (Name      : String;\n+      Directory : String := \"\")\n+      return      String\n+   is\n+      Max_Path : Integer;\n+      pragma Import (C, Max_Path, \"max_path_len\");\n+      --  Maximum length of a path name\n+\n+      procedure Get_Current_Dir\n+        (Dir    : System.Address;\n+         Length : System.Address);\n+      pragma Import (C, Get_Current_Dir, \"__gnat_get_current_dir\");\n+\n+      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);\n+      End_Path    : Natural := 0;\n+      Link_Buffer : String (1 .. Max_Path + 2);\n+      Status      : Integer;\n+      Last        : Positive;\n+      Start       : Natural;\n+      Finish      : Positive;\n+\n+      Max_Iterations : constant := 500;\n+\n+      function Readlink\n+        (Path   : System.Address;\n+         Buf    : System.Address;\n+         Bufsiz : Integer)\n+         return   Integer;\n+      pragma Import (C, Readlink, \"__gnat_readlink\");\n+\n+      function To_Canonical_File_Spec\n+        (Host_File : System.Address)\n+         return      System.Address;\n+      pragma Import\n+        (C, To_Canonical_File_Spec, \"__gnat_to_canonical_file_spec\");\n+\n+      The_Name : String (1 .. Name'Length + 1);\n+      Canonical_File_Addr : System.Address;\n+      Canonical_File_Len  : Integer;\n+\n+      function Strlen (S : System.Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+\n+      function Get_Directory return String;\n+      --  If Directory is not empty, return it, adding a directory separator\n+      --  if not already present, otherwise return current working directory\n+      --  with terminating directory separator.\n+\n+      -------------------\n+      -- Get_Directory --\n+      -------------------\n+\n+      function Get_Directory return String is\n+      begin\n+         --  Directory given, add directory separator if needed\n+\n+         if Directory'Length > 0 then\n+            if Directory (Directory'Length) = Directory_Separator then\n+               return Directory;\n+            else\n+               declare\n+                  Result : String (1 .. Directory'Length + 1);\n+\n+               begin\n+                  Result (1 .. Directory'Length) := Directory;\n+                  Result (Result'Length) := Directory_Separator;\n+                  return Result;\n+               end;\n+            end if;\n+\n+         --  Directory name not given, get current directory\n+\n+         else\n+            declare\n+               Buffer   : String (1 .. Max_Path + 2);\n+               Path_Len : Natural := Max_Path;\n+\n+            begin\n+               Get_Current_Dir (Buffer'Address, Path_Len'Address);\n+\n+               if Buffer (Path_Len) /= Directory_Separator then\n+                  Path_Len := Path_Len + 1;\n+                  Buffer (Path_Len) := Directory_Separator;\n+               end if;\n+\n+               return Buffer (1 .. Path_Len);\n+            end;\n+         end if;\n+      end Get_Directory;\n+\n+      Reference_Dir : constant String := Get_Directory;\n+      --  Current directory name specified\n+\n+   --  Start of processing for Normalize_Pathname\n+\n+   begin\n+      --  Special case, if name is null, then return null\n+\n+      if Name'Length = 0 then\n+         return \"\";\n+      end if;\n+\n+      --  First, convert VMS file spec to Unix file spec.\n+      --  If Name is not in VMS syntax, then this is equivalent\n+      --  to put Name at the begining of Path_Buffer.\n+\n+      VMS_Conversion : begin\n+         The_Name (1 .. Name'Length) := Name;\n+         The_Name (The_Name'Last) := ASCII.NUL;\n+\n+         Canonical_File_Addr := To_Canonical_File_Spec (The_Name'Address);\n+         Canonical_File_Len  := Strlen (Canonical_File_Addr);\n+\n+         --  If VMS syntax conversion has failed, return an empty string\n+         --  to indicate the failure.\n+\n+         if Canonical_File_Len = 0 then\n+            return \"\";\n+         end if;\n+\n+         declare\n+            subtype Path_String is String (1 .. Canonical_File_Len);\n+            type    Path_String_Access is access Path_String;\n+\n+            function Address_To_Access is new\n+               Unchecked_Conversion (Source => Address,\n+                                     Target => Path_String_Access);\n+\n+            Path_Access : Path_String_Access :=\n+                         Address_To_Access (Canonical_File_Addr);\n+\n+         begin\n+            Path_Buffer (1 .. Canonical_File_Len) := Path_Access.all;\n+            End_Path := Canonical_File_Len;\n+            Last := 1;\n+         end;\n+      end VMS_Conversion;\n+\n+      --  Replace all '/' by Directory Separators (this is for Windows)\n+\n+      if Directory_Separator /= '/' then\n+         for Index in 1 .. End_Path loop\n+            if Path_Buffer (Index) = '/' then\n+               Path_Buffer (Index) := Directory_Separator;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Start the conversions\n+\n+      --  If this is not finished after Max_Iterations, give up and\n+      --  return an empty string.\n+\n+      for J in 1 .. Max_Iterations loop\n+\n+         --  If we don't have an absolute pathname, prepend\n+         --  the directory Reference_Dir.\n+\n+         if Last = 1\n+           and then not Is_Absolute_Path (Path_Buffer (1 .. End_Path))\n+         then\n+            Path_Buffer\n+              (Reference_Dir'Last + 1 .. Reference_Dir'Length + End_Path) :=\n+                 Path_Buffer (1 .. End_Path);\n+            End_Path := Reference_Dir'Length + End_Path;\n+            Path_Buffer (1 .. Reference_Dir'Length) := Reference_Dir;\n+            Last := Reference_Dir'Length;\n+         end if;\n+\n+         Start  := Last + 1;\n+         Finish := Last;\n+\n+         --  If we have traversed the full pathname, return it\n+\n+         if Start > End_Path then\n+            return Path_Buffer (1 .. End_Path);\n+         end if;\n+\n+         --  Remove duplicate directory separators\n+\n+         while Path_Buffer (Start) = Directory_Separator loop\n+            if Start = End_Path then\n+               return Path_Buffer (1 .. End_Path - 1);\n+\n+            else\n+               Path_Buffer (Start .. End_Path - 1) :=\n+                 Path_Buffer (Start + 1 .. End_Path);\n+               End_Path := End_Path - 1;\n+            end if;\n+         end loop;\n+\n+         --  Find the end of the current field: last character\n+         --  or the one preceding the next directory separator.\n+\n+         while Finish < End_Path\n+           and then Path_Buffer (Finish + 1) /= Directory_Separator\n+         loop\n+            Finish := Finish + 1;\n+         end loop;\n+\n+         --  Remove \".\" field\n+\n+         if Start = Finish and then Path_Buffer (Start) = '.' then\n+            if Start = End_Path then\n+               if Last = 1 then\n+                  return (1 => Directory_Separator);\n+               else\n+                  return Path_Buffer (1 .. Last - 1);\n+               end if;\n+\n+            else\n+               Path_Buffer (Last + 1 .. End_Path - 2) :=\n+                 Path_Buffer (Last + 3 .. End_Path);\n+               End_Path := End_Path - 2;\n+            end if;\n+\n+         --  Remove \"..\" fields\n+\n+         elsif Finish = Start + 1\n+           and then Path_Buffer (Start .. Finish) = \"..\"\n+         then\n+            Start := Last;\n+            loop\n+               Start := Start - 1;\n+               exit when Start < 1 or else\n+                 Path_Buffer (Start) = Directory_Separator;\n+            end loop;\n+\n+            if Start <= 1 then\n+               if Finish = End_Path then\n+                  return (1 => Directory_Separator);\n+\n+               else\n+                  Path_Buffer (1 .. End_Path - Finish) :=\n+                    Path_Buffer (Finish + 1 .. End_Path);\n+                  End_Path := End_Path - Finish;\n+                  Last := 1;\n+               end if;\n+\n+            else\n+               if Finish = End_Path then\n+                  return Path_Buffer (1 .. Start - 1);\n+\n+               else\n+                  Path_Buffer (Start + 1 .. Start + End_Path - Finish - 1) :=\n+                    Path_Buffer (Finish + 2 .. End_Path);\n+                  End_Path := Start + End_Path - Finish - 1;\n+                  Last := Start;\n+               end if;\n+            end if;\n+\n+         --  Check if current field is a symbolic link\n+\n+         else\n+            declare\n+               Saved : Character := Path_Buffer (Finish + 1);\n+\n+            begin\n+               Path_Buffer (Finish + 1) := ASCII.NUL;\n+               Status := Readlink (Path_Buffer'Address,\n+                                   Link_Buffer'Address,\n+                                   Link_Buffer'Length);\n+               Path_Buffer (Finish + 1) := Saved;\n+            end;\n+\n+            --  Not a symbolic link, move to the next field, if any\n+\n+            if Status <= 0 then\n+               Last := Finish + 1;\n+\n+            --  Replace symbolic link with its value.\n+\n+            else\n+               if Is_Absolute_Path (Link_Buffer (1 .. Status)) then\n+                  Path_Buffer (Status + 1 .. End_Path - (Finish - Status)) :=\n+                  Path_Buffer (Finish + 1 .. End_Path);\n+                  End_Path := End_Path - (Finish - Status);\n+                  Path_Buffer (1 .. Status) := Link_Buffer (1 .. Status);\n+                  Last := 1;\n+\n+               else\n+                  Path_Buffer\n+                    (Last + Status + 1 .. End_Path - Finish + Last + Status) :=\n+                    Path_Buffer (Finish + 1 .. End_Path);\n+                  End_Path := End_Path - Finish + Last + Status;\n+                  Path_Buffer (Last + 1 .. Last + Status) :=\n+                    Link_Buffer (1 .. Status);\n+               end if;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Too many iterations: give up\n+\n+      --  This can happen when there is a circularity in the symbolic links:\n+      --  A is a symbolic link for B, which itself is a symbolic link, and\n+      --  the target of B or of another symbolic link target of B is A.\n+      --  In this case, we return an empty string to indicate failure to\n+      --  resolve.\n+\n+      return \"\";\n+   end Normalize_Pathname;\n+\n+   ---------------\n+   -- Open_Read --\n+   ---------------\n+\n+   function Open_Read\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      function C_Open_Read\n+        (Name  : C_File_Name;\n+         Fmode : Mode)\n+         return  File_Descriptor;\n+      pragma Import (C, C_Open_Read, \"__gnat_open_read\");\n+\n+   begin\n+      return C_Open_Read (Name, Fmode);\n+   end Open_Read;\n+\n+   function Open_Read\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Open_Read (C_Name (C_Name'First)'Address, Fmode);\n+   end Open_Read;\n+\n+   ---------------------\n+   -- Open_Read_Write --\n+   ---------------------\n+\n+   function Open_Read_Write\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      function C_Open_Read_Write\n+        (Name  : C_File_Name;\n+         Fmode : Mode)\n+         return  File_Descriptor;\n+      pragma Import (C, C_Open_Read_Write, \"__gnat_open_rw\");\n+\n+   begin\n+      return C_Open_Read_Write (Name, Fmode);\n+   end Open_Read_Write;\n+\n+   function Open_Read_Write\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor\n+   is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return Open_Read_Write (C_Name (C_Name'First)'Address, Fmode);\n+   end Open_Read_Write;\n+\n+   -----------------\n+   -- Rename_File --\n+   -----------------\n+\n+   procedure Rename_File\n+     (Old_Name : C_File_Name;\n+      New_Name : C_File_Name;\n+      Success  : out Boolean)\n+   is\n+      function rename (From, To : Address) return Integer;\n+      pragma Import (C, rename, \"rename\");\n+\n+      R : Integer;\n+\n+   begin\n+      R := rename (Old_Name, New_Name);\n+      Success := (R = 0);\n+   end Rename_File;\n+\n+   procedure Rename_File\n+     (Old_Name : String;\n+      New_Name : String;\n+      Success  : out Boolean)\n+   is\n+      C_Old_Name : String (1 .. Old_Name'Length + 1);\n+      C_New_Name : String (1 .. New_Name'Length + 1);\n+\n+   begin\n+      C_Old_Name (1 .. Old_Name'Length) := Old_Name;\n+      C_Old_Name (C_Old_Name'Last)      := ASCII.NUL;\n+\n+      C_New_Name (1 .. New_Name'Length) := New_Name;\n+      C_New_Name (C_New_Name'Last)      := ASCII.NUL;\n+\n+      Rename_File (C_Old_Name'Address, C_New_Name'Address, Success);\n+   end Rename_File;\n+\n+   ------------\n+   -- Setenv --\n+   ------------\n+\n+   procedure Setenv (Name : String; Value : String) is\n+      F_Name  : String (1 .. Name'Length + 1);\n+      F_Value : String (1 .. Value'Length + 1);\n+\n+      procedure Set_Env_Value (Name, Value : System.Address);\n+      pragma Import (C, Set_Env_Value, \"__gnat_set_env_value\");\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      F_Value (1 .. Value'Length) := Value;\n+      F_Value (F_Value'Last)      := ASCII.NUL;\n+\n+      Set_Env_Value (F_Name'Address, F_Value'Address);\n+   end Setenv;\n+\n+   -----------\n+   -- Spawn --\n+   -----------\n+\n+   function Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List)\n+      return         Integer\n+   is\n+      Junk   : Process_Id;\n+      Result : Integer;\n+\n+   begin\n+      Spawn_Internal (Program_Name, Args, Result, Junk, Blocking => True);\n+      return Result;\n+   end Spawn;\n+\n+   procedure Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Success      : out Boolean)\n+   is\n+   begin\n+      Success := (Spawn (Program_Name, Args) = 0);\n+   end Spawn;\n+\n+   --------------------\n+   -- Spawn_Internal --\n+   --------------------\n+\n+   procedure Spawn_Internal\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Result       : out Integer;\n+      Pid          : out Process_Id;\n+      Blocking     : Boolean)\n+   is\n+      type Chars is array (Positive range <>) of aliased Character;\n+      type Char_Ptr is access constant Character;\n+\n+      Command_Len : constant Positive := Program_Name'Length + 1\n+                                           + Args_Length (Args);\n+      Command_Last : Natural := 0;\n+      Command : aliased Chars (1 .. Command_Len);\n+      --  Command contains all characters of the Program_Name and Args,\n+      --  all terminated by ASCII.NUL characters\n+\n+      Arg_List_Len : constant Positive := Args'Length + 2;\n+      Arg_List_Last : Natural := 0;\n+      Arg_List : aliased array (1 .. Arg_List_Len) of Char_Ptr;\n+      --  List with pointers to NUL-terminated strings of the\n+      --  Program_Name and the Args and terminated with a null pointer.\n+      --  We rely on the default initialization for the last null pointer.\n+\n+      procedure Add_To_Command (S : String);\n+      --  Add S and a NUL character to Command, updating Last\n+\n+      function Portable_Spawn (Args : Address) return Integer;\n+      pragma Import (C, Portable_Spawn, \"__gnat_portable_spawn\");\n+\n+      function Portable_No_Block_Spawn (Args : Address) return Process_Id;\n+      pragma Import\n+        (C, Portable_No_Block_Spawn, \"__gnat_portable_no_block_spawn\");\n+\n+      --------------------\n+      -- Add_To_Command --\n+      --------------------\n+\n+      procedure Add_To_Command (S : String) is\n+         First : constant Natural := Command_Last + 1;\n+\n+      begin\n+         Command_Last := Command_Last + S'Length;\n+         Command (First .. Command_Last) := Chars (S);\n+\n+         Command_Last := Command_Last + 1;\n+         Command (Command_Last) := ASCII.NUL;\n+\n+         Arg_List_Last := Arg_List_Last + 1;\n+         Arg_List (Arg_List_Last) := Command (First)'Access;\n+      end Add_To_Command;\n+\n+   --  Start of processing for Spawn_Internal\n+\n+   begin\n+      Add_To_Command (Program_Name);\n+\n+      for J in Args'Range loop\n+         Add_To_Command (Args (J).all);\n+      end loop;\n+\n+      if Blocking then\n+         Pid     := Invalid_Pid;\n+         Result  := Portable_Spawn (Arg_List'Address);\n+      else\n+         Pid     := Portable_No_Block_Spawn (Arg_List'Address);\n+         Result  := Boolean'Pos (Pid /= Invalid_Pid);\n+      end if;\n+\n+   end Spawn_Internal;\n+\n+   ---------------------------\n+   -- To_Path_String_Access --\n+   ---------------------------\n+\n+   function To_Path_String_Access\n+     (Path_Addr : Address;\n+      Path_Len  : Integer)\n+      return      String_Access\n+   is\n+      subtype Path_String is String (1 .. Path_Len);\n+      type    Path_String_Access is access Path_String;\n+\n+      function Address_To_Access is new\n+        Unchecked_Conversion (Source => Address,\n+                              Target => Path_String_Access);\n+\n+      Path_Access : Path_String_Access := Address_To_Access (Path_Addr);\n+\n+      Return_Val  : String_Access;\n+\n+   begin\n+      Return_Val := new String (1 .. Path_Len);\n+\n+      for J in 1 .. Path_Len loop\n+         Return_Val (J) := Path_Access (J);\n+      end loop;\n+\n+      return Return_Val;\n+   end To_Path_String_Access;\n+\n+   ------------------\n+   -- Wait_Process --\n+   ------------------\n+\n+   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean) is\n+      Status : Integer;\n+\n+      function Portable_Wait (S : Address) return Process_Id;\n+      pragma Import (C, Portable_Wait, \"__gnat_portable_wait\");\n+\n+   begin\n+      Pid := Portable_Wait (Status'Address);\n+      Success := (Status = 0);\n+   end Wait_Process;\n+\n+end GNAT.OS_Lib;"}, {"sha": "07fd8f1b83f6ce99858e5062101f4848cadc8b3b", "filename": "gcc/ada/g-os_lib.ads", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,512 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G N A T . O S _ L I B                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.79 $\n+--                                                                          --\n+--           Copyright (C) 1995-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Operating system interface facilities\n+\n+--  This package contains types and procedures for interfacing to the\n+--  underlying OS. It is used by the GNAT compiler and by tools associated\n+--  with the GNAT compiler, and therefore works for the various operating\n+--  systems to which GNAT has been ported. This package will undoubtedly\n+--  grow as new services are needed by various tools.\n+\n+--  This package tends to use fairly low-level Ada in order to not bring\n+--  in large portions of the RTL. For example, functions return access\n+--  to string as part of avoiding functions returning unconstrained types;\n+--  types related to dates are defined here instead of using the types\n+--  from Calendar, since use of Calendar forces linking in of tasking code.\n+\n+--  Except where specifically noted, these routines are portable across\n+--  all GNAT implementations on all supported operating systems.\n+\n+with System;\n+with Unchecked_Deallocation;\n+\n+package GNAT.OS_Lib is\n+pragma Elaborate_Body (OS_Lib);\n+\n+   type String_Access is access all String;\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Object => String, Name => String_Access);\n+\n+   ---------------------\n+   -- Time/Date Stuff --\n+   ---------------------\n+\n+   --  The OS's notion of time is represented by the private type OS_Time.\n+   --  This is the type returned by the File_Time_Stamp functions to obtain\n+   --  the time stamp of a specified file. Functions and a procedure (modeled\n+   --  after the similar subprograms in package Calendar) are provided for\n+   --  extracting information from a value of this type. Although these are\n+   --  called GM, the intention is not that they provide GMT times in all\n+   --  cases but rather the actual (time-zone independent) time stamp of the\n+   --  file (of course in Unix systems, this *is* in GMT form).\n+\n+   type OS_Time is private;\n+\n+   subtype Year_Type   is Integer range 1900 .. 2099;\n+   subtype Month_Type  is Integer range    1 ..   12;\n+   subtype Day_Type    is Integer range    1 ..   31;\n+   subtype Hour_Type   is Integer range    0 ..   23;\n+   subtype Minute_Type is Integer range    0 ..   59;\n+   subtype Second_Type is Integer range    0 ..   59;\n+\n+   function GM_Year    (Date : OS_Time) return Year_Type;\n+   function GM_Month   (Date : OS_Time) return Month_Type;\n+   function GM_Day     (Date : OS_Time) return Day_Type;\n+   function GM_Hour    (Date : OS_Time) return Hour_Type;\n+   function GM_Minute  (Date : OS_Time) return Minute_Type;\n+   function GM_Second  (Date : OS_Time) return Second_Type;\n+\n+   procedure GM_Split\n+     (Date    : OS_Time;\n+      Year    : out Year_Type;\n+      Month   : out Month_Type;\n+      Day     : out Day_Type;\n+      Hour    : out Hour_Type;\n+      Minute  : out Minute_Type;\n+      Second  : out Second_Type);\n+\n+   ----------------\n+   -- File Stuff --\n+   ----------------\n+\n+   --  These routines give access to the open/creat/close/read/write level\n+   --  of I/O routines in the typical C library (these functions are not\n+   --  part of the ANSI C standard, but are typically available in all\n+   --  systems). See also package Interfaces.C_Streams for access to the\n+   --  stream level routines.\n+\n+   --  Note on file names. If a file name is passed as type String in any\n+   --  of the following specifications, then the name is a normal Ada string\n+   --  and need not be NUL-terminated. However, a trailing NUL character is\n+   --  permitted, and will be ignored (more accurately, the NUL and any\n+   --  characters that follow it will be ignored).\n+\n+   type File_Descriptor is private;\n+   --  Corresponds to the int file handle values used in the C routines,\n+\n+   Standin  : constant File_Descriptor;\n+   Standout : constant File_Descriptor;\n+   Standerr : constant File_Descriptor;\n+   --  File descriptors for standard input output files\n+\n+   Invalid_FD : constant File_Descriptor;\n+   --  File descriptor returned when error in opening/creating file;\n+\n+   type Mode is (Binary, Text);\n+   for Mode'Size use Integer'Size;\n+   for Mode use (Binary => 0, Text => 1);\n+   --  Used in all the Open and Create calls to specify if the file is to be\n+   --  opened in binary mode or text mode. In systems like Unix, this has no\n+   --  effect, but in systems capable of text mode translation, the use of\n+   --  Text as the mode parameter causes the system to do CR/LF translation\n+   --  and also to recognize the DOS end of file character on input. The use\n+   --  of Text where appropriate allows programs to take a portable Unix view\n+   --  of DOs-format files and process them appropriately.\n+\n+   function Open_Read\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+   --  Open file Name for reading, returning file descriptor File descriptor\n+   --  returned is Invalid_FD if file cannot be opened.\n+\n+   function Open_Read_Write\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+   --  Open file Name for both reading and writing, returning file\n+   --  descriptor. File descriptor returned is Invalid_FD if file cannot be\n+   --  opened.\n+\n+   function Create_File\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+   --  Creates new file with given name for writing, returning file descriptor\n+   --  for subsequent use in Write calls. File descriptor returned is\n+   --  Invalid_FD if file cannot be successfully created\n+\n+   function Create_New_File\n+     (Name  : String;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+   --  Create new file with given name for writing, returning file descriptor\n+   --  for subsequent use in Write calls. This differs from Create_File in\n+   --  that it fails if the file already exists. File descriptor returned is\n+   --  Invalid_FD if the file exists or cannot be created.\n+\n+   Temp_File_Len : constant Integer := 12;\n+   --  Length of name returned by Create_Temp_File call (GNAT-XXXXXX & NUL)\n+\n+   subtype Temp_File_Name is String (1 .. Temp_File_Len);\n+   --  String subtype set by Create_Temp_File\n+\n+   procedure Create_Temp_File\n+     (FD   : out File_Descriptor;\n+      Name : out Temp_File_Name);\n+   --  Create and open for writing a temporary file. The name of the\n+   --  file and the File Descriptor are returned. The File Descriptor\n+   --  returned is Invalid_FD in the case of failure. No mode parameter\n+   --  is provided. Since this is a temporary file, there is no point in\n+   --  doing text translation on it.\n+\n+   procedure Close (FD : File_Descriptor);\n+   pragma Import (C, Close, \"close\");\n+   --  Close file referenced by FD\n+\n+   procedure Delete_File (Name : String; Success : out Boolean);\n+   --  Deletes file. Success is set True or False indicating if the delete is\n+   --  successful.\n+\n+   procedure Rename_File\n+     (Old_Name : String;\n+      New_Name : String;\n+      Success  : out Boolean);\n+   --  Rename a file. Successis set True or False indicating if the rename is\n+   --  successful.\n+\n+   function Read\n+     (FD   : File_Descriptor;\n+      A    : System.Address;\n+      N    : Integer)\n+      return Integer;\n+   pragma Import (C, Read, \"read\");\n+   --  Read N bytes to address A from file referenced by FD. Returned value\n+   --  is count of bytes actually read, which can be less than N at EOF.\n+\n+   function Write\n+     (FD   : File_Descriptor;\n+      A    : System.Address;\n+      N    : Integer)\n+      return Integer;\n+   pragma Import (C, Write, \"write\");\n+   --  Write N bytes from address A to file referenced by FD. The returned\n+   --  value is the number of bytes written, which can be less than N if\n+   --  a disk full condition was detected.\n+\n+   Seek_Cur : constant := 1;\n+   Seek_End : constant := 2;\n+   Seek_Set : constant := 0;\n+   --  Used to indicate origin for Lseek call\n+\n+   procedure Lseek\n+     (FD     : File_Descriptor;\n+      offset : Long_Integer;\n+      origin : Integer);\n+   pragma Import (C, Lseek, \"lseek\");\n+   --  Sets the current file pointer to the indicated offset value,\n+   --  relative to the current position (origin = SEEK_CUR), end of\n+   --  file (origin = SEEK_END), or start of file (origin = SEEK_SET).\n+\n+   function File_Length (FD : File_Descriptor) return Long_Integer;\n+   pragma Import (C, File_Length, \"__gnat_file_length\");\n+   --  Get length of file from file descriptor FD\n+\n+   function File_Time_Stamp (Name : String) return OS_Time;\n+   --  Given the name of a file or directory, Name, obtains and returns the\n+   --  time stamp. This function can be used for an unopend file.\n+\n+   function File_Time_Stamp (FD : File_Descriptor) return OS_Time;\n+   --  Get time stamp of file from file descriptor FD\n+\n+   function Normalize_Pathname\n+     (Name      : String;\n+      Directory : String := \"\")\n+      return      String;\n+   --  Returns a file name as an absolute path name, resolving all relative\n+   --  directories, and symbolic links. The parameter Directory is a fully\n+   --  resolved path name for a directory, or the empty string (the default).\n+   --  Name is the name of a file, which is either relative to the given\n+   --  directory name, if Directory is non-null, or to the current working\n+   --  directory if Directory is null. The result returned is the normalized\n+   --  name of the file. For most cases, if two file names designate the same\n+   --  file through different paths, Normalize_Pathname will return the same\n+   --  canonical name in both cases. However, there are cases when this is\n+   --  not true; for example, this is not true in Unix for two hard links\n+   --  designating the same file.\n+   --\n+   --  If Name cannot be resolved or is null on entry (for example if there is\n+   --  a circularity in symbolic links: A is a symbolic link for B, while B is\n+   --  a symbolic link for A), then Normalize_Pathname returns an empty string.\n+   --\n+   --  In VMS, if Name follows the VMS syntax file specification, it is first\n+   --  converted into Unix syntax. If the conversion fails, Normalize_Pathname\n+   --  returns an empty string.\n+\n+   function Is_Absolute_Path (Name : String) return Boolean;\n+   --  Returns True if Name is an absolute path name, i.e. it designates\n+   --  a directory absolutely, rather than relative to another directory.\n+\n+   function Is_Regular_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing\n+   --  regular file. Returns True if so, False otherwise.\n+\n+   function Is_Directory (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of a directory.\n+   --  Returns True if so, False otherwise.\n+\n+   function Is_Writable_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing\n+   --  file that is writable. Returns True if so, False otherwise.\n+\n+   function Locate_Exec_On_Path\n+     (Exec_Name : String)\n+      return      String_Access;\n+   --  Try to locate an executable whose name is given by Exec_Name in the\n+   --  directories listed in the environment Path. If the Exec_Name doesn't\n+   --  have the executable suffix, it will be appended before the search.\n+   --  Otherwise works like Locate_Regular_File below.\n+   --\n+   --  Note that this function allocates some memory for the returned value.\n+   --  This memory needs to be deallocated after use.\n+\n+   function Locate_Regular_File\n+     (File_Name : String;\n+      Path      : String)\n+      return      String_Access;\n+   --  Try to locate a regular file whose name is given by File_Name in the\n+   --  directories listed in  Path. If a file is found, its full pathname is\n+   --  returned; otherwise, a null pointer is returned. If the File_Name given\n+   --  is an absolute pathname, then Locate_Regular_File just checks that the\n+   --  file exists and is a regular file. Otherwise, the Path argument is\n+   --  parsed according to OS conventions, and for each directory in the Path\n+   --  a check is made if File_Name is a relative pathname of a regular file\n+   --  from that directory.\n+   --\n+   --  Note that this function allocates some memory for the returned value.\n+   --  This memory needs to be deallocated after use.\n+\n+   function Get_Debuggable_Suffix return String_Access;\n+   --  Return the debuggable suffix convention. Usually this is the same as\n+   --  the convention for Get_Executable_Suffix.\n+   --\n+   --  Note that this function allocates some memory for the returned value.\n+   --  This memory needs to be deallocated after use.\n+\n+   function Get_Executable_Suffix return String_Access;\n+   --  Return the executable suffix convention.\n+   --\n+   --  Note that this function allocates some memory for the returned value.\n+   --  This memory needs to be deallocated after use.\n+\n+   function Get_Object_Suffix return String_Access;\n+   --  Return the object suffix convention.\n+   --\n+   --  Note that this function allocates some memory for the returned value.\n+   --  This memory needs to be deallocated after use.\n+\n+   --  The following section contains low-level routines using addresses to\n+   --  pass file name and executable name. In each routine the name must be\n+   --  Nul-Terminated. For complete documentation refer to the equivalent\n+   --  routine (but using string) defined above.\n+\n+   subtype C_File_Name is System.Address;\n+   --  This subtype is used to document that a parameter is the address\n+   --  of a null-terminated string containing the name of a file.\n+\n+   function Open_Read\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+\n+   function Open_Read_Write\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+\n+   function Create_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+\n+   function Create_New_File\n+     (Name  : C_File_Name;\n+      Fmode : Mode)\n+      return  File_Descriptor;\n+\n+   procedure Delete_File (Name : C_File_Name; Success : out Boolean);\n+\n+   procedure Rename_File\n+     (Old_Name : C_File_Name;\n+      New_Name : C_File_Name;\n+      Success  : out Boolean);\n+\n+   function File_Time_Stamp (Name : C_File_Name) return OS_Time;\n+\n+   function Is_Regular_File (Name : C_File_Name) return Boolean;\n+\n+   function Is_Directory (Name : C_File_Name) return Boolean;\n+\n+   function Is_Writable_File (Name : C_File_Name) return Boolean;\n+\n+   function Locate_Regular_File\n+     (File_Name : C_File_Name;\n+      Path      : C_File_Name)\n+      return      String_Access;\n+\n+   ------------------\n+   -- Subprocesses --\n+   ------------------\n+\n+   type Argument_List is array (Positive range <>) of String_Access;\n+   --  Type used for argument list in call to Spawn. The lower bound\n+   --  of the array should be 1, and the length of the array indicates\n+   --  the number of arguments.\n+\n+   type Argument_List_Access is access all Argument_List;\n+   --  Type used to return an Argument_List without dragging in secondary\n+   --  stack.\n+\n+   procedure Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Success      : out Boolean);\n+   --  The first parameter of function Spawn is the name of the executable.\n+   --  The second parameter contains the arguments to be passed to the\n+   --  program. Success is False if the named program could not be spawned\n+   --  or its execution completed unsuccessfully. Note that the caller will\n+   --  be blocked until the execution of the spawned program is complete.\n+   --  For maximum portability, use a full path name for the Program_Name\n+   --  argument. On some systems (notably Unix systems) a simple file\n+   --  name may also work (if the executable can be located in the path).\n+   --\n+   --  Note: Arguments that contain spaces and/or quotes such as\n+   --        \"--GCC=gcc -v\" or \"--GCC=\"\"gcc-v\"\"\" are not portable\n+   --        across OSes. They may or may not have the desired effect.\n+\n+   function Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List)\n+      return         Integer;\n+   --  Like above, but as function returning the exact exit status\n+\n+   type Process_Id is private;\n+   --  A private type used to identify a process activated by the following\n+   --  non-blocking call. The only meaningful operation on this type is a\n+   --  comparison for equality.\n+\n+   Invalid_Pid : constant Process_Id;\n+   --  A special value used to indicate errors, as described below.\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List)\n+      return         Process_Id;\n+   --  This is a non blocking call. The Process_Id of the spawned process\n+   --  is returned. Parameters are to be used as in Spawn. If Invalid_Id\n+   --  is returned the program could not be spawned.\n+\n+   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean);\n+   --  Wait for the completion of any of the processes created by previous\n+   --  calls to Non_Blocking_Spawn. The caller will be suspended until one\n+   --  of these processes terminates (normally or abnormally). If any of\n+   --  these subprocesses terminates prior to the call to Wait_Process (and\n+   --  has not been returned by a previous call to Wait_Process), then the\n+   --  call to Wait_Process is immediate. Pid identifies the process that\n+   --  has terminated (matching the value returned from Non_Blocking_Spawn).\n+   --  Success is set to True if this sub-process terminated successfully.\n+   --  If Pid = Invalid_Id, there were no subprocesses left to wait on.\n+\n+   function Argument_String_To_List\n+     (Arg_String : String)\n+      return       Argument_List_Access;\n+   --  Take a string that is a program and it's arguments and parse it into\n+   --  an Argument_List.\n+\n+   -------------------\n+   -- Miscellaneous --\n+   -------------------\n+\n+   function Getenv (Name : String) return String_Access;\n+   --  Get the value of the environment variable. Returns an access\n+   --  to the empty string if the environment variable does not exist\n+   --  or has an explicit null value (in some operating systems these\n+   --  are distinct cases, in others they are not; this interface\n+   --  abstracts away that difference.\n+\n+   procedure Setenv (Name : String; Value : String);\n+   --  Set the value of the environment variable Name to Value. This call\n+   --  modifies the current environment, but does not modify the parent\n+   --  process environment. After a call to Setenv, Getenv (Name) will\n+   --  always return a String_Access referencing the same String as Value.\n+   --  This is true also for the null string case (the actual effect may\n+   --  be to either set an explicit null as the value, or to remove the\n+   --  entry, this is operating system dependent). Note that any following\n+   --  calls to Spawn will pass an environment to the spawned process that\n+   --  includes the changes made by Setenv calls. This procedure is not\n+   --  available under VMS.\n+\n+   procedure OS_Exit (Status : Integer);\n+   pragma Import (C, OS_Exit, \"__gnat_os_exit\");\n+   --  Exit to OS with given status code (program is terminated)\n+\n+   procedure OS_Abort;\n+   pragma Import (C, OS_Abort, \"abort\");\n+   --  Exit to OS signalling an abort (traceback or other appropriate\n+   --  diagnostic information should be given if possible, or entry made\n+   --  to the debugger if that is possible).\n+\n+   function Errno return Integer;\n+   pragma Import (C, Errno, \"__get_errno\");\n+   --  Return the task-safe last error number.\n+\n+   procedure Set_Errno (Errno : Integer);\n+   pragma Import (C, Set_Errno, \"__set_errno\");\n+   --  Set the task-safe error number.\n+\n+   Directory_Separator : constant Character;\n+   --  The character that is used to separate parts of a pathname.\n+\n+   Path_Separator : constant Character;\n+   --  The character to separate paths in an environment variable value.\n+\n+private\n+   pragma Import (C, Path_Separator, \"__gnat_path_separator\");\n+   pragma Import (C, Directory_Separator, \"__gnat_dir_separator\");\n+\n+   type OS_Time is new Integer;\n+\n+   type File_Descriptor is new Integer;\n+\n+   Standin    : constant File_Descriptor :=  0;\n+   Standout   : constant File_Descriptor :=  1;\n+   Standerr   : constant File_Descriptor :=  2;\n+   Invalid_FD : constant File_Descriptor := -1;\n+\n+   type Process_Id is new Integer;\n+   Invalid_Pid : constant Process_Id := -1;\n+\n+end GNAT.OS_Lib;"}, {"sha": "302b63a783250093cc9f122b71f195e9aac02686", "filename": "gcc/ada/g-regexp.adb", "status": "added", "additions": 1477, "deletions": 0, "changes": 1477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regexp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regexp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regexp.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,1477 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G N A T . R E G E X P                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.27 $\n+--                                                                          --\n+--            Copyright (C) 1999-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+with Unchecked_Deallocation;\n+with Ada.Exceptions;\n+with GNAT.Case_Util;\n+\n+package body GNAT.Regexp is\n+\n+   Open_Paren    : constant Character := '(';\n+   Close_Paren   : constant Character := ')';\n+   Open_Bracket  : constant Character := '[';\n+   Close_Bracket : constant Character := ']';\n+\n+   type State_Index is new Natural;\n+   type Column_Index is new Natural;\n+\n+   type Regexp_Array is array\n+     (State_Index range <>, Column_Index range <>) of State_Index;\n+   --  First index is for the state number\n+   --  Second index is for the character type\n+   --  Contents is the new State\n+\n+   type Regexp_Array_Access is access Regexp_Array;\n+   --  Use this type through the functions Set below, so that it\n+   --  can grow dynamically depending on the needs.\n+\n+   type Mapping is array (Character'Range) of Column_Index;\n+   --  Mapping between characters and column in the Regexp_Array\n+\n+   type Boolean_Array is array (State_Index range <>) of Boolean;\n+\n+   type Regexp_Value\n+     (Alphabet_Size : Column_Index;\n+      Num_States    : State_Index) is\n+   record\n+      Map            : Mapping;\n+      States         : Regexp_Array (1 .. Num_States, 0 .. Alphabet_Size);\n+      Is_Final       : Boolean_Array (1 .. Num_States);\n+      Case_Sensitive : Boolean;\n+   end record;\n+   --  Deterministic finite-state machine\n+\n+   Debug : constant Boolean := False;\n+   --  When True, the primary and secondary tables will be printed.\n+   --  Gnat does not generate any code if this variable is False;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Set\n+     (Table  : in out Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index;\n+      Value  : State_Index);\n+   --  Sets a value in the table. If the table is too small, reallocate it\n+   --  dynamically so that (State, Column) is a valid index in it.\n+\n+   function Get\n+     (Table  : Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index)\n+      return   State_Index;\n+   --  Returns the value in the table at (State, Column).\n+   --  If this index does not exist in the table, returns 0\n+\n+   procedure Free is new Unchecked_Deallocation\n+     (Regexp_Array, Regexp_Array_Access);\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (R : in out Regexp) is\n+      Tmp : Regexp_Access;\n+\n+   begin\n+      Tmp := new Regexp_Value (Alphabet_Size => R.R.Alphabet_Size,\n+                               Num_States    => R.R.Num_States);\n+      Tmp.all := R.R.all;\n+      R.R := Tmp;\n+   end Adjust;\n+\n+   -------------\n+   -- Compile --\n+   -------------\n+\n+   function Compile\n+     (Pattern        : String;\n+      Glob           : Boolean := False;\n+      Case_Sensitive : Boolean := True)\n+      return           Regexp\n+   is\n+      S : String := Pattern;\n+      --  The pattern which is really compiled (when the pattern is case\n+      --  insensitive, we convert this string to lower-cases\n+\n+      Map : Mapping := (others => 0);\n+      --  Mapping between characters and columns in the tables\n+\n+      Alphabet_Size : Column_Index := 0;\n+      --  Number of significant characters in the regular expression.\n+      --  This total does not include special operators, such as *, (, ...\n+\n+      procedure Create_Mapping;\n+      --  Creates a mapping between characters in the regexp and columns\n+      --  in the tables representing the regexp. Test that the regexp is\n+      --  well-formed Modifies Alphabet_Size and Map\n+\n+      procedure Create_Primary_Table\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index);\n+      --  Creates the first version of the regexp (this is a non determinist\n+      --  finite state machine, which is unadapted for a fast pattern\n+      --  matching algorithm). We use a recursive algorithm to process the\n+      --  parenthesis sub-expressions.\n+      --\n+      --  Table : at the end of the procedure : Column 0 is for any character\n+      --  ('.') and the last columns are for no character (closure)\n+      --  Num_States is set to the number of states in the table\n+      --  Start_State is the number of the starting state in the regexp\n+      --  End_State is the number of the final state when the regexp matches\n+\n+      procedure Create_Primary_Table_Glob\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index);\n+      --  Same function as above, but it deals with the second possible\n+      --  grammar for 'globbing pattern', which is a kind of subset of the\n+      --  whole regular expression grammar.\n+\n+      function Create_Secondary_Table\n+        (First_Table : Regexp_Array_Access;\n+         Num_States  : State_Index;\n+         Start_State : State_Index;\n+         End_State   : State_Index)\n+         return        Regexp;\n+      --  Creates the definitive table representing the regular expression\n+      --  This is actually a transformation of the primary table First_Table,\n+      --  where every state is grouped with the states in its 'no-character'\n+      --  columns. The transitions between the new states are then recalculated\n+      --  and if necessary some new states are created.\n+      --\n+      --  Note that the resulting finite-state machine is not optimized in\n+      --  terms of the number of states : it would be more time-consuming to\n+      --  add a third pass to reduce the number of states in the machine, with\n+      --  no speed improvement...\n+\n+      procedure Raise_Exception\n+        (M     : String;\n+         Index : Integer);\n+      pragma No_Return (Raise_Exception);\n+      --  Raise an exception, indicating an error at character Index in S.\n+\n+      procedure Print_Table\n+        (Table      : Regexp_Array;\n+         Num_States : State_Index;\n+         Is_Primary : Boolean := True);\n+      --  Print a table for debugging purposes\n+\n+      --------------------\n+      -- Create_Mapping --\n+      --------------------\n+\n+      procedure Create_Mapping is\n+\n+         procedure Add_In_Map (C : Character);\n+         --  Add a character in the mapping, if it is not already defined\n+\n+         -----------------\n+         --  Add_In_Map --\n+         -----------------\n+\n+         procedure Add_In_Map (C : Character) is\n+         begin\n+            if Map (C) = 0 then\n+               Alphabet_Size := Alphabet_Size + 1;\n+               Map (C) := Alphabet_Size;\n+            end if;\n+         end Add_In_Map;\n+\n+         J                 : Integer := S'First;\n+         Parenthesis_Level : Integer := 0;\n+         Curly_Level       : Integer := 0;\n+\n+      --  Start of processing for Create_Mapping\n+\n+      begin\n+         while J <= S'Last loop\n+            case S (J) is\n+               when Open_Bracket =>\n+                  J := J + 1;\n+\n+                  if S (J) = '^' then\n+                     J := J + 1;\n+                  end if;\n+\n+                  if S (J) = ']' or S (J) = '-' then\n+                     J := J + 1;\n+                  end if;\n+\n+                  --  The first character never has a special meaning\n+\n+                  loop\n+                     if J > S'Last then\n+                        Raise_Exception\n+                          (\"Ran out of characters while parsing \", J);\n+                     end if;\n+\n+                     exit when S (J) = Close_Bracket;\n+\n+                     if S (J) = '-'\n+                       and then S (J + 1) /= Close_Bracket\n+                     then\n+                        declare\n+                           Start : constant Integer := J - 1;\n+\n+                        begin\n+                           J := J + 1;\n+\n+                           if S (J) = '\\' then\n+                              J := J + 1;\n+                           end if;\n+\n+                           for Char in S (Start) .. S (J) loop\n+                              Add_In_Map (Char);\n+                           end loop;\n+                        end;\n+                     else\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+\n+                        Add_In_Map (S (J));\n+                     end if;\n+\n+                     J := J + 1;\n+                  end loop;\n+\n+                  --  A close bracket must follow a open_bracket,\n+                  --  and cannot be found alone on the line\n+\n+               when Close_Bracket =>\n+                  Raise_Exception\n+                    (\"Incorrect character ']' in regular expression\", J);\n+\n+               when '\\' =>\n+                  if J < S'Last  then\n+                     J := J + 1;\n+                     Add_In_Map (S (J));\n+\n+                  else\n+                     --  \\ not allowed at the end of the regexp\n+\n+                     Raise_Exception\n+                       (\"Incorrect character '\\' in regular expression\", J);\n+                  end if;\n+\n+               when Open_Paren =>\n+                  if not Glob then\n+                     Parenthesis_Level := Parenthesis_Level + 1;\n+                  else\n+                     Add_In_Map (Open_Paren);\n+                  end if;\n+\n+               when Close_Paren =>\n+                  if not Glob then\n+                     Parenthesis_Level := Parenthesis_Level - 1;\n+\n+                     if Parenthesis_Level < 0 then\n+                        Raise_Exception\n+                          (\"')' is not associated with '(' in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+\n+                     if S (J - 1) = Open_Paren then\n+                        Raise_Exception\n+                          (\"Empty parenthesis not allowed in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+\n+                  else\n+                     Add_In_Map (Close_Paren);\n+                  end if;\n+\n+               when '.' =>\n+                  if Glob then\n+                     Add_In_Map ('.');\n+                  end if;\n+\n+               when '{' =>\n+                  if not Glob then\n+                     Add_In_Map (S (J));\n+                  else\n+                     Curly_Level := Curly_Level + 1;\n+                  end if;\n+\n+               when '}' =>\n+                  if not Glob then\n+                     Add_In_Map (S (J));\n+                  else\n+                     Curly_Level := Curly_Level - 1;\n+                  end if;\n+\n+               when '*' | '?' =>\n+                  if not Glob then\n+                     if J = S'First then\n+                        Raise_Exception\n+                          (\"'*', '+', '?' and '|' operators can not be in \"\n+                           & \"first position in regular expression\", J);\n+                     end if;\n+                  end if;\n+\n+               when '|' | '+' =>\n+                  if not Glob then\n+                     if J = S'First then\n+\n+                        --  These operators must apply to a sub-expression,\n+                        --  and cannot be found at the beginning of the line\n+\n+                        Raise_Exception\n+                          (\"'*', '+', '?' and '|' operators can not be in \"\n+                           & \"first position in regular expression\", J);\n+                     end if;\n+\n+                  else\n+                     Add_In_Map (S (J));\n+                  end if;\n+\n+               when others =>\n+                  Add_In_Map (S (J));\n+            end case;\n+\n+            J := J + 1;\n+         end loop;\n+\n+         --  A closing parenthesis must follow an open parenthesis\n+\n+         if Parenthesis_Level /= 0 then\n+            Raise_Exception\n+              (\"'(' must always be associated with a ')'\", J);\n+         end if;\n+\n+         if Curly_Level /= 0 then\n+            Raise_Exception\n+              (\"'{' must always be associated with a '}'\", J);\n+         end if;\n+      end Create_Mapping;\n+\n+      --------------------------\n+      -- Create_Primary_Table --\n+      --------------------------\n+\n+      procedure Create_Primary_Table\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index)\n+      is\n+         Empty_Char : constant Column_Index := Alphabet_Size + 1;\n+\n+         Current_State : State_Index := 0;\n+         --  Index of the last created state\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index);\n+         --  Add a empty-character transition from State to To_State.\n+\n+         procedure Create_Repetition\n+           (Repetition : Character;\n+            Start_Prev : State_Index;\n+            End_Prev   : State_Index;\n+            New_Start  : out State_Index;\n+            New_End    : in out State_Index);\n+         --  Create the table in case we have a '*', '+' or '?'.\n+         --  Start_Prev .. End_Prev should indicate respectively the start and\n+         --  end index of the previous expression, to which '*', '+' or '?' is\n+         --  applied.\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index);\n+         --  Fill the table for the regexp Simple.\n+         --  This is the recursive procedure called to handle () expressions\n+         --  If End_State = 0, then the call to Create_Simple creates an\n+         --  independent regexp, not a concatenation\n+         --  Start_Index .. End_Index is the starting index in the string S.\n+         --\n+         --  Warning: it may look like we are creating too many empty-string\n+         --  transitions, but they are needed to get the correct regexp.\n+         --  The table is filled as follow ( s means start-state, e means\n+         --  end-state) :\n+         --\n+         --  regexp   state_num | a b * empty_string\n+         --  -------  ---------------------------------------\n+         --    a          1 (s) | 2 - - -\n+         --               2 (e) | - - - -\n+         --\n+         --    ab         1 (s) | 2 - - -\n+         --               2     | - - - 3\n+         --               3     | - 4 - -\n+         --               4 (e) | - - - -\n+         --\n+         --    a|b        1     | 2 - - -\n+         --               2     | - - - 6\n+         --               3     | - 4 - -\n+         --               4     | - - - 6\n+         --               5 (s) | - - - 1,3\n+         --               6 (e) | - - - -\n+         --\n+         --    a*         1     | 2 - - -\n+         --               2     | - - - 4\n+         --               3 (s) | - - - 1,4\n+         --               4 (e) | - - - 3\n+         --\n+         --    (a)        1 (s) | 2 - - -\n+         --               2 (e) | - - - -\n+         --\n+         --    a+         1     | 2 - - -\n+         --               2     | - - - 4\n+         --               3 (s) | - - - 1\n+         --               4 (e) | - - - 3\n+         --\n+         --    a?         1     | 2 - - -\n+         --               2     | - - - 4\n+         --               3 (s) | - - - 1,4\n+         --               4 (e) | - - - -\n+         --\n+         --    .          1 (s) | 2 2 2 -\n+         --               2 (e) | - - - -\n+\n+         function Next_Sub_Expression\n+           (Start_Index : Integer;\n+            End_Index   : Integer)\n+            return        Integer;\n+         --  Returns the index of the last character of the next sub-expression\n+         --  in Simple. Index can not be greater than End_Index\n+\n+         --------------------\n+         -- Add_Empty_Char --\n+         --------------------\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index)\n+         is\n+            J : Column_Index := Empty_Char;\n+\n+         begin\n+            while Get (Table, State, J) /= 0 loop\n+               J := J + 1;\n+            end loop;\n+\n+            Set (Table, State, J, To_State);\n+         end Add_Empty_Char;\n+\n+         -----------------------\n+         -- Create_Repetition --\n+         -----------------------\n+\n+         procedure Create_Repetition\n+           (Repetition : Character;\n+            Start_Prev : State_Index;\n+            End_Prev   : State_Index;\n+            New_Start  : out State_Index;\n+            New_End    : in out State_Index)\n+         is\n+         begin\n+            New_Start := Current_State + 1;\n+\n+            if New_End /= 0 then\n+               Add_Empty_Char (New_End, New_Start);\n+            end if;\n+\n+            Current_State := Current_State + 2;\n+            New_End   := Current_State;\n+\n+            Add_Empty_Char (End_Prev, New_End);\n+            Add_Empty_Char (New_Start, Start_Prev);\n+\n+            if Repetition /= '+' then\n+               Add_Empty_Char (New_Start, New_End);\n+            end if;\n+\n+            if Repetition /= '?' then\n+               Add_Empty_Char (New_End, New_Start);\n+            end if;\n+         end Create_Repetition;\n+\n+         -------------------\n+         -- Create_Simple --\n+         -------------------\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index)\n+         is\n+            J          : Integer := Start_Index;\n+            Last_Start : State_Index := 0;\n+\n+         begin\n+            Start_State := 0;\n+            End_State   := 0;\n+            while J <= End_Index loop\n+               case S (J) is\n+                  when Open_Paren =>\n+                     declare\n+                        J_Start    : Integer := J + 1;\n+                        Next_Start : State_Index;\n+                        Next_End   : State_Index;\n+\n+                     begin\n+                        J := Next_Sub_Expression (J, End_Index);\n+                        Create_Simple (J_Start, J - 1, Next_Start, Next_End);\n+\n+                        if J < End_Index\n+                          and then (S (J + 1) = '*' or else\n+                                    S (J + 1) = '+' or else\n+                                    S (J + 1) = '?')\n+                        then\n+                           J := J + 1;\n+                           Create_Repetition\n+                             (S (J),\n+                              Next_Start,\n+                              Next_End,\n+                              Last_Start,\n+                              End_State);\n+\n+                        else\n+                           Last_Start := Next_Start;\n+\n+                           if End_State /= 0 then\n+                              Add_Empty_Char (End_State, Last_Start);\n+                           end if;\n+\n+                           End_State := Next_End;\n+                        end if;\n+                     end;\n+\n+                  when '|' =>\n+                     declare\n+                        Start_Prev : State_Index := Start_State;\n+                        End_Prev   : State_Index := End_State;\n+                        Start_Next : State_Index := 0;\n+                        End_Next   : State_Index := 0;\n+                        Start_J    : Integer := J + 1;\n+\n+                     begin\n+                        J := Next_Sub_Expression (J, End_Index);\n+\n+                        --  Create a new state for the start of the alternative\n+\n+                        Current_State := Current_State + 1;\n+                        Last_Start := Current_State;\n+                        Start_State := Last_Start;\n+\n+                        --  Create the tree for the second part of alternative\n+\n+                        Create_Simple (Start_J, J, Start_Next, End_Next);\n+\n+                        --  Create the end state\n+\n+                        Add_Empty_Char (Last_Start, Start_Next);\n+                        Add_Empty_Char (Last_Start, Start_Prev);\n+                        Current_State := Current_State + 1;\n+                        End_State := Current_State;\n+                        Add_Empty_Char (End_Prev, End_State);\n+                        Add_Empty_Char (End_Next, End_State);\n+                     end;\n+\n+                  when Open_Bracket =>\n+                     Current_State := Current_State + 1;\n+\n+                     declare\n+                        Next_State : State_Index := Current_State + 1;\n+\n+                     begin\n+                        J := J + 1;\n+\n+                        if S (J) = '^' then\n+                           J := J + 1;\n+\n+                           Next_State := 0;\n+\n+                           for Column in 0 .. Alphabet_Size loop\n+                              Set (Table, Current_State, Column,\n+                                   Value => Current_State + 1);\n+                           end loop;\n+                        end if;\n+\n+                        --  Automatically add the first character\n+\n+                        if S (J) = '-' or S (J) = ']' then\n+                           Set (Table, Current_State, Map (S (J)),\n+                                Value => Next_State);\n+                           J := J + 1;\n+                        end if;\n+\n+                        --  Loop till closing bracket found\n+\n+                        loop\n+                           exit when S (J) = Close_Bracket;\n+\n+                           if S (J) = '-'\n+                             and then S (J + 1) /= ']'\n+                           then\n+                              declare\n+                                 Start : constant Integer := J - 1;\n+\n+                              begin\n+                                 J := J + 1;\n+\n+                                 if S (J) = '\\' then\n+                                    J := J + 1;\n+                                 end if;\n+\n+                                 for Char in S (Start) .. S (J) loop\n+                                    Set (Table, Current_State, Map (Char),\n+                                         Value => Next_State);\n+                                 end loop;\n+                              end;\n+\n+                           else\n+                              if S (J) = '\\' then\n+                                 J := J + 1;\n+                              end if;\n+\n+                              Set (Table, Current_State, Map (S (J)),\n+                                   Value => Next_State);\n+                           end if;\n+                           J := J + 1;\n+                        end loop;\n+                     end;\n+\n+                     Current_State := Current_State + 1;\n+\n+                     --  If the next symbol is a special symbol\n+\n+                     if J < End_Index\n+                       and then (S (J + 1) = '*' or else\n+                                 S (J + 1) = '+' or else\n+                                 S (J + 1) = '?')\n+                     then\n+                        J := J + 1;\n+                        Create_Repetition\n+                          (S (J),\n+                           Current_State - 1,\n+                           Current_State,\n+                           Last_Start,\n+                           End_State);\n+\n+                     else\n+                        Last_Start := Current_State - 1;\n+\n+                        if End_State /= 0 then\n+                           Add_Empty_Char (End_State, Last_Start);\n+                        end if;\n+\n+                        End_State := Current_State;\n+                     end if;\n+\n+                  when '*' | '+' | '?' | Close_Paren | Close_Bracket =>\n+                     Raise_Exception\n+                       (\"Incorrect character in regular expression :\", J);\n+\n+                  when others =>\n+                     Current_State := Current_State + 1;\n+\n+                     --  Create the state for the symbol S (J)\n+\n+                     if S (J) = '.' then\n+                        for K in 0 .. Alphabet_Size loop\n+                           Set (Table, Current_State, K,\n+                                Value => Current_State + 1);\n+                        end loop;\n+\n+                     else\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+\n+                        Set (Table, Current_State, Map (S (J)),\n+                             Value => Current_State + 1);\n+                     end if;\n+\n+                     Current_State := Current_State + 1;\n+\n+                     --  If the next symbol is a special symbol\n+\n+                     if J < End_Index\n+                       and then (S (J + 1) = '*' or else\n+                                 S (J + 1) = '+' or else\n+                                 S (J + 1) = '?')\n+                     then\n+                        J := J + 1;\n+                        Create_Repetition\n+                          (S (J),\n+                           Current_State - 1,\n+                           Current_State,\n+                           Last_Start,\n+                           End_State);\n+\n+                     else\n+                        Last_Start := Current_State - 1;\n+\n+                        if End_State /= 0 then\n+                           Add_Empty_Char (End_State, Last_Start);\n+                        end if;\n+\n+                        End_State := Current_State;\n+                     end if;\n+\n+               end case;\n+\n+               if Start_State = 0 then\n+                  Start_State := Last_Start;\n+               end if;\n+\n+               J := J + 1;\n+            end loop;\n+         end Create_Simple;\n+\n+         -------------------------\n+         -- Next_Sub_Expression --\n+         -------------------------\n+\n+         function Next_Sub_Expression\n+           (Start_Index : Integer;\n+            End_Index   : Integer)\n+            return        Integer\n+         is\n+            J              : Integer := Start_Index;\n+            Start_On_Alter : Boolean := False;\n+\n+         begin\n+            if S (J) = '|' then\n+               Start_On_Alter := True;\n+            end if;\n+\n+            loop\n+               exit when J = End_Index;\n+               J := J + 1;\n+\n+               case S (J) is\n+                  when '\\' =>\n+                     J := J + 1;\n+\n+                  when Open_Bracket =>\n+                     loop\n+                        J := J + 1;\n+                        exit when S (J) = Close_Bracket;\n+\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+                     end loop;\n+\n+                  when Open_Paren =>\n+                     J := Next_Sub_Expression (J, End_Index);\n+\n+                  when Close_Paren =>\n+                     return J;\n+\n+                  when '|' =>\n+                     if Start_On_Alter then\n+                        return J - 1;\n+                     end if;\n+\n+                  when others =>\n+                     null;\n+               end case;\n+            end loop;\n+\n+            return J;\n+         end Next_Sub_Expression;\n+\n+      --  Start of Create_Primary_Table\n+\n+      begin\n+         Table.all := (others => (others => 0));\n+         Create_Simple (S'First, S'Last, Start_State, End_State);\n+         Num_States := Current_State;\n+      end Create_Primary_Table;\n+\n+      -------------------------------\n+      -- Create_Primary_Table_Glob --\n+      -------------------------------\n+\n+      procedure Create_Primary_Table_Glob\n+        (Table       : out Regexp_Array_Access;\n+         Num_States  : out State_Index;\n+         Start_State : out State_Index;\n+         End_State   : out State_Index)\n+      is\n+         Empty_Char : constant Column_Index := Alphabet_Size + 1;\n+\n+         Current_State : State_Index := 0;\n+         --  Index of the last created state\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index);\n+         --  Add a empty-character transition from State to To_State.\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index);\n+         --  Fill the table for the S (Start_Index .. End_Index).\n+         --  This is the recursive procedure called to handle () expressions\n+\n+         --------------------\n+         -- Add_Empty_Char --\n+         --------------------\n+\n+         procedure Add_Empty_Char\n+           (State    : State_Index;\n+            To_State : State_Index)\n+         is\n+            J : Column_Index := Empty_Char;\n+\n+         begin\n+            while Get (Table, State, J) /= 0 loop\n+               J := J + 1;\n+            end loop;\n+\n+            Set (Table, State, J,\n+                 Value => To_State);\n+         end Add_Empty_Char;\n+\n+         -------------------\n+         -- Create_Simple --\n+         -------------------\n+\n+         procedure Create_Simple\n+           (Start_Index : Integer;\n+            End_Index   : Integer;\n+            Start_State : out State_Index;\n+            End_State   : out State_Index)\n+         is\n+            J          : Integer := Start_Index;\n+            Last_Start : State_Index := 0;\n+\n+         begin\n+            Start_State := 0;\n+            End_State   := 0;\n+\n+            while J <= End_Index loop\n+               case S (J) is\n+\n+                  when Open_Bracket =>\n+                     Current_State := Current_State + 1;\n+\n+                     declare\n+                        Next_State : State_Index := Current_State + 1;\n+\n+                     begin\n+                        J := J + 1;\n+\n+                        if S (J) = '^' then\n+                           J := J + 1;\n+                           Next_State := 0;\n+\n+                           for Column in 0 .. Alphabet_Size loop\n+                              Set (Table, Current_State, Column,\n+                                   Value => Current_State + 1);\n+                           end loop;\n+                        end if;\n+\n+                        --  Automatically add the first character\n+\n+                        if S (J) = '-' or S (J) = ']' then\n+                           Set (Table, Current_State, Map (S (J)),\n+                                Value => Current_State);\n+                           J := J + 1;\n+                        end if;\n+\n+                        --  Loop till closing bracket found\n+\n+                        loop\n+                           exit when S (J) = Close_Bracket;\n+\n+                           if S (J) = '-'\n+                             and then S (J + 1) /= ']'\n+                           then\n+                              declare\n+                                 Start : constant Integer := J - 1;\n+                              begin\n+                                 J := J + 1;\n+\n+                                 if S (J) = '\\' then\n+                                    J := J + 1;\n+                                 end if;\n+\n+                                 for Char in S (Start) .. S (J) loop\n+                                    Set (Table, Current_State, Map (Char),\n+                                         Value => Next_State);\n+                                 end loop;\n+                              end;\n+\n+                           else\n+                              if S (J) = '\\' then\n+                                 J := J + 1;\n+                              end if;\n+\n+                              Set (Table, Current_State, Map (S (J)),\n+                                   Value => Next_State);\n+                           end if;\n+                           J := J + 1;\n+                        end loop;\n+                     end;\n+\n+                     Last_Start := Current_State;\n+                     Current_State := Current_State + 1;\n+\n+                     if End_State /= 0 then\n+                        Add_Empty_Char (End_State, Last_Start);\n+                     end if;\n+\n+                     End_State := Current_State;\n+\n+                  when '{' =>\n+                     declare\n+                        End_Sub          : Integer;\n+                        Start_Regexp_Sub : State_Index;\n+                        End_Regexp_Sub   : State_Index;\n+                        Create_Start     : State_Index := 0;\n+\n+                        Create_End : State_Index := 0;\n+                        --  Initialized to avoid junk warning\n+\n+                     begin\n+                        while S (J) /= '}' loop\n+\n+                           --  First step : find sub pattern\n+\n+                           End_Sub := J + 1;\n+                           while S (End_Sub) /= ','\n+                             and then S (End_Sub) /= '}'\n+                           loop\n+                              End_Sub := End_Sub + 1;\n+                           end loop;\n+\n+                           --  Second step : create a sub pattern\n+\n+                           Create_Simple\n+                             (J + 1,\n+                              End_Sub - 1,\n+                              Start_Regexp_Sub,\n+                              End_Regexp_Sub);\n+\n+                           J := End_Sub;\n+\n+                           --  Third step : create an alternative\n+\n+                           if Create_Start = 0 then\n+                              Current_State := Current_State + 1;\n+                              Create_Start := Current_State;\n+                              Add_Empty_Char (Create_Start, Start_Regexp_Sub);\n+                              Current_State := Current_State + 1;\n+                              Create_End := Current_State;\n+                              Add_Empty_Char (End_Regexp_Sub, Create_End);\n+\n+                           else\n+                              Current_State := Current_State + 1;\n+                              Add_Empty_Char (Current_State, Create_Start);\n+                              Create_Start := Current_State;\n+                              Add_Empty_Char (Create_Start, Start_Regexp_Sub);\n+                              Add_Empty_Char (End_Regexp_Sub, Create_End);\n+                           end if;\n+                        end loop;\n+\n+                        if End_State /= 0 then\n+                           Add_Empty_Char (End_State, Create_Start);\n+                        end if;\n+\n+                        End_State := Create_End;\n+                        Last_Start := Create_Start;\n+                     end;\n+\n+                  when '*' =>\n+                     Current_State := Current_State + 1;\n+\n+                     if End_State /= 0 then\n+                        Add_Empty_Char (End_State, Current_State);\n+                     end if;\n+\n+                     Add_Empty_Char (Current_State, Current_State + 1);\n+                     Add_Empty_Char (Current_State, Current_State + 3);\n+                     Last_Start := Current_State;\n+\n+                     Current_State := Current_State + 1;\n+\n+                     for K in 0 .. Alphabet_Size loop\n+                        Set (Table, Current_State, K,\n+                             Value => Current_State + 1);\n+                     end loop;\n+\n+                     Current_State := Current_State + 1;\n+                     Add_Empty_Char (Current_State, Current_State + 1);\n+\n+                     Current_State := Current_State + 1;\n+                     Add_Empty_Char (Current_State,  Last_Start);\n+                     End_State := Current_State;\n+\n+                  when others =>\n+                     Current_State := Current_State + 1;\n+\n+                     if S (J) = '?' then\n+                        for K in 0 .. Alphabet_Size loop\n+                           Set (Table, Current_State, K,\n+                                Value => Current_State + 1);\n+                        end loop;\n+\n+                     else\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                        end if;\n+\n+                        --  Create the state for the symbol S (J)\n+\n+                        Set (Table, Current_State, Map (S (J)),\n+                             Value => Current_State + 1);\n+                     end if;\n+\n+                     Last_Start := Current_State;\n+                     Current_State := Current_State + 1;\n+\n+                     if End_State /= 0 then\n+                        Add_Empty_Char (End_State, Last_Start);\n+                     end if;\n+\n+                     End_State := Current_State;\n+\n+               end case;\n+\n+               if Start_State = 0 then\n+                  Start_State := Last_Start;\n+               end if;\n+\n+               J := J + 1;\n+            end loop;\n+         end Create_Simple;\n+\n+      --  Start of processing for Create_Primary_Table_Glob\n+\n+      begin\n+         Table.all := (others => (others => 0));\n+         Create_Simple (S'First, S'Last, Start_State, End_State);\n+         Num_States := Current_State;\n+      end Create_Primary_Table_Glob;\n+\n+      ----------------------------\n+      -- Create_Secondary_Table --\n+      ----------------------------\n+\n+      function Create_Secondary_Table\n+        (First_Table : Regexp_Array_Access;\n+         Num_States  : State_Index;\n+         Start_State : State_Index;\n+         End_State   : State_Index)\n+         return        Regexp\n+      is\n+         Last_Index : constant State_Index := First_Table'Last (1);\n+         type Meta_State is array (1 .. Last_Index) of Boolean;\n+\n+         Table : Regexp_Array (1 .. Last_Index, 0 .. Alphabet_Size) :=\n+                   (others => (others => 0));\n+\n+         Meta_States : array (1 .. Last_Index + 1) of Meta_State :=\n+                         (others => (others => False));\n+\n+         Temp_State_Not_Null : Boolean;\n+\n+         Is_Final : Boolean_Array (1 .. Last_Index) := (others => False);\n+\n+         Current_State       : State_Index := 1;\n+         Nb_State            : State_Index := 1;\n+\n+         procedure Closure\n+           (State : in out Meta_State;\n+            Item  :        State_Index);\n+         --  Compute the closure of the state (that is every other state which\n+         --  has a empty-character transition) and add it to the state\n+\n+         -------------\n+         -- Closure --\n+         -------------\n+\n+         procedure Closure\n+           (State : in out Meta_State;\n+            Item  : State_Index)\n+         is\n+         begin\n+            if State (Item) then\n+               return;\n+            end if;\n+\n+            State (Item) := True;\n+\n+            for Column in Alphabet_Size + 1 .. First_Table'Last (2) loop\n+               if First_Table (Item, Column) = 0 then\n+                  return;\n+               end if;\n+\n+               Closure (State, First_Table (Item, Column));\n+            end loop;\n+         end Closure;\n+\n+      --  Start of procesing for Create_Secondary_Table\n+\n+      begin\n+         --  Create a new state\n+\n+         Closure (Meta_States (Current_State), Start_State);\n+\n+         while Current_State <= Nb_State loop\n+\n+            --  If this new meta-state includes the primary table end state,\n+            --  then this meta-state will be a final state in the regexp\n+\n+            if Meta_States (Current_State)(End_State) then\n+               Is_Final (Current_State) := True;\n+            end if;\n+\n+            --  For every character in the regexp, calculate the possible\n+            --  transitions from Current_State\n+\n+            for Column in 0 .. Alphabet_Size loop\n+               Meta_States (Nb_State + 1) := (others => False);\n+               Temp_State_Not_Null := False;\n+\n+               for K in Meta_States (Current_State)'Range loop\n+                  if Meta_States (Current_State)(K)\n+                    and then First_Table (K, Column) /= 0\n+                  then\n+                     Closure\n+                       (Meta_States (Nb_State + 1), First_Table (K, Column));\n+                     Temp_State_Not_Null := True;\n+                  end if;\n+               end loop;\n+\n+               --  If at least one transition existed\n+\n+               if Temp_State_Not_Null then\n+\n+                  --  Check if this new state corresponds to an old one\n+\n+                  for K in 1 .. Nb_State loop\n+                     if Meta_States (K) = Meta_States (Nb_State + 1) then\n+                        Table (Current_State, Column) := K;\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  --  If not, create a new state\n+\n+                  if Table (Current_State, Column) = 0 then\n+                     Nb_State := Nb_State + 1;\n+                     Table (Current_State, Column) := Nb_State;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            Current_State := Current_State + 1;\n+         end loop;\n+\n+         --  Returns the regexp\n+\n+         declare\n+            R : Regexp_Access;\n+\n+         begin\n+            R := new Regexp_Value (Alphabet_Size => Alphabet_Size,\n+                                   Num_States    => Nb_State);\n+            R.Map            := Map;\n+            R.Is_Final       := Is_Final (1 .. Nb_State);\n+            R.Case_Sensitive := Case_Sensitive;\n+\n+            for State in 1 .. Nb_State loop\n+               for K in 0 .. Alphabet_Size loop\n+                  R.States (State, K) := Table (State, K);\n+               end loop;\n+            end loop;\n+\n+            if Debug then\n+               Ada.Text_IO.New_Line;\n+               Ada.Text_IO.Put_Line (\"Secondary table : \");\n+               Print_Table (R.States, Nb_State, False);\n+            end if;\n+\n+            return (Ada.Finalization.Controlled with R => R);\n+         end;\n+      end Create_Secondary_Table;\n+\n+      -----------------\n+      -- Print_Table --\n+      -----------------\n+\n+      procedure Print_Table\n+        (Table      : Regexp_Array;\n+         Num_States : State_Index;\n+         Is_Primary : Boolean := True)\n+      is\n+         function Reverse_Mapping (N : Column_Index) return Character;\n+         --  Return the character corresponding to a column in the mapping\n+\n+         ---------------------\n+         -- Reverse_Mapping --\n+         ---------------------\n+\n+         function Reverse_Mapping (N : Column_Index) return Character is\n+         begin\n+            for Column in Map'Range loop\n+               if Map (Column) = N then\n+                  return Column;\n+               end if;\n+            end loop;\n+\n+            return ' ';\n+         end Reverse_Mapping;\n+\n+      --  Start of processing for Print_Table\n+\n+      begin\n+         --  Print the header line\n+\n+         Ada.Text_IO.Put (\"   [*]  \");\n+\n+         for Column in 1 .. Alphabet_Size  loop\n+            Ada.Text_IO.Put (String'(1 .. 1 => Reverse_Mapping (Column))\n+                             & \"   \");\n+         end loop;\n+\n+         if Is_Primary then\n+            Ada.Text_IO.Put (\"closure....\");\n+         end if;\n+\n+         Ada.Text_IO.New_Line;\n+\n+         --  Print every line\n+\n+         for State in 1 .. Num_States loop\n+            Ada.Text_IO.Put (State'Img);\n+\n+            for K in 1 .. 3 - State'Img'Length loop\n+               Ada.Text_IO.Put (\" \");\n+            end loop;\n+\n+            for K in 0 .. Alphabet_Size loop\n+               Ada.Text_IO.Put (Table (State, K)'Img & \"  \");\n+            end loop;\n+\n+            for K in Alphabet_Size + 1 .. Table'Last (2) loop\n+               if Table (State, K) /= 0 then\n+                  Ada.Text_IO.Put (Table (State, K)'Img & \",\");\n+               end if;\n+            end loop;\n+\n+            Ada.Text_IO.New_Line;\n+         end loop;\n+\n+      end Print_Table;\n+\n+      ---------------------\n+      -- Raise_Exception --\n+      ---------------------\n+\n+      procedure Raise_Exception\n+        (M     : String;\n+         Index : Integer)\n+      is\n+      begin\n+         Ada.Exceptions.Raise_Exception\n+           (Error_In_Regexp'Identity, M & \" at offset \" & Index'Img);\n+      end Raise_Exception;\n+\n+   --  Start of processing for Compile\n+\n+   begin\n+      if not Case_Sensitive then\n+         GNAT.Case_Util.To_Lower (S);\n+      end if;\n+\n+      Create_Mapping;\n+\n+      --  Creates the primary table\n+\n+      declare\n+         Table : Regexp_Array_Access;\n+         Num_States  : State_Index;\n+         Start_State : State_Index;\n+         End_State   : State_Index;\n+         R           : Regexp;\n+\n+      begin\n+         Table := new Regexp_Array (1 .. 100,\n+                                    0 .. Alphabet_Size + 10);\n+         if not Glob then\n+            Create_Primary_Table (Table, Num_States, Start_State, End_State);\n+         else\n+            Create_Primary_Table_Glob\n+              (Table, Num_States, Start_State, End_State);\n+         end if;\n+\n+         if Debug then\n+            Print_Table (Table.all, Num_States);\n+            Ada.Text_IO.Put_Line (\"Start_State : \" & Start_State'Img);\n+            Ada.Text_IO.Put_Line (\"End_State   : \" & End_State'Img);\n+         end if;\n+\n+         --  Creates the secondary table\n+\n+         R := Create_Secondary_Table\n+           (Table, Num_States, Start_State, End_State);\n+         Free (Table);\n+         return R;\n+      end;\n+   end Compile;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (R : in out Regexp) is\n+      procedure Free is new\n+        Unchecked_Deallocation (Regexp_Value, Regexp_Access);\n+\n+   begin\n+      Free (R.R);\n+   end Finalize;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get\n+     (Table  : Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index)\n+      return   State_Index\n+   is\n+   begin\n+      if State <= Table'Last (1)\n+        and then Column <= Table'Last (2)\n+      then\n+         return Table (State, Column);\n+      else\n+         return 0;\n+      end if;\n+   end Get;\n+\n+   -----------\n+   -- Match --\n+   -----------\n+\n+   function Match (S : String; R : Regexp) return Boolean is\n+      Current_State : State_Index := 1;\n+\n+   begin\n+      if R.R = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      for Char in S'Range loop\n+\n+         if R.R.Case_Sensitive then\n+            Current_State := R.R.States (Current_State, R.R.Map (S (Char)));\n+         else\n+            Current_State :=\n+              R.R.States (Current_State,\n+                          R.R.Map (GNAT.Case_Util.To_Lower (S (Char))));\n+         end if;\n+\n+         if Current_State = 0 then\n+            return False;\n+         end if;\n+\n+      end loop;\n+\n+      return R.R.Is_Final (Current_State);\n+   end Match;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set\n+     (Table  : in out Regexp_Array_Access;\n+      State  : State_Index;\n+      Column : Column_Index;\n+      Value  : State_Index)\n+   is\n+      New_Lines   : State_Index;\n+      New_Columns : Column_Index;\n+      New_Table   : Regexp_Array_Access;\n+\n+   begin\n+      if State <= Table'Last (1)\n+        and then Column <= Table'Last (2)\n+      then\n+         Table (State, Column) := Value;\n+      else\n+         --  Doubles the size of the table until it is big enough that\n+         --  (State, Column) is a valid index\n+\n+         New_Lines := Table'Last (1) * (State / Table'Last (1) + 1);\n+         New_Columns := Table'Last (2) * (Column / Table'Last (2) + 1);\n+         New_Table := new Regexp_Array (Table'First (1) .. New_Lines,\n+                                        Table'First (2) .. New_Columns);\n+         New_Table.all := (others => (others => 0));\n+\n+         if Debug then\n+            Ada.Text_IO.Put_Line (\"Reallocating table: Lines from \"\n+                                  & State_Index'Image (Table'Last (1)) & \" to \"\n+                                  & State_Index'Image (New_Lines));\n+            Ada.Text_IO.Put_Line (\"   and columns from \"\n+                                  & Column_Index'Image (Table'Last (2))\n+                                  & \" to \"\n+                                  & Column_Index'Image (New_Columns));\n+         end if;\n+\n+         for J in Table'Range (1) loop\n+            for K in Table'Range (2) loop\n+               New_Table (J, K) := Table (J, K);\n+            end loop;\n+         end loop;\n+\n+         Free (Table);\n+         Table := New_Table;\n+         Table (State, Column) := Value;\n+      end if;\n+   end Set;\n+\n+end GNAT.Regexp;"}, {"sha": "7e45e0eab67b7351b7f3e0ed22edfbe5e4b0c86d", "filename": "gcc/ada/g-regexp.ads", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regexp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regexp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regexp.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,163 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G N A T . R E G E X P                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--           Copyright (C) 1998-1999 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Simple Regular expression matching\n+\n+--  This package provides a simple implementation of a regular expression\n+--  pattern matching algorithm, using a subset of the syntax of regular\n+--  expressions copied from familiar Unix style utilities.\n+\n+------------------------------------------------------------\n+-- Summary of Pattern Matching Packages in GNAT Hierarchy --\n+------------------------------------------------------------\n+\n+--  There are three related packages that perform pattern maching functions.\n+--  the following is an outline of these packages, to help you determine\n+--  which is best for your needs.\n+\n+--     GNAT.Regexp (files g-regexp.ads/g-regexp.adb)\n+--       This is a simple package providing Unix-style regular expression\n+--       matching with the restriction that it matches entire strings. It\n+--       is particularly useful for file name matching, and in particular\n+--       it provides \"globbing patterns\" that are useful in implementing\n+--       unix or DOS style wild card matching for file names.\n+\n+--     GNAT.Regpat (files g-regpat.ads/g-regpat.adb)\n+--       This is a more complete implementation of Unix-style regular\n+--       expressions, copied from the original V7 style regular expression\n+--       library written in C by Henry Spencer. It is functionally the\n+--       same as this library, and uses the same internal data structures\n+--       stored in a binary compatible manner.\n+\n+--     GNAT.Spitbol.Patterns (files g-spipat.ads/g-spipat.adb)\n+--       This is a completely general patterm matching package based on the\n+--       pattern language of SNOBOL4, as implemented in SPITBOL. The pattern\n+--       language is modeled on context free grammars, with context sensitive\n+--       extensions that provide full (type 0) computational capabilities.\n+\n+with Ada.Finalization;\n+\n+package GNAT.Regexp is\n+\n+   --  The regular expression must first be compiled, using the Compile\n+   --  function, which creates a finite state matching table, allowing\n+   --  very fast matching once the expression has been compiled.\n+\n+   --  The following is the form of a regular expression, expressed in Ada\n+   --  reference manual style BNF is as follows\n+\n+   --     regexp ::= term\n+\n+   --     regexp ::= term | term          -- alternation (term or term ...)\n+\n+   --     term ::= item\n+\n+   --     term ::= item item ...          -- concatenation (item then item)\n+\n+   --     item ::= elmt                   -- match elmt\n+   --     item ::= elmt *                 -- zero or more elmt's\n+   --     item ::= elmt +                 -- one or more elmt's\n+   --     item ::= elmt ?                 -- matches elmt or nothing\n+\n+   --     elmt ::= nchr                   -- matches given character\n+   --     elmt ::= [nchr nchr ...]        -- matches any character listed\n+   --     elmt ::= [^ nchr nchr ...]      -- matches any character not listed\n+   --     elmt ::= [char - char]          -- matches chars in given range\n+   --     elmt ::= .                      -- matches any single character\n+   --     elmt ::= ( regexp )             -- parens used for grouping\n+\n+   --     char ::= any character, including special characters\n+   --     nchr ::= any character except \\()[].*+?^ or \\char to match char\n+   --     ... is used to indication repetition (one or more terms)\n+\n+   --  See also regexp(1) man page on Unix systems for further details\n+\n+   --  A second kind of regular expressions is provided. This one is more\n+   --  like the wild card patterns used in file names by the Unix shell (or\n+   --  DOS prompt) command lines. The grammar is the following:\n+\n+   --     regexp ::= term\n+\n+   --     term   ::= elmt\n+\n+   --     term   ::= elmt elmt ...     -- concatenation (elmt then elmt)\n+   --     term   ::= *                 -- any string of 0 or more characters\n+   --     term   ::= ?                 -- matches any character\n+   --     term   ::= [char char ...]   -- matches any character listed\n+   --     term   ::= [char - char]     -- matches any character in given range\n+   --     term   ::= {elmt, elmt, ...} -- alternation (matches any of elmt)\n+\n+   --  Important note : This package was mainly intended to match regular\n+   --  expressions against file names. The whole string has to match the\n+   --  regular expression. If only a substring matches, then the function\n+   --  Match will return False.\n+\n+   type Regexp is private;\n+   --  Private type used to represent a regular expression\n+\n+   Error_In_Regexp : exception;\n+   --  Exception raised when an error is found in the regular expression\n+\n+   function Compile\n+     (Pattern        : String;\n+      Glob           : Boolean := False;\n+      Case_Sensitive : Boolean := True)\n+      return           Regexp;\n+   --  Compiles a regular expression S. If the syntax of the given\n+   --  expression is invalid (does not match above grammar, Error_In_Regexp\n+   --  is raised. If Glob is True, the pattern is considered as a 'globbing\n+   --  pattern', that is a pattern as given by the second grammar above\n+\n+   function Match (S : String; R : Regexp) return Boolean;\n+   --  True if S matches R, otherwise False. Raises Constraint_Error if\n+   --  R is an uninitialized regular expression value.\n+\n+private\n+   type Regexp_Value;\n+\n+   type Regexp_Access is access Regexp_Value;\n+\n+   type Regexp is new Ada.Finalization.Controlled with record\n+      R : Regexp_Access := null;\n+   end record;\n+\n+   pragma Finalize_Storage_Only (Regexp);\n+\n+   procedure Finalize (R : in out Regexp);\n+   --  Free the memory occupied by R\n+\n+   procedure Adjust (R : in out Regexp);\n+   --  Called after an assignment (do a copy of the Regexp_Access.all)\n+\n+end GNAT.Regexp;"}, {"sha": "97e58fbc24e5d83c8509c015f699c2c711386fe0", "filename": "gcc/ada/g-regist.adb", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regist.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,434 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         G N A T . R E G I S T R Y                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--              Copyright (C) 2001 Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Exceptions;\n+with Interfaces.C;\n+with System;\n+\n+package body GNAT.Registry is\n+\n+   use Ada;\n+   use System;\n+\n+   ------------------------------\n+   -- Binding to the Win32 API --\n+   ------------------------------\n+\n+   subtype LONG is Interfaces.C.long;\n+   subtype ULONG is Interfaces.C.unsigned_long;\n+   subtype DWORD is ULONG;\n+\n+   type    PULONG is access all ULONG;\n+   subtype PDWORD is PULONG;\n+   subtype LPDWORD is PDWORD;\n+\n+   subtype Error_Code is LONG;\n+\n+   subtype REGSAM is LONG;\n+\n+   type PHKEY is access all HKEY;\n+\n+   ERROR_SUCCESS : constant Error_Code := 0;\n+\n+   REG_SZ : constant := 1;\n+\n+   function RegCloseKey (Key : HKEY) return LONG;\n+   pragma Import (Stdcall, RegCloseKey, \"RegCloseKey\");\n+\n+   function RegCreateKeyEx\n+     (Key                  : HKEY;\n+      lpSubKey             : Address;\n+      Reserved             : DWORD;\n+      lpClass              : Address;\n+      dwOptions            : DWORD;\n+      samDesired           : REGSAM;\n+      lpSecurityAttributes : Address;\n+      phkResult            : PHKEY;\n+      lpdwDisposition      : LPDWORD)\n+      return                 LONG;\n+   pragma Import (Stdcall, RegCreateKeyEx, \"RegCreateKeyExA\");\n+\n+   function RegDeleteKey\n+     (Key      : HKEY;\n+      lpSubKey : Address)\n+      return     LONG;\n+   pragma Import (Stdcall, RegDeleteKey, \"RegDeleteKeyA\");\n+\n+   function RegDeleteValue\n+     (Key         : HKEY;\n+      lpValueName : Address)\n+      return        LONG;\n+   pragma Import (Stdcall, RegDeleteValue, \"RegDeleteValueA\");\n+\n+   function RegEnumValue\n+     (Key           : HKEY;\n+      dwIndex       : DWORD;\n+      lpValueName   : Address;\n+      lpcbValueName : LPDWORD;\n+      lpReserved    : LPDWORD;\n+      lpType        : LPDWORD;\n+      lpData        : Address;\n+      lpcbData      : LPDWORD)\n+      return          LONG;\n+   pragma Import (Stdcall, RegEnumValue, \"RegEnumValueA\");\n+\n+   function RegOpenKeyEx\n+     (Key        : HKEY;\n+      lpSubKey   : Address;\n+      ulOptions  : DWORD;\n+      samDesired : REGSAM;\n+      phkResult  : PHKEY)\n+      return       LONG;\n+   pragma Import (Stdcall, RegOpenKeyEx, \"RegOpenKeyExA\");\n+\n+   function RegQueryValueEx\n+     (Key         : HKEY;\n+      lpValueName : Address;\n+      lpReserved  : LPDWORD;\n+      lpType      : LPDWORD;\n+      lpData      : Address;\n+      lpcbData    : LPDWORD)\n+      return        LONG;\n+   pragma Import (Stdcall, RegQueryValueEx, \"RegQueryValueExA\");\n+\n+   function RegSetValueEx\n+     (Key         : HKEY;\n+      lpValueName : Address;\n+      Reserved    : DWORD;\n+      dwType      : DWORD;\n+      lpData      : Address;\n+      cbData      : DWORD)\n+      return        LONG;\n+   pragma Import (Stdcall, RegSetValueEx, \"RegSetValueExA\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function To_C_Mode (Mode : Key_Mode) return REGSAM;\n+   --  Returns the Win32 mode value for the Key_Mode value.\n+\n+   procedure Check_Result (Result : LONG; Message : String);\n+   --  Checks value Result and raise the exception Registry_Error if it is not\n+   --  equal to ERROR_SUCCESS. Message and the error value (Result) is added\n+   --  to the exception message.\n+\n+   ------------------\n+   -- Check_Result --\n+   ------------------\n+\n+   procedure Check_Result (Result : LONG; Message : String) is\n+      use type LONG;\n+\n+   begin\n+      if Result /= ERROR_SUCCESS then\n+         Exceptions.Raise_Exception\n+           (Registry_Error'Identity,\n+            Message & \" (\" & LONG'Image (Result) & ')');\n+      end if;\n+   end Check_Result;\n+\n+   ---------------\n+   -- Close_Key --\n+   ---------------\n+\n+   procedure Close_Key (Key : HKEY) is\n+      Result : LONG;\n+\n+   begin\n+      Result := RegCloseKey (Key);\n+      Check_Result (Result, \"Close_Key\");\n+   end Close_Key;\n+\n+   ----------------\n+   -- Create_Key --\n+   ----------------\n+\n+   function Create_Key\n+     (From_Key : HKEY;\n+      Sub_Key  : String;\n+      Mode     : Key_Mode := Read_Write)\n+      return     HKEY\n+   is\n+      use type REGSAM;\n+      use type DWORD;\n+\n+      REG_OPTION_NON_VOLATILE : constant := 16#0#;\n+\n+      C_Sub_Key : constant String := Sub_Key & ASCII.Nul;\n+      C_Class   : constant String := \"\" & ASCII.Nul;\n+      C_Mode    : constant REGSAM := To_C_Mode (Mode);\n+\n+      New_Key : aliased HKEY;\n+      Result  : LONG;\n+      Dispos  : aliased DWORD;\n+\n+   begin\n+      Result := RegCreateKeyEx\n+        (From_Key,\n+         C_Sub_Key (C_Sub_Key'First)'Address,\n+         0,\n+         C_Class (C_Class'First)'Address,\n+         REG_OPTION_NON_VOLATILE,\n+         C_Mode,\n+         Null_Address,\n+         New_Key'Unchecked_Access,\n+         Dispos'Unchecked_Access);\n+\n+      Check_Result (Result, \"Create_Key \" & Sub_Key);\n+      return New_Key;\n+   end Create_Key;\n+\n+   ----------------\n+   -- Delete_Key --\n+   ----------------\n+\n+   procedure Delete_Key (From_Key : HKEY; Sub_Key : String) is\n+      C_Sub_Key : constant String := Sub_Key & ASCII.Nul;\n+      Result    : LONG;\n+\n+   begin\n+      Result := RegDeleteKey (From_Key, C_Sub_Key (C_Sub_Key'First)'Address);\n+      Check_Result (Result, \"Delete_Key \" & Sub_Key);\n+   end Delete_Key;\n+\n+   ------------------\n+   -- Delete_Value --\n+   ------------------\n+\n+   procedure Delete_Value (From_Key : HKEY; Sub_Key : String) is\n+      C_Sub_Key : constant String := Sub_Key & ASCII.Nul;\n+      Result    : LONG;\n+\n+   begin\n+      Result := RegDeleteValue (From_Key, C_Sub_Key (C_Sub_Key'First)'Address);\n+      Check_Result (Result, \"Delete_Value \" & Sub_Key);\n+   end Delete_Value;\n+\n+   -------------------------\n+   -- For_Every_Key_Value --\n+   -------------------------\n+\n+   procedure For_Every_Key_Value (From_Key : HKEY) is\n+      use type LONG;\n+      use type ULONG;\n+\n+      Index  : ULONG := 0;\n+      Result : LONG;\n+\n+      Sub_Key : String (1 .. 100);\n+      pragma Warnings (Off, Sub_Key);\n+\n+      Value : String (1 .. 100);\n+      pragma Warnings (Off, Value);\n+\n+      Size_Sub_Key : aliased ULONG;\n+      Size_Value   : aliased ULONG;\n+      Type_Sub_Key : aliased DWORD;\n+\n+      Quit : Boolean;\n+\n+   begin\n+      loop\n+         Size_Sub_Key := Sub_Key'Length;\n+         Size_Value   := Value'Length;\n+\n+         Result := RegEnumValue\n+           (From_Key, Index,\n+            Sub_Key (1)'Address,\n+            Size_Sub_Key'Unchecked_Access,\n+            null,\n+            Type_Sub_Key'Unchecked_Access,\n+            Value (1)'Address,\n+            Size_Value'Unchecked_Access);\n+\n+         exit when not (Result = ERROR_SUCCESS);\n+\n+         if Type_Sub_Key = REG_SZ then\n+            Quit := False;\n+\n+            Action (Natural (Index) + 1,\n+                    Sub_Key (1 .. Integer (Size_Sub_Key)),\n+                    Value (1 .. Integer (Size_Value) - 1),\n+                    Quit);\n+\n+            exit when Quit;\n+\n+            Index := Index + 1;\n+         end if;\n+\n+      end loop;\n+   end For_Every_Key_Value;\n+\n+   ----------------\n+   -- Key_Exists --\n+   ----------------\n+\n+   function Key_Exists\n+     (From_Key : HKEY;\n+      Sub_Key  : String)\n+      return     Boolean\n+   is\n+      New_Key : HKEY;\n+\n+   begin\n+      New_Key := Open_Key (From_Key, Sub_Key);\n+      Close_Key (New_Key);\n+\n+      --  We have been able to open the key so it exists\n+\n+      return True;\n+\n+   exception\n+      when Registry_Error =>\n+\n+         --  An error occured, the key was not found\n+\n+         return False;\n+   end Key_Exists;\n+\n+   --------------\n+   -- Open_Key --\n+   --------------\n+\n+   function Open_Key\n+     (From_Key : HKEY;\n+      Sub_Key  : String;\n+      Mode     : Key_Mode := Read_Only)\n+      return     HKEY\n+   is\n+      use type REGSAM;\n+\n+      C_Sub_Key : constant String := Sub_Key & ASCII.Nul;\n+      C_Mode    : constant REGSAM := To_C_Mode (Mode);\n+\n+      New_Key   : aliased HKEY;\n+      Result    : LONG;\n+\n+   begin\n+      Result := RegOpenKeyEx\n+        (From_Key,\n+         C_Sub_Key (C_Sub_Key'First)'Address,\n+         0,\n+         C_Mode,\n+         New_Key'Unchecked_Access);\n+\n+      Check_Result (Result, \"Open_Key \" & Sub_Key);\n+      return New_Key;\n+   end Open_Key;\n+\n+   -----------------\n+   -- Query_Value --\n+   -----------------\n+\n+   function Query_Value\n+     (From_Key : HKEY;\n+      Sub_Key  : String)\n+      return     String\n+   is\n+      use type LONG;\n+      use type ULONG;\n+\n+      Value : String (1 .. 100);\n+      pragma Warnings (Off, Value);\n+\n+      Size_Value : aliased ULONG;\n+      Type_Value : aliased DWORD;\n+\n+      C_Sub_Key : constant String := Sub_Key & ASCII.Nul;\n+      Result    : LONG;\n+\n+   begin\n+      Size_Value := Value'Length;\n+\n+      Result := RegQueryValueEx\n+        (From_Key,\n+         C_Sub_Key (C_Sub_Key'First)'Address,\n+         null,\n+         Type_Value'Unchecked_Access,\n+         Value (Value'First)'Address,\n+         Size_Value'Unchecked_Access);\n+\n+      Check_Result (Result, \"Query_Value \" & Sub_Key & \" key\");\n+\n+      return Value (1 .. Integer (Size_Value - 1));\n+   end Query_Value;\n+\n+   ---------------\n+   -- Set_Value --\n+   ---------------\n+\n+   procedure Set_Value\n+     (From_Key : HKEY;\n+      Sub_Key  : String;\n+      Value    : String)\n+   is\n+      C_Sub_Key : constant String := Sub_Key & ASCII.Nul;\n+      C_Value   : constant String := Value & ASCII.Nul;\n+\n+      Result : LONG;\n+\n+   begin\n+      Result := RegSetValueEx\n+        (From_Key,\n+         C_Sub_Key (C_Sub_Key'First)'Address,\n+         0,\n+         REG_SZ,\n+         C_Value (C_Value'First)'Address,\n+         C_Value'Length);\n+\n+      Check_Result (Result, \"Set_Value \" & Sub_Key & \" key\");\n+   end Set_Value;\n+\n+   ---------------\n+   -- To_C_Mode --\n+   ---------------\n+\n+   function To_C_Mode (Mode : Key_Mode) return REGSAM is\n+      use type REGSAM;\n+\n+      KEY_READ  : constant :=  16#20019#;\n+      KEY_WRITE : constant :=  16#20006#;\n+\n+   begin\n+      case Mode is\n+         when Read_Only =>\n+            return KEY_READ;\n+\n+         when Read_Write =>\n+            return KEY_READ + KEY_WRITE;\n+      end case;\n+   end To_C_Mode;\n+\n+end GNAT.Registry;"}, {"sha": "3cf06a883408793ecae2ba69624b9519c746f050", "filename": "gcc/ada/g-regist.ads", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regist.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,133 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         G N A T . R E G I S T R Y                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--              Copyright (C) 2001 Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The registry is a Windows database to store key/value pair. It is used\n+--  to keep Windows operation system and applications configuration options.\n+--  The database is a hierarchal set of key and for each key a value can\n+--  be associated. This package provides high level routines to deal with\n+--  the Windows registry. For full registry API, but at a lower level of\n+--  abstraction, refer to the Win32.Winreg package provided with the\n+--  Win32Ada binding. For example this binding handle only key values of\n+--  type Standard.String.\n+\n+--  This package is specific to the NT version of GNAT, and is not available\n+--  on any other platforms.\n+\n+package GNAT.Registry is\n+\n+   type HKEY is private;\n+   --  HKEY is a handle to a registry key, including standard registry keys:\n+   --  HKEY_CLASSES_ROOT, HKEY_CURRENT_CONFIG, HKEY_CURRENT_USER,\n+   --  HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_PERFORMANCE_DATA.\n+\n+   HKEY_CLASSES_ROOT     : constant HKEY;\n+   HKEY_CURRENT_USER     : constant HKEY;\n+   HKEY_CURRENT_CONFIG   : constant HKEY;\n+   HKEY_LOCAL_MACHINE    : constant HKEY;\n+   HKEY_USERS            : constant HKEY;\n+   HKEY_PERFORMANCE_DATA : constant HKEY;\n+\n+   type Key_Mode is (Read_Only, Read_Write);\n+   --  Access mode for the registry key.\n+\n+   Registry_Error : exception;\n+   --  Registry_Error is raises by all routines below if a problem occurs\n+   --  (key cannot be opened, key cannot be found etc).\n+\n+   function Create_Key\n+     (From_Key : HKEY;\n+      Sub_Key  : String;\n+      Mode     : Key_Mode := Read_Write)\n+      return     HKEY;\n+   --  Open or create a key (named Sub_Key) in the Windows registry database.\n+   --  The key will be created under key From_Key. It returns the key handle.\n+   --  From_Key must be a valid handle to an already opened key or one of\n+   --  the standard keys identified by HKEY declarations above.\n+\n+   function Open_Key\n+     (From_Key : HKEY;\n+      Sub_Key  : String;\n+      Mode     : Key_Mode := Read_Only)\n+      return     HKEY;\n+   --  Return a registry key handle for key named Sub_Key opened under key\n+   --  From_Key. It is possible to open a key at any level in the registry\n+   --  tree in a single call to Open_Key.\n+\n+   procedure Close_Key (Key : HKEY);\n+   --  Close registry key handle. All resources used by Key are released.\n+\n+   function Key_Exists (From_Key : HKEY; Sub_Key : String) return Boolean;\n+   --  Returns True if Sub_Key is defined under From_Key in the registry.\n+\n+   function Query_Value (From_Key : HKEY; Sub_Key : String) return String;\n+   --  Returns the registry key's value associated with Sub_Key in From_Key\n+   --  registry key.\n+\n+   procedure Set_Value (From_Key : HKEY; Sub_Key : String; Value : String);\n+   --  Add the pair (Sub_Key, Value) into From_Key registry key.\n+\n+   procedure Delete_Key (From_Key : HKEY; Sub_Key : String);\n+   --  Remove Sub_Key from the registry key From_Key.\n+\n+   procedure Delete_Value (From_Key : HKEY; Sub_Key : String);\n+   --  Remove the named value Sub_Key from the registry key From_Key.\n+\n+   generic\n+      with procedure Action\n+        (Index   : Positive;\n+         Sub_Key : String;\n+         Value   : String;\n+         Quit    : in out Boolean);\n+   procedure For_Every_Key_Value (From_Key : HKEY);\n+   --  Iterates over all the pairs (Sub_Key, Value) registered under\n+   --  From_Key. Index will be set to 1 for the first key and will be\n+   --  incremented by one in each iteration. Quit can be set to True to\n+   --  stop iteration; its initial value is False.\n+   --\n+   --  Key value that are not of type string are skipped. In this case, the\n+   --  iterator behaves exactly as if the key was not present. Note that you\n+   --  must use the Win32.Winreg API to deal with this case.\n+\n+private\n+\n+   type HKEY is mod 2 ** Integer'Size;\n+\n+   HKEY_CLASSES_ROOT     : constant HKEY := 16#80000000#;\n+   HKEY_CURRENT_USER     : constant HKEY := 16#80000001#;\n+   HKEY_LOCAL_MACHINE    : constant HKEY := 16#80000002#;\n+   HKEY_USERS            : constant HKEY := 16#80000003#;\n+   HKEY_PERFORMANCE_DATA : constant HKEY := 16#80000004#;\n+   HKEY_CURRENT_CONFIG   : constant HKEY := 16#80000005#;\n+\n+end GNAT.Registry;"}, {"sha": "f36d5bf9ffcee8da003ba8d4bf9e267ae3624049", "filename": "gcc/ada/g-regpat.adb", "status": "added", "additions": 3545, "deletions": 0, "changes": 3545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regpat.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "5d6c4b764992357823239788a9e06ae276883ff3", "filename": "gcc/ada/g-regpat.ads", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regpat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-regpat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regpat.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,548 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . R E G P A T                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.27 $\n+--                                                                          --\n+--               Copyright (C) 1986 by University of Toronto.               --\n+--           Copyright (C) 1996-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements roughly the same set of regular expressions as\n+--  are available in the Perl or Python programming languages.\n+\n+--  This is an extension of the original V7 style regular expression library\n+--  written in C by Henry Spencer. Apart from the translation to Ada, the\n+--  interface has been considerably changed to use the Ada String type\n+--  instead of C-style nul-terminated strings.\n+\n+------------------------------------------------------------\n+-- Summary of Pattern Matching Packages in GNAT Hierarchy --\n+------------------------------------------------------------\n+\n+--  There are three related packages that perform pattern maching functions.\n+--  the following is an outline of these packages, to help you determine\n+--  which is best for your needs.\n+\n+--     GNAT.Regexp (files g-regexp.ads/g-regexp.adb)\n+--       This is a simple package providing Unix-style regular expression\n+--       matching with the restriction that it matches entire strings. It\n+--       is particularly useful for file name matching, and in particular\n+--       it provides \"globbing patterns\" that are useful in implementing\n+--       unix or DOS style wild card matching for file names.\n+\n+--     GNAT.Regpat (files g-regpat.ads/g-regpat.adb)\n+--       This is a more complete implementation of Unix-style regular\n+--       expressions, copied from the Perl regular expression engine,\n+--       written originally in C by Henry Spencer. It is functionally the\n+--       same as that library.\n+\n+--     GNAT.Spitbol.Patterns (files g-spipat.ads/g-spipat.adb)\n+--       This is a completely general pattern matching package based on the\n+--       pattern language of SNOBOL4, as implemented in SPITBOL. The pattern\n+--       language is modeled on context free grammars, with context sensitive\n+--       extensions that provide full (type 0) computational capabilities.\n+\n+package GNAT.Regpat is\n+pragma Preelaborate (Regpat);\n+\n+   --  The grammar is the following:\n+\n+   --     regexp ::= expr\n+   --            ::= ^ expr               -- anchor at the beginning of string\n+   --            ::= expr $               -- anchor at the end of string\n+   --     expr   ::= term\n+   --            ::= term | term          -- alternation (term or term ...)\n+   --     term   ::= item\n+   --            ::= item item ...        -- concatenation (item then item)\n+   --     item   ::= elmt                 -- match elmt\n+   --            ::= elmt *               -- zero or more elmt's\n+   --            ::= elmt +               -- one or more elmt's\n+   --            ::= elmt ?               -- matches elmt or nothing\n+   --            ::= elmt *?              -- zero or more times, minimum number\n+   --            ::= elmt +?              -- one or more times, minimum number\n+   --            ::= elmt ??              -- zero or one time, minimum number\n+   --            ::= elmt { num }         -- matches elmt exactly num times\n+   --            ::= elmt { num , }       -- matches elmt at least num times\n+   --            ::= elmt { num , num2 }  -- matches between num and num2 times\n+   --            ::= elmt { num }?        -- matches elmt exactly num times\n+   --            ::= elmt { num , }?      -- matches elmt at least num times\n+   --                                        non-greedy version\n+   --            ::= elmt { num , num2 }? -- matches between num and num2 times\n+   --                                        non-greedy version\n+   --     elmt   ::= nchr                 -- matches given character\n+   --            ::= [range range ...]    -- matches any character listed\n+   --            ::= [^ range range ...]  -- matches any character not listed\n+   --            ::= .                    -- matches any single character\n+   --                                     -- except newlines\n+   --            ::= ( expr )             -- parens used for grouping\n+   --            ::= \\ num                -- reference to num-th parenthesis\n+   --     range  ::= char - char          -- matches chars in given range\n+   --            ::= nchr\n+   --            ::= [: posix :]          -- any character in the POSIX range\n+   --            ::= [:^ posix :]         -- not in the POSIX range\n+   --     posix  ::= alnum                -- alphanumeric characters\n+   --            ::= alpha                -- alphabetic characters\n+   --            ::= ascii                -- ascii characters (0 .. 127)\n+   --            ::= cntrl                -- control chars (0..31, 127..159)\n+   --            ::= digit                -- digits ('0' .. '9')\n+   --            ::= graph                -- graphic chars (32..126, 160..255)\n+   --            ::= lower                -- lower case characters\n+   --            ::= print                -- printable characters (32..127)\n+   --            ::= punct                -- printable, except alphanumeric\n+   --            ::= space                -- space characters\n+   --            ::= upper                -- upper case characters\n+   --            ::= word                 -- alphanumeric characters\n+   --            ::= xdigit               -- hexadecimal chars (0..9, a..f)\n+\n+   --     char   ::= any character, including special characters\n+   --                ASCII.NUL is not supported.\n+   --     nchr   ::= any character except \\()[].*+?^ or \\char to match char\n+   --                \\n means a newline (ASCII.LF)\n+   --                \\t means a tab (ASCII.HT)\n+   --                \\r means a return (ASCII.CR)\n+   --                \\b matches the empty string at the beginning or end of a\n+   --                   word. A word is defined as a set of alphanumerical\n+   --                   characters (see \\w below).\n+   --                \\B matches the empty string only when *not* at the\n+   --                   beginning or end of a word.\n+   --                \\d matches any digit character ([0-9])\n+   --                \\D matches any non digit character ([^0-9])\n+   --                \\s matches any white space character. This is equivalent\n+   --                   to [ \\t\\n\\r\\f\\v]  (tab, form-feed, vertical-tab,...\n+   --                \\S matches any non-white space character.\n+   --                \\w matches any alphanumeric character or underscore.\n+   --                   This include accented letters, as defined in the\n+   --                   package Ada.Characters.Handling.\n+   --                \\W matches any non-alphanumeric character.\n+   --                \\A match the empty string only at the beginning of the\n+   --                   string, whatever flags are used for Compile (the\n+   --                   behavior of ^ can change, see Regexp_Flags below).\n+   --                \\G match the empty string only at the end of the\n+   --                   string, whatever flags are used for Compile (the\n+   --                   behavior of $ can change, see Regexp_Flags below).\n+   --     ...    ::= is used to indication repetition (one or more terms)\n+\n+   --  Embedded newlines are not matched by the ^ operator.\n+   --  It is possible to retrieve the substring matched a parenthesis\n+   --  expression. Although the depth of parenthesis is not limited in the\n+   --  regexp, only the first 9 substrings can be retrieved.\n+\n+   --  The highest value possible for the arguments to the curly operator ({})\n+   --  are given by the constant Max_Curly_Repeat below.\n+\n+   --  The operators '*', '+', '?' and '{}' always match the longest possible\n+   --  substring. They all have a non-greedy version (with an extra ? after the\n+   --  operator), which matches the shortest possible substring.\n+\n+   --  For instance:\n+   --      regexp=\"<.*>\"   string=\"<h1>title</h1>\"   matches=\"<h1>title</h1>\"\n+   --      regexp=\"<.*?>\"  string=\"<h1>title</h1>\"   matches=\"<h1>\"\n+   --\n+   --  '{' and '}' are only considered as special characters if they appear\n+   --  in a substring that looks exactly like '{n}', '{n,m}' or '{n,}', where\n+   --  n and m are digits. No space is allowed. In other contexts, the curly\n+   --  braces will simply be treated as normal characters.\n+\n+   --  Compiling Regular Expressions\n+   --  =============================\n+\n+   --  To use this package, you first need to compile the regular expression\n+   --  (a string) into a byte-code program, in a Pattern_Matcher structure.\n+   --  This first step checks that the regexp is valid, and optimizes the\n+   --  matching algorithms of the second step.\n+\n+   --  Two versions of the Compile subprogram are given: one in which this\n+   --  package will compute itself the best possible size to allocate for the\n+   --  byte code; the other where you must allocate enough memory yourself. An\n+   --  exception is raised if there is not enough memory.\n+\n+   --     declare\n+   --        Regexp : String := \"a|b\";\n+\n+   --        Matcher : Pattern_Matcher := Compile (Regexp);\n+   --        --  The size for matcher is automatically allocated\n+\n+   --        Matcher2 : Pattern_Matcher (1000);\n+   --        --  Some space is allocated directly.\n+\n+   --     begin\n+   --        Compile (Matcher2, Regexp);\n+   --        ...\n+   --     end;\n+\n+   --  Note that the second version is significantly faster, since with the\n+   --  first version the regular expression has in fact to be compiled twice\n+   --  (first to compute the size, then to generate the byte code).\n+\n+   --  Note also that you can not use the function version of Compile if you\n+   --  specify the size of the Pattern_Matcher, since the discriminants will\n+   --  most probably be different and you will get a Constraint_Error\n+\n+   --  Matching Strings\n+   --  ================\n+\n+   --  Once the regular expression has been compiled, you can use it as often\n+   --  as needed to match strings.\n+\n+   --  Several versions of the Match subprogram are provided, with different\n+   --  parameters and return results.\n+\n+   --  See the description under each of these subprograms.\n+\n+   --  Here is a short example showing how to get the substring matched by\n+   --  the first parenthesis pair.\n+\n+   --     declare\n+   --        Matches : Match_Array;\n+   --        Regexp  : String := \"a(b|c)d\";\n+   --        Str     : String := \"gacdg\";\n+\n+   --     begin\n+   --        Match (Compile (Regexp), Str, Matches);\n+   --        return Str (Matches (1).First .. Matches (1).Last);\n+   --        --  returns 'c'\n+   --     end;\n+\n+   --  String Substitution\n+   --  ===================\n+\n+   --  No subprogram is currently provided for string substitution.\n+   --  However, this is easy to simulate with the parenthesis groups, as\n+   --  shown below.\n+\n+   --  This example swaps the first two words of the string:\n+\n+   --     declare\n+   --        Regexp  : String := \"([a-z]+) +([a-z]+)\";\n+   --        Str     : String := \" first   second third \";\n+   --        Matches : Match_Array;\n+\n+   --     begin\n+   --        Match (Compile (Regexp), Str, Matches);\n+   --        return Str (Str'First .. Matches (1).First - 1)\n+   --               & Str (Matches (2).First .. Matches (2).Last)\n+   --               & \" \"\n+   --               & Str (Matches (1).First .. Matches (1).Last)\n+   --               & Str (Matches (2).Last + 1 .. Str'Last);\n+   --        --  returns \" second first third \"\n+   --     end;\n+\n+   ---------------\n+   -- Constants --\n+   ---------------\n+\n+   Expression_Error : exception;\n+   --  This exception is raised when trying to compile an invalid\n+   --  regular expression. All subprograms taking an expression\n+   --  as parameter may raise Expression_Error.\n+\n+   Max_Paren_Count : constant := 255;\n+   --  Maximum number of parenthesis in a regular expression.\n+   --  This is limited by the size of a Character, as found in the\n+   --  byte-compiled version of regular expressions.\n+\n+   Max_Program_Size : constant := 2**15 - 1;\n+   --  Maximum size that can be allocated for a program.\n+\n+   Max_Curly_Repeat : constant := 32767;\n+   --  Maximum number of repetition for the curly operator.\n+   --  The digits in the {n}, {n,} and {n,m } operators can not be higher\n+   --  than this constant, since they have to fit on two characters in the\n+   --  byte-compiled version of regular expressions.\n+\n+   type Program_Size is range 0 .. Max_Program_Size;\n+   for Program_Size'Size use 16;\n+   --  Number of bytes allocated for the byte-compiled version of a regular\n+   --  expression.\n+\n+   type Regexp_Flags is mod 256;\n+   for Regexp_Flags'Size use 8;\n+   --  Flags that can be given at compile time to specify default\n+   --  properties for the regular expression.\n+\n+   No_Flags         : constant Regexp_Flags;\n+   Case_Insensitive : constant Regexp_Flags;\n+   --  The automaton is optimized so that the matching is done in a case\n+   --  insensitive manner (upper case characters and lower case characters\n+   --  are all treated the same way).\n+\n+   Single_Line      : constant Regexp_Flags;\n+   --  Treat the Data we are matching as a single line. This means that\n+   --  ^ and $ will ignore \\n (unless Multiple_Lines is also specified),\n+   --  and that '.' will match \\n.\n+\n+   Multiple_Lines   : constant Regexp_Flags;\n+   --  Treat the Data as multiple lines. This means that ^ and $ will also\n+   --  match on internal newlines (ASCII.LF), in addition to the beginning\n+   --  and end of the string.\n+   --\n+   --  This can be combined with Single_Line.\n+\n+   -----------------\n+   -- Match_Array --\n+   -----------------\n+\n+   subtype Match_Count is Natural range 0 .. Max_Paren_Count;\n+\n+   type Match_Location is record\n+      First : Natural := 0;\n+      Last  : Natural := 0;\n+   end record;\n+\n+   type Match_Array is array (Match_Count range <>) of Match_Location;\n+   --  The substring matching a given pair of parenthesis.\n+   --  Index 0 is the whole substring that matched the full regular\n+   --  expression.\n+   --\n+   --  For instance, if your regular expression is something like:\n+   --  \"a(b*)(c+)\", then Match_Array(1) will be the indexes of the\n+   --  substring that matched \"b*\" and Match_Array(2) will be the substring\n+   --  that matched \"c+\".\n+   --\n+   --  The number of parenthesis groups that can be retrieved is unlimited,\n+   --  and all the Match subprograms below can use a Match_Array of any size.\n+   --  Indexes that do not have any matching parenthesis are set to\n+   --  No_Match.\n+\n+   No_Match : constant Match_Location := (First => 0, Last => 0);\n+   --  The No_Match constant is (0, 0) to differentiate between\n+   --  matching a null string at position 1, which uses (1, 0)\n+   --  and no match at all.\n+\n+   ------------------------------\n+   -- Pattern_Matcher Creation --\n+   ------------------------------\n+\n+   type Pattern_Matcher (Size : Program_Size) is private;\n+   --  Type used to represent a regular expression compiled into byte code\n+\n+   Never_Match : constant Pattern_Matcher;\n+   --  A regular expression that never matches anything\n+\n+   function Compile\n+     (Expression : String;\n+      Flags      : Regexp_Flags := No_Flags)\n+      return       Pattern_Matcher;\n+   --  Compile a regular expression into internal code.\n+   --  Raises Expression_Error if Expression is not a legal regular expression.\n+   --  The appropriate size is calculated automatically, but this means that\n+   --  the regular expression has to be compiled twice (the first time to\n+   --  calculate the size, the second time to actually generate the byte code).\n+   --\n+   --  Flags is the default value to use to set properties for Expression (case\n+   --  sensitivity,...).\n+\n+   procedure Compile\n+     (Matcher         : out Pattern_Matcher;\n+      Expression      : String;\n+      Final_Code_Size : out Program_Size;\n+      Flags           : Regexp_Flags := No_Flags);\n+   --  Compile a regular expression into into internal code\n+   --  This procedure is significantly faster than the function\n+   --  Compile, as there is a known maximum size for the matcher.\n+   --  This function raises Storage_Error if Matcher is too small\n+   --  to hold the resulting code, or Expression_Error is Expression\n+   --  is not a legal regular expression.\n+   --\n+   --  Flags is the default value to use to set properties for Expression (case\n+   --  sensitivity,...).\n+\n+   procedure Compile\n+     (Matcher    : out Pattern_Matcher;\n+      Expression : String;\n+      Flags      : Regexp_Flags := No_Flags);\n+   --  Same procedure as above, expect it does not return the final\n+   --  program size.\n+\n+   function Paren_Count (Regexp : Pattern_Matcher) return Match_Count;\n+   pragma Inline (Paren_Count);\n+\n+   --  Return the number of parenthesis pairs in Regexp.\n+\n+   --  This is the maximum index that will be filled if a Match_Array is\n+   --  used as an argument to Match.\n+   --\n+   --  Thus, if you want to be sure to get all the parenthesis, you should\n+   --  do something like:\n+   --\n+   --     declare\n+   --        Regexp  : Pattern_Matcher := Compile (\"a(b*)(c+)\");\n+   --        Matched : Match_Array (0 .. Paren_Count (Regexp));\n+   --     begin\n+   --        Match (Regexp, \"a string\", Matched);\n+   --     end;\n+\n+   -------------\n+   -- Quoting --\n+   -------------\n+\n+   function Quote (Str : String) return String;\n+   --  Return a version of Str so that every special character is quoted.\n+   --  The resulting string can be used in a regular expression to match\n+   --  exactly Str, whatever character was present in Str.\n+\n+   --------------\n+   -- Matching --\n+   --------------\n+\n+   procedure Match\n+     (Expression     : String;\n+      Data           : String;\n+      Matches        : out Match_Array;\n+      Size           : Program_Size := 0);\n+   --  Match Expression against Data and store result in Matches.\n+   --  Function raises Storage_Error if Size is too small for Expression,\n+   --  or Expression_Error if Expression is not a legal regular expression.\n+   --  If Size is 0, then the appropriate size is automatically calculated\n+   --  by this package, but this is slightly slower.\n+   --\n+   --  At most Matches'Length parenthesis are returned.\n+\n+   function  Match\n+     (Expression : String;\n+      Data       : String;\n+      Size       : Program_Size := 0)\n+      return       Natural;\n+   --  Return the position where Data matches, or (Data'First - 1) if there is\n+   --  no match.\n+   --  Function raises Storage_Error if Size is too small for Expression\n+   --  or Expression_Error if Expression is not a legal regular expression\n+   --  If Size is 0, then the appropriate size is automatically calculated\n+   --  by this package, but this is slightly slower.\n+\n+   function Match\n+     (Expression : String;\n+      Data       : String;\n+      Size       : Program_Size := 0)\n+      return       Boolean;\n+   --  Return True if Data matches Expression. Match raises Storage_Error\n+   --  if Size is too small for Expression, or Expression_Error if Expression\n+   --  is not a legal regular expression.\n+   --\n+   --  If Size is 0, then the appropriate size is automatically calculated\n+   --  by this package, but this is slightly slower.\n+\n+   ------------------------------------------------\n+   -- Matching a pre-compiled regular expression --\n+   ------------------------------------------------\n+\n+   --  The following functions are significantly faster if you need to reuse\n+   --  the same regular expression multiple times, since you only have to\n+   --  compile it once.\n+\n+   function  Match\n+     (Self : Pattern_Matcher;\n+      Data : String)\n+      return Natural;\n+   --  Return the position where Data matches, or (Data'First - 1) if there is\n+   --  no match. Raises Expression_Error if Expression is not a legal regular\n+   --  expression.\n+\n+   pragma Inline (Match);\n+   --  All except the last one below.\n+\n+   procedure Match\n+     (Self    : Pattern_Matcher;\n+      Data    : String;\n+      Matches : out Match_Array);\n+   --  Match Data using the given pattern matcher and store result in Matches.\n+   --  Raises Expression_Error if Expression is not a legal regular expression.\n+   --  The expression matches if Matches (0) /= No_Match.\n+   --\n+   --  At most Matches'Length parenthesis are returned.\n+\n+   -----------\n+   -- Debug --\n+   -----------\n+\n+   procedure Dump (Self : Pattern_Matcher);\n+   --  Dump the compiled version of the regular expression matched by Self.\n+\n+--------------------------\n+-- Private Declarations --\n+--------------------------\n+\n+private\n+\n+   subtype Pointer is Program_Size;\n+   --  The Pointer type is used to point into Program_Data\n+\n+   --  Note that the pointer type is not necessarily 2 bytes\n+   --  although it is stored in the program using 2 bytes\n+\n+   type Program_Data is array (Pointer range <>) of Character;\n+\n+   Program_First : constant := 1;\n+\n+   --  The \"internal use only\" fields in regexp are present to pass\n+   --  info from compile to execute that permits the execute phase\n+   --  to run lots faster on simple cases.  They are:\n+\n+   --     First              character that must begin a match or ASCII.Nul\n+   --     Anchored           true iff match must start at beginning of line\n+   --     Must_Have          pointer to string that match must include or null\n+   --     Must_Have_Length   length of Must_Have string\n+\n+   --  First and Anchored permit very fast decisions on suitable\n+   --  starting points for a match, cutting down the work a lot.\n+   --  Must_Have permits fast rejection of lines that cannot possibly\n+   --  match.\n+\n+   --  The Must_Have tests are costly enough that Optimize\n+   --  supplies a Must_Have only if the r.e. contains something potentially\n+   --  expensive (at present, the only such thing detected is * or +\n+   --  at the start of the r.e., which can involve a lot of backup).\n+   --  The length is supplied because the test in Execute needs it\n+   --  and Optimize is computing it anyway.\n+\n+   --  The initialization is meant to fail-safe in case the user of this\n+   --  package tries to use an uninitialized matcher. This takes advantage\n+   --  of the knowledge that ASCII.Nul translates to the end-of-program (EOP)\n+   --  instruction code of the state machine.\n+\n+   No_Flags         : constant Regexp_Flags := 0;\n+   Case_Insensitive : constant Regexp_Flags := 1;\n+   Single_Line      : constant Regexp_Flags := 2;\n+   Multiple_Lines   : constant Regexp_Flags := 4;\n+\n+   type Pattern_Matcher (Size : Pointer) is record\n+      First            : Character    := ASCII.NUL;  --  internal use only\n+      Anchored         : Boolean      := False;      --  internal use only\n+      Must_Have        : Pointer      := 0;          --  internal use only\n+      Must_Have_Length : Natural      := 0;          --  internal use only\n+      Paren_Count      : Natural      := 0;          --  # paren groups\n+      Flags            : Regexp_Flags := No_Flags;\n+      Program          : Program_Data (Program_First .. Size) :=\n+                           (others => ASCII.NUL);\n+   end record;\n+\n+   Never_Match : constant Pattern_Matcher :=\n+      (0, ASCII.NUL, False, 0, 0, 0, No_Flags, (others => ASCII.NUL));\n+\n+end GNAT.Regpat;"}, {"sha": "bfa29f55c6e45d49e95cd45ad556252764664818", "filename": "gcc/ada/g-soccon.ads", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-soccon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-soccon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-soccon.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,115 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--               G N A T . S O C K E T S . C O N S T A N T S                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--              Copyright (C) 2001 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the version for Linux\n+\n+package GNAT.Sockets.Constants is\n+\n+   --  Families\n+\n+   AF_INET              : constant :=                2;\n+   AF_INET6             : constant :=               10;\n+\n+   --  Modes\n+\n+   SOCK_STREAM          : constant :=                1;\n+   SOCK_DGRAM           : constant :=                2;\n+\n+   --  Socket Errors\n+\n+   EBADF                : constant :=                9;\n+   ENOTSOCK             : constant :=               88;\n+   ENOTCONN             : constant :=              107;\n+   ENOBUFS              : constant :=              105;\n+   EOPNOTSUPP           : constant :=               95;\n+   EFAULT               : constant :=               14;\n+   EWOULDBLOCK          : constant :=               11;\n+   EADDRNOTAVAIL        : constant :=               99;\n+   EMSGSIZE             : constant :=               90;\n+   EADDRINUSE           : constant :=               98;\n+   EINVAL               : constant :=               22;\n+   EACCES               : constant :=               13;\n+   EAFNOSUPPORT         : constant :=               97;\n+   EISCONN              : constant :=              106;\n+   ETIMEDOUT            : constant :=              110;\n+   ECONNREFUSED         : constant :=              111;\n+   ENETUNREACH          : constant :=              101;\n+   EALREADY             : constant :=              114;\n+   EINPROGRESS          : constant :=              115;\n+   ENOPROTOOPT          : constant :=               92;\n+   EPROTONOSUPPORT      : constant :=               93;\n+   EINTR                : constant :=                4;\n+   EIO                  : constant :=                5;\n+   ESOCKTNOSUPPORT      : constant :=               94;\n+\n+   --  Host Errors\n+\n+   HOST_NOT_FOUND       : constant :=                1;\n+   TRY_AGAIN            : constant :=                2;\n+   NO_ADDRESS           : constant :=                4;\n+   NO_RECOVERY          : constant :=                3;\n+\n+   --  Control Flags\n+\n+   FIONBIO              : constant :=            21537;\n+   FIONREAD             : constant :=            21531;\n+\n+   --  Shutdown Modes\n+\n+   SHUT_RD              : constant :=                0;\n+   SHUT_WR              : constant :=                1;\n+   SHUT_RDWR            : constant :=                2;\n+\n+   --  Protocol Levels\n+\n+   SOL_SOCKET           : constant :=                1;\n+   IPPROTO_IP           : constant :=                0;\n+   IPPROTO_UDP          : constant :=               17;\n+   IPPROTO_TCP          : constant :=                6;\n+\n+   --  Socket Options\n+\n+   TCP_NODELAY          : constant :=                1;\n+   SO_SNDBUF            : constant :=                7;\n+   SO_RCVBUF            : constant :=                8;\n+   SO_REUSEADDR         : constant :=                2;\n+   SO_KEEPALIVE         : constant :=                9;\n+   SO_LINGER            : constant :=               13;\n+   SO_ERROR             : constant :=                4;\n+   SO_BROADCAST         : constant :=                6;\n+   IP_ADD_MEMBERSHIP    : constant :=               35;\n+   IP_DROP_MEMBERSHIP   : constant :=               36;\n+   IP_MULTICAST_TTL     : constant :=               33;\n+   IP_MULTICAST_LOOP    : constant :=               34;\n+end GNAT.Sockets.Constants;"}, {"sha": "b58a0dc20c0b598cd11fd7072aee74b02dcead4c", "filename": "gcc/ada/g-socket.adb", "status": "added", "additions": 1776, "deletions": 0, "changes": 1776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,1776 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         G N A T . S O C K E T S                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.21 $\n+--                                                                          --\n+--              Copyright (C) 2001 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Streams;                use Ada.Streams;\n+with Ada.Exceptions;             use Ada.Exceptions;\n+with Ada.Unchecked_Deallocation;\n+with Ada.Unchecked_Conversion;\n+\n+with Interfaces.C.Strings;\n+\n+with GNAT.OS_Lib;                use GNAT.OS_Lib;\n+with GNAT.Sockets.Constants;\n+with GNAT.Sockets.Thin;          use GNAT.Sockets.Thin;\n+with GNAT.Task_Lock;\n+\n+with GNAT.Sockets.Linker_Options;\n+pragma Warnings (Off, GNAT.Sockets.Linker_Options);\n+--  Need to include pragma Linker_Options which is platform dependent.\n+\n+with System; use System;\n+\n+package body GNAT.Sockets is\n+\n+   use type C.int, System.Address;\n+\n+   Finalized   : Boolean := False;\n+   Initialized : Boolean := False;\n+\n+   --  Correspondance tables\n+\n+   Families : constant array (Family_Type) of C.int :=\n+     (Family_Inet  => Constants.AF_INET,\n+      Family_Inet6 => Constants.AF_INET6);\n+\n+   Levels : constant array (Level_Type) of C.int :=\n+     (Socket_Level              => Constants.SOL_SOCKET,\n+      IP_Protocol_For_IP_Level  => Constants.IPPROTO_IP,\n+      IP_Protocol_For_UDP_Level => Constants.IPPROTO_UDP,\n+      IP_Protocol_For_TCP_Level => Constants.IPPROTO_TCP);\n+\n+   Modes : constant array (Mode_Type) of C.int :=\n+     (Socket_Stream   => Constants.SOCK_STREAM,\n+      Socket_Datagram => Constants.SOCK_DGRAM);\n+\n+   Shutmodes : constant array (Shutmode_Type) of C.int :=\n+     (Shut_Read       => Constants.SHUT_RD,\n+      Shut_Write      => Constants.SHUT_WR,\n+      Shut_Read_Write => Constants.SHUT_RDWR);\n+\n+   Requests : constant array (Request_Name) of C.int :=\n+     (Non_Blocking_IO => Constants.FIONBIO,\n+      N_Bytes_To_Read => Constants.FIONREAD);\n+\n+   Options : constant array (Option_Name) of C.int :=\n+     (Keep_Alive      => Constants.SO_KEEPALIVE,\n+      Reuse_Address   => Constants.SO_REUSEADDR,\n+      Broadcast       => Constants.SO_BROADCAST,\n+      Send_Buffer     => Constants.SO_SNDBUF,\n+      Receive_Buffer  => Constants.SO_RCVBUF,\n+      Linger          => Constants.SO_LINGER,\n+      Error           => Constants.SO_ERROR,\n+      No_Delay        => Constants.TCP_NODELAY,\n+      Add_Membership  => Constants.IP_ADD_MEMBERSHIP,\n+      Drop_Membership => Constants.IP_DROP_MEMBERSHIP,\n+      Multicast_TTL   => Constants.IP_MULTICAST_TTL,\n+      Multicast_Loop  => Constants.IP_MULTICAST_LOOP);\n+\n+   Socket_Error_Id : constant Exception_Id := Socket_Error'Identity;\n+   Host_Error_Id : constant Exception_Id := Host_Error'Identity;\n+\n+   Hex_To_Char : constant String (1 .. 16) := \"0123456789ABCDEF\";\n+   --  Use to print in hexadecimal format\n+\n+   function To_In_Addr is new Ada.Unchecked_Conversion (C.int, In_Addr);\n+   function To_Int     is new Ada.Unchecked_Conversion (In_Addr, C.int);\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   function Resolve_Error\n+     (Error_Value : Integer;\n+      From_Errno  : Boolean := True)\n+     return         Error_Type;\n+   --  Associate an enumeration value (error_type) to en error value\n+   --  (errno). From_Errno prevents from mixing h_errno with errno.\n+\n+   function To_Host_Name (N  : String) return Host_Name_Type;\n+   function To_String    (HN : Host_Name_Type) return String;\n+   --  Conversion functions\n+\n+   function Port_To_Network\n+     (Port : C.unsigned_short)\n+      return C.unsigned_short;\n+   pragma Inline (Port_To_Network);\n+   --  Convert a port number into a network port number\n+\n+   function Network_To_Port\n+     (Net_Port : C.unsigned_short)\n+      return     C.unsigned_short\n+   renames Port_To_Network;\n+   --  Symetric operation\n+\n+   function Image\n+     (Val :  Inet_Addr_VN_Type;\n+      Hex :  Boolean := False)\n+      return String;\n+   --  Output an array of inet address components either in\n+   --  hexadecimal or in decimal mode.\n+\n+   function To_In_Addr (Addr : Inet_Addr_Type) return Thin.In_Addr;\n+   function To_Inet_Addr (Addr : In_Addr) return Inet_Addr_Type;\n+   --  Conversion functions\n+\n+   function To_Host_Entry (Host : Hostent) return Host_Entry_Type;\n+   --  Conversion function\n+\n+   function To_Timeval (Val : Duration) return Timeval;\n+   --  Separate Val in seconds and microseconds\n+\n+   procedure Raise_Socket_Error (Error : Integer);\n+   --  Raise Socket_Error with an exception message describing\n+   --  the error code.\n+\n+   procedure Raise_Host_Error (Error : Integer);\n+   --  Raise Host_Error exception with message describing error code\n+   --  (note hstrerror seems to be obsolete).\n+\n+   --  Types needed for Socket_Set_Type\n+\n+   type Socket_Set_Record is new Fd_Set;\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Socket_Set_Record, Socket_Set_Type);\n+\n+   --  Types needed for Datagram_Socket_Stream_Type\n+\n+   type Datagram_Socket_Stream_Type is new Root_Stream_Type with\n+      record\n+         Socket : Socket_Type;\n+         To     : Sock_Addr_Type;\n+         From   : Sock_Addr_Type;\n+      end record;\n+\n+   type Datagram_Socket_Stream_Access is\n+     access all Datagram_Socket_Stream_Type;\n+\n+   procedure Read\n+     (Stream : in out Datagram_Socket_Stream_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset);\n+\n+   procedure Write\n+     (Stream : in out Datagram_Socket_Stream_Type;\n+      Item   : Ada.Streams.Stream_Element_Array);\n+\n+   --  Types needed for Stream_Socket_Stream_Type\n+\n+   type Stream_Socket_Stream_Type is new Root_Stream_Type with\n+      record\n+         Socket : Socket_Type;\n+      end record;\n+\n+   type Stream_Socket_Stream_Access is\n+     access all Stream_Socket_Stream_Type;\n+\n+   procedure Read\n+     (Stream : in out Stream_Socket_Stream_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset);\n+\n+   procedure Write\n+     (Stream : in out Stream_Socket_Stream_Type;\n+      Item   : Ada.Streams.Stream_Element_Array);\n+\n+   --------------------\n+   -- Abort_Selector --\n+   --------------------\n+\n+   procedure Abort_Selector (Selector : Selector_Type) is\n+   begin\n+      --  Send an empty array to unblock C select system call\n+\n+      if Selector.In_Progress then\n+         declare\n+            Buf : Character;\n+            Res : C.int;\n+         begin\n+            Res := C_Write (C.int (Selector.W_Sig_Socket), Buf'Address, 0);\n+         end;\n+      end if;\n+   end Abort_Selector;\n+\n+   -------------------\n+   -- Accept_Socket --\n+   -------------------\n+\n+   procedure Accept_Socket\n+     (Server  : Socket_Type;\n+      Socket  : out Socket_Type;\n+      Address : out Sock_Addr_Type)\n+   is\n+      Res : C.int;\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+\n+   begin\n+      Res := C_Accept (C.int (Server), Sin'Address, Len'Access);\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Socket := Socket_Type (Res);\n+\n+      Address.Addr := To_Inet_Addr (Sin.Sin_Addr);\n+      Address.Port := Port_Type (Network_To_Port (Sin.Sin_Port));\n+   end Accept_Socket;\n+\n+   ---------------\n+   -- Addresses --\n+   ---------------\n+\n+   function Addresses\n+     (E    : Host_Entry_Type;\n+      N    : Positive := 1)\n+      return Inet_Addr_Type\n+   is\n+   begin\n+      return E.Addresses (N);\n+   end Addresses;\n+\n+   ----------------------\n+   -- Addresses_Length --\n+   ----------------------\n+\n+   function Addresses_Length (E : Host_Entry_Type) return Natural is\n+   begin\n+      return E.Addresses_Length;\n+   end Addresses_Length;\n+\n+   -------------\n+   -- Aliases --\n+   -------------\n+\n+   function Aliases\n+     (E    : Host_Entry_Type;\n+      N    : Positive := 1)\n+      return String\n+   is\n+   begin\n+      return To_String (E.Aliases (N));\n+   end Aliases;\n+\n+   --------------------\n+   -- Aliases_Length --\n+   --------------------\n+\n+   function Aliases_Length (E : Host_Entry_Type) return Natural is\n+   begin\n+      return E.Aliases_Length;\n+   end Aliases_Length;\n+\n+   -----------------\n+   -- Bind_Socket --\n+   -----------------\n+\n+   procedure Bind_Socket\n+     (Socket  : Socket_Type;\n+      Address : Sock_Addr_Type)\n+   is\n+      Res : C.int;\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+\n+   begin\n+      if Address.Family = Family_Inet6 then\n+         raise Socket_Error;\n+      end if;\n+\n+      Sin.Sin_Family := C.unsigned_short (Families (Address.Family));\n+      Sin.Sin_Port   := Port_To_Network (C.unsigned_short (Address.Port));\n+\n+      Res := C_Bind (C.int (Socket), Sin'Address, Len);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+   end Bind_Socket;\n+\n+   --------------------\n+   -- Check_Selector --\n+   --------------------\n+\n+   procedure Check_Selector\n+     (Selector     : in out Selector_Type;\n+      R_Socket_Set : in out Socket_Set_Type;\n+      W_Socket_Set : in out Socket_Set_Type;\n+      Status       : out Selector_Status;\n+      Timeout      : Duration := Forever)\n+   is\n+      Res  : C.int;\n+      Len  : C.int;\n+      RSet : aliased Fd_Set;\n+      WSet : aliased Fd_Set;\n+      TVal : aliased Timeval;\n+      TPtr : Timeval_Access;\n+\n+   begin\n+      Status := Completed;\n+\n+      --  No timeout or Forever is indicated by a null timeval pointer.\n+\n+      if Timeout = Forever then\n+         TPtr := null;\n+      else\n+         TVal := To_Timeval (Timeout);\n+         TPtr := TVal'Unchecked_Access;\n+      end if;\n+\n+      --  Copy R_Socket_Set in RSet and add read signalling socket.\n+\n+      if R_Socket_Set = null then\n+         RSet := Null_Fd_Set;\n+      else\n+         RSet := Fd_Set (R_Socket_Set.all);\n+      end if;\n+\n+      Set (RSet, C.int (Selector.R_Sig_Socket));\n+      Len := Max (RSet) + 1;\n+\n+      --  Copy W_Socket_Set in WSet.\n+\n+      if W_Socket_Set = null then\n+         WSet := Null_Fd_Set;\n+      else\n+         WSet := Fd_Set (W_Socket_Set.all);\n+      end if;\n+      Len := C.int'Max (Max (RSet) + 1, Len);\n+\n+      Selector.In_Progress := True;\n+      Res :=\n+        C_Select\n+         (Len,\n+          RSet'Unchecked_Access,\n+          WSet'Unchecked_Access,\n+          null, TPtr);\n+      Selector.In_Progress := False;\n+\n+      --  If Select was resumed because of read signalling socket,\n+      --  read this data and remove socket from set.\n+\n+      if Is_Set (RSet, C.int (Selector.R_Sig_Socket)) then\n+         Clear (RSet, C.int (Selector.R_Sig_Socket));\n+\n+         declare\n+            Buf : Character;\n+         begin\n+            Res := C_Read (C.int (Selector.R_Sig_Socket), Buf'Address, 0);\n+         end;\n+\n+         --  Select was resumed because of read signalling socket, but\n+         --  the call is said aborted only when there is no other read\n+         --  or write event.\n+\n+         if Is_Empty (RSet)\n+           and then Is_Empty (WSet)\n+         then\n+            Status := Aborted;\n+         end if;\n+\n+      elsif Res = 0 then\n+         Status := Expired;\n+      end if;\n+\n+      if R_Socket_Set /= null then\n+         R_Socket_Set.all := Socket_Set_Record (RSet);\n+      end if;\n+\n+      if W_Socket_Set /= null then\n+         W_Socket_Set.all := Socket_Set_Record (WSet);\n+      end if;\n+   end Check_Selector;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear\n+     (Item   : in out Socket_Set_Type;\n+      Socket : Socket_Type)\n+   is\n+   begin\n+      if Item = null then\n+         Item := new Socket_Set_Record;\n+         Empty (Fd_Set (Item.all));\n+      end if;\n+\n+      Clear (Fd_Set (Item.all), C.int (Socket));\n+   end Clear;\n+\n+   --------------------\n+   -- Close_Selector --\n+   --------------------\n+\n+   procedure Close_Selector (Selector : in out Selector_Type) is\n+   begin\n+      begin\n+         Close_Socket (Selector.R_Sig_Socket);\n+      exception when Socket_Error =>\n+         null;\n+      end;\n+\n+      begin\n+         Close_Socket (Selector.W_Sig_Socket);\n+      exception when Socket_Error =>\n+         null;\n+      end;\n+   end Close_Selector;\n+\n+   ------------------\n+   -- Close_Socket --\n+   ------------------\n+\n+   procedure Close_Socket (Socket : Socket_Type) is\n+      Res : C.int;\n+\n+   begin\n+      Res := C_Close (C.int (Socket));\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+   end Close_Socket;\n+\n+   --------------------\n+   -- Connect_Socket --\n+   --------------------\n+\n+   procedure Connect_Socket\n+     (Socket : Socket_Type;\n+      Server : in out Sock_Addr_Type)\n+   is\n+      Res : C.int;\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+\n+   begin\n+      if Server.Family = Family_Inet6 then\n+         raise Socket_Error;\n+      end if;\n+\n+      Sin.Sin_Family := C.unsigned_short (Families (Server.Family));\n+      Sin.Sin_Addr   := To_In_Addr (Server.Addr);\n+      Sin.Sin_Port   := Port_To_Network (C.unsigned_short (Server.Port));\n+\n+      Res := C_Connect (C.int (Socket), Sin'Address, Len);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+   end Connect_Socket;\n+\n+   --------------------\n+   -- Control_Socket --\n+   --------------------\n+\n+   procedure Control_Socket\n+     (Socket  : Socket_Type;\n+      Request : in out Request_Type)\n+   is\n+      Arg : aliased C.int;\n+      Res : C.int;\n+\n+   begin\n+      case Request.Name is\n+         when Non_Blocking_IO =>\n+            Arg := C.int (Boolean'Pos (Request.Enabled));\n+\n+         when N_Bytes_To_Read =>\n+            null;\n+\n+      end case;\n+\n+      Res := C_Ioctl\n+        (C.int (Socket),\n+         Requests (Request.Name),\n+         Arg'Unchecked_Access);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      case Request.Name is\n+         when Non_Blocking_IO =>\n+            null;\n+\n+         when N_Bytes_To_Read =>\n+            Request.Size := Natural (Arg);\n+\n+      end case;\n+   end Control_Socket;\n+\n+   ---------------------\n+   -- Create_Selector --\n+   ---------------------\n+\n+   procedure Create_Selector (Selector : out Selector_Type) is\n+      S0  : C.int;\n+      S1  : C.int;\n+      S2  : C.int;\n+      Res : C.int;\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+      Err : Integer;\n+\n+   begin\n+      --  We open two signalling sockets. One socket to send a signal\n+      --  to a another socket that always included in a C_Select\n+      --  socket set. When received, it resumes the task suspended in\n+      --  C_Select.\n+\n+      --  Create a listening socket\n+\n+      S0 := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n+      if S0 = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      --  Sin is already correctly initialized. Bind the socket to any\n+      --  unused port.\n+\n+      Res := C_Bind (S0, Sin'Address, Len);\n+      if Res = Failure then\n+         Err := Socket_Errno;\n+         Res := C_Close (S0);\n+         Raise_Socket_Error (Err);\n+      end if;\n+\n+      --  Get the port used by the socket\n+\n+      Res := C_Getsockname (S0, Sin'Address, Len'Access);\n+      if Res = Failure then\n+         Err := Socket_Errno;\n+         Res := C_Close (S0);\n+         Raise_Socket_Error (Err);\n+      end if;\n+\n+      Res := C_Listen (S0, 2);\n+      if Res = Failure then\n+         Err := Socket_Errno;\n+         Res := C_Close (S0);\n+         Raise_Socket_Error (Err);\n+      end if;\n+\n+      S1 := C_Socket (Constants.AF_INET, Constants.SOCK_STREAM, 0);\n+      if S1 = Failure then\n+         Err := Socket_Errno;\n+         Res := C_Close (S0);\n+         Raise_Socket_Error (Err);\n+      end if;\n+\n+      --  Use INADDR_LOOPBACK\n+\n+      Sin.Sin_Addr.S_B1 := 127;\n+      Sin.Sin_Addr.S_B2 := 0;\n+      Sin.Sin_Addr.S_B3 := 0;\n+      Sin.Sin_Addr.S_B4 := 1;\n+\n+      --  Do a connect and accept the connection\n+\n+      Res := C_Connect (S1, Sin'Address, Len);\n+      if Res = Failure then\n+         Err := Socket_Errno;\n+         Res := C_Close (S0);\n+         Res := C_Close (S1);\n+         Raise_Socket_Error (Err);\n+      end if;\n+\n+      S2 := C_Accept (S0, Sin'Address, Len'Access);\n+      if S2 = Failure then\n+         Err := Socket_Errno;\n+         Res := C_Close (S0);\n+         Res := C_Close (S1);\n+         Raise_Socket_Error (Err);\n+      end if;\n+\n+      Res := C_Close (S0);\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Selector.R_Sig_Socket := Socket_Type (S1);\n+      Selector.W_Sig_Socket := Socket_Type (S2);\n+   end Create_Selector;\n+\n+   -------------------\n+   -- Create_Socket --\n+   -------------------\n+\n+   procedure Create_Socket\n+     (Socket : out Socket_Type;\n+      Family : Family_Type := Family_Inet;\n+      Mode   : Mode_Type   := Socket_Stream)\n+   is\n+      Res : C.int;\n+\n+   begin\n+      Res := C_Socket (Families (Family), Modes (Mode), 0);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Socket := Socket_Type (Res);\n+   end Create_Socket;\n+\n+   -----------\n+   -- Empty --\n+   -----------\n+\n+   procedure Empty  (Item : in out Socket_Set_Type) is\n+   begin\n+      if Item /= null then\n+         Free (Item);\n+      end if;\n+   end Empty;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize is\n+   begin\n+      if not Finalized\n+        and then Initialized\n+      then\n+         Finalized := True;\n+         Thin.Finalize;\n+      end if;\n+   end Finalize;\n+\n+   -----------------\n+   -- Get_Address --\n+   -----------------\n+\n+   function Get_Address (Stream : Stream_Access) return Sock_Addr_Type is\n+   begin\n+      if Stream = null then\n+         raise Socket_Error;\n+\n+      elsif Stream.all in Datagram_Socket_Stream_Type then\n+         return Datagram_Socket_Stream_Type (Stream.all).From;\n+\n+      else\n+         return Get_Peer_Name (Stream_Socket_Stream_Type (Stream.all).Socket);\n+      end if;\n+   end Get_Address;\n+\n+   -------------------------\n+   -- Get_Host_By_Address --\n+   -------------------------\n+\n+   function Get_Host_By_Address\n+     (Address : Inet_Addr_Type;\n+      Family  : Family_Type := Family_Inet)\n+      return    Host_Entry_Type\n+   is\n+      HA  : aliased In_Addr := To_In_Addr (Address);\n+      Res : Hostent_Access;\n+      Err : Integer;\n+\n+   begin\n+      --  This C function is not always thread-safe. Protect against\n+      --  concurrent access.\n+\n+      Task_Lock.Lock;\n+      Res := C_Gethostbyaddr (HA'Address, HA'Size / 8, Constants.AF_INET);\n+\n+      if Res = null then\n+         Err := Socket_Errno;\n+         Task_Lock.Unlock;\n+         Raise_Host_Error (Err);\n+      end if;\n+\n+      --  Translate from the C format to the API format\n+\n+      declare\n+         HE : Host_Entry_Type := To_Host_Entry (Res.all);\n+\n+      begin\n+         Task_Lock.Unlock;\n+         return HE;\n+      end;\n+   end Get_Host_By_Address;\n+\n+   ----------------------\n+   -- Get_Host_By_Name --\n+   ----------------------\n+\n+   function Get_Host_By_Name\n+     (Name : String)\n+      return Host_Entry_Type\n+   is\n+      HN  : C.char_array := C.To_C (Name);\n+      Res : Hostent_Access;\n+      Err : Integer;\n+\n+   begin\n+      --  This C function is not always thread-safe. Protect against\n+      --  concurrent access.\n+\n+      Task_Lock.Lock;\n+      Res := C_Gethostbyname (HN);\n+\n+      if Res = null then\n+         Err := Socket_Errno;\n+         Task_Lock.Unlock;\n+         Raise_Host_Error (Err);\n+      end if;\n+\n+      --  Translate from the C format to the API format\n+\n+      declare\n+         HE : Host_Entry_Type := To_Host_Entry (Res.all);\n+\n+      begin\n+         Task_Lock.Unlock;\n+         return HE;\n+      end;\n+   end Get_Host_By_Name;\n+\n+   -------------------\n+   -- Get_Peer_Name --\n+   -------------------\n+\n+   function Get_Peer_Name\n+     (Socket : Socket_Type)\n+      return   Sock_Addr_Type\n+   is\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+      Res : Sock_Addr_Type (Family_Inet);\n+\n+   begin\n+      if C_Getpeername (C.int (Socket), Sin'Address, Len'Access) = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Res.Addr := To_Inet_Addr (Sin.Sin_Addr);\n+      Res.Port := Port_Type (Network_To_Port (Sin.Sin_Port));\n+\n+      return Res;\n+   end Get_Peer_Name;\n+\n+   ---------------------\n+   -- Get_Socket_Name --\n+   ---------------------\n+\n+   function Get_Socket_Name\n+     (Socket : Socket_Type)\n+      return   Sock_Addr_Type\n+   is\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+      Res : Sock_Addr_Type (Family_Inet);\n+\n+   begin\n+      if C_Getsockname (C.int (Socket), Sin'Address, Len'Access) = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Res.Addr := To_Inet_Addr (Sin.Sin_Addr);\n+      Res.Port := Port_Type (Network_To_Port (Sin.Sin_Port));\n+\n+      return Res;\n+   end Get_Socket_Name;\n+\n+   -----------------------\n+   -- Get_Socket_Option --\n+   -----------------------\n+\n+   function Get_Socket_Option\n+     (Socket : Socket_Type;\n+      Level  : Level_Type := Socket_Level;\n+      Name   : Option_Name)\n+      return   Option_Type\n+   is\n+      use type C.unsigned_char;\n+\n+      V8  : aliased Two_Int;\n+      V4  : aliased C.int;\n+      V1  : aliased C.unsigned_char;\n+      Len : aliased C.int;\n+      Add : System.Address;\n+      Res : C.int;\n+      Opt : Option_Type (Name);\n+\n+   begin\n+      case Name is\n+         when Multicast_Loop  |\n+              Multicast_TTL   =>\n+            Len := V1'Size / 8;\n+            Add := V1'Address;\n+\n+         when Keep_Alive      |\n+              Reuse_Address   |\n+              Broadcast       |\n+              No_Delay        |\n+              Send_Buffer     |\n+              Receive_Buffer  |\n+              Error           =>\n+            Len := V4'Size / 8;\n+            Add := V4'Address;\n+\n+         when Linger          |\n+              Add_Membership  |\n+              Drop_Membership =>\n+            Len := V8'Size / 8;\n+            Add := V8'Address;\n+\n+      end case;\n+\n+      Res := C_Getsockopt\n+        (C.int (Socket),\n+         Levels (Level),\n+         Options (Name),\n+         Add, Len'Unchecked_Access);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      case Name is\n+         when Keep_Alive      |\n+              Reuse_Address   |\n+              Broadcast       |\n+              No_Delay        =>\n+            Opt.Enabled := (V4 /= 0);\n+\n+         when Linger          =>\n+            Opt.Enabled := (V8 (V8'First) /= 0);\n+            Opt.Seconds := Natural (V8 (V8'Last));\n+\n+         when Send_Buffer     |\n+              Receive_Buffer  =>\n+            Opt.Size := Natural (V4);\n+\n+         when Error           =>\n+            Opt.Error := Resolve_Error (Integer (V4));\n+\n+         when Add_Membership  |\n+              Drop_Membership =>\n+            Opt.Multiaddr := To_Inet_Addr (To_In_Addr (V8 (V8'First)));\n+            Opt.Interface := To_Inet_Addr (To_In_Addr (V8 (V8'Last)));\n+\n+         when Multicast_TTL   =>\n+            Opt.Time_To_Live := Integer (V1);\n+\n+         when Multicast_Loop  =>\n+            Opt.Enabled := (V1 /= 0);\n+\n+      end case;\n+\n+      return Opt;\n+   end Get_Socket_Option;\n+\n+   ---------------\n+   -- Host_Name --\n+   ---------------\n+\n+   function Host_Name return String is\n+      Name : aliased C.char_array (1 .. 64);\n+      Res  : C.int;\n+\n+   begin\n+      Res := C_Gethostname (Name'Address, Name'Length);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      return C.To_Ada (Name);\n+   end Host_Name;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image\n+     (Val  : Inet_Addr_VN_Type;\n+      Hex  : Boolean := False)\n+      return String\n+   is\n+      --  The largest Inet_Addr_Comp_Type image occurs with IPv4. It\n+      --  has at most a length of 3 plus one '.' character.\n+\n+      Buffer    : String (1 .. 4 * Val'Length);\n+      Length    : Natural := 1;\n+      Separator : Character;\n+\n+      procedure Img10 (V : Inet_Addr_Comp_Type);\n+      --  Append to Buffer image of V in decimal format\n+\n+      procedure Img16 (V : Inet_Addr_Comp_Type);\n+      --  Append to Buffer image of V in hexadecimal format\n+\n+      procedure Img10 (V : Inet_Addr_Comp_Type) is\n+         Img : constant String := V'Img;\n+         Len : Natural := Img'Length - 1;\n+\n+      begin\n+         Buffer (Length .. Length + Len - 1) := Img (2 .. Img'Last);\n+         Length := Length + Len;\n+      end Img10;\n+\n+      procedure Img16 (V : Inet_Addr_Comp_Type) is\n+      begin\n+         Buffer (Length)     := Hex_To_Char (Natural (V / 16) + 1);\n+         Buffer (Length + 1) := Hex_To_Char (Natural (V mod 16) + 1);\n+         Length := Length + 2;\n+      end Img16;\n+\n+   --  Start of processing for Image\n+\n+   begin\n+      if Hex then\n+         Separator := ':';\n+      else\n+         Separator := '.';\n+      end if;\n+\n+      for J in Val'Range loop\n+         if Hex then\n+            Img16 (Val (J));\n+         else\n+            Img10 (Val (J));\n+         end if;\n+\n+         if J /= Val'Last then\n+            Buffer (Length) := Separator;\n+            Length := Length + 1;\n+         end if;\n+      end loop;\n+\n+      return Buffer (1 .. Length - 1);\n+   end Image;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Value : Inet_Addr_Type) return String is\n+   begin\n+      if Value.Family = Family_Inet then\n+         return Image (Inet_Addr_VN_Type (Value.Sin_V4), Hex => False);\n+      else\n+         return Image (Inet_Addr_VN_Type (Value.Sin_V6), Hex => True);\n+      end if;\n+   end Image;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Value : Sock_Addr_Type) return String is\n+      Port : constant String := Value.Port'Img;\n+\n+   begin\n+      return Image (Value.Addr) & ':' & Port (2 .. Port'Last);\n+   end Image;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Socket : Socket_Type) return String is\n+   begin\n+      return Socket'Img;\n+   end Image;\n+\n+   ---------------\n+   -- Inet_Addr --\n+   ---------------\n+\n+   function Inet_Addr (Image : String) return Inet_Addr_Type is\n+      use Interfaces.C.Strings;\n+\n+      Img : chars_ptr := New_String (Image);\n+      Res : C.int;\n+      Err : Integer;\n+\n+   begin\n+      Res := C_Inet_Addr (Img);\n+      Err := Errno;\n+      Free (Img);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Err);\n+      end if;\n+\n+      return To_Inet_Addr (To_In_Addr (Res));\n+   end Inet_Addr;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Process_Blocking_IO : Boolean := False) is\n+   begin\n+      if not Initialized then\n+         Initialized := True;\n+         Thin.Initialize (Process_Blocking_IO);\n+      end if;\n+   end Initialize;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Item : Socket_Set_Type) return Boolean is\n+   begin\n+      return Item = null or else Is_Empty (Fd_Set (Item.all));\n+   end Is_Empty;\n+\n+   ------------\n+   -- Is_Set --\n+   ------------\n+\n+   function Is_Set\n+     (Item   : Socket_Set_Type;\n+      Socket : Socket_Type) return Boolean\n+   is\n+   begin\n+      return Item /= null\n+        and then Is_Set (Fd_Set (Item.all), C.int (Socket));\n+   end Is_Set;\n+\n+   -------------------\n+   -- Listen_Socket --\n+   -------------------\n+\n+   procedure Listen_Socket\n+     (Socket : Socket_Type;\n+      Length : Positive := 15)\n+   is\n+      Res : C.int;\n+\n+   begin\n+      Res := C_Listen (C.int (Socket), C.int (Length));\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+   end Listen_Socket;\n+\n+   -------------------\n+   -- Official_Name --\n+   -------------------\n+\n+   function Official_Name (E : Host_Entry_Type) return String is\n+   begin\n+      return To_String (E.Official);\n+   end Official_Name;\n+\n+   ---------------------\n+   -- Port_To_Network --\n+   ---------------------\n+\n+   function Port_To_Network\n+     (Port : C.unsigned_short)\n+      return C.unsigned_short\n+   is\n+      use type C.unsigned_short;\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+\n+         --  No conversion needed. On these platforms, htons() defaults\n+         --  to a null procedure.\n+\n+         return Port;\n+\n+      else\n+         --  We need to swap the high and low byte on this short to make\n+         --  the port number network compliant.\n+\n+         return (Port / 256) + (Port mod 256) * 256;\n+      end if;\n+   end Port_To_Network;\n+\n+   ----------------------\n+   -- Raise_Host_Error --\n+   ----------------------\n+\n+   procedure Raise_Host_Error (Error : Integer) is\n+\n+      function Error_Message return String;\n+      --  We do not use a C function like strerror because hstrerror\n+      --  that would correspond seems to be obsolete. Return\n+      --  appropriate string for error value.\n+\n+      function Error_Message return String is\n+      begin\n+         case Error is\n+            when Constants.HOST_NOT_FOUND => return \"Host not found\";\n+            when Constants.TRY_AGAIN      => return \"Try again\";\n+            when Constants.NO_RECOVERY    => return \"No recovery\";\n+            when Constants.NO_ADDRESS     => return \"No address\";\n+            when others                   => return \"Unknown error\";\n+         end case;\n+      end Error_Message;\n+\n+   --  Start of processing for Raise_Host_Error\n+\n+   begin\n+      Ada.Exceptions.Raise_Exception (Host_Error'Identity, Error_Message);\n+   end Raise_Host_Error;\n+\n+   ------------------------\n+   -- Raise_Socket_Error --\n+   ------------------------\n+\n+   procedure Raise_Socket_Error (Error : Integer) is\n+      use type C.Strings.chars_ptr;\n+\n+      function Image (E : Integer) return String;\n+      function Image (E : Integer) return String is\n+         Msg : String := E'Img & \"] \";\n+      begin\n+         Msg (Msg'First) := '[';\n+         return Msg;\n+      end Image;\n+\n+   begin\n+      Ada.Exceptions.Raise_Exception\n+        (Socket_Error'Identity, Image (Error) & Socket_Error_Message (Error));\n+   end Raise_Socket_Error;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream : in out Datagram_Socket_Stream_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset)\n+   is\n+      First : Ada.Streams.Stream_Element_Offset          := Item'First;\n+      Index : Ada.Streams.Stream_Element_Offset          := First - 1;\n+      Max   : constant Ada.Streams.Stream_Element_Offset := Item'Last;\n+\n+   begin\n+      loop\n+         Receive_Socket\n+           (Stream.Socket,\n+            Item (First .. Max),\n+            Index,\n+            Stream.From);\n+\n+         Last  := Index;\n+\n+         --  Exit when all or zero data received. Zero means that\n+         --  the socket peer is closed.\n+\n+         exit when Index < First or else Index = Max;\n+\n+         First := Index + 1;\n+      end loop;\n+   end Read;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream : in out Stream_Socket_Stream_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset)\n+   is\n+      First : Ada.Streams.Stream_Element_Offset          := Item'First;\n+      Index : Ada.Streams.Stream_Element_Offset          := First - 1;\n+      Max   : constant Ada.Streams.Stream_Element_Offset := Item'Last;\n+\n+   begin\n+      loop\n+         Receive_Socket (Stream.Socket, Item (First .. Max), Index);\n+         Last  := Index;\n+\n+         --  Exit when all or zero data received. Zero means that\n+         --  the socket peer is closed.\n+\n+         exit when Index < First or else Index = Max;\n+\n+         First := Index + 1;\n+      end loop;\n+   end Read;\n+\n+   -------------------\n+   -- Resolve_Error --\n+   -------------------\n+\n+   function Resolve_Error\n+     (Error_Value : Integer;\n+      From_Errno  : Boolean := True)\n+     return         Error_Type\n+   is\n+      use GNAT.Sockets.Constants;\n+\n+   begin\n+      if not From_Errno then\n+         case Error_Value is\n+            when HOST_NOT_FOUND => return Unknown_Host;\n+            when TRY_AGAIN      => return Host_Name_Lookup_Failure;\n+            when NO_RECOVERY    => return No_Address_Associated_With_Name;\n+            when NO_ADDRESS     => return Unknown_Server_Error;\n+            when others         => return Cannot_Resolve_Error;\n+         end case;\n+      end if;\n+      case Error_Value is\n+         when EACCES          => return Permission_Denied;\n+         when EADDRINUSE      => return Address_Already_In_Use;\n+         when EADDRNOTAVAIL   => return Cannot_Assign_Requested_Address;\n+         when EAFNOSUPPORT    =>\n+            return Address_Family_Not_Supported_By_Protocol;\n+         when EALREADY        => return Operation_Already_In_Progress;\n+         when EBADF           => return Bad_File_Descriptor;\n+         when ECONNREFUSED    => return Connection_Refused;\n+         when EFAULT          => return Bad_Address;\n+         when EINPROGRESS     => return Operation_Now_In_Progress;\n+         when EINTR           => return Interrupted_System_Call;\n+         when EINVAL          => return Invalid_Argument;\n+         when EIO             => return Input_Output_Error;\n+         when EISCONN         => return Transport_Endpoint_Already_Connected;\n+         when EMSGSIZE        => return Message_Too_Long;\n+         when ENETUNREACH     => return Network_Is_Unreachable;\n+         when ENOBUFS         => return No_Buffer_Space_Available;\n+         when ENOPROTOOPT     => return Protocol_Not_Available;\n+         when ENOTCONN        => return Transport_Endpoint_Not_Connected;\n+         when EOPNOTSUPP      => return Operation_Not_Supported;\n+         when EPROTONOSUPPORT => return Protocol_Not_Supported;\n+         when ESOCKTNOSUPPORT => return Socket_Type_Not_Supported;\n+         when ETIMEDOUT       => return Connection_Timed_Out;\n+         when EWOULDBLOCK     => return Resource_Temporarily_Unavailable;\n+         when others          => return Cannot_Resolve_Error;\n+      end case;\n+   end Resolve_Error;\n+\n+   -----------------------\n+   -- Resolve_Exception --\n+   -----------------------\n+\n+   function Resolve_Exception\n+     (Occurrence : Exception_Occurrence)\n+     return        Error_Type\n+   is\n+      Id    : Exception_Id := Exception_Identity (Occurrence);\n+      Msg   : constant String := Exception_Message (Occurrence);\n+      First : Natural := Msg'First;\n+      Last  : Natural;\n+      Val   : Integer;\n+\n+   begin\n+      while First <= Msg'Last\n+        and then Msg (First) not in '0' .. '9'\n+      loop\n+         First := First + 1;\n+      end loop;\n+\n+      if First > Msg'Last then\n+         return Cannot_Resolve_Error;\n+      end if;\n+\n+      Last := First;\n+\n+      while Last < Msg'Last\n+        and then Msg (Last + 1) in '0' .. '9'\n+      loop\n+         Last := Last + 1;\n+      end loop;\n+\n+      Val := Integer'Value (Msg (First .. Last));\n+\n+      if Id = Socket_Error_Id then\n+         return Resolve_Error (Val);\n+\n+      elsif Id = Host_Error_Id then\n+         return Resolve_Error (Val, False);\n+\n+      else\n+         return Cannot_Resolve_Error;\n+      end if;\n+   end Resolve_Exception;\n+\n+   --------------------\n+   -- Receive_Socket --\n+   --------------------\n+\n+   procedure Receive_Socket\n+     (Socket : Socket_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset)\n+   is\n+      use type Ada.Streams.Stream_Element_Offset;\n+\n+      Res : C.int;\n+\n+   begin\n+      Res := C_Recv\n+        (C.int (Socket),\n+         Item (Item'First)'Address,\n+         Item'Length, 0);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Last := Item'First + Ada.Streams.Stream_Element_Offset (Res - 1);\n+   end Receive_Socket;\n+\n+   --------------------\n+   -- Receive_Socket --\n+   --------------------\n+\n+   procedure Receive_Socket\n+     (Socket : Socket_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset;\n+      From   : out Sock_Addr_Type)\n+   is\n+      use type Ada.Streams.Stream_Element_Offset;\n+\n+      Res  : C.int;\n+      Sin  : aliased Sockaddr_In;\n+      Len  : aliased C.int := Sin'Size / 8;\n+\n+   begin\n+      Res := C_Recvfrom\n+        (C.int (Socket),\n+         Item (Item'First)'Address,\n+         Item'Length, 0,\n+         Sin'Unchecked_Access,\n+         Len'Unchecked_Access);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Last := Item'First + Ada.Streams.Stream_Element_Offset (Res - 1);\n+\n+      From.Addr := To_Inet_Addr (Sin.Sin_Addr);\n+      From.Port := Port_Type (Network_To_Port (Sin.Sin_Port));\n+   end Receive_Socket;\n+\n+   -----------------\n+   -- Send_Socket --\n+   -----------------\n+\n+   procedure Send_Socket\n+     (Socket : Socket_Type;\n+      Item   : Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset)\n+   is\n+      use type Ada.Streams.Stream_Element_Offset;\n+\n+      Res  : C.int;\n+\n+   begin\n+      Res := C_Send\n+        (C.int (Socket),\n+         Item (Item'First)'Address,\n+         Item'Length, 0);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Last := Item'First + Ada.Streams.Stream_Element_Offset (Res - 1);\n+   end Send_Socket;\n+\n+   -----------------\n+   -- Send_Socket --\n+   -----------------\n+\n+   procedure Send_Socket\n+     (Socket : Socket_Type;\n+      Item   : Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset;\n+      To     : Sock_Addr_Type)\n+   is\n+      use type Ada.Streams.Stream_Element_Offset;\n+\n+      Res : C.int;\n+      Sin : aliased Sockaddr_In;\n+      Len : aliased C.int := Sin'Size / 8;\n+\n+   begin\n+      Sin.Sin_Family := C.unsigned_short (Families (To.Family));\n+      Sin.Sin_Addr   := To_In_Addr (To.Addr);\n+      Sin.Sin_Port   := Port_To_Network (C.unsigned_short (To.Port));\n+\n+      Res := C_Sendto\n+        (C.int (Socket),\n+         Item (Item'First)'Address,\n+         Item'Length, 0,\n+         Sin'Unchecked_Access,\n+         Len);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Last := Item'First + Ada.Streams.Stream_Element_Offset (Res - 1);\n+   end Send_Socket;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set (Item : in out Socket_Set_Type; Socket : Socket_Type) is\n+   begin\n+      if Item = null then\n+         Item := new Socket_Set_Record'(Socket_Set_Record (Null_Fd_Set));\n+      end if;\n+\n+      Set (Fd_Set (Item.all), C.int (Socket));\n+   end Set;\n+\n+   -----------------------\n+   -- Set_Socket_Option --\n+   -----------------------\n+\n+   procedure Set_Socket_Option\n+     (Socket : Socket_Type;\n+      Level  : Level_Type := Socket_Level;\n+      Option : Option_Type)\n+   is\n+      V8  : aliased Two_Int;\n+      V4  : aliased C.int;\n+      V1  : aliased C.unsigned_char;\n+      Len : aliased C.int;\n+      Add : System.Address := Null_Address;\n+      Res : C.int;\n+\n+   begin\n+      case Option.Name is\n+         when Keep_Alive      |\n+              Reuse_Address   |\n+              Broadcast       |\n+              No_Delay        =>\n+            V4  := C.int (Boolean'Pos (Option.Enabled));\n+            Len := V4'Size / 8;\n+            Add := V4'Address;\n+\n+         when Linger          =>\n+            V8 (V8'First) := C.int (Boolean'Pos (Option.Enabled));\n+            V8 (V8'Last)  := C.int (Option.Seconds);\n+            Len := V8'Size / 8;\n+            Add := V8'Address;\n+\n+         when Send_Buffer     |\n+              Receive_Buffer  =>\n+            V4  := C.int (Option.Size);\n+            Len := V4'Size / 8;\n+            Add := V4'Address;\n+\n+         when Error           =>\n+            V4  := C.int (Boolean'Pos (True));\n+            Len := V4'Size / 8;\n+            Add := V4'Address;\n+\n+         when Add_Membership  |\n+              Drop_Membership =>\n+            V8 (V8'First) := To_Int (To_In_Addr (Option.Multiaddr));\n+            V8 (V8'Last)  := To_Int (To_In_Addr (Option.Interface));\n+            Len := V8'Size / 8;\n+            Add := V8'Address;\n+\n+         when Multicast_TTL   =>\n+            V1  := C.unsigned_char (Option.Time_To_Live);\n+            Len := V1'Size / 8;\n+            Add := V1'Address;\n+\n+         when Multicast_Loop  =>\n+            V1  := C.unsigned_char (Boolean'Pos (Option.Enabled));\n+            Len := V1'Size / 8;\n+            Add := V1'Address;\n+\n+      end case;\n+\n+      Res := C_Setsockopt\n+        (C.int (Socket),\n+         Levels (Level),\n+         Options (Option.Name),\n+         Add, Len);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+   end Set_Socket_Option;\n+\n+   ---------------------\n+   -- Shutdown_Socket --\n+   ---------------------\n+\n+   procedure Shutdown_Socket\n+     (Socket : Socket_Type;\n+      How    : Shutmode_Type := Shut_Read_Write)\n+   is\n+      Res : C.int;\n+\n+   begin\n+      Res := C_Shutdown (C.int (Socket), Shutmodes (How));\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+   end Shutdown_Socket;\n+\n+   ------------\n+   -- Stream --\n+   ------------\n+\n+   function Stream\n+     (Socket  : Socket_Type;\n+      Send_To : Sock_Addr_Type)\n+     return Stream_Access\n+   is\n+      S : Datagram_Socket_Stream_Access;\n+\n+   begin\n+      S := new Datagram_Socket_Stream_Type;\n+      S.Socket := Socket;\n+      S.To     := Send_To;\n+      S.From   := Get_Socket_Name (Socket);\n+      return Stream_Access (S);\n+   end Stream;\n+\n+   ------------\n+   -- Stream --\n+   ------------\n+\n+   function Stream\n+     (Socket : Socket_Type)\n+     return Stream_Access\n+   is\n+      S : Stream_Socket_Stream_Access;\n+\n+   begin\n+      S := new Stream_Socket_Stream_Type;\n+      S.Socket := Socket;\n+      return Stream_Access (S);\n+   end Stream;\n+\n+   ----------\n+   -- To_C --\n+   ----------\n+\n+   function To_C (Socket : Socket_Type) return Integer is\n+   begin\n+      return Integer (Socket);\n+   end To_C;\n+\n+   -------------------\n+   -- To_Host_Entry --\n+   -------------------\n+\n+   function To_Host_Entry\n+     (Host : Hostent)\n+      return Host_Entry_Type\n+   is\n+      use type C.size_t;\n+\n+      Official : constant String :=\n+                   C.Strings.Value (Host.H_Name);\n+\n+      Aliases : constant Chars_Ptr_Array :=\n+                  Chars_Ptr_Pointers.Value (Host.H_Aliases);\n+      --  H_Aliases points to a list of name aliases. The list is\n+      --  terminated by a NULL pointer.\n+\n+      Addresses : constant In_Addr_Access_Array :=\n+                    In_Addr_Access_Pointers.Value (Host.H_Addr_List);\n+      --  H_Addr_List points to a list of binary addresses (in network\n+      --  byte order). The list is terminated by a NULL pointer.\n+\n+      --  H_Length is not used because it is currently only set to 4.\n+      --  H_Addrtype is always AF_INET\n+\n+      Result    : Host_Entry_Type\n+        (Aliases_Length   => Aliases'Length - 1,\n+         Addresses_Length => Addresses'Length - 1);\n+      --  The last element is a null pointer.\n+\n+      Source : C.size_t;\n+      Target : Natural;\n+\n+   begin\n+      Result.Official := To_Host_Name (Official);\n+\n+      Source := Aliases'First;\n+      Target := Result.Aliases'First;\n+      while Target <= Result.Aliases_Length loop\n+         Result.Aliases (Target) :=\n+           To_Host_Name (C.Strings.Value (Aliases (Source)));\n+         Source := Source + 1;\n+         Target := Target + 1;\n+      end loop;\n+\n+      Source := Addresses'First;\n+      Target := Result.Addresses'First;\n+      while Target <= Result.Addresses_Length loop\n+         Result.Addresses (Target) :=\n+           To_Inet_Addr (Addresses (Source).all);\n+         Source := Source + 1;\n+         Target := Target + 1;\n+      end loop;\n+\n+      return Result;\n+   end To_Host_Entry;\n+\n+   ------------------\n+   -- To_Host_Name --\n+   ------------------\n+\n+   function To_Host_Name (N : String) return Host_Name_Type is\n+   begin\n+      return (N'Length, N);\n+   end To_Host_Name;\n+\n+   ----------------\n+   -- To_In_Addr --\n+   ----------------\n+\n+   function To_In_Addr (Addr : Inet_Addr_Type) return Thin.In_Addr is\n+   begin\n+      if Addr.Family = Family_Inet then\n+         return (S_B1 => C.unsigned_char (Addr.Sin_V4 (1)),\n+                 S_B2 => C.unsigned_char (Addr.Sin_V4 (2)),\n+                 S_B3 => C.unsigned_char (Addr.Sin_V4 (3)),\n+                 S_B4 => C.unsigned_char (Addr.Sin_V4 (4)));\n+      end if;\n+\n+      raise Socket_Error;\n+   end To_In_Addr;\n+\n+   ------------------\n+   -- To_Inet_Addr --\n+   ------------------\n+\n+   function To_Inet_Addr\n+     (Addr : In_Addr)\n+      return Inet_Addr_Type\n+   is\n+      Result : Inet_Addr_Type;\n+\n+   begin\n+      Result.Sin_V4 (1) := Inet_Addr_Comp_Type (Addr.S_B1);\n+      Result.Sin_V4 (2) := Inet_Addr_Comp_Type (Addr.S_B2);\n+      Result.Sin_V4 (3) := Inet_Addr_Comp_Type (Addr.S_B3);\n+      Result.Sin_V4 (4) := Inet_Addr_Comp_Type (Addr.S_B4);\n+\n+      return Result;\n+   end To_Inet_Addr;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String (HN : Host_Name_Type) return String is\n+   begin\n+      return HN.Name (1 .. HN.Length);\n+   end To_String;\n+\n+   ----------------\n+   -- To_Timeval --\n+   ----------------\n+\n+   function To_Timeval (Val : Duration) return Timeval is\n+      S  : Timeval_Unit := Timeval_Unit (Val);\n+      MS : Timeval_Unit := Timeval_Unit (1_000_000 * (Val - Duration (S)));\n+\n+   begin\n+      return (S, MS);\n+   end To_Timeval;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream : in out Datagram_Socket_Stream_Type;\n+      Item   : Ada.Streams.Stream_Element_Array)\n+   is\n+      First : Ada.Streams.Stream_Element_Offset          := Item'First;\n+      Index : Ada.Streams.Stream_Element_Offset          := First - 1;\n+      Max   : constant Ada.Streams.Stream_Element_Offset := Item'Last;\n+\n+   begin\n+      loop\n+         Send_Socket\n+           (Stream.Socket,\n+            Item (First .. Max),\n+            Index,\n+            Stream.To);\n+\n+         --  Exit when all or zero data sent. Zero means that the\n+         --  socket has been closed by peer.\n+\n+         exit when Index < First or else Index = Max;\n+\n+         First := Index + 1;\n+      end loop;\n+\n+      if Index /= Max then\n+         raise Socket_Error;\n+      end if;\n+   end Write;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream : in out Stream_Socket_Stream_Type;\n+      Item   : Ada.Streams.Stream_Element_Array)\n+   is\n+      First : Ada.Streams.Stream_Element_Offset          := Item'First;\n+      Index : Ada.Streams.Stream_Element_Offset          := First - 1;\n+      Max   : constant Ada.Streams.Stream_Element_Offset := Item'Last;\n+\n+   begin\n+      loop\n+         Send_Socket (Stream.Socket, Item (First .. Max), Index);\n+\n+         --  Exit when all or zero data sent. Zero means that the\n+         --  socket has been closed by peer.\n+\n+         exit when Index < First or else Index = Max;\n+\n+         First := Index + 1;\n+      end loop;\n+\n+      if Index /= Max then\n+         raise Socket_Error;\n+      end if;\n+   end Write;\n+\n+end GNAT.Sockets;"}, {"sha": "e43ce857e99fc03046365e67617b93bb625e5f0d", "filename": "gcc/ada/g-socket.ads", "status": "added", "additions": 891, "deletions": 0, "changes": 891, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "patch": "@@ -0,0 +1,891 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         G N A T . S O C K E T S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $\n+--                                                                          --\n+--              Copyright (C) 2001 Ada Core Technologies, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface to the sockets communication facility\n+--  provided on many operating systems. Currently this is implemented on all\n+--  native GNAT ports except for VMS. It is not yet implemented for any of\n+--  the cross-ports (e.g. it is not available for VxWorks or LynxOS).\n+--  Another restriction is that there is no multicast support under Windows\n+--  or under any system on which the multicast support is not available or\n+--  installed.\n+\n+with Ada.Exceptions;\n+with Ada.Streams;\n+\n+package GNAT.Sockets is\n+\n+   --  Sockets are designed to provide a consistent communication\n+   --  facility between applications. This package provides an\n+   --  Ada-like interface similar to the one proposed as part of the\n+   --  BSD socket layer. This is a system independant thick binding.\n+   --  Here is a typical example of what you can do.\n+\n+   --  with GNAT.Sockets; use GNAT.Sockets;\n+   --\n+   --  with Ada.Text_IO;\n+   --  with Ada.Exceptions; use Ada.Exceptions;\n+   --\n+   --  procedure PingPong is\n+   --\n+   --     Group : constant String := \"239.255.128.128\";\n+   --     --  Multicast groupe: administratively scoped IP address\n+   --\n+   --     task Pong is\n+   --        entry Start;\n+   --        entry Stop;\n+   --     end Pong;\n+   --\n+   --     task body Pong is\n+   --        Address  : Sock_Addr_Type;\n+   --        Server   : Socket_Type;\n+   --        Socket   : Socket_Type;\n+   --        Channel  : Stream_Access;\n+   --\n+   --     begin\n+   --        accept Start;\n+   --\n+   --        --  Get an Internet address of a host (here \"localhost\").\n+   --        --  Note that a host can have several addresses. Here we get\n+   --        --  the first one which is supposed to be the official one.\n+   --\n+   --        Address.Addr := Addresses (Get_Host_By_Name (\"localhost\"), 1);\n+   --\n+   --        --  Get a socket address that is an Internet address and a port\n+   --\n+   --        Address.Port := 5432;\n+   --\n+   --        --  The first step is to create a socket. Once created, this\n+   --        --  socket must be associated to with an address. Usually only a\n+   --        --  server (Pong here) needs to bind an address explicitly.\n+   --        --  Most of the time clients can skip this step because the\n+   --        --  socket routines will bind an arbitrary address to an unbound\n+   --        --  socket.\n+   --\n+   --        Create_Socket (Server);\n+   --\n+   --        --  Allow reuse of local addresses.\n+   --\n+   --        Set_Socket_Option\n+   --          (Server,\n+   --           Socket_Level,\n+   --           (Reuse_Address, True));\n+   --\n+   --        Bind_Socket (Server, Address);\n+   --\n+   --        --  A server marks a socket as willing to receive connect events.\n+   --\n+   --        Listen_Socket (Server);\n+   --\n+   --        --  Once a server calls Listen_Socket, incoming connects events\n+   --        --  can be accepted. The returned Socket is a new socket that\n+   --        --  represents the server side of the connection. Server remains\n+   --        --  available to receive further connections.\n+   --\n+   --        Accept_Socket (Server, Socket, Address);\n+   --\n+   --        --  Return a stream associated to the connected socket.\n+   --\n+   --        Channel := Stream (Socket);\n+   --\n+   --        --  Force Pong to block\n+   --\n+   --        delay 0.2;\n+   --\n+   --        --  Receive and print message from client Ping.\n+   --\n+   --        declare\n+   --           Message : String := String'Input (Channel);\n+   --\n+   --        begin\n+   --           Ada.Text_IO.Put_Line (Message);\n+   --\n+   --           --  Send same message to server Pong.\n+   --\n+   --           String'Output (Channel, Message);\n+   --        end;\n+   --\n+   --        Close_Socket (Server);\n+   --        Close_Socket (Socket);\n+   --\n+   --        --  Part of the multicast example\n+   --\n+   --        --  Create a datagram socket to send connectionless, unreliable\n+   --        --  messages of a fixed maximum length.\n+   --\n+   --        Create_Socket (Socket, Family_Inet, Socket_Datagram);\n+   --\n+   --        --  Allow reuse of local addresses.\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           Socket_Level,\n+   --           (Reuse_Address, True));\n+   --\n+   --        --  Join a multicast group.\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           IP_Protocol_For_IP_Level,\n+   --           (Add_Membership, Inet_Addr (Group), Any_Inet_Addr));\n+   --\n+   --        --  Controls the live time of the datagram to avoid it being\n+   --        --  looped forever due to routing errors. Routers decrement\n+   --        --  the TTL of every datagram as it traverses from one network\n+   --        --  to another and when its value reaches 0 the packet is\n+   --        --  dropped. Default is 1.\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           IP_Protocol_For_IP_Level,\n+   --           (Multicast_TTL, 1));\n+   --\n+   --        --  Want the data you send to be looped back to your host.\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           IP_Protocol_For_IP_Level,\n+   --           (Multicast_Loop, True));\n+   --\n+   --        --  If this socket is intended to receive messages, bind it to a\n+   --        --  given socket address.\n+   --\n+   --        Address.Addr := Any_Inet_Addr;\n+   --        Address.Port := 55505;\n+   --\n+   --        Bind_Socket (Socket, Address);\n+   --\n+   --        --  If this socket is intended to send messages, provide the\n+   --        --  receiver socket address.\n+   --\n+   --        Address.Addr := Inet_Addr (Group);\n+   --        Address.Port := 55506;\n+   --\n+   --        Channel := Stream (Socket, Address);\n+   --\n+   --        --  Receive and print message from client Ping.\n+   --\n+   --        declare\n+   --           Message : String := String'Input (Channel);\n+   --\n+   --        begin\n+   --\n+   --           --  Get the address of the sender.\n+   --\n+   --           Address := Get_Address (Channel);\n+   --           Ada.Text_IO.Put_Line (Message & \" from \" & Image (Address));\n+   --\n+   --           --  Send same message to server Pong.\n+   --\n+   --           String'Output (Channel, Message);\n+   --        end;\n+   --\n+   --        Close_Socket (Socket);\n+   --\n+   --        accept Stop;\n+   --\n+   --     exception when E : others =>\n+   --        Ada.Text_IO.Put_Line\n+   --          (Exception_Name (E) & \": \" & Exception_Message (E));\n+   --     end Pong;\n+   --\n+   --     task Ping is\n+   --        entry Start;\n+   --        entry Stop;\n+   --     end Ping;\n+   --\n+   --     task body Ping is\n+   --        Address  : Sock_Addr_Type;\n+   --        Socket   : Socket_Type;\n+   --        Channel  : Stream_Access;\n+   --\n+   --     begin\n+   --        accept Start;\n+   --\n+   --        --  See comments in Ping section for the first steps.\n+   --\n+   --        Address.Addr := Addresses (Get_Host_By_Name (\"localhost\"), 1);\n+   --        Address.Port := 5432;\n+   --        Create_Socket (Socket);\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           Socket_Level,\n+   --           (Reuse_Address, True));\n+   --\n+   --        --  Force Pong to block\n+   --\n+   --        delay 0.2;\n+   --\n+   --        --  If the client's socket is not bound, Connect_Socket will\n+   --        --  bind to an unused address. The client uses Connect_Socket to\n+   --        --  create a logical connection between the client's socket and\n+   --        --  a server's socket returned by Accept_Socket.\n+   --\n+   --        Connect_Socket (Socket, Address);\n+   --\n+   --        Channel := Stream (Socket);\n+   --\n+   --        --  Send message to server Pong.\n+   --\n+   --        String'Output (Channel, \"Hello world\");\n+   --\n+   --        --  Force Ping to block\n+   --\n+   --        delay 0.2;\n+   --\n+   --        --  Receive and print message from server Pong.\n+   --\n+   --        Ada.Text_IO.Put_Line (String'Input (Channel));\n+   --        Close_Socket (Socket);\n+   --\n+   --        --  Part of multicast example. Code similar to Pong's one.\n+   --\n+   --        Create_Socket (Socket, Family_Inet, Socket_Datagram);\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           Socket_Level,\n+   --           (Reuse_Address, True));\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           IP_Protocol_For_IP_Level,\n+   --           (Add_Membership, Inet_Addr (Group), Any_Inet_Addr));\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           IP_Protocol_For_IP_Level,\n+   --           (Multicast_TTL, 1));\n+   --\n+   --        Set_Socket_Option\n+   --          (Socket,\n+   --           IP_Protocol_For_IP_Level,\n+   --           (Multicast_Loop, True));\n+   --\n+   --        Address.Addr := Any_Inet_Addr;\n+   --        Address.Port := 55506;\n+   --\n+   --        Bind_Socket (Socket, Address);\n+   --\n+   --        Address.Addr := Inet_Addr (Group);\n+   --        Address.Port := 55505;\n+   --\n+   --        Channel := Stream (Socket, Address);\n+   --\n+   --        --  Send message to server Pong.\n+   --\n+   --        String'Output (Channel, \"Hello world\");\n+   --\n+   --        --  Receive and print message from server Pong.\n+   --\n+   --        declare\n+   --           Message : String := String'Input (Channel);\n+   --\n+   --        begin\n+   --           Address := Get_Address (Channel);\n+   --           Ada.Text_IO.Put_Line (Message & \" from \" & Image (Address));\n+   --        end;\n+   --\n+   --        Close_Socket (Socket);\n+   --\n+   --        accept Stop;\n+   --\n+   --     exception when E : others =>\n+   --        Ada.Text_IO.Put_Line\n+   --          (Exception_Name (E) & \": \" & Exception_Message (E));\n+   --     end Ping;\n+   --\n+   --  begin\n+   --     --  Indicate whether the thread library provides process\n+   --     --  blocking IO. Basically, if you are not using FSU threads\n+   --     --  the default is ok.\n+   --\n+   --     Initialize (Process_Blocking_IO => False);\n+   --     Ping.Start;\n+   --     Pong.Start;\n+   --     Ping.Stop;\n+   --     Pong.Stop;\n+   --     Finalize;\n+   --  end PingPong;\n+\n+   procedure Initialize (Process_Blocking_IO : Boolean := False);\n+   --  Initialize must be called before using any socket routines. If\n+   --  the thread library provides process blocking IO - basically\n+   --  with FSU threads - GNAT.Sockets should be initialized with a\n+   --  value of True to simulate thread blocking IO. Further calls to\n+   --  Initialize will be ignored.\n+\n+   procedure Finalize;\n+   --  After Finalize is called it is not possible to use any routines\n+   --  exported in by this package. This procedure is idempotent.\n+\n+   type Socket_Type is private;\n+   --  Sockets are used to implement a reliable bi-directional\n+   --  point-to-point, stream-based connections between\n+   --  hosts. No_Socket provides a special value to denote\n+   --  uninitialized sockets.\n+\n+   No_Socket : constant Socket_Type;\n+\n+   Socket_Error : exception;\n+   --  There is only one exception in this package to deal with an\n+   --  error during a socket routine. Once raised, its message\n+   --  contains a string describing the error code.\n+\n+   function Image (Socket : Socket_Type) return String;\n+   --  Return a printable string for Socket\n+\n+   function To_C (Socket : Socket_Type) return Integer;\n+   --  Return a file descriptor to be used by external subprograms\n+   --  especially the C functions that are not yet interfaced in this\n+   --  package.\n+\n+   type Family_Type is (Family_Inet, Family_Inet6);\n+   --  Address family (or protocol family) identifies the\n+   --  communication domain and groups protocols with similar address\n+   --  formats. IPv6 will soon be supported.\n+\n+   type Mode_Type is (Socket_Stream, Socket_Datagram);\n+   --  Stream sockets provide connection-oriented byte\n+   --  streams. Datagram sockets support unreliable connectionless\n+   --  message based communication.\n+\n+   type Shutmode_Type is (Shut_Read, Shut_Write, Shut_Read_Write);\n+   --  When a process closes a socket, the policy is to retain any\n+   --  data queued until either a delivery or a timeout expiration (in\n+   --  this case, the data are discarded). A finer control is\n+   --  available through shutdown. With Shut_Read, no more data can be\n+   --  received from the socket. With_Write, no more data can be\n+   --  transmitted. Neither transmission nor reception can be\n+   --  performed with Shut_Read_Write.\n+\n+   type Port_Type is new Natural;\n+   --  Classical port definition. No_Port provides a special value to\n+   --  denote uninitialized port. Any_Port provides a special value\n+   --  enabling all ports.\n+\n+   Any_Port : constant Port_Type;\n+   No_Port  : constant Port_Type;\n+\n+   type Inet_Addr_Type (Family : Family_Type := Family_Inet) is private;\n+   --  An Internet address depends on an address family (IPv4 contains\n+   --  4 octets and Ipv6 contains 16 octets). Any_Inet_Address is a\n+   --  special value treated like a wildcard enabling all addresses.\n+   --  No_Inet_Addr provides a special value to denote uninitialized\n+   --  inet addresses.\n+\n+   Any_Inet_Addr : constant Inet_Addr_Type;\n+   No_Inet_Addr  : constant Inet_Addr_Type;\n+\n+   type Sock_Addr_Type (Family : Family_Type := Family_Inet) is record\n+      Addr : Inet_Addr_Type (Family);\n+      Port : Port_Type;\n+   end record;\n+   --  Socket addresses fully define a socket connection with a\n+   --  protocol family, an Internet address and a port. No_Sock_Addr\n+   --  provides a special value for uninitialized socket addresses.\n+\n+   No_Sock_Addr : constant Sock_Addr_Type;\n+\n+   function Image (Value : Inet_Addr_Type) return String;\n+   --  Return an image of an Internet address. IPv4 notation consists\n+   --  in 4 octets in decimal format separated by dots. IPv6 notation\n+   --  consists in 16 octets in hexadecimal format separated by\n+   --  colons (and possibly dots).\n+\n+   function Image (Value : Sock_Addr_Type) return String;\n+   --  Return inet address image and port image separated by a colon.\n+\n+   function Inet_Addr (Image : String) return Inet_Addr_Type;\n+   --  Convert address image from numbers-and-dots notation into an\n+   --  inet address.\n+\n+   --  Host entries provide a complete information on a given host:\n+   --  the official name, an array of alternative names or aliases and\n+   --  array of network addresses.\n+\n+   type Host_Entry_Type\n+     (Aliases_Length, Addresses_Length : Natural) is private;\n+\n+   function Official_Name (E : Host_Entry_Type) return String;\n+   --  Return official name in host entry\n+\n+   function Aliases_Length (E : Host_Entry_Type) return Natural;\n+   --  Return number of aliases in host entry\n+\n+   function Addresses_Length (E : Host_Entry_Type) return Natural;\n+   --  Return number of addresses in host entry\n+\n+   function Aliases\n+     (E    : Host_Entry_Type;\n+      N    : Positive := 1)\n+      return String;\n+   --  Return N'th aliases in host entry. The first index is 1.\n+\n+   function Addresses\n+     (E    : Host_Entry_Type;\n+      N    : Positive := 1)\n+      return Inet_Addr_Type;\n+   --  Return N'th addresses in host entry. The first index is 1.\n+\n+   Host_Error : exception;\n+   --  Exception raised by the two following procedures. Once raised,\n+   --  its message contains a string describing the error code. This\n+   --  exception is raised when an host entry can not be retrieved.\n+\n+   function Get_Host_By_Address\n+     (Address : Inet_Addr_Type;\n+      Family  : Family_Type := Family_Inet)\n+      return    Host_Entry_Type;\n+   --  Return host entry structure for the given inet address\n+\n+   function Get_Host_By_Name\n+     (Name : String)\n+      return Host_Entry_Type;\n+   --  Return host entry structure for the given host name\n+\n+   function Host_Name return String;\n+   --  Return the name of the current host\n+\n+   --  Errors are described by an enumeration type. There is only one\n+   --  exception Socket_Error in this package to deal with an error\n+   --  during a socket routine. Once raised, its message contains the\n+   --  error code between brackets and a string describing the error\n+   --  code.\n+\n+   type Error_Type is\n+     (Permission_Denied,\n+      Address_Already_In_Use,\n+      Cannot_Assign_Requested_Address,\n+      Address_Family_Not_Supported_By_Protocol,\n+      Operation_Already_In_Progress,\n+      Bad_File_Descriptor,\n+      Connection_Refused,\n+      Bad_Address,\n+      Operation_Now_In_Progress,\n+      Interrupted_System_Call,\n+      Invalid_Argument,\n+      Input_Output_Error,\n+      Transport_Endpoint_Already_Connected,\n+      Message_Too_Long,\n+      Network_Is_Unreachable,\n+      No_Buffer_Space_Available,\n+      Protocol_Not_Available,\n+      Transport_Endpoint_Not_Connected,\n+      Operation_Not_Supported,\n+      Protocol_Not_Supported,\n+      Socket_Type_Not_Supported,\n+      Connection_Timed_Out,\n+      Resource_Temporarily_Unavailable,\n+      Unknown_Host,\n+      Host_Name_Lookup_Failure,\n+      No_Address_Associated_With_Name,\n+      Unknown_Server_Error,\n+      Cannot_Resolve_Error);\n+\n+   --  Get_Socket_Options and Set_Socket_Options manipulate options\n+   --  associated with a socket. Options may exist at multiple\n+   --  protocol levels in the communication stack. Socket_Level is the\n+   --  uppermost socket level.\n+\n+   type Level_Type is (\n+     Socket_Level,\n+     IP_Protocol_For_IP_Level,\n+     IP_Protocol_For_UDP_Level,\n+     IP_Protocol_For_TCP_Level);\n+\n+   --  There are several options available to manipulate sockets. Each\n+   --  option has a name and several values available. Most of the\n+   --  time, the value is a boolean to enable or disable this option.\n+\n+   type Option_Name is (\n+     Keep_Alive,      -- Enable sending of keep-alive messages\n+     Reuse_Address,   -- Allow bind to reuse local address\n+     Broadcast,       -- Enable datagram sockets to recv/send broadcast packets\n+     Send_Buffer,     -- Set/get the maximum socket send buffer in bytes\n+     Receive_Buffer,  -- Set/get the maximum socket recv buffer in bytes\n+     Linger,          -- Shutdown wait for msg to be sent or timeout occur\n+     Error,           -- Get and clear the pending socket error\n+     No_Delay,        -- Do not delay send to coalesce packets (TCP_NODELAY)\n+     Add_Membership,  -- Join a multicast group\n+     Drop_Membership, -- Leave a multicast group\n+     Multicast_TTL,   -- Indicates the time-to-live of sent multicast packets\n+     Multicast_Loop); -- Sent multicast packets are looped to the local socket\n+\n+   type Option_Type (Name : Option_Name := Keep_Alive) is record\n+      case Name is\n+         when Keep_Alive      |\n+              Reuse_Address   |\n+              Broadcast       |\n+              Linger          |\n+              No_Delay        |\n+              Multicast_Loop  =>\n+            Enabled : Boolean;\n+\n+            case Name is\n+               when Linger    =>\n+                  Seconds : Natural;\n+               when others    =>\n+                  null;\n+            end case;\n+\n+         when Send_Buffer     |\n+              Receive_Buffer  =>\n+            Size : Natural;\n+\n+         when Error           =>\n+            Error : Error_Type;\n+\n+         when Add_Membership  |\n+              Drop_Membership =>\n+            Multiaddr : Inet_Addr_Type;\n+            Interface : Inet_Addr_Type;\n+\n+         when Multicast_TTL   =>\n+            Time_To_Live : Natural;\n+\n+      end case;\n+   end record;\n+\n+   --  There are several controls available to manipulate\n+   --  sockets. Each option has a name and several values available.\n+   --  These controls differ from the socket options in that they are\n+   --  not specific to sockets but are available for any device.\n+\n+   type Request_Name is (\n+      Non_Blocking_IO,  --  Cause a caller not to wait on blocking operations.\n+      N_Bytes_To_Read); --  Return the number of bytes available to read\n+\n+   type Request_Type (Name : Request_Name := Non_Blocking_IO) is record\n+      case Name is\n+         when Non_Blocking_IO =>\n+            Enabled : Boolean;\n+\n+         when N_Bytes_To_Read =>\n+            Size : Natural;\n+\n+      end case;\n+   end record;\n+\n+   procedure Create_Socket\n+     (Socket : out Socket_Type;\n+      Family : Family_Type := Family_Inet;\n+      Mode   : Mode_Type   := Socket_Stream);\n+   --  Create an endpoint for communication. Raise Socket_Error on error.\n+\n+   procedure Accept_Socket\n+     (Server  : Socket_Type;\n+      Socket  : out Socket_Type;\n+      Address : out Sock_Addr_Type);\n+   --  Extract the first connection request on the queue of pending\n+   --  connections, creates a new connected socket with mostly the\n+   --  same properties as Server, and allocates a new socket. The\n+   --  returned Address is filled in with the address of the\n+   --  connection. Raise Socket_Error on error.\n+\n+   procedure Bind_Socket\n+     (Socket  : Socket_Type;\n+      Address : Sock_Addr_Type);\n+   --  Once a socket is created, assign a local address to it. Raise\n+   --  Socket_Error on error.\n+\n+   procedure Close_Socket (Socket : Socket_Type);\n+   --  Close a socket and more specifically a non-connected socket.\n+   --  Fail silently.\n+\n+   procedure Connect_Socket\n+     (Socket : Socket_Type;\n+      Server : in out Sock_Addr_Type);\n+   --  Make a connection to another socket which has the address of\n+   --  Server. Raise Socket_Error on error.\n+\n+   procedure Control_Socket\n+     (Socket  : Socket_Type;\n+      Request : in out Request_Type);\n+   --  Obtain or set parameter values that control the socket. This\n+   --  control differs from the socket options in that they are not\n+   --  specific to sockets but are avaiable for any device.\n+\n+   function Get_Peer_Name (Socket : Socket_Type) return Sock_Addr_Type;\n+   --  Return the peer or remote socket address of a socket. Raise\n+   --  Socket_Error on error.\n+\n+   function Get_Socket_Name (Socket : Socket_Type) return Sock_Addr_Type;\n+   --  Return the local or current socket address of a socket. Raise\n+   --  Socket_Error on error.\n+\n+   function Get_Socket_Option\n+     (Socket : Socket_Type;\n+      Level  : Level_Type := Socket_Level;\n+      Name   : Option_Name)\n+      return   Option_Type;\n+   --  Get the options associated with a socket. Raise Socket_Error on\n+   --  error.\n+\n+   procedure Listen_Socket\n+     (Socket : Socket_Type;\n+      Length : Positive := 15);\n+   --  To accept connections, a socket is first created with\n+   --  Create_Socket, a willingness to accept incoming connections and\n+   --  a queue Length for incoming connections are specified. Raise\n+   --  Socket_Error on error.\n+\n+   procedure Receive_Socket\n+     (Socket : Socket_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset);\n+   --  Receive message from Socket. Last is the index value such that\n+   --  Item (Last) is the last character assigned. Note that Last is\n+   --  set to Item'First - 1 when the socket has been closed by\n+   --  peer. This is not an error and no exception is raised. Raise\n+   --  Socket_Error on error.\n+\n+   procedure Receive_Socket\n+     (Socket : Socket_Type;\n+      Item   : out Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset;\n+      From   : out Sock_Addr_Type);\n+   --  Receive message from Socket. If Socket is not\n+   --  connection-oriented, the source address From of the message is\n+   --  filled in. Last is the index value such that Item (Last) is the\n+   --  last character assigned. Raise Socket_Error on error.\n+\n+   function Resolve_Exception\n+     (Occurrence : Ada.Exceptions.Exception_Occurrence)\n+     return        Error_Type;\n+   --  When Socket_Error or Host_Error are raised, the exception\n+   --  message contains the error code between brackets and a string\n+   --  describing the error code. Resolve_Error extracts the error\n+   --  code from an exception message and translate it into an\n+   --  enumeration value.\n+\n+   procedure Send_Socket\n+     (Socket : Socket_Type;\n+      Item   : Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset);\n+   --  Transmit a message to another socket. Note that Last is set to\n+   --  Item'First when socket has been closed by peer. This is not an\n+   --  error and no exception is raised. Raise Socket_Error on error;\n+\n+   procedure Send_Socket\n+     (Socket : Socket_Type;\n+      Item   : Ada.Streams.Stream_Element_Array;\n+      Last   : out Ada.Streams.Stream_Element_Offset;\n+      To     : Sock_Addr_Type);\n+   --  Transmit a message to another socket. The address is given by\n+   --  To. Raise Socket_Error on error;\n+\n+   procedure Set_Socket_Option\n+     (Socket : Socket_Type;\n+      Level  : Level_Type := Socket_Level;\n+      Option : Option_Type);\n+   --  Manipulate socket options. Raise Socket_Error on error.\n+\n+   procedure Shutdown_Socket\n+     (Socket : Socket_Type;\n+      How    : Shutmode_Type := Shut_Read_Write);\n+   --  Shutdown a connected socket. If How is Shut_Read, further\n+   --  receives will be disallowed. If How is Shut_Write, further\n+   --  sends will be disallowed. If how is Shut_Read_Write, further\n+   --  sends and receives will be disallowed. Fail silently.\n+\n+   type Stream_Access is access all Ada.Streams.Root_Stream_Type'Class;\n+   --  Same interface as Ada.Streams.Stream_IO\n+\n+   function Stream\n+     (Socket : Socket_Type)\n+      return   Stream_Access;\n+   --  Associate a stream with a stream-based socket that is already\n+   --  connected.\n+\n+   function Stream\n+     (Socket  : Socket_Type;\n+      Send_To : Sock_Addr_Type)\n+      return    Stream_Access;\n+   --  Associate a stream with a datagram-based socket that is already\n+   --  bound. Send_To is the socket address to which messages are\n+   --  being sent.\n+\n+   function Get_Address\n+     (Stream : Stream_Access)\n+     return Sock_Addr_Type;\n+   --  Return the socket address from which the last message was\n+   --  received.\n+\n+   type Socket_Set_Type is private;\n+   --  This type allows to manipulate sets of sockets. It allows to\n+   --  wait for events on multiple endpoints at one time. This is an\n+   --  access type on a system dependent structure. To avoid memory\n+   --  leaks it is highly recommended to clean the access value with\n+   --  procedure Empty.\n+\n+   procedure Clear (Item : in out Socket_Set_Type; Socket : Socket_Type);\n+   --  Remove Socket from Item\n+\n+   procedure Set   (Item : in out Socket_Set_Type; Socket : Socket_Type);\n+   --  Insert Socket into Item\n+\n+   procedure Empty (Item : in out Socket_Set_Type);\n+   --  Remove all Sockets from Item and deallocate internal data\n+\n+   function Is_Empty\n+     (Item : Socket_Set_Type)\n+      return  Boolean;\n+   --  Return True if Item is empty\n+\n+   function Is_Set\n+     (Item   : Socket_Set_Type;\n+      Socket : Socket_Type)\n+      return   Boolean;\n+   --  Return True if Socket is present in Item\n+\n+   --  C select() waits for a number of file descriptors to change\n+   --  status. Usually, three independant sets of descriptors are\n+   --  watched (read, write and exception). A timeout gives an upper\n+   --  bound on the amount of time elapsed before select returns.\n+   --  This function blocks until an event occurs. On some platforms,\n+   --  C select can block the full process.\n+   --\n+   --  Check_Selector provides the very same behaviour. The only\n+   --  difference is that it does not watch for exception events. Note\n+   --  that on some platforms it is kept process blocking in purpose.\n+   --  The timeout parameter allows the user to have the behaviour he\n+   --  wants. Abort_Selector allows to abort safely a Check_Selector\n+   --  that is blocked forever. A special file descriptor is opened by\n+   --  Create_Selector and included in each call to\n+   --  Check_Selector. Abort_Selector causes an event to occur on this\n+   --  descriptor in order to unblock Check_Selector. The user must\n+   --  call Close_Selector to discard this special file. A reason to\n+   --  abort a select operation is typically to add a socket in one of\n+   --  the socket sets when the timeout is set to forever.\n+\n+   Forever : constant Duration;\n+\n+   type Selector_Type is limited private;\n+   type Selector_Access is access all Selector_Type;\n+\n+   procedure Create_Selector (Selector : out Selector_Type);\n+   --  Create a new selector\n+\n+   procedure Close_Selector (Selector : in out Selector_Type);\n+   --  Close Selector and all internal descriptors associated\n+\n+   type Selector_Status is (Completed, Expired, Aborted);\n+\n+   procedure Check_Selector\n+     (Selector     : in out Selector_Type;\n+      R_Socket_Set : in out Socket_Set_Type;\n+      W_Socket_Set : in out Socket_Set_Type;\n+      Status       : out Selector_Status;\n+      Timeout      : Duration := Forever);\n+   --  Return when one Socket in R_Socket_Set has some data to be read\n+   --  or if one Socket in W_Socket_Set is ready to receive some\n+   --  data. In these cases Status is set to Completed and sockets\n+   --  that are ready are set in R_Socket_Set or W_Socket_Set. Status\n+   --  is set to Expired if no socket was ready after a Timeout\n+   --  expiration. Status is set to Aborted if an abort signal as been\n+   --  received while checking socket status. As this procedure\n+   --  returns when Timeout occurs, it is a design choice to keep this\n+   --  procedure process blocking. Note that a Timeout of 0.0 returns\n+   --  immediatly.\n+\n+   procedure Abort_Selector (Selector : Selector_Type);\n+   --  Send an abort signal to the selector.\n+\n+private\n+\n+   type Socket_Type is new Integer;\n+   No_Socket : constant Socket_Type := -1;\n+\n+   Forever : constant Duration := Duration'Last;\n+\n+   type Selector_Type is limited record\n+      R_Sig_Socket : Socket_Type;\n+      W_Sig_Socket : Socket_Type;\n+      In_Progress  : Boolean := False;\n+   end record;\n+   --  The two signalling sockets are used to abort a select\n+   --  operation.\n+\n+   type Socket_Set_Record;\n+   type Socket_Set_Type is access all Socket_Set_Record;\n+\n+   subtype Inet_Addr_Comp_Type is Natural range 0 .. 255;\n+   --  Octet for Internet address\n+\n+   type Inet_Addr_VN_Type is array (Natural range <>) of Inet_Addr_Comp_Type;\n+\n+   subtype Inet_Addr_V4_Type is Inet_Addr_VN_Type (1 ..  4);\n+   subtype Inet_Addr_V6_Type is Inet_Addr_VN_Type (1 .. 16);\n+\n+   type Inet_Addr_Type (Family : Family_Type := Family_Inet) is record\n+      case Family is\n+         when Family_Inet =>\n+            Sin_V4 : Inet_Addr_V4_Type := (others => 0);\n+\n+         when Family_Inet6 =>\n+            Sin_V6 : Inet_Addr_V6_Type := (others => 0);\n+      end case;\n+   end record;\n+\n+   Any_Port : constant Port_Type := 0;\n+   No_Port  : constant Port_Type := 0;\n+\n+   Any_Inet_Addr : constant Inet_Addr_Type := (Family_Inet, (others => 0));\n+   No_Inet_Addr  : constant Inet_Addr_Type := (Family_Inet, (others => 0));\n+\n+   No_Sock_Addr  : constant Sock_Addr_Type := (Family_Inet, No_Inet_Addr, 0);\n+\n+   Max_Host_Name_Length : constant := 64;\n+   --  The constant MAXHOSTNAMELEN is usually set to 64\n+\n+   subtype Host_Name_Index is Natural range 1 .. Max_Host_Name_Length;\n+\n+   type Host_Name_Type\n+     (Length : Host_Name_Index := Max_Host_Name_Length)\n+   is record\n+      Name : String (1 .. Length);\n+   end record;\n+   --  We need fixed strings to avoid access types in host entry type\n+\n+   type Host_Name_Array is array (Natural range <>) of Host_Name_Type;\n+   type Inet_Addr_Array is array (Natural range <>) of Inet_Addr_Type;\n+\n+   type Host_Entry_Type (Aliases_Length, Addresses_Length : Natural) is record\n+      Official  : Host_Name_Type;\n+      Aliases   : Host_Name_Array (1 .. Aliases_Length);\n+      Addresses : Inet_Addr_Array (1 .. Addresses_Length);\n+   end record;\n+\n+end GNAT.Sockets;"}, {"sha": "7fdf17e36603a2c85a69a1e872a39ec078698370", "filename": "gcc/ada/g-socthi.adb", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socthi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socthi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "2e46390a5bd31228dbb653de7ce99ee9dfa87b29", "filename": "gcc/ada/g-socthi.ads", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socthi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-socthi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "26f621c41ea7afce8847e72fa68326edebae0a73", "filename": "gcc/ada/g-soliop.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-soliop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-soliop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-soliop.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "6d647118bc57a5c6eb25b145f9e1dcbdb3b4b74d", "filename": "gcc/ada/g-souinf.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-souinf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-souinf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-souinf.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "07d5e62f2e4c89c44a88ea06ecb4a83d12b60c18", "filename": "gcc/ada/g-speche.adb", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-speche.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-speche.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-speche.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "80604599194600de82c8af4071b8d1dcfcd65b83", "filename": "gcc/ada/g-speche.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-speche.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-speche.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-speche.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "fbacdb600c92b0c38f369b867314560c415476fe", "filename": "gcc/ada/g-spipat.adb", "status": "added", "additions": 6328, "deletions": 0, "changes": 6328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spipat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spipat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "9b66d9e3e72c9f03ffcf1ea78fcbe4a35e42d029", "filename": "gcc/ada/g-spipat.ads", "status": "added", "additions": 1204, "deletions": 0, "changes": 1204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spipat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spipat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "cb2cee8f410f9d186cd74c86d543604dcd7e13b6", "filename": "gcc/ada/g-spitbo.adb", "status": "added", "additions": 764, "deletions": 0, "changes": 764, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spitbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spitbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spitbo.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "ebf2620e156a0762d7cd5f52f2bd3dbdda7eba07", "filename": "gcc/ada/g-spitbo.ads", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spitbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-spitbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spitbo.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "f6c170e32509ea525ffdccf70860e3c1ec0464f8", "filename": "gcc/ada/g-sptabo.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-sptabo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-sptabo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sptabo.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "24b824508b3ca3ef750387b53fb3c0aeda94a458", "filename": "gcc/ada/g-sptain.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-sptain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-sptain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sptain.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "87d4d5cef21ec3f5893216496239a7b9dd49a6c2", "filename": "gcc/ada/g-sptavs.ads", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-sptavs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-sptavs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sptavs.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "086f1de7970349a018db6ef92446fa625c7695ca", "filename": "gcc/ada/g-table.adb", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-table.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-table.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "2ddd0b08d70be27772c3b3a69c0c23ca227d3d8b", "filename": "gcc/ada/g-table.ads", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-table.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-table.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "375586c7c4ea7ab1300c8133dcfb2cd646921e05", "filename": "gcc/ada/g-tasloc.adb", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-tasloc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-tasloc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-tasloc.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "f80bdf49a60c36bc69d4f08bd9f75d9f25ca0e50", "filename": "gcc/ada/g-tasloc.ads", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-tasloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-tasloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-tasloc.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "ad6b754106d21542030eab353d14dc543f7f392c", "filename": "gcc/ada/g-thread.adb", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-thread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-thread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-thread.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "4ccdda9b6d82daa48eb75b6cb91880eeac47a8c4", "filename": "gcc/ada/g-thread.ads", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-thread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-thread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-thread.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "d1d6c42a664642e33463a07db19771bdc0e9210a", "filename": "gcc/ada/g-traceb.adb", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-traceb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-traceb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-traceb.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "5f7a6ec1540d654317ac010900343b168ad648e7", "filename": "gcc/ada/g-traceb.ads", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-traceb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-traceb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-traceb.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "65ffe0feb0ee8fff16272ab00a8a7b1e24852ad9", "filename": "gcc/ada/g-trasym.adb", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-trasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-trasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "c8f27b048b627f4487bc0c6ab926111b4d2b0da9", "filename": "gcc/ada/g-trasym.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-trasym.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fg-trasym.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "69b265fc8695a7face78597866e3008e8df4e287", "filename": "gcc/ada/get_targ.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fget_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fget_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "d6b0e3cbf3bf7a091e4d871af6513b659b1f1b17", "filename": "gcc/ada/get_targ.ads", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "49d8533c8c9493ad703d21571b6125a0e6798800", "filename": "gcc/ada/gigi.h", "status": "added", "additions": 783, "deletions": 0, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "31e4b848eb23b58877cae01c10c94a032110d572", "filename": "gcc/ada/gmem.c", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgmem.c?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "f42efcbd35d805b28cf48624b3129f3d756e67cb", "filename": "gcc/ada/gnat.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "afa04c6409a7d372467b54028f3226721e78c4a8", "filename": "gcc/ada/gnat1drv.adb", "status": "added", "additions": 642, "deletions": 0, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "192e1b840ee3c9ee195af8dacd1fc52aa1e26f14", "filename": "gcc/ada/gnat1drv.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnat1drv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnat1drv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "61f4a01f4767e339683a4db1c919feef6389e89c", "filename": "gcc/ada/gnatbind.adb", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "39c03c3d94db89ac7d2a53c78e18d001184aaa0a", "filename": "gcc/ada/gnatbind.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatbind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatbind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "18529a272b722291f3db8b17bc98767c2750535f", "filename": "gcc/ada/gnatbl.c", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatbl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatbl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbl.c?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "acb644460f801cda03d33ef68ce5c7ccbd1ed439", "filename": "gcc/ada/gnatchop.adb", "status": "added", "additions": 1696, "deletions": 0, "changes": 1696, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "ac4e302f252fbb0cc5bdf0c750c2746acbabb901", "filename": "gcc/ada/gnatcmd.adb", "status": "added", "additions": 3239, "deletions": 0, "changes": 3239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "3a1344b8c7e463ce508fdd9e589045a68f8ad239", "filename": "gcc/ada/gnatcmd.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatcmd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatcmd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "c83a3975b7a13b71c1efe5fcf28cf57fa5b33942", "filename": "gcc/ada/gnatdll.adb", "status": "added", "additions": 545, "deletions": 0, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatdll.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "f7ebf856a0c4ef88624e5b26330af2af2e5865d7", "filename": "gcc/ada/gnatfind.adb", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatfind.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "7d8715852500339c1a50e29d3ef3f2c5ae3a048c", "filename": "gcc/ada/gnatkr.adb", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatkr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatkr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatkr.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "771043209a6d550112929f07847614047aa51abe", "filename": "gcc/ada/gnatkr.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatkr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatkr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatkr.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "f4dd7cb2f10717a3750a042a88f2aa1b84d2bf01", "filename": "gcc/ada/gnatlbr.adb", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatlbr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatlbr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlbr.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "30482a8763814d7432609faddce01756e216f580", "filename": "gcc/ada/gnatlink.adb", "status": "added", "additions": 1351, "deletions": 0, "changes": 1351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "65e4845a7a0c9cd53659b375c8264875a9fb4245", "filename": "gcc/ada/gnatlink.ads", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatlink.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatlink.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "b131ddb572f5572a0caf93796964828da53f9e74", "filename": "gcc/ada/gnatls.adb", "status": "added", "additions": 1157, "deletions": 0, "changes": 1157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "fc499abc751956d203948937051cf5350c46a50d", "filename": "gcc/ada/gnatls.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatls.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatls.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "0380b6f8610b7bb16a072eacd7518f84fe4f7c38", "filename": "gcc/ada/gnatmake.adb", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatmake.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "5d46676c38dd98ab9fd68ff9169e76645df93e8b", "filename": "gcc/ada/gnatmake.ads", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatmake.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatmake.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatmake.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "b3457118f9ac5648a001c93e8bd22553c6e85160", "filename": "gcc/ada/gnatmem.adb", "status": "added", "additions": 1059, "deletions": 0, "changes": 1059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatmem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatmem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatmem.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "ccff6fc4a3cae1b8ec21d4bde1240271e6e76382", "filename": "gcc/ada/gnatprep.adb", "status": "added", "additions": 1395, "deletions": 0, "changes": 1395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatprep.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "7e8fbd82e7b4d029a3345aa5c68975172fc66a92", "filename": "gcc/ada/gnatprep.ads", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatprep.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatprep.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatprep.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "08dae2e0fe7bdfc652b77c040e3ef323a1c677e5", "filename": "gcc/ada/gnatpsta.adb", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatpsta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatpsta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatpsta.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "9e65c2a25377fc8ecd239e95797c666110c01f1b", "filename": "gcc/ada/gnatpsys.adb", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatpsys.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatpsys.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatpsys.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "a6f27cdbf1631ead25bcf02536983a784c56cd65", "filename": "gcc/ada/gnatvsn.ads", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatvsn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatvsn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatvsn.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "6e44ddcdde7ff4dad2a53ab9bdfe62d5e743c070", "filename": "gcc/ada/gnatxref.adb", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatxref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fgnatxref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatxref.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "86fe3bd32822474ac14cf2713b656b504fc08616", "filename": "gcc/ada/hlo.adb", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fhlo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fhlo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fhlo.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "22d37e5d17f2524f6f61235b610d99b1a6152def", "filename": "gcc/ada/hlo.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fhlo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fhlo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fhlo.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "b076f99bd69f7f278ad6855e5e44f0b506d37cd5", "filename": "gcc/ada/hostparm.ads", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fhostparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fhostparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fhostparm.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "33410de29416531be96240542104b7e7b9350d65", "filename": "gcc/ada/i-c.adb", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-c.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "848c5247cc3c76b183b6ea004ed20a94a4e23b8b", "filename": "gcc/ada/i-c.ads", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-c.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "85506195bce0c5fc70fce1f4e3518ec2ef0cfa5e", "filename": "gcc/ada/i-cexten.ads", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cexten.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cexten.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cexten.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "74b65b9e457af9cfe83262d78ef3d2755616869b", "filename": "gcc/ada/i-cobol.adb", "status": "added", "additions": 1024, "deletions": 0, "changes": 1024, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cobol.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cobol.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cobol.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "cbb3c350dec0c72b728a432625d5db6b4bbf9271", "filename": "gcc/ada/i-cobol.ads", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cobol.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cobol.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cobol.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "7d4cbc8143a7d2b989b88437e0dc0fbf0669c4f0", "filename": "gcc/ada/i-cpoint.adb", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpoint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpoint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpoint.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "728643a2a5f18098abf9bc437af8bce46e60d3bb", "filename": "gcc/ada/i-cpoint.ads", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpoint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpoint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpoint.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "3aed957b943026f52bdb0954224f4a0b206b3c46", "filename": "gcc/ada/i-cpp.adb", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpp.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "86d6673c4311ef6d46bb2466f258627c924a1bda", "filename": "gcc/ada/i-cpp.ads", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cpp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpp.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "00057dc33f1bd99dfc75735bbabecd18ea087181", "filename": "gcc/ada/i-cstrea.adb", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrea.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "220b215e78f7e98241089dfe1db17ffe8d35d84a", "filename": "gcc/ada/i-cstrea.ads", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrea.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "4c0f166ce6779301566d378008d797c8b5656c2a", "filename": "gcc/ada/i-cstrin.adb", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrin.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "308b6000146ced6da6170654de659c88b23ba036", "filename": "gcc/ada/i-cstrin.ads", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-cstrin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrin.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "cc18578431d3f89393b3eb80e95eabb37e675b29", "filename": "gcc/ada/i-fortra.adb", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-fortra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-fortra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-fortra.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "9a9262cd904e09ffa954ccca9f44b5a24f96585d", "filename": "gcc/ada/i-fortra.ads", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-fortra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-fortra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-fortra.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "12d80f7de772dc1836e0b50a95f1a30e281b2a4b", "filename": "gcc/ada/i-os2err.ads", "status": "added", "additions": 657, "deletions": 0, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2err.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2err.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2err.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "0e5446bb5cd9e6894cb9d5fc8832fdd4add3f649", "filename": "gcc/ada/i-os2lib.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2lib.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "45bc8e94b9666728a4b3787d935900f3f79cf683", "filename": "gcc/ada/i-os2lib.ads", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2lib.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "331fff326e926c5d9b4f29820bdab4431a535e99", "filename": "gcc/ada/i-os2syn.ads", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2syn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2syn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2syn.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "383c6e560c8339e3a172ef2afa2a1e9e4c2630e3", "filename": "gcc/ada/i-os2thr.ads", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2thr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-os2thr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2thr.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "81f805120a529be6ea2b521bdc83f1c0ccb7f2ec", "filename": "gcc/ada/i-pacdec.adb", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-pacdec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-pacdec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-pacdec.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "79f1e0db7c0c350a1761579dc33141647d625079", "filename": "gcc/ada/i-pacdec.ads", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-pacdec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-pacdec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-pacdec.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "edd61d027ca18222cb399fb622d3ab6eec8d4210", "filename": "gcc/ada/i-vxwork.ads", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-vxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fi-vxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-vxwork.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "46cc84408b6517633468fad8a81db9e22282251f", "filename": "gcc/ada/impunit.adb", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "99cf2af8bf045993760f3081f374993e2056a77a", "filename": "gcc/ada/impunit.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fimpunit.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fimpunit.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "77d0d6f967e40fe6afb65cf95192560a2ab1b2b7", "filename": "gcc/ada/init.c", "status": "added", "additions": 2027, "deletions": 0, "changes": 2027, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "b21ca1f53ddfd1fb58ea134ac10bdd2595b3c036", "filename": "gcc/ada/inline.adb", "status": "added", "additions": 954, "deletions": 0, "changes": 954, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "788d33c93763ac9d613f948fcbfc7f846251da7f", "filename": "gcc/ada/inline.ads", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "40cedcf9a8748695af84157f3c9af9e8d254ee83", "filename": "gcc/ada/interfac.ads", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finterfac.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Finterfac.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finterfac.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "33fbd5f2f8e01b01bd8045770e8c4c8cec0af0e7", "filename": "gcc/ada/io-aux.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fio-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fio-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fio-aux.c?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "ef8c1ae418d5cb499b9f77bb79045a79ab2b3c41", "filename": "gcc/ada/ioexcept.ads", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fioexcept.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fioexcept.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fioexcept.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "27b634dabe1f4f104c1afc1f4afca631759b6b39", "filename": "gcc/ada/itypes.adb", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fitypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fitypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "b44a28ee7d82e759b3f66bf12b8570372d595a56", "filename": "gcc/ada/itypes.ads", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fitypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fitypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "3f160e6fd4d78746b27b8ee92930c033dc83d2c3", "filename": "gcc/ada/krunch.adb", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fkrunch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fkrunch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "54877bce5a708a4c0dbceaa2ca8f7dafc4be03eb", "filename": "gcc/ada/krunch.ads", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fkrunch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fkrunch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "bd42c9b6bbde267f045d0b73c4988fa4f57b02b2", "filename": "gcc/ada/lang-options.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang-options.h?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "0019bb939d00397ae7447019e28d3d67f5c368c0", "filename": "gcc/ada/lang-specs.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang-specs.h?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "2ac451768a668c3c5d31668e73e5a4255ace56fb", "filename": "gcc/ada/layout.adb", "status": "added", "additions": 2573, "deletions": 0, "changes": 2573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "277ef5c09941cb2a2faba9a8c9dac6b0b9a0a050", "filename": "gcc/ada/layout.ads", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flayout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flayout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "0c900c6a691129c3a5280fc1983f62d7479abe00", "filename": "gcc/ada/lib-list.adb", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-list.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-list.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-list.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "b1f18d5f41e7b440633cb7de0466ac48b986276d", "filename": "gcc/ada/lib-load.adb", "status": "added", "additions": 717, "deletions": 0, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "1434e843238902c1cd7bd862df5890c33668f335", "filename": "gcc/ada/lib-load.ads", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-load.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-load.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "3fdfb72fe922da577df38c4a2f9f6b53df1b1f27", "filename": "gcc/ada/lib-sort.adb", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-sort.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-sort.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-sort.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "4e3770c5bab5429528aeeab2329dd1b3483c5320", "filename": "gcc/ada/lib-util.adb", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-util.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "48644764d65480ad029ea703d976a011063c7022", "filename": "gcc/ada/lib-util.ads", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-util.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "a7039f8390fff7114200dab8e6631d2d80b3305e", "filename": "gcc/ada/lib-writ.adb", "status": "added", "additions": 936, "deletions": 0, "changes": 936, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "f4ca41ac011142b1d8f67038d8223529679409e2", "filename": "gcc/ada/lib-writ.ads", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "f7e12ef65f1640a749c59e016a99dc431b2a226c", "filename": "gcc/ada/lib-xref.adb", "status": "added", "additions": 784, "deletions": 0, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "d0d2c8ab36c545b32db3d98319596ec5e7f755d2", "filename": "gcc/ada/lib-xref.ads", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "53e74f5459b7ddba3d369da96afc8d83d903e3e6", "filename": "gcc/ada/lib.adb", "status": "added", "additions": 866, "deletions": 0, "changes": 866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "d14fa2d0cc2faee523bab06d1e2f5434f48de8ff", "filename": "gcc/ada/lib.ads", "status": "added", "additions": 696, "deletions": 0, "changes": 696, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "a33735be8d09bbe1f37b5aba5e3b5c030f0a23b6", "filename": "gcc/ada/link.c", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "16627c2b5cd995c319e4515acdc79bd952894b51", "filename": "gcc/ada/live.adb", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flive.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flive.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flive.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "dcff98fcc302f1944b6fd9d099019114a5ff959b", "filename": "gcc/ada/live.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flive.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Flive.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flive.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "4fe8c1a74e5f95b2ac590601f66aa726271c0975", "filename": "gcc/ada/namet.adb", "status": "added", "additions": 1216, "deletions": 0, "changes": 1216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "2517c5579a3c8d3cb9899d14b64cc2d72a7c5f72", "filename": "gcc/ada/namet.ads", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "feb69b713f287f51478b25f4541ec0a07db00c29", "filename": "gcc/ada/namet.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnamet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnamet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.h?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "5e8fe695b9d8deb85857982808bab1feff6c24f8", "filename": "gcc/ada/nlists.adb", "status": "added", "additions": 1379, "deletions": 0, "changes": 1379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "910e02546c54409b5e429dd51ede50b4c5444e97", "filename": "gcc/ada/nlists.ads", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "2080feac4d21663c0dca2e8147bcb3fd4d1a5df0", "filename": "gcc/ada/nlists.h", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnlists.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnlists.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.h?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "92bb4986f3fd9ffe34a1ff5e47af8909e0f94cf8", "filename": "gcc/ada/nmake.adb", "status": "added", "additions": 2846, "deletions": 0, "changes": 2846, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnmake.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "55f57c40bdda1ce710fe199941a835d2dd49938b", "filename": "gcc/ada/nmake.ads", "status": "added", "additions": 1343, "deletions": 0, "changes": 1343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnmake.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnmake.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnmake.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "bc7f1c4e24aaea6b7cdf20705581d7d4f8894cf6", "filename": "gcc/ada/nmake.adt", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnmake.adt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fnmake.adt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnmake.adt?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "933c8ec94034a310328b046a5bdf9b58bb1f54fd", "filename": "gcc/ada/opt.adb", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "7ba1c43d209551be0b2aa5630726663ef35678cb", "filename": "gcc/ada/opt.ads", "status": "added", "additions": 876, "deletions": 0, "changes": 876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "5d5bf72c231a839bfdc0d5f5a2c01a63ed4cf56e", "filename": "gcc/ada/osint.adb", "status": "added", "additions": 2722, "deletions": 0, "changes": 2722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "842c353fe2b40dd2f4c22d74f04eb15f9d989850", "filename": "gcc/ada/osint.ads", "status": "added", "additions": 671, "deletions": 0, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "af23afc6db9102a19908d074caebbf25af6a4406", "filename": "gcc/ada/output.adb", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Foutput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Foutput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.adb?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}, {"sha": "bc61989fd87238b3466971207fc39354924445d9", "filename": "gcc/ada/output.ads", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Foutput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39/gcc%2Fada%2Foutput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.ads?ref=38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}]}