{"sha": "4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY0MmQ3MTRhMjY1ZjE1MzQ5ZGM3NDVmZjU5YTQ5YjRjMGE1YjZjMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-12T18:41:44Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-12T18:41:44Z"}, "message": "re PR target/49713 (Conflicting types for 'arm_dbx_register_number')\n\nPR target/49713\n        * dwarf2out.h (dwarf_frame_regnum): Remove.\n        * dwarf2out.c (based_loc_descr): Revert last change.  Initialize regno\n        earlier from DWARF_FRAME_REGNUM.  Never use dbx_reg_number.\n        * dwarf2cfi.c (dw_stack_pointer_regnum, dw_frame_pointer_regnum): New.\n        (execute_dwarf2_frame): Initialize them.\n        (DW_STACK_POINTER_REGNUM, DW_FRAME_POINTER_REGNUM): Remove; replace\n        users of the macros with the variables.\n        (expand_builtin_dwarf_sp_column): Revert last change.\n        (expand_builtin_init_dwarf_reg_sizes): Likewise.  Compute the\n        result of DWARF_FRAME_REGNUM into a local variable.\n\nFrom-SVN: r176212", "tree": {"sha": "7684869ecfa82f014ed7d97b3a98896445b71089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7684869ecfa82f014ed7d97b3a98896445b71089"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/comments", "author": null, "committer": null, "parents": [{"sha": "3a5e4ad6e2e1293c707721525f896542571d8d85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a5e4ad6e2e1293c707721525f896542571d8d85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a5e4ad6e2e1293c707721525f896542571d8d85"}], "stats": {"total": 99, "additions": 54, "deletions": 45}, "files": [{"sha": "462ee7d281db2c7c5db8dc3fd218a1f991a0a902", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "patch": "@@ -1,3 +1,17 @@\n+2011-07-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/49713\n+\t* dwarf2out.h (dwarf_frame_regnum): Remove.\n+\t* dwarf2out.c (based_loc_descr): Revert last change.  Initialize regno\n+\tearlier from DWARF_FRAME_REGNUM.  Never use dbx_reg_number.\n+\t* dwarf2cfi.c (dw_stack_pointer_regnum, dw_frame_pointer_regnum): New.\n+\t(execute_dwarf2_frame): Initialize them.\n+\t(DW_STACK_POINTER_REGNUM, DW_FRAME_POINTER_REGNUM): Remove; replace\n+\tusers of the macros with the variables.\n+\t(expand_builtin_dwarf_sp_column): Revert last change.\n+\t(expand_builtin_init_dwarf_reg_sizes): Likewise.  Compute the\n+\tresult of DWARF_FRAME_REGNUM into a local variable.\n+\n 2011-07-12  Richard Henderson  <rth@redhat.com>\n \n \tPR target/49714"}, {"sha": "4e648ae417c6388c680dcb7370e43b6237cf0950", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "patch": "@@ -57,10 +57,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Maximum size (in bytes) of an artificially generated label.  */\n #define MAX_ARTIFICIAL_LABEL_BYTES\t30\n-\n-/* Short-hand for commonly used register numbers.  */\n-#define DW_STACK_POINTER_REGNUM  dwarf_frame_regnum (STACK_POINTER_REGNUM)\n-#define DW_FRAME_POINTER_REGNUM  dwarf_frame_regnum (HARD_FRAME_POINTER_REGNUM)\n \f\n /* A vector of call frame insns for the CIE.  */\n cfi_vec cie_cfi_vec;\n@@ -78,6 +74,10 @@ static bool emit_cfa_remember;\n \n /* True if any CFI directives were emitted at the current insn.  */\n static bool any_cfis_emitted;\n+\n+/* Short-hand for commonly used register numbers.  */\n+static unsigned dw_stack_pointer_regnum;\n+static unsigned dw_frame_pointer_regnum;\n \f\n \n static void dwarf2out_cfi_begin_epilogue (rtx insn);\n@@ -89,7 +89,7 @@ static void dwarf2out_frame_debug_restore_state (void);\n rtx\n expand_builtin_dwarf_sp_column (void)\n {\n-  unsigned int dwarf_regnum = DW_STACK_POINTER_REGNUM;\n+  unsigned int dwarf_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n   return GEN_INT (DWARF2_FRAME_REG_OUT (dwarf_regnum, 1));\n }\n \n@@ -117,7 +117,8 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      unsigned int rnum = DWARF2_FRAME_REG_OUT (dwarf_frame_regnum (i), 1);\n+      unsigned int dnum = DWARF_FRAME_REGNUM (i);\n+      unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);\n \n       if (rnum < DWARF_FRAME_REGISTERS)\n \t{\n@@ -127,7 +128,7 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n \n \t  if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))\n \t    save_mode = choose_hard_reg_mode (i, 1, true);\n-\t  if (dwarf_frame_regnum (i) == DWARF_FRAME_RETURN_COLUMN)\n+\t  if (dnum == DWARF_FRAME_RETURN_COLUMN)\n \t    {\n \t      if (save_mode == VOIDmode)\n \t\tcontinue;\n@@ -812,10 +813,10 @@ dwarf2out_args_size (HOST_WIDE_INT size)\n static void\n dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n {\n-  if (cfa.reg == DW_STACK_POINTER_REGNUM)\n+  if (cfa.reg == dw_stack_pointer_regnum)\n     cfa.offset += offset;\n \n-  if (cfa_store.reg == DW_STACK_POINTER_REGNUM)\n+  if (cfa_store.reg == dw_stack_pointer_regnum)\n     cfa_store.offset += offset;\n \n   if (ACCUMULATE_OUTGOING_ARGS)\n@@ -861,7 +862,7 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n \n   /* If only calls can throw, and we have a frame pointer,\n      save up adjustments until we see the CALL_INSN.  */\n-  if (!flag_asynchronous_unwind_tables && cfa.reg != DW_STACK_POINTER_REGNUM)\n+  if (!flag_asynchronous_unwind_tables && cfa.reg != dw_stack_pointer_regnum)\n     {\n       if (CALL_P (insn) && !after_p)\n \t{\n@@ -955,13 +956,13 @@ static GTY(()) VEC(reg_saved_in_data, gc) *regs_saved_in_regs;\n static GTY(()) reg_saved_in_data *cie_return_save;\n \n /* Short-hand inline for the very common D_F_R (REGNO (x)) operation.  */\n-/* ??? This ought to go into dwarf2out.h alongside dwarf_frame_regnum,\n-   except that dwarf2out.h is used in places where rtl is prohibited.  */\n+/* ??? This ought to go into dwarf2out.h, except that dwarf2out.h is\n+   used in places where rtl is prohibited.  */\n \n static inline unsigned\n dwf_regno (const_rtx reg)\n {\n-  return dwarf_frame_regnum (REGNO (reg));\n+  return DWARF_FRAME_REGNUM (REGNO (reg));\n }\n \n /* Compare X and Y for equivalence.  The inputs may be REGs or PC_RTX.  */\n@@ -1651,8 +1652,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n \t\t{\n \t\t  /* Restoring SP from FP in the epilogue.  */\n-\t\t  gcc_assert (cfa.reg == DW_FRAME_POINTER_REGNUM);\n-\t\t  cfa.reg = DW_STACK_POINTER_REGNUM;\n+\t\t  gcc_assert (cfa.reg == dw_frame_pointer_regnum);\n+\t\t  cfa.reg = dw_stack_pointer_regnum;\n \t\t}\n \t      else if (GET_CODE (src) == LO_SUM)\n \t\t/* Assume we've set the source reg of the LO_SUM from sp.  */\n@@ -1662,9 +1663,9 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n-\t      if (cfa.reg == DW_STACK_POINTER_REGNUM)\n+\t      if (cfa.reg == dw_stack_pointer_regnum)\n \t\tcfa.offset += offset;\n-\t      if (cfa_store.reg == DW_STACK_POINTER_REGNUM)\n+\t      if (cfa_store.reg == dw_stack_pointer_regnum)\n \t\tcfa_store.offset += offset;\n \t    }\n \t  else if (dest == hard_frame_pointer_rtx)\n@@ -1681,7 +1682,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n \t      cfa.offset += offset;\n-\t      cfa.reg = DW_FRAME_POINTER_REGNUM;\n+\t      cfa.reg = dw_frame_pointer_regnum;\n \t    }\n \t  else\n \t    {\n@@ -1709,7 +1710,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n \t\t     of SP for saving registers to the stack.  */\n-\t\t  gcc_assert (cfa.reg == DW_STACK_POINTER_REGNUM);\n+\t\t  gcc_assert (cfa.reg == dw_stack_pointer_regnum);\n \t\t  cfa_store.reg = dwf_regno (dest);\n \t\t  cfa_store.offset = cfa.offset - cfa_temp.offset;\n \t\t}\n@@ -1771,8 +1772,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n               fde->stack_realignment = INTVAL (XEXP (src, 1));\n               cfa_store.offset = 0;\n \n-\t      if (cfa.reg != DW_STACK_POINTER_REGNUM\n-\t\t  && cfa.reg != DW_FRAME_POINTER_REGNUM)\n+\t      if (cfa.reg != dw_stack_pointer_regnum\n+\t\t  && cfa.reg != dw_frame_pointer_regnum)\n \t\tfde->drap_reg = cfa.reg;\n             }\n           return;\n@@ -1800,10 +1801,10 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  offset = -INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1));\n \n \t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n-\t\t      && cfa_store.reg == DW_STACK_POINTER_REGNUM);\n+\t\t      && cfa_store.reg == dw_stack_pointer_regnum);\n \n \t  cfa_store.offset += offset;\n-\t  if (cfa.reg == DW_STACK_POINTER_REGNUM)\n+\t  if (cfa.reg == dw_stack_pointer_regnum)\n \t    cfa.offset = cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_MODIFY)\n@@ -1822,7 +1823,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t  gcc_assert ((REGNO (XEXP (XEXP (dest, 0), 0))\n \t\t       == STACK_POINTER_REGNUM)\n-\t\t      && cfa_store.reg == DW_STACK_POINTER_REGNUM);\n+\t\t      && cfa_store.reg == dw_stack_pointer_regnum);\n \n \t  cfa_store.offset += offset;\n \n@@ -1833,11 +1834,11 @@ dwarf2out_frame_debug_expr (rtx expr)\n               && fde->stack_realign\n               && src == hard_frame_pointer_rtx)\n \t    {\n-\t      gcc_assert (cfa.reg != DW_FRAME_POINTER_REGNUM);\n+\t      gcc_assert (cfa.reg != dw_frame_pointer_regnum);\n \t      cfa_store.offset = 0;\n \t    }\n \n-\t  if (cfa.reg == DW_STACK_POINTER_REGNUM)\n+\t  if (cfa.reg == dw_stack_pointer_regnum)\n \t    cfa.offset = cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_DEC)\n@@ -1927,14 +1928,14 @@ dwarf2out_frame_debug_expr (rtx expr)\n               if (fde\n                   && fde->stack_realign\n                   && cfa.indirect == 0\n-                  && cfa.reg != DW_FRAME_POINTER_REGNUM)\n+                  && cfa.reg != dw_frame_pointer_regnum)\n                 {\n \t\t  dw_cfa_location cfa_exp;\n \n \t\t  gcc_assert (fde->drap_reg == cfa.reg);\n \n \t\t  cfa_exp.indirect = 1;\n-\t\t  cfa_exp.reg = DW_FRAME_POINTER_REGNUM;\n+\t\t  cfa_exp.reg = dw_frame_pointer_regnum;\n \t\t  cfa_exp.base_offset = offset;\n \t\t  cfa_exp.offset = 0;\n \n@@ -2487,14 +2488,17 @@ execute_dwarf2_frame (void)\n     {\n       dw_cfa_location loc;\n \n+      dw_stack_pointer_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n+      dw_frame_pointer_regnum = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n+\n       add_cfi_vec = &cie_cfi_vec;\n \n-      memset(&old_cfa, 0, sizeof (old_cfa));\n+      memset (&old_cfa, 0, sizeof (old_cfa));\n       old_cfa.reg = INVALID_REGNUM;\n \n       /* On entry, the Canonical Frame Address is at SP.  */\n       memset(&loc, 0, sizeof (loc));\n-      loc.reg = DW_STACK_POINTER_REGNUM;\n+      loc.reg = dw_stack_pointer_regnum;\n       loc.offset = INCOMING_FRAME_SP_OFFSET;\n       def_cfa_1 (&loc);\n \n@@ -2534,7 +2538,7 @@ execute_dwarf2_frame (void)\n   gcc_checking_assert (regs_saved_in_regs == NULL);\n \n   memset (&cfa, 0, sizeof(cfa));\n-  cfa.reg = DW_STACK_POINTER_REGNUM;\n+  cfa.reg = dw_stack_pointer_regnum;\n   cfa.offset = INCOMING_FRAME_SP_OFFSET;\n \n   old_cfa = cfa;"}, {"sha": "8fdebc6b8858f9a3199847386700bf67cd8c38a4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "patch": "@@ -10406,10 +10406,11 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n \t  return new_loc_descr (DW_OP_fbreg, offset, 0);\n \t}\n     }\n-  else if (!optimize\n-\t   && fde\n-\t   && (fde->drap_reg == dwarf_frame_regnum (REGNO (reg))\n-\t       || fde->vdrap_reg == dwarf_frame_regnum (REGNO (reg))))\n+\n+  regno = DWARF_FRAME_REGNUM (REGNO (reg));\n+\n+  if (!optimize && fde\n+      && (fde->drap_reg == regno || fde->vdrap_reg == regno))\n     {\n       /* Use cfa+offset to represent the location of arguments passed\n \t on the stack when drap is used to align stack.\n@@ -10420,7 +10421,6 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n       return new_loc_descr (DW_OP_fbreg, offset, 0);\n     }\n \n-  regno = dbx_reg_number (reg);\n   if (regno <= 31)\n     result = new_loc_descr ((enum dwarf_location_atom) (DW_OP_breg0 + regno),\n \t\t\t    offset, 0);"}, {"sha": "301321155a6208f863fca63f8158f13f4e62376e", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f42d714a265f15349dc745ff59a49b4c0a5b6c3/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=4f42d714a265f15349dc745ff59a49b4c0a5b6c3", "patch": "@@ -262,15 +262,6 @@ extern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));\n extern void dwarf2out_vms_debug_main_pointer (void);\n #endif\n \n-/* Unfortunately, DWARF_FRAME_REGNUM is not universally defined in such a\n-   way as to force an unsigned return type.  Do that via inline wrapper.  */\n-\n-static inline unsigned\n-dwarf_frame_regnum (unsigned regnum)\n-{\n-  return DWARF_FRAME_REGNUM (regnum);\n-}\n-  \n struct array_descr_info\n {\n   int ndimensions;"}]}