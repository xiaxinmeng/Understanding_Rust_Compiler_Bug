{"sha": "7d63a2fae019a83772ebae65689f4113a0eb4bec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q2M2EyZmFlMDE5YTgzNzcyZWJhZTY1Njg5ZjQxMTNhMGViNGJlYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-05-14T16:01:20Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-05-14T16:01:20Z"}, "message": "gcov-io.h (gcov_write_bytes, [...]): Remove here.\n\n\t* gcov-io.h (gcov_write_bytes, gcov_read_bytes): Remove here.\n\t(GCOV_TAG_*) Force type to gcov_unsigned_t.\n\t(GCOV_CHECK, GCOV_CHECK_READING, GCOV_CHECK_WRITING): New.\n\t(struct gcov_var): Remove modified. Add start, length, offset,\n\toverread. Have buffer array for libgcov.\n\t(gcov_sync, gcov_seek): Definitions moved to gcov-io.c.\n\t(gcov_position, gcov_rewrite, gcov_is_eof): Adjust.\n\t* gcov-io.c (gcov_open): Set mode, do not read anything.\n\t(gcov_close): Write final block.\n\t (gcov_write_block, gcov_allocate): New.\n\t(gcov_write_bytes): Make static. Write or allocate buffer.\n\t(gcov_write_unsigned, gcov_write_counter): Buffer can never be\n\tnull.\n\t(gcov_write_string): Adjust.\n\t(gcov_write_tag)\n\t(gcov_write_length): Adjust. Flush the block.\n\t(gcov_write_tag_length): Buffer can never be null.\n\t(gcov_read_bytes): Make static. Read in block.\n\t(gcov_sync): Moved here. Adjust.\n\t(gcov_seek): Moved here. Adjust.\n\t* coverage.c (read_counts_file): Adjust.\n\t* gcov-dump.c (print_prefix): Add position parameter.\n\t(flag_dump_positions): New flag.\n\t(options, main, print_usage): Add it.\n\t(dump_file, tag_blocks, tag_arcs, tag_lines, tag_counters,\n\ttag_summary): Adjust.\n\t* gcov.c (read_graph_file, read_count_file): Adjust.\n\t* libgcov.c (gcov_exit): Adjust.\n\nFrom-SVN: r66805", "tree": {"sha": "1253c5f7880fe8708b5e0666b848785f27dcd9cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1253c5f7880fe8708b5e0666b848785f27dcd9cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d63a2fae019a83772ebae65689f4113a0eb4bec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d63a2fae019a83772ebae65689f4113a0eb4bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d63a2fae019a83772ebae65689f4113a0eb4bec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d63a2fae019a83772ebae65689f4113a0eb4bec/comments", "author": null, "committer": null, "parents": [{"sha": "990f4800f2228c94b23362016ddcb11401a8e5d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/990f4800f2228c94b23362016ddcb11401a8e5d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/990f4800f2228c94b23362016ddcb11401a8e5d6"}], "stats": {"total": 691, "additions": 413, "deletions": 278}, "files": [{"sha": "f8af6e71d2cb4cbb2167131f2b87182538e5533f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d63a2fae019a83772ebae65689f4113a0eb4bec", "patch": "@@ -1,5 +1,34 @@\n 2003-05-14  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* gcov-io.h (gcov_write_bytes, gcov_read_bytes): Remove here.\n+\t(GCOV_TAG_*) Force type to gcov_unsigned_t.\n+\t(GCOV_CHECK, GCOV_CHECK_READING, GCOV_CHECK_WRITING): New.\n+\t(struct gcov_var): Remove modified. Add start, length, offset,\n+\toverread. Have buffer array for libgcov.\n+\t(gcov_sync, gcov_seek): Definitions moved to gcov-io.c.\n+\t(gcov_position, gcov_rewrite, gcov_is_eof): Adjust.\n+\t* gcov-io.c (gcov_open): Set mode, do not read anything.\n+\t(gcov_close): Write final block.\n+\t (gcov_write_block, gcov_allocate): New.\n+\t(gcov_write_bytes): Make static. Write or allocate buffer.\n+\t(gcov_write_unsigned, gcov_write_counter): Buffer can never be\n+\tnull.\n+\t(gcov_write_string): Adjust.\n+\t(gcov_write_tag)\n+\t(gcov_write_length): Adjust. Flush the block.\n+\t(gcov_write_tag_length): Buffer can never be null.\n+\t(gcov_read_bytes): Make static. Read in block.\n+\t(gcov_sync): Moved here. Adjust.\n+\t(gcov_seek): Moved here. Adjust.\n+\t* coverage.c (read_counts_file): Adjust.\n+\t* gcov-dump.c (print_prefix): Add position parameter.\n+\t(flag_dump_positions): New flag.\n+\t(options, main, print_usage): Add it.\n+\t(dump_file, tag_blocks, tag_arcs, tag_lines, tag_counters,\n+\ttag_summary): Adjust.\n+\t* gcov.c (read_graph_file, read_count_file): Adjust.\n+\t* libgcov.c (gcov_exit): Adjust.\n+\n \t* Makefile.in (LIBGCC_DEPS): Use $(srcdir) on gcov files\n \t(libgcov.a): Depend on libgcc.a.\n \t(gcov.o, gcov-dump.o): Add gcov-io.c."}, {"sha": "1b537c621ebabe72f02721350aacaaf0deb6f3e5", "filename": "gcc/coverage.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=7d63a2fae019a83772ebae65689f4113a0eb4bec", "patch": "@@ -158,7 +158,9 @@ read_counts_file ()\n   unsigned ix;\n   counts_entry_t *summaried = NULL;\n   unsigned seen_summary = 0;\n-  \n+  gcov_unsigned_t tag;\n+  int error = 0;\n+\n   if (!gcov_open (da_file_name, 1))\n     return;\n   \n@@ -187,13 +189,11 @@ read_counts_file ()\n   counts_hash = htab_create (10,\n \t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n \t\t\t     htab_counts_entry_del);\n-  while (!gcov_is_eof ())\n+  while ((tag = gcov_read_unsigned ()))\n     {\n-      gcov_unsigned_t tag, length;\n+      gcov_unsigned_t length;\n       gcov_position_t offset;\n-      int error;\n       \n-      tag = gcov_read_unsigned ();\n       length = gcov_read_unsigned ();\n       offset = gcov_position ();\n       if (tag == GCOV_TAG_FUNCTION)\n@@ -284,14 +284,16 @@ read_counts_file ()\n \t}\n       gcov_sync (offset, length);\n       if ((error = gcov_is_error ()))\n-\t{\n-\t  warning (error < 0 ? \"`%s' has overflowed\" : \"`%s' is corrupted\",\n-\t\t   da_file_name);\n-\t  htab_delete (counts_hash);\n-\t  break;\n-\t}\n+\tbreak;\n     }\n \n+  if (!gcov_is_eof ())\n+    {\n+      warning (error < 0 ? \"`%s' has overflowed\" : \"`%s' is corrupted\",\n+\t       da_file_name);\n+      htab_delete (counts_hash);\n+    }\n+  \n   gcov_close ();\n }\n "}, {"sha": "c7c31ad5454c2d4795e6ab5857ba91f204b255bc", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=7d63a2fae019a83772ebae65689f4113a0eb4bec", "patch": "@@ -28,7 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"gcov-io.c\"\n \n static void dump_file PARAMS ((const char *));\n-static void print_prefix PARAMS ((const char *, unsigned));\n+static void print_prefix PARAMS ((const char *, unsigned, gcov_position_t));\n static void print_usage PARAMS ((void));\n static void print_version PARAMS ((void));\n static void tag_function PARAMS ((const char *, unsigned, unsigned));\n@@ -47,12 +47,14 @@ typedef struct tag_format\n } tag_format_t;\n \n static int flag_dump_contents = 0;\n+static int flag_dump_positions = 0;\n \n static const struct option options[] =\n {\n   { \"help\",                 no_argument,       NULL, 'h' },\n   { \"version\",              no_argument,       NULL, 'v' },\n   { \"long\",                 no_argument,       NULL, 'l' },\n+  { \"positions\",\t    no_argument,       NULL, 'o' },\n };\n \n static const tag_format_t tag_table[] =\n@@ -75,7 +77,7 @@ int main (argc, argv)\n {\n   int opt;\n \n-  while ((opt = getopt_long (argc, argv, \"hlv\", options, NULL)) != -1)\n+  while ((opt = getopt_long (argc, argv, \"hlpv\", options, NULL)) != -1)\n     {\n       switch (opt)\n \t{\n@@ -88,6 +90,9 @@ int main (argc, argv)\n \tcase 'l':\n \t  flag_dump_contents = 1;\n \t  break;\n+\tcase 'p':\n+\t  flag_dump_positions = 1;\n+\t  break;\n \tdefault:\n \t  fprintf (stderr, \"unknown flag `%c'\\n\", opt);\n \t}\n@@ -106,6 +111,7 @@ print_usage ()\n   printf (\"  -h, --help           Print this help\\n\");\n   printf (\"  -v, --version        Print version number\\n\");\n   printf (\"  -l, --long           Dump record contents too\\n\");\n+  printf (\"  -p, --positions      Dump record positions\\n\");\n }\n \n static void\n@@ -124,13 +130,17 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n }\n \n static void\n-print_prefix (filename, depth)\n+print_prefix (filename, depth, position)\n      const char *filename;\n      unsigned depth;\n+     gcov_position_t position;\n {\n   static const char prefix[] = \"    \";\n   \n-  printf (\"%s:%.*s\", filename, (int) depth, prefix);\n+  printf (\"%s:\", filename);\n+  if (flag_dump_positions)\n+    printf (\"%lu:\", (unsigned long) position);\n+  printf (\"%.*s\", (int) depth, prefix);\n }\n \n static void\n@@ -178,30 +188,29 @@ dump_file (filename)\n       printf (\"%s:warning:current version is `%.4s'\\n\", filename, e);\n   }\n \n-  while (!gcov_is_eof ())\n+  while (1)\n     {\n-      unsigned tag = gcov_read_unsigned ();\n-      unsigned length = gcov_read_unsigned ();\n-      unsigned long base = gcov_position ();\n+      gcov_position_t base, position = gcov_position ();\n+      unsigned tag, length;\n       tag_format_t const *format;\n       unsigned tag_depth;\n       int error;\n-      \n+      unsigned mask;\n+\n+      tag = gcov_read_unsigned ();\n       if (!tag)\n-\ttag_depth = depth;\n-      else\n+\tbreak;\n+      length = gcov_read_unsigned ();\n+      base = gcov_position ();\n+      mask = GCOV_TAG_MASK (tag) >> 1;\n+      for (tag_depth = 4; mask; mask >>= 8)\n \t{\n-\t  unsigned mask = GCOV_TAG_MASK (tag) >> 1;\n-\t  \n-\t  for (tag_depth = 4; mask; mask >>= 8)\n+\t  if ((mask & 0xff) != 0xff)\n \t    {\n-\t      if ((mask & 0xff) != 0xff)\n-\t\t{\n-\t\t  printf (\"%s:tag `%08x' is invalid\\n\", filename, tag);\n-\t\t  break;\n-\t\t}\n-\t      tag_depth--;\n+\t      printf (\"%s:tag `%08x' is invalid\\n\", filename, tag);\n+\t      break;\n \t    }\n+\t  tag_depth--;\n \t}\n       for (format = tag_table; format->name; format++)\n \tif (format->tag == tag)\n@@ -220,7 +229,7 @@ dump_file (filename)\n \t  tags[depth - 1] = tag;\n \t}\n       \n-      print_prefix (filename, tag_depth);\n+      print_prefix (filename, tag_depth, position);\n       printf (\"%08x:%4u:%s\", tag, length, format->name);\n       if (format->proc)\n \t(*format->proc) (filename, tag, length);\n@@ -246,6 +255,8 @@ dump_file (filename)\n \t  break;\n \t}\n     }\n+  if (!gcov_is_eof ())\n+    printf (\"%s:early end of file\\n\", filename);\n   gcov_close ();\n }\n \n@@ -289,7 +300,11 @@ tag_blocks (filename, tag, length)\n       for (ix = 0; ix != n_blocks; ix++)\n \t{\n \t  if (!(ix & 7))\n-\t    printf (\"\\n%s:\\t\\t%u\", filename, ix);\n+\t    {\n+\t      printf (\"\\n\");\n+\t      print_prefix (filename, 0, gcov_position ());\n+\t      printf (\"\\t\\t%u\", ix);\n+\t    }\n \t  printf (\" %04x\", gcov_read_unsigned ());\n \t}\n     }\n@@ -311,11 +326,16 @@ tag_arcs (filename, tag, length)\n \n       for (ix = 0; ix != n_arcs; ix++)\n \t{\n-\t  unsigned dst = gcov_read_unsigned ();\n-\t  unsigned flags = gcov_read_unsigned ();\n+\t  unsigned dst, flags;\n \t  \n \t  if (!(ix & 3))\n-\t    printf (\"\\n%s:\\tblock %u:\", filename, blockno);\n+\t    {\n+\t      printf (\"\\n\");\n+\t      print_prefix (filename, 0, gcov_position ());\n+\t      printf (\"\\tblock %u:\", blockno);\n+\t    }\n+\t  dst = gcov_read_unsigned ();\n+\t  flags = gcov_read_unsigned ();\n \t  printf (\" %u:%04x\", dst, flags);\n \t}\n     }\n@@ -334,6 +354,7 @@ tag_lines (filename, tag, length)\n \n       while (1)\n \t{\n+\t  gcov_position_t position = gcov_position ();\n \t  const char *source = NULL;\n \t  unsigned lineno = gcov_read_unsigned ();\n \t  \n@@ -347,7 +368,9 @@ tag_lines (filename, tag, length)\n \t  \n \t  if (!sep)\n \t    {\n-\t      printf (\"\\n%s:\\tblock %u:\", filename, blockno);\n+\t      printf (\"\\n\");\n+\t      print_prefix (filename, 0, position);\n+\t      printf (\"\\tblock %u:\", blockno);\n \t      sep = \"\";\n \t    }\n \t  if (lineno)\n@@ -381,10 +404,16 @@ tag_counters (filename, tag, length)\n \n       for (ix = 0; ix != n_counts; ix++)\n \t{\n-\t  gcov_type count = gcov_read_counter ();\n+\t  gcov_type count;\n \t  \n \t  if (!(ix & 7))\n-\t    printf (\"\\n%s:\\t\\t%u\", filename, ix);\n+\t    {\n+\t      printf (\"\\n\");\n+\t      print_prefix (filename, 0, gcov_position ());\n+\t      printf (\"\\t\\t%u\", ix);\n+\t    }\n+\t  \n+\t  count = gcov_read_counter ();\n \t  printf (\" \");\n \t  printf (HOST_WIDEST_INT_PRINT_DEC, count);\n \t}\n@@ -405,7 +434,9 @@ tag_summary (filename, tag, length)\n   \n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     {\n-      printf (\"\\n%sL\\t\\tcounts=%u, runs=%u\", filename,\n+      printf (\"\\n\");\n+      print_prefix (filename, 0, 0);\n+      printf (\"\\t\\tcounts=%u, runs=%u\",\n \t      summary.ctrs[ix].num, summary.ctrs[ix].runs);\n       \n       printf (\", sum_all=\" HOST_WIDEST_INT_PRINT_DEC,"}, {"sha": "3aad30e445d9dc9303a242ec74a4b4ec2989a105", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 162, "deletions": 112, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=7d63a2fae019a83772ebae65689f4113a0eb4bec", "patch": "@@ -24,6 +24,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Routines declared in gcov-io.h.  This file should be #included by\n    another source file, after having #included gcov-io.h.  */\n \n+#if !IN_GCOV\n+static void gcov_write_block (unsigned);\n+static unsigned char *gcov_write_bytes (unsigned);\n+#endif\n+static const unsigned char *gcov_read_bytes (unsigned);\n+#if !IN_LIBGCOV\n+static void gcov_allocate (unsigned);\n+#endif\n+\n /* Open a gcov file. NAME is the name of the file to open and MODE\n    indicates whether a new file should be created, or an existing file\n    opened for modification. If MODE is >= 0 an existing file will be\n@@ -36,7 +45,6 @@ GCOV_LINKAGE int\n gcov_open (const char *name, int mode)\n {\n   int result = 1;\n-  size_t alloc = 1024;\n #if GCOV_LOCKED\n   struct flock s_flock;\n \n@@ -49,63 +57,32 @@ gcov_open (const char *name, int mode)\n   \n   if (gcov_var.file)\n     abort ();\n-  gcov_var.position = gcov_var.length = 0;\n-  gcov_var.error = gcov_var.modified = 0;\n+  gcov_var.start = 0;\n+  gcov_var.offset = gcov_var.length = 0;\n+  gcov_var.overread = -4u;\n+  gcov_var.error = 0;\n   if (mode >= 0)\n     gcov_var.file = fopen (name, \"r+b\");\n-  if (!gcov_var.file && mode <= 0)\n+  if (gcov_var.file)\n+    gcov_var.mode = 1;\n+  else if (mode <= 0)\n     {\n       result = -1;\n       gcov_var.file = fopen (name, \"w+b\");\n+      if (gcov_var.file)\n+\tgcov_var.mode = -1;\n     }\n   if (!gcov_var.file)\n     return 0;\n \n+  setbuf (gcov_var.file, (char *)0);\n+  \n #if GCOV_LOCKED\n   while (fcntl (fileno (gcov_var.file), F_SETLKW, &s_flock)\n \t && errno == EINTR)\n     continue;\n #endif\n \n-  if (result >= 0)\n-    {\n-      if (fseek (gcov_var.file, 0, SEEK_END))\n-\t{\n-\t  fclose (gcov_var.file);\n-\t  gcov_var.file = 0;\n-\t  return 0;\n-\t}\n-      gcov_var.length = ftell (gcov_var.file);\n-      fseek (gcov_var.file, 0, SEEK_SET);\n-      alloc += gcov_var.length;\n-    }\n-  if (alloc > gcov_var.alloc)\n-    {\n-      if (gcov_var.buffer)\n-\tfree (gcov_var.buffer);\n-      gcov_var.alloc = alloc;\n-#if IN_LIBGCOV\n-      gcov_var.buffer = malloc (gcov_var.alloc);\n-      if (!gcov_var.buffer)\n-\t{\n-\t  fclose (gcov_var.file);\n-\t  gcov_var.file = 0;\n-\t  gcov_var.length = 0;\n-\t  gcov_var.alloc = 0;\n-\t  return 0;\n-\t}\n-#else\n-      gcov_var.buffer = xmalloc (gcov_var.alloc);\n-#endif\n-    }\n-  if (result >= 0\n-      && fread (gcov_var.buffer, gcov_var.length, 1, gcov_var.file) != 1)\n-    {\n-      fclose (gcov_var.file);\n-      gcov_var.file = 0;\n-      gcov_var.length = 0;\n-      return 0;\n-    }\n   return result;\n }\n \n@@ -115,15 +92,12 @@ gcov_open (const char *name, int mode)\n GCOV_LINKAGE int\n gcov_close ()\n {\n-  int result = 0;\n-  \n   if (gcov_var.file)\n     {\n-      if (gcov_var.modified\n-\t  && (fseek (gcov_var.file, 0, SEEK_SET)\n-\t      || fwrite (gcov_var.buffer, gcov_var.length,\n-\t\t\t 1, gcov_var.file) != 1))\n-\tresult = 1;\n+#if !IN_GCOV\n+      if (gcov_var.offset && gcov_var.mode < 0)\n+\tgcov_write_block (gcov_var.offset);\n+#endif\n       fclose (gcov_var.file);\n       gcov_var.file = 0;\n       gcov_var.length = 0;\n@@ -133,47 +107,64 @@ gcov_close ()\n   gcov_var.alloc = 0;\n   gcov_var.buffer = 0;\n #endif\n-  return result ? 1 : gcov_var.error;\n+  gcov_var.mode = 0;\n+  return gcov_var.error;\n+}\n+\n+#if !IN_LIBGCOV\n+static void\n+gcov_allocate (unsigned length)\n+{\n+  size_t new_size = gcov_var.alloc;\n+  \n+  if (!new_size)\n+    new_size = GCOV_BLOCK_SIZE;\n+  new_size += length;\n+  new_size *= 2;\n+  \n+  gcov_var.alloc = new_size;\n+  gcov_var.buffer = xrealloc (gcov_var.buffer, new_size);\n }\n+#endif\n \n #if !IN_GCOV\n+/* Write out the current block, if needs be.  */\n+\n+static void\n+gcov_write_block (unsigned size)\n+{\n+  if (fwrite (gcov_var.buffer, size, 1, gcov_var.file) != 1)\n+    gcov_var.error = 1;\n+  gcov_var.start += size;\n+  gcov_var.offset -= size;\n+}\n+\n /* Allocate space to write BYTES bytes to the gcov file. Return a\n    pointer to those bytes, or NULL on failure.  */\n \n-GCOV_LINKAGE unsigned char *\n+static unsigned char *\n gcov_write_bytes (unsigned bytes)\n {\n   char unsigned *result;\n \n-  if (gcov_var.position + bytes > gcov_var.alloc)\n-    {\n-      size_t new_size = (gcov_var.alloc + bytes) * 3 / 2;\n-\n-      if (!gcov_var.buffer)\n-\treturn 0;\n+  GCOV_CHECK_WRITING ();\n #if IN_LIBGCOV\n-      result = realloc (gcov_var.buffer, new_size);\n-      if (!result)\n+  if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n+    {\n+      gcov_write_block (GCOV_BLOCK_SIZE);\n+      if (gcov_var.offset)\n \t{\n-\t  free (gcov_var.buffer);\n-\t  gcov_var.buffer = 0;\n-\t  gcov_var.alloc = 0;\n-\t  gcov_var.position = gcov_var.length = 0;\n-\t  gcov_var.error = 1;\n-\t  return 0;\n+\t  GCOV_CHECK (gcov_var.offset == 4);\n+\t  memcpy (gcov_var.buffer, gcov_var.buffer + GCOV_BLOCK_SIZE, 4);\n \t}\n+    }\n #else\n-      result = xrealloc (gcov_var.buffer, new_size);\n+  if (gcov_var.offset + bytes > gcov_var.alloc)\n+    gcov_allocate (gcov_var.offset + bytes);\n #endif\n-      gcov_var.alloc = new_size;\n-      gcov_var.buffer = result;\n-    }\n+  result = &gcov_var.buffer[gcov_var.offset];\n+  gcov_var.offset += bytes;\n   \n-  result = &gcov_var.buffer[gcov_var.position];\n-  gcov_var.position += bytes;\n-  gcov_var.modified = 1;\n-  if (gcov_var.position > gcov_var.length)\n-    gcov_var.length = gcov_var.position;\n   return result;\n }\n \n@@ -186,8 +177,6 @@ gcov_write_unsigned (gcov_unsigned_t value)\n   unsigned char *buffer = gcov_write_bytes (4);\n   unsigned ix;\n \n-  if (!buffer)\n-    return;\n   for (ix = 4; ix--; )\n     {\n       buffer[ix] = value;\n@@ -209,8 +198,6 @@ gcov_write_counter (gcov_type value)\n   unsigned char *buffer = gcov_write_bytes (8);\n   unsigned ix;\n \n-  if (!buffer)\n-    return;\n   for (ix = 8; ix--; )\n     {\n       buffer[ix] = value;\n@@ -233,6 +220,8 @@ gcov_write_string (const char *string)\n   unsigned pad = 0;\n   unsigned rem = 0;\n   unsigned char *buffer;\n+  unsigned ix;\n+  unsigned value;\n \n   if (string)\n     {\n@@ -241,19 +230,15 @@ gcov_write_string (const char *string)\n     }\n   \n   buffer = gcov_write_bytes (4 + length + rem);\n-  if (buffer)\n+\n+  value = length;\n+  for (ix = 4; ix--; )\n     {\n-      unsigned ix;\n-      unsigned value = length;\n-      \n-      for (ix = 4; ix--; )\n-\t{\n-\t  buffer[ix] = value;\n-\t  value >>= 8;\n-\t}\n-      memcpy (buffer + 4, string, length);\n-      memcpy (buffer + 4 + length, &pad, rem);\n+      buffer[ix] = value;\n+      value >>= 8;\n     }\n+  memcpy (buffer + 4, string, length);\n+  memcpy (buffer + 4 + length, &pad, rem);\n }\n #endif\n \n@@ -264,12 +249,10 @@ gcov_write_string (const char *string)\n GCOV_LINKAGE gcov_position_t\n gcov_write_tag (gcov_unsigned_t tag)\n {\n-  gcov_position_t result = gcov_var.position;\n+  gcov_position_t result = gcov_var.start + gcov_var.offset;\n   unsigned char *buffer = gcov_write_bytes (8);\n   unsigned ix;\n \n-  if (!buffer)\n-    return 0;\n   for (ix = 4; ix--; )\n     {\n       buffer[ix] = tag;\n@@ -287,18 +270,24 @@ gcov_write_tag (gcov_unsigned_t tag)\n GCOV_LINKAGE void\n gcov_write_length (gcov_position_t position)\n {\n-  if (position)\n+  unsigned offset;\n+  gcov_unsigned_t length;\n+  unsigned char *buffer;\n+  unsigned ix;\n+\n+  GCOV_CHECK_WRITING ();\n+  GCOV_CHECK (position + 8 <= gcov_var.start + gcov_var.offset);\n+  GCOV_CHECK (position >= gcov_var.start);\n+  offset = position - gcov_var.start;\n+  length = gcov_var.offset - offset - 8;\n+  buffer = &gcov_var.buffer[offset + 4];\n+  for (ix = 4; ix--; )\n     {\n-      gcov_unsigned_t length = gcov_var.position - position - 8;\n-      unsigned char *buffer = &gcov_var.buffer[position + 4];\n-      unsigned ix;\n-      \n-      for (ix = 4; ix--; )\n-\t{\n-\t  buffer[ix] = length;\n-\t  length >>= 8;\n-\t}\n+      buffer[ix] = length;\n+      length >>= 8;\n     }\n+  if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n+    gcov_write_block (gcov_var.offset);\n }\n \n #else /* IN_LIBGCOV */\n@@ -311,8 +300,6 @@ gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n   unsigned char *buffer = gcov_write_bytes (8);\n   unsigned ix;\n \n-  if (!buffer)\n-    return;\n   for (ix = 4; ix--; )\n     {\n       buffer[ix] = tag;\n@@ -353,19 +340,47 @@ gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n /* Return a pointer to read BYTES bytes from the gcov file. Returns\n    NULL on failure (read past EOF). */\n \n-GCOV_LINKAGE const unsigned char *\n+static const unsigned char *\n gcov_read_bytes (unsigned bytes)\n {\n   const unsigned char *result;\n+  unsigned excess = gcov_var.length - gcov_var.offset;\n   \n-  if (gcov_var.position + bytes > gcov_var.length)\n+  GCOV_CHECK_READING ();\n+  if (excess < bytes)\n     {\n-      gcov_var.error = 1;\n-      return 0;\n+      gcov_var.start += gcov_var.offset;\n+#if IN_LIBGCOV\n+      if (excess)\n+\t{\n+\t  GCOV_CHECK (excess == 4);\n+\t  memcpy (gcov_var.buffer, gcov_var.buffer + gcov_var.offset, 4);\n+\t}\n+#else\n+      memmove (gcov_var.buffer, gcov_var.buffer + gcov_var.offset, excess);\n+#endif\n+      gcov_var.offset = 0;\n+      gcov_var.length = excess;\n+#if IN_LIBGCOV\n+      GCOV_CHECK (!gcov_var.length || gcov_var.length == 4);\n+      excess = GCOV_BLOCK_SIZE;\n+#else\n+      if (gcov_var.length + bytes > gcov_var.alloc)\n+\tgcov_allocate (gcov_var.length + bytes);\n+      excess = gcov_var.alloc - gcov_var.length;\n+#endif\n+      excess = fread (gcov_var.buffer + gcov_var.offset,\n+\t\t      1, excess, gcov_var.file);\n+      gcov_var.length += excess;\n+      if (gcov_var.length < bytes)\n+\t{\n+\t  gcov_var.overread += bytes - gcov_var.length;\n+\t  gcov_var.length = 0;\n+\t  return 0;\n+\t}\n     }\n-  \n-  result = &gcov_var.buffer[gcov_var.position];\n-  gcov_var.position += bytes;\n+  result = &gcov_var.buffer[gcov_var.offset];\n+  gcov_var.offset += bytes;\n   return result;\n }\n \n@@ -452,6 +467,41 @@ gcov_read_summary (struct gcov_summary *summary)\n     }\n }\n \n+#if !IN_LIBGCOV\n+/* Reset to a known position.  BASE should have been obtained from\n+   gcov_position, LENGTH should be a record length.  */\n+\n+GCOV_LINKAGE void\n+gcov_sync (gcov_position_t base, gcov_unsigned_t length)\n+{\n+  GCOV_CHECK_READING ();\n+  base += length;\n+  if (base - gcov_var.start <= gcov_var.length)\n+    gcov_var.offset = base - gcov_var.start;\n+  else\n+    {\n+      gcov_var.offset = gcov_var.length = 0;\n+      fseek (gcov_var.file, base, SEEK_SET);\n+      gcov_var.start = ftell (gcov_var.file);\n+    }\n+}\n+#endif\n+\n+#if IN_LIBGCOV\n+/* Move to the a set position in a gcov file.  BASE is zero to move to\n+   the end, and non-zero to move to that position. */\n+\n+GCOV_LINKAGE void\n+gcov_seek (gcov_position_t base)\n+{\n+  GCOV_CHECK_WRITING ();\n+  if (gcov_var.offset)\n+    gcov_write_block (gcov_var.offset);\n+  fseek (gcov_var.file, base, base ? SEEK_SET : SEEK_END);\n+  gcov_var.start = ftell (gcov_var.file);\n+}\n+#endif\n+\n #if IN_GCOV > 0\n /* Return the modification time of the current gcov file.  */\n "}, {"sha": "e6cf94e6ac26b67adce54a59f60a3f6c00f229ad", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=7d63a2fae019a83772ebae65689f4113a0eb4bec", "patch": "@@ -202,35 +202,31 @@ typedef HOST_WIDEST_INT gcov_type;\n \n #endif /* !IN_LIBGCOV */\n \n-/* In gcov we want function linkage to be static, so we do not\n-   polute the global namespace. In libgcov we need these functions\n-   to be extern, so prefix them with __gcov so that we do not conflict.\n-   In the compiler we want it extern, so that they can be accessed from\n+/* In gcov we want function linkage to be static. In libgcov we need\n+   these functions to be extern, so prefix them with __gcov.  In the\n+   compiler we want it extern, so that they can be accessed from\n    elsewhere.  */\n #if IN_LIBGCOV\n #define gcov_var __gcov_var\n #define gcov_open __gcov_open\n #define gcov_close __gcov_close\n-#define gcov_write_bytes __gcov_write_bytes\n+#define gcov_write_tag_length __gcov_write_tag_length\n+#define gcov_position __gcov_position\n+#define gcov_seek __gcov_seek\n+#define gcov_rewrite __gcov_rewrite\n+#define gcov_is_error __gcov_is_error\n+#define gcov_is_eof __gcov_is_eof\n #define gcov_write_unsigned __gcov_write_unsigned\n #define gcov_write_counter __gcov_write_counter\n-#pragma GCC poison gcov_write_string\n-#pragma GCC poison gcov_write_tag\n-#pragma GCC poison gcov_write_length\n-#define gcov_write_tag_length __gcov_write_tag_length\n #define gcov_write_summary __gcov_write_summary\n-#define gcov_read_bytes __gcov_read_bytes\n #define gcov_read_unsigned __gcov_read_unsigned\n #define gcov_read_counter __gcov_read_counter\n-#pragma GCC poison gcov_read_string\n #define gcov_read_summary __gcov_read_summary\n-#define gcov_position __gcov_position\n-#define gcov_sync __gcov_sync\n-#define gcov_seek __gcov_seek\n-#define gcov_rewrite __gcov_rewrite\n-#define gcov_is_eof __gcov_is_eof\n-#define gcov_is_error __gcov_is_error\n-#pragma GCC poison gcov_time\n+\n+/* Poison these, so they don't accidentally slip in. */\n+#pragma GCC poison gcov_write_string gcov_write_tag gcov_write_length\n+#pragma GCC poison gcov_read_string gcov_sync gcov_time\n+\n #endif\n \n #ifndef GCOV_LINKAGE\n@@ -255,18 +251,19 @@ typedef HOST_WIDEST_INT gcov_type;\n    file.  Values [41..9f] for those in the bbg file and [a1..ff] for\n    the data file.  */\n \n-#define GCOV_TAG_FUNCTION\t ((unsigned)0x01000000)\n+#define GCOV_TAG_FUNCTION\t ((gcov_unsigned_t)0x01000000)\n #define GCOV_TAG_FUNCTION_LENGTH (2 * 4)\n-#define GCOV_TAG_BLOCKS\t\t ((unsigned)0x01410000)\n+#define GCOV_TAG_BLOCKS\t\t ((gcov_unsigned_t)0x01410000)\n #define GCOV_TAG_BLOCKS_LENGTH(NUM) ((NUM) * 4)\n-#define GCOV_TAG_ARCS\t\t ((unsigned)0x01430000)\n+#define GCOV_TAG_ARCS\t\t ((gcov_unsigned_t)0x01430000)\n #define GCOV_TAG_ARCS_LENGTH(NUM)  (1 * 4 + (NUM) * (2 * 4))\n-#define GCOV_TAG_LINES\t\t ((unsigned)0x01450000)\n-#define GCOV_TAG_COUNTER_BASE \t ((unsigned)0x01a10000) /* First counter */\n+#define GCOV_TAG_LINES\t\t ((gcov_unsigned_t)0x01450000)\n+#define GCOV_TAG_COUNTER_BASE \t ((gcov_unsigned_t)0x01a10000)\n #define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 8)\n-#define GCOV_TAG_OBJECT_SUMMARY  ((unsigned)0xa1000000)\n-#define GCOV_TAG_PROGRAM_SUMMARY ((unsigned)0xa3000000)\n-#define GCOV_TAG_SUMMARY_LENGTH  (1 * 4 + GCOV_COUNTERS_SUMMABLE * (2 * 4 + 3 * 8))\n+#define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000)\n+#define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n+#define GCOV_TAG_SUMMARY_LENGTH  \\\n+\t(1 * 4 + GCOV_COUNTERS_SUMMABLE * (2 * 4 + 3 * 8))\n \n /* Counters that are collected.  */\n #define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n@@ -282,10 +279,10 @@ typedef HOST_WIDEST_INT gcov_type;\n \n /* Convert a counter index to a tag. */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n-\t(GCOV_TAG_COUNTER_BASE + ((COUNT) << 17))\n+\t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))\n /* Convert a tag to a counter.  */\n #define GCOV_COUNTER_FOR_TAG(TAG)\t\t\t\t\t\\\n-\t(((TAG) - GCOV_TAG_COUNTER_BASE) >> 17)\n+\t((unsigned)(((TAG) - GCOV_TAG_COUNTER_BASE) >> 17))\n /* Check whether a tag is a counter tag.  */\n #define GCOV_TAG_IS_COUNTER(TAG)\t\t\t\t\\\n \t(!((TAG) & 0xFFFF) && GCOV_COUNTER_FOR_TAG (TAG) < GCOV_COUNTERS)\n@@ -387,114 +384,131 @@ extern void __gcov_merge_add (gcov_type *, unsigned);\n \n #if IN_LIBGCOV >= 0\n \n-/* Because small reads and writes, interspersed with seeks cause lots\n-   of disk activity, we buffer the entire count files.  */\n+/* Optimum size read from or written to disk.  */\n+#define GCOV_BLOCK_SIZE (1 << 12)\n \n GCOV_LINKAGE struct gcov_var\n {\n   FILE *file;\n-  gcov_position_t position;\n-  gcov_position_t length;\n+  gcov_position_t start;\t/* Position of first byte of block */\n+  unsigned offset;\t\t/* Read/write position within the block. */\n+  unsigned length;\t\t/* Read limit in the block. */\n+  unsigned overread;\t\t/* Number of bytes overread.  */\n+  int error;\t\t\t/* < 0 overflow, > 0 disk error.  */\n+  int mode;\t                /* < 0 writing, > 0 reading */\n+#if IN_LIBGCOV\n+  /* Holds one block plus 4 bytes, thus all coverage reads & writes\n+     fit within this buffer and we always can transfer GCOV_BLOCK_SIZE\n+     to and from the disk. libgcov never backtracks and only writes 4\n+     or 8 byte objects.  */\n+  unsigned char buffer[GCOV_BLOCK_SIZE + 4];\n+#else\n+  /* Holds a variable length block, as the compiler can write\n+     strings and needs to backtrack.  */\n   size_t alloc;\n-  unsigned modified;\n-  int error;\n   unsigned char *buffer;\n+#endif\n } gcov_var;\n \n-/* Functions for reading and writing gcov files.  */\n+/* Functions for reading and writing gcov files. You can open a file\n+   for (1) reading or (2) writing or (3) reading then rewriting. When\n+   reading a file you may use the gcov_read_* functions, gcov_sync,\n+   gcov_position, & gcov_error. When writing a file you\n+   may use the gcov_write functions, gcov_seek & gcov_error. When a\n+   file is to be rewritten you use the functions for reading, then\n+   gcov_rewrite then the functions for writing.  Your file may become\n+   corrupted if you break these invariants. */\n GCOV_LINKAGE int gcov_open (const char */*name*/, int /*truncate*/);\n GCOV_LINKAGE int gcov_close (void);\n-#if !IN_GCOV\n-GCOV_LINKAGE unsigned char *gcov_write_bytes (unsigned);\n-GCOV_LINKAGE void gcov_write_unsigned (gcov_unsigned_t);\n+\n+/* Available everywhere.  */\n+static gcov_position_t gcov_position (void);\n+static int gcov_is_error (void);\n+static int gcov_is_eof (void);\n+\n+GCOV_LINKAGE gcov_unsigned_t gcov_read_unsigned (void);\n+GCOV_LINKAGE gcov_type gcov_read_counter (void);\n+GCOV_LINKAGE void gcov_read_summary (struct gcov_summary *);\n+\n #if IN_LIBGCOV\n+/* Available only in libgcov */\n GCOV_LINKAGE void gcov_write_counter (gcov_type);\n-#else\n-GCOV_LINKAGE void gcov_write_string (const char *);\n-#endif\n-#if !IN_LIBGCOV\n-GCOV_LINKAGE gcov_position_t gcov_write_tag (gcov_unsigned_t);\n-GCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);\n-#else\n GCOV_LINKAGE void gcov_write_tag_length (gcov_unsigned_t, gcov_unsigned_t);\n GCOV_LINKAGE void gcov_write_summary (gcov_unsigned_t /*tag*/,\n \t\t\t\t      const struct gcov_summary *);\n-#endif\n-#endif /* !IN_GCOV */\n-GCOV_LINKAGE const unsigned char *gcov_read_bytes (unsigned);\n-GCOV_LINKAGE gcov_unsigned_t gcov_read_unsigned (void);\n-GCOV_LINKAGE gcov_type gcov_read_counter (void);\n-#if !IN_LIBGCOV\n+static void gcov_rewrite (void);\n+GCOV_LINKAGE void gcov_seek (gcov_position_t /*position*/);\n+#else\n+/* Available outside libgcov */\n GCOV_LINKAGE const char *gcov_read_string (void);\n+GCOV_LINKAGE void gcov_sync (gcov_position_t /*base*/,\n+\t\t\t     gcov_unsigned_t /*length */);\n #endif\n-GCOV_LINKAGE void gcov_read_summary (struct gcov_summary *);\n-static gcov_position_t gcov_position (void);\n-static void gcov_sync (gcov_position_t /*base*/, gcov_unsigned_t /*length */);\n-static void gcov_seek (gcov_position_t /*position*/);\n-static void gcov_rewrite (void);\n-static int gcov_is_eof (void);\n-static int gcov_is_error (void);\n+\n+#if !IN_GCOV\n+/* Available outside gcov */\n+GCOV_LINKAGE void gcov_write_unsigned (gcov_unsigned_t);\n+#endif\n+\n+#if !IN_GCOV && !IN_LIBGCOV\n+/* Available only in compiler */\n+GCOV_LINKAGE void gcov_write_string (const char *);\n+GCOV_LINKAGE gcov_position_t gcov_write_tag (gcov_unsigned_t);\n+GCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);\n+#endif\n+\n #if IN_GCOV > 0\n+/* Available in gcov */\n GCOV_LINKAGE time_t gcov_time (void);\n #endif\n \n+/* Make sure the library is used correctly.  */\n+#if ENABLE_CHECKING\n+#define GCOV_CHECK(expr) ((expr) ? (void)0 : (void)abort ())\n+#else\n+#define GCOV_CHECK(expr)\n+#endif\n+#define GCOV_CHECK_READING() GCOV_CHECK(gcov_var.mode > 0)\n+#define GCOV_CHECK_WRITING() GCOV_CHECK(gcov_var.mode < 0)\n+\n /* Save the current position in the gcov file.  */\n \n static inline gcov_position_t\n gcov_position (void)\n {\n-  return gcov_var.position;\n+  GCOV_CHECK_READING ();\n+  return gcov_var.start + gcov_var.offset;\n }\n \n-/* Reset to a known position.  BASE should have been obtained from\n-   gcov_save_position, LENGTH should be a record length, or zero.  */\n+/* Return non-zero if we read to end of file.  */\n \n-static inline void\n-gcov_sync (gcov_position_t base, gcov_unsigned_t length)\n+static inline int\n+gcov_is_eof ()\n {\n-  if (gcov_var.buffer)\n-    {\n-      base += length;\n-      if (gcov_var.length < base)\n-\t{\n-\t  gcov_var.error = 1;\n-\t  base = gcov_var.length;\n-\t}\n-      gcov_var.position = base;\n-    }\n+  return !gcov_var.overread;\n }\n \n-/* Move to the end of the gcov file.  */\n+/* Return non-zero if the error flag is set.  */\n \n-static inline void\n-gcov_seek (gcov_position_t base)\n+static inline int\n+gcov_is_error ()\n {\n-  gcov_var.position = base < gcov_var.length ? base : gcov_var.length;\n+  return gcov_var.file ? gcov_var.error : 1;\n }\n \n+#if IN_LIBGCOV\n /* Move to beginning of file and intialize for writing.  */\n \n static inline void\n gcov_rewrite (void)\n {\n-  gcov_var.position = 0;\n-}\n-\n-/* Tests whether we have reached end of .da file.  */\n-\n-static inline int\n-gcov_is_eof ()\n-{\n-  return gcov_var.position == gcov_var.length;\n-}\n-\n-/* Return non-zero if the error flag is set.  */\n-\n-static inline int\n-gcov_is_error ()\n-{\n-  return gcov_var.file ? gcov_var.error : 1;\n+  GCOV_CHECK_READING ();\n+  gcov_var.mode = -1;\n+  gcov_var.start = 0;\n+  gcov_var.offset = 0;\n+  fseek (gcov_var.file, 0L, SEEK_SET);\n }\n+#endif\n \n #endif /* IN_LIBGCOV >= 0 */\n "}, {"sha": "32590cba2fa8cd280f11c286ff5b3296998c07cd", "filename": "gcc/gcov.c", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=7d63a2fae019a83772ebae65689f4113a0eb4bec", "patch": "@@ -711,7 +711,8 @@ read_graph_file ()\n   struct function_info *fn = NULL;\n   source_t *src = NULL;\n   unsigned ix;\n-\n+  unsigned tag;\n+  \n   if (!gcov_open (bbg_file_name, 1))\n     {\n       fnotice (stderr, \"%s:cannot open graph file\\n\", bbg_file_name);\n@@ -740,11 +741,10 @@ read_graph_file ()\n \t       bbg_file_name, v, e);\n     }\n   \n-  while (!gcov_is_eof ())\n+  while ((tag = gcov_read_unsigned ()))\n     {\n-      unsigned tag = gcov_read_unsigned ();\n       unsigned length = gcov_read_unsigned ();\n-      unsigned long base = gcov_position ();\n+      gcov_position_t base = gcov_position ();\n \n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n@@ -906,12 +906,14 @@ read_graph_file ()\n \t}\n       gcov_sync (base, length);\n       if (gcov_is_error ())\n-\t{\n-\tcorrupt:;\n-\t  fnotice (stderr, \"%s:corrupted\\n\", bbg_file_name);\n-\t  gcov_close ();\n-\t  return 1;\n-\t}\n+\tbreak;\n+    }\n+  if (!gcov_is_eof ())\n+    {\n+    corrupt:;\n+      fnotice (stderr, \"%s:corrupted\\n\", bbg_file_name);\n+      gcov_close ();\n+      return 1;\n     }\n   gcov_close ();\n   \n@@ -976,7 +978,9 @@ read_count_file ()\n {\n   unsigned ix;\n   unsigned version;\n+  unsigned tag;\n   function_t *fn = NULL;\n+  int error = 0;\n \n   if (!gcov_open (da_file_name, 1))\n     {\n@@ -1005,12 +1009,10 @@ read_count_file ()\n \t       da_file_name, v, e);\n     }\n   \n-  while (!gcov_is_eof ())\n+  while ((tag = gcov_read_unsigned ()))\n     {\n-      unsigned tag = gcov_read_unsigned ();\n       unsigned length = gcov_read_unsigned ();\n       unsigned long base = gcov_position ();\n-      int error;\n \n       if (tag == GCOV_TAG_OBJECT_SUMMARY)\n \tgcov_read_summary (&object_summary);\n@@ -1061,13 +1063,16 @@ read_count_file ()\n \t}\n       gcov_sync (base, length);\n       if ((error = gcov_is_error ()))\n-\t{\n-\t  fnotice (stderr, error < 0\n-\t\t   ? \"%s:overflowed\\n\" : \"%s:corrupted\\n\", da_file_name);\n-\t  goto cleanup;\n-\t}\n+\tbreak;\n     }\n \n+  if (!gcov_is_eof ())\n+    {\n+      fnotice (stderr, error < 0 ? \"%s:overflowed\\n\" : \"%s:corrupted\\n\",\n+\t       da_file_name);\n+      goto cleanup;\n+    }\n+  \n   gcov_close ();\n   return 0;\n }"}, {"sha": "ba54281e58585ac186c77807fa9944e36ba9b370", "filename": "gcc/libgcov.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d63a2fae019a83772ebae65689f4113a0eb4bec/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=7d63a2fae019a83772ebae65689f4113a0eb4bec", "patch": "@@ -152,10 +152,10 @@ gcov_exit (void)\n       const struct gcov_ctr_info *ci_ptr;\n       struct gcov_ctr_summary *cs_ptr;\n       struct gcov_ctr_summary *cs_obj, *cs_tobj, *cs_prg, *cs_tprg, *cs_all;\n-      int error;\n+      int error = 0;\n       int merging;\n       gcov_unsigned_t tag, length;\n-      gcov_position_t summary_pos = ~(gcov_position_t)0;\n+      gcov_position_t summary_pos = 0;\n \n       /* Totals for this object file.  */\n       memset (&this_object, 0, sizeof (this_object));\n@@ -256,37 +256,41 @@ gcov_exit (void)\n \t    }\n \n \t  /* Check program & object summary */\n-\t  while (!gcov_is_eof ())\n+\t  while (1)\n \t    {\n \t      gcov_position_t base = gcov_position ();\n \t      int is_program;\n \t      \n \t      tag = gcov_read_unsigned ();\n+\t      if (!tag)\n+\t\tbreak;\n \t      length = gcov_read_unsigned ();\n \t      is_program = tag == GCOV_TAG_PROGRAM_SUMMARY;\n \t      if (length != GCOV_TAG_SUMMARY_LENGTH\n \t\t  || (!is_program && tag != GCOV_TAG_OBJECT_SUMMARY))\n \t\tgoto read_mismatch;\n \t      gcov_read_summary (is_program ? &program : &object);\n \t      if ((error = gcov_is_error ()))\n+\t\tgoto read_error;\n+\t      if (is_program && program.checksum == gcov_crc32)\n \t\t{\n-\t\tread_error:;\n-\t\t  fprintf (stderr, error < 0 ?\n-\t\t\t   \"profiling:%s:Overflow merging\\n\" :\n-\t\t\t   \"profiling:%s:Error merging\\n\", gi_ptr->filename);\n-\t\t  goto read_fatal;\n+\t\t  summary_pos = base;\n+\t\t  goto rewrite;\n \t\t}\n-\t      \n-\t      if (!is_program || program.checksum != gcov_crc32)\n-\t\tcontinue;\n-\t      summary_pos = base;\n-\t      break;\n \t    }\n+\t  if (!gcov_is_eof ())\n+\t    {\n+\t    read_error:;\n+\t      fprintf (stderr, error < 0 ? \"profiling:%s:Overflow merging\\n\"\n+\t\t       : \"profiling:%s:Error merging\\n\", gi_ptr->filename);\n+\t      goto read_fatal;\n+\t    }\n+\trewrite:;\n \t  gcov_rewrite ();\n \t}\n       else\n \tmemset (&object, 0, sizeof (object));\n-      if (!(summary_pos + 1))\n+      if (!summary_pos)\n \tmemset (&program, 0, sizeof (program));\n \n       /* Merge the summaries.  */"}]}