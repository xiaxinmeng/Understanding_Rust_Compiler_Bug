{"sha": "da8e0e1191c5512244a752b30dea0eba83e3d10c", "node_id": "C_kwDOANBUbNoAKGRhOGUwZTExOTFjNTUxMjI0NGE3NTJiMzBkZWEwZWJhODNlM2QxMGM", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-10-27T19:52:07Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-11-02T19:51:40Z"}, "message": "Support OpenACC 'declare create' with Fortran allocatable arrays, part I [PR106643]\n\n\tPR libgomp/106643\n\tlibgomp/\n\t* oacc-mem.c (goacc_enter_data_internal): Support\n\tOpenACC 'declare create' with Fortran allocatable arrays, part I.\n\t* testsuite/libgomp.oacc-fortran/declare-allocatable-1-directive.f90:\n\tNew.\n\t* testsuite/libgomp.oacc-fortran/declare-allocatable-array_descriptor-1-directive.f90:\n\tNew.", "tree": {"sha": "1ec78de232712e3c59460d16773e891724f64a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ec78de232712e3c59460d16773e891724f64a5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da8e0e1191c5512244a752b30dea0eba83e3d10c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da8e0e1191c5512244a752b30dea0eba83e3d10c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da8e0e1191c5512244a752b30dea0eba83e3d10c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da8e0e1191c5512244a752b30dea0eba83e3d10c/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abeaf3735fe2568b9d5b8096318da866b1fe1e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abeaf3735fe2568b9d5b8096318da866b1fe1e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abeaf3735fe2568b9d5b8096318da866b1fe1e5c"}], "stats": {"total": 708, "additions": 706, "deletions": 2}, "files": [{"sha": "ba010fddbb35b1da2cd142694947bc4e5c015c9e", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da8e0e1191c5512244a752b30dea0eba83e3d10c/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da8e0e1191c5512244a752b30dea0eba83e3d10c/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=da8e0e1191c5512244a752b30dea0eba83e3d10c", "patch": "@@ -1150,8 +1150,7 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t}\n       else if (n && groupnum > 1)\n \t{\n-\t  assert (n->refcount != REFCOUNT_INFINITY\n-\t\t  && n->refcount != REFCOUNT_LINK);\n+\t  assert (n->refcount != REFCOUNT_LINK);\n \n \t  for (size_t j = i + 1; j <= group_last; j++)\n \t    if ((kinds[j] & 0xff) == GOMP_MAP_ATTACH)\n@@ -1166,6 +1165,31 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t  bool processed = false;\n \n \t  struct target_mem_desc *tgt = n->tgt;\n+\n+\t  /* Arrange so that OpenACC 'declare' code \u00e0 la PR106643\n+\t     \"[gfortran + OpenACC] Allocate in module causes refcount error\"\n+\t     has a chance to work.  */\n+\t  if ((kinds[i] & 0xff) == GOMP_MAP_TO_PSET\n+\t      && tgt->list_count == 0)\n+\t    {\n+\t      /* 'declare target'.  */\n+\t      assert (n->refcount == REFCOUNT_INFINITY);\n+\n+\t      for (size_t k = 1; k < groupnum; k++)\n+\t\t{\n+\t\t  /* The only thing we expect to see here.  */\n+\t\t  assert ((kinds[i + k] & 0xff) == GOMP_MAP_POINTER);\n+\t\t}\n+\n+\t      /* Given that 'goacc_exit_data_internal'/'goacc_exit_datum_1'\n+\t\t will always see 'n->refcount == REFCOUNT_INFINITY',\n+\t\t there's no need to adjust 'n->dynamic_refcount' here.  */\n+\n+\t      processed = true;\n+\t    }\n+\t  else\n+\t    assert (n->refcount != REFCOUNT_INFINITY);\n+\n \t  for (size_t j = 0; j < tgt->list_count; j++)\n \t    if (tgt->list[j].key == n)\n \t      {"}, {"sha": "759873bad67551fa8d30cc68e2405a506652eed2", "filename": "libgomp/testsuite/libgomp.oacc-fortran/declare-allocatable-1-directive.f90", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da8e0e1191c5512244a752b30dea0eba83e3d10c/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-1-directive.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da8e0e1191c5512244a752b30dea0eba83e3d10c/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-1-directive.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-1-directive.f90?ref=da8e0e1191c5512244a752b30dea0eba83e3d10c", "patch": "@@ -0,0 +1,278 @@\n+! Test OpenACC 'declare create' with allocatable arrays.\n+\n+! { dg-do run }\n+\n+!TODO-OpenACC-declare-allocate\n+! Missing support for OpenACC \"Changes from Version 2.0 to 2.5\":\n+! \"The 'declare create' directive with a Fortran 'allocatable' has new behavior\".\n+! Thus, after 'allocate'/before 'deallocate', do\n+! '!$acc enter data create'/'!$acc exit data delete' manually.\n+\n+!TODO { dg-additional-options -fno-inline } for stable results regarding OpenACC 'routine'.\n+\n+! { dg-additional-options -fopt-info-all-omp }\n+! { dg-additional-options -foffload=-fopt-info-all-omp }\n+\n+! { dg-additional-options --param=openacc-privatization=noisy }\n+! { dg-additional-options -foffload=--param=openacc-privatization=noisy }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable '[Di]\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n+\n+! { dg-additional-options -Wopenacc-parallelism }\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c 0] }\n+! { dg-message dummy {} { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n+\n+\n+module vars\n+  implicit none\n+  integer, parameter :: n = 100\n+  real*8, allocatable :: b(:)\n+ !$acc declare create (b)\n+end module vars\n+\n+program test\n+  use vars\n+  use openacc\n+  implicit none\n+  real*8 :: a\n+  integer :: i\n+\n+  interface\n+     subroutine sub1\n+       !$acc routine gang\n+     end subroutine sub1\n+\n+     subroutine sub2\n+     end subroutine sub2\n+\n+     real*8 function fun1 (ix)\n+       integer ix\n+       !$acc routine seq\n+     end function fun1\n+\n+     real*8 function fun2 (ix)\n+       integer ix\n+       !$acc routine seq\n+     end function fun2\n+  end interface\n+\n+  if (allocated (b)) error stop\n+\n+  ! Test local usage of an allocated declared array.\n+\n+  allocate (b(n))\n+  !$acc enter data create (b)\n+\n+  if (.not.allocated (b)) error stop\n+  if (.not.acc_is_present (b)) error stop\n+\n+  a = 2.0\n+\n+  !$acc parallel loop ! { dg-line l[incr c] }\n+  ! { dg-note {variable 'i' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' ought to be adjusted for OpenACC privatization level: 'vector'} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' adjusted for OpenACC privatization level: 'vector'} {} { target { ! openacc_host_selected } } l$c }\n+  ! { dg-note {variable 'i\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l$c }\n+  ! { dg-optimized {assigned OpenACC gang vector loop parallelism} {} { target *-*-* } l$c }\n+  do i = 1, n\n+     b(i) = i * a\n+  end do\n+\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc update host(b)\n+\n+  do i = 1, n\n+     if (b(i) /= i*a) error stop\n+  end do\n+\n+  !$acc exit data delete (b)\n+  deallocate (b)\n+\n+  ! Test the usage of an allocated declared array inside an acc\n+  ! routine subroutine.\n+\n+  allocate (b(n))\n+  !$acc enter data create (b)\n+\n+  if (.not.allocated (b)) error stop\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc parallel\n+  call sub1 ! { dg-line l[incr c] }\n+  ! { dg-optimized {assigned OpenACC gang worker vector loop parallelism} {} { target *-*-* } l$c }\n+  !$acc end parallel\n+\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc update host(b)\n+\n+  do i = 1, n\n+     if (b(i) /= i*2) error stop\n+  end do\n+\n+  !$acc exit data delete (b)\n+  deallocate (b)\n+\n+  ! Test the usage of an allocated declared array inside a host\n+  ! subroutine.\n+\n+  call sub2\n+\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc update host(b)\n+\n+  do i = 1, n\n+     if (b(i) /= 1.0) error stop\n+  end do\n+\n+  !$acc exit data delete (b)\n+  deallocate (b)\n+\n+  if (allocated (b)) error stop\n+\n+  ! Test the usage of an allocated declared array inside an acc\n+  ! routine function.\n+\n+  allocate (b(n))\n+  !$acc enter data create (b)\n+\n+  if (.not.allocated (b)) error stop\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc parallel loop ! { dg-line l[incr c] }\n+  ! { dg-note {variable 'i' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' ought to be adjusted for OpenACC privatization level: 'vector'} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' adjusted for OpenACC privatization level: 'vector'} {} { target { ! openacc_host_selected } } l$c }\n+  ! { dg-note {variable 'i\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l$c }\n+  ! { dg-optimized {assigned OpenACC gang vector loop parallelism} {} { target *-*-* } l$c }\n+  do i = 1, n\n+     b(i) = 1.0\n+  end do\n+\n+  !$acc parallel loop ! { dg-line l[incr c] }\n+  ! { dg-note {variable 'i' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' ought to be adjusted for OpenACC privatization level: 'vector'} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' adjusted for OpenACC privatization level: 'vector'} {} { target { ! openacc_host_selected } } l$c }\n+  ! { dg-note {variable 'i\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l$c }\n+  ! { dg-optimized {assigned OpenACC gang vector loop parallelism} {} { target *-*-* } l$c }\n+  do i = 1, n\n+     b(i) = fun1 (i) ! { dg-line l[incr c] }\n+     ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l$c }\n+  end do\n+\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc update host(b)\n+\n+  do i = 1, n\n+     if (b(i) /= i) error stop\n+  end do\n+\n+  !$acc exit data delete (b)\n+  deallocate (b)\n+\n+  ! Test the usage of an allocated declared array inside a host\n+  ! function.\n+\n+  allocate (b(n))\n+  !$acc enter data create (b)\n+\n+  if (.not.allocated (b)) error stop\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc parallel loop ! { dg-line l[incr c] }\n+  ! { dg-note {variable 'i' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' ought to be adjusted for OpenACC privatization level: 'vector'} {} { target *-*-* } l$c }\n+  !   { dg-note {variable 'i' adjusted for OpenACC privatization level: 'vector'} {} { target { ! openacc_host_selected } } l$c }\n+  ! { dg-note {variable 'i\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l$c }\n+  ! { dg-optimized {assigned OpenACC gang vector loop parallelism} {} { target *-*-* } l$c }\n+  do i = 1, n\n+     b(i) = 1.0\n+  end do\n+\n+  !$acc update host(b)\n+\n+  do i = 1, n\n+     b(i) = fun2 (i)\n+  end do\n+\n+  if (.not.acc_is_present (b)) error stop\n+\n+  do i = 1, n\n+     if (b(i) /= i*i) error stop\n+  end do\n+\n+  !$acc exit data delete (b)\n+  deallocate (b)\n+end program test ! { dg-line l[incr c] }\n+! { dg-bogus {note: variable 'overflow\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {TODO n/a} { xfail *-*-* } l$c }\n+! { dg-bogus {note: variable 'not_prev_allocated\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {TODO n/a} { xfail *-*-* } l$c }\n+! { dg-bogus {note: variable 'parm\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} {TODO n/a} { xfail *-*-* } l$c }\n+\n+! Set each element in array 'b' at index i to i*2.\n+\n+subroutine sub1 ! { dg-line subroutine_sub1 }\n+  use vars\n+  implicit none\n+  integer i\n+  !$acc routine gang\n+  ! { dg-bogus {[Ww]arning: region is worker partitioned but does not contain worker partitioned code} {TODO default 'gang' 'vector'} { xfail *-*-* } subroutine_sub1 }\n+\n+  !$acc loop ! { dg-line l[incr c] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l$c }\n+  ! { dg-optimized {assigned OpenACC gang vector loop parallelism} {} { target *-*-* } l$c }\n+  do i = 1, n\n+     b(i) = i*2\n+  end do\n+end subroutine sub1\n+\n+! Allocate array 'b', and set it to all 1.0.\n+\n+subroutine sub2\n+  use vars\n+  use openacc\n+  implicit none\n+  integer i\n+\n+  allocate (b(n))\n+  !$acc enter data create (b)\n+\n+  if (.not.allocated (b)) error stop\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc parallel loop ! { dg-line l[incr c] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l$c }\n+  ! { dg-optimized {assigned OpenACC gang vector loop parallelism} {} { target *-*-* } l$c }\n+  do i = 1, n\n+     b(i) = 1.0\n+  end do\n+end subroutine sub2\n+\n+! Return b(i) * i;\n+\n+real*8 function fun1 (i)\n+  use vars\n+  implicit none\n+  integer i\n+  !$acc routine seq\n+\n+  fun1 = b(i) * i\n+end function fun1\n+\n+! Return b(i) * i * i;\n+\n+real*8 function fun2 (i)\n+  use vars\n+  implicit none\n+  integer i\n+\n+  fun2 = b(i) * i * i\n+end function fun2"}, {"sha": "10e1d5bc378b5891d88d73f4e65feae7871be76e", "filename": "libgomp/testsuite/libgomp.oacc-fortran/declare-allocatable-array_descriptor-1-directive.f90", "status": "added", "additions": 402, "deletions": 0, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da8e0e1191c5512244a752b30dea0eba83e3d10c/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-directive.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da8e0e1191c5512244a752b30dea0eba83e3d10c/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-directive.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-directive.f90?ref=da8e0e1191c5512244a752b30dea0eba83e3d10c", "patch": "@@ -0,0 +1,402 @@\n+! Test OpenACC 'declare create' with allocatable arrays.\n+\n+! { dg-do run }\n+\n+! Note that we're not testing OpenACC semantics here, but rather documenting\n+! current GCC behavior, specifically, behavior concerning updating of\n+! host/device array descriptors.\n+! { dg-skip-if n/a { *-*-* } { -DACC_MEM_SHARED=1 } }\n+\n+!TODO-OpenACC-declare-allocate\n+! Missing support for OpenACC \"Changes from Version 2.0 to 2.5\":\n+! \"The 'declare create' directive with a Fortran 'allocatable' has new behavior\".\n+! Thus, after 'allocate'/before 'deallocate', do\n+! '!$acc enter data create'/'!$acc exit data delete' manually.\n+\n+\n+!TODO { dg-additional-options -fno-inline } for stable results regarding OpenACC 'routine'.\n+\n+\n+!TODO OpenACC 'serial' vs. GCC/nvptx:\n+!TODO { dg-prune-output {using 'vector_length \\(32\\)', ignoring 1} }\n+\n+\n+! { dg-additional-options -fdump-tree-original }\n+! { dg-additional-options -fdump-tree-gimple }\n+\n+\n+module vars\n+  implicit none\n+  integer, parameter :: n1_lb = -3\n+  integer, parameter :: n1_ub = 6\n+  integer, parameter :: n2_lb = -9999\n+  integer, parameter :: n2_ub = 22222\n+\n+  integer, allocatable :: b(:)\n+  !$acc declare create (b)\n+\n+end module vars\n+\n+program test\n+  use vars\n+  use openacc\n+  implicit none\n+  integer :: i\n+\n+  ! Identifiers for purposes of reliable '-fdump-tree-[...]' scanning.\n+  integer :: id1_1, id1_2\n+\n+  interface\n+\n+     subroutine verify_initial\n+       implicit none\n+       !$acc routine seq\n+     end subroutine verify_initial\n+\n+     subroutine verify_n1_allocated\n+       implicit none\n+       !$acc routine seq\n+     end subroutine verify_n1_allocated\n+\n+     subroutine verify_n1_values (addend)\n+       implicit none\n+       !$acc routine gang\n+       integer, value :: addend\n+     end subroutine verify_n1_values\n+\n+     subroutine verify_n1_deallocated (expect_allocated)\n+       implicit none\n+       !$acc routine seq\n+       logical, value :: expect_allocated\n+     end subroutine verify_n1_deallocated\n+\n+     subroutine verify_n2_allocated\n+       implicit none\n+       !$acc routine seq\n+     end subroutine verify_n2_allocated\n+\n+     subroutine verify_n2_values (addend)\n+       implicit none\n+       !$acc routine gang\n+       integer, value :: addend\n+     end subroutine verify_n2_values\n+\n+     subroutine verify_n2_deallocated (expect_allocated)\n+       implicit none\n+       !$acc routine seq\n+       logical, value :: expect_allocated\n+     end subroutine verify_n2_deallocated\n+\n+  end interface\n+\n+  call acc_create (id1_1)\n+  call acc_create (id1_2)\n+\n+  call verify_initial\n+  ! It is important here (and similarly, following) that there is no data\n+  ! clause for 'b' (explicit or implicit): no 'GOMP_MAP_TO_PSET'.\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  allocate (b(n1_lb:n1_ub))\n+  call verify_n1_allocated\n+  if (acc_is_present (b)) error stop\n+  !$acc enter data create (b)\n+  ! This is now OpenACC \"present\":\n+  if (.not.acc_is_present (b)) error stop\n+  ! This still has the initial array descriptor:\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  do i = n1_lb, n1_ub\n+     b(i) = i - 1\n+  end do\n+\n+  ! Verify that host-to-device copy doesn't touch the device-side (still\n+  ! initial) array descriptor (but it does copy the array data).\n+  call acc_update_device (b)\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  b = 40\n+\n+  ! Verify that device-to-host copy doesn't touch the host-side array\n+  ! descriptor, doesn't copy out the device-side (still initial) array\n+  ! descriptor (but it does copy the array data).\n+  call acc_update_self (b)\n+  call verify_n1_allocated\n+\n+  do i = n1_lb, n1_ub\n+     if (b(i) /= i - 1) error stop\n+     b(i) = b(i) + 2\n+  end do\n+\n+  ! The same using the OpenACC 'update' directive.\n+\n+  !$acc update device (b) self (id1_1)\n+  ! We do have 'GOMP_MAP_TO_PSET' here:\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc update map\\(force_to:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_1\\);$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_update map\\(force_to:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+  ! ..., but it's silently skipped in 'GOACC_update'.\n+  !$acc serial\n+  call verify_initial\n+  !$acc end serial\n+\n+  b = 41\n+\n+  !$acc update self (b) self (id1_2)\n+  ! We do have 'GOMP_MAP_TO_PSET' here:\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc update map\\(force_from:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_2\\);$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_update map\\(force_from:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+  ! ..., but it's silently skipped in 'GOACC_update'.\n+  call verify_n1_allocated\n+\n+  do i = n1_lb, n1_ub\n+     if (b(i) /= i + 1) error stop\n+     b(i) = b(i) + 2\n+  end do\n+\n+  ! Now install the actual array descriptor, via a data clause for 'b'\n+  ! (explicit or implicit): must get a 'GOMP_MAP_TO_PSET', which then in\n+  ! 'gomp_map_vars_internal' is handled as 'declare target', and because of\n+  ! '*(void **) hostaddrs[i] != NULL', we've got 'has_always_ptrset == true',\n+  ! 'always_to_cnt == 1', and therefore 'gomp_map_vars_existing' does update\n+  ! the 'GOMP_MAP_TO_PSET'.\n+  !$acc serial present (b) copyin (id1_1)\n+  call verify_initial\n+  id1_1 = 0\n+  !$acc end serial\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc serial map\\(force_present:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_1\\)$} 1 original } }\n+  !TODO ..., but without an actual use of 'b', the gimplifier removes the\n+  !TODO 'GOMP_MAP_TO_PSET':\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_serial map\\(force_present:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+  !$acc serial present (b) copyin (id1_2)\n+  call verify_n1_allocated\n+  !TODO Use of 'b':\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc serial map\\(force_present:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2\\)$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_serial map\\(force_present:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  !$acc parallel copyin (id1_1) ! No data clause for 'b' (explicit or implicit): no 'GOMP_MAP_TO_PSET'.\n+  call verify_n1_values (1)\n+  id1_1 = 0\n+  !$acc end parallel\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc parallel map\\(to:id1_1\\)$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_parallel map\\(to:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  !$acc parallel copy (b) copyin (id1_2)\n+  ! As already present, 'copy (b)' doesn't copy; addend is still '1'.\n+  call verify_n1_values (1)\n+  id1_2 = 0\n+  !$acc end parallel\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc parallel map\\(tofrom:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2\\)$} 1 original } }\n+  !TODO ..., but without an actual use of 'b', the gimplifier removes the\n+  !TODO 'GOMP_MAP_TO_PSET':\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_parallel map\\(tofrom:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  call verify_n1_allocated\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc exit data delete (b)\n+  if (.not.allocated (b)) error stop\n+  if (acc_is_present (b)) error stop\n+  ! The device-side array descriptor doesn't get updated, so 'b' still appears\n+  ! as \"allocated\":\n+  !$acc serial\n+  call verify_n1_allocated\n+  !$acc end serial\n+\n+  deallocate (b)\n+  call verify_n1_deallocated (.false.)\n+  ! The device-side array descriptor doesn't get updated, so 'b' still appears\n+  ! as \"allocated\":\n+  !$acc serial\n+  call verify_n1_allocated\n+  !$acc end serial\n+\n+  ! Now try to install the actual array descriptor, via a data clause for 'b'\n+  ! (explicit or implicit): must get a 'GOMP_MAP_TO_PSET', which then in\n+  ! 'gomp_map_vars_internal' is handled as 'declare target', but because of\n+  ! '*(void **) hostaddrs[i] == NULL', we've got 'has_always_ptrset == false',\n+  ! 'always_to_cnt == 0', and therefore 'gomp_map_vars_existing' doesn't update\n+  ! the 'GOMP_MAP_TO_PSET'.\n+  ! The device-side array descriptor doesn't get updated, so 'b' still appears\n+  ! as \"allocated\":\n+  !TODO Why does 'present (b)' still work here?\n+  !$acc serial present (b) copyout (id1_2)\n+  call verify_n1_deallocated (.true.)\n+  !TODO Use of 'b'.\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc serial map\\(force_present:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(from:id1_2\\)$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_serial map\\(force_present:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(from:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+\n+  ! Restart the procedure, with different array dimensions.\n+\n+  allocate (b(n2_lb:n2_ub))\n+  call verify_n2_allocated\n+  if (acc_is_present (b)) error stop\n+  !$acc enter data create (b)\n+  if (.not.acc_is_present (b)) error stop\n+  ! This still has the previous (n1) array descriptor:\n+  !$acc serial\n+  call verify_n1_deallocated (.true.)\n+  !$acc end serial\n+\n+  do i = n2_lb, n2_ub\n+     b(i) = i + 20\n+  end do\n+\n+  call acc_update_device (b)\n+  !$acc serial\n+  call verify_n1_deallocated (.true.)\n+  !$acc end serial\n+\n+  b = -40\n+\n+  call acc_update_self (b)\n+  call verify_n2_allocated\n+\n+  do i = n2_lb, n2_ub\n+     if (b(i) /= i + 20) error stop\n+     b(i) = b(i) - 40\n+  end do\n+\n+  !$acc update device (b)\n+  !$acc serial\n+  call verify_n1_deallocated (.true.)\n+  !$acc end serial\n+\n+  b = -41\n+\n+  !$acc update self (b)\n+  call verify_n2_allocated\n+\n+  do i = n2_lb, n2_ub\n+     if (b(i) /= i - 20) error stop\n+     b(i) = b(i) + 10\n+  end do\n+\n+  !$acc serial present (b) copy (id1_2)\n+  call verify_n2_allocated\n+  !TODO Use of 'b':\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+\n+  !$acc parallel\n+  call verify_n2_values (-20)\n+  !$acc end parallel\n+\n+  !$acc parallel copy (b)\n+  call verify_n2_values (-20)\n+  !$acc end parallel\n+\n+  call verify_n2_allocated\n+  if (.not.acc_is_present (b)) error stop\n+\n+  !$acc exit data delete (b)\n+  if (.not.allocated (b)) error stop\n+  if (acc_is_present (b)) error stop\n+  !$acc serial\n+  call verify_n2_allocated\n+  !$acc end serial\n+\n+  deallocate (b)\n+  call verify_n2_deallocated (.false.)\n+  !$acc serial\n+  call verify_n2_allocated\n+  !$acc end serial\n+\n+  !$acc serial present (b) copy (id1_2)\n+  call verify_n2_deallocated (.true.)\n+  !TODO Use of 'b':\n+  id1_2 = ubound (b, 1)\n+  !$acc end serial\n+\n+end program test\n+\n+\n+subroutine verify_initial\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+\n+  if (allocated (b)) error stop \"verify_initial allocated\"\n+  if (any (lbound (b) /= [0])) error stop \"verify_initial lbound\"\n+  if (any (ubound (b) /= [0])) error stop \"verify_initial ubound\"\n+end subroutine verify_initial\n+\n+subroutine verify_n1_allocated\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+\n+  if (.not.allocated (b)) error stop \"verify_n1_allocated allocated\"\n+  if (any (lbound (b) /= [n1_lb])) error stop \"verify_n1_allocated lbound\"\n+  if (any (ubound (b) /= [n1_ub])) error stop \"verify_n1_allocated ubound\"\n+end subroutine verify_n1_allocated\n+\n+subroutine verify_n1_values (addend)\n+  use vars\n+  implicit none\n+  !$acc routine gang\n+  integer, value :: addend\n+  integer :: i\n+\n+  !$acc loop\n+  do i = n1_lb, n1_ub\n+     if (b(i) /= i + addend) error stop\n+  end do\n+end subroutine verify_n1_values\n+\n+subroutine verify_n1_deallocated (expect_allocated)\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+  logical, value :: expect_allocated\n+\n+  if (allocated(b) .neqv. expect_allocated) error stop \"verify_n1_deallocated allocated\"\n+  ! Apparently 'deallocate'ing doesn't unset the bounds.\n+  if (any (lbound (b) /= [n1_lb])) error stop \"verify_n1_deallocated lbound\"\n+  if (any (ubound (b) /= [n1_ub])) error stop \"verify_n1_deallocated ubound\"\n+end subroutine verify_n1_deallocated\n+\n+subroutine verify_n2_allocated\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+\n+  if (.not.allocated(b)) error stop \"verify_n2_allocated allocated\"\n+  if (any (lbound (b) /= [n2_lb])) error stop \"verify_n2_allocated lbound\"\n+  if (any (ubound (b) /= [n2_ub])) error stop \"verify_n2_allocated ubound\"\n+end subroutine verify_n2_allocated\n+\n+subroutine verify_n2_values (addend)\n+  use vars\n+  implicit none\n+  !$acc routine gang\n+  integer, value :: addend\n+  integer :: i\n+\n+  !$acc loop\n+  do i = n2_lb, n2_ub\n+     if (b(i) /= i + addend) error stop\n+  end do\n+end subroutine verify_n2_values\n+\n+subroutine verify_n2_deallocated (expect_allocated)\n+  use vars\n+  implicit none\n+  !$acc routine seq\n+  logical, value :: expect_allocated\n+\n+  if (allocated(b) .neqv. expect_allocated) error stop \"verify_n2_deallocated allocated\"\n+  ! Apparently 'deallocate'ing doesn't unset the bounds.\n+  if (any (lbound (b) /= [n2_lb])) error stop \"verify_n2_deallocated lbound\"\n+  if (any (ubound (b) /= [n2_ub])) error stop \"verify_n2_deallocated ubound\"\n+end subroutine verify_n2_deallocated"}]}