{"sha": "e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNhOGYxZmE4OGQ2ZDg3NDQ0NDg5YzVjZjgxMDBhZWIwOWJmYjE3OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-08T18:09:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-08T18:09:41Z"}, "message": "loop-unswitch.c (unswitch_single_loop): Use estimated_loop_iterations_int to prevent unswitching when...\n\n\n\t* loop-unswitch.c (unswitch_single_loop): Use\n\testimated_loop_iterations_int to prevent unswitching when loop\n\tis known to not roll.\n\t* tree-ssa-loop-niter.c (estimated_loop_iterations): Do not segfault\n\twhen SCEV is not initialized.\n\t(max_loop_iterations): Likewise.\n\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops): Use\n\testimated_loop_iterations_int to prevent unswithcing when\n\tloop is known to not roll.\n\t* tree-scalar-evolution.c (scev_initialized_p): New function.\n\t* tree-scalar-evolution.h (scev_initialized_p): Likewise.\n\t* loop-unroll.c (decide_peel_once_rolling): Use\n\tmax_loop_iterations_int.\n\t(unroll_loop_constant_iterations): Update\n\tnb_iterations_upper_bound and nb_iterations_estimate.\n\t(decide_unroll_runtime_iterations): Use\n\testimated_loop_iterations or max_loop_iterations;\n\t(unroll_loop_runtime_iterations): fix profile updating.\n\t(decide_peel_simple): Use estimated_loop_iterations\n\tand max_loop_iterations.\n\t(decide_unroll_stupid): Use estimated_loop_iterations\n\tad max_loop_iterations.\n\t* loop-doloop.c (doloop_modify): Use max_loop_iterations_int.\n\t(doloop_optimize): Likewise.\n\t* loop-iv.c (iv_number_of_iterations): Use record_niter_bound.\n\t(find_simple_exit): Likewise.\n\t* cfgloop.h (struct niter_desc): Remove niter_max.\n\nFrom-SVN: r192219", "tree": {"sha": "eb195a552c62fbc24735e6506d9aa729f6806b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb195a552c62fbc24735e6506d9aa729f6806b75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/comments", "author": null, "committer": null, "parents": [{"sha": "ee84cd3713c1246afc473ae4acc9b6e061c206fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee84cd3713c1246afc473ae4acc9b6e061c206fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee84cd3713c1246afc473ae4acc9b6e061c206fe"}], "stats": {"total": 219, "additions": 173, "deletions": 46}, "files": [{"sha": "ba74c1bbc1f47509fed5068cf4d1c784d000c00c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -1,3 +1,33 @@\n+2012-10-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop-unswitch.c (unswitch_single_loop): Use\n+\testimated_loop_iterations_int to prevent unswitching when loop\n+\tis known to not roll.\n+\t* tree-ssa-loop-niter.c (estimated_loop_iterations): Do not segfault\n+\twhen SCEV is not initialized.\n+\t(max_loop_iterations): Likewise.\n+\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops): Use\n+\testimated_loop_iterations_int to prevent unswithcing when\n+\tloop is known to not roll.\n+\t* tree-scalar-evolution.c (scev_initialized_p): New function.\n+\t* tree-scalar-evolution.h (scev_initialized_p): Likewise.\n+\t* loop-unroll.c (decide_peel_once_rolling): Use\n+\tmax_loop_iterations_int.\n+\t(unroll_loop_constant_iterations): Update\n+\tnb_iterations_upper_bound and nb_iterations_estimate.\n+\t(decide_unroll_runtime_iterations): Use\n+\testimated_loop_iterations or max_loop_iterations;\n+\t(unroll_loop_runtime_iterations): fix profile updating.\n+\t(decide_peel_simple): Use estimated_loop_iterations\n+\tand max_loop_iterations.\n+\t(decide_unroll_stupid): Use estimated_loop_iterations\n+\tad max_loop_iterations.\n+\t* loop-doloop.c (doloop_modify): Use max_loop_iterations_int.\n+\t(doloop_optimize): Likewise.\n+\t* loop-iv.c (iv_number_of_iterations): Use record_niter_bound.\n+\t(find_simple_exit): Likewise.\n+\t* cfgloop.h (struct niter_desc): Remove niter_max.\n+\n 2012-10-08  Marek Polacek  <polacek@redhat.com>\n \n \tPR debug/54831"}, {"sha": "9d7b784174d3124eb42af3fc463a40b8a9f045db", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -386,9 +386,6 @@ struct niter_desc\n   /* Number of iterations if constant.  */\n   unsigned HOST_WIDEST_INT niter;\n \n-  /* Upper bound on the number of iterations.  */\n-  unsigned HOST_WIDEST_INT niter_max;\n-\n   /* Assumptions under that the rest of the information is valid.  */\n   rtx assumptions;\n "}, {"sha": "8dcfea5bba83122f72783797c0efedd36517d2a1", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -410,6 +410,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   basic_block loop_end = desc->out_edge->src;\n   enum machine_mode mode;\n   rtx true_prob_val;\n+  double_int iterations;\n \n   jump_insn = BB_END (loop_end);\n \n@@ -460,9 +461,10 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \n       /* Determine if the iteration counter will be non-negative.\n \t Note that the maximum value loaded is iterations_max - 1.  */\n-      if (desc->niter_max\n-\t  <= ((unsigned HOST_WIDEST_INT) 1\n-\t      << (GET_MODE_PRECISION (mode) - 1)))\n+      if (max_loop_iterations (loop, &iterations)\n+\t  && (iterations.ule (double_int_one.llshift\n+\t\t\t       (GET_MODE_PRECISION (mode) - 1,\n+\t\t\t\tGET_MODE_PRECISION (mode)))))\n \tnonneg = 1;\n       break;\n \n@@ -548,9 +550,17 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   {\n     rtx init;\n     unsigned level = get_loop_level (loop) + 1;\n+    double_int iter;\n+    rtx iter_rtx;\n+\n+    if (!max_loop_iterations (loop, &iter)\n+\t|| !iter.fits_shwi ())\n+      iter_rtx = const0_rtx;\n+    else\n+      iter_rtx = GEN_INT (iter.to_shwi());\n     init = gen_doloop_begin (counter_reg,\n \t\t\t     desc->const_iter ? desc->niter_expr : const0_rtx,\n-\t\t\t     GEN_INT (desc->niter_max),\n+\t\t\t     iter_rtx,\n \t\t\t     GEN_INT (level));\n     if (init)\n       {\n@@ -608,6 +618,7 @@ doloop_optimize (struct loop *loop)\n   struct niter_desc *desc;\n   unsigned word_mode_size;\n   unsigned HOST_WIDE_INT word_mode_max;\n+  double_int iter;\n \n   if (dump_file)\n     fprintf (dump_file, \"Doloop: Processing loop %d.\\n\", loop->num);\n@@ -658,7 +669,11 @@ doloop_optimize (struct loop *loop)\n \n   count = copy_rtx (desc->niter_expr);\n   iterations = desc->const_iter ? desc->niter_expr : const0_rtx;\n-  iterations_max = GEN_INT (desc->niter_max);\n+  if (!max_loop_iterations (loop, &iter)\n+      || !iter.fits_shwi ())\n+    iterations_max = const0_rtx;\n+  else\n+    iterations_max = GEN_INT (iter.to_shwi());\n   level = get_loop_level (loop) + 1;\n \n   /* Generate looping insn.  If the pattern FAILs then give up trying\n@@ -678,7 +693,7 @@ doloop_optimize (struct loop *loop)\n \t computed, we must be sure that the number of iterations fits into\n \t the new mode.  */\n       && (word_mode_size >= GET_MODE_PRECISION (mode)\n-\t  || desc->niter_max <= word_mode_max))\n+\t  || iter.ule (double_int::from_shwi (word_mode_max))))\n     {\n       if (word_mode_size > GET_MODE_PRECISION (mode))\n \t{"}, {"sha": "658f20360f786cd8ff44133574083c4021b6297a", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -2294,10 +2294,6 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \n   desc->const_iter = false;\n   desc->niter_expr = NULL_RTX;\n-  desc->niter_max = 0;\n-  if (loop->any_upper_bound\n-      && loop->nb_iterations_upper_bound.fits_uhwi ())\n-    desc->niter_max = loop->nb_iterations_upper_bound.low;\n \n   cond = GET_CODE (condition);\n   gcc_assert (COMPARISON_P (condition));\n@@ -2567,9 +2563,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t\t\t ? iv0.base\n \t\t\t : mode_mmin);\n \t  max = (up - down) / inc + 1;\n-\t  if (!desc->niter_max\n-\t      || max < desc->niter_max)\n-\t    desc->niter_max = max;\n+\t  record_niter_bound (loop, double_int::from_shwi (max),\n+\t\t\t      false, true);\n \n \t  if (iv0.step == const0_rtx)\n \t    {\n@@ -2780,14 +2775,16 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       unsigned HOST_WIDEST_INT val = INTVAL (desc->niter_expr);\n \n       desc->const_iter = true;\n-      desc->niter_max = desc->niter = val & GET_MODE_MASK (desc->mode);\n+      desc->niter = val & GET_MODE_MASK (desc->mode);\n+      record_niter_bound (loop, double_int::from_shwi (desc->niter),\n+\t\t\t  false, true);\n     }\n   else\n     {\n       max = determine_max_iter (loop, desc, old_niter);\n-      if (!desc->niter_max\n-\t  || max < desc->niter_max)\n-\tdesc->niter_max = max;\n+      gcc_assert (max);\n+      record_niter_bound (loop, double_int::from_shwi (max),\n+\t\t\t  false, true);\n \n       /* simplify_using_initial_values does a copy propagation on the registers\n \t in the expression for the number of iterations.  This prolongs life\n@@ -2812,7 +2809,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n zero_iter:\n   desc->const_iter = true;\n   desc->niter = 0;\n-  desc->niter_max = 0;\n+  record_niter_bound (loop, double_int_zero,\n+\t\t      true, true);\n   desc->noloop_assumptions = NULL_RTX;\n   desc->niter_expr = const0_rtx;\n   return;\n@@ -2946,9 +2944,10 @@ find_simple_exit (struct loop *loop, struct niter_desc *desc)\n \t  print_rtl (dump_file, desc->niter_expr);\n       \t  fprintf (dump_file, \"\\n\");\n \n-\t  fprintf (dump_file, \"  upper bound: \");\n-\t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, desc->niter_max);\n-      \t  fprintf (dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"  upper bound: %li\\n\",\n+\t\t   (long)max_loop_iterations_int (loop));\n+\t  fprintf (dump_file, \"  realistic bound: %li\\n\",\n+\t\t   (long)estimated_loop_iterations_int (loop));\n \t}\n       else\n \tfprintf (dump_file, \"Loop %d is not simple.\\n\", loop->num);"}, {"sha": "b9ac22b825526046ef86edccccf80c1da9d3de72", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 65, "deletions": 18, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -341,7 +341,8 @@ decide_peel_once_rolling (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n       || desc->assumptions\n       || desc->infinite\n       || !desc->const_iter\n-      || desc->niter != 0)\n+      || (desc->niter != 0\n+\t  && max_loop_iterations_int (loop) != 0))\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n@@ -695,7 +696,13 @@ unroll_loop_constant_iterations (struct loop *loop)\n \n \t  desc->noloop_assumptions = NULL_RTX;\n \t  desc->niter -= exit_mod;\n-\t  desc->niter_max -= exit_mod;\n+\t  loop->nb_iterations_upper_bound -= double_int::from_uhwi (exit_mod);\n+\t  if (loop->any_estimate\n+\t      && double_int::from_uhwi (exit_mod).ule\n+\t           (loop->nb_iterations_estimate))\n+\t    loop->nb_iterations_estimate -= double_int::from_uhwi (exit_mod);\n+\t  else\n+\t    loop->any_estimate = false;\n \t}\n \n       SET_BIT (wont_exit, 1);\n@@ -733,7 +740,12 @@ unroll_loop_constant_iterations (struct loop *loop)\n   \t    apply_opt_in_copies (opt_info, exit_mod + 1, false, false);\n \n \t  desc->niter -= exit_mod + 1;\n-\t  desc->niter_max -= exit_mod + 1;\n+\t  if (loop->any_estimate\n+\t      && double_int::from_uhwi (exit_mod + 1).ule\n+\t           (loop->nb_iterations_estimate))\n+\t    loop->nb_iterations_estimate -= double_int::from_uhwi (exit_mod + 1);\n+\t  else\n+\t    loop->any_estimate = false;\n \t  desc->noloop_assumptions = NULL_RTX;\n \n \t  SET_BIT (wont_exit, 0);\n@@ -782,7 +794,15 @@ unroll_loop_constant_iterations (struct loop *loop)\n     }\n \n   desc->niter /= max_unroll + 1;\n-  desc->niter_max /= max_unroll + 1;\n+  loop->nb_iterations_upper_bound\n+    = loop->nb_iterations_upper_bound.udiv (double_int::from_uhwi (exit_mod\n+\t\t\t\t\t\t\t\t   + 1),\n+\t\t\t\t\t    FLOOR_DIV_EXPR);\n+  if (loop->any_estimate)\n+    loop->nb_iterations_estimate\n+      = loop->nb_iterations_estimate.udiv (double_int::from_uhwi (exit_mod\n+\t\t\t\t\t\t\t          + 1),\n+\t\t\t\t           FLOOR_DIV_EXPR);\n   desc->niter_expr = GEN_INT (desc->niter);\n \n   /* Remove the edges.  */\n@@ -803,6 +823,7 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n   struct niter_desc *desc;\n+  double_int iterations;\n \n   if (!(flags & UAP_UNROLL))\n     {\n@@ -856,9 +877,10 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n     }\n \n   /* If we have profile feedback, check whether the loop rolls.  */\n-  if ((loop->header->count\n-       && expected_loop_iterations (loop) < 2 * nunroll)\n-      || desc->niter_max < 2 * nunroll)\n+  if ((estimated_loop_iterations (loop, &iterations)\n+       || max_loop_iterations (loop, &iterations))\n+      && iterations.fits_shwi ()\n+      && iterations.to_shwi () <= 2 * nunroll)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n@@ -1092,6 +1114,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       single_pred_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n \t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);\n+      e->count = RDIV (preheader->count * REG_BR_PROB_BASE, p);\n       e->probability = p;\n     }\n \n@@ -1111,6 +1134,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       single_succ_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n \t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);\n+      e->count = RDIV (preheader->count * REG_BR_PROB_BASE, p);\n       e->probability = p;\n     }\n \n@@ -1172,13 +1196,26 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   desc->niter_expr =\n     simplify_gen_binary (UDIV, desc->mode, old_niter,\n \t\t\t GEN_INT (max_unroll + 1));\n-  desc->niter_max /= max_unroll + 1;\n+  loop->nb_iterations_upper_bound\n+    = loop->nb_iterations_upper_bound.udiv (double_int::from_uhwi (max_unroll\n+\t\t\t\t\t\t\t\t   + 1),\n+\t\t\t\t\t    FLOOR_DIV_EXPR);\n+  if (loop->any_estimate)\n+    loop->nb_iterations_estimate\n+      = loop->nb_iterations_estimate.udiv (double_int::from_uhwi (max_unroll\n+\t\t\t\t\t\t\t          + 1),\n+\t\t\t\t           FLOOR_DIV_EXPR);\n   if (exit_at_end)\n     {\n       desc->niter_expr =\n \tsimplify_gen_binary (MINUS, desc->mode, desc->niter_expr, const1_rtx);\n       desc->noloop_assumptions = NULL_RTX;\n-      desc->niter_max--;\n+      --loop->nb_iterations_upper_bound;\n+      if (loop->any_estimate\n+\t  && loop->nb_iterations_estimate != double_int_zero)\n+\t--loop->nb_iterations_estimate;\n+      else\n+\tloop->any_estimate = false;\n     }\n \n   if (dump_file)\n@@ -1196,6 +1233,7 @@ decide_peel_simple (struct loop *loop, int flags)\n {\n   unsigned npeel;\n   struct niter_desc *desc;\n+  double_int iterations;\n \n   if (!(flags & UAP_PEEL))\n     {\n@@ -1239,23 +1277,30 @@ decide_peel_simple (struct loop *loop, int flags)\n       return;\n     }\n \n-  if (loop->header->count)\n+  /* If we have realistic estimate on number of iterations, use it.  */\n+  if (estimated_loop_iterations (loop, &iterations))\n     {\n-      unsigned niter = expected_loop_iterations (loop);\n-      if (niter + 1 > npeel)\n+      if (!iterations.fits_shwi ()\n+\t  || iterations.to_shwi () + 1 > npeel)\n \t{\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \";; Not peeling loop, rolls too much (\");\n \t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n-\t\t       (HOST_WIDEST_INT) (niter + 1));\n+\t\t       (HOST_WIDEST_INT) (iterations.to_shwi () + 1));\n \t      fprintf (dump_file, \" iterations > %d [maximum peelings])\\n\",\n \t\t       npeel);\n \t    }\n \t  return;\n \t}\n-      npeel = niter + 1;\n-    }\n+      npeel = iterations.to_shwi () + 1;\n+    }\n+  /* If we have small enough bound on iterations, we can still peel (completely\n+     unroll).  */\n+  else if (max_loop_iterations (loop, &iterations)\n+           && iterations.fits_shwi ()\n+           && iterations.to_shwi () + 1 <= npeel)\n+    npeel = iterations.to_shwi () + 1;\n   else\n     {\n       /* For now we have no good heuristics to decide whether loop peeling\n@@ -1349,6 +1394,7 @@ decide_unroll_stupid (struct loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n   struct niter_desc *desc;\n+  double_int iterations;\n \n   if (!(flags & UAP_UNROLL_ALL))\n     {\n@@ -1401,9 +1447,10 @@ decide_unroll_stupid (struct loop *loop, int flags)\n     }\n \n   /* If we have profile feedback, check whether the loop rolls.  */\n-  if ((loop->header->count\n-       && expected_loop_iterations (loop) < 2 * nunroll)\n-      || desc->niter_max < 2 * nunroll)\n+  if ((estimated_loop_iterations (loop, &iterations)\n+       || max_loop_iterations (loop, &iterations))\n+      && iterations.fits_shwi ()\n+      && iterations.to_shwi () <= 2 * nunroll)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unrolling loop, doesn't roll\\n\");"}, {"sha": "4107048de0192305e1dc3fec71bdd22f9108ce66", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -257,6 +257,7 @@ unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n   rtx cond, rcond = NULL_RTX, conds, rconds, acond, cinsn;\n   int repeat;\n   edge e;\n+  HOST_WIDE_INT iterations;\n \n   /* Do not unswitch too much.  */\n   if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n@@ -299,7 +300,8 @@ unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n     }\n \n   /* Nor if the loop usually does not roll.  */\n-  if (expected_loop_iterations (loop) < 1)\n+  iterations = estimated_loop_iterations_int (loop);\n+  if (iterations >= 0 && iterations <= 1)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unswitching, loop iterations < 1\\n\");"}, {"sha": "325654bac1b9ed6eab7a6ad0aaa99eaa725e0540", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -3124,6 +3124,14 @@ scev_initialize (void)\n     }\n }\n \n+/* Return true if SCEV is initialized.  */\n+\n+bool\n+scev_initialized_p (void)\n+{\n+  return scalar_evolution_info != NULL;\n+}\n+\n /* Cleans up the information cached by the scalar evolutions analysis\n    in the hash table.  */\n "}, {"sha": "3e52c57e393dc9a8b318a7b2e92aef4e5e8b9556", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -27,6 +27,7 @@ extern tree number_of_exit_cond_executions (struct loop *);\n extern gimple get_loop_exit_condition (const struct loop *);\n \n extern void scev_initialize (void);\n+extern bool scev_initialized_p (void);\n extern void scev_reset (void);\n extern void scev_reset_htab (void);\n extern void scev_finalize (void);"}, {"sha": "cdcdb5c5ad8e116c18182af48f3846a93f5ba943", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -3012,9 +3012,23 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n bool\n estimated_loop_iterations (struct loop *loop, double_int *nit)\n {\n-  estimate_numbers_of_iterations_loop (loop);\n+  /* When SCEV information is available, try to update loop iterations\n+     estimate.  Otherwise just return whatever we recorded earlier.  */\n+  if (scev_initialized_p ())\n+    estimate_numbers_of_iterations_loop (loop);\n+\n+  /* Even if the bound is not recorded, possibly we can derrive one from\n+     profile.  */\n   if (!loop->any_estimate)\n-    return false;\n+    {\n+      if (loop->header->count)\n+\t{\n+          *nit = gcov_type_to_double_int\n+\t\t   (expected_loop_iterations_unbounded (loop) + 1);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n \n   *nit = loop->nb_iterations_estimate;\n   return true;\n@@ -3027,7 +3041,10 @@ estimated_loop_iterations (struct loop *loop, double_int *nit)\n bool\n max_loop_iterations (struct loop *loop, double_int *nit)\n {\n-  estimate_numbers_of_iterations_loop (loop);\n+  /* When SCEV information is available, try to update loop iterations\n+     estimate.  Otherwise just return whatever we recorded earlier.  */\n+  if (scev_initialized_p ())\n+    estimate_numbers_of_iterations_loop (loop);\n   if (!loop->any_upper_bound)\n     return false;\n "}, {"sha": "b24f3d74dceeff432420a7b413574fade6f843d2", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a8f1fa88d6d87444489c5cf8100aeb09bfb179/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=e3a8f1fa88d6d87444489c5cf8100aeb09bfb179", "patch": "@@ -78,6 +78,7 @@ tree_ssa_unswitch_loops (void)\n   loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n+  HOST_WIDE_INT iterations;\n \n   /* Go through inner loops (only original ones).  */\n   FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n@@ -102,6 +103,16 @@ tree_ssa_unswitch_loops (void)\n           continue;\n         }\n \n+      /* If the loop is not expected to iterate, there is no need\n+\t for unswitching.  */\n+      iterations = estimated_loop_iterations_int (loop);\n+      if (iterations >= 0 && iterations <= 1)\n+\t{\n+          if (dump_file && (dump_flags & TDF_DETAILS))\n+            fprintf (dump_file, \";; Not unswitching, loop is not expected to iterate\\n\");\n+          continue;\n+\t}\n+\n       changed |= tree_unswitch_single_loop (loop, 0);\n     }\n "}]}