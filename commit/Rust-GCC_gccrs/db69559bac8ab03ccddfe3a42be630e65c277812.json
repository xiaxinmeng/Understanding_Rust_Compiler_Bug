{"sha": "db69559bac8ab03ccddfe3a42be630e65c277812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI2OTU1OWJhYzhhYjAzY2NkZGZlM2E0MmJlNjMwZTY1YzI3NzgxMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-04T07:30:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-04T07:30:53Z"}, "message": "PR82045: Avoid passing machine modes through \"...\"\n\nPR82045 is about a bootstrap failure on sparc-sun-solaris2.11.\nThe problem was that we were passing the new machine_mode wrapper\nclasses through \"...\"  to emit_library_call(_value), which then\nread them back as ints instead.\n\nThe simplest fix seemed to be replace \"...\" with an array of\nrtx_mode_ts, then provide wrappers for the common cases.  This\nbulks out rtl.h a bit, but it does make things a bit more typesafe.\n\n2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR bootstrap/82045\n\t* rtl.h (emit_library_call_value_1): Declare.\n\t(emit_library_call): Replace declaration with a series of overloads.\n\tRemove the parameter count argument.\n\t(emit_library_call_value): Likewise.\n\t* calls.c (emit_library_call_value_1): Make global.  Replace varargs\n\twith an \"rtx_mode_t *\".\n\t(emit_library_call_value): Delete.\n\t(emit_library_call): Likewise.\n\t* asan.c (asan_emit_stack_protection): Update calls accordingly.\n\t(asan_emit_allocas_unpoison): Likewise.\n\t* builtins.c (expand_builtin_powi): Likewise.\n\t(expand_asan_emit_allocas_unpoison): Likewise.\n\t* cfgexpand.c (expand_main_function): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_trampoline_init): Likewise.\n\t* config/aarch64/aarch64.h (PROFILE_HOOK): Likewise.\n\t* config/alpha/alpha.c (alpha_trampoline_init): Likewise.\n\t* config/arm/arm.c (arm_trampoline_init): Likewise.\n\t(arm_call_tls_get_addr): Likewise.\n\t(arm_expand_divmod_libfunc): Likewise.\n\t* config/bfin/bfin.md (umulsi3_highpart): Likewise.\n\t(smulsi3_highpart): Likewise.\n\t* config/c6x/c6x.c (c6x_initialize_trampoline): Likewise.\n\t(c6x_expand_compare): Likewise.\n\t(c6x_expand_movmem): Likewise.\n\t* config/frv/frv.c (frv_trampoline_init): Likewise.\n\t* config/i386/i386.c (ix86_trampoline_init): Likewise.\n\t(ix86_expand_divmod_libfunc): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_tls_address): Likewise.\n\t(ia64_expand_compare): Likewise.\n\t(ia64_profile_hook): Likewise.\n\t* config/ia64/ia64.md (save_stack_nonlocal): Likewise.\n\t(nonlocal_goto): Likewise.\n\t(restore_stack_nonlocal): Likewise.\n\t* config/m32r/m32r.c (block_move_call): Likewise.\n\t(m32r_trampoline_init): Likewise.\n\t* config/m68k/linux.h (FINALIZE_TRAMPOLINE): Likewise.\n\t* config/m68k/m68k.c (m68k_call_tls_get_addr): Likewise.\n\t(m68k_call_m68k_read_tp): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_call_tls_get_addr)\n\t(microblaze_expand_divide): Likewise.\n\t* config/mips/mips.h (mips_args): Likewise.\n\t* config/mips/sdemtk.h (mips_sync_icache): Likewise.\n\t(MIPS_ICACHE_SYNC): Likewise.\n\t* config/nios2/nios2.c (nios2_emit_expensive_div): Likewise.\n\t(nios2_trampoline_init): Likewise.\n\t* config/pa/pa.c (hppa_tls_call): Likewise.\n\t(pa_trampoline_init): Likewise.\n\t* config/pa/pa.md (canonicalize_funcptr_for_compare): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_legitimize_tls_address)\n\t(expand_strn_compare): Likewise.\n\t(rs6000_generate_compare): Likewise.\n\t(rs6000_expand_float128_convert): Likewise.\n\t(output_profile_hook): Likewise.\n\t(rs6000_trampoline_init): Likewise.\n\t* config/powerpcspe/powerpcspe.md (neg<mode>2): Likewise.\n\t* config/riscv/riscv.h (PROFILE_HOOK): Likewise.\n\t* config/rs6000/rs6000-string.c (expand_strn_compare): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_legitimize_tls_address): Likewise.\n\t(rs6000_generate_compare): Likewise.\n\t(rs6000_expand_float128_convert): Likewise.\n\t(output_profile_hook): Likewise.\n\t(rs6000_trampoline_init): Likewise.\n\t* config/rs6000/rs6000.md (neg<mode>2): Likewise.\n\t* config/sh/sh.c (sh_trampoline_init): Likewise.\n\t* config/sparc/sparc.c (emit_soft_tfmode_libcall): Likewise.\n\t(sparc_emit_float_lib_cmp): Likewise.\n\t(sparc32_initialize_trampoline): Likewise.\n\t(sparc64_initialize_trampoline): Likewise.\n\t(sparc_profile_hook): Likewise.\n\t* config/spu/spu.c (ea_load_store): Likewise.\n\t* config/spu/spu.md (floatunssidf2): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_trampoline_init): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_trampoline_init): Likewise.\n\t* config/visium/visium.c (expand_block_move_4): Likewise.\n\t(expand_block_move_2): Likewise.\n\t(expand_block_move_1): Likewise.\n\t(expand_block_set_4): Likewise.\n\t(expand_block_set_2): Likewise.\n\t(expand_block_set_1): Likewise.\n\t(visium_trampoline_init): Likewise.\n\t(visium_profile_hook): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_expand_nonlocal_goto): Likewise.\n\t(xtensa_setup_frame_addresses): Likewise.\n\t(xtensa_trampoline_init): Likewise.\n\t* except.c (sjlj_emit_function_enter): Likewise.\n\t(sjlj_emit_function_exit): Likewise.\n\t* explow.c (allocate_dynamic_stack_space): Likewise.\n\t(probe_stack_range): Likewise.\n\t* expr.c (convert_mode_scalar): Likewise.\n\t* optabs.c (expand_binop): Likewise.\n\t(expand_twoval_binop_libfunc): Likewise.\n\t(expand_unop): Likewise.\n\t(prepare_cmp_insn): Likewise.\n\t(prepare_float_lib_cmp): Likewise.\n\t(expand_float): Likewise.\n\t(expand_fix): Likewise.\n\t(expand_fixed_convert): Likewise.\n\t(maybe_emit_sync_lock_test_and_set): Likewise.\n\t(expand_atomic_compare_and_swap): Likewise.\n\t(expand_mem_thread_fence): Likewise.\n\t(expand_atomic_fetch_op): Likewise.\n\nFrom-SVN: r251637", "tree": {"sha": "2cf080b045129f4dea972ab956100f6ec25bddbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cf080b045129f4dea972ab956100f6ec25bddbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db69559bac8ab03ccddfe3a42be630e65c277812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db69559bac8ab03ccddfe3a42be630e65c277812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db69559bac8ab03ccddfe3a42be630e65c277812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db69559bac8ab03ccddfe3a42be630e65c277812/comments", "author": null, "committer": null, "parents": [{"sha": "77701e2346bee936056ff33e1a94b214e359b4d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77701e2346bee936056ff33e1a94b214e359b4d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77701e2346bee936056ff33e1a94b214e359b4d2"}], "stats": {"total": 586, "additions": 387, "deletions": 199}, "files": [{"sha": "a1bdd8593b33268b3803a7f36ddc8777cc90da3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1,3 +1,108 @@\n+2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR bootstrap/82045\n+\t* rtl.h (emit_library_call_value_1): Declare.\n+\t(emit_library_call): Replace declaration with a series of overloads.\n+\tRemove the parameter count argument.\n+\t(emit_library_call_value): Likewise.\n+\t* calls.c (emit_library_call_value_1): Make global.  Replace varargs\n+\twith an \"rtx_mode_t *\".\n+\t(emit_library_call_value): Delete.\n+\t(emit_library_call): Likewise.\n+\t* asan.c (asan_emit_stack_protection): Update calls accordingly.\n+\t(asan_emit_allocas_unpoison): Likewise.\n+\t* builtins.c (expand_builtin_powi): Likewise.\n+\t(expand_asan_emit_allocas_unpoison): Likewise.\n+\t* cfgexpand.c (expand_main_function): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_trampoline_init): Likewise.\n+\t* config/aarch64/aarch64.h (PROFILE_HOOK): Likewise.\n+\t* config/alpha/alpha.c (alpha_trampoline_init): Likewise.\n+\t* config/arm/arm.c (arm_trampoline_init): Likewise.\n+\t(arm_call_tls_get_addr): Likewise.\n+\t(arm_expand_divmod_libfunc): Likewise.\n+\t* config/bfin/bfin.md (umulsi3_highpart): Likewise.\n+\t(smulsi3_highpart): Likewise.\n+\t* config/c6x/c6x.c (c6x_initialize_trampoline): Likewise.\n+\t(c6x_expand_compare): Likewise.\n+\t(c6x_expand_movmem): Likewise.\n+\t* config/frv/frv.c (frv_trampoline_init): Likewise.\n+\t* config/i386/i386.c (ix86_trampoline_init): Likewise.\n+\t(ix86_expand_divmod_libfunc): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_tls_address): Likewise.\n+\t(ia64_expand_compare): Likewise.\n+\t(ia64_profile_hook): Likewise.\n+\t* config/ia64/ia64.md (save_stack_nonlocal): Likewise.\n+\t(nonlocal_goto): Likewise.\n+\t(restore_stack_nonlocal): Likewise.\n+\t* config/m32r/m32r.c (block_move_call): Likewise.\n+\t(m32r_trampoline_init): Likewise.\n+\t* config/m68k/linux.h (FINALIZE_TRAMPOLINE): Likewise.\n+\t* config/m68k/m68k.c (m68k_call_tls_get_addr): Likewise.\n+\t(m68k_call_m68k_read_tp): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_call_tls_get_addr)\n+\t(microblaze_expand_divide): Likewise.\n+\t* config/mips/mips.h (mips_args): Likewise.\n+\t* config/mips/sdemtk.h (mips_sync_icache): Likewise.\n+\t(MIPS_ICACHE_SYNC): Likewise.\n+\t* config/nios2/nios2.c (nios2_emit_expensive_div): Likewise.\n+\t(nios2_trampoline_init): Likewise.\n+\t* config/pa/pa.c (hppa_tls_call): Likewise.\n+\t(pa_trampoline_init): Likewise.\n+\t* config/pa/pa.md (canonicalize_funcptr_for_compare): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_legitimize_tls_address)\n+\t(expand_strn_compare): Likewise.\n+\t(rs6000_generate_compare): Likewise.\n+\t(rs6000_expand_float128_convert): Likewise.\n+\t(output_profile_hook): Likewise.\n+\t(rs6000_trampoline_init): Likewise.\n+\t* config/powerpcspe/powerpcspe.md (neg<mode>2): Likewise.\n+\t* config/riscv/riscv.h (PROFILE_HOOK): Likewise.\n+\t* config/rs6000/rs6000-string.c (expand_strn_compare): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_tls_address): Likewise.\n+\t(rs6000_generate_compare): Likewise.\n+\t(rs6000_expand_float128_convert): Likewise.\n+\t(output_profile_hook): Likewise.\n+\t(rs6000_trampoline_init): Likewise.\n+\t* config/rs6000/rs6000.md (neg<mode>2): Likewise.\n+\t* config/sh/sh.c (sh_trampoline_init): Likewise.\n+\t* config/sparc/sparc.c (emit_soft_tfmode_libcall): Likewise.\n+\t(sparc_emit_float_lib_cmp): Likewise.\n+\t(sparc32_initialize_trampoline): Likewise.\n+\t(sparc64_initialize_trampoline): Likewise.\n+\t(sparc_profile_hook): Likewise.\n+\t* config/spu/spu.c (ea_load_store): Likewise.\n+\t* config/spu/spu.md (floatunssidf2): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_trampoline_init): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_trampoline_init): Likewise.\n+\t* config/visium/visium.c (expand_block_move_4): Likewise.\n+\t(expand_block_move_2): Likewise.\n+\t(expand_block_move_1): Likewise.\n+\t(expand_block_set_4): Likewise.\n+\t(expand_block_set_2): Likewise.\n+\t(expand_block_set_1): Likewise.\n+\t(visium_trampoline_init): Likewise.\n+\t(visium_profile_hook): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_expand_nonlocal_goto): Likewise.\n+\t(xtensa_setup_frame_addresses): Likewise.\n+\t(xtensa_trampoline_init): Likewise.\n+\t* except.c (sjlj_emit_function_enter): Likewise.\n+\t(sjlj_emit_function_exit): Likewise.\n+\t* explow.c (allocate_dynamic_stack_space): Likewise.\n+\t(probe_stack_range): Likewise.\n+\t* expr.c (convert_mode_scalar): Likewise.\n+\t* optabs.c (expand_binop): Likewise.\n+\t(expand_twoval_binop_libfunc): Likewise.\n+\t(expand_unop): Likewise.\n+\t(prepare_cmp_insn): Likewise.\n+\t(prepare_float_lib_cmp): Likewise.\n+\t(expand_float): Likewise.\n+\t(expand_fix): Likewise.\n+\t(expand_fixed_convert): Likewise.\n+\t(maybe_emit_sync_lock_test_and_set): Likewise.\n+\t(expand_atomic_compare_and_swap): Likewise.\n+\t(expand_mem_thread_fence): Likewise.\n+\t(expand_atomic_fetch_op): Likewise.\n+\n 2017-09-03  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/generic.texi (OpenACC): Adjust URL."}, {"sha": "bebacd6c390c422980c3db30ceeea0f0d3af2066", "filename": "gcc/asan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1347,7 +1347,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n       snprintf (buf, sizeof buf, \"__asan_stack_malloc_%d\",\n \t\tuse_after_return_class);\n       ret = init_one_libfunc (buf);\n-      ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode, 1,\n+      ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode,\n \t\t\t\t     GEN_INT (asan_frame_size\n \t\t\t\t\t      + base_align_bias),\n \t\t\t\t     TYPE_MODE (pointer_sized_int_node));\n@@ -1477,7 +1477,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n \t  ret = init_one_libfunc (buf);\n \t  rtx addr = convert_memory_address (ptr_mode, base);\n \t  rtx orig_addr = convert_memory_address (ptr_mode, orig_base);\n-\t  emit_library_call (ret, LCT_NORMAL, ptr_mode, 3, addr, ptr_mode,\n+\t  emit_library_call (ret, LCT_NORMAL, ptr_mode, addr, ptr_mode,\n \t\t\t     GEN_INT (asan_frame_size + base_align_bias),\n \t\t\t     TYPE_MODE (pointer_sized_int_node),\n \t\t\t     orig_addr, ptr_mode);\n@@ -1573,8 +1573,8 @@ asan_emit_allocas_unpoison (rtx top, rtx bot, rtx_insn *before)\n   rtx ret = init_one_libfunc (\"__asan_allocas_unpoison\");\n   top = convert_memory_address (ptr_mode, top);\n   bot = convert_memory_address (ptr_mode, bot);\n-  ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode, 2, top,\n-\t\t\t\t ptr_mode, bot, ptr_mode);\n+  ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode,\n+\t\t\t\t top, ptr_mode, bot, ptr_mode);\n \n   do_pending_stack_adjust ();\n   rtx_insn *insns = get_insns ();"}, {"sha": "8fd1202aca93d9572e28de06246105f199f9dda2", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -2768,7 +2768,7 @@ expand_builtin_powi (tree exp, rtx target)\n     op1 = convert_to_mode (mode2, op1, 0);\n \n   target = emit_library_call_value (optab_libfunc (powi_optab, mode),\n-\t\t\t\t    target, LCT_CONST, mode, 2,\n+\t\t\t\t    target, LCT_CONST, mode,\n \t\t\t\t    op0, mode, op1, mode2);\n \n   return target;\n@@ -4909,8 +4909,8 @@ expand_asan_emit_allocas_unpoison (tree exp)\n   rtx top = expand_expr (arg0, NULL_RTX, ptr_mode, EXPAND_NORMAL);\n   rtx bot = convert_memory_address (ptr_mode, virtual_stack_dynamic_rtx);\n   rtx ret = init_one_libfunc (\"__asan_allocas_unpoison\");\n-  ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode, 2, top,\n-\t\t\t\t ptr_mode, bot, ptr_mode);\n+  ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode,\n+\t\t\t\t top, ptr_mode, bot, ptr_mode);\n   return ret;\n }\n "}, {"sha": "4b34ab23bb4787c514da45077b9c20139b38202f", "filename": "gcc/calls.c", "status": "modified", "additions": 15, "deletions": 55, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -164,8 +164,6 @@ static void compute_argument_addresses (struct arg_data *, rtx, int);\n static rtx rtx_for_function_call (tree, tree);\n static void load_register_parameters (struct arg_data *, int, rtx *, int,\n \t\t\t\t      int, int *);\n-static rtx emit_library_call_value_1 (int, rtx, rtx, enum libcall_type,\n-\t\t\t\t      machine_mode, int, va_list);\n static int special_function_p (const_tree, int);\n static int check_sibcall_argument_overlap_1 (rtx);\n static int check_sibcall_argument_overlap (rtx_insn *, struct arg_data *, int);\n@@ -4364,14 +4362,21 @@ split_complex_types (tree types)\n   return types;\n }\n \f\n-/* Output a library call to function FUN (a SYMBOL_REF rtx).\n-   The RETVAL parameter specifies whether return value needs to be saved, other\n-   parameters are documented in the emit_library_call function below.  */\n+/* Output a library call to function ORGFUN (a SYMBOL_REF rtx)\n+   for a value of mode OUTMODE,\n+   with NARGS different arguments, passed as ARGS.\n+   Store the return value if RETVAL is nonzero: store it in VALUE if\n+   VALUE is nonnull, otherwise pick a convenient location.  In either\n+   case return the location of the stored value.\n \n-static rtx\n+   FN_TYPE should be LCT_NORMAL for `normal' calls, LCT_CONST for\n+   `const' calls, LCT_PURE for `pure' calls, or another LCT_ value for\n+   other types of library calls.  */\n+\n+rtx\n emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t\t   enum libcall_type fn_type,\n-\t\t\t   machine_mode outmode, int nargs, va_list p)\n+\t\t\t   machine_mode outmode, int nargs, rtx_mode_t *args)\n {\n   /* Total size in bytes of all the stack-parms scanned so far.  */\n   struct args_size args_size;\n@@ -4553,10 +4558,10 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       count++;\n     }\n \n-  for (; count < nargs; count++)\n+  for (unsigned int i = 0; count < nargs; i++, count++)\n     {\n-      rtx val = va_arg (p, rtx);\n-      machine_mode mode = (machine_mode) va_arg (p, int);\n+      rtx val = args[i].first;\n+      machine_mode mode = args[i].second;\n       int unsigned_p = 0;\n \n       /* We cannot convert the arg value to the mode the library wants here;\n@@ -5128,51 +5133,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n }\n \f\n-/* Output a library call to function FUN (a SYMBOL_REF rtx)\n-   (emitting the queue unless NO_QUEUE is nonzero),\n-   for a value of mode OUTMODE,\n-   with NARGS different arguments, passed as alternating rtx values\n-   and machine_modes to convert them to.\n-\n-   FN_TYPE should be LCT_NORMAL for `normal' calls, LCT_CONST for\n-   `const' calls, LCT_PURE for `pure' calls, or other LCT_ value for\n-   other types of library calls.  */\n-\n-void\n-emit_library_call (rtx orgfun, enum libcall_type fn_type,\n-\t\t   machine_mode outmode, int nargs, ...)\n-{\n-  va_list p;\n-\n-  va_start (p, nargs);\n-  emit_library_call_value_1 (0, orgfun, NULL_RTX, fn_type, outmode, nargs, p);\n-  va_end (p);\n-}\n-\f\n-/* Like emit_library_call except that an extra argument, VALUE,\n-   comes second and says where to store the result.\n-   (If VALUE is zero, this function chooses a convenient way\n-   to return the value.\n-\n-   This function returns an rtx for where the value is to be found.\n-   If VALUE is nonzero, VALUE is returned.  */\n-\n-rtx\n-emit_library_call_value (rtx orgfun, rtx value,\n-\t\t\t enum libcall_type fn_type,\n-\t\t\t machine_mode outmode, int nargs, ...)\n-{\n-  rtx result;\n-  va_list p;\n-\n-  va_start (p, nargs);\n-  result = emit_library_call_value_1 (1, orgfun, value, fn_type, outmode,\n-\t\t\t\t      nargs, p);\n-  va_end (p);\n-\n-  return result;\n-}\n-\f\n \n /* Store pointer bounds argument ARG  into Bounds Table entry\n    associated with PARM.  */"}, {"sha": "7657a65ec895fac492613d838b09545f136123ec", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -6079,7 +6079,7 @@ expand_main_function (void)\n      || (!defined(HAS_INIT_SECTION)\t\t\t\\\n \t && !defined(INIT_SECTION_ASM_OP)\t\t\\\n \t && !defined(INIT_ARRAY_SECTION_ASM_OP)))\n-  emit_library_call (init_one_libfunc (NAME__MAIN), LCT_NORMAL, VOIDmode, 0);\n+  emit_library_call (init_one_libfunc (NAME__MAIN), LCT_NORMAL, VOIDmode);\n #endif\n }\n \f"}, {"sha": "fe5b59c3a707f947d3fbd9ee8de2ed8da54a03b4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -5977,7 +5977,7 @@ aarch64_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n      gen_clear_cache().  */\n   a_tramp = XEXP (m_tramp, 0);\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\n-\t\t     LCT_NORMAL, VOIDmode, 2, a_tramp, ptr_mode,\n+\t\t     LCT_NORMAL, VOIDmode, a_tramp, ptr_mode,\n \t\t     plus_constant (ptr_mode, a_tramp, TRAMPOLINE_SIZE),\n \t\t     ptr_mode);\n }"}, {"sha": "a6e0479cd09e550560c4fd2298645951a1983851", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -857,7 +857,7 @@ typedef struct\n     rtx fun, lr;\t\t\t\t\t\t\t\\\n     lr = get_hard_reg_initial_val (Pmode, LR_REGNUM);\t\t\t\\\n     fun = gen_rtx_SYMBOL_REF (Pmode, MCOUNT_NAME);\t\t\t\\\n-    emit_library_call (fun, LCT_NORMAL, VOIDmode, 1, lr, Pmode);\t\\\n+    emit_library_call (fun, LCT_NORMAL, VOIDmode, lr, Pmode);\t\t\\\n   }\n \n /* All the work done in PROFILE_HOOK, but still required.  */"}, {"sha": "cbcfc0151653c02d1359f013aeb0071260abdeff", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -5562,7 +5562,7 @@ alpha_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n       emit_insn (gen_imb ());\n #ifdef HAVE_ENABLE_EXECUTE_STACK\n       emit_library_call (init_one_libfunc (\"__enable_execute_stack\"),\n-\t\t\t LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);\n+\t\t\t LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);\n #endif\n     }\n }"}, {"sha": "b27853464a55dcf22339298da30431aba900180e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -3888,7 +3888,7 @@ arm_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \n   a_tramp = XEXP (m_tramp, 0);\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\n-\t\t     LCT_NORMAL, VOIDmode, 2, a_tramp, Pmode,\n+\t\t     LCT_NORMAL, VOIDmode, a_tramp, Pmode,\n \t\t     plus_constant (Pmode, a_tramp, TRAMPOLINE_SIZE), Pmode);\n }\n \n@@ -8364,7 +8364,7 @@ arm_call_tls_get_addr (rtx x, rtx reg, rtx *valuep, int reloc)\n \n   *valuep = emit_library_call_value (get_tls_get_addr (), NULL_RTX,\n \t\t\t\t     LCT_PURE, /* LCT_CONST?  */\n-\t\t\t\t     Pmode, 1, reg, Pmode);\n+\t\t\t\t     Pmode, reg, Pmode);\n \n   rtx_insn *insns = get_insns ();\n   end_sequence ();\n@@ -31101,7 +31101,7 @@ arm_expand_divmod_libfunc (rtx libfunc, machine_mode mode,\n     = smallest_int_mode_for_size (2 * GET_MODE_BITSIZE (mode));\n \n   rtx libval = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t\tlibval_mode, 2,\n+\t\t\t\t\tlibval_mode,\n \t\t\t\t\top0, GET_MODE (op0),\n \t\t\t\t\top1, GET_MODE (op1));\n "}, {"sha": "1b7f6fed04a10be891fe30049ec5e34b668bd3ba", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1578,7 +1578,7 @@\n \n       emit_library_call_value (umulsi3_highpart_libfunc,\n \t\t\t       operands[0], LCT_NORMAL, SImode,\n-\t\t\t       2, operands[1], SImode, operands[2], SImode);\n+\t\t\t       operands[1], SImode, operands[2], SImode);\n     }\n   DONE;\n })\n@@ -1628,7 +1628,7 @@\n \n       emit_library_call_value (smulsi3_highpart_libfunc,\n \t\t\t       operands[0], LCT_NORMAL, SImode,\n-\t\t\t       2, operands[1], SImode, operands[2], SImode);\n+\t\t\t       operands[1], SImode, operands[2], SImode);\n     }\n   DONE;\n })"}, {"sha": "4671f3c3cce0b9a0784269a3b2e2e1975a923797", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -739,9 +739,8 @@ c6x_initialize_trampoline (rtx tramp, tree fndecl, rtx cxt)\n #ifdef CLEAR_INSN_CACHE\n   tramp = XEXP (tramp, 0);\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__gnu_clear_cache\"),\n-\t\t     LCT_NORMAL, VOIDmode, 2, tramp, Pmode,\n-\t\t     plus_constant (Pmode, tramp, TRAMPOLINE_SIZE),\n-\t\t     Pmode);\n+\t\t     LCT_NORMAL, VOIDmode, tramp, Pmode,\n+\t\t     plus_constant (Pmode, tramp, TRAMPOLINE_SIZE), Pmode);\n #endif\n }\n \f\n@@ -1592,7 +1591,7 @@ c6x_expand_compare (rtx comparison, machine_mode mode)\n \t    }\n \t  start_sequence ();\n \n-\t  cmp = emit_library_call_value (libfunc, 0, LCT_CONST, SImode, 2,\n+\t  cmp = emit_library_call_value (libfunc, 0, LCT_CONST, SImode,\n \t\t\t\t\t op0, op_mode, op1, op_mode);\n \t  insns = get_insns ();\n \t  end_sequence ();\n@@ -1728,7 +1727,7 @@ c6x_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \tmark_addressable (src_expr);\n       if (dst_expr)\n \tmark_addressable (dst_expr);\n-      emit_library_call (fn, LCT_NORMAL, VOIDmode, 3,\n+      emit_library_call (fn, LCT_NORMAL, VOIDmode,\n \t\t\t dstreg, Pmode, srcreg, Pmode, count_exp, SImode);\n       return true;\n     }"}, {"sha": "4e589cfc501abdd534b1fab381b992fc1009a45e", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -6241,7 +6241,7 @@ frv_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n   rtx sc_reg = force_reg (Pmode, static_chain);\n \n   emit_library_call (gen_rtx_SYMBOL_REF (SImode, \"__trampoline_setup\"),\n-\t\t     LCT_NORMAL, VOIDmode, 4,\n+\t\t     LCT_NORMAL, VOIDmode,\n \t\t     addr, Pmode,\n \t\t     GEN_INT (frv_trampoline_size ()), SImode,\n \t\t     fnaddr, Pmode,"}, {"sha": "68cb32bc9cf48ef63afecd1c9022e5ce322bb698", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -31824,7 +31824,7 @@ ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   if (CHECK_EXECUTE_STACK_ENABLED)\n #endif\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n-\t\t     LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);\n+\t\t     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);\n #endif\n }\n \n@@ -52432,10 +52432,10 @@ ix86_expand_divmod_libfunc (rtx libfunc, machine_mode mode,\n   rtx rem = assign_386_stack_local (mode, SLOT_TEMP);\n \n   rtx quot = emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,\n-\t\t\t\t    mode, 3,\n-\t\t\t\t    op0, GET_MODE (op0),\n-\t\t\t\t    op1, GET_MODE (op1),\n-\t\t\t\t    XEXP (rem, 0), Pmode);\n+\t\t\t\t      mode,\n+\t\t\t\t      op0, GET_MODE (op0),\n+\t\t\t\t      op1, GET_MODE (op1),\n+\t\t\t\t      XEXP (rem, 0), Pmode);\n   *quot_p = quot;\n   *rem_p = rem;\n }"}, {"sha": "1326877b26a18e6bab90c887f19bf8640d04d511", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1202,8 +1202,8 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1,\n       emit_insn (gen_load_dtprel (tga_op2, op1));\n \n       tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n-\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n-\t\t\t\t\t Pmode, tga_op2, Pmode);\n+\t\t\t\t\t LCT_CONST, Pmode,\n+\t\t\t\t\t tga_op1, Pmode, tga_op2, Pmode);\n \n       insns = get_insns ();\n       end_sequence ();\n@@ -1226,8 +1226,8 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1,\n       tga_op2 = const0_rtx;\n \n       tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n-\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n-\t\t\t\t\t Pmode, tga_op2, Pmode);\n+\t\t\t\t\t LCT_CONST, Pmode,\n+\t\t\t\t\t tga_op1, Pmode, tga_op2, Pmode);\n \n       insns = get_insns ();\n       end_sequence ();\n@@ -1836,7 +1836,7 @@ ia64_expand_compare (rtx *expr, rtx *op0, rtx *op1)\n \n       start_sequence ();\n \n-      ret = emit_library_call_value (cmptf_libfunc, 0, LCT_CONST, DImode, 3,\n+      ret = emit_library_call_value (cmptf_libfunc, 0, LCT_CONST, DImode,\n \t\t\t\t     *op0, TFmode, *op1, TFmode,\n \t\t\t\t     GEN_INT (magic), DImode);\n       cmp = gen_reg_rtx (BImode);\n@@ -11101,7 +11101,7 @@ ia64_profile_hook (int labelno)\n   ip = gen_reg_rtx (Pmode);\n   emit_insn (gen_ip_value (ip));\n   emit_library_call (gen_mcount_func_rtx (), LCT_NORMAL,\n-                     VOIDmode, 3,\n+                     VOIDmode,\n \t\t     gen_rtx_REG (Pmode, BR_REG (0)), Pmode,\n \t\t     ip, Pmode,\n \t\t     label, Pmode);"}, {"sha": "b7cd52ba366ba3d63e98479df5f4be44ffd17ca6", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -5056,7 +5056,7 @@\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t\t \\\"__ia64_save_stack_nonlocal\\\"),\n-\t\t     LCT_NORMAL, VOIDmode, 2, XEXP (operands[0], 0), Pmode,\n+\t\t     LCT_NORMAL, VOIDmode, XEXP (operands[0], 0), Pmode,\n \t\t     operands[1], Pmode);\n   DONE;\n })\n@@ -5069,7 +5069,7 @@\n   \"\"\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \\\"__ia64_nonlocal_goto\\\"),\n-\t\t     LCT_NORETURN, VOIDmode, 3,\n+\t\t     LCT_NORETURN, VOIDmode,\n \t\t     operands[1], Pmode,\n \t\t     copy_to_reg (XEXP (operands[2], 0)), Pmode,\n \t\t     operands[3], Pmode);\n@@ -5134,7 +5134,7 @@\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t\t \"__ia64_restore_stack_nonlocal\"),\n-\t\t     LCT_NORMAL, VOIDmode, 1,\n+\t\t     LCT_NORMAL, VOIDmode,\n \t\t     copy_to_reg (XEXP (operands[1], 0)), Pmode);\n   DONE;\n })"}, {"sha": "56d1dbddb2d0f3b6f74328a3bfb73da3b59e0411", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -2493,7 +2493,7 @@ block_move_call (rtx dest_reg, rtx src_reg, rtx bytes_rtx)\n     bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n \n   emit_library_call (m32r_function_symbol (\"memcpy\"), LCT_NORMAL,\n-\t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n+\t\t     VOIDmode, dest_reg, Pmode, src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n \t\t\t\t      TYPE_UNSIGNED (sizetype)),\n \t\t     TYPE_MODE (sizetype));\n@@ -2796,7 +2796,7 @@ m32r_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \t\tgen_int_mode (m32r_cache_flush_trap, SImode)));\n   else if (m32r_cache_flush_func && m32r_cache_flush_func[0])\n     emit_library_call (m32r_function_symbol (m32r_cache_flush_func),\n-\t\t       LCT_NORMAL, VOIDmode, 3, XEXP (m_tramp, 0), Pmode,\n+\t\t       LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode,\n \t\t       gen_int_mode (TRAMPOLINE_SIZE, SImode), SImode,\n \t\t       GEN_INT (3), SImode);\n }"}, {"sha": "5ed48b36b253a37f0cec2d962b08547002f3b050", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -192,8 +192,8 @@ along with GCC; see the file COPYING3.  If not see\n #undef FINALIZE_TRAMPOLINE\n #define FINALIZE_TRAMPOLINE(TRAMP)\t\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n-\t\t     LCT_NORMAL, VOIDmode, 2, TRAMP, Pmode,\t\t\\\n-\t\t     plus_constant (Pmode, TRAMP, TRAMPOLINE_SIZE), \\\n+\t\t     LCT_NORMAL, VOIDmode, TRAMP, Pmode,\t\t\\\n+\t\t     plus_constant (Pmode, TRAMP, TRAMPOLINE_SIZE), \t\\\n \t\t     Pmode);\n \n /* Clear the instruction cache from `beg' to `end'.  This makes an"}, {"sha": "08c7292a42cac43cca471ef6cd4cbb0ea3afbfad", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -2540,7 +2540,7 @@ m68k_call_tls_get_addr (rtx x, rtx eqv, enum m68k_reloc reloc)\n \n   m68k_libcall_value_in_a0_p = true;\n   a0 = emit_library_call_value (m68k_get_tls_get_addr (), NULL_RTX, LCT_PURE,\n-\t\t\t\tPmode, 1, x, Pmode);\n+\t\t\t\tPmode, x, Pmode);\n   m68k_libcall_value_in_a0_p = false;\n   \n   insns = get_insns ();\n@@ -2589,7 +2589,7 @@ m68k_call_m68k_read_tp (void)\n   /* Emit the call sequence.  */\n   m68k_libcall_value_in_a0_p = true;\n   a0 = emit_library_call_value (m68k_get_m68k_read_tp (), NULL_RTX, LCT_PURE,\n-\t\t\t\tPmode, 0);\n+\t\t\t\tPmode);\n   m68k_libcall_value_in_a0_p = false;\n   insns = get_insns ();\n   end_sequence ();"}, {"sha": "2a291ea81fbc9584b59696472c51e17ab1c45b7f", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -585,7 +585,7 @@ microblaze_call_tls_get_addr (rtx x, rtx reg, rtx *valuep, int reloc)\n \n   *valuep = emit_library_call_value (get_tls_get_addr (), NULL_RTX,\n                                      LCT_PURE, /* LCT_CONST?  */\n-                                     Pmode, 1, reg, Pmode);\n+                                     Pmode, reg, Pmode);\n \n   insns = get_insns ();\n   end_sequence ();\n@@ -3560,10 +3560,10 @@ microblaze_expand_divide (rtx operands[])\n \n   emit_label (div_label);\n   ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \"__divsi3\"), \n-\t\t\t\t       operands[0], LCT_NORMAL, \n-\t\t\t\t       GET_MODE (operands[0]), 2, operands[1], \n-\t\t\t\t       GET_MODE (operands[1]), operands[2], \n-\t\t\t\t       GET_MODE (operands[2]));\n+\t\t\t\t operands[0], LCT_NORMAL,\n+\t\t\t\t GET_MODE (operands[0]),\n+\t\t\t\t operands[1], GET_MODE (operands[1]),\n+\t\t\t\t operands[2], GET_MODE (operands[2]));\n   if (ret != operands[0])\n                 emit_move_insn (operands[0], ret);    \n "}, {"sha": "3016ce0bb8e4710d4f770a3fd50f664118a46f26", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -2603,7 +2603,7 @@ typedef struct mips_args {\n   /* Flush both caches.  We need to flush the data cache in case\t\\\n      the system has a write-back cache.  */\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mips_cache_flush_func),\t\\\n-\t\t     LCT_NORMAL, VOIDmode, 3, ADDR, Pmode, SIZE, Pmode,\t\\\n+\t\t     LCT_NORMAL, VOIDmode, ADDR, Pmode, SIZE, Pmode,\t\\\n \t\t     GEN_INT (3), TYPE_MODE (integer_type_node))\n \n \f"}, {"sha": "5144cdae8771091eb2f38def2affbc56d1a1cf20", "filename": "gcc/config/mips/sdemtk.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fmips%2Fsdemtk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fmips%2Fsdemtk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsdemtk.h?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -70,7 +70,7 @@ extern void mips_sync_icache (void *beg, unsigned long len);\n #undef MIPS_ICACHE_SYNC\n #define MIPS_ICACHE_SYNC(ADDR, SIZE)\t\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mips_cache_flush_func),\t\\\n-\t\t     LCT_NORMAL, VOIDmode, 2, ADDR, Pmode,\t\t\\\n+\t\t     LCT_NORMAL, VOIDmode, ADDR, Pmode,\t\t\t\\\n \t\t     SIZE, TYPE_MODE (sizetype))\n \n /* This version of _mcount does not pop 2 words from the stack.  */"}, {"sha": "fa7f14e0f5587fb3aa27d6409bf0bd50ff55b3f2", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1734,7 +1734,7 @@ nios2_emit_expensive_div (rtx *operands, machine_mode mode)\n \n   start_sequence ();\n   final_result = emit_library_call_value (libfunc, NULL_RTX,\n-                                          LCT_CONST, SImode, 2,\n+                                          LCT_CONST, SImode,\n                                           operands[1], SImode,\n                                           operands[2], SImode);\n \n@@ -3025,7 +3025,7 @@ nios2_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n   rtx addr = force_reg (Pmode, XEXP (m_tramp, 0));\n \n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__trampoline_setup\"),\n-\t\t     LCT_NORMAL, VOIDmode, 3, addr, Pmode, fnaddr, Pmode,\n+\t\t     LCT_NORMAL, VOIDmode, addr, Pmode, fnaddr, Pmode,\n \t\t     ctx_reg, Pmode);\n }\n "}, {"sha": "6783fe3b0e890ee059ff6a50ff2f0ded8c71d3c8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -906,7 +906,7 @@ hppa_tls_call (rtx arg)\n \n   ret = gen_reg_rtx (Pmode);\n   emit_library_call_value (gen_tls_get_addr (), ret,\n-\t\t  \t   LCT_CONST, Pmode, 1, arg, Pmode);\n+\t\t\t   LCT_CONST, Pmode, arg, Pmode);\n \n   return ret;\n }\n@@ -10192,7 +10192,7 @@ pa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \n #ifdef HAVE_ENABLE_EXECUTE_STACK\n  \u00a0emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n-\t\t\u00a0\u00a0\u00a0\u00a0 LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);\n+\t\t     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);\n #endif\n }\n "}, {"sha": "1d979e0328d566c04412a74fa0bd54a402e6bfef", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -9637,7 +9637,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n       emit_library_call_value (canonicalize_funcptr_for_compare_libfunc,\n       \t\t\t       operands[0], LCT_NORMAL, Pmode,\n-\t\t\t       1, operands[1], Pmode);\n+\t\t\t       operands[1], Pmode);\n       DONE;\n     }\n "}, {"sha": "0df373dbe0f9b806aded535c4b2c3766eb73768c", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -9694,7 +9694,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t{\n \t  tga = rs6000_tls_get_addr ();\n \t  emit_library_call_value (tga, dest, LCT_CONST, Pmode,\n-\t\t\t\t   1, const0_rtx, Pmode);\n+\t\t\t\t   const0_rtx, Pmode);\n \n \t  r3 = gen_rtx_REG (Pmode, 3);\n \t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n@@ -9719,7 +9719,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t  tga = rs6000_tls_get_addr ();\n \t  tmp1 = gen_reg_rtx (Pmode);\n \t  emit_library_call_value (tga, tmp1, LCT_CONST, Pmode,\n-\t\t\t\t   1, const0_rtx, Pmode);\n+\t\t\t\t   const0_rtx, Pmode);\n \n \t  r3 = gen_rtx_REG (Pmode, 3);\n \t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n@@ -20417,7 +20417,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t{\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 2,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode);\n \t}\n@@ -20436,7 +20436,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRNCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 3,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n \t\t\t\t   len_rtx, GET_MODE (len_rtx));\n@@ -20683,7 +20683,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t{\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 2,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode);\n \t}\n@@ -20698,7 +20698,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t  emit_move_insn (len_rtx, GEN_INT (bytes - compare_length));\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRNCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 3,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n \t\t\t\t   len_rtx, GET_MODE (len_rtx));\n@@ -24720,7 +24720,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \n       if (!check_nan)\n \tdest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t\tSImode, 2, op0, mode, op1, mode);\n+\t\t\t\t\tSImode, op0, mode, op1, mode);\n \n       /* The library signals an exception for signalling NaNs, so we need to\n \t handle isgreater, etc. by first checking isordered.  */\n@@ -24736,8 +24736,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t  /* Test for either value being a NaN.  */\n \t  gcc_assert (unord_func);\n \t  unord_dest = emit_library_call_value (unord_func, NULL_RTX, LCT_CONST,\n-\t\t\t\t\t\tSImode, 2, op0, mode, op1,\n-\t\t\t\t\t\tmode);\n+\t\t\t\t\t\tSImode, op0, mode, op1, mode);\n \n \t  /* Set value (0) if either value is a NaN, and jump to the join\n \t     label.  */\n@@ -24756,8 +24755,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t  /* Do the normal comparison, knowing that the values are not\n \t     NaNs.  */\n \t  normal_dest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t\t\t SImode, 2, op0, mode, op1,\n-\t\t\t\t\t\t mode);\n+\t\t\t\t\t\t SImode, op0, mode, op1, mode);\n \n \t  emit_insn (gen_cstoresi4 (dest,\n \t\t\t\t    gen_rtx_fmt_ee (code, SImode, normal_dest,\n@@ -25121,8 +25119,8 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n       libfunc = convert_optab_libfunc (cvt, dest_mode, src_mode);\n       gcc_assert (libfunc != NULL_RTX);\n \n-      dest2 = emit_library_call_value (libfunc, dest, LCT_CONST, dest_mode, 1, src,\n-\t\t\t\t       src_mode);\n+      dest2 = emit_library_call_value (libfunc, dest, LCT_CONST, dest_mode,\n+\t\t\t\t       src, src_mode);\n \n       gcc_assert (dest2 != NULL_RTX);\n       if (!rtx_equal_p (dest, dest2))\n@@ -33083,7 +33081,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n #endif\n       if (NO_PROFILE_COUNTERS)\n \temit_library_call (init_one_libfunc (RS6000_MCOUNT),\n-\t\t\t   LCT_NORMAL, VOIDmode, 0);\n+\t\t\t   LCT_NORMAL, VOIDmode);\n       else\n \t{\n \t  char buf[30];\n@@ -33095,7 +33093,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n \t  fun = gen_rtx_SYMBOL_REF (Pmode, label_name);\n \n \t  emit_library_call (init_one_libfunc (RS6000_MCOUNT),\n-\t\t\t     LCT_NORMAL, VOIDmode, 1, fun, Pmode);\n+\t\t\t     LCT_NORMAL, VOIDmode, fun, Pmode);\n \t}\n     }\n   else if (DEFAULT_ABI == ABI_DARWIN)\n@@ -33114,7 +33112,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n \tcaller_addr_regno = 0;\n #endif\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mcount_name),\n-\t\t\t LCT_NORMAL, VOIDmode, 1,\n+\t\t\t LCT_NORMAL, VOIDmode,\n \t\t\t gen_rtx_REG (Pmode, caller_addr_regno), Pmode);\n     }\n }\n@@ -35464,7 +35462,7 @@ rs6000_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n     case ABI_DARWIN:\n     case ABI_V4:\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__trampoline_setup\"),\n-\t\t\t LCT_NORMAL, VOIDmode, 4,\n+\t\t\t LCT_NORMAL, VOIDmode,\n \t\t\t addr, Pmode,\n \t\t\t GEN_INT (rs6000_trampoline_size ()), SImode,\n \t\t\t fnaddr, Pmode,"}, {"sha": "8dc69294a6a51e5dab3517b6147e7982ccd07424", "filename": "gcc/config/powerpcspe/powerpcspe.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.md?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -7997,7 +7997,7 @@\n \t{\n \t  rtx libfunc = optab_libfunc (neg_optab, <MODE>mode);\n \t  rtx target = emit_library_call_value (libfunc, operands[0], LCT_CONST,\n-\t\t\t\t\t\t<MODE>mode, 1,\n+\t\t\t\t\t\t<MODE>mode,\n \t\t\t\t\t\toperands[1], <MODE>mode);\n \n \t  if (target && !rtx_equal_p (target, operands[0]))"}, {"sha": "30d2ae260d2289fd0341d35e8e6a4072b8bfe971", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -340,7 +340,7 @@ along with GCC; see the file COPYING3.  If not see\n     rtx fun, ra;\t\t\t\t\t\t\t\\\n     ra = get_hard_reg_initial_val (Pmode, RETURN_ADDR_REGNUM);\t\t\\\n     fun = gen_rtx_SYMBOL_REF (Pmode, MCOUNT_NAME);\t\t\t\\\n-    emit_library_call (fun, LCT_NORMAL, VOIDmode, 1, ra, Pmode);\t\\\n+    emit_library_call (fun, LCT_NORMAL, VOIDmode, ra, Pmode);\t\t\\\n   }\n \n /* All the work done in PROFILE_HOOK, but still required.  */"}, {"sha": "fb57ab3d4cfa2ffffb22f3be66e0ca1eb68fb607", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -843,7 +843,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t{\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 2,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode);\n \t}\n@@ -862,7 +862,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRNCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 3,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n \t\t\t\t   len_rtx, GET_MODE (len_rtx));\n@@ -1109,7 +1109,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t{\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 2,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode);\n \t}\n@@ -1124,7 +1124,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t  emit_move_insn (len_rtx, GEN_INT (bytes - compare_length));\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRNCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n-\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 3,\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n \t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n \t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n \t\t\t\t   len_rtx, GET_MODE (len_rtx));"}, {"sha": "a787a29f9f870919d96b1496d270143b8fcbc358", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -9233,7 +9233,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t{\n \t  tga = rs6000_tls_get_addr ();\n \t  emit_library_call_value (tga, dest, LCT_CONST, Pmode,\n-\t\t\t\t   1, const0_rtx, Pmode);\n+\t\t\t\t   const0_rtx, Pmode);\n \n \t  r3 = gen_rtx_REG (Pmode, 3);\n \t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n@@ -9258,7 +9258,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t  tga = rs6000_tls_get_addr ();\n \t  tmp1 = gen_reg_rtx (Pmode);\n \t  emit_library_call_value (tga, tmp1, LCT_CONST, Pmode,\n-\t\t\t\t   1, const0_rtx, Pmode);\n+\t\t\t\t   const0_rtx, Pmode);\n \n \t  r3 = gen_rtx_REG (Pmode, 3);\n \t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n@@ -21887,7 +21887,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \n       if (!check_nan)\n \tdest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t\tSImode, 2, op0, mode, op1, mode);\n+\t\t\t\t\tSImode, op0, mode, op1, mode);\n \n       /* The library signals an exception for signalling NaNs, so we need to\n \t handle isgreater, etc. by first checking isordered.  */\n@@ -21903,8 +21903,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t  /* Test for either value being a NaN.  */\n \t  gcc_assert (unord_func);\n \t  unord_dest = emit_library_call_value (unord_func, NULL_RTX, LCT_CONST,\n-\t\t\t\t\t\tSImode, 2, op0, mode, op1,\n-\t\t\t\t\t\tmode);\n+\t\t\t\t\t\tSImode, op0, mode, op1, mode);\n \n \t  /* Set value (0) if either value is a NaN, and jump to the join\n \t     label.  */\n@@ -21923,8 +21922,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t  /* Do the normal comparison, knowing that the values are not\n \t     NaNs.  */\n \t  normal_dest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t\t\t SImode, 2, op0, mode, op1,\n-\t\t\t\t\t\t mode);\n+\t\t\t\t\t\t SImode, op0, mode, op1, mode);\n \n \t  emit_insn (gen_cstoresi4 (dest,\n \t\t\t\t    gen_rtx_fmt_ee (code, SImode, normal_dest,\n@@ -22287,8 +22285,8 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n       libfunc = convert_optab_libfunc (cvt, dest_mode, src_mode);\n       gcc_assert (libfunc != NULL_RTX);\n \n-      dest2 = emit_library_call_value (libfunc, dest, LCT_CONST, dest_mode, 1, src,\n-\t\t\t\t       src_mode);\n+      dest2 = emit_library_call_value (libfunc, dest, LCT_CONST, dest_mode,\n+\t\t\t\t       src, src_mode);\n \n       gcc_assert (dest2 != NULL_RTX);\n       if (!rtx_equal_p (dest, dest2))\n@@ -29928,7 +29926,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n #endif\n       if (NO_PROFILE_COUNTERS)\n \temit_library_call (init_one_libfunc (RS6000_MCOUNT),\n-\t\t\t   LCT_NORMAL, VOIDmode, 0);\n+\t\t\t   LCT_NORMAL, VOIDmode);\n       else\n \t{\n \t  char buf[30];\n@@ -29940,7 +29938,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n \t  fun = gen_rtx_SYMBOL_REF (Pmode, label_name);\n \n \t  emit_library_call (init_one_libfunc (RS6000_MCOUNT),\n-\t\t\t     LCT_NORMAL, VOIDmode, 1, fun, Pmode);\n+\t\t\t     LCT_NORMAL, VOIDmode, fun, Pmode);\n \t}\n     }\n   else if (DEFAULT_ABI == ABI_DARWIN)\n@@ -29959,7 +29957,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n \tcaller_addr_regno = 0;\n #endif\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mcount_name),\n-\t\t\t LCT_NORMAL, VOIDmode, 1,\n+\t\t\t LCT_NORMAL, VOIDmode,\n \t\t\t gen_rtx_REG (Pmode, caller_addr_regno), Pmode);\n     }\n }\n@@ -32309,7 +32307,7 @@ rs6000_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n     case ABI_DARWIN:\n     case ABI_V4:\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__trampoline_setup\"),\n-\t\t\t LCT_NORMAL, VOIDmode, 4,\n+\t\t\t LCT_NORMAL, VOIDmode,\n \t\t\t addr, Pmode,\n \t\t\t GEN_INT (rs6000_trampoline_size ()), SImode,\n \t\t\t fnaddr, Pmode,"}, {"sha": "10ce01420868d3d64705a5f6c5b7562479cf0d9e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -7886,7 +7886,7 @@\n \t{\n \t  rtx libfunc = optab_libfunc (neg_optab, <MODE>mode);\n \t  rtx target = emit_library_call_value (libfunc, operands[0], LCT_CONST,\n-\t\t\t\t\t\t<MODE>mode, 1,\n+\t\t\t\t\t\t<MODE>mode,\n \t\t\t\t\t\toperands[1], <MODE>mode);\n \n \t  if (target && !rtx_equal_p (target, operands[0]))"}, {"sha": "c68b0777497fcae18d5ab68cf8bada3a3f88985b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -10090,7 +10090,7 @@ sh_trampoline_init (rtx tramp_mem, tree fndecl, rtx cxt)\n \t  || (!(TARGET_SH4A || TARGET_SH4_300) && TARGET_USERMODE))\n \temit_library_call (function_symbol (NULL, \"__ic_invalidate\",\n \t\t\t\t\t    FUNCTION_ORDINARY).sym,\n-\t\t\t   LCT_NORMAL, VOIDmode, 1, tramp, SImode);\n+\t\t\t   LCT_NORMAL, VOIDmode, tramp, SImode);\n       else\n \temit_insn (gen_ic_invalidate_line (tramp));\n     }"}, {"sha": "57b008ea3795d7b6a003db4d6c2ccf1cc1d1a75a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -3399,11 +3399,11 @@ emit_soft_tfmode_libcall (const char *func_name, int nargs, rtx *operands)\n   if (GET_MODE (operands[0]) == TFmode)\n     {\n       if (nargs == 2)\n-\temit_library_call (func_sym, LCT_NORMAL, VOIDmode, 2,\n+\temit_library_call (func_sym, LCT_NORMAL, VOIDmode,\n \t\t\t   arg[0], GET_MODE (arg[0]),\n \t\t\t   arg[1], GET_MODE (arg[1]));\n       else\n-\temit_library_call (func_sym, LCT_NORMAL, VOIDmode, 3,\n+\temit_library_call (func_sym, LCT_NORMAL, VOIDmode,\n \t\t\t   arg[0], GET_MODE (arg[0]),\n \t\t\t   arg[1], GET_MODE (arg[1]),\n \t\t\t   arg[2], GET_MODE (arg[2]));\n@@ -3418,7 +3418,7 @@ emit_soft_tfmode_libcall (const char *func_name, int nargs, rtx *operands)\n       gcc_assert (nargs == 2);\n \n       ret = emit_library_call_value (func_sym, operands[0], LCT_NORMAL,\n-\t\t\t\t     GET_MODE (operands[0]), 1,\n+\t\t\t\t     GET_MODE (operands[0]),\n \t\t\t\t     arg[1], GET_MODE (arg[1]));\n \n       if (ret != operands[0])\n@@ -8131,7 +8131,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n \n       libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);\n       emit_library_call (libfunc, LCT_NORMAL,\n-\t\t\t DImode, 2,\n+\t\t\t DImode,\n \t\t\t XEXP (slot0, 0), Pmode,\n \t\t\t XEXP (slot1, 0), Pmode);\n       mode = DImode;\n@@ -8140,7 +8140,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n     {\n       libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);\n       emit_library_call (libfunc, LCT_NORMAL,\n-\t\t\t SImode, 2,\n+\t\t\t SImode,\n \t\t\t x, TFmode, y, TFmode);\n       mode = SImode;\n     }\n@@ -9632,7 +9632,7 @@ sparc32_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n      the stack address is accessible.  */\n #ifdef HAVE_ENABLE_EXECUTE_STACK\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n-                     LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);\n+                     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);\n #endif\n \n }\n@@ -9679,7 +9679,7 @@ sparc64_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n      the stack address is accessible.  */\n #ifdef HAVE_ENABLE_EXECUTE_STACK\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n-                     LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);\n+                     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);\n #endif\n }\n \n@@ -10183,13 +10183,13 @@ sparc_profile_hook (int labelno)\n   fun = gen_rtx_SYMBOL_REF (Pmode, MCOUNT_FUNCTION);\n   if (NO_PROFILE_COUNTERS)\n     {\n-      emit_library_call (fun, LCT_NORMAL, VOIDmode, 0);\n+      emit_library_call (fun, LCT_NORMAL, VOIDmode);\n     }\n   else\n     {\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LP\", labelno);\n       lab = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n-      emit_library_call (fun, LCT_NORMAL, VOIDmode, 1, lab, Pmode);\n+      emit_library_call (fun, LCT_NORMAL, VOIDmode, lab, Pmode);\n     }\n }\n \f"}, {"sha": "cd840e3072bf3ba81a3ad9c0829785fab7495240", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -4201,14 +4201,14 @@ ea_load_store (rtx mem, bool is_store, rtx ea_addr, rtx data_addr)\n       if (!cache_fetch_dirty)\n \tcache_fetch_dirty = init_one_libfunc (\"__cache_fetch_dirty\");\n       emit_library_call_value (cache_fetch_dirty, data_addr, LCT_NORMAL, Pmode,\n-\t\t\t       2, ea_addr, EAmode, ndirty, SImode);\n+\t\t\t       ea_addr, EAmode, ndirty, SImode);\n     }\n   else\n     {\n       if (!cache_fetch)\n \tcache_fetch = init_one_libfunc (\"__cache_fetch\");\n       emit_library_call_value (cache_fetch, data_addr, LCT_NORMAL, Pmode,\n-\t\t\t       1, ea_addr, EAmode);\n+\t\t\t       ea_addr, EAmode);\n     }\n }\n "}, {"sha": "9b766692a7f16f38c1513b29f6de9e01f9313102", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -864,9 +864,10 @@\n     {\n        start_sequence ();\n        value =\n-         emit_library_call_value (convert_optab_libfunc (ufloat_optab,\n-                                                         DFmode, SImode),\n-                   NULL_RTX, LCT_NORMAL, DFmode, 1, operands[1], SImode);\n+\t emit_library_call_value (convert_optab_libfunc (ufloat_optab,\n+\t\t\t\t\t\t\t DFmode, SImode),\n+\t\t\t\t  NULL_RTX, LCT_NORMAL, DFmode,\n+\t\t\t\t  operands[1], SImode);\n        rtx_insn *insns = get_insns ();\n        end_sequence ();\n        emit_libcall_block (insns, operands[0], value,\n@@ -959,7 +960,8 @@\n       value =\n          emit_library_call_value (convert_optab_libfunc (ufloat_optab,\n                                                          DFmode, DImode),\n-                   NULL_RTX, LCT_NORMAL, DFmode, 1, operands[1], DImode);\n+\t\t\t\t  NULL_RTX, LCT_NORMAL, DFmode,\n+\t\t\t\t  operands[1], DImode);\n       rtx_insn *insns = get_insns ();\n       end_sequence ();\n       emit_libcall_block (insns, operands[0], value,"}, {"sha": "004cc93ae0f8640ea8d6789628d74f0d4491b440", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -5063,7 +5063,7 @@ tilegx_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n \t\t\t\t\t      TRAMPOLINE_SIZE));\n \n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\n-\t\t     LCT_NORMAL, VOIDmode, 2, begin_addr, Pmode,\n+\t\t     LCT_NORMAL, VOIDmode, begin_addr, Pmode,\n \t\t     end_addr, Pmode);\n }\n "}, {"sha": "ae3337ba0a430d1c9656ff78e1580180b8f816ac", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -4472,7 +4472,7 @@ tilepro_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n \t\t\t\t\t      TRAMPOLINE_SIZE));\n \n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\n-\t\t     LCT_NORMAL, VOIDmode, 2, begin_addr, Pmode,\n+\t\t     LCT_NORMAL, VOIDmode, begin_addr, Pmode,\n \t\t     end_addr, Pmode);\n }\n "}, {"sha": "dcffe5c5fccc7c35e80b699bb12d44eb92491741", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -2380,7 +2380,7 @@ expand_block_move_4 (rtx dst, rtx dst_reg, rtx src, rtx src_reg, rtx bytes_rtx)\n       emit_insn (insn);\n     }\n   else\n-    emit_library_call (long_int_memcpy_libfunc, LCT_NORMAL, VOIDmode, 3,\n+    emit_library_call (long_int_memcpy_libfunc, LCT_NORMAL, VOIDmode,\n \t\t       dst_reg, Pmode,\n \t\t       src_reg, Pmode,\n \t\t       convert_to_mode (TYPE_MODE (sizetype),\n@@ -2416,7 +2416,7 @@ expand_block_move_2 (rtx dst, rtx dst_reg, rtx src, rtx src_reg, rtx bytes_rtx)\n   unsigned HOST_WIDE_INT bytes = UINTVAL (bytes_rtx);\n   unsigned int rem = bytes % 2;\n \n-  emit_library_call (wrd_memcpy_libfunc, LCT_NORMAL, VOIDmode, 3,\n+  emit_library_call (wrd_memcpy_libfunc, LCT_NORMAL, VOIDmode,\n \t\t     dst_reg, Pmode,\n \t\t     src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype),\n@@ -2440,7 +2440,7 @@ expand_block_move_2 (rtx dst, rtx dst_reg, rtx src, rtx src_reg, rtx bytes_rtx)\n static void\n expand_block_move_1 (rtx dst_reg, rtx src_reg, rtx bytes_rtx)\n {\n-  emit_library_call (byt_memcpy_libfunc, LCT_NORMAL, VOIDmode, 3,\n+  emit_library_call (byt_memcpy_libfunc, LCT_NORMAL, VOIDmode,\n \t\t     dst_reg, Pmode,\n \t\t     src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype),\n@@ -2459,7 +2459,7 @@ expand_block_set_4 (rtx dst, rtx dst_reg, rtx value_rtx, rtx bytes_rtx)\n   unsigned int rem = bytes % 4;\n \n   value_rtx = convert_to_mode (Pmode, value_rtx, 1);\n-  emit_library_call (long_int_memset_libfunc, LCT_NORMAL, VOIDmode, 3,\n+  emit_library_call (long_int_memset_libfunc, LCT_NORMAL, VOIDmode,\n \t\t     dst_reg, Pmode,\n \t\t     value_rtx, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype),\n@@ -2505,7 +2505,7 @@ expand_block_set_2 (rtx dst, rtx dst_reg, rtx value_rtx, rtx bytes_rtx)\n   unsigned int rem = bytes % 2;\n \n   value_rtx = convert_to_mode (Pmode, value_rtx, 1);\n-  emit_library_call (wrd_memset_libfunc, LCT_NORMAL, VOIDmode, 3,\n+  emit_library_call (wrd_memset_libfunc, LCT_NORMAL, VOIDmode,\n \t\t     dst_reg, Pmode,\n \t\t     value_rtx, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype),\n@@ -2529,7 +2529,7 @@ static void\n expand_block_set_1 (rtx dst_reg, rtx value_rtx, rtx bytes_rtx)\n {\n   value_rtx = convert_to_mode (Pmode, value_rtx, 1);\n-  emit_library_call (byt_memset_libfunc, LCT_NORMAL, VOIDmode, 3,\n+  emit_library_call (byt_memset_libfunc, LCT_NORMAL, VOIDmode,\n \t\t     dst_reg, Pmode,\n \t\t     value_rtx, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype),\n@@ -2681,7 +2681,7 @@ visium_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n \t\t\t\t\t     GEN_INT (0xffff), NULL_RTX),\n \t\t\t\t 0x04940000));\n \n-  emit_library_call (set_trampoline_parity_libfunc, LCT_NORMAL, VOIDmode, 1,\n+  emit_library_call (set_trampoline_parity_libfunc, LCT_NORMAL, VOIDmode,\n \t\t     addr, SImode);\n }\n \n@@ -2721,7 +2721,7 @@ visium_profile_hook (void)\n {\n   visium_frame_needed = true;\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"mcount\"), LCT_NORMAL,\n-\t\t     VOIDmode, 0);\n+\t\t     VOIDmode);\n }\n \n /* A C expression whose value is RTL representing the address in a stack frame"}, {"sha": "9c94c59f48a204f1e43538b47d48aabab1e465c5", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1343,7 +1343,7 @@ xtensa_expand_nonlocal_goto (rtx *operands)\n     containing_fp = force_reg (Pmode, containing_fp);\n \n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_nonlocal_goto\"),\n-\t\t     LCT_NORMAL, VOIDmode, 2,\n+\t\t     LCT_NORMAL, VOIDmode,\n \t\t     containing_fp, Pmode,\n \t\t     goto_handler, Pmode);\n }\n@@ -1623,7 +1623,7 @@ xtensa_setup_frame_addresses (void)\n   if (TARGET_WINDOWED_ABI)\n     emit_library_call\n       (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_libgcc_window_spill\"),\n-       LCT_NORMAL, VOIDmode, 0);\n+       LCT_NORMAL, VOIDmode);\n }\n \n \n@@ -4045,7 +4045,7 @@ xtensa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain)\n   emit_move_insn (adjust_address (m_tramp, SImode, chain_off), chain);\n   emit_move_insn (adjust_address (m_tramp, SImode, func_off), func);\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_sync_caches\"),\n-\t\t     LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);\n+\t\t     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);\n }\n \n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */"}, {"sha": "10b5a7c7cd0f177cbbf9c3e74fc004991c630f7e", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1190,7 +1190,7 @@ sjlj_emit_function_enter (rtx_code_label *dispatch_label)\n     }\n \n   emit_library_call (unwind_sjlj_register_libfunc, LCT_NORMAL, VOIDmode,\n-\t\t     1, XEXP (fc, 0), Pmode);\n+\t\t     XEXP (fc, 0), Pmode);\n \n   seq = get_insns ();\n   end_sequence ();\n@@ -1232,7 +1232,7 @@ sjlj_emit_function_exit (void)\n   start_sequence ();\n \n   emit_library_call (unwind_sjlj_unregister_libfunc, LCT_NORMAL, VOIDmode,\n-\t\t     1, XEXP (crtl->eh.sjlj_fc, 0), Pmode);\n+\t\t     XEXP (crtl->eh.sjlj_fc, 0), Pmode);\n \n   seq = get_insns ();\n   end_sequence ();"}, {"sha": "13736a586d88965e442d0cc265607f9c3d06b803", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1408,7 +1408,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n       func = init_one_libfunc (\"__morestack_allocate_stack_space\");\n \n       space = emit_library_call_value (func, target, LCT_NORMAL, Pmode,\n-\t\t\t\t       1, ask, Pmode);\n+\t\t\t\t       ask, Pmode);\n \n       if (available_label == NULL_RTX)\n \treturn space;\n@@ -1621,8 +1621,8 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n \t\t\t\t\t         stack_pointer_rtx,\n \t\t\t\t\t         plus_constant (Pmode,\n \t\t\t\t\t\t\t\tsize, first)));\n-      emit_library_call (stack_check_libfunc, LCT_THROW, VOIDmode, 1, addr,\n-\t\t\t Pmode);\n+      emit_library_call (stack_check_libfunc, LCT_THROW, VOIDmode,\n+\t\t\t addr, Pmode);\n     }\n \n   /* Next see if we have an insn to check the stack.  */"}, {"sha": "c14deedae5ffae14d0f01454c2f1d3fcd07e4242", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -327,7 +327,7 @@ convert_mode_scalar (rtx to, rtx from, int unsignedp)\n \n       start_sequence ();\n       value = emit_library_call_value (libcall, NULL_RTX, LCT_CONST, to_mode,\n-\t\t\t\t       1, from, from_mode);\n+\t\t\t\t       from, from_mode);\n       insns = get_insns ();\n       end_sequence ();\n       emit_libcall_block (insns, to, value,"}, {"sha": "b7f1e2c6491ba2a922a0ae9b00eeca9abc78962c", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -1759,7 +1759,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n       value = emit_library_call_value (libfunc,\n-\t\t\t\t       NULL_RTX, LCT_CONST, mode, 2,\n+\t\t\t\t       NULL_RTX, LCT_CONST, mode,\n \t\t\t\t       op0, mode, op1x, op1_mode);\n \n       insns = get_insns ();\n@@ -2092,7 +2092,7 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n   libval_mode = smallest_int_mode_for_size (2 * GET_MODE_BITSIZE (mode));\n   start_sequence ();\n   libval = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t    libval_mode, 2,\n+\t\t\t\t    libval_mode,\n \t\t\t\t    op0, mode,\n \t\t\t\t    op1, mode);\n   /* Get the part of VAL containing the value that we want.  */\n@@ -2966,7 +2966,7 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n       value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST, outmode,\n-\t\t\t\t       1, op0, mode);\n+\t\t\t\t       op0, mode);\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -3917,7 +3917,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n       ret_mode = targetm.libgcc_cmp_return_mode ();\n       result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t\tret_mode, 2, x, mode, y, mode);\n+\t\t\t\t\tret_mode, x, mode, y, mode);\n \n       /* There are two kinds of comparison routines. Biased routines\n \t return 0/1/2, and unbiased routines return -1/0/1. Other parts\n@@ -4171,7 +4171,7 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n \n   start_sequence ();\n   value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t   cmp_mode, 2, x, mode, y, mode);\n+\t\t\t\t   cmp_mode, x, mode, y, mode);\n   insns = get_insns ();\n   end_sequence ();\n \n@@ -4811,8 +4811,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n       start_sequence ();\n \n       value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t       GET_MODE (to), 1, from,\n-\t\t\t\t       GET_MODE (from));\n+\t\t\t\t       GET_MODE (to), from, GET_MODE (from));\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -5004,8 +5003,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n       start_sequence ();\n \n       value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t       GET_MODE (to), 1, from,\n-\t\t\t\t       GET_MODE (from));\n+\t\t\t\t       GET_MODE (to), from, GET_MODE (from));\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -5097,7 +5095,7 @@ expand_fixed_convert (rtx to, rtx from, int uintp, int satp)\n \n   start_sequence ();\n   value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST, to_mode,\n-\t\t\t\t   1, from, from_mode);\n+\t\t\t\t   from, from_mode);\n   insns = get_insns ();\n   end_sequence ();\n \n@@ -5944,7 +5942,7 @@ maybe_emit_sync_lock_test_and_set (rtx target, rtx mem, rtx val,\n \n \t  addr = convert_memory_address (ptr_mode, XEXP (mem, 0));\n \t  return emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,\n-\t\t\t\t\t  mode, 2, addr, ptr_mode,\n+\t\t\t\t\t  mode, addr, ptr_mode,\n \t\t\t\t\t  val, mode);\n \t}\n     }\n@@ -6252,7 +6250,7 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n     {\n       rtx addr = convert_memory_address (ptr_mode, XEXP (mem, 0));\n       rtx target = emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,\n-\t\t\t\t\t    mode, 3, addr, ptr_mode,\n+\t\t\t\t\t    mode, addr, ptr_mode,\n \t\t\t\t\t    expected, mode, desired, mode);\n       emit_move_insn (target_oval, target);\n \n@@ -6313,7 +6311,7 @@ expand_mem_thread_fence (enum memmodel model)\n   else if (targetm.have_memory_barrier ())\n     emit_insn (targetm.gen_memory_barrier ());\n   else if (synchronize_libfunc != NULL_RTX)\n-    emit_library_call (synchronize_libfunc, LCT_NORMAL, VOIDmode, 0);\n+    emit_library_call (synchronize_libfunc, LCT_NORMAL, VOIDmode);\n   else\n     expand_asm_memory_barrier ();\n }\n@@ -6813,7 +6811,7 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \t{\n \t  rtx addr = convert_memory_address (ptr_mode, XEXP (mem, 0));\n \t  result = emit_library_call_value (libfunc, NULL, LCT_NORMAL, mode,\n-\t\t\t\t\t    2, addr, ptr_mode, val, mode);\n+\t\t\t\t\t    addr, ptr_mode, val, mode);\n \n \t  if (!unused_result && fixup)\n \t    result = expand_simple_binop (mode, code, result, val, target,"}, {"sha": "36d42542171a2a9f08d9911c2b3ae6d637190957", "filename": "gcc/rtl.h", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db69559bac8ab03ccddfe3a42be630e65c277812/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=db69559bac8ab03ccddfe3a42be630e65c277812", "patch": "@@ -3773,10 +3773,138 @@ enum libcall_type\n   LCT_RETURNS_TWICE = 5\n };\n \n-extern void emit_library_call (rtx, enum libcall_type, machine_mode, int,\n-\t\t\t       ...);\n-extern rtx emit_library_call_value (rtx, rtx, enum libcall_type,\n-\t\t\t\t    machine_mode, int, ...);\n+extern rtx emit_library_call_value_1 (int, rtx, rtx, enum libcall_type,\n+\t\t\t\t      machine_mode, int, rtx_mode_t *);\n+\n+/* Output a library call and discard the returned value.  FUN is the\n+   address of the function, as a SYMBOL_REF rtx, and OUTMODE is the mode\n+   of the (discarded) return value.  FN_TYPE is LCT_NORMAL for `normal'\n+   calls, LCT_CONST for `const' calls, LCT_PURE for `pure' calls, or\n+   another LCT_ value for other types of library calls.\n+\n+   There are different overloads of this function for different numbers\n+   of arguments.  In each case the argument value is followed by its mode.  */\n+\n+inline void\n+emit_library_call (rtx fun, libcall_type fn_type, machine_mode outmode)\n+{\n+  emit_library_call_value_1 (0, fun, NULL_RTX, fn_type, outmode, 0, NULL);\n+}\n+\n+inline void\n+emit_library_call (rtx fun, libcall_type fn_type, machine_mode outmode,\n+\t\t   rtx arg1, machine_mode arg1_mode)\n+{\n+  rtx_mode_t args[] = { rtx_mode_t (arg1, arg1_mode) };\n+  emit_library_call_value_1 (0, fun, NULL_RTX, fn_type, outmode, 1, args);\n+}\n+\n+inline void\n+emit_library_call (rtx fun, libcall_type fn_type, machine_mode outmode,\n+\t\t   rtx arg1, machine_mode arg1_mode,\n+\t\t   rtx arg2, machine_mode arg2_mode)\n+{\n+  rtx_mode_t args[] = {\n+    rtx_mode_t (arg1, arg1_mode),\n+    rtx_mode_t (arg2, arg2_mode)\n+  };\n+  emit_library_call_value_1 (0, fun, NULL_RTX, fn_type, outmode, 2, args);\n+}\n+\n+inline void\n+emit_library_call (rtx fun, libcall_type fn_type, machine_mode outmode,\n+\t\t   rtx arg1, machine_mode arg1_mode,\n+\t\t   rtx arg2, machine_mode arg2_mode,\n+\t\t   rtx arg3, machine_mode arg3_mode)\n+{\n+  rtx_mode_t args[] = {\n+    rtx_mode_t (arg1, arg1_mode),\n+    rtx_mode_t (arg2, arg2_mode),\n+    rtx_mode_t (arg3, arg3_mode)\n+  };\n+  emit_library_call_value_1 (0, fun, NULL_RTX, fn_type, outmode, 3, args);\n+}\n+\n+inline void\n+emit_library_call (rtx fun, libcall_type fn_type, machine_mode outmode,\n+\t\t   rtx arg1, machine_mode arg1_mode,\n+\t\t   rtx arg2, machine_mode arg2_mode,\n+\t\t   rtx arg3, machine_mode arg3_mode,\n+\t\t   rtx arg4, machine_mode arg4_mode)\n+{\n+  rtx_mode_t args[] = {\n+    rtx_mode_t (arg1, arg1_mode),\n+    rtx_mode_t (arg2, arg2_mode),\n+    rtx_mode_t (arg3, arg3_mode),\n+    rtx_mode_t (arg4, arg4_mode)\n+  };\n+  emit_library_call_value_1 (0, fun, NULL_RTX, fn_type, outmode, 4, args);\n+}\n+\n+/* Like emit_library_call, but return the value produced by the call.\n+   Use VALUE to store the result if it is nonnull, otherwise pick a\n+   convenient location.  */\n+\n+inline rtx\n+emit_library_call_value (rtx fun, rtx value, libcall_type fn_type,\n+\t\t\t machine_mode outmode)\n+{\n+  return emit_library_call_value_1 (1, fun, value, fn_type, outmode, 0, NULL);\n+}\n+\n+inline rtx\n+emit_library_call_value (rtx fun, rtx value, libcall_type fn_type,\n+\t\t\t machine_mode outmode,\n+\t\t\t rtx arg1, machine_mode arg1_mode)\n+{\n+  rtx_mode_t args[] = { rtx_mode_t (arg1, arg1_mode) };\n+  return emit_library_call_value_1 (1, fun, value, fn_type, outmode, 1, args);\n+}\n+\n+inline rtx\n+emit_library_call_value (rtx fun, rtx value, libcall_type fn_type,\n+\t\t\t machine_mode outmode,\n+\t\t\t rtx arg1, machine_mode arg1_mode,\n+\t\t\t rtx arg2, machine_mode arg2_mode)\n+{\n+  rtx_mode_t args[] = {\n+    rtx_mode_t (arg1, arg1_mode),\n+    rtx_mode_t (arg2, arg2_mode)\n+  };\n+  return emit_library_call_value_1 (1, fun, value, fn_type, outmode, 2, args);\n+}\n+\n+inline rtx\n+emit_library_call_value (rtx fun, rtx value, libcall_type fn_type,\n+\t\t\t machine_mode outmode,\n+\t\t\t rtx arg1, machine_mode arg1_mode,\n+\t\t\t rtx arg2, machine_mode arg2_mode,\n+\t\t\t rtx arg3, machine_mode arg3_mode)\n+{\n+  rtx_mode_t args[] = {\n+    rtx_mode_t (arg1, arg1_mode),\n+    rtx_mode_t (arg2, arg2_mode),\n+    rtx_mode_t (arg3, arg3_mode)\n+  };\n+  return emit_library_call_value_1 (1, fun, value, fn_type, outmode, 3, args);\n+}\n+\n+inline rtx\n+emit_library_call_value (rtx fun, rtx value, libcall_type fn_type,\n+\t\t\t machine_mode outmode,\n+\t\t\t rtx arg1, machine_mode arg1_mode,\n+\t\t\t rtx arg2, machine_mode arg2_mode,\n+\t\t\t rtx arg3, machine_mode arg3_mode,\n+\t\t\t rtx arg4, machine_mode arg4_mode)\n+{\n+  rtx_mode_t args[] = {\n+    rtx_mode_t (arg1, arg1_mode),\n+    rtx_mode_t (arg2, arg2_mode),\n+    rtx_mode_t (arg3, arg3_mode),\n+    rtx_mode_t (arg4, arg4_mode)\n+  };\n+  return emit_library_call_value_1 (1, fun, value, fn_type, outmode, 4, args);\n+}\n \n /* In varasm.c */\n extern void init_varasm_once (void);"}]}