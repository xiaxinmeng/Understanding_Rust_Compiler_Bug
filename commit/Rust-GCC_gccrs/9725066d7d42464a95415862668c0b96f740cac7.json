{"sha": "9725066d7d42464a95415862668c0b96f740cac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyNTA2NmQ3ZDQyNDY0YTk1NDE1ODYyNjY4YzBiOTZmNzQwY2FjNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-01T23:00:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-01T23:00:41Z"}, "message": "optabs.c (emit_cmp_insn): Immediately copy the return value from the library call into a pseudo register.\n\n        * optabs.c (emit_cmp_insn): Immediately copy the return\n        value from the library call into a pseudo register.\n        (emit_float_lib_cmp): Likewise.\n\nFrom-SVN: r11398", "tree": {"sha": "cb22a4cfe3163d18f7772355ee42448ac5c2feca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb22a4cfe3163d18f7772355ee42448ac5c2feca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9725066d7d42464a95415862668c0b96f740cac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9725066d7d42464a95415862668c0b96f740cac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9725066d7d42464a95415862668c0b96f740cac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9725066d7d42464a95415862668c0b96f740cac7/comments", "author": null, "committer": null, "parents": [{"sha": "fff4998bc9872fac229a83563e4759e811ab360a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff4998bc9872fac229a83563e4759e811ab360a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff4998bc9872fac229a83563e4759e811ab360a"}], "stats": {"total": 31, "additions": 27, "deletions": 4}, "files": [{"sha": "09c4526ed9f2f8a754792240c792317fe3b24315", "filename": "gcc/optabs.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9725066d7d42464a95415862668c0b96f740cac7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9725066d7d42464a95415862668c0b96f740cac7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9725066d7d42464a95415862668c0b96f740cac7", "patch": "@@ -2743,6 +2743,8 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n       else\n #endif\n \t{\n+\t  rtx result;\n+\n #ifdef TARGET_MEM_FUNCTIONS\n \t  emit_library_call (memcmp_libfunc, 0,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n@@ -2759,7 +2761,14 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t\t\t\t\t      TREE_UNSIGNED (integer_type_node)),\n \t\t\t     TYPE_MODE (integer_type_node));\n #endif\n-\t  emit_cmp_insn (hard_libcall_value (TYPE_MODE (integer_type_node)),\n+\n+\t  /* Immediately move the result of the libcall into a pseudo\n+\t     register so reload doesn't clobber the value if it needs\n+\t     the return register for a spill reg.  */\n+\t  result = gen_reg_rtx (TYPE_MODE (integer_type_node));\n+\t  emit_move_insn (result,\n+\t\t\t  hard_libcall_value (TYPE_MODE (integer_type_node)));\n+\t  emit_cmp_insn (result,\n \t\t\t const0_rtx, comparison, NULL_RTX,\n \t\t\t TYPE_MODE (integer_type_node), 0, 0);\n \t}\n@@ -2836,6 +2845,8 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n       && class != MODE_FLOAT)\n     {\n       rtx libfunc = cmp_optab->handlers[(int) mode].libfunc;\n+      rtx result;\n+\n       /* If we want unsigned, and this mode has a distinct unsigned\n \t comparison routine, use that.  */\n       if (unsignedp && ucmp_optab->handlers[(int) mode].libfunc)\n@@ -2844,11 +2855,16 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n       emit_library_call (libfunc, 1,\n \t\t\t word_mode, 2, x, mode, y, mode);\n \n+      /* Immediately move the result of the libcall into a pseudo\n+\t register so reload doesn't clobber the value if it needs\n+\t the return register for a spill reg.  */\n+      result = gen_reg_rtx (word_mode);\n+      emit_move_insn (result, hard_libcall_value (word_mode));\n+\n       /* Integer comparison returns a result that must be compared against 1,\n \t so that even if we do an unsigned compare afterward,\n \t there is still a value that can represent the result \"less than\".  */\n-\n-      emit_cmp_insn (hard_libcall_value (word_mode), const1_rtx,\n+      emit_cmp_insn (result, const1_rtx,\n \t\t     comparison, NULL_RTX, word_mode, unsignedp, 0);\n       return;\n     }\n@@ -2887,6 +2903,7 @@ emit_float_lib_cmp (x, y, comparison)\n {\n   enum machine_mode mode = GET_MODE (x);\n   rtx libfunc = 0;\n+  rtx result;\n \n   if (mode == HFmode)\n     switch (comparison)\n@@ -3051,7 +3068,13 @@ emit_float_lib_cmp (x, y, comparison)\n   emit_library_call (libfunc, 1,\n \t\t     word_mode, 2, x, mode, y, mode);\n \n-  emit_cmp_insn (hard_libcall_value (word_mode), const0_rtx, comparison,\n+  /* Immediately move the result of the libcall into a pseudo\n+     register so reload doesn't clobber the value if it needs\n+     the return register for a spill reg.  */\n+  result = gen_reg_rtx (word_mode);\n+  emit_move_insn (result, hard_libcall_value (word_mode));\n+\n+  emit_cmp_insn (result, const0_rtx, comparison,\n \t\t NULL_RTX, word_mode, 0, 0);\n }\n \f"}]}