{"sha": "487a92fed227132325f624811a4eb80c47da8aca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg3YTkyZmVkMjI3MTMyMzI1ZjYyNDgxMWE0ZWI4MGM0N2RhOGFjYQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-07-19T08:38:52Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-07-19T08:38:52Z"}, "message": "c-tree.h (struct c_expr): Define.\n\n\t* c-tree.h (struct c_expr): Define.\n\t(C_SET_EXP_ORIGINAL_CODE): Remove.\n\t(parser_build_binary_op, build_compound_expr): Update prototypes.\n\t* c-parse.in (%union): Add exprtype.\n\t(FUNC_NAME): Mark as ttype.\n\t(expr, expr_no_commas, cast_expr, unary_expr, primary): Change to\n\texprtype.\n\t(expr): Update.  Define directly in terms of expr_no_commas\n\tinstead of using nonnull_exprlist.\n\t(nonnull_exprlist, unary_expr, cast_expr, expr_no_commas, primary,\n\toffsetof_member_designator, typespec_nonreserved_nonattr, init,\n\tinitval, designator, component_declarator,\n\tcomponent_notype_declarator, enumerator, array_declarator,\n\tcondition, exexpr, switch_statement, stmt_nocomp, stmt,\n\tnonnull_asm_operands, ivar_declarator, receiver): Update.  Don't\n\tset C_EXP_ORIGINAL_CODE.  Use TREE_NO_WARNING for assignments\n\twhere appropriate.\n\t* c-common.h (C_EXP_ORIGINAL_CODE): Remove.\n\t* c-common.c (c_common_truthvalue_conversion): Don't check\n\tC_EXP_ORIGINAL_CODE.\n\t* c-typeck.c (parser_build_binary_op): Use c_expr structures.\n\tDon't use C_EXP_ORIGINAL_CODE.\n\t(default_conversion, default_function_array_conversion): Don't use\n\tC_EXP_ORIGINAL_CODE.  Preserve TREE_NO_WARNING.\n\t(internal_build_compound_expr): Merge into build_compound_expr.\n\t(build_compound_expr): Take two operands instead of a TREE_LIST.\n\t* objc/objc-act.c (get_super_receiver): Update calls to\n\tbuild_compound_expr.\n\ncp:\n\t* typeck.c (build_modify_expr, build_x_modify_expr): Set\n\tTREE_NO_WARNING on assignments with an operator other than '='.\n\ntestsuite:\n\t* g++.dg/warn/Wparentheses-1.C, g++.dg/warn/Wparentheses-2.C,\n\tgcc.dg/Wparentheses-10.c: New tests.\n\t* gcc.dg/Wparentheses-5.c: Remove XFAILs.\n\nFrom-SVN: r84911", "tree": {"sha": "435cb0f3950c18eee6ce95cc4156e770e0aac344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/435cb0f3950c18eee6ce95cc4156e770e0aac344"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/487a92fed227132325f624811a4eb80c47da8aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487a92fed227132325f624811a4eb80c47da8aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/487a92fed227132325f624811a4eb80c47da8aca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487a92fed227132325f624811a4eb80c47da8aca/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de7ffa72b74d7a9a20379a3f121962c6ee8077e"}], "stats": {"total": 600, "additions": 399, "deletions": 201}, "files": [{"sha": "b1053bf38fb9ea5cf8eddf7f677d3b744b5bb171", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -1,3 +1,34 @@\n+2004-07-19  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-tree.h (struct c_expr): Define.\n+\t(C_SET_EXP_ORIGINAL_CODE): Remove.\n+\t(parser_build_binary_op, build_compound_expr): Update prototypes.\n+\t* c-parse.in (%union): Add exprtype.\n+\t(FUNC_NAME): Mark as ttype.\n+\t(expr, expr_no_commas, cast_expr, unary_expr, primary): Change to\n+\texprtype.\n+\t(expr): Update.  Define directly in terms of expr_no_commas\n+\tinstead of using nonnull_exprlist.\n+\t(nonnull_exprlist, unary_expr, cast_expr, expr_no_commas, primary,\n+\toffsetof_member_designator, typespec_nonreserved_nonattr, init,\n+\tinitval, designator, component_declarator,\n+\tcomponent_notype_declarator, enumerator, array_declarator,\n+\tcondition, exexpr, switch_statement, stmt_nocomp, stmt,\n+\tnonnull_asm_operands, ivar_declarator, receiver): Update.  Don't\n+\tset C_EXP_ORIGINAL_CODE.  Use TREE_NO_WARNING for assignments\n+\twhere appropriate.\n+\t* c-common.h (C_EXP_ORIGINAL_CODE): Remove.\n+\t* c-common.c (c_common_truthvalue_conversion): Don't check\n+\tC_EXP_ORIGINAL_CODE.\n+\t* c-typeck.c (parser_build_binary_op): Use c_expr structures.\n+\tDon't use C_EXP_ORIGINAL_CODE.\n+\t(default_conversion, default_function_array_conversion): Don't use\n+\tC_EXP_ORIGINAL_CODE.  Preserve TREE_NO_WARNING.\n+\t(internal_build_compound_expr): Merge into build_compound_expr.\n+\t(build_compound_expr): Take two operands instead of a TREE_LIST.\n+\t* objc/objc-act.c (get_super_receiver): Update calls to\n+\tbuild_compound_expr.\n+\n 2004-07-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/sh/sh.c (sh_use_dfa_interface): Remove."}, {"sha": "1966b0da23607b1d6a7ee6ef29ec183ec3a2d8bc", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -2365,9 +2365,7 @@ c_common_truthvalue_conversion (tree expr)\n       break;\n \n     case MODIFY_EXPR:\n-      if (warn_parentheses\n-\t  && C_EXP_ORIGINAL_CODE (expr) == MODIFY_EXPR\n-\t  && !TREE_NO_WARNING (expr))\n+      if (warn_parentheses && !TREE_NO_WARNING (expr))\n \twarning (\"suggest parentheses around assignment used as truth value\");\n       break;\n "}, {"sha": "89fc7eed098a17e4493b2f4237c619fb40dcd0e9", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -598,10 +598,6 @@ extern int skip_evaluation;\n #define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n   (!C_TYPE_FUNCTION_P (type))\n \n-/* Record in each node resulting from a binary operator\n-   what operator was specified for it.  */\n-#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n-\n /* Attribute table common to the C front ends.  */\n extern const struct attribute_spec c_common_attribute_table[];\n extern const struct attribute_spec c_common_format_attribute_table[];"}, {"sha": "b56bfee03ac535bb723c7d7aaf87cf1e0f3c2c1a", "filename": "gcc/c-parse.in", "status": "modified", "additions": 144, "deletions": 109, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -102,7 +102,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n %start program\n \n-%union {long itype; tree ttype; enum tree_code code;\n+%union {long itype; tree ttype; struct c_expr exprtype; enum tree_code code;\n \tlocation_t location; }\n \n /* All identifiers that are not reserved words\n@@ -184,8 +184,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n %type <ttype> BREAK CONTINUE RETURN GOTO ASM_KEYWORD SIZEOF TYPEOF ALIGNOF\n \n-%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n-%type <ttype> expr_no_commas cast_expr unary_expr primary STRING\n+%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT STRING FUNC_NAME\n+%type <ttype> nonnull_exprlist exprlist\n+%type <exprtype> expr expr_no_commas cast_expr unary_expr primary\n %type <ttype> declspecs_nosc_nots_nosa_noea declspecs_nosc_nots_nosa_ea\n %type <ttype> declspecs_nosc_nots_sa_noea declspecs_nosc_nots_sa_ea\n %type <ttype> declspecs_nosc_ts_nosa_noea declspecs_nosc_ts_nosa_ea\n@@ -462,8 +463,10 @@ unop:     '&'\n \t\t{ $$ = TRUTH_NOT_EXPR; }\n \t;\n \n-expr:\tnonnull_exprlist\n-\t\t{ $$ = build_compound_expr ($1); }\n+expr:\texpr_no_commas\n+\t| expr ',' expr_no_commas\n+\t\t{ $$.value = build_compound_expr ($1.value, $3.value);\n+\t\t  $$.original_code = COMPOUND_EXPR; }\n \t;\n \n exprlist:\n@@ -474,44 +477,53 @@ exprlist:\n \n nonnull_exprlist:\n \texpr_no_commas\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1.value); }\n \t| nonnull_exprlist ',' expr_no_commas\n-\t\t{ chainon ($1, build_tree_list (NULL_TREE, $3)); }\n+\t\t{ chainon ($1, build_tree_list (NULL_TREE, $3.value)); }\n \t;\n \n unary_expr:\n \tprimary\n \t| '*' cast_expr   %prec UNARY\n-\t\t{ $$ = build_indirect_ref ($2, \"unary *\"); }\n+\t\t{ $$.value = build_indirect_ref ($2.value, \"unary *\");\n+\t\t  $$.original_code = ERROR_MARK; }\n \t/* __extension__ turns off -pedantic for following primary.  */\n \t| extension cast_expr\t  %prec UNARY\n \t\t{ $$ = $2;\n \t\t  RESTORE_EXT_FLAGS ($1); }\n \t| unop cast_expr  %prec UNARY\n-\t\t{ $$ = build_unary_op ($1, $2, 0);\n-\t\t  overflow_warning ($$); }\n+\t\t{ $$.value = build_unary_op ($1, $2.value, 0);\n+\t\t  overflow_warning ($$.value);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t/* Refer to the address of a label as a pointer.  */\n \t| ANDAND identifier\n-\t\t{ $$ = finish_label_address_expr ($2); }\n+\t\t{ $$.value = finish_label_address_expr ($2);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| sizeof unary_expr  %prec UNARY\n \t\t{ skip_evaluation--;\n-\t\t  if (TREE_CODE ($2) == COMPONENT_REF\n-\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2, 1)))\n+\t\t  if (TREE_CODE ($2.value) == COMPONENT_REF\n+\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2.value, 1)))\n \t\t    error (\"`sizeof' applied to a bit-field\");\n-\t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n+\t\t  $$.value = c_sizeof (TREE_TYPE ($2.value));\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| sizeof '(' typename ')'  %prec HYPERUNARY\n \t\t{ skip_evaluation--;\n-\t\t  $$ = c_sizeof (groktypename ($3)); }\n+\t\t  $$.value = c_sizeof (groktypename ($3));\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| alignof unary_expr  %prec UNARY\n \t\t{ skip_evaluation--;\n-\t\t  $$ = c_alignof_expr ($2); }\n+\t\t  $$.value = c_alignof_expr ($2.value);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| alignof '(' typename ')'  %prec HYPERUNARY\n \t\t{ skip_evaluation--;\n-\t\t  $$ = c_alignof (groktypename ($3)); }\n+\t\t  $$.value = c_alignof (groktypename ($3));\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| REALPART cast_expr %prec UNARY\n-\t\t{ $$ = build_unary_op (REALPART_EXPR, $2, 0); }\n+\t\t{ $$.value = build_unary_op (REALPART_EXPR, $2.value, 0);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| IMAGPART cast_expr %prec UNARY\n-\t\t{ $$ = build_unary_op (IMAGPART_EXPR, $2, 0); }\n+\t\t{ $$.value = build_unary_op (IMAGPART_EXPR, $2.value, 0);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t;\n \n sizeof:\n@@ -529,7 +541,8 @@ typeof:\n cast_expr:\n \tunary_expr\n \t| '(' typename ')' cast_expr  %prec UNARY\n-\t\t{ $$ = c_cast_expr ($2, $4); }\n+\t\t{ $$.value = c_cast_expr ($2, $4.value);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t;\n \n expr_no_commas:\n@@ -559,54 +572,51 @@ expr_no_commas:\n \t| expr_no_commas '^' expr_no_commas\n \t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n \t| expr_no_commas ANDAND\n-\t\t{ $1 = lang_hooks.truthvalue_conversion\n-\t\t    (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == truthvalue_false_node; }\n+\t\t{ $1.value = lang_hooks.truthvalue_conversion\n+\t\t    (default_conversion ($1.value));\n+\t\t  skip_evaluation += $1.value == truthvalue_false_node; }\n \t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == truthvalue_false_node;\n+\t\t{ skip_evaluation -= $1.value == truthvalue_false_node;\n \t\t  $$ = parser_build_binary_op (TRUTH_ANDIF_EXPR, $1, $4); }\n \t| expr_no_commas OROR\n-\t\t{ $1 = lang_hooks.truthvalue_conversion\n-\t\t    (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == truthvalue_true_node; }\n+\t\t{ $1.value = lang_hooks.truthvalue_conversion\n+\t\t    (default_conversion ($1.value));\n+\t\t  skip_evaluation += $1.value == truthvalue_true_node; }\n \t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == truthvalue_true_node;\n+\t\t{ skip_evaluation -= $1.value == truthvalue_true_node;\n \t\t  $$ = parser_build_binary_op (TRUTH_ORIF_EXPR, $1, $4); }\n \t| expr_no_commas '?'\n-\t\t{ $1 = lang_hooks.truthvalue_conversion\n-\t\t    (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == truthvalue_false_node; }\n+\t\t{ $1.value = lang_hooks.truthvalue_conversion\n+\t\t    (default_conversion ($1.value));\n+\t\t  skip_evaluation += $1.value == truthvalue_false_node; }\n           expr ':'\n-\t\t{ skip_evaluation += (($1 == truthvalue_true_node)\n-\t\t\t\t      - ($1 == truthvalue_false_node)); }\n+\t\t{ skip_evaluation += (($1.value == truthvalue_true_node)\n+\t\t\t\t      - ($1.value == truthvalue_false_node)); }\n \t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == truthvalue_true_node;\n-\t\t  $$ = build_conditional_expr ($1, $4, $7); }\n+\t\t{ skip_evaluation -= $1.value == truthvalue_true_node;\n+\t\t  $$.value = build_conditional_expr ($1.value, $4.value,\n+\t\t\t\t\t\t     $7.value);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| expr_no_commas '?'\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids omitting the middle term of a ?: expression\");\n \t\t  /* Make sure first operand is calculated only once.  */\n-\t\t  $<ttype>2 = save_expr (default_conversion ($1));\n-\t\t  $1 = lang_hooks.truthvalue_conversion ($<ttype>2);\n-\t\t  skip_evaluation += $1 == truthvalue_true_node; }\n+\t\t  $<ttype>2 = save_expr (default_conversion ($1.value));\n+\t\t  $1.value = lang_hooks.truthvalue_conversion ($<ttype>2);\n+\t\t  skip_evaluation += $1.value == truthvalue_true_node; }\n \t  ':' expr_no_commas\n-\t\t{ skip_evaluation -= $1 == truthvalue_true_node;\n-\t\t  $$ = build_conditional_expr ($1, $<ttype>2, $5); }\n+\t\t{ skip_evaluation -= $1.value == truthvalue_true_node;\n+\t\t  $$.value = build_conditional_expr ($1.value, $<ttype>2,\n+\t\t\t\t\t\t     $5.value);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| expr_no_commas '=' expr_no_commas\n-\t\t{ char class;\n-\t\t  $$ = build_modify_expr ($1, NOP_EXPR, $3);\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (IS_EXPR_CODE_CLASS (class))\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR);\n+\t\t{ $$.value = build_modify_expr ($1.value, NOP_EXPR, $3.value);\n+\t\t  $$.original_code = MODIFY_EXPR;\n \t\t}\n \t| expr_no_commas ASSIGN expr_no_commas\n-\t\t{ char class;\n-\t\t  $$ = build_modify_expr ($1, $2, $3);\n-\t\t  /* This inhibits warnings in\n-\t\t     c_common_truthvalue_conversion.  */\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (IS_EXPR_CODE_CLASS (class))\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK);\n+\t\t{ $$.value = build_modify_expr ($1.value, $2, $3.value);\n+\t\t  TREE_NO_WARNING ($$.value) = 1;\n+\t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t;\n \n@@ -615,12 +625,16 @@ primary:\n \t\t{\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n-\t\t  $$ = build_external_ref ($1, yychar == '(');\n+\t\t  $$.value = build_external_ref ($1, yychar == '(');\n+\t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t| CONSTANT\n+\t\t{ $$.value = $1; $$.original_code = ERROR_MARK; }\n \t| STRING\n+\t\t{ $$.value = $1; $$.original_code = ERROR_MARK; }\n \t| FUNC_NAME\n-\t\t{ $$ = fname_decl (C_RID_CODE ($$), $$); }\n+\t\t{ $$.value = fname_decl (C_RID_CODE ($1), $1);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| '(' typename ')' '{'\n \t\t{ start_init (NULL_TREE, NULL, 0);\n \t\t  $2 = groktypename ($2);\n@@ -632,83 +646,100 @@ primary:\n \n \t\t  if (pedantic && ! flag_isoc99)\n \t\t    pedwarn (\"ISO C90 forbids compound literals\");\n-\t\t  $$ = build_compound_literal (type, constructor);\n+\t\t  $$.value = build_compound_literal (type, constructor);\n+\t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t| '(' expr ')'\n-\t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));\n-\t\t  if (IS_EXPR_CODE_CLASS (class))\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($2, ERROR_MARK);\n-\t\t  $$ = $2; }\n+\t\t{ $$.value = $2.value;\n+\t\t  if (TREE_CODE ($$.value) == MODIFY_EXPR)\n+\t\t    TREE_NO_WARNING ($$.value) = 1;\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| '(' error ')'\n-\t\t{ $$ = error_mark_node; }\n+\t\t{ $$.value = error_mark_node; $$.original_code = ERROR_MARK; }\n \t| compstmt_primary_start compstmt_nostart ')'\n                 { if (pedantic)\n \t\t    pedwarn (\"ISO C forbids braced-groups within expressions\");\n-\t\t  $$ = c_finish_stmt_expr ($1);\n+\t\t  $$.value = c_finish_stmt_expr ($1);\n+\t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t| compstmt_primary_start error ')'\n \t\t{ c_finish_stmt_expr ($1);\n-\t\t  $$ = error_mark_node;\n+\t\t  $$.value = error_mark_node;\n+\t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t| primary '(' exprlist ')'   %prec '.'\n-\t\t{ $$ = build_function_call ($1, $3); }\n+\t\t{ $$.value = build_function_call ($1.value, $3);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| VA_ARG '(' expr_no_commas ',' typename ')'\n-\t\t{ $$ = build_va_arg ($3, groktypename ($5)); }\n+\t\t{ $$.value = build_va_arg ($3.value, groktypename ($5));\n+\t\t  $$.original_code = ERROR_MARK; }\n \n \t| OFFSETOF '(' typename ',' offsetof_member_designator ')'\n-\t\t{ $$ = build_offsetof (groktypename ($3), $5); }\n+\t\t{ $$.value = build_offsetof (groktypename ($3), $5);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| OFFSETOF '(' error ')'\n-\t\t{ $$ = error_mark_node; }\n+\t\t{ $$.value = error_mark_node; $$.original_code = ERROR_MARK; }\n \t| CHOOSE_EXPR '(' expr_no_commas ',' expr_no_commas ','\n \t\t\t  expr_no_commas ')'\n \t\t{\n                   tree c;\n \n-                  c = fold ($3);\n+                  c = fold ($3.value);\n                   STRIP_NOPS (c);\n                   if (TREE_CODE (c) != INTEGER_CST)\n                     error (\"first argument to __builtin_choose_expr not\"\n \t\t\t   \" a constant\");\n                   $$ = integer_zerop (c) ? $7 : $5;\n \t\t}\n \t| CHOOSE_EXPR '(' error ')'\n-\t\t{ $$ = error_mark_node; }\n+\t\t{ $$.value = error_mark_node; $$.original_code = ERROR_MARK; }\n \t| TYPES_COMPATIBLE_P '(' typename ',' typename ')'\n \t\t{\n \t\t  tree e1, e2;\n \n \t\t  e1 = TYPE_MAIN_VARIANT (groktypename ($3));\n \t\t  e2 = TYPE_MAIN_VARIANT (groktypename ($5));\n \n-\t\t  $$ = comptypes (e1, e2)\n+\t\t  $$.value = comptypes (e1, e2)\n \t\t    ? build_int_2 (1, 0) : build_int_2 (0, 0);\n+\t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t| TYPES_COMPATIBLE_P '(' error ')'\n-\t\t{ $$ = error_mark_node; }\n+\t\t{ $$.value = error_mark_node; $$.original_code = ERROR_MARK; }\n \t| primary '[' expr ']'   %prec '.'\n-\t\t{ $$ = build_array_ref ($1, $3); }\n+\t\t{ $$.value = build_array_ref ($1.value, $3.value);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| primary '.' identifier\n-\t\t{ $$ = build_component_ref ($1, $3); }\n+\t\t{ $$.value = build_component_ref ($1.value, $3);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| primary POINTSAT identifier\n \t\t{\n-                  tree expr = build_indirect_ref ($1, \"->\");\n-\t\t  $$ = build_component_ref (expr, $3);\n+                  tree expr = build_indirect_ref ($1.value, \"->\");\n+\t\t  $$.value = build_component_ref (expr, $3);\n+\t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t| primary PLUSPLUS\n-\t\t{ $$ = build_unary_op (POSTINCREMENT_EXPR, $1, 0); }\n+\t\t{ $$.value = build_unary_op (POSTINCREMENT_EXPR, $1.value, 0);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| primary MINUSMINUS\n-\t\t{ $$ = build_unary_op (POSTDECREMENT_EXPR, $1, 0); }\n+\t\t{ $$.value = build_unary_op (POSTDECREMENT_EXPR, $1.value, 0);\n+\t\t  $$.original_code = ERROR_MARK; }\n @@ifobjc\n \t| objcmessageexpr\n-\t\t{ $$ = build_message_expr ($1); }\n+\t\t{ $$.value = build_message_expr ($1);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| objcselectorexpr\n-\t\t{ $$ = build_selector_expr ($1); }\n+\t\t{ $$.value = build_selector_expr ($1);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| objcprotocolexpr\n-\t\t{ $$ = build_protocol_expr ($1); }\n+\t\t{ $$.value = build_protocol_expr ($1);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| objcencodeexpr\n-\t\t{ $$ = build_encode_expr ($1); }\n+\t\t{ $$.value = build_encode_expr ($1);\n+\t\t  $$.original_code = ERROR_MARK; }\n \t| OBJC_STRING\n-\t\t{ $$ = build_objc_string_object ($1); }\n+\t\t{ $$.value = build_objc_string_object ($1);\n+\t\t  $$.original_code = ERROR_MARK; }\n @@end_ifobjc\n \t;\n \n@@ -724,7 +755,7 @@ offsetof_member_designator:\n \t| offsetof_member_designator '.' identifier\n \t\t{ $$ = tree_cons ($3, NULL_TREE, $1); }\n \t| offsetof_member_designator '[' expr ']'\n-\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n+\t\t{ $$ = tree_cons (NULL_TREE, $3.value, $1); }\n \t;\n \n old_style_parm_decls:\n@@ -1332,10 +1363,10 @@ typespec_nonreserved_nonattr:\n @@end_ifobjc\n \t| typeof '(' expr ')'\n \t\t{ skip_evaluation--;\n-\t\t  if (TREE_CODE ($3) == COMPONENT_REF\n-\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($3, 1)))\n+\t\t  if (TREE_CODE ($3.value) == COMPONENT_REF\n+\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($3.value, 1)))\n \t\t    error (\"`typeof' applied to a bit-field\");\n-\t\t  $$ = TREE_TYPE ($3); }\n+\t\t  $$ = TREE_TYPE ($3.value); }\n \t| typeof '(' typename ')'\n \t\t{ skip_evaluation--; $$ = groktypename ($3); }\n \t;\n@@ -1445,6 +1476,7 @@ scspec:\n \n init:\n \texpr_no_commas\n+\t\t{ $$ = $1.value; }\n \t| '{'\n \t\t{ really_start_incremental_init (NULL_TREE); }\n \t  initlist_maybe_comma '}'\n@@ -1490,7 +1522,7 @@ initval:\n \t  initlist_maybe_comma '}'\n \t\t{ process_init_element (pop_init_level (0)); }\n \t| expr_no_commas\n-\t\t{ process_init_element ($1); }\n+\t\t{ process_init_element ($1.value); }\n \t| error\n \t;\n \n@@ -1503,11 +1535,11 @@ designator:\n \t  '.' identifier\n \t\t{ set_init_label ($2); }\n \t| '[' expr_no_commas ELLIPSIS expr_no_commas ']'\n-\t\t{ set_init_index ($2, $4);\n+\t\t{ set_init_index ($2.value, $4.value);\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C forbids specifying range of elements to initialize\"); }\n \t| '[' expr_no_commas ']'\n-\t\t{ set_init_index ($2, NULL_TREE); }\n+\t\t{ set_init_index ($2.value, NULL_TREE); }\n \t;\n \f\n nested_function:\n@@ -1809,11 +1841,11 @@ component_declarator:\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($2, all_prefix_attributes), 0); }\n \t| declarator ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield ($1, current_declspecs, $3);\n+\t\t{ $$ = grokfield ($1, current_declspecs, $3.value);\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($4, all_prefix_attributes), 0); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2);\n+\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2.value);\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($3, all_prefix_attributes), 0); }\n \t;\n@@ -1824,11 +1856,11 @@ component_notype_declarator:\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($2, all_prefix_attributes), 0); }\n \t| notype_declarator ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield ($1, current_declspecs, $3);\n+\t\t{ $$ = grokfield ($1, current_declspecs, $3.value);\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($4, all_prefix_attributes), 0); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2);\n+\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2.value);\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($3, all_prefix_attributes), 0); }\n \t;\n@@ -1852,7 +1884,7 @@ enumerator:\n \t  identifier\n \t\t{ $$ = build_enumerator ($1, NULL_TREE); }\n \t| identifier '=' expr_no_commas\n-\t\t{ $$ = build_enumerator ($1, $3); }\n+\t\t{ $$ = build_enumerator ($1, $3.value); }\n \t;\n \n typename:\n@@ -1919,16 +1951,16 @@ direct_absdcl1:\n \n array_declarator:\n \t'[' maybe_type_quals_attrs expr_no_commas ']'\n-\t\t{ $$ = build_array_declarator ($3, $2, 0, 0); }\n+\t\t{ $$ = build_array_declarator ($3.value, $2, 0, 0); }\n \t| '[' maybe_type_quals_attrs ']'\n \t\t{ $$ = build_array_declarator (NULL_TREE, $2, 0, 0); }\n \t| '[' maybe_type_quals_attrs '*' ']'\n \t\t{ $$ = build_array_declarator (NULL_TREE, $2, 0, 1); }\n \t| '[' STATIC maybe_type_quals_attrs expr_no_commas ']'\n-\t\t{ $$ = build_array_declarator ($4, $3, 1, 0); }\n+\t\t{ $$ = build_array_declarator ($4.value, $3, 1, 0); }\n \t/* declspecs_nosc_nots is a synonym for type_quals_attrs.  */\n \t| '[' declspecs_nosc_nots STATIC expr_no_commas ']'\n-\t\t{ $$ = build_array_declarator ($4, $2, 1, 0); }\n+\t\t{ $$ = build_array_declarator ($4.value, $2, 1, 0); }\n \t;\n \n /* A nonempty series of declarations and statements (possibly followed by\n@@ -2102,7 +2134,7 @@ lineno_label:\n \t;\n \n condition: save_location expr\n-\t\t{ $$ = lang_hooks.truthvalue_conversion ($2);\n+\t\t{ $$ = lang_hooks.truthvalue_conversion ($2.value);\n \t\t  if (EXPR_P ($$))\n \t\t    SET_EXPR_LOCATION ($$, $1); }\n \t;\n@@ -2177,6 +2209,7 @@ xexpr:\n \t/* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| expr\n+\t\t{ $$ = $1.value; }\n \t;\n \n for_init_stmt:\n@@ -2214,7 +2247,7 @@ for_statement:\n \n switch_statement:\n \tSWITCH c99_block_start '(' expr ')'\n-\t\t{ $<ttype>$ = c_start_case ($4); }\n+\t\t{ $<ttype>$ = c_start_case ($4.value); }\n \tstart_break c99_block_lineno_labeled_stmt\n                 { c_finish_case ($8);\n \t\t  if (c_break_label)\n@@ -2227,7 +2260,7 @@ switch_statement:\n /* Parse a single real statement, not including any labels or compounds.  */\n stmt_nocomp:\n \t  expr ';'\n-\t\t{ $$ = c_finish_expr_stmt ($1); }\n+\t\t{ $$ = c_finish_expr_stmt ($1.value); }\n \t| if_statement\n \t\t{ $$ = NULL_TREE; }\n \t| while_statement\n@@ -2245,23 +2278,23 @@ stmt_nocomp:\n \t| RETURN ';'\n                 { $$ = c_finish_return (NULL_TREE); }\n \t| RETURN expr ';'\n-                { $$ = c_finish_return ($2); }\n+                { $$ = c_finish_return ($2.value); }\n \t| asm_stmt\n \t| GOTO identifier ';'\n \t\t{ $$ = c_finish_goto_label ($2); }\n \t| GOTO '*' expr ';'\n-\t\t{ $$ = c_finish_goto_ptr ($3); }\n+\t\t{ $$ = c_finish_goto_ptr ($3.value); }\n \t| ';'\n \t\t{ $$ = NULL_TREE; }\n @@ifobjc\n \t| AT_THROW expr ';'\n-\t\t{ $$ = objc_build_throw_stmt ($2); }\n+\t\t{ $$ = objc_build_throw_stmt ($2.value); }\n \t| AT_THROW ';'\n \t\t{ $$ = objc_build_throw_stmt (NULL_TREE); }\n \t| objc_try_catch_stmt\n \t\t{ $$ = NULL_TREE; }\n \t| AT_SYNCHRONIZED save_location '(' expr ')' compstmt\n-\t\t{ objc_build_synchronized ($2, $4, $6); $$ = NULL_TREE; }\n+\t\t{ objc_build_synchronized ($2, $4.value, $6); $$ = NULL_TREE; }\n \t;\n \n objc_catch_prefix:\n@@ -2312,9 +2345,9 @@ stmt:\n    also at the end of a compound statement.  */\n \n label:\t  CASE expr_no_commas ':'\n-                { $$ = do_case ($2, NULL_TREE); }\n+                { $$ = do_case ($2.value, NULL_TREE); }\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-                { $$ = do_case ($2, $4); }\n+                { $$ = do_case ($2.value, $4.value); }\n \t| DEFAULT ':'\n                 { $$ = do_case (NULL_TREE, NULL_TREE); }\n \t| identifier save_location ':' maybe_attribute\n@@ -2408,12 +2441,13 @@ nonnull_asm_operands:\n \n asm_operand:\n \t  STRING start_string_translation '(' expr ')' stop_string_translation\n-\t\t{ $$ = build_tree_list (build_tree_list (NULL_TREE, $1), $4); }\n+\t\t{ $$ = build_tree_list (build_tree_list (NULL_TREE, $1),\n+\t\t\t\t\t$4.value); }\n \t| '[' identifier ']' STRING start_string_translation\n \t  '(' expr ')' stop_string_translation\n \t\t{ $2 = build_string (IDENTIFIER_LENGTH ($2),\n \t\t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = build_tree_list (build_tree_list ($2, $4), $7); }\n+\t\t  $$ = build_tree_list (build_tree_list ($2, $4), $7.value); }\n \t;\n \n asm_clobbers:\n@@ -2805,14 +2839,14 @@ ivar_declarator:\n \t\t{\n \t\t  $$ = add_instance_variable (objc_ivar_context,\n \t\t\t\t\t      objc_public_flag,\n-\t\t\t\t\t      $1, current_declspecs, $3);\n+\t\t\t\t\t      $1, current_declspecs, $3.value);\n                 }\n \t| ':' expr_no_commas\n \t\t{\n \t\t  $$ = add_instance_variable (objc_ivar_context,\n \t\t\t\t\t      objc_public_flag,\n \t\t\t\t\t      NULL_TREE,\n-\t\t\t\t\t      current_declspecs, $2);\n+\t\t\t\t\t      current_declspecs, $2.value);\n                 }\n \t;\n \n@@ -3068,6 +3102,7 @@ keywordarg:\n \n receiver:\n \t  expr\n+\t\t{ $$ = $1.value; }\n \t| CLASSNAME\n \t\t{\n \t\t  $$ = get_class_reference ($1);"}, {"sha": "d6cdc97be13be270951aff337468c3b286502fa0", "filename": "gcc/c-tree.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -80,10 +80,6 @@ struct lang_type GTY(())\n #define C_TYPE_VARIABLE_SIZE(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n #define C_DECL_VARIABLE_SIZE(TYPE) DECL_LANG_FLAG_0 (TYPE)\n \n-/* Store a value in that field.  */\n-#define C_SET_EXP_ORIGINAL_CODE(EXP, CODE) \\\n-  (TREE_COMPLEXITY (EXP) = (int) (CODE))\n-\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n \n@@ -116,6 +112,18 @@ struct lang_type GTY(())\n    without prototypes.  */\n #define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_LANG_SLOT_1 (NODE)\n \n+/* Record parser information about an expression that is irrelevant\n+   for code generation alongside a tree representing its value.  */\n+struct c_expr\n+{\n+  /* The value of the expression.  */\n+  tree value;\n+  /* Record the original binary operator of an expression, which may\n+     have been changed by fold, or ERROR_MARK for other expressions\n+     (including parenthesized expressions).  */\n+  enum tree_code original_code;\n+};\n+\n /* Save and restore the variables in this file and elsewhere\n    that keep track of the progress of compilation of the current function.\n    Used for nested functions.  */\n@@ -225,10 +233,11 @@ extern tree build_component_ref (tree, tree);\n extern tree build_indirect_ref (tree, const char *);\n extern tree build_array_ref (tree, tree);\n extern tree build_external_ref (tree, int);\n-extern tree parser_build_binary_op (enum tree_code, tree, tree);\n+extern struct c_expr parser_build_binary_op (enum tree_code, struct c_expr,\n+\t\t\t\t\t     struct c_expr);\n extern void readonly_error (tree, const char *);\n extern tree build_conditional_expr (tree, tree, tree);\n-extern tree build_compound_expr (tree);\n+extern tree build_compound_expr (tree, tree);\n extern tree c_cast_expr (tree, tree);\n extern tree build_c_cast (tree, tree);\n extern tree build_modify_expr (tree, enum tree_code, tree);"}, {"sha": "29a9ec3abadc03ffaaefa3cd115f2a71c438b7cc", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 31, "deletions": 72, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -62,7 +62,6 @@ static tree default_function_array_conversion (tree);\n static tree lookup_field (tree, tree);\n static tree convert_arguments (tree, tree, tree, tree);\n static tree pointer_diff (tree, tree);\n-static tree internal_build_compound_expr (tree, int);\n static tree convert_for_assignment (tree, tree, const char *, tree, tree,\n \t\t\t\t    int);\n static void warn_for_assignment (const char *, const char *, tree, int);\n@@ -1182,9 +1181,8 @@ default_function_array_conversion (tree exp)\n       exp = TREE_OPERAND (exp, 0);\n     }\n \n-  /* Preserve the original expression code.  */\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (exp))))\n-    C_SET_EXP_ORIGINAL_CODE (exp, C_EXP_ORIGINAL_CODE (orig_exp));\n+  if (TREE_NO_WARNING (orig_exp))\n+    TREE_NO_WARNING (exp) = 1;\n \n   if (code == FUNCTION_TYPE)\n     {\n@@ -1294,9 +1292,8 @@ default_conversion (tree exp)\n \t     && TREE_TYPE (TREE_OPERAND (exp, 0)) == TREE_TYPE (exp)))\n     exp = TREE_OPERAND (exp, 0);\n \n-  /* Preserve the original expression code.  */\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (exp))))\n-    C_SET_EXP_ORIGINAL_CODE (exp, C_EXP_ORIGINAL_CODE (orig_exp));\n+  if (TREE_NO_WARNING (orig_exp))\n+    TREE_NO_WARNING (exp) = 1;\n \n   /* Normally convert enums to int,\n      but convert wide enums to something wider.  */\n@@ -2099,28 +2096,23 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n    we check for operands that were written with other binary operators\n    in a way that is likely to confuse the user.  */\n \n-tree\n-parser_build_binary_op (enum tree_code code, tree arg1, tree arg2)\n+struct c_expr\n+parser_build_binary_op (enum tree_code code, struct c_expr arg1,\n+\t\t\tstruct c_expr arg2)\n {\n-  tree result = build_binary_op (code, arg1, arg2, 1);\n+  struct c_expr result;\n \n-  char class;\n-  char class1 = TREE_CODE_CLASS (TREE_CODE (arg1));\n-  char class2 = TREE_CODE_CLASS (TREE_CODE (arg2));\n-  enum tree_code code1 = ERROR_MARK;\n-  enum tree_code code2 = ERROR_MARK;\n+  enum tree_code code1 = arg1.original_code;\n+  enum tree_code code2 = arg2.original_code;\n \n-  if (TREE_CODE (result) == ERROR_MARK)\n-    return error_mark_node;\n+  result.value = build_binary_op (code, arg1.value, arg2.value, 1);\n+  result.original_code = code;\n \n-  if (IS_EXPR_CODE_CLASS (class1))\n-    code1 = C_EXP_ORIGINAL_CODE (arg1);\n-  if (IS_EXPR_CODE_CLASS (class2))\n-    code2 = C_EXP_ORIGINAL_CODE (arg2);\n+  if (TREE_CODE (result.value) == ERROR_MARK)\n+    return result;\n \n   /* Check for cases such as x+y<<z which users are likely\n-     to misinterpret.  If parens are used, C_EXP_ORIGINAL_CODE\n-     is cleared to prevent these warnings.  */\n+     to misinterpret.  */\n   if (warn_parentheses)\n     {\n       if (code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n@@ -2178,25 +2170,9 @@ parser_build_binary_op (enum tree_code code, tree arg1, tree arg2)\n \n     }\n \n-  unsigned_conversion_warning (result, arg1);\n-  unsigned_conversion_warning (result, arg2);\n-  overflow_warning (result);\n-\n-  class = TREE_CODE_CLASS (TREE_CODE (result));\n-\n-  /* Record the code that was specified in the source,\n-     for the sake of warnings about confusing nesting.  */\n-  if (IS_EXPR_CODE_CLASS (class))\n-    C_SET_EXP_ORIGINAL_CODE (result, code);\n-  else\n-    {\n-      /* We used to use NOP_EXPR rather than NON_LVALUE_EXPR\n-\t so that convert_for_assignment wouldn't strip it.\n-\t That way, we got warnings for things like p = (1 - 1).\n-\t But it turns out we should not get those warnings.  */\n-      result = build1 (NON_LVALUE_EXPR, TREE_TYPE (result), result);\n-      C_SET_EXP_ORIGINAL_CODE (result, code);\n-    }\n+  unsigned_conversion_warning (result.value, arg1.value);\n+  unsigned_conversion_warning (result.value, arg2.value);\n+  overflow_warning (result.value);\n \n   return result;\n }\n@@ -2894,44 +2870,27 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   return fold (build (COND_EXPR, result_type, ifexp, op1, op2));\n }\n \f\n-/* Given a list of expressions, return a compound expression\n-   that performs them all and returns the value of the last of them.  */\n+/* Return a compound expression that performs two expressions and\n+   returns the value of the second of them.  */\n \n tree\n-build_compound_expr (tree list)\n+build_compound_expr (tree expr1, tree expr2)\n {\n-  return internal_build_compound_expr (list, TRUE);\n-}\n-\n-static tree\n-internal_build_compound_expr (tree list, int first_p)\n-{\n-  tree rest;\n-\n-  if (TREE_CHAIN (list) == 0)\n-    {\n-      /* Convert arrays and functions to pointers when there\n-\t really is a comma operator.  */\n-      if (!first_p)\n-\tTREE_VALUE (list)\n-\t  = default_function_array_conversion (TREE_VALUE (list));\n-\n-      /* Don't let (0, 0) be null pointer constant.  */\n-      if (!first_p && integer_zerop (TREE_VALUE (list)))\n-\treturn non_lvalue (TREE_VALUE (list));\n-      return TREE_VALUE (list);\n-    }\n+  /* Convert arrays and functions to pointers.  */\n+  expr2 = default_function_array_conversion (expr2);\n \n-  rest = internal_build_compound_expr (TREE_CHAIN (list), FALSE);\n+  /* Don't let (0, 0) be null pointer constant.  */\n+  if (integer_zerop (expr2))\n+    expr2 = non_lvalue (expr2);\n \n-  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n+  if (! TREE_SIDE_EFFECTS (expr1))\n     {\n       /* The left-hand operand of a comma expression is like an expression\n          statement: with -Wextra or -Wunused, we should warn if it doesn't have\n \t any side-effects, unless it was explicitly cast to (void).  */\n       if (warn_unused_value\n-           && ! (TREE_CODE (TREE_VALUE (list)) == CONVERT_EXPR\n-                && VOID_TYPE_P (TREE_TYPE (TREE_VALUE (list)))))\n+           && ! (TREE_CODE (expr1) == CONVERT_EXPR\n+                && VOID_TYPE_P (TREE_TYPE (expr1))))\n         warning (\"left-hand operand of comma expression has no effect\");\n     }\n \n@@ -2940,9 +2899,9 @@ internal_build_compound_expr (tree list, int first_p)\n      `foo() + bar(), baz()' the result of the `+' operator is not used,\n      so we should issue a warning.  */\n   else if (warn_unused_value)\n-    warn_if_unused_value (TREE_VALUE (list), input_location);\n+    warn_if_unused_value (expr1, input_location);\n \n-  return build (COMPOUND_EXPR, TREE_TYPE (rest), TREE_VALUE (list), rest);\n+  return build (COMPOUND_EXPR, TREE_TYPE (expr2), expr1, expr2);\n }\n \n /* Build an expression representing a cast to type TYPE of expression EXPR.  */"}, {"sha": "00ef4b59ef187a1cd541852b9a318b49fcf4bbaf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -1,3 +1,8 @@\n+2004-07-19  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* typeck.c (build_modify_expr, build_x_modify_expr): Set\n+\tTREE_NO_WARNING on assignments with an operator other than '='.\n+\n 2004-07-10  Steven Bosscher  <stevenb@suse.de>\n \t    Joseph S. Myers  <jsm@polyomino.org.uk>\n "}, {"sha": "0e23e9a48c69c76b2bb1120d8f15e95868c41ea5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -4995,6 +4995,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n   tree olhs = NULL_TREE;\n+  bool plain_assign = (modifycode == NOP_EXPR);\n \n   /* Avoid duplicate error messages from operands that had errors.  */\n   if (lhs == error_mark_node || rhs == error_mark_node)\n@@ -5254,6 +5255,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t\t  lhstype, lhs, newrhs);\n \n   TREE_SIDE_EFFECTS (result) = 1;\n+  if (!plain_assign)\n+    TREE_NO_WARNING (result) = 1;\n \n   /* If we got the LHS in a different type for storing in,\n      convert the result back to the nominal type of LHS\n@@ -5285,7 +5288,10 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t\t\t\tmake_node (modifycode),\n \t\t\t\t/*overloaded_p=*/NULL);\n       if (rval)\n-\treturn rval;\n+\t{\n+\t  TREE_NO_WARNING (rval) = 1;\n+\t  return rval;\n+\t}\n     }\n   return build_modify_expr (lhs, modifycode, rhs);\n }"}, {"sha": "0da09aec33aa374d8863f220f00c5e8745511b3e", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -7870,7 +7870,7 @@ get_super_receiver (void)\n       /* Set receiver to self.  */\n       super_expr = build_component_ref (UOBJC_SUPER_decl, self_id);\n       super_expr = build_modify_expr (super_expr, NOP_EXPR, self_decl);\n-      super_expr_list = build_tree_list (NULL_TREE, super_expr);\n+      super_expr_list = super_expr;\n \n       /* Set class to begin searching.  */\n #ifdef OBJCPLUS\n@@ -7941,12 +7941,12 @@ get_super_receiver (void)\n \t\t\t\t\t       super_class));\n \t}\n \n-      chainon (super_expr_list, build_tree_list (NULL_TREE, super_expr));\n+      super_expr_list = build_compound_expr (super_expr_list, super_expr);\n \n       super_expr = build_unary_op (ADDR_EXPR, UOBJC_SUPER_decl, 0);\n-      chainon (super_expr_list, build_tree_list (NULL_TREE, super_expr));\n+      super_expr_list = build_compound_expr (super_expr_list, super_expr);\n \n-      return build_compound_expr (super_expr_list);\n+      return super_expr_list;\n     }\n   else\n     {"}, {"sha": "6df5bc924787c7b5091bf48f00cd0893773c0acd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -1,3 +1,9 @@\n+2004-07-19  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* g++.dg/warn/Wparentheses-1.C, g++.dg/warn/Wparentheses-2.C,\n+\tgcc.dg/Wparentheses-10.c: New tests.\n+\t* gcc.dg/Wparentheses-5.c: Remove XFAILs.\n+\n 2004-07-18  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/16465"}, {"sha": "34cb58fc77fc40ec9d32e06436471cca54338a86", "filename": "gcc/testsuite/g++.dg/warn/Wparentheses-1.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWparentheses-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWparentheses-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWparentheses-1.C?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -0,0 +1,68 @@\n+// Test operation of -Wparentheses.  Warnings for assignments used as\n+// truth-values.  Essentially the same as gcc.dg/Wparentheses-3.c.\n+// Origin: Joseph Myers <jsm@polyomino.org.uk>\n+\n+// { dg-do compile }\n+// { dg-options \"-Wparentheses\" }\n+\n+int foo (int);\n+\n+int a, b, c;\n+bool d;\n+\n+void\n+bar (void)\n+{\n+  if (a = b) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (0);\n+  if ((a = b))\n+    foo (1);\n+  if (a = a) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (2);\n+  if ((a = a))\n+    foo (3);\n+  if (b = c) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (4);\n+  else\n+    foo (5);\n+  if ((b = c))\n+    foo (6);\n+  else\n+    foo (7);\n+  if (b = b) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (8);\n+  else\n+    foo (9);\n+  if ((b = b))\n+    foo (10);\n+  else\n+    foo (11);\n+  while (c = b) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (12);\n+  while ((c = b))\n+    foo (13);\n+  while (c = c) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (14);\n+  while ((c = c))\n+    foo (15);\n+  do foo (16); while (a = b); // { dg-warning \"assignment\" \"correct warning\" }\n+  do foo (17); while ((a = b));\n+  do foo (18); while (a = a); // { dg-warning \"assignment\" \"correct warning\" }\n+  do foo (19); while ((a = a));\n+  for (;c = b;) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (20);\n+  for (;(c = b);)\n+    foo (21);\n+  for (;c = c;) // { dg-warning \"assignment\" \"correct warning\" }\n+    foo (22);\n+  for (;(c = c);)\n+    foo (23);\n+  d = a = b; // { dg-warning \"assignment\" \"correct warning\" }\n+  foo (24);\n+  d = (a = b);\n+  foo (25);\n+  d = a = a; // { dg-warning \"assignment\" \"correct warning\" }\n+  foo (26);\n+  d = (a = a);\n+  foo (27);\n+}"}, {"sha": "286e2f97cc59914dc3c836040aa28d87c82c3dda", "filename": "gcc/testsuite/g++.dg/warn/Wparentheses-2.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWparentheses-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWparentheses-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWparentheses-2.C?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -0,0 +1,43 @@\n+// Test operation of -Wparentheses.  Warnings for assignments used as\n+// truth-values shouldn't apply other than for plain assignment.\n+// Essentially the same as gcc.dg/Wparentheses-10.c.\n+// Origin: Joseph Myers <jsm@polyomino.org.uk>\n+\n+// { dg-do compile }\n+// { dg-options \"-Wparentheses\" }\n+\n+int foo (int);\n+\n+int a, b, c;\n+bool d;\n+\n+void\n+bar (void)\n+{\n+  if (a += b)\n+    foo (0);\n+  if (a -= a)\n+    foo (1);\n+  if (b *= c)\n+    foo (2);\n+  else\n+    foo (3);\n+  if (b /= b)\n+    foo (4);\n+  else\n+    foo (5);\n+  while (c %= b)\n+    foo (6);\n+  while (c <<= c)\n+    foo (7);\n+  do foo (8); while (a >>= b);\n+  do foo (9); while (a &= a);\n+  for (;c ^= b;)\n+    foo (10);\n+  for (;c |= c;)\n+    foo (11);\n+  d = a += b;\n+  foo (12);\n+  d = a -= a;\n+  foo (13);\n+}"}, {"sha": "aafcae2ad360e31db3bc763f3f2764a1ce2eae8d", "filename": "gcc/testsuite/gcc.dg/Wparentheses-10.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fgcc.dg%2FWparentheses-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fgcc.dg%2FWparentheses-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWparentheses-10.c?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -0,0 +1,42 @@\n+/* Test operation of -Wparentheses.  Warnings for assignments used as\n+   truth-values shouldn't apply other than for plain assignment.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wparentheses -std=gnu99\" } */\n+\n+int foo (int);\n+\n+int a, b, c;\n+_Bool d;\n+\n+void\n+bar (void)\n+{\n+  if (a += b)\n+    foo (0);\n+  if (a -= a)\n+    foo (1);\n+  if (b *= c)\n+    foo (2);\n+  else\n+    foo (3);\n+  if (b /= b)\n+    foo (4);\n+  else\n+    foo (5);\n+  while (c %= b)\n+    foo (6);\n+  while (c <<= c)\n+    foo (7);\n+  do foo (8); while (a >>= b);\n+  do foo (9); while (a &= a);\n+  for (;c ^= b;)\n+    foo (10);\n+  for (;c |= c;)\n+    foo (11);\n+  d = a += b;\n+  foo (12);\n+  d = a -= a;\n+  foo (13);\n+}"}, {"sha": "49c65c21a05a09d4a9a6cfd73a73dbc89dfab834", "filename": "gcc/testsuite/gcc.dg/Wparentheses-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fgcc.dg%2FWparentheses-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487a92fed227132325f624811a4eb80c47da8aca/gcc%2Ftestsuite%2Fgcc.dg%2FWparentheses-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWparentheses-5.c?ref=487a92fed227132325f624811a4eb80c47da8aca", "patch": "@@ -13,10 +13,10 @@ bar (int a, int b, int c)\n   foo (a && b || c); /* { dg-warning \"parentheses\" \"correct warning\" } */\n   foo ((a && b) || c);\n   foo (a && (b || c));\n-  foo (1 && 2 || c); /* { dg-warning \"parentheses\" \"correct warning\" { xfail *-*-* } } */\n+  foo (1 && 2 || c); /* { dg-warning \"parentheses\" \"correct warning\" } */\n   foo ((1 && 2) || c);\n   foo (1 && (2 || c));\n-  foo (1 && 2 || 3); /* { dg-warning \"parentheses\" \"correct warning\" { xfail *-*-* } } */\n+  foo (1 && 2 || 3); /* { dg-warning \"parentheses\" \"correct warning\" } */\n   foo ((1 && 2) || 3);\n   foo (1 && (2 || 3));\n   foo (a || b && c); /* { dg-warning \"parentheses\" \"correct warning\" } */"}]}