{"sha": "ed920373a5faece7ea0bfdfebbd615294165c01c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ5MjAzNzNhNWZhZWNlN2VhMGJmZGZlYmJkNjE1Mjk0MTY1YzAxYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-06-18T23:01:16Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-06-18T23:01:16Z"}, "message": "Implement new serial algorithms from Parallelism TS (P0024R2)\n\nThese new (non-parallel) algorithms were added to C++17 along with the\nparallel algorithms, but were missing from libstdc++.\n\n\t* include/bits/algorithmfwd.h: Change title of doc group.\n\t* include/bits/stl_algo.h (for_each_n): Add new C++17 algorithm from\n\tP0024R2.\n\t* include/bits/stl_numeric.h: Define doc group and add algos to it.\n\t* include/std/numeric (__is_random_access_iter): New internal trait.\n\t(reduce, transform_reduce, exclusive_scan, inclusive_scan)\n\t(transform_exclusive_scan, transform_inclusive_scan): Likewise.\n\t* testsuite/25_algorithms/for_each/for_each_n.cc: New test.\n\t* testsuite/26_numerics/exclusive_scan/1.cc: New test.\n\t* testsuite/26_numerics/inclusive_scan/1.cc: New test.\n\t* testsuite/26_numerics/reduce/1.cc: New test.\n\t* testsuite/26_numerics/transform_exclusive_scan/1.cc: New test.\n\t* testsuite/26_numerics/transform_inclusive_scan/1.cc: New test.\n\t* testsuite/26_numerics/transform_reduce/1.cc: New test.\n\t* testsuite/util/testsuite_iterators.h (test_container::size()): New\n\tmember function.\n\nFrom-SVN: r272459", "tree": {"sha": "b0e17812ec5afc3cb13a4b604dbce907aea79f23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0e17812ec5afc3cb13a4b604dbce907aea79f23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed920373a5faece7ea0bfdfebbd615294165c01c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed920373a5faece7ea0bfdfebbd615294165c01c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed920373a5faece7ea0bfdfebbd615294165c01c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed920373a5faece7ea0bfdfebbd615294165c01c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fe39f194c83e0189a239edf44d9db191c1625fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe39f194c83e0189a239edf44d9db191c1625fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fe39f194c83e0189a239edf44d9db191c1625fa"}], "stats": {"total": 1168, "additions": 1159, "deletions": 9}, "files": [{"sha": "5702523ed1cbfc0997e72d3fcf3d20a4480c93bd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -1,5 +1,22 @@\n 2019-06-18  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/algorithmfwd.h: Change title of doc group.\n+\t* include/bits/stl_algo.h (for_each_n): Add new C++17 algorithm from\n+\tP0024R2.\n+\t* include/bits/stl_numeric.h: Define doc group and add algos to it.\n+\t* include/std/numeric (__is_random_access_iter): New internal trait.\n+\t(reduce, transform_reduce, exclusive_scan, inclusive_scan)\n+\t(transform_exclusive_scan, transform_inclusive_scan): Likewise.\n+\t* testsuite/25_algorithms/for_each/for_each_n.cc: New test.\n+\t* testsuite/26_numerics/exclusive_scan/1.cc: New test.\n+\t* testsuite/26_numerics/inclusive_scan/1.cc: New test.\n+\t* testsuite/26_numerics/reduce/1.cc: New test.\n+\t* testsuite/26_numerics/transform_exclusive_scan/1.cc: New test.\n+\t* testsuite/26_numerics/transform_inclusive_scan/1.cc: New test.\n+\t* testsuite/26_numerics/transform_reduce/1.cc: New test.\n+\t* testsuite/util/testsuite_iterators.h (test_container::size()): New\n+\tmember function.\n+\n \t* include/c_global/cstddef (std::byte): Perform arithmetic operations\n \tin unsigned int to avoid promotion (LWG 2950).\n "}, {"sha": "5e47fffe86e18ec097288dfa1b54c7c8b3799635", "filename": "libstdc++-v3/include/bits/algorithmfwd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -154,7 +154,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   /**\n-   * @defgroup set_algorithms Set Operation\n+   * @defgroup set_algorithms Set Operations\n    * @ingroup sorting_algorithms\n    *\n    * These algorithms are common set operations performed on sequences"}, {"sha": "ca957e0b9a74cc935e85bb83793f528a2967a294", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -3867,6 +3867,39 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       return __f; // N.B. [alg.foreach] says std::move(f) but it's redundant.\n     }\n \n+#if __cplusplus >= 201703L\n+  /**\n+   *  @brief Apply a function to every element of a sequence.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first  An input iterator.\n+   *  @param  __n      A value convertible to an integer.\n+   *  @param  __f      A unary function object.\n+   *  @return   `__first+__n`\n+   *\n+   *  Applies the function object `__f` to each element in the range\n+   *  `[first, first+n)`.  `__f` must not modify the order of the sequence.\n+   *  If `__f` has a return value it is ignored.\n+  */\n+  template<typename _InputIterator, typename _Size, typename _Function>\n+    _InputIterator\n+    for_each_n(_InputIterator __first, _Size __n, _Function __f)\n+    {\n+      auto __n2 = std::__size_to_integer(__n);\n+      using _Cat = typename iterator_traits<_InputIterator>::iterator_category;\n+      if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>)\n+\treturn std::for_each(__first, __first + __n2, __f);\n+      else\n+\t{\n+\t  while (__n2-->0)\n+\t    {\n+\t      __f(*__first);\n+\t      ++__first;\n+\t    }\n+\t  return __first;\n+\t}\n+    }\n+#endif // C++17\n+\n   /**\n    *  @brief Find the first occurrence of a value in a sequence.\n    *  @ingroup non_mutating_algorithms"}, {"sha": "387bed911747c61324896d83e23a05df0b70c3d3", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -60,12 +60,16 @@\n #include <debug/debug.h>\n #include <bits/move.h> // For _GLIBCXX_MOVE\n \n-#if __cplusplus >= 201103L\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  /** @defgroup numeric_ops Generalized Numeric operations\n+   *  @ingroup algorithms\n+   */\n+\n+#if __cplusplus >= 201103L\n   /**\n    *  @brief  Create a range of sequentially increasing values.\n    *\n@@ -76,6 +80,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @param  __last  End of range.\n    *  @param  __value  Starting value.\n    *  @return  Nothing.\n+   *  @ingroup numeric_ops\n    */\n   template<typename _ForwardIterator, typename _Tp>\n     void\n@@ -94,14 +99,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  ++__value;\n \t}\n     }\n+#endif\n \n _GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace std\n \n-#endif\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n _GLIBCXX_BEGIN_NAMESPACE_ALGO\n \n #if __cplusplus > 201703L\n@@ -112,6 +113,9 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n # define _GLIBCXX_MOVE_IF_20(_E) _E\n #endif\n \n+  /// @addtogroup numeric_ops\n+  /// @{\n+\n   /**\n    *  @brief  Accumulate values in a range.\n    *\n@@ -139,8 +143,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n   /**\n    *  @brief  Accumulate values in a range with operation.\n    *\n-   *  Accumulates the values in the range [first,last) using the function\n-   *  object @p __binary_op.  The initial value is @p __init.  The values are\n+   *  Accumulates the values in the range `[first,last)` using the function\n+   *  object `__binary_op`.  The initial value is `__init`.  The values are\n    *  processed in order.\n    *\n    *  @param  __first  Start of range.\n@@ -390,6 +394,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       return ++__result;\n     }\n \n+  // @} group numeric_ops\n+\n #undef _GLIBCXX_MOVE_IF_20\n \n _GLIBCXX_END_NAMESPACE_ALGO"}, {"sha": "66792506d10ea6c11db9ee442228417145d71a74", "filename": "libstdc++-v3/include/std/numeric", "status": "modified", "additions": 466, "deletions": 0, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -205,6 +205,472 @@ _GLIBCXX_END_NAMESPACE_VERSION\n #endif // C++14\n \n #if __cplusplus > 201402L\n+#include <bits/stl_function.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /// @addtogroup numeric_ops\n+  /// @{\n+\n+  /// @cond undocumented\n+  template<typename _It, typename _Traits = iterator_traits<_It>,\n+\t   typename _Cat = typename _Traits::iterator_category>\n+    using __is_random_access_iter\n+      = is_base_of<random_access_iterator_tag, _Cat>;\n+  /// @endcond\n+\n+  /**\n+   *  @brief  Calculate reduction of values in a range.\n+   *\n+   *  @param  __first  Start of range.\n+   *  @param  __last  End of range.\n+   *  @param  __init  Starting value to add other values to.\n+   *  @param  __binary_op A binary function object.\n+   *  @return  The final sum.\n+   *\n+   *  Reduce the values in the range `[first,last)` using a binary operation.\n+   *  The initial value is `init`.  The values are not necessarily processed\n+   *  in order.\n+   *\n+   *  This algorithm is similar to `std::accumulate` but is not required to\n+   *  perform the operations in order from first to last. For operations\n+   *  that are commutative and associative the result will be the same as\n+   *  for `std::accumulate`, but for other operations (such as floating point\n+   *  arithmetic) the result can be different.\n+   */\n+  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>\n+    _Tp\n+    reduce(_InputIterator __first, _InputIterator __last, _Tp __init,\n+\t   _BinaryOperation __binary_op)\n+    {\n+      using value_type = typename iterator_traits<_InputIterator>::value_type;\n+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation, _Tp&, _Tp&>);\n+      static_assert(is_convertible_v<value_type, _Tp>);\n+      if constexpr (__is_random_access_iter<_InputIterator>::value)\n+\t{\n+\t  while ((__last - __first) >= 4)\n+\t    {\n+\t      _Tp __v1 = __binary_op(__first[0], __first[1]);\n+\t      _Tp __v2 = __binary_op(__first[2], __first[3]);\n+\t      _Tp __v3 = __binary_op(__v1, __v2);\n+\t      __init = __binary_op(__init, __v3);\n+\t      __first += 4;\n+\t    }\n+\t}\n+      for (; __first != __last; ++__first)\n+\t__init = __binary_op(__init, *__first);\n+      return __init;\n+    }\n+\n+ /**\n+   *  @brief  Calculate reduction of values in a range.\n+   *\n+   *  @param  __first  Start of range.\n+   *  @param  __last  End of range.\n+   *  @param  __init  Starting value to add other values to.\n+   *  @return  The final sum.\n+   *\n+   *  Reduce the values in the range `[first,last)` using addition.\n+   *  Equivalent to calling std::reduce(first, last, init, std::plus<>())`.\n+   */\n+  template<typename _InputIterator, typename _Tp>\n+    inline _Tp\n+    reduce(_InputIterator __first, _InputIterator __last, _Tp __init)\n+    { return std::reduce(__first, __last, __init, plus<>()); }\n+\n+  /**\n+   *  @brief  Calculate reduction of values in a range.\n+   *\n+   *  @param  __first  Start of range.\n+   *  @param  __last  End of range.\n+   *  @return  The final sum.\n+   *\n+   *  Reduce the values in the range `[first,last)` using addition, with\n+   *  an initial value of `T{}`, where `T` is the iterator's value type.\n+   *  Equivalent to calling std::reduce(first, last, T{}, std::plus<>())`.\n+   */\n+  template<typename _InputIterator>\n+    inline typename iterator_traits<_InputIterator>::value_type\n+    reduce(_InputIterator __first, _InputIterator __last)\n+    {\n+      using value_type = typename iterator_traits<_InputIterator>::value_type;\n+      return std::reduce(__first, __last, value_type{}, plus<>());\n+    }\n+\n+  /**\n+   *  @brief  Combine elements from two ranges and reduce\n+   *\n+   *  @param  __first1  Start of first range.\n+   *  @param  __last1  End of first range.\n+   *  @param  __first2  Start of second range.\n+   *  @param  __init  Starting value to add other values to.\n+   *  @param  __binary_op1 The function used to perform reduction.\n+   *  @param  __binary_op2 The function used to combine values from the ranges.\n+   *  @return  The final sum.\n+   *\n+   *  Call `binary_op2(first1[n],first2[n])` for each `n` in `[0,last1-first1)`\n+   *  and then use `binary_op1` to reduce the values returned by `binary_op2`\n+   *  to a single value of type `T`.\n+   *\n+   *  The range beginning at `first2` must contain at least `last1-first1`\n+   *  elements.\n+   */\n+  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,\n+\t   typename _BinaryOperation1, typename _BinaryOperation2>\n+    _Tp\n+    transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t\t     _InputIterator2 __first2, _Tp __init,\n+\t\t     _BinaryOperation1 __binary_op1,\n+\t\t     _BinaryOperation2 __binary_op2)\n+    {\n+      if constexpr (__and_v<__is_random_access_iter<_InputIterator1>,\n+\t\t\t    __is_random_access_iter<_InputIterator2>>)\n+\t{\n+\t  while ((__last1 - __first1) >= 4)\n+\t    {\n+\t      _Tp __v1 = __binary_op1(__binary_op2(__first1[0], __first2[0]),\n+\t\t\t\t      __binary_op2(__first1[1], __first2[1]));\n+\t      _Tp __v2 = __binary_op1(__binary_op2(__first1[2], __first2[2]),\n+\t\t\t\t      __binary_op2(__first1[3], __first2[3]));\n+\t      _Tp __v3 = __binary_op1(__v1, __v2);\n+\t      __init = __binary_op1(__init, __v3);\n+\t      __first1 += 4;\n+\t      __first2 += 4;\n+\t    }\n+\t}\n+      for (; __first1 != __last1; ++__first1, (void) ++__first2)\n+\t__init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n+      return __init;\n+    }\n+\n+  /**\n+   *  @brief  Combine elements from two ranges and reduce\n+   *\n+   *  @param  __first1  Start of first range.\n+   *  @param  __last1  End of first range.\n+   *  @param  __first2  Start of second range.\n+   *  @param  __init  Starting value to add other values to.\n+   *  @return  The final sum.\n+   *\n+   *  Call `first1[n]*first2[n]` for each `n` in `[0,last1-first1)` and then\n+   *  use addition to sum those products to a single value of type `T`.\n+   *\n+   *  The range beginning at `first2` must contain at least `last1-first1`\n+   *  elements.\n+   */\n+  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>\n+    inline _Tp\n+    transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t\t     _InputIterator2 __first2, _Tp __init)\n+    {\n+      return std::transform_reduce(__first1, __last1, __first2,\n+\t\t\t\t   std::move(__init),\n+\t\t\t\t   plus<>(), multiplies<>());\n+    }\n+\n+  /**\n+   *  @brief  Transform the elements of a range and reduce\n+   *\n+   *  @param  __first  Start of range.\n+   *  @param  __last  End of range.\n+   *  @param  __init  Starting value to add other values to.\n+   *  @param  __binary_op The function used to perform reduction.\n+   *  @param  __unary_op The function used to transform values from the range.\n+   *  @return  The final sum.\n+   *\n+   *  Call `unary_op(first[n])` for each `n` in `[0,last-first)` and then\n+   *  use `binary_op` to reduce the values returned by `unary_op`\n+   *  to a single value of type `T`.\n+   */\n+  template<typename _InputIterator, typename _Tp,\n+\t   typename _BinaryOperation, typename _UnaryOperation>\n+    _Tp\n+    transform_reduce(_InputIterator __first, _InputIterator __last, _Tp __init,\n+\t\t     _BinaryOperation __binary_op, _UnaryOperation __unary_op)\n+    {\n+      if constexpr (__is_random_access_iter<_InputIterator>::value)\n+\t{\n+\t  while ((__last - __first) >= 4)\n+\t    {\n+\t      _Tp __v1 = __binary_op(__unary_op(__first[0]),\n+\t\t\t\t     __unary_op(__first[1]));\n+\t      _Tp __v2 = __binary_op(__unary_op(__first[2]),\n+\t\t\t\t     __unary_op(__first[3]));\n+\t      _Tp __v3 = __binary_op(__v1, __v2);\n+\t      __init = __binary_op(__init, __v3);\n+\t      __first += 4;\n+\t    }\n+\t}\n+      for (; __first != __last; ++__first)\n+\t__init = __binary_op(__init, __unary_op(*__first));\n+      return __init;\n+    }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @param __init   Initial value.\n+   *  @param __binary_op Function to perform summation.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements (and the initial value),\n+   *  using `binary_op` for summation.\n+   *\n+   *  This function generates an \"exclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N-1 input elements,\n+   *  so the Nth input element is not included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator, typename _Tp,\n+\t   typename _BinaryOperation>\n+    _OutputIterator\n+    exclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t   _OutputIterator __result, _Tp __init,\n+\t\t   _BinaryOperation __binary_op)\n+    {\n+      while (__first != __last)\n+\t{\n+\t  auto __v = __init;\n+\t  __init = __binary_op(__init, *__first);\n+\t  ++__first;\n+\t  *__result++ = std::move(__v);\n+\t}\n+      return __result;\n+    }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @param __init   Initial value.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements (and the initial value),\n+   *  using `std::plus<>` for summation.\n+   *\n+   *  This function generates an \"exclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N-1 input elements,\n+   *  so the Nth input element is not included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator, typename _Tp>\n+    inline _OutputIterator\n+    exclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t   _OutputIterator __result, _Tp __init)\n+    {\n+      return std::exclusive_scan(__first, __last, __result, std::move(__init),\n+\t\t\t\t plus<>());\n+    }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @param __binary_op Function to perform summation.\n+   *  @param __init   Initial value.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements (and the initial value),\n+   *  using `binary_op` for summation.\n+   *\n+   *  This function generates an \"inclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N input elements,\n+   *  so the Nth input element is included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator,\n+\t   typename _BinaryOperation, typename _Tp>\n+    _OutputIterator\n+    inclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t   _OutputIterator __result, _BinaryOperation __binary_op,\n+\t\t   _Tp __init)\n+    {\n+      for (; __first != __last; ++__first)\n+\t*__result++ = __init = __binary_op(__init, *__first);\n+      return __result;\n+    }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @param __binary_op Function to perform summation.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements, using `binary_op` for summation.\n+   *\n+   *  This function generates an \"inclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N input elements,\n+   *  so the Nth input element is included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    _OutputIterator\n+    inclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t   _OutputIterator __result, _BinaryOperation __binary_op)\n+    {\n+      if (__first != __last)\n+\t{\n+\t  auto __init = *__first;\n+\t  *__result++ = __init;\n+\t  ++__first;\n+\t  if (__first != __last)\n+\t    __result = std::inclusive_scan(__first, __last, __result,\n+\t\t\t\t\t   __binary_op, std::move(__init));\n+\t}\n+      return __result;\n+    }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements, using `std::plus<>` for summation.\n+   *\n+   *  This function generates an \"inclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N input elements,\n+   *  so the Nth input element is included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator>\n+    inline _OutputIterator\n+    inclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t   _OutputIterator __result)\n+    { return std::inclusive_scan(__first, __last, __result, plus<>()); }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @param __init   Initial value.\n+   *  @param __binary_op Function to perform summation.\n+   *  @param __unary_op Function to transform elements of the input range.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements (and the initial value),\n+   *  using `__unary_op` to transform the input elements\n+   *  and using `__binary_op` for summation.\n+   *\n+   *  This function generates an \"exclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N-1 input elements,\n+   *  so the Nth input element is not included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator, typename _Tp,\n+\t   typename _BinaryOperation, typename _UnaryOperation>\n+    _OutputIterator\n+    transform_exclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t\t     _OutputIterator __result, _Tp __init,\n+\t\t\t     _BinaryOperation __binary_op,\n+\t\t\t     _UnaryOperation __unary_op)\n+    {\n+      while (__first != __last)\n+\t{\n+\t  auto __v = __init;\n+\t  __init = __binary_op(__init, __unary_op(*__first));\n+\t  ++__first;\n+\t  *__result++ = std::move(__v);\n+\t}\n+      return __result;\n+    }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @param __binary_op Function to perform summation.\n+   *  @param __unary_op Function to transform elements of the input range.\n+   *  @param __init   Initial value.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements (and the initial value),\n+   *  using `__unary_op` to transform the input elements\n+   *  and using `__binary_op` for summation.\n+   *\n+   *  This function generates an \"inclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N input elements,\n+   *  so the Nth input element is included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator,\n+\t   typename _BinaryOperation, typename _UnaryOperation, typename _Tp>\n+    _OutputIterator\n+    transform_inclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t\t     _OutputIterator __result,\n+\t\t\t     _BinaryOperation __binary_op,\n+\t\t\t     _UnaryOperation __unary_op,\n+\t\t\t     _Tp __init)\n+    {\n+      for (; __first != __last; ++__first)\n+\t*__result++ = __init = __binary_op(__init, __unary_op(*__first));\n+      return __result;\n+    }\n+\n+  /** @brief Output the cumulative sum of one range to a second range\n+   *\n+   *  @param __first  Start of input range.\n+   *  @param __last   End of input range.\n+   *  @param __result Start of output range.\n+   *  @param __binary_op Function to perform summation.\n+   *  @param __unary_op Function to transform elements of the input range.\n+   *  @return The end of the output range.\n+   *\n+   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range\n+   *  to the output range. Each element of the output range contains the\n+   *  running total of all earlier elements,\n+   *  using `__unary_op` to transform the input elements\n+   *  and using `__binary_op` for summation.\n+   *\n+   *  This function generates an \"inclusive\" scan, meaning the Nth element\n+   *  of the output range is the sum of the first N input elements,\n+   *  so the Nth input element is included.\n+   */\n+  template<typename _InputIterator, typename _OutputIterator,\n+\t  typename _BinaryOperation, typename _UnaryOperation>\n+    _OutputIterator\n+    transform_inclusive_scan(_InputIterator __first, _InputIterator __last,\n+\t\t\t     _OutputIterator __result,\n+\t\t\t     _BinaryOperation __binary_op,\n+\t\t\t     _UnaryOperation __unary_op)\n+    {\n+      if (__first != __last)\n+\t{\n+\t  auto __init = __unary_op(*__first);\n+\t  *__result++ = __init;\n+\t  ++__first;\n+\t  if (__first != __last)\n+\t    __result = std::transform_inclusive_scan(__first, __last, __result,\n+\t\t\t\t\t\t     __binary_op, __unary_op,\n+\t\t\t\t\t\t     std::move(__init));\n+\t}\n+      return __result;\n+    }\n+\n+  // @} group numeric_ops\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n // Parallel STL algorithms\n # if _PSTL_EXECUTION_POLICIES_DEFINED\n // If <execution> has already been included, pull in implementations"}, {"sha": "57c2bbe6d3639f965b7c7703b14c16c6802dbe1c", "filename": "libstdc++-v3/testsuite/25_algorithms/for_each/for_each_n.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Ffor_each_n.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Ffor_each_n.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Ffor_each_n.cc?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+void test01()\n+{\n+  using __gnu_test::test_container;\n+  using __gnu_test::input_iterator_wrapper;\n+  int array[5] = { 1, 2, 3, 4, 5 };\n+  test_container<int, input_iterator_wrapper> con(array);\n+\n+  int sum = 0;\n+  struct Func\n+  {\n+    Func(int& i) : i(i) { }\n+    Func(Func&&) = default;\n+    Func& operator=(Func&&) = delete;\n+    void operator()(int n) const { i += n; }\n+    int& i;\n+  };\n+\n+  struct Size\n+  {\n+    Size(short v) : val(v) { }\n+    operator short() const { return val; }\n+    short val;\n+  };\n+  auto res = std::for_each_n(con.begin(), Size(con.size()), Func(sum));\n+\n+  VERIFY( res.ptr == con.end().ptr );\n+  VERIFY( sum == 15 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "05a0135d7abeea97a2890f8e4cdbd7e2156d7939", "filename": "libstdc++-v3/testsuite/26_numerics/exclusive_scan/1.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fexclusive_scan%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fexclusive_scan%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fexclusive_scan%2F1.cc?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -0,0 +1,94 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 29.8.7 [exclusive.scan]\n+\n+#include <numeric>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+/*\n+template<class InputIterator, class OutputIterator, class T>\n+  OutputIterator\n+  exclusive_scan(InputIterator, InputIterator, OutputIterator, T);\n+*/\n+void\n+test01()\n+{\n+  int out[10];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::exclusive_scan(ca.begin(), ca.end(), co.begin(), 5);\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+10 );\n+  VERIFY( out[0] == 5 );\n+  VERIFY( out[1] == 6 );\n+  VERIFY( out[2] == 8 );\n+  VERIFY( out[3] == 11 );\n+  VERIFY( out[4] == 15 );\n+  VERIFY( out[5] == 20 );\n+  VERIFY( out[6] == 26 );\n+  VERIFY( out[7] == 33 );\n+  VERIFY( out[8] == 41 );\n+  VERIFY( out[9] == 50 );\n+}\n+\n+/*\n+template<class InputIterator, class OutputIterator, class T,\n+\t class BinaryOperation>\n+  OutputIterator\n+  exclusive_scan(InputIterator, InputIterator, OutputIterator, T,\n+\t\t BinaryOperation);\n+*/\n+void\n+test02()\n+{\n+  int out[10];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::exclusive_scan(ca.begin(), ca.end(), co.begin(), 2,\n+\t\t\t\t [](int i, int j) { return 2*i + 2*j; });\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+10 );\n+  VERIFY( out[0] == 2 );\n+  VERIFY( out[1] == 6 );\n+  VERIFY( out[2] == 16 );\n+  VERIFY( out[3] == 38 );\n+  VERIFY( out[4] == 84 );\n+  VERIFY( out[5] == 178 );\n+  VERIFY( out[6] == 368 );\n+  VERIFY( out[7] == 750 );\n+  VERIFY( out[8] == 1516 );\n+  VERIFY( out[9] == 3050 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "68f1578928c908945fab7a50c8fb1df407d8f389", "filename": "libstdc++-v3/testsuite/26_numerics/inclusive_scan/1.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Finclusive_scan%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Finclusive_scan%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Finclusive_scan%2F1.cc?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -0,0 +1,123 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 29.8.8 [inclusive.scan]\n+\n+#include <numeric>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+/*\n+template<class InputIterator, class OutputIterator>\n+  OutputIterator\n+  inclusive_scan(InputIterator, InputIterator, OutputIterator);\n+*/\n+void\n+test01()\n+{\n+  int out[10];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::inclusive_scan(ca.begin(), ca.end(), co.begin());\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+10 );\n+  VERIFY( out[0] == 1 );\n+  VERIFY( out[1] == (1+2) );\n+  VERIFY( out[2] == (1+2+3) );\n+  VERIFY( out[3] == (1+2+3+4) );\n+  VERIFY( out[4] == (1+2+3+4+5) );\n+  VERIFY( out[5] == (1+2+3+4+5+6) );\n+  VERIFY( out[6] == (1+2+3+4+5+6+7) );\n+  VERIFY( out[7] == (1+2+3+4+5+6+7+8) );\n+  VERIFY( out[8] == (1+2+3+4+5+6+7+8+9) );\n+  VERIFY( out[9] == (1+2+3+4+5+6+7+8+9+10) );\n+}\n+\n+/*\n+template<class InputIterator, class OutputIterator, class BinaryOperation>\n+  OutputIterator\n+  inclusive_scan(InputIterator, InputIterator, OutputIterator,\n+\t\t BinaryOperation);\n+*/\n+void\n+test02()\n+{\n+  int out[10];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::inclusive_scan(ca.begin(), ca.end(), co.begin(),\n+\t\t\t\t [](int i, int j) { return 2*i + 2*j; });\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+10 );\n+  VERIFY( out[0] == 1 );\n+  VERIFY( out[1] == (2*1+2*2) );\n+  VERIFY( out[2] == (2*6+2*3) );\n+  VERIFY( out[3] == (2*18+2*4) );\n+  VERIFY( out[4] == (2*44+2*5) );\n+  VERIFY( out[5] == (2*98+2*6));\n+  VERIFY( out[6] == (2*208+2*7) );\n+  VERIFY( out[7] == (2*430+2*8) );\n+  VERIFY( out[8] == (2*876+2*9) );\n+  VERIFY( out[9] == (2*1770+2*10) );\n+}\n+\n+/*\n+template<class InputIterator, class OutputIterator, class BinaryOperation, T>\n+  OutputIterator\n+  inclusive_scan(InputIterator, InputIterator, OutputIterator,\n+\t\t BinaryOperation, T);\n+*/\n+void\n+test03()\n+{\n+  int out[10];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::inclusive_scan(ca.begin(), ca.end(), co.begin(),\n+\t\t\t\t [](int i, int j) { return 2*i + 2*j; },\n+\t\t\t\t 1);\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+10 );\n+  VERIFY( out[0] == 4 );\n+  VERIFY( out[1] == (2*4+2*2) );\n+  VERIFY( out[2] == (2*12+2*3) );\n+  VERIFY( out[3] == (2*30+2*4) );\n+  VERIFY( out[4] == (2*68+2*5) );\n+  VERIFY( out[5] == (2*146+2*6) );\n+  VERIFY( out[6] == (2*304+2*7));\n+  VERIFY( out[7] == (2*622+2*8) );\n+  VERIFY( out[8] == (2*1260+2*9) );\n+  VERIFY( out[9] == (2*2538+2*10) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "0434d2ecf49e607c8863d96470c3f9eba6217352", "filename": "libstdc++-v3/testsuite/26_numerics/reduce/1.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Freduce%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Freduce%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Freduce%2F1.cc?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 29.8.3 [reduce]\n+\n+#include <numeric>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+/*\n+template<class InputIterator>\n+  iterator_traits<InputIterator>::value_type\n+  reduce(InputIterator, InputIterator);\n+*/\n+void\n+test01()\n+{\n+  using __gnu_test::test_container;\n+  using __gnu_test::input_iterator_wrapper;\n+  int array[5] = { 1, 2, 3, 4, 5 };\n+  test_container<int, input_iterator_wrapper> con(array);\n+  int res = std::reduce(con.begin(), con.end());\n+  VERIFY( res == 15 );\n+}\n+\n+/*\n+template<class InputIterator, class T>\n+  T reduce(InputIterator, InputIterator, T);\n+*/\n+void\n+test02()\n+{\n+  bool b[] = {true, false, true, true, false, true, false, true, true, false};\n+  int res = std::reduce(std::begin(b), std::end(b), 100);\n+  VERIFY( res == 106 );\n+}\n+\n+/*\n+template<class InputIterator, class T>\n+  T reduce(InputIterator, InputIterator, T);\n+template<class InputIterator, class T, class BinaryOperation>\n+  T reduce(InputIterator, InputIterator, T, BinaryOperation);\n+*/\n+void\n+test03()\n+{\n+  int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+\n+  auto res = std::reduce(std::begin(a), std::end(a), (short)11);\n+  static_assert(std::is_same_v<decltype(res), short>);\n+  VERIFY( res == 66 );\n+\n+  auto res2 = std::reduce(std::begin(a), std::end(a), -1l, std::multiplies<>());\n+  static_assert(std::is_same_v<decltype(res2), long>);\n+  VERIFY( res2 == -3628800 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "61dca6af6ac2f85ee844bddc90c4979197c2d09e", "filename": "libstdc++-v3/testsuite/26_numerics/transform_exclusive_scan/1.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_exclusive_scan%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_exclusive_scan%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_exclusive_scan%2F1.cc?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 29.8.9 [transform.exclusive.scan]\n+\n+#include <numeric>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+int a[] = {1, 2, 3, 4, 5, 6, 7};\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+/*\n+template<class InputIterator, class OutputIterator, class T,\n+\t class BinaryOperation, class UnaryOperation>\n+  OutputIterator\n+  transform_exclusive_scan(InputIterator, InputIterator, OutputIterator, T,\n+\t\t\t   BinaryOperation, UnaryOperation);\n+*/\n+void\n+test01()\n+{\n+  int out[7];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::transform_exclusive_scan(ca.begin(), ca.end(), co.begin(), 5,\n+\t\t\t\t\t   std::multiplies<>(),\n+\t\t\t\t\t   std::negate<>());\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+7 );\n+  VERIFY( out[0] == 5 );\n+  VERIFY( out[1] == -5 );\n+  VERIFY( out[2] == 10 );\n+  VERIFY( out[3] == -30 );\n+  VERIFY( out[4] == 120 );\n+  VERIFY( out[5] == -600 );\n+  VERIFY( out[6] == 3600 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "16eeedb58ee54987e7bb7cc7715dc009df8cb509", "filename": "libstdc++-v3/testsuite/26_numerics/transform_inclusive_scan/1.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_inclusive_scan%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_inclusive_scan%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_inclusive_scan%2F1.cc?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -0,0 +1,94 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 29.8.10 [transform.inclusive.scan]\n+\n+#include <numeric>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+int a[] = {1, 2, 3, 4, 5, 6, 7};\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+/*\n+template<class InputIterator, class OutputIterator, class BinaryOperation,\n+\t class UnaryOperation>\n+  OutputIterator\n+  transform_inclusive_scan(InputIterator, InputIterator, OutputIterator,\n+\t\t\t   BinaryOperation, UnaryOperation);\n+*/\n+void\n+test01()\n+{\n+  int out[7];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::transform_inclusive_scan(ca.begin(), ca.end(), co.begin(),\n+\t\t\t\t\t   std::multiplies<>(),\n+\t\t\t\t\t   [](int i) { return i+1; });\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+7 );\n+  VERIFY( out[0] == 2 );\n+  VERIFY( out[1] == (2*3) );\n+  VERIFY( out[2] == (2*3*4) );\n+  VERIFY( out[3] == (2*3*4*5) );\n+  VERIFY( out[4] == (2*3*4*5*6) );\n+  VERIFY( out[5] == (2*3*4*5*6*7) );\n+  VERIFY( out[6] == (2*3*4*5*6*7*8) );\n+}\n+\n+/*\n+template<class InputIterator, class OutputIterator, class BinaryOperation,\n+\t class UnaryOperation, class T>\n+  OutputIterator\n+  transform_inclusive_scan(InputIterator, InputIterator, OutputIterator,\n+\t\t\t   BinaryOperation, UnaryOperation, T);\n+*/\n+void\n+test02()\n+{\n+  int out[7];\n+  test_container<int, output_iterator_wrapper> co(out);\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  auto end = std::transform_inclusive_scan(ca.begin(), ca.end(), co.begin(),\n+\t\t\t\t\t   std::multiplies<>(),\n+\t\t\t\t\t   [](int i) { return i+1; },\n+\t\t\t\t\t   3);\n+  static_assert(std::is_same_v<decltype(end), decltype(co.begin())>);\n+  VERIFY( end.ptr == out+7 );\n+  VERIFY( out[0] == 3*2 );\n+  VERIFY( out[1] == (3*2*3) );\n+  VERIFY( out[2] == (3*2*3*4) );\n+  VERIFY( out[3] == (3*2*3*4*5) );\n+  VERIFY( out[4] == (3*2*3*4*5*6) );\n+  VERIFY( out[5] == (3*2*3*4*5*6*7) );\n+  VERIFY( out[6] == (3*2*3*4*5*6*7*8) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "bb9a5bbce7efd1e168c7b388b135504cd07cbeeb", "filename": "libstdc++-v3/testsuite/26_numerics/transform_reduce/1.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_reduce%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_reduce%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Ftransform_reduce%2F1.cc?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -0,0 +1,109 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 29.8.5 [transform.reduce]\n+\n+#include <numeric>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+double b[] = {0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5};\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+\n+/*\n+template<class InputIterator1, class InputIterator2, class T>\n+  T transform_reduce(InputIterator1, InputIterator1, InputIterator2, T);\n+*/\n+void\n+test01()\n+{\n+  auto res = std::transform_reduce(std::begin(a), std::end(a), std::begin(b),\n+\t\t\t\t   1.0f);\n+  static_assert(std::is_same_v<decltype(res), float>);\n+  VERIFY( res == (float)(1 + 0.5 + 1 + 1.5 + 2 + 2.5 + 3 + 3.5 + 4 + 4.5 + 5) );\n+\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  test_container<double, input_iterator_wrapper> cb(b);\n+\n+  auto res2 = std::transform_reduce(ca.begin(), ca.end(), cb.begin(),\n+\t\t\t\t   1.0f);\n+  static_assert(std::is_same_v<decltype(res2), float>);\n+  VERIFY( res2 == res );\n+}\n+\n+/*\n+template<class InputIterator1, class InputIterator2, class T,\n+\t class BinaryOperation1, class BinaryOperation2>\n+  T transform_reduce(InputIterator1, InputIterator1, InputIterator2, T,\n+\t\t     BinaryOperation1, BinaryOperation2);\n+*/\n+void\n+test02()\n+{\n+  auto res = std::transform_reduce(std::begin(a), std::end(a), std::begin(b),\n+\t\t\t\t    1L, std::multiplies<>(), std::plus<int>());\n+  static_assert(std::is_same_v<decltype(res), long>);\n+  VERIFY( res == (1L * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10) );\n+\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  test_container<double, input_iterator_wrapper> cb(b);\n+\n+  auto res2 = std::transform_reduce(ca.begin(), ca.end(), cb.begin(),\n+\t\t\t\t    1L, std::multiplies<>(), std::plus<int>());\n+  static_assert(std::is_same_v<decltype(res2), long>);\n+  VERIFY( res2 == res );\n+}\n+\n+/*\n+template<class InputIterator, class T, class BinaryOperation,\n+\t class UnaryOperation>\n+  T transform_reduce(InputIterator, InputIterator, T,\n+\t\t     BinaryOperation, UnaryOperation);\n+*/\n+void\n+test03()\n+{\n+  auto res = std::transform_reduce(std::begin(a), std::end(a), 10.0,\n+\t\t\t\t   std::plus<>(),\n+\t\t\t\t   [](int i) { return i * i; });\n+  static_assert(std::is_same_v<decltype(res), double>);\n+  VERIFY( res == (10.0 + 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81 + 100) );\n+\n+  test_container<int, input_iterator_wrapper> ca(a);\n+  test_container<double, input_iterator_wrapper> cb(b);\n+\n+  auto res2 = std::transform_reduce(ca.begin(), ca.end(), 10.0,\n+\t\t\t\t   std::plus<>(),\n+\t\t\t\t   [](int i) { return i * i; });\n+  static_assert(std::is_same_v<decltype(res2), double>);\n+  VERIFY( res2 == (10.0 + 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81 + 100) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "ac646a59cb8350ee01f2a8e2990d7466dcc3c18a", "filename": "libstdc++-v3/testsuite/util/testsuite_iterators.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed920373a5faece7ea0bfdfebbd615294165c01c/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h?ref=ed920373a5faece7ea0bfdfebbd615294165c01c", "patch": "@@ -589,6 +589,10 @@ namespace __gnu_test\n     ItType<T>\n     end()\n     { return it(bounds.last); }\n+\n+    std::size_t\n+    size() const\n+    { return bounds.last - bounds.first; }\n   };\n }\n #endif"}]}