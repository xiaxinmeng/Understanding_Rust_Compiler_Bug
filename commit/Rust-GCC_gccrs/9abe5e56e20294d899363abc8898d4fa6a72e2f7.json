{"sha": "9abe5e56e20294d899363abc8898d4fa6a72e2f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFiZTVlNTZlMjAyOTRkODk5MzYzYWJjODg5OGQ0ZmE2YTcyZTJmNw==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-09-29T07:42:42Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-09-29T07:42:42Z"}, "message": "re PR fortran/39626 (Correctly implement details of Fortran 2008 BLOCK construct)\n\n2009-09-29  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/39626\n\t* gfortran.h (enum gfc_statement): Add ST_BLOCK and ST_END_BLOCK.\n\t(struct gfc_namespace): Convert flags to bit-fields and add flag\n\t`construct_entities' for use with BLOCK constructs.\n\t(enum gfc_exec_code): Add EXEC_BLOCK.\n\t(struct gfc_code): Add namespace field to union for EXEC_BLOCK.\n\t* match.h (gfc_match_block): New prototype.\n\t* parse.h (enum gfc_compile_state): Add COMP_BLOCK.\n\t* trans.h (gfc_process_block_locals): New prototype.\n\t(gfc_trans_deferred_vars): Made public, new prototype.\n\t* trans-stmt.h (gfc_trans_block_construct): New prototype.\n\t* decl.c (gfc_match_end): Handle END BLOCK correctly.\n\t(gfc_match_intent): Error if inside of BLOCK.\n\t(gfc_match_optional), (gfc_match_value): Ditto.\n\t* match.c (gfc_match_block): New routine.\n\t* parse.c (decode_statement): Handle BLOCK statement.\n\t(case_exec_markers): Add ST_BLOCK.\n\t(case_end): Add ST_END_BLOCK.\n\t(gfc_ascii_statement): Handle ST_BLOCK and ST_END_BLOCK.\n\t(parse_spec): Check for statements not allowed inside of BLOCK.\n\t(parse_block_construct): New routine.\n\t(parse_executable): Parse BLOCKs.\n\t(parse_progunit): Disallow CONTAINS in BLOCK constructs.\n\t* resolve.c (is_illegal_recursion): Find real container procedure and\n\tdon't get confused by BLOCK constructs.\n\t(resolve_block_construct): New routine.\n\t(gfc_resolve_blocks), (resolve_code): Handle EXEC_BLOCK.\n\t* st.c (gfc_free_statement): Handle EXEC_BLOCK statements.\n\t* trans-decl.c (saved_local_decls): New static variable.\n\t(add_decl_as_local): New routine.\n\t(gfc_finish_var_decl): Add variable as local if inside BLOCK.\n\t(gfc_trans_deferred_vars): Make public.\n\t(gfc_process_block_locals): New routine.\n\t* trans-stmt.c (gfc_trans_block_construct): New routine.\n\t* trans.c (gfc_trans_code): Handle EXEC_BLOCK statements.\n\n2009-09-29  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/39626\n\t* gfortran.dg/block_1.f08: New test.\n\t* gfortran.dg/block_2.f08: New test.\n\t* gfortran.dg/block_3.f90: New test.\n\t* gfortran.dg/block_4.f08: New test.\n\t* gfortran.dg/block_5.f08: New test.\n\t* gfortran.dg/block_6.f08: New test.\n\t* gfortran.dg/block_7.f08: New test.\n\t* gfortran.dg/block_8.f08: New test.\n\nFrom-SVN: r152266", "tree": {"sha": "8bbc9942644ae27a9137a47480f2dfeeba5ab54c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bbc9942644ae27a9137a47480f2dfeeba5ab54c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9abe5e56e20294d899363abc8898d4fa6a72e2f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abe5e56e20294d899363abc8898d4fa6a72e2f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abe5e56e20294d899363abc8898d4fa6a72e2f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abe5e56e20294d899363abc8898d4fa6a72e2f7/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b13eb8457f5b02769cfd6762c8885d58be80f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b13eb8457f5b02769cfd6762c8885d58be80f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b13eb8457f5b02769cfd6762c8885d58be80f78"}], "stats": {"total": 595, "additions": 559, "deletions": 36}, "files": [{"sha": "addfcbeede825f566a0121beae16d191d7d81d14", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -1,3 +1,41 @@\n+2009-09-29  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/39626\n+\t* gfortran.h (enum gfc_statement): Add ST_BLOCK and ST_END_BLOCK.\n+\t(struct gfc_namespace): Convert flags to bit-fields and add flag\n+\t`construct_entities' for use with BLOCK constructs.\n+\t(enum gfc_exec_code): Add EXEC_BLOCK.\n+\t(struct gfc_code): Add namespace field to union for EXEC_BLOCK.\n+\t* match.h (gfc_match_block): New prototype.\n+\t* parse.h (enum gfc_compile_state): Add COMP_BLOCK.\n+\t* trans.h (gfc_process_block_locals): New prototype.\n+\t(gfc_trans_deferred_vars): Made public, new prototype.\n+\t* trans-stmt.h (gfc_trans_block_construct): New prototype.\n+\t* decl.c (gfc_match_end): Handle END BLOCK correctly.\n+\t(gfc_match_intent): Error if inside of BLOCK.\n+\t(gfc_match_optional), (gfc_match_value): Ditto.\n+\t* match.c (gfc_match_block): New routine.\n+\t* parse.c (decode_statement): Handle BLOCK statement.\n+\t(case_exec_markers): Add ST_BLOCK.\n+\t(case_end): Add ST_END_BLOCK.\n+\t(gfc_ascii_statement): Handle ST_BLOCK and ST_END_BLOCK.\n+\t(parse_spec): Check for statements not allowed inside of BLOCK.\n+\t(parse_block_construct): New routine.\n+\t(parse_executable): Parse BLOCKs.\n+\t(parse_progunit): Disallow CONTAINS in BLOCK constructs.\n+\t* resolve.c (is_illegal_recursion): Find real container procedure and\n+\tdon't get confused by BLOCK constructs.\n+\t(resolve_block_construct): New routine.\n+\t(gfc_resolve_blocks), (resolve_code): Handle EXEC_BLOCK.\n+\t* st.c (gfc_free_statement): Handle EXEC_BLOCK statements.\n+\t* trans-decl.c (saved_local_decls): New static variable.\n+\t(add_decl_as_local): New routine.\n+\t(gfc_finish_var_decl): Add variable as local if inside BLOCK.\n+\t(gfc_trans_deferred_vars): Make public.\n+\t(gfc_process_block_locals): New routine.\n+\t* trans-stmt.c (gfc_trans_block_construct): New routine.\n+\t* trans.c (gfc_trans_code): Handle EXEC_BLOCK statements.\n+\n 2009-09-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/35862"}, {"sha": "cfd8b8126ea13000079cdc1a1ced0b08b78a2024", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -5344,8 +5344,8 @@ set_enum_kind(void)\n \n \n /* Match any of the various end-block statements.  Returns the type of\n-   END to the caller.  The END INTERFACE, END IF, END DO and END\n-   SELECT statements cannot be replaced by a single END statement.  */\n+   END to the caller.  The END INTERFACE, END IF, END DO, END SELECT\n+   and END BLOCK statements cannot be replaced by a single END statement.  */\n \n match\n gfc_match_end (gfc_statement *st)\n@@ -5366,6 +5366,9 @@ gfc_match_end (gfc_statement *st)\n   block_name = gfc_current_block () == NULL\n \t     ? NULL : gfc_current_block ()->name;\n \n+  if (state == COMP_BLOCK && !strcmp (block_name, \"block@\"))\n+    block_name = NULL;\n+\n   if (state == COMP_CONTAINS || state == COMP_DERIVED_CONTAINS)\n     {\n       state = gfc_state_stack->previous->state;\n@@ -5419,6 +5422,12 @@ gfc_match_end (gfc_statement *st)\n       eos_ok = 0;\n       break;\n \n+    case COMP_BLOCK:\n+      *st = ST_END_BLOCK;\n+      target = \" block\";\n+      eos_ok = 0;\n+      break;\n+\n     case COMP_IF:\n       *st = ST_ENDIF;\n       target = \" if\";\n@@ -5488,10 +5497,10 @@ gfc_match_end (gfc_statement *st)\n     {\n \n       if (*st != ST_ENDDO && *st != ST_ENDIF && *st != ST_END_SELECT\n-\t  && *st != ST_END_FORALL && *st != ST_END_WHERE)\n+\t  && *st != ST_END_FORALL && *st != ST_END_WHERE && *st != ST_END_BLOCK)\n \treturn MATCH_YES;\n \n-      if (gfc_current_block () == NULL)\n+      if (!block_name)\n \treturn MATCH_YES;\n \n       gfc_error (\"Expected block name of '%s' in %s statement at %C\",\n@@ -5854,6 +5863,13 @@ gfc_match_intent (void)\n {\n   sym_intent intent;\n \n+  /* This is not allowed within a BLOCK construct!  */\n+  if (gfc_current_state () == COMP_BLOCK)\n+    {\n+      gfc_error (\"INTENT is not allowed inside of BLOCK at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n   intent = match_intent_spec ();\n   if (intent == INTENT_UNKNOWN)\n     return MATCH_ERROR;\n@@ -5879,6 +5895,12 @@ gfc_match_intrinsic (void)\n match\n gfc_match_optional (void)\n {\n+  /* This is not allowed within a BLOCK construct!  */\n+  if (gfc_current_state () == COMP_BLOCK)\n+    {\n+      gfc_error (\"OPTIONAL is not allowed inside of BLOCK at %C\");\n+      return MATCH_ERROR;\n+    }\n \n   gfc_clear_attr (&current_attr);\n   current_attr.optional = 1;\n@@ -6362,6 +6384,13 @@ gfc_match_value (void)\n   gfc_symbol *sym;\n   match m;\n \n+  /* This is not allowed within a BLOCK construct!  */\n+  if (gfc_current_state () == COMP_BLOCK)\n+    {\n+      gfc_error (\"VALUE is not allowed inside of BLOCK at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n   if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VALUE statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;"}, {"sha": "0dce218b22c2de085ae686570c83966784a21d88", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -206,15 +206,17 @@ arith;\n /* Statements.  */\n typedef enum\n {\n-  ST_ARITHMETIC_IF, ST_ALLOCATE, ST_ATTR_DECL, ST_BACKSPACE, ST_BLOCK_DATA,\n+  ST_ARITHMETIC_IF, ST_ALLOCATE, ST_ATTR_DECL, ST_BACKSPACE,\n+  ST_BLOCK, ST_BLOCK_DATA,\n   ST_CALL, ST_CASE, ST_CLOSE, ST_COMMON, ST_CONTINUE, ST_CONTAINS, ST_CYCLE,\n   ST_DATA, ST_DATA_DECL, ST_DEALLOCATE, ST_DO, ST_ELSE, ST_ELSEIF,\n-  ST_ELSEWHERE, ST_END_BLOCK_DATA, ST_ENDDO, ST_IMPLIED_ENDDO,\n+  ST_ELSEWHERE, ST_END_BLOCK, ST_END_BLOCK_DATA, ST_ENDDO, ST_IMPLIED_ENDDO,\n   ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,\n   ST_END_INTERFACE, ST_END_MODULE, ST_END_PROGRAM, ST_END_SELECT,\n   ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE, ST_ENTRY, ST_EQUIVALENCE,\n   ST_EXIT, ST_FORALL, ST_FORALL_BLOCK, ST_FORMAT, ST_FUNCTION, ST_GOTO,\n-  ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT, ST_INQUIRE, ST_INTERFACE,\n+  ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT,\n+  ST_INQUIRE, ST_INTERFACE,\n   ST_PARAMETER, ST_MODULE, ST_MODULE_PROC, ST_NAMELIST, ST_NULLIFY, ST_OPEN,\n   ST_PAUSE, ST_PRIVATE, ST_PROGRAM, ST_PUBLIC, ST_READ, ST_RETURN, ST_REWIND,\n   ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT, \n@@ -1278,8 +1280,8 @@ gfc_dt_list;\n   /* A list of all derived types.  */\n   extern gfc_dt_list *gfc_derived_types;\n \n-/* A namespace describes the contents of procedure, module or\n-   interface block.  */\n+/* A namespace describes the contents of procedure, module, interface block\n+   or BLOCK construct.  */\n /* ??? Anything else use these?  */\n \n typedef struct gfc_namespace\n@@ -1357,16 +1359,20 @@ typedef struct gfc_namespace\n   gfc_use_list *use_stmts;\n \n   /* Set to 1 if namespace is a BLOCK DATA program unit.  */\n-  int is_block_data;\n+  unsigned is_block_data:1;\n \n   /* Set to 1 if namespace is an interface body with \"IMPORT\" used.  */\n-  int has_import_set;\n+  unsigned has_import_set:1;\n \n   /* Set to 1 if resolved has been called for this namespace.  */\n-  int resolved;\n+  unsigned resolved:1;\n \n   /* Set to 1 if code has been generated for this namespace.  */\n-  int translated;\n+  unsigned translated:1;\n+\n+  /* Set to 1 if symbols in this namespace should be 'construct entities',\n+     i.e. for BLOCK local variables.  */\n+  unsigned construct_entities:1;\n }\n gfc_namespace;\n \n@@ -1964,7 +1970,7 @@ typedef enum\n   EXEC_POINTER_ASSIGN,\n   EXEC_GOTO, EXEC_CALL, EXEC_COMPCALL, EXEC_ASSIGN_CALL, EXEC_RETURN,\n   EXEC_ENTRY, EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE, EXEC_INIT_ASSIGN,\n-  EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT,\n+  EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT, EXEC_BLOCK,\n   EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT, EXEC_CALL_PPC,\n   EXEC_ALLOCATE, EXEC_DEALLOCATE, EXEC_END_PROCEDURE,\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n@@ -2015,6 +2021,7 @@ typedef struct gfc_code\n     const char *omp_name;\n     gfc_namelist *omp_namelist;\n     bool omp_bool;\n+    gfc_namespace *ns;\n   }\n   ext;\t\t/* Points to additional structures required by statement */\n "}, {"sha": "919d5d148fc102c5d85eda6a6e7925eea9d02bb8", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -1705,6 +1705,30 @@ gfc_free_iterator (gfc_iterator *iter, int flag)\n }\n \n \n+/* Match a BLOCK statement.  */\n+\n+match\n+gfc_match_block (void)\n+{\n+  match m;\n+\n+  if (gfc_match_label () == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match (\" block\") != MATCH_YES)\n+    return MATCH_NO;\n+\n+  /* For this to be a correct BLOCK statement, the line must end now.  */\n+  m = gfc_match_eos ();\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+  if (m == MATCH_NO)\n+    return MATCH_NO;\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a DO statement.  */\n \n match"}, {"sha": "a53c7f0f8ddea4ac054ef5212f7b277977a1cdfd", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -69,6 +69,7 @@ match gfc_match_assignment (void);\n match gfc_match_if (gfc_statement *);\n match gfc_match_else (void);\n match gfc_match_elseif (void);\n+match gfc_match_block (void);\n match gfc_match_do (void);\n match gfc_match_cycle (void);\n match gfc_match_exit (void);"}, {"sha": "e6b5dbb18019df4c5f5d1693e77a27c5349ecf36", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 98, "deletions": 11, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -289,7 +289,7 @@ decode_statement (void)\n   gfc_undo_symbols ();\n   gfc_current_locus = old_locus;\n \n-  /* Check for the IF, DO, SELECT, WHERE and FORALL statements, which\n+  /* Check for the IF, DO, SELECT, WHERE, FORALL and BLOCK statements, which\n      might begin with a block label.  The match functions for these\n      statements are unusual in that their keyword is not seen before\n      the matcher is called.  */\n@@ -309,6 +309,7 @@ decode_statement (void)\n   gfc_undo_symbols ();\n   gfc_current_locus = old_locus;\n \n+  match (NULL, gfc_match_block, ST_BLOCK);\n   match (NULL, gfc_match_do, ST_DO);\n   match (NULL, gfc_match_select, ST_SELECT_CASE);\n \n@@ -933,7 +934,8 @@ next_statement (void)\n \n /* Statements that mark other executable statements.  */\n \n-#define case_exec_markers case ST_DO: case ST_FORALL_BLOCK: case ST_IF_BLOCK: \\\n+#define case_exec_markers case ST_DO: case ST_FORALL_BLOCK: \\\n+  case ST_IF_BLOCK: case ST_BLOCK: \\\n   case ST_WHERE_BLOCK: case ST_SELECT_CASE: case ST_OMP_PARALLEL: \\\n   case ST_OMP_PARALLEL_SECTIONS: case ST_OMP_SECTIONS: case ST_OMP_ORDERED: \\\n   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \\\n@@ -952,7 +954,8 @@ next_statement (void)\n    are detected in gfc_match_end().  */\n \n #define case_end case ST_END_BLOCK_DATA: case ST_END_FUNCTION: \\\n-\t\t case ST_END_PROGRAM: case ST_END_SUBROUTINE\n+\t\t case ST_END_PROGRAM: case ST_END_SUBROUTINE: \\\n+\t\t case ST_END_BLOCK\n \n \n /* Push a new state onto the stack.  */\n@@ -1142,6 +1145,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_BACKSPACE:\n       p = \"BACKSPACE\";\n       break;\n+    case ST_BLOCK:\n+      p = \"BLOCK\";\n+      break;\n     case ST_BLOCK_DATA:\n       p = \"BLOCK DATA\";\n       break;\n@@ -1190,6 +1196,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_ELSEWHERE:\n       p = \"ELSEWHERE\";\n       break;\n+    case ST_END_BLOCK:\n+      p = \"END BLOCK\";\n+      break;\n     case ST_END_BLOCK_DATA:\n       p = \"END BLOCK DATA\";\n       break;\n@@ -2391,6 +2400,27 @@ parse_spec (gfc_statement st)\n     }\n \n loop:\n+\n+  /* If we're inside a BLOCK construct, some statements are disallowed.\n+     Check this here.  Attribute declaration statements like INTENT, OPTIONAL\n+     or VALUE are also disallowed, but they don't have a particular ST_*\n+     key so we have to check for them individually in their matcher routine.  */\n+  if (gfc_current_state () == COMP_BLOCK)\n+    switch (st)\n+      {\n+\tcase ST_IMPLICIT:\n+\tcase ST_IMPLICIT_NONE:\n+\tcase ST_NAMELIST:\n+\tcase ST_COMMON:\n+\tcase ST_EQUIVALENCE:\n+\tcase ST_STATEMENT_FUNCTION:\n+\t  gfc_error (\"%s statement is not allowed inside of BLOCK at %C\",\n+\t\t     gfc_ascii_statement (st));\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+      }\n   \n   /* If we find a statement that can not be followed by an IMPLICIT statement\n      (and thus we can expect to see none any further), type the function result\n@@ -2908,6 +2938,58 @@ check_do_closure (void)\n }\n \n \n+/* Parse a series of contained program units.  */\n+\n+static void parse_progunit (gfc_statement);\n+\n+\n+/* Parse a BLOCK construct.  */\n+\n+static void\n+parse_block_construct (void)\n+{\n+  gfc_namespace* parent_ns;\n+  gfc_namespace* my_ns;\n+  gfc_state_data s;\n+\n+  gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: BLOCK construct at %C\");\n+\n+  parent_ns = gfc_current_ns;\n+  my_ns = gfc_get_namespace (parent_ns, 1);\n+  my_ns->construct_entities = 1;\n+\n+  /* Give the BLOCK a symbol of flavor LABEL; this is later needed for correct\n+     code generation (so it must not be NULL).\n+     We set its recursive argument if our container procedure is recursive, so\n+     that local variables are accordingly placed on the stack when it\n+     will be necessary.  */\n+  if (gfc_new_block)\n+    my_ns->proc_name = gfc_new_block;\n+  else\n+    {\n+      gfc_try t;\n+\n+      gfc_get_symbol (\"block@\", my_ns, &my_ns->proc_name);\n+      t = gfc_add_flavor (&my_ns->proc_name->attr, FL_LABEL,\n+\t\t\t  my_ns->proc_name->name, NULL);\n+      gcc_assert (t == SUCCESS);\n+    }\n+  my_ns->proc_name->attr.recursive = parent_ns->proc_name->attr.recursive;\n+\n+  new_st.op = EXEC_BLOCK;\n+  new_st.ext.ns = my_ns;\n+  accept_statement (ST_BLOCK);\n+\n+  push_state (&s, COMP_BLOCK, my_ns->proc_name);\n+  gfc_current_ns = my_ns;\n+\n+  parse_progunit (ST_NONE);\n+\n+  gfc_current_ns = parent_ns;\n+  pop_state ();\n+}\n+\n+\n /* Parse a DO loop.  Note that the ST_CYCLE and ST_EXIT statements are\n    handled inside of parse_executable(), because they aren't really\n    loop statements.  */\n@@ -3301,6 +3383,10 @@ parse_executable (gfc_statement st)\n \t    return ST_IMPLIED_ENDDO;\n \t  break;\n \n+\tcase ST_BLOCK:\n+\t  parse_block_construct ();\n+\t  break;\n+\n \tcase ST_IF_BLOCK:\n \t  parse_if_block ();\n \t  break;\n@@ -3359,11 +3445,6 @@ parse_executable (gfc_statement st)\n }\n \n \n-/* Parse a series of contained program units.  */\n-\n-static void parse_progunit (gfc_statement);\n-\n-\n /* Fix the symbols for sibling functions.  These are incorrectly added to\n    the child namespace as the parser didn't know about this procedure.  */\n \n@@ -3545,7 +3626,7 @@ parse_contained (int module)\n }\n \n \n-/* Parse a PROGRAM, SUBROUTINE or FUNCTION unit.  */\n+/* Parse a PROGRAM, SUBROUTINE, FUNCTION unit or BLOCK construct.  */\n \n static void\n parse_progunit (gfc_statement st)\n@@ -3560,7 +3641,10 @@ parse_progunit (gfc_statement st)\n       unexpected_eof ();\n \n     case ST_CONTAINS:\n-      goto contains;\n+      /* This is not allowed within BLOCK!  */\n+      if (gfc_current_state () != COMP_BLOCK)\n+\tgoto contains;\n+      break;\n \n     case_end:\n       accept_statement (st);\n@@ -3584,7 +3668,10 @@ parse_progunit (gfc_statement st)\n \t  unexpected_eof ();\n \n \tcase ST_CONTAINS:\n-\t  goto contains;\n+\t  /* This is not allowed within BLOCK!  */\n+\t  if (gfc_current_state () != COMP_BLOCK)\n+\t    goto contains;\n+\t  break;\n \n \tcase_end:\n \t  accept_statement (st);"}, {"sha": "7239c38da7f261d4b3f9422e5848b73cae3e8448", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -29,7 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n typedef enum\n {\n   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,\n-  COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS, COMP_IF,\n+  COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,\n+  COMP_BLOCK, COMP_IF,\n   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n   COMP_OMP_STRUCTURED_BLOCK\n }"}, {"sha": "3eec50e53733a336cba59ed9c9927bdce48c3129", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -1101,6 +1101,7 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)\n {\n   gfc_symbol* proc_sym;\n   gfc_symbol* context_proc;\n+  gfc_namespace* real_context;\n \n   gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n \n@@ -1114,11 +1115,29 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)\n   if (proc_sym->attr.recursive || gfc_option.flag_recursive)\n     return false;\n \n-  /* Find the context procdure's \"real\" symbol if it has entries.  */\n-  context_proc = (context->entries ? context->entries->sym\n-\t\t\t\t   : context->proc_name);\n-  if (!context_proc)\n-    return true;\n+  /* Find the context procedure's \"real\" symbol if it has entries.\n+     We look for a procedure symbol, so recurse on the parents if we don't\n+     find one (like in case of a BLOCK construct).  */\n+  for (real_context = context; ; real_context = real_context->parent)\n+    {\n+      /* We should find something, eventually!  */\n+      gcc_assert (real_context);\n+\n+      context_proc = (real_context->entries ? real_context->entries->sym\n+\t\t\t\t\t    : real_context->proc_name);\n+\n+      /* In some special cases, there may not be a proc_name, like for this\n+\t invalid code:\n+\t real(bad_kind()) function foo () ...\n+\t when checking the call to bad_kind ().\n+\t In these cases, we simply return here and assume that the\n+\t call is ok.  */\n+      if (!context_proc)\n+\treturn false;\n+\n+      if (context_proc->attr.flavor != FL_LABEL)\n+\tbreak;\n+    }\n \n   /* A call from sym's body to itself is recursion, of course.  */\n   if (context_proc == proc_sym)\n@@ -6838,7 +6857,19 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n }\n \n \n-/* Resolve lists of blocks found in IF, SELECT CASE, WHERE, FORALL ,GOTO and\n+/* Resolve a BLOCK construct statement.  */\n+\n+static void\n+resolve_block_construct (gfc_code* code)\n+{\n+  /* Eventually, we may want to do some checks here or handle special stuff.\n+     But so far the only thing we can do is resolving the local namespace.  */\n+\n+  gfc_resolve (code->ext.ns);\n+}\n+\n+\n+/* Resolve lists of blocks found in IF, SELECT CASE, WHERE, FORALL, GOTO and\n    DO code nodes.  */\n \n static void resolve_code (gfc_code *, gfc_namespace *);\n@@ -6875,6 +6906,10 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \t  resolve_branch (b->label1, b);\n \t  break;\n \n+\tcase EXEC_BLOCK:\n+\t  resolve_block_construct (b);\n+\t  break;\n+\n \tcase EXEC_SELECT:\n \tcase EXEC_FORALL:\n \tcase EXEC_DO:\n@@ -6902,7 +6937,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \t  break;\n \n \tdefault:\n-\t  gfc_internal_error (\"resolve_block(): Bad block type\");\n+\t  gfc_internal_error (\"gfc_resolve_blocks(): Bad block type\");\n \t}\n \n       resolve_code (b->next, ns);\n@@ -7066,6 +7101,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n   return false;\n }\n \n+\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -7250,7 +7286,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_CALL_PPC:\n-          resolve_ppc_call (code);\n+\t  resolve_ppc_call (code);\n \t  break;\n \n \tcase EXEC_SELECT:\n@@ -7259,6 +7295,10 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_select (code);\n \t  break;\n \n+\tcase EXEC_BLOCK:\n+\t  gfc_resolve (code->ext.ns);\n+\t  break;\n+\n \tcase EXEC_DO:\n \t  if (code->ext.iterator != NULL)\n \t    {"}, {"sha": "c3c640adc93d5fb80d88b1bc04c9982d095b2694", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -110,6 +110,10 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_ARITHMETIC_IF:\n       break;\n \n+    case EXEC_BLOCK:\n+      gfc_free_namespace (p->ext.ns);\n+      break;\n+\n     case EXEC_COMPCALL:\n     case EXEC_CALL_PPC:\n     case EXEC_CALL:"}, {"sha": "3d6a5e2221c4a4fe75a00e3842aeb6fe7d62de9e", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -64,6 +64,10 @@ static GTY(()) tree saved_parent_function_decls;\n static struct pointer_set_t *nonlocal_dummy_decl_pset;\n static GTY(()) tree nonlocal_dummy_decls;\n \n+/* Holds the variable DECLs that are locals.  */\n+\n+static GTY(()) tree saved_local_decls;\n+\n /* The namespace of the module we're currently generating.  Only used while\n    outputting decls for module variables.  Do not rely on this being set.  */\n \n@@ -180,6 +184,16 @@ gfc_add_decl_to_function (tree decl)\n   saved_function_decls = decl;\n }\n \n+static void\n+add_decl_as_local (tree decl)\n+{\n+  gcc_assert (decl);\n+  TREE_USED (decl) = 1;\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  TREE_CHAIN (decl) = saved_local_decls;\n+  saved_local_decls = decl;\n+}\n+\n \n /* Build a  backend label declaration.  Set TREE_USED for named labels.\n    The context of the label is always the current_function_decl.  All\n@@ -504,8 +518,11 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n   if (current_function_decl != NULL_TREE)\n     {\n       if (sym->ns->proc_name->backend_decl == current_function_decl\n-          || sym->result == sym)\n+\t  || sym->result == sym)\n \tgfc_add_decl_to_function (decl);\n+      else if (sym->ns->proc_name->attr.flavor == FL_LABEL)\n+\t/* This is a BLOCK construct.  */\n+\tadd_decl_as_local (decl);\n       else\n \tgfc_add_decl_to_parent_function (decl);\n     }\n@@ -3036,7 +3053,7 @@ init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n     Initialization and possibly repacking of dummy arrays.\n     Initialization of ASSIGN statement auxiliary variable.  */\n \n-static tree\n+tree\n gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n {\n   locus loc;\n@@ -4552,4 +4569,28 @@ gfc_generate_block_data (gfc_namespace * ns)\n }\n \n \n+/* Process the local variables of a BLOCK construct.  */\n+\n+void\n+gfc_process_block_locals (gfc_namespace* ns)\n+{\n+  tree decl;\n+\n+  gcc_assert (saved_local_decls == NULL_TREE);\n+  generate_local_vars (ns);\n+\n+  decl = saved_local_decls;\n+  while (decl)\n+    {\n+      tree next;\n+\n+      next = TREE_CHAIN (decl);\n+      TREE_CHAIN (decl) = NULL_TREE;\n+      pushdecl (decl);\n+      decl = next;\n+    }\n+  saved_local_decls = NULL_TREE;\n+}\n+\n+\n #include \"gt-fortran-trans-decl.h\""}, {"sha": "25a5b3b4edebc6aaf193105092fd28a40112cc0d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -756,6 +756,36 @@ gfc_trans_arithmetic_if (gfc_code * code)\n }\n \n \n+/* Translate a BLOCK construct.  This is basically what we would do for a\n+   procedure body.  */\n+\n+tree\n+gfc_trans_block_construct (gfc_code* code)\n+{\n+  gfc_namespace* ns;\n+  gfc_symbol* sym;\n+  stmtblock_t body;\n+  tree tmp;\n+\n+  ns = code->ext.ns;\n+  gcc_assert (ns);\n+  sym = ns->proc_name;\n+  gcc_assert (sym);\n+\n+  gcc_assert (!sym->tlink);\n+  sym->tlink = sym;\n+\n+  gfc_start_block (&body);\n+  gfc_process_block_locals (ns);\n+\n+  tmp = gfc_trans_code (ns->code);\n+  tmp = gfc_trans_deferred_vars (sym, tmp);\n+\n+  gfc_add_expr_to_block (&body, tmp);\n+  return gfc_finish_block (&body);\n+}\n+\n+\n /* Translate the simple DO construct.  This is where the loop variable has\n    integer type and step +-1.  We can't use this in the general case\n    because integer overflow and floating point errors could give incorrect"}, {"sha": "0b8461c4e15c124a9a835818c7be9a7bdfbeddb9", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -43,6 +43,7 @@ tree gfc_trans_call (gfc_code *, bool, tree, tree, bool);\n tree gfc_trans_return (gfc_code *);\n tree gfc_trans_if (gfc_code *);\n tree gfc_trans_arithmetic_if (gfc_code *);\n+tree gfc_trans_block_construct (gfc_code *);\n tree gfc_trans_do (gfc_code *);\n tree gfc_trans_do_while (gfc_code *);\n tree gfc_trans_select (gfc_code *);"}, {"sha": "f53f75e3674c99de0fb11188f8ec624283eba806", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -1157,6 +1157,10 @@ gfc_trans_code (gfc_code * code)\n \t  res = gfc_trans_arithmetic_if (code);\n \t  break;\n \n+\tcase EXEC_BLOCK:\n+\t  res = gfc_trans_block_construct (code);\n+\t  break;\n+\n \tcase EXEC_DO:\n \t  res = gfc_trans_do (code);\n \t  break;"}, {"sha": "27b040a1288c0da5bff78e147b432b4f76b18233", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -498,6 +498,12 @@ void gfc_build_io_library_fndecls (void);\n /* Build a function decl for a library function.  */\n tree gfc_build_library_function_decl (tree, tree, int, ...);\n \n+/* Process the local variable decls of a block construct.  */\n+void gfc_process_block_locals (gfc_namespace*);\n+\n+/* Output initialization/clean-up code that was deferred.  */\n+tree gfc_trans_deferred_vars (gfc_symbol*, tree);\n+\n /* somewhere! */\n tree pushdecl (tree);\n tree pushdecl_top_level (tree);"}, {"sha": "35e21e23f28b1af6be298878d4bf6e44b5bed6e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -1,3 +1,15 @@\n+2009-09-29  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/39626\n+\t* gfortran.dg/block_1.f08: New test.\n+\t* gfortran.dg/block_2.f08: New test.\n+\t* gfortran.dg/block_3.f90: New test.\n+\t* gfortran.dg/block_4.f08: New test.\n+\t* gfortran.dg/block_5.f08: New test.\n+\t* gfortran.dg/block_6.f08: New test.\n+\t* gfortran.dg/block_7.f08: New test.\n+\t* gfortran.dg/block_8.f08: New test.\n+\n 2009-09-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/35862"}, {"sha": "a2a67bc2950d6b275e60e6ef0a72e38a0b5a1b7a", "filename": "gcc/testsuite/gfortran.dg/block_1.f08", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_1.f08?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics\" }\n+\n+! Basic Fortran 2008 BLOCK construct test.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: i\n+\n+  i = 42\n+\n+  ! Empty block.\n+  BLOCK\n+  END BLOCK\n+\n+  ! Block without local variables but name.\n+  BLOCK\n+    IF (i /= 42) CALL abort ()\n+    i = 5\n+  END BLOCK\n+  IF (i /= 5) CALL abort ()\n+\n+  ! Named block with local variable and nested block.\n+  myblock: BLOCK\n+    INTEGER :: i\n+    i = -1\n+    BLOCK\n+      IF (i /= -1) CALL abort ()\n+      i = -2\n+    END BLOCK\n+    IF (i /= -2) CALL abort ()\n+  END BLOCK myblock ! Matching end-label.\n+  IF (i /= 5) CALL abort ()\n+END PROGRAM main"}, {"sha": "a2ba2d5caea9ea4bd97e4d94c47aa623f05100da", "filename": "gcc/testsuite/gfortran.dg/block_2.f08", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_2.f08?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics -fdump-tree-original\" }\n+\n+! More sophisticated BLOCK runtime checks for correct initialization/clean-up.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: n\n+\n+  n = 5\n+\n+  myblock: BLOCK\n+    INTEGER :: arr(n)\n+    IF (SIZE (arr) /= 5) CALL abort ()\n+    BLOCK\n+      INTEGER :: arr(2*n)\n+      IF (SIZE (arr) /= 10) CALL abort ()\n+    END BLOCK\n+    IF (SIZE (arr) /= 5) CALL abort ()\n+  END BLOCK myblock\n+\n+  BLOCK\n+    INTEGER, ALLOCATABLE :: alloc_arr(:)\n+    IF (ALLOCATED (alloc_arr)) CALL abort ()\n+    ALLOCATE (alloc_arr(n))\n+    IF (SIZE (alloc_arr) /= 5) CALL abort ()\n+    ! Should be free'ed here (but at least somewhere), this is checked\n+    ! with pattern below.\n+  END BLOCK\n+\n+  BLOCK\n+    CHARACTER(LEN=n) :: str\n+    IF (LEN (str) /= 5) CALL abort ()\n+    str = \"123456789\"\n+    IF (str /= \"12345\") CALL abort ()\n+  END BLOCK\n+END PROGRAM main\n+! { dg-final { scan-tree-dump-times \"free \\\\(\\\\(void \\\\*\\\\) alloc_arr\\\\.data\" 1 \"original\" } }"}, {"sha": "2242628295fbc7d72b70e3f3943dbfcc3d345225", "filename": "gcc/testsuite/gfortran.dg/block_3.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_3.f90?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! BLOCK should be rejected without F2008.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  BLOCK ! { dg-error \"Fortran 2008\" }\n+    INTEGER :: i\n+  END BLOCK\n+END PROGRAM main"}, {"sha": "4c63194c85d8a8b239c22aa65ec636cef3098da9", "filename": "gcc/testsuite/gfortran.dg/block_4.f08", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_4.f08?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+\n+! Check for label mismatch errors with BLOCK statements.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  BLOCK \n+  END BLOCK wrongname ! { dg-error \"Syntax error\" }\n+\n+  myname: BLOCK\n+  END BLOCK wrongname ! { dg-error \"Expected label 'myname'\" }\n+\n+  myname2: BLOCK\n+  END BLOCK ! { dg-error \"Expected block name of 'myname2'\" }\n+END PROGRAM main ! { dg-error \"Expecting END BLOCK\" }\n+! { dg-excess-errors \"Unexpected end of file\" }"}, {"sha": "46de78dd0c58310cd9536b3dfe6bb9cea4624c61", "filename": "gcc/testsuite/gfortran.dg/block_5.f08", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_5.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_5.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_5.f08?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! { dg-options \"-std=legacy\" }\n+! We want to check for statement functions, thus legacy mode.\n+\n+! Check for errors with declarations not allowed within BLOCK.\n+\n+SUBROUTINE proc (a)\n+  IMPLICIT NONE\n+  INTEGER :: a\n+\n+  BLOCK\n+    INTENT(IN) :: a ! { dg-error \"not allowed inside of BLOCK\" }\n+    VALUE :: a ! { dg-error \"not allowed inside of BLOCK\" }\n+    OPTIONAL :: a ! { dg-error \"not allowed inside of BLOCK\" }\n+  END BLOCK\n+END SUBROUTINE proc\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  BLOCK \n+    IMPLICIT INTEGER(a-z) ! { dg-error \"not allowed inside of BLOCK\" }\n+    INTEGER :: a, b, c, d\n+    INTEGER :: stfunc\n+    stfunc(a, b) = a + b ! { dg-error \"not allowed inside of BLOCK\" }\n+    EQUIVALENCE (a, b) ! { dg-error \"not allowed inside of BLOCK\" }\n+    NAMELIST /NLIST/ a, b ! { dg-error \"not allowed inside of BLOCK\" }\n+    COMMON /CBLOCK/ c, d ! { dg-error \"not allowed inside of BLOCK\" }\n+  ! This contains is in the specification part.\n+  CONTAINS ! { dg-error \"Unexpected CONTAINS statement\" }\n+  END BLOCK\n+\n+  BLOCK\n+    PRINT *, \"Hello, world\"\n+  ! This one in the executable statement part.\n+  CONTAINS ! { dg-error \"Unexpected CONTAINS statement\" }\n+  END BLOCK\n+END PROGRAM main"}, {"sha": "621a93304b0489cb93fb1588cc163a0f8b1eb2b3", "filename": "gcc/testsuite/gfortran.dg/block_6.f08", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_6.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_6.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_6.f08?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run { xfail *-*-* } }\n+! { dg-options \"-std=f2008 -fall-intrinsics\" }\n+\n+! Check for correct scope of variables that are implicit typed within a BLOCK.\n+! This is not yet implemented, thus XFAIL'ed the test.\n+\n+PROGRAM main\n+  IMPLICIT INTEGER(a-z)\n+\n+  BLOCK\n+    ! a gets implicitly typed, but scope should not be limited to BLOCK.\n+    a = 42\n+  END BLOCK\n+\n+  ! Here, we should still access the same a that was set above.\n+  IF (a /= 42) CALL abort ()\n+END PROGRAM main"}, {"sha": "3a267edc37be32b0e8165bac8f33bbeac7c6efba", "filename": "gcc/testsuite/gfortran.dg/block_7.f08", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_7.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_7.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_7.f08?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics\" }\n+\n+! Check for correct placement (on the stack) of local variables with BLOCK\n+! and recursive container procedures.\n+\n+RECURSIVE SUBROUTINE myproc (i)\n+  INTEGER, INTENT(IN) :: i\n+  ! Wrap the block up in some other construct so we see this doesn't mess\n+  ! things up, either.\n+  DO\n+    BLOCK\n+      INTEGER :: x\n+      x = i\n+      IF (i > 0) CALL myproc (i - 1)\n+      IF (x /= i) CALL abort ()\n+    END BLOCK\n+    EXIT\n+  END DO\n+END SUBROUTINE myproc\n+\n+PROGRAM main\n+  CALL myproc (42)\n+END PROGRAM main"}, {"sha": "6059fa89c79374f76bd5757e5dfc6e5a62cd8871", "filename": "gcc/testsuite/gfortran.dg/block_8.f08", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_8.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5e56e20294d899363abc8898d4fa6a72e2f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_8.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_8.f08?ref=9abe5e56e20294d899363abc8898d4fa6a72e2f7", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics\" }\n+\n+! Check BLOCK with SAVE'ed variables.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: i\n+\n+  DO i = 1, 100\n+    BLOCK\n+      INTEGER, SAVE :: summed = 0\n+      summed = summed + i\n+      IF (i == 100 .AND. summed /= 5050) CALL abort ()\n+    END BLOCK\n+  END DO\n+END PROGRAM main"}]}