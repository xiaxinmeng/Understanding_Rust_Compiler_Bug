{"sha": "26a8c34ec94a479266f641699dbc4a8b36bdfd30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZhOGMzNGVjOTRhNDc5MjY2ZjY0MTY5OWRiYzRhOGIzNmJkZmQzMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-14T19:26:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-14T19:26:20Z"}, "message": "compiler: check duplicate string keys in map composite literals\n    \n    Updates golang/go#28104\n    \n    Reviewed-on: https://go-review.googlesource.com/c/161357\n\nFrom-SVN: r268891", "tree": {"sha": "fff938f7314bf9e5944bfddf2440a99108385ede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fff938f7314bf9e5944bfddf2440a99108385ede"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26a8c34ec94a479266f641699dbc4a8b36bdfd30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a8c34ec94a479266f641699dbc4a8b36bdfd30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a8c34ec94a479266f641699dbc4a8b36bdfd30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a8c34ec94a479266f641699dbc4a8b36bdfd30/comments", "author": null, "committer": null, "parents": [{"sha": "a930500fc4dbd32c0d6f5d9382adb45de96605c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a930500fc4dbd32c0d6f5d9382adb45de96605c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a930500fc4dbd32c0d6f5d9382adb45de96605c9"}], "stats": {"total": 153, "additions": 98, "deletions": 55}, "files": [{"sha": "f74b5f8521539993fac04322b350b6e38a69fc94", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=26a8c34ec94a479266f641699dbc4a8b36bdfd30", "patch": "@@ -1,4 +1,4 @@\n-6d03c4c8ca320042bd550d44c0f25575c5311ac2\n+a487c86418488f6a17dab4f9945e2a5d495e3ddb\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "40b9f18b9de307c0af77ff4f0eb8bbf6f14496f0", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 73, "deletions": 30, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=26a8c34ec94a479266f641699dbc4a8b36bdfd30", "patch": "@@ -673,7 +673,7 @@ Type_expression : public Expression\n   { go_unreachable(); }\n \n   void do_dump_expression(Ast_dump_context*) const;\n- \n+\n  private:\n   // The type which we are representing as an expression.\n   Type* type_;\n@@ -2950,7 +2950,7 @@ Const_expression::do_numeric_constant_value(Numeric_constant* nc) const\n     return false;\n \n   Expression* e = this->constant_->const_value()->expr();\n-  \n+\n   this->seen_ = true;\n \n   bool r = e->numeric_constant_value(nc);\n@@ -3298,10 +3298,10 @@ class Iota_expression : public Parser_expression\n   Expression*\n   do_copy()\n   { go_unreachable(); }\n-  \n+\n   void\n   do_dump_expression(Ast_dump_context* ast_dump_context) const\n-  { ast_dump_context->ostream() << \"iota\"; } \n+  { ast_dump_context->ostream() << \"iota\"; }\n };\n \n // Make an iota expression.  This is only called for one case: the\n@@ -4174,7 +4174,7 @@ Unary_expression::base_is_static_initializer(Expression* expr)\n // know the address of this expression is being taken, we must always\n // check for nil.\n Unary_expression::Nil_check_classification\n-Unary_expression::requires_nil_check(Gogo* gogo) \n+Unary_expression::requires_nil_check(Gogo* gogo)\n {\n   go_assert(this->op_ == OPERATOR_MULT);\n   go_assert(this->expr_->type()->points_to() != NULL);\n@@ -7311,14 +7311,14 @@ Bound_method_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n {\n   if (this->expr_type_ != NULL)\n     ast_dump_context->ostream() << \"(\";\n-  ast_dump_context->dump_expression(this->expr_); \n-  if (this->expr_type_ != NULL) \n+  ast_dump_context->dump_expression(this->expr_);\n+  if (this->expr_type_ != NULL)\n     {\n       ast_dump_context->ostream() << \":\";\n       ast_dump_context->dump_type(this->expr_type_);\n       ast_dump_context->ostream() << \")\";\n     }\n-    \n+\n   ast_dump_context->ostream() << \".\" << this->function_->name();\n }\n \n@@ -7461,7 +7461,7 @@ Builtin_call_expression::do_lower(Gogo*, Named_object* function,\n \t  farg = farg->expr()->field_reference_expression();\n \t}\n     }\n- \n+\n   if (this->is_constant())\n     {\n       Numeric_constant nc;\n@@ -10812,7 +10812,7 @@ void\n Call_result_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n-  // FIXME: Wouldn't it be better if the call is assigned to a temporary \n+  // FIXME: Wouldn't it be better if the call is assigned to a temporary\n   // (struct) and the fields are referenced instead.\n   ast_dump_context->ostream() << this->index_ << \"@(\";\n   ast_dump_context->dump_expression(this->call_);\n@@ -10930,8 +10930,8 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n // (expr[expr:expr:expr], expr[expr:expr] or expr[expr]) to a dump context.\n \n void\n-Index_expression::dump_index_expression(Ast_dump_context* ast_dump_context, \n-\t\t\t\t\tconst Expression* expr, \n+Index_expression::dump_index_expression(Ast_dump_context* ast_dump_context,\n+\t\t\t\t\tconst Expression* expr,\n \t\t\t\t\tconst Expression* start,\n \t\t\t\t\tconst Expression* end,\n \t\t\t\t\tconst Expression* cap)\n@@ -10955,10 +10955,10 @@ Index_expression::dump_index_expression(Ast_dump_context* ast_dump_context,\n // Dump ast representation for an index expression.\n \n void\n-Index_expression::do_dump_expression(Ast_dump_context* ast_dump_context) \n+Index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n-  Index_expression::dump_index_expression(ast_dump_context, this->left_, \n+  Index_expression::dump_index_expression(ast_dump_context, this->left_,\n                                           this->start_, this->end_, this->cap_);\n }\n \n@@ -11471,10 +11471,10 @@ Array_index_expression::do_get_backend(Translate_context* context)\n // Dump ast representation for an array index expression.\n \n void\n-Array_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context) \n+Array_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n-  Index_expression::dump_index_expression(ast_dump_context, this->array_, \n+  Index_expression::dump_index_expression(ast_dump_context, this->array_,\n                                           this->start_, this->end_, this->cap_);\n }\n \n@@ -11697,7 +11697,7 @@ String_index_expression::do_get_backend(Translate_context* context)\n       Bexpression* ptr = bytes->get_backend(context);\n       ptr = gogo->backend()->pointer_offset_expression(ptr, bstart, loc);\n       Btype* ubtype = Type::lookup_integer_type(\"uint8\")->get_backend(gogo);\n-      Bexpression* index = \n+      Bexpression* index =\n \tgogo->backend()->indirect_expression(ubtype, ptr, true, loc);\n \n       Btype* byte_btype = bytes->type()->points_to()->get_backend(gogo);\n@@ -11945,7 +11945,7 @@ Map_index_expression::get_value_pointer(Gogo* gogo)\n // Dump ast representation for a map index expression\n \n void\n-Map_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context) \n+Map_index_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n   Index_expression::dump_index_expression(ast_dump_context, this->map_,\n@@ -12546,7 +12546,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \timethod = it->find_method(name);\n     }\n \n-  if ((method == NULL && imethod == NULL) \n+  if ((method == NULL && imethod == NULL)\n       || (left_type->named_type() != NULL && left_type->points_to() != NULL))\n     {\n       if (!is_ambiguous)\n@@ -12621,7 +12621,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \t   ++p)\n \tresults->push_back(*p);\n     }\n-  \n+\n   Function_type* fntype = Type::make_function_type(NULL, parameters, results,\n \t\t\t\t\t\t   location);\n   if (method_type->is_varargs())\n@@ -12708,14 +12708,14 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n // Dump the ast for a selector expression.\n \n void\n-Selector_expression::do_dump_expression(Ast_dump_context* ast_dump_context) \n+Selector_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n   ast_dump_context->dump_expression(this->left_);\n   ast_dump_context->ostream() << \".\";\n   ast_dump_context->ostream() << this->name_;\n }\n-                      \n+\n // Make a selector expression.\n \n Expression*\n@@ -12800,7 +12800,7 @@ Allocation_expression::do_get_backend(Translate_context* context)\n // Dump ast representation for an allocation expression.\n \n void\n-Allocation_expression::do_dump_expression(Ast_dump_context* ast_dump_context) \n+Allocation_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n     const\n {\n   ast_dump_context->ostream() << \"new(\";\n@@ -14447,6 +14447,7 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n \t\t\t\t\tType* type)\n {\n   Location location = this->location();\n+  Unordered_map(unsigned int, std::vector<Expression*>) st;\n   if (this->vals_ != NULL)\n     {\n       if (!this->has_keys_)\n@@ -14477,6 +14478,48 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n \t      go_assert((*p)->is_error_expression());\n \t      return Expression::make_error(location);\n \t    }\n+\t  // Check if there are duplicate constant keys.\n+\t  if (!(*p)->is_constant())\n+\t    continue;\n+\t  std::string sval;\n+\t  // Check if there are duplicate constant string keys.\n+\t  if ((*p)->string_constant_value(&sval))\n+\t    {\n+\t      unsigned int h = Gogo::hash_string(sval, 0);\n+\t      // Search the index h in the hash map.\n+\t      Unordered_map(unsigned int, std::vector<Expression*>)::iterator mit;\n+\t      mit = st.find(h);\n+\t      if (mit == st.end())\n+\t\t{\n+\t\t  // No duplicate since h is a new index.\n+\t\t  // Create a new vector indexed by h and add it to the hash map.\n+\t\t  std::vector<Expression*> l;\n+\t\t  l.push_back(*p);\n+\t\t  std::pair<unsigned int, std::vector<Expression*> > val(h, l);\n+\t\t  st.insert(val);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // Do further check since index h already exists.\n+\t\t  for (std::vector<Expression*>::iterator lit =\n+\t\t\t   mit->second.begin();\n+\t\t       lit != mit->second.end();\n+\t\t       lit++)\n+\t\t    {\n+\t\t      std::string s;\n+\t\t      bool ok = (*lit)->string_constant_value(&s);\n+\t\t      go_assert(ok);\n+\t\t      if (s == sval)\n+\t\t\t{\n+\t\t\t  go_error_at((*p)->location(), (\"duplicate key \"\n+\t\t\t\t      \"in map literal\"));\n+\t\t\t  return Expression::make_error(location);\n+\t\t\t}\n+\t\t    }\n+\t\t  // Add this new string key to the vector indexed by h.\n+\t\t  mit->second.push_back(*p);\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -15260,8 +15303,8 @@ Type_info_expression::do_dump_expression(\n   ast_dump_context->ostream() << \"typeinfo(\";\n   ast_dump_context->dump_type(this->type_);\n   ast_dump_context->ostream() << \",\";\n-  ast_dump_context->ostream() << \n-    (this->type_info_ == TYPE_INFO_ALIGNMENT ? \"alignment\" \n+  ast_dump_context->ostream() <<\n+    (this->type_info_ == TYPE_INFO_ALIGNMENT ? \"alignment\"\n     : this->type_info_ == TYPE_INFO_FIELD_ALIGNMENT ? \"field alignment\"\n     : this->type_info_ == TYPE_INFO_SIZE ? \"size\"\n     : this->type_info_ == TYPE_INFO_BACKEND_PTRDATA ? \"backend_ptrdata\"\n@@ -15369,8 +15412,8 @@ Slice_info_expression::do_dump_expression(\n   ast_dump_context->ostream() << \"sliceinfo(\";\n   this->slice_->dump_expression(ast_dump_context);\n   ast_dump_context->ostream() << \",\";\n-  ast_dump_context->ostream() << \n-      (this->slice_info_ == SLICE_INFO_VALUE_POINTER ? \"values\" \n+  ast_dump_context->ostream() <<\n+      (this->slice_info_ == SLICE_INFO_VALUE_POINTER ? \"values\"\n     : this->slice_info_ == SLICE_INFO_LENGTH ? \"length\"\n     : this->slice_info_ == SLICE_INFO_CAPACITY ? \"capacity \"\n     : \"unknown\");\n@@ -15969,7 +16012,7 @@ class Struct_field_offset_expression : public Expression\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n-  \n+\n  private:\n   // The type of the struct.\n   Struct_type* type_;\n@@ -16056,7 +16099,7 @@ class Label_addr_expression : public Expression\n   void\n   do_dump_expression(Ast_dump_context* ast_dump_context) const\n   { ast_dump_context->ostream() << this->label_->name(); }\n-  \n+\n  private:\n   // The label whose address we are taking.\n   Label* label_;\n@@ -17028,7 +17071,7 @@ Numeric_constant::check_float_type(Float_type* type, bool issue_error,\n     }\n \n   return ret;\n-} \n+}\n \n // Check whether the constant can be expressed in a complex type.\n "}, {"sha": "79c3cc9f736cd0147369a8080fc5de846b71e1a8", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=26a8c34ec94a479266f641699dbc4a8b36bdfd30", "patch": "@@ -265,6 +265,21 @@ Gogo::pkgpath_for_symbol(const std::string& pkgpath)\n   return go_encode_id(pkgpath);\n }\n \n+// Return a hash code for a string, given a starting hash.\n+\n+unsigned int\n+Gogo::hash_string(const std::string& s, unsigned int h)\n+{\n+  const char* p = s.data();\n+  size_t len = s.length();\n+  for (; len > 0; --len)\n+    {\n+      h ^= *p++;\n+      h*= 16777619;\n+    }\n+  return h;\n+}\n+\n // Get the package path to use for type reflection data.  This should\n // ideally be unique across the entire link.\n "}, {"sha": "e4a1415269610f09cdfcdaae61db9611eeadfd13", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=26a8c34ec94a479266f641699dbc4a8b36bdfd30", "patch": "@@ -224,6 +224,10 @@ class Gogo\n   static std::string\n   pkgpath_for_symbol(const std::string& pkgpath);\n \n+  // Compute a hash code for a string, given a seed.\n+  static unsigned int\n+  hash_string(const std::string&, unsigned int);\n+\n   // Return the package path to use for reflect.Type.PkgPath.\n   const std::string&\n   pkgpath() const;"}, {"sha": "e411456434caca4833ea453d70c86d57470b09a0", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=26a8c34ec94a479266f641699dbc4a8b36bdfd30", "patch": "@@ -951,21 +951,6 @@ Type::do_hash_for_method(Gogo*, int) const\n   return 0;\n }\n \n-// Return a hash code for a string, given a starting hash.\n-\n-unsigned int\n-Type::hash_string(const std::string& s, unsigned int h)\n-{\n-  const char* p = s.data();\n-  size_t len = s.length();\n-  for (; len > 0; --len)\n-    {\n-      h ^= *p++;\n-      h*= 16777619;\n-    }\n-  return h;\n-}\n-\n // A hash table mapping unnamed types to the backend representation of\n // those types.\n \n@@ -4668,7 +4653,7 @@ Function_type::Results_hash::operator()(const Typed_identifier_list* t) const\n        ++p)\n     {\n       hash <<= 2;\n-      hash = Type::hash_string(p->name(), hash);\n+      hash = Gogo::hash_string(p->name(), hash);\n       hash += p->type()->hash_for_method(NULL, Type::COMPARE_TAGS);\n     }\n   return hash;\n@@ -8924,7 +8909,7 @@ Interface_type::do_hash_for_method(Gogo*, int) const\n \t   p != this->all_methods_->end();\n \t   ++p)\n \t{\n-\t  ret = Type::hash_string(p->name(), ret);\n+\t  ret = Gogo::hash_string(p->name(), ret);\n \t  // We don't use the method type in the hash, to avoid\n \t  // infinite recursion if an interface method uses a type\n \t  // which is an interface which inherits from the interface\n@@ -10469,7 +10454,7 @@ Named_type::do_hash_for_method(Gogo* gogo, int) const\n   go_assert(!this->is_alias_);\n \n   const std::string& name(this->named_object()->name());\n-  unsigned int ret = Type::hash_string(name, 0);\n+  unsigned int ret = Gogo::hash_string(name, 0);\n \n   // GOGO will be NULL here when called from Type_hash_identical.\n   // That is OK because that is only used for internal hash tables\n@@ -10481,9 +10466,9 @@ Named_type::do_hash_for_method(Gogo* gogo, int) const\n     {\n       const Package* package = this->named_object()->package();\n       if (package == NULL)\n-\tret = Type::hash_string(gogo->pkgpath(), ret);\n+\tret = Gogo::hash_string(gogo->pkgpath(), ret);\n       else\n-\tret = Type::hash_string(package->pkgpath(), ret);\n+\tret = Gogo::hash_string(package->pkgpath(), ret);\n     }\n \n   return ret;"}, {"sha": "4bc5497bc8d0cc5b5d47340969cc011a156806dc", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a8c34ec94a479266f641699dbc4a8b36bdfd30/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=26a8c34ec94a479266f641699dbc4a8b36bdfd30", "patch": "@@ -1161,10 +1161,6 @@ class Type\n   append_mangled_name(const Type* type, Gogo* gogo, std::string* ret) const\n   { type->do_mangled_name(gogo, ret); }\n \n-  // Incorporate a string into a hash code.\n-  static unsigned int\n-  hash_string(const std::string&, unsigned int);\n-\n   // Return the backend representation for the underlying type of a\n   // named type.\n   static Btype*"}]}