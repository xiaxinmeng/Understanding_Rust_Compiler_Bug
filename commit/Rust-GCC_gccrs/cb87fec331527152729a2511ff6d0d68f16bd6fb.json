{"sha": "cb87fec331527152729a2511ff6d0d68f16bd6fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I4N2ZlYzMzMTUyNzE1MjcyOWEyNTExZmY2ZDBkNjhmMTZiZDZmYg==", "commit": {"author": {"name": "Sebastian Huber", "email": "sebastian.huber@embedded-brains.de", "date": "2019-01-09T06:16:05Z"}, "committer": {"name": "Sebastian Huber", "email": "sh@gcc.gnu.org", "date": "2019-01-09T06:16:05Z"}, "message": "libgomp: Reduce copy and paste for RTEMS\n\nlibgomp/\n\n\t* config/rtems/bar.c: Include \"../linux/bar.c\" and delete copy\n\tand paste code.\n\nFrom-SVN: r267752", "tree": {"sha": "88f57359f3f0424a899b12d6e57e8d8ac6100388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88f57359f3f0424a899b12d6e57e8d8ac6100388"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb87fec331527152729a2511ff6d0d68f16bd6fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb87fec331527152729a2511ff6d0d68f16bd6fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb87fec331527152729a2511ff6d0d68f16bd6fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb87fec331527152729a2511ff6d0d68f16bd6fb/comments", "author": {"login": "sebhub", "id": 932056, "node_id": "MDQ6VXNlcjkzMjA1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/932056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebhub", "html_url": "https://github.com/sebhub", "followers_url": "https://api.github.com/users/sebhub/followers", "following_url": "https://api.github.com/users/sebhub/following{/other_user}", "gists_url": "https://api.github.com/users/sebhub/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebhub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebhub/subscriptions", "organizations_url": "https://api.github.com/users/sebhub/orgs", "repos_url": "https://api.github.com/users/sebhub/repos", "events_url": "https://api.github.com/users/sebhub/events{/privacy}", "received_events_url": "https://api.github.com/users/sebhub/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30b4d0d0b9c82e2ae5c9abde62967c5fe01c4f84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b4d0d0b9c82e2ae5c9abde62967c5fe01c4f84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30b4d0d0b9c82e2ae5c9abde62967c5fe01c4f84"}], "stats": {"total": 188, "additions": 7, "deletions": 181}, "files": [{"sha": "9bb7e89367d687facb015ca1a30c7ac108cfee14", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb87fec331527152729a2511ff6d0d68f16bd6fb/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb87fec331527152729a2511ff6d0d68f16bd6fb/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=cb87fec331527152729a2511ff6d0d68f16bd6fb", "patch": "@@ -1,3 +1,8 @@\n+2019-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n+\n+\t* config/rtems/bar.c: Include \"../linux/bar.c\" and delete copy\n+\tand paste code.\n+\n 2019-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n \t* config/rtems/affinity-fmt.c: New file.  Include affinity-fmt.c,"}, {"sha": "e15327d9b7197d3ea31d855b043a0ec5b5867079", "filename": "libgomp/config/rtems/bar.c", "status": "modified", "additions": 2, "deletions": 181, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb87fec331527152729a2511ff6d0d68f16bd6fb/libgomp%2Fconfig%2Frtems%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb87fec331527152729a2511ff6d0d68f16bd6fb/libgomp%2Fconfig%2Frtems%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Frtems%2Fbar.c?ref=cb87fec331527152729a2511ff6d0d68f16bd6fb", "patch": "@@ -72,184 +72,5 @@ do_wait (int *addr, int val)\n     futex_wait (addr, val);\n }\n \n-/* Everything below this point should be identical to the Linux\n-   implementation.  */\n-\n-void\n-gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n-{\n-  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n-    {\n-      /* Next time we'll be awaiting TOTAL threads again.  */\n-      bar->awaited = bar->total;\n-      __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,\n-\t\t\tMEMMODEL_RELEASE);\n-      futex_wake ((int *) &bar->generation, INT_MAX);\n-    }\n-  else\n-    {\n-      do\n-\tdo_wait ((int *) &bar->generation, state);\n-      while (__atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE) == state);\n-    }\n-}\n-\n-void\n-gomp_barrier_wait (gomp_barrier_t *bar)\n-{\n-  gomp_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n-}\n-\n-/* Like gomp_barrier_wait, except that if the encountering thread\n-   is not the last one to hit the barrier, it returns immediately.\n-   The intended usage is that a thread which intends to gomp_barrier_destroy\n-   this barrier calls gomp_barrier_wait, while all other threads\n-   call gomp_barrier_wait_last.  When gomp_barrier_wait returns,\n-   the barrier can be safely destroyed.  */\n-\n-void\n-gomp_barrier_wait_last (gomp_barrier_t *bar)\n-{\n-  gomp_barrier_state_t state = gomp_barrier_wait_start (bar);\n-  if (state & BAR_WAS_LAST)\n-    gomp_barrier_wait_end (bar, state);\n-}\n-\n-void\n-gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n-{\n-  futex_wake ((int *) &bar->generation, count == 0 ? INT_MAX : count);\n-}\n-\n-void\n-gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n-{\n-  unsigned int generation, gen;\n-\n-  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n-    {\n-      /* Next time we'll be awaiting TOTAL threads again.  */\n-      struct gomp_thread *thr = gomp_thread ();\n-      struct gomp_team *team = thr->ts.team;\n-\n-      bar->awaited = bar->total;\n-      team->work_share_cancelled = 0;\n-      if (__builtin_expect (team->task_count, 0))\n-\t{\n-\t  gomp_barrier_handle_tasks (state);\n-\t  state &= ~BAR_WAS_LAST;\n-\t}\n-      else\n-\t{\n-\t  state &= ~BAR_CANCELLED;\n-\t  state += BAR_INCR - BAR_WAS_LAST;\n-\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n-\t  futex_wake ((int *) &bar->generation, INT_MAX);\n-\t  return;\n-\t}\n-    }\n-\n-  generation = state;\n-  state &= ~BAR_CANCELLED;\n-  do\n-    {\n-      do_wait ((int *) &bar->generation, generation);\n-      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n-      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n-\t{\n-\t  gomp_barrier_handle_tasks (state);\n-\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n-\t}\n-      generation |= gen & BAR_WAITING_FOR_TASK;\n-    }\n-  while (gen != state + BAR_INCR);\n-}\n-\n-void\n-gomp_team_barrier_wait (gomp_barrier_t *bar)\n-{\n-  gomp_team_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n-}\n-\n-void\n-gomp_team_barrier_wait_final (gomp_barrier_t *bar)\n-{\n-  gomp_barrier_state_t state = gomp_barrier_wait_final_start (bar);\n-  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n-    bar->awaited_final = bar->total;\n-  gomp_team_barrier_wait_end (bar, state);\n-}\n-\n-bool\n-gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n-\t\t\t\t   gomp_barrier_state_t state)\n-{\n-  unsigned int generation, gen;\n-\n-  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n-    {\n-      /* Next time we'll be awaiting TOTAL threads again.  */\n-      /* BAR_CANCELLED should never be set in state here, because\n-\t cancellation means that at least one of the threads has been\n-\t cancelled, thus on a cancellable barrier we should never see\n-\t all threads to arrive.  */\n-      struct gomp_thread *thr = gomp_thread ();\n-      struct gomp_team *team = thr->ts.team;\n-\n-      bar->awaited = bar->total;\n-      team->work_share_cancelled = 0;\n-      if (__builtin_expect (team->task_count, 0))\n-\t{\n-\t  gomp_barrier_handle_tasks (state);\n-\t  state &= ~BAR_WAS_LAST;\n-\t}\n-      else\n-\t{\n-\t  state += BAR_INCR - BAR_WAS_LAST;\n-\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n-\t  futex_wake ((int *) &bar->generation, INT_MAX);\n-\t  return false;\n-\t}\n-    }\n-\n-  if (__builtin_expect (state & BAR_CANCELLED, 0))\n-    return true;\n-\n-  generation = state;\n-  do\n-    {\n-      do_wait ((int *) &bar->generation, generation);\n-      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n-      if (__builtin_expect (gen & BAR_CANCELLED, 0))\n-\treturn true;\n-      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n-\t{\n-\t  gomp_barrier_handle_tasks (state);\n-\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n-\t}\n-      generation |= gen & BAR_WAITING_FOR_TASK;\n-    }\n-  while (gen != state + BAR_INCR);\n-\n-  return false;\n-}\n-\n-bool\n-gomp_team_barrier_wait_cancel (gomp_barrier_t *bar)\n-{\n-  return gomp_team_barrier_wait_cancel_end (bar, gomp_barrier_wait_start (bar));\n-}\n-\n-void\n-gomp_team_barrier_cancel (struct gomp_team *team)\n-{\n-  gomp_mutex_lock (&team->task_lock);\n-  if (team->barrier.generation & BAR_CANCELLED)\n-    {\n-      gomp_mutex_unlock (&team->task_lock);\n-      return;\n-    }\n-  team->barrier.generation |= BAR_CANCELLED;\n-  gomp_mutex_unlock (&team->task_lock);\n-  futex_wake ((int *) &team->barrier.generation, INT_MAX);\n-}\n+#define GOMP_WAIT_H 1\n+#include \"../linux/bar.c\""}]}