{"sha": "53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNiNGJmNzRlYjZhNTJkZjZiM2U2NGU0OWM2ZmM5NjgwZjEwYjE0ZQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-07-22T16:39:49Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-07-22T16:39:49Z"}, "message": "tree-into-ssa.c (set_livein_block): Fix typo in comment.\n\n\n\t* tree-into-ssa.c (set_livein_block): Fix typo in comment.\n\t(rewrite_ssa_into_ssa): Start iterating over SSA names at 1.\n\tRelease SSA names that have been re-renamed.\n\t* tree-phinodes.c (make_phi_node): Set same TREE_TYPE as the\n\tvariable.\n\t* tree-ssa-alias.c (init_alias_info): If aliases have been\n\tcomputed before, clear existing alias information.\n\t(create_name_tags): Do no fixup PT_ANYTHING pointers.\n\tIf the new name tag for a pointer is different than the one it\n\thad before, mark the old tag for renaming.\n\t(replace_may_alias): New function.\n\t(group_aliases): Call it.\n\t(setup_pointers_and_addressables): Always call get_tmt_for.\n\t(maybe_create_global_var): Don't create .GLOBAL_VAR more than\n\tonce.\n\t(set_pt_anything): New local function.\n\t(set_pt_malloc): New local function.\n\t(merge_pointed_to_info): Don't merge pointed-to variables from\n\tthe original pointer if the destination is pointing to an\n\tunknown location.\n\t(add_pointed_to_expr): Call set_pt_anything and set_pt_malloc.\n\t(add_pointed_to_var): Do not add a variable to the points-to\n\tset if the pointer is already pointing to anywhere.\n\t(collect_points_to_info_r): If the defining statement is a PHI\n\tnode, only merge pointed-to information if the argument has\n\talready been visited.\n\t(get_tmt_for): Only create a new tag if the pointer didn't\n\thave one already.\n\t(dump_alias_info): Emit more information.\n\t(dump_points_to_info_for): Likewise.\n\t* tree-ssa-dom.c (redirect_edges_and_update_ssa_graph): Don't\n\ttry to get the annotation of an SSA_NAME.\n\t* tree-ssa-operands.c (add_stmt_operand): Only check for empty\n\talias sets when checking is enabled.\n\t* tree-ssa-pre.c (need_eh_cleanup): New local variable.\n\t(eliminate): Mark basic blocks that will need\n\tEH information cleaned up.\n\t(init_pre): Split ENTRY_BLOCK->0 if block 0 has more than one\n\tpredecessor.\n\tInitialize need_eh_cleanup.\n\t(fini_pre): Call tree_purge_all_dead_eh_edges and\n\tcleanup_tree_cfg if needed.\n\tFree need_eh_cleanup.\n\t* tree-ssa.c (verify_ssa_name): New function.\n\t(verify_def): Call it.\n\tRe-arrange to avoid printing too many error messages.\n\t(verify_use): Likewise.\n\t(verify_phi_args): Likewise.\n\t(verify_flow_insensitive_alias_info): New function.\n\t(verify_flow_sensitive_alias_info): New function.\n\t(verify_alias_info): New function.\n\t(verify_ssa): Call verify_alias_info.\n\tClear TREE_VISITED on all the SSA_NAMEs before scanning the\n\tprogram.\n\tRe-arrange to avoid printing too many error messages.\n\t* tree-ssanames.c (make_ssa_name): Clear\n\tSSA_NAME_IN_FREE_LIST.\n\t(release_ssa_name): Never release a default definition.\n\t(release_defs): New function.\n\t* tree.h: Declare it.\n\t* tree-ssa-dce.c (remove_dead_stmt): Call it.\n\n\n\t* tree-ssa.c (walk_use_def_chains_1): Add new argument IS_DFS.\n\tIf true, do a depth-first search.  Do a breadht-first search,\n\totherwise.\n\t(walk_use_def_chains): Add new argument IS_DFS.\n\tUpdate all users.\n\t* tree-flow.h (walk_use_def_chains): Update prototype.\n\nFrom-SVN: r85052", "tree": {"sha": "f1ef74e5fc1c2bcc492abd6b400e131a68c5977f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1ef74e5fc1c2bcc492abd6b400e131a68c5977f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/comments", "author": null, "committer": null, "parents": [{"sha": "8e99fb4f70a03741b3be630a290932c4de63ce23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e99fb4f70a03741b3be630a290932c4de63ce23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e99fb4f70a03741b3be630a290932c4de63ce23"}], "stats": {"total": 900, "additions": 730, "deletions": 170}, "files": [{"sha": "2b38a13387cf0c5b60a104a64ecf73a7fc89747d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -1,3 +1,76 @@\n+2004-07-22  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-into-ssa.c (set_livein_block): Fix typo in comment.\n+\t(rewrite_ssa_into_ssa): Start iterating over SSA names at 1.\n+\tRelease SSA names that have been re-renamed.\n+\t* tree-phinodes.c (make_phi_node): Set same TREE_TYPE as the\n+\tvariable.\n+\t* tree-ssa-alias.c (init_alias_info): If aliases have been\n+\tcomputed before, clear existing alias information.\n+\t(create_name_tags): Do no fixup PT_ANYTHING pointers.\n+\tIf the new name tag for a pointer is different than the one it\n+\thad before, mark the old tag for renaming.\n+\t(replace_may_alias): New function.\n+\t(group_aliases): Call it.\n+\t(setup_pointers_and_addressables): Always call get_tmt_for.\n+\t(maybe_create_global_var): Don't create .GLOBAL_VAR more than\n+\tonce.\n+\t(set_pt_anything): New local function.\n+\t(set_pt_malloc): New local function.\n+\t(merge_pointed_to_info): Don't merge pointed-to variables from\n+\tthe original pointer if the destination is pointing to an\n+\tunknown location.\n+\t(add_pointed_to_expr): Call set_pt_anything and set_pt_malloc.\n+\t(add_pointed_to_var): Do not add a variable to the points-to\n+\tset if the pointer is already pointing to anywhere.\n+\t(collect_points_to_info_r): If the defining statement is a PHI\n+\tnode, only merge pointed-to information if the argument has\n+\talready been visited.\n+\t(get_tmt_for): Only create a new tag if the pointer didn't\n+\thave one already.\n+\t(dump_alias_info): Emit more information.\n+\t(dump_points_to_info_for): Likewise.\n+\t* tree-ssa-dom.c (redirect_edges_and_update_ssa_graph): Don't\n+\ttry to get the annotation of an SSA_NAME.\n+\t* tree-ssa-operands.c (add_stmt_operand): Only check for empty\n+\talias sets when checking is enabled.\n+\t* tree-ssa-pre.c (need_eh_cleanup): New local variable.\n+\t(eliminate): Mark basic blocks that will need\n+\tEH information cleaned up.\n+\t(init_pre): Split ENTRY_BLOCK->0 if block 0 has more than one\n+\tpredecessor.\n+\tInitialize need_eh_cleanup.\n+\t(fini_pre): Call tree_purge_all_dead_eh_edges and\n+\tcleanup_tree_cfg if needed.\n+\tFree need_eh_cleanup.\n+\t* tree-ssa.c (verify_ssa_name): New function.\n+\t(verify_def): Call it.\n+\tRe-arrange to avoid printing too many error messages.\n+\t(verify_use): Likewise.\n+\t(verify_phi_args): Likewise.\n+\t(verify_flow_insensitive_alias_info): New function.\n+\t(verify_flow_sensitive_alias_info): New function.\n+\t(verify_alias_info): New function.\n+\t(verify_ssa): Call verify_alias_info.\n+\tClear TREE_VISITED on all the SSA_NAMEs before scanning the\n+\tprogram.\n+\tRe-arrange to avoid printing too many error messages.\n+\t* tree-ssanames.c (make_ssa_name): Clear\n+\tSSA_NAME_IN_FREE_LIST.\n+\t(release_ssa_name): Never release a default definition.\n+\t(release_defs): New function.\n+\t* tree.h: Declare it.\n+\t* tree-ssa-dce.c (remove_dead_stmt): Call it.\n+\n+2004-07-22  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa.c (walk_use_def_chains_1): Add new argument IS_DFS.\n+\tIf true, do a depth-first search.  Do a breadht-first search,\n+\totherwise.\n+\t(walk_use_def_chains): Add new argument IS_DFS.\n+\tUpdate all users.\n+\t* tree-flow.h (walk_use_def_chains): Update prototype.\n+\n 2004-07-22  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/cris.md: Tweak formatting."}, {"sha": "dcde389b711f07ef3afcacc487cad4922532bf99", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -576,7 +576,7 @@ extern bool tree_ssa_useless_type_conversion_1 (tree, tree);\n extern void verify_ssa (void);\n extern void delete_tree_ssa (void);\n extern void register_new_def (tree, varray_type *);\n-extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *);\n+extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n extern void kill_redundant_phi_nodes (void);\n \n /* In tree-into-ssa.c  */"}, {"sha": "4d5992e2d564a27f836741e58fa22eb0f5290c2c", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -608,7 +608,7 @@ set_livein_block (tree var, basic_block bb)\n /* If the use operand pointed to by OP_P needs to be renamed, then strip away \n    any SSA_NAME wrapping the operand, set *UID_P to the underlying variable's \n    uid, and return true.  Otherwise return false.  If the operand was an \n-   SSA_NAME, change it to the stipped name.  */\n+   SSA_NAME, change it to the stripped name.  */\n \n static bool\n prepare_use_operand_for_rename (use_operand_p op_p, size_t *uid_p)\n@@ -1822,9 +1822,8 @@ rewrite_ssa_into_ssa (bitmap names_to_rename)\n   /* We no longer need this bitmap, clear and free it.  */\n   sbitmap_free (mark_def_sites_global_data.kills);\n \n-  for (i = 0; i < num_ssa_names; i++)\n-    if (ssa_name (i))\n-      set_current_def (ssa_name (i), NULL_TREE);\n+  for (i = 1; i < num_ssa_names; i++)\n+    set_current_def (ssa_name (i), NULL_TREE);\n \n   /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n   insert_phi_nodes (dfs, names_to_rename);\n@@ -1856,6 +1855,9 @@ rewrite_ssa_into_ssa (bitmap names_to_rename)\n   /* Finalize the dominator walker.  */\n   fini_walk_dominator_tree (&walk_data);\n \n+  EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i,\n+      release_ssa_name (ssa_name (i)));\n+\n   sbitmap_free (snames_to_rename);\n \n   timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n@@ -1874,16 +1876,16 @@ rewrite_ssa_into_ssa (bitmap names_to_rename)\n \n   htab_delete (def_blocks);\n \n-  for (i = 0; i < num_ssa_names; i++)\n+  for (i = 1; i < num_ssa_names; i++)\n     {\n       name = ssa_name (i);\n-      if (!name\n-\t  || !SSA_NAME_AUX (name))\n+      if (!SSA_NAME_AUX (name))\n \tcontinue;\n \n       free (SSA_NAME_AUX (name));\n       SSA_NAME_AUX (name) = NULL;\n     }\n+\n   timevar_pop (TV_TREE_SSA_OTHER);\n }\n "}, {"sha": "3b54b08a40db98dc63f41b56082543a8139fe0b0", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -202,6 +202,7 @@ make_phi_node (tree var, int len)\n   memset (phi, 0, size);\n   TREE_SET_CODE (phi, PHI_NODE);\n   PHI_ARG_CAPACITY (phi) = len;\n+  TREE_TYPE (phi) = TREE_TYPE (var);\n   if (TREE_CODE (var) == SSA_NAME)\n     SET_PHI_RESULT (phi, var);\n   else"}, {"sha": "bf11fe2c27098aa1a11c2b84efad10b79355a0dc", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 225, "deletions": 41, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -141,6 +141,7 @@ static tree create_memory_tag (tree type, bool is_type_tag);\n static tree get_tmt_for (tree, struct alias_info *);\n static tree get_nmt_for (tree);\n static void add_may_alias (tree, tree);\n+static void replace_may_alias (tree, size_t, tree);\n static struct alias_info *init_alias_info (void);\n static void delete_alias_info (struct alias_info *);\n static void compute_points_to_and_addr_escape (struct alias_info *);\n@@ -386,6 +387,73 @@ init_alias_info (void)\n   ai->dereferenced_ptrs_store = BITMAP_XMALLOC ();\n   ai->dereferenced_ptrs_load = BITMAP_XMALLOC ();\n \n+  /* If aliases have been computed before, clear existing information.  */\n+  if (aliases_computed_p)\n+    {\n+      size_t i;\n+\n+      /* Clear the call-clobbered set.  We are going to re-discover\n+\t  call-clobbered variables.  */\n+      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n+\t{\n+\t  tree var = referenced_var (i);\n+\t  DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL (var) = 0;\n+\n+\t  /* Variables that are intrinsically call-clobbered (globals,\n+\t     local statics, etc) will not be marked by the aliasing\n+\t     code, so we can't remove them from CALL_CLOBBERED_VARS.  */\n+\t  if (!is_call_clobbered (var))\n+\t    bitmap_clear_bit (call_clobbered_vars, var_ann (var)->uid);\n+\t});\n+\n+      /* Similarly, clear the set of addressable variables.  In this\n+\t case, we can just clear the set because addressability is\n+\t only computed here.  */\n+      bitmap_clear (addressable_vars);\n+\n+      /* Clear flow-insensitive alias information from each symbol.  */\n+      for (i = 0; i < num_referenced_vars; i++)\n+\t{\n+\t  var_ann_t ann = var_ann (referenced_var (i));\n+\n+\t  ann->is_alias_tag = 0;\n+\t  if (ann->type_mem_tag)\n+\t    {\n+\t      var_ann_t tag_ann = var_ann (ann->type_mem_tag);\n+\t      tag_ann->may_aliases = NULL;\n+\t      bitmap_set_bit (vars_to_rename, tag_ann->uid);\n+\t    }\n+\t}\n+\n+      /* Clear flow-sensitive points-to information from each SSA name.  */\n+      for (i = 1; i < num_ssa_names; i++)\n+\t{\n+\t  tree name = ssa_name (i);\n+\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (name)))\n+\t    continue;\n+\n+\t  if (SSA_NAME_PTR_INFO (name))\n+\t    {\n+\t      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (name);\n+\n+\t      /* Clear all the flags but keep the name tag to\n+\t\t avoid creating new temporaries unnecessarily.  If\n+\t\t this pointer is found to point to a subset or\n+\t\t superset of its former points-to set, then a new\n+\t\t tag will need to be created in create_name_tags.  */\n+\t      pi->pt_anything = 0;\n+\t      pi->pt_malloc = 0;\n+\t      pi->value_escapes_p = 0;\n+\t      pi->is_dereferenced = 0;\n+\t      if (pi->pt_vars)\n+\t\tbitmap_clear (pi->pt_vars);\n+\t      if (pi->name_mem_tag)\n+\t\tvar_ann (pi->name_mem_tag)->may_aliases = NULL;\n+\t    }\n+\t}\n+    }\n+\n   return ai;\n }\n \n@@ -438,7 +506,7 @@ collect_points_to_info_for (struct alias_info *ai, tree ptr)\n   if (!bitmap_bit_p (ai->ssa_names_visited, SSA_NAME_VERSION (ptr)))\n     {\n       bitmap_set_bit (ai->ssa_names_visited, SSA_NAME_VERSION (ptr));\n-      walk_use_def_chains (ptr, collect_points_to_info_r, ai);\n+      walk_use_def_chains (ptr, collect_points_to_info_r, ai, true);\n       VARRAY_PUSH_TREE (ai->processed_ptrs, ptr);\n     }\n }\n@@ -704,22 +772,13 @@ create_name_tags (struct alias_info *ai)\n       tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n \n-      /* If we could not determine where PTR was pointing to, clear\n-\t all the other points-to flags.  */\n-      pi = SSA_NAME_PTR_INFO (ptr);\n-      if (pi->pt_anything)\n-\t{\n-\t  pi->pt_malloc = 0;\n-\t  pi->pt_vars = NULL;\n-\t  pi->is_dereferenced = 0;\n-\t}\n-\n       if (!pi->is_dereferenced)\n \tcontinue;\n \n       if (pi->pt_vars)\n \t{\n \t  size_t j;\n+\t  tree old_name_tag = pi->name_mem_tag;\n \n \t  /* If PTR points to a set of variables, check if we don't\n \t     have another pointer Q with the same points-to set before\n@@ -732,7 +791,6 @@ create_name_tags (struct alias_info *ai)\n \t     problems if they both had different name tags because\n \t     they would have different SSA version numbers (which\n \t     would force us to take the name tags in and out of SSA).  */\n-\t  pi->name_mem_tag = NULL_TREE;\n \t  for (j = 0; j < i; j++)\n \t    {\n \t      tree q = VARRAY_TREE (ai->processed_ptrs, j);\n@@ -748,8 +806,17 @@ create_name_tags (struct alias_info *ai)\n \t\t}\n \t    }\n \n+\t  /* If we didn't find a pointer with the same points-to set\n+\t     as PTR, create a new name tag if needed.  */\n \t  if (pi->name_mem_tag == NULL_TREE)\n \t    pi->name_mem_tag = get_nmt_for (ptr);\n+\n+\t  /* If the new name tag computed for PTR is different than\n+\t     the old name tag that it used to have, then the old tag\n+\t     needs to be removed from the IL, so we mark it for\n+\t     renaming.  */\n+\t  if (old_name_tag && old_name_tag != pi->name_mem_tag)\n+\t    bitmap_set_bit (vars_to_rename, var_ann (old_name_tag)->uid);\n \t}\n       else if (pi->pt_malloc)\n \t{\n@@ -1160,11 +1227,14 @@ group_aliases (struct alias_info *ai)\n \t  var_ann_t ann = var_ann (alias);\n \t  if (ann->may_aliases)\n \t    {\n+\t      tree new_alias;\n+\n #if defined ENABLE_CHECKING\n \t      if (VARRAY_ACTIVE_SIZE (ann->may_aliases) != 1)\n \t\tabort ();\n #endif\n-\t      VARRAY_TREE (aliases, j) = VARRAY_TREE (ann->may_aliases, 0);\n+\t      new_alias = VARRAY_TREE (ann->may_aliases, 0);\n+\t      replace_may_alias (name_tag, j, new_alias);\n \t    }\n \t}\n     }\n@@ -1305,8 +1375,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n \t  /* If pointer VAR still doesn't have a memory tag associated\n \t     with it, create it now or re-use an existing one.  */\n-\t  if (tag == NULL_TREE)\n-\t    tag = get_tmt_for (var, ai);\n+\t  tag = get_tmt_for (var, ai);\n \t  t_ann = var_ann (tag);\n \n \t  /* The type tag will need to be renamed into SSA afterwards.\n@@ -1410,6 +1479,10 @@ maybe_create_global_var (struct alias_info *ai)\n {\n   size_t i, n_clobbered;\n   \n+  /* No need to create it, if we have one already.  */\n+  if (global_var)\n+    return;\n+\n   /* Count all the call-clobbered variables.  */\n   n_clobbered = 0;\n   EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, n_clobbered++);\n@@ -1613,6 +1686,63 @@ add_may_alias (tree var, tree alias)\n }\n \n \n+/* Replace alias I in the alias sets of VAR with NEW_ALIAS.  */\n+\n+static void\n+replace_may_alias (tree var, size_t i, tree new_alias)\n+{\n+  var_ann_t v_ann = var_ann (var);\n+  VARRAY_TREE (v_ann->may_aliases, i) = new_alias;\n+\n+  /* If VAR is a call-clobbered variable, so is NEW_ALIAS.  */\n+  if (is_call_clobbered (var))\n+    mark_call_clobbered (new_alias);\n+\n+  /* Likewise.  If NEW_ALIAS is call-clobbered, so is VAR.  */\n+  else if (is_call_clobbered (new_alias))\n+    mark_call_clobbered (var);\n+}\n+\n+\n+/* Mark pointer PTR as pointing to an arbitrary memory location.  */\n+\n+static void\n+set_pt_anything (tree ptr)\n+{\n+  struct ptr_info_def *pi = get_ptr_info (ptr);\n+\n+  pi->pt_anything = 1;\n+  pi->pt_malloc = 0;\n+  pi->pt_vars = NULL;\n+  pi->is_dereferenced = 0;\n+\n+  /* The pointer used to have a name tag, but we now found it pointing\n+     to an arbitrary location.  The name tag needs to be renamed and\n+     disassociated from PTR.  */\n+  if (pi->name_mem_tag)\n+    {\n+      bitmap_set_bit (vars_to_rename, var_ann (pi->name_mem_tag)->uid);\n+      pi->name_mem_tag = NULL_TREE;\n+    }\n+}\n+\n+\n+/* Mark pointer PTR as pointing to a malloc'd memory area.  */\n+\n+static void\n+set_pt_malloc (tree ptr)\n+{\n+  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\n+  /* If the pointer has already been found to point to arbitrary\n+     memory locations, it is unsafe to mark it as pointing to malloc. */\n+  if (pi->pt_anything)\n+    return;\n+\n+  pi->pt_malloc = 1;\n+}\n+\n+\n /* Given two pointers DEST and ORIG.  Merge the points-to information in\n    ORIG into DEST.  AI is as in collect_points_to_info.  */\n \n@@ -1629,8 +1759,6 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \n   if (orig_pi)\n     {\n-      dest_pi->pt_anything |= orig_pi->pt_anything;\n-\n       /* Notice that we never merge PT_MALLOC.  This attribute is only\n \t true if the pointer is the result of a malloc() call.\n \t Otherwise, we can end up in this situation:\n@@ -1654,10 +1782,13 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \t malloc call.  Copy propagation before aliasing should cure\n \t this.  */\n       dest_pi->pt_malloc = 0;\n-      if (orig_pi->pt_malloc)\n-\tdest_pi->pt_anything = 1;\n \n-      if (orig_pi->pt_vars)\n+      if (orig_pi->pt_malloc || orig_pi->pt_anything)\n+\tset_pt_anything (dest);\n+\n+      if (!dest_pi->pt_anything\n+\t  && orig_pi->pt_vars\n+\t  && bitmap_first_set_bit (orig_pi->pt_vars) >= 0)\n \t{\n \t  if (dest_pi->pt_vars == NULL)\n \t    {\n@@ -1678,8 +1809,6 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n static void\n add_pointed_to_expr (tree ptr, tree value)\n {\n-  struct ptr_info_def *pi;\n-\n   if (TREE_CODE (value) == WITH_SIZE_EXPR)\n     value = TREE_OPERAND (value, 0);\n \n@@ -1690,18 +1819,20 @@ add_pointed_to_expr (tree ptr, tree value)\n     abort ();\n #endif\n \n-  pi = get_ptr_info (ptr);\n+  get_ptr_info (ptr);\n \n   /* If VALUE is the result of a malloc-like call, then the area pointed to\n      PTR is guaranteed to not alias with anything else.  */\n   if (TREE_CODE (value) == CALL_EXPR\n       && (call_expr_flags (value) & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n-    pi->pt_malloc = 1;\n+    set_pt_malloc (ptr);\n   else\n-    pi->pt_anything = 1;\n+    set_pt_anything (ptr);\n \n   if (dump_file)\n     {\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\n       fprintf (dump_file, \"Pointer \");\n       print_generic_expr (dump_file, ptr, dump_flags);\n       fprintf (dump_file, \" points to \");\n@@ -1722,10 +1853,11 @@ add_pointed_to_expr (tree ptr, tree value)\n static void\n add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n {\n+  struct ptr_info_def *pi = get_ptr_info (ptr);\n+\n   if (TREE_CODE (value) == ADDR_EXPR)\n     {\n       tree pt_var;\n-      struct ptr_info_def *pi;\n       size_t uid;\n \n       pt_var = TREE_OPERAND (value, 0);\n@@ -1734,12 +1866,17 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n \n       if (pt_var && SSA_VAR_P (pt_var))\n \t{\n-\t  pi = get_ptr_info (ptr);\n \t  uid = var_ann (pt_var)->uid;\n-\t  if (pi->pt_vars == NULL)\n-\t    pi->pt_vars = BITMAP_GGC_ALLOC ();\n-\t  bitmap_set_bit (pi->pt_vars, uid);\n \t  bitmap_set_bit (ai->addresses_needed, uid);\n+\n+\t  /* If PTR has already been found to point anywhere, don't\n+\t     add the variable to PTR's points-to set.  */\n+\t  if (!pi->pt_anything)\n+\t    {\n+\t      if (pi->pt_vars == NULL)\n+\t\tpi->pt_vars = BITMAP_GGC_ALLOC ();\n+\t      bitmap_set_bit (pi->pt_vars, uid);\n+\t    }\n \t}\n       else\n \tadd_pointed_to_expr (ptr, value);\n@@ -1813,7 +1950,7 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n   else if (TREE_CODE (stmt) == ASM_EXPR)\n     {\n       /* Pointers defined by __asm__ statements can point anywhere.  */\n-      get_ptr_info (var)->pt_anything = 1;\n+      set_pt_anything (var);\n     }\n   else if (IS_EMPTY_STMT (stmt))\n     {\n@@ -1828,12 +1965,19 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n     }\n   else if (TREE_CODE (stmt) == PHI_NODE)\n     {\n+      /* It STMT is a PHI node, then VAR is one of its arguments.  The\n+\t variable that we are analyzing is the LHS of the PHI node.  */\n       tree lhs = PHI_RESULT (stmt);\n \n       if (is_gimple_min_invariant (var))\n \tadd_pointed_to_var (ai, lhs, var);\n       else if (TREE_CODE (var) == SSA_NAME)\n-\tmerge_pointed_to_info (ai, lhs, var);\n+\t{\n+\t  if (bitmap_bit_p (ai->ssa_names_visited, SSA_NAME_VERSION (var)))\n+\t    merge_pointed_to_info (ai, lhs, var);\n+\t  else\n+\t    set_pt_anything (lhs);\n+\t}\n       else\n \tabort ();\n     }\n@@ -2009,9 +2153,13 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n     {\n       struct alias_map_d *alias_map;\n \n-      /* Create a new MT.* artificial variable representing the memory\n-\t location pointed-to by PTR.  */\n-      tag = create_memory_tag (tag_type, true);\n+      /* If PTR did not have a type tag already, create a new TMT.*\n+\t artificial variable representing the memory location\n+\t pointed-to by PTR.  */\n+      if (var_ann (ptr)->type_mem_tag == NULL_TREE)\n+\ttag = create_memory_tag (tag_type, true);\n+      else\n+\ttag = var_ann (ptr)->type_mem_tag;\n \n       /* Add PTR to the POINTERS array.  Note that we are not interested in\n \t PTR's alias set.  Instead, we cache the alias set for the memory that\n@@ -2086,16 +2234,53 @@ dump_alias_info (FILE *file)\n   const char *funcname\n     = lang_hooks.decl_printable_name (current_function_decl, 2);\n \n-  fprintf (file, \"\\nAlias information for %s\\n\\n\", funcname);\n+  fprintf (file, \"\\nFlow-insensitive alias information for %s\\n\\n\", funcname);\n+\n+  fprintf (file, \"Aliased symbols\\n\\n\");\n+  for (i = 0; i < num_referenced_vars; i++)\n+    {\n+      tree var = referenced_var (i);\n+      if (may_be_aliased (var))\n+\tdump_variable (file, var);\n+    }\n+\n+  fprintf (file, \"\\nDereferenced pointers\\n\\n\");\n+  for (i = 0; i < num_referenced_vars; i++)\n+    {\n+      tree var = referenced_var (i);\n+      var_ann_t ann = var_ann (var);\n+      if (ann->type_mem_tag)\n+\tdump_variable (file, var);\n+    }\n+\n+  fprintf (file, \"\\nType memory tags\\n\\n\");\n+  for (i = 0; i < num_referenced_vars; i++)\n+    {\n+      tree var = referenced_var (i);\n+      var_ann_t ann = var_ann (var);\n+      if (ann->mem_tag_kind == TYPE_TAG)\n+\tdump_variable (file, var);\n+    }\n+\n+  fprintf (file, \"\\n\\nFlow-sensitive alias information for %s\\n\\n\", funcname);\n+\n+  fprintf (file, \"SSA_NAME pointers\\n\\n\");\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree ptr = ssa_name (i);\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+      if (!SSA_NAME_IN_FREE_LIST (ptr)\n+\t  && pi\n+\t  && pi->name_mem_tag)\n+\tdump_points_to_info_for (file, ptr);\n+    }\n \n+  fprintf (file, \"\\nName memory tags\\n\\n\");\n   for (i = 0; i < num_referenced_vars; i++)\n     {\n       tree var = referenced_var (i);\n       var_ann_t ann = var_ann (var);\n-      if (ann->may_aliases\n-\t  || ann->type_mem_tag\n-\t  || ann->is_alias_tag\n-\t  || ann->mem_tag_kind != NOT_A_TAG)\n+      if (ann->mem_tag_kind == NAME_TAG)\n \tdump_variable (file, var);\n     }\n \n@@ -2144,7 +2329,6 @@ dump_points_to_info_for (FILE *file, tree ptr)\n {\n   struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n \n-  fprintf (file, \"Pointer \");\n   print_generic_expr (file, ptr, dump_flags);\n \n   if (pi)"}, {"sha": "1d3038fc60cb2977759c57f3de5933564f70ba30", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -753,6 +753,7 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n     }\n \n   bsi_remove (i);\n+  release_defs (t);\n }\n \f\n /* Print out removed statement statistics.  */"}, {"sha": "e1f30d4ed564d346ef56d5edb01ebf2df4be7407", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -366,27 +366,30 @@ redirect_edges_and_update_ssa_graph (varray_type redirection_edges)\n \t  defs = DEF_OPS (ann);\n \t  for (j = 0; j < NUM_DEFS (defs); j++)\n \t    {\n-\t      tree op = SSA_NAME_VAR (DEF_OP (defs, j));\n-\t      bitmap_set_bit (vars_to_rename, var_ann (op)->uid);\n+\t      tree op = DEF_OP (defs, j);\n+\t      tree var = SSA_NAME_VAR (op);\n+\t      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t    }\n \n \t  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n \t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n \t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n-\t      bitmap_set_bit (vars_to_rename, var_ann (op)->uid);\n+\t      tree var = SSA_NAME_VAR (op);\n+\t      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t    }\n \t    \n \t  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n \t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n \t    {\n \t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n-\t      bitmap_set_bit (vars_to_rename, var_ann (op)->uid);\n+\t      tree var = SSA_NAME_VAR (op);\n+\t      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t    }\n \t}\n \n       /* Finally, any variables in PHI nodes at our final destination\n-         must also be taken our of SSA form.  */\n+         must also be taken out of SSA form.  */\n       for (phi = phi_nodes (tgt); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  tree result = SSA_NAME_VAR (PHI_RESULT (phi));\n@@ -528,6 +531,7 @@ redirect_edges_and_update_ssa_graph (varray_type redirection_edges)\n \t    remove_phi_node (phi, NULL, bb);\n \t}\n     }\n+\n   BITMAP_XFREE (virtuals_to_rename);\n }\n "}, {"sha": "6f632e4447e1a0045e47687cc30427d637bc50b0", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -1386,8 +1386,10 @@ add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n \n \t  /* The variable is aliased.  Add its aliases to the virtual\n \t     operands.  */\n+#if defined ENABLE_CHECKING\n \t  if (VARRAY_ACTIVE_SIZE (aliases) == 0)\n \t    abort ();\n+#endif\n \n \t  if (flags & opf_is_def)\n \t    {"}, {"sha": "d24ebc0b547de130f4bafccd9e16c1b2fa4cf4d9", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -307,6 +307,10 @@ static alloc_pool binary_node_pool;\n static alloc_pool unary_node_pool;\n static alloc_pool reference_node_pool;\n \n+/* Set of blocks with statements that have had its EH information\n+   cleaned up.  */\n+static bitmap need_eh_cleanup;\n+\n /* The phi_translate_table caches phi translations for a given\n    expression and predecessor.  */\n \n@@ -1891,6 +1895,16 @@ eliminate (void)\n \t\t  pre_stats.eliminations++;\n \t\t  propagate_tree_value (rhs_p, sprime);\n \t\t  modify_stmt (stmt);\n+\n+\t\t  /* If we removed EH side effects from the statement, clean\n+\t\t     its EH information.  */\n+\t\t  if (maybe_clean_eh_stmt (stmt))\n+\t\t    {\n+\t\t      bitmap_set_bit (need_eh_cleanup,\n+\t\t\t\t      bb_for_stmt (stmt)->index);\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tfprintf (dump_file, \"  Removed EH side effects.\\n\");\n+\t\t    }\n \t\t}\n \t    }\n         }\n@@ -1909,6 +1923,18 @@ init_pre (void)\n   connect_infinite_loops_to_exit ();\n   vn_init ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n+\n+  /* If block 0 has more than one predecessor, it means that its PHI\n+     nodes will have arguments coming from block -1.  This creates\n+     problems for several places in PRE that keep local arrays indexed\n+     by block number.  To prevent this, we split the edge coming from\n+     ENTRY_BLOCK_PTR (FIXME, if ENTRY_BLOCK_PTR had an index number\n+     different than -1 we wouldn't have to hack this.  tree-ssa-dce.c\n+     needs a similar change).  */\n+  if (ENTRY_BLOCK_PTR->succ->dest->pred->pred_next)\n+    if (!(ENTRY_BLOCK_PTR->succ->flags & EDGE_ABNORMAL))\n+      split_edge (ENTRY_BLOCK_PTR->succ);\n+\n   FOR_ALL_BB (bb)\n     bb->aux = xcalloc (1, sizeof (struct bb_value_sets));\n \n@@ -1926,7 +1952,8 @@ init_pre (void)\n   binary_node_pool = create_alloc_pool (\"Binary tree nodes\", tsize, 30);\n   tsize = tree_size (build1 (NEGATE_EXPR, void_type_node, NULL_TREE));\n   unary_node_pool = create_alloc_pool (\"Unary tree nodes\", tsize, 30);\n-  tsize = tree_size (build (COMPONENT_REF, void_type_node, NULL_TREE, NULL_TREE, NULL_TREE));\n+  tsize = tree_size (build (COMPONENT_REF, void_type_node, NULL_TREE,\n+\t\t\t    NULL_TREE, NULL_TREE));\n   reference_node_pool = create_alloc_pool (\"Reference tree nodes\", tsize, 30);\n   FOR_ALL_BB (bb)\n     {\n@@ -1935,6 +1962,8 @@ init_pre (void)\n       TMP_GEN (bb) = bitmap_set_new ();\n       AVAIL_OUT (bb) = bitmap_set_new ();\n     }\n+\n+  need_eh_cleanup = BITMAP_XMALLOC ();\n }\n \n \n@@ -1962,6 +1991,14 @@ fini_pre (void)\n \n   free_dominance_info (CDI_POST_DOMINATORS);\n   vn_delete ();\n+\n+  if (bitmap_first_set_bit (need_eh_cleanup) >= 0)\n+    {\n+      tree_purge_all_dead_eh_edges (need_eh_cleanup);\n+      cleanup_tree_cfg ();\n+    }\n+\n+  BITMAP_XFREE (need_eh_cleanup);\n }\n \n "}, {"sha": "6e92597f5116e112868c2823f41585b69f7b8fcc", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 336, "deletions": 115, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -102,52 +102,91 @@ ssa_redirect_edge (edge e, basic_block dest)\n }\n \n \n-/* Return true if the definition of SSA_NAME at block BB is malformed.\n-\n-   STMT is the statement where SSA_NAME is created.\n+/* Return true if SSA_NAME is malformed and mark it visited.\n \n-   DEFINITION_BLOCK is an array of basic blocks indexed by SSA_NAME version\n-      numbers.  If DEFINITION_BLOCK[SSA_NAME_VERSION] is set, it means that the\n-      block in that array slot contains the definition of SSA_NAME.  */\n+   IS_VIRTUAL is true if this SSA_NAME was found inside a virtual\n+      operand.  */\n \n static bool\n-verify_def (basic_block bb, basic_block *definition_block, tree ssa_name,\n-\t    tree stmt)\n+verify_ssa_name (tree ssa_name, bool is_virtual)\n {\n-  bool err = false;\n+  TREE_VISITED (ssa_name) = 1;\n \n   if (TREE_CODE (ssa_name) != SSA_NAME)\n     {\n       error (\"Expected an SSA_NAME object\");\n-      debug_generic_stmt (ssa_name);\n-      debug_generic_stmt (stmt);\n+      return true;\n+    }\n+\n+  if (SSA_NAME_IN_FREE_LIST (ssa_name))\n+    {\n+      error (\"Found an SSA_NAME that had been released into the free pool\");\n+      return true;\n+    }\n+\n+  if (is_virtual && is_gimple_reg (ssa_name))\n+    {\n+      error (\"Found a virtual definition for a GIMPLE register\");\n+      return true;\n     }\n \n+  if (!is_virtual && !is_gimple_reg (ssa_name))\n+    {\n+      error (\"Found a real definition for a non-register\");\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Return true if the definition of SSA_NAME at block BB is malformed.\n+\n+   STMT is the statement where SSA_NAME is created.\n+\n+   DEFINITION_BLOCK is an array of basic blocks indexed by SSA_NAME\n+      version numbers.  If DEFINITION_BLOCK[SSA_NAME_VERSION] is set,\n+      it means that the block in that array slot contains the\n+      definition of SSA_NAME.\n+\n+   IS_VIRTUAL is true if SSA_NAME is created by a V_MAY_DEF or a\n+      V_MUST_DEF.  */\n+\n+static bool\n+verify_def (basic_block bb, basic_block *definition_block, tree ssa_name,\n+\t    tree stmt, bool is_virtual)\n+{\n+  if (verify_ssa_name (ssa_name, is_virtual))\n+    goto err;\n+\n   if (definition_block[SSA_NAME_VERSION (ssa_name)])\n     {\n       error (\"SSA_NAME created in two different blocks %i and %i\",\n \t     definition_block[SSA_NAME_VERSION (ssa_name)]->index, bb->index);\n-      fprintf (stderr, \"SSA_NAME: \");\n-      debug_generic_stmt (ssa_name);\n-      debug_generic_stmt (stmt);\n-      err = true;\n+      goto err;\n     }\n \n   definition_block[SSA_NAME_VERSION (ssa_name)] = bb;\n \n   if (SSA_NAME_DEF_STMT (ssa_name) != stmt)\n     {\n       error (\"SSA_NAME_DEF_STMT is wrong\");\n-      fprintf (stderr, \"SSA_NAME: \");\n-      debug_generic_stmt (ssa_name);\n       fprintf (stderr, \"Expected definition statement:\\n\");\n       debug_generic_stmt (SSA_NAME_DEF_STMT (ssa_name));\n       fprintf (stderr, \"\\nActual definition statement:\\n\");\n       debug_generic_stmt (stmt);\n-      err = true;\n+      goto err;\n     }\n \n-  return err;\n+  return false;\n+\n+err:\n+  fprintf (stderr, \"while verifying SSA_NAME \");\n+  print_generic_expr (stderr, ssa_name, 0);\n+  fprintf (stderr, \" in statement\\n\");\n+  debug_generic_stmt (stmt);\n+\n+  return true;\n }\n \n \n@@ -160,16 +199,22 @@ verify_def (basic_block bb, basic_block *definition_block, tree ssa_name,\n \n    CHECK_ABNORMAL is true if the caller wants to check whether this use\n       is flowing through an abnormal edge (only used when checking PHI\n-      arguments).  */\n+      arguments).\n+\n+   IS_VIRTUAL is true if SSA_NAME is created by a V_MAY_DEF or a\n+      V_MUST_DEF.  */\n \n static bool\n verify_use (basic_block bb, basic_block def_bb, tree ssa_name,\n-\t    tree stmt, bool check_abnormal)\n+\t    tree stmt, bool check_abnormal, bool is_virtual)\n {\n   bool err = false;\n \n-  if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (ssa_name)))\n-    ; /* Nothing to do.  */\n+  err = verify_ssa_name (ssa_name, is_virtual);\n+\n+  if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (ssa_name))\n+      && var_ann (SSA_NAME_VAR (ssa_name))->default_def == ssa_name)\n+    ; /* Default definitions have empty statements.  Nothing to do.  */\n   else if (!def_bb)\n     {\n       error (\"Missing definition\");\n@@ -193,7 +238,7 @@ verify_use (basic_block bb, basic_block def_bb, tree ssa_name,\n   if (err)\n     {\n       fprintf (stderr, \"for SSA_NAME: \");\n-      debug_generic_stmt (ssa_name);\n+      debug_generic_expr (ssa_name);\n       fprintf (stderr, \"in statement:\\n\");\n       debug_generic_stmt (stmt);\n     }\n@@ -229,8 +274,9 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n       e = PHI_ARG_EDGE (phi, i);\n \n       if (TREE_CODE (op) == SSA_NAME)\n-\terr |= verify_use (e->src, definition_block[SSA_NAME_VERSION (op)], op,\n-\t\t\t   phi, e->flags & EDGE_ABNORMAL);\n+\terr = verify_use (e->src, definition_block[SSA_NAME_VERSION (op)], op,\n+\t\t\t  phi, e->flags & EDGE_ABNORMAL,\n+\t\t\t  !is_gimple_reg (PHI_RESULT (phi)));\n \n       if (e->dest != bb)\n \t{\n@@ -257,6 +303,7 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n \t{\n \t  fprintf (stderr, \"PHI argument\\n\");\n \t  debug_generic_stmt (op);\n+\t  goto error;\n \t}\n \n       e->aux = (void *) 2;\n@@ -269,10 +316,12 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n \t  error (\"No argument flowing through edge %d->%d\\n\", e->src->index,\n \t\t e->dest->index);\n \t  err = true;\n+\t  goto error;\n \t}\n       e->aux = (void *) 0;\n     }\n \n+error:\n   if (err)\n     {\n       fprintf (stderr, \"for PHI node\\n\");\n@@ -284,18 +333,196 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n }\n \n \n+static void\n+verify_flow_insensitive_alias_info (void)\n+{\n+  size_t i;\n+  tree var;\n+  bitmap visited = BITMAP_XMALLOC ();\n+\n+  for (i = 0; i < num_referenced_vars; i++)\n+    {\n+      var_ann_t ann;\n+\n+      var = referenced_var (i);\n+      ann = var_ann (var);\n+\n+      if (ann->mem_tag_kind == TYPE_TAG || ann->mem_tag_kind == NAME_TAG)\n+\t{\n+\t  size_t j;\n+\t  varray_type may_aliases = ann->may_aliases;\n+\n+\t  for (j = 0; may_aliases && j < VARRAY_ACTIVE_SIZE (may_aliases); j++)\n+\t    {\n+\t      tree alias = VARRAY_TREE (may_aliases, j);\n+\n+\t      bitmap_set_bit (visited, var_ann (alias)->uid);\n+\n+\t      if (!may_be_aliased (alias))\n+\t\t{\n+\t\t  error (\"Non-addressable variable inside an alias set.\");\n+\t\t  debug_variable (alias);\n+\t\t  goto err;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  for (i = 0; i < num_referenced_vars; i++)\n+    {\n+      var_ann_t ann;\n+\n+      var = referenced_var (i);\n+      ann = var_ann (var);\n+\n+      if (ann->mem_tag_kind == NOT_A_TAG\n+\t  && ann->is_alias_tag\n+\t  && !bitmap_bit_p (visited, ann->uid))\n+\t{\n+\t  error (\"Addressable variable that is an alias tag but is not in any alias set.\");\n+\t  goto err;\n+\t}\n+    }\n+\n+  BITMAP_XFREE (visited);\n+  return;\n+\n+err:\n+  debug_variable (var);\n+  internal_error (\"verify_flow_insensitive_alias_info failed.\");\n+}\n+\n+\n+static void\n+verify_flow_sensitive_alias_info (void)\n+{\n+  size_t i;\n+  tree ptr;\n+\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      var_ann_t ann;\n+      struct ptr_info_def *pi;\n+\n+      ptr = ssa_name (i);\n+      ann = var_ann (SSA_NAME_VAR (ptr));\n+      pi = SSA_NAME_PTR_INFO (ptr);\n+\n+      /* We only care for pointers that are actually referenced in the\n+\t program.  */\n+      if (!TREE_VISITED (ptr) || !POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\tcontinue;\n+\n+      /* RESULT_DECL is special.  If it's a GIMPLE register, then it\n+\t is only written-to only once in the return statement.\n+\t Otherwise, aggregate RESULT_DECLs may be written-to more than\n+\t once in virtual operands.  */\n+      if (TREE_CODE (SSA_NAME_VAR (ptr)) == RESULT_DECL\n+\t  && is_gimple_reg (ptr))\n+\tcontinue;\n+\n+      if (pi == NULL)\n+\tcontinue;\n+\n+      if (pi->is_dereferenced && !pi->name_mem_tag && !ann->type_mem_tag)\n+\t{\n+\t  error (\"Dereferenced pointers should have a name or a type tag\");\n+\t  goto err;\n+\t}\n+\n+      if (pi->pt_anything && (pi->pt_malloc || pi->pt_vars))\n+\t{\n+\t  error (\"Pointers that point to anything should not point to malloc or other vars\");\n+\t  goto err;\n+\t}\n+      \n+      if (pi->pt_malloc && pi->pt_vars)\n+\t{\n+\t  error (\"Pointers pointing to malloc get a unique tag and cannot point to other vars\");\n+\t  goto err;\n+\t}\n+\n+      if (pi->name_mem_tag\n+\t  && !pi->pt_malloc\n+\t  && (pi->pt_vars == NULL\n+\t      || bitmap_first_set_bit (pi->pt_vars) < 0))\n+\t{\n+\t  error (\"Pointers with a memory tag, should have points-to sets or point to malloc\");\n+\t  goto err;\n+\t}\n+\n+      if (pi->value_escapes_p\n+\t  && pi->name_mem_tag\n+\t  && !is_call_clobbered (pi->name_mem_tag))\n+\t{\n+\t  error (\"Pointer escapes but its name tag is not call-clobbered.\");\n+\t  goto err;\n+\t}\n+\n+      if (pi->name_mem_tag && pi->pt_vars)\n+\t{\n+\t  size_t j;\n+\n+\t  for (j = i + 1; j < num_ssa_names; j++)\n+\t    {\n+\t      tree ptr2 = ssa_name (j);\n+\t      struct ptr_info_def *pi2 = SSA_NAME_PTR_INFO (ptr2);\n+\n+\t      if (!POINTER_TYPE_P (TREE_TYPE (ptr2)))\n+\t\tcontinue;\n+\n+\t      if (pi2\n+\t\t  && pi2->name_mem_tag\n+\t\t  && pi2->pt_vars\n+\t\t  && bitmap_first_set_bit (pi2->pt_vars) >= 0\n+\t\t  && pi->name_mem_tag != pi2->name_mem_tag\n+\t\t  && bitmap_equal_p (pi->pt_vars, pi2->pt_vars))\n+\t\t{\n+\t\t  error (\"Two pointers with different name tags and identical points-to sets\");\n+\t\t  debug_variable (ptr2);\n+\t\t  goto err;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return;\n+\n+err:\n+  debug_variable (ptr);\n+  internal_error (\"verify_flow_sensitive_alias_info failed.\");\n+}\n+\n+\n+/* Verify the consistency of aliasing information.  */\n+\n+static void\n+verify_alias_info (void)\n+{\n+  if (aliases_computed_p)\n+    {\n+      verify_flow_sensitive_alias_info ();\n+      verify_flow_insensitive_alias_info ();\n+    }\n+}\n+\n+\n /* Verify common invariants in the SSA web.\n    TODO: verify the variable annotations.  */\n \n void\n verify_ssa (void)\n {\n-  bool err = false;\n+  size_t i;\n   basic_block bb;\n   basic_block *definition_block = xcalloc (num_ssa_names, sizeof (basic_block));\n \n   timevar_push (TV_TREE_SSA_VERIFY);\n \n+  /* Keep track of SSA names present in the IL.  */\n+  for (i = 1; i < num_ssa_names; i++)\n+    TREE_VISITED (ssa_name (i)) = 0;\n+\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   /* Verify and register all the SSA_NAME definitions found in the\n@@ -306,7 +533,9 @@ verify_ssa (void)\n       block_stmt_iterator bsi;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\terr |= verify_def (bb, definition_block, PHI_RESULT (phi), phi);\n+\tif (verify_def (bb, definition_block, PHI_RESULT (phi), phi,\n+\t\t\t!is_gimple_reg (PHI_RESULT (phi))))\n+\t  goto err;\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n@@ -323,47 +552,33 @@ verify_ssa (void)\n \n \t  v_may_defs = V_MAY_DEF_OPS (ann);\n \t  if (ann->makes_aliased_stores && NUM_V_MAY_DEFS (v_may_defs) == 0)\n-\t    error (\"Makes aliased stores, but no V_MAY_DEFS\");\n+\t    {\n+\t      error (\"Statement makes aliased stores, but has no V_MAY_DEFS\");\n+\t      debug_generic_stmt (stmt);\n+\t      goto err;\n+\t    }\n \t    \n \t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n \t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n-\t      if (is_gimple_reg (op))\n-\t\t{\n-\t\t  error (\"Found a virtual definition for a GIMPLE register\");\n-\t\t  debug_generic_stmt (op);\n-\t\t  debug_generic_stmt (stmt);\n-\t\t  err = true;\n-\t\t}\n-\t      err |= verify_def (bb, definition_block, op, stmt);\n+\t      if (verify_def (bb, definition_block, op, stmt, true))\n+\t\tgoto err;\n \t    }\n           \n \t  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n \t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n \t    {\n \t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n-\t      if (is_gimple_reg (op))\n-\t\t{\n-\t\t  error (\"Found a virtual must-def for a GIMPLE register\");\n-\t\t  debug_generic_stmt (op);\n-\t\t  debug_generic_stmt (stmt);\n-\t\t  err = true;\n-\t\t}\n-\t      err |= verify_def (bb, definition_block, op, stmt);\n+\t      if (verify_def (bb, definition_block, op, stmt, true))\n+\t\tgoto err;\n \t    }\n \n \t  defs = DEF_OPS (ann);\n \t  for (j = 0; j < NUM_DEFS (defs); j++)\n \t    {\n \t      tree op = DEF_OP (defs, j);\n-\t      if (TREE_CODE (op) == SSA_NAME && !is_gimple_reg (op))\n-\t\t{\n-\t\t  error (\"Found a real definition for a non-GIMPLE register\");\n-\t\t  debug_generic_stmt (op);\n-\t\t  debug_generic_stmt (stmt);\n-\t\t  err = true;\n-\t\t}\n-\t      err |= verify_def (bb, definition_block, op, stmt);\n+\t      if (verify_def (bb, definition_block, op, stmt, false))\n+\t\tgoto err;\n \t    }\n \t}\n     }\n@@ -384,17 +599,16 @@ verify_ssa (void)\n \t    {\n \t      error (\"AUX pointer initialized for edge %d->%d\\n\", e->src->index,\n \t\t      e->dest->index);\n-\t      err = true;\n+\t      goto err;\n \t    }\n \t}\n \n       /* Verify the arguments for every PHI node in the block.  */\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\terr |= verify_phi_args (phi, bb, definition_block);\n-\n-      /* Now verify all the uses and vuses in every statement of the block. \n+\tif (verify_phi_args (phi, bb, definition_block))\n+\t  goto err;\n \n-\t Remember, the RHS of a V_MAY_DEF is a use as well.  */\n+      /* Now verify all the uses and vuses in every statement of the block.  */\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n@@ -408,58 +622,40 @@ verify_ssa (void)\n \t  for (j = 0; j < NUM_VUSES (vuses); j++)\n \t    {\n \t      tree op = VUSE_OP (vuses, j);\n-\n-\t      if (is_gimple_reg (op))\n-\t\t{\n-\t\t  error (\"Found a virtual use for a GIMPLE register\");\n-\t\t  debug_generic_stmt (op);\n-\t\t  debug_generic_stmt (stmt);\n-\t\t  err = true;\n-\t\t}\n-\t      err |= verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n-\t\t\t\t op, stmt, false);\n+\t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n+\t\t\t      op, stmt, false, true))\n+\t\tgoto err;\n \t    }\n \n \t  v_may_defs = V_MAY_DEF_OPS (ann);\n \t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n \t      tree op = V_MAY_DEF_OP (v_may_defs, j);\n-\n-\t      if (is_gimple_reg (op))\n-\t\t{\n-\t\t  error (\"Found a virtual use for a GIMPLE register\");\n-\t\t  debug_generic_stmt (op);\n-\t\t  debug_generic_stmt (stmt);\n-\t\t  err = true;\n-\t\t}\n-\t      err |= verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n-\t\t\t\t op, stmt, false);\n+\t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n+\t\t\t      op, stmt, false, true))\n+\t\tgoto err;\n \t    }\n \n \t  uses = USE_OPS (ann);\n \t  for (j = 0; j < NUM_USES (uses); j++)\n \t    {\n \t      tree op = USE_OP (uses, j);\n-\n-\t      if (TREE_CODE (op) == SSA_NAME && !is_gimple_reg (op))\n-\t\t{\n-\t\t  error (\"Found a real use of a non-GIMPLE register\");\n-\t\t  debug_generic_stmt (op);\n-\t\t  debug_generic_stmt (stmt);\n-\t\t  err = true;\n-\t\t}\n-\t      err |= verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n-\t\t\t\t op, stmt, false);\n+\t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n+\t\t\t      op, stmt, false, false))\n+\t\tgoto err;\n \t    }\n \t}\n     }\n \n-  free (definition_block);\n+  /* Finally, verify alias information.  */\n+  verify_alias_info ();\n \n+  free (definition_block);\n   timevar_pop (TV_TREE_SSA_VERIFY);\n+  return;\n \n-  if (err)\n-    internal_error (\"verify_ssa failed.\");\n+err:\n+  internal_error (\"verify_ssa failed.\");\n }\n \n \n@@ -598,12 +794,20 @@ tree_ssa_useless_type_conversion (tree expr)\n \n \n /* Internal helper for walk_use_def_chains.  VAR, FN and DATA are as\n-   described in walk_use_def_chains.  VISITED is a bitmap used to mark\n-   visited SSA_NAMEs to avoid infinite loops.  */\n+   described in walk_use_def_chains.\n+   \n+   VISITED is a bitmap used to mark visited SSA_NAMEs to avoid\n+      infinite loops.\n+\n+   IS_DFS is true if the caller wants to perform a depth-first search\n+      when visiting PHI nodes.  A DFS will visit each PHI argument and\n+      call FN after each one.  Otherwise, all the arguments are\n+      visited first and then FN is called with each of the visited\n+      arguments in a separate pass.  */\n \n static bool\n walk_use_def_chains_1 (tree var, walk_use_def_chains_fn fn, void *data,\n-\t\t       bitmap visited)\n+\t\t       bitmap visited, bool is_dfs)\n {\n   tree def_stmt;\n \n@@ -617,49 +821,65 @@ walk_use_def_chains_1 (tree var, walk_use_def_chains_fn fn, void *data,\n   if (TREE_CODE (def_stmt) != PHI_NODE)\n     {\n       /* If we reached the end of the use-def chain, call FN.  */\n-      return (*fn) (var, def_stmt, data);\n+      return fn (var, def_stmt, data);\n     }\n   else\n     {\n       int i;\n \n-      /* Otherwise, follow use-def links out of each PHI argument and call\n-\t FN after visiting each one.  */\n+      /* When doing a breadth-first search, call FN before following the\n+\t use-def links for each argument.  */\n+      if (!is_dfs)\n+\tfor (i = 0; i < PHI_NUM_ARGS (def_stmt); i++)\n+\t  if (fn (PHI_ARG_DEF (def_stmt, i), def_stmt, data))\n+\t    return true;\n+\n+      /* Follow use-def links out of each PHI argument.  */\n       for (i = 0; i < PHI_NUM_ARGS (def_stmt); i++)\n \t{\n \t  tree arg = PHI_ARG_DEF (def_stmt, i);\n \t  if (TREE_CODE (arg) == SSA_NAME\n-\t      && walk_use_def_chains_1 (arg, fn, data, visited))\n-\t    return true;\n-\t  \n-\t  if ((*fn) (arg, def_stmt, data))\n+\t      && walk_use_def_chains_1 (arg, fn, data, visited, is_dfs))\n \t    return true;\n \t}\n+\n+      /* When doing a depth-first search, call FN after following the\n+\t use-def links for each argument.  */\n+      if (is_dfs)\n+\tfor (i = 0; i < PHI_NUM_ARGS (def_stmt); i++)\n+\t  if (fn (PHI_ARG_DEF (def_stmt, i), def_stmt, data))\n+\t    return true;\n     }\n+  \n   return false;\n }\n   \n \n \n-/* Walk use-def chains starting at the SSA variable VAR.  Call function FN\n-   at each reaching definition found.  FN takes three arguments: VAR, its\n-   defining statement (DEF_STMT) and a generic pointer to whatever state\n-   information that FN may want to maintain (DATA).  FN is able to stop the \n-   walk by returning true, otherwise in order to continue the walk, FN \n-   should return false.  \n+/* Walk use-def chains starting at the SSA variable VAR.  Call\n+   function FN at each reaching definition found.  FN takes three\n+   arguments: VAR, its defining statement (DEF_STMT) and a generic\n+   pointer to whatever state information that FN may want to maintain\n+   (DATA).  FN is able to stop the walk by returning true, otherwise\n+   in order to continue the walk, FN should return false.  \n \n    Note, that if DEF_STMT is a PHI node, the semantics are slightly\n-   different.  For each argument ARG of the PHI node, this function will:\n+   different.  The first argument to FN is no longer the original\n+   variable VAR, but the PHI argument currently being examined.  If FN\n+   wants to get at VAR, it should call PHI_RESULT (PHI).\n+\n+   If IS_DFS is true, this function will:\n \n-\t1- Walk the use-def chains for ARG.\n-\t2- Call (*FN) (ARG, PHI, DATA).\n+\t1- walk the use-def chains for all the PHI arguments, and,\n+\t2- call (*FN) (ARG, PHI, DATA) on all the PHI arguments.\n+\n+   If IS_DFS is false, the two steps above are done in reverse order\n+   (i.e., a breadth-first search).  */\n \n-   Note how the first argument to FN is no longer the original variable\n-   VAR, but the PHI argument currently being examined.  If FN wants to get\n-   at VAR, it should call PHI_RESULT (PHI).  */\n \n void\n-walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data)\n+walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data,\n+                     bool is_dfs)\n {\n   tree def_stmt;\n \n@@ -677,11 +897,12 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data)\n   else\n     {\n       bitmap visited = BITMAP_XMALLOC ();\n-      walk_use_def_chains_1 (var, fn, data, visited);\n+      walk_use_def_chains_1 (var, fn, data, visited, is_dfs);\n       BITMAP_XFREE (visited);\n     }\n }\n \n+\n /* Replaces VAR with REPL in memory reference expression *X in\n    statement STMT.  */\n "}, {"sha": "2785e530b3c54eb780cc236065481c3f68ed30b2", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -160,6 +160,7 @@ make_ssa_name (tree var, tree stmt)\n   SSA_NAME_VAR (t) = var;\n   SSA_NAME_DEF_STMT (t) = stmt;\n   SSA_NAME_PTR_INFO (t) = NULL;\n+  SSA_NAME_IN_FREE_LIST (t) = 0;\n \n   return t;\n }\n@@ -176,6 +177,11 @@ make_ssa_name (tree var, tree stmt)\n void\n release_ssa_name (tree var)\n {\n+  /* Never release the default definition for a symbol.  It's a\n+     special SSA name that should always exist once it's created.  */\n+  if (var == var_ann (SSA_NAME_VAR (var))->default_def)\n+    return;\n+\n   /* release_ssa_name can be called multiple times on a single SSA_NAME.\n      However, it should only end up on our free list one time.   We\n      keep a status bit in the SSA_NAME node itself to indicate it has\n@@ -216,4 +222,31 @@ duplicate_ssa_name (tree name, tree stmt)\n   return new_name;\n }\n \n+\n+/* Release all the SSA_NAMEs created by STMT.  */\n+\n+void\n+release_defs (tree stmt)\n+{\n+  size_t i;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  def_optype defs;\n+  stmt_ann_t ann;\n+\n+  ann = stmt_ann (stmt);\n+  defs = DEF_OPS (ann);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+\n+  for (i = 0; i < NUM_DEFS (defs); i++)\n+    release_ssa_name (DEF_OP (defs, i));\n+\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    release_ssa_name (V_MAY_DEF_RESULT (v_may_defs, i));\n+\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    release_ssa_name (V_MUST_DEF_OP (v_must_defs, i));\n+}\n+\n #include \"gt-tree-ssanames.h\""}, {"sha": "1962d72dff5797199f59ebeb9dbb4d9761befba5", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=53b4bf74eb6a52df6b3e64e49c6fc9680f10b14e", "patch": "@@ -2647,6 +2647,8 @@ extern void fini_ssanames (void);\n extern tree make_ssa_name (tree, tree);\n extern tree duplicate_ssa_name (tree, tree);\n extern void release_ssa_name (tree);\n+extern void release_defs (tree);\n+\n #ifdef GATHER_STATISTICS\n extern void ssanames_print_statistics (void);\n #endif"}]}