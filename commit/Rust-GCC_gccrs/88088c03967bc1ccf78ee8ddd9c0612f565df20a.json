{"sha": "88088c03967bc1ccf78ee8ddd9c0612f565df20a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwODhjMDM5NjdiYzFjY2Y3OGVlOGRkZDljMDYxMmY1NjVkZjIwYQ==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2005-06-05T09:54:20Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-06-05T09:54:20Z"}, "message": "tree-flow.h (stmt_ann_d): Move aux to ...\n\n        * tree-flow.h (stmt_ann_d): Move aux to ...\n        (tree_ann_common_d): ... here.\n        * tree-ssa-loop-im.c (LIM_DATA, determine_invariantness_stmt,\n        move_computations_stmt, schedule_sm): Update references to\n        aux.\n        * tree-vectorizer.h (set_stmt_info, vinfo_for_stmt): Likewise.\n        * tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n        call to set_stmt_info.\n        (vect_transform_loop): Likewise.\n        * tree-vectorizer.c (new_loop_vec_info, destroy_loop_vec_info):\n        Likewise.\n\n        * tree-vect-analyze.c (vect_analyze_scalar_cycles): Made void instead of\n        bool.\n        (vect_mark_relevant): Takes two additional arguments - live_p and\n        relevant_p. Set RELEVANT_P and LIVE_P according to these arguments.\n        (vect_stmt_relevant_p): Differentiate between a live stmt and a\n        relevant stmt. Return two values = live_p and relevant_p.\n        (vect_mark_stmts_to_be_vectorized): Call vect_mark_relevant and\n        vect_stmt_relevant_p with additional arguments. Phis are no longer\n        put into the worklist (analyzed seperately in analyze_scalar_cycles).\n        (vect_determine_vectorization_factor): Also check for LIVE_P, because a\n        stmt that is marked as irrelevant and live, cause it's only used out\n        side the loop, may need to be vectorized (e.g. reduction).\n        (vect_analyze_operations): Examine phis. Call\n        vectorizable_live_operation for for LIVE_P stmts. Check if\n        need_to_vectorize.\n        (vect_analyze_scalar_cycles): Update documentation. Don't fail\n        vectorization - just classify the scalar cycles created by the loop\n        phis. Call vect_is_simple_reduction.\n        (vect_analyze_loop): Call to analyze_scalar_cycles moved earlier.\n        * tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n        call to set_stmt_info.\n        (vect_get_vec_def_for_operand): Code reorganized - the code that\n        classifies the type of use was factored out to vect_is_simple_use.\n        (vectorizable_store, vect_is_simple_cond): Call vect_is_simple_use with\n        additional arguments.\n        (vectorizable_assignment): Likewise. Also make sure the stmt is relevant\n        and computes a loop_vec_def.\n        (vectorizable_operation, vectorizable_load, vectorizable_condition):\n        Likewise.\n        (vectorizable_live_operation): New.\n        (vect_transform_stmt): Handle LIVE_P stmts.\n        * tree-vectorizer.c (new_stmt_vec_info): Initialize the new fields\n        STMT_VINFO_LIVE_P and STMT_VINFO_DEF_TYPE.\n        (new_loop_vec_info, destroy_loop_vec_info): Also handle phis.\n        (vect_is_simple_use): Determine the type of the def and return it\n        in a new function argument. Consider vect_reduction_def and\n        vect_induction_def, but for now these are not supported.\n        (vect_is_simple_reduction): New. Empty for now.\n        * tree-vectorizer.h (vect_def_type): New enum type.\n        (_stmt_vec_info): Added new fields - live and _stmt_vec_info.\n        (STMT_VINFO_LIVE_P, STMT_VINFO_DEF_TYPE): New accessor macros.\n        (vect_is_simple_use): New arguments added to function declaration.\n        (vect_is_simple_reduction): New function declaration.\n        (vectorizable_live_operation): New function declaration.\n\n        * tree-vect-analyze.c (vect_can_advance_ivs_p): Add debug printout.\n        (vect_can_advance_ivs_p): Likewise.\n        * tree-vect-transform.c (vect_update_ivs_after_vectorizer): Likewise.\n\nFrom-SVN: r100617", "tree": {"sha": "26cd50c3f350a2ee9a8127ba71ee3f88ea837a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26cd50c3f350a2ee9a8127ba71ee3f88ea837a07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88088c03967bc1ccf78ee8ddd9c0612f565df20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88088c03967bc1ccf78ee8ddd9c0612f565df20a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88088c03967bc1ccf78ee8ddd9c0612f565df20a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88088c03967bc1ccf78ee8ddd9c0612f565df20a/comments", "author": null, "committer": null, "parents": [{"sha": "57049d399a8eff8cd573a9f162467cb3aaeeee35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57049d399a8eff8cd573a9f162467cb3aaeeee35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57049d399a8eff8cd573a9f162467cb3aaeeee35"}], "stats": {"total": 1221, "additions": 882, "deletions": 339}, "files": [{"sha": "47bcfa06f29f887e3b141702be93393a15354471", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -1,3 +1,66 @@\n+2005-06-05  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+        * tree-flow.h (stmt_ann_d): Move aux to ...\n+        (tree_ann_common_d): ... here.\n+        * tree-ssa-loop-im.c (LIM_DATA, determine_invariantness_stmt,\n+        move_computations_stmt, schedule_sm): Update references to\n+        aux.\n+        * tree-vectorizer.h (set_stmt_info, vinfo_for_stmt): Likewise.\n+        * tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n+        call to set_stmt_info.\n+        (vect_transform_loop): Likewise.\n+        * tree-vectorizer.c (new_loop_vec_info, destroy_loop_vec_info):\n+        Likewise.\n+\n+        * tree-vect-analyze.c (vect_analyze_scalar_cycles): Made void instead of\n+        bool.\n+        (vect_mark_relevant): Takes two additional arguments - live_p and\n+        relevant_p. Set RELEVANT_P and LIVE_P according to these arguments.\n+        (vect_stmt_relevant_p): Differentiate between a live stmt and a\n+        relevant stmt. Return two values = live_p and relevant_p.\n+        (vect_mark_stmts_to_be_vectorized): Call vect_mark_relevant and\n+        vect_stmt_relevant_p with additional arguments. Phis are no longer\n+        put into the worklist (analyzed seperately in analyze_scalar_cycles).\n+        (vect_determine_vectorization_factor): Also check for LIVE_P, because a\n+        stmt that is marked as irrelevant and live, cause it's only used out\n+        side the loop, may need to be vectorized (e.g. reduction).\n+        (vect_analyze_operations): Examine phis. Call\n+        vectorizable_live_operation for for LIVE_P stmts. Check if\n+        need_to_vectorize.\n+        (vect_analyze_scalar_cycles): Update documentation. Don't fail\n+        vectorization - just classify the scalar cycles created by the loop\n+        phis. Call vect_is_simple_reduction.\n+        (vect_analyze_loop): Call to analyze_scalar_cycles moved earlier.\n+        * tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n+        call to set_stmt_info.\n+        (vect_get_vec_def_for_operand): Code reorganized - the code that\n+        classifies the type of use was factored out to vect_is_simple_use.\n+        (vectorizable_store, vect_is_simple_cond): Call vect_is_simple_use with\n+        additional arguments.\n+        (vectorizable_assignment): Likewise. Also make sure the stmt is relevant\n+        and computes a loop_vec_def.\n+        (vectorizable_operation, vectorizable_load, vectorizable_condition):\n+        Likewise.\n+        (vectorizable_live_operation): New.\n+        (vect_transform_stmt): Handle LIVE_P stmts.\n+        * tree-vectorizer.c (new_stmt_vec_info): Initialize the new fields\n+        STMT_VINFO_LIVE_P and STMT_VINFO_DEF_TYPE.\n+        (new_loop_vec_info, destroy_loop_vec_info): Also handle phis.\n+        (vect_is_simple_use): Determine the type of the def and return it\n+        in a new function argument. Consider vect_reduction_def and\n+        vect_induction_def, but for now these are not supported.\n+        (vect_is_simple_reduction): New. Empty for now.\n+        * tree-vectorizer.h (vect_def_type): New enum type.\n+        (_stmt_vec_info): Added new fields - live and _stmt_vec_info.\n+        (STMT_VINFO_LIVE_P, STMT_VINFO_DEF_TYPE): New accessor macros.\n+        (vect_is_simple_use): New arguments added to function declaration.\n+        (vect_is_simple_reduction): New function declaration.\n+        (vectorizable_live_operation): New function declaration.\n+\n+        * tree-vect-analyze.c (vect_can_advance_ivs_p): Add debug printout.\n+        (vect_can_advance_ivs_p): Likewise.\n+        * tree-vect-transform.c (vect_update_ivs_after_vectorizer): Likewise.\n+\n 2005-06-05  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.c (mips_rtx_costs): Remove unused variable."}, {"sha": "5c440db350388ca8031be033d3b02ebd57dfcfe7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -1,3 +1,10 @@\n+2005-06-05  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-62: Check that second loop is not vectorized.\n+\t* gcc.dg/vect/vect-reduc-1.c: New.\n+\t* gcc.dg/vect/vect-reduc-2.c: New.\n+\t* gcc.dg/vect/vect-reduc-3.c: New.\n+\n 2005-06-04  Dale Johannesen  <dalej@apple.com>\n \n \t* gcc.c-torture/execute/20050603-1.c:  New."}, {"sha": "433b8bf3571cfbc57cbdc3b396e05b557c9c6920", "filename": "gcc/testsuite/gcc.dg/vect/vect-62.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-62.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -32,7 +32,9 @@ int main1 ()\n     }\n \n   /* Multidimensional array. Aligned. The \"inner\" dimensions\n-     are invariant in the inner loop. Store. */\n+     are invariant in the inner loop. Vectorizable, but the\n+     vectorizer detects that everything is invariant and that\n+     the loop is better left untouched. (it should be optimized away). */\n   for (i = 0; i < N; i++)\n     {\n       for (j = 0; j < N; j++)\n@@ -62,6 +64,7 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: redundant loop. no profit to vectorize.\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1c3d555f5d4e1abe35612528330bf1bf14191e3b", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+/* Test vectorization of reduction of unsigned-int.  */\n+/* Not supported yet.  */\n+\n+int main1 (unsigned int x, unsigned int max_result)\n+{\n+  int i;\n+  unsigned int ub[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned int uc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned int udiff = 2;\n+  unsigned int umax = x;\n+  unsigned int umin = 10;\n+\n+  /* Summation.  */\n+  for (i = 0; i < N; i++) {\n+    udiff += (ub[i] - uc[i]);\n+  }\n+\n+  /* Maximum.  */\n+  for (i = 0; i < N; i++) {\n+    umax = umax < uc[i] ? uc[i] : umax;\n+  }\n+\n+  /* Minimum.  */\n+  for (i = 0; i < N; i++) {\n+    umin = umin > uc[i] ? uc[i] : umin;\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+  if (umax != max_result)\n+    abort ();\n+  if (umin != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 (100, 100);\n+  return main1 (0, 15);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported use in stmt.\" 3 \"vect\" } } */"}, {"sha": "fd5e94b50046d3e1e3e84676d1d8ba4f74a4a2da", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -0,0 +1,54 @@\n+\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+/* Test vectorization of reduction of signed-int.  */\n+/* Not supported yet.  */\n+\n+int main1 (int x, int max_result)\n+{\n+  int i;\n+  int b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  int c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  int diff = 2;\n+  int max = x;\n+  int min = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    diff += (b[i] - c[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    max = max < c[i] ? c[i] : max;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    min = min > c[i] ? c[i] : min;\n+  }\n+\n+  /* check results:  */\n+  if (diff != DIFF)\n+    abort ();\n+  if (max != max_result)\n+    abort ();\n+  if (min != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 (100, 100);\n+  return main1 (0, 15);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported use in stmt.\" 3 \"vect\" } } */"}, {"sha": "86fbc4bdec1fa531190cfb31a98d22bbb59f7ab4", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-3.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 240\n+\n+/* Test vectorization of reduction of unsigned-int in the presence\n+   of unknown-loop-bound.  */\n+/* Not supported yet.  */\n+\n+int main1 (int n)\n+{\n+  int i;\n+  unsigned int ub[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned int uc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned int udiff;\n+\n+  udiff = 0;\n+  for (i = 0; i < n; i++) {\n+    udiff += (ub[i] - uc[i]);\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 (N);\n+  return main1 (N-1);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported use in stmt.\" 1 \"vect\" } } */"}, {"sha": "584e42b6594311e7d63d4e0a65b68f22bdd42fb1", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -93,6 +93,10 @@ struct tree_ann_common_d GTY(())\n   /* Annotation type.  */\n   enum tree_ann_type type;\n \n+ /* Auxiliary info specific to a pass.  At all times, this\n+    should either point to valid data or be NULL.  */ \n+  PTR GTY ((skip (\"\"))) aux; \n+\n   /* The value handle for this expression.  Used by GVN-PRE.  */\n   tree GTY((skip)) value_handle;\n };\n@@ -293,10 +297,6 @@ struct stmt_ann_d GTY(())\n      pass which needs statement UIDs.  */\n   unsigned int uid;\n \n- /* Auxiliary info specific to a pass.  At all times, this\n-    should either point to valid data or be NULL.  */\n-  PTR GTY ((skip (\"\"))) aux;\n-\n   /* Linked list of histograms for value-based profiling.  This is really a\n      struct histogram_value*.  We use void* to avoid having to export that\n      everywhere, and to avoid having to put it in GC memory.  */"}, {"sha": "e7acc5cdc05e2e09a8c622b42c3480524c00e9b2", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -102,7 +102,7 @@ struct lim_aux_data\n \n #define LIM_DATA(STMT) (TREE_CODE (STMT) == PHI_NODE \\\n \t\t\t? NULL \\\n-\t\t\t: (struct lim_aux_data *) (stmt_ann (STMT)->aux))\n+\t\t\t: (struct lim_aux_data *) (stmt_ann (STMT)->common.aux))\n \n /* Description of a memory reference location for store motion.  */\n \n@@ -632,7 +632,7 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t  stmt = stmt1;\n \t}\n \n-      stmt_ann (stmt)->aux = xcalloc (1, sizeof (struct lim_aux_data));\n+      stmt_ann (stmt)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n       LIM_DATA (stmt)->always_executed_in = outermost;\n \n       if (maybe_never && pos == MOVE_PRESERVE_EXECUTION)\n@@ -723,7 +723,7 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n       cost = LIM_DATA (stmt)->cost;\n       level = LIM_DATA (stmt)->tgt_loop;\n       free_lim_aux_data (LIM_DATA (stmt));\n-      stmt_ann (stmt)->aux = NULL;\n+      stmt_ann (stmt)->common.aux = NULL;\n \n       if (!level)\n \t{\n@@ -952,7 +952,7 @@ schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n \n   /* Emit the load & stores.  */\n   load = build (MODIFY_EXPR, void_type_node, tmp_var, ref);\n-  get_stmt_ann (load)->aux = xcalloc (1, sizeof (struct lim_aux_data));\n+  get_stmt_ann (load)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n   LIM_DATA (load)->max_loop = loop;\n   LIM_DATA (load)->tgt_loop = loop;\n "}, {"sha": "0b8e26ce9e15a890057f98b685dd5f54f8013d3d", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 242, "deletions": 158, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -42,7 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static loop_vec_info vect_analyze_loop_form (struct loop *);\n static bool vect_analyze_data_refs (loop_vec_info);\n static bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n-static bool vect_analyze_scalar_cycles (loop_vec_info);\n+static void vect_analyze_scalar_cycles (loop_vec_info);\n static bool vect_analyze_data_ref_accesses (loop_vec_info);\n static bool vect_analyze_data_ref_dependences (loop_vec_info);\n static bool vect_analyze_data_refs_alignment (loop_vec_info);\n@@ -53,8 +53,8 @@ static bool vect_determine_vectorization_factor (loop_vec_info);\n \n /* Utility functions for the analyses.  */\n static bool exist_non_indexing_operands_for_use_p (tree, tree);\n-static void vect_mark_relevant (VEC(tree,heap) **, tree);\n-static bool vect_stmt_relevant_p (tree, loop_vec_info);\n+static void vect_mark_relevant (VEC(tree,heap) **, tree, bool, bool);\n+static bool vect_stmt_relevant_p (tree, loop_vec_info, bool *, bool *);\n static tree vect_get_loop_niters (struct loop *, tree *);\n static bool vect_analyze_data_ref_dependence\n   (struct data_reference *, struct data_reference *, loop_vec_info);\n@@ -344,8 +344,13 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n           gcc_assert (stmt_info);\n           /* skip stmts which do not need to be vectorized.  */\n-          if (!STMT_VINFO_RELEVANT_P (stmt_info))\n-            continue;\n+          if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+\t      && !STMT_VINFO_LIVE_P (stmt_info))\n+            {\n+              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+                fprintf (vect_dump, \"skip.\");\n+              continue;\n+            }\n \n           if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n             {\n@@ -444,6 +449,9 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   unsigned int vectorization_factor = 0;\n   int i;\n   bool ok;\n+  tree phi;\n+  stmt_vec_info stmt_info;\n+  bool need_to_vectorize = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     fprintf (vect_dump, \"=== vect_analyze_operations ===\");\n@@ -455,6 +463,29 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n     {\n       basic_block bb = bbs[i];\n \n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+        {\n+\t  stmt_info = vinfo_for_stmt (phi);\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    {\n+\t      fprintf (vect_dump, \"examining phi: \");\n+\t      print_generic_expr (vect_dump, phi, TDF_SLIM);\n+\t    }\n+\n+\t  gcc_assert (stmt_info);\n+\n+\t  if (STMT_VINFO_LIVE_P (stmt_info))\n+\t    {\n+\t      /* FORNOW: not yet supported.  */\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t\tfprintf (vect_dump, \"not vectorized: value used after loop.\");\n+\t    return false;\n+\t  }\n+\n+          gcc_assert (!STMT_VINFO_RELEVANT_P (stmt_info));\n+        }\n+\n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  tree stmt = bsi_stmt (si);\n@@ -475,42 +506,77 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t     - computations that are used only for array indexing or loop\n \t     control  */\n \n-\t  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+\t      && !STMT_VINFO_LIVE_P (stmt_info))\n \t    {\n \t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t        fprintf (vect_dump, \"irrelevant.\");\n \t      continue;\n \t    }\n \n-#ifdef ENABLE_CHECKING\n           if (STMT_VINFO_RELEVANT_P (stmt_info))\n             {\n               gcc_assert (!VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))));\n               gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n-            }\n-#endif\n \n-\t  ok = (vectorizable_operation (stmt, NULL, NULL)\n-\t\t|| vectorizable_assignment (stmt, NULL, NULL)\n-\t\t|| vectorizable_load (stmt, NULL, NULL)\n-\t\t|| vectorizable_store (stmt, NULL, NULL)\n-\t\t|| vectorizable_condition (stmt, NULL, NULL));\n+\t      ok = (vectorizable_operation (stmt, NULL, NULL)\n+\t\t    || vectorizable_assignment (stmt, NULL, NULL)\n+\t\t    || vectorizable_load (stmt, NULL, NULL)\n+\t\t    || vectorizable_store (stmt, NULL, NULL)\n+\t\t    || vectorizable_condition (stmt, NULL, NULL));\n+\n+\t      if (!ok)\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t\t    {\n+\t\t      fprintf (vect_dump, \n+\t\t\t       \"not vectorized: relevant stmt not supported: \");\n+\t\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t    }\n+\t\t  return false;\n+\t\t}\t\n+\t      need_to_vectorize = true;\n+            }\n \n-\t  if (!ok)\n+\t  if (STMT_VINFO_LIVE_P (stmt_info))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-                                         LOOP_LOC (loop_vinfo)))\n+\t      ok = vectorizable_live_operation (stmt, NULL, NULL);\n+\n+\t      if (!ok)\n \t\t{\n-                  fprintf (vect_dump, \"not vectorized: stmt not supported: \");\n-\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t\t    {\n+\t\t      fprintf (vect_dump, \n+\t\t\t       \"not vectorized: live stmt not supported: \");\n+\t\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t    }\n+\t\t  return false;\n \t\t}\n-\t      return false;\n \t    }\n-\t}\n-    }\n+\t} /* stmts in bb */\n+    } /* bbs */\n \n   /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n \n+  /* All operations in the loop are either irrelevant (deal with loop\n+     control, or dead), or only used outside the loop and can be moved\n+     out of the loop (e.g. invariants, inductions).  The loop can be \n+     optimized away by scalar optimizations.  We're better off not \n+     touching this loop.  */\n+  if (!need_to_vectorize)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \n+\t\t \"All the computation can be taken out of the loop.\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \n+\t\t \"not vectorized: redundant loop. no profit to vectorize.\");\n+      return false;\n+    }\n+\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     fprintf (vect_dump,\n@@ -601,40 +667,43 @@ exist_non_indexing_operands_for_use_p (tree use, tree stmt)\n /* Function vect_analyze_scalar_cycles.\n \n    Examine the cross iteration def-use cycles of scalar variables, by\n-   analyzing the loop (scalar) PHIs; verify that the cross iteration def-use\n-   cycles that they represent do not impede vectorization.\n+   analyzing the loop (scalar) PHIs; Classify each cycle as one of the\n+   following: invariant, induction, reduction, unknown.\n+   \n+   Some forms of scalar cycles are not yet supported.\n+\n+   Example1: reduction: (unsupported yet)\n \n-   FORNOW: Reduction as in the following loop, is not supported yet:\n               loop1:\n               for (i=0; i<N; i++)\n                  sum += a[i];\n-\t   The cross-iteration cycle corresponding to variable 'sum' will be\n-\t   considered too complicated and will impede vectorization.\n \n-   FORNOW: Induction as in the following loop, is not supported yet:\n+   Example2: induction: (unsupported yet)\n+\n               loop2:\n               for (i=0; i<N; i++)\n                  a[i] = i;\n \n-           However, the following loop *is* vectorizable:\n+   Note: the following loop *is* vectorizable:\n+\n               loop3:\n               for (i=0; i<N; i++)\n                  a[i] = b[i];\n \n-           In both loops there exists a def-use cycle for the variable i:\n+         even though it has a def-use cycle caused by the induction variable i:\n+\n               loop: i_2 = PHI (i_0, i_1)\n                     a[i_2] = ...;\n                     i_1 = i_2 + 1;\n                     GOTO loop;\n \n-           The evolution of the above cycle is considered simple enough,\n-\t   however, we also check that the cycle does not need to be\n-\t   vectorized, i.e - we check that the variable that this cycle\n-\t   defines is only used for array indexing or in stmts that do not\n-\t   need to be vectorized. This is not the case in loop2, but it\n-\t   *is* the case in loop3.  */\n+         because the def-use cycle in loop3 is considered \"not relevant\" - i.e.,\n+         it does not need to be vectorized because it is only used for array\n+         indexing (see 'mark_stmts_to_be_vectorized'). The def-use cycle in\n+         loop2 on the other hand is relevant (it is being written to memory).\n+*/\n \n-static bool\n+static void\n vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n {\n   tree phi;\n@@ -648,6 +717,9 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree access_fn = NULL;\n+      tree def = PHI_RESULT (phi);\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n+      tree reduc_stmt;\n \n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n@@ -658,35 +730,21 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n       /* Skip virtual phi's. The data dependences that are associated with\n          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n \n-      if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n+      if (!is_gimple_reg (SSA_NAME_VAR (def)))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    fprintf (vect_dump, \"virtual phi. skip.\");\n \t  continue;\n \t}\n \n-      /* Analyze the evolution function.  */\n-\n-      /* FORNOW: The only scalar cross-iteration cycles that we allow are\n-         those of loop induction variables; This property is verified here.\n+      STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_unknown_def_type;\n \n-         Furthermore, if that induction variable is used in an operation\n-         that needs to be vectorized (i.e, is not solely used to index\n-         arrays and check the exit condition) - we do not support its\n-         vectorization yet. This property is verified in vect_is_simple_use,\n-         during vect_analyze_operations.  */\n+      /* Analyze the evolution function.  */\n \n-      access_fn = /* instantiate_parameters\n-\t\t     (loop,*/\n-\t analyze_scalar_evolution (loop, PHI_RESULT (phi));\n+      access_fn = analyze_scalar_evolution (loop, def);\n \n       if (!access_fn)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n-\t    fprintf (vect_dump, \"not vectorized: unsupported scalar cycle.\");\n-\t  return false;\n-\t}\n+\tcontinue;\n \n       if (vect_print_dump_info (REPORT_DETAILS,\n \t\t\t\tLOOP_LOC (loop_vinfo)))\n@@ -695,16 +753,32 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n            print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n         }\n \n-      if (!vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, &dummy))\n+      if (vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, &dummy))\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n-\t    fprintf (vect_dump, \"not vectorized: unsupported scalar cycle.\");\n-\t  return false;\n+\t  if (vect_print_dump_info (REPORT_DETAILS,LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"Detected induction.\");\n+\t  STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_induction_def;\n+          continue;\n \t}\n+\n+      /* TODO: handle invariant phis  */\n+\n+      reduc_stmt = vect_is_simple_reduction (loop, phi);\n+      if (reduc_stmt)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+            fprintf (vect_dump, \"Detected reduction.\");\n+          STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n+          STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n+                                                        vect_reduction_def;\n+        }\n+      else\n+        if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+          fprintf (vect_dump, \"Unknown def-use cycle pattern.\");\n+\n     }\n \n-  return true;\n+  return;\n }\n \n \n@@ -2049,39 +2123,32 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n    Mark STMT as \"relevant for vectorization\" and add it to WORKLIST.  */\n \n static void\n-vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt)\n+vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n+\t\t    bool relevant_p, bool live_p)\n {\n-  stmt_vec_info stmt_info;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  bool save_relevant_p = STMT_VINFO_RELEVANT_P (stmt_info);\n+  bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n \n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-    fprintf (vect_dump, \"mark relevant.\");\n+    fprintf (vect_dump, \"mark relevant %d, live %d.\",relevant_p, live_p);\n \n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    {\n-      VEC_safe_push (tree, heap, *worklist, stmt);\n-      return;\n-    }\n+  STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n \n-  stmt_info = vinfo_for_stmt (stmt);\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    /* Don't mark as relevant because it's not going to vectorized.  */\n+    return;\n \n-  if (!stmt_info)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t{\n-\t  fprintf (vect_dump, \"mark relevant: no stmt info!!.\");\n-\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t}\n-      return;\n-    }\n+  STMT_VINFO_RELEVANT_P (stmt_info) |= relevant_p;\n \n-  if (STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (STMT_VINFO_RELEVANT_P (stmt_info) == save_relevant_p\n+      && STMT_VINFO_LIVE_P (stmt_info) == save_live_p)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-        fprintf (vect_dump, \"already marked relevant.\");\n+        fprintf (vect_dump, \"already marked relevant/live.\");\n       return;\n     }\n \n-  STMT_VINFO_RELEVANT_P (stmt_info) = 1;\n   VEC_safe_push (tree, heap, *worklist, stmt);\n }\n \n@@ -2099,25 +2166,29 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt)\n    CHECKME: what other side effects would the vectorizer allow?  */\n \n static bool\n-vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n+vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n+\t\t      bool *relevant_p, bool *live_p)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   ssa_op_iter op_iter;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n   def_operand_p def_p;\n \n+  *relevant_p = false;\n+  *live_p = false;\n+\n   /* cond stmt other than loop exit cond.  */\n   if (is_ctrl_stmt (stmt) && (stmt != LOOP_VINFO_EXIT_COND (loop_vinfo)))\n-    return true;\n+    *relevant_p = true;\n \n   /* changing memory.  */\n   if (TREE_CODE (stmt) != PHI_NODE)\n     if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n       {\n \tif (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t  fprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n-\treturn true;\n+\t*relevant_p = true;\n       }\n \n   /* uses outside the loop.  */\n@@ -2130,12 +2201,18 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n \t    {\n \t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t\tfprintf (vect_dump, \"vec_stmt_relevant_p: used out of loop.\");\n-\t      return true;\n+\n+\t      /* We expect all such uses to be in the loop exit phis\n+\t\t (because of loop closed form)   */\n+\t      gcc_assert (TREE_CODE (USE_STMT (use_p)) == PHI_NODE);\n+\t      gcc_assert (bb == loop->single_exit->dest);\n+\n+              *live_p = true;\n \t    }\n \t}\n     }\n \n-  return false;\n+  return (*live_p || *relevant_p);\n }\n \n \n@@ -2164,16 +2241,23 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   unsigned int nbbs = loop->num_nodes;\n   block_stmt_iterator si;\n   tree stmt, use;\n+  stmt_ann_t ann;\n   ssa_op_iter iter;\n   unsigned int i;\n-  int j;\n-  stmt_vec_info stmt_info;\n+  stmt_vec_info stmt_vinfo;\n   basic_block bb;\n   tree phi;\n+  bool relevant_p, live_p;\n+  tree def, def_stmt;\n+  enum vect_def_type dt;\n \n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     fprintf (vect_dump, \"=== vect_mark_stmts_to_be_vectorized ===\");\n \n+  worklist = VEC_alloc (tree, heap, 64);\n+\n+  /* 1. Init worklist.  */\n+\n   bb = loop->header;\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n@@ -2183,19 +2267,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n           print_generic_expr (vect_dump, phi, TDF_SLIM);\n         }\n \n-      if (vect_stmt_relevant_p (phi, loop_vinfo))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t    LOOP_LOC (loop_vinfo)))\n-\t    fprintf (vect_dump, \"unsupported reduction/induction.\");\n-          return false;\n-\t}\n+      if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant_p, &live_p))\n+\tvect_mark_relevant (&worklist, phi, relevant_p, live_p);\n     }\n \n-  worklist = VEC_alloc (tree, heap, 64);\n-\n-  /* 1. Init worklist.  */\n-\n   for (i = 0; i < nbbs; i++)\n     {\n       bb = bbs[i];\n@@ -2209,11 +2284,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t    } \n \n-\t  stmt_info = vinfo_for_stmt (stmt);\n-\t  STMT_VINFO_RELEVANT_P (stmt_info) = 0;\n-\n-\t  if (vect_stmt_relevant_p (stmt, loop_vinfo))\n-\t    vect_mark_relevant (&worklist, stmt);\n+\t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant_p, &live_p))\n+            vect_mark_relevant (&worklist, stmt, relevant_p, live_p);\n \t}\n     }\n \n@@ -2230,61 +2302,65 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n           print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t}\n \n-      /* Examine the USES in this statement. Mark all the statements which\n-         feed this statement's uses as \"relevant\", unless the USE is used as\n-         an array index.  */\n+      /* Examine the USEs of STMT. For each ssa-name USE thta is defined\n+         in the loop, mark the stmt that defines it (DEF_STMT) as\n+         relevant/irrelevant and live/dead according to the liveness and\n+         relevance properties of STMT.\n+       */\n \n-      if (TREE_CODE (stmt) == PHI_NODE)\n-\t{\n-\t  /* follow the def-use chain inside the loop.  */\n-\t  for (j = 0; j < PHI_NUM_ARGS (stmt); j++)\n-\t    {\n-\t      tree arg = PHI_ARG_DEF (stmt, j);\n-\t      tree def_stmt = NULL_TREE;\n-\t      basic_block bb;\n-\t      if (!vect_is_simple_use (arg, loop_vinfo, &def_stmt))\n-\t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n-\t\t    fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n-\t\t  VEC_free (tree, heap, worklist);\n-\t\t  return false;\n-\t\t}\n-\t      if (!def_stmt)\n-\t\tcontinue;\n+      gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n \n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t        {\n-\t          fprintf (vect_dump, \"worklist: def_stmt: \");\n-\t\t  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n-\t\t}\n+      ann = stmt_ann (stmt);\n+      stmt_vinfo = vinfo_for_stmt (stmt);\n \n-\t      bb = bb_for_stmt (def_stmt);\n-\t      if (flow_bb_inside_loop_p (loop, bb))\n-\t        vect_mark_relevant (&worklist, def_stmt);\n-\t    }\n-\t} \n+      relevant_p = STMT_VINFO_RELEVANT_P (stmt_vinfo);\n+      live_p = STMT_VINFO_LIVE_P (stmt_vinfo);\n+\n+      /* Generally, the liveness and relevance properties of STMT are\n+         propagated to the DEF_STMTs of its USEs:\n+             STMT_VINFO_LIVE_P (DEF_STMT_info) <-- live_p\n+             STMT_VINFO_RELEVANT_P (DEF_STMT_info) <-- relevant_p\n+\n+         Exceptions:\n+\n+         - if USE is used only for address computations (e.g. array indexing),\n+           which does not need to be directly vectorized, then the\n+           liveness/relevance of the respective DEF_STMT is left unchanged.\n+\n+         - if STMT has been identified as defining a reduction variable, then:\n+             STMT_VINFO_LIVE_P (DEF_STMT_info) <-- false\n+             STMT_VINFO_RELEVANT_P (DEF_STMT_info) <-- true\n+           because even though STMT is classified as live (since it defines a\n+           value that is used across loop iterations) and irrelevant (since it\n+           is not used inside the loop), it will be vectorized, and therefore\n+           the corresponding DEF_STMTs need to marked as relevant.\n+       */\n+\n+      if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n+        {\n+          gcc_assert (!relevant_p && live_p);\n+          relevant_p = true;\n+          live_p = false;\n+        }\n \n       FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n \t{\n-\n \t  /* We are only interested in uses that need to be vectorized. Uses \n \t     that are used for address computation are not considered relevant.\n \t   */\n \t  if (exist_non_indexing_operands_for_use_p (use, stmt))\n \t    {\n-              tree def_stmt = NULL_TREE;\n-              basic_block bb;\n-              if (!vect_is_simple_use (use, loop_vinfo, &def_stmt))\n+\t      if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n                 {\n                   if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n \t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n-                    fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n+                    fprintf (vect_dump, \n+\t\t\t     \"not vectorized: unsupported use in stmt.\");\n \t\t  VEC_free (tree, heap, worklist);\n                   return false;\n                 }\n \n-\t      if (!def_stmt)\n+\t      if (!def_stmt || IS_EMPTY_STMT (def_stmt))\n \t\tcontinue;\n \n               if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n@@ -2294,8 +2370,16 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n                 }\n \n \t      bb = bb_for_stmt (def_stmt);\n-\t      if (flow_bb_inside_loop_p (loop, bb))\n-\t\tvect_mark_relevant (&worklist, def_stmt);\n+              if (!flow_bb_inside_loop_p (loop, bb))\n+                continue;\n+\n+              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+                {\n+                  fprintf (vect_dump, \"def_stmt: \");\n+                  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n+                }\n+\n+              vect_mark_relevant (&worklist, def_stmt, relevant_p, live_p);\n \t    }\n \t}\n     }\t\t\t\t/* while worklist */\n@@ -2323,6 +2407,9 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n   /* Analyze phi functions of the loop header.  */\n \n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_can_advance_ivs_p ===\");\n+\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree access_fn = NULL;\n@@ -2365,7 +2452,11 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n       evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n       \n       if (evolution_part == NULL_TREE)\n-\treturn false;\n+        {\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"No evolution.\");\n+\t  return false;\n+        }\n   \n       /* FORNOW: We do not transform initial conditions of IVs \n \t which evolution functions are a polynomial of degree >= 2.  */\n@@ -2582,6 +2673,11 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n+  /* Classify all cross-iteration scalar data-flow cycles.\n+     Cross-iteration cycles caused by virtual phis are analyzed separately.  */\n+\n+  vect_analyze_scalar_cycles (loop_vinfo);\n+\n   /* Data-flow analysis to detect stmts that do not need to be vectorized.  */\n \n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);\n@@ -2593,18 +2689,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-  /* Check that all cross-iteration scalar data-flow cycles are OK.\n-     Cross-iteration cycles caused by virtual phis are analyzed separately.  */\n-\n-  ok = vect_analyze_scalar_cycles (loop_vinfo);\n-  if (!ok)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n-\tfprintf (vect_dump, \"bad scalar cycle.\");\n-      destroy_loop_vec_info (loop_vinfo);\n-      return NULL;\n-    }\n-\n   ok = vect_determine_vectorization_factor (loop_vinfo);\n   if (!ok)\n     {"}, {"sha": "f5724dbbd773bf5d8aa076c955ebf0931f72ea86", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 233, "deletions": 131, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -145,7 +145,7 @@ vect_create_index_for_vector_ref (loop_vec_info loop_vinfo)\n   create_iv (init, step, NULL_TREE, loop, &incr_bsi, insert_after,\n \t&indx_before_incr, &indx_after_incr);\n   incr = bsi_stmt (incr_bsi);\n-  set_stmt_info (stmt_ann (incr), new_stmt_vec_info (incr, loop_vinfo));\n+  set_stmt_info ((tree_ann_t)stmt_ann (incr), new_stmt_vec_info (incr, loop_vinfo));\n \n   return indx_before_incr;\n }\n@@ -512,116 +512,94 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block bb;\n   tree vec_inv;\n+  tree vec_cst;\n   tree t = NULL_TREE;\n   tree def;\n   int i;\n+  enum vect_def_type dt;\n+  bool is_simple_use;\n \n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n       fprintf (vect_dump, \"vect_get_vec_def_for_operand: \");\n       print_generic_expr (vect_dump, op, TDF_SLIM);\n     }\n \n-  /** ===> Case 1: operand is a constant.  **/\n-\n-  if (TREE_CODE (op) == INTEGER_CST || TREE_CODE (op) == REAL_CST)\n+  is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt);\n+  gcc_assert (is_simple_use);\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n-\n-      tree vec_cst;\n-\n-      /* Build a tree with vector elements.  */\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-        fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n-\n-      for (i = nunits - 1; i >= 0; --i)\n+      if (def)\n         {\n-          t = tree_cons (NULL_TREE, op, t);\n+          fprintf (vect_dump, \"def =  \");\n+          print_generic_expr (vect_dump, def, TDF_SLIM);\n+        }\n+      if (def_stmt)\n+        {\n+          fprintf (vect_dump, \"  def_stmt =  \");\n+          print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n         }\n-      vec_cst = build_vector (vectype, t);\n-      return vect_init_vector (stmt, vec_cst);\n-    }\n-\n-  gcc_assert (TREE_CODE (op) == SSA_NAME);\n- \n-  /** ===> Case 2: operand is an SSA_NAME - find the stmt that defines it.  **/\n-\n-  def_stmt = SSA_NAME_DEF_STMT (op);\n-  def_stmt_info = vinfo_for_stmt (def_stmt);\n-\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-    {\n-      fprintf (vect_dump, \"vect_get_vec_def_for_operand: def_stmt: \");\n-      print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n-    }\n-\n-\n-  /** ==> Case 2.1: operand is defined inside the loop.  **/\n-\n-  if (def_stmt_info)\n-    {\n-      /* Get the def from the vectorized stmt.  */\n-\n-      vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n-      gcc_assert (vec_stmt);\n-      vec_oprnd = TREE_OPERAND (vec_stmt, 0);\n-      return vec_oprnd;\n     }\n \n+  /* FORNOW */\n+  gcc_assert (dt != vect_reduction_def);\n \n-  /** ==> Case 2.2: operand is defined by the loop-header phi-node - \n-                    it is a reduction/induction.  **/\n-\n-  bb = bb_for_stmt (def_stmt);\n-  if (TREE_CODE (def_stmt) == PHI_NODE && flow_bb_inside_loop_p (loop, bb))\n+  switch (dt)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\tfprintf (vect_dump, \"reduction/induction - unsupported.\");\n-      internal_error (\"no support for reduction/induction\"); /* FORNOW */\n-    }\n-\n+    /* Case 1: operand is a constant.  */\n+    case vect_constant_def:\n+      {\n+        /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n+        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n+\n+        for (i = nunits - 1; i >= 0; --i)\n+          {\n+            t = tree_cons (NULL_TREE, op, t);\n+          }\n+        vec_cst = build_vector (vectype, t);\n+        return vect_init_vector (stmt, vec_cst);\n+      }\n+\n+    /* Case 2: operand is defined outside the loop - loop invariant.  */\n+    case vect_invariant_def:\n+      {\n+        /* Create 'vec_inv = {inv,inv,..,inv}'  */\n+        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          fprintf (vect_dump, \"Create vector_inv.\");\n+\n+        for (i = nunits - 1; i >= 0; --i)\n+          {\n+            t = tree_cons (NULL_TREE, def, t);\n+          }\n+\n+        vec_inv = build_constructor (vectype, t);\n+        return vect_init_vector (stmt, vec_inv);\n+      }\n+\n+    /* Case 3: operand is defined inside the loop.  */\n+    case vect_loop_def:\n+      {\n+        /* Get the def from the vectorized stmt.  */\n+        def_stmt_info = vinfo_for_stmt (def_stmt);\n+        vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n+        gcc_assert (vec_stmt);\n+        vec_oprnd = TREE_OPERAND (vec_stmt, 0);\n+        return vec_oprnd;\n+      }\n+\n+    /* Case 4: operand is defined by loop-header phi - induction.  */\n+    case vect_induction_def:\n+      {\n+        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+          fprintf (vect_dump, \"induction - unsupported.\");\n+        internal_error (\"no support for induction\"); /* FORNOW */\n+      }\n \n-  /** ==> Case 2.3: operand is defined outside the loop - \n-                    it is a loop invariant.  */\n-\n-  switch (TREE_CODE (def_stmt))\n-    {\n-    case PHI_NODE:\n-      def = PHI_RESULT (def_stmt);\n-      break;\n-    case MODIFY_EXPR:\n-      def = TREE_OPERAND (def_stmt, 0);\n-      break;\n-    case NOP_EXPR:\n-      def = TREE_OPERAND (def_stmt, 0);\n-      gcc_assert (IS_EMPTY_STMT (def_stmt));\n-      def = op;\n-      break;\n     default:\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t{\n-          fprintf (vect_dump, \"unsupported defining stmt: \");\n-\t  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n-\t}\n-      internal_error (\"unsupported defining stmt\");\n-    }\n-\n-  /* Build a tree with vector elements.\n-     Create 'vec_inv = {inv,inv,..,inv}'  */\n-\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-    fprintf (vect_dump, \"Create vector_inv.\");\n-\n-  for (i = nunits - 1; i >= 0; --i)\n-    {\n-      t = tree_cons (NULL_TREE, def, t);\n+      gcc_unreachable ();\n     }\n-\n-  vec_inv = build_constructor (vectype, t);\n-  return vect_init_vector (stmt, vec_inv);\n }\n \n \n@@ -671,8 +649,14 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n+  tree def, def_stmt;\n+  enum vect_def_type dt;\n \n   /* Is vectorizable assignment?  */\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n \n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n@@ -682,7 +666,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     return false;\n \n   op = TREE_OPERAND (stmt, 1);\n-  if (!vect_is_simple_use (op, loop_vinfo, NULL))\n+  if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -742,6 +726,7 @@ vect_min_worthwhile_factor (enum tree_code code)\n     }\n }\n \n+\n /* Function vectorizable_operation.\n \n    Check if STMT performs a binary or unary operation that can be vectorized. \n@@ -767,8 +752,23 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   int op_type;\n   tree op;\n   optab optab;\n+  tree def, def_stmt;\n+  enum vect_def_type dt;\n \n   /* Is STMT a vectorizable binary/unary operation?   */\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+\n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n \n@@ -791,7 +791,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   for (i = 0; i < op_type; i++)\n     {\n       op = TREE_OPERAND (operation, i);\n-      if (!vect_is_simple_use (op, loop_vinfo, NULL))\n+      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -892,8 +892,9 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n-  tree def;\n   ssa_op_iter iter;\n+  tree def, def_stmt;\n+  enum vect_def_type dt;\n \n   /* Is vectorizable store? */\n \n@@ -906,7 +907,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     return false;\n \n   op = TREE_OPERAND (stmt, 1);\n-  if (!vect_is_simple_use (op, loop_vinfo, NULL))\n+  if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -1001,6 +1002,18 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum dr_alignment_support alignment_support_cheme;\n \n   /* Is vectorizable load? */\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n \n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n@@ -1180,6 +1193,64 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   return true;\n }\n \n+\n+/* Function vectorizable_live_operation.\n+\n+   STMT computes a value that is used outside the loop. Check if \n+   it can be supported.  */\n+\n+bool\n+vectorizable_live_operation (tree stmt,\n+                             block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n+                             tree *vec_stmt ATTRIBUTE_UNUSED)\n+{\n+  tree operation;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  int i;\n+  enum tree_code code;\n+  int op_type;\n+  tree op;\n+  tree def, def_stmt;\n+  enum vect_def_type dt; \n+\n+  if (!STMT_VINFO_LIVE_P (stmt_info))\n+    return false;\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+    return false;\n+\n+  operation = TREE_OPERAND (stmt, 1);\n+  code = TREE_CODE (operation);\n+\n+  op_type = TREE_CODE_LENGTH (code);\n+\n+  /* FORNOW: support only if all uses are invariant. This means\n+     that the scalar operations can remain in place, unvectorized.\n+     The original last scalar value that they compute will be used.  */\n+\n+  for (i = 0; i < op_type; i++)\n+    {\n+      op = TREE_OPERAND (operation, i);\n+      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            fprintf (vect_dump, \"use not simple.\");\n+          return false;\n+        }\n+\n+      if (dt != vect_invariant_def && dt != vect_constant_def)\n+        return false;\n+    }\n+\n+  /* No transformation is required for the cases we currently support.  */\n+  return true;\n+}\n+\n+\n /* Function vect_is_simple_cond.\n   \n    Input:\n@@ -1193,6 +1264,8 @@ static bool\n vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n {\n   tree lhs, rhs;\n+  tree def;\n+  enum vect_def_type dt;\n \n   if (!COMPARISON_CLASS_P (cond))\n     return false;\n@@ -1203,7 +1276,7 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       tree lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use (lhs, loop_vinfo, &lhs_def_stmt))\n+      if (!vect_is_simple_use (lhs, loop_vinfo, &lhs_def_stmt, &def, &dt))\n \treturn false;\n     }\n   else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST)\n@@ -1212,7 +1285,7 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       tree rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use (rhs, loop_vinfo, &rhs_def_stmt))\n+      if (!vect_is_simple_use (rhs, loop_vinfo, &rhs_def_stmt, &def, &dt))\n \treturn false;\n     }\n   else if (TREE_CODE (rhs) != INTEGER_CST  && TREE_CODE (rhs) != REAL_CST)\n@@ -1244,10 +1317,22 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree new_temp;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum machine_mode vec_mode;\n+  tree def;\n+  enum vect_def_type dt;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+\n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n \n@@ -1266,7 +1351,8 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (TREE_CODE (then_clause) == SSA_NAME)\n     {\n       tree then_def_stmt = SSA_NAME_DEF_STMT (then_clause);\n-      if (!vect_is_simple_use (then_clause, loop_vinfo, &then_def_stmt))\n+      if (!vect_is_simple_use (then_clause, loop_vinfo, \n+\t\t\t       &then_def_stmt, &def, &dt))\n \treturn false;\n     }\n   else if (TREE_CODE (then_clause) != INTEGER_CST \n@@ -1276,7 +1362,8 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (TREE_CODE (else_clause) == SSA_NAME)\n     {\n       tree else_def_stmt = SSA_NAME_DEF_STMT (else_clause);\n-      if (!vect_is_simple_use (else_clause, loop_vinfo, &else_def_stmt))\n+      if (!vect_is_simple_use (else_clause, loop_vinfo, \n+\t\t\t       &else_def_stmt, &def, &dt))\n \treturn false;\n     }\n   else if (TREE_CODE (else_clause) != INTEGER_CST \n@@ -1332,43 +1419,52 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   bool done;\n \n-  switch (STMT_VINFO_TYPE (stmt_info))\n+  if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n-    case op_vec_info_type:\n-      done = vectorizable_operation (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      break;\n-\n-    case assignment_vec_info_type:\n-      done = vectorizable_assignment (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      break;\n-\n-    case load_vec_info_type:\n-      done = vectorizable_load (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      break;\n-\n-    case store_vec_info_type:\n-      done = vectorizable_store (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      is_store = true;\n-      break;\n+      switch (STMT_VINFO_TYPE (stmt_info))\n+      {\n+      case op_vec_info_type:\n+\tdone = vectorizable_operation (stmt, bsi, &vec_stmt);\n+\tgcc_assert (done);\n+\tbreak;\n+\n+      case assignment_vec_info_type:\n+\tdone = vectorizable_assignment (stmt, bsi, &vec_stmt);\n+\tgcc_assert (done);\n+\tbreak;\n+\n+      case load_vec_info_type:\n+\tdone = vectorizable_load (stmt, bsi, &vec_stmt);\n+\tgcc_assert (done);\n+\tbreak;\n+\n+      case store_vec_info_type:\n+\tdone = vectorizable_store (stmt, bsi, &vec_stmt);\n+\tgcc_assert (done);\n+\tis_store = true;\n+\tbreak;\n+\n+      case condition_vec_info_type:\n+\tdone = vectorizable_condition (stmt, bsi, &vec_stmt);\n+\tgcc_assert (done);\n+\tbreak;\n+\n+      default:\n+\tif (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  fprintf (vect_dump, \"stmt not supported.\");\n+\tgcc_unreachable ();\n+      }\n+\n+      STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+    }\n \n-    case condition_vec_info_type:\n-      done = vectorizable_condition (stmt, bsi, &vec_stmt);\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      done = vectorizable_live_operation (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n-      break;\n-\n-    default:\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-        fprintf (vect_dump, \"stmt not supported.\");\n-      gcc_unreachable ();\n     }\n \n-  STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n-\n-  return is_store;\n+  return is_store; \n }\n \n \n@@ -1607,6 +1703,12 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       tree var, stmt, ni, ni_name;\n       block_stmt_iterator last_bsi;\n \n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"vect_update_ivs_after_vectorizer: phi: \");\n+          print_generic_expr (vect_dump, phi, TDF_SLIM);\n+        }\n+\n       /* Skip virtual phi's.  */\n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n@@ -2021,7 +2123,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t      /* Free the attached stmt_vec_info and remove the stmt.  */\n \t      stmt_ann_t ann = stmt_ann (stmt);\n \t      free (stmt_info);\n-\t      set_stmt_info (ann, NULL);\n+\t      set_stmt_info ((tree_ann_t)ann, NULL);\n \t      bsi_remove (&si);\n \t      continue;\n \t    }"}, {"sha": "53f5358194e5590a99790d3065f7d31236565eab", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 144, "deletions": 34, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -1338,9 +1338,14 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_STMT (res) = stmt;\n   STMT_VINFO_LOOP_VINFO (res) = loop_vinfo;\n   STMT_VINFO_RELEVANT_P (res) = 0;\n+  STMT_VINFO_LIVE_P (res) = 0;\n   STMT_VINFO_VECTYPE (res) = NULL;\n   STMT_VINFO_VEC_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;\n+  else\n+    STMT_VINFO_DEF_TYPE (res) = vect_loop_def;\n   STMT_VINFO_MEMTAG (res) = NULL;\n   STMT_VINFO_PTR_INFO (res) = NULL;\n   STMT_VINFO_SUBVARS (res) = NULL;\n@@ -1375,13 +1380,21 @@ new_loop_vec_info (struct loop *loop)\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = bbs[i];\n+      tree phi;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+        {\n+          tree_ann_t ann = get_tree_ann (phi);\n+          set_stmt_info (ann, new_stmt_vec_info (phi, res));\n+        }\n+\n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  tree stmt = bsi_stmt (si);\n \t  stmt_ann_t ann;\n \n \t  ann = stmt_ann (stmt);\n-\t  set_stmt_info (ann, new_stmt_vec_info (stmt, res));\n+\t  set_stmt_info ((tree_ann_t)ann, new_stmt_vec_info (stmt, res));\n \t}\n     }\n \n@@ -1428,13 +1441,26 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n   for (j = 0; j < nbbs; j++)\n     {\n       basic_block bb = bbs[j];\n+      tree phi;\n+      stmt_vec_info stmt_info;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+        {\n+          tree_ann_t ann = get_tree_ann (phi);\n+\n+          stmt_info = vinfo_for_stmt (phi);\n+          free (stmt_info);\n+          set_stmt_info (ann, NULL);\n+        }\n+\n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  tree stmt = bsi_stmt (si);\n \t  stmt_ann_t ann = stmt_ann (stmt);\n+\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \t  free (stmt_info);\n-\t  set_stmt_info (ann, NULL);\n+\t  set_stmt_info ((tree_ann_t)ann, NULL);\n \t}\n     }\n \n@@ -1596,64 +1622,148 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n    in reduction/induction computations).  */\n \n bool\n-vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n+vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n+\t\t    tree *def, enum vect_def_type *dt)\n { \n-  tree def_stmt;\n   basic_block bb;\n+  stmt_vec_info stmt_vinfo;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n-  if (def)\n-    *def = NULL_TREE;\n-\n+  *def_stmt = NULL_TREE;\n+  *def = NULL_TREE;\n+  \n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    {\n+      fprintf (vect_dump, \"vect_is_simple_use: operand \");\n+      print_generic_expr (vect_dump, operand, TDF_SLIM);\n+    }\n+    \n   if (TREE_CODE (operand) == INTEGER_CST || TREE_CODE (operand) == REAL_CST)\n-    return true;\n-\n+    {\n+      *dt = vect_constant_def;\n+      return true;\n+    }\n+    \n   if (TREE_CODE (operand) != SSA_NAME)\n-    return false;\n-\n-  def_stmt = SSA_NAME_DEF_STMT (operand);\n-  if (def_stmt == NULL_TREE )\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"not ssa-name.\");\n+      return false;\n+    }\n+    \n+  *def_stmt = SSA_NAME_DEF_STMT (operand);\n+  if (*def_stmt == NULL_TREE )\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         fprintf (vect_dump, \"no def_stmt.\");\n       return false;\n     }\n \n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    {\n+      fprintf (vect_dump, \"def_stmt: \");\n+      print_generic_expr (vect_dump, *def_stmt, TDF_SLIM);\n+    }\n+\n   /* empty stmt is expected only in case of a function argument.\n      (Otherwise - we expect a phi_node or a modify_expr).  */\n-  if (IS_EMPTY_STMT (def_stmt))\n+  if (IS_EMPTY_STMT (*def_stmt))\n     {\n-      tree arg = TREE_OPERAND (def_stmt, 0);\n+      tree arg = TREE_OPERAND (*def_stmt, 0);\n       if (TREE_CODE (arg) == INTEGER_CST || TREE_CODE (arg) == REAL_CST)\n-\treturn true;\n+        {\n+          *def = operand;\n+          *dt = vect_invariant_def;\n+          return true;\n+        }\n+\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t{\n-\t  fprintf (vect_dump, \"Unexpected empty stmt: \");\n-\t  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n-\t}\n-      return false;  \n+        fprintf (vect_dump, \"Unexpected empty stmt.\");\n+      return false;\n     }\n \n-  /* phi_node inside the loop indicates an induction/reduction pattern.\n-     This is not supported yet.  */\n-  bb = bb_for_stmt (def_stmt);\n-  if (TREE_CODE (def_stmt) == PHI_NODE && flow_bb_inside_loop_p (loop, bb))\n+  bb = bb_for_stmt (*def_stmt);\n+  if (!flow_bb_inside_loop_p (loop, bb))\n+    *dt = vect_invariant_def;\n+  else\n+    {\n+      stmt_vinfo = vinfo_for_stmt (*def_stmt);\n+      *dt = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n+    }\n+\n+  if (*dt == vect_unknown_def_type)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\tfprintf (vect_dump, \"reduction/induction - unsupported.\");\n-      return false; /* FORNOW: not supported yet.  */\n+        fprintf (vect_dump, \"Unsupported pattern.\");\n+      return false;\n     }\n \n-  /* Expecting a modify_expr or a phi_node.  */\n-  if (TREE_CODE (def_stmt) == MODIFY_EXPR\n-      || TREE_CODE (def_stmt) == PHI_NODE)\n+  /* stmts inside the loop that have been identified as performing\n+     a reduction operation cannot have uses in the loop.  */\n+  if (*dt == vect_reduction_def && TREE_CODE (*def_stmt) != PHI_NODE)\n     {\n-      if (def)\n-        *def = def_stmt; \t\n-      return true;\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"reduction used in loop.\");\n+      return false;\n+    }\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"type of def: %d.\",*dt);\n+\n+  switch (TREE_CODE (*def_stmt))\n+    {\n+    case PHI_NODE:\n+      *def = PHI_RESULT (*def_stmt);\n+      gcc_assert (*dt == vect_induction_def || *dt == vect_reduction_def\n+                  || *dt == vect_invariant_def);\n+      break;\n+\n+    case MODIFY_EXPR:\n+      *def = TREE_OPERAND (*def_stmt, 0);\n+      gcc_assert (*dt == vect_loop_def || *dt == vect_invariant_def);\n+      break;\n+\n+    default:\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"unsupported defining stmt: \");\n+      return false;\n     }\n \n-  return false;\n+  if (*dt == vect_induction_def)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"induction not supported.\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Function vect_is_simple_reduction\n+\n+   TODO:\n+   Detect a cross-iteration def-use cucle that represents a simple\n+   reduction computation. We look for the followng pattern:\n+\n+   loop_header:\n+     a1 = phi < a0, a2 >\n+     a3 = ...\n+     a2 = operation (a3, a1)\n+  \n+   such that:\n+   1. operation is...\n+   2. no uses for a2 in the loop (elsewhere)  */\n+\n+tree\n+vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED, \n+\t\t\t  tree phi ATTRIBUTE_UNUSED)\n+{\n+  /* FORNOW */\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"reduction: unknown pattern.\");\n+\n+  return NULL_TREE;\n }\n \n "}, {"sha": "739da71fea9b98a5ca7f1d7d70b87877c4d165a0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88088c03967bc1ccf78ee8ddd9c0612f565df20a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=88088c03967bc1ccf78ee8ddd9c0612f565df20a", "patch": "@@ -56,6 +56,16 @@ enum dr_alignment_support {\n   dr_aligned\n };\n \n+/* Define type of def-use cross-iteraiton cycle.  */\n+enum vect_def_type {\n+  vect_constant_def,\n+  vect_invariant_def,\n+  vect_loop_def,\n+  vect_induction_def,\n+  vect_reduction_def,\n+  vect_unknown_def_type\n+};\n+\n /* Define verbosity levels.  */\n enum verbosity_levels {\n   REPORT_NONE,\n@@ -163,6 +173,10 @@ typedef struct _stmt_vec_info {\n      indicates whether the stmt needs to be vectorized.  */\n   bool relevant;\n \n+  /* Indicates whether this stmts is part of a computation whose result is\n+     used outside the loop.  */\n+  bool live;\n+\n   /* The vector type to be used.  */\n   tree vectype;\n \n@@ -215,13 +229,18 @@ typedef struct _stmt_vec_info {\n   /* Alignment information. The offset of the data-reference from its base \n      in bytes.  */\n   tree misalignment;\n+\n+  /* Classify the def of this stmt.  */\n+  enum vect_def_type def_type;\n+\n } *stmt_vec_info;\n \n /* Access Functions.  */\n #define STMT_VINFO_TYPE(S)                (S)->type\n #define STMT_VINFO_STMT(S)                (S)->stmt\n #define STMT_VINFO_LOOP_VINFO(S)          (S)->loop_vinfo\n #define STMT_VINFO_RELEVANT_P(S)          (S)->relevant\n+#define STMT_VINFO_LIVE_P(S)              (S)->live\n #define STMT_VINFO_VECTYPE(S)             (S)->vectype\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n #define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n@@ -233,22 +252,23 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VECT_STEP(S)           (S)->step\n #define STMT_VINFO_VECT_BASE_ALIGNED_P(S) (S)->base_aligned_p\n #define STMT_VINFO_VECT_MISALIGNMENT(S)   (S)->misalignment\n+#define STMT_VINFO_DEF_TYPE(S)            (S)->def_type\n \n-static inline void set_stmt_info (stmt_ann_t ann, stmt_vec_info stmt_info);\n+static inline void set_stmt_info (tree_ann_t ann, stmt_vec_info stmt_info);\n static inline stmt_vec_info vinfo_for_stmt (tree stmt);\n \n static inline void\n-set_stmt_info (stmt_ann_t ann, stmt_vec_info stmt_info)\n+set_stmt_info (tree_ann_t ann, stmt_vec_info stmt_info)\n {\n   if (ann)\n-    ann->aux = (char *) stmt_info;\n+    ann->common.aux = (char *) stmt_info;\n }\n \n static inline stmt_vec_info\n vinfo_for_stmt (tree stmt)\n {\n-  stmt_ann_t ann = stmt_ann (stmt);\n-  return ann ? (stmt_vec_info) ann->aux : NULL;\n+  tree_ann_t ann = tree_ann (stmt);\n+  return ann ? (stmt_vec_info) ann->common.aux : NULL;\n }\n \n /*-----------------------------------------------------------------*/\n@@ -309,8 +329,10 @@ extern void slpeel_verify_cfg_after_peeling (struct loop *, struct loop *);\n /** In tree-vectorizer.c **/\n extern tree vect_strip_conversion (tree);\n extern tree get_vectype_for_scalar_type (tree);\n-extern bool vect_is_simple_use (tree , loop_vec_info, tree *);\n+extern bool vect_is_simple_use (tree, loop_vec_info, tree *, tree *,\n+\t\t\t\tenum vect_def_type *);\n extern bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *);\n+extern tree vect_is_simple_reduction (struct loop *, tree);\n extern bool vect_can_force_dr_alignment_p (tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n   (struct data_reference *);\n@@ -331,6 +353,7 @@ extern bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);\n /* Driver for transformation stage.  */\n extern void vect_transform_loop (loop_vec_info, struct loops *);\n "}]}