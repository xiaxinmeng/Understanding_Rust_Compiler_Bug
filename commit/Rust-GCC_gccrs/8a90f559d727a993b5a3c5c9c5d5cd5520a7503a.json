{"sha": "8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE5MGY1NTlkNzI3YTk5M2I1YTNjNWM5YzVkNWNkNTUyMGE3NTAzYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T00:45:55Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T00:45:55Z"}, "message": "compiler: omit a couple of write barriers\n    \n    Omit a write barrier for\n        s = s[0:]\n    for a slice s.  In this case the pointer is not changing and no write\n    barrier is required.\n    \n    Omit a write barrier for\n        s = append(s, v)\n    in the case where len(s) < cap(s) (and similarly when appending more\n    values).  When the slice has enough capacity the pointer is not\n    changing and no write barrier is required.\n    \n    These changes are required to avoid write barriers in the method\n    randomOrder.reset in the runtime package.  That method is called from\n    procresize, at a point where we do not want to allocate memory.\n    Otherwise that method can use a write barrier, allocate memory, and\n    break TestReadMemStats.\n    \n    Reviewed-on: https://go-review.googlesource.com/134219\n\nFrom-SVN: r264259", "tree": {"sha": "f2ea2103f31f5a039dac854bf39c87a5c9daa85d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2ea2103f31f5a039dac854bf39c87a5c9daa85d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/comments", "author": null, "committer": null, "parents": [{"sha": "6201be94cd3da234ea9a6a0b767083328b885488", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6201be94cd3da234ea9a6a0b767083328b885488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6201be94cd3da234ea9a6a0b767083328b885488"}], "stats": {"total": 228, "additions": 204, "deletions": 24}, "files": [{"sha": "1afbcb48b34a5c9904d2282a1284184dcfff4bbc", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "patch": "@@ -1,4 +1,4 @@\n-06e688ff6d829c8de3735e9f59b61b373afc596f\n+acf852f838e6b99f907d84648be853fa2c374393\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "a296777bd543bf5e22fd2de8ecd24a5bc6cbdf93", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 94, "deletions": 11, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "patch": "@@ -131,6 +131,40 @@ Expression::determine_type_no_context()\n   this->do_determine_type(&context);\n }\n \n+// Return true if two expressions refer to the same variable or struct\n+// field.  This can only be true when there are no side effects.\n+\n+bool\n+Expression::is_same_variable(Expression* a, Expression* b)\n+{\n+  if (a->classification() != b->classification())\n+    return false;\n+\n+  Var_expression* av = a->var_expression();\n+  if (av != NULL)\n+    return av->named_object() == b->var_expression()->named_object();\n+\n+  Field_reference_expression* af = a->field_reference_expression();\n+  if (af != NULL)\n+    {\n+      Field_reference_expression* bf = b->field_reference_expression();\n+      return (af->field_index() == bf->field_index()\n+\t      && Expression::is_same_variable(af->expr(), bf->expr()));\n+    }\n+\n+  Unary_expression* au = a->unary_expression();\n+  if (au != NULL)\n+    {\n+      Unary_expression* bu = b->unary_expression();\n+      return (au->op() == OPERATOR_MULT\n+\t      && bu->op() == OPERATOR_MULT\n+\t      && Expression::is_same_variable(au->operand(),\n+\t\t\t\t\t      bu->operand()));\n+    }\n+\n+  return false;\n+}\n+\n // Return an expression handling any conversions which must be done during\n // assignment.\n \n@@ -7421,7 +7455,7 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n       break;\n \n     case BUILTIN_APPEND:\n-      return this->flatten_append(gogo, function, inserter);\n+      return this->flatten_append(gogo, function, inserter, NULL, NULL);\n \n     case BUILTIN_COPY:\n       {\n@@ -7658,11 +7692,18 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n \n // Flatten a call to the predeclared append function.  We do this in\n // the flatten phase, not the lowering phase, so that we run after\n-// type checking and after order_evaluations.\n+// type checking and after order_evaluations.  If ASSIGN_LHS is not\n+// NULL, this append is the right-hand-side of an assignment and\n+// ASSIGN_LHS is the left-hand-side; in that case, set LHS directly\n+// rather than returning a slice.  This lets us omit a write barrier\n+// in common cases like a = append(a, ...) when the slice does not\n+// need to grow.  ENCLOSING is not NULL iff ASSIGN_LHS is not NULL.\n \n Expression*\n Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n-\t\t\t\t\tStatement_inserter* inserter)\n+\t\t\t\t\tStatement_inserter* inserter,\n+\t\t\t\t\tExpression* assign_lhs,\n+\t\t\t\t\tBlock* enclosing)\n {\n   if (this->is_error_expression())\n     return this;\n@@ -7679,6 +7720,8 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n   if (args->size() == 1)\n     {\n       // append(s) evaluates to s.\n+      if (assign_lhs != NULL)\n+\treturn NULL;\n       return args->front();\n     }\n \n@@ -7795,14 +7838,46 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n   // FIXME: Mark this index as not requiring bounds checks.\n   ref = Expression::make_index(ref, zero, ref2, NULL, loc);\n \n-  Expression* rhs = Expression::make_conditional(cond, call, ref, loc);\n+  if (assign_lhs == NULL)\n+    {\n+      Expression* rhs = Expression::make_conditional(cond, call, ref, loc);\n+\n+      gogo->lower_expression(function, inserter, &rhs);\n+      gogo->flatten_expression(function, inserter, &rhs);\n \n-  gogo->lower_expression(function, inserter, &rhs);\n-  gogo->flatten_expression(function, inserter, &rhs);\n+      ref = Expression::make_temporary_reference(s1tmp, loc);\n+      Statement* assign = Statement::make_assignment(ref, rhs, loc);\n+      inserter->insert(assign);\n+    }\n+  else\n+    {\n+      gogo->lower_expression(function, inserter, &cond);\n+      gogo->flatten_expression(function, inserter, &cond);\n+      gogo->lower_expression(function, inserter, &call);\n+      gogo->flatten_expression(function, inserter, &call);\n+      gogo->lower_expression(function, inserter, &ref);\n+      gogo->flatten_expression(function, inserter, &ref);\n \n-  Expression* lhs = Expression::make_temporary_reference(s1tmp, loc);\n-  Statement* assign = Statement::make_assignment(lhs, rhs, loc);\n-  inserter->insert(assign);\n+      Block* then_block = new Block(enclosing, loc);\n+      Assignment_statement* assign =\n+\tStatement::make_assignment(assign_lhs, call, loc);\n+      then_block->add_statement(assign);\n+\n+      Block* else_block = new Block(enclosing, loc);\n+      assign = Statement::make_assignment(assign_lhs->copy(), ref, loc);\n+      // This assignment will not change the pointer value, so it does\n+      // not need a write barrier.\n+      assign->set_omit_write_barrier();\n+      else_block->add_statement(assign);\n+\n+      Statement* s = Statement::make_if_statement(cond, then_block,\n+\t\t\t\t\t\t  else_block, loc);\n+      inserter->insert(s);\n+\n+      ref = Expression::make_temporary_reference(s1tmp, loc);\n+      assign = Statement::make_assignment(ref, assign_lhs->copy(), loc);\n+      inserter->insert(assign);\n+    }\n \n   if (this->is_varargs())\n     {\n@@ -7839,12 +7914,17 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n \t  Expression* off = Expression::make_integer_ul(i, int_type, loc);\n \t  ref2 = Expression::make_binary(OPERATOR_PLUS, ref2, off, loc);\n \t  // FIXME: Mark this index as not requiring bounds checks.\n-\t  lhs = Expression::make_index(ref, ref2, NULL, NULL, loc);\n+\t  Expression* lhs = Expression::make_index(ref, ref2, NULL, NULL,\n+\t\t\t\t\t\t   loc);\n \t  gogo->lower_expression(function, inserter, &lhs);\n \t  gogo->flatten_expression(function, inserter, &lhs);\n \t  // The flatten pass runs after the write barrier pass, so we\n \t  // need to insert a write barrier here if necessary.\n-\t  if (!gogo->assign_needs_write_barrier(lhs))\n+\t  // However, if ASSIGN_LHS is not NULL, we have been called\n+\t  // directly before the write barrier pass.\n+\t  Statement* assign;\n+\t  if (assign_lhs != NULL\n+\t      || !gogo->assign_needs_write_barrier(lhs))\n \t    assign = Statement::make_assignment(lhs, *pa, loc);\n \t  else\n \t    {\n@@ -7856,6 +7936,9 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n \t}\n     }\n \n+  if (assign_lhs != NULL)\n+    return NULL;\n+\n   return Expression::make_temporary_reference(s1tmp, loc);\n }\n "}, {"sha": "f53cc6e62aa45ae2ffc996caa42622f3f0241f1c", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "patch": "@@ -869,6 +869,11 @@ class Expression\n   bool\n   is_local_variable() const;\n \n+  // Return true if two expressions refer to the same variable or\n+  // struct field.\n+  static bool\n+  is_same_variable(Expression*, Expression*);\n+\n   // Make the builtin function descriptor type, so that it can be\n   // converted.\n   static void\n@@ -2402,6 +2407,10 @@ class Builtin_call_expression : public Call_expression\n   static bool\n   array_len_is_constant(Expression* expr);\n \n+  Expression*\n+  flatten_append(Gogo*, Named_object*, Statement_inserter*, Expression*,\n+\t\t Block*);\n+\n  protected:\n   // This overrides Call_expression::do_lower.\n   Expression*\n@@ -2459,8 +2468,6 @@ class Builtin_call_expression : public Call_expression\n   Expression*\n   lower_make(Statement_inserter*);\n \n-  Expression* flatten_append(Gogo*, Named_object*, Statement_inserter*);\n-\n   bool\n   check_int_value(Expression*, bool is_length, bool* small);\n "}, {"sha": "19a07d462baeb19dda3afde9564734f88b587f02", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "patch": "@@ -686,7 +686,7 @@ Assignment_statement::do_traverse_assignments(Traverse_assignments* tassign)\n }\n \n // Lower an assignment to a map index expression to a runtime function\n-// call.\n+// call.  Mark some slice assignments as not requiring a write barrier.\n \n Statement*\n Assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n@@ -750,6 +750,21 @@ Assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n       return Statement::make_block_statement(b, loc);\n     }\n \n+  // An assignment of the form s = s[:n] does not require a write\n+  // barrier, because the pointer value will not change.\n+  Array_index_expression* aie = this->rhs_->array_index_expression();\n+  if (aie != NULL\n+      && aie->end() != NULL\n+      && Expression::is_same_variable(this->lhs_, aie->array()))\n+    {\n+      Numeric_constant nc;\n+      unsigned long ival;\n+      if (aie->start()->numeric_constant_value(&nc)\n+\t  && nc.to_unsigned_long(&ival) == Numeric_constant::NC_UL_VALID\n+\t  && ival == 0)\n+\tthis->omit_write_barrier_ = true;\n+    }\n+\n   return this;\n }\n \n@@ -876,7 +891,7 @@ Assignment_statement::do_dump_statement(Ast_dump_context* ast_dump_context)\n \n // Make an assignment statement.\n \n-Statement*\n+Assignment_statement*\n Statement::make_assignment(Expression* lhs, Expression* rhs,\n \t\t\t   Location location)\n {"}, {"sha": "c9ab4d6fac338d2ef3f66f51dbbc52a170a99c0d", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "patch": "@@ -148,7 +148,7 @@ class Statement\n   make_temporary(Type*, Expression*, Location);\n \n   // Make an assignment statement.\n-  static Statement*\n+  static Assignment_statement*\n   make_assignment(Expression*, Expression*, Location);\n \n   // Make an assignment operation (+=, etc.).\n@@ -562,7 +562,7 @@ class Assignment_statement : public Statement\n   Assignment_statement(Expression* lhs, Expression* rhs,\n \t\t       Location location)\n     : Statement(STATEMENT_ASSIGNMENT, location),\n-      lhs_(lhs), rhs_(rhs)\n+      lhs_(lhs), rhs_(rhs), omit_write_barrier_(false)\n   { }\n \n   Expression*\n@@ -573,6 +573,14 @@ class Assignment_statement : public Statement\n   rhs() const\n   { return this->rhs_; }\n \n+  bool\n+  omit_write_barrier() const\n+  { return this->omit_write_barrier_; }\n+\n+  void\n+  set_omit_write_barrier()\n+  { this->omit_write_barrier_ = true; }\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -603,6 +611,8 @@ class Assignment_statement : public Statement\n   Expression* lhs_;\n   // Right hand side--the rvalue.\n   Expression* rhs_;\n+  // True if we can omit a write barrier from this assignment.\n+  bool omit_write_barrier_;\n };\n \n // A statement which creates and initializes a temporary variable."}, {"sha": "58524cdb3223bc067d7244b14a55aee1d9b1db62", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a90f559d727a993b5a3c5c9c5d5cd5520a7503a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=8a90f559d727a993b5a3c5c9c5d5cd5520a7503a", "patch": "@@ -16,26 +16,87 @@\n #include \"runtime.h\"\n #include \"gogo.h\"\n \n-// Mark variables whose addresses are taken.  This has to be done\n-// before the write barrier pass and after the escape analysis pass.\n-// It would be nice to do this elsewhere but there isn't an obvious\n-// place.\n+// Mark variables whose addresses are taken and do some other\n+// cleanups.  This has to be done before the write barrier pass and\n+// after the escape analysis pass.  It would be nice to do this\n+// elsewhere but there isn't an obvious place.\n \n class Mark_address_taken : public Traverse\n {\n  public:\n   Mark_address_taken(Gogo* gogo)\n-    : Traverse(traverse_expressions),\n-      gogo_(gogo)\n+    : Traverse(traverse_functions\n+\t       | traverse_statements\n+\t       | traverse_expressions),\n+      gogo_(gogo), function_(NULL)\n   { }\n \n+  int\n+  function(Named_object*);\n+\n+  int\n+  statement(Block*, size_t*, Statement*);\n+\n   int\n   expression(Expression**);\n \n  private:\n+  // General IR.\n   Gogo* gogo_;\n+  // The function we are traversing.\n+  Named_object* function_;\n };\n \n+// Record a function.\n+\n+int\n+Mark_address_taken::function(Named_object* no)\n+{\n+  go_assert(this->function_ == NULL);\n+  this->function_ = no;\n+  int t = no->func_value()->traverse(this);\n+  this->function_ = NULL;\n+\n+  if (t == TRAVERSE_EXIT)\n+    return t;\n+  return TRAVERSE_SKIP_COMPONENTS;\n+}\n+\n+// Traverse a statement.\n+\n+int\n+Mark_address_taken::statement(Block* block, size_t* pindex, Statement* s)\n+{\n+  // If this is an assignment of the form s = append(s, ...), expand\n+  // it now, so that we can assign it to the left hand side in the\n+  // middle of the expansion and possibly skip a write barrier.\n+  Assignment_statement* as = s->assignment_statement();\n+  if (as != NULL && !as->lhs()->is_sink_expression())\n+    {\n+      Call_expression* rce = as->rhs()->call_expression();\n+      if (rce != NULL\n+\t  && rce->builtin_call_expression() != NULL\n+\t  && (rce->builtin_call_expression()->code()\n+\t      == Builtin_call_expression::BUILTIN_APPEND)\n+          && Expression::is_same_variable(as->lhs(), rce->args()->front()))\n+\t{\n+\t  Statement_inserter inserter = Statement_inserter(block, pindex);\n+\t  Expression* a =\n+\t    rce->builtin_call_expression()->flatten_append(this->gogo_,\n+\t\t\t\t\t\t\t   this->function_,\n+\t\t\t\t\t\t\t   &inserter,\n+\t\t\t\t\t\t\t   as->lhs(),\n+\t\t\t\t\t\t\t   block);\n+\t  go_assert(a == NULL);\n+\t  // That does the assignment, so remove this statement.\n+\t  Expression* e = Expression::make_boolean(true, s->location());\n+\t  Statement* dummy = Statement::make_statement(e, true);\n+\t  block->replace_statement(*pindex, dummy);\n+\t}\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Mark variable addresses taken.\n \n int\n@@ -387,6 +448,10 @@ Write_barriers::statement(Block* block, size_t* pindex, Statement* s)\n     case Statement::STATEMENT_ASSIGNMENT:\n       {\n \tAssignment_statement* as = s->assignment_statement();\n+\n+\tif (as->omit_write_barrier())\n+\t  break;\n+\n \tExpression* lhs = as->lhs();\n \tExpression* rhs = as->rhs();\n "}]}