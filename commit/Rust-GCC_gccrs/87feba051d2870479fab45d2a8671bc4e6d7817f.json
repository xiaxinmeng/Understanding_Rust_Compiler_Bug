{"sha": "87feba051d2870479fab45d2a8671bc4e6d7817f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdmZWJhMDUxZDI4NzA0NzlmYWI0NWQyYTg2NzFiYzRlNmQ3ODE3Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:46:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:46:40Z"}, "message": "[multiple changes]\n\n2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* namet.adb, namet.ads, exp_unst.adb: Minor reformatting.\n\n2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_eval.adb (Choice_Matches): Check the expression\n\tagainst the predicate values when the choice denotes a\n\tsubtype with a static predicate.\n\t(Eval_Membership_Op): Code cleanup. Remove the suspicious guard which\n\ttests for predicates.\n\t(Is_OK_Static_Subtype): A subtype with a dynamic predicate\n\tis not static.\t(Is_Static_Subtype): A subtype with a dynamic\n\tpredicate is not static.\n\t* sem_eval.ads (Is_OK_Static_Subtype): Update the comment on usage.\n\t(Is_Static_Subtype): Update the comment on usage.\n\n2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Input_Item): Allow\n\tgeneric formals to appear as initialization items.\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Stream_TSS_Definition,\n\tHas_Good_Profile): Additional error message to indicate that\n\tthe second parameter of the subprogram must be a first subtype.\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper, Is_Inline_Pragma):\n\tUse the pragma lookahead that determines whether a subprogram\n\tis to be inlined, when some level of backend optimization is\n\trequired.\n\t* sem_ch12.ads, sem_ch12.adb (Add_Pending_Instantiation): Factorize\n\tcode used to create an instance body when needed for inlining.\n\t* exp_ch6.adb (Expand_Call): When a call is to be inlined, and the\n\tcall appears within an instantiation that is not a compilation\n\tunit, add a pending instantiation for the enclosing instance,\n\tso the backend can inline in turn the calls contained in the\n\tinlined body.\n\nFrom-SVN: r235124", "tree": {"sha": "6b79a0b34a4ee6a589bdc031cfa4e17af7e81b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b79a0b34a4ee6a589bdc031cfa4e17af7e81b98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87feba051d2870479fab45d2a8671bc4e6d7817f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87feba051d2870479fab45d2a8671bc4e6d7817f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87feba051d2870479fab45d2a8671bc4e6d7817f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87feba051d2870479fab45d2a8671bc4e6d7817f/comments", "author": null, "committer": null, "parents": [{"sha": "3e20cb680fae4486f196dcc807237d573ad6d207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e20cb680fae4486f196dcc807237d573ad6d207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e20cb680fae4486f196dcc807237d573ad6d207"}], "stats": {"total": 580, "additions": 347, "deletions": 233}, "files": [{"sha": "143a6a10309eef12989a197e6ae0a3bcadf310f9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -1,3 +1,45 @@\n+2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* namet.adb, namet.ads, exp_unst.adb: Minor reformatting.\n+\n+2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_eval.adb (Choice_Matches): Check the expression\n+\tagainst the predicate values when the choice denotes a\n+\tsubtype with a static predicate.\n+\t(Eval_Membership_Op): Code cleanup. Remove the suspicious guard which\n+\ttests for predicates.\n+\t(Is_OK_Static_Subtype): A subtype with a dynamic predicate\n+\tis not static.\t(Is_Static_Subtype): A subtype with a dynamic\n+\tpredicate is not static.\n+\t* sem_eval.ads (Is_OK_Static_Subtype): Update the comment on usage.\n+\t(Is_Static_Subtype): Update the comment on usage.\n+\n+2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Input_Item): Allow\n+\tgeneric formals to appear as initialization items.\n+\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Stream_TSS_Definition,\n+\tHas_Good_Profile): Additional error message to indicate that\n+\tthe second parameter of the subprogram must be a first subtype.\n+\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper, Is_Inline_Pragma):\n+\tUse the pragma lookahead that determines whether a subprogram\n+\tis to be inlined, when some level of backend optimization is\n+\trequired.\n+\t* sem_ch12.ads, sem_ch12.adb (Add_Pending_Instantiation): Factorize\n+\tcode used to create an instance body when needed for inlining.\n+\t* exp_ch6.adb (Expand_Call): When a call is to be inlined, and the\n+\tcall appears within an instantiation that is not a compilation\n+\tunit, add a pending instantiation for the enclosing instance,\n+\tso the backend can inline in turn the calls contained in the\n+\tinlined body.\n+\n 2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb (Build_Pragma_Check_Equivalent): The mapping"}, {"sha": "a72bbe18d0ae9c863ebcb17060bd1b1c441219e2", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -59,6 +59,7 @@ with Sem;       use Sem;\n with Sem_Aux;   use Sem_Aux;\n with Sem_Ch6;   use Sem_Ch6;\n with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch12;  use Sem_Ch12;\n with Sem_Ch13;  use Sem_Ch13;\n with Sem_Dim;   use Sem_Dim;\n with Sem_Disp;  use Sem_Disp;\n@@ -3898,6 +3899,50 @@ package body Exp_Ch6 is\n          then\n             Add_Inlined_Body (Subp, Call_Node);\n \n+            --  If the inlined call appears within an instantiation and some\n+            --  level of optimization is required, ensure that the enclosing\n+            --  instance body is available so that the back-end can actually\n+            --  perform the inlining.\n+\n+            if In_Instance\n+               and then Comes_From_Source (Subp)\n+               and then Optimization_Level > 0\n+            then\n+               declare\n+                  Inst : Entity_Id;\n+                  Decl : Node_Id;\n+\n+               begin\n+                  Inst := Scope (Subp);\n+\n+                  --  Find enclosing instance.\n+\n+                  while Present (Inst) and then Inst /= Standard_Standard loop\n+                     exit when Is_Generic_Instance (Inst);\n+                     Inst := Scope (Inst);\n+                  end loop;\n+\n+                  if Present (Inst) and then Is_Generic_Instance (Inst) then\n+                     Set_Is_Inlined (Inst);\n+                     Decl := Unit_Declaration_Node (Inst);\n+\n+                     --  Do not add a pending instantiation if the body exits\n+                     --  already, or if the instance is a compilation unit, or\n+                     --  the instance node is missing.\n+\n+                     if Present (Corresponding_Body (Decl))\n+                       or else Nkind (Parent (Decl)) = N_Compilation_Unit\n+                       or else No (Next (Decl))\n+                     then\n+                        null;\n+\n+                     else\n+                        Add_Pending_Instantiation (Next (Decl), Decl);\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n+\n          --  Front end expansion of simple functions returning unconstrained\n          --  types (see Check_And_Split_Unconstrained_Function). Note that the\n          --  case of a simple renaming (Body_To_Inline in N_Entity above, see"}, {"sha": "eed26e66bc923ce969b055f79cf0b6e1f2a2624d", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -243,9 +243,10 @@ package body Exp_Unst is\n          loop\n             if No (C) then\n                return Chars (Ent);\n+\n             elsif Chars (Defining_Identifier (C)) = Chars (Ent) then\n-               return Name_Find\n-                        (Get_Name_String (Chars (Ent)) & Img_Pos (Index));\n+               return\n+                 Name_Find (Get_Name_String (Chars (Ent)) & Img_Pos (Index));\n             else\n                Next (C);\n             end if;"}, {"sha": "4ba68df7171c25f8bf36eb5fcd7414af0b8628dc", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -140,6 +140,7 @@ package body Namet is\n    procedure Append (Buf : in out Bounded_String; Id : Name_Id) is\n       pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n       S : constant Int := Name_Entries.Table (Id).Name_Chars_Index;\n+\n    begin\n       for J in 1 .. Natural (Name_Entries.Table (Id).Name_Len) loop\n          Append (Buf, Name_Chars.Table (S + Int (J)));\n@@ -420,7 +421,9 @@ package body Namet is\n    ----------------------------------\n \n    procedure Append_Decoded_With_Brackets\n-     (Buf : in out Bounded_String; Id : Name_Id) is\n+     (Buf : in out Bounded_String;\n+      Id  : Name_Id)\n+   is\n       P : Natural;\n \n    begin\n@@ -560,8 +563,7 @@ package body Namet is\n    -- Append_Unqualified --\n    ------------------------\n \n-   procedure Append_Unqualified\n-     (Buf : in out Bounded_String; Id : Name_Id) is\n+   procedure Append_Unqualified (Buf : in out Bounded_String; Id : Name_Id) is\n    begin\n       Append (Buf, Id);\n       Strip_Qualification_And_Suffixes (Buf);\n@@ -572,7 +574,9 @@ package body Namet is\n    --------------------------------\n \n    procedure Append_Unqualified_Decoded\n-     (Buf : in out Bounded_String; Id : Name_Id) is\n+     (Buf : in out Bounded_String;\n+      Id  : Name_Id)\n+   is\n    begin\n       Append_Decoded (Buf, Id);\n       Strip_Qualification_And_Suffixes (Buf);\n@@ -908,8 +912,12 @@ package body Namet is\n    ----------------\n \n    procedure Insert_Str\n-     (Buf : in out Bounded_String; S : String; Index : Positive) is\n+     (Buf   : in out Bounded_String;\n+      S     : String;\n+      Index : Positive)\n+   is\n       SL : constant Natural := S'Length;\n+\n    begin\n       Buf.Chars (Index + SL .. Buf.Length + SL) :=\n         Buf.Chars (Index .. Buf.Length);\n@@ -1468,7 +1476,9 @@ package body Namet is\n    --------------------------------\n \n    procedure Set_Character_Literal_Name\n-     (Buf : in out Bounded_String; C : Char_Code) is\n+     (Buf : in out Bounded_String;\n+      C   : Char_Code)\n+   is\n    begin\n       Buf.Length := 0;\n       Append (Buf, 'Q');"}, {"sha": "1d00ee0cc6b130725f4435a042015fe67cfc1f36", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -152,10 +152,10 @@ package Namet is\n    type Bounded_String (Max_Length : Natural := 4 * Max_Line_Length) is limited\n    --  The default here is intended to be an infinite value that ensures that\n    --  we never overflow the buffer (names this long are too absurd to worry).\n-      record\n-         Length : Natural := 0;\n-         Chars  : String (1 .. Max_Length);\n-      end record;\n+   record\n+      Length : Natural := 0;\n+      Chars  : String (1 .. Max_Length);\n+   end record;\n \n    --  To create a Name_Id, you can declare a Bounded_String as a local\n    --  variable, and Append things onto it, and finally call Name_Find.\n@@ -167,8 +167,8 @@ package Namet is\n    --  to avoid the global.\n \n    Global_Name_Buffer : Bounded_String;\n-   Name_Buffer : String renames Global_Name_Buffer.Chars;\n-   Name_Len : Natural renames Global_Name_Buffer.Length;\n+   Name_Buffer        : String renames Global_Name_Buffer.Chars;\n+   Name_Len           : Natural renames Global_Name_Buffer.Length;\n \n    --  Note that there is some circuitry (e.g. Osint.Write_Program_Name) that\n    --  does a save/restore on Name_Len and Name_Buffer (1 .. Name_Len). This\n@@ -373,7 +373,8 @@ package Namet is\n    --  apostrophes.\n \n    procedure Append_Decoded_With_Brackets\n-     (Buf : in out Bounded_String; Id : Name_Id);\n+     (Buf : in out Bounded_String;\n+      Id  : Name_Id);\n    --  Same as Append_Decoded, except that the brackets notation (Uhh\n    --  replaced by [\"hh\"], Whhhh replaced by [\"hhhh\"], WWhhhhhhhh replaced by\n    --  [\"hhhhhhhh\"]) is used for all non-lower half characters, regardless of\n@@ -383,8 +384,7 @@ package Namet is\n    --  requirement for a canonical representation not affected by the\n    --  character set options (e.g. in the binder generation of symbols).\n \n-   procedure Append_Unqualified\n-     (Buf : in out Bounded_String; Id : Name_Id);\n+   procedure Append_Unqualified (Buf : in out Bounded_String; Id : Name_Id);\n    --  Same as Append, except that qualification (as defined in unit\n    --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n    --  also the suffixes used to indicate package body entities and to\n@@ -395,7 +395,8 @@ package Namet is\n    --  after gigi has been called.\n \n    procedure Append_Unqualified_Decoded\n-     (Buf : in out Bounded_String; Id : Name_Id);\n+     (Buf : in out Bounded_String;\n+      Id  : Name_Id);\n    --  Same as Append_Unqualified, but decoded as for Append_Decoded\n \n    procedure Append_Encoded (Buf : in out Bounded_String; C : Char_Code);\n@@ -408,12 +409,15 @@ package Namet is\n    --  are stored using the Uhh encoding).\n \n    procedure Set_Character_Literal_Name\n-     (Buf : in out Bounded_String; C : Char_Code);\n+     (Buf : in out Bounded_String;\n+      C   : Char_Code);\n    --  This procedure sets the proper encoded name for the character literal\n    --  for the given character code.\n \n    procedure Insert_Str\n-     (Buf : in out Bounded_String; S : String; Index : Positive);\n+     (Buf   : in out Bounded_String;\n+      S     : String;\n+      Index : Positive);\n    --  Inserts S in Buf, starting at Index. Any existing characters at or past\n    --  this location get moved beyond the inserted string.\n "}, {"sha": "5508c9b9eda62b0207241ac9bb3cf95f82f6656f", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -1027,6 +1027,31 @@ package body Sem_Ch12 is\n       raise Instantiation_Error;\n    end Abandon_Instantiation;\n \n+   --------------------------------\n+   --  Add_Pending_Instantiation --\n+   --------------------------------\n+\n+   procedure Add_Pending_Instantiation (Inst : Node_Id; Act_Decl : Node_Id) is\n+   begin\n+\n+      --  Add to the instantiation node and the corresponding unit declaration\n+      --  the current values of global flags to be used when analyzing the\n+      --  instance body.\n+\n+      Pending_Instantiations.Append\n+        ((Inst_Node                => Inst,\n+          Act_Decl                 => Act_Decl,\n+          Expander_Status          => Expander_Active,\n+          Current_Sem_Unit         => Current_Sem_Unit,\n+          Scope_Suppress           => Scope_Suppress,\n+          Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n+          Version                  => Ada_Version,\n+          Version_Pragma           => Ada_Version_Pragma,\n+          Warnings                 => Save_Warnings,\n+          SPARK_Mode               => SPARK_Mode,\n+          SPARK_Mode_Pragma        => SPARK_Mode_Pragma));\n+   end Add_Pending_Instantiation;\n+\n    --------------------------\n    -- Analyze_Associations --\n    --------------------------\n@@ -4138,18 +4163,7 @@ package body Sem_Ch12 is\n \n                --  Make entry in table\n \n-               Pending_Instantiations.Append\n-                 ((Inst_Node                => N,\n-                   Act_Decl                 => Act_Decl,\n-                   Expander_Status          => Expander_Active,\n-                   Current_Sem_Unit         => Current_Sem_Unit,\n-                   Scope_Suppress           => Scope_Suppress,\n-                   Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n-                   Version                  => Ada_Version,\n-                   Version_Pragma           => Ada_Version_Pragma,\n-                   Warnings                 => Save_Warnings,\n-                   SPARK_Mode               => SPARK_Mode,\n-                   SPARK_Mode_Pragma        => SPARK_Mode_Pragma));\n+               Add_Pending_Instantiation (N, Act_Decl);\n             end if;\n          end if;\n \n@@ -4745,18 +4759,7 @@ package body Sem_Ch12 is\n \n         and then not Is_Eliminated (Subp)\n       then\n-         Pending_Instantiations.Append\n-           ((Inst_Node                => N,\n-             Act_Decl                 => Unit_Declaration_Node (Subp),\n-             Expander_Status          => Expander_Active,\n-             Current_Sem_Unit         => Current_Sem_Unit,\n-             Scope_Suppress           => Scope_Suppress,\n-             Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n-             Version                  => Ada_Version,\n-             Version_Pragma           => Ada_Version_Pragma,\n-             Warnings                 => Save_Warnings,\n-             SPARK_Mode               => SPARK_Mode,\n-             SPARK_Mode_Pragma        => SPARK_Mode_Pragma));\n+         Add_Pending_Instantiation (N, Unit_Declaration_Node (Subp));\n          return True;\n \n       --  Here if not inlined, or we ignore the inlining"}, {"sha": "c95396a35e6d42f80952de0ae9603becc3893691", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -37,6 +37,10 @@ package Sem_Ch12 is\n    procedure Analyze_Formal_Subprogram_Declaration      (N : Node_Id);\n    procedure Analyze_Formal_Package_Declaration         (N : Node_Id);\n \n+   procedure Add_Pending_Instantiation (Inst : Node_Id; Act_Decl : Node_Id);\n+   --  Add an entry in the table of instance bodies that must be analyzed\n+   --  when inlining requires its body or the body of a nested instance.\n+\n    function Build_Function_Wrapper\n      (Formal_Subp : Entity_Id;\n       Actual_Subp : Entity_Id) return Node_Id;\n@@ -113,12 +117,12 @@ package Sem_Ch12 is\n    --  of G, we compile the body of I2, but not that of I1. However, when we\n    --  compile U as the main unit, we compile both bodies. This will lead to\n    --  link-time errors if the compilation of I1 generates public symbols,\n-   --  because those in I2 will receive different names in both cases.\n-   --  This forces us to analyze the body of I1 even when U is not the main\n-   --  unit. We don't want this additional mechanism to generate an error\n-   --  when the body of the generic for I1 is not present, and this is the\n-   --  reason for the presence of the flag Body_Optional, which is exchanged\n-   --  between the current procedure and Load_Parent_Of_Generic.\n+   --  because those in I2 will receive different names in both cases. This\n+   --  forces us to analyze the body of I1 even when U is not the main unit.\n+   --  We don't want this additional mechanism to generate an error when the\n+   --  body of the generic for I1 is not present, and this is the reason for\n+   --  the presence of the flag Body_Optional, which is exchanged between the\n+   --  current procedure and Load_Parent_Of_Generic.\n \n    procedure Instantiate_Subprogram_Body\n      (Body_Info     : Pending_Body_Info;"}, {"sha": "cb7eb8f16f5324fa4c721c6c39bbfbbba5ea0772", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -3754,15 +3754,21 @@ package body Sem_Ch13 is\n          Is_Read : constant Boolean := (TSS_Nam = TSS_Stream_Read);\n          --  True for Read attribute, false for other attributes\n \n-         function Has_Good_Profile (Subp : Entity_Id) return Boolean;\n+         function Has_Good_Profile\n+           (Subp   : Entity_Id;\n+            Report : Boolean := False) return Boolean;\n          --  Return true if the entity is a subprogram with an appropriate\n-         --  profile for the attribute being defined.\n+         --  profile for the attribute being defined. If result is false and\n+         --  Report is True function emits appropriate error.\n \n          ----------------------\n          -- Has_Good_Profile --\n          ----------------------\n \n-         function Has_Good_Profile (Subp : Entity_Id) return Boolean is\n+         function Has_Good_Profile\n+           (Subp   : Entity_Id;\n+            Report : Boolean := False) return Boolean\n+         is\n             F              : Entity_Id;\n             Is_Function    : constant Boolean := (TSS_Nam = TSS_Stream_Input);\n             Expected_Ekind : constant array (Boolean) of Entity_Kind :=\n@@ -3837,6 +3843,11 @@ package body Sem_Ch13 is\n               and then not Is_First_Subtype (Typ)\n               and then not Is_Class_Wide_Type (Typ)\n             then\n+               if Report and not Is_First_Subtype (Typ) then\n+                  Error_Msg_N\n+                    (\"formal of stream operation must be a first subtype\", F);\n+               end if;\n+\n                return False;\n \n             else\n@@ -3885,7 +3896,7 @@ package body Sem_Ch13 is\n \n          if Is_Entity_Name (Expr) then\n             if not Is_Overloaded (Expr) then\n-               if Has_Good_Profile (Entity (Expr)) then\n+               if Has_Good_Profile (Entity (Expr), Report => True) then\n                   Subp := Entity (Expr);\n                end if;\n "}, {"sha": "343fbe69b93787bfc5376f1c2059b4d1db51a1f0", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -2554,8 +2554,9 @@ package body Sem_Ch6 is\n               Nkind (N) = N_Pragma\n                 and then\n                   (Pragma_Name (N) = Name_Inline_Always\n-                    or else (Front_End_Inlining\n-                              and then Pragma_Name (N) = Name_Inline))\n+                    or else (Pragma_Name (N) = Name_Inline\n+                      and then\n+                        (Front_End_Inlining or else Optimization_Level > 0)))\n                 and then\n                   Chars\n                     (Expression (First (Pragma_Argument_Associations (N)))) ="}, {"sha": "67d464c772f107dfab4fd7e9ba77a545bc264cdb", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -173,21 +173,26 @@ package body Sem_Eval is\n    --  discrete, real, or string type and must be a compile time known value\n    --  (it is an error to make the call if these conditions are not met).\n \n+   function Find_Universal_Operator_Type (N : Node_Id) return Entity_Id;\n+   --  Check whether an arithmetic operation with universal operands which is a\n+   --  rewritten function call with an explicit scope indication is ambiguous:\n+   --  P.\"+\" (1, 2) will be ambiguous if there is more than one visible numeric\n+   --  type declared in P and the context does not impose a type on the result\n+   --  (e.g. in the expression of a type conversion). If ambiguous, emit an\n+   --  error and return Empty, else return the result type of the operator.\n+\n    function From_Bits (B : Bits; T : Entity_Id) return Uint;\n    --  Converts a bit string of length B'Length to a Uint value to be used for\n    --  a target of type T, which is a modular type. This procedure includes the\n    --  necessary reduction by the modulus in the case of a nonbinary modulus\n    --  (for a binary modulus, the bit string is the right length any way so all\n    --  is well).\n \n-   function Is_Static_Choice (Choice : Node_Id) return Boolean;\n-   --  Given a choice (from a case expression or membership test), returns\n-   --  True if the choice is static. No test is made for raising of constraint\n-   --  error, so this function is used only for legality tests.\n-\n-   function Is_Static_Choice_List (Choices : List_Id) return Boolean;\n-   --  Given a choice list (from a case expression or membership test), return\n-   --  True if all choices are static in the sense of Is_Static_Choice.\n+   function Get_String_Val (N : Node_Id) return Node_Id;\n+   --  Given a tree node for a folded string or character value, returns the\n+   --  corresponding string literal or character literal (one of the two must\n+   --  be available, or the operand would not have been marked as foldable in\n+   --  the earlier analysis of the operation).\n \n    function Is_OK_Static_Choice (Choice : Node_Id) return Boolean;\n    --  Given a choice (from a case expression or membership test), returns\n@@ -197,6 +202,15 @@ package body Sem_Eval is\n    --  Given a choice list (from a case expression or membership test), return\n    --  True if all choices are static in the sense of Is_OK_Static_Choice.\n \n+   function Is_Static_Choice (Choice : Node_Id) return Boolean;\n+   --  Given a choice (from a case expression or membership test), returns\n+   --  True if the choice is static. No test is made for raising of constraint\n+   --  error, so this function is used only for legality tests.\n+\n+   function Is_Static_Choice_List (Choices : List_Id) return Boolean;\n+   --  Given a choice list (from a case expression or membership test), return\n+   --  True if all choices are static in the sense of Is_Static_Choice.\n+\n    function Is_Static_Range (N : Node_Id) return Boolean;\n    --  Determine if range is static, as defined in RM 4.9(26). The only allowed\n    --  argument is an N_Range node (but note that the semantic analysis of\n@@ -206,12 +220,6 @@ package body Sem_Eval is\n    --  raise Constraint_Error or not. Used for checking whether expressions are\n    --  static in the 4.9 sense (without worrying about exceptions).\n \n-   function Get_String_Val (N : Node_Id) return Node_Id;\n-   --  Given a tree node for a folded string or character value, returns the\n-   --  corresponding string literal or character literal (one of the two must\n-   --  be available, or the operand would not have been marked as foldable in\n-   --  the earlier analysis of the operation).\n-\n    function OK_Bits (N : Node_Id; Bits : Uint) return Boolean;\n    --  Bits represents the number of bits in an integer value to be computed\n    --  (but the value has not been computed yet). If this value in Bits is\n@@ -255,14 +263,6 @@ package body Sem_Eval is\n    --  used for producing the result of the static evaluation of the\n    --  logical operators\n \n-   function Find_Universal_Operator_Type (N : Node_Id) return Entity_Id;\n-   --  Check whether an arithmetic operation with universal operands which is a\n-   --  rewritten function call with an explicit scope indication is ambiguous:\n-   --  P.\"+\" (1, 2) will be ambiguous if there is more than one visible numeric\n-   --  type declared in P and the context does not impose a type on the result\n-   --  (e.g. in the expression of a type conversion). If ambiguous, emit an\n-   --  error and return Empty, else return the result type of the operator.\n-\n    procedure Test_Expression_Is_Foldable\n      (N    : Node_Id;\n       Op1  : Node_Id;\n@@ -596,9 +596,21 @@ package body Sem_Eval is\n          Set_Raises_Constraint_Error (Choice);\n          return Non_Static;\n \n+      --  When the choice denotes a subtype with a static predictate, check the\n+      --  expression against the predicate values.\n+\n+      elsif (Nkind (Choice) = N_Subtype_Indication\n+               or else (Is_Entity_Name (Choice)\n+                         and then Is_Type (Entity (Choice))))\n+        and then Has_Predicates (Etype (Choice))\n+        and then Has_Static_Predicate (Etype (Choice))\n+      then\n+         return\n+           Choices_Match (Expr, Static_Discrete_Predicate (Etype (Choice)));\n+\n       --  Discrete type case\n \n-      elsif Is_Discrete_Type (Etype (Expr)) then\n+      elsif Is_Discrete_Type (Etyp) then\n          Val := Expr_Value (Expr);\n \n          if Nkind (Choice) = N_Range then\n@@ -612,8 +624,7 @@ package body Sem_Eval is\n             end if;\n \n          elsif Nkind (Choice) = N_Subtype_Indication\n-           or else\n-             (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+           or else (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n          then\n             if Val >= Expr_Value (Type_Low_Bound  (Etype (Choice)))\n                  and then\n@@ -635,9 +646,9 @@ package body Sem_Eval is\n             end if;\n          end if;\n \n-         --  Real type case\n+      --  Real type case\n \n-      elsif Is_Real_Type (Etype (Expr)) then\n+      elsif Is_Real_Type (Etyp) then\n          ValR := Expr_Value_R (Expr);\n \n          if Nkind (Choice) = N_Range then\n@@ -651,8 +662,7 @@ package body Sem_Eval is\n             end if;\n \n          elsif Nkind (Choice) = N_Subtype_Indication\n-           or else\n-             (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+           or else (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n          then\n             if ValR >= Expr_Value_R (Type_Low_Bound  (Etype (Choice)))\n                  and then\n@@ -671,15 +681,14 @@ package body Sem_Eval is\n             end if;\n          end if;\n \n-         --  String type cases\n+      --  String type cases\n \n       else\n-         pragma Assert (Is_String_Type (Etype (Expr)));\n+         pragma Assert (Is_String_Type (Etyp));\n          ValS := Expr_Value_S (Expr);\n \n          if Nkind (Choice) = N_Subtype_Indication\n-           or else\n-             (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+           or else (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n          then\n             if not Is_Constrained (Etype (Choice)) then\n                return Match;\n@@ -2714,45 +2723,34 @@ package body Sem_Eval is\n    --  static subtype (RM 4.9(12)).\n \n    procedure Eval_Membership_Op (N : Node_Id) is\n-      Left   : constant Node_Id := Left_Opnd (N);\n-      Right  : constant Node_Id := Right_Opnd (N);\n       Alts   : constant List_Id := Alternatives (N);\n+      Choice : constant Node_Id := Right_Opnd (N);\n+      Expr   : constant Node_Id := Left_Opnd (N);\n       Result : Match_Result;\n \n    begin\n       --  Ignore if error in either operand, except to make sure that Any_Type\n       --  is properly propagated to avoid junk cascaded errors.\n \n-      if Etype (Left) = Any_Type\n-        or else (Present (Right) and then Etype (Right) = Any_Type)\n+      if Etype (Expr) = Any_Type\n+        or else (Present (Choice) and then Etype (Choice) = Any_Type)\n       then\n          Set_Etype (N, Any_Type);\n          return;\n       end if;\n \n-      --  Ignore if types involved have predicates\n-      --  Is this right for static predicates ???\n-      --  And what about the alternatives ???\n-\n-      if Present (Predicate_Function (Etype (Left)))\n-        or else (Present (Right)\n-                  and then Present (Predicate_Function (Etype (Right))))\n-      then\n-         return;\n-      end if;\n-\n       --  If left operand non-static, then nothing to do\n \n-      if not Is_Static_Expression (Left) then\n+      if not Is_Static_Expression (Expr) then\n          return;\n       end if;\n \n       --  If choice is non-static, left operand is in non-static context\n \n-      if (Present (Right) and then not Is_Static_Choice (Right))\n+      if (Present (Choice) and then not Is_Static_Choice (Choice))\n         or else (Present (Alts) and then not Is_Static_Choice_List (Alts))\n       then\n-         Check_Non_Static_Context (Left);\n+         Check_Non_Static_Context (Expr);\n          return;\n       end if;\n \n@@ -2762,16 +2760,16 @@ package body Sem_Eval is\n \n       --  If left operand raises constraint error, propagate and we are done\n \n-      if Raises_Constraint_Error (Left) then\n+      if Raises_Constraint_Error (Expr) then\n          Set_Raises_Constraint_Error (N, True);\n \n       --  See if we match\n \n       else\n-         if Present (Right) then\n-            Result := Choice_Matches (Left, Right);\n+         if Present (Choice) then\n+            Result := Choice_Matches (Expr, Choice);\n          else\n-            Result := Choices_Match (Left, Alts);\n+            Result := Choices_Match (Expr, Alts);\n          end if;\n \n          --  If result is Non_Static, it means that we raise Constraint_Error,\n@@ -4697,8 +4695,7 @@ package body Sem_Eval is\n          return Is_OK_Static_Range (Choice);\n \n       elsif Nkind (Choice) = N_Subtype_Indication\n-        or else\n-          (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+        or else (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n       then\n          return Is_OK_Static_Subtype (Etype (Choice));\n \n@@ -4787,6 +4784,9 @@ package body Sem_Eval is\n       then\n          return False;\n \n+      elsif Has_Dynamic_Predicate_Aspect (Typ) then\n+         return False;\n+\n       --  String types\n \n       elsif Is_String_Type (Typ) then\n@@ -4853,8 +4853,7 @@ package body Sem_Eval is\n          return Is_Static_Range (Choice);\n \n       elsif Nkind (Choice) = N_Subtype_Indication\n-        or else\n-          (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+        or else (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n       then\n          return Is_Static_Subtype (Etype (Choice));\n \n@@ -4883,7 +4882,7 @@ package body Sem_Eval is\n       return True;\n    end Is_Static_Choice_List;\n \n----------------------\n+   ---------------------\n    -- Is_Static_Range --\n    ---------------------\n \n@@ -4929,6 +4928,9 @@ package body Sem_Eval is\n       then\n          return False;\n \n+      elsif Has_Dynamic_Predicate_Aspect (Typ) then\n+         return False;\n+\n       --  String types\n \n       elsif Is_String_Type (Typ) then"}, {"sha": "b59fb6c11378e49f25cc00820a462731cb4845c9", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 100, "deletions": 115, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -198,88 +198,10 @@ package Sem_Eval is\n    --  True for a recursive call from within Compile_Time_Compare to avoid some\n    --  infinite recursion cases. It should never be set by a client.\n \n-   procedure Flag_Non_Static_Expr (Msg : String; Expr : Node_Id);\n-   --  This procedure is called after it has been determined that Expr is not\n-   --  static when it is required to be. Msg is the text of a message that\n-   --  explains the error. This procedure checks if an error is already posted\n-   --  on Expr, if so, it does nothing unless All_Errors_Mode is set in which\n-   --  case this flag is ignored. Otherwise the given message is posted using\n-   --  Error_Msg_F, and then Why_Not_Static is called on Expr to generate\n-   --  additional messages. The string given as Msg should end with ! to make\n-   --  it an unconditional message, to ensure that if it is posted, the entire\n-   --  set of messages is all posted.\n-\n-   function Is_OK_Static_Expression (N : Node_Id) return Boolean;\n-   --  An OK static expression is one that is static in the RM definition sense\n-   --  and which does not raise constraint error. For most legality checking\n-   --  purposes you should use Is_Static_Expression. For those legality checks\n-   --  where the expression N should not raise constraint error use this\n-   --  routine. This routine is *not* to be used in contexts where the test is\n-   --  for compile time evaluation purposes. Use Compile_Time_Known_Value\n-   --  instead (see section on \"Compile-Time Known Values\" above).\n-\n-   function Is_OK_Static_Range (N : Node_Id) return Boolean;\n-   --  Determines if range is static, as defined in RM 4.9(26), and also checks\n-   --  that neither bound of the range raises constraint error, thus ensuring\n-   --  that both bounds of the range are compile-time evaluable (i.e. do not\n-   --  raise constraint error). A result of true means that the bounds are\n-   --  compile time evaluable. A result of false means they are not (either\n-   --  because the range is not static, or because one or the other bound\n-   --  raises CE).\n-\n-   function Is_Static_Subtype (Typ : Entity_Id) return Boolean;\n-   --  Determines whether a subtype fits the definition of an Ada static\n-   --  subtype as given in (RM 4.9(26)). Important note: This check does not\n-   --  include the Ada 2012 case of a non-static predicate which results in an\n-   --  otherwise static subtype being non-static. Such a subtype will return\n-   --  True for this test, so if the distinction is important, the caller must\n-   --  deal with this.\n-   --\n-   --  Implementation note: an attempt to include this Ada 2012 case failed,\n-   --  since it appears that this routine is called in some cases before the\n-   --  Static_Discrete_Predicate field is set ???\n-   --\n-   --  This differs from Is_OK_Static_Subtype (which is what must be used by\n-   --  clients) in that it does not care whether the bounds raise a constraint\n-   --  error exception or not. Used for checking whether expressions are static\n-   --  in the 4.9 sense (without worrying about exceptions).\n-\n-   function Is_OK_Static_Subtype (Typ : Entity_Id) return Boolean;\n-   --  Determines whether a subtype fits the definition of an Ada static\n-   --  subtype as given in (RM 4.9(26)) with the additional check that neither\n-   --  bound raises constraint error (meaning that Expr_Value[_R|S] can be used\n-   --  on these bounds). Important note: This check does not include the Ada\n-   --  2012 case of a non-static predicate which results in an otherwise static\n-   --  subtype being non-static. Such a subtype will return True for this test,\n-   --  so if the distinction is important, the caller must deal with this.\n-   --\n-   --  Implementation note: an attempt to include this Ada 2012 case failed,\n-   --  since it appears that this routine is called in some cases before the\n-   --  Static_Discrete_Predicate field is set ???\n-   --\n-   --  This differs from Is_Static_Subtype in that it includes the constraint\n-   --  error checks, which are missing from Is_Static_Subtype.\n-\n-   function Subtypes_Statically_Compatible\n-     (T1                      : Entity_Id;\n-      T2                      : Entity_Id;\n-      Formal_Derived_Matching : Boolean := False) return Boolean;\n-   --  Returns true if the subtypes are unconstrained or the constraint on\n-   --  on T1 is statically compatible with T2 (as defined by 4.9.1(4)).\n-   --  Otherwise returns false. Formal_Derived_Matching indicates whether\n-   --  the type T1 is a generic actual being checked against ancestor T2\n-   --  in a formal derived type association.\n-\n-   function Subtypes_Statically_Match\n-     (T1                      : Entity_Id;\n-      T2                      : Entity_Id;\n-      Formal_Derived_Matching : Boolean := False) return Boolean;\n-   --  Determine whether two types T1, T2, which have the same base type,\n-   --  are statically matching subtypes (RM 4.9.1(1-2)). Also includes the\n-   --  extra GNAT rule that object sizes must match (this can be false for\n-   --  types that match in the RM sense because of use of 'Object_Size),\n-   --  except when testing a generic actual T1 against an ancestor T2 in a\n-   --  formal derived type association (indicated by Formal_Derived_Matching).\n+   function Compile_Time_Known_Bounds (T : Entity_Id) return Boolean;\n+   --  If T is an array whose index bounds are all known at compile time, then\n+   --  True is returned. If T is not an array type, or one or more of its index\n+   --  bounds is not known at compile time, then False is returned.\n \n    function Compile_Time_Known_Value (Op : Node_Id) return Boolean;\n    --  Returns true if Op is an expression not raising Constraint_Error whose\n@@ -306,6 +228,15 @@ package Sem_Eval is\n    --  efficient with compile time known values, e.g. range analysis for the\n    --  purpose of removing checks is more effective if we know precise bounds.\n \n+   function Compile_Time_Known_Value_Or_Aggr (Op : Node_Id) return Boolean;\n+   --  Similar to Compile_Time_Known_Value, but also returns True if the value\n+   --  is a compile-time-known aggregate, i.e. an aggregate all of whose\n+   --  constituent expressions are either compile-time-known values (based on\n+   --  calling Compile_Time_Known_Value) or compile-time-known aggregates.\n+   --  Note that the aggregate could still involve run-time checks that might\n+   --  fail (such as for subtype checks in component associations), but the\n+   --  evaluation of the expressions themselves will not raise an exception.\n+\n    function CRT_Safe_Compile_Time_Known_Value (Op : Node_Id) return Boolean;\n    --  In the case of configurable run-times, there may be an issue calling\n    --  Compile_Time_Known_Value with non-static expressions where the legality\n@@ -328,19 +259,16 @@ package Sem_Eval is\n    --  if we are in configurable run-time mode, even if the expression would\n    --  normally be considered compile-time known.\n \n-   function Compile_Time_Known_Value_Or_Aggr (Op : Node_Id) return Boolean;\n-   --  Similar to Compile_Time_Known_Value, but also returns True if the value\n-   --  is a compile-time-known aggregate, i.e. an aggregate all of whose\n-   --  constituent expressions are either compile-time-known values (based on\n-   --  calling Compile_Time_Known_Value) or compile-time-known aggregates.\n-   --  Note that the aggregate could still involve run-time checks that might\n-   --  fail (such as for subtype checks in component associations), but the\n-   --  evaluation of the expressions themselves will not raise an exception.\n-\n-   function Compile_Time_Known_Bounds (T : Entity_Id) return Boolean;\n-   --  If T is an array whose index bounds are all known at compile time, then\n-   --  True is returned. If T is not an array type, or one or more of its index\n-   --  bounds is not known at compile time, then False is returned.\n+   function Expr_Rep_Value (N : Node_Id) return Uint;\n+   --  This is identical to Expr_Value, except in the case of enumeration\n+   --  literals of types for which an enumeration representation clause has\n+   --  been given, in which case it returns the representation value rather\n+   --  than the pos value. This is the value that is needed for generating code\n+   --  sequences, while the Expr_Value value is appropriate for compile time\n+   --  constraint errors or getting the logical value. Note that this function\n+   --  does NOT concern itself with biased values, if the caller needs a\n+   --  properly biased value, the subtraction of the bias must be handled\n+   --  explicitly.\n \n    function Expr_Value (N : Node_Id) return Uint;\n    --  Returns the folded value of the expression N. This function is called in\n@@ -372,17 +300,6 @@ package Sem_Eval is\n    --  is static or its value is known at compile time. This version is used\n    --  for string types and returns the corresponding N_String_Literal node.\n \n-   function Expr_Rep_Value (N : Node_Id) return Uint;\n-   --  This is identical to Expr_Value, except in the case of enumeration\n-   --  literals of types for which an enumeration representation clause has\n-   --  been given, in which case it returns the representation value rather\n-   --  than the pos value. This is the value that is needed for generating code\n-   --  sequences, while the Expr_Value value is appropriate for compile time\n-   --  constraint errors or getting the logical value. Note that this function\n-   --  does NOT concern itself with biased values, if the caller needs a\n-   --  properly biased value, the subtraction of the bias must be handled\n-   --  explicitly.\n-\n    procedure Eval_Actual                 (N : Node_Id);\n    procedure Eval_Allocator              (N : Node_Id);\n    procedure Eval_Arithmetic_Op          (N : Node_Id);\n@@ -411,6 +328,17 @@ package Sem_Eval is\n    procedure Eval_Unary_Op               (N : Node_Id);\n    procedure Eval_Unchecked_Conversion   (N : Node_Id);\n \n+   procedure Flag_Non_Static_Expr (Msg : String; Expr : Node_Id);\n+   --  This procedure is called after it has been determined that Expr is not\n+   --  static when it is required to be. Msg is the text of a message that\n+   --  explains the error. This procedure checks if an error is already posted\n+   --  on Expr, if so, it does nothing unless All_Errors_Mode is set in which\n+   --  case this flag is ignored. Otherwise the given message is posted using\n+   --  Error_Msg_F, and then Why_Not_Static is called on Expr to generate\n+   --  additional messages. The string given as Msg should end with ! to make\n+   --  it an unconditional message, to ensure that if it is posted, the entire\n+   --  set of messages is all posted.\n+\n    procedure Fold_Str (N : Node_Id; Val : String_Id; Static : Boolean);\n    --  Rewrite N with a new N_String_Literal node as the result of the compile\n    --  time evaluation of the node N. Val is the resulting string value from\n@@ -474,6 +402,38 @@ package Sem_Eval is\n    --  is some independent way of knowing that it is valid, i.e. either it is\n    --  an entity with Is_Known_Valid set, or Assume_No_Invalid_Values is True.\n \n+   function Is_Null_Range (Lo : Node_Id; Hi : Node_Id) return Boolean;\n+   --  Returns True if it can guarantee that Lo .. Hi is a null range. If it\n+   --  cannot (because the value of Lo or Hi is not known at compile time) then\n+   --  it returns False.\n+\n+   function Is_OK_Static_Expression (N : Node_Id) return Boolean;\n+   --  An OK static expression is one that is static in the RM definition sense\n+   --  and which does not raise constraint error. For most legality checking\n+   --  purposes you should use Is_Static_Expression. For those legality checks\n+   --  where the expression N should not raise constraint error use this\n+   --  routine. This routine is *not* to be used in contexts where the test is\n+   --  for compile time evaluation purposes. Use Compile_Time_Known_Value\n+   --  instead (see section on \"Compile-Time Known Values\" above).\n+\n+   function Is_OK_Static_Range (N : Node_Id) return Boolean;\n+   --  Determines if range is static, as defined in RM 4.9(26), and also checks\n+   --  that neither bound of the range raises constraint error, thus ensuring\n+   --  that both bounds of the range are compile-time evaluable (i.e. do not\n+   --  raise constraint error). A result of true means that the bounds are\n+   --  compile time evaluable. A result of false means they are not (either\n+   --  because the range is not static, or because one or the other bound\n+   --  raises CE).\n+\n+   function Is_OK_Static_Subtype (Typ : Entity_Id) return Boolean;\n+   --  Determines whether a subtype fits the definition of an Ada static\n+   --  subtype as given in (RM 4.9(26)) with the additional check that neither\n+   --  bound raises constraint error (meaning that Expr_Value[_R|S] can be used\n+   --  on these bounds).\n+   --\n+   --  This differs from Is_Static_Subtype in that it includes the constraint\n+   --  error checks, which are missing from Is_Static_Subtype.\n+\n    function Is_Out_Of_Range\n      (N            : Node_Id;\n       Typ          : Entity_Id;\n@@ -488,6 +448,19 @@ package Sem_Eval is\n    --  that it is out of range. The parameters Assume_Valid, Fixed_Int, and\n    --  Int_Real are as described for Is_In_Range above.\n \n+   function Is_Static_Subtype (Typ : Entity_Id) return Boolean;\n+   --  Determines whether a subtype fits the definition of an Ada static\n+   --  subtype as given in (RM 4.9(26)).\n+   --\n+   --  This differs from Is_OK_Static_Subtype (which is what must be used by\n+   --  clients) in that it does not care whether the bounds raise a constraint\n+   --  error exception or not. Used for checking whether expressions are static\n+   --  in the 4.9 sense (without worrying about exceptions).\n+\n+   function Is_Statically_Unevaluated (Expr : Node_Id) return Boolean;\n+   --  This function returns True if the given expression Expr is statically\n+   --  unevaluated, as defined in (RM 4.9 (32.1-32.6)).\n+\n    function In_Subrange_Of\n      (T1        : Entity_Id;\n       T2        : Entity_Id;\n@@ -498,15 +471,6 @@ package Sem_Eval is\n    --  it cannot be determined at compile time. Flag Fixed_Int is used as in\n    --  routine Is_In_Range above.\n \n-   function Is_Null_Range (Lo : Node_Id; Hi : Node_Id) return Boolean;\n-   --  Returns True if it can guarantee that Lo .. Hi is a null range. If it\n-   --  cannot (because the value of Lo or Hi is not known at compile time) then\n-   --  it returns False.\n-\n-   function Is_Statically_Unevaluated (Expr : Node_Id) return Boolean;\n-   --  This function returns True if the given expression Expr is statically\n-   --  unevaluated, as defined in (RM 4.9 (32.1-32.6)).\n-\n    function Not_Null_Range (Lo : Node_Id; Hi : Node_Id) return Boolean;\n    --  Returns True if it can guarantee that Lo .. Hi is not a null range. If\n    --  it cannot (because the value of Lo or Hi is not known at compile time)\n@@ -518,6 +482,27 @@ package Sem_Eval is\n    --  predicates match. Separated out from Subtypes_Statically_Match so\n    --  that it can be used in specializing error messages.\n \n+   function Subtypes_Statically_Compatible\n+     (T1                      : Entity_Id;\n+      T2                      : Entity_Id;\n+      Formal_Derived_Matching : Boolean := False) return Boolean;\n+   --  Returns true if the subtypes are unconstrained or the constraint on\n+   --  on T1 is statically compatible with T2 (as defined by 4.9.1(4)).\n+   --  Otherwise returns false. Formal_Derived_Matching indicates whether\n+   --  the type T1 is a generic actual being checked against ancestor T2\n+   --  in a formal derived type association.\n+\n+   function Subtypes_Statically_Match\n+     (T1                      : Entity_Id;\n+      T2                      : Entity_Id;\n+      Formal_Derived_Matching : Boolean := False) return Boolean;\n+   --  Determine whether two types T1, T2, which have the same base type,\n+   --  are statically matching subtypes (RM 4.9.1(1-2)). Also includes the\n+   --  extra GNAT rule that object sizes must match (this can be false for\n+   --  types that match in the RM sense because of use of 'Object_Size),\n+   --  except when testing a generic actual T1 against an ancestor T2 in a\n+   --  formal derived type association (indicated by Formal_Derived_Matching).\n+\n    procedure Why_Not_Static (Expr : Node_Id);\n    --  This procedure may be called after generating an error message that\n    --  complains that something is non-static. If it finds good reasons, it"}, {"sha": "c753e6114a86e986ccc0f8c4aae9a258d2a7f96c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87feba051d2870479fab45d2a8671bc4e6d7817f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=87feba051d2870479fab45d2a8671bc4e6d7817f", "patch": "@@ -2860,15 +2860,21 @@ package body Sem_Prag is\n \n                   if Ekind_In (Input_Id, E_Abstract_State,\n                                          E_Constant,\n+                                         E_Generic_In_Out_Parameter,\n+                                         E_Generic_In_Parameter,\n                                          E_In_Parameter,\n                                          E_In_Out_Parameter,\n                                          E_Out_Parameter,\n                                          E_Variable)\n                   then\n                      --  The input cannot denote states or objects declared\n-                     --  within the related package (SPARK RM 7.1.5(4)).\n+                     --  within the related package (SPARK RM 7.1.5(4)). The\n+                     --  only exception to this are generic formal parameters.\n \n-                     if Within_Scope (Input_Id, Current_Scope) then\n+                     if not Ekind_In (Input_Id, E_Generic_In_Out_Parameter,\n+                                                E_Generic_In_Parameter)\n+                       and then Within_Scope (Input_Id, Current_Scope)\n+                     then\n                         Error_Msg_Name_1 := Chars (Pack_Id);\n                         SPARK_Msg_NE\n                           (\"input item & cannot denote a visible object or \""}]}