{"sha": "f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFiYTZjNWE1MTkzNmFjOTA2NTc4OWIxZmRiNzdmNGUzNWY5MGVmZA==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2019-04-01T13:57:41Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2019-04-01T13:57:41Z"}, "message": "Use single-visitation in variant assignment and swap and relops.\n\nAlso use indices instead of types when checking whether\nvariants hold the same thing.\n* include/std/variant (__do_visit): Add a template parameter\nfor index visitation, invoke with indices if index visitation\nis used.\n(__variant_idx_cookie): New.\n(__visit_with_index): Likewise.\n(_Copy_assign_base::operator=): Do single-visitation with\nan index visitor.\n(_Move_assign_base::operator=): Likewise.\n(_Extra_visit_slot_needed): Adjust.\n(__visit_invoke): Call with indices if it's an index visitor.\n(relops): Do single-visitation with an index visitor.\n(swap): Likewise.\n(__visitor_result_type): New.\n\nFrom-SVN: r270056", "tree": {"sha": "7c62957207e8e4e859e378353dc277ddb6d8ef9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c62957207e8e4e859e378353dc277ddb6d8ef9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37240b0b556c2bcdf94b0a84ff798cd4bd5a316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e37240b0b556c2bcdf94b0a84ff798cd4bd5a316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e37240b0b556c2bcdf94b0a84ff798cd4bd5a316"}], "stats": {"total": 238, "additions": 141, "deletions": 97}, "files": [{"sha": "0b3d0c2d7e807afacd7e9cddb551fdebc9ef505f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "patch": "@@ -1,3 +1,22 @@\n+2019-04-01  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tUse single-visitation in variant assignment and swap and relops.\n+\tAlso use indices instead of types when checking whether\n+\tvariants hold the same thing.\n+\t* include/std/variant (__do_visit): Add a template parameter\n+\tfor index visitation, invoke with indices if index visitation\n+\tis used.\n+\t(__variant_idx_cookie): New.\n+\t(__visit_with_index): Likewise.\n+\t(_Copy_assign_base::operator=): Do single-visitation with\n+\tan index visitor.\n+\t(_Move_assign_base::operator=): Likewise.\n+\t(_Extra_visit_slot_needed): Adjust.\n+\t(__visit_invoke): Call with indices if it's an index visitor.\n+\t(relops): Do single-visitation with an index visitor.\n+\t(swap): Likewise.\n+\t(__visitor_result_type): New.\n+\n 2019-03-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* src/c++17/fs_ops.cc (fs::permissions): Use std::errc::not_supported."}, {"sha": "a7cc2065073cb6bf7b773c20fca13963b6ebff8f", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 122, "deletions": 97, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "patch": "@@ -138,7 +138,7 @@ namespace __variant\n     constexpr variant_alternative_t<_Np, variant<_Types...>> const&&\n     get(const variant<_Types...>&&);\n \n-  template<typename _Visitor, typename... _Variants>\n+  template<bool __use_index=false, typename _Visitor, typename... _Variants>\n     constexpr decltype(auto)\n     __do_visit(_Visitor&& __visitor, _Variants&&... __variants);\n \n@@ -175,6 +175,10 @@ namespace __variant\n \n   // used for raw visitation\n   struct __variant_cookie {};\n+  // used for raw visitation with indices passed in\n+  struct __variant_idx_cookie {};\n+  // a more explanatory name than 'true'\n+  inline constexpr auto __visit_with_index = bool_constant<true>{};\n \n   // _Uninitialized<T> is guaranteed to be a literal type, even if T is not.\n   // We have to do this, because [basic.types]p10.5.3 (n4606) is not implemented\n@@ -570,45 +574,44 @@ namespace __variant\n       operator=(const _Copy_assign_base& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)\n       {\n-\t__do_visit([this, &__rhs](auto&& __this_mem, auto&& __rhs_mem) mutable\n-\t\t   -> __detail::__variant::__variant_cookie\n+\t__do_visit<__visit_with_index>([this](auto&& __rhs_mem,\n+\t\t\t\t\t      auto __rhs_index) mutable\n+\t    -> __detail::__variant::__variant_idx_cookie\n \t  {\n-\t    if constexpr (is_same_v<\n-\t\t\t    remove_reference_t<decltype(__this_mem)>,\n-\t\t\t    remove_reference_t<decltype(__rhs_mem)>>)\n+\t    if constexpr (__rhs_index != variant_npos)\n \t      {\n-\t\tif constexpr (!is_same_v<\n-\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n-\t\t\t        __variant_cookie>)\n-\t\t  __this_mem = __rhs_mem;\n-\t      }\n-\t    else\n-\t      {\n-\t\tif constexpr (!is_same_v<\n-\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n-\t\t\t        __variant_cookie>)\n+\t\tif (this->_M_index == __rhs_index)\n \t\t  {\n-\t\t    using __rhs_type =\n-\t\t      remove_reference_t<decltype(__rhs_mem)>;\n-\t\t    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>\n-\t\t      || !is_nothrow_move_constructible_v<__rhs_type>)\n+\t\t    if constexpr (__rhs_index != variant_npos)\n \t\t      {\n-\t\t\tthis->_M_destructive_copy(__rhs._M_index, __rhs_mem);\n+\t\t\tauto& __this_mem =\n+\t\t\t  __variant::__get<__rhs_index>(*this);\n+\t\t\tif constexpr (is_same_v<\n+\t\t\t\t      remove_reference_t<decltype(__this_mem)>,\n+\t\t\t\t      remove_reference_t<decltype(__rhs_mem)>>)\n+\t\t\t  __this_mem = __rhs_mem;\n \t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    using __rhs_type =\n+\t\t      remove_reference_t<decltype(__rhs_mem)>;\n+\t\t    if constexpr\n+\t\t      (is_nothrow_copy_constructible_v<__rhs_type>\n+\t\t       || !is_nothrow_move_constructible_v<__rhs_type>)\n+\t\t\tthis->_M_destructive_copy(__rhs_index, __rhs_mem);\n \t\t    else\n \t\t      {\n \t\t\tauto __tmp(__rhs_mem);\n-\t\t\tthis->_M_destructive_move(__rhs._M_index,\n+\t\t\tthis->_M_destructive_move(__rhs_index,\n \t\t\t\t\t\t  std::move(__tmp));\n \t\t      }\n \t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    this->_M_reset();\n-\t\t  }\n \t      }\n-\t  return {};\n-\t}, __variant_cast<_Types...>(*this), __variant_cast<_Types...>(__rhs));\n+\t    else\n+\t      this->_M_reset();\n+\t    return {};\n+\t  }, __variant_cast<_Types...>(__rhs));\n \t__glibcxx_assert(this->_M_index == __rhs._M_index);\n \treturn *this;\n       }\n@@ -641,25 +644,32 @@ namespace __variant\n       operator=(_Move_assign_base&& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)\n       {\n-\t__do_visit([this, &__rhs](auto&& __this_mem, auto&& __rhs_mem) mutable\n-\t\t   -> __detail::__variant::__variant_cookie\n+\t__do_visit<__visit_with_index>([this](auto&& __rhs_mem,\n+\t\t\t\t\t      auto __rhs_index) mutable\n+\t    -> __detail::__variant::__variant_idx_cookie\n \t  {\n-\t    if constexpr (is_same_v<\n-\t\t\t    remove_reference_t<decltype(__this_mem)>,\n-\t\t\t    remove_reference_t<decltype(__rhs_mem)>>)\n+\t    if constexpr (__rhs_index != variant_npos)\n \t      {\n-\t\tif constexpr (!is_same_v<\n-\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n-\t\t\t        __variant_cookie>)\n-\t\t  __this_mem = std::move(__rhs_mem);\n+\t\tif (this->_M_index == __rhs_index)\n+\t\t  {\n+\t\t    if constexpr (__rhs_index != variant_npos)\n+\t\t      {\n+\t\t\tauto& __this_mem =\n+\t\t\t  __variant::__get<__rhs_index>(*this);\n+\t\t\tif constexpr (is_same_v<\n+\t\t\t\t      remove_reference_t<decltype(__this_mem)>,\n+\t\t\t\t      remove_reference_t<decltype(__rhs_mem)>>)\n+\t\t\t  __this_mem = std::move(__rhs_mem);\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  this->_M_destructive_move(__rhs_index,\n+\t\t\t\t\t    std::move(__rhs_mem));\n \t      }\n \t    else\n-\t      {\n-\t\tauto __tmp(std::move(__rhs_mem));\n-\t\tthis->_M_destructive_move(__rhs._M_index, std::move(__tmp));\n-\t      }\n-\t  return {};\n-\t}, __variant_cast<_Types...>(*this), __variant_cast<_Types...>(__rhs));\n+\t      this->_M_reset();\n+\t    return {};\n+\t  }, __variant_cast<_Types...>(__rhs));\n \t__glibcxx_assert(this->_M_index == __rhs._M_index);\n \treturn *this;\n       }\n@@ -777,7 +787,8 @@ namespace __variant\n       : bool_constant<__never_valueless<_Types...>()> {};\n \n     static constexpr bool value =\n-      is_same_v<_Maybe_variant_cookie, __variant_cookie>\n+      (is_same_v<_Maybe_variant_cookie, __variant_cookie>\n+       || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)\n       && !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;\n   };\n \n@@ -925,7 +936,13 @@ namespace __variant\n       static constexpr decltype(auto)\n       __visit_invoke(_Visitor&& __visitor, _Variants... __vars)\n       {\n-\treturn std::__invoke(std::forward<_Visitor>(__visitor),\n+\tif constexpr (is_same_v<_Result_type, __variant_idx_cookie>)\n+\t  return std::__invoke(std::forward<_Visitor>(__visitor),\n+\t    __element_by_index_or_cookie<__indices>(\n+\t      std::forward<_Variants>(__vars))...,\n+\t      integral_constant<size_t, __indices>()...);\n+\telse\n+\t  return std::__invoke(std::forward<_Visitor>(__visitor),\n \t    __element_by_index_or_cookie<__indices>(\n \t      std::forward<_Variants>(__vars))...);\n       }\n@@ -1082,25 +1099,25 @@ namespace __variant\n \t\t\t\t const variant<_Types...>& __rhs) \\\n     { \\\n       bool __ret = true; \\\n-      __do_visit([&__ret, &__lhs, __rhs] \\\n-\t\t (auto&& __this_mem, auto&& __rhs_mem) mutable\t\\\n-\t\t   -> __detail::__variant::__variant_cookie \\\n+      __do_visit<__detail::__variant::__visit_with_index>( \\\n+        [&__ret, &__lhs, __rhs] \\\n+\t\t (auto&& __rhs_mem, auto __rhs_index) mutable \\\n+\t\t   -> __detail::__variant::__variant_idx_cookie \\\n         { \\\n-\t  if constexpr (!is_same_v< \\\n-\t\t\t  remove_reference_t<decltype(__this_mem)>, \\\n-\t\t\t  remove_reference_t<decltype(__rhs_mem)>> \\\n-\t\t\t|| is_same_v<decltype(__this_mem), \\\n-\t\t\t             __detail::__variant::__variant_cookie>) \\\n-\t    __ret = (__lhs.index() + 1) __OP (__rhs.index() + 1); \\\n-\t  else if constexpr (is_same_v< \\\n-\t\t\t       remove_reference_t<decltype(__this_mem)>, \\\n-\t\t\t       remove_reference_t<decltype(__rhs_mem)>> \\\n-                             && !is_same_v< \\\n-\t                          remove_reference_t<decltype(__this_mem)>, \\\n-\t\t\t\t  __detail::__variant::__variant_cookie>) \\\n-\t    __ret = __this_mem __OP __rhs_mem; \\\n+\t  if constexpr (__rhs_index != variant_npos) \\\n+\t    { \\\n+\t      if (__lhs.index() == __rhs_index) \\\n+\t        { \\\n+\t\t  auto& __this_mem = std::get<__rhs_index>(__lhs);\t\\\n+                  __ret = __this_mem __OP __rhs_mem; \\\n+                } \\\n+\t      else \\\n+\t\t__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \\\n+            } \\\n+          else \\\n+            __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \\\n \t  return {}; \\\n-\t}, __lhs, __rhs); \\\n+\t}, __rhs); \\\n       return __ret; \\\n     } \\\n \\\n@@ -1402,51 +1419,47 @@ namespace __variant\n       noexcept((__is_nothrow_swappable<_Types>::value && ...)\n \t       && is_nothrow_move_constructible_v<variant>)\n       {\n-\t__do_visit([this, &__rhs](auto&& __this_mem, auto&& __rhs_mem) mutable\n-\t\t   -> __detail::__variant::__variant_cookie\n+\t__do_visit<__detail::__variant::__visit_with_index>(\n+\t  [this, &__rhs](auto&& __rhs_mem,\n+\t\t\t auto __rhs_index) mutable\n+\t    -> __detail::__variant::__variant_idx_cookie\n \t  {\n-\t    if constexpr (is_same_v<\n-\t\t\t    remove_reference_t<decltype(__this_mem)>,\n-\t\t\t    remove_reference_t<decltype(__rhs_mem)>>)\n+\t    if constexpr (__rhs_index != variant_npos)\n \t      {\n-\t\tif constexpr (!is_same_v<\n-\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n-\t\t\t        __detail::__variant::__variant_cookie>)\n+\t\tif (this->index() == __rhs_index)\n \t\t  {\n+\t\t    auto& __this_mem =\n+\t\t      std::get<__rhs_index>(*this);\n \t\t    using std::swap;\n \t\t    swap(__this_mem, __rhs_mem);\n \t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (this->index() != variant_npos)\n+\t\t      {\n+\t\t\tauto __tmp(std::move(__rhs_mem));\n+\t\t\t__rhs = std::move(*this);\n+\t\t\tthis->_M_destructive_move(__rhs_index,\n+\t\t\t\t\t\t  std::move(__tmp));\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tthis->_M_destructive_move(__rhs_index,\n+\t\t\t\t\t\t  std::move(__rhs_mem));\n+\t\t\t__rhs._M_reset();\n+\t\t      }\n+\t\t  }\n \t      }\n \t    else\n \t      {\n-\t\tif constexpr (is_same_v<\n-\t\t\t        remove_reference_t<decltype(__this_mem)>,\n-\t\t\t        __detail::__variant::__variant_cookie>)\n+\t\tif (this->index() != variant_npos)\n \t\t  {\n-\t\t    this->_M_destructive_move(__rhs.index(),\n-\t\t\t\t\t      std::move(__rhs_mem));\n-\t\t    __rhs._M_reset();\n-\t\t  }\n-\t\telse if constexpr (is_same_v<\n-\t\t\t             remove_reference_t<decltype(__rhs_mem)>,\n-\t\t\t             __detail::__variant::__variant_cookie>)\n-\t\t  {\n-\t\t    __rhs._M_destructive_move(this->index(),\n-\t\t\t\t\t      std::move(__this_mem));\n+\t\t    __rhs = std::move(*this);\n \t\t    this->_M_reset();\n \t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    auto __tmp(std::move(__rhs_mem));\n-\t\t    auto __idx = __rhs.index();\n-\t\t    __rhs._M_destructive_move(this->index(),\n-\t\t\t\t\t      std::move(__this_mem));\n-\t\t    this->_M_destructive_move(__idx,\n-\t\t\t\t\t      std::move(__tmp));\n-\t\t  }\n \t      }\n-\t  return {};\n-\t}, *this, __rhs);\n+\t    return {};\n+\t  }, __rhs);\n       }\n \n     private:\n@@ -1523,13 +1536,25 @@ namespace __variant\n       return __detail::__variant::__get<_Np>(std::move(__v));\n     }\n \n-  template<typename _Visitor, typename... _Variants>\n+  template<bool __use_index, typename _Visitor, typename... _Variants>\n+    decltype(auto)\n+    __visitor_result_type(_Visitor&& __visitor, _Variants&&... __variants)\n+    {\n+      if constexpr(__use_index)\n+        return __detail::__variant::__variant_idx_cookie{};\n+      else\n+\treturn std::forward<_Visitor>(__visitor)(\n+\t  std::get<0>(std::forward<_Variants>(__variants))...);\n+    }\n+\n+  template<bool __use_index, typename _Visitor, typename... _Variants>\n     constexpr decltype(auto)\n     __do_visit(_Visitor&& __visitor, _Variants&&... __variants)\n     {\n       using _Result_type =\n-\tdecltype(std::forward<_Visitor>(__visitor)(\n-\t    std::get<0>(std::forward<_Variants>(__variants))...));\n+\tdecltype(__visitor_result_type<__use_index>(\n+\t           std::forward<_Visitor>(__visitor),\n+\t           std::forward<_Variants>(__variants)...));\n \n       constexpr auto& __vtable = __detail::__variant::__gen_vtable<\n \t_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;"}]}