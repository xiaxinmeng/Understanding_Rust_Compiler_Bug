{"sha": "4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlOGM1ZGVhNTNkODA3MzZiOWMwYmE2ZmFhNzQzMGVkNjVlZDM2NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-08-10T19:07:30Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-08-10T19:07:30Z"}, "message": "PR c++/80452 - Core 1579, implicit move semantics on return/throw\n\n\t* cp-tree.h (LOOKUP_PREFER_RVALUE): Now means that we've already\n\ttentatively changed the lvalue to an rvalue.\n\t* call.c (reference_binding): Remove LOOKUP_PREFER_RVALUE handling.\n\t(build_over_call): If LOOKUP_PREFER_RVALUE, check that the first\n\tparameter is an rvalue reference.\n\t* except.c (build_throw): Do maybe-rvalue overload resolution twice.\n\t* typeck.c (check_return_expr): Likewise.\n\nFrom-SVN: r251035", "tree": {"sha": "35dee6c3dcd6215feee0eca6d281f1e78ffc2975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35dee6c3dcd6215feee0eca6d281f1e78ffc2975"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0a10c6defa8e52d7b43aff169115028f07fb744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a10c6defa8e52d7b43aff169115028f07fb744", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a10c6defa8e52d7b43aff169115028f07fb744"}], "stats": {"total": 111, "additions": 92, "deletions": 19}, "files": [{"sha": "bc4eaa20b46feb7d94de8ae8ed46ddb3bca2e225", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "patch": "@@ -1,3 +1,14 @@\n+2017-08-10  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/80452 - Core 1579, implicit move semantics on return/throw\n+\t* cp-tree.h (LOOKUP_PREFER_RVALUE): Now means that we've already\n+\ttentatively changed the lvalue to an rvalue.\n+\t* call.c (reference_binding): Remove LOOKUP_PREFER_RVALUE handling.\n+\t(build_over_call): If LOOKUP_PREFER_RVALUE, check that the first\n+\tparameter is an rvalue reference.\n+\t* except.c (build_throw): Do maybe-rvalue overload resolution twice.\n+\t* typeck.c (check_return_expr): Likewise.\n+\n 2017-08-10  David Malcolm  <dmalcolm@redhat.com>\n \n \t* parser.c (cp_parser_error): Update for new param to"}, {"sha": "37902991f3f8620c2ab8833c4cbeb6ffcae7468e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "patch": "@@ -101,7 +101,7 @@ struct conversion {\n   /* If KIND is ck_ref_bind, true when either an lvalue reference is\n      being bound to an lvalue expression or an rvalue reference is\n      being bound to an rvalue expression.  If KIND is ck_rvalue,\n-     true when we should treat an lvalue as an rvalue (12.8p33).  If\n+     true when we are treating an lvalue as an rvalue (12.8p33).  If\n      KIND is ck_base, always false.  */\n   BOOL_BITFIELD rvaluedness_matches_p: 1;\n   BOOL_BITFIELD check_narrowing: 1;\n@@ -1161,6 +1161,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t}\n       conv = build_conv (ck_rvalue, from, conv);\n       if (flags & LOOKUP_PREFER_RVALUE)\n+\t/* Tell convert_like_real to set LOOKUP_PREFER_RVALUE.  */\n \tconv->rvaluedness_matches_p = true;\n     }\n \n@@ -1629,11 +1630,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n       conv = build_identity_conv (tfrom, expr);\n       conv = direct_reference_binding (rto, conv);\n \n-      if (flags & LOOKUP_PREFER_RVALUE)\n-\t/* The top-level caller requested that we pretend that the lvalue\n-\t   be treated as an rvalue.  */\n-\tconv->rvaluedness_matches_p = TYPE_REF_IS_RVALUE (rto);\n-      else if (TREE_CODE (rfrom) == REFERENCE_TYPE)\n+      if (TREE_CODE (rfrom) == REFERENCE_TYPE)\n \t/* Handle rvalue reference to function properly.  */\n \tconv->rvaluedness_matches_p\n \t  = (TYPE_REF_IS_RVALUE (rto) == TYPE_REF_IS_RVALUE (rfrom));\n@@ -1659,8 +1656,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n       /* Don't allow binding of lvalues (other than function lvalues) to\n \t rvalue references.  */\n       if (is_lvalue && TYPE_REF_IS_RVALUE (rto)\n-\t  && TREE_CODE (to) != FUNCTION_TYPE\n-          && !(flags & LOOKUP_PREFER_RVALUE))\n+\t  && TREE_CODE (to) != FUNCTION_TYPE)\n \tconv->bad_p = true;\n \n       /* Nor the reverse.  */\n@@ -6917,6 +6913,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       else\n \tflags |= LOOKUP_ONLYCONVERTING;\n       if (convs->rvaluedness_matches_p)\n+\t/* standard_conversion got LOOKUP_PREFER_RVALUE.  */\n \tflags |= LOOKUP_PREFER_RVALUE;\n       if (TREE_CODE (expr) == TARGET_EXPR\n \t  && TARGET_EXPR_LIST_INIT_P (expr))\n@@ -7716,6 +7713,19 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  ++arg_index;\n \t  parm = TREE_CHAIN (parm);\n \t}\n+\n+      if (flags & LOOKUP_PREFER_RVALUE)\n+\t{\n+\t  /* The implicit move specified in 15.8.3/3 fails \"...if the type of\n+\t     the first parameter of the selected constructor is not an rvalue\n+\t     reference to the object\u2019s type (possibly cv-qualified)....\" */\n+\t  gcc_assert (!(complain & tf_error));\n+\t  tree ptype = convs[0]->type;\n+\t  if (TREE_CODE (ptype) != REFERENCE_TYPE\n+\t      || !TYPE_REF_IS_RVALUE (ptype)\n+\t      || CONVERSION_RANK (convs[0]) > cr_exact)\n+\t    return error_mark_node;\n+\t}\n     }\n   /* Bypass access control for 'this' parameter.  */\n   else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)"}, {"sha": "6c4153d558b13c37b77b17230a21a9248ca9aefa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "patch": "@@ -5296,7 +5296,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n    (Normally, these entities are registered in the symbol table, but\n    not found by lookup.)  */\n #define LOOKUP_HIDDEN (LOOKUP_PREFER_NAMESPACES << 1)\n-/* Prefer that the lvalue be treated as an rvalue.  */\n+/* We're trying to treat an lvalue as an rvalue.  */\n #define LOOKUP_PREFER_RVALUE (LOOKUP_HIDDEN << 1)\n /* We're inside an init-list, so narrowing conversions are ill-formed.  */\n #define LOOKUP_NO_NARROWING (LOOKUP_PREFER_RVALUE << 1)"}, {"sha": "b25b91b97bec129f4b553f6cddaef9e272865aeb", "filename": "gcc/cp/except.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "patch": "@@ -665,6 +665,7 @@ build_throw (tree exp)\n \t{\n \t  int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n \t  vec<tree, va_gc> *exp_vec;\n+\t  bool converted = false;\n \n \t  /* Under C++0x [12.8/16 class.copy], a thrown lvalue is sometimes\n \t     treated as an rvalue for the purposes of overload resolution\n@@ -675,14 +676,31 @@ build_throw (tree exp)\n \t      && ! TREE_STATIC (exp)\n \t      /* The variable must not have the `volatile' qualifier.  */\n \t      && !(cp_type_quals (TREE_TYPE (exp)) & TYPE_QUAL_VOLATILE))\n-\t    flags = flags | LOOKUP_PREFER_RVALUE;\n+\t    {\n+\t      tree moved = move (exp);\n+\t      exp_vec = make_tree_vector_single (moved);\n+\t      moved = (build_special_member_call\n+\t\t       (object, complete_ctor_identifier, &exp_vec,\n+\t\t\tTREE_TYPE (object), flags|LOOKUP_PREFER_RVALUE,\n+\t\t\ttf_none));\n+\t      release_tree_vector (exp_vec);\n+\t      if (moved != error_mark_node)\n+\t\t{\n+\t\t  exp = moved;\n+\t\t  converted = true;\n+\t\t}\n+\t    }\n \n \t  /* Call the copy constructor.  */\n-\t  exp_vec = make_tree_vector_single (exp);\n-\t  exp = (build_special_member_call\n-\t\t (object, complete_ctor_identifier, &exp_vec,\n-\t\t  TREE_TYPE (object), flags, tf_warning_or_error));\n-\t  release_tree_vector (exp_vec);\n+\t  if (!converted)\n+\t    {\n+\t      exp_vec = make_tree_vector_single (exp);\n+\t      exp = (build_special_member_call\n+\t\t     (object, complete_ctor_identifier, &exp_vec,\n+\t\t      TREE_TYPE (object), flags, tf_warning_or_error));\n+\t      release_tree_vector (exp_vec);\n+\t    }\n+\n \t  if (exp == error_mark_node)\n \t    {\n \t      error (\"  in thrown expression\");"}, {"sha": "a5a363bc9424c13281e97449633fca0ae2429413", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "patch": "@@ -9156,21 +9156,33 @@ check_return_expr (tree retval, bool *no_warning)\n \n          Note that these conditions are similar to, but not as strict as,\n \t the conditions for the named return value optimization.  */\n+      bool converted = false;\n       if ((cxx_dialect != cxx98)\n           && ((VAR_P (retval) && !DECL_HAS_VALUE_EXPR_P (retval))\n \t      || TREE_CODE (retval) == PARM_DECL)\n \t  && DECL_CONTEXT (retval) == current_function_decl\n \t  && !TREE_STATIC (retval)\n \t  /* This is only interesting for class type.  */\n \t  && CLASS_TYPE_P (functype))\n-\tflags = flags | LOOKUP_PREFER_RVALUE;\n+\t{\n+\t  tree moved = move (retval);\n+\t  moved = convert_for_initialization\n+\t    (NULL_TREE, functype, moved, flags|LOOKUP_PREFER_RVALUE,\n+\t     ICR_RETURN, NULL_TREE, 0, tf_none);\n+\t  if (moved != error_mark_node)\n+\t    {\n+\t      retval = moved;\n+\t      converted = true;\n+\t    }\n+\t}\n \n       /* First convert the value to the function's return type, then\n \t to the type of return value's location to handle the\n \t case that functype is smaller than the valtype.  */\n-      retval = convert_for_initialization\n-\t(NULL_TREE, functype, retval, flags, ICR_RETURN, NULL_TREE, 0,\n-         tf_warning_or_error);\n+      if (!converted)\n+\tretval = convert_for_initialization\n+\t  (NULL_TREE, functype, retval, flags, ICR_RETURN, NULL_TREE, 0,\n+\t   tf_warning_or_error);\n       retval = convert (valtype, retval);\n \n       /* If the conversion failed, treat this just like `return;'.  */"}, {"sha": "dc2b313fee63e8309d3e570e09ef9213689d4d65", "filename": "gcc/testsuite/g++.dg/cpp0x/move-return1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce8c5dea53d80736b9c0ba6faa7430ed65ed365/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return1.C?ref=4ce8c5dea53d80736b9c0ba6faa7430ed65ed365", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/80452\n+// { dg-do compile { target c++11 } }\n+\n+template<typename> struct check { };\n+template<typename T> struct check<T&>;\n+\n+struct A {\n+  A() = default;\n+  A(A&&) = default;\n+  A(const A&) = delete;\n+};\n+\n+template <class T>\n+struct B {\n+  template <class U> B(U&&) { check<U> u; }\n+};\n+\n+B<A> f()\n+{\n+  A a;\n+  return a;\n+}"}]}