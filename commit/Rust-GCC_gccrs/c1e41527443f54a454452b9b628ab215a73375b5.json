{"sha": "c1e41527443f54a454452b9b628ab215a73375b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlNDE1Mjc0NDNmNTRhNDU0NDUyYjliNjI4YWIyMTVhNzMzNzViNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-03-17T16:20:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-03-17T16:20:16Z"}, "message": "Core 1212\n\n\tCore 1212\n\t* semantics.c (finish_decltype_type): Return T&& for xvalue.\n\t* typeck.c (unlowered_expr_type): Preserve cv-quals.\n\nFrom-SVN: r171104", "tree": {"sha": "efff327edaa7e3722b06262633cad9b924af6ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efff327edaa7e3722b06262633cad9b924af6ac8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1e41527443f54a454452b9b628ab215a73375b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e41527443f54a454452b9b628ab215a73375b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1e41527443f54a454452b9b628ab215a73375b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e41527443f54a454452b9b628ab215a73375b5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "547206a4e530360a06679894c2a9f2168bf5f943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/547206a4e530360a06679894c2a9f2168bf5f943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/547206a4e530360a06679894c2a9f2168bf5f943"}], "stats": {"total": 145, "additions": 55, "deletions": 90}, "files": [{"sha": "f710f7a7c6d30ad1df1dff93a109d1d9145b9200", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c1e41527443f54a454452b9b628ab215a73375b5", "patch": "@@ -1,5 +1,9 @@\n 2011-03-17  Jason Merrill  <jason@redhat.com>\n \n+\tCore 1212\n+\t* semantics.c (finish_decltype_type): Return T&& for xvalue.\n+\t* typeck.c (unlowered_expr_type): Preserve cv-quals.\n+\n \tPR c++/48166\n \t* decl.c (revert_static_member_fn): Strip function-cv-quals.\n "}, {"sha": "cafca56fbba50e581df672023bb7818e47e28f04", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 28, "deletions": 86, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c1e41527443f54a454452b9b628ab215a73375b5", "patch": "@@ -4787,7 +4787,6 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n \t  && processing_template_decl\n \t  && TREE_CODE (expr) == COMPONENT_REF))\n     {\n-    treat_as_dependent:\n       type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;\n       DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type)\n@@ -4899,91 +4898,34 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n     }\n   else\n     {\n-      /* Expressions of reference type are sometimes wrapped in\n-         INDIRECT_REFs.  INDIRECT_REFs are just internal compiler\n-         representation, not part of the language, so we have to look\n-         through them.  */\n-      if (TREE_CODE (expr) == INDIRECT_REF\n-          && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n-  \t  == REFERENCE_TYPE)\n-        expr = TREE_OPERAND (expr, 0);\n-\n-      if (TREE_CODE (expr) == CALL_EXPR)\n-        {\n-          /* If e is a function call (5.2.2 [expr.call]) or an\n-           invocation of an overloaded operator (parentheses around e\n-           are ignored), decltype(e) is defined as the return type of\n-           that function.  */\n-          tree fndecl = get_callee_fndecl (expr);\n-          if (fndecl && fndecl != error_mark_node)\n-            type = TREE_TYPE (TREE_TYPE (fndecl));\n-          else \n-            {\n-              tree target_type = TREE_TYPE (CALL_EXPR_FN (expr));\n-              if ((TREE_CODE (target_type) == REFERENCE_TYPE\n-                   || TREE_CODE (target_type) == POINTER_TYPE)\n-                  && (TREE_CODE (TREE_TYPE (target_type)) == FUNCTION_TYPE\n-                      || TREE_CODE (TREE_TYPE (target_type)) == METHOD_TYPE))\n-                type = TREE_TYPE (TREE_TYPE (target_type));\n-\t      else if (processing_template_decl)\n-\t\t/* Within a template finish_call_expr doesn't resolve\n-\t\t   CALL_EXPR_FN, so even though this decltype isn't really\n-\t\t   dependent let's defer resolving it.  */\n-\t\tgoto treat_as_dependent;\n-              else\n-                sorry (\"unable to determine the declared type of expression %<%E%>\",\n-                       expr);\n-            }\n-        }\n-      else \n-        {\n-          type = is_bitfield_expr_with_lowered_type (expr);\n-          if (type)\n-            {\n-              /* Bitfields are special, because their type encodes the\n-                 number of bits they store.  If the expression referenced a\n-                 bitfield, TYPE now has the declared type of that\n-                 bitfield.  */\n-              type = cp_build_qualified_type (type, \n-                                              cp_type_quals (TREE_TYPE (expr)));\n-              \n-              if (real_lvalue_p (expr))\n-                type = build_reference_type (type);\n-            }\n-\t  /* Within a lambda-expression:\n-\n-\t     Every occurrence of decltype((x)) where x is a possibly\n-\t     parenthesized id-expression that names an entity of\n-\t     automatic storage duration is treated as if x were\n-\t     transformed into an access to a corresponding data member\n-\t     of the closure type that would have been declared if x\n-\t     were a use of the denoted entity.  */\n-\t  else if (outer_automatic_var_p (expr)\n-\t\t   && current_function_decl\n-\t\t   && LAMBDA_FUNCTION_P (current_function_decl))\n-\t    type = capture_decltype (expr);\n-          else\n-            {\n-              /* Otherwise, where T is the type of e, if e is an lvalue,\n-                 decltype(e) is defined as T&, otherwise decltype(e) is\n-                 defined as T.  */\n-              type = TREE_TYPE (expr);\n-              if (type == error_mark_node)\n-                return error_mark_node;\n-              else if (expr == current_class_ptr)\n-                /* If the expression is just \"this\", we want the\n-                   cv-unqualified pointer for the \"this\" type.  */\n-                type = TYPE_MAIN_VARIANT (type);\n-              else if (real_lvalue_p (expr))\n-                {\n-                  if (TREE_CODE (type) != REFERENCE_TYPE\n-\t\t      || TYPE_REF_IS_RVALUE (type))\n-                    type = build_reference_type (non_reference (type));\n-                }\n-              else\n-                type = non_reference (type);\n-            }\n-        }\n+      /* Within a lambda-expression:\n+\n+\t Every occurrence of decltype((x)) where x is a possibly\n+\t parenthesized id-expression that names an entity of\n+\t automatic storage duration is treated as if x were\n+\t transformed into an access to a corresponding data member\n+\t of the closure type that would have been declared if x\n+\t were a use of the denoted entity.  */\n+      if (outer_automatic_var_p (expr)\n+\t  && current_function_decl\n+\t  && LAMBDA_FUNCTION_P (current_function_decl))\n+\ttype = capture_decltype (expr);\n+      else if (error_operand_p (expr))\n+\ttype = error_mark_node;\n+      else if (expr == current_class_ptr)\n+\t/* If the expression is just \"this\", we want the\n+\t   cv-unqualified pointer for the \"this\" type.  */\n+\ttype = TYPE_MAIN_VARIANT (TREE_TYPE (expr));\n+      else\n+\t{\n+\t  /* Otherwise, where T is the type of e, if e is an lvalue,\n+\t     decltype(e) is defined as T&; if an xvalue, T&&; otherwise, T. */\n+\t  cp_lvalue_kind clk = lvalue_kind (expr);\n+\t  type = unlowered_expr_type (expr);\n+\t  gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);\n+\t  if (clk != clk_none && !(clk & clk_class))\n+\t    type = cp_build_reference_type (type, (clk & clk_rvalueref));\n+\t}\n     }\n \n   if (!type || type == unknown_type_node)"}, {"sha": "955ff578f11fd17335eb9ef45a34efa3b05293fe", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c1e41527443f54a454452b9b628ab215a73375b5", "patch": "@@ -1768,10 +1768,13 @@ tree\n unlowered_expr_type (const_tree exp)\n {\n   tree type;\n+  tree etype = TREE_TYPE (exp);\n \n   type = is_bitfield_expr_with_lowered_type (exp);\n-  if (!type)\n-    type = TREE_TYPE (exp);\n+  if (type)\n+    type = cp_build_qualified_type (type, cp_type_quals (etype));\n+  else\n+    type = etype;\n \n   return type;\n }"}, {"sha": "29d38239df3197db212206802ed45fe85dfd5b43", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c1e41527443f54a454452b9b628ab215a73375b5", "patch": "@@ -1,3 +1,8 @@\n+2011-03-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/decltype-1212.C: New.\n+\t* g++.dg/cpp0x/rv-return.C: Adjust expected type.\n+\n 2011-03-17  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/parse/memfnquals1.C: New."}, {"sha": "38393d3b874bdbf1d9e46b59d096f6b05ed3985d", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype-1212.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-1212.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-1212.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-1212.C?ref=c1e41527443f54a454452b9b628ab215a73375b5", "patch": "@@ -0,0 +1,11 @@\n+// Core 1212\n+// { dg-options -std=c++0x }\n+\n+template <class T, class U> struct assert_same_type;\n+template <class T> struct assert_same_type<T,T> {};\n+\n+int main()\n+{\n+  int i;\n+  assert_same_type<int&&,decltype(static_cast<int&&>(i))>();\n+}"}, {"sha": "3ab659833eab4d9b0df1eb075d72488648cd7845", "filename": "gcc/testsuite/g++.dg/cpp0x/rv-return.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv-return.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e41527443f54a454452b9b628ab215a73375b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv-return.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv-return.C?ref=c1e41527443f54a454452b9b628ab215a73375b5", "patch": "@@ -7,12 +7,12 @@ template<typename T> struct same_type<T, T> {};\n int const f() { return 0; }\n \n int &&r = f(); // binding \"int&&\" to \"int\" should succeed\n-same_type<decltype(f()), int const> s1;\n+same_type<decltype(f()), int> s1;\n same_type<decltype(0,f()), int> s2;\n \n template <class T>\n T const g() { return 0; }\n \n int &&r2 = g<int>();\n-same_type<decltype(g<int>()), int const> s3;\n+same_type<decltype(g<int>()), int> s3;\n same_type<decltype(0,g<int>()), int> s4;"}]}