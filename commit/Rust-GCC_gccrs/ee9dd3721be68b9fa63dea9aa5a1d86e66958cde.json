{"sha": "ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5ZGQzNzIxYmU2OGI5ZmE2M2RlYTlhYTVhMWQ4NmU2Njk1OGNkZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T14:42:40Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T14:42:40Z"}, "message": "Initial revision\n\nFrom-SVN: r26263", "tree": {"sha": "d96801a16fdf03a5682ef98730fe333a46eef944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d96801a16fdf03a5682ef98730fe333a46eef944"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/comments", "author": null, "committer": null, "parents": [{"sha": "140fa895c6b859f827fc4437b91775a82cd105fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140fa895c6b859f827fc4437b91775a82cd105fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/140fa895c6b859f827fc4437b91775a82cd105fb"}], "stats": {"total": 173494, "additions": 173494, "deletions": 0}, "files": [{"sha": "161a3d1d47b94f5d092b4c5fa316007c6f22fe81", "filename": "libjava/COPYING.LIB", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FCOPYING.LIB", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FCOPYING.LIB", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FCOPYING.LIB?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,482 @@\n+\t\t  GNU LIBRARY GENERAL PUBLIC LICENSE\n+\t\t       Version 2, June 1991\n+\n+ Copyright (C) 1991 Free Software Foundation, Inc.\n+ 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA\n+ Everyone is permitted to copy and distribute verbatim copies\n+ of this license document, but changing it is not allowed.\n+\n+[This is the first released version of the library GPL.  It is\n+ numbered 2 because it goes with version 2 of the ordinary GPL.]\n+\n+\t\t\t    Preamble\n+\n+  The licenses for most software are designed to take away your\n+freedom to share and change it.  By contrast, the GNU General Public\n+Licenses are intended to guarantee your freedom to share and change\n+free software--to make sure the software is free for all its users.\n+\n+  This license, the Library General Public License, applies to some\n+specially designated Free Software Foundation software, and to any\n+other libraries whose authors decide to use it.  You can use it for\n+your libraries, too.\n+\n+  When we speak of free software, we are referring to freedom, not\n+price.  Our General Public Licenses are designed to make sure that you\n+have the freedom to distribute copies of free software (and charge for\n+this service if you wish), that you receive source code or can get it\n+if you want it, that you can change the software or use pieces of it\n+in new free programs; and that you know you can do these things.\n+\n+  To protect your rights, we need to make restrictions that forbid\n+anyone to deny you these rights or to ask you to surrender the rights.\n+These restrictions translate to certain responsibilities for you if\n+you distribute copies of the library, or if you modify it.\n+\n+  For example, if you distribute copies of the library, whether gratis\n+or for a fee, you must give the recipients all the rights that we gave\n+you.  You must make sure that they, too, receive or can get the source\n+code.  If you link a program with the library, you must provide\n+complete object files to the recipients so that they can relink them\n+with the library, after making changes to the library and recompiling\n+it.  And you must show them these terms so they know their rights.\n+\n+  Our method of protecting your rights has two steps: (1) copyright\n+the library, and (2) offer you this license which gives you legal\n+permission to copy, distribute and/or modify the library.\n+\n+  Also, for each distributor's protection, we want to make certain\n+that everyone understands that there is no warranty for this free\n+library.  If the library is modified by someone else and passed on, we\n+want its recipients to know that what they have is not the original\n+version, so that any problems introduced by others will not reflect on\n+the original authors' reputations.\n+\f\n+  Finally, any free program is threatened constantly by software\n+patents.  We wish to avoid the danger that companies distributing free\n+software will individually obtain patent licenses, thus in effect\n+transforming the program into proprietary software.  To prevent this,\n+we have made it clear that any patent must be licensed for everyone's\n+free use or not licensed at all.\n+\n+  Most GNU software, including some libraries, is covered by the ordinary\n+GNU General Public License, which was designed for utility programs.  This\n+license, the GNU Library General Public License, applies to certain\n+designated libraries.  This license is quite different from the ordinary\n+one; be sure to read it in full, and don't assume that anything in it is\n+the same as in the ordinary license.\n+\n+  The reason we have a separate public license for some libraries is that\n+they blur the distinction we usually make between modifying or adding to a\n+program and simply using it.  Linking a program with a library, without\n+changing the library, is in some sense simply using the library, and is\n+analogous to running a utility program or application program.  However, in\n+a textual and legal sense, the linked executable is a combined work, a\n+derivative of the original library, and the ordinary General Public License\n+treats it as such.\n+\n+  Because of this blurred distinction, using the ordinary General\n+Public License for libraries did not effectively promote software\n+sharing, because most developers did not use the libraries.  We\n+concluded that weaker conditions might promote sharing better.\n+\n+  However, unrestricted linking of non-free programs would deprive the\n+users of those programs of all benefit from the free status of the\n+libraries themselves.  This Library General Public License is intended to\n+permit developers of non-free programs to use free libraries, while\n+preserving your freedom as a user of such programs to change the free\n+libraries that are incorporated in them.  (We have not seen how to achieve\n+this as regards changes in header files, but we have achieved it as regards\n+changes in the actual functions of the Library.)  The hope is that this\n+will lead to faster development of free libraries.\n+\n+  The precise terms and conditions for copying, distribution and\n+modification follow.  Pay close attention to the difference between a\n+\"work based on the library\" and a \"work that uses the library\".  The\n+former contains code derived from the library, while the latter only\n+works together with the library.\n+\n+  Note that it is possible for a library to be covered by the ordinary\n+General Public License rather than by this special one.\n+\f\n+\t\t  GNU LIBRARY GENERAL PUBLIC LICENSE\n+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n+\n+  0. This License Agreement applies to any software library which\n+contains a notice placed by the copyright holder or other authorized\n+party saying it may be distributed under the terms of this Library\n+General Public License (also called \"this License\").  Each licensee is\n+addressed as \"you\".\n+\n+  A \"library\" means a collection of software functions and/or data\n+prepared so as to be conveniently linked with application programs\n+(which use some of those functions and data) to form executables.\n+\n+  The \"Library\", below, refers to any such software library or work\n+which has been distributed under these terms.  A \"work based on the\n+Library\" means either the Library or any derivative work under\n+copyright law: that is to say, a work containing the Library or a\n+portion of it, either verbatim or with modifications and/or translated\n+straightforwardly into another language.  (Hereinafter, translation is\n+included without limitation in the term \"modification\".)\n+\n+  \"Source code\" for a work means the preferred form of the work for\n+making modifications to it.  For a library, complete source code means\n+all the source code for all modules it contains, plus any associated\n+interface definition files, plus the scripts used to control compilation\n+and installation of the library.\n+\n+  Activities other than copying, distribution and modification are not\n+covered by this License; they are outside its scope.  The act of\n+running a program using the Library is not restricted, and output from\n+such a program is covered only if its contents constitute a work based\n+on the Library (independent of the use of the Library in a tool for\n+writing it).  Whether that is true depends on what the Library does\n+and what the program that uses the Library does.\n+  \n+  1. You may copy and distribute verbatim copies of the Library's\n+complete source code as you receive it, in any medium, provided that\n+you conspicuously and appropriately publish on each copy an\n+appropriate copyright notice and disclaimer of warranty; keep intact\n+all the notices that refer to this License and to the absence of any\n+warranty; and distribute a copy of this License along with the\n+Library.\n+\n+  You may charge a fee for the physical act of transferring a copy,\n+and you may at your option offer warranty protection in exchange for a\n+fee.\n+\f\n+  2. You may modify your copy or copies of the Library or any portion\n+of it, thus forming a work based on the Library, and copy and\n+distribute such modifications or work under the terms of Section 1\n+above, provided that you also meet all of these conditions:\n+\n+    a) The modified work must itself be a software library.\n+\n+    b) You must cause the files modified to carry prominent notices\n+    stating that you changed the files and the date of any change.\n+\n+    c) You must cause the whole of the work to be licensed at no\n+    charge to all third parties under the terms of this License.\n+\n+    d) If a facility in the modified Library refers to a function or a\n+    table of data to be supplied by an application program that uses\n+    the facility, other than as an argument passed when the facility\n+    is invoked, then you must make a good faith effort to ensure that,\n+    in the event an application does not supply such function or\n+    table, the facility still operates, and performs whatever part of\n+    its purpose remains meaningful.\n+\n+    (For example, a function in a library to compute square roots has\n+    a purpose that is entirely well-defined independent of the\n+    application.  Therefore, Subsection 2d requires that any\n+    application-supplied function or table used by this function must\n+    be optional: if the application does not supply it, the square\n+    root function must still compute square roots.)\n+\n+These requirements apply to the modified work as a whole.  If\n+identifiable sections of that work are not derived from the Library,\n+and can be reasonably considered independent and separate works in\n+themselves, then this License, and its terms, do not apply to those\n+sections when you distribute them as separate works.  But when you\n+distribute the same sections as part of a whole which is a work based\n+on the Library, the distribution of the whole must be on the terms of\n+this License, whose permissions for other licensees extend to the\n+entire whole, and thus to each and every part regardless of who wrote\n+it.\n+\n+Thus, it is not the intent of this section to claim rights or contest\n+your rights to work written entirely by you; rather, the intent is to\n+exercise the right to control the distribution of derivative or\n+collective works based on the Library.\n+\n+In addition, mere aggregation of another work not based on the Library\n+with the Library (or with a work based on the Library) on a volume of\n+a storage or distribution medium does not bring the other work under\n+the scope of this License.\n+\n+  3. You may opt to apply the terms of the ordinary GNU General Public\n+License instead of this License to a given copy of the Library.  To do\n+this, you must alter all the notices that refer to this License, so\n+that they refer to the ordinary GNU General Public License, version 2,\n+instead of to this License.  (If a newer version than version 2 of the\n+ordinary GNU General Public License has appeared, then you can specify\n+that version instead if you wish.)  Do not make any other change in\n+these notices.\n+\f\n+  Once this change is made in a given copy, it is irreversible for\n+that copy, so the ordinary GNU General Public License applies to all\n+subsequent copies and derivative works made from that copy.\n+\n+  This option is useful when you wish to copy part of the code of\n+the Library into a program that is not a library.\n+\n+  4. You may copy and distribute the Library (or a portion or\n+derivative of it, under Section 2) in object code or executable form\n+under the terms of Sections 1 and 2 above provided that you accompany\n+it with the complete corresponding machine-readable source code, which\n+must be distributed under the terms of Sections 1 and 2 above on a\n+medium customarily used for software interchange.\n+\n+  If distribution of object code is made by offering access to copy\n+from a designated place, then offering equivalent access to copy the\n+source code from the same place satisfies the requirement to\n+distribute the source code, even though third parties are not\n+compelled to copy the source along with the object code.\n+\n+  5. A program that contains no derivative of any portion of the\n+Library, but is designed to work with the Library by being compiled or\n+linked with it, is called a \"work that uses the Library\".  Such a\n+work, in isolation, is not a derivative work of the Library, and\n+therefore falls outside the scope of this License.\n+\n+  However, linking a \"work that uses the Library\" with the Library\n+creates an executable that is a derivative of the Library (because it\n+contains portions of the Library), rather than a \"work that uses the\n+library\".  The executable is therefore covered by this License.\n+Section 6 states terms for distribution of such executables.\n+\n+  When a \"work that uses the Library\" uses material from a header file\n+that is part of the Library, the object code for the work may be a\n+derivative work of the Library even though the source code is not.\n+Whether this is true is especially significant if the work can be\n+linked without the Library, or if the work is itself a library.  The\n+threshold for this to be true is not precisely defined by law.\n+\n+  If such an object file uses only numerical parameters, data\n+structure layouts and accessors, and small macros and small inline\n+functions (ten lines or less in length), then the use of the object\n+file is unrestricted, regardless of whether it is legally a derivative\n+work.  (Executables containing this object code plus portions of the\n+Library will still fall under Section 6.)\n+\n+  Otherwise, if the work is a derivative of the Library, you may\n+distribute the object code for the work under the terms of Section 6.\n+Any executables containing that work also fall under Section 6,\n+whether or not they are linked directly with the Library itself.\n+\f\n+  6. As an exception to the Sections above, you may also compile or\n+link a \"work that uses the Library\" with the Library to produce a\n+work containing portions of the Library, and distribute that work\n+under terms of your choice, provided that the terms permit\n+modification of the work for the customer's own use and reverse\n+engineering for debugging such modifications.\n+\n+  You must give prominent notice with each copy of the work that the\n+Library is used in it and that the Library and its use are covered by\n+this License.  You must supply a copy of this License.  If the work\n+during execution displays copyright notices, you must include the\n+copyright notice for the Library among them, as well as a reference\n+directing the user to the copy of this License.  Also, you must do one\n+of these things:\n+\n+    a) Accompany the work with the complete corresponding\n+    machine-readable source code for the Library including whatever\n+    changes were used in the work (which must be distributed under\n+    Sections 1 and 2 above); and, if the work is an executable linked\n+    with the Library, with the complete machine-readable \"work that\n+    uses the Library\", as object code and/or source code, so that the\n+    user can modify the Library and then relink to produce a modified\n+    executable containing the modified Library.  (It is understood\n+    that the user who changes the contents of definitions files in the\n+    Library will not necessarily be able to recompile the application\n+    to use the modified definitions.)\n+\n+    b) Accompany the work with a written offer, valid for at\n+    least three years, to give the same user the materials\n+    specified in Subsection 6a, above, for a charge no more\n+    than the cost of performing this distribution.\n+\n+    c) If distribution of the work is made by offering access to copy\n+    from a designated place, offer equivalent access to copy the above\n+    specified materials from the same place.\n+\n+    d) Verify that the user has already received a copy of these\n+    materials or that you have already sent this user a copy.\n+\n+  For an executable, the required form of the \"work that uses the\n+Library\" must include any data and utility programs needed for\n+reproducing the executable from it.  However, as a special exception,\n+the source code distributed need not include anything that is normally\n+distributed (in either source or binary form) with the major\n+components (compiler, kernel, and so on) of the operating system on\n+which the executable runs, unless that component itself accompanies\n+the executable.\n+\n+  It may happen that this requirement contradicts the license\n+restrictions of other proprietary libraries that do not normally\n+accompany the operating system.  Such a contradiction means you cannot\n+use both them and the Library together in an executable that you\n+distribute.\n+\f\n+  7. You may place library facilities that are a work based on the\n+Library side-by-side in a single library together with other library\n+facilities not covered by this License, and distribute such a combined\n+library, provided that the separate distribution of the work based on\n+the Library and of the other library facilities is otherwise\n+permitted, and provided that you do these two things:\n+\n+    a) Accompany the combined library with a copy of the same work\n+    based on the Library, uncombined with any other library\n+    facilities.  This must be distributed under the terms of the\n+    Sections above.\n+\n+    b) Give prominent notice with the combined library of the fact\n+    that part of it is a work based on the Library, and explaining\n+    where to find the accompanying uncombined form of the same work.\n+\n+  8. You may not copy, modify, sublicense, link with, or distribute\n+the Library except as expressly provided under this License.  Any\n+attempt otherwise to copy, modify, sublicense, link with, or\n+distribute the Library is void, and will automatically terminate your\n+rights under this License.  However, parties who have received copies,\n+or rights, from you under this License will not have their licenses\n+terminated so long as such parties remain in full compliance.\n+\n+  9. You are not required to accept this License, since you have not\n+signed it.  However, nothing else grants you permission to modify or\n+distribute the Library or its derivative works.  These actions are\n+prohibited by law if you do not accept this License.  Therefore, by\n+modifying or distributing the Library (or any work based on the\n+Library), you indicate your acceptance of this License to do so, and\n+all its terms and conditions for copying, distributing or modifying\n+the Library or works based on it.\n+\n+  10. Each time you redistribute the Library (or any work based on the\n+Library), the recipient automatically receives a license from the\n+original licensor to copy, distribute, link with or modify the Library\n+subject to these terms and conditions.  You may not impose any further\n+restrictions on the recipients' exercise of the rights granted herein.\n+You are not responsible for enforcing compliance by third parties to\n+this License.\n+\f\n+  11. If, as a consequence of a court judgment or allegation of patent\n+infringement or for any other reason (not limited to patent issues),\n+conditions are imposed on you (whether by court order, agreement or\n+otherwise) that contradict the conditions of this License, they do not\n+excuse you from the conditions of this License.  If you cannot\n+distribute so as to satisfy simultaneously your obligations under this\n+License and any other pertinent obligations, then as a consequence you\n+may not distribute the Library at all.  For example, if a patent\n+license would not permit royalty-free redistribution of the Library by\n+all those who receive copies directly or indirectly through you, then\n+the only way you could satisfy both it and this License would be to\n+refrain entirely from distribution of the Library.\n+\n+If any portion of this section is held invalid or unenforceable under any\n+particular circumstance, the balance of the section is intended to apply,\n+and the section as a whole is intended to apply in other circumstances.\n+\n+It is not the purpose of this section to induce you to infringe any\n+patents or other property right claims or to contest validity of any\n+such claims; this section has the sole purpose of protecting the\n+integrity of the free software distribution system which is\n+implemented by public license practices.  Many people have made\n+generous contributions to the wide range of software distributed\n+through that system in reliance on consistent application of that\n+system; it is up to the author/donor to decide if he or she is willing\n+to distribute software through any other system and a licensee cannot\n+impose that choice.\n+\n+This section is intended to make thoroughly clear what is believed to\n+be a consequence of the rest of this License.\n+\n+  12. If the distribution and/or use of the Library is restricted in\n+certain countries either by patents or by copyrighted interfaces, the\n+original copyright holder who places the Library under this License may add\n+an explicit geographical distribution limitation excluding those countries,\n+so that distribution is permitted only in or among countries not thus\n+excluded.  In such case, this License incorporates the limitation as if\n+written in the body of this License.\n+\n+  13. The Free Software Foundation may publish revised and/or new\n+versions of the Library General Public License from time to time.\n+Such new versions will be similar in spirit to the present version,\n+but may differ in detail to address new problems or concerns.\n+\n+Each version is given a distinguishing version number.  If the Library\n+specifies a version number of this License which applies to it and\n+\"any later version\", you have the option of following the terms and\n+conditions either of that version or of any later version published by\n+the Free Software Foundation.  If the Library does not specify a\n+license version number, you may choose any version ever published by\n+the Free Software Foundation.\n+\f\n+  14. If you wish to incorporate parts of the Library into other free\n+programs whose distribution conditions are incompatible with these,\n+write to the author to ask for permission.  For software which is\n+copyrighted by the Free Software Foundation, write to the Free\n+Software Foundation; we sometimes make exceptions for this.  Our\n+decision will be guided by the two goals of preserving the free status\n+of all derivatives of our free software and of promoting the sharing\n+and reuse of software generally.\n+\n+\t\t\t    NO WARRANTY\n+\n+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\n+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\n+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\n+OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\n+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\n+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\n+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n+\n+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\n+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\n+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\n+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\n+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\n+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\n+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\n+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\n+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+DAMAGES.\n+\n+\t\t     END OF TERMS AND CONDITIONS\n+\f\n+     Appendix: How to Apply These Terms to Your New Libraries\n+\n+  If you develop a new library, and you want it to be of the greatest\n+possible use to the public, we recommend making it free software that\n+everyone can redistribute and change.  You can do so by permitting\n+redistribution under these terms (or, alternatively, under the terms of the\n+ordinary General Public License).\n+\n+  To apply these terms, attach the following notices to the library.  It is\n+safest to attach them to the start of each source file to most effectively\n+convey the exclusion of warranty; and each file should have at least the\n+\"copyright\" line and a pointer to where the full notice is found.\n+\n+    <one line to give the library's name and a brief idea of what it does.>\n+    Copyright (C) <year>  <name of author>\n+\n+    This library is free software; you can redistribute it and/or\n+    modify it under the terms of the GNU Library General Public\n+    License as published by the Free Software Foundation; either\n+    version 2 of the License, or (at your option) any later version.\n+\n+    This library is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+    Library General Public License for more details.\n+\n+    You should have received a copy of the GNU Library General Public\n+    License along with this library; if not, write to the Free\n+    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+    MA 02111-1307, USA\n+\n+Also add information on how to contact you by electronic and paper mail.\n+\n+You should also get your employer (if you work as a programmer) or your\n+school, if any, to sign a \"copyright disclaimer\" for the library, if\n+necessary.  Here is a sample; alter the names:\n+\n+  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.\n+\n+  <signature of Ty Coon>, 1 April 1990\n+  Ty Coon, President of Vice\n+\n+That's all there is to it!"}, {"sha": "befc15228704c2e34a462ab335ee0c85ad973a30", "filename": "libjava/ChangeLog", "status": "added", "additions": 5035, "deletions": 0, "changes": 5035, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "3785700f91bc98a5a32cbf87d0739fdc77d09c1d", "filename": "libjava/LIBGCJ_LICENSE", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FLIBGCJ_LICENSE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FLIBGCJ_LICENSE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FLIBGCJ_LICENSE?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,11 @@\n+March 2, 1999\n+\n+The libgcj library is licensed under the terms of the GNU Library\n+General Public License.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libjava; see the file COPYING.LIB.  If not, write\n+to the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA.\n+\n+"}, {"sha": "eed9d2ac6003a6975f15bcfea38dcb6ed300e1f4", "filename": "libjava/Makefile.am", "status": "added", "additions": 660, "deletions": 0, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,660 @@\n+## Process this file with automake to produce Makefile.in.\n+\n+AUTOMAKE_OPTIONS = foreign no-installinfo\n+\n+if TESTSUBDIR\n+SUBDIRS = testsuite\n+endif\n+\n+## ################################################################\n+\n+##\n+## What gets installed, and where.\n+##\n+\n+toolexecdir = $(exec_prefix)/$(target_alias)\n+toolexeclibdir = $(toolexecdir)/lib$(MULTISUBDIR)\n+\n+toolexeclib_LIBRARIES = libgcj.a\n+data_DATA = libgcj.zip\n+\n+## For now, only on native systems.\n+if NATIVE\n+bin_PROGRAMS = jv-convert\n+endif\n+\n+## ################################################################\n+\n+##\n+## Compilers and compilation flags.\n+##\n+\n+## CANADIAN is a misnomer.  Really we check to see if we must pick up\n+## the tools from the path.\n+if CANADIAN\n+if NULL_TARGET\n+## In this case, gcj is found outside the build tree.  However, zip is\n+## found in the build tree.\n+GCJ = gcj\n+ZIP = $(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+else\n+GCJ = $(target_alias)-gcj\n+ZIP = zip\n+endif\n+GCJH = gcjh\n+else # CANADIAN\n+## JAVAC is set to `$(GCJ) -C'.  However, JAVAC is run from the srcdir\n+## (due to problems running it in builddir).  In this case the obvious\n+## definition of GCJ won't work; instead we resort to this ugly\n+## definition that gives us absolute paths.\n+expanded = `cd $(MULTIBUILDTOP)../$(COMPPATH)/gcc && pwd`\n+GCJ = $(expanded)/gcj$(EXEEXT) -B$(expanded)/\n+GCJH = $(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+ZIP = $(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+endif # CANADIAN\n+\n+JAVAC = $(GCJ) -C\n+\n+EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n+\n+WARNINGS = -W -Wall\n+AM_CXXFLAGS = -fno-rtti -fvtable-thunks @LIBGCJ_CXXFLAGS@ $(WARNINGS)\n+if USING_GCC\n+AM_CFLAGS = @LIBGCJ_CFLAGS@ $(WARNINGS)\n+else\n+AM_CFLAGS = @LIBGCJ_CFLAGS@\n+endif\n+\n+JCFLAGS = -g\n+JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n+\n+INCLUDES = -Iinclude -I$(top_srcdir)/include $(GCINCS) $(THREADINCS) $(EH_COMMON_INCLUDE)\n+\n+\n+## ################################################################\n+\n+##\n+## How to build libgcj.a and libgcj.zip\n+##\n+\n+## Objects from C++ sources in subdirs.\n+nat_files = $(nat_source_files:.cc=.o)\n+## Objects from C sources in subdirs.\n+c_files = $(c_source_files:.c=.o)\n+## Objects from Java sources in subdirs.\n+javao_files = $(java_source_files:.java=.o)\n+\n+libgcj_a_SOURCES = prims.cc jni.cc exception.cc\n+EXTRA_libgcj_a_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n+\t$(c_source_files) $(java_source_files)\n+libgcj_a_DEPENDENCIES = libgcj.zip $(javao_files) $(nat_files) \\\n+\t$(c_files) $(GCOBJS) $(THREADOBJS)\n+libgcj_a_LIBADD = $(javao_files) $(nat_files) $(c_files) $(GCOBJS) \\\n+\t$(THREADOBJS)\n+\n+## Make the .class files depend on the .zip file.  This seems\n+## backwards, but is right.  This doesn't catch all the .class files,\n+## but that is ok, because the ones it fails to pick up are defined in\n+## a .java file with some other class which is caught.  Note that we\n+## only want to create headers for those files which do not have\n+## hand-maintained headers.\n+$(java_source_files:.java=.class): libgcj.zip\n+\n+## We have the zip file depend on the java sources and not the class\n+## files, because we don't know the names of all the class files.\n+## FIXME: this method fails in a peculiar case: if libgcj.zip is\n+## up-to-date, and foo.class is removed, and bar.java is touched, then\n+## `make libgcj.zip' will not rebuilt foo.class.  That's because\n+## libgcj.zip is not out-of-date with respect to foo.java.\n+libgcj.zip: $(java_source_files)\n+## This little nastiness is here so that the backquoted stuff in the\n+## GCJ definition can be correctly expanded, if required.\n+\tjavac=\"$(JAVAC)\"; cd $(srcdir); \\\n+\t  $$javac $(JCFLAGS) -classpath $(here):`/bin/pwd` -d $(here) \\\n+\t    $(subst $(srcdir)/,,$?)\n+\t-@rm -f libgcj.zip\n+## Note that we explicitly want to include directory information.\n+\t$(ZIP) -r libgcj java -n .class -i '*.class' -i '*/'\n+\n+MOSTLYCLEANFILES = $(javao_files) $(nat_files) $(nat_headers) $(c_files)\n+CLEANFILES = libgcj.zip $(class_files)\n+\n+SUFFIXES = .class .java .h\n+\n+.class.o:\n+\tCLASSPATH=$(here) $(CC) -fassume-compiled $(JC1FLAGS) -c -o $@ $<\n+\n+.java.o:\n+\tCLASSPATH=$(here) $(GCJ) -fassume-compiled $(JC1FLAGS) -c -o $@ $<\n+\n+## This is GNU make specific.  For the .o files in subdirs, use a\n+## special rule.  The standard automake rule can't be overridden (this\n+## is a bug in automake), and it also won't put the .o files into\n+## subdirs.  FIXME.\n+$(nat_files): %.o: %.cc\n+\t$(CXXCOMPILE) -c -o $@ $<\n+\n+$(nat_files) $(GCOBJS) $(THREADOBJS) $(libgcj_a_OBJECTS): \\\n+\t\tinclude/config.h $(nat_headers)\n+\n+## FIXME: GNU make.\n+$(c_files): %.o: %.c\n+\t$(COMPILE) -c -o $@ $<\n+\n+$(c_files): java/lang/fdlibm.h java/lang/ieeefp.h java/lang/mprec.h\n+\n+## FIXME: GNU make.\n+$(javao_files): %.o: %.java\n+\tCLASSPATH=$(here) $(GCJ) -fassume-compiled $(JC1FLAGS) -c -o $@ $<\n+\n+## ################################################################\n+\n+##\n+## How to build header files.\n+##\n+\n+.class.h:\n+## FIXME: GNU make specific.\n+\t$(GCJH) -classpath $(top_builddir) $(basename $<)\n+\n+## Header files used when compiling some of the nat* files.\n+nat_headers = $(ordinary_java_source_files:.java=.h)\n+\n+$(nat_headers): libgcj.zip\n+\n+## Our internal main program needs to be able to create a FirstThread.\n+FTFRIEND = void JvRunMain (jclass klass, int argc, const char **argv)\n+java/lang/FirstThread.h: java/lang/FirstThread.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) -friend '$(FTFRIEND);' \\\n+\t\t$(basename $<)\n+\n+## ThreadGroup has a special constructor that is used when creating\n+## the first ThreadGroup.  We need to expose this to the main program.\n+TGFRIEND = void JvRunMain (jclass klass, int argc, const char **argv)\n+java/lang/ThreadGroup.h: java/lang/ThreadGroup.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) -friend '$(TGFRIEND);' \\\n+\t\t$(basename $<)\n+\n+java/lang/String.h: java/lang/String.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jchar* _Jv_GetStringChars (jstring str);' \\\n+\t    -friend 'jstring* _Jv_StringFindSlot (jchar*, jint, jint);' \\\n+\t    -friend 'jstring* _Jv_StringGetSlot (jstring);' \\\n+\t    -friend 'jstring _Jv_NewStringUtf8Const (_Jv_Utf8Const* str);' \\\n+\t    -friend 'jstring _Jv_NewStringLatin1 (const char*, jsize);' \\\n+\t    -friend 'jstring _Jv_AllocString (jsize);' \\\n+\t    $(basename $<)\n+\n+java/lang/reflect/Field.h: java/lang/reflect/Field.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv*, jclass, jfieldID);' \\\n+\t    -friend 'java::lang::Class;' \\\n+\t    $(basename $<)\n+\n+java/lang/reflect/Method.h: java/lang/reflect/Method.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);' \\\n+\t    -friend 'java::lang::Class;' \\\n+\t    $(basename $<)\n+\n+\n+## ################################################################\n+\n+##\n+## Additional `check' targets for maintainer convenience.\n+##\n+\n+## This is used for maintainer-check.  FIXME: should set from\n+## configure using AC_CHECK_TOOL.\n+NM = nm\n+\n+## Try to make sure our library doesn't stomp the namespace.\n+maintainer-check: libgcj.a\n+\t$(NM) libgcj.a | grep ' T ' \\\n+## Anything with `4java' is assumed to be from .java source.\n+\t  | grep -v '4java' \\\n+## Anything with Jv is ok.\n+\t  | grep -v 'Jv' \\\n+## `terminate' and `unexpected' are part of the runtime.\n+\t  | grep -v 'terminate__Fv' | grep -v 'unexpected__Fv'\n+\n+## This rule can be used to see if the headers are more or less\n+## correct.\n+header-check: libgcj.zip $(nat_headers)\n+\trm -f htest.cc; \\\n+\tfor h in $(nat_headers); do \\\n+\t  echo \"#include \\\"$$h\\\"\" >> htest.cc; \\\n+\tdone; \\\n+\t$(CXXCOMPILE) -fsyntax-only htest.cc\n+\n+\n+## ################################################################\n+\n+##\n+## The `jv-convert' program and code to rebuild the converter header\n+## files.\n+##\n+\n+## it only makes sense to try to rebuild the JIS .h files on native\n+## systems.\n+if NATIVE\n+if MAINTAINER_MODE\n+noinst_PROGRAMS = gen-from-JIS\n+endif\n+endif \n+\n+CONVERT_DIR = gnu/gcj/convert\n+\n+jv_convert_SOURCES =\n+EXTRA_jv_convert_SOURCES = $(convert_source_files)\n+jv_convert_LDFLAGS = --main=gnu.gcj.convert.Convert\n+jv_convert_LINK = $(GCJ) $(JC1FLAGS) $(LDFLAGS) -o jv-convert\n+jv_convert_LDADD = $(convert_source_files:.java=.o) -L. $(GCLIBS) $(THREADLIBS)\n+jv_convert_DEPENDENCIES = $(convert_source_files:.java=.o) \\\n+\t$(GCDEPS) $(THREADDEPS) libgcj.a\n+\n+# The Unicode consortium does not permit re-distributing the file JIS0208.TXT.\n+# You can get it from ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/.\n+\n+$(srcdir)/$(CONVERT_DIR)/JIS0208.h:  # JIS0208.TXT\n+\techo '/* This file is autoamtically generated from Unicode tables */' > tmp-0208; \\\n+\tsed -n -e 's|\\(0x....\\).*0x\\(..\\)\\(..\\).*\\(0x....\\).*#\\(.*\\).$$|MAP(0x\\2, 0x\\3, \\4)  /*\\5 */|p' \\\n+\t\t<JIS0208.TXT >> tmp-0208; \\\n+\tmv tmp-0208 $(srcdir)/$(CONVERT_DIR)/JIS0208.h\n+\n+# The Unicode consortium does not permit re-distributing the file JIS0212.TXT.\n+# You can get it from ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/.\n+\n+$(srcdir)/$(CONVERT_DIR)/JIS0212.h:  # JIS0212.TXT\n+\techo '/* This file is autoamtically generated from Unicode tables */' > tmp-0212; \\\n+\tsed -n -e 's|0x\\(..\\)\\(..\\).*\\(0x....\\).*#\\(.*\\).$$|MAP(0x\\1, 0x\\2, \\3)  /*\\4 */|p' \\\n+\t\t<JIS0212.TXT >> tmp-0212; \\\n+\tmv tmp-0212 $(srcdir)/$(CONVERT_DIR)/JIS0212.h\n+\n+\n+gen_from_JIS_SOURCES =\n+EXTRA_gen_from_JIS_SOURCES = $(srcdir)/$(CONVERT_DIR)/gen-from-JIS.c \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0208.h \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0212.h\n+gen_from_JIS_LDADD = $(CONVERT_DIR)/gen-from-JIS.o\n+gen_from_JIS_DEPENDENCIES = $(CONVERT_DIR)/gen-from-JIS.o\n+\n+$(CONVERT_DIR)/gen-from-JIS.o: $(srcdir)/$(CONVERT_DIR)/gen-from-JIS.c \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0208.h \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0212.h\n+\t$(COMPILE) -c -o $(CONVERT_DIR)/gen-from-JIS.o \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.c\n+\n+if NATIVE\n+if MAINTAINER_MODE\n+\n+$(srcdir)/$(CONVERT_DIR)/JIS0208_to_Unicode.cc: ./gen-from-JIS$(EXEEXT)\n+\t ./gen-from-JIS JIS0208>$(srcdir)/$(CONVERT_DIR)/JIS0208_to_Unicode.cc\n+\n+$(srcdir)/$(CONVERT_DIR)/JIS0212_to_Unicode.cc: ./gen-from-JIS$(EXEEXT)\n+\t ./gen-from-JIS JIS0212>$(srcdir)/$(CONVERT_DIR)/JIS0212_to_Unicode.cc\n+\n+endif # MAINTAINER_MODE\n+endif # NATIVE\n+\n+\n+## ################################################################\n+\n+##\n+## This section lists all the source files we care about.\n+##\n+\n+convert_source_files = \\\n+gnu/gcj/convert/BytesToUnicode.java \\\n+gnu/gcj/convert/Convert.java \\\n+gnu/gcj/convert/Input_8859_1.java \\\n+gnu/gcj/convert/Input_EUCJIS.java \\\n+gnu/gcj/convert/Input_UTF8.java\t\\\n+gnu/gcj/convert/Output_8859_1.java \\\n+gnu/gcj/convert/Output_JavaSrc.java \\\n+gnu/gcj/convert/Output_UTF8.java \\\n+gnu/gcj/convert/UnicodeToBytes.java\n+\n+## List of all .java files for which the .h file is maintained by\n+## hand.\n+special_java_source_files = java/lang/Class.java java/lang/Object.java\n+\n+## List of all .java files to be compiled.  Please keep this list\n+## alphabetical.  Please put files from gnu/gcj/convert into\n+## convert_source_files.  If the .java file has a hand-maintained\n+## header, please list it in special_java_source_files.\n+ordinary_java_source_files =  $(convert_source_files) \\\n+gnu/gcj/text/BaseBreakIterator.java \\\n+gnu/gcj/text/CharacterBreakIterator.java \\\n+gnu/gcj/text/LineBreakIterator.java \\\n+gnu/gcj/text/LocaleData_en.java\t\\\n+gnu/gcj/text/LocaleData_en_US.java \\\n+gnu/gcj/text/SentenceBreakIterator.java\t\\\n+gnu/gcj/text/WordBreakIterator.java \\\n+gnu/gcj/protocol/http/Connection.java \\\n+gnu/gcj/protocol/http/Handler.java \\\n+java/io/BufferedInputStream.java \\\n+java/io/BufferedOutputStream.java \\\n+java/io/BufferedReader.java \\\n+java/io/BufferedWriter.java \\\n+java/io/ByteArrayInputStream.java \\\n+java/io/ByteArrayOutputStream.java \\\n+java/io/CharArrayReader.java \\\n+java/io/CharArrayWriter.java \\\n+java/io/CharConversionException.java \\\n+java/io/DataInput.java \\\n+java/io/DataInputStream.java \\\n+java/io/DataOutput.java\t\\\n+java/io/DataOutputStream.java \\\n+java/io/EOFException.java \\\n+java/io/File.java \\\n+java/io/FileDescriptor.java \\\n+java/io/FileInputStream.java \\\n+java/io/FileNotFoundException.java \\\n+java/io/FileOutputStream.java \\\n+java/io/FileReader.java\t\\\n+java/io/FileWriter.java\t\\\n+java/io/FilenameFilter.java \\\n+java/io/FilterInputStream.java \\\n+java/io/FilterOutputStream.java\t\\\n+java/io/FilterReader.java \\\n+java/io/FilterWriter.java \\\n+java/io/IOException.java \\\n+java/io/InputStream.java \\\n+java/io/InputStreamReader.java \\\n+java/io/InterruptedIOException.java \\\n+java/io/LineNumberInputStream.java \\\n+java/io/LineNumberReader.java \\\n+java/io/OutputStream.java \\\n+java/io/OutputStreamWriter.java\t\\\n+java/io/PipedInputStream.java \\\n+java/io/PipedOutputStream.java \\\n+java/io/PipedReader.java \\\n+java/io/PipedWriter.java \\\n+java/io/PrintStream.java \\\n+java/io/PrintWriter.java \\\n+java/io/PushbackInputStream.java \\\n+java/io/PushbackReader.java \\\n+java/io/RandomAccessFile.java \\\n+java/io/Reader.java \\\n+java/io/SequenceInputStream.java \\\n+java/io/Serializable.java \\\n+java/io/StreamTokenizer.java \\\n+java/io/StringBufferInputStream.java \\\n+java/io/StringReader.java \\\n+java/io/StringWriter.java \\\n+java/io/SyncFailedException.java \\\n+java/io/UTFDataFormatException.java \\\n+java/io/UnsupportedEncodingException.java \\\n+java/io/Writer.java \\\n+java/lang/AbstractMethodError.java \\\n+java/lang/ArithmeticException.java \\\n+java/lang/ArrayIndexOutOfBoundsException.java \\\n+java/lang/ArrayStoreException.java \\\n+java/lang/Boolean.java \\\n+java/lang/Byte.java \\\n+java/lang/Character.java \\\n+java/lang/ClassCastException.java \\\n+java/lang/ClassCircularityError.java \\\n+java/lang/ClassFormatError.java\t\\\n+java/lang/ClassLoader.java \\\n+java/lang/ClassNotFoundException.java \\\n+java/lang/CloneNotSupportedException.java \\\n+java/lang/Cloneable.java \\\n+java/lang/Comparable.java \\\n+java/lang/Compiler.java\t\\\n+java/lang/Double.java \\\n+java/lang/Error.java \\\n+java/lang/Exception.java \\\n+java/lang/ExceptionInInitializerError.java \\\n+java/lang/FirstThread.java \\\n+java/lang/Float.java \\\n+java/lang/IllegalAccessError.java \\\n+java/lang/IllegalAccessException.java \\\n+java/lang/IllegalArgumentException.java\t\\\n+java/lang/IllegalMonitorStateException.java \\\n+java/lang/IllegalStateException.java \\\n+java/lang/IllegalThreadStateException.java \\\n+java/lang/IncompatibleClassChangeError.java \\\n+java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InstantiationError.java \\\n+java/lang/InstantiationException.java \\\n+java/lang/Integer.java \\\n+java/lang/InternalError.java \\\n+java/lang/InterruptedException.java \\\n+java/lang/LinkageError.java \\\n+java/lang/Long.java \\\n+java/lang/Math.java \\\n+java/lang/NegativeArraySizeException.java \\\n+java/lang/NoClassDefFoundError.java \\\n+java/lang/NoSuchFieldError.java\t\\\n+java/lang/NoSuchFieldException.java \\\n+java/lang/NoSuchMethodError.java \\\n+java/lang/NoSuchMethodException.java \\\n+java/lang/NullPointerException.java \\\n+java/lang/Number.java \\\n+java/lang/NumberFormatException.java \\\n+java/lang/OutOfMemoryError.java\t\\\n+java/lang/Process.java \\\n+java/lang/Runnable.java\t\\\n+java/lang/Runtime.java \\\n+java/lang/RuntimeException.java\t\\\n+java/lang/SecurityException.java \\\n+java/lang/SecurityManager.java \\\n+java/lang/Short.java \\\n+java/lang/StackOverflowError.java \\\n+java/lang/String.java \\\n+java/lang/StringBuffer.java \\\n+java/lang/StringIndexOutOfBoundsException.java \\\n+java/lang/System.java \\\n+java/lang/Thread.java \\\n+java/lang/ThreadDeath.java \\\n+java/lang/ThreadGroup.java \\\n+java/lang/Throwable.java \\\n+java/lang/UnknownError.java \\\n+java/lang/UnsatisfiedLinkError.java \\\n+java/lang/UnsupportedOperationException.java \\\n+java/lang/VerifyError.java \\\n+java/lang/VirtualMachineError.java \\\n+java/lang/Void.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Modifier.java\t\\\n+java/net/BindException.java \\\n+java/net/ConnectException.java \\\n+java/net/ContentHandler.java \\\n+java/net/ContentHandlerFactory.java \\\n+java/net/FileNameMap.java \\\n+java/net/HttpURLConnection.java \\\n+java/net/InetAddress.java \\\n+java/net/MalformedURLException.java \\\n+java/net/NoRouteToHostException.java \\\n+java/net/PlainSocketImpl.java \\\n+java/net/ProtocolException.java\t\\\n+java/net/ServerSocket.java \\\n+java/net/Socket.java \\\n+java/net/SocketException.java \\\n+java/net/SocketImpl.java \\\n+java/net/SocketImplFactory.java\t\\\n+java/net/URL.java \\\n+java/net/URLConnection.java \\\n+java/net/URLStreamHandler.java \\\n+java/net/URLStreamHandlerFactory.java \\\n+java/net/UnknownHostException.java \\\n+java/net/UnknownServiceException.java \\\n+java/text/BreakIterator.java \\\n+java/text/CharacterIterator.java \\\n+java/text/ChoiceFormat.java \\\n+java/text/DateFormat.java \\\n+java/text/DateFormatSymbols.java \\\n+java/text/DecimalFormat.java \\\n+java/text/DecimalFormatSymbols.java \\\n+java/text/FieldPosition.java \\\n+java/text/Format.java \\\n+java/text/MessageFormat.java \\\n+java/text/NumberFormat.java \\\n+java/text/ParseException.java \\\n+java/text/ParsePosition.java \\\n+java/text/SimpleDateFormat.java\t\\\n+java/text/StringCharacterIterator.java \\\n+java/util/BitSet.java \\\n+java/util/Calendar.java\t\\\n+java/util/ConcurrentModificationException.java \\\n+java/util/Date.java \\\n+java/util/Dictionary.java \\\n+java/util/EmptyStackException.java \\\n+java/util/Enumeration.java \\\n+java/util/EventListener.java \\\n+java/util/EventObject.java \\\n+java/util/GregorianCalendar.java \\\n+java/util/Hashtable.java \\\n+java/util/ListResourceBundle.java \\\n+java/util/Locale.java \\\n+java/util/MissingResourceException.java\t\\\n+java/util/NoSuchElementException.java \\\n+java/util/Observable.java \\\n+java/util/Observer.java\t\\\n+java/util/Properties.java \\\n+java/util/Random.java \\\n+java/util/ResourceBundle.java \\\n+java/util/SimpleTimeZone.java \\\n+java/util/Stack.java \\\n+java/util/StringTokenizer.java \\\n+java/util/TimeZone.java\t\\\n+java/util/TooManyListenersException.java \\\n+java/util/Vector.java \\\n+java/util/zip/Adler32.java \\\n+java/util/zip/CRC32.java \\\n+java/util/zip/Checksum.java \\\n+java/util/zip/Deflater.java \\\n+java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/ZipConstants.java\t\\\n+java/util/zip/ZipEntry.java \\\n+java/util/zip/ZipException.java\t\\\n+java/util/zip/ZipFile.java \\\n+java/util/zip/ZipOutputStream.java\n+\n+java_source_files = $(ordinary_java_source_files) $(special_java_source_files)\n+\n+## Math library: C, not C++\n+c_source_files = \\\n+  java/lang/dtoa.c        java/lang/k_rem_pio2.c  java/lang/s_tan.c       \\\n+  java/lang/e_acos.c      java/lang/k_sin.c       java/lang/strtod.c      \\\n+  java/lang/e_asin.c      java/lang/k_tan.c       java/lang/w_acos.c      \\\n+  java/lang/e_atan2.c     java/lang/mprec.c       java/lang/w_asin.c      \\\n+  java/lang/e_exp.c       java/lang/s_atan.c      java/lang/w_atan2.c     \\\n+  java/lang/e_fmod.c      java/lang/s_ceil.c      java/lang/w_exp.c       \\\n+  java/lang/e_log.c       java/lang/s_copysign.c  java/lang/w_fmod.c      \\\n+  java/lang/e_pow.c       java/lang/s_cos.c       java/lang/w_log.c       \\\n+  java/lang/e_rem_pio2.c  java/lang/s_fabs.c      java/lang/w_pow.c       \\\n+  java/lang/e_remainder.c java/lang/s_floor.c     java/lang/w_remainder.c \\\n+  java/lang/e_scalb.c     java/lang/s_rint.c      java/lang/w_sqrt.c      \\\n+  java/lang/e_sqrt.c      java/lang/s_scalbn.c    java/lang/sf_rint.c     \\\n+  java/lang/k_cos.c       java/lang/s_sin.c\n+\n+## This lists all the C++ source files in subdirectories.\n+nat_source_files = java/lang/natObject.cc java/lang/natClass.cc\t\\\n+java/lang/natString.cc java/lang/natDouble.cc java/lang/natRuntime.cc \\\n+java/lang/natSystem.cc java/lang/natThread.cc java/io/natFile.cc \\\n+java/io/natFileDescriptor.cc java/util/natDate.cc \\\n+java/util/natGregorianCalendar.cc java/lang/natFirstThread.cc \\\n+java/lang/natCharacter.cc java/lang/natMath.cc java/lang/natFloat.cc \\\n+java/lang/reflect/natField.cc java/net/natInetAddress.cc \\\n+java/net/natPlainSocketImpl.cc java/lang/reflect/natMethod.cc \\\n+java/lang/reflect/natArray.cc gnu/gcj/convert/natInput_EUCJIS.cc \\\n+gnu/gcj/convert/JIS0208_to_Unicode.cc \\\n+gnu/gcj/convert/JIS0212_to_Unicode.cc\n+\n+## ################################################################\n+\n+##\n+## This section is for make and multilib madness.\n+##\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+CONFIG_STATUS_DEPENDENCIES = $(libgcj_basedir)/configure.host\n+\n+MAKEOVERRIDES=\n+\n+# Multilib support variables.\n+MULTISRCTOP =\n+MULTIBUILDTOP =\n+MULTIDIRS =\n+MULTISUBDIR =\n+MULTIDO = true\n+MULTICLEAN = true\n+\n+# Multilib support.\n+.PHONY: all-multi mostlyclean-multi clean-multi distclean-multi \\\n+\tmaintainer-clean-multi\n+\n+all-recursive: all-multi\n+install-recursive: install-multi\n+mostlyclean-recursive: mostlyclean-multi\n+clean-recursive: clean-multi\n+distclean-recursive: distclean-multi\n+maintainer-clean-recursive: maintainer-clean-multi\n+\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean\n+\n+\n+## ################################################################\n+\n+\n+## See above.\n+cygnus_hack =\n+\n+"}, {"sha": "d47a7f8057ab0316045583da76e9a8a8b9e9b412", "filename": "libjava/Makefile.in", "status": "added", "additions": 1309, "deletions": 0, "changes": 1309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,1309 @@\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+\n+SHELL = @SHELL@\n+\n+srcdir = @srcdir@\n+top_srcdir = @top_srcdir@\n+VPATH = @srcdir@\n+prefix = @prefix@\n+exec_prefix = @exec_prefix@\n+\n+bindir = @bindir@\n+sbindir = @sbindir@\n+libexecdir = @libexecdir@\n+datadir = @datadir@\n+sysconfdir = @sysconfdir@\n+sharedstatedir = @sharedstatedir@\n+localstatedir = @localstatedir@\n+libdir = @libdir@\n+infodir = @infodir@\n+mandir = @mandir@\n+includedir = @includedir@\n+oldincludedir = /usr/include\n+\n+DESTDIR =\n+\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+\n+top_builddir = .\n+\n+ACLOCAL = @ACLOCAL@\n+AUTOCONF = @AUTOCONF@\n+AUTOMAKE = @AUTOMAKE@\n+AUTOHEADER = @AUTOHEADER@\n+\n+INSTALL = @INSTALL@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@ $(AM_INSTALL_PROGRAM_FLAGS)\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+transform = @program_transform_name@\n+\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_alias = @build_alias@\n+build_triplet = @build@\n+host_alias = @host_alias@\n+host_triplet = @host@\n+target_alias = @target_alias@\n+target_triplet = @target@\n+AM_RUNTESTFLAGS = @AM_RUNTESTFLAGS@\n+AR = @AR@\n+AS = @AS@\n+CC = @CC@\n+COMPPATH = @COMPPATH@\n+CPP = @CPP@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+EXEEXT = @EXEEXT@\n+GCDEPS = @GCDEPS@\n+GCINCS = @GCINCS@\n+GCLIBS = @GCLIBS@\n+GCOBJS = @GCOBJS@\n+LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n+LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n+LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+PACKAGE = @PACKAGE@\n+PERL = @PERL@\n+RANLIB = @RANLIB@\n+THREADDEPS = @THREADDEPS@\n+THREADINCS = @THREADINCS@\n+THREADLIBS = @THREADLIBS@\n+THREADOBJS = @THREADOBJS@\n+VERSION = @VERSION@\n+here = @here@\n+libgcj_basedir = @libgcj_basedir@\n+\n+AUTOMAKE_OPTIONS = foreign no-installinfo\n+\n+@TESTSUBDIR_TRUE@SUBDIRS = \\\n+@TESTSUBDIR_TRUE@testsuite\n+\n+toolexecdir = $(exec_prefix)/$(target_alias)\n+toolexeclibdir = $(toolexecdir)/lib$(MULTISUBDIR)\n+\n+toolexeclib_LIBRARIES = libgcj.a\n+data_DATA = libgcj.zip\n+\n+@NATIVE_TRUE@bin_PROGRAMS = \\\n+@NATIVE_TRUE@jv-convert\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@GCJ = \\\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@gcj\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@GCJ = \\\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@$(target_alias)-gcj\n+@CANADIAN_FALSE@GCJ = \\\n+@CANADIAN_FALSE@$(expanded)/gcj$(EXEEXT) -B$(expanded)/\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n+@CANADIAN_FALSE@ZIP = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = \\\n+@CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_FALSE@expanded = \\\n+@CANADIAN_FALSE@`cd $(MULTIBUILDTOP)../$(COMPPATH)/gcc && pwd`\n+\n+JAVAC = $(GCJ) -C\n+\n+EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n+\n+WARNINGS = -W -Wall\n+AM_CXXFLAGS = -fno-rtti -fvtable-thunks @LIBGCJ_CXXFLAGS@ $(WARNINGS)\n+@USING_GCC_TRUE@AM_CFLAGS = \\\n+@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = \\\n+@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+\n+JCFLAGS = -g\n+JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n+\n+INCLUDES = -Iinclude -I$(top_srcdir)/include $(GCINCS) $(THREADINCS) $(EH_COMMON_INCLUDE)\n+\n+nat_files = $(nat_source_files:.cc=.o)\n+c_files = $(c_source_files:.c=.o)\n+javao_files = $(java_source_files:.java=.o)\n+\n+libgcj_a_SOURCES = prims.cc jni.cc exception.cc\n+EXTRA_libgcj_a_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n+\t$(c_source_files) $(java_source_files)\n+\n+libgcj_a_DEPENDENCIES = libgcj.zip $(javao_files) $(nat_files) \\\n+\t$(c_files) $(GCOBJS) $(THREADOBJS)\n+\n+libgcj_a_LIBADD = $(javao_files) $(nat_files) $(c_files) $(GCOBJS) \\\n+\t$(THREADOBJS)\n+\n+\n+MOSTLYCLEANFILES = $(javao_files) $(nat_files) $(nat_headers) $(c_files)\n+CLEANFILES = libgcj.zip $(class_files)\n+\n+SUFFIXES = .class .java .h\n+\n+nat_headers = $(ordinary_java_source_files:.java=.h)\n+\n+FTFRIEND = void JvRunMain (jclass klass, int argc, const char **argv)\n+\n+TGFRIEND = void JvRunMain (jclass klass, int argc, const char **argv)\n+\n+NM = nm\n+\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+\n+CONVERT_DIR = gnu/gcj/convert\n+\n+jv_convert_SOURCES = \n+EXTRA_jv_convert_SOURCES = $(convert_source_files)\n+jv_convert_LDFLAGS = --main=gnu.gcj.convert.Convert\n+jv_convert_LINK = $(GCJ) $(JC1FLAGS) $(LDFLAGS) -o jv-convert\n+jv_convert_LDADD = $(convert_source_files:.java=.o) -L. $(GCLIBS) $(THREADLIBS)\n+jv_convert_DEPENDENCIES = $(convert_source_files:.java=.o) \\\n+\t$(GCDEPS) $(THREADDEPS) libgcj.a\n+\n+\n+gen_from_JIS_SOURCES = \n+EXTRA_gen_from_JIS_SOURCES = $(srcdir)/$(CONVERT_DIR)/gen-from-JIS.c \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0208.h \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0212.h\n+\n+gen_from_JIS_LDADD = $(CONVERT_DIR)/gen-from-JIS.o\n+gen_from_JIS_DEPENDENCIES = $(CONVERT_DIR)/gen-from-JIS.o\n+\n+convert_source_files = \\\n+gnu/gcj/convert/BytesToUnicode.java \\\n+gnu/gcj/convert/Convert.java \\\n+gnu/gcj/convert/Input_8859_1.java \\\n+gnu/gcj/convert/Input_EUCJIS.java \\\n+gnu/gcj/convert/Input_UTF8.java\t\\\n+gnu/gcj/convert/Output_8859_1.java \\\n+gnu/gcj/convert/Output_JavaSrc.java \\\n+gnu/gcj/convert/Output_UTF8.java \\\n+gnu/gcj/convert/UnicodeToBytes.java\n+\n+\n+special_java_source_files = java/lang/Class.java java/lang/Object.java\n+\n+ordinary_java_source_files = $(convert_source_files) \\\n+gnu/gcj/text/BaseBreakIterator.java \\\n+gnu/gcj/text/CharacterBreakIterator.java \\\n+gnu/gcj/text/LineBreakIterator.java \\\n+gnu/gcj/text/LocaleData_en.java\t\\\n+gnu/gcj/text/LocaleData_en_US.java \\\n+gnu/gcj/text/SentenceBreakIterator.java\t\\\n+gnu/gcj/text/WordBreakIterator.java \\\n+gnu/gcj/protocol/http/Connection.java \\\n+gnu/gcj/protocol/http/Handler.java \\\n+java/io/BufferedInputStream.java \\\n+java/io/BufferedOutputStream.java \\\n+java/io/BufferedReader.java \\\n+java/io/BufferedWriter.java \\\n+java/io/ByteArrayInputStream.java \\\n+java/io/ByteArrayOutputStream.java \\\n+java/io/CharArrayReader.java \\\n+java/io/CharArrayWriter.java \\\n+java/io/CharConversionException.java \\\n+java/io/DataInput.java \\\n+java/io/DataInputStream.java \\\n+java/io/DataOutput.java\t\\\n+java/io/DataOutputStream.java \\\n+java/io/EOFException.java \\\n+java/io/File.java \\\n+java/io/FileDescriptor.java \\\n+java/io/FileInputStream.java \\\n+java/io/FileNotFoundException.java \\\n+java/io/FileOutputStream.java \\\n+java/io/FileReader.java\t\\\n+java/io/FileWriter.java\t\\\n+java/io/FilenameFilter.java \\\n+java/io/FilterInputStream.java \\\n+java/io/FilterOutputStream.java\t\\\n+java/io/FilterReader.java \\\n+java/io/FilterWriter.java \\\n+java/io/IOException.java \\\n+java/io/InputStream.java \\\n+java/io/InputStreamReader.java \\\n+java/io/InterruptedIOException.java \\\n+java/io/LineNumberInputStream.java \\\n+java/io/LineNumberReader.java \\\n+java/io/OutputStream.java \\\n+java/io/OutputStreamWriter.java\t\\\n+java/io/PipedInputStream.java \\\n+java/io/PipedOutputStream.java \\\n+java/io/PipedReader.java \\\n+java/io/PipedWriter.java \\\n+java/io/PrintStream.java \\\n+java/io/PrintWriter.java \\\n+java/io/PushbackInputStream.java \\\n+java/io/PushbackReader.java \\\n+java/io/RandomAccessFile.java \\\n+java/io/Reader.java \\\n+java/io/SequenceInputStream.java \\\n+java/io/Serializable.java \\\n+java/io/StreamTokenizer.java \\\n+java/io/StringBufferInputStream.java \\\n+java/io/StringReader.java \\\n+java/io/StringWriter.java \\\n+java/io/SyncFailedException.java \\\n+java/io/UTFDataFormatException.java \\\n+java/io/UnsupportedEncodingException.java \\\n+java/io/Writer.java \\\n+java/lang/AbstractMethodError.java \\\n+java/lang/ArithmeticException.java \\\n+java/lang/ArrayIndexOutOfBoundsException.java \\\n+java/lang/ArrayStoreException.java \\\n+java/lang/Boolean.java \\\n+java/lang/Byte.java \\\n+java/lang/Character.java \\\n+java/lang/ClassCastException.java \\\n+java/lang/ClassCircularityError.java \\\n+java/lang/ClassFormatError.java\t\\\n+java/lang/ClassLoader.java \\\n+java/lang/ClassNotFoundException.java \\\n+java/lang/CloneNotSupportedException.java \\\n+java/lang/Cloneable.java \\\n+java/lang/Comparable.java \\\n+java/lang/Compiler.java\t\\\n+java/lang/Double.java \\\n+java/lang/Error.java \\\n+java/lang/Exception.java \\\n+java/lang/ExceptionInInitializerError.java \\\n+java/lang/FirstThread.java \\\n+java/lang/Float.java \\\n+java/lang/IllegalAccessError.java \\\n+java/lang/IllegalAccessException.java \\\n+java/lang/IllegalArgumentException.java\t\\\n+java/lang/IllegalMonitorStateException.java \\\n+java/lang/IllegalStateException.java \\\n+java/lang/IllegalThreadStateException.java \\\n+java/lang/IncompatibleClassChangeError.java \\\n+java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InstantiationError.java \\\n+java/lang/InstantiationException.java \\\n+java/lang/Integer.java \\\n+java/lang/InternalError.java \\\n+java/lang/InterruptedException.java \\\n+java/lang/LinkageError.java \\\n+java/lang/Long.java \\\n+java/lang/Math.java \\\n+java/lang/NegativeArraySizeException.java \\\n+java/lang/NoClassDefFoundError.java \\\n+java/lang/NoSuchFieldError.java\t\\\n+java/lang/NoSuchFieldException.java \\\n+java/lang/NoSuchMethodError.java \\\n+java/lang/NoSuchMethodException.java \\\n+java/lang/NullPointerException.java \\\n+java/lang/Number.java \\\n+java/lang/NumberFormatException.java \\\n+java/lang/OutOfMemoryError.java\t\\\n+java/lang/Process.java \\\n+java/lang/Runnable.java\t\\\n+java/lang/Runtime.java \\\n+java/lang/RuntimeException.java\t\\\n+java/lang/SecurityException.java \\\n+java/lang/SecurityManager.java \\\n+java/lang/Short.java \\\n+java/lang/StackOverflowError.java \\\n+java/lang/String.java \\\n+java/lang/StringBuffer.java \\\n+java/lang/StringIndexOutOfBoundsException.java \\\n+java/lang/System.java \\\n+java/lang/Thread.java \\\n+java/lang/ThreadDeath.java \\\n+java/lang/ThreadGroup.java \\\n+java/lang/Throwable.java \\\n+java/lang/UnknownError.java \\\n+java/lang/UnsatisfiedLinkError.java \\\n+java/lang/UnsupportedOperationException.java \\\n+java/lang/VerifyError.java \\\n+java/lang/VirtualMachineError.java \\\n+java/lang/Void.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Modifier.java\t\\\n+java/net/BindException.java \\\n+java/net/ConnectException.java \\\n+java/net/ContentHandler.java \\\n+java/net/ContentHandlerFactory.java \\\n+java/net/FileNameMap.java \\\n+java/net/HttpURLConnection.java \\\n+java/net/InetAddress.java \\\n+java/net/MalformedURLException.java \\\n+java/net/NoRouteToHostException.java \\\n+java/net/PlainSocketImpl.java \\\n+java/net/ProtocolException.java\t\\\n+java/net/ServerSocket.java \\\n+java/net/Socket.java \\\n+java/net/SocketException.java \\\n+java/net/SocketImpl.java \\\n+java/net/SocketImplFactory.java\t\\\n+java/net/URL.java \\\n+java/net/URLConnection.java \\\n+java/net/URLStreamHandler.java \\\n+java/net/URLStreamHandlerFactory.java \\\n+java/net/UnknownHostException.java \\\n+java/net/UnknownServiceException.java \\\n+java/text/BreakIterator.java \\\n+java/text/CharacterIterator.java \\\n+java/text/ChoiceFormat.java \\\n+java/text/DateFormat.java \\\n+java/text/DateFormatSymbols.java \\\n+java/text/DecimalFormat.java \\\n+java/text/DecimalFormatSymbols.java \\\n+java/text/FieldPosition.java \\\n+java/text/Format.java \\\n+java/text/MessageFormat.java \\\n+java/text/NumberFormat.java \\\n+java/text/ParseException.java \\\n+java/text/ParsePosition.java \\\n+java/text/SimpleDateFormat.java\t\\\n+java/text/StringCharacterIterator.java \\\n+java/util/BitSet.java \\\n+java/util/Calendar.java\t\\\n+java/util/ConcurrentModificationException.java \\\n+java/util/Date.java \\\n+java/util/Dictionary.java \\\n+java/util/EmptyStackException.java \\\n+java/util/Enumeration.java \\\n+java/util/EventListener.java \\\n+java/util/EventObject.java \\\n+java/util/GregorianCalendar.java \\\n+java/util/Hashtable.java \\\n+java/util/ListResourceBundle.java \\\n+java/util/Locale.java \\\n+java/util/MissingResourceException.java\t\\\n+java/util/NoSuchElementException.java \\\n+java/util/Observable.java \\\n+java/util/Observer.java\t\\\n+java/util/Properties.java \\\n+java/util/Random.java \\\n+java/util/ResourceBundle.java \\\n+java/util/SimpleTimeZone.java \\\n+java/util/Stack.java \\\n+java/util/StringTokenizer.java \\\n+java/util/TimeZone.java\t\\\n+java/util/TooManyListenersException.java \\\n+java/util/Vector.java \\\n+java/util/zip/Adler32.java \\\n+java/util/zip/CRC32.java \\\n+java/util/zip/Checksum.java \\\n+java/util/zip/Deflater.java \\\n+java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/ZipConstants.java\t\\\n+java/util/zip/ZipEntry.java \\\n+java/util/zip/ZipException.java\t\\\n+java/util/zip/ZipFile.java \\\n+java/util/zip/ZipOutputStream.java\n+\n+\n+java_source_files = $(ordinary_java_source_files) $(special_java_source_files)\n+\n+c_source_files = \\\n+  java/lang/dtoa.c        java/lang/k_rem_pio2.c  java/lang/s_tan.c       \\\n+  java/lang/e_acos.c      java/lang/k_sin.c       java/lang/strtod.c      \\\n+  java/lang/e_asin.c      java/lang/k_tan.c       java/lang/w_acos.c      \\\n+  java/lang/e_atan2.c     java/lang/mprec.c       java/lang/w_asin.c      \\\n+  java/lang/e_exp.c       java/lang/s_atan.c      java/lang/w_atan2.c     \\\n+  java/lang/e_fmod.c      java/lang/s_ceil.c      java/lang/w_exp.c       \\\n+  java/lang/e_log.c       java/lang/s_copysign.c  java/lang/w_fmod.c      \\\n+  java/lang/e_pow.c       java/lang/s_cos.c       java/lang/w_log.c       \\\n+  java/lang/e_rem_pio2.c  java/lang/s_fabs.c      java/lang/w_pow.c       \\\n+  java/lang/e_remainder.c java/lang/s_floor.c     java/lang/w_remainder.c \\\n+  java/lang/e_scalb.c     java/lang/s_rint.c      java/lang/w_sqrt.c      \\\n+  java/lang/e_sqrt.c      java/lang/s_scalbn.c    java/lang/sf_rint.c     \\\n+  java/lang/k_cos.c       java/lang/s_sin.c\n+\n+\n+nat_source_files = java/lang/natObject.cc java/lang/natClass.cc\t\\\n+java/lang/natString.cc java/lang/natDouble.cc java/lang/natRuntime.cc \\\n+java/lang/natSystem.cc java/lang/natThread.cc java/io/natFile.cc \\\n+java/io/natFileDescriptor.cc java/util/natDate.cc \\\n+java/util/natGregorianCalendar.cc java/lang/natFirstThread.cc \\\n+java/lang/natCharacter.cc java/lang/natMath.cc java/lang/natFloat.cc \\\n+java/lang/reflect/natField.cc java/net/natInetAddress.cc \\\n+java/net/natPlainSocketImpl.cc java/lang/reflect/natMethod.cc \\\n+java/lang/reflect/natArray.cc gnu/gcj/convert/natInput_EUCJIS.cc \\\n+gnu/gcj/convert/JIS0208_to_Unicode.cc \\\n+gnu/gcj/convert/JIS0212_to_Unicode.cc\n+\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+\n+CONFIG_STATUS_DEPENDENCIES = $(libgcj_basedir)/configure.host\n+\n+MAKEOVERRIDES = \n+\n+# Multilib support variables.\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+\n+\n+cygnus_hack = \n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = ./include/config.h\n+CONFIG_CLEAN_FILES = \n+LIBRARIES =  $(toolexeclib_LIBRARIES)\n+\n+\n+DEFS = @DEFS@ -I. -I$(srcdir) -I./include\n+CPPFLAGS = @CPPFLAGS@\n+LDFLAGS = @LDFLAGS@\n+LIBS = @LIBS@\n+libgcj_a_OBJECTS =  prims.o jni.o exception.o\n+@NATIVE_TRUE@bin_PROGRAMS =  jv-convert$(EXEEXT)\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS =  \\\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS$(EXEEXT)\n+PROGRAMS =  $(bin_PROGRAMS) $(noinst_PROGRAMS)\n+\n+jv_convert_OBJECTS = \n+gen_from_JIS_OBJECTS = \n+gen_from_JIS_LDFLAGS = \n+CXXFLAGS = @CXXFLAGS@\n+CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@\n+CFLAGS = @CFLAGS@\n+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n+DATA =  $(data_DATA)\n+\n+DIST_COMMON =  COPYING.LIB ChangeLog Makefile.am Makefile.in acconfig.h \\\n+acinclude.m4 aclocal.m4 configure configure.in include/config.h.in \\\n+include/stamp-h.in\n+\n+\n+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n+\n+TAR = tar\n+GZIP_ENV = --best\n+DIST_SUBDIRS =  testsuite\n+DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P .deps/boehm.P \\\n+.deps/exception.P .deps/gnu/gcj/convert/BytesToUnicode.P \\\n+.deps/gnu/gcj/convert/Convert.P .deps/gnu/gcj/convert/Input_8859_1.P \\\n+.deps/gnu/gcj/convert/Input_EUCJIS.P .deps/gnu/gcj/convert/Input_UTF8.P \\\n+.deps/gnu/gcj/convert/Output_8859_1.P \\\n+.deps/gnu/gcj/convert/Output_JavaSrc.P \\\n+.deps/gnu/gcj/convert/Output_UTF8.P \\\n+.deps/gnu/gcj/convert/UnicodeToBytes.P \\\n+.deps/gnu/gcj/protocol/http/Connection.P \\\n+.deps/gnu/gcj/protocol/http/Handler.P \\\n+.deps/gnu/gcj/text/BaseBreakIterator.P \\\n+.deps/gnu/gcj/text/CharacterBreakIterator.P \\\n+.deps/gnu/gcj/text/LineBreakIterator.P \\\n+.deps/gnu/gcj/text/LocaleData_en.P \\\n+.deps/gnu/gcj/text/LocaleData_en_US.P \\\n+.deps/gnu/gcj/text/SentenceBreakIterator.P \\\n+.deps/gnu/gcj/text/WordBreakIterator.P \\\n+.deps/java/io/BufferedInputStream.P \\\n+.deps/java/io/BufferedOutputStream.P .deps/java/io/BufferedReader.P \\\n+.deps/java/io/BufferedWriter.P .deps/java/io/ByteArrayInputStream.P \\\n+.deps/java/io/ByteArrayOutputStream.P .deps/java/io/CharArrayReader.P \\\n+.deps/java/io/CharArrayWriter.P .deps/java/io/CharConversionException.P \\\n+.deps/java/io/DataInput.P .deps/java/io/DataInputStream.P \\\n+.deps/java/io/DataOutput.P .deps/java/io/DataOutputStream.P \\\n+.deps/java/io/EOFException.P .deps/java/io/File.P \\\n+.deps/java/io/FileDescriptor.P .deps/java/io/FileInputStream.P \\\n+.deps/java/io/FileNotFoundException.P .deps/java/io/FileOutputStream.P \\\n+.deps/java/io/FileReader.P .deps/java/io/FileWriter.P \\\n+.deps/java/io/FilenameFilter.P .deps/java/io/FilterInputStream.P \\\n+.deps/java/io/FilterOutputStream.P .deps/java/io/FilterReader.P \\\n+.deps/java/io/FilterWriter.P .deps/java/io/IOException.P \\\n+.deps/java/io/InputStream.P .deps/java/io/InputStreamReader.P \\\n+.deps/java/io/InterruptedIOException.P \\\n+.deps/java/io/LineNumberInputStream.P .deps/java/io/LineNumberReader.P \\\n+.deps/java/io/OutputStream.P .deps/java/io/OutputStreamWriter.P \\\n+.deps/java/io/PipedInputStream.P .deps/java/io/PipedOutputStream.P \\\n+.deps/java/io/PipedReader.P .deps/java/io/PipedWriter.P \\\n+.deps/java/io/PrintStream.P .deps/java/io/PrintWriter.P \\\n+.deps/java/io/PushbackInputStream.P .deps/java/io/PushbackReader.P \\\n+.deps/java/io/RandomAccessFile.P .deps/java/io/Reader.P \\\n+.deps/java/io/SequenceInputStream.P .deps/java/io/Serializable.P \\\n+.deps/java/io/StreamTokenizer.P .deps/java/io/StringBufferInputStream.P \\\n+.deps/java/io/StringReader.P .deps/java/io/StringWriter.P \\\n+.deps/java/io/SyncFailedException.P \\\n+.deps/java/io/UTFDataFormatException.P \\\n+.deps/java/io/UnsupportedEncodingException.P .deps/java/io/Writer.P \\\n+.deps/java/lang/AbstractMethodError.P \\\n+.deps/java/lang/ArithmeticException.P \\\n+.deps/java/lang/ArrayIndexOutOfBoundsException.P \\\n+.deps/java/lang/ArrayStoreException.P .deps/java/lang/Boolean.P \\\n+.deps/java/lang/Byte.P .deps/java/lang/Character.P \\\n+.deps/java/lang/Class.P .deps/java/lang/ClassCastException.P \\\n+.deps/java/lang/ClassCircularityError.P \\\n+.deps/java/lang/ClassFormatError.P .deps/java/lang/ClassLoader.P \\\n+.deps/java/lang/ClassNotFoundException.P \\\n+.deps/java/lang/CloneNotSupportedException.P \\\n+.deps/java/lang/Cloneable.P .deps/java/lang/Comparable.P \\\n+.deps/java/lang/Compiler.P .deps/java/lang/Double.P \\\n+.deps/java/lang/Error.P .deps/java/lang/Exception.P \\\n+.deps/java/lang/ExceptionInInitializerError.P \\\n+.deps/java/lang/FirstThread.P .deps/java/lang/Float.P \\\n+.deps/java/lang/IllegalAccessError.P \\\n+.deps/java/lang/IllegalAccessException.P \\\n+.deps/java/lang/IllegalArgumentException.P \\\n+.deps/java/lang/IllegalMonitorStateException.P \\\n+.deps/java/lang/IllegalStateException.P \\\n+.deps/java/lang/IllegalThreadStateException.P \\\n+.deps/java/lang/IncompatibleClassChangeError.P \\\n+.deps/java/lang/IndexOutOfBoundsException.P \\\n+.deps/java/lang/InstantiationError.P \\\n+.deps/java/lang/InstantiationException.P .deps/java/lang/Integer.P \\\n+.deps/java/lang/InternalError.P .deps/java/lang/InterruptedException.P \\\n+.deps/java/lang/LinkageError.P .deps/java/lang/Long.P \\\n+.deps/java/lang/Math.P .deps/java/lang/NegativeArraySizeException.P \\\n+.deps/java/lang/NoClassDefFoundError.P \\\n+.deps/java/lang/NoSuchFieldError.P \\\n+.deps/java/lang/NoSuchFieldException.P \\\n+.deps/java/lang/NoSuchMethodError.P \\\n+.deps/java/lang/NoSuchMethodException.P \\\n+.deps/java/lang/NullPointerException.P .deps/java/lang/Number.P \\\n+.deps/java/lang/NumberFormatException.P .deps/java/lang/Object.P \\\n+.deps/java/lang/OutOfMemoryError.P .deps/java/lang/Process.P \\\n+.deps/java/lang/Runnable.P .deps/java/lang/Runtime.P \\\n+.deps/java/lang/RuntimeException.P .deps/java/lang/SecurityException.P \\\n+.deps/java/lang/SecurityManager.P .deps/java/lang/Short.P \\\n+.deps/java/lang/StackOverflowError.P .deps/java/lang/String.P \\\n+.deps/java/lang/StringBuffer.P \\\n+.deps/java/lang/StringIndexOutOfBoundsException.P \\\n+.deps/java/lang/System.P .deps/java/lang/Thread.P \\\n+.deps/java/lang/ThreadDeath.P .deps/java/lang/ThreadGroup.P \\\n+.deps/java/lang/Throwable.P .deps/java/lang/UnknownError.P \\\n+.deps/java/lang/UnsatisfiedLinkError.P \\\n+.deps/java/lang/UnsupportedOperationException.P \\\n+.deps/java/lang/VerifyError.P .deps/java/lang/VirtualMachineError.P \\\n+.deps/java/lang/Void.P .deps/java/lang/dtoa.P .deps/java/lang/e_acos.P \\\n+.deps/java/lang/e_asin.P .deps/java/lang/e_atan2.P \\\n+.deps/java/lang/e_exp.P .deps/java/lang/e_fmod.P \\\n+.deps/java/lang/e_log.P .deps/java/lang/e_pow.P \\\n+.deps/java/lang/e_rem_pio2.P .deps/java/lang/e_remainder.P \\\n+.deps/java/lang/e_scalb.P .deps/java/lang/e_sqrt.P \\\n+.deps/java/lang/k_cos.P .deps/java/lang/k_rem_pio2.P \\\n+.deps/java/lang/k_sin.P .deps/java/lang/k_tan.P .deps/java/lang/mprec.P \\\n+.deps/java/lang/reflect/AccessibleObject.P \\\n+.deps/java/lang/reflect/Array.P .deps/java/lang/reflect/Constructor.P \\\n+.deps/java/lang/reflect/Field.P \\\n+.deps/java/lang/reflect/InvocationTargetException.P \\\n+.deps/java/lang/reflect/Member.P .deps/java/lang/reflect/Method.P \\\n+.deps/java/lang/reflect/Modifier.P .deps/java/lang/s_atan.P \\\n+.deps/java/lang/s_ceil.P .deps/java/lang/s_copysign.P \\\n+.deps/java/lang/s_cos.P .deps/java/lang/s_fabs.P \\\n+.deps/java/lang/s_floor.P .deps/java/lang/s_rint.P \\\n+.deps/java/lang/s_scalbn.P .deps/java/lang/s_sin.P \\\n+.deps/java/lang/s_tan.P .deps/java/lang/sf_rint.P \\\n+.deps/java/lang/strtod.P .deps/java/lang/w_acos.P \\\n+.deps/java/lang/w_asin.P .deps/java/lang/w_atan2.P \\\n+.deps/java/lang/w_exp.P .deps/java/lang/w_fmod.P \\\n+.deps/java/lang/w_log.P .deps/java/lang/w_pow.P \\\n+.deps/java/lang/w_remainder.P .deps/java/lang/w_sqrt.P \\\n+.deps/java/net/BindException.P .deps/java/net/ConnectException.P \\\n+.deps/java/net/ContentHandler.P .deps/java/net/ContentHandlerFactory.P \\\n+.deps/java/net/FileNameMap.P .deps/java/net/HttpURLConnection.P \\\n+.deps/java/net/InetAddress.P .deps/java/net/MalformedURLException.P \\\n+.deps/java/net/NoRouteToHostException.P \\\n+.deps/java/net/PlainSocketImpl.P .deps/java/net/ProtocolException.P \\\n+.deps/java/net/ServerSocket.P .deps/java/net/Socket.P \\\n+.deps/java/net/SocketException.P .deps/java/net/SocketImpl.P \\\n+.deps/java/net/SocketImplFactory.P .deps/java/net/URL.P \\\n+.deps/java/net/URLConnection.P .deps/java/net/URLStreamHandler.P \\\n+.deps/java/net/URLStreamHandlerFactory.P \\\n+.deps/java/net/UnknownHostException.P \\\n+.deps/java/net/UnknownServiceException.P \\\n+.deps/java/text/BreakIterator.P .deps/java/text/CharacterIterator.P \\\n+.deps/java/text/ChoiceFormat.P .deps/java/text/DateFormat.P \\\n+.deps/java/text/DateFormatSymbols.P .deps/java/text/DecimalFormat.P \\\n+.deps/java/text/DecimalFormatSymbols.P .deps/java/text/FieldPosition.P \\\n+.deps/java/text/Format.P .deps/java/text/MessageFormat.P \\\n+.deps/java/text/NumberFormat.P .deps/java/text/ParseException.P \\\n+.deps/java/text/ParsePosition.P .deps/java/text/SimpleDateFormat.P \\\n+.deps/java/text/StringCharacterIterator.P .deps/java/util/BitSet.P \\\n+.deps/java/util/Calendar.P \\\n+.deps/java/util/ConcurrentModificationException.P \\\n+.deps/java/util/Date.P .deps/java/util/Dictionary.P \\\n+.deps/java/util/EmptyStackException.P .deps/java/util/Enumeration.P \\\n+.deps/java/util/EventListener.P .deps/java/util/EventObject.P \\\n+.deps/java/util/GregorianCalendar.P .deps/java/util/Hashtable.P \\\n+.deps/java/util/ListResourceBundle.P .deps/java/util/Locale.P \\\n+.deps/java/util/MissingResourceException.P \\\n+.deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n+.deps/java/util/Observer.P .deps/java/util/Properties.P \\\n+.deps/java/util/Random.P .deps/java/util/ResourceBundle.P \\\n+.deps/java/util/SimpleTimeZone.P .deps/java/util/Stack.P \\\n+.deps/java/util/StringTokenizer.P .deps/java/util/TimeZone.P \\\n+.deps/java/util/TooManyListenersException.P .deps/java/util/Vector.P \\\n+.deps/java/util/zip/Adler32.P .deps/java/util/zip/CRC32.P \\\n+.deps/java/util/zip/Checksum.P .deps/java/util/zip/Deflater.P \\\n+.deps/java/util/zip/DeflaterOutputStream.P \\\n+.deps/java/util/zip/ZipConstants.P .deps/java/util/zip/ZipEntry.P \\\n+.deps/java/util/zip/ZipException.P .deps/java/util/zip/ZipFile.P \\\n+.deps/java/util/zip/ZipOutputStream.P .deps/jni.P .deps/no-threads.P \\\n+.deps/nogc.P .deps/posix-threads.P .deps/prims.P\n+SOURCES = $(libgcj_a_SOURCES) $(EXTRA_libgcj_a_SOURCES) $(jv_convert_SOURCES) $(EXTRA_jv_convert_SOURCES) $(gen_from_JIS_SOURCES) $(EXTRA_gen_from_JIS_SOURCES)\n+OBJECTS = $(libgcj_a_OBJECTS) $(jv_convert_OBJECTS) $(gen_from_JIS_OBJECTS)\n+\n+all: all-redirect\n+.SUFFIXES:\n+.SUFFIXES: .S .c .cc .class .h .java .o .s\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n+\tcd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile\n+\n+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status $(BUILT_SOURCES)\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status\n+\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ configure.in  acinclude.m4\n+\tcd $(srcdir) && $(ACLOCAL)\n+\n+config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+$(srcdir)/configure: @MAINTAINER_MODE_TRUE@$(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)\n+\tcd $(srcdir) && $(AUTOCONF)\n+\n+include/config.h: include/stamp-h\n+\t@if test ! -f $@; then \\\n+\t\trm -f include/stamp-h; \\\n+\t\t$(MAKE) include/stamp-h; \\\n+\telse :; fi\n+include/stamp-h: $(srcdir)/include/config.h.in $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES= CONFIG_HEADERS=include/config.h \\\n+\t     $(SHELL) ./config.status\n+\t@echo timestamp > include/stamp-h 2> /dev/null\n+$(srcdir)/include/config.h.in: @MAINTAINER_MODE_TRUE@$(srcdir)/include/stamp-h.in\n+\t@if test ! -f $@; then \\\n+\t\trm -f $(srcdir)/include/stamp-h.in; \\\n+\t\t$(MAKE) $(srcdir)/include/stamp-h.in; \\\n+\telse :; fi\n+$(srcdir)/include/stamp-h.in: $(top_srcdir)/configure.in $(ACLOCAL_M4) acconfig.h\n+\tcd $(top_srcdir) && $(AUTOHEADER)\n+\t@echo timestamp > $(srcdir)/include/stamp-h.in 2> /dev/null\n+\n+mostlyclean-hdr:\n+\n+clean-hdr:\n+\n+distclean-hdr:\n+\t-rm -f include/config.h\n+\n+maintainer-clean-hdr:\n+\n+mostlyclean-toolexeclibLIBRARIES:\n+\n+clean-toolexeclibLIBRARIES:\n+\t-test -z \"$(toolexeclib_LIBRARIES)\" || rm -f $(toolexeclib_LIBRARIES)\n+\n+distclean-toolexeclibLIBRARIES:\n+\n+maintainer-clean-toolexeclibLIBRARIES:\n+\n+install-toolexeclibLIBRARIES: $(toolexeclib_LIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(DESTDIR)$(toolexeclibdir)\n+\t@list='$(toolexeclib_LIBRARIES)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \" $(INSTALL_DATA) $$p $(DESTDIR)$(toolexeclibdir)/$$p\"; \\\n+\t    $(INSTALL_DATA) $$p $(DESTDIR)$(toolexeclibdir)/$$p; \\\n+\t  else :; fi; \\\n+\tdone\n+\t@$(POST_INSTALL)\n+\t@list='$(toolexeclib_LIBRARIES)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \" $(RANLIB) $(DESTDIR)$(toolexeclibdir)/$$p\"; \\\n+\t    $(RANLIB) $(DESTDIR)$(toolexeclibdir)/$$p; \\\n+\t  else :; fi; \\\n+\tdone\n+\n+uninstall-toolexeclibLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\tlist='$(toolexeclib_LIBRARIES)'; for p in $$list; do \\\n+\t  rm -f $(DESTDIR)$(toolexeclibdir)/$$p; \\\n+\tdone\n+\n+.s.o:\n+\t$(COMPILE) -c $<\n+\n+.S.o:\n+\t$(COMPILE) -c $<\n+\n+mostlyclean-compile:\n+\t-rm -f *.o core *.core\n+\n+clean-compile:\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+maintainer-clean-compile:\n+\n+libgcj.a: $(libgcj_a_OBJECTS) $(libgcj_a_DEPENDENCIES)\n+\t-rm -f libgcj.a\n+\t$(AR) cru libgcj.a $(libgcj_a_OBJECTS) $(libgcj_a_LIBADD)\n+\t$(RANLIB) libgcj.a\n+\n+mostlyclean-binPROGRAMS:\n+\n+clean-binPROGRAMS:\n+\t-test -z \"$(bin_PROGRAMS)\" || rm -f $(bin_PROGRAMS)\n+\n+distclean-binPROGRAMS:\n+\n+maintainer-clean-binPROGRAMS:\n+\n+install-binPROGRAMS: $(bin_PROGRAMS)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(DESTDIR)$(bindir)\n+\t@list='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \"  $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`\"; \\\n+\t     $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \\\n+\t  else :; fi; \\\n+\tdone\n+\n+uninstall-binPROGRAMS:\n+\t@$(NORMAL_UNINSTALL)\n+\tlist='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  rm -f $(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \\\n+\tdone\n+\n+mostlyclean-noinstPROGRAMS:\n+\n+clean-noinstPROGRAMS:\n+\t-test -z \"$(noinst_PROGRAMS)\" || rm -f $(noinst_PROGRAMS)\n+\n+distclean-noinstPROGRAMS:\n+\n+maintainer-clean-noinstPROGRAMS:\n+\n+jv-convert$(EXEEXT): $(jv_convert_OBJECTS) $(jv_convert_DEPENDENCIES)\n+\t@rm -f jv-convert$(EXEEXT)\n+\t$(jv_convert_LINK) $(jv_convert_LDFLAGS) $(jv_convert_OBJECTS) $(jv_convert_LDADD) $(LIBS)\n+\n+gen-from-JIS$(EXEEXT): $(gen_from_JIS_OBJECTS) $(gen_from_JIS_DEPENDENCIES)\n+\t@rm -f gen-from-JIS$(EXEEXT)\n+\t$(LINK) $(gen_from_JIS_LDFLAGS) $(gen_from_JIS_OBJECTS) $(gen_from_JIS_LDADD) $(LIBS)\n+.cc.o:\n+\t$(CXXCOMPILE) -c $<\n+\n+install-dataDATA: $(data_DATA)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(DESTDIR)$(datadir)\n+\t@list='$(data_DATA)'; for p in $$list; do \\\n+\t  if test -f $(srcdir)/$$p; then \\\n+\t    echo \" $(INSTALL_DATA) $(srcdir)/$$p $(DESTDIR)$(datadir)/$$p\"; \\\n+\t    $(INSTALL_DATA) $(srcdir)/$$p $(DESTDIR)$(datadir)/$$p; \\\n+\t  else if test -f $$p; then \\\n+\t    echo \" $(INSTALL_DATA) $$p $(DESTDIR)$(datadir)/$$p\"; \\\n+\t    $(INSTALL_DATA) $$p $(DESTDIR)$(datadir)/$$p; \\\n+\t  fi; fi; \\\n+\tdone\n+\n+uninstall-dataDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\tlist='$(data_DATA)'; for p in $$list; do \\\n+\t  rm -f $(DESTDIR)$(datadir)/$$p; \\\n+\tdone\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+\n+@SET_MAKE@\n+\n+all-recursive install-data-recursive install-exec-recursive \\\n+installdirs-recursive install-recursive uninstall-recursive install-info-recursive \\\n+check-recursive installcheck-recursive info-recursive dvi-recursive:\n+\t@set fnord $(MAKEFLAGS); amf=$$2; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+mostlyclean-recursive clean-recursive distclean-recursive \\\n+maintainer-clean-recursive:\n+\t@set fnord $(MAKEFLAGS); amf=$$2; \\\n+\tdot_seen=no; \\\n+\trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  rev=\"$$subdir $$rev\"; \\\n+\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n+\tdone; \\\n+\ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+\n+tags: TAGS\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)'; \\\n+\tunique=`for i in $$list; do echo $$i; done | \\\n+\t  awk '    { files[$$0] = 1; } \\\n+\t       END { for (i in files) print i; }'`; \\\n+\there=`pwd` && cd $(srcdir) \\\n+\t  && mkid -f$$here/ID $$unique $(LISP)\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)\n+\ttags=; \\\n+\there=`pwd`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+   if test \"$$subdir\" = .; then :; else \\\n+\t    test -f $$subdir/TAGS && tags=\"$$tags -i $$here/$$subdir/TAGS\"; \\\n+   fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS)'; \\\n+\tunique=`for i in $$list; do echo $$i; done | \\\n+\t  awk '    { files[$$0] = 1; } \\\n+\t       END { for (i in files) print i; }'`; \\\n+\ttest -z \"$(ETAGS_ARGS)$$unique$(LISP)$$tags\" \\\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)\n+\n+mostlyclean-tags:\n+\n+clean-tags:\n+\n+distclean-tags:\n+\t-rm -f TAGS ID\n+\n+maintainer-clean-tags:\n+\n+distdir = $(PACKAGE)-$(VERSION)\n+top_distdir = $(distdir)\n+\n+# This target untars the dist file and tries a VPATH configuration.  Then\n+# it guarantees that the distribution is self-contained by making another\n+# tarfile.\n+distcheck: dist\n+\t-rm -rf $(distdir)\n+\tGZIP=$(GZIP_ENV) $(TAR) zxf $(distdir).tar.gz\n+\tmkdir $(distdir)/=build\n+\tmkdir $(distdir)/=inst\n+\tdc_install_base=`cd $(distdir)/=inst && pwd`; \\\n+\tcd $(distdir)/=build \\\n+\t  && ../configure --srcdir=.. --prefix=$$dc_install_base \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dist\n+\t-rm -rf $(distdir)\n+\t@banner=\"$(distdir).tar.gz is ready for distribution\"; \\\n+\tdashes=`echo \"$$banner\" | sed s/./=/g`; \\\n+\techo \"$$dashes\"; \\\n+\techo \"$$banner\"; \\\n+\techo \"$$dashes\"\n+dist: distdir\n+\t-chmod -R a+r $(distdir)\n+\tGZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)\n+\t-rm -rf $(distdir)\n+dist-all: distdir\n+\t-chmod -R a+r $(distdir)\n+\tGZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)\n+\t-rm -rf $(distdir)\n+distdir: $(DISTFILES)\n+\t-rm -rf $(distdir)\n+\tmkdir $(distdir)\n+\t-chmod 777 $(distdir)\n+\there=`cd $(top_builddir) && pwd`; \\\n+\ttop_distdir=`cd $(distdir) && pwd`; \\\n+\tdistdir=`cd $(distdir) && pwd`; \\\n+\tcd $(top_srcdir) \\\n+\t  && $(AUTOMAKE) --include-deps --build-dir=$$here --srcdir-name=$(top_srcdir) --output-dir=$$top_distdir --foreign Makefile\n+\t@for file in $(DISTFILES); do \\\n+\t  d=$(srcdir); \\\n+\t  if test -d $$d/$$file; then \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t  else \\\n+\t    test -f $(distdir)/$$file \\\n+\t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n+\t    || cp -p $$d/$$file $(distdir)/$$file || :; \\\n+\t  fi; \\\n+\tdone\n+\tfor subdir in $(DIST_SUBDIRS); do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test -d $(distdir)/$$subdir \\\n+\t    || mkdir $(distdir)/$$subdir \\\n+\t    || exit 1; \\\n+\t    chmod 777 $(distdir)/$$subdir; \\\n+\t    (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=../$(distdir) distdir=../$(distdir)/$$subdir distdir) \\\n+\t      || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\n+DEPS_MAGIC := $(shell mkdir .deps > /dev/null 2>&1 || :)\n+\n+-include $(DEP_FILES)\n+\n+mostlyclean-depend:\n+\n+clean-depend:\n+\n+distclean-depend:\n+\t-rm -rf .deps\n+\n+maintainer-clean-depend:\n+\n+%.o: %.c\n+\t@echo '$(COMPILE) -c $<'; \\\n+\t$(COMPILE) -Wp,-MD,.deps/$(*F).pp -c $<\n+\t@-cp .deps/$(*F).pp .deps/$(*F).P; \\\n+\ttr ' ' '\\012' < .deps/$(*F).pp \\\n+\t  | sed -e 's/^\\\\$$//' -e '/^$$/ d' -e '/:$$/ d' -e 's/$$/ :/' \\\n+\t    >> .deps/$(*F).P; \\\n+\trm .deps/$(*F).pp\n+\n+%.lo: %.c\n+\t@echo '$(LTCOMPILE) -c $<'; \\\n+\t$(LTCOMPILE) -Wp,-MD,.deps/$(*F).pp -c $<\n+\t@-sed -e 's/^\\([^:]*\\)\\.o[ \t]*:/\\1.lo \\1.o :/' \\\n+\t  < .deps/$(*F).pp > .deps/$(*F).P; \\\n+\ttr ' ' '\\012' < .deps/$(*F).pp \\\n+\t  | sed -e 's/^\\\\$$//' -e '/^$$/ d' -e '/:$$/ d' -e 's/$$/ :/' \\\n+\t    >> .deps/$(*F).P; \\\n+\trm -f .deps/$(*F).pp\n+\n+%.o: %.cc\n+\t@echo '$(CXXCOMPILE) -c $<'; \\\n+\t$(CXXCOMPILE) -Wp,-MD,.deps/$(*F).pp -c $<\n+\t@-cp .deps/$(*F).pp .deps/$(*F).P; \\\n+\ttr ' ' '\\012' < .deps/$(*F).pp \\\n+\t  | sed -e 's/^\\\\$$//' -e '/^$$/ d' -e '/:$$/ d' -e 's/$$/ :/' \\\n+\t    >> .deps/$(*F).P; \\\n+\trm .deps/$(*F).pp\n+\n+%.lo: %.cc\n+\t@echo '$(LTCXXCOMPILE) -c $<'; \\\n+\t$(LTCXXCOMPILE) -Wp,-MD,.deps/$(*F).pp -c $<\n+\t@-sed -e 's/^\\([^:]*\\)\\.o[ \t]*:/\\1.lo \\1.o :/' \\\n+\t  < .deps/$(*F).pp > .deps/$(*F).P; \\\n+\ttr ' ' '\\012' < .deps/$(*F).pp \\\n+\t  | sed -e 's/^\\\\$$//' -e '/^$$/ d' -e '/:$$/ d' -e 's/$$/ :/' \\\n+\t    >> .deps/$(*F).P; \\\n+\trm -f .deps/$(*F).pp\n+info-am:\n+info: info-recursive\n+dvi-am:\n+dvi: dvi-recursive\n+check-am: all-am\n+check: check-recursive\n+installcheck-am:\n+installcheck: installcheck-recursive\n+install-info-am: \n+install-info: install-info-recursive\n+install-exec-am: install-toolexeclibLIBRARIES install-binPROGRAMS\n+install-exec: install-exec-recursive\n+\n+install-data-am: install-dataDATA\n+install-data: install-data-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+install: install-recursive\n+uninstall-am: uninstall-toolexeclibLIBRARIES uninstall-binPROGRAMS \\\n+\t\tuninstall-dataDATA\n+uninstall: uninstall-recursive\n+all-am: Makefile $(LIBRARIES) $(PROGRAMS) $(DATA)\n+all-redirect: all-recursive\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install\n+installdirs: installdirs-recursive\n+installdirs-am:\n+\t$(mkinstalldirs)  $(DESTDIR)$(toolexeclibdir) $(DESTDIR)$(bindir) \\\n+\t\t$(DESTDIR)$(datadir)\n+\n+\n+mostlyclean-generic:\n+\t-test -z \"$(MOSTLYCLEANFILES)\" || rm -f $(MOSTLYCLEANFILES)\n+\n+clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n+\n+distclean-generic:\n+\t-rm -f Makefile $(CONFIG_CLEAN_FILES)\n+\t-rm -f config.cache config.log stamp-h stamp-h[0-9]*\n+\n+maintainer-clean-generic:\n+mostlyclean-am:  mostlyclean-hdr mostlyclean-toolexeclibLIBRARIES \\\n+\t\tmostlyclean-compile mostlyclean-binPROGRAMS \\\n+\t\tmostlyclean-noinstPROGRAMS mostlyclean-tags \\\n+\t\tmostlyclean-depend mostlyclean-generic\n+\n+mostlyclean: mostlyclean-recursive\n+\n+clean-am:  clean-hdr clean-toolexeclibLIBRARIES clean-compile \\\n+\t\tclean-binPROGRAMS clean-noinstPROGRAMS clean-tags \\\n+\t\tclean-depend clean-generic mostlyclean-am\n+\n+clean: clean-recursive\n+\n+distclean-am:  distclean-hdr distclean-toolexeclibLIBRARIES \\\n+\t\tdistclean-compile distclean-binPROGRAMS \\\n+\t\tdistclean-noinstPROGRAMS distclean-tags \\\n+\t\tdistclean-depend distclean-generic clean-am\n+\n+distclean: distclean-recursive\n+\t-rm -f config.status\n+\n+maintainer-clean-am:  maintainer-clean-hdr \\\n+\t\tmaintainer-clean-toolexeclibLIBRARIES \\\n+\t\tmaintainer-clean-compile maintainer-clean-binPROGRAMS \\\n+\t\tmaintainer-clean-noinstPROGRAMS maintainer-clean-tags \\\n+\t\tmaintainer-clean-depend maintainer-clean-generic \\\n+\t\tdistclean-am\n+\t@echo \"This command is intended for maintainers to use;\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+\n+maintainer-clean: maintainer-clean-recursive\n+\t-rm -f config.status\n+\n+.PHONY: mostlyclean-hdr distclean-hdr clean-hdr maintainer-clean-hdr \\\n+mostlyclean-toolexeclibLIBRARIES distclean-toolexeclibLIBRARIES \\\n+clean-toolexeclibLIBRARIES maintainer-clean-toolexeclibLIBRARIES \\\n+uninstall-toolexeclibLIBRARIES install-toolexeclibLIBRARIES \\\n+mostlyclean-compile distclean-compile clean-compile \\\n+maintainer-clean-compile mostlyclean-binPROGRAMS distclean-binPROGRAMS \\\n+clean-binPROGRAMS maintainer-clean-binPROGRAMS uninstall-binPROGRAMS \\\n+install-binPROGRAMS mostlyclean-noinstPROGRAMS distclean-noinstPROGRAMS \\\n+clean-noinstPROGRAMS maintainer-clean-noinstPROGRAMS uninstall-dataDATA \\\n+install-dataDATA install-data-recursive uninstall-data-recursive \\\n+install-exec-recursive uninstall-exec-recursive installdirs-recursive \\\n+uninstalldirs-recursive all-recursive check-recursive \\\n+installcheck-recursive info-recursive dvi-recursive \\\n+mostlyclean-recursive distclean-recursive clean-recursive \\\n+maintainer-clean-recursive tags tags-recursive mostlyclean-tags \\\n+distclean-tags clean-tags maintainer-clean-tags distdir \\\n+mostlyclean-depend distclean-depend clean-depend \\\n+maintainer-clean-depend info-am info dvi-am dvi check check-am \\\n+installcheck-am installcheck install-info-am install-info \\\n+install-exec-am install-exec install-data-am install-data install-am \\\n+install uninstall-am uninstall all-redirect all-am all installdirs-am \\\n+installdirs mostlyclean-generic distclean-generic clean-generic \\\n+maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n+\n+\n+$(java_source_files:.java=.class): libgcj.zip\n+\n+libgcj.zip: $(java_source_files)\n+\tjavac=\"$(JAVAC)\"; cd $(srcdir); \\\n+\t  $$javac $(JCFLAGS) -classpath $(here):`/bin/pwd` -d $(here) \\\n+\t    $(subst $(srcdir)/,,$?)\n+\t-@rm -f libgcj.zip\n+\t$(ZIP) -r libgcj java -n .class -i '*.class' -i '*/'\n+\n+.class.o:\n+\tCLASSPATH=$(here) $(CC) -fassume-compiled $(JC1FLAGS) -c -o $@ $<\n+\n+.java.o:\n+\tCLASSPATH=$(here) $(GCJ) -fassume-compiled $(JC1FLAGS) -c -o $@ $<\n+\n+$(nat_files): %.o: %.cc\n+\t$(CXXCOMPILE) -c -o $@ $<\n+\n+$(nat_files) $(GCOBJS) $(THREADOBJS) $(libgcj_a_OBJECTS): \\\n+\t\tinclude/config.h $(nat_headers)\n+\n+$(c_files): %.o: %.c\n+\t$(COMPILE) -c -o $@ $<\n+\n+$(c_files): java/lang/fdlibm.h java/lang/ieeefp.h java/lang/mprec.h\n+\n+$(javao_files): %.o: %.java\n+\tCLASSPATH=$(here) $(GCJ) -fassume-compiled $(JC1FLAGS) -c -o $@ $<\n+\n+.class.h:\n+\t$(GCJH) -classpath $(top_builddir) $(basename $<)\n+\n+$(nat_headers): libgcj.zip\n+java/lang/FirstThread.h: java/lang/FirstThread.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) -friend '$(FTFRIEND);' \\\n+\t\t$(basename $<)\n+java/lang/ThreadGroup.h: java/lang/ThreadGroup.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) -friend '$(TGFRIEND);' \\\n+\t\t$(basename $<)\n+\n+java/lang/String.h: java/lang/String.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jchar* _Jv_GetStringChars (jstring str);' \\\n+\t    -friend 'jstring* _Jv_StringFindSlot (jchar*, jint, jint);' \\\n+\t    -friend 'jstring* _Jv_StringGetSlot (jstring);' \\\n+\t    -friend 'jstring _Jv_NewStringUtf8Const (_Jv_Utf8Const* str);' \\\n+\t    -friend 'jstring _Jv_NewStringLatin1 (const char*, jsize);' \\\n+\t    -friend 'jstring _Jv_AllocString (jsize);' \\\n+\t    $(basename $<)\n+\n+java/lang/reflect/Field.h: java/lang/reflect/Field.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv*, jclass, jfieldID);' \\\n+\t    -friend 'java::lang::Class;' \\\n+\t    $(basename $<)\n+\n+java/lang/reflect/Method.h: java/lang/reflect/Method.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);' \\\n+\t    -friend 'java::lang::Class;' \\\n+\t    $(basename $<)\n+\n+maintainer-check: libgcj.a\n+\t$(NM) libgcj.a | grep ' T ' \\\n+\t  | grep -v '4java' \\\n+\t  | grep -v 'Jv' \\\n+\t  | grep -v 'terminate__Fv' | grep -v 'unexpected__Fv'\n+\n+header-check: libgcj.zip $(nat_headers)\n+\trm -f htest.cc; \\\n+\tfor h in $(nat_headers); do \\\n+\t  echo \"#include \\\"$$h\\\"\" >> htest.cc; \\\n+\tdone; \\\n+\t$(CXXCOMPILE) -fsyntax-only htest.cc\n+\n+# The Unicode consortium does not permit re-distributing the file JIS0208.TXT.\n+# You can get it from ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/.\n+\n+$(srcdir)/$(CONVERT_DIR)/JIS0208.h:  # JIS0208.TXT\n+\techo '/* This file is autoamtically generated from Unicode tables */' > tmp-0208; \\\n+\tsed -n -e 's|\\(0x....\\).*0x\\(..\\)\\(..\\).*\\(0x....\\).*#\\(.*\\).$$|MAP(0x\\2, 0x\\3, \\4)  /*\\5 */|p' \\\n+\t\t<JIS0208.TXT >> tmp-0208; \\\n+\tmv tmp-0208 $(srcdir)/$(CONVERT_DIR)/JIS0208.h\n+\n+# The Unicode consortium does not permit re-distributing the file JIS0212.TXT.\n+# You can get it from ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/.\n+\n+$(srcdir)/$(CONVERT_DIR)/JIS0212.h:  # JIS0212.TXT\n+\techo '/* This file is autoamtically generated from Unicode tables */' > tmp-0212; \\\n+\tsed -n -e 's|0x\\(..\\)\\(..\\).*\\(0x....\\).*#\\(.*\\).$$|MAP(0x\\1, 0x\\2, \\3)  /*\\4 */|p' \\\n+\t\t<JIS0212.TXT >> tmp-0212; \\\n+\tmv tmp-0212 $(srcdir)/$(CONVERT_DIR)/JIS0212.h\n+\n+$(CONVERT_DIR)/gen-from-JIS.o: $(srcdir)/$(CONVERT_DIR)/gen-from-JIS.c \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0208.h \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/JIS0212.h\n+\t$(COMPILE) -c -o $(CONVERT_DIR)/gen-from-JIS.o \\\n+\t\t$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.c\n+\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@$(srcdir)/$(CONVERT_DIR)/JIS0208_to_Unicode.cc: ./gen-from-JIS$(EXEEXT)\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@\t ./gen-from-JIS JIS0208>$(srcdir)/$(CONVERT_DIR)/JIS0208_to_Unicode.cc\n+\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@$(srcdir)/$(CONVERT_DIR)/JIS0212_to_Unicode.cc: ./gen-from-JIS$(EXEEXT)\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@\t ./gen-from-JIS JIS0212>$(srcdir)/$(CONVERT_DIR)/JIS0212_to_Unicode.cc\n+\n+# Multilib support.\n+.PHONY: all-multi mostlyclean-multi clean-multi distclean-multi \\\n+\tmaintainer-clean-multi\n+\n+all-recursive: all-multi\n+install-recursive: install-multi\n+mostlyclean-recursive: mostlyclean-multi\n+clean-recursive: clean-multi\n+distclean-recursive: distclean-multi\n+maintainer-clean-recursive: maintainer-clean-multi\n+\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "11a7c3787e310afdb7f998dad37a50b85d860d25", "filename": "libjava/acconfig.h", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Facconfig.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,89 @@\n+/* Name of this package.  */\n+#undef PACKAGE\n+\n+/* Version number of this package.  */\n+#undef VERSION\n+\n+/* Define this if you want runtime debugging enabled.  */\n+#undef DEBUG\n+\n+/* Define if using POSIX threads that have the mutexattr functions.  */\n+#undef HAVE_PTHREAD_MUTEXATTR_INIT\n+\n+/* Define this if you prefer size over speed for java.lang.Character.  */\n+#undef COMPACT_CHARACTER\n+\n+/* Define if you have memcpy.  */\n+#undef HAVE_MEMCPY\n+\n+/* Define if you have memmove.  */\n+#undef HAVE_MEMMOVE\n+\n+/* Define if you have strerror.  */\n+#undef HAVE_STRERROR\n+\n+/* Define if you have fsync.  */\n+#undef HAVE_FSYNC\n+\n+/* Define if you have sleep.  */\n+#undef HAVE_SLEEP\n+\n+/* Define if you have __int32_t and __uint32_t. */\n+#undef HAVE_INT32_DEFINED\n+\n+/* Define if you're running eCos. */\n+#undef ECOS\n+\n+/* */\n+#undef HAVE_LOCALTIME\n+\n+/* */\n+#undef HAVE_MKTIME\n+\n+/* Define if using POSIX threads on Linux.  */\n+#undef LINUX_THREADS\n+\n+/* Define if you have the `ctime_r' function.  */\n+#undef HAVE_CTIME_R\n+\n+/* Define if you have the `gmtime_r' function.  */\n+#undef HAVE_GMTIME_R\n+\n+/* Define if you have the `localtime_r' function.  */\n+#undef HAVE_LOCALTIME_R\n+\n+/* Define if inet6 structures are defined in netinet/in.h.  */\n+#undef HAVE_INET6\n+\n+/* Define it socklen_t typedef is in sys/socket.h.  */\n+#undef HAVE_SOCKLEN_T\n+\n+/* Define if Boehm GC in use.  */\n+#undef HAVE_BOEHM_GC\n+\n+/* Define if gethostname is declared in <unistd.h>.  */\n+#undef HAVE_GETHOSTNAME_DECL\n+\n+/* Define if gethostbyname_r returns `int'.  */\n+#undef GETHOSTBYNAME_R_RETURNS_INT\n+\n+/* Define if gethostbyaddr_r returns `int'.  */\n+#undef GETHOSTBYADDR_R_RETURNS_INT\n+\n+/* Define if struct tm has tm_gmtoff field.  */\n+#undef STRUCT_TM_HAS_GMTOFF\n+\n+/* Define if global `timezone' exists.  */\n+#undef HAVE_TIMEZONE\n+\n+/* Define if you have the appropriate function.  */\n+#undef HAVE_ACCESS\n+#undef HAVE_STAT\n+#undef HAVE_MKDIR\n+#undef HAVE_RENAME\n+#undef HAVE_RMDIR\n+#undef HAVE_UNLINK\n+#undef HAVE_REALPATH\n+#undef HAVE_READDIR_R\n+#undef HAVE_GETHOSTBYNAME_R\n+#undef HAVE_GETHOSTBYADDR_R"}, {"sha": "2056b9f9b771da648ba33f0293538f7a138daa3d", "filename": "libjava/acinclude.m4", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Facinclude.m4?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,156 @@\n+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n+# are probably using a cross compiler, which will not be able to fully\n+# link an executable.  This should really be fixed in autoconf\n+# itself.\n+\n+AC_DEFUN(LIBGCJ_CONFIGURE,\n+[\n+dnl Default to --enable-multilib\n+AC_ARG_ENABLE(multilib,\n+[  --enable-multilib         build many library versions (default)],\n+[case \"${enableval}\" in\n+  yes) multilib=yes ;;\n+  no)  multilib=no ;;\n+  *)   AC_MSG_ERROR(bad value ${enableval} for multilib option) ;;\n+ esac], [multilib=yes])dnl\n+\n+dnl We may get other options which we dont document:\n+dnl --with-target-subdir, --with-multisrctop, --with-multisubdir\n+\n+if test \"[$]{srcdir}\" = \".\"; then\n+  if test \"[$]{with_target_subdir}\" != \".\"; then\n+    libgcj_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n+  else\n+    libgcj_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n+  fi\n+else\n+  libgcj_basedir=\"[$]{srcdir}/$1\"\n+fi\n+AC_SUBST(libgcj_basedir)\n+\n+AC_CANONICAL_HOST\n+\n+dnl Still use \"libjava\" here to placate dejagnu.\n+AM_INIT_AUTOMAKE(libjava, 0.0.7)\n+\n+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n+# are probably using a cross compiler, which will not be able to fully\n+# link an executable.  This should really be fixed in autoconf\n+# itself.\n+\n+AC_DEFUN(LIB_AC_PROG_CC,\n+[AC_BEFORE([$0], [AC_PROG_CPP])dnl\n+AC_CHECK_PROG(CC, gcc, gcc)\n+if test -z \"$CC\"; then\n+  AC_CHECK_PROG(CC, cc, cc, , , /usr/ucb/cc)\n+  test -z \"$CC\" && AC_MSG_ERROR([no acceptable cc found in \\$PATH])\n+fi\n+\n+AC_PROG_CC_GNU\n+\n+if test $ac_cv_prog_gcc = yes; then\n+  GCC=yes\n+dnl Check whether -g works, even if CFLAGS is set, in case the package\n+dnl plays around with CFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CFLAGS=\"${CFLAGS+set}\"\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\n+  AC_PROG_CC_G\n+  if test \"$ac_test_CFLAGS\" = set; then\n+    CFLAGS=\"$ac_save_CFLAGS\"\n+  elif test $ac_cv_prog_cc_g = yes; then\n+    CFLAGS=\"-g -O2\"\n+  else\n+    CFLAGS=\"-O2\"\n+  fi\n+else\n+  GCC=\n+  test \"${CFLAGS+set}\" = set || CFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CC\n+\n+# Likewise for AC_PROG_CXX.\n+AC_DEFUN(LIB_AC_PROG_CXX,\n+[AC_BEFORE([$0], [AC_PROG_CXXCPP])dnl\n+AC_CHECK_PROGS(CXX, $CCC c++ g++ gcc CC cxx cc++, gcc)\n+test -z \"$CXX\" && AC_MSG_ERROR([no acceptable c++ found in \\$PATH])\n+\n+AC_PROG_CXX_GNU\n+\n+if test $ac_cv_prog_gxx = yes; then\n+  GXX=yes\n+dnl Check whether -g works, even if CXXFLAGS is set, in case the package\n+dnl plays around with CXXFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CXXFLAGS=\"${CXXFLAGS+set}\"\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\n+  AC_PROG_CXX_G\n+  if test \"$ac_test_CXXFLAGS\" = set; then\n+    CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  elif test $ac_cv_prog_cxx_g = yes; then\n+    CXXFLAGS=\"-g -O2\"\n+  else\n+    CXXFLAGS=\"-O2\"\n+  fi\n+else\n+  GXX=\n+  test \"${CXXFLAGS+set}\" = set || CXXFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CXX\n+\n+# AC_CHECK_TOOL does AC_REQUIRE (AC_CANONICAL_BUILD).  If we dont\n+# run it explicitly here, it will be run implicitly before\n+# LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n+# be run before AC_CANONICAL_HOST.\n+AC_CANONICAL_BUILD\n+\n+AC_CHECK_TOOL(AS, as)\n+AC_CHECK_TOOL(AR, ar)\n+AC_CHECK_TOOL(RANLIB, ranlib, :)\n+\n+AC_PROG_INSTALL\n+\n+AM_MAINTAINER_MODE\n+\n+# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n+# at least currently, we never actually build a program, so we never\n+# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n+# fails, because we are probably configuring with a cross compiler\n+# which cant create executables.  So we include AC_EXEEXT to keep\n+# automake happy, but we dont execute it, since we dont care about\n+# the result.\n+if false; then\n+  AC_EXEEXT\n+fi\n+\n+# configure.host sets the following important variables\n+#\tlibgcj_cflags    - host specific C compiler flags\n+#\tlibgcj_cxxflags  - host specific C++ compiler flags\n+#\tlibgcj_javaflags - host specific Java compiler flags\n+\n+libgcj_cflags=\n+libgcj_cxxflags=\n+libgcj_javaflags=\n+\n+. [$]{libgcj_basedir}/configure.host\n+\n+case [$]{libgcj_basedir} in\n+/* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{libgcj_basedir} ;;\n+*) libgcj_flagbasedir='[$](top_builddir)/'[$]{libgcj_basedir} ;;\n+esac\n+\n+LIBGCJ_CFLAGS=\"[$]{libgcj_cflags}\"\n+LIBGCJ_CXXFLAGS=\"[$]{libgcj_cxxflags}\"\n+LIBGCJ_JAVAFLAGS=\"[$]{libgcj_javaflags}\"\n+AC_SUBST(LIBGCJ_CFLAGS)\n+AC_SUBST(LIBGCJ_CXXFLAGS)\n+AC_SUBST(LIBGCJ_JAVAFLAGS)\n+])dnl"}, {"sha": "651dd93fc24ee6de42a14848cfbfc81bca23bc57", "filename": "libjava/aclocal.m4", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Faclocal.m4?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,317 @@\n+dnl aclocal.m4 generated automatically by aclocal 1.4\n+\n+dnl Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+dnl This file is free software; the Free Software Foundation\n+dnl gives unlimited permission to copy and/or distribute it,\n+dnl with or without modifications, as long as this notice is preserved.\n+\n+dnl This program is distributed in the hope that it will be useful,\n+dnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+dnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+dnl PARTICULAR PURPOSE.\n+\n+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n+# are probably using a cross compiler, which will not be able to fully\n+# link an executable.  This should really be fixed in autoconf\n+# itself.\n+\n+AC_DEFUN(LIBGCJ_CONFIGURE,\n+[\n+dnl Default to --enable-multilib\n+AC_ARG_ENABLE(multilib,\n+[  --enable-multilib         build many library versions (default)],\n+[case \"${enableval}\" in\n+  yes) multilib=yes ;;\n+  no)  multilib=no ;;\n+  *)   AC_MSG_ERROR(bad value ${enableval} for multilib option) ;;\n+ esac], [multilib=yes])dnl\n+\n+dnl We may get other options which we dont document:\n+dnl --with-target-subdir, --with-multisrctop, --with-multisubdir\n+\n+if test \"[$]{srcdir}\" = \".\"; then\n+  if test \"[$]{with_target_subdir}\" != \".\"; then\n+    libgcj_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n+  else\n+    libgcj_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n+  fi\n+else\n+  libgcj_basedir=\"[$]{srcdir}/$1\"\n+fi\n+AC_SUBST(libgcj_basedir)\n+\n+AC_CANONICAL_HOST\n+\n+dnl Still use \"libjava\" here to placate dejagnu.\n+AM_INIT_AUTOMAKE(libjava, 0.0.7)\n+\n+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n+# are probably using a cross compiler, which will not be able to fully\n+# link an executable.  This should really be fixed in autoconf\n+# itself.\n+\n+AC_DEFUN(LIB_AC_PROG_CC,\n+[AC_BEFORE([$0], [AC_PROG_CPP])dnl\n+AC_CHECK_PROG(CC, gcc, gcc)\n+if test -z \"$CC\"; then\n+  AC_CHECK_PROG(CC, cc, cc, , , /usr/ucb/cc)\n+  test -z \"$CC\" && AC_MSG_ERROR([no acceptable cc found in \\$PATH])\n+fi\n+\n+AC_PROG_CC_GNU\n+\n+if test $ac_cv_prog_gcc = yes; then\n+  GCC=yes\n+dnl Check whether -g works, even if CFLAGS is set, in case the package\n+dnl plays around with CFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CFLAGS=\"${CFLAGS+set}\"\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\n+  AC_PROG_CC_G\n+  if test \"$ac_test_CFLAGS\" = set; then\n+    CFLAGS=\"$ac_save_CFLAGS\"\n+  elif test $ac_cv_prog_cc_g = yes; then\n+    CFLAGS=\"-g -O2\"\n+  else\n+    CFLAGS=\"-O2\"\n+  fi\n+else\n+  GCC=\n+  test \"${CFLAGS+set}\" = set || CFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CC\n+\n+# Likewise for AC_PROG_CXX.\n+AC_DEFUN(LIB_AC_PROG_CXX,\n+[AC_BEFORE([$0], [AC_PROG_CXXCPP])dnl\n+AC_CHECK_PROGS(CXX, $CCC c++ g++ gcc CC cxx cc++, gcc)\n+test -z \"$CXX\" && AC_MSG_ERROR([no acceptable c++ found in \\$PATH])\n+\n+AC_PROG_CXX_GNU\n+\n+if test $ac_cv_prog_gxx = yes; then\n+  GXX=yes\n+dnl Check whether -g works, even if CXXFLAGS is set, in case the package\n+dnl plays around with CXXFLAGS (such as to build both debugging and\n+dnl normal versions of a library), tasteless as that idea is.\n+  ac_test_CXXFLAGS=\"${CXXFLAGS+set}\"\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\n+  AC_PROG_CXX_G\n+  if test \"$ac_test_CXXFLAGS\" = set; then\n+    CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  elif test $ac_cv_prog_cxx_g = yes; then\n+    CXXFLAGS=\"-g -O2\"\n+  else\n+    CXXFLAGS=\"-O2\"\n+  fi\n+else\n+  GXX=\n+  test \"${CXXFLAGS+set}\" = set || CXXFLAGS=\"-g\"\n+fi\n+])\n+\n+LIB_AC_PROG_CXX\n+\n+# AC_CHECK_TOOL does AC_REQUIRE (AC_CANONICAL_BUILD).  If we dont\n+# run it explicitly here, it will be run implicitly before\n+# LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n+# be run before AC_CANONICAL_HOST.\n+AC_CANONICAL_BUILD\n+\n+AC_CHECK_TOOL(AS, as)\n+AC_CHECK_TOOL(AR, ar)\n+AC_CHECK_TOOL(RANLIB, ranlib, :)\n+\n+AC_PROG_INSTALL\n+\n+AM_MAINTAINER_MODE\n+\n+# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n+# at least currently, we never actually build a program, so we never\n+# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n+# fails, because we are probably configuring with a cross compiler\n+# which cant create executables.  So we include AC_EXEEXT to keep\n+# automake happy, but we dont execute it, since we dont care about\n+# the result.\n+if false; then\n+  AC_EXEEXT\n+fi\n+\n+# configure.host sets the following important variables\n+#\tlibgcj_cflags    - host specific C compiler flags\n+#\tlibgcj_cxxflags  - host specific C++ compiler flags\n+#\tlibgcj_javaflags - host specific Java compiler flags\n+\n+libgcj_cflags=\n+libgcj_cxxflags=\n+libgcj_javaflags=\n+\n+. [$]{libgcj_basedir}/configure.host\n+\n+case [$]{libgcj_basedir} in\n+/* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{libgcj_basedir} ;;\n+*) libgcj_flagbasedir='[$](top_builddir)/'[$]{libgcj_basedir} ;;\n+esac\n+\n+LIBGCJ_CFLAGS=\"[$]{libgcj_cflags}\"\n+LIBGCJ_CXXFLAGS=\"[$]{libgcj_cxxflags}\"\n+LIBGCJ_JAVAFLAGS=\"[$]{libgcj_javaflags}\"\n+AC_SUBST(LIBGCJ_CFLAGS)\n+AC_SUBST(LIBGCJ_CXXFLAGS)\n+AC_SUBST(LIBGCJ_JAVAFLAGS)\n+])dnl\n+\n+# Do all the work for Automake.  This macro actually does too much --\n+# some checks are only needed if your package does certain things.\n+# But this isn't really a big deal.\n+\n+# serial 1\n+\n+dnl Usage:\n+dnl AM_INIT_AUTOMAKE(package,version, [no-define])\n+\n+AC_DEFUN(AM_INIT_AUTOMAKE,\n+[AC_REQUIRE([AC_PROG_INSTALL])\n+PACKAGE=[$1]\n+AC_SUBST(PACKAGE)\n+VERSION=[$2]\n+AC_SUBST(VERSION)\n+dnl test to see if srcdir already configured\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\" && test -f $srcdir/config.status; then\n+  AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+fi\n+ifelse([$3],,\n+AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package]))\n+AC_REQUIRE([AM_SANITY_CHECK])\n+AC_REQUIRE([AC_ARG_PROGRAM])\n+dnl FIXME This is truly gross.\n+missing_dir=`cd $ac_aux_dir && pwd`\n+AM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)\n+AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)\n+AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)\n+AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)\n+AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)\n+AC_REQUIRE([AC_PROG_MAKE_SET])])\n+\n+#\n+# Check to make sure that the build environment is sane.\n+#\n+\n+AC_DEFUN(AM_SANITY_CHECK,\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftestfile\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt $srcdir/configure conftestfile 2> /dev/null`\n+   if test \"[$]*\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t $srcdir/configure conftestfile`\n+   fi\n+   if test \"[$]*\" != \"X $srcdir/configure conftestfile\" \\\n+      && test \"[$]*\" != \"X conftestfile $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"[$]2\" = conftestfile\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+rm -f conftest*\n+AC_MSG_RESULT(yes)])\n+\n+dnl AM_MISSING_PROG(NAME, PROGRAM, DIRECTORY)\n+dnl The program must properly implement --version.\n+AC_DEFUN(AM_MISSING_PROG,\n+[AC_MSG_CHECKING(for working $2)\n+# Run test in a subshell; some versions of sh will print an error if\n+# an executable is not found, even if stderr is redirected.\n+# Redirect stdin to placate older versions of autoconf.  Sigh.\n+if ($2 --version) < /dev/null > /dev/null 2>&1; then\n+   $1=$2\n+   AC_MSG_RESULT(found)\n+else\n+   $1=\"$3/missing $2\"\n+   AC_MSG_RESULT(missing)\n+fi\n+AC_SUBST($1)])\n+\n+# Add --enable-maintainer-mode option to configure.\n+# From Jim Meyering\n+\n+# serial 1\n+\n+AC_DEFUN(AM_MAINTAINER_MODE,\n+[AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode is disabled by default\n+  AC_ARG_ENABLE(maintainer-mode,\n+[  --enable-maintainer-mode enable make rules and dependencies not useful\n+                          (and sometimes confusing) to the casual installer],\n+      USE_MAINTAINER_MODE=$enableval,\n+      USE_MAINTAINER_MODE=no)\n+  AC_MSG_RESULT($USE_MAINTAINER_MODE)\n+  AM_CONDITIONAL(MAINTAINER_MODE, test $USE_MAINTAINER_MODE = yes)\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST(MAINT)dnl\n+]\n+)\n+\n+# Define a conditional.\n+\n+AC_DEFUN(AM_CONDITIONAL,\n+[AC_SUBST($1_TRUE)\n+AC_SUBST($1_FALSE)\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi])\n+\n+# Like AC_CONFIG_HEADER, but automatically create stamp file.\n+\n+AC_DEFUN(AM_CONFIG_HEADER,\n+[AC_PREREQ([2.12])\n+AC_CONFIG_HEADER([$1])\n+dnl When config.status generates a header, we must update the stamp-h file.\n+dnl This file resides in the same directory as the config header\n+dnl that is generated.  We must strip everything past the first \":\",\n+dnl and everything past the last \"/\".\n+AC_OUTPUT_COMMANDS(changequote(<<,>>)dnl\n+ifelse(patsubst(<<$1>>, <<[^ ]>>, <<>>), <<>>,\n+<<test -z \"<<$>>CONFIG_HEADERS\" || echo timestamp > patsubst(<<$1>>, <<^\\([^:]*/\\)?.*>>, <<\\1>>)stamp-h<<>>dnl>>,\n+<<am_indx=1\n+for am_file in <<$1>>; do\n+  case \" <<$>>CONFIG_HEADERS \" in\n+  *\" <<$>>am_file \"*<<)>>\n+    echo timestamp > `echo <<$>>am_file | sed -e 's%:.*%%' -e 's%[^/]*$%%'`stamp-h$am_indx\n+    ;;\n+  esac\n+  am_indx=`expr \"<<$>>am_indx\" + 1`\n+done<<>>dnl>>)\n+changequote([,]))])\n+"}, {"sha": "c41dab94387ca1df21052da53931eb291d49a5b9", "filename": "libjava/boehm.cc", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,367 @@\n+// boehm.cc - interface between libjava and Boehm GC.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+\n+#include <cni.h>\n+#include <java/lang/Class.h>\n+#include <jvm.h>\n+#include <java-field.h>\n+\n+// We need to include gc_priv.h.  However, it tries to include\n+// config.h if it hasn't already been included.  So we force the\n+// inclusion of the Boehm config.h.\n+extern \"C\"\n+{\n+#include <boehm-config.h>\n+#include <gc_priv.h>\n+#include <gc_mark.h>\n+\n+  // These aren't declared in any Boehm GC header.\n+  void GC_finalize_all (void);\n+  ptr_t GC_debug_generic_malloc (size_t size, int k, GC_EXTRA_PARAMS);\n+};\n+\n+// FIXME: this should probably be defined in some GC header.\n+#ifdef GC_DEBUG\n+#  define GC_GENERIC_MALLOC(Size, Type) \\\n+    GC_debug_generic_malloc (Size, Type, GC_EXTRAS)\n+#else\n+#  define GC_GENERIC_MALLOC(Size, Type) GC_generic_malloc (Size, Type)\n+#endif\n+\n+// We must check for plausibility ourselves.\n+#define MAYBE_MARK(Obj, Top, Limit, Source, Exit)  \\\n+      if ((ptr_t) (Obj) >= GC_least_plausible_heap_addr \\\n+\t  && (ptr_t) (Obj) <= GC_greatest_plausible_heap_addr) \\\n+        PUSH_CONTENTS (Obj, Top, Limit, Source, Exit)\n+\n+#define ObjectClass _CL_Q34java4lang6Object\n+extern java::lang::Class ObjectClass;\n+#define ClassClass _CL_Q34java4lang5Class\n+extern java::lang::Class ClassClass;\n+\n+\f\n+\n+// Nonzero if this module has been initialized.\n+static int initialized = 0;\n+\n+// `kind' index used when allocating Java objects.\n+static int obj_kind_x;\n+\n+// `kind' index used when allocating Java arrays.\n+static int array_kind_x;\n+\n+// Freelist used for Java objects.\n+static ptr_t *obj_free_list;\n+\n+// Freelist used for Java arrays.\n+static ptr_t *array_free_list;\n+\n+\f\n+\n+// This is called by the GC during the mark phase.  It marks a Java\n+// object.  We use `void *' arguments and return, and not what the\n+// Boehm GC wants, to avoid pollution in our headers.\n+void *\n+_Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n+{\n+  mse *mark_stack_ptr = (mse *) msp;\n+  mse *mark_stack_limit = (mse *) msl;\n+  jobject obj = (jobject) addr;\n+\n+  _Jv_VTable *dt = *(_Jv_VTable **) addr;\n+  // We check this in case a GC occurs before the vtbl is set.  FIXME:\n+  // should use allocation lock while initializing object.\n+  if (! dt)\n+    return mark_stack_ptr;\n+  jclass klass = dt->clas;\n+\n+  // Every object has a sync_info pointer.\n+  word w = (word) obj->sync_info;\n+  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, obj, o1label);\n+  // Mark the object's class.\n+  w = (word) klass;\n+  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, obj, o2label);\n+\n+  if (klass == &ClassClass)\n+    {\n+      jclass c = (jclass) addr;\n+\n+      w = (word) c->next;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c2label);\n+      w = (word) c->name;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c3label);\n+      w = (word) c->superclass;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c4label);\n+      for (int i = 0; i < c->constants.size; ++i)\n+\t{\n+\t  w = (word) c->constants.data[i];\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c5label);\n+\t}\n+\n+      // If the class is an array, then the methods field holds a\n+      // pointer to the element class.  If the class is primitive,\n+      // then the methods field holds a pointer to the array class.\n+      w = (word) c->methods;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c6label);\n+\n+      if (! c->isArray() && ! c->isPrimitive())\n+\t{\n+\t  // Scan each method in the cases where `methods' really\n+\t  // points to a methods structure.\n+\t  for (int i = 0; i < c->method_count; ++i)\n+\t    {\n+\t      w = (word) c->methods[i].name;\n+\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c,\n+\t\t\t     cm1label);\n+\t      w = (word) c->methods[i].signature;\n+\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c,\n+\t\t\t     cm2label);\n+\t      // FIXME: `ncode' entry?\n+\t    }\n+\t}\n+\n+      // Mark all the fields.\n+      w = (word) c->fields;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8label);\n+      for (int i = 0; i < c->field_count; ++i)\n+\t{\n+#ifndef COMPACT_FIELDS\n+\t  w = (word) c->fields[i].name;\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8alabel);\n+#endif\n+\t  w = (word) c->fields[i].type;\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8blabel);\n+\t}\n+\n+      w = (word) c->vtable;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c9label);\n+      w = (word) c->interfaces;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, cAlabel);\n+      for (int i = 0; i < c->interface_count; ++i)\n+\t{\n+\t  w = (word) c->interfaces[i];\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, cClabel);\n+\t}\n+      w = (word) c->loader;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, cBlabel);\n+    }\n+  else\n+    {\n+      // NOTE: each class only holds information about the class\n+      // itself.  So we must do the marking for the entire inheritance\n+      // tree in order to mark all fields.  FIXME: what about\n+      // interfaces?  We skip Object here, because Object only has a\n+      // sync_info, and we handled that earlier.\n+      // Note: occasionally `klass' can be null.  For instance, this\n+      // can happen if a GC occurs between the point where an object\n+      // is allocated and where the vtbl slot is set.\n+      while (klass && klass != &ObjectClass)\n+\t{\n+\t  jfieldID field = JvGetFirstInstanceField (klass);\n+\t  jint max = JvNumInstanceFields (klass);\n+\n+\t  for (int i = 0; i < max; ++i)\n+\t    {\n+\t      if (JvFieldIsRef (field))\n+\t\t{\n+\t\t  jobject val = JvGetObjectField (obj, field);\n+\t\t  w = (word) val;\n+\t\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit,\n+\t\t\t      obj, elabel);\n+\t\t}\n+\t      field = field->getNextInstanceField ();\n+\t    }\n+\t  klass = klass->getSuperclass();\n+\t}\n+    }\n+\n+  return mark_stack_ptr;\n+}\n+\n+// This is called by the GC during the mark phase.  It marks a Java\n+// array (of objects).  We use `void *' arguments and return, and not\n+// what the Boehm GC wants, to avoid pollution in our headers.\n+void *\n+_Jv_MarkArray (void *addr, void *msp, void *msl, void * /*env*/)\n+{\n+  mse *mark_stack_ptr = (mse *) msp;\n+  mse *mark_stack_limit = (mse *) msl;\n+  jobjectArray array = (jobjectArray) addr;\n+\n+  _Jv_VTable *dt = *(_Jv_VTable **) addr;\n+  // We check this in case a GC occurs before the vtbl is set.  FIXME:\n+  // should use allocation lock while initializing object.\n+  if (! dt)\n+    return mark_stack_ptr;\n+  jclass klass = dt->clas;\n+\n+  // Every object has a sync_info pointer.\n+  word w = (word) array->sync_info;\n+  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, array, e1label);\n+  // Mark the object's class.\n+  w = (word) klass;\n+  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, obj, o2label);\n+\n+  for (int i = 0; i < JvGetArrayLength (array); ++i)\n+    {\n+      jobject obj = elements (array)[i];\n+      w = (word) obj;\n+      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, array, e2label);\n+    }\n+\n+  return mark_stack_ptr;\n+}\n+\n+// Allocate space for a new Java object.  FIXME: this might be the\n+// wrong interface; we might prefer to pass in the object type as\n+// well.  It isn't important for this collector, but it might be for\n+// other collectors.\n+void *\n+_Jv_AllocObj (jsize size)\n+{\n+  return GC_GENERIC_MALLOC (size, obj_kind_x);\n+}\n+\n+// Allocate space for a new Java array.  FIXME: again, this might be\n+// the wrong interface.\n+void *\n+_Jv_AllocArray (jsize size)\n+{\n+  return GC_GENERIC_MALLOC (size, array_kind_x);\n+}\n+\n+// Allocate some space that is known to be pointer-free.\n+void *\n+_Jv_AllocBytes (jsize size)\n+{\n+  return GC_GENERIC_MALLOC (size, PTRFREE);\n+}\n+\n+static void\n+call_finalizer (GC_PTR obj, GC_PTR client_data)\n+{\n+  _Jv_FinalizerFunc *fn = (_Jv_FinalizerFunc *) client_data;\n+  jobject jobj = (jobject) obj;\n+\n+  (*fn) (jobj);\n+}\n+\n+void\n+_Jv_RegisterFinalizer (void *object, _Jv_FinalizerFunc *meth)\n+{\n+  GC_REGISTER_FINALIZER_NO_ORDER (object, call_finalizer, meth,\n+\t\t\t\t  NULL, NULL);\n+}\n+\n+void\n+_Jv_RunFinalizers (void)\n+{\n+  GC_invoke_finalizers ();\n+}\n+\n+void\n+_Jv_RunAllFinalizers (void)\n+{\n+  GC_finalize_all ();\n+}\n+\n+void\n+_Jv_RunGC (void)\n+{\n+  GC_gcollect ();\n+}\n+\n+long\n+_Jv_GCTotalMemory (void)\n+{\n+  return GC_get_heap_size ();\n+}\n+\n+/* Sum size of each hblk.  */\n+static void\n+sum_blocks (struct hblk *h, word arg)\n+{\n+  long *sump = (long *) arg;\n+  /* This evil computation is from boehm-gc/checksums.c.  */\n+  hdr *hhdr = HDR (h);\n+  int bytes = WORDS_TO_BYTES (hhdr->hb_sz);\n+  bytes += HDR_BYTES + HBLKSIZE - 1;\n+  bytes &= ~ (HBLKSIZE - 1);\n+  *sump += bytes;\n+}\n+\n+/* This turns out to be expensive to implement.  For now, we don't\n+   care.  We could make it less expensive, perhaps, but that would\n+   require some changes to the collector.  */\n+long\n+_Jv_GCFreeMemory (void)\n+{\n+  long sum = 0;\n+  GC_apply_to_all_blocks (sum_blocks, &sum);\n+  return sum;\n+}\n+\n+void\n+_Jv_InitGC (void)\n+{\n+  int proc;\n+  DCL_LOCK_STATE;\n+\n+  DISABLE_SIGNALS ();\n+  LOCK ();\n+\n+  if (initialized)\n+    {\n+      UNLOCK ();\n+      ENABLE_SIGNALS ();\n+      return;\n+    }\n+  initialized = 1;\n+\n+  // Set up state for marking and allocation of Java objects.\n+  obj_free_list = (ptr_t *) GC_generic_malloc_inner ((MAXOBJSZ + 1)\n+\t\t\t\t\t\t     * sizeof (ptr_t),\n+\t\t\t\t\t\t     PTRFREE);\n+  memset (obj_free_list, 0, (MAXOBJSZ + 1) * sizeof (ptr_t));\n+\n+  proc = GC_n_mark_procs++;\n+  GC_mark_procs[proc] = (mark_proc) _Jv_MarkObj;\n+\n+  obj_kind_x = GC_n_kinds++;\n+  GC_obj_kinds[obj_kind_x].ok_freelist = obj_free_list;\n+  GC_obj_kinds[obj_kind_x].ok_reclaim_list = 0;\n+  GC_obj_kinds[obj_kind_x].ok_descriptor = MAKE_PROC (proc, 0);\n+  GC_obj_kinds[obj_kind_x].ok_relocate_descr = FALSE;\n+  GC_obj_kinds[obj_kind_x].ok_init = TRUE;\n+\n+  // Set up state for marking and allocation of arrays of Java\n+  // objects.\n+  array_free_list = (ptr_t *) GC_generic_malloc_inner ((MAXOBJSZ + 1)\n+\t\t\t\t\t\t       * sizeof (ptr_t),\n+\t\t\t\t\t\t       PTRFREE);\n+  memset (array_free_list, 0, (MAXOBJSZ + 1) * sizeof (ptr_t));\n+\n+  proc = GC_n_mark_procs++;\n+  GC_mark_procs[proc] = (mark_proc) _Jv_MarkArray;\n+\n+  array_kind_x = GC_n_kinds++;\n+  GC_obj_kinds[array_kind_x].ok_freelist = array_free_list;\n+  GC_obj_kinds[array_kind_x].ok_reclaim_list = 0;\n+  GC_obj_kinds[array_kind_x].ok_descriptor = MAKE_PROC (proc, 0);\n+  GC_obj_kinds[array_kind_x].ok_relocate_descr = FALSE;\n+  GC_obj_kinds[array_kind_x].ok_init = TRUE;\n+\n+  UNLOCK ();\n+  ENABLE_SIGNALS ();\n+}"}, {"sha": "fbcfb277d7bd53be8297bbb6d5661f4e2e89c0c2", "filename": "libjava/chartables.pl", "status": "added", "additions": 965, "deletions": 0, "changes": 965, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fchartables.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fchartables.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fchartables.pl?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,965 @@\n+# chartables.pl - A perl program to generate tables for use by the\n+# Character class.\n+\n+# Copyright (C) 1998, 1999  Cygnus Solutions\n+#\n+# This file is part of libjava.\n+# \n+# This software is copyrighted work licensed under the terms of the\n+# Libjava License.  Please consult the file \"LIBJAVA_LICENSE\" for\n+# details.\n+\n+# This program requires a `unidata.txt' file of the form distributed\n+# on the Unicode 2.0 CD ROM.  Or, get it more conveniently here:\n+# ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData-Latest.txt\n+# Version `2.1.8' of this file was last used to update the Character class.\n+\n+# Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+# \"The Java Language Specification\", ISBN 0-201-63451-1\n+# plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+\n+# Usage: perl chartables.pl [-n] UnicodeData-VERSION.txt\n+# If this exits with nonzero status, then you must investigate the\n+# cause of the problem.\n+# Diagnostics and other information to stderr.\n+# This creates the new include/java-chartables.h and\n+# include/java-chardecomp.h files directly.\n+# With -n, the files are not created, but all processing\n+# still occurs.\n+\n+# Fields in the table.\n+$CODE = 0;\n+$NAME = 1;\n+$CATEGORY = 2;\n+$DECOMPOSITION = 5;\n+$DECIMAL = 6;\n+$DIGIT = 7;\n+$NUMERIC = 8;\n+$UPPERCASE = 12;\n+$LOWERCASE = 13;\n+$TITLECASE = 14;\n+\n+# A special case.\n+$TAMIL_DIGIT_ONE  = 0x0be7;\n+$TAMIL_DIGIT_NINE = 0x0bef;\n+\n+# These are endpoints of legitimate gaps in the tables.\n+$CJK_IDEOGRAPH_END = 0x9fa5;\n+$HANGUL_END = 0xd7a3;\n+$HIGH_SURROGATE_END = 0xdb7f;\n+$PRIVATE_HIGH_SURROGATE_END = 0xdbff;\n+$LOW_SURROGATE_END = 0xdfff;\n+$PRIVATE_END = 0xf8ff;\n+\n+%title_to_upper = ();\n+%title_to_lower = ();\n+%numerics  = ();\n+%name = ();\n+\n+@digit_start = ();\n+@digit_end   = ();\n+\n+@space_start = ();\n+@space_end   = ();\n+\n+# @letter_start = ();\n+# @letter_end   = ();\n+\n+@all_start = ();\n+@all_end   = ();\n+@all_cats  = ();\n+\n+@upper_start = ();\n+@upper_end   = ();\n+@upper_map   = ();\n+%upper_anom  = ();\n+\n+@lower_start = ();\n+@lower_end   = ();\n+@lower_map   = ();\n+%lower_anom  = ();\n+\n+@attributes = ();\n+\n+# There are a few characters which actually need two attributes.\n+# These are special-cased.\n+$ROMAN_START = 0x2160;\n+$ROMAN_END   = 0x217f;\n+%second_attributes = ();\n+\n+$prevcode = -1;\n+$status = 0;\n+\n+%category_map =\n+(\n+ 'Mn' => 'NON_SPACING_MARK',\n+ 'Mc' => 'COMBINING_SPACING_MARK',\n+ 'Me' => 'ENCLOSING_MARK',\n+ 'Nd' => 'DECIMAL_DIGIT_NUMBER',\n+ 'Nl' => 'LETTER_NUMBER',\n+ 'No' => 'OTHER_NUMBER',\n+ 'Zs' => 'SPACE_SEPARATOR',\n+ 'Zl' => 'LINE_SEPARATOR',\n+ 'Zp' => 'PARAGRAPH_SEPARATOR',\n+ 'Cc' => 'CONTROL',\n+ 'Cf' => 'FORMAT',\n+ 'Cs' => 'SURROGATE',\n+ 'Co' => 'PRIVATE_USE',\n+ 'Cn' => 'UNASSIGNED',\n+ 'Lu' => 'UPPERCASE_LETTER',\n+ 'Ll' => 'LOWERCASE_LETTER',\n+ 'Lt' => 'TITLECASE_LETTER',\n+ 'Lm' => 'MODIFIER_LETTER',\n+ 'Lo' => 'OTHER_LETTER',\n+ 'Pc' => 'CONNECTOR_PUNCTUATION',\n+ 'Pd' => 'DASH_PUNCTUATION',\n+ 'Ps' => 'START_PUNCTUATION',\n+ 'Pe' => 'END_PUNCTUATION',\n+ 'Pi' => 'START_PUNCTUATION',\n+ 'Pf' => 'END_PUNCTUATION',\n+ 'Po' => 'OTHER_PUNCTUATION',\n+ 'Sm' => 'MATH_SYMBOL',\n+ 'Sc' => 'CURRENCY_SYMBOL',\n+ 'Sk' => 'MODIFIER_SYMBOL',\n+ 'So' => 'OTHER_SYMBOL'\n+ );\n+\n+# These maps characters to their decompositions.\n+%canonical_decomposition = ();\n+%full_decomposition = ();\n+\n+\n+# Handle `-n' and open output files.\n+local ($f1, $f2) = ('include/java-chartables.h',\n+\t\t    'include/java-chardecomp.h');\n+if ($ARGV[0] eq '-n')\n+{\n+    shift @ARGV;\n+    $f1 = '/dev/null';\n+    $f2 = '/dev/null';\n+}\n+\n+open (CHARTABLE, \"> $f1\");\n+open (DECOMP, \"> $f2\");\n+\n+# Process the Unicode file.\n+while (<>)\n+{\n+    chop;\n+    # Specify a limit for split so that we pick up trailing fields.\n+    # We make the limit larger than we need, to catch the case where\n+    # there are extra fields.\n+    @fields = split (';', $_, 30);\n+    # Convert code to number.\n+    $ncode = hex ($fields[$CODE]);\n+\n+    if ($#fields != 14)\n+    {\n+\tprint STDERR (\"Entry for \\\\u\", $fields[$CODE],\n+\t\t      \" has wrong number of fields: \", $#fields, \"\\n\");\n+    }\n+\n+    $name{$fields[$CODE]} = $fields[$NAME];\n+\n+    # If we've found a gap in the table, fill it in.\n+    if ($ncode != $prevcode + 1)\n+    {\n+\t&process_gap (*fields, $prevcode, $ncode);\n+    }\n+\n+    &process_char (*fields, $ncode);\n+\n+    $prevcode = $ncode;\n+}\n+\n+if ($prevcode != 0xffff)\n+{\n+    # Setting of `fields' parameter doesn't matter here.\n+    &process_gap (*fields, $prevcode, 0x10000);\n+}\n+\n+print CHARTABLE \"// java-chartables.h - Character tables for java.lang.Character -*- c++ -*-\\n\\n\";\n+print CHARTABLE \"#ifndef __JAVA_CHARTABLES_H__\\n\";\n+print CHARTABLE \"#define __JAVA_CHARTABLES_H__\\n\\n\";\n+print CHARTABLE \"// These tables are automatically generated by the chartables.pl\\n\";\n+print CHARTABLE \"// script.  DO NOT EDIT the tables.  Instead, fix the script\\n\";\n+print CHARTABLE \"// and run it again.\\n\\n\";\n+print CHARTABLE \"// This file should only be included by natCharacter.cc\\n\\n\";\n+\n+\n+$bytes = 0;\n+\n+# Titlecase mapping tables.\n+if ($#title_to_lower != $#title_to_upper)\n+{\n+    # If this fails we need to reimplement toTitleCase.\n+    print STDERR \"titlecase mappings have different sizes\\n\";\n+    $status = 1;\n+}\n+# Also ensure that the tables are entirely parallel.\n+foreach $key (sort keys %title_to_lower)\n+{\n+    if (! defined $title_to_upper{$key})\n+    {\n+\tprint STDERR \"titlecase mappings have different entries\\n\";\n+\t$status = 1;\n+    }\n+}\n+&print_single_map (\"title_to_lower_table\", %title_to_lower);\n+&print_single_map (\"title_to_upper_table\", %title_to_upper);\n+\n+print CHARTABLE \"#ifdef COMPACT_CHARACTER\\n\\n\";\n+\n+printf CHARTABLE \"#define TAMIL_DIGIT_ONE 0x%04x\\n\\n\", $TAMIL_DIGIT_ONE;\n+\n+# All numeric values.\n+&print_numerics;\n+\n+# Digits only.\n+&print_block (\"digit_table\", *digit_start, *digit_end);\n+\n+# Space characters.\n+&print_block (\"space_table\", *space_start, *space_end);\n+\n+# Letters.  We used to generate a separate letter table.  But this\n+# doesn't really seem worthwhile.  Simply using `all_table' saves us\n+# about 800 bytes, and only adds 3 table probes to isLetter.\n+# &print_block (\"letter_table\", *letter_start, *letter_end);\n+\n+# Case tables.\n+&print_case_table (\"upper\", *upper_start, *upper_end, *upper_map, *upper_anom);\n+&print_case_table (\"lower\", *lower_start, *lower_end, *lower_map, *lower_anom);\n+\n+# Everything else.\n+&print_all_block (*all_start, *all_end, *all_cats);\n+\n+print CHARTABLE \"#else /* COMPACT_CHARACTER */\\n\\n\";\n+\n+printf CHARTABLE \"#define ROMAN_START 0x%04x\\n\", $ROMAN_START;\n+printf CHARTABLE \"#define ROMAN_END   0x%04x\\n\\n\", $ROMAN_END;\n+\n+&print_fast_tables (*all_start, *all_end, *all_cats,\n+\t\t    *attributes, *second_attributes);\n+\n+print CHARTABLE \"#endif /* COMPACT_CHARACTER */\\n\\n\";\n+\n+print CHARTABLE \"#endif /* __JAVA_CHARTABLES_H__ */\\n\";\n+\n+printf STDERR \"Approximately %d bytes of data generated (compact case)\\n\",\n+    $bytes;\n+\n+\n+# Now generate decomposition tables.\n+printf DECOMP \"// java-chardecomp.h - Decomposition character tables -*- c++ -*-\\n\\n\";\n+printf DECOMP \"#ifndef __JAVA_CHARDECOMP_H__\\n\";\n+printf DECOMP \"#define __JAVA_CHARDECOMP_H__\\n\\n\";\n+print DECOMP \"// These tables are automatically generated by the chartables.pl\\n\";\n+print DECOMP \"// script.  DO NOT EDIT the tables.  Instead, fix the script\\n\";\n+print DECOMP \"// and run it again.\\n\\n\";\n+print DECOMP \"// This file should only be included by natCollator.cc\\n\\n\";\n+\n+print DECOMP \"struct decomp_entry\\n{\\n\";\n+print DECOMP \"  jchar key;\\n\";\n+print DECOMP \"  const char *value;\\n\";\n+print DECOMP \"};\\n\\n\";\n+\n+&write_decompositions;\n+\n+printf DECOMP \"#endif /* __JAVA_CHARDECOMP_H__ */\\n\";\n+\n+\n+close (CHARTABLE);\n+close (DECOMP);\n+\n+exit $status;\n+\n+\n+# Process a gap in the space.\n+sub process_gap\n+{\n+    local (*fields, $prevcode, $ncode) = @_;\n+    local (@gap_fields, $i);\n+\n+    if ($ncode == $CJK_IDEOGRAPH_END\n+\t|| $ncode == $HANGUL_END\n+\t|| $ncode == $HIGH_SURROGATE_END\n+\t|| $ncode == $PRIVATE_HIGH_SURROGATE_END\n+\t|| $ncode == $LOW_SURROGATE_END\n+\t|| $ncode == $PRIVATE_END)\n+    {\n+\t# The characters in the gap we just found are known to\n+\t# have the same properties as the character at the end of\n+\t# the gap.\n+\t@gap_fields = @fields;\n+    }\n+    else\n+    {\n+\t# This prints too much to be enabled.\n+\t# print STDERR \"Gap found at \\\\u\", $fields[$CODE], \"\\n\";\n+\t@gap_fields = ('', '', 'Cn', '', '', '', '', '', '', '', '',\n+\t\t       '', '', '', '');\n+    }\n+\n+    for ($i = $prevcode + 1; $i < $ncode; ++$i)\n+    {\n+\t$gap_fields[$CODE] = sprintf (\"%04x\", $i);\n+\t$gap_fields[$NAME] = \"CHARACTER \" . $gap_fields[$CODE];\n+\t&process_char (*gap_fields, $i);\n+    }\n+}\n+\n+# Process a single character.\n+sub process_char\n+{\n+    local (*fields, $ncode) = @_;\n+\n+    if ($fields[$DECOMPOSITION] ne '')\n+    {\n+\t&add_decomposition ($ncode, $fields[$DECOMPOSITION]);\n+    }\n+\n+    # If this is a titlecase character, mark it.\n+    if ($fields[$CATEGORY] eq 'Lt')\n+    {\n+\t$title_to_upper{$fields[$CODE]} = $fields[$UPPERCASE];\n+\t$title_to_lower{$fields[$CODE]} = $fields[$LOWERCASE];\n+    }\n+    else\n+    {\n+\t# For upper and lower case mappings, we try to build compact\n+\t# tables that map range onto range.  We specifically want to\n+\t# avoid titlecase characters.  Java specifies a range check to\n+\t# make sure the character is not between 0x2000 and 0x2fff.\n+\t# We avoid that here because we need to generate table entries\n+\t# -- toLower and toUpper still work in that range.\n+\tif ($fields[$UPPERCASE] eq ''\n+\t    && ($fields[$LOWERCASE] ne ''\n+\t\t|| $fields[$NAME] =~ /CAPITAL (LETTER|LIGATURE)/))\n+\t{\n+\t    if ($fields[$LOWERCASE] ne '')\n+\t    {\n+\t\t&update_case_block (*upper_start, *upper_end, *upper_map,\n+\t\t\t\t    $fields[$CODE], $fields[$LOWERCASE]);\n+\t\t&set_attribute ($ncode, hex ($fields[$LOWERCASE]));\n+\t    }\n+\t    else\n+\t    {\n+\t\t$upper_anom{$fields[$CODE]} = 1;\n+\t    }\n+\t}\n+\telsif ($fields[$LOWERCASE] ne '')\n+\t{\n+\t    print STDERR (\"Java missed upper case char \\\\u\",\n+\t\t\t  $fields[$CODE], \"\\n\");\n+\t}\n+\telsif ($fields[$CATEGORY] eq 'Lu')\n+\t{\n+\t    # This case is for letters which are marked as upper case\n+\t    # but for which there is no lower case equivalent.  For\n+\t    # instance, LATIN LETTER YR.\n+\t}\n+\n+\tif ($fields[$LOWERCASE] eq ''\n+\t    && ($fields[$UPPERCASE] ne ''\n+\t\t|| $fields[$NAME] =~ /SMALL (LETTER|LIGATURE)/))\n+\t{\n+\t    if ($fields[$UPPERCASE] ne '')\n+\t    {\n+\t\t&update_case_block (*lower_start, *lower_end, *lower_map,\n+\t\t\t\t    $fields[$CODE], $fields[$UPPERCASE]);\n+\t\t&set_attribute ($ncode, hex ($fields[$UPPERCASE]));\n+\t    }\n+\t    else\n+\t    {\n+\t\t$lower_anom{$fields[$CODE]} = 1;\n+\t    }\n+\t}\n+\telsif ($fields[$UPPERCASE] ne '')\n+\t{\n+\t    print STDERR (\"Java missed lower case char \\\\u\",\n+\t\t\t  $fields[$CODE], \"\\n\");\n+\t}\n+\telsif ($fields[$CATEGORY] eq 'Ll')\n+\t{\n+\t    # This case is for letters which are marked as lower case\n+\t    # but for which there is no upper case equivalent.  For\n+\t    # instance, FEMININE ORDINAL INDICATOR.\n+\t}\n+    }\n+\n+\n+    # If we have a non-decimal numeric value, add it to the list.\n+    if ($fields[$CATEGORY] eq 'Nd'\n+\t&& ($ncode < 0x2000 || $ncode > 0x2fff)\n+\t&& $fields[$NAME] =~ /DIGIT/)\n+    {\n+\t# This is a digit character that is handled elsewhere.\n+    }\n+    elsif ($fields[$DIGIT] ne '' || $fields[$NUMERIC] ne '')\n+    {\n+\t# Do a simple check.\n+\tif ($fields[$DECIMAL] ne '')\n+\t{\n+\t    # This catches bugs in an earlier implementation of\n+\t    # chartables.pl.  Now it is here for historical interest\n+\t    # only.\n+\t    # print STDERR (\"Character \\u\", $fields[$CODE],\n+\t    # \" would have been missed as digit\\n\");\n+\t}\n+\n+\tlocal ($val) = $fields[$DIGIT];\n+\t$val = $fields[$NUMERIC] if $val eq '';\n+\tlocal ($ok) = 1;\n+\n+\t# If we have a value which is not a positive integer, then we\n+\t# set the value to -2 to make life easier for\n+\t# Character.getNumericValue.\n+\tif ($val !~ m/^[0-9]+$/)\n+\t{\n+\t    if ($fields[$CATEGORY] ne 'Nl'\n+\t\t&& $fields[$CATEGORY] ne 'No')\n+\t    {\n+\t\t# This shows a few errors in the Unicode table.  These\n+\t\t# characters have a missing Numeric field, and the `N'\n+\t\t# for the mirrored field shows up there instead.  I\n+\t\t# reported these characters to errata@unicode.org on\n+\t\t# Thu Sep 10 1998.  They said it will be fixed in the\n+\t\t# 2.1.6 release of the tables.\n+\t\tprint STDERR (\"Character \\u\", $fields[$CODE],\n+\t\t\t      \" has value but is not numeric; val = '\",\n+\t\t\t      $val, \"'\\n\");\n+\t\t# We skip these.\n+\t\t$ok = 0;\n+\t    }\n+\t    $val = \"-2\";\n+\t}\n+\n+\tif ($ok)\n+\t{\n+\t    $numerics{$fields[$CODE]} = $val;\n+\t    &set_attribute ($ncode, $val);\n+\t}\n+    }\n+\n+    # We build a table that lists ranges of ordinary decimal values.\n+    # At each step we make sure that the digits are in the correct\n+    # order, with no holes, as this is assumed by Character.  If this\n+    # fails, reimplementation is required.  This implementation\n+    # dovetails nicely with the Java Spec, which has strange rules for\n+    # what constitutes a decimal value.  In particular the Unicode\n+    # name must contain the word `DIGIT'.  The spec doesn't directly\n+    # say that digits must have type `Nd' (or that their value must an\n+    # integer), but that can be inferred from the list of digits in\n+    # the book(s).  Currently the only Unicode characters whose name\n+    # includes `DIGIT' which would not fit are the Tibetan \"half\"\n+    # digits.\n+    if ($fields[$CATEGORY] eq 'Nd')\n+    {\n+\tif (($ncode < 0x2000 || $ncode > 0x2fff)\n+\t    && $fields[$NAME] =~ /DIGIT/)\n+\t{\n+\t    &update_digit_block (*digit_start, *digit_end, $fields[$CODE],\n+\t\t\t\t $fields[$DECIMAL]);\n+\t    &set_attribute ($ncode, $fields[$DECIMAL]);\n+\t}\n+\telse\n+\t{\n+\t    # If this fails then Character.getType will fail.  We\n+\t    # assume that things in `digit_table' are the only\n+\t    # category `Nd' characters.\n+\t    print STDERR (\"Character \\u\", $fields[$CODE],\n+\t\t\t  \" is class Nd but not in digit table\\n\");\n+\t    $status = 1;\n+\t}\n+    }\n+\n+    # Keep track of space characters.\n+    if ($fields[$CATEGORY] =~ /Z[slp]/)\n+    {\n+\t&update_block (*space_start, *space_end, $fields[$CODE]);\n+    }\n+\n+    # Keep track of letters.\n+    # if ($fields[$CATEGORY] =~ /L[ultmo]/)\n+    # {\n+    # \t&update_letter_block (*letter_start, *letter_end, $fields[$CODE],\n+    # \t\t\t      $fields[$CATEGORY]);\n+    # }\n+\n+    # Keep track of all characters.  You might think we wouldn't have\n+    # to do this for uppercase letters, or other characters we already\n+    # \"classify\".  The problem is that this classification is\n+    # different.  E.g., \\u216f is uppercase by Java rules, but is a\n+    # LETTER_NUMBER here.\n+    &update_all_block (*all_start, *all_end, *all_cats,\n+\t\t       $fields[$CODE], $fields[$CATEGORY]);\n+}\n+\n+\n+# Called to add a new decomposition.\n+sub add_decomposition\n+{\n+    local ($ncode, $value) = @_;\n+    local ($is_full) = 0;\n+    local ($first) = 1;\n+    local (@decomp) = ();\n+\n+    foreach (split (' ', $value))\n+    {\n+\tif ($first && /^\\<.*\\>$/)\n+\t{\n+\t    $is_full = 1;\n+\t}\n+\telse\n+\t{\n+\t    push (@decomp, hex ($_));\n+\t}\n+\t$first = 0;\n+    }\n+\n+    # We pack the value into a string because this means we can stick\n+    # with Perl 4 features.\n+    local ($s) = pack \"I*\", @decomp;\n+    if ($is_full)\n+    {\n+\t$full_decomposition{$ncode} = $s;\n+    }\n+    else\n+    {\n+\t$canonical_decomposition{$ncode} = $s;\n+    }\n+}\n+\n+# Write a single decomposition table.\n+sub write_single_decomposition\n+{\n+    local ($name, $is_canon, %table) = @_;\n+\n+    printf DECOMP \"static const decomp_entry ${name}_decomposition[] =\\n{\\n\";\n+\n+    local ($key, @expansion, $char);\n+    local ($first_line) = 1;\n+\n+    for ($key = 0; $key <= 65535; ++$key)\n+    {\n+\tnext if ! defined $table{$key};\n+\n+\tprintf DECOMP \",\\n\"\n+\t    unless $first_line;\n+\t$first_line = 0;\n+\n+\tprintf DECOMP \"  { 0x%04x, \\\"\", $key;\n+\n+\t# We represent the expansion as a series of bytes, terminated\n+\t# with a double nul.  This is ugly, but relatively\n+\t# space-efficient.  Most expansions are short, but there are a\n+\t# few that are very long (e.g. \\uFDFA).  This means that if we\n+\t# chose a fixed-space representation we would waste a lot of\n+\t# space.\n+\t@expansion = unpack \"I*\", $table{$key};\n+\tforeach $char (@expansion)\n+\t{\n+\t    printf DECOMP \"\\\\x%02x\\\\x%02x\", ($char / 256), ($char % 256);\n+\t}\n+\n+\tprintf DECOMP \"\\\" }\";\n+    }\n+\n+    printf DECOMP \"\\n};\\n\\n\";\n+}\n+\n+sub write_decompositions\n+{\n+    &write_single_decomposition ('canonical', 1, %canonical_decomposition);\n+    &write_single_decomposition ('full', 0, %full_decomposition);\n+}\n+\n+# We represent a block of characters with a pair of lists.  This\n+# function updates the pair to account for the new character.  Returns\n+# 1 if we added to the old block, 0 otherwise.\n+sub update_block\n+{\n+    local (*start, *end, $char) = @_;\n+\n+    local ($nchar) = hex ($char);\n+    local ($count) = $#end;\n+    if ($count >= 0 && $end[$count] == $nchar - 1)\n+    {\n+\t++$end[$count];\n+\treturn 1;\n+    }\n+    else\n+    {\n+\t++$count;\n+\t$start[$count] = $nchar;\n+\t$end[$count] = $nchar;\n+    }\n+    return 0;\n+}\n+\n+# Return true if we will be appending this character to the end of the\n+# existing block.\n+sub block_append_p\n+{\n+    local (*end, $char) = @_;\n+    return $#end >= 0 && $end[$#end] == $char - 1;\n+}\n+\n+# This updates the digit block.  This table is much like an ordinary\n+# block, but it has an extra constraint.\n+sub update_digit_block\n+{\n+    local (*start, *end, $char, $value) = @_;\n+\n+    &update_block ($start, $end, $char);\n+    local ($nchar) = hex ($char);\n+\n+    # We want to make sure that the new digit's value is correct for\n+    # its place in the block.  However, we special-case Tamil digits,\n+    # since Tamil does not have a digit `0'.\n+    local ($count) = $#start;\n+    if (($nchar < $TAMIL_DIGIT_ONE || $nchar > $TAMIL_DIGIT_NINE)\n+\t&& $nchar - $start[$count] != $value)\n+    {\n+\t# If this fails then Character.digit_value will be wrong.\n+\tprint STDERR \"Character \\\\u\", $char, \" violates digit constraint\\n\";\n+\t$status = 1;\n+    }\n+}\n+\n+# Update letter table.  We could be smart about avoiding upper or\n+# lower case letters, but it is much simpler to just track them all.\n+sub update_letter_block\n+{\n+    local (*start, *end, $char, $category) = @_;\n+\n+    &update_block (*start, *end, $char);\n+}\n+\n+# Update `all' table.  This table holds all the characters we don't\n+# already categorize for other reasons.  FIXME: if a given type has\n+# very few characters, we should just inline the code.  E.g., there is\n+# only one paragraph separator.\n+sub update_all_block\n+{\n+    local (*start, *end, *cats, $char, $category) = @_;\n+\n+    local ($nchar) = hex ($char);\n+    local ($count) = $#end;\n+    if ($count >= 0\n+\t&& $end[$count] == $nchar - 1\n+\t&& $cats[$count] eq $category)\n+    {\n+\t++$end[$count];\n+    }\n+    else\n+    {\n+\t++$count;\n+\t$start[$count] = $nchar;\n+\t$end[$count] = $nchar;\n+\t$cats[$count] = $category;\n+    }\n+}\n+\n+# Update a case table.  We handle case tables specially because we\n+# want to map (e.g.) a block of uppercase characters directly onto the\n+# corresponding block of lowercase characters.  Therefore we generate\n+# a new entry when the block would no longer map directly.\n+sub update_case_block\n+{\n+    local (*start, *end, *map, $char, $mapchar) = @_;\n+\n+    local ($nchar) = hex ($char);\n+    local ($nmap) = hex ($mapchar);\n+\n+    local ($count) = $#end;\n+    if ($count >= 0\n+\t&& $end[$count] == $nchar - 1\n+\t&& $nchar - $start[$count] == $nmap - $map[$count])\n+    {\n+\t++$end[$count];\n+    }\n+    else\n+    {\n+\t++$count;\n+\t$start[$count] = $nchar;\n+\t$end[$count] = $nchar;\n+\t$map[$count] = $nmap;\n+    }\n+}\n+\n+# Set the attribute value for the character.  Each character can have\n+# only one attribute.\n+sub set_attribute\n+{\n+    local ($ncode, $attr) = @_;\n+\n+    if ($attributes{$ncode} ne '' && $attributes{$ncode} ne $attr)\n+    {\n+\tif ($ncode >= $ROMAN_START && $ncode <= $ROMAN_END)\n+\t{\n+\t    $second_attributes{$ncode} = $attr;\n+\t}\n+\telse\n+\t{\n+\t    printf STDERR \"character \\\\u%04x already has attribute\\n\", $ncode;\n+\t}\n+    }\n+    # Attributes can be interpreted as unsigned in some situations,\n+    # so we check against 65535.  This could cause errors -- we need\n+    # to check the interpretation here.\n+    elsif ($attr < -32768 || $attr > 65535)\n+    {\n+\tprintf STDERR \"attribute out of range for character \\\\u%04x\\n\", $ncode;\n+    }\n+    else\n+    {\n+\t$attributes{$ncode} = $attr;\n+    }\n+}\n+\n+\n+# Print a block table.\n+sub print_block\n+{\n+    local ($title, *start, *end) = @_;\n+\n+    print CHARTABLE \"static const jchar \", $title, \"[][2] =\\n\";\n+    print CHARTABLE \"  {\\n\";\n+\n+    local ($i) = 0;\n+    while ($i <= $#start)\n+    {\n+\tprint CHARTABLE \"    { \";\n+\t&print_char ($start[$i]);\n+\tprint CHARTABLE \", \";\n+\t&print_char ($end[$i]);\n+\tprint CHARTABLE \" }\";\n+\tprint CHARTABLE \",\" if ($i != $#start);\n+\tprint CHARTABLE \"\\n\";\n+\t++$i;\n+\t$bytes += 4;\t\t# Two bytes per char.\n+    }\n+\n+    print CHARTABLE \"  };\\n\\n\";\n+}\n+\n+# Print the numerics table.\n+sub print_numerics\n+{\n+    local ($i, $key, $count, @keys);\n+\n+    $i = 0;\n+    @keys = sort keys %numerics;\n+    $count = @keys;\n+\n+    print CHARTABLE \"static const jchar numeric_table[] =\\n\";\n+    print CHARTABLE \"  { \";\n+    foreach $key (@keys)\n+    {\n+\t&print_char (hex ($key));\n+\t++$i;\n+\tprint CHARTABLE \", \" if $i < $count;\n+\t# Print 5 per line.\n+\tprint CHARTABLE \"\\n    \" if ($i % 5 == 0);\n+\t$bytes += 2;\t\t# One character.\n+    }\n+    print CHARTABLE \" };\\n\\n\";\n+\n+    print CHARTABLE \"static const jshort numeric_value[] =\\n\";\n+    print CHARTABLE \"  { \";\n+    $i = 0;\n+    foreach $key (@keys)\n+    {\n+\tprint CHARTABLE $numerics{$key};\n+\tif ($numerics{$key} > 32767 || $numerics{$key} < -32768)\n+\t{\n+\t    # This means our generated type info is incorrect.  We\n+\t    # could just detect and work around this here, but I'm\n+\t    # lazy.\n+\t    print STDERR \"numeric value won't fit in a short\\n\";\n+\t    $status = 1;\n+\t}\n+\t++$i;\n+\tprint CHARTABLE \", \" if $i < $count;\n+\t# Print 10 per line.\n+\tprint CHARTABLE \"\\n    \" if ($i % 10 == 0);\n+\t$bytes += 2;\t\t# One short.\n+    }\n+    print CHARTABLE \" };\\n\\n\";\n+}\n+\n+# Print a table that maps one single letter onto another.  It assumes\n+# the map is index by char code.\n+sub print_single_map\n+{\n+    local ($title, %map) = @_;\n+\n+    local (@keys) = sort keys %map;\n+    $num = @keys;\n+    print CHARTABLE \"static const jchar \", $title, \"[][2] =\\n\";\n+    print CHARTABLE \"  {\\n\";\n+    $i = 0;\n+    for $key (@keys)\n+    {\n+\tprint CHARTABLE \"    { \";\n+\t&print_char (hex ($key));\n+\tprint CHARTABLE \", \";\n+\t&print_char (hex ($map{$key}));\n+\tprint CHARTABLE \" }\";\n+\t++$i;\n+\tif ($i < $num)\n+\t{\n+\t    print CHARTABLE \",\";\n+\t}\n+\telse\n+\t{\n+\t    print CHARTABLE \" \";\n+\t}\n+\tprint CHARTABLE \"   // \", $name{$key}, \"\\n\";\n+\t$bytes += 4;\t\t# Two bytes per char.\n+    }\n+    print CHARTABLE \"  };\\n\\n\";\n+}\n+\n+# Print the `all' block.\n+sub print_all_block\n+{\n+    local (*start, *end, *cats) = @_;\n+\n+    &print_block (\"all_table\", *start, *end);\n+\n+    local ($i) = 0;\n+    local ($sum) = 0;\n+    while ($i <= $#start)\n+    {\n+\t$sum += $end[$i] - $start[$i] + 1;\n+\t++$i;\n+    }\n+    # We do this computation just to make sure it isn't cheaper to\n+    # simply list all the characters individually.\n+    printf STDERR (\"all_table encodes %d characters in %d entries\\n\",\n+\t\t   $sum, $#start + 1);\n+\n+    print CHARTABLE \"static const jbyte category_table[] =\\n\";\n+    print CHARTABLE \"  { \";\n+\n+    $i = 0;\n+    while ($i <= $#cats)\n+    {\n+\tif ($i > 0 && $cats[$i] eq $cats[$i - 1])\n+\t{\n+\t    # This isn't an error.  We can have a duplicate because\n+\t    # two ranges are not adjacent while the intervening\n+\t    # characters are left out of the table for other reasons.\n+\t    # We could exploit this to make the table a little smaller.\n+\t    # printf STDERR \"Duplicate all entry at \\\\u%04x\\n\", $start[$i];\n+\t}\n+\tprint CHARTABLE 'java::lang::Character::', $category_map{$cats[$i]};\n+\tprint CHARTABLE \", \" if ($i < $#cats);\n+\t++$i;\n+\tprint CHARTABLE \"\\n    \";\n+\t++$bytes;\n+    }\n+    print CHARTABLE \"  };\\n\\n\";\n+}\n+\n+# Print case table.\n+sub print_case_table\n+{\n+    local ($title, *start, *end, *map, *anomalous) = @_;\n+\n+    &print_block ($title . '_case_table', *start, *end);\n+\n+    print CHARTABLE \"static const jchar \", $title, \"_case_map_table[] =\\n\";\n+    print CHARTABLE \"  { \";\n+\n+    local ($i) = 0;\n+    while ($i <= $#map)\n+    {\n+\t&print_char ($map[$i]);\n+\tprint CHARTABLE \", \" if $i < $#map;\n+\t++$i;\n+\tprint CHARTABLE \"\\n    \" if $i % 5 == 0;\n+\t$bytes += 2;\n+    }\n+    print CHARTABLE \"  };\\n\";\n+\n+\n+    local ($key, @keys);\n+    @keys = sort keys %anomalous;\n+\n+    if ($title eq 'upper')\n+    {\n+\tif ($#keys >= 0)\n+\t{\n+\t    # If these are found we need to change Character.isUpperCase.\n+\t    print STDERR \"Found anomalous upper case characters\\n\";\n+\t    $status = 1;\n+\t}\n+    }\n+    else\n+    {\n+\tprint CHARTABLE \"\\n\";\n+\tprint CHARTABLE \"static const jchar \", $title, \"_anomalous_table[] =\\n\";\n+\tprint CHARTABLE \"  { \";\n+\t$i = 0;\n+\tforeach $key (@keys)\n+\t{\n+\t    &print_char (hex ($key));\n+\t    print CHARTABLE \", \" if $i < $#keys;\n+\t    ++$i;\n+\t    print CHARTABLE \"\\n    \" if $i % 5 == 0;\n+\t    $bytes += 2;\n+\t}\n+\tprint CHARTABLE \"  };\\n\";\n+    }\n+\n+    print CHARTABLE \"\\n\";\n+}\n+\n+# Print the type table and attributes table for the fast version.\n+sub print_fast_tables\n+{\n+    local (*start, *end, *cats, *atts, *second_atts) = @_;\n+\n+    print CHARTABLE \"static const jbyte type_table[] =\\n{ \";\n+\n+    local ($i, $j);\n+    for ($i = 0; $i <= $#cats; ++$i)\n+    {\n+\tfor ($j = $start[$i]; $j <= $end[$i]; ++$j)\n+\t{\n+\t    print CHARTABLE 'java::lang::Character::', $category_map{$cats[$i]};\n+\t    print CHARTABLE \",\" if ($i < $#cats || $j < $end[$i]);\n+\t    print CHARTABLE \"\\n    \";\n+\t}\n+    }\n+    print CHARTABLE \"\\n };\\n\\n\";\n+\n+    print CHARTABLE \"static const jshort attribute_table[] =\\n{ \";\n+    for ($i = 0; $i <= 0xffff; ++$i)\n+    {\n+\t$atts{$i} = 0 if ! defined $atts{$i};\n+\tprint CHARTABLE $atts{$i};\n+\tprint CHARTABLE \", \" if $i < 0xffff;\n+\tprint CHARTABLE \"\\n    \" if $i % 5 == 1;\n+    }\n+    print CHARTABLE \"\\n };\\n\\n\";\n+\n+    print CHARTABLE \"static const jshort secondary_attribute_table[] =\\n{ \";\n+    for ($i = $ROMAN_START; $i <= $ROMAN_END; ++$i)\n+    {\n+\tprint CHARTABLE $second_atts{$i};\n+\tprint CHARTABLE \", \" if $i < $ROMAN_END;\n+\tprint CHARTABLE \"\\n    \" if $i % 5 == 1;\n+    }\n+    print CHARTABLE \"\\n };\\n\\n\";\n+}\n+\n+# Print a character constant.\n+sub print_char\n+{\n+    local ($ncode) = @_;\n+    printf CHARTABLE \"0x%04x\", $ncode;\n+}"}, {"sha": "4db80a08c2e3c6b2e16662ffe296e373a643540d", "filename": "libjava/classes.pl", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fclasses.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fclasses.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasses.pl?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,104 @@\n+# classes.pl - A perl program to generate most of the contents of\n+# javaprims.h automatically.\n+\n+# Copyright (C) 1998, 1999  Cygnus Solutions\n+#\n+# This file is part of libjava.\n+#\n+# This software is copyrighted work licensed under the terms of the\n+# Libjava License.  Please consult the file \"LIBJAVA_LICENSE\" for\n+# details.\n+\n+# Usage: cd <top-srcdir> ; perl classes.pl.\n+# Can also be run from the `include' directory; this lets us\n+# more easily insert the output into javaprims.h (which is where it goes).\n+\n+use DirHandle;\n+\n+if (-d 'java')\n+{\n+    # Ok here.\n+}\n+elsif (-d '../java')\n+{\n+    chdir ('..');\n+}\n+else\n+{\n+    die \"couldn't find java directory\\n\";\n+}\n+\n+&scan ('java', 2);\n+\n+exit 0;\n+\n+sub scan\n+{\n+    local ($dir, $indent) = @_;\n+    local (@subdirs) = ();\n+    local (@classes) = ();\n+\n+    local ($d) = new DirHandle $dir;\n+    local (*JFILE);\n+    local ($name);\n+    if (defined $d)\n+    {\n+\twhile (defined ($name = $d->read))\n+\t{\n+\t    next if $name eq 'CVS';\n+\t    next if $name eq '.';\n+\t    next if $name eq '..';\n+\t    if ($dir eq 'java'\n+\t\t&& $name ne 'lang'\n+\t\t&& $name ne 'util'\n+\t\t&& $name ne 'io')\n+\t    {\n+\t\t# We only generate decls for java.lang, java.io, and\n+\t\t# java.util.\n+\t\tnext;\n+\t    }\n+\t    if (-d ($dir . '/' . $name))\n+\t    {\n+\t\tpush (@subdirs, $name);\n+\t\tnext;\n+\t    }\n+\t    next unless $name =~ /\\.java$/;\n+\n+\t    open (FILE, \"< $dir/$name\");\n+\t    while (<FILE>)\n+\t    {\n+\t\t# NOTE: we don't skip `/*' comments.\n+\t\ts,//.*$,,;\n+\t\t# For now assume that class names start with upper\n+\t\t# case letter.\n+\t\tnext unless /(class|interface) ([A-Z][A-Za-z0-9]+)/;\n+\t\tpush (@classes, $2);\n+\t    }\n+\t    close (FILE);\n+\t}\n+\n+\tundef $d;\n+    }\n+\n+    local ($spaces) = ' ' x $indent;\n+    local ($classname);\n+    ($classname = $dir) =~ s/^.*\\///;\n+    print $spaces, \"namespace \", $classname, \"\\n\";\n+    print $spaces, \"{\\n\";\n+\n+    foreach (sort @classes)\n+    {\n+\tprint $spaces, \"  class \", $_, \";\\n\";\n+    }\n+    print \"\\n\" if scalar @classes > 0 && scalar @subdirs > 0;\n+\n+    local ($first) = 1;\n+    foreach (sort @subdirs)\n+    {\n+\tprint \"\\n\" unless $first;\n+\t$first = 0;\n+\t&scan (\"$dir/$_\", $indent + 2);\n+    }\n+\n+    print $spaces, \"};\\n\";\n+}"}, {"sha": "84067083648424a5f6ad16c724af9a7252d8a3e1", "filename": "libjava/configure", "status": "added", "additions": 3783, "deletions": 0, "changes": 3783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "61e722b559802dc2fbcd524f2201fe73cfa09b88", "filename": "libjava/configure.host", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,61 @@\n+# configure.host\n+\n+# This shell script handles all host based configuration for libgcj.\n+# It sets various shell variables based on the the host and the\n+# configuration options.  You can modify this shell script without\n+# needing to rerun autoconf.\n+\n+# This shell script should be invoked as\n+#   . configure.host\n+# If it encounters an error, it will exit with a message.\n+\n+# It uses the following shell variables:\n+#   host\t\tThe configuration host\n+#   host_cpu\t\tThe configuration host CPU\n+#   target_optspace\t--enable-target-optspace (\"yes\", \"no\", \"\")\n+\n+# It sets the following shell variables:\n+#   libgcj_cflags\tSpecial CFLAGS to use when building\n+#   libgcj_cxxflags\tSpecial CXXFLAGS to use when building\n+#   libgcj_javaflags\tSpecial JAVAFLAGS to use when building\n+\n+libgcj_flags=\n+libgcj_cflags=\n+libgcj_cxxflags=\n+libgcj_javaflags=\n+\n+case \"${target_optspace}:${host}\" in\n+  yes:*)\n+    libgcj_flags=\"${libgcj_flags} -Os\"\n+    ;;\n+  :m32r-* | :d10v-* | :d30v-*)\n+    libgcj_flags=\"${libgcj_flags} -Os\"\n+    ;;\n+  no:* | :*)\n+    # Nothing.\n+    ;;\n+esac\n+\n+AM_RUNTESTFLAGS= \n+\n+# Set any host dependent compiler flags.\n+# THIS TABLE IS SORTED.  KEEP IT THAT WAY.\n+\n+echo \"$target\"\n+\n+case \"${host}\" in\n+  mips-tx39-*|mipstx39-unknown-*)\n+\tlibgcj_flags=\"${libgcj_flags} -G 0\"\n+\tLDFLAGS=\"$LDFLAGS -Tjmr3904dram.ld\"\n+\tAM_RUNTESTFLAGS=\"--target_board=jmr3904-sim\"\n+\t;;\n+  i686-*|i586-*)\n+\tlibgcj_flags=\"${libgcj_flags} -ffloat-store\"\n+\t;;\n+  *)\n+\t;;\n+esac\n+\n+libgcj_cflags=\"${libgcj_cflags} ${libgcj_flags}\"\n+libgcj_cxxflags=\"${libgcj_cxxflags} ${libgcj_flags}\"\n+libgcj_javaflags=\"${libgcj_javaflags} ${libgcj_flags}\""}, {"sha": "98083c9d6da6c11a5c1048c0cebd38b3e7cbacbc", "filename": "libjava/configure.in", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,387 @@\n+dnl Process this with autoconf to create configure\n+AC_INIT(java/lang/System.java)\n+\n+dnl Can't be done in LIBGCJ_CONFIGURE because that confuses automake. \n+AC_CONFIG_AUX_DIR(..)\n+\n+AC_CANONICAL_SYSTEM\n+\n+dnl We use these options to decide which functions to include.\n+AC_ARG_WITH(target-subdir,\n+[  --with-target-subdir=SUBDIR      Configuring in a subdirectory])\n+AC_ARG_WITH(cross-host,\n+[  --with-cross-host=HOST           Configuring with a cross compiler])\n+\n+LIBGCJ_CONFIGURE(.)\n+\n+AM_CONFIG_HEADER(include/config.h)\n+\n+if test -z \"$with_target_subdir\" || test \"$with_target_subdir\" = \".\"; then\n+   COMPPATH=.\n+else\n+   COMPPATH=..\n+fi\n+AC_SUBST(COMPPATH)\n+\n+dnl The -no-testsuite modules omit the test subdir.\n+AM_CONDITIONAL(TESTSUBDIR, test -d $srcdir/testsuite)\n+\n+dnl See whether the user prefers size or speed for Character.\n+dnl The default is size.\n+AC_ARG_ENABLE(fast-character,\n+[  --enable-fast-character          Prefer speed over size for Character],\n+# Nothing\n+, AC_DEFINE(COMPACT_CHARACTER))\n+\n+dnl See if the user has requested runtime debugging.\n+AC_ARG_ENABLE(libgcj-debug,\n+[  --enable-libgcj-debug           Enable runtime debugging code],\n+  if test \"$enable_libgcj_debug\" = yes; then\n+     AC_DEFINE(DEBUG)\n+  fi)\n+\n+dnl If the target is an eCos system, use the appropriate eCos\n+dnl I/O routines.\n+dnl FIXME: this should not be a local option but a global target\n+dnl system; at present there is no eCos target.\n+TARGET_ECOS=\"no\"\n+AC_ARG_WITH(ecos,\n+[  --with-ecos      Enable runtime eCos target support.],\n+TARGET_ECOS=\"$with_ecos\"\n+)\n+\n+case \"$TARGET_ECOS\" in\n+   no)\n+      FILE_DESCRIPTOR=natFileDescriptorPosix.cc\n+      ;;\n+   *)\n+      FILE_DESCRIPTOR=natFileDescriptorEcos.cc\n+      AC_DEFINE(ECOS)\n+      ;;\n+esac\n+\n+AC_EGREP_HEADER(__uint32_t, sys/types.h, AC_DEFINE(HAVE_INT32_DEFINED))\n+AC_EGREP_HEADER(__uint32_t, sys/config.h, AC_DEFINE(HAVE_INT32_DEFINED))\n+\n+dnl These may not be defined in a non-ANS conformant embedded system.\n+dnl FIXME: Should these case a runtime exception in that case?\n+AC_EGREP_HEADER(mktime, time.h, AC_DEFINE(HAVE_MKTIME))\n+AC_EGREP_HEADER(localtime, time.h, AC_DEFINE(HAVE_LOCALTIME))\n+\n+dnl Create the subdirectory for natFileDescriptor.cc, or the attempt\n+dnl to create the link will fail.\n+test -d java || mkdir java\n+test -d java/io || mkdir java/io\n+AC_LINK_FILES(java/io/$FILE_DESCRIPTOR, java/io/natFileDescriptor.cc)\n+\n+dnl Allow the GC to be disabled.  Can be useful when debugging.\n+AC_MSG_CHECKING([for garbage collector to use])\n+AC_ARG_ENABLE(java-gc,\n+changequote(<<,>>)dnl\n+<<  --enable-java-gc=TYPE    choose garbage collector [boehm]>>,\n+changequote([,])\n+  GC=$enableval,\n+  GC=boehm)\n+GCLIBS=\n+GCINCS=\n+GCDEPS=\n+GCOBJS=\n+case \"$GC\" in\n+ boehm)\n+    AC_MSG_RESULT(boehm)\n+    GCLIBS='-L$(top_builddir)/../boehm-gc -lgcjgc'\n+    GCDEPS='$(top_builddir)/../boehm-gc/libgcjgc.a'\n+    GCINCS='-I$(top_srcdir)/../boehm-gc -I$(top_builddir)/../boehm-gc'\n+    dnl We also want to pick up some cpp flags required when including\n+    dnl boehm-config.h.  Yuck.\n+    GCINCS=\"$GCINCS `cat ../boehm-gc/boehm-cflags`\"\n+    GCOBJS=boehm.o\n+    GCHDR=boehm-gc.h\n+    dnl The POSIX thread support needs to know this.\n+    AC_DEFINE(HAVE_BOEHM_GC)\n+    ;;\n+ no)\n+    AC_MSG_RESULT(none)\n+    GCOBJS=nogc.o\n+    GCHDR=no-gc.h\n+    ;;\n+ *)\n+    AC_MSG_ERROR(unrecognized collector \\\"$GC\\\")\n+    ;;\n+esac\n+AC_SUBST(GCLIBS)\n+AC_SUBST(GCINCS)\n+AC_SUBST(GCDEPS)\n+AC_SUBST(GCOBJS)\n+AC_LINK_FILES(include/$GCHDR, include/java-gc.h)\n+\n+\n+dnl Note that this code is kept in sync with similar code in gcc/configure.in.\n+dnl In particular both packages must make the same decision about which\n+dnl thread package to use.\n+AC_MSG_CHECKING([for threads package to use])\n+AC_ARG_ENABLE(threads, [  --enable-threads=TYPE    choose threading package],\n+  THREADS=$enableval,\n+  dnl FIXME: figure out native threads to use here.\n+  THREADS=no)\n+\n+if test \"$THREADS\" = yes; then\n+   case \"$host\" in\n+    *-*-vxworks*)\n+       THREADS=vxworks\n+       ;;\n+    *-*-linux*)\n+       # FIXME: this isn't correct in all cases.\n+       THREADS=posix\n+       ;;\n+    *-*-win*)\n+       THREADS=win32\n+       ;;\n+    *-*-irix*)\n+       THREADS=irix\n+       ;;\n+    *-*-solaris*)\n+       # FIXME: for now, choose POSIX, because we implement that.\n+       # Later, choose solaris threads.\n+       THREADS=posix\n+       ;;\n+    *)\n+       # For now.\n+       THREADS=none\n+       ;;\n+   esac\n+fi\n+\n+case \"$THREADS\" in\n+ no | none | single)\n+    THREADS=none\n+    ;;\n+ posix | pthreads)\n+    THREADS=posix\n+    case \"$host\" in\n+     *-*-linux*)\n+\tAC_DEFINE(LINUX_THREADS)\n+\t;;\n+    esac\n+    ;;\n+ qt)\n+    ;;\n+ decosf1 | irix | mach | os2 | solaris | win32 | dce | vxworks)\n+    AC_MSG_ERROR(thread package $THREADS not yet supported)\n+    ;;\n+ *)\n+    AC_MSG_ERROR($THREADS is an unknown thread package)\n+    ;;\n+esac\n+AC_MSG_RESULT($THREADS)\n+\n+THREADLIBS=\n+THREADINCS=\n+THREADDEPS=\n+THREADOBJS=\n+THREADH=\n+case \"$THREADS\" in\n+ posix)\n+    THREADLIBS=-lpthread\n+    THREADOBJS=posix-threads.o\n+    THREADH=posix-threads.h\n+    # MIT pthreads doesn't seem to have the mutexattr functions.\n+    # But for now we don't check for it.  We just assume you aren't\n+    # using MIT pthreads.\n+    AC_DEFINE(HAVE_PTHREAD_MUTEXATTR_INIT)\n+    ;;\n+\n+ qt)\n+    THREADLIBS='-L$(top_builddir)/../qthreads -lgcjcoop'\n+    THREADOBJS=quick-threads.o\n+    THREADINCS='-I$(top_srcdir)/../qthreads'\n+    THREADH=quick-threads.h\n+    THREADDEPS='$(top_builddir)/../qthreads/libgcjcoop.a'\n+    ;;\n+\n+ none)\n+    THREADOBJS=no-threads.o\n+    THREADH=no-threads.h\n+    ;;\n+esac\n+AC_LINK_FILES(include/$THREADH, include/java-threads.h)\n+AC_SUBST(THREADLIBS)\n+AC_SUBST(THREADINCS)\n+AC_SUBST(THREADDEPS)\n+AC_SUBST(THREADOBJS)\n+\n+AM_CONDITIONAL(USING_GCC, test \"$GCC\" = yes)\n+\n+CANADIAN=no\n+NULL_TARGET=no\n+\n+# Find eh-common.h and support headers.  If we're in the tree with\n+# gcc, then look there.  Otherwise look in compat-include.  If all else\n+# fails, just hope the user has set things up somehow.\n+if test -r $srcdir/../gcc/eh-common.h; then\n+   EH_COMMON_INCLUDE='-I$(top_srcdir)/../gcc -I$(top_srcdir)/../include'\n+else\n+   if test -d $srcdir/../compat-include; then\n+      EH_COMMON_INCLUDE='-I$(top_srcdir)/../compat-include'\n+   else\n+      EH_COMMON_INCLUDE=\n+   fi\n+fi\n+\n+if test -n \"${with_cross_host}\"; then\n+   # We are being configured with a cross compiler.  AC_REPLACE_FUNCS\n+   # may not work correctly, because the compiler may not be able to\n+   # link executables.\n+\n+   # We assume newlib.  This lets us hard-code the functions we know\n+   # we'll have.\n+   AC_DEFINE(HAVE_MEMMOVE)\n+   AC_DEFINE(HAVE_MEMCPY)\n+   AC_DEFINE(HAVE_STRERROR)\n+   AC_DEFINE(HAVE_CTIME_R)\n+   AC_DEFINE(HAVE_GMTIME_R)\n+   AC_DEFINE(HAVE_LOCALTIME_R)\n+   dnl This is only for POSIX threads.\n+   AC_DEFINE(HAVE_PTHREAD_MUTEXATTR_INIT)\n+   dnl We also assume we are using gcc, which provides alloca.\n+   AC_DEFINE(HAVE_ALLOCA)\n+\n+   # If Canadian cross, then don't pick up tools from the build\n+   # directory.\n+   if test \"$build\" != \"$with_cross_host\"; then\n+      CANADIAN=yes\n+      EH_COMMON_INCLUDE=\n+   fi\n+else\n+   # Some POSIX thread systems don't have pthread_mutexattr_settype.\n+   # E.g., Solaris.\n+   AC_CHECK_FUNCS(strerror ioctl select open fsync sleep)\n+   AC_CHECK_FUNCS(ctime_r ctime, break)\n+   AC_CHECK_FUNCS(gmtime_r localtime_r readdir_r getpwuid_r)\n+   AC_CHECK_FUNCS(access stat mkdir rename rmdir unlink realpath)\n+   AC_CHECK_FUNCS(inet_aton inet_addr, break)\n+   AC_CHECK_FUNCS(inet_pton uname)\n+\n+   AC_CHECK_FUNCS(gethostbyname_r, [\n+     AC_DEFINE(HAVE_GETHOSTBYNAME_R)\n+     # There are two different kinds of gethostbyname_r.\n+     # We look for the one that returns `int'.\n+     # Hopefully this check is robust enough.\n+     AC_EGREP_HEADER(int.*gethostbyname_r, netdb.h, [\n+       AC_DEFINE(GETHOSTBYNAME_R_RETURNS_INT)])])\n+\n+   AC_CHECK_FUNCS(gethostbyaddr_r, [\n+     AC_DEFINE(HAVE_GETHOSTBYADDR_R)\n+     # There are two different kinds of gethostbyaddr_r.\n+     # We look for the one that returns `int'.\n+     # Hopefully this check is robust enough.\n+     AC_EGREP_HEADER(int.*gethostbyaddr_r, netdb.h, [\n+       AC_DEFINE(GETHOSTBYADDR_R_RETURNS_INT)])])\n+\n+   AC_CHECK_FUNCS(gethostname, [\n+     AC_DEFINE(HAVE_GETHOSTNAME)\n+     AC_EGREP_HEADER(gethostname, unistd.h, [\n+       AC_DEFINE(HAVE_GETHOSTNAME_DECL)])])\n+\n+   # Look for these functions in the thread library.\n+   save_LIBS=\"$LIBS\"\n+   LIBS=\"$LIBS $THREADLIBS\"\n+   AC_CHECK_FUNCS(pthread_mutexattr_settype pthread_mutexattr_setkind_np sched_yield)\n+   LIBS=\"$save_LIBS\"\n+\n+   # We require a way to get the time.\n+   time_found=no\n+   AC_CHECK_FUNCS(gettimeofday time ftime, time_found=yes)\n+   if test \"$time_found\" = no; then\n+      AC_MSG_ERROR([no function found to get the time])\n+   fi\n+\n+   # We require memmove.\n+   memmove_found=no\n+   AC_CHECK_FUNCS(memmove, memmove_found=yes)\n+   if test \"$memmove_found\" = no; then\n+      AC_MSG_ERROR([memmove is required])\n+   fi\n+\n+   # We require memcpy.\n+   memcpy_found=no\n+   AC_CHECK_FUNCS(memcpy, memcpy_found=yes)\n+   if test \"$memcpy_found\" = no; then\n+      AC_MSG_ERROR([memcpy is required])\n+   fi\n+\n+   test -d \"$libgcj_basedir/../gcc/java\" || {\n+      CANADIAN=yes\n+      NULL_TARGET=yes\n+   }\n+fi\n+\n+AM_CONDITIONAL(CANADIAN, test \"$CANADIAN\" = yes)\n+AM_CONDITIONAL(NULL_TARGET, test \"$NULL_TARGET\" = yes)\n+AM_CONDITIONAL(NATIVE, test \"$CANADIAN\" = no || test \"$NULL_TARGET\" = yes)\n+\n+AC_SUBST(EH_COMMON_INCLUDE)\n+\n+AC_SUBST(AM_RUNTESTFLAGS)\n+\n+dnl We check for sys/filio.h because Solaris 2.5 defines FIONREAD there.\n+dnl On that system, sys/ioctl.h will not include sys/filio.h unless\n+dnl BSD_COMP is defined; just including sys/filio.h is simpler.\n+AC_CHECK_HEADERS(unistd.h sys/time.h sys/types.h fcntl.h sys/ioctl.h sys/filio.h sys/stat.h sys/select.h sys/socket.h netinet/in.h arpa/inet.h netdb.h pwd.h)\n+dnl We avoid AC_HEADER_DIRENT since we really only care about dirent.h\n+dnl for now.  If you change this, you also must update natFile.cc.\n+AC_CHECK_HEADERS(dirent.h)\n+\n+AC_MSG_CHECKING([whether struct sockaddr_in6 is in netinet/in.h])\n+AC_TRY_COMPILE([#include <netinet/in.h>], [struct sockaddr_in6 addr6;],\n+  [AC_DEFINE(HAVE_INET6)\n+   AC_MSG_RESULT(yes)],\n+  [AC_MSG_RESULT(no)])\n+\n+AC_MSG_CHECKING([for socklen_t in sys/socket.h])\n+AC_TRY_COMPILE([#include <sys/socket.h>], [socklen_t x = 5;],\n+  [AC_DEFINE(HAVE_SOCKLEN_T)\n+   AC_MSG_RESULT(yes)],\n+  [AC_MSG_RESULT(no)])\n+\n+AC_MSG_CHECKING([for tm_gmtoff in struct tm])\n+AC_TRY_COMPILE([#include <time.h>], [struct tm tim; tim.tm_gmtoff = 0;],\n+  [AC_DEFINE(STRUCT_TM_HAS_GMTOFF)\n+   AC_MSG_RESULT(yes)],\n+  [AC_MSG_RESULT(no)\n+   AC_MSG_CHECKING([for global timezone variable])\n+   dnl FIXME: we don't want a link check here because that won't work\n+   dnl when cross-compiling.  So instead we make an assumption that\n+   dnl the header file will mention timezone if it exists.\n+   AC_TRY_COMPILE([#include <time.h>], [long z2 = timezone;],\n+     [AC_DEFINE(HAVE_TIMEZONE)\n+      AC_MSG_RESULT(yes)],\n+     [AC_MSG_RESULT(no)])])\n+\n+AC_FUNC_ALLOCA\n+\n+AC_CHECK_PROGS(PERL, perl, false)\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+here=`pwd`\n+AC_SUBST(here)\n+\n+AC_OUTPUT(Makefile testsuite/Makefile,\n+[if test -n \"$CONFIG_FILES\"; then\n+  ac_file=Makefile . ${libgcj_basedir}/../config-ml.in\n+fi],\n+srcdir=${srcdir}\n+host=${host}\n+target=${target}\n+with_multisubdir=${with_multisubdir}\n+ac_configure_args=\"${multilib_arg} ${ac_configure_args}\"\n+CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n+libgcj_basedir=${libgcj_basedir}\n+CC=\"${CC}\"\n+CXX=\"${CXX}\"\n+)"}, {"sha": "02554319508eed7e51a512d47d780c61a7048bd0", "filename": "libjava/doc/cni.sgml", "status": "added", "additions": 972, "deletions": 0, "changes": 972, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fdoc%2Fcni.sgml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fdoc%2Fcni.sgml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fcni.sgml?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,972 @@\n+<!DOCTYPE article PUBLIC \"-//Davenport//DTD DocBook V3.0//EN\">\n+<article>\n+<artheader>\n+<title>The Cygnus Native Interface for C++/Java Integration</title>\n+<subtitle>Writing native Java methods in natural C++</subtitle>\n+<authorgroup>\n+<corpauthor>Cygnus Solutions</corpauthor>\n+</authorgroup>\n+<date>February, 1999</date>\n+</artheader>\n+\n+<abstract><para>\n+This documents CNI, the Cygnus Native Interface,\n+which is is a convenient way to write Java native methods using C++.\n+This is a more efficient, more convenient, but less portable\n+alternative to the standard JNI (Java Native Interface).</para>\n+</abstract>\n+\n+<sect1><title>Basic Concepts</title>\n+<para>\n+In terms of languages features, Java is mostly a subset\n+of C++.  Java has a few important extensions, plus a powerful standard\n+class library, but on the whole that does not change the basic similarity.\n+Java is a hybrid object-oriented language, with a few native types,\n+in addition to class types.  It is class-based, where a class may have\n+static as well as per-object fields, and static as well as instance methods.\n+Non-static methods may be virtual, and may be overloaded.  Overloading is\n+resolved at compile time by matching the actual argument types against\n+the parameter types.  Virtual methods are implemented using indirect calls\n+through a dispatch table (virtual function table).  Objects are\n+allocated on the heap, and initialized using a constructor method.\n+Classes are organized in a package hierarchy.\n+</para>\n+<para>\n+All of the listed attributes are also true of C++, though C++ has\n+extra features (for example in C++ objects may be allocated not just\n+on the heap, but also statically or in a local stack frame).  Because\n+<acronym>gcj</acronym> uses the same compiler technology as\n+<acronym>g++</acronym> (the GNU C++ compiler), it is possible\n+to make the intersection of the two languages use the same\n+<acronym>ABI</acronym> (object representation and calling conventions).\n+The key idea in <acronym>CNI</acronym> is that Java objects are C++ objects,\n+and all Java classes are C++ classes (but not the other way around).\n+So the most important task in integrating Java and C++ is to\n+remove gratuitous incompatibilities.\n+</para>\n+<para>\n+You write CNI code as a regular C++ source file.  (You do have to use\n+a Java/CNI-aware C++ compiler, specifically a recent version of G++.)</para>\n+<para>\n+You start with:\n+<programlisting>\n+#include &lt;cni.h&gt;\n+</programlisting></para>\n+\n+<para>\n+You then include header files for the various Java classes you need\n+to use:\n+<programlisting>\n+#include &lt;java/lang/Character.h&gt;\n+#include &lt;java/util/Date.h&gt;\n+#include &lt;java/lang/IndexOutOfBoundsException.h&gt;\n+</programlisting></para>\n+\n+<para>\n+In general, <acronym>CNI</acronym> functions and macros start with the\n+`<literal>Jv</literal>' prefix, for example the function\n+`<literal>JvNewObjectArray</literal>'.  This convention is used to\n+avoid conflicts with other libraries.\n+Internal functions in <acronym>CNI</acronym> start with the prefix\n+`<literal>_Jv_</literal>'.  You should not call these;\n+if you find a need to, let us know and we will try to come up with an\n+alternate solution.  (This manual lists <literal>_Jv_AllocBytes</literal>\n+as an example;  <acronym>CNI</acronym> should instead provide\n+a <literal>JvAllocBytes</literal> function.)</para>\n+<para>\n+These header files are automatically generated by <command>gcjh</command>.\n+</para>\n+</sect1>\n+\n+<sect1><title>Packages</title>\n+<para>\n+The only global names in Java are class names, and packages.\n+A <firstterm>package</firstterm> can contain zero or more classes, and\n+also zero or more sub-packages.\n+Every class belongs to either an unnamed package or a package that\n+has a hierarchical and globally unique name.\n+</para>\n+<para>\n+A Java package is mapped to a C++ <firstterm>namespace</firstterm>.\n+The Java class <literal>java.lang.String</literal>\n+is in the package <literal>java.lang</literal>, which is a sub-package\n+of <literal>java</literal>.  The C++ equivalent is the\n+class <literal>java::lang::String</literal>,\n+which is in the namespace <literal>java::lang</literal>,\n+which is in the namespace <literal>java</literal>.\n+</para>\n+<para>\n+Here is how you could express this:\n+<programlisting>\n+// Declare the class(es), possibly in a header file:\n+namespace java {\n+  namespace lang {\n+    class Object;\n+    class String;\n+    ...\n+  }\n+}\n+\n+class java::lang::String : public java::lang::Object\n+{\n+  ...\n+};\n+</programlisting>\n+</para>\n+<para>\n+The <literal>gcjh</literal> tool automatically generates the\n+nessary namespace declarations.</para>\n+\n+<sect2><title>Nested classes as a substitute for namespaces</title>\n+<para>\n+<!-- FIXME the next line reads poorly jsm -->\n+It is not that long since g++ got complete namespace support,\n+and it was very recent (end of February 1999) that <literal>libgcj</literal>\n+was changed to uses namespaces.  Releases before then used\n+nested classes, which are the C++ equivalent of Java inner classes.\n+They provide similar (though less convenient) functionality.\n+The old syntax is:\n+<programlisting>\n+class java {\n+  class lang {\n+    class Object;\n+    class String;\n+  };\n+};\n+</programlisting>\n+The obvious difference is the use of <literal>class</literal> instead\n+of <literal>namespace</literal>.  The more important difference is\n+that all the members of a nested class have to be declared inside\n+the parent class definition, while namespaces can be defined in\n+multiple places in the source.  This is more convenient, since it\n+corresponds more closely to how Java packages are defined.\n+The main difference is in the declarations; the syntax for\n+using a nested class is the same as with namespaces:\n+<programlisting>\n+class java::lang::String : public java::lang::Object\n+{ ... }\n+</programlisting>\n+Note that the generated code (including name mangling)\n+using nested classes is the same as that using namespaces.</para>\n+</sect2>\n+\n+<sect2><title>Leaving out package names</title>\n+<para>\n+<!-- FIXME next line reads poorly jsm -->\n+Having to always type the fully-qualified class name is verbose.\n+It also makes it more difficult to change the package containing a class.\n+The Java <literal>package</literal> declaration specifies that the\n+following class declarations are in the named package, without having\n+to explicitly name the full package qualifiers.\n+The <literal>package</literal> declaration can be followed by zero or\n+more <literal>import</literal> declarations, which allows either\n+a single class or all the classes in a package to be named by a simple\n+identifier.  C++ provides something similar\n+with the <literal>using</literal> declaration and directive.\n+</para>\n+<para>\n+A Java simple-type-import declaration:\n+<programlisting>\n+import <replaceable>PackageName</replaceable>.<replaceable>TypeName</replaceable>;\n+</programlisting>\n+allows using <replaceable>TypeName</replaceable> as a shorthand for\n+<literal><replaceable>PackageName</replaceable>.<replaceable>TypeName</replaceable></literal>.\n+The C++ (more-or-less) equivalent is a <literal>using</literal>-declaration:\n+<programlisting>\n+using <replaceable>PackageName</replaceable>::<replaceable>TypeName</replaceable>;\n+</programlisting>\n+</para>\n+<para>\n+A Java import-on-demand declaration:\n+<programlisting>\n+import <replaceable>PackageName</replaceable>.*;\n+</programlisting>\n+allows using <replaceable>TypeName</replaceable> as a shorthand for\n+<literal><replaceable>PackageName</replaceable>.<replaceable>TypeName</replaceable></literal>\n+The C++ (more-or-less) equivalent is a <literal>using</literal>-directive:\n+<programlisting>\n+using namespace <replaceable>PackageName</replaceable>;\n+</programlisting>\n+</para>\n+</sect2>\n+</sect1>\n+\n+<sect1><title>Primitive types</title>\n+<para>\n+Java provides 8 <quote>primitives</quote> types:\n+<literal>byte</literal>, <literal>short</literal>, <literal>int</literal>,\n+<literal>long</literal>, <literal>float</literal>, <literal>double</literal>,\n+<literal>char</literal>, and <literal>boolean</literal>.\n+These are the same as the following C++ <literal>typedef</literal>s\n+(which are defined by <literal>cni.h</literal>):\n+<literal>jbyte</literal>, <literal>jshort</literal>, <literal>jint</literal>,\n+<literal>jlong</literal>, <literal>jfloat</literal>,\n+<literal>jdouble</literal>,\n+<literal>jchar</literal>, and <literal>jboolean</literal>.\n+You should use the C++ typenames\n+(<ForeignPhrase><Abbrev>e.g.</Abbrev></ForeignPhrase> <literal>jint</literal>),\n+and not the Java types names\n+(<ForeignPhrase><Abbrev>e.g.</Abbrev></ForeignPhrase> <literal>int</literal>),\n+even if they are <quote>the same</quote>.\n+This is because there is no guarantee that the C++ type\n+<literal>int</literal> is a 32-bit type, but <literal>jint</literal>\n+<emphasis>is</emphasis> guaranteed to be a 32-bit type.\n+\n+<informaltable frame=\"all\" colsep=\"1\" rowsep=\"0\">\n+<tgroup cols=\"3\">\n+<thead>\n+<row>\n+<entry>Java type</entry>\n+<entry>C/C++ typename</entry>\n+<entry>Description</entry>\n+</thead>\n+<tbody>\n+<row>\n+<entry>byte</entry>\n+<entry>jbyte</entry>\n+<entry>8-bit signed integer</entry>\n+</row>\n+<row>\n+<entry>short</entry>\n+<entry>jshort</entry>\n+<entry>16-bit signed integer</entry>\n+</row>\n+<row>\n+<entry>int</entry>\n+<entry>jint</entry>\n+<entry>32-bit signed integer</entry>\n+</row>\n+<row>\n+<entry>long</entry>\n+<entry>jlong</entry>\n+<entry>64-bit signed integer</entry>\n+</row>\n+<row>\n+<entry>float</entry>\n+<entry>jfloat</entry>\n+<entry>32-bit IEEE floating-point number</entry>\n+</row>\n+<row>\n+<entry>double</entry>\n+<entry>jdouble</entry>\n+<entry>64-bit IEEE floating-point number</entry>\n+</row>\n+<row>\n+<entry>char</entry>\n+<entry>jchar</entry>\n+<entry>16-bit Unicode character</entry>\n+</row>\n+<row>\n+<entry>boolean</entry>\n+<entry>jboolean</entry>\n+<entry>logical (Boolean) values</entry>\n+</row>\n+<row>\n+<entry>void</entry>\n+<entry>void</entry>\n+<entry>no value</entry>\n+</row>\n+</tbody></tgroup>\n+</informaltable>\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+<funcdef><function>JvPrimClass</function></funcdef>\n+<paramdef><parameter>primtype</parameter></paramdef>\n+</funcsynopsis>\n+This is a macro whose argument should be the name of a primitive\n+type, <ForeignPhrase><Abbrev>e.g.</Abbrev></ForeignPhrase>\n+<literal>byte</literal>.\n+The macro expands to a pointer to the <literal>Class</literal> object\n+corresponding to the primitive type.\n+<ForeignPhrase><Abbrev>E.g.</Abbrev></ForeignPhrase>,\n+<literal>JvPrimClass(void)</literal>\n+has the same value as the Java expression\n+<literal>Void.TYPE</literal> (or <literal>void.class</literal>).\n+</para>\n+\n+</sect1>\n+\n+<sect1><title>Objects and Classes</title>\n+<sect2><title>Classes</title>\n+<para>\n+All Java classes are derived from <literal>java.lang.Object</literal>.\n+C++ does not have a unique <quote>root</quote>class, but we use\n+a C++ <literal>java::lang::Object</literal> as the C++ version\n+of the <literal>java.lang.Object</literal> Java class.  All\n+other Java classes are mapped into corresponding C++ classes\n+derived from <literal>java::lang::Object</literal>.</para>\n+<para>\n+Interface inheritance (the <quote><literal>implements</literal></quote>\n+keyword) is currently not reflected in the C++ mapping.</para>\n+</sect2>\n+<sect2><title>Object references</title>\n+<para>\n+We implement a Java object reference as a pointer to the start\n+of the referenced object.  It maps to a C++ pointer.\n+(We cannot use C++ references for Java references, since\n+once a C++ reference has been initialized, you cannot change it to\n+point to another object.)\n+The <literal>null</literal> Java reference maps to the <literal>NULL</literal>\n+C++ pointer.\n+</para>\n+<para>\n+Note that in some Java implementations an object reference is implemented as\n+a pointer to a two-word <quote>handle</quote>.  One word of the handle\n+points to the fields of the object, while the other points\n+to a method table.  Gcj does not use this extra indirection.\n+</para>\n+</sect2>\n+<sect2><title>Object fields</title>\n+<para>\n+Each object contains an object header, followed by the instance\n+fields of the class, in order.  The object header consists of\n+a single pointer to a dispatch or virtual function table.\n+(There may be extra fields <quote>in front of</quote> the object,\n+for example for\n+memory management, but this is invisible to the application, and\n+the reference to the object points to the dispatch table pointer.)\n+</para>\n+<para>\n+The fields are laid out in the same order, alignment, and size\n+as in C++.  Specifically, 8-bite and 16-bit native types\n+(<literal>byte</literal>, <literal>short</literal>, <literal>char</literal>,\n+and <literal>boolean</literal>) are <emphasis>not</emphasis>\n+widened to 32 bits.\n+Note that the Java VM does extend 8-bit and 16-bit types to 32 bits\n+when on the VM stack or temporary registers.</para>\n+<para>\n+If you include the <literal>gcjh</literal>-generated header for a\n+class, you can access fields of Java classes in the <quote>natural</quote>\n+way.  Given the following Java class:\n+<programlisting>\n+public class Int\n+{\n+  public int i;\n+  public Integer (int i) { this.i = i; }\n+  public static zero = new Integer(0);\n+}\n+</programlisting>\n+you can write:\n+<programlisting>\n+#include &lt;cni.h&gt;\n+#include &lt;Int.h&gt;\n+Int*\n+mult (Int *p, jint k)\n+{\n+  if (k == 0)\n+    return Int::zero;  // static member access.\n+  return new Int(p->i * k);\n+}\n+</programlisting>\n+</para>\n+<para>\n+<acronym>CNI</acronym> does not strictly enforce the Java access\n+specifiers, because Java permissions cannot be directly mapped\n+into C++ permission.  Private Java fields and methods are mapped\n+to private C++ fields and methods, but other fields and methods\n+are mapped to public fields and methods.\n+</para>\n+</sect2>\n+</sect1>\n+\n+<sect1><title>Arrays</title>\n+<para>\n+While in many ways Java is similar to C and C++,\n+it is quite different in its treatment of arrays.\n+C arrays are based on the idea of pointer arithmetic,\n+which would be incompatible with Java's security requirements.\n+Java arrays are true objects (array types inherit from\n+<literal>java.lang.Object</literal>).  An array-valued variable\n+is one that contains a reference (pointer) to an array object.\n+</para>\n+<para>\n+Referencing a Java array in C++ code is done using the\n+<literal>JArray</literal> template, which as defined as follows:\n+<programlisting>\n+class __JArray : public java::lang::Object\n+{\n+public:\n+  int length;\n+};\n+\n+template&lt;class T&gt;\n+class JArray : public __JArray\n+{\n+  T data[0];\n+public:\n+  T&amp; operator[](jint i) { return data[i]; }\n+};\n+</programlisting></para>\n+<para>\n+<funcsynopsis> \n+   <funcdef>template&lt;class T&gt;  T *<function>elements</function></funcdef>\n+   <paramdef>JArray&lt;T&gt; &amp;<parameter>array</parameter></paramdef>\n+</funcsynopsis>\n+   This template function can be used to get a pointer to the\n+   elements of the <parameter>array</parameter>.\n+   For instance, you can fetch a pointer\n+   to the integers that make up an <literal>int[]</literal> like so:\n+<programlisting>\n+extern jintArray foo;\n+jint *intp = elements (foo);\n+</programlisting>\n+The name of this function may change in the future.</para>\n+<para>\n+There are a number of typedefs which correspond to typedefs from JNI.\n+Each is the type of an array holding objects of the appropriate type:\n+<programlisting>\n+typedef __JArray *jarray;\n+typedef JArray&lt;jobject&gt; *jobjectArray;\n+typedef JArray&lt;jboolean&gt; *jbooleanArray;\n+typedef JArray&lt;jbyte&gt; *jbyteArray;\n+typedef JArray&lt;jchar&gt; *jcharArray;\n+typedef JArray&lt;jshort&gt; *jshortArray;\n+typedef JArray&lt;jint&gt; *jintArray;\n+typedef JArray&lt;jlong&gt; *jlongArray;\n+typedef JArray&lt;jfloat&gt; *jfloatArray;\n+typedef JArray&lt;jdouble&gt; *jdoubleArray;\n+</programlisting>\n+</para>\n+<para>\n+ You can create an array of objects using this function:\n+<funcsynopsis> \n+   <funcdef>jobjectArray <function>JvNewObjectArray</function></funcdef>\n+   <paramdef>jint <parameter>length</parameter></paramdef>\n+   <paramdef>jclass <parameter>klass</parameter></paramdef>\n+   <paramdef>jobject <parameter>init</parameter></paramdef>\n+   </funcsynopsis>\n+   Here <parameter>klass</parameter> is the type of elements of the array;\n+   <parameter>init</parameter> is the initial\n+   value to be put into every slot in the array.\n+</para>\n+<para>\n+For each primitive type there is a function which can be used\n+   to create a new array holding that type.  The name of the function\n+   is of the form\n+   `<literal>JvNew&lt;<replaceable>Type</replaceable>&gt;Array</literal>',\n+   where `&lt;<replaceable>Type</replaceable>&gt;' is the name of\n+   the primitive type, with its initial letter in upper-case.  For\n+   instance, `<literal>JvNewBooleanArray</literal>' can be used to create\n+   a new array of booleans.\n+   Each such function follows this example:\n+<funcsynopsis>  \n+   <funcdef>jbooleanArray <function>JvNewBooleanArray</function></funcdef> \n+   <paramdef>jint <parameter>length</parameter></paramdef>\n+</funcsynopsis>\n+</para>\n+<para>\n+<funcsynopsis>\n+   <funcdef>jsize <function>JvGetArrayLength</function></funcdef>\n+   <paramdef>jarray <parameter>array</parameter></paramdef> \n+   </funcsynopsis>\n+   Returns the length of <parameter>array</parameter>.</para>\n+</sect1>\n+\n+<sect1><title>Methods</title>\n+\n+<para>\n+Java methods are mapped directly into C++ methods.\n+The header files generated by <literal>gcjh</literal>\n+include the appropriate method definitions.\n+Basically, the generated methods have the same names and\n+<quote>corresponding</quote> types as the Java methods,\n+and are called in the natural manner.</para>\n+\n+<sect2><title>Overloading</title>\n+<para>\n+Both Java and C++ provide method overloading, where multiple\n+methods in a class have the same name, and the correct one is chosen\n+(at compile time) depending on the argument types.\n+The rules for choosing the correct method are (as expected) more complicated\n+in C++ than in Java, but given a set of overloaded methods\n+generated by <literal>gcjh</literal> the C++ compiler will choose\n+the expected one.</para>\n+<para>\n+Common assemblers and linkers are not aware of C++ overloading,\n+so the standard implementation strategy is to encode the\n+parameter types of a method into its assembly-level name.\n+This encoding is called <firstterm>mangling</firstterm>,\n+and the encoded name is the <firstterm>mangled name</firstterm>.\n+The same mechanism is used to implement Java overloading.\n+For C++/Java interoperability, it is important that both the Java\n+and C++ compilers use the <emphasis>same</emphasis> encoding scheme.\n+</para>\n+</sect2>\n+\n+<sect2><title>Static methods</title>\n+<para>\n+Static Java methods are invoked in <acronym>CNI</acronym> using the standard\n+C++ syntax, using the `<literal>::</literal>' operator rather\n+than the `<literal>.</literal>' operator.  For example:\n+</para>\n+<programlisting>\n+jint i = java::lang::Math::round((jfloat) 2.3);\n+</programlisting>\n+<para>\n+<!-- FIXME this next sentence seems ungammatical jsm -->\n+Defining a static native method uses standard C++ method\n+definition syntax.  For example:\n+<programlisting>\n+#include &lt;java/lang/Integer.h&gt;\n+java::lang::Integer*\n+java::lang::Integer::getInteger(jstring str)\n+{\n+  ...\n+}\n+</programlisting>\n+</sect2>\n+\n+<sect2><title>Object Constructors</title>\n+<para>\n+Constructors are called implicitly as part of object allocation\n+using the <literal>new</literal> operator.  For example:\n+<programlisting> \n+java::lang::Int x = new java::lang::Int(234);\n+</programlisting> \n+</para>\n+<para>\n+<!-- FIXME rewrite needed here, mine may not be good jsm -->\n+Java does not allow a constructor to be a native method.\n+Instead, you could define a private method which\n+you can have the constructor call.\n+</para>\n+</sect2>\n+\n+<sect2><title>Instance methods</title>\n+<para>\n+<!-- FIXME next para week, I would remove a few words from some sentences jsm -->\n+Virtual method dispatch is handled essentially the same way\n+in C++ and Java -- <abbrev>i.e.</abbrev> by doing an\n+indirect call through a function pointer stored in a per-class virtual\n+function table.  C++ is more complicated because it has to support\n+multiple inheritance, but this does not effect Java classes.\n+However, G++ has historically used a different calling convention\n+that is not compatible with the one used by <acronym>gcj</acronym>.\n+During 1999, G++ will switch to a new ABI that is compatible with\n+<acronym>gcj</acronym>.  Some platforms (including Linux) have already\n+changed.  On other platforms, you will have to pass\n+the <literal>-fvtable-thunks</literal> flag to g++ when\n+compiling <acronym>CNI</acronym> code.\n+</para>\n+<para>\n+Calling a Java instance method in <acronym>CNI</acronym> is done\n+using the standard C++ syntax.  For example:\n+<programlisting>\n+  java::lang::Number *x;\n+  if (x-&gt;doubleValue() &gt; 0.0) ...\n+</programlisting>\n+</para>\n+<para>\n+Defining a Java native instance method is also done the natural way:\n+<programlisting>\n+#include &lt;java/lang/Integer.h&gt;\n+jdouble\n+java::lang:Integer::doubleValue()\n+{\n+  return (jdouble) value;\n+}\n+</programlisting>\n+</para>\n+</sect2>\n+\n+<sect2><title>Interface method calls</title>\n+<para>\n+In Java you can call a method using an interface reference.\n+This is not yet supported in <acronym>CNI</acronym>.</para>\n+</sect2>\n+</sect1>\n+\n+<sect1><title>Object allocation</title>\n+\n+<para>\n+New Java objects are allocated using a\n+<firstterm>class-instance-creation-expression</firstterm>:\n+<programlisting>\n+new <replaceable>Type</replaceable> ( <replaceable>arguments</replaceable> )\n+</programlisting>\n+The same syntax is used in C++.  The main difference is that\n+C++ objects have to be explicitly deleted; in Java they are\n+automatically deleted by the garbage collector.\n+Using <acronym>CNI</acronym>, you can allocate a new object\n+using standard C++ syntax.  The C++ compiler is smart enough to\n+realize the class is a Java class, and hence it needs to allocate\n+memory from the garbage collector.  If you have overloaded\n+constructors, the compiler will choose the correct one\n+using standard C++ overload resolution rules.  For example:\n+<programlisting>\n+java::util::Hashtable *ht = new java::util::Hashtable(120);\n+</programlisting>\n+</para>\n+<para>\n+<funcsynopsis>\n+  <funcdef>void *<function>_Jv_AllocBytes</function></funcdef>\n+  <paramdef>jsize <parameter>size</parameter></paramdef>\n+</funcsynopsis>\n+   Allocate <parameter>size</parameter> bytes.  This memory is not\n+   scanned by the garbage collector.  However, it will be freed by\n+the GC if no references to it are discovered.\n+</para>\n+</sect1>\n+\n+<sect1><title>Interfaces</title>\n+<para>\n+A Java class can <firstterm>implement</firstterm> zero or more\n+<firstterm>interfaces</firstterm>, in addition to inheriting from\n+a single base class. \n+An interface is a collection of constants and method specifications;\n+it is similar to the <firstterm>signatures</firstterm> available\n+as a G++ extension.  An interface provides a subset of the\n+functionality of C++ abstract virtual base classes, but they\n+are currently implemented differently.\n+CNI does not currently provide any support for interfaces,\n+or calling methods from an interface pointer.\n+This is partly because we are planning to re-do how\n+interfaces are implemented in <acronym>gcj</acronym>.\n+</para>\n+</sect1>\n+\n+<sect1><title>Strings</title>\n+<para>\n+<acronym>CNI</acronym> provides a number of utility functions for\n+working with Java <literal>String</literal> objects.\n+The names and interfaces are analogous to those of <acronym>JNI</acronym>.\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+  <funcdef>jstring <function>JvNewString</function></funcdef>\n+  <paramdef>const jchar *<parameter>chars</parameter></paramdef>\n+  <paramdef>jsize <parameter>len</parameter></paramdef>\n+  </funcsynopsis>\n+  Creates a new Java String object, where\n+  <parameter>chars</parameter> are the contents, and\n+  <parameter>len</parameter> is the number of characters.\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+  <funcdef>jstring <function>JvNewStringLatin1</function></funcdef>\n+  <paramdef>const char *<parameter>bytes</parameter></paramdef>\n+  <paramdef>jsize <parameter>len</parameter></paramdef>\n+ </funcsynopsis>\n+  Creates a new Java String object, where <parameter>bytes</parameter>\n+  are the Latin-1 encoded\n+  characters, and <parameter>len</parameter> is the length of\n+  <parameter>bytes</parameter>, in bytes.\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+  <funcdef>jstring <function>JvNewStringLatin1</function></funcdef>\n+  <paramdef>const char *<parameter>bytes</parameter></paramdef>\n+  </funcsynopsis>\n+  Like the first JvNewStringLatin1, but computes <parameter>len</parameter>\n+  using <literal>strlen</literal>.\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+  <funcdef>jstring <function>JvNewStringUTF</function></funcdef>\n+  <paramdef>const char *<parameter>bytes</parameter></paramdef>\n+  </funcsynopsis>\n+   Creates a new Java String object, where <parameter>bytes</parameter> are\n+   the UTF-8 encoded characters of the string, terminated by a null byte.\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+   <funcdef>jchar *<function>JvGetStringChars</function></funcdef>\n+  <paramdef>jstring <parameter>str</parameter></paramdef>\n+  </funcsynopsis>\n+   Returns a pointer to the array of characters which make up a string.\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+   <funcdef> int <function>JvGetStringUTFLength</function></funcdef>\n+  <paramdef>jstring <parameter>str</parameter></paramdef>\n+  </funcsynopsis>\n+   Returns number of bytes required to encode contents\n+   of <parameter>str</parameter> as UTF-8.\n+</para>\n+\n+<para>\n+<funcsynopsis>\n+  <funcdef> jsize <function>JvGetStringUTFRegion</function></funcdef>\n+  <paramdef>jstring <parameter>str</parameter></paramdef>\n+  <paramdef>jsize <parameter>start</parameter></paramdef>\n+  <paramdef>jsize <parameter>len</parameter></paramdef>\n+  <paramdef>char *<parameter>buf</parameter></paramdef>\n+  </funcsynopsis>\n+  This puts the UTF-8 encoding of a region of the\n+  string <parameter>str</parameter> into\n+  the buffer <parameter>buf</parameter>.\n+  The region of the string to fetch is specifued by\n+  <parameter>start</parameter> and <parameter>len</parameter>.\n+   It is assumed that <parameter>buf</parameter> is big enough\n+   to hold the result.  Note\n+   that <parameter>buf</parameter> is <emphasis>not</emphasis> null-terminated.\n+</para>\n+</sect1>\n+\n+<sect1><title>Class Initialization</title>\n+<para>\n+Java requires that each class be automatically initialized at the time \n+of the first active use.  Initializing a class involves \n+initializing the static fields, running code in class initializer \n+methods, and initializing base classes.  There may also be \n+some implementation specific actions, such as allocating \n+<classname>String</classname> objects corresponding to string literals in\n+the code.</para>\n+<para>\n+The Gcj compiler inserts calls to <literal>JvInitClass</literal> (actually\n+<literal>_Jv_InitClass</literal>) at appropriate places to ensure that a\n+class is initialized when required.  The C++ compiler does not\n+insert these calls automatically - it is the programmer's\n+responsibility to make sure classes are initialized.  However,\n+this is fairly painless because of the conventions assumed by the Java\n+system.</para>\n+<para>\n+First, <literal>libgcj</literal> will make sure a class is initialized\n+before an instance of that object is created.  This is one\n+of the responsibilities of the <literal>new</literal> operation.  This is\n+taken care of both in Java code, and in C++ code.  (When the G++\n+compiler sees a <literal>new</literal> of a Java class, it will call\n+a routine in <literal>libgcj</literal> to allocate the object, and that\n+routine will take care of initializing the class.)  It follows that you can\n+access an instance field, or call an instance (non-static)\n+method and be safe in the knowledge that the class and all\n+of its base classes have been initialized.</para>\n+<para>\n+Invoking a static method is also safe.  This is because the\n+Java compiler adds code to the start of a static method to make sure\n+the class is initialized.  However, the C++ compiler does not\n+add this extra code.  Hence, if you write a native static method\n+using CNI, you are responsible for calling <literal>JvInitClass</literal>\n+before doing anything else in the method (unless you are sure\n+it is safe to leave it out).</para>\n+<para>\n+Accessing a static field also requires the class of the\n+field to be initialized.  The Java compiler will generate code\n+to call <literal>_Jv_InitClass</literal> before getting or setting the field.\n+However, the C++ compiler will not generate this extra code,\n+so it is your responsibility to make sure the class is\n+initialized before you access a static field.</para>\n+</sect1>\n+<sect1><title>Exception Handling</title>\n+<para>\n+While C++ and Java share a common exception handling framework,\n+things are not quite as integrated as we would like, yet.\n+The main issue is the incompatible exception <emphasis>values</emphasis>,\n+and that the <quote>run-time type information</quote> facilities of the\n+two languages are not integrated.</para>\n+<para>\n+Basically, this means that you cannot in C++ catch an exception\n+value (<classname>Throwable</classname>) thrown from Java code, nor\n+can you use <literal>throw</literal> on a Java exception value from C++ code,\n+and expect to be able to catch it in Java code.\n+We do intend to change this.</para>\n+<para>\n+You can throw a Java exception from C++ code by using\n+the <literal>JvThrow</literal> <acronym>CNI</acronym> function.\n+<funcsynopsis>\n+   <funcdef>void <function>JvThrow</function></funcdef>\n+   <paramdef>jobject <parameter>obj</parameter></paramdef>\n+</funcsynopsis>\n+  Throws an exception <parameter>obj</parameter>, in a way compatible \n+with the Java exception-handling functions.\n+  The class of <parameter>obj</parameter> must be a subclass of\n+  <literal>Throwable</literal>.\n+</para>\n+<para>\n+Here is an example:\n+<programlisting>\n+if (i >= count)\n+   JvThrow (new java::lang::IndexOutOfBoundsException());\n+</programlisting>\n+</para>\n+</sect1>\n+\n+<sect1><title>Synchronization</title>\n+<para>\n+Each Java object has an implicit monitor.\n+The Java VM uses the instruction <literal>monitorenter</literal> to acquire\n+and lock a monitor, and <literal>monitorexit</literal> to release it.\n+The JNI has corresponding methods <literal>MonitorEnter</literal>\n+and <literal>MonitorExit</literal>.  The corresponding CNI macros\n+are <literal>JvMonitorEnter</literal> and <literal>JvMonitorExit</literal>.\n+</para>\n+<para>\n+The Java source language does not provide direct access to these primitives.\n+Instead, there is a <literal>synchronized</literal> statement that does an\n+implicit <literal>monitorenter</literal> before entry to the block,\n+and does a <literal>monitorexit</literal> on exit from the block.\n+Note that the lock has to be released even the block is abnormally\n+terminated by an exception, which means there is an implicit\n+<literal>try</literal>-<literal>finally</literal>.\n+</para>\n+<para>\n+From C++, it makes sense to use a destructor to release a lock.\n+CNI defines the following utility class.\n+<programlisting>\n+class JvSynchronize() {\n+  jobject obj;\n+  JvSynchronize(jobject o) { obj = o; JvMonitorEnter(o); }\n+  ~JvSynchronize() { JvMonitorExit(obj); }\n+};\n+</programlisting>\n+The equivalent of Java's:\n+<programlisting>\n+synchronized (OBJ) { CODE; }\n+</programlisting>\n+can be simply expressed:\n+<programlisting>\n+{ JvSynchronize dummy(OBJ); CODE; }\n+</programlisting>\n+</para>\n+<para>\n+Java also has methods with the <literal>synchronized</literal> attribute.\n+This is equivalent to wrapping the entire method body in a\n+<literal>synchronized</literal> statement.\n+(Alternatively, an implementation could require the caller to do\n+the synchronization.  This is not practical for a compiler, because\n+each virtual method call would have to test at run-time if\n+synchronization is needed.)  Since in <literal>gcj</literal>\n+the <literal>synchronized</literal> attribute is handled by the\n+method implementation, it is up to the programmer\n+of a synchronized native method to handle the synchronization\n+(in the C++ implementation of the method).\n+In otherwords, you need to manually add <literal>JvSynchronize</literal>\n+in a <literal>native synchornized</literal> method.</para>\n+</sect1>\n+\n+<sect1><title>Reflection</title>\n+<para>The types <literal>jfieldID</literal> and <literal>jmethodID</literal>\n+are as in JNI.</para>\n+<para>\n+The function <literal>JvFromReflectedField</literal>,\n+<literal>JvFromReflectedMethod</literal>,\n+<literal>JvToReflectedField</literal>, and\n+<literal>JvToFromReflectedMethod</literal> (as in Java 2 JNI)\n+will be added shortly, as will other functions corresponding to JNI.</para>\n+\n+<sect1><title>Using gcjh</title>\n+<para>\n+      The <command>gcjh</command> is used to generate C++ header files from\n+      Java class files.  By default, <command>gcjh</command> generates\n+      a relatively straightforward C++ header file.  However, there\n+      are a few caveats to its use, and a few options which can be\n+      used to change how it operates:\n+</para>\n+<variablelist>\n+<varlistentry>\n+<term><literal>--classpath</literal> <replaceable>path</replaceable></term>\n+<term><literal>--CLASSPATH</literal> <replaceable>path</replaceable></term>\n+<term><literal>-I</literal> <replaceable>dir</replaceable></term>\n+<listitem><para>\n+        These options can be used to set the class path for gcjh.\n+        Gcjh searches the class path the same way the compiler does;\n+\tthese options have their familiar meanings.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry>\n+<term><literal>-d <replaceable>directory</replaceable></literal></term>\n+<listitem><para>\n+Puts the generated <literal>.h</literal> files\n+beneath <replaceable>directory</replaceable>.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry>\n+<term><literal>-o <replaceable>file</replaceable></literal></term>\n+<listitem><para>\n+        Sets the name of the <literal>.h</literal> file to be generated.\n+        By default the <literal>.h</literal> file is named after the class.\n+        This option only really makes sense if just a single class file\n+        is specified.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry>\n+<term><literal>--verbose</literal></term>\n+<listitem><para>\n+        gcjh will print information to stderr as it works.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry>\n+<term><literal>-M</literal></term>\n+<term><literal>-MM</literal></term>\n+<term><literal>-MD</literal></term>\n+<term><literal>-MMD</literal></term>\n+<listitem><para>\n+        These options can be used to generate dependency information\n+        for the generated header file.  They work the same way as the\n+        corresponding compiler options.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry>\n+<term><literal>-prepend <replaceable>text</replaceable></literal></term>\n+<listitem><para>\n+This causes the <replaceable>text</replaceable> to be put into the generated\n+        header just after class declarations (but before declaration\n+        of the current class).  This option should be used with caution.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry> \n+<term><literal>-friend <replaceable>text</replaceable></literal></term>\n+<listitem><para>\n+This causes the <replaceable>text</replaceable> to be put into the class\n+declaration after a <literal>friend</literal> keyword.\n+This can be used to declare some\n+        other class or function to be a friend of this class.\n+        This option should be used with caution.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry>  \n+<term><literal>-add <replaceable>text</replaceable></literal></term>\n+<listitem><para>\n+The <replaceable>text</replaceable> is inserted into the class declaration.\n+This option should be used with caution.</para>\n+</listitem>\n+</varlistentry>\n+\n+<varlistentry> \n+<term><literal>-append <replaceable>text</replaceable></literal></term>\n+<listitem><para>\n+The <replaceable>text</replaceable> is inserted into the header file\n+after the class declaration.  One use for this is to generate\n+inline functions.  This option should be used with caution.\n+</listitem>\n+</varlistentry>\n+</variablelist>\n+<para>\n+All other options not beginning with a <literal>-</literal> are treated\n+as the names of classes for which headers should be generated.</para>\n+<para>\n+gcjh will generate all the required namespace declarations and\n+<literal>#include</literal>'s for the header file.\n+In some situations, gcjh will generate simple inline member functions.</para>\n+<para>\n+There are a few cases where gcjh will fail to work properly:</para>\n+<para>\n+gcjh assumes that all the methods and fields of a class have ASCII\n+names.  The C++ compiler cannot correctly handle non-ASCII\n+identifiers.  gcjh does not currently diagnose this problem.</para>\n+<para>\n+gcjh also cannot fully handle classes where a field and a method have\n+the same name.  If the field is static, an error will result.\n+Otherwise, the field will be renamed in the generated header; `__'\n+will be appended to the field name.</para>\n+<para>\n+Eventually we hope to change the C++ compiler so that these\n+restrictions can be lifted.</para>\n+</sect1>\n+\n+</article>"}, {"sha": "644f80b8b0f43019970cd3f6709ad7632611974c", "filename": "libjava/exception.cc", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,155 @@\n+// Functions for Exception Support for Java.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include \"exception\"\n+#include <stddef.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/NullPointerException.h>\n+#include <cni.h>\n+#include <jvm.h>\n+\n+// eh-common.h needs gansidecl.h.\n+#include \"gansidecl.h\"\n+#include \"eh-common.h\"\n+\n+typedef struct {\n+  __eh_info eh_info;\n+  void *value;\n+} java_eh_info;\n+\n+\n+/* Language-specific EH info pointer, throw routine, and language/version\n+   info routines. All defined in libgcc2. */\n+\n+extern \"C\" java_eh_info **__get_eh_info (); \n+extern \"C\" void __throw () __attribute__ ((__noreturn__));\n+extern \"C\" short __get_eh_table_version (void *table);\n+extern \"C\" short __get_eh_table_language (void *table);\n+\n+\n+extern \"C\" void * malloc (size_t);\n+extern \"C\" void free (void *);\n+\n+\n+extern \"C\" void *\n+_Jv_type_matcher (java_eh_info *info, void* match_info, \n+\t\t  void *exception_table)\n+{\n+  if (__get_eh_table_language (exception_table) != EH_LANG_Java)\n+    return NULL;\n+\n+  /* we don't worry about version info yet, there is only one version! */\n+  \n+  if (match_info != NULL)\n+    {\n+      // The match_info is either a (java::lang::Class*) or\n+      // match_info is one more than a (Utf8Const*).\n+      if (sizeof(void*) != sizeof(size_t))\n+\tabort();\n+      size_t mi = (size_t) match_info;\n+      if ((mi & 1) != 0)\n+\tmatch_info = _Jv_FindClass ((Utf8Const*) (mi - 1), NULL);\n+      if (! _Jv_IsInstanceOf ((jobject) info->value, (jclass) match_info))\n+\treturn NULL;\n+    }\n+\n+  return info->value;\n+}\n+\n+/* Compiler hook to return a pointer to java exception object. The value\n+   is cleared, so if the exception needs to be rethrown, it should be set \n+   again */\n+\n+extern \"C\" void *\n+_Jv_exception_info (void)\n+{\n+  java_eh_info *info = *(__get_eh_info ());\n+  void *ptr;\n+\n+  if (info == NULL)\n+    abort ();\n+\n+  ptr = info->value;\n+\n+  /* clear the value so another throw is an error */\n+  info->value = NULL;\n+\n+  return ptr;\n+}\n+\n+\n+\n+/* Allocate an exception info structure for java. Called the first time\n+   an exception is thrown. */\n+\n+extern \"C\" void\n+_Jv_eh_alloc ()\n+{\n+  /* FIXME: we should use _Jv_AllocBytes here.  However, libgcc2\n+     apparently can sometimes free() this value itself.  */\n+  java_eh_info *p = (java_eh_info *) malloc (sizeof (java_eh_info));\n+  if (p == 0)\n+    terminate ();\n+\n+  p->value = 0;\n+  java_eh_info ** info_ptr = __get_eh_info ();\n+\n+  /* There should NOT be an exception info pointer already. */\n+  if (*info_ptr != NULL)\n+    abort ();\n+\n+  *info_ptr = p;\n+}\n+\n+/* Deallocate the current exception info structure. Called at shutdown time. */\n+\n+extern \"C\" void\n+_Jv_eh_free ()\n+{\n+  java_eh_info ** info_ptr = __get_eh_info ();\n+  if (*info_ptr == NULL)\n+    abort ();\n+  \n+  /* FIXME: ideally we should just let the GC handle this.  */\n+  free (*info_ptr);\n+  *info_ptr = NULL;\n+}\n+\n+/* Perform a throw, Java style. Throw will unwind through this call, so\n+   there better not be any handlers or exception thrown here. */\n+\n+\n+/* Initialize an __eh_info structure with this libraries matching info. */\n+\n+extern \"C\" void\n+_Jv_setup_eh_info (__eh_info *)\n+{\n+}\n+\n+extern \"C\" void\n+_Jv_Throw (void *value)\n+{\n+  if (value == NULL)\n+    value = (void *) new java::lang::NullPointerException ();\n+  java_eh_info *ehinfo = *(__get_eh_info ());\n+  if (ehinfo == NULL)\n+    {\n+      _Jv_eh_alloc ();\n+      ehinfo = *(__get_eh_info ());\n+    }\n+  ehinfo->eh_info.match_function = _Jv_type_matcher;\n+  ehinfo->eh_info.language = EH_LANG_Java;\n+  ehinfo->eh_info.version = 1;\n+  ehinfo->value = value;\n+  __throw();\n+}"}, {"sha": "21c1e7e6230a44d29df7a5349444bb540cc1989d", "filename": "libjava/gnu/gcj/convert/BytesToUnicode.java", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FBytesToUnicode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FBytesToUnicode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FBytesToUnicode.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,105 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert;\n+\n+public abstract class BytesToUnicode\n+{\n+  /** Buffer to read bytes from.\n+   * The characters inbuffer[inpos] ... inbuffer[inlength-1] are available. */\n+  public byte[] inbuffer;\n+  /** Starting index in buffer to read bytes from. */\n+  public int inpos;\n+  /** End of valid bytes in buffer. */\n+  public int inlength;\n+\n+  static Class defaultDecodingClass;\n+\n+  static synchronized void getDefaultDecodingClass()\n+  {\n+    // Test (defaultDecodingClass == null) again in case of race condition.\n+    if (defaultDecodingClass == null)\n+      {\n+\tString encoding = System.getProperty(\"file.encoding\");\n+\tString className = \"gnu.gcj.convert.Input_\"+encoding;\n+\ttry\n+\t  {\n+\t    defaultDecodingClass = Class.forName(className);\n+\t  }\n+\tcatch (ClassNotFoundException ex)\n+\t  {\n+\t    throw new NoClassDefFoundError(\"missing default encoding \"\n+\t\t\t\t\t   + encoding + \" (class \"\n+\t\t\t\t\t   + className + \" not found)\");\n+\t  }\n+      }\n+  }\n+\n+  public abstract String getName();\n+\n+  public static BytesToUnicode getDefaultDecoder()\n+  {\n+    try\n+      {\n+\tif (defaultDecodingClass == null)\n+\t  getDefaultDecodingClass();\n+\treturn (BytesToUnicode) defaultDecodingClass.newInstance();\n+      }\n+    catch (Throwable ex)\n+      {\n+\treturn new Input_8859_1();\n+      }\n+  }\n+\n+  /** Get a byte-stream->char-stream converter given an encoding name. */\n+  public static BytesToUnicode getDecoder (String encoding)\n+    throws java.io.UnsupportedEncodingException\n+  {\n+    String className = \"gnu.gcj.convert.Input_\"+encoding;\n+    Class decodingClass;\n+    try \n+      { \n+\tdecodingClass = Class.forName(className); \n+\treturn (BytesToUnicode) decodingClass.newInstance();\n+      } \n+    catch (Throwable ex) \n+      { \n+\tthrow new java.io.UnsupportedEncodingException(encoding\n+\t\t\t\t\t\t       + \" (\" + ex + ')');\n+      }\n+  }\n+\n+  /** Make input bytes available to the conversion.\n+   * @param buffer source of input bytes\n+   * @param pos index of first available byte\n+   * @param length one more than index of last available byte\n+   */\n+  public final void setInput(byte[] buffer, int pos, int length)\n+  {\n+    inbuffer = buffer;\n+    inpos = pos;\n+    inlength = length;\n+  }\n+\n+  /** Convert bytes to chars.\n+   * Input bytes are taken from this.inbuffer.  The available input\n+   * bytes start at inbuffer[inpos], and end at inbuffer[inlength-1].\n+   * @param outbuffer buffer for the converted character\n+   * @param outpos position in buffer to start putting converted characters\n+   * @param outlength the maximum number of characters to read\n+   * @return number of chars placed in outbuffer.\n+   * Also, this.inpos is incremented by the number of bytes consumed.\n+   *\n+   * (Note the asymmetry in that the input upper bound is inbuffer[inlength-1],\n+   * while the output upper bound is outbuffer[outpos+outlength-1].  The\n+   * justification is that inlength is like the count field of a\n+   * BufferedInputStream, while the outlength parameter is like the\n+   * length parameter of a read request.)\n+   */\n+  public abstract int read (char[] outbuffer, int outpos, int outlength);\n+}"}, {"sha": "4cdc1152654291c89385535354c83bf5b2accc0d", "filename": "libjava/gnu/gcj/convert/Convert.java", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FConvert.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FConvert.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FConvert.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,151 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert;\n+import java.io.*;\n+\n+public class Convert\n+{\n+  static void error (String message)\n+  {\n+    System.err.print(\"convert: \");\n+    System.err.println(message);\n+    System.err.println(\"Usage:  convert [--from srcEncoding] [--to dstEncoding]\");\n+    System.err.println(\"  [inputfile [outputfile]]\");\n+    System.exit(-1);\n+  }\n+\n+  static void missing (String arg)\n+  {\n+    error(\"missing arg after `\" + arg + \"' option\");\n+  }\n+\n+  public static void main (String[] args)\n+  {\n+    String inName = \"-\";\n+    String outName = \"-\";\n+    String inEncodingName = null;\n+    String outEncodingName = \"JavaSrc\";\n+    int seenNames = 0;\n+    boolean reverse = false;\n+\n+    for (int i = 0;  i < args.length;  i++)\n+      {\n+\tString arg = args[i];\n+\tif (arg.length() == 0)\n+\t  error(\"zero-length argument\");\n+\tif (arg.charAt(0) == '-')\n+\t  {\n+\t    if (arg.equals(\"-encoding\") || arg.equals(\"--encoding\")\n+\t\t|| args.equals(\"-from\") || arg.equals(\"--from\"))\n+\t      {\n+\t\tif (++i == args.length) missing(arg);\n+\t\tinEncodingName = args[i];\n+\t      }\n+\t    else if (arg.equals(\"-to\") || arg.equals(\"--to\"))\n+\t      {\n+\t\tif (++i == args.length) missing(arg);\n+\t\toutEncodingName = args[i];\n+\t      }\n+\t    else if (arg.equals(\"-i\"))\n+\t      {\n+\t\tif (++i == args.length) missing(arg);\n+\t\tinName = args[i];\n+\t      }\n+\t    else if (arg.equals(\"-o\"))\n+\t      {\n+\t\tif (++i == args.length) missing(arg);\n+\t\toutName = args[i];\n+\t      }\n+\t    else if (arg.equals(\"-reverse\") || arg.equals(\"--reverse\"))\n+\t      {\n+\t\treverse = true;\n+\t      }\n+\t    else if (arg.equals(\"-\"))\n+\t      {\n+\t\tswitch (seenNames)\n+\t\t  {\n+\t\t  case 0:\n+\t\t    inName = \"-\";\n+\t\t    seenNames++;\n+\t\t    break;\n+\t\t  case 1:\n+\t\t    outName = \"-\";\n+\t\t    seenNames++;\n+\t\t    break;\n+\t\t  default:\n+\t\t    error(\"too many `-' arguments\");\n+\t\t  }\n+\t      }\n+\t    else\n+\t      error(\"unrecognized argument `\" + arg + \"'\");\n+\t  }\n+\telse\n+\t  {\n+\t    switch (seenNames)\n+\t      {\n+\t      case 0:\n+\t\tinName = arg;\n+\t\tseenNames++;\n+\t\tbreak;\n+\t      case 1:\n+\t\toutName = arg;\n+\t\tseenNames++;\n+\t\tbreak;\n+\t      default:\n+\t\terror(\"too many filename arguments\");\n+\t      }\n+\t  }\n+      }\n+\n+    if (reverse)\n+      {\n+\tString tmp = inEncodingName;\n+\tinEncodingName = outEncodingName;\n+\toutEncodingName = tmp;\n+      }\n+\n+    try\n+      {\n+\tBytesToUnicode inDecoder\n+\t  = inEncodingName == null ? BytesToUnicode.getDefaultDecoder()\n+\t  : BytesToUnicode.getDecoder(inEncodingName);\n+\tUnicodeToBytes outEncoder\n+\t  = outEncodingName == null ? UnicodeToBytes.getDefaultEncoder()\n+\t  : UnicodeToBytes.getEncoder(outEncodingName);\n+\tInputStream inStream = inName == \"-\" ? System.in\n+\t  : new FileInputStream(inName);\n+\tOutputStream outStream;\n+\tif (outName == \"-\")\n+\t  outStream = System.out;\n+\telse\n+\t  outStream = new FileOutputStream(outName);\n+\tInputStreamReader in\n+\t  = new InputStreamReader(inStream, inEncodingName);\n+\tOutputStreamWriter out\n+\t  = new OutputStreamWriter(outStream, outEncodingName);\n+\tchar[] buffer = new char[2048];\n+\tfor (;;)\n+\t  {\n+\t    int count = in.read(buffer);\n+\t    if (count < 0)\n+\t      break;\n+\t    out.write(buffer, 0, count);\n+\t  }\n+\n+\tin.close();\n+\tout.close();\n+      }\n+    catch (java.io.IOException ex)\n+      {\n+\tSystem.err.print(\"convert exception: \");\n+\tSystem.err.println(ex);\n+\tSystem.exit(-1);\n+      }\n+  }\n+}"}, {"sha": "262099a13aa6a3bbf7ae4b502c4e2df668640a5b", "filename": "libjava/gnu/gcj/convert/Input_8859_1.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_8859_1.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_8859_1.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_8859_1.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert;\n+\n+public class Input_8859_1 extends BytesToUnicode\n+{\n+  public String getName() { return \"8859_1\"; }\n+\n+  public int read (char[] outbuffer, int outpos, int outlength)\n+  {\n+    int origpos = outpos;\n+    // Make sure fields of this are in registers.\n+    int inpos = this.inpos;\n+    byte[] inbuffer = this.inbuffer;\n+    int inavail = this.inlength - inpos;\n+    int outavail = outlength - outpos;\n+    if (outavail > inavail)\n+      outavail = inavail;\n+    while (--outavail >= 0)\n+      {\n+\toutbuffer[outpos++] = (char) (inbuffer[inpos++] & 0xFF);\n+      }\n+    this.inpos = inpos;\n+    return outpos - origpos;\n+  }\n+}"}, {"sha": "ecc0fdb9bb8500d7286578be3a7356c00e64cdc9", "filename": "libjava/gnu/gcj/convert/Input_EUCJIS.java", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_EUCJIS.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_EUCJIS.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_EUCJIS.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,19 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert;\n+\n+public class Input_EUCJIS extends BytesToUnicode\n+{\n+  public String getName() { return \"EUCJIS\"; }\n+\n+  int codeset = 0;\n+  int first_byte;\n+\n+  public native int read (char[] outbuffer, int outpos, int outlength);\n+}"}, {"sha": "c706a5259a738143e00167d2f12c61569a875126", "filename": "libjava/gnu/gcj/convert/Input_UTF8.java", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_UTF8.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_UTF8.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_UTF8.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,107 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert;\n+\n+public class Input_UTF8 extends BytesToUnicode\n+{\n+  public String getName() { return \"UTF8\"; }\n+\n+  int partial = 0;\n+  int partial_bytes_expected = 0;\n+  //int suggogate_second = -1;\n+\n+  public int read (char[] outbuffer, int outpos, int outlength)\n+  {\n+    int origpos = outpos;\n+    for (;;)\n+      {\n+\tif (outpos >= outlength)\n+\t  break;\n+\tif (inpos >= inlength)\n+\t  break;\n+\tint b = inbuffer[inpos++];\n+\tif (b >= 0)\n+\t  outbuffer[outpos++] = (char) b;\n+\telse\n+\t  {\n+\t    if ((b & 0xC0) == 0x80) // Continuation byte\n+\t      {\n+\t\tpartial = (partial << 6) | (b & 0x3F);\n+\t\t--partial_bytes_expected;\n+\t\tif (partial_bytes_expected == 1)\n+\t\t  {\n+\t\t    if (partial > (0xFFFF>>6))\n+\t\t      {\n+\t\t\t// The next continuation byte will cause the result\n+\t\t\t// to exceed 0xFFFF, so we must use a surrogate pair.\n+\t\t\t// The \"Unicode scalar value\" (see D28 in section 3.7\n+\t\t\t// of the Unicode Standard 2.0) is defined as:\n+\t\t\t// value == (hi-0xD800)*0x400+(lo-0xDC00)+0x10000,\n+\t\t\t// where (hi, lo) is the Unicode surrogate pair.\n+\t\t\t// After reading the first three bytes, we have:\n+\t\t\t// partial == (value >> 6).\n+\t\t\t// Substituting and simplifying, we get:\n+\t\t\t// partial == (hi-0xD800)*0x10+((lo-0xDC00)>>6)+0x400.\n+\t\t\t// The definition lo>=0xDC00 && lo<=0xDFFF implies\n+\t\t\t// that (lo-0xDC00)>>6 is in the range 0..15.\n+\t\t\t// Hence we can infer (partial-0x400)>>4 == (hi-0xDB00)\n+\t\t\t// and we can emit the high-surrogate without waiting\n+\t\t\t// for the final byte:\n+\t\t\toutbuffer[outpos++] = (char) (0xDA00+(partial>>4));\n+\n+\t\t\t// Now we want to set it up so that when we read\n+\t\t\t// the final byte on the next iteration, we will\n+\t\t\t// get the low-surrogate without special handling.\n+\t\t\t// I.e. we want:\n+\t\t\t// lo == (next_partial << 6) | (next & 0x3F)\n+\t\t\t// where next is the next input byte and next_partial\n+\t\t\t// is the value of partial at the end of this\n+\t\t\t// iteration.  This implies:  next_partial == lo >> 6.\n+\t\t\t// We can simplify the previous:\n+\t\t\t// partial == (hi-0xD800)*0x10+((lo-0xDC00)>>6)+0x400,\n+\t\t\t// to: partial == (hi-0xD800)*0x10+(lo>>6)+0x90.\n+\t\t\t// Inserting the values of hi and next_partial,\n+\t\t\t// and simplifying, we get:  partial ==\n+\t\t\t// ( (partial-0x400)&~0xF) + next_partial + 0x90.\n+\t\t\t// Solving for next_partial, we get:\n+\t\t\t// next_partial = partial+0x400-0x90-(partial&~0xF):\n+\t\t\t// or: next_partial = (partial&0xF) + 0x370.  Hence:\n+\t\t\tpartial = (partial & 0xF) + 0x370;\n+\t\t      }\n+\t\t  }\n+\t\telse if (partial_bytes_expected == 0)\n+\t\t  {\n+\t\t    outbuffer[outpos++] = (char) partial;\n+\t\t    partial = 0;\n+\t\t    partial_bytes_expected = 0;\n+\t\t  }\n+\t      }\n+\t    else // prefix byte\n+\t      {\n+\t\tif ((b & 0xE) == 0xC0)\n+\t\t  {\n+\t\t    partial = b & 0x1F;\n+\t\t    partial_bytes_expected = 1;\n+\t\t  }\n+\t\telse if ((b & 0xF) == 0xF0)\n+\t\t  {\n+\t\t    partial = b & 0xF;\n+\t\t    partial_bytes_expected = 2;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    partial = b & 7;\n+\t\t    partial_bytes_expected = 3;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+    return outpos - origpos;\n+  }\n+}"}, {"sha": "204348f8d77b26197e630c0e1dda4055e04ca97b", "filename": "libjava/gnu/gcj/convert/JIS0208.h", "status": "added", "additions": 6880, "deletions": 0, "changes": 6880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0208.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0208.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0208.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "a10ad4b3c25a979272bb28e211068d44f80a060d", "filename": "libjava/gnu/gcj/convert/JIS0208_to_Unicode.cc", "status": "added", "additions": 7325, "deletions": 0, "changes": 7325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0208_to_Unicode.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0208_to_Unicode.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0208_to_Unicode.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d79c2599e644d83a3954df2e32fd74527b32f461", "filename": "libjava/gnu/gcj/convert/JIS0212.h", "status": "added", "additions": 6068, "deletions": 0, "changes": 6068, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0212.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0212.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0212.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f05ef32c0ea2348cd3d26f1e6663f2191789392f", "filename": "libjava/gnu/gcj/convert/JIS0212_to_Unicode.cc", "status": "added", "additions": 6471, "deletions": 0, "changes": 6471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0212_to_Unicode.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0212_to_Unicode.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FJIS0212_to_Unicode.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ef6e211f9f8e67dae81cce60e5db89b0901fb91e", "filename": "libjava/gnu/gcj/convert/Output_8859_1.java", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_8859_1.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_8859_1.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_8859_1.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,31 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert; \n+ \n+public class Output_8859_1 extends UnicodeToBytes\n+{\n+  public String getName() { return \"8859_1\"; }\n+\n+  /**\n+   * @return number of chars converted. */\n+  public int write (char[] inbuffer, int inpos, int inlength)\n+  {\n+    int count = this.count;\n+    byte[] buf = this.buf;\n+    int avail = buf.length - count;\n+    if (inlength > avail)\n+      inlength = avail;\n+    for (int i = inlength;  --i >= 0;  )\n+      {\n+\tbuf[count++] = (byte) inbuffer[inpos++];\n+      }\n+    this.count = count;\n+    return inlength;\n+  }\n+}"}, {"sha": "aa233612cd79f3b070a91498e77fd8fcbe644f29", "filename": "libjava/gnu/gcj/convert/Output_JavaSrc.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_JavaSrc.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_JavaSrc.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_JavaSrc.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,82 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert; \n+ \n+/** Convert Unicode to Ascii with \\ u XXXX-escapes. */\n+\n+public class Output_JavaSrc extends UnicodeToBytes\n+{\n+  public String getName() { return \"JavaSrc\"; }\n+\n+  // Number of bytes remaining before pending_char has been written.\n+  int todo;\n+ int pending_char;\n+\n+  public int write (char[] inbuffer, int inpos, int inlength)\n+  {\n+    int start_pos = inpos;\n+    int avail = buf.length - count;\n+    for (;;)\n+      {\n+\tif (avail == 0)\n+\t  break;\n+\tswitch (todo)\n+\t  {\n+\t  case 1:\n+\t    if (pending_char == '\\\\')\n+\t      {\n+\t\tbuf[count++] = (byte) '\\\\';\n+\t\tavail--;\n+\t\ttodo = 0;\n+\t\tcontinue;\n+\t      }\n+\t    /* ... else fall through ... */\n+\t  case 2:\n+\t  case 3:\n+\t  case 4:\n+\t    todo--;\n+\t    int digit = ((int) pending_char >> (todo * 4)) & 0xF;\n+\t    buf[count++] = (byte) Character.forDigit(digit, 16);\n+\t    avail--;\n+\t    continue;\n+\t  case 5:\n+\t    buf[count++] = (byte) 'u';\n+\t    avail--;\n+\t    todo = 4;\n+\t    continue;\n+\t  default:\n+\t    ;\n+\t  }\n+\tif (inlength == 0)\n+\t  break;\n+\tchar ch = inbuffer[inpos++];\n+\tinlength--;\n+\tif (ch == '\\\\')\n+\t  {\n+\t    buf[count++] = (byte) '\\\\';\n+\t    pending_char = ch;\n+\t    todo = 1;\n+\t    avail--;\n+\t  }\n+\telse if (ch < 127)\n+\t  {\n+\t    buf[count++] = (byte) ch;\n+\t    avail--;\n+\t  }\n+\telse\n+\t  {\n+\t    buf[count++] = (byte) '\\\\';\n+\t    pending_char = ch;\n+\t    todo = 5;\n+\t    avail--;\n+\t  }\n+      }\n+    return inpos - start_pos;\n+  }\n+}"}, {"sha": "6be753bf8ec1b1d5e18158cc5a274dba26d181ad", "filename": "libjava/gnu/gcj/convert/Output_UTF8.java", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_UTF8.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_UTF8.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_UTF8.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,108 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert;\n+\n+public class Output_UTF8 extends UnicodeToBytes\n+{\n+  public String getName() { return \"UTF8\"; }\n+\n+  /** True if a surrogate pair should be emitted as a single UTF8 sequence.\n+   * Otherwise, a surrogate pair is treated as two separate characters.\n+   * Also, '\\0' is emitted as {0} if true, and as {0xC0,0x80} if false. */\n+  public boolean standardUTF8;\n+\n+  // Saves the previous char if it was a high-surrogate.\n+  char hi_part;\n+  // Value of imcomplete character.\n+  int value;\n+  // Number of continuation bytes still to emit.\n+  int bytes_todo;\n+\n+  public int write (char[] inbuffer, int inpos, int inlength)\n+  {\n+    int start_pos = inpos;\n+    int avail = buf.length - count;\n+    for (;;)\n+      {\n+\tif (inlength == 0 || avail == 0)\n+\t  break;\n+\t// The algororith is made more complicated because we want to write\n+\t// at least one byte in the output buffer, if there is room for\n+\t// that byte, and at least one input character is available.\n+\t// This makes the code more robust, since client code will\n+\t// always \"make progress\", even in the complicated cases,\n+\t// where the output buffer only has room for only *part* of a\n+\t// multi-byte sequence, or the input char buffer only has half\n+\t// of a surrogate pair (when standardUTF8 is set), or both.\n+\n+\t// Handle continuation characters we did not have room for before.\n+\tif (bytes_todo > 0)\n+\t  {\n+\t    do\n+\t      {\n+\t\tbytes_todo--;\n+\t\tbuf[count++] = (byte)\n+\t\t  (((value >> (bytes_todo * 6)) & 0xC0) | 0x80);\n+\t\tavail--;\n+\t      }\n+\t    while (bytes_todo > 0 && avail > 0);\n+\t    continue;\n+\t  }\n+\tchar ch = inbuffer[inpos++];\n+\tinlength--;\n+\tif (ch < 128 && (ch != 0 || standardUTF8))\n+\t  {\n+\t    avail--;\n+\t    buf[count++] = (byte) ch;\n+\t  }\n+\telse if (ch <= 0x07FF)\n+\t  {\n+\t    buf[count++] = (byte) (0xC0 | (ch >> 6));\n+\t    if (--avail > 0)\n+\t      {\n+\t\tbuf[count++] = (byte) ((ch & 0x3F) | 0x80);\n+\t\tavail--;\n+\t      }\n+\t    else\n+\t    {\n+\t      value = ch;\n+\t      bytes_todo = 1;\n+\t      break;\n+\t    }\n+\t  }\n+\telse if (ch >= 0xD800 && ch <= 0xDFFF && standardUTF8)\n+\t  {\n+\t    if (ch <= 0xDBFF)  // High surrogates\n+\t      {\n+\t\t// The first byte is (0xF0 | value>>18), where value is the\n+\t\t// Unicode scalar value of the combine character - which\n+\t\t// we may not know yet.  But from substituting:\n+\t\t// value == (hi-0xD800)*0x400+(lo-0xDC00)+0x10000,\n+\t\t// hi==ch, and cancelling we get:\n+\t\tbuf[count++] = (byte) (0xF0 | ((ch-0xD800) >> 8));\n+\t\tavail--;\n+\t\thi_part = ch;\n+\t      }\n+\t    else // Low surrogates\n+\t      {\n+\t\tvalue = (hi_part - 0xD800) * 0x400 + (ch - 0xDC00) + 0x10000;\n+\t\tbytes_todo = 3;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    buf[count++] = (byte) (0xE0 | (ch >> 12));\n+\t    value = ch;\n+\t    avail--;\n+\t    bytes_todo = 2;\n+\t  }\n+      }\n+    return inpos - start_pos;\n+  }\n+}"}, {"sha": "4b772f96edac7c52b69ec80cd31e2cc854073a0a", "filename": "libjava/gnu/gcj/convert/UnicodeToBytes.java", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FUnicodeToBytes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FUnicodeToBytes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FUnicodeToBytes.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,90 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.convert; \n+ \n+public abstract class UnicodeToBytes\n+{\n+  /** Buffer to emit bytes to.\n+   * The locations buf[count] ... buf[buf.length-1] are available. */\n+  public byte[] buf;\n+  public int count;\n+\n+  static Class defaultEncodingClass;\n+\n+  static synchronized void getDefaultEncodingClass()\n+  {\n+    // Test (defaultEncodingClass == null) again in case of race condition.\n+    if (defaultEncodingClass == null)\n+      {\n+\tString encoding = System.getProperty(\"file.encoding\");\n+\tString className = \"gnu.gcj.convert.Output_\"+encoding;\n+\ttry\n+\t  {\n+\t    defaultEncodingClass = Class.forName(className);\n+\t  }\n+\tcatch (ClassNotFoundException ex)\n+\t  {\n+\t    throw new NoClassDefFoundError(\"missing default encoding \"\n+\t\t\t\t\t   + encoding + \" (class \"\n+\t\t\t\t\t   + className + \" not found)\");\n+\t    \n+\t  }\n+      }\n+  }\n+\n+  public abstract String getName();\n+\n+  public static UnicodeToBytes getDefaultEncoder()\n+  {\n+    try\n+      {\n+\tif (defaultEncodingClass == null)\n+\t  getDefaultEncodingClass();\n+\treturn (UnicodeToBytes) defaultEncodingClass.newInstance();\n+      }\n+    catch (Throwable ex)\n+      {\n+\treturn new Output_8859_1();\n+      }\n+  }\n+\n+  /** Get a char-stream->byte-stream converter given an encoding name. */\n+  public static UnicodeToBytes getEncoder (String encoding)\n+    throws java.io.UnsupportedEncodingException\n+  {\n+    String className = \"gnu.gcj.convert.Output_\"+encoding;\n+    Class encodingClass;\n+    try \n+      { \n+\tencodingClass = Class.forName(className); \n+\treturn (UnicodeToBytes) encodingClass.newInstance();\n+      } \n+    catch (Throwable ex) \n+      { \n+\tthrow new java.io.UnsupportedEncodingException(encoding + \" (\"\n+\t\t\t\t\t\t       + ex + ')');\n+      }\n+  }\n+\n+  public final void setOutput(byte[] buffer, int count)\n+  {\n+    this.buf = buffer;\n+    this.count = count;\n+  }\n+\n+  /** Convert chars to bytes.\n+    * Converted bytes are written to buf, starting at count.\n+    * @param inbuffer sources of characters to convert\n+    * @param inpos index of initial character ininbuffer to convert\n+    * @param inlength number of characters to convert\n+    * @return number of chars converted\n+    * Also, this.count is increment by the number of bytes converted.\n+    */\n+  public abstract int write (char[] inbuffer, int inpos, int inlength);\n+}"}, {"sha": "c49b8945ec3e0845273b0472c759b3c0a45af6d4", "filename": "libjava/gnu/gcj/convert/gen-from-JIS.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2Fgen-from-JIS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2Fgen-from-JIS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2Fgen-from-JIS.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,154 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <stdio.h>\n+struct chval\n+{\n+  unsigned char b1;            /* 1st byte */\n+  unsigned char b2;            /* 2nd byte */\n+  unsigned short uc;  /* unicode value */\n+};\n+\n+#define MAP(B1, B2, C) { B1, B2, C },\n+\n+struct chval chtab_0208[] = {\n+#include \"JIS0208.h\"\n+  { 255, 255, 0}\n+};\n+\n+struct chval chtab_0212[] = {\n+#include \"JIS0212.h\"\n+  { 255, 255, 0}\n+};\n+#undef MAP\n+\n+struct chval sorted[] = {\n+#define MAP(B1, B2, C) { B1, B2, C },\n+#include \"JIS0208.h\"\n+#undef MAP\n+#define MAP(B1, B2, C) { 0x80|B1, B2, C },\n+#include \"JIS0212.h\"\n+#undef MAP\n+};\n+\n+struct chval *chtab;\n+\n+int\n+compare (void *p1, void *p2)\n+{\n+  struct chval *c1 = (struct chval *) p1;\n+  struct chval *c2 = (struct chval *) p2;\n+  return (int) c1->uc - (int) c2->uc;\n+}\n+\n+int\n+main(int argc, char** argv)\n+{\n+  FILE *out = stdout;\n+  unsigned min1 = 256, max1 = 0, min2 = 256, max2 = 0, count = 0;\n+  unsigned short low1_uc = 0xFFFF, high1_uc = 0;\n+  unsigned short low2_uc = 0xFFFF, high2_uc = 0;\n+  int i;  int row, col;\n+  if (strcmp (argv[1], \"JIS0208\") == 0)\n+    chtab = chtab_0208;\n+  else if (strcmp (argv[1], \"JIS0212\") == 0)\n+    chtab = chtab_0212;\n+  else if (strcmp (argv[1], \"toJIS\") == 0)\n+    {\n+      int i;\n+      int count = sizeof(sorted)/sizeof(struct chval);\n+      qsort (sorted, count, sizeof(struct chval),\n+\t     compare);\n+      for (i = 0;  i < count;  i++)\n+\t{\n+\t  fprintf (out, \"  0x%04x -> 0x%02x, 0x%02x\\n\",\n+\t\t   sorted[i].uc, sorted[i].b1, sorted[i].b2);\n+\t}\n+      exit(0);\n+    }\n+  else\n+    {\n+      fprintf (stderr, \"bad argument!\");\n+      exit (-1);\n+    }\n+  for (i = 0;  chtab[i].b1 != 255; i++)\n+    {\n+      if (chtab[i].b1 < min1) min1 = chtab[i].b1;\n+      if (chtab[i].b2 < min2) min2 = chtab[i].b2;\n+      if (chtab[i].b1 > max1) max1 = chtab[i].b1;\n+      if (chtab[i].b2 > max2) max2 = chtab[i].b2;\n+      count++;\n+    }\n+  fprintf(stderr, \"1st byte ranges from %d to %d.\\n\", min1, max1);\n+  fprintf(stderr, \"2nd byte ranges from %d to %d.\\n\", min2, max2);\n+\n+  fprintf(out,\"/* This file is automatically generated from %s.TXT. */\\n\",\n+\t  argv[1]);\n+  fprintf(out, \"unsigned short %s_to_Unicode[%d][%d] = {\\n\",\n+\t  argv[1], max1 - min1 + 1,  max2 - min2 + 1);\n+  i = 0;\n+  for (row = min1;  row <= max1;  row++)\n+    {\n+      fprintf(out, \"/* 1st byte: %d */ { \", row);\n+      if (row < chtab[i].b1)\n+\t{\n+\t  fprintf(out, \"0 }, /* unused row */\\n\");\n+\t}\n+      else if (row > chtab[i].b1)\n+\t{\n+\t  fprintf (stderr, \"error - char table out of order!\\n\");\n+\t  exit (-1);\n+\t}\n+      else\n+\t{\n+\t  fprintf(out, \"\\n\");\n+\t  for (col = min2;  col <= max2;  col++)\n+\t    {\n+\t      if (row == chtab[i].b1 && col == chtab[i].b2)\n+\t\t{\n+\t\t  unsigned uc = chtab[i].uc;\n+\t\t  if (uc < 0x2000)\n+\t\t    {\n+\t\t      if (uc > high1_uc)\n+\t\t\thigh1_uc = uc;\n+\t\t      if (uc < low1_uc)\n+\t\t\tlow1_uc = uc;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (uc > high2_uc)\n+\t\t\thigh2_uc = uc;\n+\t\t      if (uc < low2_uc)\n+\t\t\tlow2_uc = uc;\n+\t\t    }\n+\t\t  fprintf (out, \"  /* 2nd byte: %d */ 0x%04x\",\n+\t\t\t   chtab[i].b2, uc);\n+\t\t  i++;\n+\t\t}\n+\t      else if (row < chtab[i].b1\n+\t\t  || (row == chtab[i].b1 && col < chtab[i].b2))\n+\t\t{\n+\t\t  fprintf (out, \"  0\");\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fprintf (stderr, \"error - char table our of order!\\n\");\n+\t\t  exit (-1);\n+\t\t}\n+\t      if (col != max2)\n+\t\tfprintf (out, \",\\n\");\n+\t    }\n+\t  fprintf(out, row == max1 ? \"}\\n\" : \"},\\n\");\n+\t}\n+    }\n+  fprintf(out, \"};\\n\");\n+  fprintf(stderr, \"total number of characters is %d.\\n\", count);\n+  fprintf(stderr, \"Range is 0x%04x-0x%04x and 0x%04x-0x%04x.\\n\",\n+\t  low1_uc, high1_uc, low2_uc, high2_uc);\n+  return 0;\n+}"}, {"sha": "68e4caed2c026d0a0904eba86ae02bca800eecdb", "filename": "libjava/gnu/gcj/convert/natInput_EUCJIS.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatInput_EUCJIS.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatInput_EUCJIS.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatInput_EUCJIS.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,101 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+#include <cni.h>\n+#include <gnu/gcj/convert/Input_EUCJIS.h>\n+\n+#define ERROR_CHAR 0xFFFD\n+\n+extern unsigned short JIS0208_to_Unicode[84][94];\n+extern unsigned short JIS0212_to_Unicode[76][94];\n+\n+jint\n+gnu::gcj::convert::Input_EUCJIS::read(jcharArray outbuffer, jint outpos,\n+\t\t\t\t      jint outlength)\n+{\n+  jint start_outpos = outpos;\n+  for (;;)\n+    {\n+      if (outpos >= outlength)\n+\tbreak;\n+      if (inpos >= inlength)\n+\tbreak;\n+      int b = ((unsigned char*) elements(inbuffer))[inpos++];\n+      if (codeset == 0)  // ASCII or JIS-Roman\n+\t{\n+\t  if (b < 128)\n+\t    {\n+#if 0\n+\t      // Technically, we should translate 0x5c to Yen symbol;\n+\t      // in practice, it is not clear.\n+\t      if (b == 0x5c)\n+\t\tb = 0x00A5;  // Yen sign.\n+#endif\n+\t      elements(outbuffer)[outpos++] = (char) b;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (b == 0x8E) // SS2\n+\t\tcodeset = 2;\n+\t      else if (b == 0x8F) // SS3\n+\t\tcodeset = 3;\n+\t      else\n+\t\t{\n+\t\t  codeset = 1;\n+\t\t  first_byte = b;\n+\t\t}\n+\t    }\n+\t}\n+      else if (codeset == 1) // JIS X 0208:1997\n+\t{\n+\t  first_byte -= 0x80 + 33;\n+\t  b -= 0x80 + 33;\n+\t  if ((unsigned) first_byte >= 84 || (unsigned) b >= 94)\n+\t    b = ERROR_CHAR;\n+\t  else\n+\t    {\n+\t      b = JIS0208_to_Unicode[first_byte][b];\n+\t      if (b == 0)\n+\t\tb = ERROR_CHAR;\n+\t    }\n+\t  elements(outbuffer)[outpos++] = b;\n+\t  codeset = 0;\n+\t}\n+      else if (codeset == 2) // Half-width katakana\n+\t{\n+\t  if (b >= 0xA1 && b <= 0xDF)\n+\t    b += 0xFF61 - 0xA1;\n+\t  else\n+\t    b = ERROR_CHAR;\n+\t  elements(outbuffer)[outpos++] = b;\n+\t  codeset = 0;\n+\t}\n+      else if (codeset == 3) // second byte of JIS X 0212-1990\n+\t{\n+\t  first_byte = b;\n+\t  codeset = 4;\n+\t}\n+      else // codeset == 4 // third byte of JIS X 0212-1990\n+\t{\n+\t  first_byte -= 0x80 + 34;\n+\t  b -= 0x80 + 33;\n+\t  if ((unsigned) first_byte >= 76 || (unsigned) b >= 94)\n+\t    b = ERROR_CHAR;\n+\t  else\n+\t    {\n+\t      b = JIS0208_to_Unicode[first_byte][b];\n+\t      if (b == 0)\n+\t\tb = ERROR_CHAR;\n+\t    }\n+\t  elements(outbuffer)[outpos++] = b;\n+\t  codeset = 0;\n+\t}\n+    }\n+  return outpos - start_outpos;\n+}"}, {"sha": "aee6fdd3e571446eafc3aa4dc5cb726048d9b17d", "filename": "libjava/gnu/gcj/protocol/http/Connection.java", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fhttp%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fhttp%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fhttp%2FConnection.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,285 @@\n+// Connection.java - Implementation of HttpURLConnection for http protocol.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.protocol.http;\n+\n+import java.net.*;\n+import java.io.*;\n+import java.util.Vector;\n+import java.util.Hashtable;\n+import java.util.Enumeration;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date March 29, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Minimal subset of functionality.  Proxies and Redirects\n+ *\tnot yet handled.  FileNameMap handling needs to be considered.\n+ *\tuseCaches, ifModifiedSince, and allowUserInteraction need\n+ *\tconsideration as well as doInput and doOutput.\n+ */\n+\n+class Connection extends HttpURLConnection\n+{\n+  protected Socket sock = null;\n+  private static Hashtable defRequestProperties = new Hashtable();\n+  private Hashtable requestProperties;\n+  private Hashtable hdrHash = new Hashtable();\n+  private Vector hdrVec = new Vector();\n+  private boolean gotHeaders = false;\n+  private BufferedInputStream bufferedIn;\n+\n+  public Connection(URL url)\n+  {\n+    super(url);\n+    requestProperties = (Hashtable) defRequestProperties.clone();\n+  }\n+\n+  // Override method in URLConnection.\n+  public static void setDefaultRequestProperty(String key, String value)\n+  {\n+    defRequestProperties.put(key, value);\n+  }\n+\n+  // Override method in URLConnection.\n+  public static String getDefaultRequestProperty(String key)\n+  {\n+    return (String) defRequestProperties.get(key);\n+  }\n+\n+  // Override method in URLConnection.\n+  public void setRequestProperty(String key, String value)\n+  {\n+    if (connected)\n+      throw new IllegalAccessError(\"Connection already established.\");\n+\n+    requestProperties.put(key, value);\n+  }\n+\n+  // Override method in URLConnection.\n+  public String getRequestProperty(String key)\n+  {\n+    if (connected)\n+      throw new IllegalAccessError(\"Connection already established.\");\n+\n+    return (String) requestProperties.get(key);\n+  }\n+\n+  // Implementation of abstract method.\n+  public void connect() throws IOException\n+  {\n+    // Call is ignored if already connected.\n+    if (connected)\n+      return;\n+\n+    // Get address and port number.\n+    int port;\n+    InetAddress destAddr = InetAddress.getByName(url.getHost());\n+    if ((port = url.getPort()) == -1)\n+      port = 80;\n+\n+    // Open socket and output stream.\n+    sock = new Socket(destAddr, port);\n+    PrintWriter out = new PrintWriter(sock.getOutputStream());\n+\n+    // Send request including any request properties that were set.\n+    out.print(getRequestMethod() + \" \" + url.getFile() + \" HTTP/1.1\\n\");\n+    out.print(\"Host: \" + url.getHost() + \":\" + port + \"\\n\");\n+    Enumeration reqKeys = requestProperties.keys();\n+    Enumeration reqVals = requestProperties.elements();\n+    while (reqKeys.hasMoreElements())\n+      out.print(reqKeys.nextElement() + \": \" + reqVals.nextElement() + \"\\n\");\n+    out.print(\"\\n\");\n+    out.flush();\n+    connected = true;\n+  }\n+\n+  // Implementation of abstract method.\n+  public void disconnect()\n+  {\n+    if (sock != null)\n+      {\n+\ttry\n+\t  {\n+\t    sock.close();\n+\t  }\n+\tcatch (IOException ex)\n+\t  {\n+\t    ; // Ignore errors in closing socket.\n+\t  }\n+\tsock = null;\n+      }\n+    connected = false;\n+  }\n+\n+  // TODO: public boolean usingProxy()\n+  public boolean usingProxy()\n+  {\n+    throw new InternalError(\"HttpURLConnection.usingProxy not implemented\");\n+  }\n+\n+  // Override default method in URLConnection.\n+  public InputStream getInputStream() throws IOException\n+  {\n+    if (!connected)\n+      connect();\n+\n+    if (bufferedIn == null)\n+      bufferedIn = new BufferedInputStream(sock.getInputStream());\n+    return bufferedIn;\n+  }\n+\n+  // Override default method in URLConnection.\n+  public OutputStream getOutputStream() throws IOException\n+  {\n+    if (!connected)\n+      connect();\n+\n+    return sock.getOutputStream();\n+  }\n+\n+  // Override default method in URLConnection.\n+  public String getHeaderField(String name)\n+  {\n+    try\n+      {\n+\tgetHttpHeaders();\n+      }\n+    catch (IOException x)\n+      {\n+\treturn null;\n+      }\n+    return (String) hdrHash.get(name.toLowerCase());\n+  }\n+\n+  // Override default method in URLConnection.\n+  public String getHeaderField(int n)\n+  {\n+    try\n+      {\n+\tgetHttpHeaders();\n+      }\n+    catch (IOException x)\n+      {\n+\treturn null;\n+      }\n+    if (n < hdrVec.size())\n+      return getField((String) hdrVec.elementAt(n));\n+\n+    return null;\n+  }\n+\n+  // Override default method in URLConnection.\n+  public String getHeaderFieldKey(int n)\n+  {\n+    try\n+      {\n+\tgetHttpHeaders();\n+      }\n+    catch (IOException x)\n+      {\n+\treturn null;\n+      }\n+    if (n < hdrVec.size())\n+      return getKey((String) hdrVec.elementAt(n));\n+\n+    return null;\n+  }\n+\n+  private String getKey(String str)\n+  {\n+    if (str == null)\n+      return null;\n+    int index = str.indexOf(':');\n+    if (index >= 0)\n+      return str.substring(0, index);\n+    else\n+      return null;\n+  }\n+\n+  private String getField(String str)\n+  {\n+    if (str == null)\n+      return null;\n+    int index = str.indexOf(':');\n+    if (index >= 0)\n+      return str.substring(index + 1).trim();\n+    else\n+      return str;\n+  }\n+\n+  private void getHttpHeaders() throws IOException\n+  {\n+    if (gotHeaders)\n+      return;\n+    gotHeaders = true;\n+\n+    connect();\n+\n+    // Originally tried using a BufferedReader here to take advantage of\n+    // the readLine method and avoid the following, but the buffer read\n+    // past the end of the headers so the first part of the content was lost.\n+    // It is probably more robust than it needs to be, e.g. the byte[]\n+    // is unlikely to overflow and a '\\r' should always be followed by a '\\n',\n+    // but it is better to be safe just in case.\n+    if (bufferedIn == null)\n+      bufferedIn = new BufferedInputStream(sock.getInputStream());\n+\n+    int buflen = 100;\n+    byte[] buf = new byte[buflen];\n+    String line = \"\";\n+    boolean gotnl = false;\n+    byte[] ch = new byte[1];\n+    ch[0] = (byte) '\\n';\n+    while (true)\n+      {\n+\t// Check for leftover byte from non-'\\n' after a '\\r'.\n+\tif (ch[0] != '\\n')\n+\t  line = line + '\\r' + new String(ch, 0, 1);\n+\n+\tint i;\n+\tfor (i = 0; i < buflen; i++)\n+\t  {\n+\t    bufferedIn.read(buf, i, 1);\n+\t    if (buf[i] == '\\r')\n+\t      {\n+\t        bufferedIn.read(ch, 0, 1);\n+\t\tif (ch[0] == '\\n')\n+\t\t  gotnl = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tline = line + new String(buf, 0, i);\n+\n+\t// A '\\r' '\\n' combo indicates the end of the header entry.\n+\t// If it wasn't found, cycle back through the loop and append\n+\t// to 'line' until one is found.\n+\tif (gotnl)\n+\t  {\n+\t    // A zero length entry signals the end of the headers.\n+\t    if (line.length() == 0)\n+\t      break;\n+\n+\t    // Store the header and reinitialize for next cycle.\n+\t    hdrVec.addElement(line);\n+\t    String key = getKey(line);\n+\t    if (key != null)\n+\t      hdrHash.put(key.toLowerCase(), getField(line));\n+\t    line = \"\";\n+\t    ch[0] = (byte) '\\n';\n+\t    gotnl = false;\n+\t  }\n+      }\n+  }\n+}"}, {"sha": "7e379890eb23a8d14251f674977bc243965b93ab", "filename": "libjava/gnu/gcj/protocol/http/Handler.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fhttp%2FHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fhttp%2FHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fhttp%2FHandler.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,35 @@\n+// Handler.java - URLStreamHandler for http protocol.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.protocol.http;\n+\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.io.IOException;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date March 26, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Minimal functionality.\n+ */\n+\n+public class Handler extends URLStreamHandler\n+{\n+  protected URLConnection openConnection(URL url) throws IOException\n+  {\n+    return new Connection(url);\n+  }\n+}"}, {"sha": "794fb2e0c16952b7896f1357fcbfda997bba6ef9", "filename": "libjava/gnu/gcj/text/BaseBreakIterator.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FBaseBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FBaseBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FBaseBreakIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,82 @@\n+// Base class for default BreakIterators.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.text;\n+\n+import java.text.BreakIterator;\n+import java.text.CharacterIterator;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 22, 1999\n+ */\n+\n+public abstract class BaseBreakIterator extends BreakIterator\n+{\n+  public int current ()\n+  {\n+    return iter.getIndex();\n+  }\n+\n+  public int first ()\n+  {\n+    iter.first();\n+    return iter.getBeginIndex();\n+  }\n+\n+  public int following (int pos)\n+  {\n+    int save = iter.getIndex();\n+    iter.setIndex(pos);\n+    int r = next ();\n+    iter.setIndex(save);\n+    return r;\n+  }\n+\n+  public CharacterIterator getText ()\n+  {\n+    return iter;\n+  }\n+\n+  public int last ()\n+  {\n+    iter.last();\n+    return iter.getEndIndex();\n+  }\n+\n+  public int next (int n)\n+  {\n+    int r = iter.getIndex ();\n+    if (n > 0)\n+      {\n+\twhile (n > 0 && r != DONE)\n+\t  {\n+\t    r = next ();\n+\t    --n;\n+\t  }\n+      }\n+    else if (n < 0)\n+      {\n+\twhile (n < 0 && r != DONE)\n+\t  {\n+\t    r = previous ();\n+\t    ++n;\n+\t  }\n+      }\n+    return r;\n+  }\n+\n+  public void setText (CharacterIterator newText)\n+  {\n+    iter = newText;\n+  }\n+\n+  protected CharacterIterator iter;\n+}"}, {"sha": "e1777fd9945ffdf40f352524a49e918ef40fca90", "filename": "libjava/gnu/gcj/text/CharacterBreakIterator.java", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FCharacterBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FCharacterBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FCharacterBreakIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,188 @@\n+// Default character BreakIterator.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.text;\n+\n+import java.text.BreakIterator;\n+import java.text.CharacterIterator;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 19, 1999\n+ * Written using The Unicode Standard, Version 2.0.\n+ */\n+\n+public class CharacterBreakIterator extends BaseBreakIterator\n+{\n+  // Hangul Jamo constants from Unicode book.\n+  private static final int LBase = 0x1100;\n+  private static final int VBase = 0x1161;\n+  private static final int TBase = 0x11a7;\n+  private static final int LCount = 19;\n+  private static final int VCount = 21;\n+  private static final int TCount = 28;\n+\n+  // Information about surrogates.\n+  private static final int highSurrogateStart = 0xD800;\n+  private static final int highSurrogateEnd = 0xDBFF;\n+  private static final int lowSurrogateStart = 0xDC00;\n+  private static final int lowSurrogateEnd = 0xDFFF;\n+\n+  public Object clone ()\n+  {\n+    return new CharacterBreakIterator (this);\n+  }\n+\n+  public CharacterBreakIterator ()\n+  {\n+    iter = null;\t\t// FIXME?\n+  }\n+\n+  private CharacterBreakIterator (CharacterBreakIterator other)\n+  {\n+    iter = (CharacterIterator) other.iter.clone();\n+  }\n+\n+  // Some methods to tell us different properties of characters.\n+  private final boolean isL (char c)\n+  {\n+    return c >= LBase && c <= LBase + LCount;\n+  }\n+  private final boolean isV (char c)\n+  {\n+    return c >= VBase && c <= VBase + VCount;\n+  }\n+  private final boolean isT (char c)\n+  {\n+    return c >= TBase && c <= TBase + TCount;\n+  }\n+  private final boolean isLVT (char c)\n+  {\n+    return isL (c) || isV (c) || isT (c);\n+  }\n+  private final boolean isHighSurrogate (char c)\n+  {\n+    return c >= highSurrogateStart && c <= highSurrogateEnd;\n+  }\n+  private final boolean isLowSurrogate (char c)\n+  {\n+    return c >= lowSurrogateStart && c <= lowSurrogateEnd;\n+  }\n+\n+  public int next ()\n+  {\n+    int end = iter.getEndIndex();\n+    if (iter.getIndex() == end)\n+      return DONE;\n+\n+    char c;\n+    for (char prev = CharacterIterator.DONE; iter.getIndex() < end; prev = c)\n+      {\n+\tc = iter.next();\n+\tif (c == CharacterIterator.DONE)\n+\t  break;\n+\tint type = Character.getType(c);\n+\n+\t// Break after paragraph separators.\n+\tif (type == Character.PARAGRAPH_SEPARATOR)\n+\t  break;\n+\n+\t// Now we need some lookahead.\n+\tchar ahead = iter.next();\n+\titer.previous();\n+\tif (ahead == CharacterIterator.DONE)\n+\t  break;\n+\tint aheadType = Character.getType(ahead);\n+\n+\tif (aheadType != Character.NON_SPACING_MARK\n+\t    && ! isLowSurrogate (ahead)\n+\t    && ! isLVT (ahead))\n+\t  break;\n+\tif (! isLVT (c) && isLVT (ahead))\n+\t  break;\n+\tif (isL (c) && ! isLVT (ahead)\n+\t    && aheadType != Character.NON_SPACING_MARK)\n+\t  break;\n+\tif (isV (c) && ! isV (ahead) && !isT (ahead)\n+\t    && aheadType != Character.NON_SPACING_MARK)\n+\t  break;\n+\tif (isT (c) && ! isT (ahead)\n+\t    && aheadType != Character.NON_SPACING_MARK)\n+\t  break;\n+\n+\tif (! isHighSurrogate (c) && isLowSurrogate (ahead))\n+\t  break;\n+\tif (isHighSurrogate (c) && ! isLowSurrogate (ahead))\n+\t  break;\n+\tif (! isHighSurrogate (prev) && isLowSurrogate (c))\n+\t  break;\n+      }\n+\n+    return iter.getIndex();\n+  }\n+\n+  public int previous ()\n+  {\n+    if (iter.getIndex() == iter.getBeginIndex())\n+      return DONE;\n+\n+    int start = iter.getBeginIndex();\n+    while (iter.getIndex() >= iter.getBeginIndex())\n+      {\n+\tchar c = iter.previous();\n+\tif (c == CharacterIterator.DONE)\n+\t  break;\n+\tint type = Character.getType(c);\n+\n+\tif (type != Character.NON_SPACING_MARK\n+\t    && ! isLowSurrogate (c)\n+\t    && ! isLVT (c))\n+\t  break;\n+\n+\t// Now we need some lookahead.\n+\tchar ahead = iter.previous();\n+\tif (ahead == CharacterIterator.DONE)\n+\t  {\n+\t    iter.next();\n+\t    break;\n+\t  }\n+\tchar ahead2 = iter.previous();\n+\titer.next();\n+\titer.next();\n+\tif (ahead2 == CharacterIterator.DONE)\n+\t  break;\n+\tint aheadType = Character.getType(ahead);\n+\n+\tif (aheadType == Character.PARAGRAPH_SEPARATOR)\n+\t  break;\n+\n+\tif (isLVT (c) && ! isLVT (ahead))\n+\t  break;\n+\tif (! isLVT (c) && type != Character.NON_SPACING_MARK\n+\t    && isL (ahead))\n+\t  break;\n+\tif (! isV (c) && ! isT (c) && type != Character.NON_SPACING_MARK\n+\t    && isV (ahead))\n+\t  break;\n+\tif (! isT (c) && type != Character.NON_SPACING_MARK\n+\t    && isT (ahead))\n+\t  break;\n+\n+\tif (isLowSurrogate (c) && ! isHighSurrogate (ahead))\n+\t  break;\n+\tif (! isLowSurrogate (c) && isHighSurrogate (ahead))\n+\t  break;\n+\tif (isLowSurrogate (ahead) && ! isHighSurrogate (ahead2))\n+\t  break;\n+      }\n+\n+    return iter.getIndex();\n+  }\n+}"}, {"sha": "b42881c864e38b7258a47d3f40a0effd9ad606c8", "filename": "libjava/gnu/gcj/text/LineBreakIterator.java", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FLineBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FLineBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLineBreakIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,168 @@\n+// Default word BreakIterator.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.text;\n+\n+import java.text.BreakIterator;\n+import java.text.CharacterIterator;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 22, 1999\n+ * Written using The Unicode Standard, Version 2.0.\n+ */\n+\n+public class LineBreakIterator extends BaseBreakIterator\n+{\n+  public Object clone ()\n+  {\n+    return new LineBreakIterator (this);\n+  }\n+\n+  public LineBreakIterator ()\n+  {\n+    iter = null;\n+  }\n+\n+  private LineBreakIterator (LineBreakIterator other)\n+  {\n+    iter = (CharacterIterator) other.iter.clone();\n+  }\n+\n+  // Some methods to tell us different properties of characters.\n+  private final boolean isNb (char c)\n+  {\n+    return (c == 0x00a0\t\t// NO-BREAK SPACE\n+\t    || c == 0x2011\t// NON-BREAKING HYPHEN\n+\t    || c == 0xfeff);\t// ZERO WITH NO-BREAK SPACE\n+  }\n+  private final boolean isClose (int type)\n+  {\n+    return (type == Character.END_PUNCTUATION\n+\t    // Unicode book says \"comma, period, ...\", which I take to\n+\t    // mean \"Po\" class.\n+\t    || type == Character.OTHER_PUNCTUATION);\n+  }\n+  private final boolean isIdeo (char c)\n+  {\n+    return (c >= 0x3040 && c <= 0x309f\t       // Hiragana\n+\t    || c >= 0x30a0 && c <= 0x30ff      // Katakana\n+\t    || c >= 0x4e00 && c <= 0x9fff      // Han\n+\t    || c >= 0x3100 && c <= 0x312f);    // Bopomofo\n+  }\n+\n+  public int next ()\n+  {\n+    int end = iter.getEndIndex();\n+    if (iter.getIndex() == end)\n+      return DONE;\n+\n+    while (iter.getIndex() < end)\n+      {\n+\tchar c = iter.current();\n+\tint type = Character.getType(c);\n+\n+\tchar n = iter.next();\n+\n+\tif (n == CharacterIterator.DONE\n+\t    || type == Character.PARAGRAPH_SEPARATOR\n+\t    || type == Character.LINE_SEPARATOR)\n+\t  break;\n+\n+\t// Handle two cases where we must scan for non-spacing marks.\n+\tint start = iter.getIndex();\n+\tif (type == Character.SPACE_SEPARATOR\n+\t    || type == Character.START_PUNCTUATION\n+\t    || isIdeo (c))\n+\t  {\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.NON_SPACING_MARK)\n+\t      n = iter.next();\n+\t    if (n == CharacterIterator.DONE)\n+\t      break;\n+\n+\t    if (type == Character.SPACE_SEPARATOR)\n+\t      {\n+\t\tint nt = Character.getType(n);\n+\t\tif (nt != Character.NON_SPACING_MARK\n+\t\t    && nt != Character.SPACE_SEPARATOR\n+\t\t    && ! isNb (n))\n+\t\t  break;\n+\t      }\n+\t    else if (type == Character.START_PUNCTUATION)\n+\t      {\n+\t\tif (isIdeo (n))\n+\t\t  {\n+\t\t    // Open punctuation followed by non spacing marks\n+\t\t    // and then ideograph does not have a break in\n+\t\t    // it.  So skip all this.\n+\t\t    start = iter.getIndex();\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Ideograph preceded this character.\n+\t\tif (isClose (Character.getType(n)))\n+\t\t  break;\n+\t      }\n+\t  }\n+\titer.setIndex(start);\n+      }\n+\n+    return iter.getIndex();\n+  }\n+\n+  public int previous ()\n+  {\n+    int start = iter.getBeginIndex();\n+    if (iter.getIndex() == start)\n+      return DONE;\n+\n+    while (iter.getIndex() >= start)\n+      {\n+\tchar c = iter.previous();\n+\tif (c == CharacterIterator.DONE)\n+\t  break;\n+\tint type = Character.getType(c);\n+\n+\tchar n = iter.previous();\n+\tif (n == CharacterIterator.DONE)\n+\t  break;\n+\titer.next();\n+\n+\tint nt = Character.getType(n);\n+\t// Break after paragraph separators.\n+\tif (nt == Character.PARAGRAPH_SEPARATOR\n+\t    || nt == Character.LINE_SEPARATOR)\n+\t  break;\n+\n+\t// Skip non-spacing marks.\n+\tint init = iter.getIndex();\n+\twhile (n != CharacterIterator.DONE && nt == Character.NON_SPACING_MARK)\n+\t  {\n+\t    n = iter.previous();\n+\t    nt = Character.getType(n);\n+\t  }\n+\n+\tif (nt == Character.SPACE_SEPARATOR\n+\t    && type != Character.SPACE_SEPARATOR\n+\t    && type != Character.NON_SPACING_MARK\n+\t    && ! isNb (c))\n+\t  break;\n+\tif (! isClose (type) && isIdeo (n))\n+\t  break;\n+\tif (isIdeo (c) && nt != Character.START_PUNCTUATION)\n+\t  break;\n+\titer.setIndex(init);\n+      }\n+\n+    return iter.getIndex();\n+  }\n+}"}, {"sha": "df5a0de8a403d4cebe1897b059525913a025ffc0", "filename": "libjava/gnu/gcj/text/LocaleData_en.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,75 @@\n+// Generic English locale data for java.text.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.text;\n+\n+import java.util.ListResourceBundle;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 4, 1999\n+ */\n+\n+public final class LocaleData_en extends ListResourceBundle\n+{\n+  // These are for DateFormatSymbols.\n+  static final String[] ampmsDefault = {\"AM\", \"PM\" };\n+  static final String[] erasDefault = {\"BC\", \"AD\" };\n+  static final String localPatternCharsDefault = \"GyMdkHmsSEDFwWahKz\";\n+  static final String[] monthsDefault = {\n+    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n+    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\"\n+  };\n+  static final String[] shortMonthsDefault = {\n+    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n+    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\"\n+  };\n+  static final String[] shortWeekdaysDefault = {\n+    \"\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n+  };\n+  static final String[] weekdaysDefault = {\n+    \"\", \"Sunday\", \"Monday\", \"Tuesday\",\n+    \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n+  };\n+\n+  private static final Object[][] contents =\n+  {\n+    // These are for DecimalFormatSymbols.\n+    { \"decimalSeparator\", \".\" },\n+    { \"digit\", \"#\" },\n+    { \"exponential\", \"E\" },\n+    { \"groupingSeparator\", \",\" },\n+    { \"infinity\", \"\\u221e\" },\n+    { \"minusSign\", \"-\" },\n+    { \"NaN\", \"\\ufffd\" },\n+    { \"patternSeparator\", \";\" },\n+    { \"percent\", \"%\" },\n+    { \"perMill\", \"\\u2030\" },\n+    { \"zeroDigit\", \"0\" },\n+\n+    // These are for NumberFormat.\n+    { \"numberFormat\", \"#,##0.###\" },\n+    { \"percentFormat\", \"#,##0%\" },\n+\n+    // These are for DateFormatSymbols.\n+    { \"ampm\", ampmsDefault },\n+    { \"eras\", erasDefault },\n+    { \"datePatternChars\", localPatternCharsDefault },\n+    { \"months\", monthsDefault },\n+    { \"shortMonths\", shortMonthsDefault },\n+    { \"shortWeekdays\", shortWeekdaysDefault },\n+    { \"weekdays\", weekdaysDefault }\n+  };\n+\n+  protected Object[][] getContents ()\n+    {\n+      return contents;\n+    }\n+}"}, {"sha": "a0f0209797546b305461f9e94a951620f0cda535", "filename": "libjava/gnu/gcj/text/LocaleData_en_US.java", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en_US.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en_US.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en_US.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,71 @@\n+// US English locale data for java.text.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.text;\n+\n+import java.util.ListResourceBundle;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 4, 1999\n+ */\n+\n+public final class LocaleData_en_US extends ListResourceBundle\n+{\n+  // These are for DateFormatSymbols.\n+  static String[][] zoneStringsDefault = {\n+    { \"PST\", \"Pacific Standard Time\", \"PST\",\n+      /**/   \"Pacific Daylight Time\", \"PDT\", \"San Francisco\" },\n+    { \"MST\", \"Mountain Standard Time\", \"MST\",\n+      /**/   \"Mountain Daylight Time\", \"MDT\", \"Denver\" },\n+    { \"PNT\", \"Mountain Standard Time\", \"MST\",\n+      /**/   \"Mountain Standard Time\", \"MST\", \"Phoenix\" },\n+    { \"CST\", \"Central Standard Time\", \"CST\",\n+      /**/   \"Central Daylight Time\", \"CDT\", \"Chicago\" },\n+    { \"EST\", \"Eastern Standard Time\", \"EST\",\n+      /**/   \"Eastern Daylight Time\", \"EDT\", \"Boston\" },\n+    { \"IET\", \"Eastern Standard Time\", \"EST\",\n+      /**/   \"Eastern Standard Time\", \"EST\", \"Indianapolis\" },\n+    { \"PRT\", \"Atlantic Standard Time\", \"AST\",\n+      /**/   \"Atlantic Daylight Time\", \"ADT\", \"Halifax\" },\n+    { \"HST\", \"Hawaii Standard Time\", \"HST\",\n+      /**/   \"Hawaii Daylight Time\", \"HDT\", \"Honolulu\" },\n+    { \"AST\", \"Alaska Standard Time\", \"AST\",\n+      /**/   \"Alaska Daylight Time\", \"ADT\", \"Anchorage\" }\n+  };\n+\n+  private static final Object[][] contents =\n+  {\n+    // These are for DecimalFormatSymbols.\n+    { \"currency\", \"$\" },\n+    { \"intlCurrencySymbol\", \"$\" },\t      // FIXME?\n+\n+    // These are for NumberFormat.\n+    { \"currencyFormat\", \"$#,##0.00;($#,##0.00)\" },\n+\n+    // These are for DateFormatSymbols.\n+    { \"zoneStrings\", zoneStringsDefault },\n+\n+    // These are for DateFormat.\n+    { \"shortDateFormat\", \"M/d/yy\" },\t      // Java's Y2K bug.\n+    { \"mediumDateFormat\", \"d-MMM-yy\" },\n+    { \"longDateFormat\", \"MMMM d, yyyy\" },\n+    { \"fullDateFormat\", \"EEEE MMMM d, yyyy G\" },\n+    { \"shortTimeFormat\", \"h:mm a\" },\n+    { \"mediumTimeFormat\", \"h:mm:ss a\" },\n+    { \"longTimeFormat\", \"h:mm:ss a z\" },\n+    { \"fullTimeFormat\", \"h:mm:ss;S 'o''clock' a z\" }\n+  };\n+\n+  protected Object[][] getContents ()\n+    {\n+      return contents;\n+    }\n+}"}, {"sha": "8668087b23f091c2bcf42be8cbdd3645e65a7099", "filename": "libjava/gnu/gcj/text/SentenceBreakIterator.java", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FSentenceBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FSentenceBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FSentenceBreakIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,226 @@\n+// Default sentence BreakIterator.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.text;\n+\n+import java.text.BreakIterator;\n+import java.text.CharacterIterator;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 23, 1999\n+ * Written using The Unicode Standard, Version 2.0.\n+ */\n+\n+public class SentenceBreakIterator extends BaseBreakIterator\n+{\n+  public Object clone ()\n+  {\n+    return new SentenceBreakIterator (this);\n+  }\n+\n+  public SentenceBreakIterator ()\n+  {\n+    iter = null;\n+  }\n+\n+  private SentenceBreakIterator (SentenceBreakIterator other)\n+  {\n+    iter = (CharacterIterator) other.iter.clone();\n+  }\n+\n+  public int next ()\n+  {\n+    int end = iter.getEndIndex();\n+    if (iter.getIndex() == end)\n+      return DONE;\n+\n+    while (iter.getIndex() < end)\n+      {\n+\tchar c = iter.current();\n+\tif (c == CharacterIterator.DONE)\n+\t  break;\n+\tint type = Character.getType(c);\n+\n+\tchar n = iter.next();\n+\tif (n == CharacterIterator.DONE)\n+\t  break;\n+\n+\t// Always break after paragraph separator.\n+\tif (type == Character.PARAGRAPH_SEPARATOR)\n+\t  break;\n+\n+\tif (c == '!' || c == '?')\n+\t  {\n+\t    // Skip close punctuation.\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.END_PUNCTUATION)\n+\t      n = iter.next();\n+\t    // Skip spaces.\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.SPACE_SEPARATOR)\n+\t      n = iter.next();\n+\t    // Skip optional paragraph separator.\n+\t    if (n != CharacterIterator.DONE\n+\t\t&& Character.getType(n) == Character.PARAGRAPH_SEPARATOR)\n+\t      n = iter.next();\n+\n+\t    // There's always a break somewhere after `!' or `?'.\n+\t    break;\n+\t  }\n+\n+\tif (c == '.')\n+\t  {\n+\t    int save = iter.getIndex();\n+\t    // Skip close punctuation.\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.END_PUNCTUATION)\n+\t      n = iter.next();\n+\t    // Skip spaces.  We keep count because we need at least\n+\t    // one for this period to represent a terminator.\n+\t    int spcount = 0;\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.SPACE_SEPARATOR)\n+\t      {\n+\t\tn = iter.next();\n+\t\t++spcount;\n+\t      }\n+\t    if (spcount > 0)\n+\t      {\n+\t\tint save2 = iter.getIndex();\n+\t\t// Skip over open puncutation.\n+\t\twhile (n != CharacterIterator.DONE\n+\t\t       && Character.getType(n) == Character.START_PUNCTUATION)\n+\t\t  n = iter.next();\n+\t\t// Next character must not be lower case.\n+\t\tif (n == CharacterIterator.DONE\n+\t\t    || ! Character.isLowerCase(n))\n+\t\t  {\n+\t\t    iter.setIndex(save2);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    iter.setIndex(save);\n+\t  }\n+      }\n+\n+    return iter.getIndex();\n+  }\n+\n+  private final int previous_internal ()\n+  {\n+    int start = iter.getBeginIndex();\n+    if (iter.getIndex() == start)\n+      return DONE;\n+\n+    while (iter.getIndex() >= start)\n+      {\n+\tchar c = iter.previous();\n+\tif (c == CharacterIterator.DONE)\n+\t  break;\n+\n+\tchar n = iter.previous();\n+\tif (n == CharacterIterator.DONE)\n+\t  break;\n+\titer.next();\n+\tint nt = Character.getType(n);\n+\n+\tif (! Character.isLowerCase(c)\n+\t    && (nt == Character.START_PUNCTUATION\n+\t\t|| nt == Character.SPACE_SEPARATOR))\n+\t  {\n+\t    int save = iter.getIndex();\n+\t    int save_nt = nt;\n+\t    char save_n = n;\n+\t    // Skip open punctuation.\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.START_PUNCTUATION)\n+\t      n = iter.previous();\n+\t    if (n == CharacterIterator.DONE)\n+\t      break;\n+\t    if (Character.getType(n) == Character.SPACE_SEPARATOR)\n+\t      {\n+\t\t// Must have at least once space after the `.'.\n+\t\tint save2 = iter.getIndex();\n+\t\twhile (n != CharacterIterator.DONE\n+\t\t       && Character.getType(n) == Character.SPACE_SEPARATOR)\n+\t\t  n = iter.previous();\n+\t\t// Skip close punctuation.\n+\t\twhile (n != CharacterIterator.DONE\n+\t\t       && Character.getType(n) == Character.END_PUNCTUATION)\n+\t\t  n = iter.previous();\n+\t\tif (n == CharacterIterator.DONE || n == '.')\n+\t\t  {\n+\t\t    // Communicate location of actual end.\n+\t\t    period = iter.getIndex();\n+\t\t    iter.setIndex(save2);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    iter.setIndex(save);\n+\t    nt = save_nt;\n+\t    n = save_n;\n+\t  }\n+\n+\tif (nt == Character.PARAGRAPH_SEPARATOR)\n+\t  {\n+\t    // Communicate location of actual end.\n+\t    period = iter.getIndex();\n+\t    break;\n+\t  }\n+\telse if (nt == Character.SPACE_SEPARATOR\n+\t\t || nt == Character.END_PUNCTUATION)\n+\t  {\n+\t    int save = iter.getIndex();\n+\t    // Skip spaces.\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.SPACE_SEPARATOR)\n+\t      n = iter.previous();\n+\t    // Skip close punctuation.\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.END_PUNCTUATION)\n+\t      n = iter.previous();\n+\t    int here = iter.getIndex();\n+\t    iter.setIndex(save);\n+\t    if (n == CharacterIterator.DONE || n == '!' || n == '?')\n+\t      {\n+\t\t// Communicate location of actual end.\n+\t\tperiod = here;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse if (n == '!' || n == '?')\n+\t  {\n+\t    // Communicate location of actual end.\n+\t    period = iter.getIndex();\n+\t    break;\n+\t  }\n+      }\n+\n+    return iter.getIndex();\n+  }\n+\n+  public int previous ()\n+  {\n+    // We want to skip over the first sentence end to the second one.\n+    // However, at the end of the string we want the first end.\n+    int here = iter.getIndex();\n+    period = here;\n+    int first = previous_internal ();\n+    if (here == iter.getEndIndex() || first == DONE)\n+      return first;\n+    iter.setIndex(period);\n+    return previous_internal ();\n+  }\n+\n+  // This is used for communication between previous and\n+  // previous_internal.\n+  private int period;\n+}"}, {"sha": "b2fcb97a1a1238ef9d7cf893447b9c663afe8959", "filename": "libjava/gnu/gcj/text/WordBreakIterator.java", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FWordBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fgnu%2Fgcj%2Ftext%2FWordBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FWordBreakIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,224 @@\n+// Default word BreakIterator.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.text;\n+\n+import java.text.BreakIterator;\n+import java.text.CharacterIterator;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 22, 1999\n+ * Written using The Unicode Standard, Version 2.0.\n+ */\n+\n+public class WordBreakIterator extends BaseBreakIterator\n+{\n+  public Object clone ()\n+  {\n+    return new WordBreakIterator (this);\n+  }\n+\n+  public WordBreakIterator ()\n+  {\n+    iter = null;\n+  }\n+\n+  private WordBreakIterator (WordBreakIterator other)\n+  {\n+    iter = (CharacterIterator) other.iter.clone();\n+  }\n+\n+  // Some methods to tell us different properties of characters.\n+  private final boolean isHira (char c)\n+  {\n+    return c >= 0x3040 && c <= 0x309f;\n+  }\n+  private final boolean isKata (char c)\n+  {\n+    return c >= 0x30a0 && c <= 0x30ff;\n+  }\n+  private final boolean isHan (char c)\n+  {\n+    return c >= 0x4e00 && c <= 0x9fff;\n+  }\n+\n+  public int next ()\n+  {\n+    int end = iter.getEndIndex();\n+    if (iter.getIndex() == end)\n+      return DONE;\n+\n+    while (iter.getIndex() < end)\n+      {\n+\tchar c = iter.current();\n+\tif (c == CharacterIterator.DONE)\n+\t  break;\n+\tint type = Character.getType(c);\n+\n+\tchar n = iter.next();\n+\tif (n == CharacterIterator.DONE)\n+\t  break;\n+\n+\t// Break after paragraph separators.\n+\tif (type == Character.PARAGRAPH_SEPARATOR\n+\t    || type == Character.LINE_SEPARATOR)\n+\t  break;\n+\n+\t// Break between letters and non-letters.\n+\t// FIXME: we treat apostrophe as part of a word.  This\n+\t// is an English-ism.\n+\tboolean is_letter = Character.isLetter(c);\n+\tif (c != '\\'' && ! is_letter && type != Character.NON_SPACING_MARK\n+\t    && Character.isLetter(n))\n+\t  break;\n+\n+\t// Always break after certain symbols, such as punctuation.\n+\t// This heuristic is derived from hints in the JCL book and is\n+\t// not part of Unicode.  It seems to be right, however.\n+\t// FIXME: we treat apostrophe as part of a word.  This\n+\t// is an English-ism.\n+\tif (c != '\\''\n+\t    && (type == Character.DASH_PUNCTUATION\n+\t\t|| type == Character.START_PUNCTUATION\n+\t\t|| type == Character.END_PUNCTUATION\n+\t\t|| type == Character.CONNECTOR_PUNCTUATION\n+\t\t|| type == Character.OTHER_PUNCTUATION\n+\t\t|| type == Character.MATH_SYMBOL\n+\t\t|| type == Character.CURRENCY_SYMBOL\n+\t\t|| type == Character.MODIFIER_SYMBOL\n+\t\t|| type == Character.OTHER_SYMBOL\n+\t\t|| type == Character.FORMAT\n+\t\t|| type == Character.CONTROL))\n+\t  break;\n+\n+\tboolean is_hira = isHira (c);\n+\tboolean is_kata = isKata (c);\n+\tboolean is_han = isHan (c);\n+\n+\t// Special case Japanese.\n+\tif (! is_hira && ! is_kata && ! is_han\n+\t    && type != Character.NON_SPACING_MARK\n+\t    && (isHira (n) || isKata (n) || isHan (n)))\n+\t  break;\n+\n+\tif (is_hira || is_kata || is_han || is_letter)\n+\t  {\n+\t    // Now we need to do some lookahead.  We might need to do\n+\t    // quite a bit of lookahead, so we save our position and\n+\t    // restore it later.\n+\t    int save = iter.getIndex();\n+\t    // Skip string of non spacing marks.\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.NON_SPACING_MARK)\n+\t      n = iter.next();\n+\t    if (n == CharacterIterator.DONE)\n+\t      break;\n+\t    if ((is_hira && ! isHira (n))\n+\t\t|| (is_kata && ! isHira (n) && ! isKata (n))\n+\t\t|| (is_han && ! isHira (n) && ! isHan (n))\n+\t\t// FIXME: we treat apostrophe as part of a word.  This\n+\t\t// is an English-ism.\n+\t\t|| (is_letter && ! Character.isLetter(n) && n != '\\''))\n+\t      break;\n+\t    iter.setIndex(save);\n+\t  }\n+      }\n+\n+    return iter.getIndex();\n+  }\n+\n+  public int previous ()\n+  {\n+    int start = iter.getBeginIndex();\n+    if (iter.getIndex() == start)\n+      return DONE;\n+\n+    while (iter.getIndex() >= start)\n+      {\n+\tchar c = iter.previous();\n+\tif (c == CharacterIterator.DONE)\n+\t  break;\n+\n+\tboolean is_hira = isHira (c);\n+\tboolean is_kata = isKata (c);\n+\tboolean is_han = isHan (c);\n+\tboolean is_letter = Character.isLetter(c);\n+\n+\tchar n = iter.previous();\n+\tif (n == CharacterIterator.DONE)\n+\t  break;\n+\titer.next();\n+\tint type = Character.getType(n);\n+\t// Break after paragraph separators.\n+\tif (type == Character.PARAGRAPH_SEPARATOR\n+\t    || type == Character.LINE_SEPARATOR)\n+\t  break;\n+\n+\t// Break between letters and non-letters.\n+\t// FIXME: we treat apostrophe as part of a word.  This\n+\t// is an English-ism.\n+\tif (n != '\\'' && ! Character.isLetter(n)\n+\t    && type != Character.NON_SPACING_MARK\n+\t    && is_letter)\n+\t  break;\n+\n+\t// Always break after certain symbols, such as punctuation.\n+\t// This heuristic is derived from hints in the JCL book and is\n+\t// not part of Unicode.  It seems to be right, however.\n+\t// FIXME: we treat apostrophe as part of a word.  This\n+\t// is an English-ism.\n+\tif (n != '\\''\n+\t    && (type == Character.DASH_PUNCTUATION\n+\t\t|| type == Character.START_PUNCTUATION\n+\t\t|| type == Character.END_PUNCTUATION\n+\t\t|| type == Character.CONNECTOR_PUNCTUATION\n+\t\t|| type == Character.OTHER_PUNCTUATION\n+\t\t|| type == Character.MATH_SYMBOL\n+\t\t|| type == Character.CURRENCY_SYMBOL\n+\t\t|| type == Character.MODIFIER_SYMBOL\n+\t\t|| type == Character.OTHER_SYMBOL\n+\t\t|| type == Character.FORMAT\n+\t\t|| type == Character.CONTROL))\n+\t  break;\n+\n+\t// Special case Japanese.\n+\tif ((is_hira || is_kata || is_han)\n+\t    && ! isHira (n) && ! isKata (n) && ! isHan (n)\n+\t    && type != Character.NON_SPACING_MARK)\n+\t  break;\n+\n+\t// We might have to skip over non spacing marks to see what's\n+\t// on the other side.\n+\tif (! is_hira || (! is_letter && c != '\\''))\n+\t  {\n+\t    int save = iter.getIndex();\n+\t    while (n != CharacterIterator.DONE\n+\t\t   && Character.getType(n) == Character.NON_SPACING_MARK)\n+\t      n = iter.previous();\n+\t    iter.setIndex(save);\n+\t    // This is a strange case: a bunch of non-spacing marks at\n+\t    // the beginning.  We treat the current location as a word\n+\t    // break.\n+\t    if (n == CharacterIterator.DONE)\n+\t      break;\n+\t    if ((isHira (n) && ! is_hira)\n+\t\t|| (isKata (n) && ! is_hira && ! is_kata)\n+\t\t|| (isHan (n) && ! is_hira && ! is_han)\n+\t\t// FIXME: we treat apostrophe as part of a word.  This\n+\t\t// is an English-ism.\n+\t\t|| (! is_letter && c != '\\'' && Character.isLetter(n)))\n+\t      break;\n+\t  }\n+      }\n+\n+    return iter.getIndex();\n+  }\n+}"}, {"sha": "6081a8981bf1fa79009bc90951ac1f5699949d3e", "filename": "libjava/include/boehm-gc.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fboehm-gc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fboehm-gc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fboehm-gc.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,24 @@\n+// -*- c++ -*-\n+// boehm-gc.h - Defines for Boehm collector.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JV_BOEHM_GC__\n+#define __JV_BOEHM_GC__\n+\n+#define JV_MARKOBJ_DECL void *_Jv_MarkObj (void *, void *, void *, void *)\n+#define JV_MARKARRAY_DECL void *_Jv_MarkArray (void *, void *, void *, void *)\n+\n+extern \"C\"\n+{\n+  JV_MARKOBJ_DECL;\n+  JV_MARKARRAY_DECL;\n+};\n+\n+#endif /* __JV_BOEHM_GC__ */"}, {"sha": "b9b202d41dd9bc8bd80ae0bd3f7ff9d9ff4d6649", "filename": "libjava/include/cni.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fcni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fcni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fcni.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,133 @@\n+// cni.h -*- c++ -*-\n+// This file describes the Cygnus Native Interface, CNI.\n+// It provides a nicer interface to many of the things in javaprims.h.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_CNI_H__\n+#define __JAVA_CNI_H__\n+\n+#include <java/lang/Object.h>\n+#include <java/lang/Class.h>\n+\n+#include <java-threads.h>\n+#include <java-array.h>\n+\n+extern inline jobject\n+JvAllocObject (jclass cls)\n+{\n+  return _Jv_AllocObject (cls, cls->size());\n+}\n+\n+extern inline jobject\n+JvAllocObject (jclass cls, jsize sz)\n+{\n+  return _Jv_AllocObject (cls, sz);\n+}\n+\n+extern \"C\" jstring _Jv_NewStringUTF (const char *bytes);\n+extern \"C\" void _Jv_InitClass (jclass);\n+\n+extern inline void\n+JvInitClass (jclass cls)\n+{\n+  return _Jv_InitClass (cls);\n+}\n+\n+extern inline jstring\n+JvAllocString (jsize sz)\n+{\n+  return _Jv_AllocString (sz);\n+}\n+\n+extern inline jstring\n+JvNewString (const jchar *chars, jsize len)\n+{\n+  return _Jv_NewString (chars, len);\n+}\n+\n+extern inline jstring\n+JvNewStringLatin1 (const char *bytes, jsize len)\n+{\n+  return _Jv_NewStringLatin1 (bytes, len);\n+}\n+\n+extern inline jstring\n+JvNewStringLatin1 (const char *bytes)\n+{\n+  return _Jv_NewStringLatin1 (bytes, strlen (bytes));\n+}\n+\n+extern inline jchar *\n+_Jv_GetStringChars (jstring str)\n+{\n+  return (jchar*)((char*) str->data + str->boffset);\n+}\n+\n+extern inline jchar*\n+JvGetStringChars (jstring str)\n+{\n+  return _Jv_GetStringChars (str);\n+}\n+\n+extern inline jsize\n+JvGetStringUTFLength (jstring string)\n+{\n+  return _Jv_GetStringUTFLength (string);\n+}\n+\n+extern inline jsize\n+JvGetStringUTFRegion (jstring str, jsize start, jsize len, char *buf) \n+{ \n+  return _Jv_GetStringUTFRegion (str, start, len, buf); \n+} \n+\n+extern inline jstring\n+JvNewStringUTF (const char *bytes)\n+{\n+  return _Jv_NewStringUTF (bytes);\n+}\n+\n+extern class _Jv_PrimClass _Jv_byteClass, _Jv_shortClass, _Jv_intClass,\n+  _Jv_longClass, _Jv_booleanClass, _Jv_charClass, _Jv_floatClass,\n+  _Jv_doubleClass, _Jv_voidClass;\n+#define JvPrimClass(TYPE) ((jclass) & _Jv_##TYPE##Class)\n+\n+class JvSynchronize\n+{\n+private:\n+  jobject obj;\n+public:\n+  JvSynchronize (const jobject &o) : obj (o)\n+    { _Jv_MonitorEnter (obj); }\n+  ~JvSynchronize ()\n+    { _Jv_MonitorExit (obj); }\n+};\n+\n+// Throw some exception.\n+extern void JvThrow (jobject obj) __attribute__ ((__noreturn__));\n+extern inline void\n+JvThrow (jobject obj)\n+{\n+  _Jv_Throw ((void *) obj);\n+}\n+\n+/* Call malloc, but throw exception if insufficient memory. */\n+extern inline void *\n+JvMalloc (jsize size)\n+{\n+  return _Jv_Malloc (size);\n+}\n+\n+extern inline void\n+JvFree (void *ptr)\n+{\n+  return _Jv_Free (ptr);\n+}\n+#endif /* __JAVA_CNI_H__ */"}, {"sha": "7575b771a3d5e3f7e1ef64a32488c7563e8afbdc", "filename": "libjava/include/config.h.in", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,252 @@\n+/* include/config.h.in.  Generated automatically from configure.in by autoheader.  */\n+\n+/* Define if using alloca.c.  */\n+#undef C_ALLOCA\n+\n+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.\n+   This function is required for alloca.c support on those systems.  */\n+#undef CRAY_STACKSEG_END\n+\n+/* Define if you have alloca, as a function or macro.  */\n+#undef HAVE_ALLOCA\n+\n+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */\n+#undef HAVE_ALLOCA_H\n+\n+/* If using the C implementation of alloca, define if you know the\n+   direction of stack growth for your system; otherwise it will be\n+   automatically deduced at run-time.\n+ STACK_DIRECTION > 0 => grows toward higher addresses\n+ STACK_DIRECTION < 0 => grows toward lower addresses\n+ STACK_DIRECTION = 0 => direction of growth unknown\n+ */\n+#undef STACK_DIRECTION\n+\n+/* Define this if you want runtime debugging enabled.  */\n+#undef DEBUG\n+\n+/* Define if using POSIX threads that have the mutexattr functions.  */\n+#undef HAVE_PTHREAD_MUTEXATTR_INIT\n+\n+/* Define this if you prefer size over speed for java.lang.Character.  */\n+#undef COMPACT_CHARACTER\n+\n+/* Define if you have memcpy.  */\n+#undef HAVE_MEMCPY\n+\n+/* Define if you have memmove.  */\n+#undef HAVE_MEMMOVE\n+\n+/* Define if you have strerror.  */\n+#undef HAVE_STRERROR\n+\n+/* Define if you have __int32_t and __uint32_t. */\n+#undef HAVE_INT32_DEFINED\n+\n+/* Define if you're running eCos. */\n+#undef ECOS\n+\n+/* */\n+#undef HAVE_LOCALTIME\n+\n+/* */\n+#undef HAVE_MKTIME\n+\n+/* Define if using POSIX threads on Linux.  */\n+#undef LINUX_THREADS\n+\n+/* Define if you have the `ctime_r' function.  */\n+#undef HAVE_CTIME_R\n+\n+/* Define if you have the `gmtime_r' function.  */\n+#undef HAVE_GMTIME_R\n+\n+/* Define if you have the `localtime_r' function.  */\n+#undef HAVE_LOCALTIME_R\n+\n+/* Define if inet6 structures are defined in netinet/in.h.  */\n+#undef HAVE_INET6\n+\n+/* Define it socklen_t typedef is in sys/socket.h.  */\n+#undef HAVE_SOCKLEN_T\n+\n+/* Define if Boehm GC in use.  */\n+#undef HAVE_BOEHM_GC\n+\n+/* Define if gethostname is declared in <unistd.h>.  */\n+#undef HAVE_GETHOSTNAME_DECL\n+\n+/* Define if gethostbyname_r returns `int'.  */\n+#undef GETHOSTBYNAME_R_RETURNS_INT\n+\n+/* Define if gethostbyaddr_r returns `int'.  */\n+#undef GETHOSTBYADDR_R_RETURNS_INT\n+\n+/* Define if struct tm has tm_gmtoff field.  */\n+#undef STRUCT_TM_HAS_GMTOFF\n+\n+/* Define if global `timezone' exists.  */\n+#undef HAVE_TIMEZONE\n+\n+/* Define if you have the appropriate function.  */\n+#undef HAVE_ACCESS\n+#undef HAVE_STAT\n+#undef HAVE_MKDIR\n+#undef HAVE_RENAME\n+#undef HAVE_RMDIR\n+#undef HAVE_UNLINK\n+#undef HAVE_REALPATH\n+#undef HAVE_READDIR_R\n+#undef HAVE_GETHOSTBYNAME_R\n+#undef HAVE_GETHOSTBYADDR_R\n+\n+/* Define if you have the access function.  */\n+#undef HAVE_ACCESS\n+\n+/* Define if you have the ctime function.  */\n+#undef HAVE_CTIME\n+\n+/* Define if you have the ctime_r function.  */\n+#undef HAVE_CTIME_R\n+\n+/* Define if you have the fsync function.  */\n+#undef HAVE_FSYNC\n+\n+/* Define if you have the ftime function.  */\n+#undef HAVE_FTIME\n+\n+/* Define if you have the gethostbyaddr_r function.  */\n+#undef HAVE_GETHOSTBYADDR_R\n+\n+/* Define if you have the gethostbyname_r function.  */\n+#undef HAVE_GETHOSTBYNAME_R\n+\n+/* Define if you have the gethostname function.  */\n+#undef HAVE_GETHOSTNAME\n+\n+/* Define if you have the getpwuid_r function.  */\n+#undef HAVE_GETPWUID_R\n+\n+/* Define if you have the gettimeofday function.  */\n+#undef HAVE_GETTIMEOFDAY\n+\n+/* Define if you have the gmtime_r function.  */\n+#undef HAVE_GMTIME_R\n+\n+/* Define if you have the inet_addr function.  */\n+#undef HAVE_INET_ADDR\n+\n+/* Define if you have the inet_aton function.  */\n+#undef HAVE_INET_ATON\n+\n+/* Define if you have the inet_pton function.  */\n+#undef HAVE_INET_PTON\n+\n+/* Define if you have the ioctl function.  */\n+#undef HAVE_IOCTL\n+\n+/* Define if you have the localtime_r function.  */\n+#undef HAVE_LOCALTIME_R\n+\n+/* Define if you have the memcpy function.  */\n+#undef HAVE_MEMCPY\n+\n+/* Define if you have the memmove function.  */\n+#undef HAVE_MEMMOVE\n+\n+/* Define if you have the mkdir function.  */\n+#undef HAVE_MKDIR\n+\n+/* Define if you have the open function.  */\n+#undef HAVE_OPEN\n+\n+/* Define if you have the pthread_mutexattr_setkind_np function.  */\n+#undef HAVE_PTHREAD_MUTEXATTR_SETKIND_NP\n+\n+/* Define if you have the pthread_mutexattr_settype function.  */\n+#undef HAVE_PTHREAD_MUTEXATTR_SETTYPE\n+\n+/* Define if you have the readdir_r function.  */\n+#undef HAVE_READDIR_R\n+\n+/* Define if you have the realpath function.  */\n+#undef HAVE_REALPATH\n+\n+/* Define if you have the rename function.  */\n+#undef HAVE_RENAME\n+\n+/* Define if you have the rmdir function.  */\n+#undef HAVE_RMDIR\n+\n+/* Define if you have the sched_yield function.  */\n+#undef HAVE_SCHED_YIELD\n+\n+/* Define if you have the select function.  */\n+#undef HAVE_SELECT\n+\n+/* Define if you have the sleep function.  */\n+#undef HAVE_SLEEP\n+\n+/* Define if you have the stat function.  */\n+#undef HAVE_STAT\n+\n+/* Define if you have the strerror function.  */\n+#undef HAVE_STRERROR\n+\n+/* Define if you have the time function.  */\n+#undef HAVE_TIME\n+\n+/* Define if you have the uname function.  */\n+#undef HAVE_UNAME\n+\n+/* Define if you have the unlink function.  */\n+#undef HAVE_UNLINK\n+\n+/* Define if you have the <arpa/inet.h> header file.  */\n+#undef HAVE_ARPA_INET_H\n+\n+/* Define if you have the <dirent.h> header file.  */\n+#undef HAVE_DIRENT_H\n+\n+/* Define if you have the <fcntl.h> header file.  */\n+#undef HAVE_FCNTL_H\n+\n+/* Define if you have the <netdb.h> header file.  */\n+#undef HAVE_NETDB_H\n+\n+/* Define if you have the <netinet/in.h> header file.  */\n+#undef HAVE_NETINET_IN_H\n+\n+/* Define if you have the <pwd.h> header file.  */\n+#undef HAVE_PWD_H\n+\n+/* Define if you have the <sys/filio.h> header file.  */\n+#undef HAVE_SYS_FILIO_H\n+\n+/* Define if you have the <sys/ioctl.h> header file.  */\n+#undef HAVE_SYS_IOCTL_H\n+\n+/* Define if you have the <sys/select.h> header file.  */\n+#undef HAVE_SYS_SELECT_H\n+\n+/* Define if you have the <sys/socket.h> header file.  */\n+#undef HAVE_SYS_SOCKET_H\n+\n+/* Define if you have the <sys/stat.h> header file.  */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define if you have the <sys/time.h> header file.  */\n+#undef HAVE_SYS_TIME_H\n+\n+/* Define if you have the <sys/types.h> header file.  */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define if you have the <unistd.h> header file.  */\n+#undef HAVE_UNISTD_H\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Version number of package */\n+#undef VERSION\n+"}, {"sha": "3be61b635a234d77cb4793bd8ec03c9cf699c6fc", "filename": "libjava/include/java-array.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-array.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,78 @@\n+// java-array.h - Header file for CNI arrays.  -*- c++ -*-\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_ARRAY_H__\n+#define __JAVA_ARRAY_H__\n+\n+#pragma interface\n+\n+#include <java/lang/Object.h>\n+\n+extern \"Java\" {\n+\n+class __JArray : public java::lang::Object\n+{\n+public:\n+  int length;\n+  friend jsize JvGetArrayLength (__JArray*);\n+};\n+\n+template<class T>\n+class JArray : public __JArray\n+{\n+  T data[0];\n+public:\n+  friend T* elements<>(JArray<T>& x);\n+  friend T* elements<>(JArray<T>* x);\n+  // T* getData() { return data; }\n+  // T& operator[](jint i) { return data[i]; }\n+};\n+\n+template<class T>\n+T* elements(JArray<T>& x) { return x.data; }\n+template<class T>\n+T* elements(JArray<T>* x) { return x->data; }\n+\n+}; // end extern \"Java\"\n+\n+/* These typesdefs match those in JNI. */\n+typedef __JArray *jarray;\n+typedef JArray<jobject> *jobjectArray;\n+typedef JArray<jboolean> *jbooleanArray;\n+typedef JArray<jbyte> *jbyteArray;\n+typedef JArray<jchar> *jcharArray;\n+typedef JArray<jshort> *jshortArray;\n+typedef JArray<jint> *jintArray;\n+typedef JArray<jlong> *jlongArray;\n+typedef JArray<jfloat> *jfloatArray;\n+typedef JArray<jdouble> *jdoubleArray;\n+typedef JArray<jstring> *jstringArray;\n+// Temporary work-around for gcjh bug.  FIXME\n+typedef JArray<jcharArray> *jobjectArrayjchar;\n+\n+extern \"C\" jbooleanArray JvNewBooleanArray (jint length);\n+extern \"C\" jbyteArray JvNewByteArray (jint length);\n+extern \"C\" jcharArray JvNewCharArray (jint length);\n+extern \"C\" jshortArray JvNewShortArray (jint length);\n+extern \"C\" jintArray JvNewIntArray (jint length);\n+extern \"C\" jlongArray JvNewLongArray (jint length);\n+extern \"C\" jfloatArray JvNewFloatArray (jint length);\n+extern \"C\" jdoubleArray JvNewDoubleArray (jint length);\n+extern \"C\" jobjectArray _Jv_NewObjectArray(jsize length, jclass, jobject init);\n+\n+inline jobjectArray JvNewObjectArray (jsize length, jclass cls, jobject init)\n+{ return _Jv_NewObjectArray (length, cls, init); }\n+\n+extern \"C\" jstringArray JvConvertArgv(int argc, const char **argv);\n+extern \"C\" void JvRunMain (jclass klass, int argc, const char **argv);\n+\n+inline jsize JvGetArrayLength (jarray array) { return array->length; }\n+\n+#endif /* __JAVA_ARRAY_H__ */"}, {"sha": "6e942f2a705c37fa5842b9c96de15116c7a7ce9b", "filename": "libjava/include/java-assert.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-assert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-assert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-assert.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,38 @@\n+// java-assert.h - Header file holding assertion definitions.  -*- c++ -*-\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_ASSERT_H__\n+#define __JAVA_ASSERT_H__\n+\n+// This is a libgcj implementation header.\n+\n+void _Jv_Abort (const char *, const char *, int, const char *)\n+  __attribute__ ((__noreturn__));\n+\n+#ifdef DEBUG\n+#define _Jv_AssertDoCall(Message) _Jv_Abort (__FUNCTION__, __FILE__, __LINE__, Message)\n+\n+#define JvAssertMessage(Expr, Message) \\\n+   do { if (! (Expr)) _Jv_AssertDoCall (Message); } while (0)\n+#define JvAssert(Expr) \\\n+   do { if (! (Expr)) _Jv_AssertDoCall (# Expr); } while (0)\n+\n+#define JvFail(Message) _Jv_AssertDoCall (Message)\n+\n+#else /* DEBUG */\n+\n+#define _Jv_AssertDoCall(Message)\n+#define JvAssertMessage(Expr, Message)\n+#define JvAssert(Expr)\n+#define JvFail(Message) _Jv_Abort (0, 0, 0, Message)\n+\n+#endif /* not DEBUG */\n+\n+#endif /* __JAVA_ASSERT_H__ */"}, {"sha": "346492afbd41bad2efc8b9851816f45d1525b2e0", "filename": "libjava/include/java-chardecomp.h", "status": "added", "additions": 3416, "deletions": 0, "changes": 3416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-chardecomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-chardecomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-chardecomp.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "b1053da61cb04610cda3ec9e006bdeffe943f390", "filename": "libjava/include/java-chartables.h", "status": "added", "additions": 82984, "deletions": 0, "changes": 82984, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-chartables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-chartables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-chartables.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "b4529fca30ae9798346047a2db3c58b060966e2e", "filename": "libjava/include/java-field.h", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-field.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,158 @@\n+// java-field.h - Header file for fieldID instances.  -*- c++ -*-\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_FIELD_H__\n+#define __JAVA_FIELD_H__\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/reflect/Field.h>\n+\n+#define _Jv_FIELD_UNRESOLVED_FLAG\t0x8000\n+#define\t_Jv_FIELD_CONSTANT_VALUE\t0x4000\n+\n+struct _Jv_Field\n+{\n+#ifndef COMPACT_FIELDS\n+  struct _Jv_Utf8Const*\tname;\n+#endif\n+\n+  /* The type of the field, if isResolved().\n+     If !isResolved():  The fields's signature as a (Utf8Const*). */\n+  jclass\t\ttype;\n+\n+  _Jv_ushort\t\tflags;\n+\n+#ifdef COMPACT_FIELDS\n+  short\t\t\tnameIndex;  /* ofsfet in class's name table */\n+#else\n+  _Jv_ushort\t\tbsize;  /* not really needed ... */\n+#endif\n+\n+  union {\n+    int\t\t\tboffset;  /* offset in bytes for instance field */\n+    void*\t\taddr;  /* address of static field */\n+  } u;\n+\n+#ifdef __cplusplus\n+  jboolean isResolved ()\n+  { return ! (flags & _Jv_FIELD_UNRESOLVED_FLAG); }\n+\n+  public:\n+\n+  int getOffset () { return u.boffset; }\n+\n+  jobject getObjectField (jobject obj)\n+  { return *(jobject *)((char *)obj + getOffset ()); }\n+\n+  jfieldID getNextInstanceField () { return this + 1; }\n+\n+  jboolean isRef () { return ! isResolved () || ! type->isPrimitive (); }\n+\n+  // FIXME - may need to mask off internal flags.\n+  int getModifiers() { return flags; }\n+\n+#ifdef COMPACT_FIELDS\n+  _Jv_Utf8Const * getNameUtf8Const (jclass cls)\n+  { return clas->fieldNames + nameIndex; }\n+#else\n+  _Jv_Utf8Const * getNameUtf8Const (jclass) { return name; }\n+#endif\n+#endif\n+};\n+\n+#ifdef __cplusplus\n+inline jbyte\n+_Jv_GetStaticByteField (jclass, _Jv_Field* field)\n+{\n+  return * (jbyte *) field->u.addr;\n+}\n+\n+inline jshort\n+_Jv_GetStaticShortField (jclass, _Jv_Field* field)\n+{\n+  return * (jshort *) field->u.addr;\n+}\n+\n+inline jint\n+_Jv_GetStaticIntField (jclass, _Jv_Field* field)\n+{\n+  return * (jint *) field->u.addr;\n+}\n+\n+inline jlong\n+_Jv_GetStaticLongField (jclass, _Jv_Field* field)\n+{\n+  return * (jlong *) field->u.addr;\n+}\n+\n+inline jobject\n+_Jv_GetObjectField (jobject obj, _Jv_Field* field)\n+{\n+  return field->getObjectField (obj);\n+}\n+\n+inline jbyte\n+_Jv_GetByteField (jobject obj, _Jv_Field* field)\n+{\n+  return * (jbyte *) ((char*) obj + field->getOffset ());\n+}\n+\n+inline jshort\n+_Jv_GetShortField (jobject obj, _Jv_Field* field)\n+{\n+  return * (jshort *) ((char*) obj + field->getOffset ());\n+}\n+inline jint\n+_Jv_GetIntField (jobject obj, _Jv_Field* field)\n+{\n+  return * (jint *) ((char*) obj + field->getOffset ());\n+}\n+inline jlong\n+_Jv_GetLongField (jobject obj, _Jv_Field* field)\n+{\n+  return * (jlong *) ((char*) obj + field->getOffset ());\n+}\n+\n+extern inline jfieldID \n+_Jv_FromReflectedField (java::lang::reflect::Field *field)\n+{ \n+  return (jfieldID) ((char *) field->declaringClass->fields + field->offset); \n+} \n+\n+\n+#ifdef __JAVA_CNI_H__\n+extern inline jfieldID\n+JvGetFirstInstanceField (jclass klass)\n+{\n+  return &(klass->fields[klass->static_field_count]);\n+}\n+\n+extern inline jint\n+JvNumInstanceFields (jclass klass)\n+{\n+  return klass->field_count - klass->static_field_count;\n+}\n+\n+extern inline jboolean\n+JvFieldIsRef (jfieldID field)\n+{\n+  return field->isRef ();\n+}\n+\n+extern inline jobject\n+JvGetObjectField (jobject obj, _Jv_Field* field)\n+{\n+  return _Jv_GetObjectField (obj, field);\n+}\n+#endif /* defined (__JAVA_CNI_H__) */\n+\n+#endif\n+\n+#endif /* __JAVA_FIELD_H */"}, {"sha": "1bda4719c2b7a64c3aa87ae7905e29e10ef8f3db", "filename": "libjava/include/java-method.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-method.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjava-method.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-method.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,16 @@\n+// java-method.h - Header file for methodID instances.  -*- c++ -*-\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+extern inline jmethodID\n+_Jv_FromReflectedMethod(java::lang::reflect::Method *method)\n+{\n+  return (jmethodID)\n+    ((char *) method->declaringClass->methods + method->offset);\n+}"}, {"sha": "83c2cf9faebb9ad012d18d554266fc58910def31", "filename": "libjava/include/javaprims.h", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjavaprims.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,262 @@\n+// javaprims.h - Main external header file for libgcj.  -*- c++ -*-\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVAPRIMS_H__\n+#define __JAVAPRIMS_H__\n+\n+// To force selection of correct types that will mangle consistently\n+// across platforms.\n+extern \"Java\"\n+{\n+  typedef __java_byte jbyte;\n+  typedef __java_short jshort;\n+  typedef __java_int jint;\n+  typedef __java_long jlong;\n+  typedef __java_float jfloat;\n+  typedef __java_double jdouble;\n+  typedef __java_char jchar;\n+  typedef __java_boolean jboolean;\n+  typedef jint jsize;\n+\n+  // The following class declarations are automatically generated by\n+  // the `classes.pl' script.\n+  namespace java\n+  {\n+    namespace io\n+    {\n+      class BufferedInputStream;\n+      class BufferedOutputStream;\n+      class BufferedReader;\n+      class BufferedWriter;\n+      class ByteArrayInputStream;\n+      class ByteArrayOutputStream;\n+      class CharArrayReader;\n+      class CharArrayWriter;\n+      class CharConversionException;\n+      class DataInput;\n+      class DataInputStream;\n+      class DataOutput;\n+      class DataOutputStream;\n+      class EOFException;\n+      class File;\n+      class FileDescriptor;\n+      class FileInputStream;\n+      class FileNotFoundException;\n+      class FileOutputStream;\n+      class FileReader;\n+      class FileWriter;\n+      class FilenameFilter;\n+      class FilterInputStream;\n+      class FilterOutputStream;\n+      class FilterReader;\n+      class FilterWriter;\n+      class IOException;\n+      class InputStream;\n+      class InputStreamReader;\n+      class InterruptedIOException;\n+      class LineNumberInputStream;\n+      class LineNumberReader;\n+      class OutputStream;\n+      class OutputStreamWriter;\n+      class PipedInputStream;\n+      class PipedOutputStream;\n+      class PipedReader;\n+      class PipedWriter;\n+      class PrintStream;\n+      class PrintWriter;\n+      class PushbackInputStream;\n+      class PushbackReader;\n+      class RandomAccessFile;\n+      class Reader;\n+      class SequenceInputStream;\n+      class Serializable;\n+      class StreamTokenizer;\n+      class StringBufferInputStream;\n+      class StringReader;\n+      class StringWriter;\n+      class SyncFailedException;\n+      class UTFDataFormatException;\n+      class UnsupportedEncodingException;\n+      class Writer;\n+    };\n+\n+    namespace lang\n+    {\n+      class AbstractMethodError;\n+      class ArithmeticException;\n+      class ArrayIndexOutOfBoundsException;\n+      class ArrayStoreException;\n+      class Boolean;\n+      class Byte;\n+      class Character;\n+      class Class;\n+      class ClassCastException;\n+      class ClassCircularityError;\n+      class ClassFormatError;\n+      class ClassLoader;\n+      class ClassNotFoundException;\n+      class CloneNotSupportedException;\n+      class Cloneable;\n+      class Comparable;\n+      class Compiler;\n+      class Double;\n+      class Error;\n+      class Exception;\n+      class ExceptionInInitializerError;\n+      class FirstThread;\n+      class Float;\n+      class IllegalAccessError;\n+      class IllegalAccessException;\n+      class IllegalArgumentException;\n+      class IllegalMonitorStateException;\n+      class IllegalStateException;\n+      class IllegalThreadStateException;\n+      class IncompatibleClassChangeError;\n+      class IndexOutOfBoundsException;\n+      class InstantiationError;\n+      class InstantiationException;\n+      class Integer;\n+      class InternalError;\n+      class InterruptedException;\n+      class LinkageError;\n+      class Long;\n+      class Math;\n+      class NegativeArraySizeException;\n+      class NoClassDefFoundError;\n+      class NoSuchFieldError;\n+      class NoSuchFieldException;\n+      class NoSuchMethodError;\n+      class NoSuchMethodException;\n+      class NullPointerException;\n+      class Number;\n+      class NumberFormatException;\n+      class Object;\n+      class OutOfMemoryError;\n+      class Process;\n+      class Runnable;\n+      class Runtime;\n+      class RuntimeException;\n+      class SecurityException;\n+      class SecurityManager;\n+      class Short;\n+      class StackOverflowError;\n+      class String;\n+      class StringBuffer;\n+      class StringIndexOutOfBoundsException;\n+      class System;\n+      class Thread;\n+      class ThreadDeath;\n+      class ThreadGroup;\n+      class Throwable;\n+      class UnknownError;\n+      class UnsatisfiedLinkError;\n+      class UnsupportedOperationException;\n+      class VerifyError;\n+      class VirtualMachineError;\n+      class Void;\n+\n+      namespace reflect\n+      {\n+        class AccessibleObject;\n+        class Array;\n+        class Constructor;\n+        class Field;\n+        class InvocationTargetException;\n+        class Member;\n+        class Method;\n+        class Modifier;\n+      };\n+    };\n+\n+    namespace util\n+    {\n+      class BitSet;\n+      class Calendar;\n+      class ConcurrentModificationException;\n+      class Date;\n+      class Dictionary;\n+      class EmptyStackException;\n+      class Enumeration;\n+      class EventListener;\n+      class EventObject;\n+      class GregorianCalendar;\n+      class Hashtable;\n+      class HashtableEntry;\n+      class HashtableEnumeration;\n+      class ListResourceBundle;\n+      class Locale;\n+      class MissingResourceException;\n+      class NoSuchElementException;\n+      class Observable;\n+      class Observer;\n+      class Properties;\n+      class Random;\n+      class ResourceBundle;\n+      class SimpleTimeZone;\n+      class Stack;\n+      class StringTokenizer;\n+      class TimeZone;\n+      class TooManyListenersException;\n+      class Vector;\n+      class VectorEnumeration;\n+\n+      namespace zip\n+      {\n+        class Adler32;\n+        class CRC32;\n+        class Checksum;\n+        class Deflater;\n+        class DeflaterOutputStream;\n+        class ZipConstants;\n+        class ZipEntry;\n+        class ZipEnumeration;\n+        class ZipException;\n+        class ZipFile;\n+        class ZipOutputStream;\n+      };\n+    };\n+  };\n+};\n+\n+typedef struct java::lang::Object* jobject;\n+typedef class java::lang::Class* jclass;\n+typedef class java::lang::Throwable* jthrowable;\n+typedef class java::lang::String* jstring;\n+struct _Jv_JNIEnv;\n+\n+typedef struct _Jv_Field *jfieldID;\n+typedef struct _Jv_Method *jmethodID;\n+\n+extern \"C\" jobject _Jv_AllocObject (jclass, jint);\n+extern \"C\" jboolean _Jv_IsInstanceOf(jobject, jclass);\n+extern \"C\" jstring _Jv_AllocString(jsize);\n+extern \"C\" jstring _Jv_NewString (const jchar*, jsize);\n+extern \"C\" jchar* _Jv_GetStringChars (jstring str);\n+extern \"C\" jint _Jv_MonitorEnter (jobject);\n+extern \"C\" jint _Jv_MonitorExit (jobject);\n+extern \"C\" jstring _Jv_NewStringLatin1(const char*, jsize);\n+extern \"C\" jsize _Jv_GetStringUTFLength (jstring);\n+extern \"C\" jsize _Jv_GetStringUTFRegion (jstring, jsize, jsize, char *);\n+\n+extern \"C\" void _Jv_Throw (void *) __attribute__ ((__noreturn__));\n+extern \"C\" void* _Jv_Malloc (jsize);\n+extern \"C\" void _Jv_Free (void*);\n+\n+typedef unsigned short _Jv_ushort __attribute__((__mode__(__HI__)));\n+typedef unsigned int _Jv_uint __attribute__((__mode__(__SI__)));\n+\n+struct _Jv_Utf8Const\n+{\n+  _Jv_ushort hash;\n+  _Jv_ushort length;\t/* In bytes, of data portion, without final '\\0'. */\n+  char data[1];\t\t/* In Utf8 format, with final '\\0'. */\n+};\n+\n+#endif /* __JAVAPRIMS_H__ */"}, {"sha": "bf7b015cdca13a1892b4cfbec203ebe541cdcd52", "filename": "libjava/include/jni.h", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,302 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_JNI_H__\n+#define __JAVA_JNI_H__\n+\n+#ifdef __GNUC__\n+# define __need___va_list\n+# include <stdarg.h>\n+# define _Jv_va_list __gnuc_va_list\n+#else\n+# include <stdarg.h>\n+# define _Jv_va_list va_list\n+#endif\n+\n+#ifdef __cplusplus\n+\n+// This is wrong, because it pollutes the name-space too much!\n+#include <javaprims.h>\n+\n+typedef struct _Jv_JNIEnv JNIEnv;\n+#else\n+\n+typedef int    jbyte  __attribute__((__mode__(__QI__)));\n+typedef int    jshort __attribute__((__mode__(__HI__)));\n+typedef int    jint   __attribute__((__mode__(__SI__)));\n+typedef int    jlong  __attribute__((__mode__(__DI__)));\n+typedef bool   jboolean __attribute__((__mode__(__QI__)));\n+typedef unsigned short jchar __attribute__((__mode__(__HI__)));\n+typedef float  jfloat;\n+typedef double jdouble;\n+typedef jint jsize;\n+\n+typedef const struct JNINativeInterface *JNIEnv;\n+#endif\n+\n+typedef union jvalue\n+{\n+  jboolean z;\n+  jbyte    b;\n+  jchar    c;\n+  jshort  s;\n+  jint    i;\n+  jlong    j;\n+  jfloat  f;\n+  jdouble  d;\n+  jobject l;\n+} jvalue;\n+\n+typedef void * (*_Jv_func)(...);\n+\n+struct JNINativeInterface\n+{\n+  _Jv_func reserved0;\n+  _Jv_func reserved1;\n+  _Jv_func reserved2;\n+  _Jv_func reserved3;\n+  _Jv_func GetVersion;\n+  _Jv_func DefineClass;\n+  _Jv_func FindClass;\n+  _Jv_func reserved4;\n+  _Jv_func reserved5;\n+  _Jv_func reserved6;\n+  jclass   (*GetSuperclass)                (JNIEnv*, jclass);\n+  jboolean (*IsAssignableFrom)             (JNIEnv*, jclass, jclass);\n+  _Jv_func reserved7;\n+  jint     (*Throw)                        (JNIEnv*, jthrowable);\n+  _Jv_func ThrowNew;\n+  _Jv_func ExceptionOccurred;\n+  _Jv_func ExceptionDescribe;\n+  _Jv_func ExceptionClear;\n+  _Jv_func FatalError;\n+  _Jv_func reserved8;\n+  _Jv_func reserved9;\n+  _Jv_func NewGlobalRef;\n+  _Jv_func DeleteGlobalRef;\n+  _Jv_func DeleteLocalRef;\n+  _Jv_func IsSameObject;\n+  _Jv_func reserved10;\n+  _Jv_func reserved11;\n+  _Jv_func AllocObject;\n+  _Jv_func NewObject;\n+  _Jv_func NewObjectV;\n+  _Jv_func NewObjectA;\n+  _Jv_func GetObjectClass;\n+  _Jv_func IsInstanceOf;\n+  _Jv_func GetMethodID;\n+  _Jv_func CallObjectMethod;\n+  _Jv_func CallObjectMethodV;\n+  _Jv_func CallObjectMethodA;\n+  _Jv_func CallBooleanMethod;\n+  _Jv_func CallBooleanMethodV;\n+  _Jv_func CallBooleanMethodA;\n+  _Jv_func CallByteMethod;\n+  _Jv_func CallByteMethodV;\n+  _Jv_func CallByteMethodA;\n+  _Jv_func CallCharMethod;\n+  _Jv_func CallCharMethodV;\n+  _Jv_func CallCharMethodA;\n+  _Jv_func CallShortMethod;\n+  _Jv_func CallShortMethodV;\n+  _Jv_func CallShortMethodA;\n+  _Jv_func CallIntMethod;\n+  _Jv_func CallIntMethodV;\n+  _Jv_func CallIntMethodA;\n+  _Jv_func CallLongMethod;\n+  _Jv_func CallLongMethodV;\n+  _Jv_func CallLongMethodA;\n+  _Jv_func CallFloatMethod;\n+  _Jv_func CallFloatMethodV;\n+  _Jv_func CallFloatMethodA;\n+  _Jv_func CallDoubleMethod;\n+  _Jv_func CallDoubleMethodV;\n+  _Jv_func CallDoubleMethodA;\n+  _Jv_func CallVoidMethod;\n+  _Jv_func CallVoidMethodV;\n+  _Jv_func CallVoidMethodA;\n+  _Jv_func CallNonvirtualObjectMethod;\n+  _Jv_func CallNonvirtualObjectMethodV;\n+  _Jv_func CallNonvirtualObjectMethodA;\n+  jboolean (*CallNonvirtualBooleanMethod)  (JNIEnv*, jobject, jclass, jmethodID, ...);\n+  jboolean (*CallNonvirtualBooleanMethodV) (JNIEnv*, jobject, jclass, jmethodID, _Jv_va_list);\n+  jboolean (*CallNonvirtualBooleanMethodA) (JNIEnv*, jobject, jclass, jmethodID, jvalue*);\n+  _Jv_func CallNonvirtualByteMethod;\n+  _Jv_func CallNonvirtualByteMethodV;\n+  _Jv_func CallNonvirtualByteMethodA;\n+  _Jv_func CallNonvirtualCharMethod;\n+  _Jv_func CallNonvirtualCharMethodV;\n+  _Jv_func CallNonvirtualCharMethodA;\n+  _Jv_func CallNonvirtualShortMethod;\n+  _Jv_func CallNonvirtualShortMethodV;\n+  _Jv_func CallNonvirtualShortMethodA;\n+  _Jv_func CallNonvirtualIntMethod;\n+  _Jv_func CallNonvirtualIntMethodV;\n+  _Jv_func CallNonvirtualIntMethodA;\n+  _Jv_func CallNonvirtualLongMethod;\n+  _Jv_func CallNonvirtualLongMethodV;\n+  _Jv_func CallNonvirtualLongMethodA;\n+  _Jv_func CallNonvirtualFloatMethod;\n+  _Jv_func CallNonvirtualFloatMethodV;\n+  _Jv_func CallNonvirtualFloatMethodA;\n+  _Jv_func CallNonvirtualDoubleMethod;\n+  jdouble  (*CallNonvirtualDoubleMethodV)  (JNIEnv*, jobject, jclass, jmethodID, _Jv_va_list);\n+  _Jv_func CallNonvirtualDoubleMethodA;\n+  _Jv_func CallNonvirtualVoidMethod;\n+  _Jv_func CallNonvirtualVoidMethodV;\n+  _Jv_func CallNonvirtualVoidMethodA;\n+  _Jv_func GetFieldID;\n+  jobject  (*GetObjectField)               (JNIEnv*, jobject, jfieldID);\n+  jboolean (*GetBooleanField)              (JNIEnv*, jobject, jfieldID);\n+  jbyte    (*GetByteField)                 (JNIEnv*, jobject, jfieldID);\n+  jchar    (*GetCharField)                 (JNIEnv*, jobject, jfieldID);\n+  jshort   (*GetShortField)                (JNIEnv*, jobject, jfieldID);\n+  jint     (*GetIntField)                  (JNIEnv*, jobject, jfieldID);\n+  jlong    (*GetLongField)                 (JNIEnv*, jobject, jfieldID);\n+  jfloat   (*GetFloatField)                (JNIEnv*, jobject, jfieldID);\n+  jdouble  (*GetDoubleField)               (JNIEnv*, jobject, jfieldID);\n+  _Jv_func SetObjectField;\n+  _Jv_func SetBooleanField;\n+  _Jv_func SetByteField;\n+  _Jv_func SetCharField;\n+  _Jv_func SetShortField;\n+  _Jv_func SetIntField;\n+  _Jv_func SetLongField;\n+  _Jv_func SetFloatField;\n+  _Jv_func SetDoubleField;\n+  _Jv_func GetStaticMethodID;\n+  _Jv_func CallStaticObjectMethod;\n+  _Jv_func CallStaticObjectMethodV;\n+  _Jv_func CallStaticObjectMethodA;\n+  _Jv_func CallStaticBooleanMethod;\n+  _Jv_func CallStaticBooleanMethodV;\n+  _Jv_func CallStaticBooleanMethodA;\n+  _Jv_func CallStaticByteMethod;\n+  _Jv_func CallStaticByteMethodV;\n+  _Jv_func CallStaticByteMethodA;\n+  _Jv_func CallStaticCharMethod;\n+  _Jv_func CallStaticCharMethodV;\n+  _Jv_func CallStaticCharMethodA;\n+  _Jv_func CallStaticShortMethod;\n+  _Jv_func CallStaticShortMethodV;\n+  _Jv_func CallStaticShortMethodA;\n+  _Jv_func CallStaticIntMethod;\n+  _Jv_func CallStaticIntMethodV;\n+  _Jv_func CallStaticIntMethodA;\n+  _Jv_func CallStaticLongMethod;\n+  _Jv_func CallStaticLongMethodV;\n+  _Jv_func CallStaticLongMethodA;\n+  _Jv_func CallStaticFloatMethod;\n+  _Jv_func CallStaticFloatMethodV;\n+  _Jv_func CallStaticFloatMethodA;\n+  _Jv_func CallStaticDoubleMethod;\n+  _Jv_func CallStaticDoubleMethodV;\n+  _Jv_func CallStaticDoubleMethodA;\n+  _Jv_func CallStaticVoidMethod;\n+  _Jv_func CallStaticVoidMethodV;\n+  _Jv_func CallStaticVoidMethodA;\n+  _Jv_func GetStaticFieldID;\n+  _Jv_func GetStaticObjectField;\n+  _Jv_func GetStaticBooleanField;\n+  _Jv_func GetStaticByteField;\n+  _Jv_func GetStaticCharField;\n+  _Jv_func GetStaticShortField;\n+  _Jv_func GetStaticIntField;\n+  _Jv_func GetStaticLongField;\n+  _Jv_func GetStaticFloatField;\n+  _Jv_func GetStaticDoubleField;\n+  _Jv_func SetStaticObjectField;\n+  _Jv_func SetStaticBooleanField;\n+  _Jv_func SetStaticByteField;\n+  _Jv_func SetStaticCharField;\n+  _Jv_func SetStaticShortField;\n+  _Jv_func SetStaticIntField;\n+  _Jv_func SetStaticLongField;\n+  _Jv_func SetStaticFloatField;\n+  _Jv_func SetStaticDoubleField;\n+  _Jv_func NewString;\n+  jint     (*GetStringLength)              (JNIEnv*, jstring);\n+  _Jv_func GetStringChars;\n+  _Jv_func ReleaseStringChars;\n+  _Jv_func NewStringUTF;\n+  _Jv_func GetStringUTFLength;\n+  _Jv_func GetStringUTFChars;\n+  _Jv_func ReleaseStringUTFChars;\n+  _Jv_func GetArrayLength;\n+  _Jv_func NewObjectArray;\n+  _Jv_func GetObjectArrayElement;\n+  _Jv_func SetObjectArrayElement;\n+  _Jv_func NewBooleanArray;\n+  _Jv_func NewByteArray;\n+  _Jv_func NewCharArray;\n+  _Jv_func NewShortArray;\n+  _Jv_func NewIntArray;\n+  _Jv_func NewLongArray;\n+  _Jv_func NewFloatArray;\n+  _Jv_func NewDoubleArray;\n+  _Jv_func GetBooleanArrayElements;\n+  _Jv_func GetByteArrayElements;\n+  _Jv_func GetCharArrayElements;\n+  _Jv_func GetShortArrayElements;\n+  _Jv_func GetIntArrayElements;\n+  _Jv_func GetLongArrayElements;\n+  _Jv_func GetFloatArrayElements;\n+  _Jv_func GetDoubleArrayElements;\n+  _Jv_func ReleaseBooleanArrayElements;\n+  _Jv_func ReleaseByteArrayElements;\n+  _Jv_func ReleaseCharArrayElements;\n+  _Jv_func ReleaseShortArrayElements;\n+  _Jv_func ReleaseIntArrayElements;\n+  _Jv_func ReleaseLongArrayElements;\n+  _Jv_func ReleaseFloatArrayElements;\n+  _Jv_func ReleaseDoubleArrayElements;\n+  _Jv_func GetBooleanArrayRegion;\n+  _Jv_func GetByteArrayRegion;\n+  _Jv_func GetCharArrayRegion;\n+  _Jv_func GetShortArrayRegion;\n+  _Jv_func GetIntArrayRegion;\n+  _Jv_func GetLongArrayRegion;\n+  _Jv_func GetFloatArrayRegion;\n+  _Jv_func GetDoubleArrayRegion;\n+  _Jv_func SetBooleanArrayRegion;\n+  _Jv_func SetByteArrayRegion;\n+  _Jv_func SetCharArrayRegion;\n+  _Jv_func SetShortArrayRegion;\n+  _Jv_func SetIntArrayRegion;\n+  _Jv_func SetLongArrayRegion;\n+  _Jv_func SetFloatArrayRegion;\n+  _Jv_func SetDoubleArrayRegion;\n+  _Jv_func RegisterNatives;\n+  _Jv_func UnregisterNatives;\n+  _Jv_func MonitorEnter;\n+  _Jv_func MonitorExit;\n+  _Jv_func GetJavaVM;\n+};\n+\n+#ifdef __cplusplus\n+\n+struct _Jv_JNIEnv\n+{\n+  struct JNINativeInterface *p;\n+\n+  jclass GetSuperclass (jclass cl);\n+  jsize GetStringLength (jstring str);\n+\n+};\n+\n+extern inline jclass\n+_Jv_JNIEnv::GetSuperclass (jclass cl)\n+{ return p->GetSuperclass (this, cl); }\n+\n+extern inline jsize\n+_Jv_JNIEnv::GetStringLength (jstring str)\n+{ return p->GetStringLength (this, str); }\n+\n+#endif\n+\n+#endif /* __JAVA_JNI_H__ */"}, {"sha": "f928d7178b6be087ff4b1cb80ae2b935054e46ff", "filename": "libjava/include/jvm.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,101 @@\n+// jvm.h - Header file for private implementation information. -*- c++ -*-\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_JVM_H__\n+#define __JAVA_JVM_H__\n+\n+#include <java-assert.h>\n+#include <java-field.h>\n+\n+/* Structure of the virtual table.  */\n+struct _Jv_VTable\n+{\n+  jclass clas;\n+  void *method[1];\n+};\n+\n+/* Extract a character from a Java-style Utf8 string.\n+ * PTR points to the current character.\n+ * LIMIT points to the end of the Utf8 string.\n+ * PTR is incremented to point after the character thta gets returns.\n+ * On an error, -1 is returned. */\n+#define UTF8_GET(PTR, LIMIT) \\\n+  ((PTR) >= (LIMIT) ? -1 \\\n+   : *(PTR) < 128 ? *(PTR)++ \\\n+   : (*(PTR)&0xE0) == 0xC0 && ((PTR)+=2)<=(LIMIT) && ((PTR)[-1]&0xC0) == 0x80 \\\n+   ? (((PTR)[-2] & 0x1F) << 6) + ((PTR)[-1] & 0x3F) \\\n+   : (*(PTR) & 0xF0) == 0xE0 && ((PTR) += 3) <= (LIMIT) \\\n+   && ((PTR)[-2] & 0xC0) == 0x80 && ((PTR)[-1] & 0xC0) == 0x80 \\\n+   ? (((PTR)[-3]&0x0F) << 12) + (((PTR)[-2]&0x3F) << 6) + ((PTR)[-1]&0x3F) \\\n+   : ((PTR)++, -1))\n+\n+extern int _Jv_strLengthUtf8(char* str, int len);\n+\n+typedef struct _Jv_Utf8Const Utf8Const;\n+_Jv_Utf8Const *_Jv_makeUtf8Const (char *s, int len);\n+extern jboolean _Jv_equalUtf8Consts (_Jv_Utf8Const *, _Jv_Utf8Const *);\n+extern jboolean _Jv_equal (_Jv_Utf8Const *, jstring, jint);\n+\n+#define StringClass _CL_Q34java4lang6String\n+extern java::lang::Class StringClass;\n+\n+/* Type of pointer used as finalizer.  */\n+typedef void _Jv_FinalizerFunc (jobject);\n+\n+/* Allocate space for a new Java object.  */\n+void *_Jv_AllocObj (jsize size);\n+/* Allocate space for an array of Java objects.  */\n+void *_Jv_AllocArray (jsize size);\n+/* Allocate space that is known to be pointer-free.  */\n+void *_Jv_AllocBytes (jsize size);\n+/* Initialize the GC.  */\n+void _Jv_InitGC (void);\n+/* Register a finalizer.  */\n+void _Jv_RegisterFinalizer (void *object, _Jv_FinalizerFunc *method);\n+\n+/* Run finalizers for objects ready to be finalized..  */\n+void _Jv_RunFinalizers (void);\n+/* Run all finalizers.  Should be called only before exit.  */\n+void _Jv_RunAllFinalizers (void);\n+/* Perform a GC.  */\n+void _Jv_RunGC (void);\n+\n+/* Return approximation of total size of heap.  */\n+long _Jv_GCTotalMemory (void);\n+/* Return approximation of total free memory.  */\n+long _Jv_GCFreeMemory (void);\n+\n+/* Allocate some unscanned bytes.  Throw exception if out of memory.  */\n+void *_Jv_AllocBytesChecked (jsize size);\n+\n+// This function is used to determine the hash code of an object.\n+inline jint\n+_Jv_HashCode (jobject obj)\n+{\n+  return (jint) obj;\n+}\n+\n+extern \"C\" void _Jv_ThrowBadArrayIndex (jint bad_index);\n+extern \"C\" jobject _Jv_NewArray (jint type, jint size);\n+extern \"C\" jobject _Jv_NewMultiArray (jclass klass, jint dims, ...);\n+extern \"C\" void *_Jv_CheckCast (jclass klass, jobject obj);\n+extern \"C\" void *_Jv_LookupInterfaceMethod (jclass klass, Utf8Const *name,\n+\t\t\t\t\t    Utf8Const *signature);\n+extern \"C\" void _Jv_CheckArrayStore (jobject array, jobject obj);\n+extern \"C\" void _Jv_RegisterClass (jclass klass);\n+extern \"C\" void _Jv_RegisterClasses (jclass *classes);\n+extern jclass _Jv_FindClass (_Jv_Utf8Const *name,\n+\t\t\t     java::lang::ClassLoader *loader);\n+extern jclass _Jv_FindClassFromSignature (char *,\n+\t\t\t\t\t  java::lang::ClassLoader *loader);\n+\n+extern jobject _Jv_NewMultiArray (jclass, jint ndims, jint* dims);\n+\n+#endif /* __JAVA_JVM_H__ */"}, {"sha": "f5775b9f5e52b4769125667afb6ba9e62064a27d", "filename": "libjava/include/no-gc.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fno-gc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fno-gc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fno-gc.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,17 @@\n+// -*- c++ -*-\n+// no-gc.h - Defines for no garbage collector.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JV_NO_GC__\n+#define __JV_NO_GC__\n+\n+// Nothing.\n+\n+#endif /* __JV_NO_GC__ */"}, {"sha": "5de33868eaa302618476fc3772bb171b39a140cd", "filename": "libjava/include/no-threads.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fno-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fno-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fno-threads.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,154 @@\n+// -*- c++ -*-\n+// no-threads.h - Defines for using no threads.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JV_NO_THREADS__\n+#define __JV_NO_THREADS__\n+\n+#include \"config.h\"\n+\n+#include <stdlib.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+//\n+// Typedefs.\n+//\n+\n+typedef int _Jv_ConditionVariable_t;\n+typedef int _Jv_Mutex_t;\n+typedef int _Jv_Thread_t;\n+typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n+\n+\n+//\n+// Condition variables.\n+//\n+\n+inline void\n+_Jv_CondInit (_Jv_ConditionVariable_t *)\n+{\n+}\n+\n+// Waiting is ok provided there is a timeout.  Otherwise we will just\n+// wait forever.\n+inline int\n+_Jv_CondWait (_Jv_ConditionVariable_t *, _Jv_Mutex_t *,\n+\t      jlong millis, jint nanos)\n+{\n+  if (millis == 0 && nanos == 0)\n+    JvFail (\"_Jv_CondWait without timeout\");\n+\n+#ifdef HAVE_SLEEP\n+  int seconds = millis / 1000;\n+  if (seconds > 0)\n+    sleep (seconds);\n+#endif\n+\n+  return 0;\n+}\n+\n+inline int\n+_Jv_CondNotify (_Jv_ConditionVariable_t *, _Jv_Mutex_t *)\n+{\n+  // It is ok to notify -- it just has no effect.\n+  return 0;\n+}\n+\n+inline int\n+_Jv_CondNotifyAll (_Jv_ConditionVariable_t *, _Jv_Mutex_t *)\n+{\n+  // It is ok to notify -- it just has no effect.\n+  return 0;\n+}\n+\n+\n+//\n+// Mutexes.\n+//\n+\n+inline void\n+_Jv_MutexInit (_Jv_Mutex_t *)\n+{\n+}\n+\n+inline int\n+_Jv_MutexLock (_Jv_Mutex_t *)\n+{\n+  return 0;\n+}\n+\n+inline int\n+_Jv_MutexUnlock (_Jv_Mutex_t *)\n+{\n+  return 0;\n+}\n+\n+\n+//\n+// Thread creation and manipulation.\n+//\n+\n+inline void\n+_Jv_InitThreads (void)\n+{\n+}\n+\n+inline void\n+_Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *)\n+{\n+  *data = NULL;\n+}\n+\n+inline java::lang::Thread *\n+_Jv_ThreadCurrent (void)\n+{\n+  extern java::lang::Thread *_Jv_OnlyThread;\n+  return _Jv_OnlyThread;\n+}\n+\n+inline void\n+_Jv_ThreadYield (void)\n+{\n+}\n+\n+inline void\n+_Jv_ThreadSetPriority (_Jv_Thread_t *, jint)\n+{\n+}\n+\n+inline void\n+_Jv_ThreadCancel (_Jv_Thread_t *, void *)\n+{\n+  JvFail (\"_Jv_ThreadCancel\");\n+}\n+\n+// Like Cancel, but doesn't run cleanups.\n+inline void\n+_Jv_ThreadDestroy (_Jv_Thread_t *)\n+{\n+  JvFail (\"_Jv_ThreadDestroy\");\n+}\n+\n+void _Jv_ThreadStart (java::lang::Thread *, _Jv_Thread_t *,\n+\t\t      _Jv_ThreadStartFunc *meth);\n+\n+inline void\n+_Jv_ThreadWait (void)\n+{\n+}\n+\n+inline void\n+_Jv_ThreadInterrupt (_Jv_Thread_t *)\n+{\n+}\n+\n+#endif /* __JV_NO_THREADS__ */"}, {"sha": "6e4cc70c020efab2a7e75db1c7a88055c85b3d22", "filename": "libjava/include/posix-threads.h", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,210 @@\n+// -*- c++ -*-\n+// posix-threads.h - Defines for using POSIX threads.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JV_POSIX_THREADS__\n+#define __JV_POSIX_THREADS__\n+\n+// NOTE: This file may only reference those pthread functions which\n+// are known not to be overridden by the Boehm GC.  If in doubt, scan\n+// boehm-gc/gc.h.  This is yucky but lets us avoid including gc.h\n+// everywhere (which would be truly yucky).\n+\n+#include <pthread.h>\n+#include <sched.h>\n+\n+#if defined (HAVE_PTHREAD_MUTEXATTR_SETTYPE) || defined (HAVE_PTHREAD_MUTEXATTR_SETKIND_NP)\n+#  define HAVE_RECURSIVE_MUTEX 1\n+#endif\n+\n+\n+//\n+// Typedefs.\n+//\n+\n+typedef pthread_cond_t _Jv_ConditionVariable_t;\n+#ifdef HAVE_RECURSIVE_MUTEX\n+typedef pthread_mutex_t _Jv_Mutex_t;\n+#else\n+// Some systems do not have recursive mutexes, so we must simulate\n+// them.  Solaris is one such system.\n+typedef struct\n+{\n+  // Mutex used when locking this structure transiently.\n+  pthread_mutex_t mutex;\n+  // Mutex the thread holds the entire time this mutex is held.  This\n+  // is used to make condition variables work properly.\n+  pthread_mutex_t mutex2;\n+  // Condition variable used when waiting for this lock.\n+  pthread_cond_t cond;\n+  // Thread holding this mutex.  If COUNT is 0, no thread is holding.\n+  pthread_t thread;\n+  // Number of times mutex is held.  If 0, the lock is not held.\n+  int count;\n+} _Jv_Mutex_t;\n+#endif /* HAVE_RECURSIVE_MUTEX */\n+\n+typedef struct\n+{\n+  // Flag values are defined in implementation.\n+  int flags;\n+\n+  // Actual thread id.\n+  pthread_t thread;\n+\n+  // Exception we want to throw when cancelled.\n+  void *exception;\n+} _Jv_Thread_t;\n+typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n+\n+\n+//\n+// Condition variables.\n+//\n+\n+inline void\n+_Jv_CondInit (_Jv_ConditionVariable_t *cv)\n+{\n+  pthread_cond_init (cv, 0);\n+}\n+\n+#ifndef LINUX_THREADS\n+\n+// pthread_cond_destroy does nothing on Linux and it is a win to avoid\n+// defining this macro.\n+\n+#define _Jv_HaveCondDestroy\n+\n+inline void\n+_Jv_CondDestroy (_Jv_ConditionVariable_t *cv)\n+{\n+  pthread_cond_destroy (cv);\n+}\n+\n+#endif /* LINUX_THREADS */\n+\n+int _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n+\t\t  jlong millis, jint nanos);\n+\n+inline int\n+_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n+{\n+  // FIXME: check to see if mutex is held by current thread.\n+  return pthread_cond_signal (cv);\n+}\n+\n+inline int\n+_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n+{\n+  // FIXME: check to see if mutex is held by current thread.\n+  return pthread_cond_broadcast (cv);\n+}\n+\n+\n+//\n+// Mutexes.\n+//\n+\n+#ifdef RECURSIVE_MUTEX_IS_DEFAULT\n+inline void\n+_Jv_MutexInit (_Jv_Mutex_t *mu)\n+{\n+  pthread_mutex_init (mu, NULL);\n+}\n+#else\n+void _Jv_MutexInit (_Jv_Mutex_t *mu);\n+#endif\n+\n+#ifndef LINUX_THREADS\n+\n+// pthread_mutex_destroy does nothing on Linux and it is a win to avoid\n+// defining this macro.\n+\n+#define _Jv_HaveMutexDestroy\n+\n+#ifdef HAVE_RECURSIVE_MUTEX\n+\n+inline void\n+_Jv_MutexDestroy (_Jv_Mutex_t *mu)\n+{\n+  pthread_mutex_destroy (mu);\n+}\n+\n+#else /* HAVE_RECURSIVE_MUTEX */\n+\n+extern void _Jv_MutexDestroy (_Jv_Mutex_t *mu);\n+\n+#endif /* HAVE_RECURSIVE_MUTEX */\n+#endif /* LINUX_THREADS */\n+\n+#ifdef HAVE_RECURSIVE_MUTEX\n+\n+inline int\n+_Jv_MutexLock (_Jv_Mutex_t *mu)\n+{\n+  return pthread_mutex_lock (mu);\n+}\n+\n+inline int\n+_Jv_MutexUnlock (_Jv_Mutex_t *mu)\n+{\n+  return pthread_mutex_unlock (mu);\n+}\n+\n+#else /* HAVE_RECURSIVE_MUTEX */\n+\n+extern int _Jv_MutexLock (_Jv_Mutex_t *mu);\n+extern int _Jv_MutexUnlock (_Jv_Mutex_t *mu);\n+\n+#endif /* HAVE_RECURSIVE_MUTEX */\n+\n+\n+//\n+// Thread creation and manipulation.\n+//\n+\n+void _Jv_InitThreads (void);\n+\n+void _Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *thread);\n+\n+inline java::lang::Thread *\n+_Jv_ThreadCurrent (void)\n+{\n+  extern pthread_key_t _Jv_ThreadKey;\n+  return (java::lang::Thread *) pthread_getspecific (_Jv_ThreadKey);\n+}\n+\n+inline void\n+_Jv_ThreadYield (void)\n+{\n+#ifdef HAVE_SCHED_YIELD\n+  sched_yield ();\n+#endif /* HAVE_SCHED_YIELD */\n+}\n+\n+void _Jv_ThreadSetPriority (_Jv_Thread_t *data, jint prio);\n+\n+void _Jv_ThreadCancel (_Jv_Thread_t *data, void *error);\n+\n+// Like Cancel, but doesn't run cleanups.\n+inline void\n+_Jv_ThreadDestroy (_Jv_Thread_t *)\n+{\n+  JvFail (\"_Jv_ThreadDestroy\");\n+}\n+\n+void _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n+\t\t      _Jv_ThreadStartFunc *meth);\n+\n+void _Jv_ThreadWait (void);\n+\n+void _Jv_ThreadInterrupt (_Jv_Thread_t *data);\n+\n+#endif /* __JV_POSIX_THREADS__ */"}, {"sha": "3ce8ece216834c217b22550d0b23e4ce171f17e9", "filename": "libjava/include/quick-threads.h", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fquick-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Finclude%2Fquick-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fquick-threads.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,139 @@\n+// -*- c++ -*-\n+// quick-threads.h - Defines for using QuickThreads.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JV_QUICK_THREADS__\n+#define __JV_QUICK_THREADS__\n+\n+#include <coop.h>\n+\n+//\n+// Typedefs.\n+//\n+\n+typedef coop_c _Jv_ConditionVariable_t;\n+typedef coop_m _Jv_Mutex_t;\n+typedef coop_t *_Jv_Thread_t;\n+typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n+\n+\n+//\n+// Condition variables.\n+//\n+\n+inline void\n+_Jv_CondInit (_Jv_ConditionVariable_t *cv)\n+{\n+  coop_condition_variable_init (cv);\n+}\n+\n+inline int\n+_Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n+\t      jlong millis, jint nanos)\n+{\n+  return coop_condition_variable_wait (cv, mu, millis * 1000 + nanos / 1000);\n+}\n+\n+inline int\n+_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n+{\n+  return coop_condition_variable_signal (cv, mu);\n+}\n+\n+inline int\n+_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n+{\n+  return coop_condition_variable_signal_all (cv, mu);\n+}\n+\n+\n+//\n+// Mutexes.\n+//\n+\n+inline void\n+_Jv_MutexInit (_Jv_Mutex_t *mu)\n+{\n+  coop_mutex_init (mu);\n+}\n+\n+inline int\n+_Jv_MutexLock (_Jv_Mutex_t *mu)\n+{\n+  coop_mutex_lock (mu);\n+  return 0;\n+}\n+\n+inline int\n+_Jv_MutexUnlock (_Jv_Mutex_t *mu)\n+{\n+  return coop_mutex_unlock (mu);\n+}\n+\n+\n+//\n+// Thread creation and manipulation.\n+//\n+\n+void _Jv_InitThreads (void);\n+\n+inline void\n+_Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *)\n+{\n+  *data = new _Jv_Thread_t;\n+  **data = (coop_t *) 0;\n+}\n+\n+inline java::lang::Thread *\n+_Jv_ThreadCurrent (void)\n+{\n+  extern int _Jv_ThreadKey;\n+  return (java::lang::Thread *) coop_getspecific (_Jv_ThreadKey);\n+}\n+\n+inline void\n+_Jv_ThreadYield (void)\n+{\n+  coop_yield ();\n+}\n+\n+inline void\n+_Jv_ThreadSetPriority (_Jv_Thread_t *, jint)\n+{\n+}\n+\n+inline void\n+_Jv_ThreadCancel (_Jv_Thread_t *data, void *error)\n+{\n+  coop_terminate (*data, error);\n+}\n+\n+// Like Cancel, but doesn't run cleanups.\n+inline void\n+_Jv_ThreadDestroy (_Jv_Thread_t *data)\n+{\n+  coop_terminate (*data, 0);\n+}\n+\n+void _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n+\t\t      _Jv_ThreadStartFunc *meth);\n+\n+inline void\n+_Jv_ThreadWait (void)\n+{\n+  coop_start ();\n+}\n+\n+inline void\n+_Jv_ThreadInterrupt (_Jv_Thread_t *)\n+{\n+}\n+\n+#endif /* __JV_QUICK_THREADS__ */"}, {"sha": "698abf608af5c68e3b0bd84a40eca1276da9ebb6", "filename": "libjava/java/io/BufferedInputStream.java", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,168 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 8, 1998.\n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class BufferedInputStream extends FilterInputStream\n+{\n+  /* Internal buffer array for data. */\n+  protected byte[] buf;\n+\n+  /* Index one greater than the last valid byte in the buffer. */\n+  protected int count = 0;\n+\n+  /* The current position in the buffer. */\n+  protected int pos = 0;\n+\n+  /* The value of pos the last time mark() was called. */\n+  protected int markpos = -1;\n+\n+  /* The maximum read-ahead allowed before calls to reset() fail. */\n+  protected int marklimit = 0;\n+\n+  public BufferedInputStream(InputStream in)\n+  {\n+    this(in, 2048);\n+  }\n+\n+  public BufferedInputStream(InputStream in, int size)\n+  {\n+    super(in);\n+    if (size <= 0)\n+      throw new IllegalArgumentException();\n+    buf = new byte[size];\n+  }\n+\n+  public synchronized int available() throws IOException\n+  {\n+    return count - pos + super.available();\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    // Free up the array memory.\n+    buf = null;\n+    super.close();\n+  }\n+\n+  public synchronized void mark(int readlimit)\n+  {\n+    marklimit = readlimit;\n+    markpos = pos;\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return true;\n+  }\n+\n+  public synchronized int read() throws IOException\n+  {\n+    if (pos >= count && !refill())\n+      return -1;\t// EOF\n+\n+    if (markpos >= 0 && pos - markpos > marklimit)\n+      markpos = -1;\n+\n+    return ((int) buf[pos++]) & 0xFF;\n+  }\n+\n+  public synchronized int read(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    if (pos >= count && !refill())\n+      return -1;\t\t// No bytes were read before EOF.\n+\n+    int remain = Math.min(count - pos, len);\n+    System.arraycopy(buf, pos, b, off, remain);\n+    pos += remain;\n+\n+    if (markpos >= 0 && pos - markpos > marklimit)\n+      markpos = -1;\n+\n+    return remain;\n+  }\n+\n+  public synchronized void reset() throws IOException\n+  {\n+    if (markpos < 0)\n+      throw new IOException();\n+\n+    pos = markpos;\n+  }\n+\n+  public synchronized long skip(long n) throws IOException\n+  {\n+    final long origN = n;\n+\n+    while (n > 0L)\n+      {\n+\tif (pos >= count && !refill())\n+\t  if (n < origN)\n+\t    break;\n+\t  else\n+\t    return -1;\t// No bytes were read before EOF.\n+\n+\tint numread = (int) Math.min((long) (count - pos), n);\n+\tpos += numread;\n+\tn -= numread;\n+\n+        if (markpos >= 0 && pos - markpos > marklimit)\n+          markpos = -1;\n+      }\n+\n+    return origN - n;\n+  }\n+\n+  private boolean refill() throws IOException\n+  {\n+    if (markpos < 0)\n+      count = pos = 0;\n+    else if (markpos > 0)\n+      {\n+        // Shift the marked bytes (if any) to the beginning of the array\n+\t// but don't grow it.  This saves space in case a reset is done\n+\t// before we reach the max capacity of this array.\n+        System.arraycopy(buf, markpos, buf, 0, count - markpos);\n+\tcount -= markpos;\n+\tpos -= markpos;\n+\tmarkpos = 0;\n+      }\n+    else if (marklimit >= buf.length)\t// BTW, markpos == 0\n+      {\n+\t// Need to grow the buffer now to have room for marklimit bytes.\n+\t// Note that the new buffer is one greater than marklimit.\n+\t// This is so that there will be one byte past marklimit to be read\n+\t// before having to call refill again, thus allowing marklimit to be\n+\t// invalidated.  That way refill doesn't have to check marklimit.\n+\tbyte[] newbuf = new byte[marklimit + 1];\n+\tSystem.arraycopy(buf, 0, newbuf, 0, count);\n+\tbuf = newbuf;\n+      }\n+\n+    int numread = super.read(buf, count, buf.length - count);\n+\n+    if (numread < 0)\t// EOF\n+      return false;\n+\n+    count += numread;\n+    return true;\n+  }\n+}"}, {"sha": "d37ed5d2cb06f585962c4edc9ded1f5f1ee0ac81", "filename": "libjava/java/io/BufferedOutputStream.java", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedOutputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,76 @@\n+// BufferedOutputStream.java - A buffered stream\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public class BufferedOutputStream extends FilterOutputStream\n+{\n+  public BufferedOutputStream (OutputStream ox)\n+  {\n+    this (ox, 512);\n+  }\n+\n+  public BufferedOutputStream (OutputStream ox, int size)\n+  {\n+    super (ox);\n+    buf = new byte[size];\n+  }\n+\n+  public synchronized void flush () throws IOException\n+  {\n+    out.write(buf, 0, count);\n+    count = 0;\n+    out.flush();\n+  }\n+\n+  public synchronized void write (int b) throws IOException\n+  {\n+    if (count < buf.length)\n+      buf[count++] = (byte) b;\n+    else\n+      {\n+\tout.write(buf, 0, count);\n+\tcount = 0;\n+\tout.write(b);\n+      }\n+  }\n+\n+  public synchronized void write (byte[] b, int off, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException\n+  {\n+    // If LEN < 0 then the downstream write will fail for us.\n+    if (len >= 0 && count + len < buf.length)\n+      {\n+\tSystem.arraycopy(b, off, buf, count, len);\n+\tcount += len;\n+      }\n+    else\n+      {\n+\tout.write(buf, 0, count);\n+\tcount = 0;\n+\tout.write(b, off, len);\n+      }\n+  }\n+\n+  // The buffer.\n+  protected byte[] buf;\n+  // Number of valid bytes in BUF.\n+  protected int count;\n+}"}, {"sha": "19e371a24e343dfdf2da499bf2355ff982e5acbc", "filename": "libjava/java/io/BufferedReader.java", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,373 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 22, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class BufferedReader extends Reader\n+{\n+  Reader in;\n+  char[] buffer;\n+  /* Index of current read position.  Must be >= 0 and <= limit. */\n+  /* There is a special case where pos may be equal to limit+1; this\n+   * is used as an indicator that a readLine was done with a '\\r' was\n+   * the very last char in the buffer.  Since we don't want to read-ahead\n+   * and potentially block, we set pos this way to indicate the situation\n+   * and deal with it later.  Doing it this way rather than having a\n+   * separate boolean field to indicate the condition has the advantage\n+   * that it is self-clearing on things like mark/reset.\n+   */\n+  int pos;\n+  /* Limit of valid data in buffer.  Must be >= pos and <= buffer.length. */\n+  /* This can be < pos in the one special case described above. */\n+  int limit;\n+\n+  /* The value -1 means there is no mark, or the mark has been invalidated.\n+     Otherwise, markPos is the index in the buffer of the marked position.\n+     Must be >= 0 and <= pos.\n+     Note we do not explicitly store the read-limit.\n+     The implicit read-limit is (buffer.length - markPos), which is\n+     guaranteed to be >= the read-limit requested in the call to mark. */\n+  int markPos = -1;\n+\n+  public BufferedReader(Reader in)\n+  {\n+    this(in, 8192);\n+  }\n+\n+  public BufferedReader(Reader in, int size)\n+  {\n+    super(in.lock);\n+    this.in = in;\n+    buffer = new char[size];\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (in != null)\n+\t  in.close();\n+\tin = null;\n+\tbuffer = null;\n+      }\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return true;\n+  }\n+\n+  public void mark(int readLimit) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\t// In this method we need to be aware of the special case where\n+\t// pos + 1 == limit.  This indicates that a '\\r' was the last char\n+\t// in the buffer during a readLine.  We'll want to maintain that\n+\t// condition after we shift things around and if a larger buffer is\n+\t// needed to track readLimit, we'll have to make it one element\n+\t// larger to ensure we don't invalidate the mark too early, if the\n+\t// char following the '\\r' is NOT a '\\n'.  This is ok because, per\n+\t// the spec, we are not required to invalidate when passing readLimit.\n+\t//\n+\t// Note that if 'pos > limit', then doing 'limit -= pos' will cause\n+\t// limit to be negative.  This is the only way limit will be < 0.\n+\n+\tif (pos + readLimit > limit)\n+\t  {\n+\t    char[] old_buffer = buffer;\n+\t    int extraBuffSpace = 0;\n+\t    if (pos > limit)\n+\t      extraBuffSpace = 1;\n+\t    if (readLimit + extraBuffSpace > limit)\n+\t      buffer = new char[readLimit + extraBuffSpace];\n+\t    limit -= pos;\n+\t    if (limit >= 0)\n+\t      {\n+\t        System.arraycopy(old_buffer, pos, buffer, 0, limit);\n+\t        pos = 0;\n+\t      }\n+\t  }\n+\n+\tif (limit < 0)\n+\t  {\n+\t    // Maintain the relationship of 'pos > limit'.\n+\t    pos = 1;\n+\t    limit = markPos = 0;\n+\t  }\n+\telse\n+\t  markPos = pos;\n+\t// Now pos + readLimit <= buffer.length. thus if we need to read\n+\t// beyond buffer.length, then we are allowed to invalidate markPos.\n+      }\n+  }\n+\n+  public void reset() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (markPos < 0)\n+\t  throw new IOException(\"mark never set or invalidated\");\n+\n+\t// Need to handle the extremely unlikely case where a readLine was\n+\t// done with a '\\r' as the last char in the buffer; which was then\n+\t// immediately followed by a mark and a reset with NO intervening\n+\t// read of any sort.  In that case, setting pos to markPos would\n+\t// lose that info and a subsequent read would thus not skip a '\\n'\n+\t// (if one exists).  The value of limit in this rare case is zero.\n+\t// We can assume that if limit is zero for other reasons, then\n+\t// pos is already set to zero and doesn't need to be readjusted.\n+\tif (limit > 0)\n+\t  pos = markPos;\n+      }\n+  }\n+\n+  public boolean ready() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\treturn pos < limit || in.ready();\n+      }\n+  }\n+\n+  public int read(char[] buf, int offset, int count) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\t// Once again, we need to handle the special case of a readLine\n+\t// that has a '\\r' at the end of the buffer.  In this case, we'll\n+\t// need to skip a '\\n' if it is the next char to be read.\n+\t// This special case is indicated by 'pos > limit'.\n+\tboolean retAtEndOfBuffer = false;\n+\n+\tint avail = limit - pos;\n+\tif (count > avail)\n+\t  {\n+\t    if (avail > 0)\n+\t      count = avail;\n+\t    else // pos >= limit\n+\t      {\n+\t\tif (limit == buffer.length)\n+\t\t  markPos = -1; // read too far - invalidate the mark.\n+\t\tif (pos > limit)\n+\t\t  {\n+\t\t    // Set a boolean and make pos == limit to simplify things.\n+\t\t    retAtEndOfBuffer = true;\n+\t\t    --pos;\n+\t\t  }\n+\t\tif (markPos < 0)\n+\t\t  {\n+\t\t    // Optimization:  can read directly into buf.\n+\t\t    if (count >= buffer.length && !retAtEndOfBuffer)\n+\t\t      return in.read(buf, offset, count);\n+\t\t    pos = limit = 0;\n+\t\t  }\n+\t\tavail = in.read(buffer, limit, buffer.length - limit);\n+\t\tif (retAtEndOfBuffer && avail > 0 && buffer[limit] == '\\n')\n+\t\t  {\n+\t\t    --avail;\n+\t\t    limit++;\n+\t\t  }\n+\t\tif (avail < count)\n+\t\t  {\n+\t\t    if (avail <= 0)\n+\t\t      return avail;\n+\t\t    count = avail;\n+\t\t  }\n+\t\tlimit += avail;\n+\t      }\n+\t  }\n+\tSystem.arraycopy(buffer, pos, buf, offset, count);\n+\tpos += count;\n+\treturn count;\n+      }\n+  }\n+\n+  /* Read more data into the buffer.  Update pos and limit appropriatly.\n+     Assumes pos==limit initially.  May invalidate the mark if read too much.\n+     Return number of chars read (never 0), or -1 on eof. */\n+  private int fill() throws IOException\n+  {\n+    // Handle the special case of a readLine that has a '\\r' at the end of\n+    // the buffer.  In this case, we'll need to skip a '\\n' if it is the\n+    // next char to be read.  This special case is indicated by 'pos > limit'.\n+    boolean retAtEndOfBuffer = false;\n+    if (pos > limit)\n+      {\n+        retAtEndOfBuffer = true;\n+\t--pos;\n+      }\n+\n+    if (markPos >= 0 && limit == buffer.length)\n+      markPos = -1;\n+    if (markPos <= 0)\n+      pos = limit = 0;\n+    int count = in.read(buffer, limit, buffer.length - limit);\n+    if (count > 0)\n+      limit += count;\n+\n+    if (retAtEndOfBuffer && buffer[pos] == '\\n')\n+      {\n+\t--count;\n+\tpos++;\n+      }\n+\n+    return count;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (pos >= limit && fill () <= 0)\n+\t  return -1;\n+\treturn buffer[pos++];\n+      }\n+  }\n+\n+  /* Return the end of the line starting at this.pos and ending at limit.\n+   * The index returns is *before* any line terminators, or limit\n+   * if no line terminators were found.\n+   */\n+  private int lineEnd(int limit)\n+  {\n+    int i = pos;\n+    for (; i < limit; i++)\n+      {\n+\tchar ch = buffer[i];\n+\tif (ch == '\\n' || ch == '\\r')\n+\t  break;\n+      }\n+    return i;\n+  }\n+\n+  public String readLine() throws IOException\n+  {\n+    // Handle the special case where a previous readLine (with no intervening\n+    // reads/skips) had a '\\r' at the end of the buffer.\n+    // In this case, we'll need to skip a '\\n' if it's the next char to be read.\n+    // This special case is indicated by 'pos > limit'.\n+    if (pos > limit)\n+      {\n+\tint ch = read();\n+\tif (ch < 0)\n+\t  return null;\n+\tif (ch != '\\n')\n+\t  --pos;\n+      }\n+    int i = lineEnd(limit);\n+    if (i < limit)\n+      {\n+\tString str = new String(buffer, pos, i - pos);\n+\tpos = i + 1;\n+\t// If the last char in the buffer is a '\\r', we must remember\n+\t// to check if the next char to be read after the buffer is refilled\n+\t// is a '\\n'.  If so, skip it.  To indicate this condition, we set pos\n+\t// to be limit + 1, which normally is never possible.\n+\tif (buffer[i] == '\\r')\n+\t  if (pos == limit || buffer[pos] == '\\n')\n+\t    pos++;\n+\treturn str;\n+      }\n+    StringBuffer sbuf = new StringBuffer(200);\n+    sbuf.append(buffer, pos, i - pos);\n+    pos = i;\n+    // We only want to return null when no characters were read before\n+    // EOF.  So we must keep track of this separately.  Otherwise we\n+    // would treat an empty `sbuf' as an EOF condition, which is wrong\n+    // when there is just a newline.\n+    boolean eof = false;\n+    for (;;)\n+      {\n+\tint ch = read();\n+\tif (ch < 0)\n+\t  {\n+\t    eof = true;\n+\t    break;\n+\t  }\n+\tif (ch == '\\n' || ch == '\\r')\n+\t  {\n+\t    // Check here if a '\\r' was the last char in the buffer; if so,\n+\t    // mark it as in the comment above to indicate future reads\n+\t    // should skip a newline that is the next char read after\n+\t    // refilling the buffer.\n+\t    if (ch == '\\r')\n+\t      if (pos == limit || buffer[pos] == '\\n')\n+\t        pos++;\n+\t    break;\n+\t  }\n+\ti = lineEnd(limit);\n+\tsbuf.append(buffer, pos - 1, i - (pos - 1));\n+\tpos = i;\n+      }\n+    return (sbuf.length() == 0 && eof) ? null : sbuf.toString();\n+  }\n+\n+  public long skip(long count) throws IOException\n+  {\n+    if (count <= 0)\n+      return 0;\n+    synchronized (lock)\n+      {\n+\t// Yet again, we need to handle the special case of a readLine\n+\t// that has a '\\r' at the end of the buffer.  In this case, we need\n+\t// to ignore a '\\n' if it is the next char to be read.\n+\t// This special case is indicated by 'pos > limit' (i.e. avail < 0).\n+\t// To simplify things, if we're dealing with the special case for\n+\t// readLine, just read the next char (since the fill method will\n+\t// skip the '\\n' for us).  By doing this, we'll have to back up pos.\n+\t// That's easier than trying to keep track of whether we've skipped\n+\t// one element or not.\n+\tint ch;\n+\tif (pos > limit)\n+\t  if ((ch = read()) < 0)\n+\t    return 0;\n+\t  else\n+\t    --pos; \n+\n+\tint avail = limit - pos;\n+\n+\tif (count < avail)\n+\t  {\n+\t    pos += count;\n+\t    return count;\n+\t  }\n+\n+\tpos = limit;\n+\tlong todo = count - avail;\n+\tif (todo > buffer.length)\n+\t  {\n+\t    markPos = -1;\n+\t    todo -= in.skip(todo);\n+\t  }\n+\telse\n+\t  {\n+\t    while (todo > 0)\n+\t      {\n+\t\tavail = fill();\n+\t\tif (avail <= 0)\n+\t\t  break;\n+\t\tif (avail > todo)\n+\t\t  avail = (int) todo;\n+\t\tpos += avail;\n+\t\ttodo -= avail;\n+\t      }\n+\t  }\n+\treturn count - todo;\n+      }\n+  }\n+}"}, {"sha": "85aceed68bdc0b6dabbb5a16841f81841ff5d51e", "filename": "libjava/java/io/BufferedWriter.java", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FBufferedWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,129 @@\n+// BufferedWriter.java - Filtered character output stream.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+// Why not extend FilterWriter?\n+public class BufferedWriter extends Writer\n+{\n+  public BufferedWriter (Writer out)\n+  {\n+    this (out, 8192);\n+  }\n+\n+  public BufferedWriter (Writer ox, int size)\n+  {\n+    super (ox);\n+    out = ox;\n+    buffer = new char[size];\n+    count = 0;\n+  }\n+\n+  public void close () throws IOException\n+  {\n+    localFlush ();\n+    out.close();\n+  }\n+\n+  public void flush () throws IOException\n+  {\n+    localFlush ();\n+    out.flush();\n+  }\n+\n+  public void newLine () throws IOException\n+  {\n+    write (System.getProperty(\"line.separator\"));\n+  }\n+\n+  public void write (int oneChar) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tbuffer[count++] = (char) oneChar;\n+\tif (count == buffer.length)\n+\t  localFlush ();\n+      }\n+  }\n+\n+  public void write (char[] buf, int offset, int len) throws IOException\n+  {\n+    if (offset < 0 || len < 0 || offset + len > buf.length)\n+      throw new ArrayIndexOutOfBoundsException ();\n+\n+    synchronized (lock)\n+      {\n+\t// Bypass buffering if there is too much incoming data.\n+\tif (count + len > buffer.length)\n+\t  {\n+\t    localFlush ();\n+\t    out.write(buf, offset, len);\n+\t  }\n+\telse\n+\t  {\n+\t    System.arraycopy(buf, offset, buffer, count, len);\n+\t    count += len;\n+\t    if (count == buffer.length)\n+\t      localFlush ();\n+\t  }\n+      }\n+  }\n+\n+  public void write (String str, int offset, int len) throws IOException\n+  {\n+    if (offset < 0 || len < 0 || offset + len < str.length())\n+      throw new ArrayIndexOutOfBoundsException ();\n+\n+    synchronized (lock)\n+      {\n+\tif (count + len > buffer.length)\n+\t  {\n+\t    localFlush ();\n+\t    out.write(str, offset, len);\n+\t  }\n+\telse\n+\t  {\n+\t    str.getChars(offset, offset + len, buffer, count);\n+\t    count += len;\n+\t    if (count == buffer.length)\n+\t      localFlush ();\n+\t  }\n+      }\n+  }\n+\n+  private final void localFlush () throws IOException\n+  {\n+    if (count > 0)\n+      {\n+\tsynchronized (lock)\n+\t  {\n+\t    out.write(buffer, 0, count);\n+\t    count = 0;\n+\t  }\n+      }\n+  }\n+\n+  // The downstream writer.\n+  private Writer out;\n+  // The character buffer.\n+  char[] buffer;\n+  // Number of valid chars in buffer.\n+  int count;\n+}"}, {"sha": "9b9bf964baa4d249b977806229bc6138368d17aa", "filename": "libjava/java/io/ByteArrayInputStream.java", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FByteArrayInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FByteArrayInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FByteArrayInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,113 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 7, 1998.  \n+ */ \n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct\n+ */\n+ \n+public class ByteArrayInputStream extends InputStream\n+{\n+  /* An array of bytes provided by the creator of the stream. */\n+  protected byte[] buf;\n+\n+  /* Position of the next byte in buf to be read. */\n+  protected int pos;\n+\n+  /* The currently marked position in the stream. */\n+  protected int mark;\n+\n+  /* The index in buf one greater than the last valid character. */\n+  protected int count;\n+\n+  public ByteArrayInputStream(byte[] buffer)\n+  {\n+    this(buffer, 0, buffer.length);\n+  }\n+\n+  public ByteArrayInputStream(byte[] buffer, int offset, int length)\n+  {\n+    buf = buffer;\n+\n+    count = offset + length;\n+    if (count > buf.length)\n+      count = buf.length;\n+\n+    pos = offset;\n+    // TBD: What should we do if pos is neg. or > count?  E.g. throw exc. or:\n+    // if (pos < 0 || pos > count)\n+    //   pos = 0;\n+\n+    mark = pos;\n+  }\n+\n+  public synchronized int available()\n+  {\n+    return count - pos;\n+  }\n+\n+  public synchronized void mark(int readAheadLimit)\n+  {\n+    // readAheadLimit is ignored per Java Class Lib. book, p.220.\n+    mark = pos;\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return true;\n+  }\n+\n+  public synchronized int read()\n+  {\n+    if (pos < 0)\n+      throw new ArrayIndexOutOfBoundsException(pos);\n+\n+    if (pos < count)\n+      return ((int) buf[pos++]) & 0xFF;\n+    return -1;\n+  }\n+\n+  public synchronized int read(byte[] b, int off, int len)\n+  {\n+    /* Don't need to check pos value, arraycopy will check it. */\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    if (pos >= count)\n+      return -1;\n+\n+    int numBytes = Math.min(count - pos, len);\n+    System.arraycopy(buf, pos, b, off, numBytes);\n+    pos += numBytes;\n+    return numBytes;\n+  }\n+\n+  public synchronized void reset()\n+  {\n+    pos = mark;\n+  }\n+\n+  public synchronized long skip(long n)\n+  {\n+    // Even though the var numBytes is a long, in reality it can never\n+    // be larger than an int since the result of subtracting 2 positive\n+    // ints will always fit in an int.  Since we have to return a long\n+    // anyway, numBytes might as well just be a long.\n+    long numBytes = Math.min((long) (count - pos), n < 0 ? 0L : n);\n+    pos += numBytes;\n+    return numBytes;\n+  }\n+}"}, {"sha": "4d5f224e376b4515449e2aa7c166411ef9b85609", "filename": "libjava/java/io/ByteArrayOutputStream.java", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,108 @@\n+// ByteArrayOutputStream.java - Write bytes to an array.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public class ByteArrayOutputStream extends OutputStream\n+{\n+  public ByteArrayOutputStream ()\n+  {\n+    this (32);\n+  }\n+\n+  public ByteArrayOutputStream (int size)\n+  {\n+    buf = new byte[size];\n+    count = 0;\n+  }\n+\n+  public synchronized void reset ()\n+  {\n+    count = 0;\n+  }\n+\n+  public int size ()\n+  {\n+    return count;\n+  }\n+\n+  public synchronized byte[] toByteArray ()\n+  {\n+    byte[] ret = new byte[count];\n+    System.arraycopy(buf, 0, ret, 0, count);\n+    return ret;\n+  }\n+\n+  public String toString ()\n+  {\n+    return new String (buf, 0, count);\n+  }\n+\n+  public String toString (String enc) throws UnsupportedEncodingException\n+  {\n+    return new String (buf, 0, count, enc);\n+  }\n+\n+  // This is deprecated in the JCL book.\n+  public String toString (int hibyte)\n+  {\n+    return new String (buf, 0, count, hibyte);\n+  }\n+\n+  // Resize buffer to accomodate new bytes.\n+  private void resize (int add)\n+  {\n+    if (count + add >= buf.length)\n+      {\n+\tint newlen = buf.length * 2;\n+\tif (count + add > newlen)\n+\t  newlen = count + add;\n+\tbyte[] newbuf = new byte[newlen];\n+\tSystem.arraycopy(buf, 0, newbuf, 0, count);\n+\tbuf = newbuf;\n+      }\n+  }\n+\n+  public synchronized void write (int oneByte)\n+  {\n+    resize (1);\n+    buf[count++] = (byte) oneByte;\n+  }\n+\n+  public synchronized void write (byte[] buffer, int offset, int add)\n+  {\n+    // If ADD < 0 then arraycopy will throw the appropriate error for\n+    // us.\n+    if (add >= 0)\n+      resize (add);\n+    System.arraycopy(buffer, offset, buf, count, add);\n+    count += add;\n+  }\n+\n+  public synchronized void writeTo (OutputStream out) throws IOException\n+  {\n+    out.write(buf, 0, count);\n+  }\n+\n+  // The byte buffer.\n+  protected byte[] buf;\n+  // Number of valid bytes in buffer.\n+  protected int count;\n+}"}, {"sha": "a43e8da62e9f6ee499671cdfb1e59d4e2bedfafc", "filename": "libjava/java/io/CharArrayReader.java", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FCharArrayReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FCharArrayReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FCharArrayReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,152 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 16, 1998.  \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct\n+ */\n+ \n+public class CharArrayReader extends Reader\n+{\n+  /* An array of chars provided by the creator of the stream. */\n+  protected char[] buf;\n+\n+  /* Position of the next char in buf to be read. */\n+  protected int pos;\n+\n+  /* The currently marked position in the stream. */\n+  protected int markedPos;\n+\n+  /* The index in buf one greater than the last valid character. */\n+  protected int count;\n+\n+  public CharArrayReader(char[] buffer)\n+  {\n+    this(buffer, 0, buffer.length);\n+  }\n+\n+  public CharArrayReader(char[] buffer, int offset, int length)\n+  {\n+    super();\n+    buf = buffer;\n+\n+    count = offset + length;\n+    if (count > buf.length)\n+      count = buf.length;\n+\n+    pos = offset;\n+    // TBD: What should we do if pos is neg. or > count?  E.g. throw exc. or:\n+    // if (pos < 0 || pos > count)\n+    //   pos = 0;\n+\n+    markedPos = pos;\n+  }\n+\n+  public void close()\n+  {\n+    synchronized (lock)\n+    {\n+      buf = null;\n+    }\n+  }\n+\n+  public void mark(int readAheadLimit)\n+  {\n+    synchronized (lock)\n+    {\n+      // readAheadLimit is ignored per Java Class Lib. book, p. 318.\n+      markedPos = pos;\n+    }\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return true;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      if (pos < 0)\n+        throw new ArrayIndexOutOfBoundsException(pos);\n+\n+      if (pos < count)\n+        return ((int) buf[pos++]) & 0xFFFF;\n+      return -1;\n+    }\n+  }\n+\n+  public int read(char[] b, int off, int len) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      /* Don't need to check pos value, arraycopy will check it. */\n+      if (off < 0 || len < 0 || off + len > b.length)\n+        throw new ArrayIndexOutOfBoundsException();\n+\n+      if (pos >= count)\n+        return -1;\n+\n+      int numChars = Math.min(count - pos, len);\n+      System.arraycopy(buf, pos, b, off, numChars);\n+      pos += numChars;\n+      return numChars;\n+    }\n+  }\n+\n+  public boolean ready() throws IOException\n+  {\n+    if (buf == null)\n+      throw new IOException();\n+\n+    return true;\n+  }\n+\n+  public void reset() throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      pos = markedPos;\n+    }\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      // Even though the var numChars is a long, in reality it can never\n+      // be larger than an int since the result of subtracting 2 positive\n+      // ints will always fit in an int.  Since we have to return a long\n+      // anyway, numChars might as well just be a long.\n+      long numChars = Math.min((long) (count - pos), n < 0 ? 0L : n);\n+      pos += numChars;\n+      return numChars;\n+    }\n+  }\n+}"}, {"sha": "3e1e4a4f78e3dfb6e91dafe00c30d1e12ff28f01", "filename": "libjava/java/io/CharArrayWriter.java", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FCharArrayWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FCharArrayWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FCharArrayWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,122 @@\n+// CharArrayWriter.java - Character array output stream.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class CharArrayWriter extends Writer\n+{\n+  public CharArrayWriter ()\n+  {\n+    this (32);\n+  }\n+\n+  public CharArrayWriter (int size)\n+  {\n+    super ();\n+    buf = new char[size];\n+  }\n+\n+  public void close ()\n+  {\n+    // JCL says this does nothing.  This seems to violate the Writer\n+    // contract, in that other methods should still throw and\n+    // IOException after a close.  Still, we just follow JCL.\n+  }\n+\n+  public void flush ()\n+  {\n+  }\n+\n+  public synchronized void reset ()\n+  {\n+    count = 0;\n+  }\n+\n+  public int size ()\n+  {\n+    return count;\n+  }\n+\n+  public char[] toCharArray ()\n+  {\n+    char[] nc = new char[count];\n+    System.arraycopy(buf, 0, nc, 0, count);\n+    return nc;\n+  }\n+\n+  public String toString ()\n+  {\n+    return new String (buf, 0, count);\n+  }\n+\n+  public void write (int oneChar)\n+  {\n+    synchronized (lock)\n+      {\n+\tresize (1);\n+\tbuf[count++] = (char) oneChar;\n+      }\n+  }\n+\n+  public void write (char[] buffer, int offset, int len)\n+  {\n+    synchronized (lock)\n+      {\n+\tif (len >= 0)\n+\t  resize (len);\n+\tSystem.arraycopy(buffer, offset, buf, count, len);\n+\tcount += len;\n+      }\n+  }\n+\n+  public void write (String str, int offset, int len)\n+  {\n+    synchronized (lock)\n+      {\n+\tif (len >= 0)\n+\t  resize (len);\n+\tstr.getChars(offset, offset + len, buf, count);\n+\tcount += len;\n+      }\n+  }\n+\n+  public void writeTo (Writer out) throws IOException\n+  {\n+    out.write(buf, 0, count);\n+  }\n+\n+  private final void resize (int len)\n+  {\n+    if (count + len >= buf.length)\n+      {\n+\tint newlen = buf.length * 2;\n+\tif (count + len > newlen)\n+\t  newlen = count + len;\n+\tchar[] newbuf = new char[newlen];\n+\tSystem.arraycopy(buf, 0, newbuf, 0, count);\n+\tbuf = newbuf;\n+      }\n+  }\n+\n+  // The character buffer.\n+  protected char[] buf;\n+  // Number of valid characters in buffer.\n+  protected int count;\n+}"}, {"sha": "039578e4c52dfd4f7a538995504d7c712f2a6d43", "filename": "libjava/java/io/CharConversionException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FCharConversionException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FCharConversionException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FCharConversionException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// CharConversionException.java - Problem converting char to byte encoding.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class CharConversionException extends IOException\n+{\n+  public CharConversionException ()\n+  {\n+    super ();\n+  }\n+\n+  public CharConversionException (String s)\n+  {\n+    super (s);\n+  }\n+}"}, {"sha": "2c6f988cc796544c8510f4d030dce7f68be1b43a", "filename": "libjava/java/io/DataInput.java", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataInput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataInput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInput.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 2, 1998.  \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public interface DataInput\n+{\n+  public boolean readBoolean() throws IOException;\n+  public byte readByte() throws IOException;\n+  public char readChar() throws IOException;\n+  public double readDouble() throws IOException;\n+  public float readFloat() throws IOException;\n+  public void readFully(byte[] b)\n+    throws IOException, NullPointerException;\n+  public void readFully(byte[] b, int off, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException;\n+  public int readInt() throws IOException;\n+  public String readLine() throws IOException;\n+  public long readLong() throws IOException;\n+  public short readShort() throws IOException;\n+  public int readUnsignedByte() throws IOException;\n+  public int readUnsignedShort() throws IOException;\n+  public String readUTF() throws IOException;\n+  public int skipBytes(int n) throws IOException;\n+}"}, {"sha": "7c90008c6e08e05ca7499d6e9935c42faf9d2449", "filename": "libjava/java/io/DataInputStream.java", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,249 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 20, 1998.  \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class DataInputStream extends FilterInputStream implements DataInput\n+{\n+  public DataInputStream(InputStream in)\n+  {\n+    super(in);\n+  }\n+\n+  public final int read(byte[] b) throws IOException\n+  {\n+    return super.read(b, 0, b.length);\n+  }\n+\n+  public final int read(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    return super.read(b, off, len);\n+  }\n+\n+  public final boolean readBoolean() throws IOException\n+  {\n+    return (readByte() != 0);\n+  }\n+\n+  public final byte readByte() throws IOException\n+  {\n+    int i = read();\n+    if (i < 0)\n+      throw new EOFException();\n+\n+    return (byte) i;\n+  }\n+\n+  public final char readChar() throws IOException\n+  {\n+    return (char) ((readByte() << 8) | readUnsignedByte());\n+  }\n+\n+  public final double readDouble() throws IOException\n+  {\n+    return Double.longBitsToDouble(readLong());\n+  }\n+\n+  public final float readFloat() throws IOException\n+  {\n+    return Float.intBitsToFloat(readInt());\n+  }\n+\n+  public final void readFully(byte[] b) throws IOException\n+  {\n+    readFully(b, 0, b.length);\n+  }\n+\n+  public final void readFully(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    while (len > 0)\n+      {\n+\t// super.read will block until some data is available.\n+\tint numread = super.read(b, off, len);\n+\tif (numread < 0)\n+\t  throw new EOFException();\n+\tlen -= numread;\n+\toff += numread;\n+      }\n+  }\n+\n+  public final int readInt() throws IOException\n+  {\n+    int retval = 0;\n+    for (int i = 0; i < 4; i++)\n+      retval |= readUnsignedByte() << (24 - i * 8);\n+\n+    return retval;\n+  }\n+\n+  // Deprecated as of JDK 1.1\n+  public final String readLine() throws IOException\n+  {\n+    StringBuffer strb = new StringBuffer();\n+\n+    while (true)\n+      {\n+\tchar ch = (char) read();\n+\tif (ch < 0 || (ch &= 0xFF) == '\\n')\n+\t  break;\n+\tif (ch == '\\r')\n+\t  {\n+\t    // FIXME: The following code tries to adjust the stream back one\n+\t    // character if the next char read is '\\n'.  As a last resort,\n+\t    // it tries to mark the position before reading but the bottom\n+\t    // line is that it is possible that this method will not properly\n+\t    // deal with a '\\r' '\\n' combination thus not fulfilling the\n+\t    // DataInput contract for readLine.  It's not a particularly\n+\t    // safe approach threadwise since it is unsynchronized and\n+\t    // since it might mark an input stream behind the users back.\n+\t    // Along the same vein it could try the same thing for\n+\t    // ByteArrayInputStream and PushbackInputStream, but that is\n+\t    // probably overkill since this is deprecated & BufferedInputStream\n+\t    // is the most likely type of input stream.\n+\t    //\n+\t    // The alternative is to somehow push back the next byte if it\n+\t    // isn't a '\\n' or to have the reading methods of this class\n+\t    // keep track of whether the last byte read was '\\r' by readLine\n+\t    // and then skip the very next byte if it is '\\n'.  Either way,\n+\t    // this would increase the complexity of the non-deprecated methods\n+\t    // and since it is undesirable to make non-deprecated methods\n+\t    // less efficient, the following seems like the most reasonable\n+\t    // approach.\n+\t    if (in instanceof BufferedInputStream && (read() & 0xFF) != '\\n')\n+\t      {\n+\t        BufferedInputStream bin = (BufferedInputStream) in;\n+\t\tif (bin.pos > 0)\n+                  bin.pos--;\n+\t      }\n+\t    else if (markSupported())\n+\t      {\n+\t\tmark(1);\n+\t\tif ((read() & 0xFF) != '\\n')\n+\t\t  reset();\n+\t      }\n+\t    break;\n+\t  }\n+\tstrb.append(ch);\n+      }\n+\n+    return strb.length() > 0 ? strb.toString() : null;\n+  }\n+\n+  public final long readLong() throws IOException\n+  {\n+    long retval = 0L;\n+    for (int i = 0; i < 8; i++)\n+      retval |= (long) readUnsignedByte() << (56 - i * 8);\n+\n+    return retval;\n+  }\n+\n+  public final short readShort() throws IOException\n+  {\n+    return (short) ((readByte() << 8) | readUnsignedByte());\n+  }\n+\n+  public final int readUnsignedByte() throws IOException\n+  {\n+    int i = read();\n+    if (i < 0)\n+      throw new EOFException();\n+\n+    return (i & 0xFF);\n+  }\n+\n+  public final int readUnsignedShort() throws IOException\n+  {\n+    return (readUnsignedByte() << 8) | readUnsignedByte();\n+  }\n+\n+  public final String readUTF() throws IOException\n+  {\n+    return readUTF(this);\n+  }\n+\n+  public final static String readUTF(DataInput in) throws IOException\n+  {\n+    final int UTFlen = in.readUnsignedShort();\n+    byte[] buf = new byte[UTFlen];\n+    StringBuffer strbuf = new StringBuffer();\n+\n+    // This blocks until the entire string is available rather than\n+    // doing partial processing on the bytes that are available and then\n+    // blocking.  An advantage of the latter is that Exceptions\n+    // could be thrown earlier.  The former is a bit cleaner.\n+    in.readFully(buf, 0, UTFlen);\n+    for (int i = 0; i < UTFlen; )\n+      {\n+\tif ((buf[i] & 0x80) == 0)\t\t// bit pattern 0xxxxxxx\n+\t  strbuf.append((char) (buf[i++] & 0xFF));\n+\telse if ((buf[i] & 0xE0) == 0xC0)\t// bit pattern 110xxxxx\n+\t  {\n+\t    if (i + 1 >= UTFlen || (buf[i+1] & 0xC0) != 0x80)\n+\t      throw new UTFDataFormatException();\n+\n+\t    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |\n+\t\t\t\t  (buf[i++] & 0x3F)));\n+\t  }\n+\telse if ((buf[i] & 0xF0) == 0xE0)\t// bit pattern 1110xxxx\n+\t  {\n+\t    if (i + 2 >= UTFlen ||\n+\t\t(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)\n+\t      throw new UTFDataFormatException();\n+\n+\t    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |\n+\t\t\t\t  ((buf[i++] & 0x3F) << 6) |\n+\t\t\t\t  (buf[i++] & 0x3F)));\n+\t  }\n+\telse // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)\n+\t  throw new UTFDataFormatException();\t// bit patterns 1111xxxx or\n+\t\t\t\t\t\t// \t\t10xxxxxx\n+      }\n+\n+    return strbuf.toString();\n+  }\n+\n+  public final int skipBytes(int n) throws IOException\n+  {\n+    // The contract in the Java Lang. Spec. says that this never\n+    // throws an EOFException and infers that it doesn't block (since\n+    // it may skip less than the requested number of bytes).\n+    // BUT, the JCL book specifically says that this method blocks\n+    // and can throw an EOFException.  Finally, the Java 1.2 online\n+    // doc simply refers to the general contract.  As such, we will\n+    // stick to the contract and assume for now that the JCL book\n+    // is incorrect.\n+\n+    // Since we're only skipping at most an int number of bytes, the cast\n+    // of return value to an int is fine.\n+    if (n > 0)\n+      {\n+\tn = Math.min(n, available());\n+        return (int) super.skip((long) n);\n+      }\n+\n+    return 0;\n+  }\n+}"}, {"sha": "c3fd366c5618afe4cfe9d2db3ee2d7f67c59b603", "filename": "libjava/java/io/DataOutput.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataOutput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataOutput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataOutput.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,44 @@\n+// DataOutput.java - Interface for data output conversions.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */ \n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public interface DataOutput\n+{\n+  public abstract void write (int b) throws IOException;\n+  public abstract void write (byte[] b)\n+    throws IOException, NullPointerException;\n+  public abstract void write (byte[] b, int off, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException;\n+  public abstract void writeBoolean (boolean v) throws IOException;\n+  public abstract void writeByte (int v) throws IOException;\n+  public abstract void writeShort (int v) throws IOException;\n+  public abstract void writeChar (int v) throws IOException;\n+  public abstract void writeInt (int v) throws IOException;\n+  public abstract void writeLong (long v) throws IOException;\n+  public abstract void writeFloat (float v) throws IOException;\n+  public abstract void writeDouble (double v) throws IOException;\n+  public abstract void writeBytes (String s)\n+    throws IOException, NullPointerException;\n+  public abstract void writeChars (String s)\n+    throws IOException, NullPointerException;\n+  public abstract void writeUTF (String s)\n+    throws IOException, NullPointerException;\n+}"}, {"sha": "2ef4cf088851f538ae15286fc89f3ec7aba906cd", "filename": "libjava/java/io/DataOutputStream.java", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FDataOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataOutputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,165 @@\n+// DataOutputStream.java - Output filter that implements DataOutput\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public class DataOutputStream extends FilterOutputStream implements DataOutput\n+{\n+  public DataOutputStream (OutputStream out)\n+  {\n+    super (out);\n+    written = 0;\n+  }\n+\n+  public void flush () throws IOException\n+  {\n+    out.flush();\n+  }\n+\n+  public final int size ()\n+  {\n+    return written;\n+  }\n+\n+  public synchronized void write (int b) throws IOException\n+  {\n+    out.write(b);\n+    ++written;\n+  }\n+\n+  public synchronized void write (byte[] b, int off, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException\n+  {\n+    out.write(b, off, len);\n+    written += len - off;\n+  }\n+\n+  public final void writeBoolean (boolean v) throws IOException\n+  {\n+    write (v ? 1 : 0);\n+  }\n+\n+  public final void writeByte (int v) throws IOException\n+  {\n+    write (v & 0xff);\n+  }\n+\n+  public final void writeShort (int v) throws IOException\n+  {\n+    write ((byte) (0xff & (v >> 8)));\n+    write ((byte) (0xff & v));\n+  }\n+\n+  public final void writeChar (int v) throws IOException\n+  {\n+    write ((byte) (0xff & (v >> 8)));\n+    write ((byte) (0xff & v));\n+  }\n+\n+  public final void writeInt (int v) throws IOException\n+  {\n+    write ((byte) (0xff & (v >> 24)));\n+    write ((byte) (0xff & (v >> 16)));\n+    write ((byte) (0xff & (v >>  8)));\n+    write ((byte) (0xff & v));\n+  }\n+\n+  public final void writeLong (long v) throws IOException\n+  {\n+    write ((byte) (0xff & (v >> 56)));\n+    write ((byte) (0xff & (v >> 48)));\n+    write ((byte) (0xff & (v >> 40)));\n+    write ((byte) (0xff & (v >> 32)));\n+    write ((byte) (0xff & (v >> 24)));\n+    write ((byte) (0xff & (v >> 16)));\n+    write ((byte) (0xff & (v >>  8)));\n+    write ((byte) (0xff & v));\n+  }\n+\n+  public final void writeFloat (float v) throws IOException\n+  {\n+    writeInt (Float.floatToIntBits(v));\n+  }\n+\n+  public final void writeDouble (double v) throws IOException\n+  {\n+    writeLong (Double.doubleToLongBits(v));\n+  }\n+\n+  public final void writeBytes (String s) throws IOException\n+  {\n+    int len = s.length();\n+    for (int i = 0; i < len; ++i)\n+      writeByte (s.charAt(i));\n+  }\n+\n+  public final void writeChars (String s) throws IOException\n+  {\n+    int len = s.length();\n+    for (int i = 0; i < len; ++i)\n+      writeChar (s.charAt(i));\n+  }\n+\n+  public final void writeUTF (String s) throws IOException\n+  {\n+    int len = s.length();\n+    int sum = 0;\n+\n+    for (int i = 0; i < len && sum <= 65535; ++i)\n+      {\n+\tchar c = s.charAt(i);\n+\tif (c >= '\\u0001' && c <= '\\u007f')\n+\t  sum += 1;\n+\telse if (c == '\\u0000' || (c >= '\\u0080' && c <= '\\u07ff'))\n+\t  sum += 2;\n+\telse\n+\t  sum += 3;\n+      }\n+\n+    if (sum > 65535)\n+      throw new UTFDataFormatException ();\n+\n+    writeShort (sum);\n+\n+    for (int i = 0; i < len; ++i)\n+      {\n+\tchar c = s.charAt(i);\n+\tif (c >= '\\u0001' && c <= '\\u007f')\n+\t  write (c);\n+\telse if (c == '\\u0000' || (c >= '\\u0080' && c <= '\\u07ff'))\n+\t  {\n+\t    write (0xc0 | (0x1f & (c >> 6)));\n+\t    write (0x80 | (0x3f & c));\n+\t  }\n+\telse\n+\t  {\n+\t    // JSL says the first byte should be or'd with 0xc0, but\n+\t    // that is a typo.  Unicode says 0xe0, and that is what is\n+\t    // consistent with DataInputStream.\n+\t    write (0xe0 | (0x0f & (c >> 12)));\n+\t    write (0x80 | (0x3f & (c >> 6)));\n+\t    write (0x80 | (0x3f & c));\n+\t  }\n+      }\n+  }\n+\n+  // Number of bytes written so far.\n+  protected int written;\n+}"}, {"sha": "d890a0f79a7b6df68e87640432470cab19d6a04f", "filename": "libjava/java/io/EOFException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FEOFException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FEOFException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FEOFException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// EOFException.java - End of file exception\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class EOFException extends IOException\n+{\n+  public EOFException ()\n+  {\n+    super ();\n+  }\n+\n+  public EOFException (String s)\n+  {\n+    super (s);\n+  }\n+}"}, {"sha": "30d98878f9cc817f35e435ddf7c90a7e343ef2aa", "filename": "libjava/java/io/File.java", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,288 @@\n+// File.java - File name\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1; 1.2 functionality missing.\n+ * A known bug: most calls to the security manager can generate\n+ * IOException since we use the canonical path.\n+ */\n+\n+public class File implements Serializable\n+{\n+  public boolean canRead ()\n+  {\n+    return access (checkRead (), READ);\n+  }\n+\n+  public boolean canWrite ()\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    String p = safeCanonicalPath ();\n+    // FIXME: it isn't entirely clear what to do if we can't find the\n+    // canonical path.\n+    if (p == null)\n+      return false;\n+    if (s != null)\n+      s.checkWrite(p);\n+    return access (p, WRITE);\n+  }\n+\n+  private final native boolean performDelete (String canon);\n+  public boolean delete ()\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    String p = safeCanonicalPath ();\n+    // FIXME: what is right?\n+    if (p == null)\n+      return false;\n+    if (s != null)\n+      s.checkDelete(p);\n+    return performDelete (p);\n+  }\n+\n+  public boolean equals (Object obj)\n+  {\n+    if (! (obj instanceof File))\n+      return false;\n+    File other = (File) obj;\n+    return path.compareTo(other.path) == 0;\n+  }\n+\n+  public boolean exists ()\n+  {\n+    return access (checkRead (), EXISTS);\n+  }\n+\n+  public File (String p)\n+  {\n+    if (p == null)\n+      throw new NullPointerException ();\n+    path = p;\n+  }\n+\n+  public File (String dirPath, String name)\n+  {\n+    if (name == null)\n+      throw new NullPointerException ();\n+    if (dirPath != null)\n+      {\n+\t// Try to be smart about the number of separator characters.\n+\tif (dirPath.charAt(dirPath.length() - 1) == separatorChar)\n+\t  path = dirPath + name;\n+\telse\n+\t  path = dirPath + separatorChar + name;\n+      }\n+    else\n+      path = name;\n+  }\n+\n+  public File (File dir, String name)\n+  {\n+    this (dir == null ? null : dir.path, name);\n+  }\n+\n+  public String getAbsolutePath ()\n+  {\n+    if (isAbsolute ())\n+      return path;\n+    return System.getProperty(\"user.dir\") + separatorChar + path;\n+  }\n+\n+  public native String getCanonicalPath () throws IOException;\n+\n+  public String getName ()\n+  {\n+    int last = path.lastIndexOf(separatorChar);\n+    if (last == -1)\n+      last = 0;\n+    return path.substring(last);\n+  }\n+\n+  public String getParent ()\n+  {\n+    int last = path.lastIndexOf(separatorChar);\n+    if (last == -1)\n+      return null;\n+    return path.substring(0, last);\n+  }\n+\n+  public String getPath ()\n+  {\n+    return path;\n+  }\n+\n+  public int hashCode ()\n+  {\n+    // FIXME: test.\n+    return path.hashCode();\n+  }\n+\n+  public native boolean isAbsolute ();\n+\n+  public boolean isDirectory ()\n+  {\n+    return stat (checkRead (), DIRECTORY);\n+  }\n+\n+  public boolean isFile ()\n+  {\n+    return stat (checkRead (), ISFILE);\n+  }\n+\n+  public long lastModified ()\n+  {\n+    return attr (checkRead (), MODIFIED);\n+  }\n+\n+  public long length ()\n+  {\n+    return attr (checkRead (), LENGTH);\n+  }\n+\n+  private final native String[] performList (String canon,\n+\t\t\t\t\t     FilenameFilter filter);\n+  public String[] list (FilenameFilter filter)\n+  {\n+    return performList (checkRead (), filter);\n+  }\n+\n+  public String[] list ()\n+  {\n+    return performList (checkRead (), null);\n+  }\n+\n+  public String toString ()\n+  {\n+    return path;\n+  }\n+\n+  private final native boolean performMkdir ();\n+  public boolean mkdir ()\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      {\n+\t// NOTE: in theory we should use the canonical path.  In\n+\t// practice, we can't compute the canonical path until we've\n+\t// made this completely.  Lame.\n+\ts.checkWrite(path);\n+      }\n+    return performMkdir ();\n+  }\n+\n+  private static boolean mkdirs (File x)\n+  {\n+    if (x.isDirectory())\n+      return true;\n+    String p = x.getPath();\n+    x.setPath(x.getParent());\n+    if (! mkdirs (x))\n+      return false;\n+    x.setPath(p);\n+    return x.mkdir();\n+  }\n+\n+  public boolean mkdirs ()\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      {\n+\t// NOTE: in theory we should use the canonical path.  In\n+\t// practice, we can't compute the canonical path until we've\n+\t// made this completely.  Lame.\n+\ts.checkWrite(path);\n+      }\n+\n+    if (isDirectory ())\n+      return false;\n+    return mkdirs (new File (path));\n+  }\n+\n+  private final native boolean performRenameTo (File dest);\n+  public boolean renameTo (File dest)\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      {\n+\t// FIXME: JCL doesn't specify which path to check.  We check the\n+\t// source since we can canonicalize it.\n+\ts.checkWrite(safeCanonicalPath());\n+      }\n+    return performRenameTo (dest);\n+  }\n+\n+  public static final String pathSeparator\n+    = System.getProperty(\"path.separator\");\n+  public static final char pathSeparatorChar = pathSeparator.charAt(0);\n+  public static final String separator = System.getProperty(\"file.separator\");\n+  public static final char separatorChar = separator.charAt(0);\n+\n+\n+  // The path.\n+  private String path;\n+\n+  // mkdirs() uses this to avoid repeated allocations.\n+  private final void setPath (String n)\n+  {\n+    path = n;\n+  }\n+\n+\n+  private final String checkRead ()\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    String p = safeCanonicalPath ();\n+    if (p == null)\n+      return null;\n+    if (s != null)\n+      s.checkRead(p);\n+    return p;\n+  }\n+\n+  // Return canonical path, or null.\n+  private final String safeCanonicalPath ()\n+  {\n+    String p = null;\n+    try\n+      {\n+\tp = getCanonicalPath ();\n+      }\n+    catch (IOException x)\n+      {\n+\t// Nothing.\n+      }\n+    return p;\n+  }\n+\n+  // QUERY arguments to access function.\n+  private final static int READ = 0;\n+  private final static int WRITE = 1;\n+  private final static int EXISTS = 2;\n+\n+  // QUERY arguments to stat function.\n+  private final static int DIRECTORY = 0;\n+  private final static int ISFILE = 1;\n+\n+  // QUERY arguments to attr function.\n+  private final static int MODIFIED = 0;\n+  private final static int LENGTH = 1;\n+\n+  private final native long attr (String p, int query);\n+  private final native boolean access (String p, int query);\n+  private final native boolean stat (String p, int query);\n+}"}, {"sha": "0782b0c8e958b2254ff1922810527c0d3de8199d", "filename": "libjava/java/io/FileDescriptor.java", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileDescriptor.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,87 @@\n+// FileDescriptor.java - Open file or device\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1\n+ */\n+\n+// For now we assume a POSIXy file system.  This can be changed later\n+// if need be.\n+public final class FileDescriptor\n+{\n+  public static final FileDescriptor in = new FileDescriptor (0);\n+  public static final FileDescriptor out = new FileDescriptor (1);\n+  public static final FileDescriptor err = new FileDescriptor (2);\n+\n+  public native void sync () throws SyncFailedException;\n+  public native boolean valid ();\n+\n+\n+  // These are mode values for open().\n+  static final int READ   = 1;\n+  static final int WRITE  = 2;\n+  static final int APPEND = 4;\n+\n+  // These are WHENCE values for seek.\n+  static final int SET = 0;\n+  static final int CUR = 1;\n+\n+  // Open a file.  MODE is a combination of the above mode flags.\n+  FileDescriptor (String path, int mode) throws IOException\n+  {\n+    fd = open (path, mode);\n+  }\n+\n+  public FileDescriptor ()\n+  {\n+    fd = -1;\n+  }\n+\n+  native int open (String path, int mode) throws IOException;\n+  native void write (int b) throws IOException;\n+  native void write (byte[] b, int offset, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException;\n+  native void close () throws IOException;\n+  native int seek (long pos, int whence) throws IOException;\n+  native long length () throws IOException;\n+  native long getFilePointer () throws IOException;\n+  native int read () throws IOException;\n+  native int read (byte[] bytes, int offset, int len) throws IOException;\n+  native int available () throws IOException;\n+\n+\n+  // When collected, close.\n+  protected void finalize () throws IOException\n+  {\n+    if (valid ())\n+      close ();\n+  }\n+\n+  // Attach to an already-opened file.  This is not private because we\n+  // need access to it from other packages, for instance java.net.\n+  // Ordinarily that wouldn't work, either, but in our case we know\n+  // the access comes from C++, where \"package private\" is translated\n+  // into \"public\".  Eww.\n+  FileDescriptor (int desc)\n+  {\n+    fd = desc;\n+  }\n+\n+  // System's notion of file descriptor.\n+  private int fd;\n+}"}, {"sha": "4f44dae03b7cf06a4fcc9bcf0e825873ba77b6a7", "filename": "libjava/java/io/FileInputStream.java", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,96 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 28, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class FileInputStream extends InputStream\n+{\n+  /* Contains the file descriptor for referencing the actual file. */\n+  private FileDescriptor fd;\n+\n+  public FileInputStream(String name) throws FileNotFoundException, IOException\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkRead(name);\n+    fd = new FileDescriptor(name, FileDescriptor.READ);\n+  }\n+\n+  public FileInputStream(File file) throws FileNotFoundException, IOException\n+  {\n+    this(file.getPath());\n+  }\n+\n+  public FileInputStream(FileDescriptor fdObj)\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkRead(fdObj);\n+    fd = fdObj;\n+  }\n+\n+  public int available() throws IOException\n+  {\n+    return fd.available();\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    if (fd == null)\n+      return;\n+\n+    fd.close();\n+    fd = null;\n+  }\n+\n+  protected void finalize() throws IOException\n+  {\n+    if (fd != null)\n+      fd.finalize();\n+  }\n+\n+  public final FileDescriptor getFD() throws IOException\n+  {\n+    if (!fd.valid())\n+      throw new IOException();\n+    return fd;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    return fd.read();\n+  }\n+\n+  public int read(byte[] b) throws IOException\n+  {\n+    return fd.read(b, 0, b.length);\n+  }\n+\n+  public int read(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    return fd.read(b, off, len);\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    return fd.seek(n, FileDescriptor.CUR);\n+  }\n+}"}, {"sha": "07ff9bf1d9b688eda17367e50f2fb13324702117", "filename": "libjava/java/io/FileNotFoundException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileNotFoundException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileNotFoundException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileNotFoundException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// FileNotFoundException.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class FileNotFoundException extends IOException\n+{\n+  public FileNotFoundException ()\n+  {\n+    super ();\n+  }\n+\n+  public FileNotFoundException (String s)\n+  {\n+    super (s);\n+  }\n+}"}, {"sha": "3e6e9724aec05cb50b38123beccad224acee396c", "filename": "libjava/java/io/FileOutputStream.java", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileOutputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,93 @@\n+// FileOutputStream.java - Write bytes to a file.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public class FileOutputStream extends OutputStream\n+{\n+  public FileOutputStream (String path, boolean append)\n+    throws SecurityException, IOException\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkWrite(path);\n+    fd = new FileDescriptor (path, (append\n+\t\t\t\t    ? FileDescriptor.APPEND\n+\t\t\t\t    : FileDescriptor.WRITE));\n+  }\n+\n+  public FileOutputStream (String path) throws SecurityException, IOException\n+  {\n+    this (path, false);\n+  }\n+\n+  public FileOutputStream (File file) throws SecurityException, IOException\n+  {\n+    this (file.getPath(), false);\n+  }\n+\n+  public FileOutputStream (FileDescriptor fdObj) throws SecurityException\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkWrite(fdObj);\n+    fd = fdObj;\n+  }\n+\n+  protected void finalize () throws IOException\n+  {\n+    // We don't actually need this, but we include it because it is\n+    // mentioned in the JCL.\n+  }\n+\n+  public final FileDescriptor getFD () throws IOException\n+  {\n+    if (! fd.valid())\n+      throw new IOException ();\n+    return fd;\n+  }\n+\n+  public void write (int b) throws IOException\n+  {\n+    fd.write (b);\n+  }\n+\n+  public void write (byte[] b) throws IOException, NullPointerException\n+  {\n+    fd.write (b, 0, b.length);\n+  }\n+\n+  public void write (byte[] b, int off, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException ();\n+    fd.write (b, off, len);\n+  }\n+\n+  public void close () throws IOException\n+  {\n+    if (fd.valid())\n+      fd.close();\n+  }\n+\n+  // Instance variables.\n+  private FileDescriptor fd;\n+}"}, {"sha": "259526cceff49dc48a9edfceb143f9ab3857a498", "filename": "libjava/java/io/FileReader.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,35 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 22, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class FileReader extends InputStreamReader\n+{\n+  public FileReader(String filename) throws IOException\n+  {\n+    super(new FileInputStream(filename));\n+  }\n+\n+  public FileReader(File file) throws IOException\n+  {\n+    super(new FileInputStream(file));\n+  }\n+\n+  public FileReader(FileDescriptor fd)\n+  {\n+    super(new FileInputStream(fd));\n+  }\n+}"}, {"sha": "8c3f9a9d303df33dd9cd42ef75f492a2e63bcd5c", "filename": "libjava/java/io/FileWriter.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFileWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,44 @@\n+// FileWriter.java - Character output to a file.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public class FileWriter extends OutputStreamWriter\n+{\n+  public FileWriter (String fileName) throws IOException\n+  {\n+    super (new FileOutputStream (fileName));\n+  }\n+\n+  public FileWriter (String fileName, boolean append) throws IOException\n+  {\n+    super (new FileOutputStream (fileName, append));\n+  }\n+\n+  public FileWriter (File file) throws IOException\n+  {\n+    super (new FileOutputStream (file));\n+  }\n+\n+  public FileWriter (FileDescriptor fd)\n+  {\n+    super (new FileOutputStream (fd));\n+  }\n+}"}, {"sha": "682efed6d8aa15f695df5050771328a8ce409cd1", "filename": "libjava/java/io/FilenameFilter.java", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilenameFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilenameFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilenameFilter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,26 @@\n+// FilenameFilter.java - Compute subset of list of file names\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public interface FilenameFilter\n+{\n+  public abstract boolean accept (File dir, String name);\n+}"}, {"sha": "918948b2eddb053e0f648ae624025255029c8ab1", "filename": "libjava/java/io/FilterInputStream.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,75 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 8, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class FilterInputStream extends InputStream\n+{\n+  /* The input stream to be filtered. */\n+  protected InputStream in;\n+\n+  protected FilterInputStream(InputStream in)\n+  {\n+    this.in = in; \n+  }\n+\n+  public int available() throws IOException\n+  {\n+    return in.available();\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    in.close();\n+  }\n+\n+  public synchronized void mark(int readlimit)\n+  {\n+    in.mark(readlimit);\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return in.markSupported();\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    return in.read();\n+  }\n+\n+  public int read(byte[] b) throws IOException\n+  {\n+    return read(b, 0, b.length);\n+  }\n+\n+  public int read(byte[] b, int off, int len) throws IOException\n+  {\n+    return in.read(b, off, len);\n+  }\n+\n+  public synchronized void reset() throws IOException\n+  {\n+    in.reset();\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    return in.skip(n);\n+  }\n+}"}, {"sha": "45d6fd024ade6bcc0c30ac571df0672c7305c52c", "filename": "libjava/java/io/FilterOutputStream.java", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterOutputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,61 @@\n+// FilterOutputStream.java - A filtered stream\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public class FilterOutputStream extends OutputStream\n+{\n+  public void close () throws IOException\n+  {\n+    flush ();\n+    out.close();\n+  }\n+\n+  public FilterOutputStream (OutputStream ox)\n+  {\n+    out = ox;\n+  }\n+\n+  public void flush () throws IOException\n+  {\n+    out.flush();\n+  }\n+\n+  public void write (int b) throws IOException\n+  {\n+    out.write(b);\n+  }\n+\n+  public void write (byte[] b) throws IOException, NullPointerException\n+  {\n+    // Don't do checking here, per Java Lang Spec.\n+    out.write (b);\n+  }\n+\n+  public void write (byte[] b, int off, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException\n+  {\n+    // Don't do checking here, per Java Lang Spec.\n+    out.write(b, off, len);\n+  }\n+\n+  // The output stream.\n+  protected OutputStream out;\n+}"}, {"sha": "1fe201472b4a09b5b5f532475b533e038ab62a11", "filename": "libjava/java/io/FilterReader.java", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 15, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public abstract class FilterReader extends Reader\n+{\n+  /* The input stream to be filtered. */\n+  protected Reader in;\n+\n+  protected FilterReader(Reader in)\n+  {\n+    super(in.lock);\n+    this.in = in; \n+  }\n+\n+  public void close() throws IOException\n+  {\n+    in.close();\n+    in = null;\n+  }\n+\n+  public synchronized void mark(int readlimit) throws IOException\n+  {\n+    in.mark(readlimit);\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return in.markSupported();\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    return in.read();\n+  }\n+\n+  public int read(char[] b, int off, int len) throws IOException\n+  {\n+    return in.read(b, off, len);\n+  }\n+\n+  public boolean ready() throws IOException\n+  {\n+    return in.ready();\n+  }\n+\n+  public synchronized void reset() throws IOException\n+  {\n+    in.reset();\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    return in.skip(n);\n+  }\n+}"}, {"sha": "385cc7eee30113c440cf98fa462f1a2accbd2d5b", "filename": "libjava/java/io/FilterWriter.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FFilterWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,59 @@\n+// FilterWriter.java - Filtered character output stream.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public abstract class FilterWriter extends Writer\n+{\n+  public void close () throws IOException\n+  {\n+    out.close();\n+  }\n+\n+  protected FilterWriter (Writer ox)\n+  {\n+    // FIXME: should we really share locks like this?\n+    super (ox);\n+    out = ox;\n+  }\n+\n+  public void flush () throws IOException\n+  {\n+    out.flush();\n+  }\n+\n+  public void write (int oneChar) throws IOException\n+  {\n+    out.write(oneChar);\n+  }\n+\n+  public void write (char[] buffer, int offset, int count) throws IOException\n+  {\n+    out.write(buffer, offset, count);\n+  }\n+\n+  public void write (String str, int offset, int count) throws IOException\n+  {\n+    out.write(str, offset, count);\n+  }\n+\n+  // Where our writes should go.\n+  protected Writer out;\n+}"}, {"sha": "15a14ff15fa5fb7c3da5650c7964cf8b152d349e", "filename": "libjava/java/io/IOException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FIOException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FIOException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FIOException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// IOException.java - Base class for I/O Exceptions\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class IOException extends Exception\n+{\n+  public IOException ()\n+  {\n+    super ();\n+  }\n+\n+  public IOException (String s)\n+  {\n+    super (s);\n+  }\n+}"}, {"sha": "cc86efd49d6ecfcfca1d0cbbf1c068787b575574", "filename": "libjava/java/io/InputStream.java", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,104 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 2, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public abstract class InputStream\n+{\n+  public InputStream()\n+  {\n+  }\n+\n+  public int available() throws IOException\n+  {\n+    return 0;\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    // Do nothing\n+  }\n+\n+  public void mark(int readlimit)\n+  {\n+    // Do nothing\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return false;\n+  }\n+\n+  public abstract int read() throws IOException;\n+\n+  public int read(byte[] b) throws IOException\n+  {\n+    return read(b, 0, b.length);\n+  }\n+\n+  public int read(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new IndexOutOfBoundsException();\n+    if (b.length == 0)\n+      return 0;\n+\n+    int i, ch;\n+\n+    for (i = 0; i < len; ++i)\n+      try\n+      {\n+        if ((ch = read()) < 0)\n+\t  return i == 0 ? -1 : i;\t\t// EOF\n+        b[off + i] = (byte) ch;\n+      }\n+      catch (IOException ex)\n+      {\n+        // Only reading the first byte should cause an IOException.\n+\tif (i == 0)\n+\t  throw ex;\n+\treturn i;\n+      }\n+\n+    return i;\n+  }\n+\n+  public void reset() throws IOException\n+  {\n+    throw new IOException(\"mark/reset not supported\");\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    // Throw away n bytes by reading them into a temp byte[].\n+    // Limit the temp array to 2Kb so we don't grab too much memory.\n+    final int buflen = n > 2048 ? 2048 : (int) n;\n+    byte[] tmpbuf = new byte[buflen];\n+    final long origN = n;\n+\n+    while (n > 0L)\n+      {\n+\tint numread = read(tmpbuf, 0, n > buflen ? buflen : (int) n);\n+\tif (numread <= 0)\n+\t  break;\n+\tn -= numread;\n+      }\n+\n+    return origN - n;\n+  }\n+}"}, {"sha": "ee44f9181229119a9c39f2bad61e9eeae6fe4676", "filename": "libjava/java/io/InputStreamReader.java", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FInputStreamReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FInputStreamReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStreamReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,151 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+import gnu.gcj.convert.*;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 22, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct, but only supports 8859_1.\n+ */\n+\n+public class InputStreamReader extends Reader\n+{\n+  BufferedInputStream in;\n+\n+  // Buffer of chars read from in and converted but not consumed.\n+  char[] work;\n+  // Next available character (in work buffer) to read.\n+  int wpos;\n+  // Last available character (in work buffer) to read.\n+  int wcount;\n+\n+  BytesToUnicode converter;\n+\n+  public InputStreamReader(InputStream in)\n+  {\n+    this(in, BytesToUnicode.getDefaultDecoder());\n+  }\n+\n+  public InputStreamReader(InputStream in, String enc)\n+    throws UnsupportedEncodingException\n+  {\n+    this(in, BytesToUnicode.getDecoder(enc));\n+  }\n+\n+  private InputStreamReader(InputStream in, BytesToUnicode decoder)\n+  {\n+    super(in);\n+    this.in = in instanceof BufferedInputStream  ? (BufferedInputStream) in\n+      : new BufferedInputStream(in, 250);\n+    converter = decoder;\n+    converter.setInput(this.in.buf, 0, 0);\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (in != null)\n+\t  in.close();\n+\tin = null;\n+\twork = null;\n+\twpos = wcount = 0;\n+      }\n+  }\n+\n+  public String getEncoding() { return converter.getName(); }\n+\n+  public boolean ready() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (wpos < wcount)\n+\t  return true;\n+\tif (work == null)\n+\t  {\n+\t    work = new char[100];\n+\t    wpos = 0;\n+\t    wcount = 0;\n+\t  }\n+\tfor (;;)\n+\t  {\n+\t    if (in.available() <= 0)\n+\t      return false;\n+\t    in.mark(1);\n+\t    int b = in.read();\n+\t    if (b < 0)\n+\t      return true;\n+\t    in.reset();\n+\t    converter.setInput(in.buf, in.pos, in.count);\n+\t    wpos = 0;\n+\t    wcount = converter.read(work, 0, work.length);\n+\t    in.skip(converter.inpos - in.pos);\n+\t    if (wcount > 0)\n+\t      return true;\n+\t  }\n+      }\n+  }\n+\n+  public int read(char buf[], int offset, int length) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tint wavail = wcount - wpos;\n+\tif (wavail > 0)\n+\t  {\n+\t    if (length > wavail)\n+\t      length = wavail;\n+\t    System.arraycopy(work, wpos, buf, offset, length);\n+\t    wpos += length;\n+\t    return length;\n+\t  }\n+\telse\n+\t  {\n+\t    for (;;)\n+\t      {\n+\t\tin.mark(1);\n+\t\tint b = in.read();\n+\t\tif (b < 0)\n+\t\t  return -1;\n+\t\tin.reset();\n+\t\tconverter.setInput(in.buf, in.pos, in.count);\n+\t\tint count = converter.read (buf, offset, length);\n+\t\tin.skip(converter.inpos - in.pos);\n+\t\tif (count > 0)\n+\t\t  return count;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tint wavail = wcount - wpos;\n+\tif (wavail > 0)\n+\t  return work[wpos++];\n+\tif (work == null)\n+\t  {\n+\t    work = new char[100];\n+\t    wpos = 0;\n+\t    wcount = 0;\n+\t  }\n+\tint count = read(work, wpos, work.length-wpos);\n+\tif (count <= 0)\n+\t  return -1;\n+\twcount = wpos + count;\n+\treturn work[wpos++];\n+      }\n+  }\n+}"}, {"sha": "11d922b765e78b96038f0100bc328eabc926572a", "filename": "libjava/java/io/InterruptedIOException.java", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FInterruptedIOException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FInterruptedIOException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInterruptedIOException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,36 @@\n+// InterruptedIOException.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class InterruptedIOException extends IOException\n+{\n+  public InterruptedIOException ()\n+  {\n+    super ();\n+  }\n+\n+  public InterruptedIOException (String s)\n+  {\n+    super (s);\n+  }\n+\n+  public int bytesTransferred = 0;\n+}"}, {"sha": "1b96da9c84640be00e4ca83337fe68b56bf9bbba", "filename": "libjava/java/io/LineNumberInputStream.java", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FLineNumberInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FLineNumberInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FLineNumberInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,143 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date November 11, 1998.\n+ * @deprecated \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.  Deprecated in JDK 1.1.\n+ */\n+ \n+public class LineNumberInputStream extends FilterInputStream\n+{\n+  /* The current line number. */\n+  private int lineNumber = 0;\n+\n+  /* The line number when the stream was marked. */\n+  private int markLineNumber = 0;\n+\n+  /* Flag to indicate a '\\r' was just read so that an immediately subsequent\n+   * '\\n' can be ignored. */\n+  private boolean justReadReturnChar = false;\n+\n+  public LineNumberInputStream(InputStream in)\n+  {\n+    super(in);\n+  }\n+\n+  public int available() throws IOException\n+  {\n+    // We can only guarantee half the characters that might be available\n+    // without blocking because \"\\r\\n\" is treated as a single character.\n+    return in.available() / 2;\n+  }\n+\n+  public int getLineNumber()\n+  {\n+    return lineNumber;\n+  }\n+\n+  public void mark(int readlimit)\n+  {\n+    in.mark(readlimit);\n+    markLineNumber = lineNumber;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    // Treat \"\\r\\n\" as a single character.  A '\\r' may have been read by\n+    // a previous call to read so we keep an internal flag to avoid having\n+    // to read ahead.\n+\n+    int ch = in.read();\n+\n+    if (ch == '\\n')\n+      if (justReadReturnChar)\n+\t{\n+\t  ch = in.read();\n+          justReadReturnChar = false;\n+\t}\n+      else\n+\tlineNumber++;\n+    else if (ch == '\\r')\n+      {\n+\tch = '\\n';\n+\tjustReadReturnChar = true;\n+\tlineNumber++;\n+      }\n+    else\n+      justReadReturnChar = false;\n+\n+    return ch;\n+  }\n+\n+  public int read(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    // This case always succeeds.\n+    if (len == 0)\n+      return 0;\n+\n+    // The simplest, though not necessarily the most time efficient thing\n+    // to do is simply call read(void) len times.  Since this is a deprecated\n+    // class, that should be ok.\n+    final int origOff = off;\n+    while (len-- > 0)\n+      {\n+\tint ch = read();\n+\tif (ch < 0)\n+\t  break;\n+\n+\tb[off++] = (byte) ch;\n+      }\n+\n+    // This is safe since we already know that some bytes were\n+    // actually requested.\n+    return off == origOff ? -1 : off - origOff;\n+  }\n+\n+  public void reset() throws IOException\n+  {\n+    in.reset();\n+    lineNumber = markLineNumber;\n+    justReadReturnChar = false;\n+  }\n+\n+  public void setLineNumber(int lineNumber)\n+  {\n+    this.lineNumber = lineNumber;\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    if (n <= 0)\n+      return 0L;\n+\n+    final long origN = n;\n+\n+    do\n+      {\n+\tint ch = read();\n+\tif (ch < 0)\n+\t  break;\n+\tif (ch == '\\n' || ch == '\\r')\n+\t  lineNumber++;\n+      }\n+    while (--n > 0);\n+\n+    return origN - n;\n+  }\n+}"}, {"sha": "c709a7a0079d7b3d4ac2bf81dfafb241ee144a73", "filename": "libjava/java/io/LineNumberReader.java", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FLineNumberReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FLineNumberReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FLineNumberReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,245 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 22, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ *\n+ * This implementation has the feature that if '\\r' is read, it\n+ * does not look for a '\\n', but immediately returns '\\n'.\n+ * On the next read(), if a '\\n' is read, it is skipped.\n+ * This has the advantage that we do not read (and hang) unnecessarily.\n+ *\n+ * This implementation is also minimal in the number of fields it uses.\n+ */\n+\n+public class LineNumberReader extends BufferedReader\n+{\n+  /** The current line number. */\n+  int lineNumber;\n+\n+  public LineNumberReader(Reader in)\n+  {\n+    super(in, 8192);\n+  }\n+\n+  public LineNumberReader(Reader in, int size)\n+  {\n+    super(in, size);\n+  }\n+\n+  public int getLineNumber()\n+  {\n+    return lineNumber;\n+  }\n+\n+  public void setLineNumber(int lineNumber)\n+  {\n+    this.lineNumber = lineNumber;\n+  }\n+\n+  private static int countLines (char[] buffer, int off, int len)\n+  {\n+    int count = 0;\n+    char prev = '\\0';\n+    for (int i = 0;  i < len;  i++)\n+      {\n+        char ch = buffer[i+off];\n+        if ((ch == '\\n' && prev != '\\r') || ch == '\\r')\n+          count++;\n+        prev = ch;\n+      }\n+    return count;\n+  }\n+\n+  public void mark(int readLimit) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\t// This is basically the same as BufferedReader.mark.\n+\t// However, if the previous character was a '\\r', we need to\n+\t// save that 'r', in case the next character is a '\\n'.\n+\tif (pos + readLimit > limit)\n+\t  {\n+\t    int saveCR = (pos > 0 && buffer[pos-1] == '\\r') ? 1 : 0;\n+\t    char[] old_buffer = buffer;\n+\t    if (readLimit > limit)\n+\t      buffer = new char[saveCR + readLimit];\n+\t    int copy_start = pos - saveCR;\n+\t    limit -= copy_start;\n+\t    System.arraycopy(old_buffer, copy_start, buffer, 0, limit);\n+\t    pos = saveCR;\n+\t  }\n+\tmarkPos = pos;\n+      }\n+  }\n+\n+  public void reset() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (markPos < 0)\n+\t  throw new IOException(\"mark never set or invalidated\");\n+\tif (markPos > 0 && pos > markPos && buffer[markPos-1] == '\\r'\n+\t    && buffer[markPos] == '\\n')\n+\t  lineNumber--;\n+\tlineNumber -= countLines(buffer, pos, markPos);\n+\tpos = markPos;\n+      }\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tskipRedundantLF();\n+\tif (pos >= limit)\n+\t  {\n+\t    if (markPos >= 0 && limit == buffer.length)\n+\t      markPos = -1;\n+\t    if (markPos <= 0)\n+\t      pos = limit = 0;\n+\t    int count = in.read(buffer, limit, buffer.length - limit);\n+\t    if (count <= 0)\n+\t      return -1;\n+\t    limit += count;\n+\t  }\n+\tchar ch = buffer[pos++];\n+\tif (ch == '\\r' || ch == '\\n')\n+\t  {\n+\t    lineNumber++;\n+\t    return '\\n';\n+\t  }\n+\treturn (int) ch;\n+      }\n+  }\n+\n+  public int read(char[] buf, int offset, int count) throws IOException\n+  {\n+    if (count <= 0)\n+      {\n+\tif (count < 0)\n+\t  throw new IndexOutOfBoundsException();\n+\treturn 0;\n+      }\n+    synchronized (lock)\n+      {\n+\tint first = read();\n+\tif (first < 0)\n+\t  return -1;\n+\tint start_offset = offset;\n+\tbuf[offset++] = (char) first;\n+\tif (buffer[pos-1] == '\\r' && pos < limit && buffer[pos] == '\\n')\n+\t  pos++;\n+\tcount--;\n+\twhile (count-- > 0 && pos < limit)\n+\t  {\n+\t    char ch = buffer[pos++];\n+\t    if (ch == '\\r')\n+\t      {\n+\t\tlineNumber++;\n+\t\tch = '\\n';\n+\t\tif (pos < limit && buffer[pos] == '\\n')\n+\t\t  pos++;\n+\t      }\n+\t    else if (ch == '\\n')\n+\t      lineNumber++;\n+\t    buf[offset++] = ch;\n+\t  }\n+\treturn offset - start_offset;\n+      }\n+  }\n+\n+  private void skipRedundantLF() throws IOException\n+  {\n+    if (pos > 0 && buffer[pos-1] == '\\r')\n+      {\n+\tif (pos < limit)\n+\t  { // fast case\n+\t    if (buffer[pos] == '\\n')\n+\t      pos++;\n+\t  }\n+\telse\n+\t  { // use read() to deal with the general case.\n+\t    // Set pos and limit to zero to avoid infinite recursion in read.\n+\t    // May need to invalidate markPos if we've exceeded the buffer.  \n+\t    if (pos >= buffer.length)\n+\t      markPos = -1;\n+\t    pos = limit = 0;\n+\t    int ch = read();\n+\t    if (ch >= 0 && ch != '\\n')\n+\t      pos--;\n+\t  }\n+      }\n+  }\n+\n+  public String readLine() throws IOException\n+  {\n+    // BufferedReader.readLine already does this.  Shouldn't need to keep\n+    // track of newlines (since the read method deals with this for us).\n+    // But if the buffer is large, we may not call the read method at all\n+    // and super.readLine can't increment lineNumber itself.\n+    // Though it may seem kludgy, the safest thing to do is to save off\n+    // lineNumber and increment it explicitly when we're done (iff we\n+    // ended with a '\\n' or '\\r' as opposed to EOF).\n+    //\n+    // Also, we need to undo the special casing done by BufferedReader.readLine\n+    // when a '\\r' is the last char in the buffer.  That situation is marked\n+    // by 'pos > limit'.\n+    int tmpLineNumber = lineNumber;\n+    skipRedundantLF();\n+    String str = super.readLine();\n+    if (pos > limit)\n+      --pos;\n+\n+    int ch;\n+    if (pos > 0 && ((ch = buffer[pos - 1]) == '\\n' || ch == '\\r'))\n+      lineNumber = tmpLineNumber + 1;\n+\n+    return str;\n+  }\n+\n+  public long skip(long count) throws IOException\n+  {\n+    if (count <= 0)\n+      return 0;\n+    long to_do = count;\n+    do\n+      {\n+\tint ch = read();\n+\tif (ch < 0)\n+\t  break;\n+\tto_do--;\n+\tif (ch == '\\n' || ch == '\\r')\n+\t  lineNumber++;\n+\telse\n+\t  {\n+\t    long fence = pos + to_do;\n+\t    if (limit < fence)\n+\t      fence = limit;\n+\t    int end = pos;\n+\t    for (; end < fence; end++)\n+\t      {\n+\t\tchar endch = buffer[end];\n+\t\tif (endch == '\\n' || endch == '\\r')\n+\t\t  break;\n+\t      }\n+\t    to_do -= end - pos;\n+\t    pos = end;\n+\t  }\n+      }\n+    while (to_do > 0);\n+    return count - to_do;\n+  }\n+}"}, {"sha": "5aae3611621d3a0fbc320ed20673bfbd14173e33", "filename": "libjava/java/io/OutputStream.java", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FOutputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,48 @@\n+// OutputStream.java - Send output bytes to output sink.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to version 1.1.\n+ */\n+\n+public abstract class OutputStream\n+{\n+  public abstract void write (int b) throws IOException;\n+\n+  public void write (byte[] b) throws IOException, NullPointerException\n+  {\n+    write (b, 0, b.length);\n+  }\n+\n+  public void write (byte[] b, int off, int len)\n+    throws IOException, NullPointerException, IndexOutOfBoundsException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException ();\n+    for (int i = 0; i < len; ++i)\n+      write (b[off + i]);\n+  }\n+\n+  public void flush () throws IOException\n+  {\n+  }\n+\n+  public void close () throws IOException\n+  {\n+  }\n+}"}, {"sha": "e529474875c7b6fc1dc2160b648afd2b4767fc66", "filename": "libjava/java/io/OutputStreamWriter.java", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FOutputStreamWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FOutputStreamWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FOutputStreamWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,155 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+import gnu.gcj.convert.UnicodeToBytes;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 17, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct, but only supports 8859_1.\n+ */\n+\n+public class OutputStreamWriter extends Writer\n+{\n+  BufferedOutputStream out;\n+\n+  UnicodeToBytes converter;\n+\n+  /* Temporary buffer. */\n+  private char[] work;\n+  private int wcount;\n+\n+  public String getEncoding() { return converter.getName(); }\n+\n+  private OutputStreamWriter(OutputStream out, UnicodeToBytes encoder)\n+  {\n+    super(out);\n+    this.out = out instanceof BufferedOutputStream ? (BufferedOutputStream) out\n+      : new BufferedOutputStream(out, 2048);\n+    this.converter = encoder;\n+  } \n+\n+  public OutputStreamWriter(OutputStream out, String enc)\n+   throws UnsupportedEncodingException\n+  {\n+    this(out, UnicodeToBytes.getEncoder(enc));\n+  }\n+\n+  public OutputStreamWriter(OutputStream out)\n+  {\n+    this(out, UnicodeToBytes.getDefaultEncoder());\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tflush();\n+\tif (out != null)\n+\t  {\n+\t    out.close();\n+\t    out = null;\n+\t  }\n+\twork = null;\n+      }\n+  }\n+\n+  public void flush() throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (wcount > 0)\n+\t  {\n+\t    writeChars(work, 0, wcount);\n+\t    wcount = 0;\n+\t  }\n+\tout.flush();\n+      }\n+  }\n+\n+  public void write(char[] buf, int offset, int count)\n+     throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (wcount > 0)\n+\t  {\n+\t    writeChars(work, 0, wcount);\n+\t    wcount = 0;\n+\t  }\n+\twriteChars(buf, offset, count);\n+      }\n+  }\n+\n+  private void writeChars(char[] buf, int offset, int count)\n+    throws IOException\n+  {\n+    while (count > 0)\n+      {\n+\tif (out.count != 0)\n+\t  {\n+\t    out.flush();\n+\t    if (out.count != 0)\n+\t      throw new IOException(\"unable to flush output byte buffer\");\n+\t  }\n+\tconverter.setOutput(out.buf, out.count);\n+\tint converted = converter.write(buf, offset, count);\n+\toffset += converted;\n+\tcount -= converted;\n+\tout.count = converter.count;\n+      }\n+  }\n+\n+  public void write(String str, int offset, int count)\n+     throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (work == null)\n+\t  work = new char[100];\n+\tint wlength = work.length;\n+\twhile (count > 0)\n+\t  {\n+\t    int size = count;\n+\t    if (wcount + size > wlength)\n+\t      {\n+\t\tif (2*wcount > wlength)\n+\t\t  {\n+\t\t    writeChars(work, 0, wcount);\n+\t\t    wcount = 0;\n+\t\t  }\n+\t\tif (wcount + size > wlength)\n+\t\t  size = wlength - wcount;\n+\t      }\n+\t    str.getChars(offset, offset+size, work, wcount);\n+\t    offset += size;\n+\t    count -= size;\n+\t    wcount += size;\n+\t  }\n+      }\n+  }\n+\n+  public void write(int ch) throws IOException\n+  {\n+    synchronized (lock)\n+      {\n+\tif (work == null)\n+\t  work = new char[100];\n+\tif (wcount >= work.length)\n+\t  {\n+\t    writeChars(work, 0, wcount);\n+\t    wcount = 0;\n+\t  }\n+\twork[wcount++] = (char) ch;\n+      }\n+  }\n+}"}, {"sha": "d8a836c289f811b89412ada7874c7e33a1a03fe8", "filename": "libjava/java/io/PipedInputStream.java", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,242 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 29, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class PipedInputStream extends InputStream\n+{\n+  /* The size of the pipe's circular input buffer. */\n+  protected static final int PIPE_SIZE = 1024;\n+\n+  /* The circular buffer into which incoming data is placed. */\n+  protected byte[] buffer;\n+\n+  /* The index in the buffer at which the next byte of data will be stored. */\n+  protected int in = -1;\n+\n+  /* The index in the buffer at which the next byte of data will be read. */\n+  protected int out = 0;\n+\n+  /* The output stream this is connected to; used to check for errors. */\n+  private PipedOutputStream po = null;\n+\n+  /* Flag to indicate that the output stream was closed. */\n+  private boolean outClosed = false;\n+\n+  public PipedInputStream(PipedOutputStream src) throws IOException\n+  {\n+    buffer = new byte[PIPE_SIZE];\n+    connect(src);\n+  }\n+\n+  public PipedInputStream()\n+  {\n+    buffer = new byte[PIPE_SIZE];\n+  }\n+\n+  public synchronized int available() throws IOException\n+  {\n+    if (in < 0)\n+      return 0;\n+\n+    if (in > out)\n+      return in - out;\n+\n+    // Buffer has wrapped around.\n+    return buffer.length - out + in;\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    buffer = null;\n+    po = null;\n+\n+    // Mark as empty for available method.\n+    in = -1;\n+  }\n+\n+  public void connect(PipedOutputStream src) throws IOException\n+  {\n+    if (buffer == null)\n+      throw new IOException(\"pipe closed\");\n+\n+    if (po != null)\n+      if (po == src)\n+\treturn;\n+      else\n+        throw new IOException(\"pipe already connected\");\n+\n+    po = src;\n+    try\n+    {\n+      src.connect(this);\n+    }\n+    catch (IOException ex)\n+    {\n+      po = null;\n+      throw ex;\n+    }\n+  }\n+\n+  public synchronized int read() throws IOException\n+  {\n+    // TBD: Spec says to throw IOException if thread writing to output stream\n+    // died.  What does this really mean?  Theoretically, multiple threads\n+    // could be writing to this object.  Do you track the first, last, or\n+    // all of them?\n+    if (po == null)\n+      if (buffer == null)\n+        throw new IOException(\"pipe closed\");\n+      else\n+        throw new IOException(\"pipe unconnected\");\n+\n+    // Block until there's something to read or output stream was closed.\n+    while (in < 0)\n+      try\n+\t{\n+\t  if (outClosed)\n+\t    return -1;\n+\t  wait();\n+\t}\n+      catch (InterruptedException ex)\n+       {\n+\t throw new InterruptedIOException();\n+       }\n+\n+    // Let other threads know there's room to write now.\n+    notifyAll();\n+\n+    int retval = buffer[out++] & 0xFF;\n+\n+    // Wrap back around if at end of the array.\n+    if (out >= buffer.length)\n+      out = 0;\n+\n+    // When the last byte available is read, mark the buffer as empty.\n+    if (out == in)\n+      {\n+        in = -1;\n+\tout = 0;\n+      }\n+      \n+    return retval;\n+  }\n+\n+  public synchronized int read(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    // TBD: Spec says to throw IOException if thread writing to output stream\n+    // died.  What does this really mean?  Theoretically, multiple threads\n+    // could be writing to this object.  Do you track the first, last, or\n+    // all of them?\n+    if (po == null)\n+      if (buffer == null)\n+        throw new IOException(\"pipe closed\");\n+      else\n+        throw new IOException(\"pipe unconnected\");\n+\n+    // Block until there's something to read or output stream was closed.\n+    while (in < 0)\n+      try\n+\t{\n+\t  if (outClosed)\n+\t    return -1;\n+\t  wait();\n+\t}\n+      catch (InterruptedException ex)\n+       {\n+\t throw new InterruptedIOException();\n+       }\n+\n+    // Let other threads know there's room to write now.\n+    notifyAll();\n+\n+    int numRead;\n+    len = Math.min(len, available());\n+    if (in <= out && len >= (numRead = buffer.length - out))\n+      {\n+\t// Buffer has wrapped around; need to copy in 2 steps.\n+\t// Copy to the end of the buffer first; second copy may be of zero\n+\t// bytes but that is ok.  Doing it that way saves having to check\n+\t// later if 'out' has grown to buffer.length.\n+        System.arraycopy(buffer, out, b, off, numRead);\n+\tlen -= numRead;\n+\toff += numRead;\n+\tout = 0;\n+      }\n+    else\n+      numRead = 0;\n+\n+    System.arraycopy(buffer, out, b, off, len);\n+    numRead += len;\n+    out += len;\n+\n+    // When the last byte available is read, mark the buffer as empty.\n+    if (out == in)\n+      {\n+        in = -1;\n+\tout = 0;\n+      }\n+\n+    return numRead;\n+  }\n+\n+  protected synchronized void receive(int b) throws IOException\n+  {\n+    if (buffer == null)\n+      throw new IOException(\"pipe closed\");\n+\n+    // TBD: Spec says to throw IOException if thread reading from input stream\n+    // died.  What does this really mean?  Theoretically, multiple threads\n+    // could be reading to this object (why else would 'read' be synchronized?).\n+    // Do you track the first, last, or all of them?\n+\n+    if (b < 0)\n+      {\n+        outClosed = true;\n+\tnotifyAll();\t// In case someone was blocked in a read.\n+\treturn;\n+      }\n+\n+    // Block until there's room in the pipe.\n+    while (in == out)\n+      try\n+\t{\n+\t  wait();\n+\t}\n+      catch (InterruptedException ex)\n+       {\n+\t throw new InterruptedIOException();\n+       }\n+\n+    // Check if buffer is empty.\n+    if (in < 0)\n+      in = 0;\n+\n+    buffer[in++] = (byte) b;\n+\n+    // Wrap back around if at end of the array.\n+    if (in >= buffer.length)\n+      in = 0;\n+\n+    // Let other threads know there's something to read when this returns.\n+    notifyAll();\n+  }\n+}"}, {"sha": "9b069944926871f7991f63f1718f716e4796fb37", "filename": "libjava/java/io/PipedOutputStream.java", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedOutputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,94 @@\n+// PipedOutputStream.java - Write bytes to a pipe.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class PipedOutputStream extends OutputStream\n+{\n+  public void close () throws IOException\n+  {\n+    closed = true;\n+\n+    // Notify PipedInputStream that there is no more data to be had.\n+    destination.receive(-1);\n+  }\n+\n+  public void connect (PipedInputStream dest) throws IOException\n+  {\n+    if (closed)\n+      throw new IOException(\"pipe closed\");\n+\n+    if (destination != null)\n+      if (destination == dest)\n+\treturn;\n+      else\n+        throw new IOException(\"pipe already connected\");\n+\n+    destination = dest;\n+    try\n+    {\n+      dest.connect(this);\n+    }\n+    catch (IOException ex)\n+    {\n+      destination = null;\n+      throw ex;\n+    }\n+  }\n+\n+  public synchronized void flush () throws IOException\n+  {\n+    // There doesn't seem to be anything to do here.\n+\n+    // TBD: Should this maybe do a notifyAll as a way for the user\n+    // to wake up the input stream to check for bytes to read?  Shouldn't\n+    // be necessary but if there aren't any bytes, other threads will just\n+    // go blocak again anyway so it wouldn't hurt.\n+  }\n+\n+  public PipedOutputStream ()\n+  {\n+    closed = false;\n+  }\n+\n+  public PipedOutputStream (PipedInputStream dest) throws IOException\n+  {\n+    closed = false;\n+    connect (dest);\n+  }\n+\n+  public void write (int oneByte) throws IOException\n+  {\n+    if (closed)\n+      throw new IOException ();\n+    destination.receive(oneByte);\n+  }\n+\n+  // This is mentioned in the JCL book, but we don't really need it.\n+  // If there were a corresponding receive() method on\n+  // PipedInputStream then we could get better performance using\n+  // this.\n+  // public void write (byte[] buffer, int offset, int count)\n+  // throws IOException;\n+\n+  // Instance variables.\n+  private PipedInputStream destination;\n+  private boolean closed;\n+}"}, {"sha": "f54c4f8031f1290c83e57606697f3e32d2a24d92", "filename": "libjava/java/io/PipedReader.java", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,210 @@\n+// PipedReader.java - Piped character stream.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class PipedReader extends Reader\n+{\n+  public void close () throws IOException\n+  {\n+    closed = true;\n+  }\n+\n+  public void connect (PipedWriter src) throws IOException\n+  {\n+    if (closed)\n+      throw new IOException (\"already closed\");\n+    if (writer != null)\n+      {\n+\tif (writer == src)\n+\t  return;\n+\tthrow new IOException (\"already connected\");\n+      }\n+    try\n+      {\n+\twriter = src;\n+\twriter.connect(this);\n+      }\n+    catch (IOException e)\n+      {\n+\twriter = null;\n+\tthrow e;\n+      }\n+  }\n+\n+  public PipedReader ()\n+  {\n+    super ();\n+    writer = null;\n+    closed = false;\n+    in = -1;\n+    out = 0;\n+    pipeBuffer = new char[1024];\n+  }\n+\n+  public PipedReader (PipedWriter src) throws IOException\n+  {\n+    super ();\n+    closed = false;\n+    in = -1;\n+    out = 0;\n+    pipeBuffer = new char[1024];\n+    connect (src);\n+  }\n+\n+  public int read (char buf[], int offset, int count) throws IOException\n+  {\n+    if (closed)\n+      throw new IOException (\"closed\");\n+    if (count < 0)\n+      throw new ArrayIndexOutOfBoundsException ();\n+    int toCopy = count;\n+    synchronized (lock)\n+      {\n+\twhile (toCopy > 0)\n+\t  {\n+\t    // Wait for data in the pipe.  If the writer is closed and\n+\t    // no data has been copied into the output buffer, return\n+\t    // the magic EOF number.\n+\t    while (in == -1)\n+\t      {\n+\t\tif (writer.isClosed())\n+\t\t  {\n+\t\t    if (toCopy < count)\n+\t\t      return count - toCopy;\n+\t\t    return -1;\n+\t\t  }\n+\n+\t\t// Note that JCL doesn't say this is the right thing\n+\t\t// to do.  Still, it feels right, and we must deal\n+\t\t// with an interrupt somehow.\n+\t\ttry\n+\t\t  {\n+\t\t    lock.wait();\n+\t\t  }\n+\t\tcatch (InterruptedException e)\n+\t\t  {\n+\t\t    InterruptedIOException io\n+\t\t      = new InterruptedIOException (e.getMessage());\n+\t\t    io.bytesTransferred = count - toCopy;\n+\t\t    throw io;\n+\t\t  }\n+\t      }\n+\t    // Now copy some data from pipe into user buffer.\n+\t    int len;\n+\t    if (in < out)\n+\t      len = pipeBuffer.length - out;\n+\t    else\n+\t      len = in - out;\n+\t    len = len > toCopy ? toCopy : len;\n+\t    System.arraycopy(pipeBuffer, out, buf, offset, len);\n+\t    out += len;\n+\t    if (out == pipeBuffer.length)\n+\t      out = 0;\n+\t    toCopy -= len;\n+\t    offset += len;\n+\t    // If we've read all the data, then reset so that we know\n+\t    // there is nothing left to be read.\n+\t    if (in == out)\n+\t      in = -1;\n+\t    // Tell anybody waiting for space in the buffer.\n+\t    lock.notifyAll();\n+\t  }\n+      }\n+    return count;\n+  }\n+\n+  void receive (char buf[], int offset, int count) throws IOException\n+  {\n+    if (count < 0)\n+      throw new ArrayIndexOutOfBoundsException ();\n+    int original = count;\n+    synchronized (lock)\n+      {\n+\twhile (count > 0)\n+\t  {\n+\t    // Wait until there is some space in the buffer.\n+\t    while (in == out)\n+\t      {\n+\t\ttry\n+\t\t  {\n+\t\t    lock.wait();\n+\t\t  }\n+\t\tcatch (InterruptedException e)\n+\t\t  {\n+\t\t    // Turn interrupts into IO interrupts.\n+\t\t    InterruptedIOException io\n+\t\t      = new InterruptedIOException (e.getMessage());\n+\t\t    io.bytesTransferred = original - count;\n+\t\t    throw io;\n+\t\t  }\n+\t      }\n+\n+\t    // Compute destination in the pipe.\n+\t    int base, len;\n+\t    if (in == -1)\n+\t      {\n+\t\tbase = 0;\n+\t\tlen = pipeBuffer.length;\n+\t      }\n+\t    else if (in < out)\n+\t      {\n+\t\tbase = in;\n+\t\tlen = out - in;\n+\t      }\n+\t    else\n+\t      {\n+\t\tbase = in;\n+\t\tlen = pipeBuffer.length - in;\n+\t      }\n+\t    int copyLen = len > count ? count : len;\n+\t    // Copy data and update local state.\n+\t    System.arraycopy(buf, offset, pipeBuffer, base, copyLen);\n+\t    in = base + copyLen;\n+\t    if (in == pipeBuffer.length)\n+\t      in = 0;\n+\t    count -= copyLen;\n+\t    offset += copyLen;\n+\t    // Tell anybody waiting for data.\n+\t    lock.notifyAll();\n+\t  }\n+      }\n+  }\n+\n+\n+  boolean isClosed ()\n+  {\n+    return closed;\n+  }\n+\n+  // The associated writer.\n+  private PipedWriter writer;\n+  // True if this reader has been closed.\n+  boolean closed;\n+\n+  // Index of next character to overwrite when receive() is called.\n+  // If -1, then that means the buffer is empty.\n+  private int in;\n+  // Index of next character to return from read().\n+  private int out;\n+\n+  // The pipe buffer itself.\n+  private char[] pipeBuffer;\n+}"}, {"sha": "c914cac9f9c9248b94acf4bf74b9f3ff85099e30", "filename": "libjava/java/io/PipedWriter.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPipedWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,88 @@\n+// PipedWriter.java - Piped character stream.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class PipedWriter extends Writer\n+{\n+  public void close () throws IOException\n+  {\n+    closed = true;\n+  }\n+\n+  public void connect (PipedReader sink) throws IOException\n+  {\n+    if (closed)\n+      throw new IOException (\"already closed\");\n+    if (reader != null)\n+      {\n+\tif (reader == sink)\n+\t  return;\n+\tthrow new IOException (\"already connected\");\n+      }\n+    try\n+      {\n+\treader = sink;\n+\treader.connect(this);\n+      }\n+    catch (IOException e)\n+      {\n+\treader = null;\n+\tthrow e;\n+      }\n+  }\n+\n+  public void flush () throws IOException\n+  {\n+    // We'll throw an exception if we're closed, but there's nothing\n+    // else to do here.\n+    if (closed)\n+      throw new IOException (\"closed\");\n+  }\n+\n+  public PipedWriter ()\n+  {\n+    super ();\n+    closed = false;\n+  }\n+\n+  public PipedWriter (PipedReader sink) throws IOException\n+  {\n+    super ();\n+    closed = false;\n+    connect (sink);\n+  }\n+\n+  public void write (char buffer[], int offset, int count) throws IOException\n+  {\n+    if (closed)\n+      throw new IOException (\"closed\");\n+    reader.receive(buffer, offset, count);\n+  }\n+\n+  boolean isClosed ()\n+  {\n+    return closed;\n+  }\n+\n+  // The associated reader.\n+  private PipedReader reader;\n+  private boolean closed;\n+}"}, {"sha": "499e5eb70597c7c2923c8f8c14a531c59aceb9d7", "filename": "libjava/java/io/PrintStream.java", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPrintStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPrintStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPrintStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,236 @@\n+// PrintStream.java - Print string representations\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Not finished.\n+ */\n+\n+public class PrintStream extends FilterOutputStream\n+{\n+  public boolean checkError ()\n+  {\n+    return error;\n+  }\n+\n+  public void close ()\n+  {\n+    try\n+      {\n+\tout.close();\n+      }\n+    catch (IOException e)\n+      {\n+\tsetError ();\n+      }\n+  }\n+\n+  public void flush ()\n+  {\n+    try\n+      {\n+\tout.flush();\n+      }\n+    catch (IOException e)\n+      {\n+\tsetError ();\n+      }\n+  }\n+\n+  private final void print (String str, boolean check_term)\n+  {\n+    try\n+      {\n+\twrite(str.getBytes());\n+\tif (check_term\n+\t    && auto_flush\n+\t    && str.indexOf(line_separator) != -1)\n+\t  flush ();\n+      }\n+    catch (IOException e)\n+      {\n+\tsetError ();\n+      }\n+  }\n+\n+  public void print (boolean bool)\n+  {\n+    print (String.valueOf(bool), false);\n+  }\n+\n+  public void print (int inum)\n+  {\n+    print (String.valueOf(inum), false);\n+  }\n+\n+  public void print (long lnum)\n+  {\n+    print (String.valueOf(lnum), false);\n+  }\n+\n+  public void print (float fnum)\n+  {\n+    print (String.valueOf(fnum), false);\n+  }\n+\n+  public void print (double dnum)\n+  {\n+    print (String.valueOf(dnum), false);\n+  }\n+\n+  public void print (Object obj)\n+  {\n+    print (String.valueOf(obj), false);\n+  }\n+\n+  public void print (String str)\n+  {\n+    print (str, true);\n+  }\n+\n+  public void print (char ch)\n+  {\n+    print (String.valueOf(ch), true);\n+  }\n+\n+  public void print (char[] charArray)\n+  {\n+    print (String.valueOf(charArray), true);\n+  }\n+\n+  public void println ()\n+  {\n+    print (line_separator, false);\n+    if (auto_flush)\n+      flush ();\n+  }\n+\n+  public void println (boolean bool)\n+  {\n+    print (String.valueOf(bool), false);\n+    println ();\n+  }\n+\n+  public void println (int inum)\n+  {\n+    print (String.valueOf(inum), false);\n+    println ();\n+  }\n+\n+  public void println (long lnum)\n+  {\n+    print (String.valueOf(lnum), false);\n+    println ();\n+  }\n+\n+  public void println (float fnum)\n+  {\n+    print (String.valueOf(fnum), false);\n+    println ();\n+  }\n+\n+  public void println (double dnum)\n+  {\n+    print (String.valueOf(dnum), false);\n+    println ();\n+  }\n+\n+  public void println (Object obj)\n+  {\n+    print (String.valueOf(obj), false);\n+    println ();\n+  }\n+\n+  public void println (String str)\n+  {\n+    print (str, false);\n+    println ();\n+  }\n+\n+  public void println (char ch)\n+  {\n+    print (String.valueOf(ch), false);\n+    println ();\n+  }\n+\n+  public void println (char[] charArray)\n+  {\n+    print (String.valueOf(charArray), false);\n+    println ();\n+  }\n+\n+  public PrintStream (OutputStream out)\n+  {\n+    super (out);\n+    error = false;\n+    auto_flush = false;\n+  }\n+\n+  public PrintStream (OutputStream out, boolean af)\n+  {\n+    super (out);\n+    error = false;\n+    auto_flush = af;\n+  }\n+\n+  protected void setError ()\n+  {\n+    error = true;\n+  }\n+\n+  public void write (int oneByte)\n+  {\n+    try\n+      {\n+\tout.write(oneByte);\n+\t// JCL says to do this.  I think it is wrong.  FIXME.\n+\tif (auto_flush && oneByte == '\\n')\n+\t  out.flush();\n+      }\n+    catch (IOException e)\n+      {\n+\tsetError ();\n+      }\n+  }\n+\n+  public void write (byte[] buffer, int offset, int count)\n+  {\n+    try\n+      {\n+\tout.write(buffer, offset, count);\n+\t// FIXME: JCL says to flush.  But elsewhere the JCL says to\n+\t// use write to write the stringified form of an object, and\n+\t// only to flush if that string contains the line separator.\n+\t// How to resolve the contradiction?\n+\tif (auto_flush)\n+\t  out.flush();\n+      }\n+    catch (IOException e)\n+      {\n+\tsetError ();\n+      }\n+  }\n+\n+  // True if error occurred.\n+  private boolean error;\n+  // True if auto-flush.\n+  private boolean auto_flush;\n+\n+  // Line separator string.\n+  private static final String line_separator\n+    = System.getProperty(\"line.separator\");\n+}"}, {"sha": "2a6cb01b95b8759e64940ec62069fb13f693e5fa", "filename": "libjava/java/io/PrintWriter.java", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPrintWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPrintWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPrintWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,286 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 17, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ * However, should use native methods for conversion.\n+ */\n+\n+public class PrintWriter extends Writer\n+{\n+  private boolean autoflush;\n+  private boolean error;\n+  Writer out;\n+\n+  public PrintWriter(Writer wr)\n+  {\n+    super(wr);\n+    this.out = wr;\n+  }\n+\n+  public PrintWriter(Writer wr, boolean autoflush)\n+  {\n+    super(wr);\n+    this.out = wr;\n+    this.autoflush = autoflush;\n+  }\n+\n+  public PrintWriter(OutputStream out)\n+  {\n+    super();\n+    this.out = new OutputStreamWriter(out);\n+    this.lock = this.out;\n+  }\n+\n+  public PrintWriter(OutputStream out, boolean autoflush)\n+  {\n+    this(out);\n+    this.autoflush = autoflush;\n+  }\n+  protected void setError() { error = true; }\n+\n+  public boolean checkError()\n+  {\n+    flush();\n+    return error;\n+  }\n+\n+  public void flush()\n+  {\n+    try\n+      {\n+\tout.flush();\n+      }\n+    catch (IOException ex)\n+      {\n+\terror = true;\n+      }\n+  }\n+\n+  public void close()\n+  {\n+    try\n+      {\n+\tout.close();\n+      }\n+    catch (IOException ex)\n+      {\n+\terror = true;\n+      }\n+  }\n+\n+  public void print(String str)\n+  {\n+    try\n+      {\n+\tout.write(str == null ? \"null\" : str);\n+      }\n+    catch (IOException ex)\n+      {\n+\terror = true;\n+      }\n+  }\n+\n+  public void print(char ch)\n+  {\n+    write((int) ch);\n+  }\n+\n+  public void print(char[] charArray)\n+  {\n+    write(charArray, 0, charArray.length);\n+  }\n+\n+  public void print(boolean bool)\n+  {\n+    print(bool ? \"true\" : \"false\");\n+  }\n+\n+  public void print(int inum)\n+  {\n+    print(Integer.toString(inum));\n+  }\n+\n+  public void print(long lnum)\n+  {\n+    print(Long.toString(lnum));\n+  }\n+\n+  public void print(float fnum)\n+  {\n+    print(Float.toString(fnum));\n+  }\n+\n+  public void print(double dnum)\n+  {\n+    print(Double.toString(dnum));\n+  }\n+\n+  public void print(Object obj)\n+  {\n+    print(obj == null ? \"null\" : obj.toString());\n+  }\n+\n+  private static final char[] line_separator\n+  = System.getProperty(\"line.separator\").toCharArray();\n+\n+  public void println()\n+  {\n+    synchronized (lock)\n+      {\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  private void printlnUnsynchronized()\n+  {\n+    try\n+      {\n+\twrite(line_separator, 0, line_separator.length);\n+\tif (autoflush)\n+\t  out.flush();\n+      }\n+    catch (IOException ex)\n+      {\n+\terror = true;\n+      }\n+  }\n+\n+  public void println(boolean bool)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(bool);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+  public void println(int inum)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(inum);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void println(long lnum)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(lnum);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void println(float fnum)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(fnum);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void println(double dnum)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(dnum);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void println(Object obj)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(obj);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void println(String str)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(str);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void println(char ch)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(ch);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void println(char[] charArray)\n+  {\n+    synchronized (lock)\n+      {\n+\tprint(charArray);\n+\tprintlnUnsynchronized();\n+      }\n+  }\n+\n+  public void write(int ch)\n+  {\n+    try\n+      {\n+\tout.write(ch);\n+      }\n+    catch (IOException ex)\n+      {\n+\terror = true;\n+      }\n+  }\n+\n+  public void write(char[] charArray, int offset, int count)\n+  {\n+    try\n+      {\n+\tout.write(charArray, offset, count);\n+      }\n+    catch (IOException ex)\n+      {\n+\terror = true;\n+      }\n+  }\n+\n+  public void write(String str, int offset, int count)\n+  {\n+    try\n+      {\n+\tout.write(str, offset, count);\n+      }\n+    catch (IOException ex)\n+      {\n+\terror = true;\n+      }\n+  }\n+\n+  public void write(char[] charArray)\n+  {\n+    write(charArray, 0, charArray.length);\n+  }  \n+\n+  public void write(String str)\n+  {\n+    write(str, 0, str.length());\n+  }  \n+}"}, {"sha": "58c8fe6c4ec1b5a12e970eace7c362f10dd38b5c", "filename": "libjava/java/io/PushbackInputStream.java", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPushbackInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPushbackInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPushbackInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,124 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 15, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class PushbackInputStream extends FilterInputStream\n+{\n+  /* Internal buffer array for data. */\n+  protected byte[] buf;\n+\n+  /* The current position in the buffer. */\n+  protected int pos;\n+\n+  public PushbackInputStream(InputStream in)\n+  {\n+    this(in, 1);\n+  }\n+\n+  public PushbackInputStream(InputStream in, int size)\n+  {\n+    super(in);\n+    if (size < 0)\n+      throw new IllegalArgumentException();\n+    buf = new byte[size];\n+    pos = buf.length;\n+  }\n+\n+  public int available() throws IOException\n+  {\n+    return pos + super.available();\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    buf = null;\n+    super.close();\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return false;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    if (pos < buf.length)\n+      return ((int) buf[pos++]) & 0xFF;\n+\n+    return super.read();\n+  }\n+\n+  public int read(byte[] b, int off, int len) throws IOException\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    int numBytes = Math.min(buf.length - pos, len);\n+    for (int i = 0; i < numBytes; i++)\n+      b[off++] = buf[pos++];\n+\n+    // `off' was just incremented to include `numBytes', so we can\n+    // just pass ithere.\n+    return numBytes + super.read(b, off, len - numBytes);\n+  }\n+\n+  public void unread(int b) throws IOException\n+  {\n+    if (pos <= 0)\n+      throw new IOException();\n+\n+    buf[--pos] = (byte) b;\n+  }\n+\n+  public void unread(byte[] b) throws IOException\n+  {\n+    unread(b, 0, b.length);\n+  }\n+\n+  public void unread(byte[] b, int off, int len) throws IOException\n+  {\n+    if (pos < len)\n+      throw new IOException();\n+\n+    // Note the order that these bytes are being added is the opposite\n+    // of what would be done if they were added to the buffer one at a time.\n+    // See the Java Class Libraries book p. 1390.\n+    System.arraycopy(b, off, buf, pos - len, len);\n+\n+    // Don't put this into the arraycopy above, an exception might be thrown\n+    // and in that case we don't want to modify pos.\n+    pos -= len;\n+  }\n+\n+  // JDK1.2\n+  public long skip(long n) throws IOException\n+  {\n+    final long origN = n;\n+\n+    if (n > 0L)\n+      {\n+\tint numread = (int) Math.min((long) (buf.length - pos), n);\n+\tpos += numread;\n+\tn -= numread;\n+\tn -= super.skip(n);\n+      }\n+\n+    return origN - n;\n+  }\n+}"}, {"sha": "0cfd63cdb2bcd4e2d2e23c42bb14fed39ee28426", "filename": "libjava/java/io/PushbackReader.java", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPushbackReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FPushbackReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPushbackReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,136 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 16, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class PushbackReader extends FilterReader\n+{\n+  /* Internal buffer array for data. */\n+  private char[] buf;\n+\n+  /* The current position in the buffer. */\n+  private int pos;\n+\n+  public PushbackReader(Reader in)\n+  {\n+    this(in, 1);\n+  }\n+\n+  public PushbackReader(Reader in, int size)\n+  {\n+    super(in);\n+    if (size < 0)\n+      throw new IllegalArgumentException();\n+    buf = new char[size];\n+    pos = buf.length;\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      buf = null;\n+      super.close();\n+    }\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return false;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      if (pos < buf.length)\n+        return ((int) buf[pos++]) & 0xFFFF;\n+\n+      return super.read();\n+    }\n+  }\n+\n+  public int read(char[] b, int off, int len) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      if (off < 0 || len < 0 || off + len > b.length)\n+        throw new ArrayIndexOutOfBoundsException();\n+\n+      int numBytes = Math.min(buf.length - pos, len);\n+      for (int i = 0; i < numBytes; i++)\n+        b[off++] = buf[pos++];\n+\n+      return numBytes + super.read(b, off, len - numBytes);\n+    }\n+  }\n+\n+  public boolean ready() throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      if (buf.length - pos > 0)\n+        return true;\n+\n+      return super.ready();\n+    }\n+  }\n+\n+  public void unread(int b) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null || pos <= 0)\n+        throw new IOException();\n+\n+      buf[--pos] = (char) b;\n+    }\n+  }\n+\n+  public void unread(char[] b) throws IOException\n+  {\n+    unread(b, 0, b.length);\n+  }\n+\n+  public void unread(char[] b, int off, int len) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null || pos < len)\n+        throw new IOException();\n+\n+      // Note the order that these chars are being added is the opposite\n+      // of what would be done if they were added to the buffer one at a time.\n+      // See the Java Class Libraries book p. 1397.\n+      System.arraycopy(b, off, buf, pos - len, len);\n+\n+      // Don't put this into the arraycopy above, an exception might be thrown\n+      // and in that case we don't want to modify pos.\n+      pos -= len;\n+    }\n+  }\n+}"}, {"sha": "d240e0df4391bcf6643198901159a60faac66462", "filename": "libjava/java/io/RandomAccessFile.java", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FRandomAccessFile.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,249 @@\n+// RandomAccessFile.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  not finished\n+ */\n+\n+public class RandomAccessFile implements DataOutput, DataInput\n+{\n+  public void close () throws IOException\n+  {\n+    fd.close();\n+  }\n+\n+  public final FileDescriptor getFD () throws IOException\n+  {\n+    if (! fd.valid())\n+      throw new IOException ();\n+    return fd;\n+  }\n+\n+  public long getFilePointer () throws IOException\n+  {\n+    return fd.getFilePointer();\n+  }\n+\n+  public long length () throws IOException\n+  {\n+    return fd.length();\n+  }\n+\n+  public RandomAccessFile (String fileName, String mode) throws IOException\n+  {\n+    int fdmode;\n+    if (mode.compareTo (\"r\") == 0)\n+      fdmode = FileDescriptor.READ;\n+    else if (mode.compareTo (\"rw\") == 0)\n+      fdmode = FileDescriptor.READ | FileDescriptor.WRITE;\n+    else\n+      throw new IllegalArgumentException (\"invalid mode: \" + mode);\n+\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      {\n+\ts.checkRead(fileName);\n+\tif ((fdmode & FileDescriptor.WRITE) != 0)\n+\t  s.checkWrite(fileName);\n+      }\n+\n+    fd = new FileDescriptor (fileName, fdmode);\n+    // FIXME: read-only mode.\n+    out = new DataOutputStream (new FileOutputStream (fd));\n+    in = new DataInputStream (new FileInputStream (fd));\n+  }\n+\n+  public RandomAccessFile (File file, String mode) throws IOException\n+  {\n+    this (file.getPath(), mode);\n+  }\n+\n+  public int read () throws IOException\n+  {\n+    return in.read();\n+  }\n+\n+  public int read (byte[] buffer) throws IOException\n+  {\n+    return in.read(buffer);\n+  }\n+\n+  public int read (byte[] buffer, int offset, int count) throws IOException\n+  {\n+    return in.read(buffer, offset, count);\n+  }\n+\n+  public final boolean readBoolean () throws IOException\n+  {\n+    return in.readBoolean();\n+  }\n+\n+  public final byte readByte () throws IOException\n+  {\n+    return in.readByte();\n+  }\n+\n+  public final char readChar () throws IOException\n+  {\n+    return in.readChar();\n+  }\n+\n+  public final double readDouble () throws IOException\n+  {\n+    return in.readDouble();\n+  }\n+\n+  public final float readFloat () throws IOException\n+  {\n+    return in.readFloat();\n+  }\n+\n+  public final void readFully (byte[] buffer) throws IOException\n+  {\n+    // FIXME.\n+  }\n+\n+  public final void readFully (byte[] buffer, int offset, int count)\n+    throws IOException\n+  {\n+    // FIXME.\n+  }\n+\n+  public final int readInt () throws IOException\n+  {\n+    return in.readInt();\n+  }\n+\n+  public final String readLine () throws IOException\n+  {\n+    // FIXME?\n+    return in.readLine();\n+  }\n+\n+  public final long readLong () throws IOException\n+  {\n+    return in.readLong();\n+  }\n+\n+  public final short readShort () throws IOException\n+  {\n+    return in.readShort();\n+  }\n+\n+  public final int readUnsignedByte () throws IOException\n+  {\n+    return in.readUnsignedByte();\n+  }\n+\n+  public final int readUnsignedShort () throws IOException\n+  {\n+    return in.readUnsignedShort();\n+  }\n+\n+  public final String readUTF () throws IOException\n+  {\n+    return in.readUTF();\n+  }\n+\n+  public void seek (long pos) throws IOException\n+  {\n+    fd.seek(pos, FileDescriptor.SET);\n+  }\n+\n+  public int skipBytes (int count) throws IOException\n+  {\n+    return fd.seek(count, FileDescriptor.CUR);\n+  }\n+\n+  public void write (int oneByte) throws IOException\n+  {\n+    out.write(oneByte);\n+  }\n+\n+  public void write (byte[] buffer) throws IOException\n+  {\n+    out.write(buffer);\n+  }\n+\n+  public void write (byte[] buffer, int offset, int count) throws IOException\n+  {\n+    out.write(buffer, offset, count);\n+  }\n+\n+  public final void writeBoolean (boolean val) throws IOException\n+  {\n+    out.writeBoolean(val);\n+  }\n+\n+  public final void writeByte (int v) throws IOException\n+  {\n+    out.writeByte(v);\n+  }\n+\n+  public final void writeShort (int v) throws IOException\n+  {\n+    out.writeShort(v);\n+  }\n+\n+  public final void writeChar (int v) throws IOException\n+  {\n+    out.writeChar(v);\n+  }\n+\n+  public final void writeInt (int v) throws IOException\n+  {\n+    out.writeInt(v);\n+  }\n+\n+  public final void writeLong (long v) throws IOException\n+  {\n+    out.writeLong(v);\n+  }\n+\n+  public final void writeFloat (float v) throws IOException\n+  {\n+    out.writeFloat(v);\n+  }\n+\n+  public final void writeDouble (double v) throws IOException\n+  {\n+    out.writeDouble(v);\n+  }\n+\n+  public final void writeBytes (String s) throws IOException\n+  {\n+    out.writeBytes(s);\n+  }\n+\n+  public final void writeChars (String s) throws IOException\n+  {\n+    out.writeChars(s);\n+  }\n+  \n+  public final void writeUTF (String s) throws IOException\n+  {\n+    out.writeUTF(s);\n+  }\n+\n+\n+  // The underlying file.\n+  private FileDescriptor fd;\n+  // The corresponding input and output streams.\n+  private DataOutputStream out;\n+  private DataInputStream in;\n+}"}, {"sha": "b54735836c2b9a159edadfe6618a67104cac4532", "filename": "libjava/java/io/Reader.java", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,87 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 21, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public abstract class Reader\n+{\n+  protected Object lock;\n+\n+  protected Reader()\n+  {\n+    this.lock = this;\n+  }\n+\n+  protected Reader(Object lock)\n+  {\n+    this.lock = lock;\n+  }\n+\n+  abstract public int read(char buf[], int offset, int count)\n+    throws IOException;\n+\n+  public int read(char buf[]) throws IOException\n+  {\n+    return read(buf, 0, buf.length);\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    char[] buf = new char[1];\n+    int count = read(buf, 0, 1);\n+    return count > 0 ? buf[0] : -1;\n+  }\n+\n+  abstract public void close() throws IOException;\n+\n+  public boolean markSupported()\n+  {\n+    return false;\n+  }\n+\n+  public void mark(int readLimit) throws IOException\n+  {\n+    throw new IOException(\"mark not supported\");\n+  }\n+\n+  public void reset() throws IOException\n+  {\n+    throw new IOException(\"reset not supported\");\n+  }\n+\n+  public boolean ready() throws IOException\n+  {\n+    return false;\n+  }\n+\n+  public long skip(long count) throws IOException\n+  {\n+    if (count <= 0)\n+      return 0;\n+    int bsize = count > 1024 ? 1024 : (int) count;\n+    char[] buffer = new char[bsize];\n+    long todo = count;\n+    while (todo > 0)\n+      {\n+\tint skipped = read(buffer, 0, bsize > todo ? (int) todo : bsize);\n+\tif (skipped <= 0)\n+\t  break;\n+\ttodo -= skipped;\n+      }\n+    return count - todo;\n+  }\n+}"}, {"sha": "771351784ab2299f46f94371545122a1c7687d8e", "filename": "libjava/java/io/SequenceInputStream.java", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FSequenceInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FSequenceInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FSequenceInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,112 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+import java.util.Enumeration;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date November 3, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class SequenceInputStream extends InputStream\n+{\n+  /* The handle for the current input stream. */\n+  private InputStream in;\n+\n+  /* Secondary input stream; not used if constructed w/ enumeration. */\n+  private InputStream in2;\n+\n+  /* The enum handle; not used if constructed w/ 2 explicit input streams. */\n+  private Enumeration enum;\n+\n+  public SequenceInputStream(Enumeration e)\n+  {\n+    // FIXME: Assumes that enum contains only InputStreams.\n+    enum = e;\n+    in = (InputStream) enum.nextElement();\n+    in2 = null;\n+  }\n+\n+  public SequenceInputStream(InputStream s1, InputStream s2)\n+  {\n+    in = s1;\n+    in2 = s2;\n+  }\n+\n+  public int available() throws IOException\n+  {\n+    if (in == null)\n+      return 0;\n+\n+    return in.available();\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    while (in != null)\n+      {\n+\tin.close();\n+\tin = getNextStream ();\n+      }\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    int ch = -1;\n+\n+    while (in != null && (ch = in.read()) < 0)\n+      {\n+\tin.close();\n+        in = getNextStream();\n+      }\n+\n+    return ch;\n+  }\n+\n+  public int read(byte[] b, int off, int len) throws IOException\n+  {\n+    int ch = -1;\n+\n+    // The validity of the parameters will be checked by in.read so\n+    // don't bother doing it here.\n+    while (in != null && (ch = in.read(b, off, len)) < 0)\n+      {\n+\tin.close();\n+        in = getNextStream();\n+      }\n+\n+    return ch;\n+  }\n+\n+  private InputStream getNextStream()\n+  {\n+    InputStream nextIn = null;\n+\n+    // FIXME: Assumes that enum contains only InputStreams.\n+    if (enum != null)\n+      {\n+        if (enum.hasMoreElements())\n+\t  nextIn = (InputStream) enum.nextElement();\n+      }\n+    else\n+      if (in2 != null)\n+\t{\n+\t  nextIn = in2;\n+\t  in2 = null;\n+\t}\n+\n+    return nextIn;\n+  }\n+}"}, {"sha": "d4a31dbbad190619b4a23c726f82265a4f458479", "filename": "libjava/java/io/Serializable.java", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FSerializable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FSerializable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FSerializable.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,21 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date August 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * Status:  Believed complete\n+ */\n+\n+public interface Serializable\n+{\n+}"}, {"sha": "d518f83b98d308699f1f60ad235a96e05f953b17", "filename": "libjava/java/io/StreamTokenizer.java", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStreamTokenizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStreamTokenizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStreamTokenizer.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,433 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 25, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class StreamTokenizer\n+{\n+  /* A constant indicating that the end of the stream has been read. */\n+  public static final int TT_EOF = -1;\n+\n+  /* A constant indicating that the end of the line has been read. */\n+  public static final int TT_EOL = '\\n';\n+\n+  /* A constant indicating that a number token has been read. */\n+  public static final int TT_NUMBER = -2;\n+\n+  /* A constant indicating that a word token has been read. */\n+  public static final int TT_WORD = -3;\n+\n+  /* Contains the type of the token read resulting from a call to nextToken. */\n+  public int ttype;\n+\n+  /* The String associated with word and string tokens. */\n+  public String sval;\n+\n+  /* The numeric value associated with number tokens. */\n+  public double nval;\n+\n+  /* Indicates whether end-of-line is recognized as a token. */\n+  private boolean eolSignificant = false;\n+\n+  /* Indicates whether word tokens are automatically made lower case. */\n+  private boolean lowerCase = false;\n+\n+  /* Indicates whether C++ style comments are recognized and skipped. */\n+  private boolean slashSlash = false;\n+\n+  /* Indicates whether C style comments are recognized and skipped. */\n+  private boolean slashStar = false;\n+\n+  /* Attribute tables of each byte from 0x00 to 0xFF. */\n+  private boolean[] whitespace;\n+  private boolean[] alphabetic;\n+  private boolean[] numeric;\n+  private boolean[] quote;\n+  private boolean[] comment;\n+\n+  /* The Reader associated with this class. */\n+  private PushbackReader in;\n+\n+  /* Indicates if a token has been pushed back. */\n+  private boolean pushedBack = false;\n+\n+  /* Contains the current line number of the reader. */\n+  private int lineNumber = 1;\n+\n+  // Deprecated in JDK 1.1.\n+  public StreamTokenizer(InputStream is)\n+  {\n+    this(new InputStreamReader(is));\n+  }\n+\n+  public StreamTokenizer(Reader r)\n+  {\n+    in = new PushbackReader(r);\n+\n+    whitespace = new boolean[256];\n+    alphabetic = new boolean[256];\n+    numeric = new boolean[256];\n+    quote = new boolean[256];\n+    comment = new boolean[256];\n+    for (int i = 0; i < 256; i++)\n+      resetChar(i);\n+\n+    whitespaceChars(0x00, 0x20);\n+    wordChars('A', 'Z');\n+    wordChars('a', 'z');\n+    wordChars(0xA0, 0xFF);\n+    commentChar('/');\n+    quoteChar('\\'');\n+    quoteChar('\"');\n+    parseNumbers();\n+  }\n+\n+  public void commentChar(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      comment[ch] = true;\n+  }\n+\n+  public void eolIsSignificant(boolean flag)\n+  {\n+    eolSignificant = flag;\n+  }\n+\n+  public int lineno()\n+  {\n+    return lineNumber;\n+  }\n+\n+  public void lowerCaseMode(boolean flag)\n+  {\n+    lowerCase = flag;\n+  }\n+\n+  private boolean isWhitespace(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      return whitespace[ch];\n+\n+    return false;\n+  }\n+\n+  private boolean isAlphabetic(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      return alphabetic[ch];\n+    else if (ch > 255)\n+      return true;\n+\n+    return false;\n+  }\n+\n+  private boolean isNumeric(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      return numeric[ch];\n+\n+    return false;\n+  }\n+\n+  private boolean isQuote(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      return quote[ch];\n+\n+    return false;\n+  }\n+\n+  private boolean isComment(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      return comment[ch];\n+\n+    return false;\n+  }\n+\n+  public int nextToken() throws IOException\n+  {\n+    if (pushedBack)\n+      {\n+\tpushedBack = false;\n+\treturn ttype;\n+      }\n+\n+    sval = null;\n+    int ch;\n+\n+    // Skip whitespace.  Deal with EOL along the way.\n+    while (isWhitespace(ch = in.read()))\n+      if (ch == '\\n' || ch == '\\r')\n+\t{\n+\t  lineNumber++;\n+\n+\t  // Throw away \\n if in combination with \\r.\n+\t  if (ch == '\\r' && (ch = in.read()) != '\\n')\n+\t    in.unread(ch);\n+\t  if (eolSignificant)\n+\t    return (ttype = TT_EOL);\n+\t}\n+\n+    if (ch == TT_EOF)\n+      ttype = TT_EOF;\n+    else if (isNumeric(ch))\n+      {\n+\tif (ch == '-')\n+\t  {\n+\t    // Read ahead to see if this is an ordinary '-' rather than numeric.\n+\t    ch = in.read();\n+\t    in.unread(ch);\n+\t    if (isNumeric(ch) && ch != '-')\n+\t      ch = '-';\n+\t    else\n+\t      return (ttype = '-');\n+\t  }\n+\n+\tStringBuffer tokbuf = new StringBuffer();\n+\ttokbuf.append((char) ch);\n+\n+\tint decCount = 0;\n+\twhile (isNumeric(ch = in.read()) && ch != '-')\n+\t  if (ch == '.' && decCount++ > 0)\n+\t    break;\n+\t  else\n+\t    tokbuf.append((char) ch);\n+\n+\tin.unread(ch);\n+\tttype = TT_NUMBER;\n+\tnval = Double.valueOf(tokbuf.toString()).doubleValue();\n+      }\n+    else if (isAlphabetic(ch))\n+      {\n+\tStringBuffer tokbuf = new StringBuffer();\n+\ttokbuf.append((char) ch);\n+\twhile (isAlphabetic(ch = in.read()) || isNumeric(ch))\n+\t  tokbuf.append((char) ch);\n+\tin.unread(ch);\n+\tttype = TT_WORD;\n+\tsval = tokbuf.toString();\n+\tif (lowerCase)\n+\t  sval.toLowerCase();\n+      }\n+    else if (isComment(ch))\n+      {\n+\twhile ((ch = in.read()) != '\\n' && ch != '\\r' && ch != TT_EOF)\n+\t  ;\n+\tin.unread(ch);\n+\treturn nextToken();\t// Recursive, but not too deep in normal cases.\n+      }\n+    else if (isQuote(ch))\n+      {\n+\tttype = ch;\n+\tStringBuffer tokbuf = new StringBuffer();\n+\twhile ((ch = in.read()) != ttype && ch != '\\n' && ch != '\\r' &&\n+\t       ch != TT_EOF)\n+\t  {\n+\t    if (ch == '\\\\')\n+\t      switch (ch = in.read())\n+\t\t{\n+\t\t  case 'a':\tch = 0x7;\n+\t\t    break;\n+\t\t  case 'b':\tch = '\\b';\n+\t\t    break;\n+\t\t  case 'f':\tch = 0xC;\n+\t\t    break;\n+\t\t  case 'n':\tch = '\\n';\n+\t\t    break;\n+\t\t  case 'r':\tch = '\\r';\n+\t\t    break;\n+\t\t  case 't':\tch = '\\t';\n+\t\t    break;\n+\t\t  case 'v':\tch = 0xB;\n+\t\t    break;\n+\t\t  case '\\\"':\n+\t\t  case '\\'':\n+\t\t  case '\\\\':\n+\t\t    break;\n+\t\t  default:\n+\t\t    int ch1, nextch;\n+\t\t    if ((nextch = ch1 = ch) >= '0' && ch <= '7')\n+\t\t      {\n+\t\t        ch -= '0';\n+\t\t        if ((nextch = in.read()) >= '0' && nextch <= '7')\n+\t\t\t  {\n+\t\t\t    ch = ch * 8 + nextch - '0';\n+\t\t\t    if ((nextch = in.read()) >= '0' && nextch <= '7' &&\n+\t\t\t\tch1 >= '0' && ch1 <= '3')\n+\t\t\t      {\n+\t\t\t\tch = ch * 8 + nextch - '0';\n+\t\t\t\tnextch = in.read();\n+\t\t\t      }\n+\t\t\t  }\n+\t\t      }\n+\n+\t\t    in.unread(nextch);\n+\t\t}\n+\n+\t    tokbuf.append((char) ch);\n+\t  }\n+\n+\t// Throw away matching quote char.\n+\tif (ch != ttype)\n+\t  in.unread(ch);\n+\n+\tsval = tokbuf.toString();\n+      }\n+    else\n+      {\n+        if (ch == '/')\n+\t  if ((ch = in.read()) == '/' && slashSlash)\n+\t    {\n+\t      while ((ch = in.read()) != '\\n' && ch != '\\r' && ch != TT_EOF)\n+\t\t;\n+\t      in.unread(ch);\n+\t      return nextToken(); // Recursive, but not too deep in normal cases\n+\t    }\n+\t  else if (ch == '*' && slashStar) \n+\t    {\n+\t      while (true)\n+\t\t{\n+\t          ch = in.read();\n+\t\t  if (ch == '*')\n+\t\t    if ((ch = in.read()) == '/')\n+\t\t      break;\n+\t\t    else\n+\t\t      in.unread(ch);\n+\t\t  else if (ch == '\\n' || ch == '\\r')\n+\t\t    {\n+\t\t      lineNumber++;\n+\t\t      if (ch == '\\r' && (ch = in.read()) != '\\n')\n+\t\t\tin.unread(ch);\n+\t\t    }\n+\t\t  else if (ch == TT_EOF)\n+\t\t    {\n+\t\t      in.unread(ch);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      return nextToken(); // Recursive, but not too deep in normal cases\n+\t    }\n+\t  else\n+\t    {\n+\t      in.unread(ch);\n+\t      ch = '/';\n+\t    }\n+\n+\tttype = ch;\n+      }\n+\n+    return ttype;\n+  }\n+\n+  private void resetChar(int ch)\n+  {\n+    whitespace[ch] = alphabetic[ch] = numeric[ch] = quote[ch] = comment[ch] =\n+      false;\n+  }\n+\n+  public void ordinaryChar(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      resetChar(ch);\n+  }\n+\n+  public void ordinaryChars(int low, int hi)\n+  {\n+    if (low < 0)\n+      low = 0;\n+    if (hi > 255)\n+      hi = 255;\n+    for (int i = low; i <= hi; i++)\n+      resetChar(i);\n+  }\n+\n+  public void parseNumbers()\n+  {\n+    for (int i = 0; i <= 9; i++)\n+      numeric['0' + i] = true;\n+\n+    numeric['.'] = true;\n+    numeric['-'] = true;\n+  }\n+\n+  public void pushBack()\n+  {\n+    // pushBack may cause the lineno method to return an incorrect value\n+    // if lineno is called before the next call to nextToken.\n+    pushedBack = true;\n+  }\n+\n+  public void quoteChar(int ch)\n+  {\n+    if (ch >= 0 && ch <= 255)\n+      quote[ch] = true;\n+  }\n+\n+  public void resetSyntax()\n+  {\n+    ordinaryChars(0x00, 0xFF);\n+  }\n+\n+  public void slashSlashComments(boolean flag)\n+  {\n+    slashSlash = flag;\n+  }\n+\n+  public void slashStarComments(boolean flag)\n+  {\n+    slashStar = flag;\n+  }\n+\n+  public String toString()\n+  {\n+    String tempstr;\n+    if (ttype == TT_EOF)\n+      tempstr = \"EOF\";\n+    else if (ttype == TT_EOL)\n+      tempstr = \"EOL\";\n+    else if (ttype == TT_WORD)\n+      tempstr = sval;\n+    else if (ttype == TT_NUMBER)\n+      tempstr = \"n=\" + Double.toString(nval);\n+    else // must be an ordinary char.\n+      tempstr = \"\\'\" + (new Character((char) ttype)).toString() + \"\\'\";\n+\n+    return \"Token[\" + tempstr + \"], line \" + Integer.toString(lineno());\n+  }\n+\n+  public void whitespaceChars(int low, int hi)\n+  {\n+    if (low < 0)\n+      low = 0;\n+    if (hi > 255)\n+      hi = 255;\n+    for (int i = low; i <= hi; i++)\n+      whitespace[i] = true;\n+  }\n+\n+  public void wordChars(int low, int hi)\n+  {\n+    if (low < 0)\n+      low = 0;\n+    if (hi > 255)\n+      hi = 255;\n+    for (int i = low; i <= hi; i++)\n+      alphabetic[i] = true;\n+  }\n+}"}, {"sha": "19e89db592c5d9a29a9d12c4319eba50ddf40bbf", "filename": "libjava/java/io/StringBufferInputStream.java", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStringBufferInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStringBufferInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStringBufferInputStream.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,83 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date November 11, 1998.\n+ * @deprecated \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.  Deprecated in JDK 1.1.\n+ */\n+ \n+public class StringBufferInputStream extends InputStream\n+{\n+  /* The String which is the input to this stream. */\n+  protected String buffer;\n+\n+  /* Position of the next byte in buffer to be read. */\n+  protected int pos = 0;\n+\n+  /* The length of the String buffer. */\n+  protected int count;\n+\n+  public StringBufferInputStream(String s)\n+  {\n+    buffer = s;\n+    count = s.length();\n+  }\n+\n+  public int available()\n+  {\n+    return count - pos;\n+  }\n+\n+  public int read()\n+  {\n+    if (pos >= count)\n+      return -1;\t// EOF\n+\n+    return ((int) buffer.charAt(pos++)) & 0xFF;\n+  }\n+\n+  public int read(byte[] b, int off, int len)\n+  {\n+    if (off < 0 || len < 0 || off + len > b.length)\n+      throw new ArrayIndexOutOfBoundsException();\n+\n+    if (pos >= count)\n+      return -1;\t// EOF\n+\n+    int numRead = Math.min(len, count - pos);\n+    if (numRead < 0)\n+      return 0;\n+\n+    buffer.getBytes(pos, pos + numRead, b, off);\n+    pos += numRead;\n+    return numRead;\n+  }\n+\n+  public void reset()\n+  {\n+    pos = 0;\n+  }\n+\n+  public long skip(long n)\n+  {\n+    if (n < 0)\n+      return 0L;\n+\n+    long actualSkip = Math.min(n, count - pos);\n+    pos += actualSkip;\n+    return actualSkip;\n+  }\n+}"}, {"sha": "08e8d0c4f15779b314bb798ab797b329fe869e41", "filename": "libjava/java/io/StringReader.java", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStringReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStringReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStringReader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,139 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 19, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct\n+ */\n+ \n+public class StringReader extends Reader\n+{\n+  /* A String provided by the creator of the stream. */\n+  private String buf;\n+\n+  /* Position of the next char in buf to be read. */\n+  private int pos;\n+\n+  /* The currently marked position in the stream. */\n+  private int markedPos;\n+\n+  /* The index in buf one greater than the last valid character. */\n+  private int count;\n+\n+  public StringReader(String buffer)\n+  {\n+    super();\n+    buf = buffer;\n+\n+    count = buffer.length();\n+    markedPos = pos = 0;\n+  }\n+\n+  public void close()\n+  {\n+    synchronized (lock)\n+    {\n+      buf = null;\n+    }\n+  }\n+\n+  public void mark(int readAheadLimit) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      // readAheadLimit is ignored per Java Class Lib. book, p. 1692.\n+      markedPos = pos;\n+    }\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return true;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      if (pos < count)\n+        return ((int) buf.charAt(pos++)) & 0xFFFF;\n+      return -1;\n+    }\n+  }\n+\n+  public int read(char[] b, int off, int len) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      /* Don't need to check pos value, arraycopy will check it. */\n+      if (off < 0 || len < 0 || off + len > b.length)\n+        throw new ArrayIndexOutOfBoundsException();\n+\n+      if (pos >= count)\n+        return -1;\n+\n+      int lastChar = Math.min(count, pos + len);\n+      buf.getChars(pos, lastChar, b, off);\n+      int numChars = lastChar - pos;\n+      pos = lastChar;\n+      return numChars;\n+    }\n+  }\n+\n+  public boolean ready() // TODO12: throws IOException\n+  {\n+    // TODO12: The JCL specifically says this returns true even if the\n+    // reader has been closed, whereas the online 1.2 doc specifically\n+    // says to throw an IOException if closed.\n+    return true;\n+  }\n+\n+  public void reset() throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      pos = markedPos;\n+    }\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    synchronized (lock)\n+    {\n+      if (buf == null)\n+        throw new IOException();\n+\n+      // Even though the var numChars is a long, in reality it can never\n+      // be larger than an int since the result of subtracting 2 positive\n+      // ints will always fit in an int.  Since we have to return a long\n+      // anyway, numChars might as well just be a long.\n+      long numChars = Math.min((long) (count - pos), n < 0 ? 0L : n);\n+      pos += numChars;\n+      return numChars;\n+    }\n+  }\n+}"}, {"sha": "90ad9a9b6882a4f085f3d5d0f5b4a7c5360ba9e2", "filename": "libjava/java/io/StringWriter.java", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStringWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FStringWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStringWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,80 @@\n+// StringWriter.java - StringBuffer output stream\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 25, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class StringWriter extends Writer\n+{\n+  public void close ()\n+  {\n+    // JCL says this does nothing.  This seems to violate the Writer\n+    // contract, in that other methods should still throw and\n+    // IOException after a close.  Still, we just follow JCL.\n+  }\n+\n+  public void flush ()\n+  {\n+  }\n+\n+  public StringBuffer getBuffer ()\n+  {\n+    return buffer;\n+  }\n+\n+  public StringWriter ()\n+  {\n+    this (16);\n+  }\n+\n+  protected StringWriter (int size)\n+  {\n+    super ();\n+    buffer = new StringBuffer (size);\n+    lock = buffer;\n+  }\n+\n+  public String toString ()\n+  {\n+    return buffer.toString();\n+  }\n+\n+  public void write (int oneChar)\n+  {\n+    buffer.append((char) oneChar);\n+  }\n+\n+  public void write (char[] chars, int offset, int len)\n+  {\n+    buffer.append(chars, offset, len);\n+  }\n+\n+  public void write (String str)\n+  {\n+    buffer.append(str);\n+  }\n+\n+  public void write (String str, int offset, int len)\n+  {\n+    buffer.append(str.substring(offset, offset + len));\n+  }\n+\n+  // The string buffer.\n+  private StringBuffer buffer;\n+}"}, {"sha": "b920198edf6b305b38e4b6cbae938cd6975127c4", "filename": "libjava/java/io/SyncFailedException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FSyncFailedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FSyncFailedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FSyncFailedException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// SyncFailedException.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class SyncFailedException extends IOException\n+{\n+  public SyncFailedException ()\n+  {\n+    super ();\n+  }\n+\n+  public SyncFailedException (String s)\n+  {\n+    super (s);\n+  }\n+}"}, {"sha": "aea35401772cf6794ad252f08799f914456c2807", "filename": "libjava/java/io/UTFDataFormatException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FUTFDataFormatException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FUTFDataFormatException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FUTFDataFormatException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// UTFDataFormatException.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.io;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 24, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * Status:  Complete to 1.1.\n+ */\n+\n+public class UTFDataFormatException extends IOException\n+{\n+  public UTFDataFormatException ()\n+  {\n+    super ();\n+  }\n+\n+  public UTFDataFormatException (String s)\n+  {\n+    super (s);\n+  }\n+}"}, {"sha": "f3c26f9b316cb2cc9db23d973bb92a18735695bf", "filename": "libjava/java/io/UnsupportedEncodingException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FUnsupportedEncodingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FUnsupportedEncodingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FUnsupportedEncodingException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 17, 1998.  \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class UnsupportedEncodingException extends IOException\n+{\n+  public UnsupportedEncodingException ()\n+  {\n+    super();\n+  }\n+\n+  public UnsupportedEncodingException (String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "48cedb63114d9e53d8ef194791670d2a7c9decdc", "filename": "libjava/java/io/Writer.java", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FWriter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,67 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.io;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 17, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ * However, write(String, int, int) should be made a native method.\n+ */\n+\n+public abstract class Writer\n+{\n+  protected Object lock;\n+\n+  protected Writer ()\n+  {\n+    lock = this;\n+  }\n+\n+  protected Writer (Object lock)\n+  {\n+    this.lock = lock;\n+  }\n+\n+  abstract public void close() throws IOException;\n+\n+  abstract public void flush() throws IOException;\n+\n+  abstract public void write(char[] buf, int offset, int count)\n+     throws IOException;\n+\n+  public void write(char[] buf) throws IOException\n+  {\n+    write(buf, 0, buf.length);\n+  }\n+\n+  public void write(int ch) throws IOException\n+  {\n+    char[] buf = new char[1];\n+    buf[0] = (char) ch;\n+    write(buf, 0, 1);\n+  }\n+\n+  // FIXME - re-write using native code to not require copied buffer.\n+  public void write (String str, int offset, int count) throws IOException\n+  {\n+    char[] buf = new char[count];\n+    str.getChars(offset, offset + count, buf, 0);\n+    write(buf, 0, count);\n+  }\n+\n+  public void write (String str) throws IOException\n+  {\n+    write(str, 0, str.length());\n+  }\n+\n+}"}, {"sha": "40f227719e5f1a742ed4d42acc8b04cd2d309de7", "filename": "libjava/java/io/natFile.cc", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FnatFile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FnatFile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFile.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,273 @@\n+// natFile.cc - Native part of File class.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <sys/param.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <fcntl.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#include <stdlib.h>\n+#ifdef HAVE_DIRENT_H\n+#define _POSIX_PTHREAD_SEMANTICS\n+#ifndef _REENTRANT\n+#  define _REENTRANT\n+#endif\n+#include <dirent.h>\n+#endif\n+#include <string.h>\n+\n+#include <cni.h>\n+#include <jvm.h>\n+#include <java/io/File.h>\n+#include <java/io/IOException.h>\n+#include <java/util/Vector.h>\n+#include <java/lang/String.h>\n+#include <java/io/FilenameFilter.h>\n+#include <java/lang/System.h>\n+\n+jboolean\n+java::io::File::access (jstring canon, jint query)\n+{\n+  if (! canon)\n+    return false;\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+  JvAssert (query == READ || query == WRITE || query == EXISTS);\n+#ifdef HAVE_ACCESS\n+  int mode;\n+  if (query == READ)\n+    mode = R_OK;\n+  else if (query == WRITE)\n+    mode = W_OK;\n+  else\n+    mode = F_OK;\n+  return ::access (buf, mode) == 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+jboolean\n+java::io::File::stat (jstring canon, jint query)\n+{\n+  if (! canon)\n+    return false;\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+#ifdef HAVE_STAT\n+  struct stat sb;\n+  if (::stat (buf, &sb))\n+    return false;\n+  \n+  JvAssert (query == DIRECTORY || query == ISFILE);\n+  jboolean r = S_ISDIR (sb.st_mode);\n+  return query == DIRECTORY ? r : ! r;\n+#else\n+  return false;\n+#endif\n+}\n+\n+jlong\n+java::io::File::attr (jstring canon, jint query)\n+{\n+  if (! canon)\n+    return false;\n+\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+#ifdef HAVE_STAT\n+  struct stat sb;\n+  // FIXME: not sure about return value here.\n+  if (::stat (buf, &sb))\n+    return 0;\n+\n+  JvAssert (query == MODIFIED || query == LENGTH);\n+  // FIXME: time computation is very POSIX-specific -- POSIX and Java\n+  // have the same Epoch.\n+  return query == MODIFIED ? sb.st_mtime * 1000 : sb.st_size;\n+#else\n+  // There's no good choice here.\n+  return 23;\n+#endif\n+}\n+\n+jstring\n+java::io::File::getCanonicalPath (void)\n+{\n+  char buf[MAXPATHLEN], buf2[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+#ifdef HAVE_REALPATH\n+  if (realpath (buf, buf2) == NULL)\n+    _Jv_Throw (new IOException (JvNewStringLatin1 (strerror (errno))));\n+\n+  // FIXME: what encoding to assume for file names?  This affects many\n+  // calls.\n+  return JvNewStringUTF (buf2);\n+#else\n+  return JvNewStringUTF (buf);\n+#endif\n+}\n+\n+jboolean\n+java::io::File::isAbsolute (void)\n+{\n+  // FIXME: cpp define name.\n+  // FIXME: cygwin.\n+#ifdef WIN32\n+  if (path->charAt(0) == '/' || path->charAt(0) == '\\\\')\n+    return true;\n+  if (path->length() < 3)\n+    return false;\n+  // Hard-code A-Za-z because Windows (I think) can't use non-ASCII\n+  // letters as drive names.\n+  if ((path->charAt(0) < 'a' || path->charAt(0) > 'z')\n+      && (path->charAt(0) < 'A' || path->charAt(0) > 'Z'))\n+    return false;\n+  return (path->charAt(1) == ':'\n+\t  && (path->charAt(2) == '/' || path->charAt(2) == '\\\\'));\n+#else\n+  return path->charAt(0) == '/';\n+#endif\n+}\n+\n+#ifdef HAVE_DIRENT_H\n+#if defined(__JV_POSIX_THREADS__) && defined(HAVE_READDIR_R)\n+\n+static struct dirent *\n+get_entry (DIR *dir, struct dirent *e)\n+{\n+  struct dirent *r;\n+  if (readdir_r (dir, e, &r) || r == NULL)\n+    return NULL;\n+  return e;\n+}\n+\n+#else /* defined(__JV_POSIX_THREADS__) && defined(HAVE_READDIR_R) */\n+\n+static struct dirent *\n+get_entry (DIR *dir, struct dirent *)\n+{\n+  return readdir (dir);\n+}\n+\n+#endif /* defined(__JV_POSIX_THREADS__) && defined(HAVE_READDIR_R) */\n+#endif /* HAVE_DIRENT_H */\n+\n+jstringArray\n+java::io::File::performList (jstring canon, FilenameFilter *filter)\n+{\n+  if (! canon)\n+    return NULL;\n+\n+#ifdef HAVE_DIRENT_H\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+  DIR *dir = opendir (buf);\n+  if (! dir)\n+    return NULL;\n+\n+  java::util::Vector *vec = new java::util::Vector ();\n+  struct dirent *d, d2;\n+  while ((d = get_entry (dir, &d2)) != NULL)\n+    {\n+      if (! strcmp (d->d_name, \".\") || ! strcmp (d->d_name, \"..\"))\n+\tcontinue;\n+\n+      jstring name = JvNewStringUTF (d->d_name);\n+      if (filter && ! filter->accept(this, name))\n+\tcontinue;\n+\n+      vec->addElement(name);\n+    }\n+\n+  closedir (dir);\n+\n+  jobjectArray ret = JvNewObjectArray (vec->size(), canon->getClass(),\n+\t\t\t\t       NULL);\n+  vec->copyInto(ret);\n+  return reinterpret_cast<jstringArray> (ret);\n+#else /* HAVE_DIRENT_H */\n+  return NULL;\n+#endif /* HAVE_DIRENT_H */\n+}\n+\n+jboolean\n+java::io::File::performMkdir (void)\n+{\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+#ifdef HAVE_MKDIR\n+  // FIXME: mode.\n+  return ::mkdir (buf, 0755) == 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+jboolean\n+java::io::File::performRenameTo (File *dest)\n+{\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+  char buf2[MAXPATHLEN];\n+  total = JvGetStringUTFRegion (dest->path, 0, dest->path->length(), buf2);\n+  // FIXME?\n+  buf2[total] = '\\0';\n+\n+#ifdef HAVE_RENAME\n+  return ::rename (buf, buf2) == 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+jboolean\n+java::io::File::performDelete (jstring canon)\n+{\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+#ifdef HAVE_UNLINK\n+#ifdef HAVE_RMDIR\n+  if (! ::rmdir (buf))\n+    return true;\n+#endif // HAVE_RMDIR\n+  if (errno == ENOTDIR)\n+    return ::unlink (buf) == 0;\n+#endif // HAVE_UNLINK\n+  return false;\n+}"}, {"sha": "f2c3fb0db79a7a36c9a1ba468f1592170d18de03", "filename": "libjava/java/io/natFileDescriptorEcos.cc", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FnatFileDescriptorEcos.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FnatFileDescriptorEcos.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorEcos.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,132 @@\n+// natFileDescriptor.cc - Native part of FileDescriptor class.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <errno.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <sys/param.h>\n+\n+#include <cni.h>\n+#include <jvm.h>\n+#include <java/io/FileDescriptor.h>\n+#include <java/io/SyncFailedException.h>\n+#include <java/io/IOException.h>\n+#include <java/io/EOFException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/String.h>\n+#include <java/io/FileNotFoundException.h>\n+\n+extern \"C\" void diag_write_char (char c);\n+\n+static void \n+diag_write (char *data, int len)\n+{\n+  while (len > 0)\n+    {\n+      diag_write_char (*data++);\n+      len--;\n+    }\n+}\n+\n+#define NO_FSYNC_MESSAGE \"sync unsupported\"\n+\n+jboolean\n+java::io::FileDescriptor::valid (void)\n+{\n+  return true;\n+}\n+\n+void\n+java::io::FileDescriptor::sync (void)\n+{\n+  // Some files don't support fsync.  We don't bother reporting these\n+  // as errors.\n+#ifdef HAVE_FSYNC\n+#else\n+  JvThrow (new SyncFailedException (JvNewStringLatin1 (NO_FSYNC_MESSAGE)));\n+#endif\n+}\n+\n+jint\n+java::io::FileDescriptor::open (jstring path, jint jflags)\n+{\n+  return fd;\n+}\n+\n+void\n+java::io::FileDescriptor::write (jint b)\n+{\n+  char d = (char) b;\n+  ::diag_write (&d, 1);\n+}\n+\n+void\n+java::io::FileDescriptor::write (jbyteArray b, jint offset, jint len)\n+{\n+  if (! b)\n+    JvThrow (new java::lang::NullPointerException);\n+  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n+    JvThrow (new java::lang::ArrayIndexOutOfBoundsException);\n+  char *bytes = (char *)elements (b) + offset;\n+  ::diag_write (bytes, len);\n+}\n+\n+void\n+java::io::FileDescriptor::close (void)\n+{\n+}\n+\n+jint\n+java::io::FileDescriptor::seek (jlong pos, jint whence)\n+{\n+  JvAssert (whence == SET || whence == CUR);\n+\n+  jlong len = length ();\n+  jlong here = getFilePointer ();\n+\n+  if ((whence == SET && pos > len) || (whence == CUR && here + pos > len))\n+    JvThrow (new EOFException);\n+\n+  return 0;\n+}\n+\n+jlong\n+java::io::FileDescriptor::length (void)\n+{\n+  return 0;\n+}\n+\n+jlong\n+java::io::FileDescriptor::getFilePointer (void)\n+{\n+  return 0;\n+}\n+\n+jint\n+java::io::FileDescriptor::read (void)\n+{\n+  return 0;\n+}\n+\n+jint\n+java::io::FileDescriptor::read (jbyteArray buffer, jint offset, jint count)\n+{\n+  return 0;\n+}\n+\n+jint\n+java::io::FileDescriptor::available (void)\n+{\n+  return 0;\n+}"}, {"sha": "3efd8e4791b70e3d8b882aad3e29cd3ab6177d98", "filename": "libjava/java/io/natFileDescriptorPosix.cc", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FnatFileDescriptorPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fio%2FnatFileDescriptorPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorPosix.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,264 @@\n+// natFileDescriptor.cc - Native part of FileDescriptor class.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#include <errno.h>\n+#include <stdio.h>\n+#include <string.h>\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <sys/param.h>\n+#include <fcntl.h>\n+\n+#ifdef HAVE_SYS_IOCTL_H\n+#define BSD_COMP /* Get FIONREAD on Solaris2. */\n+#include <sys/ioctl.h>\n+#endif\n+\n+// Pick up FIONREAD on Solaris 2.5.\n+#ifdef HAVE_SYS_FILIO_H\n+#include <sys/filio.h>\n+#endif\n+\n+#include <cni.h>\n+#include <jvm.h>\n+#include <java/io/FileDescriptor.h>\n+#include <java/io/SyncFailedException.h>\n+#include <java/io/IOException.h>\n+#include <java/io/InterruptedIOException.h>\n+#include <java/io/EOFException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/String.h>\n+#include <java/lang/Thread.h>\n+#include <java/io/FileNotFoundException.h>\n+\n+#define NO_FSYNC_MESSAGE \"sync unsupported\"\n+\n+jboolean\n+java::io::FileDescriptor::valid (void)\n+{\n+  struct stat sb;\n+  return ::fstat (fd, &sb) == 0;\n+}\n+\n+void\n+java::io::FileDescriptor::sync (void)\n+{\n+  // Some files don't support fsync.  We don't bother reporting these\n+  // as errors.\n+#ifdef HAVE_FSYNC\n+  if (::fsync (fd) && errno != EROFS && errno != EINVAL)\n+    JvThrow (new SyncFailedException (JvNewStringLatin1 (strerror (errno))));\n+#else\n+  JvThrow (new SyncFailedException (JvNewStringLatin1 (NO_FSYNC_MESSAGE)));\n+#endif\n+}\n+\n+jint\n+java::io::FileDescriptor::open (jstring path, jint jflags)\n+{\n+  // FIXME: eww.\n+  char buf[MAXPATHLEN];\n+  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+  int flags = 0;\n+#ifdef O_BINARY\n+  flags |= O_BINARY;\n+#endif\n+\n+  JvAssert ((jflags & READ) || (jflags & WRITE));\n+  if ((jflags & READ) && (jflags & WRITE))\n+    flags |= O_RDWR;\n+  else if ((jflags & READ))\n+    flags |= O_RDONLY;\n+  else\n+    {\n+      flags |= O_WRONLY | O_CREAT;\n+      if ((jflags & APPEND))\n+\tflags |= O_APPEND;\n+      else\n+\tflags |= O_TRUNC;\n+    }\n+\n+  // FIXME: mode?\n+  int fd = ::open (buf, flags, 0755);\n+  if (fd == -1)\n+    {\n+      char msg[MAXPATHLEN + 200];\n+      sprintf (msg, \"%s: %s\", buf, strerror (errno));\n+      JvThrow (new FileNotFoundException (JvNewStringLatin1 (msg)));\n+    }\n+  return fd;\n+}\n+\n+void\n+java::io::FileDescriptor::write (jint b)\n+{\n+  jbyte d = (jbyte) b;\n+  int r = ::write (fd, &d, 1);\n+  if (java::lang::Thread::interrupted())\n+    {\n+      InterruptedIOException *iioe\n+\t= new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n+      iioe->bytesTransferred = r == -1 ? 0 : r;\n+      JvThrow (iioe);\n+    }\n+  else if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  // FIXME: loop if r != 1.\n+}\n+\n+void\n+java::io::FileDescriptor::write (jbyteArray b, jint offset, jint len)\n+{\n+  if (! b)\n+    JvThrow (new java::lang::NullPointerException);\n+  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n+    JvThrow (new java::lang::ArrayIndexOutOfBoundsException);\n+  jbyte *bytes = elements (b) + offset;\n+  int r = ::write (fd, bytes, len);\n+  if (java::lang::Thread::interrupted())\n+    {\n+      InterruptedIOException *iioe\n+\t= new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n+      iioe->bytesTransferred = r == -1 ? 0 : r;\n+      JvThrow (iioe);\n+    }\n+  else if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  // FIXME: loop if r != len.\n+}\n+\n+void\n+java::io::FileDescriptor::close (void)\n+{\n+  jint save = fd;\n+  fd = -1;\n+  if (::close (save))\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+}\n+\n+jint\n+java::io::FileDescriptor::seek (jlong pos, jint whence)\n+{\n+  JvAssert (whence == SET || whence == CUR);\n+\n+  jlong len = length ();\n+  jlong here = getFilePointer ();\n+\n+  if ((whence == SET && pos > len) || (whence == CUR && here + pos > len))\n+    JvThrow (new EOFException);\n+\n+  off_t r = ::lseek (fd, (off_t) pos, whence == SET ? SEEK_SET : SEEK_CUR);\n+  if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  return r;\n+}\n+\n+jlong\n+java::io::FileDescriptor::length (void)\n+{\n+  struct stat sb;\n+  if (::fstat (fd, &sb))\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  return sb.st_size;\n+}\n+\n+jlong\n+java::io::FileDescriptor::getFilePointer (void)\n+{\n+  off_t r = ::lseek (fd, 0, SEEK_CUR);\n+  if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  return r;\n+}\n+\n+jint\n+java::io::FileDescriptor::read (void)\n+{\n+  jbyte b;\n+  int r = ::read (fd, &b, 1);\n+  if (r == 0)\n+    return -1;\n+  if (java::lang::Thread::interrupted())\n+    {\n+      InterruptedIOException *iioe\n+\t= new InterruptedIOException (JvNewStringLatin1 (\"read interrupted\"));\n+      iioe->bytesTransferred = r == -1 ? 0 : r;\n+      JvThrow (iioe);\n+    }\n+  else if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  return b & 0xFF;\n+}\n+\n+jint\n+java::io::FileDescriptor::read (jbyteArray buffer, jint offset, jint count)\n+{\n+  if (! buffer)\n+    JvThrow (new java::lang::NullPointerException);\n+  jsize bsize = JvGetArrayLength (buffer);\n+  if (offset < 0 || count < 0 || offset + count > bsize)\n+    JvThrow (new java::lang::ArrayIndexOutOfBoundsException);\n+  jbyte *bytes = elements (buffer) + offset;\n+  int r = ::read (fd, bytes, count);\n+  if (r == 0)\n+    return -1;\n+  if (java::lang::Thread::interrupted())\n+    {\n+      InterruptedIOException *iioe\n+\t= new InterruptedIOException (JvNewStringLatin1 (\"read interrupted\"));\n+      iioe->bytesTransferred = r == -1 ? 0 : r;\n+      JvThrow (iioe);\n+    }\n+  else if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  return r;\n+}\n+\n+jint\n+java::io::FileDescriptor::available (void)\n+{\n+#if defined (FIONREAD)\n+  long num;\n+  int r = ::ioctl (fd, FIONREAD, &num);\n+  if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  return (jint) num;\n+#elif defined (HAVE_SELECT)\n+  int r = -1;\n+  if (fd < 0)\n+    errno = EBADF;\n+  else\n+    {\n+      fd_set rd;\n+      FD_ZERO (&rd);\n+      FD_SET (fd, &rd);\n+      struct timeval tv;\n+      tv.tv_sec = 0;\n+      tv.tv_usec = 0;\n+      r = ::select (fd + 1, &rd, NULL, NULL, &tv);\n+    }\n+  if (r == -1)\n+    JvThrow (new IOException (JvNewStringLatin1 (strerror (errno))));\n+  return r == 0 ? 0 : 1;\n+#else\n+  JvThrow (new IOException (JvNewStringLatin1 (\"unimplemented\")));\n+#endif\n+}"}, {"sha": "b1751e2e0f1359f35ecb6f83015447e01e24b019", "filename": "libjava/java/lang/AbstractMethodError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FAbstractMethodError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FAbstractMethodError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FAbstractMethodError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// AbstractMethodError.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998\n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class AbstractMethodError extends IncompatibleClassChangeError\n+{\n+  public AbstractMethodError ()\n+  {\n+    super ();\n+  }\n+\n+  public AbstractMethodError (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "def8c82be77aba3fd0928ac516394ed37c0a6909", "filename": "libjava/java/lang/ArithmeticException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FArithmeticException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FArithmeticException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FArithmeticException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class ArithmeticException extends RuntimeException\n+{\n+  public ArithmeticException()\n+  {\n+    super();\n+  }\n+\n+  public ArithmeticException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "e66b6d7189b073762d84ac2c962fad3cd8a4b6e4", "filename": "libjava/java/lang/ArrayIndexOutOfBoundsException.java", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FArrayIndexOutOfBoundsException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FArrayIndexOutOfBoundsException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FArrayIndexOutOfBoundsException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException\n+{\n+  public ArrayIndexOutOfBoundsException()\n+  {\n+    super();\n+  }\n+\n+  public ArrayIndexOutOfBoundsException(int index)\n+  {\n+    this(\"Array index out of range: \" + index);\n+  }\n+\n+  public ArrayIndexOutOfBoundsException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "7b9ede6ff251be1d9e28ec195bdf5d425b594172", "filename": "libjava/java/lang/ArrayStoreException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FArrayStoreException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FArrayStoreException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FArrayStoreException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class ArrayStoreException extends RuntimeException\n+{\n+  public ArrayStoreException()\n+  {\n+    super();\n+  }\n+\n+  public ArrayStoreException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "78ab77ff81a8249f33331024f7279c868de5059a", "filename": "libjava/java/lang/Boolean.java", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FBoolean.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FBoolean.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FBoolean.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,95 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+\n+import java.io.Serializable;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 3, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public final class Boolean extends Object implements Serializable\n+{\n+  public static final Boolean FALSE = new Boolean(false);\n+  public static final Boolean TRUE = new Boolean(true);\n+\n+  // This initialization is seemingly circular, but it is accepted\n+  // by javac, and is handled specially by gcc.\n+  public static final Class TYPE = boolean.class;\n+\n+  /* The boolean value of the instance. */\n+  private boolean value;\n+\n+  public Boolean(boolean boolVal)\n+  {\n+    value = boolVal;\n+  }\n+\n+  public Boolean(String strVal)\n+  {\n+    value = strVal.equalsIgnoreCase(\"true\");\n+  }\n+\n+  public boolean booleanValue()\n+  {\n+    return value;\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    /* Don't need to compare obj to null as instanceof will do this. */\n+    if (obj instanceof Boolean)\n+      return value == ((Boolean) obj).value;\n+    return false;\n+  }\n+\n+  public static boolean getBoolean(String property)\n+  {\n+    /* TBD: If a security manager exists and it doesn't permit accessing\n+     * the property, it will throw an exception.  Should we catch it?\n+     */\n+    try\n+      {\n+\tString val = System.getProperty(property);\n+\treturn val == null ? false : val.equalsIgnoreCase(\"true\");\n+      }\n+    catch (SecurityException e)\n+      {\n+        return false;\n+      }\n+  }\n+\n+  public int hashCode()\n+  {\n+    /* These values are from the Java Lang. Spec. (Sec 20.4.7).\n+     * TBD: They could be made private static final fields but they're only\n+     * used here (and shouldn't be used anywhere else), though it might be\n+     * useful to grep on something like JAVA_HASH_* values for us as\n+     * developers.\n+     */\n+    return value ? 1231 : 1237;\n+  }\n+\n+  public String toString()\n+  {\n+    return value ? \"true\" : \"false\";\n+  }\n+\n+  public static Boolean valueOf(String str)\n+  {\n+    /* This returns a Boolean (big B), not a boolean (little b). */\n+    return str.equalsIgnoreCase(\"true\") ? TRUE : FALSE;\n+  }\n+}"}, {"sha": "f3ec40206711573a939d1c3b5406f766daae9e42", "filename": "libjava/java/lang/Byte.java", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FByte.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FByte.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FByte.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,144 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.lang;\n+\n+/**\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @date April 17, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ *\t    Includes JDK 1.2 methods.\n+ */\n+\n+public final class Byte extends Number implements Comparable\n+{\n+  byte value;\n+\n+  public final static byte MIN_VALUE = -128;\n+  public final static byte MAX_VALUE = 127;\n+\n+  // This initialization is seemingly circular, but it is accepted\n+  // by javac, and is handled specially by gcc.\n+  public static final Class TYPE = byte.class;\n+\n+  public Byte(byte value)\n+  {\n+    this.value = value;\n+  }\n+\n+  public Byte(String str) \n+    throws NumberFormatException\n+  {\n+    this.value = parseByte(str, 10);\n+  }\n+\n+  public byte byteValue()\n+  {\n+    return value;\n+  }\n+\n+  public short shortValue()\n+  {\n+    return value;\n+  }\n+\n+  public int intValue()\n+  {\n+    return value;\n+  }\n+\n+  public long longValue ()\n+  {\n+    return value;\n+  }\n+\n+  public float floatValue ()\n+  {\n+    return (float) value;\n+  }\n+\n+  public double doubleValue ()\n+  {\n+    return (double) value;\n+  }\n+\n+  public static Byte decode(String str)\n+    throws NumberFormatException\n+  {\n+    int i = (Integer.decode(str)).intValue();\n+    if (i < MIN_VALUE || i > MAX_VALUE)\n+      throw new NumberFormatException();\n+    return new Byte((byte) i);\n+  }\n+\n+  public static byte parseByte(String str, int radix)\n+    throws NumberFormatException\n+  {\n+    int i = Integer.parseInt(str, radix);\n+    if (i < MIN_VALUE || i > MAX_VALUE)\n+      throw new NumberFormatException();\n+    return (byte) i;\n+  }\n+\n+  public static byte parseByte(String str)\n+    throws NumberFormatException\n+  {\n+    return parseByte(str, 10);\n+  }\n+\n+  public static Byte valueOf(String str, int radix)\n+    throws NumberFormatException\n+  {\n+    return new Byte(parseByte(str, radix));\n+  }\n+\n+  public static Byte valueOf(String str)\n+    throws NumberFormatException\n+  {\n+    return valueOf(str, 10);\n+  }\n+\n+  // Added in JDK 1.2\n+  public int compareTo(Byte anotherByte)\n+  {\n+    return this.value - anotherByte.value;\n+  }\n+\n+  // Added in JDK 1.2\n+  public int compareTo(Object o) throws ClassCastException\n+  {\n+    if (o instanceof Byte)\n+      return this.value - ((Byte) o).value;\n+    else\n+      throw new ClassCastException();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    return obj != null && (obj instanceof Byte) && ((Byte)obj).value == value;\n+  }\n+\n+  // Verified that hashCode is returns plain value (see Boolean_1 test).\n+  public int hashCode()\n+  {\n+    return value;\n+  }\n+\n+  public String toString()\n+  {\n+    return Integer.toString((int) value);\n+  }\n+\n+  public static String toString(byte value)\n+  {\n+    return Integer.toString((int) value);\n+  }\n+}"}, {"sha": "c7dd052e0c04d287eb9fcfc931887ebcc8968a75", "filename": "libjava/java/lang/Character.java", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCharacter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCharacter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,286 @@\n+// Character.java - Character class.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.lang;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date September 10, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1,\n+ * online API docs for JDK 1.2 beta from http://www.javasoft.com,\n+ * and The Unicode Standard Version 2.0.\n+ * Status: Believed complete and correct for JDK 1.1; 1.2 methods\n+ * unimplemented.\n+ */\n+\n+public final class Character implements Serializable, Comparable\n+{\n+  public static final char MIN_VALUE = '\\u0000';\n+  public static final char MAX_VALUE = '\\uffff';\n+\n+  public static final int MIN_RADIX = 2;\n+  public static final int MAX_RADIX = 36;\n+\n+  // This initialization is seemingly circular, but it is accepted\n+  // by javac, and is handled specially by gcc.\n+  public static final Class TYPE = char.class;\n+\n+  // Space.\n+  public static final byte SPACE_SEPARATOR     = 12;\n+  public static final byte LINE_SEPARATOR      = 13;\n+  public static final byte PARAGRAPH_SEPARATOR = 14;\n+\n+  // Letters.\n+  public static final byte UPPERCASE_LETTER = 1;\n+  public static final byte LOWERCASE_LETTER = 2;\n+  public static final byte TITLECASE_LETTER = 3;\n+  public static final byte MODIFIER_LETTER  = 4;\n+  public static final byte OTHER_LETTER     = 5;\n+\n+  // Numbers.\n+  public static final byte DECIMAL_DIGIT_NUMBER =  9;\n+  public static final byte LETTER_NUMBER        = 10;\n+  public static final byte OTHER_NUMBER         = 11;\n+\n+  // Marks.\n+  public static final byte NON_SPACING_MARK     = 6;\n+  public static final byte ENCLOSING_MARK       = 7;\n+  public static final byte COMBINING_SPACING_MARK = 8;\n+\n+  // Punctuation.\n+  public static final byte DASH_PUNCTUATION      = 20;\n+  public static final byte START_PUNCTUATION     = 21;\n+  public static final byte END_PUNCTUATION       = 22;\n+  public static final byte CONNECTOR_PUNCTUATION = 23;\n+  public static final byte OTHER_PUNCTUATION     = 24;\n+\n+  // Symbols.\n+  public static final byte MATH_SYMBOL     = 25;\n+  public static final byte CURRENCY_SYMBOL = 26;\n+  public static final byte MODIFIER_SYMBOL = 27;\n+  public static final byte OTHER_SYMBOL    = 28;\n+\n+  // Format controls.\n+  public static final byte CONTROL = 15;\n+  // Note: The JCL book says that both FORMAT and PRIVATE_USE are 18.\n+  // However, FORMAT is actually 16.\n+  public static final byte FORMAT  = 16;\n+\n+  // Others.\n+  public static final byte UNASSIGNED  = 0;\n+  public static final byte PRIVATE_USE = 18;\n+  public static final byte SURROGATE   = 19;\n+\n+\n+  public Character (char ch)\n+  {\n+    value = ch;\n+  }\n+\n+  public char charValue ()\n+  {\n+    return value;\n+  }\n+\n+  // See if a character is a digit.  If so, return the corresponding\n+  // value.  Otherwise return -1.\n+  private static native int digit_value (char ch);\n+\n+  public static int digit (char ch, int radix)\n+  {\n+    if (radix < MIN_RADIX || radix > MAX_RADIX)\n+      return -1;\n+\n+    int d = digit_value (ch);\n+    if (d == -1)\n+      {\n+\tif (ch >= 'A' && ch <= 'Z')\n+\t  d = ch - 'A' + 10;\n+\telse if (ch >= 'a' && ch <= 'z')\n+\t  d = ch - 'a' + 10;\n+\telse\n+\t  return -1;\n+      }\n+    return d >= radix ? -1 : d;\n+  }\n+\n+  public boolean equals (Object obj)\n+  {\n+    // Don't need to compare OBJ to null as instanceof will do this.\n+    if (obj instanceof Character)\n+      return value == ((Character) obj).value;\n+    return false;\n+  }\n+\n+  public static char forDigit (int d, int rdx)\n+  {\n+    if (d < 0 || d >= rdx || rdx < MIN_RADIX || rdx > MAX_RADIX)\n+      return '\\u0000';\n+    if (d < 10)\n+      return (char) ('0' + d);\n+    // The Java Language Spec says to use lowercase, while the JCL\n+    // says to use uppercase.  We go with the former.\n+    return (char) ('a' + d - 10);\n+  }\n+\n+  public static native int getNumericValue (char ch);\n+  public static native int getType (char ch);\n+\n+  public int hashCode ()\n+  {\n+    return value;\n+  }\n+\n+  public static boolean isDefined (char ch)\n+  {\n+    return getType (ch) != UNASSIGNED;\n+  }\n+\n+  public static boolean isDigit (char ch)\n+  {\n+    return digit_value (ch) != -1;\n+  }\n+\n+  // The JCL book says that the argument here is a Character.  That is\n+  // wrong.\n+  public static boolean isIdentifierIgnorable (char ch)\n+  {\n+    // This information comes from the Unicode Standard.  It isn't\n+    // auto-generated as it doesn't appear in the unidata table.\n+    return ((ch >= '\\u0000' && ch <= '\\u0008')\n+\t    || (ch >= '\\u000e' && ch <= '\\u001b')\n+\t    // JDK 1.2 docs say that these are ignorable.  The Unicode\n+\t    // Standard is somewhat ambiguous on this issue.\n+\t    || (ch >= '\\u007f' && ch <= '\\u009f')\n+\t    || (ch >= '\\u200c' && ch <= '\\u200f')\n+\t    // JCl says 200a through 200e, but that is a typo.  The\n+\t    // Unicode standard says the bidi controls are 202a\n+\t    // through 202e.\n+\t    || (ch >= '\\u202a' && ch <= '\\u202e')\n+\t    || (ch >= '\\u206a' && ch <= '\\u206f')\n+\t    || ch == '\\ufeff');\n+  }\n+\n+  public static boolean isISOControl (char c)\n+  {\n+    return ((c >= '\\u0000' && c <= '\\u001f')\n+\t    || (c >= '\\u007f' && c <= '\\u009f'));\n+  }\n+\n+  public static boolean isJavaIdentifierPart (char ch)\n+  {\n+    if (isIdentifierIgnorable (ch) || isDigit (ch))\n+      return true;\n+    int type = getType (ch);\n+    return (type == COMBINING_SPACING_MARK || type == NON_SPACING_MARK\n+\t    || type == CURRENCY_SYMBOL || type == CONNECTOR_PUNCTUATION\n+\t    || type == UPPERCASE_LETTER || type == LOWERCASE_LETTER\n+\t    || type == TITLECASE_LETTER || type == MODIFIER_LETTER\n+\t    || type == OTHER_LETTER || type == LETTER_NUMBER);\n+  }\n+\n+  public static boolean isJavaIdentifierStart (char ch)\n+  {\n+    int type = getType (ch);\n+    return (type == CURRENCY_SYMBOL || type == CONNECTOR_PUNCTUATION\n+\t    || type == UPPERCASE_LETTER || type == LOWERCASE_LETTER\n+\t    || type == TITLECASE_LETTER || type == MODIFIER_LETTER\n+\t    || type == OTHER_LETTER);\n+  }\n+\n+  // Deprecated in 1.2.\n+  public static boolean isJavaLetter (char ch)\n+  {\n+    return ch == '$' || ch == '_' || isLetter (ch);\n+  }\n+\n+  // Deprecated in 1.2.\n+  public static boolean isJavaLetterOrDigit (char ch)\n+  {\n+    return ch == '$' || ch == '_' || isLetterOrDigit (ch);\n+  }\n+\n+  public static boolean isLetter (char ch)\n+  {\n+    int type = getType (ch);\n+    return (type == UPPERCASE_LETTER || type == LOWERCASE_LETTER\n+\t    || type == TITLECASE_LETTER || type == MODIFIER_LETTER\n+\t    || type == OTHER_LETTER);\n+  }\n+\n+  public static boolean isLetterOrDigit (char ch)\n+  {\n+    return isDigit (ch) || isLetter (ch);\n+  }\n+\n+  public static native boolean isLowerCase (char ch);\n+\n+  // Deprecated in JCL.\n+  public static boolean isSpace (char ch)\n+  {\n+    return ch == '\\n' || ch == '\\t' || ch == '\\f' || ch == '\\r' || ch == ' ';\n+  }\n+\n+  public static native boolean isSpaceChar (char ch);\n+  public static native boolean isTitleCase (char ch);\n+\n+  public static boolean isUnicodeIdentifierPart (char ch)\n+  {\n+    if (isIdentifierIgnorable (ch) || isDigit (ch))\n+      return true;\n+    int type = getType (ch);\n+    return (type == CONNECTOR_PUNCTUATION || type == LETTER_NUMBER\n+\t    || type == COMBINING_SPACING_MARK || type == NON_SPACING_MARK\n+\t    || type == UPPERCASE_LETTER || type == LOWERCASE_LETTER\n+\t    || type == TITLECASE_LETTER || type == MODIFIER_LETTER\n+\t    || type == OTHER_LETTER);\n+  }\n+\n+  public static boolean isUnicodeIdentifierStart (char ch)\n+  {\n+    return isLetter (ch);\n+  }\n+\n+  public static native boolean isUpperCase (char ch);\n+\n+  public static boolean isWhitespace (char ch)\n+  {\n+    return ((ch >= '\\u0009' && ch <= '\\r')\n+\t    || (ch >= '\\u001c' && ch <= '\\u001f')\n+\t    || (ch != '\\u00a0' && ch != '\\ufeff' && isSpaceChar (ch)));\n+  }\n+\n+  public static native char toLowerCase (char ch);\n+  public static native char toTitleCase (char ch);\n+  public static native char toUpperCase (char ch);\n+\n+  public String toString ()\n+  {\n+    return String.valueOf(value);\n+  }\n+\n+  public int compareTo (Character anotherCharacter)\n+  {\n+    return value - anotherCharacter.value;\n+  }\n+\n+  public int compareTo (Object o)\n+  {\n+    return compareTo ((Character) o);\n+  }\n+\n+  // Private data.\n+  private char value;\n+}"}, {"sha": "eb0a2f9553330e9ccbc8cc016100310659e4eb98", "filename": "libjava/java/lang/Class.h", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,214 @@\n+// Class.h - Header file for java.lang.Class.  -*- c++ -*-\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Written primary using compiler source and Class.java as guides.\n+#ifndef __JAVA_LANG_CLASS_H__\n+#define __JAVA_LANG_CLASS_H__\n+\n+#pragma interface\n+\n+#include <java/lang/Object.h>\n+#include <java/lang/String.h>\n+\n+// We declare these here to avoid including cni.h.\n+extern \"C\" void _Jv_InitClass (jclass klass);\n+extern \"C\" void _Jv_RegisterClasses (jclass *classes);\n+\n+struct _Jv_Field;\n+struct _Jv_VTable;\n+\n+#define CONSTANT_Class 7\n+#define CONSTANT_Fieldref 9\n+#define CONSTANT_Methodref 10\n+#define CONSTANT_InterfaceMethodref 11\n+#define CONSTANT_String 8\n+#define CONSTANT_Integer 3\n+#define CONSTANT_Float 4\n+#define CONSTANT_Long 5\n+#define CONSTANT_Double 6\n+#define CONSTANT_NameAndType 12\n+#define CONSTANT_Utf8 1\n+#define CONSTANT_Unicode 2\n+#define CONSTANT_ResolvedFlag 16\n+#define CONSTANT_ResolvedString    (CONSTANT_String+CONSTANT_ResolvedFlag)\n+#define CONSTANT_ResolvedClass     (CONSTANT_Class+CONSTANT_ResolvedFlag)\n+\n+struct _Jv_Constants\n+{\n+  jint size;\n+  jbyte *tags;\n+  void **data;\n+};\n+\n+struct _Jv_Method\n+{\n+  _Jv_Utf8Const *name;\n+  _Jv_Utf8Const *signature;\n+  unsigned short accflags;\n+  void *ncode;\n+};\n+\n+#define JV_PRIMITIVE_VTABLE ((_Jv_VTable *) -1)\n+\n+class java::lang::Class : public java::lang::Object\n+{\n+public:\n+  static jclass forName (jstring className);\n+  JArray<jclass> *getClasses (void);\n+\n+  java::lang::ClassLoader *getClassLoader (void)\n+    {\n+      return loader;\n+    }\n+\n+  jclass getComponentType (void)\n+    {\n+      return isArray () ? (* (jclass *) &methods) : 0;\n+    }\n+\n+  java::lang::reflect::Constructor *getConstructor (JArray<jclass> *);\n+  JArray<java::lang::reflect::Constructor *> *getConstructors (void);\n+  java::lang::reflect::Constructor *getDeclaredConstructor (JArray<jclass> *);\n+  JArray<java::lang::reflect::Constructor *> *getDeclaredConstructors (void);\n+  java::lang::reflect::Field *getDeclaredField (jstring);\n+  JArray<java::lang::reflect::Field *> *getDeclaredFields (void);\n+  java::lang::reflect::Method *getDeclaredMethod (jstring, JArray<jclass> *);\n+  JArray<java::lang::reflect::Method *> *getDeclaredMethods (void);\n+\n+  JArray<jclass> *getDeclaredClasses (void);\n+  jclass getDeclaringClass (void);\n+\n+  java::lang::reflect::Field *getField (jstring);\n+private:\n+  java::lang::reflect::Field *getField (jstring, jint);\n+public:\n+  JArray<java::lang::reflect::Field *> *getFields (void);\n+\n+  JArray<jclass> *getInterfaces (void);\n+\n+  java::lang::reflect::Method *getMethod (jstring, JArray<jclass> *);\n+  JArray<java::lang::reflect::Method *> *getMethods (void);\n+\n+  jint getModifiers (void)\n+    {\n+      return accflags;\n+    }\n+\n+  jstring getName (void);\n+\n+  java::io::InputStream *getResourceAsStream (jstring resourceName);\n+  JArray<jobject> *getSigners (void);\n+\n+  jclass getSuperclass (void)\n+    {\n+      return superclass;\n+    }\n+\n+  jboolean isArray (void)\n+    {\n+      return name->data[0] == '[';\n+    }\n+\n+  jboolean isAssignableFrom (jclass cls);\n+  jboolean isInstance (jobject obj);\n+  jboolean isInterface (void);\n+\n+  jboolean isPrimitive (void)\n+    {\n+      return vtable == JV_PRIMITIVE_VTABLE;\n+    }\n+\n+  jobject newInstance (void);\n+  jstring toString (void);\n+\n+  // FIXME: this probably shouldn't be public.\n+  jint size (void)\n+    {\n+      return size_in_bytes;\n+    }\n+\n+private:\n+  void checkMemberAccess (jint flags);\n+  void resolveConstants (void);\n+\n+  // Various functions to handle class initialization.\n+  java::lang::Throwable *hackTrampoline (jint, java::lang::Throwable *);\n+  void hackRunInitializers (void);\n+  void initializeClass (void);\n+\n+  // Friend functions implemented in natClass.cc.\n+  friend _Jv_Method *_Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n+\t\t\t\t\t _Jv_Utf8Const *signature);\n+  friend void _Jv_InitClass (jclass klass);\n+  friend void _Jv_RegisterClasses (jclass *classes);\n+  friend jclass _Jv_FindClassInCache (_Jv_Utf8Const *name,\n+\t\t\t\t      java::lang::ClassLoader *loader);\n+  friend jclass _Jv_FindArrayClass (jclass element);\n+  friend jclass _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n+\t\t\t      java::lang::ClassLoader *loader);\n+\n+  friend jfieldID JvGetFirstInstanceField (jclass);\n+  friend jint JvNumInstanceFields (jclass);\n+  friend jobject _Jv_AllocObject (jclass, jint);\n+  friend jobjectArray _Jv_NewObjectArray (jsize, jclass, jobject);\n+  friend jobject _Jv_NewPrimArray (jclass, jint);\n+  friend jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv *, jclass, jfieldID);\n+  friend jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);\n+  friend jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);\n+\n+  friend class _Jv_PrimClass;\n+\n+#ifdef JV_MARKOBJ_DECL\n+  friend JV_MARKOBJ_DECL;\n+#endif\n+\n+  // Chain for class pool.\n+  jclass next;\n+  // Name of class.\n+  _Jv_Utf8Const *name;\n+  // Access flags for class.\n+  unsigned short accflags;\n+  // The superclass, or null for Object.\n+  jclass superclass;\n+  // Class constants.\n+  _Jv_Constants constants;\n+  // Methods.  If this is an array class, then this field holds a\n+  // pointer to the element type.  If this is a primitive class, this\n+  // is used to cache a pointer to the appropriate array type.\n+  _Jv_Method *methods;\n+  // Number of methods.  If this class is primitive, this holds the\n+  // character used to represent this type in a signature.\n+  short method_count;\n+  // Number of methods in the vtable.\n+  short vtable_method_count;\n+  // The fields.\n+  _Jv_Field *fields;\n+  // Size of instance fields, in bytes.\n+  int size_in_bytes;\n+  // Total number of fields (instance and static).\n+  short field_count;\n+  // Number of static fields.\n+  short static_field_count;\n+  // The vtbl for all objects of this class.\n+  _Jv_VTable *vtable;\n+  // Interfaces implemented by this class.\n+  jclass *interfaces;\n+  // The class loader for this class.\n+  java::lang::ClassLoader *loader;\n+  // Number of interfaces.\n+  short interface_count;\n+  // State of this class.\n+  jbyte state;\n+  // The thread which has locked this class.  Used during class\n+  // initialization.\n+  java::lang::Thread *thread;\n+};\n+\n+#endif /* __JAVA_LANG_CLASS_H__ */"}, {"sha": "4ffcceaf675dc7345dea178137673b8e54de69dc", "filename": "libjava/java/lang/Class.java", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,155 @@\n+// Class.java - Representation of a Java class.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.lang;\n+import java.io.Serializable;\n+import java.io.InputStream;\n+import java.lang.reflect.*;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * plus gcj compiler sources (to determine object layout)\n+ * Status:  Sufficient for our purposes, but some methods missing\n+ * and some not implemented.\n+ */\n+\n+public final class Class implements Serializable\n+{\n+  public static native Class forName (String className)\n+    throws ClassNotFoundException;\n+  public native Class[] getClasses ();\n+  public native ClassLoader getClassLoader ();\n+  public native Class getComponentType ();\n+\n+  public native Constructor getConstructor (Class[] parameterTypes)\n+    throws NoSuchMethodException, SecurityException;\n+  public native Constructor[] getConstructors () throws SecurityException;\n+\n+  public native Class[] getDeclaredClasses () throws SecurityException;\n+\n+  public native Constructor getDeclaredConstructor (Class[] parameterTypes)\n+    throws NoSuchMethodException, SecurityException;\n+  public native Constructor[] getDeclaredConstructors ()\n+    throws SecurityException;\n+  public native Field getDeclaredField (String fieldName)\n+    throws NoSuchFieldException, SecurityException;\n+  public native Field[] getDeclaredFields () throws SecurityException;\n+  public native Method getDeclaredMethod (String methodName,\n+\t\t\t\t\t  Class[] parameterTypes)\n+    throws NoSuchMethodException, SecurityException;\n+  public native Method[] getDeclaredMethods () throws SecurityException;\n+\n+  // This is marked as unimplemented in the JCL book.\n+  public native Class getDeclaringClass ();\n+\n+  private native Field getField (String fieldName, int hash)\n+    throws NoSuchFieldException, SecurityException;\n+\n+  public Field getField (String fieldName)\n+    throws NoSuchFieldException, SecurityException\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkMemberAccess (this, java.lang.reflect.Member.DECLARED);\n+    Field fld = getField(fieldName, fieldName.hashCode());\n+    if (fld == null)\n+      throw new NoSuchFieldException(fieldName);\n+    return fld;\n+  }\n+  public native Field[] getFields () throws SecurityException;\n+\n+  public native Class[] getInterfaces ();\n+\n+  public native Method getMethod (String methodName, Class[] parameterTypes)\n+    throws NoSuchMethodException, SecurityException;\n+  public native Method[] getMethods () throws SecurityException;\n+\n+  public native int getModifiers ();\n+  public native String getName ();\n+\n+  // FIXME: can't implement this until we have java.net.\n+  // public URL getResource (String resourceName);\n+\n+  // FIXME: implement.\n+  public InputStream getResourceAsStream (String resourceName)\n+  {\n+    return null;\n+  }\n+\n+  // FIXME: implement.  Requires java.security.\n+  public Object[] getSigners ()\n+  {\n+    return null;\n+  }\n+\n+  public native Class getSuperclass ();\n+  public native boolean isArray ();\n+  public native boolean isAssignableFrom (Class cls);\n+  public native boolean isInstance (Object obj);\n+  public native boolean isInterface ();\n+  public native boolean isPrimitive ();\n+  public native Object newInstance ()\n+    throws InstantiationException, IllegalAccessException;\n+\n+  public String toString ()\n+  {\n+    if (isPrimitive ())\n+      return getName ();\n+    return (isInterface () ? \"interface \" : \"class \") + getName ();\n+  }\n+\n+  // Don't allow new classes to be made.\n+  private Class ()\n+  {\n+  }\n+\n+  // Do a security check.\n+  private void checkMemberAccess (int flags)\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkMemberAccess(this, flags);\n+  }\n+\n+  // FIXME: this method exists only because we cannot catch Java\n+  // exceptions from C++ code.  This is a helper for initializeClass.\n+  private Throwable hackTrampoline (int what, Throwable old_exception)\n+    {\n+      Throwable new_val = null;\n+      try\n+\t{\n+\t  if (what == 0)\n+\t    initializeClass ();\n+\t  else if (what == 1)\n+\t    hackRunInitializers ();\n+\t  else if (what == 2)\n+\t    new_val = new ExceptionInInitializerError (old_exception);\n+\t}\n+      catch (Throwable t)\n+\t{\n+\t  new_val = t;\n+\t}\n+      return new_val;\n+    }\n+\n+  // FIXME: this is a hack to let us run the class initializers.  We\n+  // could do it inline in initializeClass() if we could catch Java\n+  // exceptions from C++.\n+  private native void hackRunInitializers ();\n+\n+  // Initialize the class.\n+  private native void initializeClass ();\n+}"}, {"sha": "bd5a2a49b8ea8f38017a056edfe18cf19eacd202", "filename": "libjava/java/lang/ClassCastException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassCastException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassCastException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassCastException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class ClassCastException extends RuntimeException\n+{\n+  public ClassCastException()\n+  {\n+    super();\n+  }\n+\n+  public ClassCastException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "a5e038318052324b0b6ea89ed8cbf21b511fb9e5", "filename": "libjava/java/lang/ClassCircularityError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassCircularityError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassCircularityError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassCircularityError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// ClassCircularityError.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class ClassCircularityError extends LinkageError\n+{\n+  public ClassCircularityError ()\n+  {\n+    super ();\n+  }\n+\n+  public ClassCircularityError (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "99b8425c9be2fd4782ae896b419527425057ca7b", "filename": "libjava/java/lang/ClassFormatError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassFormatError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassFormatError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassFormatError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// ClassFormatError.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class ClassFormatError extends LinkageError\n+{\n+  public ClassFormatError ()\n+  {\n+    super ();\n+  }\n+\n+  public ClassFormatError (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "048cea7d883bf9f770cf3b01a3d2961d5faea9ac", "filename": "libjava/java/lang/ClassLoader.java", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,94 @@\n+// ClassLoader.java - Define policies for loading Java classes.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.lang;\n+import java.io.InputStream;\n+import java.util.Hashtable;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 28, 1998 \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * Status: Just a stub; not useful at all.\n+ */\n+\n+public abstract class ClassLoader\n+{\n+  protected ClassLoader ()\n+    {\n+      cache = new Hashtable ();\n+    }\n+\n+  protected final Class defineClass (String className, byte[] bytecode,\n+\t\t\t\t     int offset, int length)\n+    {\n+      throw new ClassFormatError (\"defineClass unimplemented\");\n+    }\n+\n+  protected final Class defineClass (byte[] bytecodes,\n+\t\t\t\t     int offset, int length)\n+    {\n+      return defineClass (null, bytecodes, offset, length);\n+    }\n+\n+  protected final Class findLoadedClass (String className)\n+    {\n+      return (Class) cache.get(className);\n+    }\n+\n+  protected final Class findSystemClass (String className)\n+    throws ClassNotFoundException\n+    {\n+      Class c = system.findLoadedClass(className);\n+      system.resolveClass(c);\n+      return c;\n+    }\n+\n+  // FIXME: Needs URL.\n+  // public URL getResource (String resName);\n+\n+  public InputStream getResourceAsStream (String resName)\n+    {\n+      return null;\n+    }\n+\n+  // FIXME: Needs URL.\n+  // public static final URL getSystemResource (String resName);\n+\n+  public static final InputStream getSystemResourceAsStream (String resName)\n+    {\n+      return null;\n+    }\n+\n+  protected abstract Class loadClass (String className, boolean resolve)\n+    throws ClassNotFoundException;\n+  public Class loadClass (String name) throws ClassNotFoundException\n+    {\n+      return loadClass (name, true);\n+    }\n+\n+  protected final void resolveClass (Class c)\n+    {\n+      // Nothing for now.\n+    }\n+\n+  protected final void setSigners (Class cl, Object[] signers)\n+    {\n+      // Nothing for now.\n+    }\n+\n+  // Class cache.\n+  private Hashtable cache;\n+\n+  // The system class loader.  FIXME: should have an actual value\n+  private static final ClassLoader system = null;\n+}"}, {"sha": "e0ea15e22a27f2117da0dfabb3be10365ee9fa0d", "filename": "libjava/java/lang/ClassNotFoundException.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassNotFoundException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FClassNotFoundException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassNotFoundException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class ClassNotFoundException extends Exception\n+{\n+  public ClassNotFoundException()\n+  {\n+    super();\n+  }\n+\n+  // TODO12:\n+  // public ClassNotFoundException(String msg, Throwable ex)\n+  // {\n+  // }\n+\n+  public ClassNotFoundException(String msg)\n+  {\n+    super(msg);\n+  }\n+\n+  // TODO12:\n+  // public Throwable getException()\n+  // {\n+  // }\n+\n+  // TBD: if this needs to be implemented\n+  // public void printStackTrace()\n+  // {\n+  // }\n+\n+  // TBD: if this needs to be implemented\n+  // public void printStackTrace(PrintStream ps)\n+  // {\n+  // }\n+\n+  // TBD: if this needs to be implemented\n+  // public void printStackTrace(PrintWriter pw)\n+  // {\n+  // }\n+}"}, {"sha": "155e80481a9b8634a303a6ac80383875c8421c22", "filename": "libjava/java/lang/CloneNotSupportedException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCloneNotSupportedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCloneNotSupportedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCloneNotSupportedException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class CloneNotSupportedException extends Exception\n+{\n+  public CloneNotSupportedException()\n+  {\n+    super();\n+  }\n+\n+  public CloneNotSupportedException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "730e5c91b5fe3a535a535040f861234cbb419a01", "filename": "libjava/java/lang/Cloneable.java", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCloneable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCloneable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCloneable.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,23 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 2, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public interface Cloneable\n+{\n+}"}, {"sha": "e40e6e81ae8653ce33a5c60868f87f09a5a67642", "filename": "libjava/java/lang/Comparable.java", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FComparable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FComparable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FComparable.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,22 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 8, 1998.  \n+ */\n+/* Written using online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public interface Comparable\n+{\n+  public int compareTo(Object o) throws ClassCastException;\n+}"}, {"sha": "7feb9f864299bc8940fe8a7b7d35b6590a3b5eb8", "filename": "libjava/java/lang/Compiler.java", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCompiler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FCompiler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCompiler.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,53 @@\n+// Compiler.java - Control byte->machine code compiler.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.lang;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 23, 1998.  \n+ */\n+\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ */\n+\n+public final class Compiler\n+{\n+  public static Object command (Object arg)\n+    {\n+      // Our implementation defines this to a no-op.\n+      return null;\n+    }\n+\n+  public static boolean compileClass (Class oneClass)\n+    {\n+      // Never succeed.\n+      return false;\n+    }\n+\n+  public static boolean compileClasses (String classNames)\n+    {\n+      // Note the incredibly lame interface.  Always fail.\n+      return false;\n+    }\n+\n+  public static void disable ()\n+    {\n+    }\n+\n+  public static void enable ()\n+    {\n+    }\n+\n+  // Don't allow new `Compiler's to be made.\n+  private Compiler ()\n+    {\n+    }\n+}"}, {"sha": "850aa5ad979e0c166b8f4a57fa1cc262e9ba9e1c", "filename": "libjava/java/lang/Double.java", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FDouble.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FDouble.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FDouble.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,149 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+\n+/**\n+ * @author Andrew Haley <aph@cygnus.com>\n+ * @date September 25, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public final class Double extends Number\n+{\n+  public static final double MIN_VALUE = 5e-324;\n+  public static final double MAX_VALUE = 1.7976931348623157e+308;\n+  public static final double NEGATIVE_INFINITY = -1.0d/0.0d;\n+  public static final double POSITIVE_INFINITY = 1.0d/0.0d;\n+  public static final double NaN = 0.0d/0.0d;\n+\n+  // This initialization is seemingly circular, but it is accepted\n+  // by javac, and is handled specially by gcc.\n+  public static final Class TYPE = double.class;\n+\n+  private double value;\n+\n+  private native static double doubleValueOf (String s) \n+       throws NumberFormatException;  \n+\n+  public Double (double v)\n+  {\n+    value = v;\n+  }\n+\n+  public Double (String s) throws NumberFormatException\n+  {\n+    value = valueOf (s).doubleValue ();\n+  }\n+\n+  public String toString ()\n+  {\n+    return toString (value);\n+  }\n+\n+  public boolean equals (Object obj)\n+  {\n+    if (obj == null)\n+      return false;\n+\n+    if (!(obj instanceof Double))\n+      return false;\n+\n+    Double d = (Double) obj;\n+\n+    return doubleToLongBits (value) == doubleToLongBits (d.doubleValue ());\n+  }\n+\n+  public int hashCode ()\n+  {\n+    long v = doubleToLongBits (value);\n+    return (int) (v ^ (v >>> 32));\n+  }\n+\n+  public int intValue ()\n+  {\n+    return (int) value;\n+  }\n+\n+  public long longValue ()\n+  {\n+    return (long) value;\n+  }\n+\n+  public float floatValue ()\n+  {\n+    return (float) value;\n+  }\n+\n+  public double doubleValue ()\n+  {\n+    return value;\n+  }\n+\n+  public byte byteValue ()\n+  {\n+    return (byte) value;\n+  }\n+\n+  public short shortValue ()\n+  {\n+    return (short) value;\n+  }\n+\n+  native static String toString (double v, boolean isFloat);\n+\n+  public static String toString (double v)\n+  {\n+    return toString (v, false);\n+  }\n+\n+  public static Double valueOf (String s) throws NullPointerException, \n+    NumberFormatException\n+  {\n+    if (s == null)\n+      throw new NullPointerException ();\n+\n+    return new Double (doubleValueOf (s));\n+  }\n+\n+  public boolean isNaN ()\n+  {\n+    return isNaN (value);\n+  }\n+\n+  public static boolean isNaN (double v)\n+  {\n+    long bits = doubleToLongBits (v);\n+    long e = bits & 0x7ff0000000000000L;\n+    long f = bits & 0x000fffffffffffffL;\n+\n+    return e == 0x7ff0000000000000L && f != 0L;\n+  }\n+\n+  public boolean isInfinite ()\n+  {\n+    return isInfinite (value);\n+  }\n+\n+  public static boolean isInfinite (double v)\n+  {\n+    long bits = doubleToLongBits (v);\n+    long f = bits & 0x7fffffffffffffffL;\n+\n+    return f == 0x7ff0000000000000L;\n+  }\n+\n+  public static native long doubleToLongBits (double value);\n+\n+  public static native double longBitsToDouble (long bits);\n+}\n+"}, {"sha": "ef69f0ea413195a950d0f72bb2fea451fa691d7b", "filename": "libjava/java/lang/Error.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// Error.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class Error extends Throwable\n+{\n+  public Error ()\n+  {\n+    super ();\n+  }\n+\n+  public Error (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "8eb5e44dc36a92978f5dd11ff4694d76e35bb97e", "filename": "libjava/java/lang/Exception.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class Exception extends Throwable\n+{\n+  public Exception()\n+  {\n+    super();\n+  }\n+\n+  public Exception(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "deb1213e3b2320ee399721e8dd605f8033024ec7", "filename": "libjava/java/lang/ExceptionInInitializerError.java", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FExceptionInInitializerError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FExceptionInInitializerError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FExceptionInInitializerError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,50 @@\n+// ExceptionInInitializerError.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class ExceptionInInitializerError extends LinkageError\n+{\n+  public ExceptionInInitializerError ()\n+  {\n+    super ();\n+    exception = null;\n+  }\n+\n+  public ExceptionInInitializerError (String msg)\n+  {\n+    super (msg);\n+    exception = null;\n+  }\n+\n+  public ExceptionInInitializerError (Throwable e)\n+  {\n+    super ();\n+    exception = e;\n+  }\n+\n+  public Throwable getException ()\n+  {\n+    return exception;\n+  }\n+\n+  // The exception that caused this error.\n+  private Throwable exception;\n+}"}, {"sha": "ec0f1db33d54ba39b80fcb26ddd3e6effffa4d90", "filename": "libjava/java/lang/FirstThread.java", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FFirstThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FFirstThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FFirstThread.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,40 @@\n+// FirstThread.java - Implementation of very first thread.\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.lang;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date August 24, 1998 \n+ */\n+\n+// This is entirely internal to our implementation.\n+\n+final class FirstThread extends Thread\n+{\n+  public native void run ();\n+\n+  public FirstThread (ThreadGroup g, Class k, Object o)\n+  {\n+    super (g, null, \"main\");\n+    klass = k;\n+    args = o;\n+  }\n+\n+  private static void die (String s)\n+  {\n+    System.err.println(s);\n+    System.exit(1);\n+  }\n+\n+  // Private data.\n+  private Class klass;\n+  private Object args;\n+}"}, {"sha": "99cc66bc8e79cbb07dce0bed2b94259ac7ac34e0", "filename": "libjava/java/lang/Float.java", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FFloat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FFloat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FFloat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,149 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+\n+/**\n+ * @author Andrew Haley <aph@cygnus.com>\n+ * @date September 25, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public final class Float extends Number\n+{\n+  public static final float MAX_VALUE = 3.4028235e+38f;\n+  public static final float MIN_VALUE = 1.4e-45f;\n+  public static final float NEGATIVE_INFINITY = -1.0f/0.0f;\n+  public static final float POSITIVE_INFINITY = 1.0f/0.0f;\n+  public static final float NaN = 0.0f/0.0f;\n+\n+  // This initialization is seemingly circular, but it is accepted\n+  // by javac, and is handled specially by gcc.\n+  public static final Class TYPE = float.class;\n+\n+  private float value;\n+\n+  public Float (float value)\n+  {\n+    this.value = value;\n+  }\n+\n+  public Float (double value)\n+  {\n+    this.value = (float)value;\n+  }\n+\n+  public Float (String s) throws NumberFormatException\n+  {\n+    this.value = valueOf (s).floatValue ();\n+  }\n+\n+  public String toString ()\n+  {\n+    return toString (value);\n+  }\n+\n+  public boolean equals (Object obj)\n+  {\n+    if (obj == null)\n+      return false;\n+\n+    if (!(obj instanceof Float))\n+      return false;\n+\n+    Float f = (Float) obj;\n+\n+    return floatToIntBits (value) == floatToIntBits (f.floatValue ());\n+  }\n+\n+  public int hashCode ()\n+  {\n+    return floatToIntBits (value);\n+  }\n+\n+  public int intValue ()\n+  {\n+    return (int) value;\n+  }\n+\n+  public long longValue ()\n+  {\n+    return (long) value;\n+  }\n+\n+  public float floatValue ()\n+  {\n+    return (float) value;\n+  }\n+\n+  public double doubleValue ()\n+  {\n+    return (double) value;\n+  }\n+\n+  public byte byteValue ()\n+  {\n+    return (byte) value;\n+  }\n+\n+  public short shortValue ()\n+  {\n+    return (short) value;\n+  }\n+\n+  public static String toString (float v)\n+  {\n+    return Double.toString ((double) v, true);\n+  } \n+\n+  public static Float valueOf (String s) throws NullPointerException, \n+    NumberFormatException\n+  {\n+    if (s == null)\n+      throw new NullPointerException ();\n+\n+    return new Float (Double.valueOf (s).floatValue ());\n+  }\n+\n+  public boolean isNaN ()\n+  {\n+    return isNaN (value);\n+  }\n+\n+  public static boolean isNaN (float v)\n+  {\n+    int bits = floatToIntBits (v);\n+    int e = bits & 0x7f800000;\n+    int f = bits & 0x007fffff;\n+\n+    return e == 0x7f800000 && f != 0;\n+  }\n+\n+  public boolean isInfinite ()\n+  {\n+    return isInfinite (value);\n+  }\n+\n+  public static boolean isInfinite (float v)\n+  {\n+    int bits = floatToIntBits (v);\n+    int f = bits & 0x7fffffff;\n+\n+    return f == 0x7f800000;\n+  }\n+\n+  public static native int floatToIntBits (float value);\n+\n+  public static native float intBitsToFloat (int bits);\n+\n+}\n+"}, {"sha": "2d863416eb58a508fd4e869a8fc7ceb9b3f65731", "filename": "libjava/java/lang/IllegalAccessError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalAccessError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalAccessError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIllegalAccessError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// IllegalAccessError.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class IllegalAccessError extends IncompatibleClassChangeError\n+{\n+  public IllegalAccessError ()\n+  {\n+    super ();\n+  }\n+\n+  public IllegalAccessError (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "c07a518779adec26eb1e2c39d6d0d6ace35bde11", "filename": "libjava/java/lang/IllegalAccessException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalAccessException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalAccessException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIllegalAccessException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class IllegalAccessException extends Exception\n+{\n+  public IllegalAccessException()\n+  {\n+    super();\n+  }\n+\n+  public IllegalAccessException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "6e8f0ed0300a0ad0c291d33839a8f9722b55e89d", "filename": "libjava/java/lang/IllegalArgumentException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalArgumentException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalArgumentException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIllegalArgumentException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class IllegalArgumentException extends RuntimeException\n+{\n+  public IllegalArgumentException()\n+  {\n+    super();\n+  }\n+\n+  public IllegalArgumentException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "f431749ca5f541343acc1c2ffcf89e0ce304577a", "filename": "libjava/java/lang/IllegalMonitorStateException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalMonitorStateException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalMonitorStateException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIllegalMonitorStateException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class IllegalMonitorStateException extends RuntimeException\n+{\n+  public IllegalMonitorStateException()\n+  {\n+    super();\n+  }\n+\n+  public IllegalMonitorStateException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "2ea0d02b62bbe806233720db7a4b7a0bb447fb5f", "filename": "libjava/java/lang/IllegalStateException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalStateException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalStateException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIllegalStateException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class IllegalStateException extends RuntimeException\n+{\n+  public IllegalStateException()\n+  {\n+    super();\n+  }\n+\n+  public IllegalStateException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "72afa771ede09811ac0c5ba047ba8476cbb1924e", "filename": "libjava/java/lang/IllegalThreadStateException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalThreadStateException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIllegalThreadStateException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIllegalThreadStateException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class IllegalThreadStateException extends IllegalArgumentException\n+{\n+  public IllegalThreadStateException()\n+  {\n+    super();\n+  }\n+\n+  public IllegalThreadStateException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "31a22c461758205e801cf48666cc6c884a82b0e0", "filename": "libjava/java/lang/IncompatibleClassChangeError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIncompatibleClassChangeError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIncompatibleClassChangeError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIncompatibleClassChangeError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// IncompatibleClassChangeError.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class IncompatibleClassChangeError extends LinkageError\n+{\n+  public IncompatibleClassChangeError ()\n+  {\n+    super ();\n+  }\n+\n+  public IncompatibleClassChangeError (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "c8b5878b3d897a4676789f976e555f56d9c72a2b", "filename": "libjava/java/lang/IndexOutOfBoundsException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIndexOutOfBoundsException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FIndexOutOfBoundsException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FIndexOutOfBoundsException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class IndexOutOfBoundsException extends RuntimeException\n+{\n+  public IndexOutOfBoundsException()\n+  {\n+    super();\n+  }\n+\n+  public IndexOutOfBoundsException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "7982615e8f6a691316f9c18327a18831f74932f4", "filename": "libjava/java/lang/InstantiationError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInstantiationError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInstantiationError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInstantiationError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,34 @@\n+// InstantiationError.java\n+\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date October 1, 1998 \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class InstantiationError extends IncompatibleClassChangeError\n+{\n+  public InstantiationError ()\n+  {\n+    super ();\n+  }\n+\n+  public InstantiationError (String msg)\n+  {\n+    super (msg);\n+  }\n+}"}, {"sha": "d5ca893fe027729fd7e92f3f5d532b21def6176a", "filename": "libjava/java/lang/InstantiationException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInstantiationException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInstantiationException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInstantiationException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 1998, 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+ \n+package java.lang;\n+ \n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 18, 1998.  \n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * \"The Java Language Specification\", ISBN 0-201-63451-1\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n+ * Status:  Believed complete and correct.\n+ */\n+ \n+public class InstantiationException extends Exception\n+{\n+  public InstantiationException()\n+  {\n+    super();\n+  }\n+\n+  public InstantiationException(String msg)\n+  {\n+    super(msg);\n+  }\n+}"}, {"sha": "54acc27ed6b20f5dc8229bebf8d3209cfe38b9cf", "filename": "libjava/java/lang/Integer.java", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInteger.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "6e484cfa6d02183abb7094cb4208d420c5ec3988", "filename": "libjava/java/lang/InternalError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInternalError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInternalError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInternalError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ef2e9b3adaf7f54b94c34e9ef1f7ae8abe375b45", "filename": "libjava/java/lang/InterruptedException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInterruptedException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FInterruptedException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInterruptedException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "c9386a7c3c17f036275b02b6777c8bdbc89bc936", "filename": "libjava/java/lang/LinkageError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FLinkageError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FLinkageError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FLinkageError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "1ee8bf362779efcd77d56a799fa445fc2b736710", "filename": "libjava/java/lang/Long.java", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FLong.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FLong.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FLong.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "77c00bd2fd537e42a0851ae2fe6b88f0abc53f9f", "filename": "libjava/java/lang/Math.java", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FMath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FMath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FMath.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "838f408e49cd0dfcd0ce9d08140a6e51d5eea7cb", "filename": "libjava/java/lang/NegativeArraySizeException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNegativeArraySizeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNegativeArraySizeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNegativeArraySizeException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "4368d35baa4d10efa2ec88ab55400df8d4c5290e", "filename": "libjava/java/lang/NoClassDefFoundError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoClassDefFoundError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoClassDefFoundError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNoClassDefFoundError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "13165e8979834914b5ecd16906ac192552395eee", "filename": "libjava/java/lang/NoSuchFieldError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchFieldError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchFieldError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNoSuchFieldError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "6e51cdad739b61e2bc5149d8ed33adbfebc000aa", "filename": "libjava/java/lang/NoSuchFieldException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchFieldException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchFieldException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNoSuchFieldException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "2c4c1da9f05ffe7e4e191e4a6a748b8b873c67ae", "filename": "libjava/java/lang/NoSuchMethodError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchMethodError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchMethodError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNoSuchMethodError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "9861777c77d0dbc4eced0688a95827d963be48a3", "filename": "libjava/java/lang/NoSuchMethodException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchMethodException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNoSuchMethodException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNoSuchMethodException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "1d1abdd148c852e186243723bcd1a928721096b7", "filename": "libjava/java/lang/NullPointerException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNullPointerException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNullPointerException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNullPointerException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "bf9306b45f3914e056b695eafaa6ff2ad78429d2", "filename": "libjava/java/lang/Number.java", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNumber.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNumber.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNumber.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "c05a8f172d4e4dec536e39848906f9c68a13a96a", "filename": "libjava/java/lang/NumberFormatException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNumberFormatException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FNumberFormatException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNumberFormatException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "c5d55f17833d3b7b55fd25240bfa2b7fd916789c", "filename": "libjava/java/lang/Object.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FObject.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "2adad290812dddc56f2d1269c8c646a73be96e95", "filename": "libjava/java/lang/Object.java", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FObject.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "418e13ccbce081d965fd6ff8ca3aebc1b0291175", "filename": "libjava/java/lang/OutOfMemoryError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FOutOfMemoryError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FOutOfMemoryError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FOutOfMemoryError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "765bc9bb8bdfdcf75d3f2fd7aac8340e25c1c536", "filename": "libjava/java/lang/Process.java", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FProcess.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FProcess.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FProcess.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8e27d91856d654e24c5cc4f7337b3ffcc2c8f883", "filename": "libjava/java/lang/Runnable.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FRunnable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FRunnable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FRunnable.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "baf1ae541b79851b57ec80818baca30b2291abb9", "filename": "libjava/java/lang/Runtime.java", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FRuntime.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FRuntime.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FRuntime.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "e0d3f5397d3c27f4a7b7c9b1ccb59ce5505b4a5f", "filename": "libjava/java/lang/RuntimeException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FRuntimeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FRuntimeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FRuntimeException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8a6a94f7f7556439b08752c0c2a37b11e0eb49e8", "filename": "libjava/java/lang/SecurityException.java", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FSecurityException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FSecurityException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSecurityException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "50091f1044e7c910be6c098881922a8957518731", "filename": "libjava/java/lang/SecurityManager.java", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FSecurityManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FSecurityManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSecurityManager.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "4a17f2d6ea7f7d0d9bc1e2e1a3653664745126ef", "filename": "libjava/java/lang/Short.java", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FShort.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FShort.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FShort.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ace8b25c1a0c4040ba45fd36c4ce42054ae66412", "filename": "libjava/java/lang/StackOverflowError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FStackOverflowError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FStackOverflowError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStackOverflowError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "1321676d0e52a5c58e81e1d4942c098216c64f36", "filename": "libjava/java/lang/String.java", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "4127d54787f4953d785412e525be7bb0622dad62", "filename": "libjava/java/lang/StringBuffer.java", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FStringBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FStringBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuffer.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "200acb896f0faf908257f44655ec34620c7d3553", "filename": "libjava/java/lang/StringIndexOutOfBoundsException.java", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FStringIndexOutOfBoundsException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FStringIndexOutOfBoundsException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringIndexOutOfBoundsException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "6f6dee4205726cc90b23105802c0b1884dee8e1d", "filename": "libjava/java/lang/System.java", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FSystem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FSystem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSystem.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f21d3a3fb7d3ba2182d4b3bf5ad1bd728c61e932", "filename": "libjava/java/lang/Thread.java", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "caffc936d2e51805510f4f53030d886502db2f9f", "filename": "libjava/java/lang/ThreadDeath.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThreadDeath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThreadDeath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThreadDeath.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "1aa1a9a3bedd7592cd5b683e3957a160a262e34c", "filename": "libjava/java/lang/ThreadGroup.java", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThreadGroup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThreadGroup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThreadGroup.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "5ae39ae259448e7dbb182757de104d42ebc43419", "filename": "libjava/java/lang/Throwable.java", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThrowable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FThrowable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThrowable.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "edf050c77ecbd6d4c1cda3e6093104257f50d00f", "filename": "libjava/java/lang/UnknownError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FUnknownError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FUnknownError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FUnknownError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "63930f5555fcc1fad80ea751a76cc65d5c8a6806", "filename": "libjava/java/lang/UnsatisfiedLinkError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FUnsatisfiedLinkError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FUnsatisfiedLinkError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FUnsatisfiedLinkError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d2bee88622a072722e7f7222deb6921569e06feb", "filename": "libjava/java/lang/UnsupportedOperationException.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FUnsupportedOperationException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FUnsupportedOperationException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FUnsupportedOperationException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "69d6a69baf522c557f12186359f1664376d01263", "filename": "libjava/java/lang/VerifyError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FVerifyError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FVerifyError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVerifyError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "dcc907c5d03cac7c9ad9b134087ceb9e109a7e4a", "filename": "libjava/java/lang/VirtualMachineError.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FVirtualMachineError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FVirtualMachineError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVirtualMachineError.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "5390552a62260431b4b8331b95796e48c5e67a36", "filename": "libjava/java/lang/Void.java", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FVoid.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FVoid.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVoid.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "fae45c5aeb48ec660da7a244296d56eb0f1fc7a6", "filename": "libjava/java/lang/dtoa.c", "status": "added", "additions": 906, "deletions": 0, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fdtoa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fdtoa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fdtoa.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "319b1d56fa097cf9e1df2115f58ee5de98e20b54", "filename": "libjava/java/lang/e_acos.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_acos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_acos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_acos.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "559f2884a263615fcf068f70f229379a032475de", "filename": "libjava/java/lang/e_asin.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_asin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_asin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_asin.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8e9650f290de37a0800f0b822ef960bccf847a55", "filename": "libjava/java/lang/e_atan2.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_atan2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_atan2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_atan2.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ce093c61065057c718769f2344b12f3f82f2bbe8", "filename": "libjava/java/lang/e_exp.c", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_exp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_exp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_exp.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f9739eec25d7108e404e9cf967e6fa9b35d90ee5", "filename": "libjava/java/lang/e_fmod.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_fmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_fmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_fmod.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ea6c55f6c36ff14e7012c7b750dd189e3571fd02", "filename": "libjava/java/lang/e_log.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_log.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f078dff344db6c159d70da9df2463805fc197d30", "filename": "libjava/java/lang/e_pow.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_pow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_pow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_pow.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "3e5d0f7a2277ff41563a79cc544f93871c4d2309", "filename": "libjava/java/lang/e_rem_pio2.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_rem_pio2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_rem_pio2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_rem_pio2.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ae7ce649ad5bbe5a67bdc3d2dfcb300ea1f25c8d", "filename": "libjava/java/lang/e_remainder.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_remainder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_remainder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_remainder.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "0bb924b43ee17c03164f8276235e368e60a163f8", "filename": "libjava/java/lang/e_scalb.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_scalb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_scalb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_scalb.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "b56b1eedc94c0022c05c70fce2df16e5310dc0d2", "filename": "libjava/java/lang/e_sqrt.c", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_sqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fe_sqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_sqrt.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "3f72070cf81c6424d445d08c0e6a4e383c6d4a47", "filename": "libjava/java/lang/fdlibm.h", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Ffdlibm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Ffdlibm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Ffdlibm.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "931bafb7d1a7f25f27ed24f86cf41d9232e080ac", "filename": "libjava/java/lang/ieeefp.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fieeefp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fieeefp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fieeefp.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "6c60c243856e5e65df87ca45c4efd8bd1e6ce745", "filename": "libjava/java/lang/k_cos.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_cos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_cos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_cos.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8569256686c848cdd5f63eb19e6f63ab73861e70", "filename": "libjava/java/lang/k_rem_pio2.c", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_rem_pio2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_rem_pio2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_rem_pio2.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f119916dfbc4a8fecf599e95045233d5bf400fcc", "filename": "libjava/java/lang/k_sin.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_sin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_sin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_sin.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "9f5b307600cf9d7397575bd60781435e2894fad8", "filename": "libjava/java/lang/k_tan.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_tan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fk_tan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_tan.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "12dd5d2617aeeba6a8d99d63263f1770735fab44", "filename": "libjava/java/lang/mprec.c", "status": "added", "additions": 958, "deletions": 0, "changes": 958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fmprec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fmprec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fmprec.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "192243157dfa454db34b6e9c97fdad6ba77f8eab", "filename": "libjava/java/lang/mprec.h", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fmprec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fmprec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fmprec.h?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "36cf5700fe5533f2d027739085092006d9a499d2", "filename": "libjava/java/lang/natCharacter.cc", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatCharacter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatCharacter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatCharacter.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "1768df5ecb26657395853812b2aec098cdb5905e", "filename": "libjava/java/lang/natClass.cc", "status": "added", "additions": 785, "deletions": 0, "changes": 785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "17990884751bfa09aa660014b81040579c4814ff", "filename": "libjava/java/lang/natDouble.cc", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatDouble.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatDouble.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatDouble.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d47446be4a8e9084b72db51922f2e864f01aef0e", "filename": "libjava/java/lang/natFirstThread.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatFirstThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatFirstThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatFirstThread.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "e3189bebc2d58f810d1f5a541630750ef3c44d4b", "filename": "libjava/java/lang/natFloat.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatFloat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatFloat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatFloat.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "66382473eed5fe5a1f85d772c9157d18ddf6bfed", "filename": "libjava/java/lang/natMath.cc", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatMath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatMath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatMath.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "7b26769e35165f75f6045c1454b4eaa9157e8969", "filename": "libjava/java/lang/natObject.cc", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d89ab18bd9ca6056bb4fcc2c67e4cfcf85eb4982", "filename": "libjava/java/lang/natRuntime.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "5cb7b2c72b4a6197442d648cfe8b1a116b6e99a7", "filename": "libjava/java/lang/natString.cc", "status": "added", "additions": 800, "deletions": 0, "changes": 800, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "5f613d53eadb4bc6bd1dc96f883b552c5a8e80eb", "filename": "libjava/java/lang/natSystem.cc", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatSystem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatSystem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatSystem.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "117191133a8652f24e12bcfd7de3e4fe26bff578", "filename": "libjava/java/lang/natThread.cc", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8c869e167b0ade0f0795ac87cbc3ee95a5afa812", "filename": "libjava/java/lang/reflect/AccessibleObject.java", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FAccessibleObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FAccessibleObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FAccessibleObject.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "398f80d5643fc0fa590bd177e5767b9ac8127d8c", "filename": "libjava/java/lang/reflect/Array.java", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FArray.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FArray.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FArray.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "466c1204bae1425c88bca92da463870237853f03", "filename": "libjava/java/lang/reflect/Constructor.java", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "7c7e690926a9b86532804485a941b35530aca501", "filename": "libjava/java/lang/reflect/Field.java", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FField.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "eccd5f7daed1a3e6a982bc99ae27362898f60706", "filename": "libjava/java/lang/reflect/InvocationTargetException.java", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FInvocationTargetException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FInvocationTargetException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FInvocationTargetException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "a54f05f689ea8f67009ffcc7fdd35b7e6fc8d68a", "filename": "libjava/java/lang/reflect/Member.java", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FMember.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FMember.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FMember.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "01e830876e595c785c0e2b83e3e61d2dcb146deb", "filename": "libjava/java/lang/reflect/Method.java", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FMethod.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f9df49e80ee59acbe2329903d114641c74ea3241", "filename": "libjava/java/lang/reflect/Modifier.java", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FModifier.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "3da8b5c01ce67035e84d848b3b9a2bfdc4f192a1", "filename": "libjava/java/lang/reflect/natArray.cc", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "2449b42545ca145f03a8014abdf90c330277f3c8", "filename": "libjava/java/lang/reflect/natField.cc", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "720bbc3d74e0d668e0625484aaee91e06d7fc224", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "b1410ecca5576b59770eff5c01b00c5cc08e64a7", "filename": "libjava/java/lang/s_atan.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_atan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_atan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_atan.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "1476ef821bef868caefff3d6c3dfefacedae49fc", "filename": "libjava/java/lang/s_ceil.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_ceil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_ceil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_ceil.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "bfc546db503408c05cfbae9be74a74fb91be8790", "filename": "libjava/java/lang/s_copysign.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_copysign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_copysign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_copysign.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "c471233013742423dde42e86f12bd7e11fd1cfdc", "filename": "libjava/java/lang/s_cos.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_cos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_cos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_cos.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "95b871ca53acc82c64ee5531fac54d7f34b90a5f", "filename": "libjava/java/lang/s_fabs.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_fabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_fabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_fabs.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "86f73e0e13627ca2ca369f2e99f3fa60a6e1faa5", "filename": "libjava/java/lang/s_floor.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_floor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_floor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_floor.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "9936a49b8018f28cf5bc99a22d0ddd49f6e57c19", "filename": "libjava/java/lang/s_rint.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_rint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_rint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_rint.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "b06834e913fda6b298c77ed945a9017240c419ec", "filename": "libjava/java/lang/s_scalbn.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_scalbn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_scalbn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_scalbn.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "28259f378fee2f23e03d40e6eda8acb958dc4904", "filename": "libjava/java/lang/s_sin.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_sin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_sin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_sin.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "2959f416e835af4b3695a03cb4af5aa3098b2f22", "filename": "libjava/java/lang/s_tan.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_tan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fs_tan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_tan.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "e4769e0dc60aec159d5e4be90c026afe520d8b1d", "filename": "libjava/java/lang/sf_rint.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fsf_rint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fsf_rint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fsf_rint.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "e0e8e74828bfb9ab17b2b524f2e8df2a697e84cc", "filename": "libjava/java/lang/strtod.c", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fstrtod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fstrtod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fstrtod.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "c9ca99c404110bb9674fe962c4ee24dec074b752", "filename": "libjava/java/lang/w_acos.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_acos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_acos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_acos.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f6cb271d3920a3ccf22ea8a869030cdfbfbb5274", "filename": "libjava/java/lang/w_asin.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_asin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_asin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_asin.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "91742c72b91d5a095d000fc3f5241d4126518de1", "filename": "libjava/java/lang/w_atan2.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_atan2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_atan2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_atan2.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ae792a84642e52c7f148e2d9bfe33ccda9a9423f", "filename": "libjava/java/lang/w_exp.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_exp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_exp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_exp.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "b6b36cb76ab93ea25d2fbc9802ac79f00ca89d3b", "filename": "libjava/java/lang/w_fmod.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_fmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_fmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_fmod.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "dcc8b9762ecb8dbcc98e52b39f7bbb6d5cf477b0", "filename": "libjava/java/lang/w_log.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_log.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "3df099a17144dca688aa075fa97127e4bce8a54c", "filename": "libjava/java/lang/w_pow.c", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_pow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_pow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_pow.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "a06be0e7b307517754142d7d92c599b0bbe5bd77", "filename": "libjava/java/lang/w_remainder.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_remainder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_remainder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_remainder.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "23a793ce74a694cb3abf0a4426480f9be7937afc", "filename": "libjava/java/lang/w_sqrt.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_sqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Flang%2Fw_sqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fw_sqrt.c?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "5f7b4919b40c973e597f4d4bcd10330428b86193", "filename": "libjava/java/net/BindException.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FBindException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FBindException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FBindException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d4d3a48cc68b0a1c0f641a204b9577e1acd4b684", "filename": "libjava/java/net/ConnectException.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FConnectException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FConnectException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FConnectException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "fd2e3b12f48c914b9ff69a30e07be7593aa27b30", "filename": "libjava/java/net/ContentHandler.java", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FContentHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FContentHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FContentHandler.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "ee6dcffdb69d0880368313750d534cf353cc783d", "filename": "libjava/java/net/ContentHandlerFactory.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FContentHandlerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FContentHandlerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FContentHandlerFactory.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "24e8ef894f1aec321a06755139f56a400afcdb3b", "filename": "libjava/java/net/FileNameMap.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FFileNameMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FFileNameMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FFileNameMap.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8b05b73ebbb08e883173c2c766d833598740726f", "filename": "libjava/java/net/HttpURLConnection.java", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FHttpURLConnection.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "baf5153e933007ad326e87808a0b6cb7659cdb00", "filename": "libjava/java/net/InetAddress.java", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "a5a8db586b2b99a785a83429ae6a5160571d8c40", "filename": "libjava/java/net/MalformedURLException.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FMalformedURLException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FMalformedURLException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMalformedURLException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "dc01688ab3f8725bb3baaa5808148596ef5c459a", "filename": "libjava/java/net/NoRouteToHostException.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FNoRouteToHostException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FNoRouteToHostException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FNoRouteToHostException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "5bc2caef042f7ffacd5e7cae5e41906bbb84fb36", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "f7db6852edd416666ddceac24c2c7bdd1f4288fd", "filename": "libjava/java/net/ProtocolException.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FProtocolException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FProtocolException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FProtocolException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "e4b50693e750745a252ef4ab0a8691e37545cabf", "filename": "libjava/java/net/ServerSocket.java", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8c027d9f88fe3cdf44c5d4534a5705d078714afb", "filename": "libjava/java/net/Socket.java", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "24a50ef3f75acd94507690dd424872731c7ce3d5", "filename": "libjava/java/net/SocketException.java", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocketException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocketException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "5ad311811d8f5bebfd1ac898794478481f3578d1", "filename": "libjava/java/net/SocketImpl.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImpl.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "7631ab8fd1f6d506a664ccb006980bac98eb840c", "filename": "libjava/java/net/SocketImplFactory.java", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocketImplFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FSocketImplFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImplFactory.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "da56f49dc2d5050afbe3f7981d3af86f0b968cf3", "filename": "libjava/java/net/URL.java", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "12e8a8b4cc66f1750474584f80c427be0d976fbc", "filename": "libjava/java/net/URLConnection.java", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "29e0e6d4137c54e15736b230eb417a00058bbf69", "filename": "libjava/java/net/URLStreamHandler.java", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandler.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "474d723d4f5f9883b903f5461b20da961175c66b", "filename": "libjava/java/net/URLStreamHandlerFactory.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURLStreamHandlerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FURLStreamHandlerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandlerFactory.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "1c2050923e98f51f2c17e4423c1fe2b0c7d1b3c1", "filename": "libjava/java/net/UnknownHostException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FUnknownHostException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FUnknownHostException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FUnknownHostException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "dba798e0e80dfb96dc7ab5c84d4db0f5a01c984d", "filename": "libjava/java/net/UnknownServiceException.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FUnknownServiceException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FUnknownServiceException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FUnknownServiceException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "7f7d953b9c198902cb2db6eb8767334c524a0a29", "filename": "libjava/java/net/natInetAddress.cc", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddress.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "076ee71194853d4370971cd4ec3974c7581805db", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "0e09d4566794fa831f3cb565ccc855ef65f210bf", "filename": "libjava/java/text/BreakIterator.java", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FBreakIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FBreakIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FBreakIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d34e988a1543e4225cdd812f635683f72ed464ba", "filename": "libjava/java/text/CharacterIterator.java", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCharacterIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "bed62a75e53931eadf78848059a59eac419c7c8e", "filename": "libjava/java/text/ChoiceFormat.java", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FChoiceFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FChoiceFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FChoiceFormat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "bfd6b01a777e65b29a98ab064e21a98207011e8d", "filename": "libjava/java/text/DateFormat.java", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d21cdeada109629320e70b073f6d1084370fafb8", "filename": "libjava/java/text/DateFormatSymbols.java", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "9ea9d921ec1ae5ed001fdcdb9c8e1ec47bd44294", "filename": "libjava/java/text/DecimalFormat.java", "status": "added", "additions": 983, "deletions": 0, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "783cb6f7f5050b9be9b5bb049f793a88fc19b428", "filename": "libjava/java/text/DecimalFormatSymbols.java", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "2f8c0935b48c7d3afec7efda76486fb9c03b6c3e", "filename": "libjava/java/text/FieldPosition.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FFieldPosition.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FFieldPosition.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFieldPosition.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d2c918b9072c3272d51d0d2e5590e0f56494d9c8", "filename": "libjava/java/text/Format.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFormat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8b42235796610f4b496a533a837a44ffc2e5249b", "filename": "libjava/java/text/MessageFormat.java", "status": "added", "additions": 543, "deletions": 0, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FMessageFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FMessageFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FMessageFormat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "6ee79b3b546b830a37f71b0284d7bb7ff1f57b98", "filename": "libjava/java/text/NumberFormat.java", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FNumberFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FNumberFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FNumberFormat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "6bc9353bcd2b8dae993dcb2ccd9078c96e1d5c4b", "filename": "libjava/java/text/ParseException.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FParseException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FParseException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FParseException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "4603f79259bf8ddf37d86a79623130f3541d35fc", "filename": "libjava/java/text/ParsePosition.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FParsePosition.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FParsePosition.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FParsePosition.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "b40124790458a8f1b48dea44f6098fad350cc0ba", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "6eaa8e71cee588de7ecff11b2237ef5050865b6c", "filename": "libjava/java/text/StringCharacterIterator.java", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "e5886951714f301d6f3efbb04192c3eab084d51e", "filename": "libjava/java/util/BitSet.java", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FBitSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FBitSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBitSet.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "8649adf600dec0dd9cfdd613b00dea3a24c91af1", "filename": "libjava/java/util/Calendar.java", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "478fdffebb7119372f3a727f5dacac02a3eb354b", "filename": "libjava/java/util/ConcurrentModificationException.java", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FConcurrentModificationException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FConcurrentModificationException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FConcurrentModificationException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "3d237804e4ce3d6623523cf80e91c6a62c6b3d9b", "filename": "libjava/java/util/Date.java", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FDate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FDate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FDate.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "2c27112106df8420a9ffa5a1613b67d0fdef88e0", "filename": "libjava/java/util/Dictionary.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FDictionary.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FDictionary.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FDictionary.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "9c4c0b0b4f864e313541c4349ab9246d7e6bed83", "filename": "libjava/java/util/EmptyStackException.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEmptyStackException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEmptyStackException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEmptyStackException.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "233288843e0fa6a94fdd29818207368525d72c3a", "filename": "libjava/java/util/Enumeration.java", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEnumeration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEnumeration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEnumeration.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "394d98c28ff03df0e670098e2667bee5e3ee31e7", "filename": "libjava/java/util/EventListener.java", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEventListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEventListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEventListener.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "178ecff3e7972246a2dbde7e68dfedb3835430e3", "filename": "libjava/java/util/EventObject.java", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEventObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FEventObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEventObject.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "d20c06ef8252e58afe085b5d1ab6ea5f0c099d1b", "filename": "libjava/java/util/GregorianCalendar.java", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}, {"sha": "51ab2b16ac3cf418005d79dedbd3ec29f09c65dc", "filename": "libjava/java/util/Hashtable.java", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9dd3721be68b9fa63dea9aa5a1d86e66958cde/libjava%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashtable.java?ref=ee9dd3721be68b9fa63dea9aa5a1d86e66958cde"}]}