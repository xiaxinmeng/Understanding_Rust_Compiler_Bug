{"sha": "4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI0ZGU4OThjOTRlNjc4YmJjZmE2NzdiYmI1MjRmYzNiZjMzZWQ1MQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2012-09-30T19:25:49Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2012-09-30T19:25:49Z"}, "message": "re PR rtl-optimization/38449 (delay branch scheduling follows REG_CROSSING_JUMP jumps indiscriminately)\n\n        PR rtl-optimization/38449:\n        * hooks.c (hook_bool_const_rtx_const_rtx_true): New function.\n        * hooks.h (hook_bool_const_rtx_const_rtx_true): Declare.\n        * target.def: Merge in definitions and documentation for\n        TARGET_CAN_FOLLOW_JUMP.\n        * doc/tm.texi.in: Add documentation locations for the above.\n        * doc/tm.texi: Regenerate.\n        * reorg.c (follow_jumps): New parameters jump and crossing.\n        Changed all callers.\n\nFrom-SVN: r191878", "tree": {"sha": "7bba91477b083c590808e6d2b1df353f8eabf850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bba91477b083c590808e6d2b1df353f8eabf850"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f84992b0011db09edf7efabf6750ea4ac77df441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84992b0011db09edf7efabf6750ea4ac77df441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84992b0011db09edf7efabf6750ea4ac77df441"}], "stats": {"total": 77, "additions": 69, "deletions": 8}, "files": [{"sha": "d338ee37d2318fd6a17c21638bd7c0d5e5942c27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "patch": "@@ -1,3 +1,15 @@\n+2012-09-30  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR rtl-optimization/38449:\n+\t* hooks.c (hook_bool_const_rtx_const_rtx_true): New function.\n+\t* hooks.h (hook_bool_const_rtx_const_rtx_true): Declare.\n+\t* target.def: Merge in definitions and documentation for\n+\tTARGET_CAN_FOLLOW_JUMP.\n+\t* doc/tm.texi.in: Add documentation locations for the above.\n+\t* doc/tm.texi: Regenerate.\n+\t* reorg.c (follow_jumps): New parameters jump and crossing.\n+\tChanged all callers.\n+\n 2012-09-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* reorg.c (relax_delay_slots): Use delay_insn consistently."}, {"sha": "b36c764a3b5ae7e04c925562d02ec15538270ea0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "patch": "@@ -10958,6 +10958,10 @@ filling of delay slots can result in branches being redirected, and this\n may in turn cause a branch offset to overflow.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_CAN_FOLLOW_JUMP (const_rtx @var{follower}, const_rtx @var{followee})\n+FOLLOWER and FOLLOWEE are JUMP_INSN instructions;  return true if FOLLOWER may be modified to follow FOLLOWEE;  false, if it can't.  For example, on some targets, certain kinds of branches can't be made to  follow through a hot/cold partitioning.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_COMMUTATIVE_P (const_rtx @var{x}, int @var{outer_code})\n This target hook returns @code{true} if @var{x} is considered to be commutative.\n Usually, this is just COMMUTATIVE_P (@var{x}), but the HP PA doesn't consider"}, {"sha": "4858d97e27fffdbad0db2826895d46760655772d", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "patch": "@@ -10814,6 +10814,8 @@ filling of delay slots can result in branches being redirected, and this\n may in turn cause a branch offset to overflow.\n @end defmac\n \n+@hook TARGET_CAN_FOLLOW_JUMP\n+\n @hook TARGET_COMMUTATIVE_P\n This target hook returns @code{true} if @var{x} is considered to be commutative.\n Usually, this is just COMMUTATIVE_P (@var{x}), but the HP PA doesn't consider"}, {"sha": "b26252203f7ffe34d391c6c91911fde1e6afb0df", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "patch": "@@ -117,6 +117,14 @@ hook_bool_mode_rtx_true (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return true;\n }\n \n+/* Generic hook that takes (rtx, rtx) and returns true.  */\n+bool\n+hook_bool_const_rtx_const_rtx_true (const_rtx follower ATTRIBUTE_UNUSED,\n+\t\t\t\t    const_rtx followee ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n /* Generic hook that takes (enum machine_mode, unsigned HOST_WIDE_INT)\n    and returns false.  */\n bool"}, {"sha": "71b391a1b49e665c5d41a64653e4c391d4bcd262", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "patch": "@@ -36,6 +36,7 @@ extern bool hook_bool_mode_const_rtx_false (enum machine_mode, const_rtx);\n extern bool hook_bool_mode_const_rtx_true (enum machine_mode, const_rtx);\n extern bool hook_bool_mode_rtx_false (enum machine_mode, rtx);\n extern bool hook_bool_mode_rtx_true (enum machine_mode, rtx);\n+extern bool hook_bool_const_rtx_const_rtx_true (const_rtx, const_rtx);\n extern bool hook_bool_mode_uhwi_false (enum machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT);\n extern bool hook_bool_tree_false (tree);"}, {"sha": "89442e395aa4bb55e7dd8c7e9e706ef832789e7a", "filename": "gcc/reorg.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "patch": "@@ -2494,22 +2494,25 @@ fill_simple_delay_slots (int non_jumps_p)\n #endif\n }\n \f\n-/* Follow any unconditional jump at LABEL;\n+/* Follow any unconditional jump at LABEL, for the purpose of redirecting JUMP;\n    return the ultimate label reached by any such chain of jumps.\n    Return a suitable return rtx if the chain ultimately leads to a\n    return instruction.\n    If LABEL is not followed by a jump, return LABEL.\n    If the chain loops or we can't find end, return LABEL,\n-   since that tells caller to avoid changing the insn.  */\n+   since that tells caller to avoid changing the insn.\n+   If the returned label is obtained by following a REG_CROSSING_JUMP\n+   jump, set *CROSSING to true, otherwise set it to false.  */\n \n static rtx\n-follow_jumps (rtx label)\n+follow_jumps (rtx label, rtx jump, bool *crossing)\n {\n   rtx insn;\n   rtx next;\n   rtx value = label;\n   int depth;\n \n+  *crossing = false;\n   if (ANY_RETURN_P (label))\n     return label;\n   for (depth = 0;\n@@ -2537,6 +2540,11 @@ follow_jumps (rtx label)\n \t      || GET_CODE (PATTERN (tem)) == ADDR_DIFF_VEC))\n \tbreak;\n \n+      if (!targetm.can_follow_jump (jump, insn))\n+\tbreak;\n+      if (!*crossing)\n+\t*crossing\n+\t  = find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX) != NULL_RTX;\n       value = this_label;\n     }\n   if (depth == 10)\n@@ -2984,14 +2992,15 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n   if (new_thread != thread)\n     {\n       rtx label;\n+      bool crossing = false;\n \n       gcc_assert (thread_if_true);\n \n       if (new_thread && simplejump_or_return_p (new_thread)\n \t  && redirect_with_delay_list_safe_p (insn,\n \t\t\t\t\t      JUMP_LABEL (new_thread),\n \t\t\t\t\t      delay_list))\n-\tnew_thread = follow_jumps (JUMP_LABEL (new_thread));\n+\tnew_thread = follow_jumps (JUMP_LABEL (new_thread), insn, &crossing);\n \n       if (ANY_RETURN_P (new_thread))\n \tlabel = find_end_label (new_thread);\n@@ -3001,7 +3010,11 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \tlabel = get_label_before (new_thread);\n \n       if (label)\n-\treorg_redirect_jump (insn, label);\n+\t{\n+\t  reorg_redirect_jump (insn, label);\n+\t  if (crossing)\n+\t    set_unique_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX);\n+\t}\n     }\n \n   return delay_list;\n@@ -3347,6 +3360,7 @@ relax_delay_slots (rtx first)\n   for (insn = first; insn; insn = next)\n     {\n       rtx other;\n+      bool crossing;\n \n       next = next_active_insn (insn);\n \n@@ -3357,7 +3371,9 @@ relax_delay_slots (rtx first)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && !ANY_RETURN_P (target_label = JUMP_LABEL (insn)))\n \t{\n-\t  target_label = skip_consecutive_labels (follow_jumps (target_label));\n+\t  target_label\n+\t    = skip_consecutive_labels (follow_jumps (target_label, insn,\n+\t\t\t\t\t\t     &crossing));\n \t  if (ANY_RETURN_P (target_label))\n \t    target_label = find_end_label (target_label);\n \n@@ -3369,7 +3385,11 @@ relax_delay_slots (rtx first)\n \t    }\n \n \t  if (target_label && target_label != JUMP_LABEL (insn))\n-\t    reorg_redirect_jump (insn, target_label);\n+\t    {\n+\t      reorg_redirect_jump (insn, target_label);\n+\t      if (crossing)\n+\t\tset_unique_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX);\n+\t    }\n \n \t  /* See if this jump conditionally branches around an unconditional\n \t     jump.  If so, invert this jump and point it to the target of the\n@@ -3503,7 +3523,8 @@ relax_delay_slots (rtx first)\n \n       /* If this jump goes to another unconditional jump, thread it, but\n \t don't convert a jump into a RETURN here.  */\n-      trial = skip_consecutive_labels (follow_jumps (target_label));\n+      trial = skip_consecutive_labels (follow_jumps (target_label, delay_insn,\n+\t\t\t\t\t\t     &crossing));\n       if (ANY_RETURN_P (trial))\n \ttrial = find_end_label (trial);\n \n@@ -3512,6 +3533,8 @@ relax_delay_slots (rtx first)\n \t{\n \t  reorg_redirect_jump (delay_insn, trial);\n \t  target_label = trial;\n+\t  if (crossing)\n+\t    set_unique_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX);\n \t}\n \n       /* If the first insn at TARGET_LABEL is redundant with a previous"}, {"sha": "2d79290b311b5c321edf710d8a768f2ea09fafa4", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4de898c94e678bbcfa677bbb524fc3bf33ed51/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=4b4de898c94e678bbcfa677bbb524fc3bf33ed51", "patch": "@@ -1350,6 +1350,17 @@ DEFHOOK\n  bool, (void),\n  hook_bool_void_false)\n \n+/* True if FOLLOWER may be modified to follow FOLLOWEE.  */\n+DEFHOOK\n+(can_follow_jump,\n+ \"FOLLOWER and FOLLOWEE are JUMP_INSN instructions;\\\n+  return true if FOLLOWER may be modified to follow FOLLOWEE;\\\n+  false, if it can't.\\\n+  For example, on some targets, certain kinds of branches can't be made to\\\n+  follow through a hot/cold partitioning.\",\n+ bool, (const_rtx follower, const_rtx followee),\n+ hook_bool_const_rtx_const_rtx_true)\n+\n /* Return a register class for which branch target register\n    optimizations should be applied.  */\n DEFHOOK"}]}