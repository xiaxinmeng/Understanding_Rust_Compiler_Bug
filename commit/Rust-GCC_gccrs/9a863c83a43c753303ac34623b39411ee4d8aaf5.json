{"sha": "9a863c83a43c753303ac34623b39411ee4d8aaf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4NjNjODNhNDNjNzUzMzAzYWMzNDYyM2IzOTQxMWVlNGQ4YWFmNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-04-01T00:47:52Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-04-01T00:47:52Z"}, "message": "(mips_rtx_classify, cmp2_op, fcmp_op,\n\nfpsw_register_operand, md_register_operand, uns_cmp_op,\nclassify_op, additive_op, divmod_op, unsigned_op, CLASS_*_OP,\nNOTICE_UPDATE_CC): Delete.\n(RTX_COSTS): Use different numbers for R3000/R6000/R4000.\n(REGISTER_MOVE_COST): Use cost of 2 within same register class, 4\nfor FP to GR copy, 6 otherwise.\n(ADJUST_COST): Give anti and output dependencies zero cost.\n(PREDICATE_CODES): Delete obsolete functions from list.\n\nFrom-SVN: r6931", "tree": {"sha": "dc75717d2e07f4bfdf0bbebbfd4285efb078890a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc75717d2e07f4bfdf0bbebbfd4285efb078890a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a863c83a43c753303ac34623b39411ee4d8aaf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a863c83a43c753303ac34623b39411ee4d8aaf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a863c83a43c753303ac34623b39411ee4d8aaf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a863c83a43c753303ac34623b39411ee4d8aaf5/comments", "author": null, "committer": null, "parents": [{"sha": "4a3b7dbeddc13cb90c5b76ac97add831dda508ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a3b7dbeddc13cb90c5b76ac97add831dda508ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a3b7dbeddc13cb90c5b76ac97add831dda508ca"}], "stats": {"total": 117, "additions": 66, "deletions": 51}, "files": [{"sha": "e7a954e1ee4e9e4b217e60b197a1ca76a57f9e2c", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 66, "deletions": 51, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a863c83a43c753303ac34623b39411ee4d8aaf5/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a863c83a43c753303ac34623b39411ee4d8aaf5/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=9a863c83a43c753303ac34623b39411ee4d8aaf5", "patch": "@@ -115,7 +115,6 @@ extern int set_noat;\t\t\t/* # of nested .set noat's  */\n extern int set_volatile;\t\t/* # of nested .set volatile's  */\n extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n extern int mips_dbx_regno[];\t\t/* Map register # to debug register # */\n-extern char mips_rtx_classify[];\t/* classify an RTX code */\n extern struct rtx_def *branch_cmp[2];\t/* operands for compare */\n extern enum cmp_type branch_type;\t/* what type of branch to use */\n extern enum processor_type mips_cpu;\t/* which cpu are we scheduling for */\n@@ -140,14 +139,11 @@ extern void\t\tabort_with_insn ();\n extern int\t\tarith32_operand ();\n extern int\t\tarith_operand ();\n extern int\t\tcmp_op ();\n-extern int\t\tcmp2_op ();\n extern long\t\tcompute_frame_size ();\n extern int\t\tepilogue_reg_mentioned_p ();\n extern void\t\texpand_block_move ();\n extern int\t\tequality_op ();\n-extern int\t\tfcmp_op ();\n extern void\t\tfinal_prescan_insn ();\n-extern int\t\tfpsw_register_operand ();\n extern struct rtx_def *\tfunction_arg ();\n extern void\t\tfunction_arg_advance ();\n extern int\t\tfunction_arg_partial_nregs ();\n@@ -157,7 +153,6 @@ extern void\t\tgen_conditional_branch ();\n extern struct rtx_def * gen_int_relational ();\n extern void\t\tinit_cumulative_args ();\n extern int\t\tlarge_int ();\n-extern int\t\tmd_register_operand ();\n extern int\t\tmips_address_cost ();\n extern void\t\tmips_asm_file_end ();\n extern void\t\tmips_asm_file_start ();\n@@ -188,7 +183,6 @@ extern int\t\tsimple_memory_operand ();\n extern int\t\tsmall_int ();\n extern void\t\ttrace();\n extern int\t\tuns_arith_operand ();\n-extern int\t\tuns_cmp_op ();\n \n /* Recognition functions that return if a condition is true.  */\n extern int\t\taddress_operand ();\n@@ -2632,7 +2626,14 @@ while (0)\n     {\t\t\t\t\t\t\t\t\t\\\n       enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n       if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n-\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (2);\t\t\t\t\t\\\n+\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (3);\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (6);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (xmode == DImode && !TARGET_64BIT)\t\t\t\t\\\n \treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n@@ -2647,29 +2648,67 @@ while (0)\n     {\t\t\t\t\t\t\t\t\t\\\n       enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n       if (xmode == SFmode)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (4);\t\t\t\t\t\\\n+\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (7);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (xmode == DFmode)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (5);\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n+\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (6);\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (8);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (12);\t\t\t\t\t\\\n+      if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (12);\t\t\t\t\t\\\n+      else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\treturn COSTS_N_INSNS (17);\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (10);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case DIV:\t\t\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n       if (xmode == SFmode)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (12);\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (12);\t\t\t\t\t\\\n+\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (15);\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (23);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (xmode == DFmode)\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (19);\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (19);\t\t\t\t\t\\\n+\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (16);\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (36);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (35);\n+    if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\t\\\n+      return COSTS_N_INSNS (35);\t\t\t\t\t\\\n+    else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+      return COSTS_N_INSNS (38);\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (69);\n \n /* An expression giving the cost of an addressing mode that\n    contains ADDRESS.  If not defined, the cost is computed from the\n@@ -2732,7 +2771,12 @@ while (0)\n    met.  You should do this if the `movM' pattern's constraints do\n    not allow such copying.  */\n \n-#define REGISTER_MOVE_COST(FROM, TO) 4\t/* force reload to use constraints */\n+#define REGISTER_MOVE_COST(FROM, TO)\t\\\n+  ((FROM) == GR_REGS && (TO) == GR_REGS ? 2\t\t\t\t\\\n+   : (FROM) == FP_REGS && (TO) == FP_REGS ? 2\t\t\t\t\\\n+   : (FROM) == GR_REGS && (TO) == FP_REGS ? 4\t\t\t\t\\\n+   : (FROM) == FP_REGS && (TO) == GR_REGS ? 4\t\t\t\t\\\n+   : 6)\n \n #define MEMORY_MOVE_COST(MODE) \\\n   ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 6 : 4)\n@@ -2743,22 +2787,15 @@ while (0)\n #define BRANCH_COST \\\n   ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 2 : 1)\n \n-\f\n-/* Used in by the peephole code.  */\n-#define classify_op(op,mode)\t(mips_rtx_classify[ (int)GET_CODE (op) ])\n-#define additive_op(op,mode)\t((classify_op (op,mode) & CLASS_ADD_OP)      != 0)\n-#define divmod_op(op,mode)\t((classify_op (op,mode) & CLASS_DIVMOD_OP)   != 0)\n-#define unsigned_op(op,mode)\t((classify_op (op,mode) & CLASS_UNSIGNED_OP) != 0)\n-\n-#define CLASS_ADD_OP\t\t0x01\t/* operator is PLUS/MINUS */\n-#define CLASS_DIVMOD_OP\t\t0x02\t/* operator is {,U}{DIV,MOD} */\n-#define CLASS_UNSIGNED_OP\t0x04\t/* operator is U{DIV,MOD} */\n-#define CLASS_CMP_OP\t\t0x08\t/* operator is comparison */\n-#define CLASS_EQUALITY_OP\t0x10\t/* operator is == or != */\n-#define CLASS_FCMP_OP\t\t0x08\t/* operator is fp. compare */\n-\n-#define CLASS_UNS_CMP_OP\t(CLASS_UNSIGNED_OP | CLASS_CMP_OP)\n+/* A C statement (sans semicolon) to update the integer variable COST\n+   based on the relationship between INSN that is dependent on\n+   DEP_INSN through the dependence LINK.  The default is to make no\n+   adjustment to COST.  On the MIPS, ignore the cost of anti- and\n+   output-dependencies.  */\n \n+#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n+  if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n+    (COST) = 0; /* Anti or output dependence.  */\n \f\n /* Optionally define this if you have added predicates to\n    `MACHINE.c'.  This macro is called within an initializer of an\n@@ -2788,18 +2825,13 @@ while (0)\n   {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"large_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"md_register_operand\",\t{ REG }},\t\t\t\t\\\n   {\"mips_const_double_ok\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"simple_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\\n   {\"equality_op\",\t\t{ EQ, NE }},\t\t\t\t\\\n   {\"cmp_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n \t\t\t\t  LTU, LEU }},\t\t\t\t\\\n-  {\"cmp2_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n-\t\t\t\t  LTU, LEU }},\t\t\t\t\\\n-  {\"fcmp_op\",\t\t\t{ EQ, NE, GT, GE, LT, LE }},\t\t\\\n   {\"pc_or_label_operand\",\t{ PC, LABEL_REF }},\t\t\t\\\n   {\"call_insn_operand\",\t\t{ MEM }},\t\t\t\t\\\n-  {\"uns_cmp_op\",\t\t{ GTU, GEU, LTU, LEU }},\n \n \f\n /* If defined, a C statement to be executed just prior to the\n@@ -2825,23 +2857,6 @@ while (0)\n    Here we define machine-dependent flags and fields in cc_status\n    (see `conditions.h').  */\n \n-/* A C compound statement to set the components of `cc_status'\n-   appropriately for an insn INSN whose body is EXP.  It is this\n-   macro's responsibility to recognize insns that set the condition\n-   code as a byproduct of other activity as well as those that\n-   explicitly set `(cc0)'.\n-\n-   This macro is not used on machines that do not use `cc0'.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    enum attr_type type = get_attr_type (INSN);\t\t\t\t\\\n-    if (type == TYPE_ICMP || type == TYPE_FCMP)\t\t\t\t\\\n-      CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n /* A list of names to be used for additional modes for condition code\n    values in registers.  These names are added to `enum machine_mode'\n    and all have class `MODE_CC'.  By convention, they should start"}]}