{"sha": "e22856e8fbeb8c059c5b3b6e867b8c797a774a8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIyODU2ZThmYmViOGMwNTljNWIzYjZlODY3YjhjNzk3YTc3NGE4ZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-05-19T00:34:10Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-05-19T00:34:10Z"}, "message": "(prepare_move_operands): If source is r0, and dest is reg+reg\nMEM, then copy source to a pseudo-reg.\n\nFrom-SVN: r12036", "tree": {"sha": "5bcf53b4bce0ff14cb17f8029d6ecf63018de758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bcf53b4bce0ff14cb17f8029d6ecf63018de758"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e22856e8fbeb8c059c5b3b6e867b8c797a774a8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e22856e8fbeb8c059c5b3b6e867b8c797a774a8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e22856e8fbeb8c059c5b3b6e867b8c797a774a8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e22856e8fbeb8c059c5b3b6e867b8c797a774a8e/comments", "author": null, "committer": null, "parents": [{"sha": "a1a0806af6d53e260b5169bac55a58285dce65f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a0806af6d53e260b5169bac55a58285dce65f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1a0806af6d53e260b5169bac55a58285dce65f7"}], "stats": {"total": 22, "additions": 17, "deletions": 5}, "files": [{"sha": "56fe7543eb59eefa4d25429427036858f2c4c06e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22856e8fbeb8c059c5b3b6e867b8c797a774a8e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22856e8fbeb8c059c5b3b6e867b8c797a774a8e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e22856e8fbeb8c059c5b3b6e867b8c797a774a8e", "patch": "@@ -315,11 +315,23 @@ prepare_move_operands (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n-  /* Copy the source to a register if both operands aren't registers.  */\n-  if (! reload_in_progress && ! reload_completed\n-      && ! register_operand (operands[0], mode)\n-      && ! register_operand (operands[1], mode))\n-    operands[1] = copy_to_mode_reg (mode, operands[1]);\n+  if (! reload_in_progress && ! reload_completed)\n+    {\n+      /* Copy the source to a register if both operands aren't registers.  */\n+      if (! register_operand (operands[0], mode)\n+\t  && ! register_operand (operands[1], mode))\n+\toperands[1] = copy_to_mode_reg (mode, operands[1]);\n+\n+      /* This case can happen while generating code to move the result\n+\t of a library call to the target.  Reject `st r0,@(rX,rY)' because\n+\t reload will fail to find a spill register for rX, since r0 is already\n+\t being used for the source.  */\n+      else if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 0\n+\t       && GET_CODE (operands[0]) == MEM\n+\t       && GET_CODE (XEXP (operands[0], 0)) == PLUS\n+\t       && GET_CODE (XEXP (XEXP (operands[0], 0), 1)) == REG)\n+\toperands[1] = copy_to_mode_reg (mode, operands[1]);\n+    }\n \n   return 0;\n }"}]}