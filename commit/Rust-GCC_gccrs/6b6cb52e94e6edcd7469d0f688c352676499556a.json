{"sha": "6b6cb52e94e6edcd7469d0f688c352676499556a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI2Y2I1MmU5NGU2ZWRjZDc0NjlkMGY2ODhjMzUyNjc2NDk5NTU2YQ==", "commit": {"author": {"name": "Danny Smith", "email": "dannysmith@users.sourceforge.net", "date": "2003-07-04T07:42:11Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2003-07-04T07:42:11Z"}, "message": "PR c++/5287, PR c++/7910, PR c++/11021\n\n\tPR c++/5287, PR c++/7910,  PR c++/11021\n\t* config/i386/winnt.c (ix86_handle_dll_attribute): Don't add\n\tdllimport attribute if function is defined at declaration, but\n\treport error instead. Likewise for dllimport'd variable\n\tdefinitions.  Set implicit TREE_PUBLIC for dllimport'd variables\n\tdeclared within functions, Report error if dllimport or dllexport\n\tsymbol is not global.\n\t(i386_pe_dllimport_p): Ignore dllimport attribute of functions\n\tif defined after declaration or if inlined. Don't allow definition\n\tof static data members of C++ classes. Don't dllimport virtual\n\tmethods.\n\t(i386_pe_mark_dllexport): Warn about inconsistent dll attributes.\n\t(i386_pe_mark_dllimport): Remove unnecessary checks.\n\t(i386_pe_encode_section_info): Warn if the dllimport attribute\n\tand symbol prefix have been instantiated and then overridden.\n\n\t* doc/extend.texi: Document dllimport and dllexport attributes.\n\n\t* config/i386/winnt.c (i386_pe_output_labelref): Fix indents.\n\nFrom-SVN: r68916", "tree": {"sha": "f65870e0bd14c239781b3852c0315e7496177c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f65870e0bd14c239781b3852c0315e7496177c07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b6cb52e94e6edcd7469d0f688c352676499556a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6cb52e94e6edcd7469d0f688c352676499556a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6cb52e94e6edcd7469d0f688c352676499556a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6cb52e94e6edcd7469d0f688c352676499556a/comments", "author": null, "committer": null, "parents": [{"sha": "369b78b0e49eece1fb58e75ad5bf1c7659f78efe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/369b78b0e49eece1fb58e75ad5bf1c7659f78efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/369b78b0e49eece1fb58e75ad5bf1c7659f78efe"}], "stats": {"total": 289, "additions": 227, "deletions": 62}, "files": [{"sha": "5457f7d1bf6dece296ddb13d322ef9adbe604f50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cb52e94e6edcd7469d0f688c352676499556a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cb52e94e6edcd7469d0f688c352676499556a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b6cb52e94e6edcd7469d0f688c352676499556a", "patch": "@@ -1,3 +1,25 @@\n+2003-07-04  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+\tPR c++/5287, PR c++/7910, PR c++/11021\n+\t* config/i386/winnt.c (ix86_handle_dll_attribute): Don't add\n+\tdllimport attribute if function is defined at declaration, but\n+\treport error instead. Likewise for dllimport'd variable\n+\tdefinitions.  Set implicit TREE_PUBLIC for dllimport'd variables\n+\tdeclared within functions, Report error if dllimport or dllexport\n+\tsymbol is not global.\n+\t(i386_pe_dllimport_p): Ignore dllimport attribute of functions\n+\tif defined after declaration or if inlined. Don't allow definition\n+\tof static data members of C++ classes. Don't dllimport virtual\n+\tmethods.\n+\t(i386_pe_mark_dllexport): Warn about inconsistent dll attributes.\n+\t(i386_pe_mark_dllimport): Remove unnecessary checks.\n+\t(i386_pe_encode_section_info): Warn if the dllimport attribute\n+\tand symbol prefix have been instantiated and then overridden.\n+\n+\t* doc/extend.texi: Document dllimport and dllexport attributes.\n+\n+\t* config/i386/winnt.c (i386_pe_output_labelref): Fix indents.\n+\n 2003-07-03 Uwe Stieber <uwe@kaos-group.de>\n \n \t* config/kaos.h (CPP_PREDEFINES): Delete."}, {"sha": "9c5763c000928ca7f24536d7919bb0446e45e9de", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 135, "deletions": 60, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cb52e94e6edcd7469d0f688c352676499556a/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cb52e94e6edcd7469d0f688c352676499556a/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=6b6cb52e94e6edcd7469d0f688c352676499556a", "patch": "@@ -3,19 +3,20 @@\n    Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n \n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n \n You should have received a copy of the GNU General Public License\n+\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n@@ -66,37 +67,77 @@ void i386_pe_mark_dllimport PARAMS ((tree));\n /* Handle a \"dllimport\" or \"dllexport\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n tree\n-ix86_handle_dll_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n+ix86_handle_dll_attribute (pnode, name, args, flags, no_add_attrs)\n+     tree * pnode;\n      tree name;\n      tree args;\n      int flags;\n      bool *no_add_attrs;\n {\n+  tree node = *pnode;\n+\n   /* These attributes may apply to structure and union types being created,\n      but otherwise should pass to the declaration involved.  */\n-  if (!DECL_P (*node))\n+  if (!DECL_P (node))\n     {\n       if (flags & ((int) ATTR_FLAG_DECL_NEXT | (int) ATTR_FLAG_FUNCTION_NEXT\n \t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n \t{\n \t  *no_add_attrs = true;\n \t  return tree_cons (name, args, NULL_TREE);\n \t}\n-      if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)\n+      if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n \t{\n \t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n \t  *no_add_attrs = true;\n \t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Report error on dllimport ambiguities seen now before they cause\n+     any damage.  */\n+  else if (is_attribute_p (\"dllimport\", name))\n+    {\n+      /* Like MS, treat definition of dllimported variables and\n+\t non-inlined functions on declaration as syntax errors.\n+\t We allow the attribute for function definitions if declared\n+\t inline, but just ignore it in i386_pe_dllimport_p.  */\n+      if (TREE_CODE (node) == FUNCTION_DECL  && DECL_INITIAL (node)\n+          && !DECL_INLINE (node))\n+\t{\n+\t  error (\"%Hfunction `%D' definition is marked dllimport.\",\n+\t\t &DECL_SOURCE_LOCATION (node), node);\n+\t  *no_add_attrs = true;\n+\t}\n+\n+      else if (TREE_CODE (node) == VAR_DECL)\n+\t{\n+\t  if (DECL_INITIAL (node))\n+\t    {\n+\t      error (\"%Hvariable `%D' definition is marked dllimport.\",\n+\t\t     &DECL_SOURCE_LOCATION (node), node);\n+\t      *no_add_attrs = true;\n+\t    }\n+\n+\t  /* `extern' needn't be specified with dllimport.\n+\t     Specify `extern' now and hope for the best.  Sigh.  */\n+\t  DECL_EXTERNAL (node) = 1; \n+\t  /* Also, implicitly give dllimport'd variables declared within\n+\t     a function global scope, unless declared static.  */\n+\t  if (current_function_decl != NULL_TREE && !TREE_STATIC (node))\n+  \t    TREE_PUBLIC (node) = 1;\n+\t}\n     }\n \n-  /* `extern' needn't be specified with dllimport.\n-     Specify `extern' now and hope for the best.  Sigh.  */\n-  else if (TREE_CODE (*node) == VAR_DECL\n-\t   && is_attribute_p (\"dllimport\", name))\n+  /*  Report error if symbol is not accessible at global scope. */\n+  if (!TREE_PUBLIC (node)\n+      && (TREE_CODE (node) == VAR_DECL\n+\t  || TREE_CODE (node) == FUNCTION_DECL)) \n     {\n-      DECL_EXTERNAL (*node) = 1;\n-      TREE_PUBLIC (*node) = 1;\n+      error (\"%Hexternal linkage required for symbol '%D' because of '%s' attribute.\",\n+\t       &DECL_SOURCE_LOCATION (node), node, IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n \n   return NULL_TREE;\n@@ -181,6 +222,7 @@ i386_pe_dllimport_p (decl)\n      tree decl;\n {\n   tree imp;\n+  int context_imp = 0;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && TARGET_NOP_FUN_DLLIMPORT)\n@@ -189,17 +231,65 @@ i386_pe_dllimport_p (decl)\n   if (TREE_CODE (decl) != VAR_DECL\n       && TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n+\n   imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n-  if (imp)\n-    return 1;\n \n   /* Class members get the dllimport status of their class.  */\n-  if (associated_type (decl))\n+  if (!imp && associated_type (decl))\n     {\n       imp = lookup_attribute (\"dllimport\",\n \t\t\t      TYPE_ATTRIBUTES (associated_type (decl)));\n       if (imp)\n-\treturn 1;\n+\tcontext_imp = 1;\n+    }\n+\n+  if (imp)\n+    {\n+      /* Don't mark defined functions as dllimport.  If the definition\n+\t itself was marked with dllimport, than ix86_handle_dll_attribute\n+\t reports an error. This handles the case when the definition\n+\t overrides an earlier declaration.  */\n+      if (TREE_CODE (decl) ==  FUNCTION_DECL && DECL_INITIAL (decl)\n+\t  && !DECL_INLINE (decl))\n+\t{\n+\t   /* Don't warn about artificial methods.  */\n+\t  if (!DECL_ARTIFICIAL (decl))\n+\t    warning (\"%H function '%D' is defined after prior declaration as dllimport: attribute ignored\",\n+\t\t     &DECL_SOURCE_LOCATION (decl), decl);\n+\t  return 0;\n+\t}\n+\n+      /* We ignore the dllimport attribute for inline member functions.\n+\t This differs from MSVC behaviour which treats it like GNUC\n+     \t 'extern inline' extension.   */\n+      else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n+        {\n+\t  if (extra_warnings)\n+\t    warning (\"%Hinline function '%D' is declared as dllimport: attribute ignored.\", \n+\t\t     &DECL_SOURCE_LOCATION (decl), decl);\n+\t  return 0;\n+\t}\n+\n+      /*  Don't allow definitions of static data members in dllimport class,\n+\t  Just ignore attribute for vtable data.  */\n+      else if (TREE_CODE (decl) == VAR_DECL\n+\t       && TREE_STATIC (decl) && TREE_PUBLIC (decl)\n+\t       && !DECL_EXTERNAL (decl) && context_imp)\n+\t{\n+\t  if (!DECL_VIRTUAL_P (decl))\n+\t      error (\"%Hdefinition of static data member '%D' of dllimport'd class.\", \n+\t\t     &DECL_SOURCE_LOCATION (decl), decl);\n+           return 0;\n+\t}\n+\n+      /* Since we can't treat a pointer to a dllimport'd symbol as a\n+\t constant address, we turn off the attribute on C++ virtual\n+\t methods to allow creation of vtables using thunks. */\n+      else if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n+\t       && (DECL_VIRTUAL_P (decl)))\n+           return 0;\n+\n+      return 1;\n     }\n \n   return 0;\n@@ -246,10 +336,15 @@ i386_pe_mark_dllexport (decl)\n   else\n     abort ();\n   if (i386_pe_dllimport_name_p (oldname))\n-    /* Remove DLL_IMPORT_PREFIX.  */\n-    oldname += strlen (DLL_IMPORT_PREFIX);\n+    {\n+      warning (\"%Hinconsistent dll linkage for '%D, dllexport assumed.\",\n+\t       &DECL_SOURCE_LOCATION (decl), decl);\n+     /* Remove DLL_IMPORT_PREFIX.  */\n+      oldname += strlen (DLL_IMPORT_PREFIX);\n+      DECL_NON_ADDR_CONST_P (decl) = 0;\n+    }\n   else if (i386_pe_dllexport_name_p (oldname))\n-    return; /* already done */\n+    return;  /*  already done  */\n \n   newname = alloca (strlen (DLL_EXPORT_PREFIX) + strlen (oldname) + 1);\n   sprintf (newname, \"%s%s\", DLL_EXPORT_PREFIX, oldname);\n@@ -291,41 +386,16 @@ i386_pe_mark_dllimport (decl)\n     }\n   else if (i386_pe_dllimport_name_p (oldname))\n     {\n-      /* Already done, but force correct linkage since the redeclaration \n-         might have omitted explicit extern.  Sigh.  */\n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  /* ??? Is this test for vtables needed?  */\n-\t  && !DECL_VIRTUAL_P (decl))\n+      /* Already done, but do a sanity check to prevent assembler errors. */\n+      if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n \t{\n-\t  DECL_EXTERNAL (decl) = 1;\n-\t  TREE_PUBLIC (decl) = 1;\n+\t  error (\"%Hfailure in redeclaration of '%D': dllimport'd symbol lacks external linkage.\", \n+\t\t &DECL_SOURCE_LOCATION (decl), decl);\n+\t  abort();\n \t}\n       return;\n     }\n \n-  /* ??? One can well ask why we're making these checks here,\n-     and that would be a good question.  */\n-\n-  /* Imported variables can't be initialized. Note that C++ classes\n-     are marked initial, so we need to check.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && !DECL_VIRTUAL_P (decl)\n-      && (DECL_INITIAL (decl)\n-          && ! TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))))\n-    {\n-      error_with_decl (decl, \"initialized variable `%s' is marked dllimport\");\n-      return;\n-    }\n-  /* Nor can they be static.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      /* ??? Is this test for vtables needed?  */\n-      && !DECL_VIRTUAL_P (decl)\n-      && 0 /*???*/)\n-    {\n-      error_with_decl (decl, \"static variable `%s' is marked dllimport\");\n-      return;\n-    }\n-\n   newname = alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);\n   sprintf (newname, \"%s%s\", DLL_IMPORT_PREFIX, oldname);\n \n@@ -443,7 +513,7 @@ i386_pe_encode_section_info (decl, rtl, first)\n \n   /* Mark the decl so we can tell from the rtl whether the object is\n      dllexport'd or dllimport'd.  This also handles dllexport/dllimport\n-     override semantics.   */\n+     override semantics.  */\n \n   if (i386_pe_dllexport_p (decl))\n     i386_pe_mark_dllexport (decl);\n@@ -466,6 +536,12 @@ i386_pe_encode_section_info (decl, rtl, first)\n       tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n       rtx newrtl = gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n \n+      warning (\"%H%s '%D' %s after being referenced with dllimport linkage.\",\n+\t         &DECL_SOURCE_LOCATION (decl),\n+\t         TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\", \n+\t         decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n+\t\t\t? \"defined locally\" : \"redeclared without dllimport attribute\");\n+\n       XEXP (DECL_RTL (decl), 0) = newrtl;\n \n       DECL_NON_ADDR_CONST_P (decl) = 0;\n@@ -519,8 +595,8 @@ void i386_pe_output_labelref (stream, name)\n {\n   if (strncmp (name, DLL_IMPORT_PREFIX, strlen (DLL_IMPORT_PREFIX))\n       == 0)\n-   /* A dll import */ \n-   {\n+    /* A dll import */ \n+    {\n       if (name[strlen (DLL_IMPORT_PREFIX)] == FASTCALL_PREFIX)\n       /* A dllimport fastcall symbol.  */   \n         {\n@@ -796,4 +872,3 @@ i386_pe_file_end ()\n \t}\n     }\n }\n-"}, {"sha": "dcefcdc89f18cae8ce945e943e625261d8356eac", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cb52e94e6edcd7469d0f688c352676499556a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cb52e94e6edcd7469d0f688c352676499556a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6b6cb52e94e6edcd7469d0f688c352676499556a", "patch": "@@ -2563,6 +2563,67 @@ use the normal calling convention based on @code{jsr} and @code{rts}.\n This attribute can be used to cancel the effect of the @option{-mlong-calls}\n option.\n \n+@item dllimport\n+@cindex @code{__declspec(dllimport)}\n+On Windows targets, the @code{dllimport} attribute causes the compiler\n+to reference a function or variable via a global pointer to a pointer\n+that is set up by the Windows dll library. The pointer name is formed by\n+combining @code{_imp__} and the function or variable name. The attribute\n+implies @code{extern} storage.\n+\n+Currently, the attribute is ignored for inlined functions. If the\n+attribute is applied to a symbol @emph{definition}, an error is reported.\n+If a symbol previously declared @code{dllimport} is later defined, the\n+attribute is ignored in subsequent references, and a warning is emitted.\n+The attribute is also overriden by a subsequent declaration as\n+@code{dllexport}. \n+\n+When applied to C++ classes, the attribute marks non-inlined\n+member functions and static data members as imports.  However, the\n+attribute is ignored for virtual methods to allow creation of vtables\n+using thunks.\n+\n+On cygwin, mingw and arm-pe targets, @code{__declspec(dllimport)} is\n+recognized as a synonym for @code{__attribute__ ((dllimport))} for\n+compatibility with other Windows compilers.\n+\n+The use of the @code{dllimport} attribute on functions is not necessary,\n+but provides a small performance benefit by eliminating a thunk in the\n+dll. The use of the @code{dllimport} attribute on imported variables was\n+required on older versions of GNU ld, but can now be avoided by passing\n+the @option{--enable-auto-import} switch to ld. As with functions, using\n+the attribute for a variable eliminates a thunk in the dll. \n+\n+One drawback to using this attribute is that a pointer to a function or\n+variable marked as dllimport cannot be used as a constant address. The\n+attribute can be disabled for functions by setting the\n+@option{-mnop-fun-dllimport} flag.\n+\n+@item dllexport\n+@cindex @code{__declspec(dllexport)}\n+On Windows targets the @code{dllexport} attribute causes the compiler to\n+provide a global pointer to a pointer in a dll, so that it can be\n+referenced with the @code{dllimport} attribute. The pointer name is\n+formed by combining @code{_imp__} and the function or variable name.\n+\n+Currently, the @code{dllexport}attribute is ignored for inlined\n+functions, but export can be forced by using the\n+@option{-fkeep-inline-functions} flag. The attribute is also ignored for\n+undefined symbols.\n+\n+When applied to C++ classes. the attribute marks defined non-inlined\n+member functions and static data members as exports. Static consts\n+initialized in-class are not marked unless they are also defined\n+out-of-class.\n+\n+On cygwin, mingw and arm-pe targets, @code{__declspec(dllexport)} is\n+recognized as a synonym for @code{__attribute__ ((dllexport))} for\n+compatibility with other Windows compilers.\n+\n+Alternative methods for including the symbol in the dll's export table\n+are to use a .def file with an @code{EXPORTS} section or, with GNU ld,\n+using the @option{--export-all} linker flag.\n+\n @end table\n \n You can specify multiple attributes in a declaration by separating them\n@@ -3163,7 +3224,7 @@ section, consider using the facilities of the linker instead.\n \n @item shared\n @cindex @code{shared} variable attribute\n-On Windows NT, in addition to putting variable definitions in a named\n+On Windows, in addition to putting variable definitions in a named\n section, the section can also be shared among all running copies of an\n executable or DLL@.  For example, this small program defines shared data\n by putting it in a named section @code{shared} and marking the section\n@@ -3186,7 +3247,7 @@ You may only use the @code{shared} attribute along with @code{section}\n attribute with a fully initialized global definition because of the way\n linkers work.  See @code{section} attribute for more information.\n \n-The @code{shared} attribute is only available on Windows NT@.\n+The @code{shared} attribute is only available on Windows@.\n \n @item tls_model (\"@var{tls_model}\")\n @cindex @code{tls_model} attribute\n@@ -3243,6 +3304,13 @@ the @code{int}.\n \n @item weak\n The @code{weak} attribute is described in @xref{Function Attributes}.\n+\n+@item dllimport\n+The @code{dllimport} attribute is described in @xref{Function Attributes}.\n+\n+@item dlexport\n+The @code{dllexport} attribute is described in @xref{Function Attributes}.\n+\n @end table\n \n @subsection M32R/D Variable Attributes"}]}