{"sha": "2adc7f1284cb738d1633becaf566196bee37435b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFkYzdmMTI4NGNiNzM4ZDE2MzNiZWNhZjU2NjE5NmJlZTM3NDM1Yg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2002-04-22T23:22:33Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2002-04-22T23:22:33Z"}, "message": "rtl.h (RTX_FLAG): New macro.\n\n\t* rtl.h (RTX_FLAG): New macro.\n\t* emit-rtl.c (copy_most_rtx): Use macros to access rtx flags.\n\t* final.c (alter_subreg): Use macro to access rtx flag.\n\t* integrate.c (copy_rtx_and_substitute): Use new access macro.\n\t* print-rtl.c (print_rtx): Use new access macro.\n\n\t* cse.c (insert): Check rtx code before accessing flag.\n\n\t* genattrtab.c (ATTR_IND_SIMPLIFIED_P, ATTR_CURR_SIMPLIFIED_P,\n\tATTR_PERMANENT_P, ATTR_EQ_ATTR_P): New.\n\t(attr_hash_add_string, attr_rtx_1, attr_copy_rtx, check_attr_test,\n\tconvert_const_symbol_ref, make_canonical, make_alternative_compare,\n\tevaluate_eq_attr, attr_rtx_cost, simplify_test_exp_in_temp,\n\tsimplify_test_exp, optimize_attrs, simplify_by_exploding,\n\tfind_and_mark_used_attributes, unmark_used_attributes,\n\tadd_values_to_cover, simplify_with_current_value,\n\tsimplify_with_current_value_aux, clear_struct_flag, walk_attr_value,\n\tcopy_rtx_unchanging, main): Use new access macros.\n\nFrom-SVN: r52645", "tree": {"sha": "233a32e3b9d05c7c497c48df9355d761169869b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/233a32e3b9d05c7c497c48df9355d761169869b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2adc7f1284cb738d1633becaf566196bee37435b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adc7f1284cb738d1633becaf566196bee37435b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2adc7f1284cb738d1633becaf566196bee37435b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adc7f1284cb738d1633becaf566196bee37435b/comments", "author": null, "committer": null, "parents": [{"sha": "b7c89afe9000e63a1c0f3e8502624191e5a6135d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c89afe9000e63a1c0f3e8502624191e5a6135d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c89afe9000e63a1c0f3e8502624191e5a6135d"}], "stats": {"total": 195, "additions": 111, "deletions": 84}, "files": [{"sha": "32f1217d03a31ed47b93d878874e95dc8bbeab59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -1,3 +1,24 @@\n+2002-04-22  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* rtl.h (RTX_FLAG): New macro.\n+\t* emit-rtl.c (copy_most_rtx): Use macros to access rtx flags.\n+\t* final.c (alter_subreg): Use macro to access rtx flag.\n+\t* integrate.c (copy_rtx_and_substitute): Use new access macro.\n+\t* print-rtl.c (print_rtx): Use new access macro.\n+\n+\t* cse.c (insert): Check rtx code before accessing flag.\n+\n+\t* genattrtab.c (ATTR_IND_SIMPLIFIED_P, ATTR_CURR_SIMPLIFIED_P,\n+\tATTR_PERMANENT_P, ATTR_EQ_ATTR_P): New.\n+\t(attr_hash_add_string, attr_rtx_1, attr_copy_rtx, check_attr_test,\n+\tconvert_const_symbol_ref, make_canonical, make_alternative_compare,\n+\tevaluate_eq_attr, attr_rtx_cost, simplify_test_exp_in_temp,\n+\tsimplify_test_exp, optimize_attrs, simplify_by_exploding,\n+\tfind_and_mark_used_attributes, unmark_used_attributes,\n+\tadd_values_to_cover, simplify_with_current_value,\n+\tsimplify_with_current_value_aux, clear_struct_flag, walk_attr_value,\n+\tcopy_rtx_unchanging, main): Use new access macros.\n+\n 2002-04-22  Tom Rix  <trix@redhat.com>\n \n \t* expmed.c (init_expmed): Generate shifted constant once."}, {"sha": "1f3ac4f3f99fc144a900508852bf27242fcd08ef", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -1601,8 +1601,8 @@ insert (x, classp, hash, mode)\n   elt->is_const = (CONSTANT_P (x)\n \t\t   /* GNU C++ takes advantage of this for `this'\n \t\t      (and other const values).  */\n-\t\t   || (RTX_UNCHANGING_P (x)\n-\t\t       && GET_CODE (x) == REG\n+\t\t   || (GET_CODE (x) == REG\n+\t\t       && RTX_UNCHANGING_P (x)\n \t\t       && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n \t\t   || FIXED_BASE_PLUS_P (x));\n "}, {"sha": "073688a1708e6830f76678dcadb0cec66823c9cb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -2286,11 +2286,11 @@ copy_most_rtx (orig, may_share)\n \n   copy = rtx_alloc (code);\n   PUT_MODE (copy, GET_MODE (orig));\n-  copy->in_struct = orig->in_struct;\n-  copy->volatil = orig->volatil;\n-  copy->unchanging = orig->unchanging;\n-  copy->integrated = orig->integrated;\n-  copy->frame_related = orig->frame_related;\n+  RTX_FLAG (copy, in_struct) = RTX_FLAG (orig, in_struct);\n+  RTX_FLAG (copy, volatil) = RTX_FLAG (orig, volatil);\n+  RTX_FLAG (copy, unchanging) = RTX_FLAG (orig, unchanging);\n+  RTX_FLAG (copy, integrated) = RTX_FLAG (orig, integrated);\n+  RTX_FLAG (copy, frame_related) = RTX_FLAG (orig, frame_related);\n \n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n@@ -2423,7 +2423,7 @@ copy_rtx_if_shared (orig)\n   /* This rtx may not be shared.  If it has already been seen,\n      replace it with a copy of itself.  */\n \n-  if (x->used)\n+  if (RTX_FLAG (x, used))\n     {\n       rtx copy;\n \n@@ -2434,7 +2434,7 @@ copy_rtx_if_shared (orig)\n       x = copy;\n       copied = 1;\n     }\n-  x->used = 1;\n+  RTX_FLAG (x, used) = 1;\n \n   /* Now scan the subexpressions recursively.\n      We can store any replaced subexpressions directly into X\n@@ -2513,7 +2513,7 @@ reset_used_flags (x)\n       break;\n     }\n \n-  x->used = 0;\n+  RTX_FLAG (x, used) = 0;\n \n   format_ptr = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++)\n@@ -4467,8 +4467,8 @@ gen_sequence ()\n      We only return the pattern of an insn if its code is INSN and it\n      has no notes.  This ensures that no information gets lost.  */\n   if (len == 1\n-      && ! RTX_FRAME_RELATED_P (first_insn)\n       && GET_CODE (first_insn) == INSN\n+      && ! RTX_FRAME_RELATED_P (first_insn)\n       /* Don't throw away any reg notes.  */\n       && REG_NOTES (first_insn) == 0)\n     return PATTERN (first_insn);\n@@ -4592,14 +4592,14 @@ copy_insn_1 (orig)\n \n   /* We do not copy the USED flag, which is used as a mark bit during\n      walks over the RTL.  */\n-  copy->used = 0;\n+  RTX_FLAG (copy, used) = 0;\n \n   /* We do not copy JUMP, CALL, or FRAME_RELATED for INSNs.  */\n   if (GET_RTX_CLASS (code) == 'i')\n     {\n-      copy->jump = 0;\n-      copy->call = 0;\n-      copy->frame_related = 0;\n+      RTX_FLAG (copy, jump) = 0;\n+      RTX_FLAG (copy, call) = 0;\n+      RTX_FLAG (copy, frame_related) = 0;\n     }\n \n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));"}, {"sha": "c76f6548b780409e15867b0cf3015427c80ca7e5", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -2761,7 +2761,7 @@ alter_subreg (xp)\n \t  ORIGINAL_REGNO (x) = ORIGINAL_REGNO (y);\n \t  /* This field has a different meaning for REGs and SUBREGs.  Make\n \t     sure to clear it!  */\n-\t  x->used = 0;\n+\t  RTX_FLAG (x, used) = 0;\n \t}\n       else\n \tabort ();"}, {"sha": "2c9b007000dc095cc8fbd1462902ed2ca588fd22", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -86,15 +86,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    definitions (each would be accessed through a pointer).\n \n    We use the flags in an RTX as follows:\n-   `unchanging' (RTX_UNCHANGING_P): This rtx is fully simplified\n+   `unchanging' (ATTR_IND_SIMPLIFIED_P): This rtx is fully simplified\n       independent of the insn code.\n-   `in_struct' (MEM_IN_STRUCT_P): This rtx is fully simplified\n+   `in_struct' (ATTR_CURR_SIMPLIFIED_P): This rtx is fully simplified\n       for the insn code currently being processed (see optimize_attrs).\n-   `integrated' (RTX_INTEGRATED_P): This rtx is permanent and unique\n+   `integrated' (ATTR_PERMANENT_P): This rtx is permanent and unique\n       (see attr_rtx).\n-   `volatil' (MEM_VOLATILE_P): During simplify_by_exploding the value of an\n+   `volatil' (ATTR_EQ_ATTR_P): During simplify_by_exploding the value of an\n       EQ_ATTR rtx is true if !volatil and false if volatil.  */\n \n+#define ATTR_IND_SIMPLIFIED_P(RTX) (RTX_FLAG((RTX), unchanging))\n+#define ATTR_CURR_SIMPLIFIED_P(RTX) (RTX_FLAG((RTX), in_struct))\n+#define ATTR_PERMANENT_P(RTX) (RTX_FLAG((RTX), integrated))\n+#define ATTR_EQ_ATTR_P(RTX) (RTX_FLAG((RTX), volatil))\n+\n #include \"hconfig.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n@@ -262,7 +267,7 @@ static struct function_unit *units;\n \n    The algorithm relies on sharing EQ_ATTR nodes: if two nodes in an\n    expression are the same, the will also have the same address.  We find\n-   all the EQ_ATTR nodes by marking them MEM_VOLATILE_P.  This bit later\n+   all the EQ_ATTR nodes by marking them ATTR_EQ_ATTR_P.  This bit later\n    represents the value of an EQ_ATTR node, so once all nodes are marked,\n    they are also given an initial value of FALSE.\n \n@@ -344,7 +349,7 @@ int optimize = 0;\n /* Simplify an expression.  Only call the routine if there is something to\n    simplify.  */\n #define SIMPLIFY_TEST_EXP(EXP,INSN_CODE,INSN_INDEX)\t\\\n-  (RTX_UNCHANGING_P (EXP) || MEM_IN_STRUCT_P (EXP) ? (EXP)\t\\\n+  (ATTR_IND_SIMPLIFIED_P (EXP) || ATTR_CURR_SIMPLIFIED_P (EXP) ? (EXP)\t\\\n    : simplify_test_exp (EXP, INSN_CODE, INSN_INDEX))\n \n /* Simplify (eq_attr (\"alternative\") ...)\n@@ -532,10 +537,10 @@ attr_hash_add_string (hashcode, str)\n }\n \n /* Generate an RTL expression, but avoid duplicates.\n-   Set the RTX_INTEGRATED_P flag for these permanent objects.\n+   Set the ATTR_PERMANENT_P flag for these permanent objects.\n \n    In some cases we cannot uniquify; then we return an ordinary\n-   impermanent rtx with RTX_INTEGRATED_P clear.\n+   impermanent rtx with ATTR_PERMANENT_P clear.\n \n    Args are like gen_rtx, but without the mode:\n \n@@ -560,7 +565,7 @@ attr_rtx_1 (code, p)\n       rtx arg0 = va_arg (p, rtx);\n \n       /* A permanent object cannot point to impermanent ones.  */\n-      if (! RTX_INTEGRATED_P (arg0))\n+      if (! ATTR_PERMANENT_P (arg0))\n \t{\n \t  rt_val = rtx_alloc (code);\n \t  XEXP (rt_val, 0) = arg0;\n@@ -589,7 +594,7 @@ attr_rtx_1 (code, p)\n       rtx arg1 = va_arg (p, rtx);\n \n       /* A permanent object cannot point to impermanent ones.  */\n-      if (! RTX_INTEGRATED_P (arg0) || ! RTX_INTEGRATED_P (arg1))\n+      if (! ATTR_PERMANENT_P (arg0) || ! ATTR_PERMANENT_P (arg1))\n \t{\n \t  rt_val = rtx_alloc (code);\n \t  XEXP (rt_val, 0) = arg0;\n@@ -713,7 +718,7 @@ attr_rtx_1 (code, p)\n \n   rtl_obstack = old_obstack;\n   attr_hash_add_rtx (hashcode, rt_val);\n-  RTX_INTEGRATED_P (rt_val) = 1;\n+  ATTR_PERMANENT_P (rt_val) = 1;\n   return rt_val;\n }\n \n@@ -810,7 +815,7 @@ static int\n attr_equal_p (x, y)\n      rtx x, y;\n {\n-  return (x == y || (! (RTX_INTEGRATED_P (x) && RTX_INTEGRATED_P (y))\n+  return (x == y || (! (ATTR_PERMANENT_P (x) && ATTR_PERMANENT_P (y))\n \t\t     && rtx_equal_p (x, y)));\n }\n \f\n@@ -828,7 +833,7 @@ attr_copy_rtx (orig)\n   const char *format_ptr;\n \n   /* No need to copy a permanent object.  */\n-  if (RTX_INTEGRATED_P (orig))\n+  if (ATTR_PERMANENT_P (orig))\n     return orig;\n \n   code = GET_CODE (orig);\n@@ -852,10 +857,10 @@ attr_copy_rtx (orig)\n \n   copy = rtx_alloc (code);\n   PUT_MODE (copy, GET_MODE (orig));\n-  copy->in_struct = orig->in_struct;\n-  copy->volatil = orig->volatil;\n-  copy->unchanging = orig->unchanging;\n-  copy->integrated = orig->integrated;\n+  ATTR_IND_SIMPLIFIED_P (copy) = ATTR_IND_SIMPLIFIED_P (orig);\n+  ATTR_CURR_SIMPLIFIED_P (copy) = ATTR_CURR_SIMPLIFIED_P (orig);\n+  ATTR_PERMANENT_P (copy) = ATTR_PERMANENT_P (orig);\n+  ATTR_EQ_ATTR_P (copy) = ATTR_EQ_ATTR_P (orig);\n \n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n@@ -945,7 +950,7 @@ check_attr_test (exp, is_const, lineno)\n \t\t{\n \t\t  XSTR (exp, 0) = alternative_name;\n \t\t  /* This can't be simplified any further.  */\n-\t\t  RTX_UNCHANGING_P (exp) = 1;\n+\t\t  ATTR_IND_SIMPLIFIED_P (exp) = 1;\n \t\t  return exp;\n \t\t}\n \t      else\n@@ -964,7 +969,7 @@ check_attr_test (exp, is_const, lineno)\n \t     constant attribute, so don't expand this until it's time to\n \t     write the test expression.  */\n \t  if (attr->is_const)\n-\t    RTX_UNCHANGING_P (exp) = 1;\n+\t    ATTR_IND_SIMPLIFIED_P (exp) = 1;\n \n \t  if (attr->is_numeric)\n \t    {\n@@ -1026,7 +1031,7 @@ check_attr_test (exp, is_const, lineno)\n \tfatal (\"RTL operator \\\"%s\\\" not valid in constant attribute test\",\n \t       GET_RTX_NAME (GET_CODE (exp)));\n       /* These cases can't be simplified.  */\n-      RTX_UNCHANGING_P (exp) = 1;\n+      ATTR_IND_SIMPLIFIED_P (exp) = 1;\n       break;\n \n     case LE:  case LT:  case GT:  case GE:\n@@ -1038,7 +1043,7 @@ check_attr_test (exp, is_const, lineno)\n \t\t\tattr_rtx (SYMBOL_REF, XSTR (XEXP (exp, 0), 0)),\n \t\t\tattr_rtx (SYMBOL_REF, XSTR (XEXP (exp, 1), 0)));\n       /* These cases can't be simplified.  */\n-      RTX_UNCHANGING_P (exp) = 1;\n+      ATTR_IND_SIMPLIFIED_P (exp) = 1;\n       break;\n \n     case SYMBOL_REF:\n@@ -1047,7 +1052,7 @@ check_attr_test (exp, is_const, lineno)\n \t  /* These cases are valid for constant attributes, but can't be\n \t     simplified.  */\n \t  exp = attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n-\t  RTX_UNCHANGING_P (exp) = 1;\n+\t  ATTR_IND_SIMPLIFIED_P (exp) = 1;\n \t  break;\n \t}\n     default:\n@@ -1405,7 +1410,7 @@ convert_const_symbol_ref (exp, attr)\n \t*p = TOUPPER (*p);\n \n       value = attr_rtx (SYMBOL_REF, string);\n-      RTX_UNCHANGING_P (value) = 1;\n+      ATTR_IND_SIMPLIFIED_P (value) = 1;\n \n       XVECEXP (condexp, 0, 2 * i) = attr_rtx (EQ, exp, value);\n \n@@ -1446,18 +1451,18 @@ make_canonical (attr, exp)\n       break;\n \n     case SYMBOL_REF:\n-      if (!attr->is_const || RTX_UNCHANGING_P (exp))\n+      if (!attr->is_const || ATTR_IND_SIMPLIFIED_P (exp))\n \tbreak;\n       /* The SYMBOL_REF is constant for a given run, so mark it as unchanging.\n \t This makes the COND something that won't be considered an arbitrary\n \t expression by walk_attr_value.  */\n-      RTX_UNCHANGING_P (exp) = 1;\n+      ATTR_IND_SIMPLIFIED_P (exp) = 1;\n #if 0\n       /* ??? Why do we do this?  With attribute values { A B C D E }, this\n          tends to generate (!(x==A) && !(x==B) && !(x==C) && !(x==D)) rather\n \t than (x==E).  */\n       exp = convert_const_symbol_ref (exp, attr);\n-      RTX_UNCHANGING_P (exp) = 1;\n+      ATTR_IND_SIMPLIFIED_P (exp) = 1;\n       exp = check_attr_value (exp, attr);\n       /* Goto COND case since this is now a COND.  Note that while the\n          new expression is rescanned, all symbol_ref notes are marked as\n@@ -2824,7 +2829,7 @@ make_alternative_compare (mask)\n     ;\n \n   newexp = attr_rtx (EQ_ATTR, alternative_name, attr_numeral (i));\n-  RTX_UNCHANGING_P (newexp) = 1;\n+  ATTR_IND_SIMPLIFIED_P (newexp) = 1;\n \n   return newexp;\n }\n@@ -2932,15 +2937,15 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n     abort ();\n \n   /* If uses an address, must return original expression.  But set the\n-     RTX_UNCHANGING_P bit so we don't try to simplify it again.  */\n+     ATTR_IND_SIMPLIFIED_P bit so we don't try to simplify it again.  */\n \n   address_used = 0;\n   walk_attr_value (newexp);\n \n   if (address_used)\n     {\n       /* This had `&& current_alternative_string', which seems to be wrong.  */\n-      if (! RTX_UNCHANGING_P (exp))\n+      if (! ATTR_IND_SIMPLIFIED_P (exp))\n \treturn copy_rtx_unchanging (exp);\n       return exp;\n     }\n@@ -3198,7 +3203,7 @@ attr_rtx_cost (x)\n \f\n \n /* Simplify test expression and use temporary obstack in order to avoid\n-   memory bloat.  Use RTX_UNCHANGING_P to avoid unnecesary simplifications\n+   memory bloat.  Use ATTR_IND_SIMPLIFIED to avoid unnecesary simplifications\n    and avoid unnecesary copying if possible.  */\n \n static rtx\n@@ -3208,7 +3213,7 @@ simplify_test_exp_in_temp (exp, insn_code, insn_index)\n {\n   rtx x;\n   struct obstack *old;\n-  if (RTX_UNCHANGING_P (exp))\n+  if (ATTR_IND_SIMPLIFIED_P (exp))\n     return exp;\n   old = rtl_obstack;\n   rtl_obstack = temp_obstack;\n@@ -3241,7 +3246,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n   rtx newexp = exp;\n \n   /* Don't re-simplify something we already simplified.  */\n-  if (RTX_UNCHANGING_P (exp) || MEM_IN_STRUCT_P (exp))\n+  if (ATTR_IND_SIMPLIFIED_P (exp) || ATTR_CURR_SIMPLIFIED_P (exp))\n     return exp;\n \n   switch (GET_CODE (exp))\n@@ -3491,7 +3496,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n      won't buy anything unless we weren't given a valid insn code\n      to process (i.e., we are canonicalizing something.).  */\n   if (insn_code != -2 /* Seems wrong: && current_alternative_string.  */\n-      && ! RTX_UNCHANGING_P (newexp))\n+      && ! ATTR_IND_SIMPLIFIED_P (newexp))\n     return copy_rtx_unchanging (newexp);\n \n   return newexp;\n@@ -3559,7 +3564,7 @@ optimize_attrs ()\n   /* Process one insn code at a time.  */\n   for (i = -2; i < insn_code_number; i++)\n     {\n-      /* Clear the MEM_IN_STRUCT_P flag everywhere relevant.\n+      /* Clear the ATTR_CURR_SIMPLIFIED_P flag everywhere relevant.\n \t We use it to mean \"already simplified for this insn\".  */\n       for (iv = insn_code_values[i]; iv; iv = iv->next)\n \tclear_struct_flag (iv->av->value);\n@@ -3747,13 +3752,13 @@ simplify_by_exploding (exp)\n   most_tests = -1;\n   for (i = num_marks = 0; i < total; i++)\n     if (GET_CODE (condval[i]) == CONST_STRING\n-\t&& ! MEM_VOLATILE_P (condval[i]))\n+\t&& ! ATTR_EQ_ATTR_P (condval[i]))\n       {\n \t/* Mark the unmarked constant value and count how many are marked.  */\n-\tMEM_VOLATILE_P (condval[i]) = 1;\n+\tATTR_EQ_ATTR_P (condval[i]) = 1;\n \tfor (j = new_marks = 0; j < total; j++)\n \t  if (GET_CODE (condval[j]) == CONST_STRING\n-\t      && MEM_VOLATILE_P (condval[j]))\n+\t      && ATTR_EQ_ATTR_P (condval[j]))\n \t    new_marks++;\n \tif (new_marks - num_marks > most_tests)\n \t  {\n@@ -3764,7 +3769,7 @@ simplify_by_exploding (exp)\n       }\n   /* Clear all the marks.  */\n   for (i = 0; i < total; i++)\n-    MEM_VOLATILE_P (condval[i]) = 0;\n+    ATTR_EQ_ATTR_P (condval[i]) = 0;\n \n   /* Give up if nothing is constant.  */\n   if (num_marks == 0)\n@@ -3796,7 +3801,7 @@ simplify_by_exploding (exp)\n   return ret;\n }\n \n-/* Set the MEM_VOLATILE_P flag for all EQ_ATTR expressions in EXP and\n+/* Set the ATTR_EQ_ATTR_P flag for all EQ_ATTR expressions in EXP and\n    verify that EXP can be simplified to a constant term if all the EQ_ATTR\n    tests have known value.  */\n \n@@ -3810,14 +3815,14 @@ find_and_mark_used_attributes (exp, terms, nterms)\n   switch (GET_CODE (exp))\n     {\n     case EQ_ATTR:\n-      if (! MEM_VOLATILE_P (exp))\n+      if (! ATTR_EQ_ATTR_P (exp))\n \t{\n \t  rtx link = rtx_alloc (EXPR_LIST);\n \t  XEXP (link, 0) = exp;\n \t  XEXP (link, 1) = *terms;\n \t  *terms = link;\n \t  *nterms += 1;\n-\t  MEM_VOLATILE_P (exp) = 1;\n+\t  ATTR_EQ_ATTR_P (exp) = 1;\n \t}\n       return 1;\n \n@@ -3850,7 +3855,7 @@ find_and_mark_used_attributes (exp, terms, nterms)\n     }\n }\n \n-/* Clear the MEM_VOLATILE_P flag in all EQ_ATTR expressions on LIST and\n+/* Clear the ATTR_EQ_ATTR_P flag in all EQ_ATTR expressions on LIST and\n    in the values of the NDIM-dimensional attribute space SPACE.  */\n \n static void\n@@ -3869,7 +3874,7 @@ unmark_used_attributes (list, space, ndim)\n     {\n       exp = XEXP (link, 0);\n       if (GET_CODE (exp) == EQ_ATTR)\n-\tMEM_VOLATILE_P (exp) = 0;\n+\tATTR_EQ_ATTR_P (exp) = 0;\n     }\n }\n \n@@ -3905,7 +3910,7 @@ add_values_to_cover (dim)\n \tif (GET_CODE (av->value) == CONST_STRING)\n \t  {\n \t    exp = attr_eq (dim->attr->name, XSTR (av->value, 0));\n-\t    if (MEM_VOLATILE_P (exp))\n+\t    if (ATTR_EQ_ATTR_P (exp))\n \t      continue;\n \n \t    link = rtx_alloc (EXPR_LIST);\n@@ -3995,7 +4000,7 @@ simplify_with_current_value (exp, space, ndim)\n     {\n       x = XEXP (space[i].current_value, 0);\n       if (GET_CODE (x) == EQ_ATTR)\n-\tMEM_VOLATILE_P (x) = 0;\n+\tATTR_EQ_ATTR_P (x) = 0;\n     }\n \n   exp = simplify_with_current_value_aux (exp);\n@@ -4005,13 +4010,13 @@ simplify_with_current_value (exp, space, ndim)\n     {\n       x = XEXP (space[i].current_value, 0);\n       if (GET_CODE (x) == EQ_ATTR)\n-\tMEM_VOLATILE_P (x) = 1;\n+\tATTR_EQ_ATTR_P (x) = 1;\n     }\n \n   return exp;\n }\n \n-/* Reduce the expression EXP based on the MEM_VOLATILE_P settings of\n+/* Reduce the expression EXP based on the ATTR_EQ_ATTR_P settings of\n    all EQ_ATTR expressions.  */\n \n static rtx\n@@ -4024,7 +4029,7 @@ simplify_with_current_value_aux (exp)\n   switch (GET_CODE (exp))\n     {\n     case EQ_ATTR:\n-      if (MEM_VOLATILE_P (exp))\n+      if (ATTR_EQ_ATTR_P (exp))\n \treturn false_rtx;\n       else\n \treturn true_rtx;\n@@ -4091,7 +4096,7 @@ simplify_with_current_value_aux (exp)\n     }\n }\n \f\n-/* Clear the MEM_IN_STRUCT_P flag in EXP and its subexpressions.  */\n+/* Clear the ATTR_CURR_SIMPLIFIED_P flag in EXP and its subexpressions.  */\n \n static void\n clear_struct_flag (x)\n@@ -4102,8 +4107,8 @@ clear_struct_flag (x)\n   enum rtx_code code;\n   const char *fmt;\n \n-  MEM_IN_STRUCT_P (x) = 0;\n-  if (RTX_UNCHANGING_P (x))\n+  ATTR_CURR_SIMPLIFIED_P (x) = 0;\n+  if (ATTR_IND_SIMPLIFIED_P (x))\n     return;\n \n   code = GET_CODE (x);\n@@ -4914,7 +4919,7 @@ walk_attr_value (exp)\n   switch (code)\n     {\n     case SYMBOL_REF:\n-      if (! RTX_UNCHANGING_P (exp))\n+      if (! ATTR_IND_SIMPLIFIED_P (exp))\n \t/* Since this is an arbitrary expression, it can look at anything.\n \t   However, constant expressions do not depend on any particular\n \t   insn.  */\n@@ -5986,10 +5991,10 @@ copy_rtx_unchanging (orig)\n   RTX_CODE code;\n #endif\n \n-  if (RTX_UNCHANGING_P (orig) || MEM_IN_STRUCT_P (orig))\n+  if (ATTR_IND_SIMPLIFIED_P (orig) || ATTR_CURR_SIMPLIFIED_P (orig))\n     return orig;\n \n-  MEM_IN_STRUCT_P (orig) = 1;\n+  ATTR_CURR_SIMPLIFIED_P (orig) = 1;\n   return orig;\n \n #if 0\n@@ -6008,7 +6013,7 @@ copy_rtx_unchanging (orig)\n \n   copy = rtx_alloc (code);\n   PUT_MODE (copy, GET_MODE (orig));\n-  RTX_UNCHANGING_P (copy) = 1;\n+  ATTR_IND_SIMPLIFIED_P (copy) = 1;\n \n   memcpy (&XEXP (copy, 0), &XEXP (orig, 0),\n \t  GET_RTX_LENGTH (GET_CODE (copy)) * sizeof (rtx));\n@@ -6082,8 +6087,8 @@ main (argc, argv)\n   XWINT (true_rtx, 0) = 1;\n   false_rtx = rtx_alloc (CONST_INT);\n   XWINT (false_rtx, 0) = 0;\n-  RTX_UNCHANGING_P (true_rtx) = RTX_UNCHANGING_P (false_rtx) = 1;\n-  RTX_INTEGRATED_P (true_rtx) = RTX_INTEGRATED_P (false_rtx) = 1;\n+  ATTR_IND_SIMPLIFIED_P (true_rtx) = ATTR_IND_SIMPLIFIED_P (false_rtx) = 1;\n+  ATTR_PERMANENT_P (true_rtx) = ATTR_PERMANENT_P (false_rtx) = 1;\n \n   alternative_name = attr_string (\"alternative\", strlen (\"alternative\"));\n "}, {"sha": "db540c9b596e50adfe020f5239e9419ac15436bb", "filename": "gcc/integrate.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -2209,7 +2209,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n       if (map->orig_asm_operands_vector == ASM_OPERANDS_INPUT_VEC (orig))\n \t{\n \t  copy = rtx_alloc (ASM_OPERANDS);\n-\t  copy->volatil = orig->volatil;\n+\t  RTX_FLAG (copy, volatil) = RTX_FLAG (orig, volatil);\n \t  PUT_MODE (copy, GET_MODE (orig));\n \t  ASM_OPERANDS_TEMPLATE (copy) = ASM_OPERANDS_TEMPLATE (orig);\n \t  ASM_OPERANDS_OUTPUT_CONSTRAINT (copy)\n@@ -2328,9 +2328,9 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \n   copy = rtx_alloc (code);\n   PUT_MODE (copy, mode);\n-  copy->in_struct = orig->in_struct;\n-  copy->volatil = orig->volatil;\n-  copy->unchanging = orig->unchanging;\n+  RTX_FLAG (copy, in_struct) = RTX_FLAG (orig, in_struct);\n+  RTX_FLAG (copy, volatil) = RTX_FLAG (orig, volatil);\n+  RTX_FLAG (copy, unchanging) = RTX_FLAG (orig, unchanging);\n \n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n "}, {"sha": "5bdffb4b9b34ddc8e28ba0f7b6417bd27546fe31", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -154,25 +154,25 @@ print_rtx (in_rtx)\n       \n       if (! flag_simple)\n \t{\n-\t  if (in_rtx->in_struct)\n+\t  if (RTX_FLAG (in_rtx, in_struct))\n \t    fputs (\"/s\", outfile);\n \n-\t  if (in_rtx->volatil)\n+\t  if (RTX_FLAG (in_rtx, volatil))\n \t    fputs (\"/v\", outfile);\n \t  \n-\t  if (in_rtx->unchanging)\n+\t  if (RTX_FLAG (in_rtx, unchanging))\n \t    fputs (\"/u\", outfile);\n \t  \n-\t  if (in_rtx->integrated)\n+\t  if (RTX_FLAG (in_rtx, integrated))\n \t    fputs (\"/i\", outfile);\n \t  \n-\t  if (in_rtx->frame_related)\n+\t  if (RTX_FLAG (in_rtx, frame_related))\n \t    fputs (\"/f\", outfile);\n \t  \n-\t  if (in_rtx->jump)\n+\t  if (RTX_FLAG (in_rtx, jump))\n \t    fputs (\"/j\", outfile);\n \t  \n-\t  if (in_rtx->call)\n+\t  if (RTX_FLAG (in_rtx, call))\n \t    fputs (\"/c\", outfile);\n \n \t  if (GET_MODE (in_rtx) != VOIDmode)"}, {"sha": "efa66c28fc3c3cbc59bcdabbfa9b63c9a94f42f6", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adc7f1284cb738d1633becaf566196bee37435b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2adc7f1284cb738d1633becaf566196bee37435b", "patch": "@@ -211,6 +211,7 @@ struct rtx_def\n #define GET_MODE(RTX)\t    ((enum machine_mode) (RTX)->mode)\n #define PUT_MODE(RTX, MODE) ((RTX)->mode = (ENUM_BITFIELD(machine_mode)) (MODE))\n \n+#define RTX_FLAG(RTX,FLAG) ((RTX)->FLAG)\n #define RTX_INTEGRATED_P(RTX) ((RTX)->integrated)\n #define RTX_UNCHANGING_P(RTX) ((RTX)->unchanging)\n #define RTX_FRAME_RELATED_P(RTX) ((RTX)->frame_related)"}]}