{"sha": "5a11ffadf58a3668655e08f610281ac5567b4d93", "node_id": "C_kwDOANBUbNoAKDVhMTFmZmFkZjU4YTM2Njg2NTVlMDhmNjEwMjgxYWM1NTY3YjRkOTM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-11-16T23:09:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-02T16:26:31Z"}, "message": "[Ada] Fix packing for array component with discriminated part\n\ngcc/ada/\n\n\t* gcc-interface/gigi.h (aggregate_type_contains_array_p): Delete.\n\t(type_has_variable_size): Declare.\n\t* gcc-interface/decl.c (adjust_packed): Return 0 only if the field\n\ttype is an array with variable size.\n\t* gcc-interface/utils.c (aggregate_type_contains_array_p): Make\n\tstatic and remove SELF_REFERENTIAL parameter.\n\t(type_has_variable_size): Make public.\n\t(create_field_decl): Adjust call to aggregate_type_contains_array_p.", "tree": {"sha": "5d4bf3f53bbf4ab6414139a4414798a40fa02df1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d4bf3f53bbf4ab6414139a4414798a40fa02df1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a11ffadf58a3668655e08f610281ac5567b4d93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a11ffadf58a3668655e08f610281ac5567b4d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a11ffadf58a3668655e08f610281ac5567b4d93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a11ffadf58a3668655e08f610281ac5567b4d93/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e10b7002acb3ce6134a6343cba04691f8c2d8ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e10b7002acb3ce6134a6343cba04691f8c2d8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e10b7002acb3ce6134a6343cba04691f8c2d8ff"}], "stats": {"total": 37, "additions": 16, "deletions": 21}, "files": [{"sha": "f0c17fc5eabc17be5f1d5d1eeae9b2093080dc4a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a11ffadf58a3668655e08f610281ac5567b4d93/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a11ffadf58a3668655e08f610281ac5567b4d93/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=5a11ffadf58a3668655e08f610281ac5567b4d93", "patch": "@@ -7221,13 +7221,12 @@ choices_to_gnu (tree gnu_operand, Node_Id gnat_choices)\n static int\n adjust_packed (tree field_type, tree record_type, int packed)\n {\n-  /* If the field contains an array with self-referential size, we'd better\n-     not pack it because this would misalign it and, therefore, cause large\n-     temporaries to be created in case we need to take the address of the\n-     field.  See addressable_p and the notes on the addressability issues\n-     for further details.  */\n-  if (AGGREGATE_TYPE_P (field_type)\n-      && aggregate_type_contains_array_p (field_type, true))\n+  /* If the field is an array of variable size, we'd better not pack it because\n+     this would misalign it and, therefore, probably cause large temporarie to\n+     be created in case we need to take its address.  See addressable_p and the\n+     notes on the addressability issues for further details.  */\n+  if (TREE_CODE (field_type) == ARRAY_TYPE\n+      && type_has_variable_size (field_type))\n     return 0;\n \n   /* In the other cases, we can honor the packing.  */"}, {"sha": "4b4a14dd3c6f3f79c0de3d7448a6adf8459fdd5c", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a11ffadf58a3668655e08f610281ac5567b4d93/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a11ffadf58a3668655e08f610281ac5567b4d93/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=5a11ffadf58a3668655e08f610281ac5567b4d93", "patch": "@@ -838,10 +838,9 @@ extern tree get_base_type (tree type);\n    in bits.  If we don't know anything about the alignment, return 0.  */\n extern unsigned int known_alignment (tree exp);\n \n-/* Return true if TYPE, an aggregate type, contains (or is) an array.\n-   If SELF_REFERENTIAL is true, then an additional requirement on the\n-   array is that it be self-referential.  */\n-extern bool aggregate_type_contains_array_p (tree type, bool self_referential);\n+/* Return true if TYPE is a type with variable size or a padding type with a\n+   field of variable size or a record that has a field with such a type.  */\n+extern bool type_has_variable_size (tree type);\n \n /* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n    of 2.  */"}, {"sha": "d5dd04a4fe7bff8dd4f0585f7bccfc657081f62d", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a11ffadf58a3668655e08f610281ac5567b4d93/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a11ffadf58a3668655e08f610281ac5567b4d93/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=5a11ffadf58a3668655e08f610281ac5567b4d93", "patch": "@@ -2902,12 +2902,10 @@ create_var_decl (tree name, tree asm_name, tree type, tree init,\n   return var_decl;\n }\n \n-/* Return true if TYPE, an aggregate type, contains (or is) an array.\n-   If SELF_REFERENTIAL is true, then an additional requirement on the\n-   array is that it be self-referential.  */\n+/* Return true if TYPE, an aggregate type, contains (or is) an array.  */\n \n-bool\n-aggregate_type_contains_array_p (tree type, bool self_referential)\n+static bool\n+aggregate_type_contains_array_p (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -2918,14 +2916,13 @@ aggregate_type_contains_array_p (tree type, bool self_referential)\n \ttree field;\n \tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (field))\n-\t      && aggregate_type_contains_array_p (TREE_TYPE (field),\n-\t\t\t\t\t\t  self_referential))\n+\t      && aggregate_type_contains_array_p (TREE_TYPE (field)))\n \t    return true;\n \treturn false;\n       }\n \n     case ARRAY_TYPE:\n-      return self_referential ? type_contains_placeholder_p (type) : true;\n+      return true;\n \n     default:\n       gcc_unreachable ();\n@@ -2935,7 +2932,7 @@ aggregate_type_contains_array_p (tree type, bool self_referential)\n /* Return true if TYPE is a type with variable size or a padding type with a\n    field of variable size or a record that has a field with such a type.  */\n \n-static bool\n+bool\n type_has_variable_size (tree type)\n {\n   tree field;\n@@ -3037,7 +3034,7 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n \t\t || (!pos && type_has_variable_size (type))\n \t\t || (!pos\n \t\t     && AGGREGATE_TYPE_P (type)\n-\t\t     && aggregate_type_contains_array_p (type, false))))\n+\t\t     && aggregate_type_contains_array_p (type))))\n     SET_DECL_ALIGN (field_decl, BITS_PER_UNIT);\n \n   /* Bump the alignment if need be, either for bitfield/packing purposes or"}]}