{"sha": "f8cfc6aa070047007c18468b54996c116e593642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhjZmM2YWEwNzAwNDcwMDdjMTg0NjhiNTQ5OTZjMTE2ZTU5MzY0Mg==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2004-06-15T18:02:40Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-06-15T18:02:40Z"}, "message": "alias.c (record_set, [...]): Use REG_P.\n\n2004-06-15  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* alias.c (record_set, record_base_value, canon_rtx, get_addr,\n\tnonlocal_mentioned_p_1, init_alias_analysis): Use REG_P.\n\t* bt-load.c (find_btr_reference, insn_sets_btr_p, note_btr_set):\n\tLikewise.\n\t* builtins.c (expand_builtin_setjmp, expand_builtin_apply,\n\texpand_builtin_mathfn, expand_builtin_strlen, expand_builtin_memcmp,\n\texpand_builtin_strcmp, expand_builtin_strncmp,\n\texpand_builtin_frame_address): Likewise.\n\t* caller-save.c (mark_set_regs, add_stored_regs, mark_referenced_regs,\n\tinsert_one_insn): Likewise.\n\t* calls.c (prepare_call_address, precompute_register_parameters,\n\tprecompute_arguments, expand_call, emit_library_call_value_1): Likewise.\n\t* cfganal.c (flow_active_insn_p): Likewise.\n\t* combine.c (set_nonzero_bits_and_sign_copies, can_combine_p,\n\tcombinable_i3pat, try_combine, find_split_point, COMBINE_RTX_EQUAL_P,\n\tsubst, combine_simplify_rtx, simplify_if_then_else, simplify_set,\n\tmake_extraction, recog_for_combine, gen_lowpart_for_combine,\n\tsimplify_comparison, record_dead_and_set_regs_1,\n\trecord_dead_and_set_regs, record_promoted_value,\n\tcheck_promoted_subreg, get_last_value_validate, get_last_value,\n\treg_dead_at_p_1, reg_bitfield_target_p, distribute_notes,\n\tunmentioned_reg_p_1): Likewise.\n\t* conflict.c (mark_reg): Likewise.\n\t* cse.c (HASH, COST, COST_IN, approx_reg_cost_1, notreg_cost,\n\tmention_regs, insert_regs, lookup, lookup_for_remove, insert,\n\tmerge_equiv_classes, flush_hash_table, invalidate,\n\tremove_invalid_refs, remove_invalid_subreg_refs, rehash_using_reg,\n\tinvalidate_for_call, use_related_value, canon_hash, exp_equiv_p,\n\tcse_rtx_varies_p, canon_reg, find_best_addr, fold_rtx, equiv_constant,\n\trecord_jump_cond, cse_insn, addr_affects_sp_p,\n\tinvalidate_from_clobbers, cse_process_notes, cse_around_loop,\n\tcse_set_around_loop, count_reg_usage, set_live_p, cse_change_cc_mode,\n\tcse_cc_succs, cse_condition_code_reg): Likewise.\n\t* cselib.c (cselib_reg_set_mode, rtx_equal_for_cselib_p,\n\tcselib_lookup, cselib_invalidate_regno, cselib_invalidate_rtx,\n\tcselib_record_set, cselib_record_sets): Likewise.\n\t* dbxout.c (dbxout_symbol_location, dbxout_parms, dbxout_reg_parms,\n\tdbxout_block): Likewise.\n\t* df.c (df_ref_record, df_def_record_1, df_uses_record): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* dwarf2out.c (dwarf2out_frame_debug_expr, is_pseudo_reg,\n\tis_based_loc, rtl_for_decl_location): Likewise.\n\t* emit-rtl.c (set_reg_attrs_for_parm, set_decl_rtl,\n\tset_decl_incoming_rtl, mark_user_reg): Likewise.\n\t* explow.c (copy_all_regs, copy_all_regs, memory_address, force_reg,\n\tcopy_to_suggested_reg, allocate_dynamic_stack_space,\n\tprobe_stack_range, hard_function_value): Likewise.\n\t* expmed.c (store_bit_field, store_fixed_bit_field,\n\tstore_split_bit_field, extract_bit_field, extract_fixed_bit_field,\n\textract_split_bit_field, expand_divmod, emit_store_flag_force):\n\tLikewise.\n\t* expr.c (convert_move, convert_modes,\n\tblock_move_libcall_safe_for_call_parm, emit_group_load, use_reg,\n\tuse_group_regs, emit_move_insn, emit_move_insn_1,\n\tcompress_float_constant, push_block, emit_single_push_insn,\n\temit_push_insn, get_subtarget, expand_assignment, store_expr,\n\tstore_constructor, store_field, force_operand, safe_from_p,\n\texpand_expr_real_1, expand_increment, do_store_flag, do_tablejump):\n\tLikewise.\n\t* final.c (profile_function, final_scan_insn, alter_subreg,\n\tget_mem_expr_from_op, output_asm_operand_names, output_operand,\n\tonly_leaf_regs_used, leaf_renumber_regs_insn): Likewise.\n\t* flow.c (verify_wide_reg_1, mark_regs_live_at_end,\n\tfind_regno_partial, propagate_one_insn, init_propagate_block_info,\n\tinsn_dead_p, libcall_dead_p, mark_set_1, not_reg_cond,\n\tattempt_auto_inc, find_auto_inc, mark_used_regs,\n\tcount_or_remove_death_notes_bb): Likewise.\n\t* function.c (find_temp_slot_from_address, update_temp_slot_address,\n\tpreserve_temp_slots, put_var_into_stack, fixup_var_refs_insn,\n\tfixup_var_refs_1, fixup_stack_1, optimize_bit_field, flush_addressof,\n\tput_addressof_into_stack, purge_addressof_1, insns_for_mem_walk,\n\tpurge_single_hard_subreg_set, instantiate_decl,\n\tinstantiate_virtual_regs_1, aggregate_value_p, assign_parms,\n\tpromoted_input_arg, setjmp_vars_warning, setjmp_args_warning,\n\tsetjmp_protect, setjmp_protect_args, fix_lexical_addr,\n\texpand_function_start, diddle_return_value, clobber_return_register,\n\texpand_function_end, keep_stack_depressed, handle_epilogue_set,\n\tupdate_epilogue_consts): Likewise.\n\t* genemit.c (gen_exp, gen_insn): Likewise.\n\t* genrecog.c (make_insn_sequence): Likewise.\n\t* global.c (global_conflicts, expand_preferences, mark_reg_store,\n\tmark_reg_conflicts, set_preference, reg_becomes_live,\n\tbuild_insn_chain, mark_reg_change): Likewise.\n\t* haifa_sched.c (CONST_BASED_ADDRESS_P, find_set_reg_weight):\n\tLikewise.\n\t* ifcvt.c (noce_try_abs, noce_get_condition, noce_process_if_block):\n\tLikewise.\n\t* integrate.c (copy_rtx_and_substitute, try_constants,\n\tsubst_constants, mark_stores, allocate_initial_values): Likewise.\n\t* jump.c (reversed_comparison_code_parts, delete_prior_computation,\n\tdelete_computation, rtx_renumbered_equal_p, true_regnum,\n\treg_or_subregno): Likewise.\n\t* lcm.c (reg_dies, reg_becomes_live): Likewise.\n\t* local-alloc.c (validate_equiv_mem_from_store, validate_equiv_mem,\n\tupdate_equiv_regs, no_equiv, block_alloc, combine_regs, reg_is_set,\n\twipe_dead_reg, no_conflict_p): Likewise.\n\t* loop-iv.c (simple_reg_p, simple_set_p, kill_sets,\n\tiv_get_reaching_def, iv_analyze_biv, altered_reg_used, mark_altered,\n\tsimple_rhs_p, simplify_using_assignment, implies_p): Likewise.\n\t* loop.c (scan_loop, combine_movables, rtx_equal_for_loop_p,\n\tmove_movables, note_set_pseudo_multiple_uses, consec_sets_invariant_p,\n\tfind_single_use_in_loop, count_one_set, loop_bivs_init_find,\n\tloop_givs_rescan, check_insn_for_bivs, check_insn_for_givs,\n\tvalid_initial_value_p, simplify_giv_expr, consec_sets_giv,\n\tloop_regs_update, check_dbra_loop, maybe_eliminate_biv,\n\tmaybe_eliminate_biv_1, record_initial, update_reg_last_use,\n\tcanonicalize_condition, loop_regs_scan, load_mems, try_copy_prop,\n\ttry_swap_copy_prop): Likewise.\n\t* optabs.c (expand_binop, expand_vector_binop, expand_vector_unop,\n\texpand_abs, emit_no_conflict_block, emit_libcall_block, expand_float):\n\tLikewise.\n\t* postreload.c (reload_cse_simplify, reload_cse_simplify_set,\n\treload_cse_simplify_operands, reload_combine,\n\treload_combine_note_store, reload_combine_note_use,\n\treload_cse_move2add, move2add_note_store): Likewise.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* ra-build.c (copy_insn_p, remember_move, init_one_web_common,\n\tcontains_pseudo, handle_asm_insn): Likewise.\n\t* ra-debug.c (ra_print_rtx_object, dump_constraints,\n\tdump_static_insn_cost): Likewise.\n\t* ra-rewrite.c (slots_overlap_p, emit_colors,\n\tremove_suspicious_death_notes): Likewise.\n\t* recog.c (validate_replace_rtx_1, find_single_use_1, find_single_use,\n\tregister_operand, scratch_operand, nonmemory_operand,\n\tconstrain_operands): Likewise.\n\t* reg-stack (check_asm_stack_operands, remove_regno_note,\n\temit_swap_insn, swap_rtx_condition, subst_stack_regs_pat,\n\tsubst_asm_stack_regs): Likewise.\n\t* regclass.c (scan_one_insn, record_reg_classes, copy_cost,\n\trecord_address_regs, reg_scan_mark_refs): Likewise.\n\t* regmove.c (discover_flags_reg, replacement_quality,\n\tcopy_src_to_dest, reg_is_remote_constant_p, regmove_optimize,\n\tfixup_match_1): Likewise.\n\t* regrename.c (note_sets, clear_dead_regs, build_def_use, kill_value,\n\tkill_set_value, copyprop_hardreg_forward_1): Likewise.\n\t* reload.c (MATCHES, push_secondary_reload, find_reusable_reload,\n\treload_inner_reg_of_subreg, can_reload_into, push_reload,\n\tcombine_reloads, find_dummy_reload, hard_reg_set_here_p,\n\toperands_match_p, decompose, find_reloads, find_reloads_toplev,\n\tfind_reloads_address, subst_indexed_address, find_reloads_address_1,\n\tfind_reloads_subreg_address, find_replacement,\n\trefers_to_regno_for_reload_p, reg_overlap_mentioned_for_reload_p,\n\trefers_to_mem_for_reload_p, find_equiv_reg, regno_clobbered_p): Likewise.\n\t* reload1.c (replace_pseudos_in, reload, calculate_needs_all_insns,\n\tfind_reg, delete_dead_insn, alter_reg, eliminate_regs,\n\telimination_effects, eliminate_regs_in_insn, scan_paradoxical_subregs,\n\tforget_old_reloads_1, reload_reg_free_for_value_p, choose_reload_regs,\n\temit_input_reload_insns, emit_output_reload_insns, do_input_reload,\n\tdo_output_reload, emit_reload_insns, gen_reload,\n\tdelete_address_reloads_1, inc_for_reload): Likewise.\n\t* reorg.c (update_reg_dead_notes, fix_reg_dead_note,\n\tupdate_reg_unused_notes, fill_slots_from_thread): Likewise.\n\t* resource.c (update_live_status, mark_referenced_resources,\n\tmark_set_resources, mark_target_live_regs): Likewise.\n\t* rtlanal.c (nonzero_address_p, get_jump_table_offset,\n\tglobal_reg_mentioned_p_1, reg_mentioned_p, reg_referenced_p,\n\treg_set_p, set_noop_p, find_last_value, refers_to_regno_p,\n\tnote_stores, dead_or_set_p, dead_or_set_regno_p, find_regno_note,\n\tfind_reg_fusage, find_regno_fusage, replace_regs, regno_use_in,\n\tparms_set, find_first_parameter_load, keep_with_call_p,\n\thoist_test_store, hoist_update_store, address_cost, nonzero_bits1,\n\tnum_sign_bit_copies1): Likewise.\n\t* rtlhooks.c (gen_lowpart_general): Likewise.\n\t* sched-deps.c (deps_may_trap_p, sched_analyze_1, sched_analyze_insn,\n\tsched_analyze): Likewise.\n\t* sched-rgn.c (check_live_1, update_live_1, sets_likely_spilled_1):\n\tLikewise.\n\t* sdbout.c (sdbout_symbol, sdbout_parms, sdbout_reg_parms): Likewise.\n\t* simplify-rtx.c (simplify_replace_rtx, simplify_unary_operation,\n\tsimplify_binary_operation, simplify_const_relational_operation,\n\tsimplify_subreg): Likewise.\n\t* stmt.c (decl_conflicts_with_clobbers_p, expand_asm_operands,\n\texpand_end_stmt_expr, expand_return, expand_decl,\n\texpand_anon_union_decl): Likewise.\n\t* unroll.c (precondition_loop_p, calculate_giv_inc, copy_loop_body,\n\tfind_splittable_regs, find_splittable_givs, find_common_reg_term,\n\tloop_iterations): Likewise.\n\t* var-tracking.c (variable_union, variable_part_different_p,\n\tvariable_different_p, count_uses, add_uses, add_stores,\n\tcompute_bb_dataflow, set_variable_part, delete_variable_part,\n\temit_notes_in_bb, vt_get_decl_and_offset, vt_add_function_parameters):\n\tLikewise.\n\t* varasm.c (assemble_variable): Likewise.\n\nFrom-SVN: r83195", "tree": {"sha": "59650bc9433b72fce58b94b5d3cd187f0dde42a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59650bc9433b72fce58b94b5d3cd187f0dde42a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8cfc6aa070047007c18468b54996c116e593642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8cfc6aa070047007c18468b54996c116e593642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8cfc6aa070047007c18468b54996c116e593642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8cfc6aa070047007c18468b54996c116e593642/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "347b63a2c9e48740e8d79c9be8d620d22e1eb40f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347b63a2c9e48740e8d79c9be8d620d22e1eb40f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/347b63a2c9e48740e8d79c9be8d620d22e1eb40f"}], "stats": {"total": 2121, "additions": 1154, "deletions": 967}, "files": [{"sha": "c03a523a253f81f2753f58795cfd45292ae47e79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1,3 +1,189 @@\n+2004-06-15  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* alias.c (record_set, record_base_value, canon_rtx, get_addr,\n+\tnonlocal_mentioned_p_1, init_alias_analysis): Use REG_P.\n+\t* bt-load.c (find_btr_reference, insn_sets_btr_p, note_btr_set):\n+\tLikewise.\n+\t* builtins.c (expand_builtin_setjmp, expand_builtin_apply,\n+\texpand_builtin_mathfn, expand_builtin_strlen, expand_builtin_memcmp,\n+\texpand_builtin_strcmp, expand_builtin_strncmp,\n+\texpand_builtin_frame_address): Likewise.\n+\t* caller-save.c (mark_set_regs, add_stored_regs, mark_referenced_regs,\n+\tinsert_one_insn): Likewise.\n+\t* calls.c (prepare_call_address, precompute_register_parameters,\n+\tprecompute_arguments, expand_call, emit_library_call_value_1): Likewise.\n+\t* cfganal.c (flow_active_insn_p): Likewise.\n+\t* combine.c (set_nonzero_bits_and_sign_copies, can_combine_p,\n+\tcombinable_i3pat, try_combine, find_split_point, COMBINE_RTX_EQUAL_P,\n+\tsubst, combine_simplify_rtx, simplify_if_then_else, simplify_set,\n+\tmake_extraction, recog_for_combine, gen_lowpart_for_combine,\n+\tsimplify_comparison, record_dead_and_set_regs_1,\n+\trecord_dead_and_set_regs, record_promoted_value,\n+\tcheck_promoted_subreg, get_last_value_validate, get_last_value,\n+\treg_dead_at_p_1, reg_bitfield_target_p, distribute_notes,\n+\tunmentioned_reg_p_1): Likewise.\n+\t* conflict.c (mark_reg): Likewise.\n+\t* cse.c (HASH, COST, COST_IN, approx_reg_cost_1, notreg_cost,\n+\tmention_regs, insert_regs, lookup, lookup_for_remove, insert,\n+\tmerge_equiv_classes, flush_hash_table, invalidate,\n+\tremove_invalid_refs, remove_invalid_subreg_refs, rehash_using_reg,\n+\tinvalidate_for_call, use_related_value, canon_hash, exp_equiv_p,\n+\tcse_rtx_varies_p, canon_reg, find_best_addr, fold_rtx, equiv_constant,\n+\trecord_jump_cond, cse_insn, addr_affects_sp_p,\n+\tinvalidate_from_clobbers, cse_process_notes, cse_around_loop,\n+\tcse_set_around_loop, count_reg_usage, set_live_p, cse_change_cc_mode,\n+\tcse_cc_succs, cse_condition_code_reg): Likewise.\n+\t* cselib.c (cselib_reg_set_mode, rtx_equal_for_cselib_p,\n+\tcselib_lookup, cselib_invalidate_regno, cselib_invalidate_rtx,\n+\tcselib_record_set, cselib_record_sets): Likewise.\n+\t* dbxout.c (dbxout_symbol_location, dbxout_parms, dbxout_reg_parms,\n+\tdbxout_block): Likewise.\n+\t* df.c (df_ref_record, df_def_record_1, df_uses_record): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* dwarf2out.c (dwarf2out_frame_debug_expr, is_pseudo_reg,\n+\tis_based_loc, rtl_for_decl_location): Likewise.\n+\t* emit-rtl.c (set_reg_attrs_for_parm, set_decl_rtl,\n+\tset_decl_incoming_rtl, mark_user_reg): Likewise.\n+\t* explow.c (copy_all_regs, copy_all_regs, memory_address, force_reg,\n+\tcopy_to_suggested_reg, allocate_dynamic_stack_space,\n+\tprobe_stack_range, hard_function_value): Likewise.\n+\t* expmed.c (store_bit_field, store_fixed_bit_field,\n+\tstore_split_bit_field, extract_bit_field, extract_fixed_bit_field,\n+\textract_split_bit_field, expand_divmod, emit_store_flag_force):\n+\tLikewise.\n+\t* expr.c (convert_move, convert_modes,\n+\tblock_move_libcall_safe_for_call_parm, emit_group_load, use_reg,\n+\tuse_group_regs, emit_move_insn, emit_move_insn_1,\n+\tcompress_float_constant, push_block, emit_single_push_insn,\n+\temit_push_insn, get_subtarget, expand_assignment, store_expr,\n+\tstore_constructor, store_field, force_operand, safe_from_p,\n+\texpand_expr_real_1, expand_increment, do_store_flag, do_tablejump):\n+\tLikewise.\n+\t* final.c (profile_function, final_scan_insn, alter_subreg,\n+\tget_mem_expr_from_op, output_asm_operand_names, output_operand,\n+\tonly_leaf_regs_used, leaf_renumber_regs_insn): Likewise.\n+\t* flow.c (verify_wide_reg_1, mark_regs_live_at_end,\n+\tfind_regno_partial, propagate_one_insn, init_propagate_block_info,\n+\tinsn_dead_p, libcall_dead_p, mark_set_1, not_reg_cond,\n+\tattempt_auto_inc, find_auto_inc, mark_used_regs,\n+\tcount_or_remove_death_notes_bb): Likewise.\n+\t* function.c (find_temp_slot_from_address, update_temp_slot_address,\n+\tpreserve_temp_slots, put_var_into_stack, fixup_var_refs_insn,\n+\tfixup_var_refs_1, fixup_stack_1, optimize_bit_field, flush_addressof,\n+\tput_addressof_into_stack, purge_addressof_1, insns_for_mem_walk,\n+\tpurge_single_hard_subreg_set, instantiate_decl,\n+\tinstantiate_virtual_regs_1, aggregate_value_p, assign_parms,\n+\tpromoted_input_arg, setjmp_vars_warning, setjmp_args_warning,\n+\tsetjmp_protect, setjmp_protect_args, fix_lexical_addr,\n+\texpand_function_start, diddle_return_value, clobber_return_register,\n+\texpand_function_end, keep_stack_depressed, handle_epilogue_set,\n+\tupdate_epilogue_consts): Likewise.\n+\t* genemit.c (gen_exp, gen_insn): Likewise.\n+\t* genrecog.c (make_insn_sequence): Likewise.\n+\t* global.c (global_conflicts, expand_preferences, mark_reg_store,\n+\tmark_reg_conflicts, set_preference, reg_becomes_live,\n+\tbuild_insn_chain, mark_reg_change): Likewise.\n+\t* haifa_sched.c (CONST_BASED_ADDRESS_P, find_set_reg_weight):\n+\tLikewise.\n+\t* ifcvt.c (noce_try_abs, noce_get_condition, noce_process_if_block):\n+\tLikewise.\n+\t* integrate.c (copy_rtx_and_substitute, try_constants,\n+\tsubst_constants, mark_stores, allocate_initial_values): Likewise.\n+\t* jump.c (reversed_comparison_code_parts, delete_prior_computation,\n+\tdelete_computation, rtx_renumbered_equal_p, true_regnum,\n+\treg_or_subregno): Likewise.\n+\t* lcm.c (reg_dies, reg_becomes_live): Likewise.\n+\t* local-alloc.c (validate_equiv_mem_from_store, validate_equiv_mem,\n+\tupdate_equiv_regs, no_equiv, block_alloc, combine_regs, reg_is_set,\n+\twipe_dead_reg, no_conflict_p): Likewise.\n+\t* loop-iv.c (simple_reg_p, simple_set_p, kill_sets,\n+\tiv_get_reaching_def, iv_analyze_biv, altered_reg_used, mark_altered,\n+\tsimple_rhs_p, simplify_using_assignment, implies_p): Likewise.\n+\t* loop.c (scan_loop, combine_movables, rtx_equal_for_loop_p,\n+\tmove_movables, note_set_pseudo_multiple_uses, consec_sets_invariant_p,\n+\tfind_single_use_in_loop, count_one_set, loop_bivs_init_find,\n+\tloop_givs_rescan, check_insn_for_bivs, check_insn_for_givs,\n+\tvalid_initial_value_p, simplify_giv_expr, consec_sets_giv,\n+\tloop_regs_update, check_dbra_loop, maybe_eliminate_biv,\n+\tmaybe_eliminate_biv_1, record_initial, update_reg_last_use,\n+\tcanonicalize_condition, loop_regs_scan, load_mems, try_copy_prop,\n+\ttry_swap_copy_prop): Likewise.\n+\t* optabs.c (expand_binop, expand_vector_binop, expand_vector_unop,\n+\texpand_abs, emit_no_conflict_block, emit_libcall_block, expand_float):\n+\tLikewise.\n+\t* postreload.c (reload_cse_simplify, reload_cse_simplify_set,\n+\treload_cse_simplify_operands, reload_combine,\n+\treload_combine_note_store, reload_combine_note_use,\n+\treload_cse_move2add, move2add_note_store): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* ra-build.c (copy_insn_p, remember_move, init_one_web_common,\n+\tcontains_pseudo, handle_asm_insn): Likewise.\n+\t* ra-debug.c (ra_print_rtx_object, dump_constraints,\n+\tdump_static_insn_cost): Likewise.\n+\t* ra-rewrite.c (slots_overlap_p, emit_colors,\n+\tremove_suspicious_death_notes): Likewise.\n+\t* recog.c (validate_replace_rtx_1, find_single_use_1, find_single_use,\n+\tregister_operand, scratch_operand, nonmemory_operand,\n+\tconstrain_operands): Likewise.\n+\t* reg-stack (check_asm_stack_operands, remove_regno_note,\n+\temit_swap_insn, swap_rtx_condition, subst_stack_regs_pat,\n+\tsubst_asm_stack_regs): Likewise.\n+\t* regclass.c (scan_one_insn, record_reg_classes, copy_cost,\n+\trecord_address_regs, reg_scan_mark_refs): Likewise.\n+\t* regmove.c (discover_flags_reg, replacement_quality,\n+\tcopy_src_to_dest, reg_is_remote_constant_p, regmove_optimize,\n+\tfixup_match_1): Likewise.\n+\t* regrename.c (note_sets, clear_dead_regs, build_def_use, kill_value,\n+\tkill_set_value, copyprop_hardreg_forward_1): Likewise.\n+\t* reload.c (MATCHES, push_secondary_reload, find_reusable_reload,\n+\treload_inner_reg_of_subreg, can_reload_into, push_reload,\n+\tcombine_reloads, find_dummy_reload, hard_reg_set_here_p,\n+\toperands_match_p, decompose, find_reloads, find_reloads_toplev,\n+\tfind_reloads_address, subst_indexed_address, find_reloads_address_1,\n+\tfind_reloads_subreg_address, find_replacement,\n+\trefers_to_regno_for_reload_p, reg_overlap_mentioned_for_reload_p,\n+\trefers_to_mem_for_reload_p, find_equiv_reg, regno_clobbered_p): Likewise.\n+\t* reload1.c (replace_pseudos_in, reload, calculate_needs_all_insns,\n+\tfind_reg, delete_dead_insn, alter_reg, eliminate_regs,\n+\telimination_effects, eliminate_regs_in_insn, scan_paradoxical_subregs,\n+\tforget_old_reloads_1, reload_reg_free_for_value_p, choose_reload_regs,\n+\temit_input_reload_insns, emit_output_reload_insns, do_input_reload,\n+\tdo_output_reload, emit_reload_insns, gen_reload,\n+\tdelete_address_reloads_1, inc_for_reload): Likewise.\n+\t* reorg.c (update_reg_dead_notes, fix_reg_dead_note,\n+\tupdate_reg_unused_notes, fill_slots_from_thread): Likewise.\n+\t* resource.c (update_live_status, mark_referenced_resources,\n+\tmark_set_resources, mark_target_live_regs): Likewise.\n+\t* rtlanal.c (nonzero_address_p, get_jump_table_offset,\n+\tglobal_reg_mentioned_p_1, reg_mentioned_p, reg_referenced_p,\n+\treg_set_p, set_noop_p, find_last_value, refers_to_regno_p,\n+\tnote_stores, dead_or_set_p, dead_or_set_regno_p, find_regno_note,\n+\tfind_reg_fusage, find_regno_fusage, replace_regs, regno_use_in,\n+\tparms_set, find_first_parameter_load, keep_with_call_p,\n+\thoist_test_store, hoist_update_store, address_cost, nonzero_bits1,\n+\tnum_sign_bit_copies1): Likewise.\n+\t* rtlhooks.c (gen_lowpart_general): Likewise.\n+\t* sched-deps.c (deps_may_trap_p, sched_analyze_1, sched_analyze_insn,\n+\tsched_analyze): Likewise.\n+\t* sched-rgn.c (check_live_1, update_live_1, sets_likely_spilled_1):\n+\tLikewise.\n+\t* sdbout.c (sdbout_symbol, sdbout_parms, sdbout_reg_parms): Likewise.\n+\t* simplify-rtx.c (simplify_replace_rtx, simplify_unary_operation,\n+\tsimplify_binary_operation, simplify_const_relational_operation,\n+\tsimplify_subreg): Likewise.\n+\t* stmt.c (decl_conflicts_with_clobbers_p, expand_asm_operands,\n+\texpand_end_stmt_expr, expand_return, expand_decl,\n+\texpand_anon_union_decl): Likewise.\n+\t* unroll.c (precondition_loop_p, calculate_giv_inc, copy_loop_body,\n+\tfind_splittable_regs, find_splittable_givs, find_common_reg_term,\n+\tloop_iterations): Likewise.\n+\t* var-tracking.c (variable_union, variable_part_different_p,\n+\tvariable_different_p, count_uses, add_uses, add_stores,\n+\tcompute_bb_dataflow, set_variable_part, delete_variable_part,\n+\temit_notes_in_bb, vt_get_decl_and_offset, vt_add_function_parameters):\n+\tLikewise.\n+\t* varasm.c (assemble_variable): Likewise.\n+\n 2004-06-15  Chris Demetriou  <cgd@broadcom.com>\n \n \t* config/mips/linux.h (ASM_PREFERRED_EH_DATA_FORMAT): Remove"}, {"sha": "8e168c2b47789d95f9249aa3fe03347a3bd486cb", "filename": "gcc/alias.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -942,7 +942,7 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n   rtx src;\n   int n;\n \n-  if (GET_CODE (dest) != REG)\n+  if (!REG_P (dest))\n     return;\n \n   regno = REGNO (dest);\n@@ -1063,7 +1063,7 @@ record_base_value (unsigned int regno, rtx val, int invariant)\n   if (regno >= VARRAY_SIZE (reg_base_value))\n     VARRAY_GROW (reg_base_value, max_reg_num ());\n \n-  if (GET_CODE (val) == REG)\n+  if (REG_P (val))\n     {\n       VARRAY_RTX (reg_base_value, regno)\n \t = REG_BASE_VALUE (val);\n@@ -1156,7 +1156,7 @@ rtx\n canon_rtx (rtx x)\n {\n   /* Recursively look for equivalences.  */\n-  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+  if (REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n     {\n       rtx t = get_reg_known_value (REGNO (x));\n       if (t == x)\n@@ -1595,7 +1595,7 @@ get_addr (rtx x)\n \tif (CONSTANT_P (l->loc))\n \t  return l->loc;\n       for (l = v->locs; l; l = l->next)\n-\tif (GET_CODE (l->loc) != REG && GET_CODE (l->loc) != MEM)\n+\tif (!REG_P (l->loc) && GET_CODE (l->loc) != MEM)\n \t  return l->loc;\n       if (v->locs)\n \treturn v->locs->loc;\n@@ -2411,7 +2411,7 @@ nonlocal_mentioned_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n   switch (GET_CODE (x))\n     {\n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (x)) == REG)\n+      if (REG_P (SUBREG_REG (x)))\n \t{\n \t  /* Global registers are not local.  */\n \t  if (REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER\n@@ -2552,9 +2552,9 @@ nonlocal_referenced_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n \t mentioned in the destination.  */\n       if (GET_CODE (SET_DEST (x)) != CC0\n \t  && GET_CODE (SET_DEST (x)) != PC\n-\t  && GET_CODE (SET_DEST (x)) != REG\n+\t  && !REG_P (SET_DEST (x))\n \t  && ! (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t&& GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n+\t\t&& REG_P (SUBREG_REG (SET_DEST (x)))\n \t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n \t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n \t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n@@ -2921,7 +2921,7 @@ init_alias_analysis (void)\n \t      set = single_set (insn);\n \n \t      if (set != 0\n-\t\t  && GET_CODE (SET_DEST (set)) == REG\n+\t\t  && REG_P (SET_DEST (set))\n \t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  unsigned int regno = REGNO (SET_DEST (set));\n@@ -2943,7 +2943,7 @@ init_alias_analysis (void)\n \t\t    }\n \t\t  else if (REG_N_SETS (regno) == 1\n \t\t\t   && GET_CODE (src) == PLUS\n-\t\t\t   && GET_CODE (XEXP (src, 0)) == REG\n+\t\t\t   && REG_P (XEXP (src, 0))\n \t\t\t   && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n \t\t\t   && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t    {\n@@ -3004,7 +3004,7 @@ init_alias_analysis (void)\n       for (ui = 0; ui < maxreg; ui++)\n \t{\n \t  rtx base = VARRAY_RTX (reg_base_value, ui);\n-\t  if (base && GET_CODE (base) == REG)\n+\t  if (base && REG_P (base))\n \t    {\n \t      unsigned int base_regno = REGNO (base);\n \t      if (base_regno == ui)\t\t/* register set from itself */"}, {"sha": "ae8c2e087c6923daf42b4aa67ffa5aa15c328386", "filename": "gcc/bt-load.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -195,7 +195,7 @@ find_btr_reference (rtx *px, void *preg)\n   if (px == preg)\n     return -1;\n   x = *px;\n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     return 0;\n   regno = REGNO (x);\n   for (i = hard_regno_nregs[regno][GET_MODE (x)] - 1; i >= 0; i--)\n@@ -234,7 +234,7 @@ insn_sets_btr_p (rtx insn, int check_const, int *regno)\n       if (GET_CODE (dest) == SUBREG)\n \tdest = XEXP (dest, 0);\n \n-      if (GET_CODE (dest) == REG\n+      if (REG_P (dest)\n \t  && TEST_HARD_REG_BIT (all_btrs, REGNO (dest)))\n \t{\n \t  if (btr_referenced_p (src, NULL))\n@@ -427,7 +427,7 @@ note_btr_set (rtx dest, rtx set ATTRIBUTE_UNUSED, void *data)\n   defs_uses_info *info = data;\n   int regno, end_regno;\n \n-  if (GET_CODE (dest) != REG)\n+  if (!REG_P (dest))\n     return;\n   regno = REGNO (dest);\n   end_regno = regno + hard_regno_nregs[regno][GET_MODE (dest)];"}, {"sha": "2ae99ba6a839a76672561ea9e0771b46ff1a4cb0", "filename": "gcc/builtins.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -645,7 +645,7 @@ expand_builtin_setjmp (tree arglist, rtx target)\n   if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n-  if (target == 0 || GET_CODE (target) != REG\n+  if (target == 0 || !REG_P (target)\n       || REGNO (target) < FIRST_PSEUDO_REGISTER)\n     target = gen_reg_rtx (TYPE_MODE (integer_type_node));\n \n@@ -1336,7 +1336,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n       rtx value = gen_reg_rtx (Pmode);\n       emit_move_insn (value, adjust_address (arguments, Pmode, size));\n       emit_move_insn (struct_value, value);\n-      if (GET_CODE (struct_value) == REG)\n+      if (REG_P (struct_value))\n \tuse_reg (&call_fusage, struct_value);\n       size += GET_MODE_SIZE (Pmode);\n     }\n@@ -1831,7 +1831,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n \t\t  rtx operand = XEXP (XEXP (XEXP (note, 0), 1), 0);\n \t\t  /* Check operand is a register with expected mode.  */\n \t\t  if (operand\n-\t\t      && GET_CODE (operand) == REG\n+\t\t      && REG_P (operand)\n \t\t      && GET_MODE (operand) == mode)\n \t\t    {\n \t\t      /* Replace the REG_EQUAL note with a SQRT rtx.  */\n@@ -2404,7 +2404,7 @@ expand_builtin_strlen (tree arglist, rtx target,\n       /* Make a place to write the result of the instruction.  */\n       result = target;\n       if (! (result != 0\n-\t     && GET_CODE (result) == REG\n+\t     && REG_P (result)\n \t     && GET_MODE (result) == insn_mode\n \t     && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n \tresult = gen_reg_rtx (insn_mode);\n@@ -3415,7 +3415,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n     /* Make a place to write the result of the instruction.  */\n     result = target;\n     if (! (result != 0\n-\t   && GET_CODE (result) == REG && GET_MODE (result) == insn_mode\n+\t   && REG_P (result) && GET_MODE (result) == insn_mode\n \t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n       result = gen_reg_rtx (insn_mode);\n \n@@ -3570,7 +3570,7 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n     /* Make a place to write the result of the instruction.  */\n     result = target;\n     if (! (result != 0\n-\t   && GET_CODE (result) == REG && GET_MODE (result) == insn_mode\n+\t   && REG_P (result) && GET_MODE (result) == insn_mode\n \t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n       result = gen_reg_rtx (insn_mode);\n \n@@ -3741,7 +3741,7 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n     /* Make a place to write the result of the instruction.  */\n     result = target;\n     if (! (result != 0\n-\t   && GET_CODE (result) == REG && GET_MODE (result) == insn_mode\n+\t   && REG_P (result) && GET_MODE (result) == insn_mode\n \t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n       result = gen_reg_rtx (insn_mode);\n \n@@ -4654,7 +4654,7 @@ expand_builtin_frame_address (tree fndecl, tree arglist)\n       if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n \treturn tem;\n \n-      if (GET_CODE (tem) != REG\n+      if (!REG_P (tem)\n \t  && ! CONSTANT_P (tem))\n \ttem = copy_to_mode_reg (Pmode, tem);\n       return tem;"}, {"sha": "606a76245a7b031a290c75c656622837d084ab1b", "filename": "gcc/caller-save.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -504,12 +504,12 @@ mark_set_regs (rtx reg, rtx setter ATTRIBUTE_UNUSED,\n   if (GET_CODE (reg) == SUBREG)\n     {\n       rtx inner = SUBREG_REG (reg);\n-      if (GET_CODE (inner) != REG || REGNO (inner) >= FIRST_PSEUDO_REGISTER)\n+      if (!REG_P (inner) || REGNO (inner) >= FIRST_PSEUDO_REGISTER)\n \treturn;\n \n       regno = subreg_hard_regno (reg, 1);\n     }\n-  else if (GET_CODE (reg) == REG\n+  else if (REG_P (reg)\n \t   && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     regno = REGNO (reg);\n   else\n@@ -535,7 +535,7 @@ add_stored_regs (rtx reg, rtx setter, void *data)\n   if (GET_CODE (setter) == CLOBBER)\n     return;\n \n-  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+  if (GET_CODE (reg) == SUBREG && REG_P (SUBREG_REG (reg)))\n     {\n       offset = subreg_regno_offset (REGNO (SUBREG_REG (reg)),\n \t\t\t\t    GET_MODE (SUBREG_REG (reg)),\n@@ -544,7 +544,7 @@ add_stored_regs (rtx reg, rtx setter, void *data)\n       reg = SUBREG_REG (reg);\n     }\n \n-  if (GET_CODE (reg) != REG || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+  if (!REG_P (reg) || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n     return;\n \n   regno = REGNO (reg) + offset;\n@@ -570,7 +570,7 @@ mark_referenced_regs (rtx x)\n       code = GET_CODE (x);\n       if ((code == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t  || code == PC || code == CC0\n-\t  || (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n+\t  || (code == SUBREG && REG_P (SUBREG_REG (x))\n \t      && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER\n \t      /* If we're setting only part of a multi-word register,\n \t\t we shall mark it as referenced, because the words\n@@ -824,7 +824,7 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n \t      rtx reg = XEXP (link, 0);\n \t      int regno, i;\n \n-\t      if (GET_CODE (reg) != REG)\n+\t      if (!REG_P (reg))\n \t\tabort ();\n \n \t      regno = REGNO (reg);"}, {"sha": "c443542fce2d83e722a10f119d860fb7c4d18c23", "filename": "gcc/calls.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -305,7 +305,7 @@ prepare_call_address (rtx funexp, rtx static_chain_value,\n     {\n       emit_move_insn (static_chain_rtx, static_chain_value);\n \n-      if (GET_CODE (static_chain_rtx) == REG)\n+      if (REG_P (static_chain_rtx))\n \tuse_reg (call_fusage, static_chain_rtx);\n     }\n \n@@ -811,9 +811,9 @@ precompute_register_parameters (int num_actuals, struct arg_data *args, int *reg\n \t   register parameters.  This is to avoid reload conflicts while\n \t   loading the parameters registers.  */\n \n-\tif ((! (GET_CODE (args[i].value) == REG\n+\tif ((! (REG_P (args[i].value)\n \t\t|| (GET_CODE (args[i].value) == SUBREG\n-\t\t    && GET_CODE (SUBREG_REG (args[i].value)) == REG)))\n+\t\t    && REG_P (SUBREG_REG (args[i].value)))))\n \t    && args[i].mode != BLKmode\n \t    && rtx_cost (args[i].value, SET) > COSTS_N_INSNS (1)\n \t    && ((SMALL_REGISTER_CLASSES && *reg_parm_seen)\n@@ -1412,7 +1412,7 @@ precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n \t    /* CSE will replace this only if it contains args[i].value\n \t       pseudo, so convert it down to the declared mode using\n \t       a SUBREG.  */\n-\t    if (GET_CODE (args[i].value) == REG\n+\t    if (REG_P (args[i].value)\n \t\t&& GET_MODE_CLASS (args[i].mode) == MODE_INT)\n \t      {\n \t\targs[i].initial_value\n@@ -2254,7 +2254,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t is not a REG, we must always copy it into a register.\n \t If it is virtual_outgoing_args_rtx, we must copy it to another\n \t register in some cases.  */\n-      rtx temp = (GET_CODE (structure_value_addr) != REG\n+      rtx temp = (!REG_P (structure_value_addr)\n \t\t  || (ACCUMULATE_OUTGOING_ARGS\n \t\t      && stack_arg_under_construction\n \t\t      && structure_value_addr == virtual_outgoing_args_rtx)\n@@ -2904,7 +2904,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t\t\t     force_operand (structure_value_addr,\n \t\t\t\t\t\t    NULL_RTX)));\n \n-\t  if (GET_CODE (struct_value) == REG)\n+\t  if (REG_P (struct_value))\n \t    use_reg (&call_fusage, struct_value);\n \t}\n \n@@ -3162,7 +3162,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t{\n       /* If we promoted this return value, make the proper SUBREG.  TARGET\n \t might be const0_rtx here, so be careful.  */\n-      if (GET_CODE (target) == REG\n+      if (REG_P (target)\n \t  && TYPE_MODE (TREE_TYPE (exp)) != BLKmode\n \t  && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n \t{\n@@ -3643,7 +3643,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       nargs++;\n \n       /* Make sure it is a reasonable operand for a move or push insn.  */\n-      if (GET_CODE (addr) != REG && GET_CODE (addr) != MEM\n+      if (!REG_P (addr) && GET_CODE (addr) != MEM\n \t  && ! (CONSTANT_P (addr) && LEGITIMATE_CONSTANT_P (addr)))\n \taddr = force_operand (addr, NULL_RTX);\n \n@@ -3689,7 +3689,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t either emit_move_insn or emit_push_insn will do that.  */\n \n       /* Make sure it is a reasonable operand for a move or push insn.  */\n-      if (GET_CODE (val) != REG && GET_CODE (val) != MEM\n+      if (!REG_P (val) && GET_CODE (val) != MEM\n \t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n \tval = force_operand (val, NULL_RTX);\n \n@@ -4030,7 +4030,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t      force_reg (Pmode,\n \t\t\t\t force_operand (XEXP (mem_value, 0),\n \t\t\t\t\t\tNULL_RTX)));\n-      if (GET_CODE (struct_value) == REG)\n+      if (REG_P (struct_value))\n \tuse_reg (&call_fusage, struct_value);\n     }\n "}, {"sha": "2f2f121ec005f89e8cee4fb19f477f5c7bf789f8", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -69,7 +69,7 @@ flow_active_insn_p (rtx insn)\n      function.  If we allow it to be skipped, we introduce the\n      possibility for register livetime aborts.  */\n   if (GET_CODE (PATTERN (insn)) == CLOBBER\n-      && GET_CODE (XEXP (PATTERN (insn), 0)) == REG\n+      && REG_P (XEXP (PATTERN (insn), 0))\n       && REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))\n     return true;\n "}, {"sha": "c0fef9d7f38a1d8fabc6a9e1bae1c60dc785ed66", "filename": "gcc/combine.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -845,7 +845,7 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n {\n   unsigned int num;\n \n-  if (GET_CODE (x) == REG\n+  if (REG_P (x)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n@@ -979,7 +979,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t\t something to tell them apart, e.g. different modes.  For\n \t\t now, we forgo such complicated tests and simply disallow\n \t\t combining of USES of pseudo registers with any other USE.  */\n-\t      if (GET_CODE (XEXP (elt, 0)) == REG\n+\t      if (REG_P (XEXP (elt, 0))\n \t\t  && GET_CODE (PATTERN (i3)) == PARALLEL)\n \t\t{\n \t\t  rtx i3pat = PATTERN (i3);\n@@ -991,7 +991,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t\t      rtx i3elt = XVECEXP (i3pat, 0, i);\n \n \t\t      if (GET_CODE (i3elt) == USE\n-\t\t\t  && GET_CODE (XEXP (i3elt, 0)) == REG\n+\t\t\t  && REG_P (XEXP (i3elt, 0))\n \t\t\t  && (REGNO (XEXP (i3elt, 0)) == regno\n \t\t\t      ? reg_set_between_p (XEXP (elt, 0),\n \t\t\t\t\t\t   PREV_INSN (insn), i3)\n@@ -1056,7 +1056,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n       /* Don't eliminate a function call argument.  */\n       || (GET_CODE (i3) == CALL_INSN\n \t  && (find_reg_fusage (i3, USE, dest)\n-\t      || (GET_CODE (dest) == REG\n+\t      || (REG_P (dest)\n \t\t  && REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t\t  && global_regs[REGNO (dest)])))\n       /* Don't substitute into an incremented register.  */\n@@ -1101,7 +1101,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n     return 0;\n \n   /* DEST must either be a REG or CC0.  */\n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     {\n       /* If register alignment is being enforced for multi-word items in all\n \t cases except for parameters, it is possible to have a register copy\n@@ -1112,7 +1112,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t Also, on some machines we don't want to extend the life of a hard\n \t register.  */\n \n-      if (GET_CODE (src) == REG\n+      if (REG_P (src)\n \t  && ((REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t       && ! HARD_REGNO_MODE_OK (REGNO (dest), GET_MODE (dest)))\n \t      /* Don't extend the life of a hard register unless it is\n@@ -1158,7 +1158,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n      to be an explicit register variable, and was chosen for a reason.  */\n \n   if (GET_CODE (src) == ASM_OPERANDS\n-      && GET_CODE (dest) == REG && REGNO (dest) < FIRST_PSEUDO_REGISTER)\n+      && REG_P (dest) && REGNO (dest) < FIRST_PSEUDO_REGISTER)\n     return 0;\n \n   /* If there are any volatile insns between INSN and I3, reject, because\n@@ -1284,7 +1284,7 @@ combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest,\n \t     function argument; the all_adjacent test in can_combine_p also\n \t     checks this; here, we do a more specific test for this case.  */\n \n-\t  || (GET_CODE (inner_dest) == REG\n+\t  || (REG_P (inner_dest)\n \t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER\n \t      && (! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n \t\t\t\t\tGET_MODE (inner_dest))))\n@@ -1296,7 +1296,7 @@ combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest,\n \t Never add REG_DEAD notes for the FRAME_POINTER_REGNUM or the\n \t STACK_POINTER_REGNUM, since these are always considered to be\n \t live.  Similarly for ARG_POINTER_REGNUM if it is fixed.  */\n-      if (pi3dest_killed && GET_CODE (dest) == REG\n+      if (pi3dest_killed && REG_P (dest)\n \t  && reg_referenced_p (dest, PATTERN (i3))\n \t  && REGNO (dest) != FRAME_POINTER_REGNUM\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n@@ -1524,7 +1524,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      usage tests.  */\n \n   if (i1 == 0 && GET_CODE (i3) == INSN && GET_CODE (PATTERN (i3)) == SET\n-      && GET_CODE (SET_SRC (PATTERN (i3))) == REG\n+      && REG_P (SET_SRC (PATTERN (i3)))\n       && REGNO (SET_SRC (PATTERN (i3))) >= FIRST_PSEUDO_REGISTER\n       && find_reg_note (i3, REG_DEAD, SET_SRC (PATTERN (i3)))\n       && GET_CODE (PATTERN (i2)) == PARALLEL\n@@ -1591,7 +1591,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       && (temp = single_set (i2)) != 0\n       && (GET_CODE (SET_SRC (temp)) == CONST_INT\n \t  || GET_CODE (SET_SRC (temp)) == CONST_DOUBLE)\n-      && GET_CODE (SET_DEST (temp)) == REG\n+      && REG_P (SET_DEST (temp))\n       && GET_MODE_CLASS (GET_MODE (SET_DEST (temp))) == MODE_INT\n       && GET_MODE_SIZE (GET_MODE (SET_DEST (temp))) == 2 * UNITS_PER_WORD\n       && GET_CODE (PATTERN (i3)) == SET\n@@ -1676,7 +1676,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       && GET_CODE (SET_SRC (XVECEXP (PATTERN (i2), 0, 0))) == COMPARE\n       && XEXP (SET_SRC (XVECEXP (PATTERN (i2), 0, 0)), 1) == const0_rtx\n       && GET_CODE (XVECEXP (PATTERN (i2), 0, 1)) == SET\n-      && GET_CODE (SET_DEST (XVECEXP (PATTERN (i2), 0, 1))) == REG\n+      && REG_P (SET_DEST (XVECEXP (PATTERN (i2), 0, 1)))\n       && rtx_equal_p (XEXP (SET_SRC (XVECEXP (PATTERN (i2), 0, 0)), 0),\n \t\t      SET_SRC (XVECEXP (PATTERN (i2), 0, 1))))\n     {\n@@ -1748,7 +1748,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n #if 0\n   if (!(GET_CODE (PATTERN (i3)) == SET\n-\t&& GET_CODE (SET_SRC (PATTERN (i3))) == REG\n+\t&& REG_P (SET_SRC (PATTERN (i3)))\n \t&& GET_CODE (SET_DEST (PATTERN (i3))) == MEM\n \t&& (GET_CODE (XEXP (SET_DEST (PATTERN (i3)), 0)) == POST_INC\n \t    || GET_CODE (XEXP (SET_DEST (PATTERN (i3)), 0)) == POST_DEC)))\n@@ -2039,7 +2039,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       rtx set1 = XVECEXP (newpat, 0, 1);\n       rtx note;\n \n-      if (((GET_CODE (SET_DEST (set1)) == REG\n+      if (((REG_P (SET_DEST (set1))\n \t    && find_reg_note (i3, REG_UNUSED, SET_DEST (set1)))\n \t   || (GET_CODE (SET_DEST (set1)) == SUBREG\n \t       && find_reg_note (i3, REG_UNUSED, SUBREG_REG (SET_DEST (set1)))))\n@@ -2051,7 +2051,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n \t}\n \n-      else if (((GET_CODE (SET_DEST (set0)) == REG\n+      else if (((REG_P (SET_DEST (set0))\n \t\t && find_reg_note (i3, REG_UNUSED, SET_DEST (set0)))\n \t\t|| (GET_CODE (SET_DEST (set0)) == SUBREG\n \t\t    && find_reg_note (i3, REG_UNUSED,\n@@ -2106,7 +2106,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t     we can change its mode.  */\n \t  if (GET_MODE (SET_DEST (newpat)) != GET_MODE (i2dest)\n \t      && GET_MODE (SET_DEST (newpat)) != VOIDmode\n-\t      && GET_CODE (i2dest) == REG\n+\t      && REG_P (i2dest)\n \t      && (REGNO (i2dest) < FIRST_PSEUDO_REGISTER\n \t\t  || (REG_N_SETS (REGNO (i2dest)) == 1 && ! added_sets_2\n \t\t      && ! REG_USERVAR_P (i2dest))))\n@@ -2190,8 +2190,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t     || GET_CODE (new_i2_dest) == SUBREG)\n \t\tnew_i2_dest = XEXP (new_i2_dest, 0);\n \n-\t      if (GET_CODE (new_i3_dest) == REG\n-\t\t  && GET_CODE (new_i2_dest) == REG\n+\t      if (REG_P (new_i3_dest)\n+\t\t  && REG_P (new_i2_dest)\n \t\t  && REGNO (new_i3_dest) == REGNO (new_i2_dest))\n \t\tREG_N_SETS (REGNO (new_i2_dest))++;\n \t    }\n@@ -2202,7 +2202,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t are set between I2 and I3.  */\n       if (insn_code_number < 0 && (split = find_split_point (&newpat, i3)) != 0\n #ifdef HAVE_cc0\n-\t  && GET_CODE (i2dest) == REG\n+\t  && REG_P (i2dest)\n #endif\n \t  /* We need I2DEST in the proper mode.  If it is a hard register\n \t     or the only use of a pseudo, we can change its mode.  */\n@@ -2306,15 +2306,15 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != ZERO_EXTRACT\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n-\t\t (GET_CODE (temp) == REG\n+\t\t (REG_P (temp)\n \t\t  && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n \t\t  && (reg_stat[REGNO (temp)].nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n-\t\t     (GET_CODE (temp) == REG\n+\t\t     (REG_P (temp)\n \t\t      && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n@@ -2462,15 +2462,15 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  if (REG_NOTE_KIND (note) == REG_UNUSED\n \t      && ! reg_set_p (XEXP (note, 0), PATTERN (undobuf.other_insn)))\n \t    {\n-\t      if (GET_CODE (XEXP (note, 0)) == REG)\n+\t      if (REG_P (XEXP (note, 0)))\n \t\tREG_N_DEATHS (REGNO (XEXP (note, 0)))--;\n \n \t      remove_note (undobuf.other_insn, note);\n \t    }\n \t}\n \n       for (note = new_other_notes; note; note = XEXP (note, 1))\n-\tif (GET_CODE (XEXP (note, 0)) == REG)\n+\tif (REG_P (XEXP (note, 0)))\n \t  REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n \n       distribute_notes (new_other_notes, undobuf.other_insn,\n@@ -2561,7 +2561,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       {\n \tfor (i = 0; i < XVECLEN (PATTERN (i2), 0); i++)\n \t  if (GET_CODE (XVECEXP (PATTERN (i2), 0, i)) != USE\n-\t      && GET_CODE (SET_DEST (XVECEXP (PATTERN (i2), 0, i))) == REG\n+\t      && REG_P (SET_DEST (XVECEXP (PATTERN (i2), 0, i)))\n \t      && SET_DEST (XVECEXP (PATTERN (i2), 0, i)) != i2dest\n \t      && ! find_reg_note (i2, REG_UNUSED,\n \t\t\t\t  SET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n@@ -2644,7 +2644,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     if (newi2pat && new_i2_notes)\n       {\n \tfor (temp = new_i2_notes; temp; temp = XEXP (temp, 1))\n-\t  if (GET_CODE (XEXP (temp, 0)) == REG)\n+\t  if (REG_P (XEXP (temp, 0)))\n \t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n \n \tdistribute_notes (new_i2_notes, i2, i2, NULL_RTX);\n@@ -2653,7 +2653,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     if (new_i3_notes)\n       {\n \tfor (temp = new_i3_notes; temp; temp = XEXP (temp, 1))\n-\t  if (GET_CODE (XEXP (temp, 0)) == REG)\n+\t  if (REG_P (XEXP (temp, 0)))\n \t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n \n \tdistribute_notes (new_i3_notes, i3, i3, NULL_RTX);\n@@ -2668,7 +2668,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (i3dest_killed)\n       {\n-\tif (GET_CODE (i3dest_killed) == REG)\n+\tif (REG_P (i3dest_killed))\n \t  REG_N_DEATHS (REGNO (i3dest_killed))++;\n \n \tif (newi2pat && reg_set_p (i3dest_killed, newi2pat))\n@@ -2683,7 +2683,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (i2dest_in_i2src)\n       {\n-\tif (GET_CODE (i2dest) == REG)\n+\tif (REG_P (i2dest))\n \t  REG_N_DEATHS (REGNO (i2dest))++;\n \n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n@@ -2696,7 +2696,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (i1dest_in_i1src)\n       {\n-\tif (GET_CODE (i1dest) == REG)\n+\tif (REG_P (i1dest))\n \t  REG_N_DEATHS (REGNO (i1dest))++;\n \n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n@@ -2711,7 +2711,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     distribute_links (i2links);\n     distribute_links (i1links);\n \n-    if (GET_CODE (i2dest) == REG)\n+    if (REG_P (i2dest))\n       {\n \trtx link;\n \trtx i2_insn = 0, i2_val = 0, set;\n@@ -2742,7 +2742,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  }\n       }\n \n-    if (i1 && GET_CODE (i1dest) == REG)\n+    if (i1 && REG_P (i1dest))\n       {\n \trtx link;\n \trtx i1_insn = 0, i1_val = 0, set;\n@@ -3050,9 +3050,9 @@ find_split_point (rtx *loc, rtx insn)\n \t     be better.  */\n \n \t  if (GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n-\t      && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n+\t      && REG_P (XEXP (SET_SRC (x), 0))\n \t      && (pos = exact_log2 (INTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n-\t      && GET_CODE (SET_DEST (x)) == REG\n+\t      && REG_P (SET_DEST (x))\n \t      && (split = find_single_use (SET_DEST (x), insn, (rtx*) 0)) != 0\n \t      && (GET_CODE (*split) == EQ || GET_CODE (*split) == NE)\n \t      && XEXP (*split, 0) == SET_DEST (x)\n@@ -3286,7 +3286,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \n #define COMBINE_RTX_EQUAL_P(X,Y)\t\t\t\\\n   ((X) == (Y)\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == REG && GET_CODE (Y) == REG\t\\\n+   || (REG_P (X) && REG_P (Y)\t\\\n        && REGNO (X) == REGNO (Y) && GET_MODE (X) == GET_MODE (Y)))\n \n   if (! in_dest && COMBINE_RTX_EQUAL_P (x, from))\n@@ -3302,7 +3302,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n      delete the feeding insn, which is incorrect.\n \n      So force this insn not to match in this (rare) case.  */\n-  if (! in_dest && code == REG && GET_CODE (from) == REG\n+  if (! in_dest && code == REG && REG_P (from)\n       && REGNO (x) == REGNO (from))\n     return gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \n@@ -3346,7 +3346,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t{\n \t  rtx dest = SET_DEST (XVECEXP (x, 0, i));\n \n-\t  if (GET_CODE (dest) != REG\n+\t  if (!REG_P (dest)\n \t      && GET_CODE (dest) != CC0\n \t      && GET_CODE (dest) != PC)\n \t    {\n@@ -3371,7 +3371,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t where we want to suppress replacing something inside a\n \t SET_SRC are handled via the IN_DEST operand.  */\n       if (code == SET\n-\t  && (GET_CODE (SET_DEST (x)) == REG\n+\t  && (REG_P (SET_DEST (x))\n \t      || GET_CODE (SET_DEST (x)) == CC0\n \t      || GET_CODE (SET_DEST (x)) == PC))\n \tfmt = \"ie\";\n@@ -3417,7 +3417,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t  && (code == SUBREG || code == STRICT_LOW_PART\n \t\t      || code == ZERO_EXTRACT)\n \t\t  && i == 0\n-\t\t  && GET_CODE (new) == REG)\n+\t\t  && REG_P (new))\n \t\t;\n \n \t      else if (COMBINE_RTX_EQUAL_P (XEXP (x, i), from))\n@@ -3449,7 +3449,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \n #ifdef CANNOT_CHANGE_MODE_CLASS\n \t\t  if (code == SUBREG\n-\t\t      && GET_CODE (to) == REG\n+\t\t      && REG_P (to)\n \t\t      && REGNO (to) < FIRST_PSEUDO_REGISTER\n \t\t      && REG_CANNOT_CHANGE_MODE_P (REGNO (to),\n \t\t\t\t\t\t   GET_MODE (to),\n@@ -3911,9 +3911,9 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t or a SUBREG of one since we'd be making the expression more\n \t complex if it was just a register.  */\n \n-      if (GET_CODE (temp) != REG\n+      if (!REG_P (temp)\n \t  && ! (GET_CODE (temp) == SUBREG\n-\t\t&& GET_CODE (SUBREG_REG (temp)) == REG)\n+\t\t&& REG_P (SUBREG_REG (temp)))\n \t  && (i = exact_log2 (nonzero_bits (temp, mode))) >= 0)\n \t{\n \t  rtx temp1 = simplify_shift_const\n@@ -4177,9 +4177,9 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t the bitsize of the mode - 1.  This allows simplification of\n \t \"a = (b & 8) == 0;\"  */\n       if (XEXP (x, 1) == constm1_rtx\n-\t  && GET_CODE (XEXP (x, 0)) != REG\n+\t  && !REG_P (XEXP (x, 0))\n \t  && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t\t&& GET_CODE (SUBREG_REG (XEXP (x, 0))) == REG)\n+\t\t&& REG_P (SUBREG_REG (XEXP (x, 0))))\n \t  && nonzero_bits (XEXP (x, 0), mode) == 1)\n \treturn simplify_shift_const (NULL_RTX, ASHIFTRT, mode,\n \t   simplify_shift_const (NULL_RTX, ASHIFT, mode,\n@@ -4541,7 +4541,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \treturn simplify_shift_const (x, code, mode, XEXP (x, 0),\n \t\t\t\t     INTVAL (XEXP (x, 1)));\n \n-      else if (SHIFT_COUNT_TRUNCATED && GET_CODE (XEXP (x, 1)) != REG)\n+      else if (SHIFT_COUNT_TRUNCATED && !REG_P (XEXP (x, 1)))\n \tSUBST (XEXP (x, 1),\n \t       force_to_mode (XEXP (x, 1), GET_MODE (XEXP (x, 1)),\n \t\t\t      ((HOST_WIDE_INT) 1\n@@ -4630,7 +4630,7 @@ simplify_if_then_else (rtx x)\n   if (comparison_p\n       && ((false_code = combine_reversed_comparison_code (cond))\n \t  != UNKNOWN)\n-      && GET_CODE (XEXP (cond, 0)) == REG)\n+      && REG_P (XEXP (cond, 0)))\n     {\n       HOST_WIDE_INT nzb;\n       rtx from = XEXP (cond, 0);\n@@ -5140,14 +5140,14 @@ simplify_set (rtx x)\n         < GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n #endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-      && ! (GET_CODE (dest) == REG && REGNO (dest) < FIRST_PSEUDO_REGISTER\n+      && ! (REG_P (dest) && REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t    && REG_CANNOT_CHANGE_MODE_P (REGNO (dest),\n \t\t\t\t\t GET_MODE (SUBREG_REG (src)),\n \t\t\t\t\t GET_MODE (src)))\n #endif\n-      && (GET_CODE (dest) == REG\n+      && (REG_P (dest)\n \t  || (GET_CODE (dest) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (dest)) == REG)))\n+\t      && REG_P (SUBREG_REG (dest)))))\n     {\n       SUBST (SET_DEST (x),\n \t     gen_lowpart (GET_MODE (SUBREG_REG (src)),\n@@ -6015,7 +6015,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       && ((pos_rtx == 0 && (pos % BITS_PER_WORD) == 0\n \t   && GET_CODE (inner) != MEM\n \t   && (! in_dest\n-\t       || (GET_CODE (inner) == REG\n+\t       || (REG_P (inner)\n \t\t   && have_insn_for (STRICT_LOW_PART, tmode))))\n \t  || (GET_CODE (inner) == MEM && pos_rtx == 0\n \t      && (pos\n@@ -6047,7 +6047,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n \t  new = adjust_address_nv (inner, tmode, offset);\n \t}\n-      else if (GET_CODE (inner) == REG)\n+      else if (REG_P (inner))\n \t{\n \t  if (tmode != inner_mode)\n \t    {\n@@ -9127,7 +9127,7 @@ recog_for_combine (rtx *pnewpat, rtx insn, rtx *pnotes)\n       for (i = XVECLEN (newpat, 0) - num_clobbers_to_add;\n \t   i < XVECLEN (newpat, 0); i++)\n \t{\n-\t  if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) == REG\n+\t  if (REG_P (XEXP (XVECEXP (newpat, 0, i), 0))\n \t      && ! reg_dead_at_p (XEXP (XVECEXP (newpat, 0, i), 0), insn))\n \t    return -1;\n \t  notes = gen_rtx_EXPR_LIST (REG_UNUSED,\n@@ -9192,7 +9192,7 @@ gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n #ifdef CANNOT_CHANGE_MODE_CLASS\n   if (result != 0\n       && GET_CODE (result) == SUBREG\n-      && GET_CODE (SUBREG_REG (result)) == REG\n+      && REG_P (SUBREG_REG (result))\n       && REGNO (SUBREG_REG (result)) >= FIRST_PSEUDO_REGISTER)\n     bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (result))\n \t\t\t\t      * MAX_MACHINE_MODE\n@@ -10393,7 +10393,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t{\n \t  /* For paradoxical subregs, allow case 1 as above.  Case 3 isn't\n \t     implemented.  */\n-          if (GET_CODE (SUBREG_REG (op0)) == REG)\n+          if (REG_P (SUBREG_REG (op0)))\n \t    {\n \t      op0 = SUBREG_REG (op0);\n \t      op1 = gen_lowpart (GET_MODE (op0), op1);\n@@ -10714,7 +10714,7 @@ record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     {\n       /* If we are setting the whole register, we know its value.  Otherwise\n \t show that we don't know the value.  We can handle SUBREG in\n@@ -10757,7 +10757,7 @@ record_dead_and_set_regs (rtx insn)\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     {\n       if (REG_NOTE_KIND (link) == REG_DEAD\n-\t  && GET_CODE (XEXP (link, 0)) == REG)\n+\t  && REG_P (XEXP (link, 0)))\n \t{\n \t  unsigned int regno = REGNO (XEXP (link, 0));\n \t  unsigned int endregno\n@@ -10821,7 +10821,7 @@ record_promoted_value (rtx insn, rtx subreg)\n       insn = XEXP (links, 0);\n       set = single_set (insn);\n \n-      if (! set || GET_CODE (SET_DEST (set)) != REG\n+      if (! set || !REG_P (SET_DEST (set))\n \t  || REGNO (SET_DEST (set)) != regno\n \t  || GET_MODE (SET_DEST (set)) != GET_MODE (SUBREG_REG (subreg)))\n \t{\n@@ -10835,7 +10835,7 @@ record_promoted_value (rtx insn, rtx subreg)\n \t    reg_stat[regno].last_set_nonzero_bits &= GET_MODE_MASK (mode);\n \t}\n \n-      if (GET_CODE (SET_SRC (set)) == REG)\n+      if (REG_P (SET_SRC (set)))\n \t{\n \t  regno = REGNO (SET_SRC (set));\n \t  links = LOG_LINKS (insn);\n@@ -10852,7 +10852,7 @@ static void\n check_promoted_subreg (rtx insn, rtx x)\n {\n   if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)\n-      && GET_CODE (SUBREG_REG (x)) == REG)\n+      && REG_P (SUBREG_REG (x)))\n     record_promoted_value (insn, x);\n   else\n     {\n@@ -10893,7 +10893,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n   int len = GET_RTX_LENGTH (GET_CODE (x));\n   int i;\n \n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       unsigned int regno = REGNO (x);\n       unsigned int endregno\n@@ -10997,7 +10997,7 @@ get_last_value (rtx x)\n       && (value = get_last_value (SUBREG_REG (x))) != 0)\n     return gen_lowpart (GET_MODE (x), value);\n \n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     return 0;\n \n   regno = REGNO (x);\n@@ -11108,7 +11108,7 @@ reg_dead_at_p_1 (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int regno, endregno;\n \n-  if (GET_CODE (dest) != REG)\n+  if (!REG_P (dest))\n     return;\n \n   regno = REGNO (dest);\n@@ -11505,7 +11505,7 @@ reg_bitfield_target_p (rtx x, rtx body)\n       if (GET_CODE (target) == SUBREG)\n \ttarget = SUBREG_REG (target);\n \n-      if (GET_CODE (target) != REG)\n+      if (!REG_P (target))\n \treturn 0;\n \n       tregno = REGNO (target), regno = REGNO (x);\n@@ -11545,7 +11545,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \n       /* If this NOTE references a pseudo register, ensure it references\n \t the latest copy of that register.  */\n-      if (XEXP (note, 0) && GET_CODE (XEXP (note, 0)) == REG\n+      if (XEXP (note, 0) && REG_P (XEXP (note, 0))\n \t  && REGNO (XEXP (note, 0)) >= FIRST_PSEUDO_REGISTER)\n \tXEXP (note, 0) = regno_reg_rtx[REGNO (XEXP (note, 0))];\n \n@@ -11635,7 +11635,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t      if (from_insn != i3)\n \t\tbreak;\n \n-\t      if (! (GET_CODE (XEXP (note, 0)) == REG\n+\t      if (! (REG_P (XEXP (note, 0))\n \t\t     ? find_regno_note (i3, REG_UNUSED, REGNO (XEXP (note, 0)))\n \t\t     : find_reg_note (i3, REG_UNUSED, XEXP (note, 0))))\n \t\tplace = i3;\n@@ -11644,7 +11644,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t     now dies here, so we must put a REG_DEAD note here unless there\n \t     is one already.  */\n \t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (i3))\n-\t\t   && ! (GET_CODE (XEXP (note, 0)) == REG\n+\t\t   && ! (REG_P (XEXP (note, 0))\n \t\t\t ? find_regno_note (i3, REG_DEAD,\n \t\t\t\t\t    REGNO (XEXP (note, 0)))\n \t\t\t : find_reg_note (i3, REG_DEAD, XEXP (note, 0))))\n@@ -12068,14 +12068,14 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t}\n       else if ((REG_NOTE_KIND (note) == REG_DEAD\n \t\t|| REG_NOTE_KIND (note) == REG_UNUSED)\n-\t       && GET_CODE (XEXP (note, 0)) == REG)\n+\t       && REG_P (XEXP (note, 0)))\n \tREG_N_DEATHS (REGNO (XEXP (note, 0)))--;\n \n       if (place2)\n \t{\n \t  if ((REG_NOTE_KIND (note) == REG_DEAD\n \t       || REG_NOTE_KIND (note) == REG_UNUSED)\n-\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t      && REG_P (XEXP (note, 0)))\n \t    REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n \n \t  REG_NOTES (place2) = gen_rtx_fmt_ee (GET_CODE (note),\n@@ -12189,7 +12189,7 @@ unmentioned_reg_p_1 (rtx *loc, void *expr)\n   rtx x = *loc;\n \n   if (x != NULL_RTX\n-      && (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n+      && (REG_P (x) || GET_CODE (x) == MEM)\n       && ! reg_mentioned_p (x, (rtx) expr))\n     return 1;\n   return 0;"}, {"sha": "dd6e2a1f0f016d78726f8cbb6548b82697e77317", "filename": "gcc/conflict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -376,7 +376,7 @@ mark_reg (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *data)\n     reg = SUBREG_REG (reg);\n \n   /* We're only interested in regs.  */\n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   SET_REGNO_REG_SET (set, REGNO (reg));"}, {"sha": "bb898d0498c4ad8d1abcf22c4d6e1645f7bdd8a1", "filename": "gcc/cse.c", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -485,7 +485,7 @@ struct table_elt\n    register (hard registers may require `do_not_record' to be set).  */\n \n #define HASH(X, M)\t\\\n- ((GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+ ((REG_P (X) && REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n   ? (((unsigned) REG << 7) + (unsigned) REG_QTY (REGNO (X)))\t\\\n   : canon_hash (X, M)) & HASH_MASK)\n \n@@ -510,8 +510,8 @@ struct table_elt\n    || ((N) < FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n        && FIXED_REGNO_P (N) && REGNO_REG_CLASS (N) != NO_REGS))\n \n-#define COST(X) (GET_CODE (X) == REG ? 0 : notreg_cost (X, SET))\n-#define COST_IN(X,OUTER) (GET_CODE (X) == REG ? 0 : notreg_cost (X, OUTER))\n+#define COST(X) (REG_P (X) ? 0 : notreg_cost (X, SET))\n+#define COST_IN(X,OUTER) (REG_P (X) ? 0 : notreg_cost (X, OUTER))\n \n /* Get the info associated with register N.  */\n \n@@ -729,7 +729,7 @@ approx_reg_cost_1 (rtx *xp, void *data)\n   rtx x = *xp;\n   int *cost_p = data;\n \n-  if (x && GET_CODE (x) == REG)\n+  if (x && REG_P (x))\n     {\n       unsigned int regno = REGNO (x);\n \n@@ -807,7 +807,7 @@ static int\n notreg_cost (rtx x, enum rtx_code outer)\n {\n   return ((GET_CODE (x) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (x)) == REG\n+\t   && REG_P (SUBREG_REG (x))\n \t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n \t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_INT\n \t   && (GET_MODE_SIZE (GET_MODE (x))\n@@ -1086,7 +1086,7 @@ mention_regs (rtx x)\n   /* If this is a SUBREG, we don't want to discard other SUBREGs of the same\n      pseudo if they don't use overlapping words.  We handle only pseudos\n      here for simplicity.  */\n-  if (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n+  if (code == SUBREG && REG_P (SUBREG_REG (x))\n       && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)\n     {\n       unsigned int i = REGNO (SUBREG_REG (x));\n@@ -1122,15 +1122,15 @@ mention_regs (rtx x)\n \n   if (code == COMPARE || COMPARISON_P (x))\n     {\n-      if (GET_CODE (XEXP (x, 0)) == REG\n+      if (REG_P (XEXP (x, 0))\n \t  && ! REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n \tif (insert_regs (XEXP (x, 0), NULL, 0))\n \t  {\n \t    rehash_using_reg (XEXP (x, 0));\n \t    changed = 1;\n \t  }\n \n-      if (GET_CODE (XEXP (x, 1)) == REG\n+      if (REG_P (XEXP (x, 1))\n \t  && ! REGNO_QTY_VALID_P (REGNO (XEXP (x, 1))))\n \tif (insert_regs (XEXP (x, 1), NULL, 0))\n \t  {\n@@ -1163,7 +1163,7 @@ mention_regs (rtx x)\n static int\n insert_regs (rtx x, struct table_elt *classp, int modified)\n {\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       unsigned int regno = REGNO (x);\n       int qty_valid;\n@@ -1186,7 +1186,7 @@ insert_regs (rtx x, struct table_elt *classp, int modified)\n \t    for (classp = classp->first_same_value;\n \t\t classp != 0;\n \t\t classp = classp->next_same_value)\n-\t      if (GET_CODE (classp->exp) == REG\n+\t      if (REG_P (classp->exp)\n \t\t  && GET_MODE (classp->exp) == GET_MODE (x))\n \t\t{\n \t\t  make_regs_eqv (regno, REGNO (classp->exp));\n@@ -1219,7 +1219,7 @@ insert_regs (rtx x, struct table_elt *classp, int modified)\n      not be accessible because its hash code will have changed.  So assign\n      a quantity number now.  */\n \n-  else if (GET_CODE (x) == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n+  else if (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x))\n \t   && ! REGNO_QTY_VALID_P (REGNO (SUBREG_REG (x))))\n     {\n       insert_regs (SUBREG_REG (x), NULL, 0);\n@@ -1326,8 +1326,8 @@ lookup (rtx x, unsigned int hash, enum machine_mode mode)\n   struct table_elt *p;\n \n   for (p = table[hash]; p; p = p->next_same_hash)\n-    if (mode == p->mode && ((x == p->exp && GET_CODE (x) == REG)\n-\t\t\t    || exp_equiv_p (x, p->exp, GET_CODE (x) != REG, 0)))\n+    if (mode == p->mode && ((x == p->exp && REG_P (x))\n+\t\t\t    || exp_equiv_p (x, p->exp, !REG_P (x), 0)))\n       return p;\n \n   return 0;\n@@ -1341,14 +1341,14 @@ lookup_for_remove (rtx x, unsigned int hash, enum machine_mode mode)\n {\n   struct table_elt *p;\n \n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       unsigned int regno = REGNO (x);\n \n       /* Don't check the machine mode when comparing registers;\n \t invalidating (REG:SI 0) also invalidates (REG:DF 0).  */\n       for (p = table[hash]; p; p = p->next_same_hash)\n-\tif (GET_CODE (p->exp) == REG\n+\tif (REG_P (p->exp)\n \t    && REGNO (p->exp) == regno)\n \t  return p;\n     }\n@@ -1428,11 +1428,11 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \n   /* If X is a register and we haven't made a quantity for it,\n      something is wrong.  */\n-  if (GET_CODE (x) == REG && ! REGNO_QTY_VALID_P (REGNO (x)))\n+  if (REG_P (x) && ! REGNO_QTY_VALID_P (REGNO (x)))\n     abort ();\n \n   /* If X is a hard register, show it is being put in the table.  */\n-  if (GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n     {\n       unsigned int regno = REGNO (x);\n       unsigned int endregno = regno + hard_regno_nregs[regno][GET_MODE (x)];\n@@ -1467,7 +1467,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n   elt->is_const = (CONSTANT_P (x)\n \t\t   /* GNU C++ takes advantage of this for `this'\n \t\t      (and other const values).  */\n-\t\t   || (GET_CODE (x) == REG\n+\t\t   || (REG_P (x)\n \t\t       && RTX_UNCHANGING_P (x)\n \t\t       && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n \t\t   || fixed_base_plus_p (x));\n@@ -1528,8 +1528,8 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n      update the qtys `const_insn' to show that `this_insn' is the latest\n      insn making that quantity equivalent to the constant.  */\n \n-  if (elt->is_const && classp && GET_CODE (classp->exp) == REG\n-      && GET_CODE (x) != REG)\n+  if (elt->is_const && classp && REG_P (classp->exp)\n+      && !REG_P (x))\n     {\n       int exp_q = REG_QTY (REGNO (classp->exp));\n       struct qty_table_elem *exp_ent = &qty_table[exp_q];\n@@ -1538,7 +1538,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n       exp_ent->const_insn = this_insn;\n     }\n \n-  else if (GET_CODE (x) == REG\n+  else if (REG_P (x)\n \t   && classp\n \t   && ! qty_table[REG_QTY (REGNO (x))].const_rtx\n \t   && ! elt->is_const)\n@@ -1547,7 +1547,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \n       for (p = classp; p != 0; p = p->next_same_value)\n \t{\n-\t  if (p->is_const && GET_CODE (p->exp) != REG)\n+\t  if (p->is_const && !REG_P (p->exp))\n \t    {\n \t      int x_q = REG_QTY (REGNO (x));\n \t      struct qty_table_elem *x_ent = &qty_table[x_q];\n@@ -1560,7 +1560,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \t}\n     }\n \n-  else if (GET_CODE (x) == REG\n+  else if (REG_P (x)\n \t   && qty_table[REG_QTY (REGNO (x))].const_rtx\n \t   && GET_MODE (x) == qty_table[REG_QTY (REGNO (x))].mode)\n     qty_table[REG_QTY (REGNO (x))].const_insn = this_insn;\n@@ -1631,12 +1631,12 @@ merge_equiv_classes (struct table_elt *class1, struct table_elt *class2)\n       /* Remove old entry, make a new one in CLASS1's class.\n \t Don't do this for invalid entries as we cannot find their\n \t hash code (it also isn't necessary).  */\n-      if (GET_CODE (exp) == REG || exp_equiv_p (exp, exp, 1, 0))\n+      if (REG_P (exp) || exp_equiv_p (exp, exp, 1, 0))\n \t{\n \t  hash_arg_in_memory = 0;\n \t  hash = HASH (exp, mode);\n \n-\t  if (GET_CODE (exp) == REG)\n+\t  if (REG_P (exp))\n \t    delete_reg_equiv (REGNO (exp));\n \n \t  remove_from_table (elt, hash);\n@@ -1665,7 +1665,7 @@ flush_hash_table (void)\n       {\n \t/* Note that invalidate can remove elements\n \t   after P in the current hash chain.  */\n-\tif (GET_CODE (p->exp) == REG)\n+\tif (REG_P (p->exp))\n \t  invalidate (p->exp, p->mode);\n \telse\n \t  remove_from_table (p, i);\n@@ -1769,7 +1769,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n \t\t  {\n \t\t    next = p->next_same_hash;\n \n-\t\t    if (GET_CODE (p->exp) != REG\n+\t\t    if (!REG_P (p->exp)\n \t\t\t|| REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n \t\t      continue;\n \n@@ -1856,7 +1856,7 @@ remove_invalid_refs (unsigned int regno)\n     for (p = table[i]; p; p = next)\n       {\n \tnext = p->next_same_hash;\n-\tif (GET_CODE (p->exp) != REG\n+\tif (!REG_P (p->exp)\n \t    && refers_to_regno_p (regno, regno + 1, p->exp, (rtx *) 0))\n \t  remove_from_table (p, i);\n       }\n@@ -1878,9 +1878,9 @@ remove_invalid_subreg_refs (unsigned int regno, unsigned int offset,\n \trtx exp = p->exp;\n \tnext = p->next_same_hash;\n \n-\tif (GET_CODE (exp) != REG\n+\tif (!REG_P (exp)\n \t    && (GET_CODE (exp) != SUBREG\n-\t\t|| GET_CODE (SUBREG_REG (exp)) != REG\n+\t\t|| !REG_P (SUBREG_REG (exp))\n \t\t|| REGNO (SUBREG_REG (exp)) != regno\n \t\t|| (((SUBREG_BYTE (exp)\n \t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1)) >= offset)\n@@ -1908,7 +1908,7 @@ rehash_using_reg (rtx x)\n   /* If X is not a register or if the register is known not to be in any\n      valid entries in the table, we have no work to do.  */\n \n-  if (GET_CODE (x) != REG\n+  if (!REG_P (x)\n       || REG_IN_TABLE (REGNO (x)) < 0\n       || REG_IN_TABLE (REGNO (x)) != REG_TICK (REGNO (x)))\n     return;\n@@ -1921,7 +1921,7 @@ rehash_using_reg (rtx x)\n     for (p = table[i]; p; p = next)\n       {\n \tnext = p->next_same_hash;\n-\tif (GET_CODE (p->exp) != REG && reg_mentioned_p (x, p->exp)\n+\tif (!REG_P (p->exp) && reg_mentioned_p (x, p->exp)\n \t    && exp_equiv_p (p->exp, p->exp, 1, 0)\n \t    && i != (hash = safe_hash (p->exp, p->mode) & HASH_MASK))\n \t  {\n@@ -1982,7 +1982,7 @@ invalidate_for_call (void)\n \t{\n \t  next = p->next_same_hash;\n \n-\t  if (GET_CODE (p->exp) != REG\n+\t  if (!REG_P (p->exp)\n \t      || REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n \t    continue;\n \n@@ -2048,7 +2048,7 @@ use_related_value (rtx x, struct table_elt *elt)\n \tq = 0;\n       else\n \tfor (q = p->first_same_value; q; q = q->next_same_value)\n-\t  if (GET_CODE (q->exp) == REG)\n+\t  if (REG_P (q->exp))\n \t    break;\n \n       if (q)\n@@ -2167,7 +2167,7 @@ canon_hash (rtx x, enum machine_mode mode)\n        want to have to forget unrelated subregs when one subreg changes.  */\n     case SUBREG:\n       {\n-\tif (GET_CODE (SUBREG_REG (x)) == REG)\n+\tif (REG_P (SUBREG_REG (x)))\n \t  {\n \t    hash += (((unsigned) SUBREG << 7)\n \t\t     + REGNO (SUBREG_REG (x))\n@@ -2398,7 +2398,7 @@ exp_equiv_p (rtx x, rtx y, int validate, int equal_values)\n \n       /* If X is a constant and Y is a register or vice versa, they may be\n \t equivalent.  We only have to validate if Y is a register.  */\n-      if (CONSTANT_P (x) && GET_CODE (y) == REG\n+      if (CONSTANT_P (x) && REG_P (y)\n \t  && REGNO_QTY_VALID_P (REGNO (y)))\n \t{\n \t  int y_q = REG_QTY (REGNO (y));\n@@ -2575,7 +2575,7 @@ cse_rtx_varies_p (rtx x, int from_alias)\n      mode because if X is equivalent to a constant in some mode, it\n      doesn't vary in any mode.  */\n \n-  if (GET_CODE (x) == REG\n+  if (REG_P (x)\n       && REGNO_QTY_VALID_P (REGNO (x)))\n     {\n       int x_q = REG_QTY (REGNO (x));\n@@ -2588,7 +2588,7 @@ cse_rtx_varies_p (rtx x, int from_alias)\n \n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n-      && GET_CODE (XEXP (x, 0)) == REG\n+      && REG_P (XEXP (x, 0))\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n     {\n       int x0_q = REG_QTY (REGNO (XEXP (x, 0)));\n@@ -2605,8 +2605,8 @@ cse_rtx_varies_p (rtx x, int from_alias)\n      load fp minus a constant into a register, then a MEM which is the\n      sum of the two `constant' registers.  */\n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n-      && GET_CODE (XEXP (x, 1)) == REG\n+      && REG_P (XEXP (x, 0))\n+      && REG_P (XEXP (x, 1))\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 1))))\n     {\n@@ -2701,7 +2701,7 @@ canon_reg (rtx x, rtx insn)\n \t  /* If replacing pseudo with hard reg or vice versa, ensure the\n \t     insn remains valid.  Likewise if the insn has MATCH_DUPs.  */\n \t  if (insn != 0 && new != 0\n-\t      && GET_CODE (new) == REG && GET_CODE (XEXP (x, i)) == REG\n+\t      && REG_P (new) && REG_P (XEXP (x, i))\n \t      && (((REGNO (new) < FIRST_PSEUDO_REGISTER)\n \t\t   != (REGNO (XEXP (x, i)) < FIRST_PSEUDO_REGISTER))\n \t\t  || (insn_code = recog_memoized (insn)) < 0\n@@ -2756,12 +2756,12 @@ find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n      no easy way to unshare the MEM.  In addition, looking up all stack\n      addresses is costly.  */\n   if ((GET_CODE (addr) == PLUS\n-       && GET_CODE (XEXP (addr, 0)) == REG\n+       && REG_P (XEXP (addr, 0))\n        && GET_CODE (XEXP (addr, 1)) == CONST_INT\n        && (regno = REGNO (XEXP (addr, 0)),\n \t   regno == FRAME_POINTER_REGNUM || regno == HARD_FRAME_POINTER_REGNUM\n \t   || regno == ARG_POINTER_REGNUM))\n-      || (GET_CODE (addr) == REG\n+      || (REG_P (addr)\n \t  && (regno = REGNO (addr), regno == FRAME_POINTER_REGNUM\n \t      || regno == HARD_FRAME_POINTER_REGNUM\n \t      || regno == ARG_POINTER_REGNUM))\n@@ -2773,7 +2773,7 @@ find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n      sometimes simplify the expression.  Many simplifications\n      will not be valid, but some, usually applying the associative rule, will\n      be valid and produce better code.  */\n-  if (GET_CODE (addr) != REG)\n+  if (!REG_P (addr))\n     {\n       rtx folded = fold_rtx (copy_rtx (addr), NULL_RTX);\n       int addr_folded_cost = address_cost (folded, mode);\n@@ -2824,7 +2824,7 @@ find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n \t  for (p = elt->first_same_value; p; p = p->next_same_value)\n \t    if (! p->flag)\n \t      {\n-\t\tif ((GET_CODE (p->exp) == REG\n+\t\tif ((REG_P (p->exp)\n \t\t     || exp_equiv_p (p->exp, p->exp, 1, 0))\n \t\t    && ((exp_cost = address_cost (p->exp, mode)) < best_addr_cost\n \t\t\t|| (exp_cost == best_addr_cost\n@@ -2860,7 +2860,7 @@ find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n \n   if (flag_expensive_optimizations\n       && ARITHMETIC_P (*loc)\n-      && GET_CODE (XEXP (*loc, 0)) == REG)\n+      && REG_P (XEXP (*loc, 0)))\n     {\n       rtx op1 = XEXP (*loc, 1);\n \n@@ -2900,7 +2900,7 @@ find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n \t       p && count < 32;\n \t       p = p->next_same_value, count++)\n \t    if (! p->flag\n-\t\t&& (GET_CODE (p->exp) == REG\n+\t\t&& (REG_P (p->exp)\n \t\t    || exp_equiv_p (p->exp, p->exp, 1, 0)))\n \t      {\n \t\trtx new = simplify_gen_binary (GET_CODE (*loc), Pmode,\n@@ -3261,7 +3261,7 @@ fold_rtx (rtx x, rtx insn)\n \t    return new;\n \t}\n \n-      if (GET_CODE (folded_arg0) == REG\n+      if (REG_P (folded_arg0)\n \t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (folded_arg0)))\n \t{\n \t  struct table_elt *elt;\n@@ -3306,7 +3306,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t  {\n \t\t    rtx op0 = SUBREG_REG (XEXP (elt->exp, 0));\n \n-\t\t    if (GET_CODE (op0) != REG && ! CONSTANT_P (op0))\n+\t\t    if (!REG_P (op0) && ! CONSTANT_P (op0))\n \t\t      op0 = fold_rtx (op0, NULL_RTX);\n \n \t\t    op0 = equiv_constant (op0);\n@@ -3331,13 +3331,13 @@ fold_rtx (rtx x, rtx insn)\n \t\t    rtx op0 = gen_lowpart_common (mode, XEXP (elt->exp, 0));\n \t\t    rtx op1 = gen_lowpart_common (mode, XEXP (elt->exp, 1));\n \n-\t\t    if (op0 && GET_CODE (op0) != REG && ! CONSTANT_P (op0))\n+\t\t    if (op0 && !REG_P (op0) && ! CONSTANT_P (op0))\n \t\t      op0 = fold_rtx (op0, NULL_RTX);\n \n \t\t    if (op0)\n \t\t      op0 = equiv_constant (op0);\n \n-\t\t    if (op1 && GET_CODE (op1) != REG && ! CONSTANT_P (op1))\n+\t\t    if (op1 && !REG_P (op1) && ! CONSTANT_P (op1))\n \t\t      op1 = fold_rtx (op1, NULL_RTX);\n \n \t\t    if (op1)\n@@ -3417,7 +3417,7 @@ fold_rtx (rtx x, rtx insn)\n \trtx base = 0;\n \tHOST_WIDE_INT offset = 0;\n \n-\tif (GET_CODE (addr) == REG\n+\tif (REG_P (addr)\n \t    && REGNO_QTY_VALID_P (REGNO (addr)))\n \t  {\n \t    int addr_q = REG_QTY (REGNO (addr));\n@@ -3584,7 +3584,7 @@ fold_rtx (rtx x, rtx insn)\n \t\tstruct qty_table_elem *arg_ent = &qty_table[arg_q];\n \n \t\tif (arg_ent->const_rtx != NULL_RTX\n-\t\t    && GET_CODE (arg_ent->const_rtx) != REG\n+\t\t    && !REG_P (arg_ent->const_rtx)\n \t\t    && GET_CODE (arg_ent->const_rtx) != PLUS)\n \t\t  const_arg\n \t\t    = gen_lowpart (GET_MODE (arg),\n@@ -3828,8 +3828,8 @@ fold_rtx (rtx x, rtx insn)\n \t      /* See if the two operands are the same.  */\n \n \t      if (folded_arg0 == folded_arg1\n-\t\t  || (GET_CODE (folded_arg0) == REG\n-\t\t      && GET_CODE (folded_arg1) == REG\n+\t\t  || (REG_P (folded_arg0)\n+\t\t      && REG_P (folded_arg1)\n \t\t      && (REG_QTY (REGNO (folded_arg0))\n \t\t\t  == REG_QTY (REGNO (folded_arg1))))\n \t\t  || ((p0 = lookup (folded_arg0,\n@@ -3857,7 +3857,7 @@ fold_rtx (rtx x, rtx insn)\n \t      /* If FOLDED_ARG0 is a register, see if the comparison we are\n \t\t doing now is either the same as we did before or the reverse\n \t\t (we only check the reverse if not floating-point).  */\n-\t      else if (GET_CODE (folded_arg0) == REG)\n+\t      else if (REG_P (folded_arg0))\n \t\t{\n \t\t  int qty = REG_QTY (REGNO (folded_arg0));\n \n@@ -3873,7 +3873,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t\t      || (const_arg1\n \t\t\t\t  && rtx_equal_p (ent->comparison_const,\n \t\t\t\t\t\t  const_arg1))\n-\t\t\t      || (GET_CODE (folded_arg1) == REG\n+\t\t\t      || (REG_P (folded_arg1)\n \t\t\t\t  && (REG_QTY (REGNO (folded_arg1)) == ent->comparison_qty))))\n \t\t\treturn (comparison_dominates_p (ent->comparison_code, code)\n \t\t\t\t? true_rtx : false_rtx);\n@@ -4007,7 +4007,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t manner and hope the Sun compilers get it correct.  */\n \t      && INTVAL (const_arg1) !=\n \t        ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1))\n-\t      && GET_CODE (folded_arg1) == REG)\n+\t      && REG_P (folded_arg1))\n \t    {\n \t      rtx new_const = GEN_INT (-INTVAL (const_arg1));\n \t      struct table_elt *p\n@@ -4016,7 +4016,7 @@ fold_rtx (rtx x, rtx insn)\n \n \t      if (p)\n \t\tfor (p = p->first_same_value; p; p = p->next_same_value)\n-\t\t  if (GET_CODE (p->exp) == REG)\n+\t\t  if (REG_P (p->exp))\n \t\t    return simplify_gen_binary (MINUS, mode, folded_arg0,\n \t\t\t\t\t\tcanon_reg (p->exp, NULL_RTX));\n \t    }\n@@ -4048,7 +4048,7 @@ fold_rtx (rtx x, rtx insn)\n \t     Note that the similar optimization done by combine.c only works\n \t     if the intermediate operation's result has only one reference.  */\n \n-\t  if (GET_CODE (folded_arg0) == REG\n+\t  if (REG_P (folded_arg0)\n \t      && const_arg1 && GET_CODE (const_arg1) == CONST_INT)\n \t    {\n \t      int is_shift\n@@ -4173,7 +4173,7 @@ fold_rtx (rtx x, rtx insn)\n static rtx\n equiv_constant (rtx x)\n {\n-  if (GET_CODE (x) == REG\n+  if (REG_P (x)\n       && REGNO_QTY_VALID_P (REGNO (x)))\n     {\n       int x_q = REG_QTY (REGNO (x));\n@@ -4429,11 +4429,11 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t register, or if OP1 is neither a register or constant, we can't\n \t do anything.  */\n \n-      if (GET_CODE (op1) != REG)\n+      if (!REG_P (op1))\n \top1 = equiv_constant (op1);\n \n       if ((reversed_nonequality && FLOAT_MODE_P (mode))\n-\t  || GET_CODE (op0) != REG || op1 == 0)\n+\t  || !REG_P (op0) || op1 == 0)\n \treturn;\n \n       /* Put OP0 in the hash table if it isn't already.  This gives it a\n@@ -4460,7 +4460,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n       ent = &qty_table[qty];\n \n       ent->comparison_code = code;\n-      if (GET_CODE (op1) == REG)\n+      if (REG_P (op1))\n \t{\n \t  /* Look it up again--in case op0 and op1 are the same.  */\n \t  op1_elt = lookup (op1, op1_hash, mode);\n@@ -4662,7 +4662,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t    {\n \t      rtx clobbered = XEXP (y, 0);\n \n-\t      if (GET_CODE (clobbered) == REG\n+\t      if (REG_P (clobbered)\n \t\t  || GET_CODE (clobbered) == SUBREG)\n \t\tinvalidate (clobbered, VOIDmode);\n \t      else if (GET_CODE (clobbered) == STRICT_LOW_PART\n@@ -4700,7 +4700,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\tcanon_reg (XEXP (y, 0), NULL_RTX);\n \t    }\n \t  else if (GET_CODE (y) == USE\n-\t\t   && ! (GET_CODE (XEXP (y, 0)) == REG\n+\t\t   && ! (REG_P (XEXP (y, 0))\n \t\t\t && REGNO (XEXP (y, 0)) < FIRST_PSEUDO_REGISTER))\n \t    canon_reg (y, NULL_RTX);\n \t  else if (GET_CODE (y) == CALL)\n@@ -4721,7 +4721,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n   /* Canonicalize a USE of a pseudo register or memory location.  */\n   else if (GET_CODE (x) == USE\n-\t   && ! (GET_CODE (XEXP (x, 0)) == REG\n+\t   && ! (REG_P (XEXP (x, 0))\n \t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER))\n     canon_reg (XEXP (x, 0), NULL_RTX);\n   else if (GET_CODE (x) == CALL)\n@@ -4763,7 +4763,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n       int insn_code;\n \n       sets[i].orig_src = src;\n-      if ((GET_CODE (new) == REG && GET_CODE (src) == REG\n+      if ((REG_P (new) && REG_P (src)\n \t   && ((REGNO (new) < FIRST_PSEUDO_REGISTER)\n \t       != (REGNO (src) < FIRST_PSEUDO_REGISTER)))\n \t  || (insn_code = recog_memoized (insn)) < 0\n@@ -4914,7 +4914,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n       if (GET_CODE (src) == MEM\n \t  && find_reg_note (insn, REG_EQUIV, NULL_RTX) != 0\n-\t  && GET_CODE (dest) == REG\n+\t  && REG_P (dest)\n \t  && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n \tsets[i].src_volatile = 1;\n \n@@ -5065,7 +5065,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n \t      for (const_elt = const_elt->first_same_value;\n \t\t   const_elt; const_elt = const_elt->next_same_value)\n-\t\tif (GET_CODE (const_elt->exp) == REG)\n+\t\tif (REG_P (const_elt->exp))\n \t\t  {\n \t\t    src_related = gen_lowpart (mode,\n \t\t\t\t\t\t\t   const_elt->exp);\n@@ -5104,7 +5104,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n \t\t  for (larger_elt = larger_elt->first_same_value;\n \t\t       larger_elt; larger_elt = larger_elt->next_same_value)\n-\t\t    if (GET_CODE (larger_elt->exp) == REG)\n+\t\t    if (REG_P (larger_elt->exp))\n \t\t      {\n \t\t\tsrc_related\n \t\t\t  = gen_lowpart (mode, larger_elt->exp);\n@@ -5150,7 +5150,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n \t      for (larger_elt = larger_elt->first_same_value;\n \t\t   larger_elt; larger_elt = larger_elt->next_same_value)\n-\t\tif (GET_CODE (larger_elt->exp) == REG)\n+\t\tif (REG_P (larger_elt->exp))\n \t\t  {\n \t\t    src_related = gen_lowpart (mode,\n \t\t\t\t\t\t\t   larger_elt->exp);\n@@ -5282,7 +5282,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t  rtx trial;\n \n \t  /* Skip invalid entries.  */\n-\t  while (elt && GET_CODE (elt->exp) != REG\n+\t  while (elt && !REG_P (elt->exp)\n \t\t && ! exp_equiv_p (elt->exp, elt->exp, 1, 0))\n \t    elt = elt->next_same_value;\n \n@@ -5385,7 +5385,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t need to make the same substitution in any notes attached\n \t\t to the RETVAL insn.  */\n \t      if (libcall_insn\n-\t\t  && (GET_CODE (sets[i].orig_src) == REG\n+\t\t  && (REG_P (sets[i].orig_src)\n \t\t      || GET_CODE (sets[i].orig_src) == SUBREG\n \t\t      || GET_CODE (sets[i].orig_src) == MEM))\n \t\t{\n@@ -5442,20 +5442,20 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t with the head of the class.  If we do not do this, we will have\n \t both registers live over a portion of the basic block.  This way,\n \t their lifetimes will likely abut instead of overlapping.  */\n-      if (GET_CODE (dest) == REG\n+      if (REG_P (dest)\n \t  && REGNO_QTY_VALID_P (REGNO (dest)))\n \t{\n \t  int dest_q = REG_QTY (REGNO (dest));\n \t  struct qty_table_elem *dest_ent = &qty_table[dest_q];\n \n \t  if (dest_ent->mode == GET_MODE (dest)\n \t      && dest_ent->first_reg != REGNO (dest)\n-\t      && GET_CODE (src) == REG && REGNO (src) == REGNO (dest)\n+\t      && REG_P (src) && REGNO (src) == REGNO (dest)\n \t      /* Don't do this if the original insn had a hard reg as\n \t\t SET_SRC or SET_DEST.  */\n-\t      && (GET_CODE (sets[i].src) != REG\n+\t      && (!REG_P (sets[i].src)\n \t\t  || REGNO (sets[i].src) >= FIRST_PSEUDO_REGISTER)\n-\t      && (GET_CODE (dest) != REG || REGNO (dest) >= FIRST_PSEUDO_REGISTER))\n+\t      && (!REG_P (dest) || REGNO (dest) >= FIRST_PSEUDO_REGISTER))\n \t    /* We can't call canon_reg here because it won't do anything if\n \t       SRC is a hard register.  */\n \t    {\n@@ -5506,8 +5506,8 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t which can be created for a reference to a compile time computable\n \t entry in a jump table.  */\n \n-      if (n_sets == 1 && src_const && GET_CODE (dest) == REG\n-\t  && GET_CODE (src_const) != REG\n+      if (n_sets == 1 && src_const && REG_P (dest)\n+\t  && !REG_P (src_const)\n \t  && ! (GET_CODE (src_const) == CONST\n \t\t&& GET_CODE (XEXP (src_const, 0)) == MINUS\n \t\t&& GET_CODE (XEXP (XEXP (src_const, 0), 0)) == LABEL_REF\n@@ -5652,7 +5652,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n       else if (do_not_record)\n \t{\n-\t  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n+\t  if (REG_P (dest) || GET_CODE (dest) == SUBREG)\n \t    invalidate (dest, VOIDmode);\n \t  else if (GET_CODE (dest) == MEM)\n \t    {\n@@ -5825,7 +5825,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t   previous quantity's chain.\n \t   Needed for memory if this is a nonvarying address, unless\n \t   we have just done an invalidate_memory that covers even those.  */\n-\tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n+\tif (REG_P (dest) || GET_CODE (dest) == SUBREG)\n \t  invalidate (dest, VOIDmode);\n \telse if (GET_CODE (dest) == MEM)\n \t  {\n@@ -5859,7 +5859,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t{\n \t  rtx x = SET_DEST (sets[i].rtl);\n \n-\t  if (GET_CODE (x) != REG)\n+\t  if (!REG_P (x))\n \t    mention_regs (x);\n \t  else\n \t    {\n@@ -5959,7 +5959,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \tif (GET_CODE (dest) == STRICT_LOW_PART)\n \t  dest = SUBREG_REG (XEXP (dest, 0));\n \n-\tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n+\tif (REG_P (dest) || GET_CODE (dest) == SUBREG)\n \t  /* Registers must also be inserted into chains for quantities.  */\n \t  if (insert_regs (dest, sets[i].src_elt, 1))\n \t    {\n@@ -6021,7 +6021,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\tint byte = 0;\n \n \t\t/* Ignore invalid entries.  */\n-\t\tif (GET_CODE (elt->exp) != REG\n+\t\tif (!REG_P (elt->exp)\n \t\t    && ! exp_equiv_p (elt->exp, elt->exp, 1, 0))\n \t\t  continue;\n \n@@ -6074,7 +6074,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\tclassp = src_elt->first_same_value;\n \t\t/* Ignore invalid entries.  */\n \t\twhile (classp\n-\t\t       && GET_CODE (classp->exp) != REG\n+\t\t       && !REG_P (classp->exp)\n \t\t       && ! exp_equiv_p (classp->exp, classp->exp, 1, 0))\n \t\t  classp = classp->next_same_value;\n \t      }\n@@ -6098,9 +6098,9 @@ cse_insn (rtx insn, rtx libcall_insn)\n      register to be set in the middle of a libcall, and we then get bad code\n      if the libcall is deleted.  */\n \n-  if (n_sets == 1 && sets[0].rtl && GET_CODE (SET_DEST (sets[0].rtl)) == REG\n+  if (n_sets == 1 && sets[0].rtl && REG_P (SET_DEST (sets[0].rtl))\n       && NEXT_INSN (PREV_INSN (insn)) == insn\n-      && GET_CODE (SET_SRC (sets[0].rtl)) == REG\n+      && REG_P (SET_SRC (sets[0].rtl))\n       && REGNO (SET_SRC (sets[0].rtl)) >= FIRST_PSEUDO_REGISTER\n       && REGNO_QTY_VALID_P (REGNO (SET_SRC (sets[0].rtl))))\n     {\n@@ -6208,7 +6208,7 @@ static int\n addr_affects_sp_p (rtx addr)\n {\n   if (GET_RTX_CLASS (GET_CODE (addr)) == RTX_AUTOINC\n-      && GET_CODE (XEXP (addr, 0)) == REG\n+      && REG_P (XEXP (addr, 0))\n       && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n     {\n       if (REG_TICK (STACK_POINTER_REGNUM) >= 0)\n@@ -6243,7 +6243,7 @@ invalidate_from_clobbers (rtx x)\n       rtx ref = XEXP (x, 0);\n       if (ref)\n \t{\n-\t  if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n+\t  if (REG_P (ref) || GET_CODE (ref) == SUBREG\n \t      || GET_CODE (ref) == MEM)\n \t    invalidate (ref, VOIDmode);\n \t  else if (GET_CODE (ref) == STRICT_LOW_PART\n@@ -6260,7 +6260,7 @@ invalidate_from_clobbers (rtx x)\n \t  if (GET_CODE (y) == CLOBBER)\n \t    {\n \t      rtx ref = XEXP (y, 0);\n-\t      if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n+\t      if (REG_P (ref) || GET_CODE (ref) == SUBREG\n \t\t  || GET_CODE (ref) == MEM)\n \t\tinvalidate (ref, VOIDmode);\n \t      else if (GET_CODE (ref) == STRICT_LOW_PART\n@@ -6335,7 +6335,7 @@ cse_process_notes (rtx x, rtx object)\n \n \t  if (ent->const_rtx != NULL_RTX\n \t      && (CONSTANT_P (ent->const_rtx)\n-\t\t  || GET_CODE (ent->const_rtx) == REG))\n+\t\t  || REG_P (ent->const_rtx)))\n \t    {\n \t      rtx new = gen_lowpart (GET_MODE (x), ent->const_rtx);\n \t      if (new)\n@@ -6399,9 +6399,9 @@ cse_around_loop (rtx loop_start)\n     for (p = last_jump_equiv_class->first_same_value; p;\n \t p = p->next_same_value)\n       {\n-\tif (GET_CODE (p->exp) == MEM || GET_CODE (p->exp) == REG\n+\tif (MEM_P (p->exp) || REG_P (p->exp)\n \t    || (GET_CODE (p->exp) == SUBREG\n-\t\t&& GET_CODE (SUBREG_REG (p->exp)) == REG))\n+\t\t&& REG_P (SUBREG_REG (p->exp))))\n \t  invalidate (p->exp, VOIDmode);\n \telse if (GET_CODE (p->exp) == STRICT_LOW_PART\n \t\t || GET_CODE (p->exp) == ZERO_EXTRACT)\n@@ -6544,7 +6544,7 @@ cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n      are setting PC or CC0 or whose SET_SRC is already a register.  */\n   if (GET_CODE (x) == SET\n       && GET_CODE (SET_DEST (x)) != PC && GET_CODE (SET_DEST (x)) != CC0\n-      && GET_CODE (SET_SRC (x)) != REG)\n+      && !REG_P (SET_SRC (x)))\n     {\n       src_elt = lookup (SET_SRC (x),\n \t\t\tHASH (SET_SRC (x), GET_MODE (SET_DEST (x))),\n@@ -6553,7 +6553,7 @@ cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n       if (src_elt)\n \tfor (src_elt = src_elt->first_same_value; src_elt;\n \t     src_elt = src_elt->next_same_value)\n-\t  if (GET_CODE (src_elt->exp) == REG && REG_LOOP_TEST_P (src_elt->exp)\n+\t  if (REG_P (src_elt->exp) && REG_LOOP_TEST_P (src_elt->exp)\n \t      && COST (src_elt->exp) < COST (SET_SRC (x)))\n \t    {\n \t      rtx p, set;\n@@ -6567,7 +6567,7 @@ cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n \t\t   && GET_CODE (p) != CODE_LABEL;\n \t\t   p = prev_nonnote_insn  (p))\n \t\tif ((set = single_set (p)) != 0\n-\t\t    && GET_CODE (SET_DEST (set)) == REG\n+\t\t    && REG_P (SET_DEST (set))\n \t\t    && GET_MODE (SET_DEST (set)) == src_elt->mode\n \t\t    && rtx_equal_p (SET_SRC (set), SET_SRC (x)))\n \t\t  {\n@@ -6632,7 +6632,7 @@ cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n \n   /* See comment on similar code in cse_insn for explanation of these\n      tests.  */\n-  if (GET_CODE (SET_DEST (x)) == REG || GET_CODE (SET_DEST (x)) == SUBREG\n+  if (REG_P (SET_DEST (x)) || GET_CODE (SET_DEST (x)) == SUBREG\n       || GET_CODE (SET_DEST (x)) == MEM)\n     invalidate (SET_DEST (x), VOIDmode);\n   else if (GET_CODE (SET_DEST (x)) == STRICT_LOW_PART\n@@ -7305,7 +7305,7 @@ count_reg_usage (rtx x, int *counts, int incr)\n \n     case SET:\n       /* Unless we are setting a REG, count everything in SET_DEST.  */\n-      if (GET_CODE (SET_DEST (x)) != REG)\n+      if (!REG_P (SET_DEST (x)))\n \tcount_reg_usage (SET_DEST (x), counts, incr);\n       count_reg_usage (SET_SRC (x), counts, incr);\n       return;\n@@ -7395,7 +7395,7 @@ set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n \t       || !reg_referenced_p (cc0_rtx, PATTERN (tem))))\n     return false;\n #endif\n-  else if (GET_CODE (SET_DEST (set)) != REG\n+  else if (!REG_P (SET_DEST (set))\n \t   || REGNO (SET_DEST (set)) < FIRST_PSEUDO_REGISTER\n \t   || counts[REGNO (SET_DEST (set))] != 0\n \t   || side_effects_p (SET_SRC (set))\n@@ -7587,7 +7587,7 @@ cse_change_cc_mode (rtx *loc, void *data)\n   rtx newreg = (rtx) data;\n \n   if (*loc\n-      && GET_CODE (*loc) == REG\n+      && REG_P (*loc)\n       && REGNO (*loc) == REGNO (newreg)\n       && GET_MODE (*loc) != GET_MODE (newreg))\n     {\n@@ -7683,7 +7683,7 @@ cse_cc_succs (basic_block bb, rtx cc_reg, rtx cc_src, bool can_change_mode)\n \t  /* Check whether INSN sets CC_REG to CC_SRC.  */\n \t  set = single_set (insn);\n \t  if (set\n-\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REG_P (SET_DEST (set))\n \t      && REGNO (SET_DEST (set)) == REGNO (cc_reg))\n \t    {\n \t      bool found;\n@@ -7873,7 +7873,7 @@ cse_condition_code_reg (void)\n \t    continue;\n \t  set = single_set (insn);\n \t  if (set\n-\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REG_P (SET_DEST (set))\n \t      && REGNO (SET_DEST (set)) == REGNO (cc_reg))\n \t    {\n \t      cc_src_insn = insn;"}, {"sha": "ef50cce870b2673180e3d7c1d198e8cf37d82339", "filename": "gcc/cselib.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -382,7 +382,7 @@ remove_useless_values (void)\n enum machine_mode\n cselib_reg_set_mode (rtx x)\n {\n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     return GET_MODE (x);\n \n   if (REG_VALUES (REGNO (x)) == NULL\n@@ -402,15 +402,15 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n   const char *fmt;\n   int i;\n \n-  if (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n+  if (REG_P (x) || MEM_P (x))\n     {\n       cselib_val *e = cselib_lookup (x, GET_MODE (x), 0);\n \n       if (e)\n \tx = e->u.val_rtx;\n     }\n \n-  if (GET_CODE (y) == REG || GET_CODE (y) == MEM)\n+  if (REG_P (y) || MEM_P (y))\n     {\n       cselib_val *e = cselib_lookup (y, GET_MODE (y), 0);\n \n@@ -434,7 +434,7 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n \t  rtx t = l->loc;\n \n \t  /* Avoid infinite recursion.  */\n-\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n+\t  if (REG_P (t) || GET_CODE (t) == MEM)\n \t    continue;\n \t  else if (rtx_equal_for_cselib_p (t, y))\n \t    return 1;\n@@ -452,7 +452,7 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n \t{\n \t  rtx t = l->loc;\n \n-\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n+\t  if (REG_P (t) || GET_CODE (t) == MEM)\n \t    continue;\n \t  else if (rtx_equal_for_cselib_p (x, t))\n \t    return 1;\n@@ -884,7 +884,7 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n   if (GET_CODE (x) == VALUE)\n     return CSELIB_VAL_PTR (x);\n \n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       struct elt_list *l;\n       unsigned int i = REGNO (x);\n@@ -1030,7 +1030,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t    {\n \t      rtx x = (*p)->loc;\n \n-\t      if (GET_CODE (x) == REG && REGNO (x) == i)\n+\t      if (REG_P (x) && REGNO (x) == i)\n \t\t{\n \t\t  unchain_one_elt_loc_list (p);\n \t\t  break;\n@@ -1146,7 +1146,7 @@ cselib_invalidate_rtx (rtx dest, rtx ignore ATTRIBUTE_UNUSED,\n \t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG)\n     dest = XEXP (dest, 0);\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     cselib_invalidate_regno (REGNO (dest), GET_MODE (dest));\n   else if (GET_CODE (dest) == MEM)\n     cselib_invalidate_mem (dest);\n@@ -1166,7 +1166,7 @@ cselib_invalidate_rtx (rtx dest, rtx ignore ATTRIBUTE_UNUSED,\n static void\n cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n {\n-  int dreg = GET_CODE (dest) == REG ? (int) REGNO (dest) : -1;\n+  int dreg = REG_P (dest) ? (int) REGNO (dest) : -1;\n \n   if (src_elt == 0 || side_effects_p (dest))\n     return;\n@@ -1274,7 +1274,7 @@ cselib_record_sets (rtx insn)\n \tsets[i].dest = dest = XEXP (dest, 0);\n \n       /* We don't know how to record anything but REG or MEM.  */\n-      if (GET_CODE (dest) == REG\n+      if (REG_P (dest)\n \t  || (GET_CODE (dest) == MEM && cselib_record_memory))\n         {\n \t  rtx src = sets[i].src;\n@@ -1303,7 +1303,7 @@ cselib_record_sets (rtx insn)\n       for (i = 0; i < n_sets; i++)\n \t{\n \t  rtx dest = sets[i].dest;\n-\t  if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n+\t  if (REG_P (dest) || GET_CODE (dest) == MEM)\n \t    {\n \t      int j;\n \t      for (j = i + 1; j < n_sets; j++)\n@@ -1320,7 +1320,7 @@ cselib_record_sets (rtx insn)\n   for (i = 0; i < n_sets; i++)\n     {\n       rtx dest = sets[i].dest;\n-      if (GET_CODE (dest) == REG\n+      if (REG_P (dest)\n \t  || (GET_CODE (dest) == MEM && cselib_record_memory))\n \tcselib_record_set (dest, sets[i].src_elt, sets[i].dest_addr_elt);\n     }"}, {"sha": "80dad25d0af06e2a0b4f47097740299167c9fd8a", "filename": "gcc/dbxout.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -2446,14 +2446,14 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n \n       while (GET_CODE (value) == SUBREG)\n \tvalue = SUBREG_REG (value);\n-      if (GET_CODE (value) == REG)\n+      if (REG_P (value))\n \t{\n \t  if (REGNO (value) >= FIRST_PSEUDO_REGISTER)\n \t    return 0;\n \t}\n       home = alter_subreg (&home);\n     }\n-  if (GET_CODE (home) == REG)\n+  if (REG_P (home))\n     {\n       regno = REGNO (home);\n       if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -2548,7 +2548,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n     }\n   else if (GET_CODE (home) == MEM\n \t   && (GET_CODE (XEXP (home, 0)) == MEM\n-\t       || (GET_CODE (XEXP (home, 0)) == REG\n+\t       || (REG_P (XEXP (home, 0))\n \t\t   && REGNO (XEXP (home, 0)) != HARD_FRAME_POINTER_REGNUM\n \t\t   && REGNO (XEXP (home, 0)) != STACK_POINTER_REGNUM\n #if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n@@ -2562,7 +2562,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n        so all we can do is output the variable as a pointer.\n        If it's not a parameter, ignore it.  */\n     {\n-      if (GET_CODE (XEXP (home, 0)) == REG)\n+      if (REG_P (XEXP (home, 0)))\n \t{\n \t  letter = 'r';\n \t  current_sym_code = N_RSYM;\n@@ -2587,7 +2587,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n       TREE_TYPE (type) = TREE_TYPE (decl);\n     }\n   else if (GET_CODE (home) == MEM\n-\t   && GET_CODE (XEXP (home, 0)) == REG)\n+\t   && REG_P (XEXP (home, 0)))\n     {\n       current_sym_code = N_LSYM;\n       current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));\n@@ -2842,7 +2842,7 @@ dbxout_parms (tree parms)\n \t    current_sym_value = DEBUGGER_ARG_OFFSET (current_sym_value, addr);\n \t    dbxout_finish_symbol (parms);\n \t  }\n-\telse if (GET_CODE (DECL_RTL (parms)) == REG)\n+\telse if (REG_P (DECL_RTL (parms)))\n \t  {\n \t    rtx best_rtl;\n \t    char regparm_letter;\n@@ -2893,7 +2893,7 @@ dbxout_parms (tree parms)\n \t    dbxout_finish_symbol (parms);\n \t  }\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n-\t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG\n+\t\t && REG_P (XEXP (DECL_RTL (parms), 0))\n \t\t && REGNO (XEXP (DECL_RTL (parms), 0)) != HARD_FRAME_POINTER_REGNUM\n \t\t && REGNO (XEXP (DECL_RTL (parms), 0)) != STACK_POINTER_REGNUM\n #if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n@@ -2956,7 +2956,7 @@ dbxout_parms (tree parms)\n \t    const char *const decl_name = (DECL_NAME (parms)\n \t\t\t\t     ? IDENTIFIER_POINTER (DECL_NAME (parms))\n \t\t\t\t     : \"(anon)\");\n-\t    if (GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 0)) == REG)\n+\t    if (REG_P (XEXP (XEXP (DECL_RTL (parms), 0), 0)))\n \t      current_sym_value = 0;\n \t    else\n \t      current_sym_value\n@@ -2987,7 +2987,7 @@ dbxout_parms (tree parms)\n \t       in which case we want the value of that CONST_INT,\n \t       or (MEM (REG ...)),\n \t       in which case we use a value of zero.  */\n-\t    if (GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG)\n+\t    if (REG_P (XEXP (DECL_RTL (parms), 0)))\n \t      current_sym_value = 0;\n \t    else\n \t\tcurrent_sym_value\n@@ -3056,7 +3056,7 @@ dbxout_reg_parms (tree parms)\n \n \t/* Report parms that live in registers during the function\n \t   but were passed in memory.  */\n-\tif (GET_CODE (DECL_RTL (parms)) == REG\n+\tif (REG_P (DECL_RTL (parms))\n \t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n \t  dbxout_symbol_location (parms, TREE_TYPE (parms),\n \t\t\t\t  0, DECL_RTL (parms));"}, {"sha": "cd66fe3ba506eb851a385e4764578cea96edbe47", "filename": "gcc/df.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -821,7 +821,7 @@ df_ref_record (struct df *df, rtx reg, rtx *loc, rtx insn,\n {\n   unsigned int regno;\n \n-  if (GET_CODE (reg) != REG && GET_CODE (reg) != SUBREG)\n+  if (!REG_P (reg) && GET_CODE (reg) != SUBREG)\n     abort ();\n \n   /* For the reg allocator we are interested in some SUBREG rtx's, but not\n@@ -937,8 +937,8 @@ df_def_record_1 (struct df *df, rtx x, basic_block bb, rtx insn)\n       flags |= DF_REF_READ_WRITE;\n     }\n \n-  if (GET_CODE (dst) == REG\n-      || (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n+  if (REG_P (dst)\n+      || (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst))))\n     df_ref_record (df, dst, loc, insn, DF_REF_REG_DEF, flags);\n }\n \n@@ -1013,7 +1013,7 @@ df_uses_record (struct df *df, rtx *loc, enum df_ref_type ref_type,\n       /* While we're here, optimize this case.  */\n \n       /* In case the SUBREG is not of a REG, do not optimize.  */\n-      if (GET_CODE (SUBREG_REG (x)) != REG)\n+      if (!REG_P (SUBREG_REG (x)))\n \t{\n \t  loc = &SUBREG_REG (x);\n \t  df_uses_record (df, loc, ref_type, bb, insn, flags);"}, {"sha": "e4bb6ddaf53ce5d7986f135a1c2ce704d8aa16af", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -648,7 +648,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t    {\n \t      /* Compare promoted variables in their promoted mode.  */\n \t      if (SUBREG_PROMOTED_VAR_P (temp)\n-\t\t  && GET_CODE (XEXP (temp, 0)) == REG)\n+\t\t  && REG_P (XEXP (temp, 0)))\n \t\ttemp = XEXP (temp, 0);\n \t      else\n \t\ttemp = copy_to_reg (temp);"}, {"sha": "93afca759ede5406d09108b57ef5de6febb5eedf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1454,7 +1454,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      if (! frame_pointer_needed)\n \t\tabort ();\n \n-\t      if (GET_CODE (XEXP (src, 0)) == REG\n+\t      if (REG_P (XEXP (src, 0))\n \t\t  && (unsigned) REGNO (XEXP (src, 0)) == cfa.reg\n \t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t{\n@@ -1473,7 +1473,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\tabort ();\n \n \t      /* Rule 4 */\n-\t      if (GET_CODE (XEXP (src, 0)) == REG\n+\t      if (REG_P (XEXP (src, 0))\n \t\t  && REGNO (XEXP (src, 0)) == cfa.reg\n \t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t{\n@@ -1488,7 +1488,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t}\n \n \t      /* Rule 5 */\n-\t      else if (GET_CODE (XEXP (src, 0)) == REG\n+\t      else if (REG_P (XEXP (src, 0))\n \t\t       && REGNO (XEXP (src, 0)) == cfa_temp.reg\n \t\t       && XEXP (src, 1) == stack_pointer_rtx)\n \t\t{\n@@ -1520,7 +1520,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t  /* Rule 7 */\n \tcase IOR:\n-\t  if (GET_CODE (XEXP (src, 0)) != REG\n+\t  if (!REG_P (XEXP (src, 0))\n \t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp.reg\n \t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n \t    abort ();\n@@ -1544,7 +1544,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n       break;\n \n     case MEM:\n-      if (GET_CODE (src) != REG)\n+      if (!REG_P (src))\n \tabort ();\n \n       /* Saving a register to the stack.  Make sure dest is relative to the\n@@ -1651,9 +1651,9 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t calculate the CFA.  */\n \t      rtx x = XEXP (dest, 0);\n \n-\t      if (GET_CODE (x) != REG)\n+\t      if (!REG_P (x))\n \t\tx = XEXP (x, 0);\n-\t      if (GET_CODE (x) != REG)\n+\t      if (!REG_P (x))\n \t\tabort ();\n \n \t      cfa.reg = REGNO (x);\n@@ -4012,7 +4012,7 @@ dwarf2out_set_demangle_name_func (const char *(*func) (const char *))\n static inline int\n is_pseudo_reg (rtx rtl)\n {\n-  return ((GET_CODE (rtl) == REG && REGNO (rtl) >= FIRST_PSEUDO_REGISTER)\n+  return ((REG_P (rtl) && REGNO (rtl) >= FIRST_PSEUDO_REGISTER)\n \t  || (GET_CODE (rtl) == SUBREG\n \t      && REGNO (SUBREG_REG (rtl)) >= FIRST_PSEUDO_REGISTER));\n }\n@@ -8413,7 +8413,7 @@ static inline int\n is_based_loc (rtx rtl)\n {\n   return (GET_CODE (rtl) == PLUS\n-\t  && ((GET_CODE (XEXP (rtl, 0)) == REG\n+\t  && ((REG_P (XEXP (rtl, 0))\n \t       && REGNO (XEXP (rtl, 0)) < FIRST_PSEUDO_REGISTER\n \t       && GET_CODE (XEXP (rtl, 1)) == CONST_INT)));\n }\n@@ -9715,7 +9715,7 @@ rtl_for_decl_location (tree decl)\n \t  && (CONSTANT_P (rtl)\n \t      || (GET_CODE (rtl) == MEM\n \t          && CONSTANT_P (XEXP (rtl, 0)))\n-\t      || (GET_CODE (rtl) == REG\n+\t      || (REG_P (rtl)\n \t          && TREE_CODE (decl) == VAR_DECL\n \t\t  && TREE_STATIC (decl))))\n \t{\n@@ -9756,7 +9756,7 @@ rtl_for_decl_location (tree decl)\n \t       /* Not passed in memory.  */\n \t       && GET_CODE (DECL_INCOMING_RTL (decl)) != MEM\n \t       /* Not passed by invisible reference.  */\n-\t       && (GET_CODE (XEXP (rtl, 0)) != REG\n+\t       && (!REG_P (XEXP (rtl, 0))\n \t\t   || REGNO (XEXP (rtl, 0)) == HARD_FRAME_POINTER_REGNUM\n \t\t   || REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM\n #if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM"}, {"sha": "1a6667a66567698aa4facc0800decee9a42c87e2", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -857,7 +857,7 @@ set_reg_attrs_from_mem (rtx reg, rtx mem)\n void\n set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n {\n-  if (GET_CODE (parm_rtx) == REG)\n+  if (REG_P (parm_rtx))\n     set_reg_attrs_from_mem (parm_rtx, mem);\n   else if (GET_CODE (parm_rtx) == PARALLEL)\n     {\n@@ -867,7 +867,7 @@ set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n       for (; i < XVECLEN (parm_rtx, 0); i++)\n \t{\n \t  rtx x = XVECEXP (parm_rtx, 0, i);\n-\t  if (GET_CODE (XEXP (x, 0)) == REG)\n+\t  if (REG_P (XEXP (x, 0)))\n \t    REG_ATTRS (XEXP (x, 0))\n \t      = get_reg_attrs (MEM_EXPR (mem),\n \t\t\t       INTVAL (XEXP (x, 1)));\n@@ -884,7 +884,7 @@ set_decl_rtl (tree t, rtx x)\n   if (!x)\n     return;\n   /* For register, we maintain the reverse information too.  */\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     REG_ATTRS (x) = get_reg_attrs (t, 0);\n   else if (GET_CODE (x) == SUBREG)\n     REG_ATTRS (SUBREG_REG (x))\n@@ -918,7 +918,7 @@ set_decl_incoming_rtl (tree t, rtx x)\n   if (!x)\n     return;\n   /* For register, we maintain the reverse information too.  */\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     REG_ATTRS (x) = get_reg_attrs (t, 0);\n   else if (GET_CODE (x) == SUBREG)\n     REG_ATTRS (SUBREG_REG (x))\n@@ -961,7 +961,7 @@ mark_user_reg (rtx reg)\n       REG_USERVAR_P (XEXP (reg, 0)) = 1;\n       REG_USERVAR_P (XEXP (reg, 1)) = 1;\n     }\n-  else if (GET_CODE (reg) == REG)\n+  else if (REG_P (reg))\n     REG_USERVAR_P (reg) = 1;\n   else\n     abort ();\n@@ -1034,7 +1034,7 @@ subreg_hard_regno (rtx x, int check_mode)\n   /* This is where we attempt to catch illegal subregs\n      created by the compiler.  */\n   if (GET_CODE (x) != SUBREG\n-      || GET_CODE (reg) != REG)\n+      || !REG_P (reg))\n     abort ();\n   base_regno = REGNO (reg);\n   if (base_regno >= FIRST_PSEUDO_REGISTER)\n@@ -1121,7 +1121,7 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n       else if (msize < xsize)\n \treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n     }\n-  else if (GET_CODE (x) == SUBREG || GET_CODE (x) == REG\n+  else if (GET_CODE (x) == SUBREG || REG_P (x)\n \t   || GET_CODE (x) == CONCAT || GET_CODE (x) == CONST_VECTOR\n \t   || GET_CODE (x) == CONST_DOUBLE || GET_CODE (x) == CONST_INT)\n     return simplify_gen_subreg (mode, x, innermode, offset);\n@@ -1387,7 +1387,7 @@ operand_subword_force (rtx op, unsigned int offset, enum machine_mode mode)\n     {\n       /* If this is a register which can not be accessed by words, copy it\n \t to a pseudo register.  */\n-      if (GET_CODE (op) == REG)\n+      if (REG_P (op))\n \top = copy_to_reg (op);\n       else\n \top = force_reg (mode, op);\n@@ -2784,9 +2784,9 @@ make_safe_from (rtx x, rtx other)\n  done:\n   if ((GET_CODE (other) == MEM\n        && ! CONSTANT_P (x)\n-       && GET_CODE (x) != REG\n+       && !REG_P (x)\n        && GET_CODE (x) != SUBREG)\n-      || (GET_CODE (other) == REG\n+      || (REG_P (other)\n \t  && (REGNO (other) < FIRST_PSEUDO_REGISTER\n \t      || reg_mentioned_p (other, x))))\n     {"}, {"sha": "af67003eacfb0b3d2cd64ae868116d4e56294d24", "filename": "gcc/explow.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -405,7 +405,7 @@ convert_memory_address (enum machine_mode to_mode ATTRIBUTE_UNUSED,\n rtx\n copy_all_regs (rtx x)\n {\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       if (REGNO (x) != FRAME_POINTER_REGNUM\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n@@ -451,7 +451,7 @@ memory_address (enum machine_mode mode, rtx x)\n      On attempting to put this in an insn we will call protect_from_queue\n      which will turn it into a REG, which is valid.  */\n   else if (GET_CODE (x) == QUEUED\n-      && GET_CODE (QUEUED_VAR (x)) == REG)\n+      && REG_P (QUEUED_VAR (x)))\n     ;\n \n   /* We get better cse by rejecting indirect addressing at this stage.\n@@ -460,7 +460,7 @@ memory_address (enum machine_mode mode, rtx x)\n      are visible.  But not if cse won't be done!  */\n   else\n     {\n-      if (! cse_not_expected && GET_CODE (x) != REG)\n+      if (! cse_not_expected && !REG_P (x))\n \tx = break_out_memory_refs (x);\n \n       /* At this point, any valid address is accepted.  */\n@@ -508,7 +508,7 @@ memory_address (enum machine_mode mode, rtx x)\n \n       /* If we have a register that's an invalid address,\n \t it must be a hard reg of the wrong class.  Copy it to a pseudo.  */\n-      else if (GET_CODE (x) == REG)\n+      else if (REG_P (x))\n \tx = copy_to_reg (x);\n \n       /* Last resort: copy the value to a register, since\n@@ -521,7 +521,7 @@ memory_address (enum machine_mode mode, rtx x)\n     win2:\n       x = oldx;\n     win:\n-      if (flag_force_addr && ! cse_not_expected && GET_CODE (x) != REG\n+      if (flag_force_addr && ! cse_not_expected && !REG_P (x)\n \t  /* Don't copy an addr via a reg if it is one of our stack slots.  */\n \t  && ! (GET_CODE (x) == PLUS\n \t\t&& (XEXP (x, 0) == virtual_stack_vars_rtx\n@@ -540,10 +540,10 @@ memory_address (enum machine_mode mode, rtx x)\n      a reg as a pointer if we have REG or REG + CONST_INT.  */\n   if (oldx == x)\n     return x;\n-  else if (GET_CODE (x) == REG)\n+  else if (REG_P (x))\n     mark_reg_pointer (x, BITS_PER_UNIT);\n   else if (GET_CODE (x) == PLUS\n-\t   && GET_CODE (XEXP (x, 0)) == REG\n+\t   && REG_P (XEXP (x, 0))\n \t   && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     mark_reg_pointer (XEXP (x, 0), BITS_PER_UNIT);\n \n@@ -688,7 +688,7 @@ force_reg (enum machine_mode mode, rtx x)\n {\n   rtx temp, insn, set;\n \n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     return x;\n \n   if (general_operand (x, mode))\n@@ -699,7 +699,7 @@ force_reg (enum machine_mode mode, rtx x)\n   else\n     {\n       temp = force_operand (x, NULL_RTX);\n-      if (GET_CODE (temp) == REG)\n+      if (REG_P (temp))\n \tinsn = get_last_insn ();\n       else\n \t{\n@@ -784,7 +784,7 @@ copy_to_suggested_reg (rtx x, rtx target, enum machine_mode mode)\n {\n   rtx temp;\n \n-  if (target && GET_CODE (target) == REG)\n+  if (target && REG_P (target))\n     temp = target;\n   else\n     temp = gen_reg_rtx (mode);\n@@ -1333,7 +1333,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n     probe_stack_range (STACK_CHECK_MAX_FRAME_SIZE + STACK_CHECK_PROTECT, size);\n \n   /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */\n-  if (target == 0 || GET_CODE (target) != REG\n+  if (target == 0 || !REG_P (target)\n       || REGNO (target) < FIRST_PSEUDO_REGISTER\n       || GET_MODE (target) != Pmode)\n     target = gen_reg_rtx (Pmode);\n@@ -1557,7 +1557,7 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n       rtx end_lab = gen_label_rtx ();\n       rtx temp;\n \n-      if (GET_CODE (test_addr) != REG\n+      if (!REG_P (test_addr)\n \t  || REGNO (test_addr) < FIRST_PSEUDO_REGISTER)\n \ttest_addr = force_reg (Pmode, test_addr);\n \n@@ -1611,7 +1611,7 @@ hard_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n #endif\n     val = FUNCTION_VALUE (valtype, func);\n \n-  if (GET_CODE (val) == REG\n+  if (REG_P (val)\n       && GET_MODE (val) == BLKmode)\n     {\n       unsigned HOST_WIDE_INT bytes = int_size_in_bytes (valtype);"}, {"sha": "fb590cdf6730a4df3787a84eedb867e74aaecfa6", "filename": "gcc/expmed.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -417,7 +417,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   subregs results in Severe Tire Damage.  */\n \t\tabort ();\n \t    }\n-\t  if (GET_CODE (op0) == REG)\n+\t  if (REG_P (op0))\n \t    op0 = gen_rtx_SUBREG (fieldmode, op0, byte_offset);\n \t  else\n \t    op0 = adjust_address (op0, fieldmode, offset);\n@@ -472,7 +472,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       int icode = movstrict_optab->handlers[fieldmode].insn_code;\n \n       /* Get appropriate low part of the value being stored.  */\n-      if (GET_CODE (value) == CONST_INT || GET_CODE (value) == REG)\n+      if (GET_CODE (value) == CONST_INT || REG_P (value))\n \tvalue = gen_lowpart (fieldmode, value);\n       else if (!(GET_CODE (value) == SYMBOL_REF\n \t\t || GET_CODE (value) == LABEL_REF\n@@ -558,7 +558,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       if (offset != 0\n \t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n \t{\n-\t  if (GET_CODE (op0) != REG)\n+\t  if (!REG_P (op0))\n \t    {\n \t      /* Since this is a destination (lvalue), we can't copy it to a\n \t\t pseudo.  We can trivially remove a SUBREG that does not\n@@ -597,7 +597,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && !(bitsize == 1 && GET_CODE (value) == CONST_INT)\n       /* Ensure insv's size is wide enough for this field.  */\n       && (GET_MODE_BITSIZE (op_mode) >= bitsize)\n-      && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+      && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n \t    && (bitsize + bitpos > GET_MODE_BITSIZE (op_mode))))\n     {\n       int xbitpos = bitpos;\n@@ -666,7 +666,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t/* We can't just change the mode, because this might clobber op0,\n \t   and we will need the original value of op0 if insv fails.  */\n \txop0 = gen_rtx_SUBREG (maxmode, SUBREG_REG (xop0), SUBREG_BYTE (xop0));\n-      if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n+      if (REG_P (xop0) && GET_MODE (xop0) != maxmode)\n \txop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n       /* On big-endian machines, we count bits from the most significant.\n@@ -768,7 +768,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n      and a field split across two bytes.\n      Such cases are not supposed to be able to occur.  */\n \n-  if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+  if (REG_P (op0) || GET_CODE (op0) == SUBREG)\n     {\n       if (offset != 0)\n \tabort ();\n@@ -866,7 +866,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \n       if (GET_MODE (value) != mode)\n \t{\n-\t  if ((GET_CODE (value) == REG || GET_CODE (value) == SUBREG)\n+\t  if ((REG_P (value) || GET_CODE (value) == SUBREG)\n \t      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (value)))\n \t    value = gen_lowpart (mode, value);\n \t  else\n@@ -885,7 +885,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n   /* Now clear the chosen bits in OP0,\n      except that if VALUE is -1 we need not bother.  */\n \n-  subtarget = (GET_CODE (op0) == REG || ! flag_force_mem) ? op0 : 0;\n+  subtarget = (REG_P (op0) || ! flag_force_mem) ? op0 : 0;\n \n   if (! all_one)\n     {\n@@ -924,7 +924,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \n   /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n      much at a time.  */\n-  if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+  if (REG_P (op0) || GET_CODE (op0) == SUBREG)\n     unit = BITS_PER_WORD;\n   else\n     unit = MIN (MEM_ALIGN (op0), BITS_PER_WORD);\n@@ -1013,7 +1013,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t\tGET_MODE (SUBREG_REG (op0)));\n \t  offset = 0;\n \t}\n-      else if (GET_CODE (op0) == REG)\n+      else if (REG_P (op0))\n \t{\n \t  word = operand_subword_force (op0, offset, GET_MODE (op0));\n \t  offset = 0;\n@@ -1088,7 +1088,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       op0 = SUBREG_REG (op0);\n     }\n \n-  if (GET_CODE (op0) == REG\n+  if (REG_P (op0)\n       && mode == GET_MODE (op0)\n       && bitnum == 0\n       && bitsize == GET_MODE_BITSIZE (GET_MODE (op0)))\n@@ -1239,7 +1239,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   subregs results in Severe Tire Damage.  */\n \t\tgoto no_subreg_mode_swap;\n \t    }\n-\t  if (GET_CODE (op0) == REG)\n+\t  if (REG_P (op0))\n \t    op0 = gen_rtx_SUBREG (mode1, op0, byte_offset);\n \t  else\n \t    op0 = adjust_address (op0, mode1, offset);\n@@ -1262,7 +1262,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n \n-      if (target == 0 || GET_CODE (target) != REG)\n+      if (target == 0 || !REG_P (target))\n \ttarget = gen_reg_rtx (mode);\n \n       /* Indicate for flow that the entire target reg is being set.  */\n@@ -1346,7 +1346,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       if (offset != 0\n \t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n \t{\n-\t  if (GET_CODE (op0) != REG)\n+\t  if (!REG_P (op0))\n \t    op0 = copy_to_reg (op0);\n \t  op0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n \t\t                op0, (offset * UNITS_PER_WORD));\n@@ -1362,7 +1362,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     {\n       if (HAVE_extzv\n \t  && (GET_MODE_BITSIZE (extzv_mode) >= bitsize)\n-\t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+\t  && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n \t\t&& (bitsize + bitpos > GET_MODE_BITSIZE (extzv_mode))))\n \t{\n \t  unsigned HOST_WIDE_INT xbitpos = bitpos, xoffset = offset;\n@@ -1430,7 +1430,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t     SImode). to make it acceptable to the format of extzv.  */\n \t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n \t    goto extzv_loses;\n-\t  if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n+\t  if (REG_P (xop0) && GET_MODE (xop0) != maxmode)\n \t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n \t  /* On big-endian machines, we count bits from the most significant.\n@@ -1450,7 +1450,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n \t  if (GET_MODE (xtarget) != maxmode)\n \t    {\n-\t      if (GET_CODE (xtarget) == REG)\n+\t      if (REG_P (xtarget))\n \t\t{\n \t\t  int wider = (GET_MODE_SIZE (maxmode)\n \t\t\t       > GET_MODE_SIZE (GET_MODE (xtarget)));\n@@ -1496,7 +1496,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     {\n       if (HAVE_extv\n \t  && (GET_MODE_BITSIZE (extv_mode) >= bitsize)\n-\t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+\t  && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n \t\t&& (bitsize + bitpos > GET_MODE_BITSIZE (extv_mode))))\n \t{\n \t  int xbitpos = bitpos, xoffset = offset;\n@@ -1558,7 +1558,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t     SImode) to make it acceptable to the format of extv.  */\n \t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n \t    goto extv_loses;\n-\t  if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n+\t  if (REG_P (xop0) && GET_MODE (xop0) != maxmode)\n \t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n \t  /* On big-endian machines, we count bits from the most significant.\n@@ -1579,7 +1579,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n \t  if (GET_MODE (xtarget) != maxmode)\n \t    {\n-\t      if (GET_CODE (xtarget) == REG)\n+\t      if (REG_P (xtarget))\n \t\t{\n \t\t  int wider = (GET_MODE_SIZE (maxmode)\n \t\t\t       > GET_MODE_SIZE (GET_MODE (xtarget)));\n@@ -1670,7 +1670,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n   unsigned int total_bits = BITS_PER_WORD;\n   enum machine_mode mode;\n \n-  if (GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n+  if (GET_CODE (op0) == SUBREG || REG_P (op0))\n     {\n       /* Special treatment for a bit field split across two registers.  */\n       if (bitsize + bitpos > BITS_PER_WORD)\n@@ -1732,7 +1732,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t  tree amount = build_int_2 (bitpos, 0);\n \t  /* Maybe propagate the target for the shift.  */\n \t  /* But not if we will return it--could confuse integrate.c.  */\n-\t  rtx subtarget = (target != 0 && GET_CODE (target) == REG ? target : 0);\n+\t  rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n \t  if (tmode != mode) subtarget = 0;\n \t  op0 = expand_shift (RSHIFT_EXPR, mode, op0, amount, subtarget, 1);\n \t}\n@@ -1771,7 +1771,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n       tree amount\n \t= build_int_2 (GET_MODE_BITSIZE (mode) - (bitsize + bitpos), 0);\n       /* Maybe propagate the target for the shift.  */\n-      rtx subtarget = (target != 0 && GET_CODE (target) == REG ? target : 0);\n+      rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n       op0 = expand_shift (LSHIFT_EXPR, mode, op0, amount, subtarget, 1);\n     }\n \n@@ -1868,7 +1868,7 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \n   /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n      much at a time.  */\n-  if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+  if (REG_P (op0) || GET_CODE (op0) == SUBREG)\n     unit = BITS_PER_WORD;\n   else\n     unit = MIN (MEM_ALIGN (op0), BITS_PER_WORD);\n@@ -1902,7 +1902,7 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t\tGET_MODE (SUBREG_REG (op0)));\n \t  offset = 0;\n \t}\n-      else if (GET_CODE (op0) == REG)\n+      else if (REG_P (op0))\n \t{\n \t  word = operand_subword_force (op0, offset, GET_MODE (op0));\n \t  offset = 0;\n@@ -3709,13 +3709,13 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \tif (rem_flag)\n \t  {\n \t    remainder\n-\t      = GET_CODE (target) == REG ? target : gen_reg_rtx (compute_mode);\n+\t      = REG_P (target) ? target : gen_reg_rtx (compute_mode);\n \t    quotient = gen_reg_rtx (compute_mode);\n \t  }\n \telse\n \t  {\n \t    quotient\n-\t      = GET_CODE (target) == REG ? target : gen_reg_rtx (compute_mode);\n+\t      = REG_P (target) ? target : gen_reg_rtx (compute_mode);\n \t    remainder = gen_reg_rtx (compute_mode);\n \t  }\n \n@@ -3825,13 +3825,13 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n \t    if (rem_flag)\n \t      {\n-\t\tremainder = (GET_CODE (target) == REG\n+\t\tremainder = (REG_P (target)\n \t\t\t     ? target : gen_reg_rtx (compute_mode));\n \t\tquotient = gen_reg_rtx (compute_mode);\n \t      }\n \t    else\n \t      {\n-\t\tquotient = (GET_CODE (target) == REG\n+\t\tquotient = (REG_P (target)\n \t\t\t    ? target : gen_reg_rtx (compute_mode));\n \t\tremainder = gen_reg_rtx (compute_mode);\n \t      }\n@@ -3922,13 +3922,13 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t      target = gen_reg_rtx (compute_mode);\n \t    if (rem_flag)\n \t      {\n-\t\tremainder= (GET_CODE (target) == REG\n+\t\tremainder= (REG_P (target)\n \t\t\t    ? target : gen_reg_rtx (compute_mode));\n \t\tquotient = gen_reg_rtx (compute_mode);\n \t      }\n \t    else\n \t      {\n-\t\tquotient = (GET_CODE (target) == REG\n+\t\tquotient = (REG_P (target)\n \t\t\t    ? target : gen_reg_rtx (compute_mode));\n \t\tremainder = gen_reg_rtx (compute_mode);\n \t      }\n@@ -4884,7 +4884,7 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   /* If this failed, we have to do this with set/compare/jump/set code.  */\n \n-  if (GET_CODE (target) != REG\n+  if (!REG_P (target)\n       || reg_mentioned_p (target, op0) || reg_mentioned_p (target, op1))\n     target = gen_reg_rtx (GET_MODE (target));\n "}, {"sha": "bb64d469b1049b57d772dcb95a175e80f113c1ea", "filename": "gcc/expr.c", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -706,7 +706,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t       && ((code = can_extend_p (to_mode, word_mode, unsignedp))\n \t\t   != CODE_FOR_nothing))\n \t{\n-\t  if (GET_CODE (to) == REG)\n+\t  if (REG_P (to))\n \t    {\n \t      if (reg_overlap_mentioned_p (to, from))\n \t\tfrom = force_reg (from_mode, from);\n@@ -793,7 +793,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t     && ! MEM_VOLATILE_P (from)\n \t     && direct_load[(int) to_mode]\n \t     && ! mode_dependent_address_p (XEXP (from, 0)))\n-\t    || GET_CODE (from) == REG\n+\t    || REG_P (from)\n \t    || GET_CODE (from) == SUBREG))\n \tfrom = force_reg (from_mode, from);\n       convert_move (to, gen_lowpart (word_mode, from), 0);\n@@ -812,10 +812,10 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t     && ! MEM_VOLATILE_P (from)\n \t     && direct_load[(int) to_mode]\n \t     && ! mode_dependent_address_p (XEXP (from, 0)))\n-\t    || GET_CODE (from) == REG\n+\t    || REG_P (from)\n \t    || GET_CODE (from) == SUBREG))\n \tfrom = force_reg (from_mode, from);\n-      if (GET_CODE (from) == REG && REGNO (from) < FIRST_PSEUDO_REGISTER\n+      if (REG_P (from) && REGNO (from) < FIRST_PSEUDO_REGISTER\n \t  && ! HARD_REGNO_MODE_OK (REGNO (from), to_mode))\n \tfrom = copy_to_reg (from);\n       emit_move_insn (to, gen_lowpart (to_mode, from));\n@@ -983,7 +983,7 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n \t      || (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (oldmode)\n \t\t  && ((GET_CODE (x) == MEM && ! MEM_VOLATILE_P (x)\n \t\t       && direct_load[(int) mode])\n-\t\t      || (GET_CODE (x) == REG\n+\t\t      || (REG_P (x)\n \t\t\t  && (! HARD_REGISTER_P (x)\n \t\t\t      || HARD_REGNO_MODE_OK (REGNO (x), mode))\n \t\t\t  && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n@@ -1917,7 +1917,7 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t\t to be extracted.  */\n \t      tmps[i] = XEXP (src, bytepos / slen0);\n \t      if (! CONSTANT_P (tmps[i])\n-\t\t  && (GET_CODE (tmps[i]) != REG || GET_MODE (tmps[i]) != mode))\n+\t\t  && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n \t\t\t\t\t     (bytepos % slen0) * BITS_PER_UNIT,\n \t\t\t\t\t     1, NULL_RTX, mode, mode, ssize);\n@@ -1935,7 +1935,7 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t SIMD register, which is currently broken.  While we get GCC\n \t to emit proper RTL for these cases, let's dump to memory.  */\n       else if (VECTOR_MODE_P (GET_MODE (dst))\n-\t       && GET_CODE (src) == REG)\n+\t       && REG_P (src))\n \t{\n \t  int slen = GET_MODE_SIZE (GET_MODE (src));\n \t  rtx mem;\n@@ -1948,7 +1948,7 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n                && XVECLEN (dst, 0) > 1)\n         tmps[i] = simplify_gen_subreg (mode, src, GET_MODE(dst), bytepos);\n       else if (CONSTANT_P (src)\n-\t       || (GET_CODE (src) == REG && GET_MODE (src) == mode))\n+\t       || (REG_P (src) && GET_MODE (src) == mode))\n \ttmps[i] = src;\n       else\n \ttmps[i] = extract_bit_field (src, bytelen * BITS_PER_UNIT,\n@@ -2207,7 +2207,7 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n void\n use_reg (rtx *call_fusage, rtx reg)\n {\n-  if (GET_CODE (reg) != REG\n+  if (!REG_P (reg)\n       || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n     abort ();\n \n@@ -2247,7 +2247,7 @@ use_group_regs (rtx *call_fusage, rtx regs)\n       /* A NULL entry means the parameter goes both on the stack and in\n \t registers.  This can also be a MEM for targets that pass values\n \t partially on the stack and partially in registers.  */\n-      if (reg != 0 && GET_CODE (reg) == REG)\n+      if (reg != 0 && REG_P (reg))\n \tuse_reg (call_fusage, reg);\n     }\n }\n@@ -2839,7 +2839,7 @@ emit_move_insn (rtx x, rtx y)\n \n   last_insn = emit_move_insn_1 (x, y);\n \n-  if (y_cst && GET_CODE (x) == REG\n+  if (y_cst && REG_P (x)\n       && (set = single_set (last_insn)) != NULL_RTX\n       && SET_DEST (set) == x\n       && ! rtx_equal_p (y_cst, SET_SRC (set)))\n@@ -3245,7 +3245,7 @@ compress_float_constant (rtx x, rtx y)\n       emit_unop_insn (ic, x, trunc_y, UNKNOWN);\n       last_insn = get_last_insn ();\n \n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tset_unique_reg_note (last_insn, REG_EQUAL, y);\n \n       return last_insn;\n@@ -3273,7 +3273,7 @@ push_block (rtx size, int extra, int below)\n   size = convert_modes (Pmode, ptr_mode, size, 1);\n   if (CONSTANT_P (size))\n     anti_adjust_stack (plus_constant (size, extra));\n-  else if (GET_CODE (size) == REG && extra == 0)\n+  else if (REG_P (size) && extra == 0)\n     anti_adjust_stack (size);\n   else\n     {\n@@ -3634,7 +3634,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \n       /* If X is a hard register in a non-integer mode, copy it into a pseudo;\n \t SUBREGs of such registers are not allowed.  */\n-      if ((GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER\n+      if ((REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER\n \t   && GET_MODE_CLASS (GET_MODE (x)) != MODE_INT))\n \tx = copy_to_reg (x);\n \n@@ -3723,7 +3723,7 @@ get_subtarget (rtx x)\n {\n   return ((x == 0\n \t   /* Only registers can be subtargets.  */\n-\t   || GET_CODE (x) != REG\n+\t   || !REG_P (x)\n \t   /* If the register is readonly, it can't be set more than once.  */\n \t   || RTX_UNCHANGING_P (x)\n \t   /* Don't use hard regs to avoid extending their life.  */\n@@ -3889,7 +3889,7 @@ expand_assignment (tree to, tree from, int want_value)\n   if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from, from)\n       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) == INTEGER_CST\n       && ! ((TREE_CODE (to) == VAR_DECL || TREE_CODE (to) == PARM_DECL)\n-\t    && GET_CODE (DECL_RTL (to)) == REG))\n+\t    && REG_P (DECL_RTL (to))))\n     {\n       rtx value;\n \n@@ -3925,7 +3925,7 @@ expand_assignment (tree to, tree from, int want_value)\n \n   /* Don't move directly into a return register.  */\n   if (TREE_CODE (to) == RESULT_DECL\n-      && (GET_CODE (to_rtx) == REG || GET_CODE (to_rtx) == PARALLEL))\n+      && (REG_P (to_rtx) || GET_CODE (to_rtx) == PARALLEL))\n     {\n       rtx temp;\n \n@@ -4213,7 +4213,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t Otherwise, if TEMP is not TARGET, return TEMP\n \t if it is constant (for efficiency),\n \t or if we really want the correct value.  */\n-      if (!(target && GET_CODE (target) == REG\n+      if (!(target && REG_P (target)\n \t    && REGNO (target) < FIRST_PSEUDO_REGISTER)\n \t  && !(GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n \t  && ! rtx_equal_p (temp, target)\n@@ -4379,7 +4379,7 @@ store_expr (tree exp, rtx target, int want_value)\n   /* Return TARGET itself if it is a hard register.  */\n   else if ((want_value & 1) != 0\n \t   && GET_MODE (target) != BLKmode\n-\t   && ! (GET_CODE (target) == REG\n+\t   && ! (REG_P (target)\n \t\t && REGNO (target) < FIRST_PSEUDO_REGISTER))\n     return copy_to_reg (target);\n \n@@ -4661,7 +4661,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t set the initial value as zero so we can fold the value into\n \t a constant.  But if more than one register is involved,\n \t this probably loses.  */\n-      else if (GET_CODE (target) == REG && TREE_STATIC (exp)\n+      else if (REG_P (target) && TREE_STATIC (exp)\n \t       && GET_MODE_SIZE (GET_MODE (target)) <= UNITS_PER_WORD)\n \t{\n \t  emit_move_insn (target, CONST0_RTX (GET_MODE (target)));\n@@ -4676,7 +4676,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       else if (size > 0\n \t       && ((list_length (CONSTRUCTOR_ELTS (exp)) != fields_length (type))\n \t\t   || mostly_zeros_p (exp))\n-\t       && (GET_CODE (target) != REG\n+\t       && (!REG_P (target)\n \t\t   || ((HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (target))\n \t\t       == size)))\n \t{\n@@ -4774,7 +4774,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t     start of a word, try to widen it to a full word.\n \t     This special case allows us to output C++ member function\n \t     initializations in a form that the optimizers can understand.  */\n-\t  if (GET_CODE (target) == REG\n+\t  if (REG_P (target)\n \t      && bitsize < BITS_PER_WORD\n \t      && bitpos % BITS_PER_WORD == 0\n \t      && GET_MODE_CLASS (mode) == MODE_INT\n@@ -4871,7 +4871,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       /* If the constructor has fewer elements than the array,\n          clear the whole array first.  Similarly if this is\n          static constructor of a non-BLKmode object.  */\n-      if (cleared || (GET_CODE (target) == REG && TREE_STATIC (exp)))\n+      if (cleared || (REG_P (target) && TREE_STATIC (exp)))\n \tneed_to_clear = 1;\n       else\n \t{\n@@ -5357,7 +5357,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n      twice, once with emit_move_insn and once via store_field.  */\n \n   if (mode == BLKmode\n-      && (GET_CODE (target) == REG || GET_CODE (target) == SUBREG))\n+      && (REG_P (target) || GET_CODE (target) == SUBREG))\n     {\n       rtx object = assign_temp (type, 0, 1, 1);\n       rtx blk_object = adjust_address (object, BLKmode, 0);\n@@ -5391,7 +5391,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       || (mode != BLKmode && ! direct_store[(int) mode]\n \t  && GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n \t  && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n-      || GET_CODE (target) == REG\n+      || REG_P (target)\n       || GET_CODE (target) == SUBREG\n       /* If the field isn't aligned enough to store as an ordinary memref,\n \t store it as a bit field.  */\n@@ -5487,7 +5487,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       /* If a value is wanted, it must be the lhs;\n \t so make the address stable for multiple use.  */\n \n-      if (value_mode != VOIDmode && GET_CODE (addr) != REG\n+      if (value_mode != VOIDmode && !REG_P (addr)\n \t  && ! CONSTANT_ADDRESS_P (addr)\n \t  /* A frame-pointer reference is already stable.  */\n \t  && ! (GET_CODE (addr) == PLUS\n@@ -5718,7 +5718,7 @@ force_operand (rtx value, rtx target)\n \n   /* Check for subreg applied to an expression produced by loop optimizer.  */\n   if (code == SUBREG\n-      && GET_CODE (SUBREG_REG (value)) != REG\n+      && !REG_P (SUBREG_REG (value))\n       && GET_CODE (SUBREG_REG (value)) != MEM)\n     {\n       value = simplify_gen_subreg (GET_MODE (value),\n@@ -5755,7 +5755,7 @@ force_operand (rtx value, rtx target)\n   if (ARITHMETIC_P (value))\n     {\n       op2 = XEXP (value, 1);\n-      if (!CONSTANT_P (op2) && !(GET_CODE (op2) == REG && op2 != subtarget))\n+      if (!CONSTANT_P (op2) && !(REG_P (op2) && op2 != subtarget))\n \tsubtarget = 0;\n       if (code == MINUS && GET_CODE (op2) == CONST_INT)\n \t{\n@@ -5771,7 +5771,7 @@ force_operand (rtx value, rtx target)\n          creating another one around this addition.  */\n       if (code == PLUS && GET_CODE (op2) == CONST_INT\n \t  && GET_CODE (XEXP (value, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (value, 0), 0)) == REG\n+\t  && REG_P (XEXP (XEXP (value, 0), 0))\n \t  && REGNO (XEXP (XEXP (value, 0), 0)) >= FIRST_VIRTUAL_REGISTER\n \t  && REGNO (XEXP (XEXP (value, 0), 0)) <= LAST_VIRTUAL_REGISTER)\n \t{\n@@ -5886,7 +5886,7 @@ safe_from_p (rtx x, tree exp, int top_p)\n   if (GET_CODE (x) == SUBREG)\n     {\n       x = SUBREG_REG (x);\n-      if (GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+      if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n \treturn 0;\n     }\n \n@@ -5993,7 +5993,7 @@ safe_from_p (rtx x, tree exp, int top_p)\n \tcase CALL_EXPR:\n \t  /* Assume that the call will clobber all hard registers and\n \t     all of memory.  */\n-\t  if ((GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t  if ((REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t      || GET_CODE (x) == MEM)\n \t    return 0;\n \t  break;\n@@ -6070,7 +6070,7 @@ safe_from_p (rtx x, tree exp, int top_p)\n       if (GET_CODE (exp_rtl) == SUBREG)\n \t{\n \t  exp_rtl = SUBREG_REG (exp_rtl);\n-\t  if (GET_CODE (exp_rtl) == REG\n+\t  if (REG_P (exp_rtl)\n \t      && REGNO (exp_rtl) < FIRST_PSEUDO_REGISTER)\n \t    return 0;\n \t}\n@@ -6496,7 +6496,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n      Another is a CALL_EXPR which must return in memory.  */\n \n   if (! cse_not_expected && mode != BLKmode && target\n-      && (GET_CODE (target) != REG || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+      && (!REG_P (target) || REGNO (target) < FIRST_PSEUDO_REGISTER)\n       && ! (code == CONSTRUCTOR && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n       && ! (code == CALL_EXPR && aggregate_value_p (exp, exp)))\n     target = 0;\n@@ -6587,7 +6587,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t See expand_decl.  */\n \n       else if (GET_CODE (DECL_RTL (exp)) == MEM\n-\t       && GET_CODE (XEXP (DECL_RTL (exp), 0)) == REG)\n+\t       && REG_P (XEXP (DECL_RTL (exp), 0)))\n \ttemp = validize_mem (DECL_RTL (exp));\n \n       /* If DECL_RTL is memory, we are in the normal case and either\n@@ -6601,7 +6601,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t       && (! memory_address_p (DECL_MODE (exp),\n \t\t\t\t       XEXP (DECL_RTL (exp), 0))\n \t\t   || (flag_force_addr\n-\t\t       && GET_CODE (XEXP (DECL_RTL (exp), 0)) != REG)))\n+\t\t       && !REG_P (XEXP (DECL_RTL (exp), 0)))))\n \t{\n \t  if (alt_rtl)\n \t    *alt_rtl = DECL_RTL (exp);\n@@ -6613,7 +6613,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t if the address is a register.  */\n       if (temp != 0)\n \t{\n-\t  if (GET_CODE (temp) == MEM && GET_CODE (XEXP (temp, 0)) == REG)\n+\t  if (GET_CODE (temp) == MEM && REG_P (XEXP (temp, 0)))\n \t    mark_reg_pointer (XEXP (temp, 0), DECL_ALIGN (exp));\n \n \t  return temp;\n@@ -6623,7 +6623,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t must be a promoted value.  We return a SUBREG of the wanted mode,\n \t but mark it so that we know that it was already extended.  */\n \n-      if (GET_CODE (DECL_RTL (exp)) == REG\n+      if (REG_P (DECL_RTL (exp))\n \t  && GET_MODE (DECL_RTL (exp)) != DECL_MODE (exp))\n \t{\n \t  /* Get the signedness used for this variable.  Ensure we get the\n@@ -6734,7 +6734,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  find_function_data (context);\n \n \t  temp = SAVE_EXPR_RTL (exp);\n-\t  if (temp && GET_CODE (temp) == REG)\n+\t  if (temp && REG_P (temp))\n \t    {\n \t      put_var_into_stack (exp, /*rescan=*/true);\n \t      temp = SAVE_EXPR_RTL (exp);\n@@ -6756,7 +6756,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t3, 0, 0);\n \n \t  SAVE_EXPR_RTL (exp) = temp;\n-\t  if (!optimize && GET_CODE (temp) == REG)\n+\t  if (!optimize && REG_P (temp))\n \t    save_expr_regs = gen_rtx_EXPR_LIST (VOIDmode, temp,\n \t\t\t\t\t\tsave_expr_regs);\n \n@@ -6765,7 +6765,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t     wanted mode but mark it so that we know that it was already\n \t     extended.  */\n \n-\t  if (GET_CODE (temp) == REG && GET_MODE (temp) != mode)\n+\t  if (REG_P (temp) && GET_MODE (temp) != mode)\n \t    {\n \t      temp = gen_lowpart_SUBREG (mode, SAVE_EXPR_RTL (exp));\n \t      promote_mode (type, mode, &unsignedp, 0);\n@@ -6786,7 +6786,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t must be a promoted value.  We return a SUBREG of the wanted mode,\n \t but mark it so that we know that it was already extended.  */\n \n-      if (GET_CODE (SAVE_EXPR_RTL (exp)) == REG\n+      if (REG_P (SAVE_EXPR_RTL (exp))\n \t  && GET_MODE (SAVE_EXPR_RTL (exp)) != mode)\n \t{\n \t  /* Compute the signedness and make the proper SUBREG.  */\n@@ -7299,7 +7299,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t   (which we know to be the width of a basic mode), then\n \t   storing into memory, and changing the mode to BLKmode.  */\n \tif (mode1 == VOIDmode\n-\t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n+\t    || REG_P (op0) || GET_CODE (op0) == SUBREG\n \t    || (mode1 != BLKmode && ! direct_load[(int) mode1]\n \t\t&& GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n \t\t&& GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT\n@@ -7363,7 +7363,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t    op0 = validize_mem (op0);\n \n-\t    if (GET_CODE (op0) == MEM && GET_CODE (XEXP (op0, 0)) == REG)\n+\t    if (GET_CODE (op0) == MEM && REG_P (XEXP (op0, 0)))\n \t      mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n \t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,\n@@ -7422,7 +7422,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  op0 = copy_rtx (op0);\n \n \tset_mem_attributes (op0, exp, 0);\n-\tif (GET_CODE (XEXP (op0, 0)) == REG)\n+\tif (REG_P (XEXP (op0, 0)))\n \t  mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n \tMEM_VOLATILE_P (op0) |= volatilep;\n@@ -7666,7 +7666,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\tadjust_address (target, TYPE_MODE (valtype), 0),\n \t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \n-\t  else if (GET_CODE (target) == REG)\n+\t  else if (REG_P (target))\n \t    /* Store this field into a union of the proper type.  */\n \t    store_field (target,\n \t\t\t MIN ((int_size_in_bytes (TREE_TYPE\n@@ -7989,9 +7989,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n \t\t\t     EXPAND_SUM);\n \n-\t  if (GET_CODE (op0) != REG)\n+\t  if (!REG_P (op0))\n \t    op0 = force_operand (op0, NULL_RTX);\n-\t  if (GET_CODE (op0) != REG)\n+\t  if (!REG_P (op0))\n \t    op0 = copy_to_mode_reg (mode, op0);\n \n \t  return gen_rtx_MULT (mode, op0,\n@@ -8183,7 +8183,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  || modifier == EXPAND_STACK_PARM\n \t  || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n \t  || GET_MODE (target) != mode\n-\t  || (GET_CODE (target) == REG\n+\t  || (REG_P (target)\n \t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n \ttarget = gen_reg_rtx (mode);\n       expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n@@ -8315,7 +8315,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* For foo != 0, load foo, and if it is nonzero load 1 instead.  */\n       if (code == NE_EXPR && integer_zerop (TREE_OPERAND (exp, 1))\n \t  && original_target\n-\t  && GET_CODE (original_target) == REG\n+\t  && REG_P (original_target)\n \t  && (GET_MODE (original_target)\n \t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n \t{\n@@ -8362,7 +8362,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      || ! safe_from_p (target, exp, 1)\n \t      /* Make sure we don't have a hard reg (such as function's return\n \t\t value) live across basic blocks, if not optimizing.  */\n-\t      || (!optimize && GET_CODE (target) == REG\n+\t      || (!optimize && REG_P (target)\n \t\t  && REGNO (target) < FIRST_PSEUDO_REGISTER)))\n \ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n \n@@ -8564,13 +8564,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  temp = assign_temp (type, 0, 0, 1);\n \telse if (original_target\n \t\t && (safe_from_p (original_target, TREE_OPERAND (exp, 0), 1)\n-\t\t     || (singleton && GET_CODE (original_target) == REG\n+\t\t     || (singleton && REG_P (original_target)\n \t\t\t && REGNO (original_target) >= FIRST_PSEUDO_REGISTER\n \t\t\t && original_target == var_rtx (singleton)))\n \t\t && GET_MODE (original_target) == mode\n #ifdef HAVE_conditional_move\n \t\t && (! can_conditionally_move_p (mode)\n-\t\t     || GET_CODE (original_target) == REG\n+\t\t     || REG_P (original_target)\n \t\t     || TREE_ADDRESSABLE (type))\n #endif\n \t\t && (GET_CODE (original_target) != MEM\n@@ -8646,7 +8646,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t   might clobber it.  */\n \t\tif ((binary_op\n \t\t     && ! safe_from_p (temp, TREE_OPERAND (binary_op, 1), 1))\n-\t\t    || (GET_CODE (temp) == REG\n+\t\t    || (REG_P (temp)\n \t\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER))\n \t\t  temp = gen_reg_rtx (mode);\n \t\tstore_expr (singleton, temp,\n@@ -8689,7 +8689,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t     || TREE_CODE (TREE_OPERAND (exp, 1)) == SAVE_EXPR)\n \t\t && safe_from_p (temp, TREE_OPERAND (exp, 2), 1))\n \t  {\n-\t    if (GET_CODE (temp) == REG\n+\t    if (REG_P (temp)\n \t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 1), temp,\n@@ -8714,7 +8714,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t     || TREE_CODE (TREE_OPERAND (exp, 2)) == SAVE_EXPR)\n \t\t && safe_from_p (temp, TREE_OPERAND (exp, 1), 1))\n \t  {\n-\t    if (GET_CODE (temp) == REG\n+\t    if (REG_P (temp)\n \t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 2), temp,\n@@ -8983,7 +8983,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  if (CONSTANT_P (op0))\n \t    op0 = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n \t\t\t\t   op0);\n-\t  else if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n+\t  else if (REG_P (op0) || GET_CODE (op0) == SUBREG\n \t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF\n \t\t   || GET_CODE (op0) == PARALLEL || GET_CODE (op0) == LO_SUM)\n \t    {\n@@ -9073,13 +9073,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t}\n \n       if (flag_force_addr\n-\t  && GET_CODE (op0) != REG\n+\t  && !REG_P (op0)\n \t  && modifier != EXPAND_CONST_ADDRESS\n \t  && modifier != EXPAND_INITIALIZER\n \t  && modifier != EXPAND_SUM)\n \top0 = force_reg (Pmode, op0);\n \n-      if (GET_CODE (op0) == REG\n+      if (REG_P (op0)\n \t  && ! REG_USERVAR_P (op0))\n \tmark_reg_pointer (op0, TYPE_ALIGN (TREE_TYPE (type)));\n \n@@ -9548,7 +9548,7 @@ expand_increment (tree exp, int post, int ignore)\n \tbad_subreg = 1;\n     }\n \n-  op0_is_copy = ((GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n+  op0_is_copy = ((GET_CODE (op0) == SUBREG || REG_P (op0))\n \t\t && temp != get_last_insn ());\n   op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n \n@@ -9902,7 +9902,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n     }\n \n   /* If this failed, we have to do this with set/compare/jump/set code.  */\n-  if (GET_CODE (target) != REG\n+  if (!REG_P (target)\n       || reg_mentioned_p (target, op0) || reg_mentioned_p (target, op1))\n     target = gen_reg_rtx (GET_MODE (target));\n \n@@ -10073,7 +10073,7 @@ do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n      out of PIC_CASE_VECTOR_ADDRESS won't be a valid address,\n      and break_out_memory_refs will go to work on it and mess it up.  */\n #ifdef PIC_CASE_VECTOR_ADDRESS\n-  if (flag_pic && GET_CODE (index) != REG)\n+  if (flag_pic && !REG_P (index))\n     index = copy_to_mode_reg (Pmode, index);\n #endif\n "}, {"sha": "65ebaa0bfcb9fa1dac9eb6f1d33c06d7c76cd335", "filename": "gcc/final.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1428,7 +1428,7 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n   function_section (current_function_decl);\n \n #if defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval && svrtx != NULL_RTX && GET_CODE (svrtx) == REG)\n+  if (sval && svrtx != NULL_RTX && REG_P (svrtx))\n     ASM_OUTPUT_REG_PUSH (file, REGNO (svrtx));\n #endif\n \n@@ -1459,7 +1459,7 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n #endif\n \n #if defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval && svrtx != NULL_RTX && GET_CODE (svrtx) == REG)\n+  if (sval && svrtx != NULL_RTX && REG_P (svrtx))\n     ASM_OUTPUT_REG_POP (file, REGNO (svrtx));\n #endif\n }\n@@ -2275,8 +2275,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tif (final_sequence == 0\n \t    && prescan >= 0\n \t    && GET_CODE (insn) == INSN && GET_CODE (body) == SET\n-\t    && GET_CODE (SET_SRC (body)) == REG\n-\t    && GET_CODE (SET_DEST (body)) == REG\n+\t    && REG_P (SET_SRC (body))\n+\t    && REG_P (SET_DEST (body))\n \t    && REGNO (SET_SRC (body)) == REGNO (SET_DEST (body)))\n \t  break;\n #endif\n@@ -2633,7 +2633,7 @@ alter_subreg (rtx *xp)\n       if (new != 0)\n \t*xp = new;\n       /* Simplify_subreg can't handle some REG cases, but we have to.  */\n-      else if (GET_CODE (y) == REG)\n+      else if (REG_P (y))\n \t{\n \t  unsigned int regno = subreg_hard_regno (x, 1);\n \t  *xp = gen_rtx_REG_offset (y, GET_MODE (x), regno, SUBREG_BYTE (x));\n@@ -2899,7 +2899,7 @@ get_mem_expr_from_op (rtx op, int *paddressp)\n \n   *paddressp = 0;\n \n-  if (GET_CODE (op) == REG)\n+  if (REG_P (op))\n     return REG_EXPR (op);\n   else if (GET_CODE (op) != MEM)\n     return 0;\n@@ -3218,7 +3218,7 @@ output_operand (rtx x, int code ATTRIBUTE_UNUSED)\n   /* If X is a pseudo-register, abort now rather than writing trash to the\n      assembler file.  */\n \n-  if (x && GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+  if (x && REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n     abort ();\n \n   PRINT_OPERAND (asm_out_file, x, code);\n@@ -3756,7 +3756,7 @@ only_leaf_regs_used (void)\n \n   if (current_function_uses_pic_offset_table\n       && pic_offset_table_rtx != 0\n-      && GET_CODE (pic_offset_table_rtx) == REG\n+      && REG_P (pic_offset_table_rtx)\n       && ! permitted_reg_in_leaf_functions[REGNO (pic_offset_table_rtx)])\n     return 0;\n \n@@ -3800,7 +3800,7 @@ leaf_renumber_regs_insn (rtx in_rtx)\n      renumbered_regs would be 1 for an output-register;\n      they  */\n \n-  if (GET_CODE (in_rtx) == REG)\n+  if (REG_P (in_rtx))\n     {\n       int newreg;\n "}, {"sha": "1a6546d95408570357d6733ef1ade0669807d2b7", "filename": "gcc/flow.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -455,7 +455,7 @@ verify_wide_reg_1 (rtx *px, void *pregno)\n   rtx x = *px;\n   unsigned int regno = *(int *) pregno;\n \n-  if (GET_CODE (x) == REG && REGNO (x) == regno)\n+  if (REG_P (x) && REGNO (x) == regno)\n     {\n       if (GET_MODE_BITSIZE (GET_MODE (x)) <= BITS_PER_WORD)\n \treturn 2;\n@@ -1330,15 +1330,15 @@ find_regno_partial (rtx *ptr, void *data)\n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n     case STRICT_LOW_PART:\n-      if (GET_CODE (XEXP (*ptr, 0)) == REG && REGNO (XEXP (*ptr, 0)) == reg)\n+      if (REG_P (XEXP (*ptr, 0)) && REGNO (XEXP (*ptr, 0)) == reg)\n \t{\n \t  param->retval = XEXP (*ptr, 0);\n \t  return 1;\n \t}\n       break;\n \n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (*ptr)) == REG\n+      if (REG_P (SUBREG_REG (*ptr))\n \t  && REGNO (SUBREG_REG (*ptr)) == reg)\n \t{\n \t  param->retval = SUBREG_REG (*ptr);\n@@ -1623,7 +1623,7 @@ propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n     /* Does this instruction increment or decrement a register?  */\n     if ((flags & PROP_AUTOINC)\n \t&& x != 0\n-\t&& GET_CODE (SET_DEST (x)) == REG\n+\t&& REG_P (SET_DEST (x))\n \t&& (GET_CODE (SET_SRC (x)) == PLUS\n \t    || GET_CODE (SET_SRC (x)) == MINUS)\n \t&& XEXP (SET_SRC (x), 0) == SET_DEST (x)\n@@ -1873,7 +1873,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t     in the form of a comparison of a register against zero.  \n \t     If the condition is more complex than that, then it is safe\n \t     not to record any information.  */\n-\t  if (GET_CODE (reg) == REG\n+\t  if (REG_P (reg)\n \t      && XEXP (cond_true, 1) == const0_rtx)\n \t    {\n \t      rtx cond_false\n@@ -2149,7 +2149,7 @@ insn_dead_p (struct propagate_block_info *pbi, rtx x, int call_ok,\n \t\t || GET_CODE (r) == ZERO_EXTRACT)\n \t    r = XEXP (r, 0);\n \n-\t  if (GET_CODE (r) == REG)\n+\t  if (REG_P (r))\n \t    {\n \t      int regno = REGNO (r);\n \n@@ -2225,7 +2225,7 @@ insn_dead_p (struct propagate_block_info *pbi, rtx x, int call_ok,\n      is not necessarily true for hard registers until after reload.  */\n   else if (code == CLOBBER)\n     {\n-      if (GET_CODE (XEXP (x, 0)) == REG\n+      if (REG_P (XEXP (x, 0))\n \t  && (REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER\n \t      || reload_completed)\n \t  && ! REGNO_REG_SET_P (pbi->reg_live, REGNO (XEXP (x, 0))))\n@@ -2265,7 +2265,7 @@ libcall_dead_p (struct propagate_block_info *pbi, rtx note, rtx insn)\n     {\n       rtx r = SET_SRC (x);\n \n-      if (GET_CODE (r) == REG)\n+      if (REG_P (r))\n \t{\n \t  rtx call = XEXP (note, 0);\n \t  rtx call_pat;\n@@ -2552,7 +2552,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n       break;\n \n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (reg)) == REG)\n+      if (REG_P (SUBREG_REG (reg)))\n \t{\n \t  enum machine_mode outer_mode = GET_MODE (reg);\n \t  enum machine_mode inner_mode = GET_MODE (SUBREG_REG (reg));\n@@ -2605,7 +2605,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n      If this set is a REG, then it kills any MEMs which use the reg.  */\n   if (optimize && (flags & PROP_SCAN_DEAD_STORES))\n     {\n-      if (GET_CODE (reg) == REG)\n+      if (REG_P (reg))\n \tinvalidate_mems_from_set (pbi, reg);\n \n       /* If the memory reference had embedded side effects (autoincrement\n@@ -2620,7 +2620,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \tadd_to_mem_set_list (pbi, canon_rtx (reg));\n     }\n \n-  if (GET_CODE (reg) == REG\n+  if (REG_P (reg)\n       && ! (regno_first == FRAME_POINTER_REGNUM\n \t    && (! reload_completed || frame_pointer_needed))\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n@@ -2810,7 +2810,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t      }\n \t}\n     }\n-  else if (GET_CODE (reg) == REG)\n+  else if (REG_P (reg))\n     {\n       if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n \tpbi->reg_next_use[regno_first] = 0;\n@@ -3086,7 +3086,7 @@ not_reg_cond (rtx x)\n   if (x_code == NOT)\n     return XEXP (x, 0);\n   if (COMPARISON_P (x)\n-      && GET_CODE (XEXP (x, 0)) == REG)\n+      && REG_P (XEXP (x, 0)))\n     {\n       if (XEXP (x, 1) != const0_rtx)\n \tabort ();\n@@ -3279,7 +3279,7 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n       if (! validate_change (insn, &XEXP (mem, 0), inc, 0))\n \treturn;\n     }\n-  else if (GET_CODE (q) == REG\n+  else if (REG_P (q)\n \t   /* PREV_INSN used here to check the semi-open interval\n \t      [insn,incr).  */\n \t   && ! reg_used_between_p (q,  PREV_INSN (insn), incr)\n@@ -3429,7 +3429,7 @@ find_auto_inc (struct propagate_block_info *pbi, rtx x, rtx insn)\n   if (GET_CODE (addr) == PLUS && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n     offset = INTVAL (XEXP (addr, 1)), addr = XEXP (addr, 0);\n \n-  if (GET_CODE (addr) != REG)\n+  if (!REG_P (addr))\n     return;\n \n   regno = REGNO (addr);\n@@ -3484,7 +3484,7 @@ find_auto_inc (struct propagate_block_info *pbi, rtx x, rtx insn)\n \t\t\t\t\t\t\t\t  inc_val)),\n \t\t\t  insn, x, incr, addr);\n     }\n-  else if (GET_CODE (inc_val) == REG\n+  else if (REG_P (inc_val)\n \t   && ! reg_set_between_p (inc_val, PREV_INSN (insn),\n \t\t\t\t   NEXT_INSN (incr)))\n \n@@ -3787,7 +3787,7 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n     case SUBREG:\n #ifdef CANNOT_CHANGE_MODE_CLASS\n       if ((flags & PROP_REG_INFO)\n-\t  && GET_CODE (SUBREG_REG (x)) == REG\n+\t  && REG_P (SUBREG_REG (x))\n \t  && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)\n \tbitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (x))\n \t\t\t\t\t  * MAX_MACHINE_MODE\n@@ -3796,7 +3796,7 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \n       /* While we're here, optimize this case.  */\n       x = SUBREG_REG (x);\n-      if (GET_CODE (x) != REG)\n+      if (!REG_P (x))\n \tgoto retry;\n       /* Fall through.  */\n \n@@ -3838,7 +3838,7 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n #ifdef CANNOT_CHANGE_MODE_CLASS\n \t    if ((flags & PROP_REG_INFO)\n \t\t&& GET_CODE (testreg) == SUBREG\n-\t\t&& GET_CODE (SUBREG_REG (testreg)) == REG\n+\t\t&& REG_P (SUBREG_REG (testreg))\n \t\t&& REGNO (SUBREG_REG (testreg)) >= FIRST_PSEUDO_REGISTER)\n \t      bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (testreg))\n \t\t\t\t\t\t* MAX_MACHINE_MODE\n@@ -3865,7 +3865,7 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \n \tif ((GET_CODE (testreg) == PARALLEL\n \t     && GET_MODE (testreg) == BLKmode)\n-\t    || (GET_CODE (testreg) == REG\n+\t    || (REG_P (testreg)\n \t\t&& (regno = REGNO (testreg),\n \t\t    ! (regno == FRAME_POINTER_REGNUM\n \t\t       && (! reload_completed || frame_pointer_needed)))\n@@ -4268,7 +4268,7 @@ count_or_remove_death_notes_bb (basic_block bb, int kill)\n \t      switch (REG_NOTE_KIND (link))\n \t\t{\n \t\tcase REG_DEAD:\n-\t\t  if (GET_CODE (XEXP (link, 0)) == REG)\n+\t\t  if (REG_P (XEXP (link, 0)))\n \t\t    {\n \t\t      rtx reg = XEXP (link, 0);\n \t\t      int n;"}, {"sha": "277ac7627a2b78fb798b80948acbf150cc5cc2e2", "filename": "gcc/function.c", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1061,10 +1061,10 @@ find_temp_slot_from_address (rtx x)\n \n   /* If we have a sum involving a register, see if it points to a temp\n      slot.  */\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == REG\n+  if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 0))\n       && (p = find_temp_slot_from_address (XEXP (x, 0))) != 0)\n     return p;\n-  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG\n+  else if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 1))\n \t   && (p = find_temp_slot_from_address (XEXP (x, 1))) != 0)\n     return p;\n \n@@ -1094,7 +1094,7 @@ update_temp_slot_address (rtx old, rtx new)\n       if (GET_CODE (old) != PLUS)\n \treturn;\n \n-      if (GET_CODE (new) == REG)\n+      if (REG_P (new))\n \t{\n \t  update_temp_slot_address (XEXP (old, 0), new);\n \t  update_temp_slot_address (XEXP (old, 1), new);\n@@ -1181,7 +1181,7 @@ preserve_temp_slots (rtx x)\n      a temporary slot we know it points to.  To be consistent with\n      the code below, we really should preserve all non-kept slots\n      if we can't find a match, but that seems to be much too costly.  */\n-  if (GET_CODE (x) == REG && REG_POINTER (x))\n+  if (REG_P (x) && REG_POINTER (x))\n     p = find_temp_slot_from_address (x);\n \n   /* If X is not in memory or is at a constant address, it cannot be in\n@@ -1407,7 +1407,7 @@ put_var_into_stack (tree decl, int rescan)\n      if the var is non-local.  */\n   if (TREE_CODE (decl) != SAVE_EXPR && DECL_NONLOCAL (decl)\n       && GET_CODE (reg) == MEM\n-      && GET_CODE (XEXP (reg, 0)) == REG\n+      && REG_P (XEXP (reg, 0))\n       && REGNO (XEXP (reg, 0)) > LAST_VIRTUAL_REGISTER)\n     {\n       orig_reg = reg = XEXP (reg, 0);\n@@ -1437,7 +1437,7 @@ put_var_into_stack (tree decl, int rescan)\n \n   /* Now we should have a value that resides in one or more pseudo regs.  */\n \n-  if (GET_CODE (reg) == REG)\n+  if (REG_P (reg))\n     {\n       if (can_use_addressof_p)\n \tgen_mem_addressof (reg, decl, rescan);\n@@ -1761,7 +1761,7 @@ fixup_var_refs_insn (rtx insn, rtx var, enum machine_mode promoted_mode,\n \t      don't delete the insn.  */\n \t   && find_reg_note (insn, REG_RETVAL, NULL_RTX) == 0\n \t   && (rtx_equal_p (SET_SRC (set), var)\n-\t       || (GET_CODE (SET_SRC (set)) == REG\n+\t       || (REG_P (SET_SRC (set))\n \t\t   && (prev = prev_nonnote_insn (insn)) != 0\n \t\t   && (prev_set = single_set (prev)) != 0\n \t\t   && SET_DEST (prev_set) == SET_SRC (set)\n@@ -1836,7 +1836,7 @@ fixup_var_refs_insn (rtx insn, rtx var, enum machine_mode promoted_mode,\n \t{\n \t  struct fixup_replacement *next;\n \n-\t  if (GET_CODE (replacements->new) == REG)\n+\t  if (REG_P (replacements->new))\n \t    {\n \t      rtx insert_before;\n \t      rtx seq;\n@@ -2351,9 +2351,9 @@ fixup_var_refs_1 (rtx var, enum machine_mode promoted_mode, rtx *loc, rtx insn,\n \tif ((SET_SRC (x) == var\n \t     || (GET_CODE (SET_SRC (x)) == SUBREG\n \t\t && SUBREG_REG (SET_SRC (x)) == var))\n-\t    && (GET_CODE (SET_DEST (x)) == REG\n+\t    && (REG_P (SET_DEST (x))\n \t\t|| (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t    && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG))\n+\t\t    && REG_P (SUBREG_REG (SET_DEST (x)))))\n \t    && GET_MODE (var) == promoted_mode\n \t    && x == single_set (insn))\n \t  {\n@@ -2422,9 +2422,9 @@ fixup_var_refs_1 (rtx var, enum machine_mode promoted_mode, rtx *loc, rtx insn,\n \tif ((SET_DEST (x) == var\n \t     || (GET_CODE (SET_DEST (x)) == SUBREG\n \t\t && SUBREG_REG (SET_DEST (x)) == var))\n-\t    && (GET_CODE (SET_SRC (x)) == REG\n+\t    && (REG_P (SET_SRC (x))\n \t\t|| (GET_CODE (SET_SRC (x)) == SUBREG\n-\t\t    && GET_CODE (SUBREG_REG (SET_SRC (x))) == REG))\n+\t\t    && REG_P (SUBREG_REG (SET_SRC (x)))))\n \t    && GET_MODE (var) == promoted_mode\n \t    && x == single_set (insn))\n \t  {\n@@ -2635,7 +2635,7 @@ fixup_stack_1 (rtx x, rtx insn)\n       /* If we have address of a stack slot but it's not valid\n \t (displacement is too large), compute the sum in a register.  */\n       if (GET_CODE (ad) == PLUS\n-\t  && GET_CODE (XEXP (ad, 0)) == REG\n+\t  && REG_P (XEXP (ad, 0))\n \t  && ((REGNO (XEXP (ad, 0)) >= FIRST_VIRTUAL_REGISTER\n \t       && REGNO (XEXP (ad, 0)) <= LAST_VIRTUAL_REGISTER)\n \t      || REGNO (XEXP (ad, 0)) == FRAME_POINTER_REGNUM\n@@ -2717,15 +2717,15 @@ optimize_bit_field (rtx body, rtx insn, rtx *equiv_mem)\n \n       if (GET_CODE (XEXP (bitfield, 0)) == MEM)\n \tmemref = XEXP (bitfield, 0);\n-      else if (GET_CODE (XEXP (bitfield, 0)) == REG\n+      else if (REG_P (XEXP (bitfield, 0))\n \t       && equiv_mem != 0)\n \tmemref = equiv_mem[REGNO (XEXP (bitfield, 0))];\n       else if (GET_CODE (XEXP (bitfield, 0)) == SUBREG\n \t       && GET_CODE (SUBREG_REG (XEXP (bitfield, 0))) == MEM)\n \tmemref = SUBREG_REG (XEXP (bitfield, 0));\n       else if (GET_CODE (XEXP (bitfield, 0)) == SUBREG\n \t       && equiv_mem != 0\n-\t       && GET_CODE (SUBREG_REG (XEXP (bitfield, 0))) == REG)\n+\t       && REG_P (SUBREG_REG (XEXP (bitfield, 0))))\n \tmemref = equiv_mem[REGNO (SUBREG_REG (XEXP (bitfield, 0)))];\n \n       if (memref\n@@ -2962,7 +2962,7 @@ flush_addressof (tree decl)\n       && DECL_RTL (decl) != 0\n       && GET_CODE (DECL_RTL (decl)) == MEM\n       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == ADDRESSOF\n-      && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == REG)\n+      && REG_P (XEXP (XEXP (DECL_RTL (decl), 0), 0)))\n     put_addressof_into_stack (XEXP (DECL_RTL (decl), 0), 0);\n }\n \n@@ -2976,7 +2976,7 @@ put_addressof_into_stack (rtx r, htab_t ht)\n \n   rtx reg = XEXP (r, 0);\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     abort ();\n \n   decl = ADDRESSOF_DECL (r);\n@@ -3071,7 +3071,7 @@ purge_addressof_1 (rtx *loc, rtx insn, int force, int store, int may_postpone,\n       /* If SUB is a hard or virtual register, try it as a pseudo-register.\n \t Otherwise, perhaps SUB is an expression, so generate code to compute\n \t it.  */\n-      if (GET_CODE (sub) == REG && REGNO (sub) <= LAST_VIRTUAL_REGISTER)\n+      if (REG_P (sub) && REGNO (sub) <= LAST_VIRTUAL_REGISTER)\n \tsub = copy_to_reg (sub);\n       else\n \tsub = force_operand (sub, NULL_RTX);\n@@ -3092,10 +3092,10 @@ purge_addressof_1 (rtx *loc, rtx insn, int force, int store, int may_postpone,\n \n       if (GET_CODE (sub) == MEM)\n \tsub = adjust_address_nv (sub, GET_MODE (x), 0);\n-      else if (GET_CODE (sub) == REG\n+      else if (REG_P (sub)\n \t       && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))\n \t;\n-      else if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))\n+      else if (REG_P (sub) && GET_MODE (x) != GET_MODE (sub))\n \t{\n \t  int size_x, size_sub;\n \n@@ -3133,7 +3133,7 @@ purge_addressof_1 (rtx *loc, rtx insn, int force, int store, int may_postpone,\n \t\t    rtx z = XEXP (XEXP (tem, 1), 0);\n \n \t\t    if (GET_MODE (x) == GET_MODE (z)\n-\t\t\t|| (GET_CODE (XEXP (XEXP (tem, 1), 0)) != REG\n+\t\t\t|| (!REG_P (XEXP (XEXP (tem, 1), 0))\n \t\t\t    && GET_CODE (XEXP (XEXP (tem, 1), 0)) != SUBREG))\n \t\t      abort ();\n \n@@ -3298,7 +3298,7 @@ purge_addressof_1 (rtx *loc, rtx insn, int force, int store, int may_postpone,\n \t{\n \t  /* Remember the replacement so that the same one can be done\n \t     on the REG_NOTES.  */\n-\t  if (GET_CODE (sub) == REG || GET_CODE (sub) == SUBREG)\n+\t  if (REG_P (sub) || GET_CODE (sub) == SUBREG)\n \t    {\n \t      rtx tem;\n \n@@ -3385,7 +3385,7 @@ insns_for_mem_walk (rtx *r, void *data)\n   tmp.insns = NULL_RTX;\n \n   if (ifmwi->pass == 0 && *r && GET_CODE (*r) == ADDRESSOF\n-      && GET_CODE (XEXP (*r, 0)) == REG)\n+      && REG_P (XEXP (*r, 0)))\n     {\n       void **e;\n       tmp.key = XEXP (*r, 0);\n@@ -3396,7 +3396,7 @@ insns_for_mem_walk (rtx *r, void *data)\n \t  memcpy (*e, &tmp, sizeof (tmp));\n \t}\n     }\n-  else if (ifmwi->pass == 1 && *r && GET_CODE (*r) == REG)\n+  else if (ifmwi->pass == 1 && *r && REG_P (*r))\n     {\n       struct insns_for_mem_entry *ifme;\n       tmp.key = *r;\n@@ -3534,7 +3534,7 @@ purge_single_hard_subreg_set (rtx pattern)\n   enum machine_mode mode = GET_MODE (SET_DEST (pattern));\n   int offset = 0;\n \n-  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG\n+  if (GET_CODE (reg) == SUBREG && REG_P (SUBREG_REG (reg))\n       && REGNO (SUBREG_REG (reg)) < FIRST_PSEUDO_REGISTER)\n     {\n       offset = subreg_regno_offset (REGNO (SUBREG_REG (reg)),\n@@ -3545,7 +3545,7 @@ purge_single_hard_subreg_set (rtx pattern)\n     }\n \n \n-  if (GET_CODE (reg) == REG && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n+  if (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     {\n       reg = gen_rtx_REG (mode, REGNO (reg) + offset);\n       SET_DEST (pattern) = reg;\n@@ -3724,8 +3724,8 @@ instantiate_decl (rtx x, HOST_WIDE_INT size, int valid_only)\n \n   addr = XEXP (x, 0);\n   if (CONSTANT_P (addr)\n-      || (GET_CODE (addr) == ADDRESSOF && GET_CODE (XEXP (addr, 0)) == REG)\n-      || (GET_CODE (addr) == REG\n+      || (GET_CODE (addr) == ADDRESSOF && REG_P (XEXP (addr, 0)))\n+      || (REG_P (addr)\n \t  && (REGNO (addr) < FIRST_VIRTUAL_REGISTER\n \t      || REGNO (addr) > LAST_VIRTUAL_REGISTER)))\n     return;\n@@ -3883,14 +3883,14 @@ instantiate_virtual_regs_1 (rtx *loc, rtx object, int extra_insns)\n \n \t  /* The only valid sources here are PLUS or REG.  Just do\n \t     the simplest possible thing to handle them.  */\n-\t  if (GET_CODE (src) != REG && GET_CODE (src) != PLUS)\n+\t  if (!REG_P (src) && GET_CODE (src) != PLUS)\n \t    {\n \t      instantiate_virtual_regs_lossage (object);\n \t      return 1;\n \t    }\n \n \t  start_sequence ();\n-\t  if (GET_CODE (src) != REG)\n+\t  if (!REG_P (src))\n \t    temp = force_operand (src, NULL_RTX);\n \t  else\n \t    temp = src;\n@@ -3956,7 +3956,7 @@ instantiate_virtual_regs_1 (rtx *loc, rtx object, int extra_insns)\n \t      /* We know the second operand is a constant.  Unless the\n \t\t first operand is a REG (which has been already checked),\n \t\t it needs to be checked.  */\n-\t      if (GET_CODE (XEXP (x, 0)) != REG)\n+\t      if (!REG_P (XEXP (x, 0)))\n \t\t{\n \t\t  loc = &XEXP (x, 0);\n \t\t  goto restart;\n@@ -4145,7 +4145,7 @@ instantiate_virtual_regs_1 (rtx *loc, rtx object, int extra_insns)\n       if ((GET_CODE (XEXP (x, 0)) == MEM\n \t   && instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 0), XEXP (x, 0),\n \t\t\t\t\t  0))\n-\t  || (GET_CODE (XEXP (x, 0)) == REG\n+\t  || (REG_P (XEXP (x, 0))\n \t      && instantiate_virtual_regs_1 (&XEXP (x, 0), object, 0)))\n \treturn 1;\n \n@@ -4179,7 +4179,7 @@ instantiate_virtual_regs_1 (rtx *loc, rtx object, int extra_insns)\n       return 1;\n \n     case ADDRESSOF:\n-      if (GET_CODE (XEXP (x, 0)) == REG)\n+      if (REG_P (XEXP (x, 0)))\n \treturn 1;\n \n       else if (GET_CODE (XEXP (x, 0)) == MEM)\n@@ -4273,7 +4273,7 @@ aggregate_value_p (tree exp, tree fntype)\n \n   /* If we have something other than a REG (e.g. a PARALLEL), then assume\n      it is OK.  */\n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return 0;\n \n   regno = REGNO (reg);\n@@ -4711,7 +4711,7 @@ assign_parms (tree fndecl)\n \n \t  for (i = 0; i < len; i++)\n \t    if (XEXP (XVECEXP (entry_parm, 0, i), 0) != NULL_RTX\n-\t\t&& GET_CODE (XEXP (XVECEXP (entry_parm, 0, i), 0)) == REG\n+\t\t&& REG_P (XEXP (XVECEXP (entry_parm, 0, i), 0))\n \t\t&& (GET_MODE (XEXP (XVECEXP (entry_parm, 0, i), 0))\n \t\t    == passed_mode)\n \t\t&& INTVAL (XEXP (XVECEXP (entry_parm, 0, i), 1)) == 0)\n@@ -4781,7 +4781,7 @@ assign_parms (tree fndecl)\n \t  /* If a BLKmode arrives in registers, copy it to a stack slot.\n \t     Handle calls that pass values in multiple non-contiguous\n \t     locations.  The Irix 6 ABI has examples of this.  */\n-\t  if (GET_CODE (entry_parm) == REG\n+\t  if (REG_P (entry_parm)\n \t      || (GET_CODE (entry_parm) == PARALLEL\n \t\t && (!loaded_in_reg || !optimize)))\n \t    {\n@@ -4947,7 +4947,7 @@ assign_parms (tree fndecl)\n \n \t      if (GET_CODE (tempreg) == SUBREG\n \t\t  && GET_MODE (tempreg) == nominal_mode\n-\t\t  && GET_CODE (SUBREG_REG (tempreg)) == REG\n+\t\t  && REG_P (SUBREG_REG (tempreg))\n \t\t  && nominal_mode == passed_mode\n \t\t  && GET_MODE (SUBREG_REG (tempreg)) == GET_MODE (entry_parm)\n \t\t  && GET_MODE_SIZE (GET_MODE (tempreg))\n@@ -5433,7 +5433,7 @@ promoted_input_arg (unsigned int regno, enum machine_mode *pmode, int *punsigned\n \n   for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n        arg = TREE_CHAIN (arg))\n-    if (GET_CODE (DECL_INCOMING_RTL (arg)) == REG\n+    if (REG_P (DECL_INCOMING_RTL (arg))\n \t&& REGNO (DECL_INCOMING_RTL (arg)) == regno\n \t&& TYPE_MODE (DECL_ARG_TYPE (arg)) == TYPE_MODE (TREE_TYPE (arg)))\n       {\n@@ -5708,7 +5708,7 @@ setjmp_vars_warning (tree block)\n     {\n       if (TREE_CODE (decl) == VAR_DECL\n \t  && DECL_RTL_SET_P (decl)\n-\t  && GET_CODE (DECL_RTL (decl)) == REG\n+\t  && REG_P (DECL_RTL (decl))\n \t  && regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n \twarning (\"%Jvariable '%D' might be clobbered by `longjmp' or `vfork'\",\n \t\t decl, decl);\n@@ -5728,7 +5728,7 @@ setjmp_args_warning (void)\n   for (decl = DECL_ARGUMENTS (current_function_decl);\n        decl; decl = TREE_CHAIN (decl))\n     if (DECL_RTL (decl) != 0\n-\t&& GET_CODE (DECL_RTL (decl)) == REG\n+\t&& REG_P (DECL_RTL (decl))\n \t&& regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n       warning (\"%Jargument '%D' might be clobbered by `longjmp' or `vfork'\",\n \t       decl, decl);\n@@ -5745,7 +5745,7 @@ setjmp_protect (tree block)\n     if ((TREE_CODE (decl) == VAR_DECL\n \t || TREE_CODE (decl) == PARM_DECL)\n \t&& DECL_RTL (decl) != 0\n-\t&& (GET_CODE (DECL_RTL (decl)) == REG\n+\t&& (REG_P (DECL_RTL (decl))\n \t    || (GET_CODE (DECL_RTL (decl)) == MEM\n \t\t&& GET_CODE (XEXP (DECL_RTL (decl), 0)) == ADDRESSOF))\n \t/* If this variable came from an inline function, it must be\n@@ -5778,7 +5778,7 @@ setjmp_protect_args (void)\n     if ((TREE_CODE (decl) == VAR_DECL\n \t || TREE_CODE (decl) == PARM_DECL)\n \t&& DECL_RTL (decl) != 0\n-\t&& (GET_CODE (DECL_RTL (decl)) == REG\n+\t&& (REG_P (DECL_RTL (decl))\n \t    || (GET_CODE (DECL_RTL (decl)) == MEM\n \t\t&& GET_CODE (XEXP (DECL_RTL (decl), 0)) == ADDRESSOF))\n \t&& (\n@@ -5815,7 +5815,7 @@ fix_lexical_addr (rtx addr, tree var)\n     addr = XEXP (XEXP (addr, 0), 0);\n \n   /* Decode given address as base reg plus displacement.  */\n-  if (GET_CODE (addr) == REG)\n+  if (REG_P (addr))\n     basereg = addr, displacement = 0;\n   else if (GET_CODE (addr) == PLUS && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n     basereg = XEXP (addr, 0), displacement = INTVAL (XEXP (addr, 1));\n@@ -6592,7 +6592,7 @@ diddle_return_value (void (*doit) (rtx, void *), void *arg)\n   if (! outgoing)\n     return;\n \n-  if (GET_CODE (outgoing) == REG)\n+  if (REG_P (outgoing))\n     (*doit) (outgoing, arg);\n   else if (GET_CODE (outgoing) == PARALLEL)\n     {\n@@ -6602,7 +6602,7 @@ diddle_return_value (void (*doit) (rtx, void *), void *arg)\n \t{\n \t  rtx x = XEXP (XVECEXP (outgoing, 0, i), 0);\n \n-\t  if (GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t    (*doit) (x, arg);\n \t}\n     }\n@@ -7154,19 +7154,19 @@ keep_stack_depressed (rtx insns)\n \t     unchanged.  Otherwise, it must be a MEM and we see what the\n \t     base register and offset are.  In any case, we have to emit any\n \t     pending load to the equivalent reg of SP, if any.  */\n-\t  if (GET_CODE (retaddr) == REG)\n+\t  if (REG_P (retaddr))\n \t    {\n \t      emit_equiv_load (&info);\n \t      add_insn (insn);\n \t      insn = next;\n \t      continue;\n \t    }\n \t  else if (GET_CODE (retaddr) == MEM\n-\t\t   && GET_CODE (XEXP (retaddr, 0)) == REG)\n+\t\t   && REG_P (XEXP (retaddr, 0)))\n \t    base = gen_rtx_REG (Pmode, REGNO (XEXP (retaddr, 0))), offset = 0;\n \t  else if (GET_CODE (retaddr) == MEM\n \t\t   && GET_CODE (XEXP (retaddr, 0)) == PLUS\n-\t\t   && GET_CODE (XEXP (XEXP (retaddr, 0), 0)) == REG\n+\t\t   && REG_P (XEXP (XEXP (retaddr, 0), 0))\n \t\t   && GET_CODE (XEXP (XEXP (retaddr, 0), 1)) == CONST_INT)\n \t    {\n \t      base = gen_rtx_REG (Pmode, REGNO (XEXP (XEXP (retaddr, 0), 0)));\n@@ -7291,7 +7291,7 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n \t  p->new_sp_equiv_reg = XEXP (SET_SRC (set), 0);\n \t  if (GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n \t    p->new_sp_offset = INTVAL (XEXP (SET_SRC (set), 1));\n-\t  else if (GET_CODE (XEXP (SET_SRC (set), 1)) == REG\n+\t  else if (REG_P (XEXP (SET_SRC (set), 1))\n \t\t   && REGNO (XEXP (SET_SRC (set), 1)) < FIRST_PSEUDO_REGISTER\n \t\t   && p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))] != 0)\n \t    p->new_sp_offset\n@@ -7309,7 +7309,7 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n \t  p->new_sp_offset += p->sp_offset;\n \t}\n \n-      if (p->new_sp_equiv_reg == 0 || GET_CODE (p->new_sp_equiv_reg) != REG)\n+      if (p->new_sp_equiv_reg == 0 || !REG_P (p->new_sp_equiv_reg))\n \tabort ();\n \n       return;\n@@ -7326,8 +7326,8 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n   else if (p->new_sp_equiv_reg != 0 && reg_set_p (p->new_sp_equiv_reg, set))\n     {\n       if (p->equiv_reg_src != 0\n-\t  || GET_CODE (p->new_sp_equiv_reg) != REG\n-\t  || GET_CODE (SET_DEST (set)) != REG\n+\t  || !REG_P (p->new_sp_equiv_reg)\n+\t  || !REG_P (SET_DEST (set))\n \t  || GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) > BITS_PER_WORD\n \t  || REGNO (p->new_sp_equiv_reg) != REGNO (SET_DEST (set)))\n \tabort ();\n@@ -7360,7 +7360,7 @@ update_epilogue_consts (rtx dest, rtx x, void *data)\n   struct epi_info *p = (struct epi_info *) data;\n   rtx new;\n \n-  if (GET_CODE (dest) != REG || REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+  if (!REG_P (dest) || REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n     return;\n \n   /* If we are either clobbering a register or doing a partial set,\n@@ -7375,7 +7375,7 @@ update_epilogue_consts (rtx dest, rtx x, void *data)\n   /* If this is a binary operation between a register we have been tracking\n      and a constant, see if we can compute a new constant value.  */\n   else if (ARITHMETIC_P (SET_SRC (x))\n-\t   && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n+\t   && REG_P (XEXP (SET_SRC (x), 0))\n \t   && REGNO (XEXP (SET_SRC (x), 0)) < FIRST_PSEUDO_REGISTER\n \t   && p->const_equiv[REGNO (XEXP (SET_SRC (x), 0))] != 0\n \t   && GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT"}, {"sha": "0195c97ff64ded4b8e918efac0ff817a219c4794", "filename": "gcc/genemit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -321,7 +321,7 @@ gen_insn (rtx insn, int lineno)\n \t  if (GET_CODE (XVECEXP (insn, 1, i)) != CLOBBER)\n \t    break;\n \n-\t  if (GET_CODE (XEXP (XVECEXP (insn, 1, i), 0)) == REG)\n+\t  if (REG_P (XEXP (XVECEXP (insn, 1, i), 0)))\n \t    has_hard_reg = 1;\n \t  else if (GET_CODE (XEXP (XVECEXP (insn, 1, i), 0)) != MATCH_SCRATCH)\n \t    break;\n@@ -355,7 +355,7 @@ gen_insn (rtx insn, int lineno)\n \t\t  if (! (GET_MODE (old) == GET_MODE (new)\n \t\t\t && ((GET_CODE (old) == MATCH_SCRATCH\n \t\t\t      && GET_CODE (new) == MATCH_SCRATCH)\n-\t\t\t     || (GET_CODE (old) == REG && GET_CODE (new) == REG\n+\t\t\t     || (REG_P (old) && REG_P (new)\n \t\t\t\t && REGNO (old) == REGNO (new)))))\n \t\t    break;\n \t\t}"}, {"sha": "6dc10840c74574a3630b9ae440e2bb6f46414ee5", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -2522,7 +2522,7 @@ make_insn_sequence (rtx insn, enum routine_type type)\n \t    {\n \t      rtx y = XVECEXP (x, 0, i - 1);\n \t      if (GET_CODE (y) != CLOBBER\n-\t\t  || (GET_CODE (XEXP (y, 0)) != REG\n+\t\t  || (!REG_P (XEXP (y, 0))\n \t\t      && GET_CODE (XEXP (y, 0)) != MATCH_SCRATCH))\n \t\tbreak;\n \t    }"}, {"sha": "bef4023181944774c67afb920337d3e3bee09766", "filename": "gcc/global.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -849,7 +849,7 @@ global_conflicts (void)\n \t\t\t{\n \t\t\t  rtx set = XVECEXP (PATTERN (insn), 0, i);\n \t\t\t  if (GET_CODE (set) == SET\n-\t\t\t      && GET_CODE (SET_DEST (set)) != REG\n+\t\t\t      && !REG_P (SET_DEST (set))\n \t\t\t      && !rtx_equal_p (reg, SET_DEST (set))\n \t\t\t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n \t\t\t    used_in_output = 1;\n@@ -896,11 +896,11 @@ expand_preferences (void)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn)\n \t&& (set = single_set (insn)) != 0\n-\t&& GET_CODE (SET_DEST (set)) == REG\n+\t&& REG_P (SET_DEST (set))\n \t&& reg_allocno[REGNO (SET_DEST (set))] >= 0)\n       for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \tif (REG_NOTE_KIND (link) == REG_DEAD\n-\t    && GET_CODE (XEXP (link, 0)) == REG\n+\t    && REG_P (XEXP (link, 0))\n \t    && reg_allocno[REGNO (XEXP (link, 0))] >= 0\n \t    && ! CONFLICTP (reg_allocno[REGNO (SET_DEST (set))],\n \t\t\t    reg_allocno[REGNO (XEXP (link, 0))]))\n@@ -1465,7 +1465,7 @@ mark_reg_store (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   regs_set[n_regs_set++] = reg;\n@@ -1522,7 +1522,7 @@ mark_reg_conflicts (rtx reg)\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   regno = REGNO (reg);\n@@ -1625,9 +1625,9 @@ set_preference (rtx dest, rtx src)\n   /* Get the reg number for both SRC and DEST.\n      If neither is a reg, give up.  */\n \n-  if (GET_CODE (src) == REG)\n+  if (REG_P (src))\n     src_regno = REGNO (src);\n-  else if (GET_CODE (src) == SUBREG && GET_CODE (SUBREG_REG (src)) == REG)\n+  else if (GET_CODE (src) == SUBREG && REG_P (SUBREG_REG (src)))\n     {\n       src_regno = REGNO (SUBREG_REG (src));\n \n@@ -1643,9 +1643,9 @@ set_preference (rtx dest, rtx src)\n   else\n     return;\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     dest_regno = REGNO (dest);\n-  else if (GET_CODE (dest) == SUBREG && GET_CODE (SUBREG_REG (dest)) == REG)\n+  else if (GET_CODE (dest) == SUBREG && REG_P (SUBREG_REG (dest)))\n     {\n       dest_regno = REGNO (SUBREG_REG (dest));\n \n@@ -1746,7 +1746,7 @@ reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *regs_set)\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   regno = REGNO (reg);\n@@ -1841,7 +1841,7 @@ build_insn_chain (rtx first)\n \n \t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t    && GET_CODE (XEXP (link, 0)) == REG)\n+\t\t    && REG_P (XEXP (link, 0)))\n \t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)),\n \t\t\t    c);\n \n@@ -1863,7 +1863,7 @@ build_insn_chain (rtx first)\n \n \t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_UNUSED\n-\t\t    && GET_CODE (XEXP (link, 0)) == REG)\n+\t\t    && REG_P (XEXP (link, 0)))\n \t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)),\n \t\t\t    c);\n \t    }\n@@ -2074,7 +2074,7 @@ mark_reg_change (rtx reg, rtx setter, void *data)\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   regno = REGNO (reg);"}, {"sha": "e3c819c3ea5f1fbe5c2629d8acb386da24192e38", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -307,7 +307,7 @@ static int may_trap_exp (rtx, int);\n \n /* Nonzero iff the address is comprised from at most 1 register.  */\n #define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n-  (GET_CODE (x) == REG\t\t\t\t\t\\\n+  (REG_P (x)\t\t\t\t\t\\\n    || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\t\\\n \t|| (GET_CODE (x) == LO_SUM))\t\t\t\\\n        && (CONSTANT_P (XEXP (x, 0))\t\t\t\\\n@@ -1685,7 +1685,7 @@ find_set_reg_weight (rtx x)\n   if (GET_CODE (x) == SET\n       && register_operand (SET_DEST (x), VOIDmode))\n     {\n-      if (GET_CODE (SET_DEST (x)) == REG)\n+      if (REG_P (SET_DEST (x)))\n \t{\n \t  if (!reg_mentioned_p (SET_DEST (x), SET_SRC (x)))\n \t    return 1;"}, {"sha": "270cc59b2047ca8a4db5d0b42298da06aa8b8305", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1969,7 +1969,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   /* Only operate on register destinations, and even then avoid extending\n      the lifetime of hard registers on small register class machines.  */\n   orig_x = x;\n-  if (GET_CODE (x) != REG\n+  if (!REG_P (x)\n       || (SMALL_REGISTER_CLASSES\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER))\n     {"}, {"sha": "df2c8234ba28e350dfdc3fadc308b48b3be16072", "filename": "gcc/integrate.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -558,7 +558,7 @@ copy_rtx_and_substitute (rtx orig, struct inline_remap *map, int for_lhs)\n \t  equiv_loc = VARRAY_CONST_EQUIV (map->const_equiv_varray,\n \t\t\t\t\t  REGNO (equiv_reg)).rtx;\n \t  loc_offset\n-\t    = GET_CODE (equiv_loc) == REG ? 0 : INTVAL (XEXP (equiv_loc, 1));\n+\t    = REG_P (equiv_loc) ? 0 : INTVAL (XEXP (equiv_loc, 1));\n \n \t  return gen_rtx_SET (VOIDmode, SET_DEST (orig),\n \t\t\t      force_operand\n@@ -691,7 +691,7 @@ try_constants (rtx insn, struct inline_remap *map)\n   /* Set up any constant equivalences made in this insn.  */\n   for (i = 0; i < map->num_sets; i++)\n     {\n-      if (GET_CODE (map->equiv_sets[i].dest) == REG)\n+      if (REG_P (map->equiv_sets[i].dest))\n \t{\n \t  int regno = REGNO (map->equiv_sets[i].dest);\n \n@@ -792,7 +792,7 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n \t be a special hack and we don't know how to treat it specially.\n \t Consider for example mulsidi3 in m68k.md.\n \t Ordinary SUBREG of a REG needs this special treatment.  */\n-      if (! memonly && GET_CODE (SUBREG_REG (x)) == REG)\n+      if (! memonly && REG_P (SUBREG_REG (x)))\n \t{\n \t  rtx inner = SUBREG_REG (x);\n \t  rtx new = 0;\n@@ -885,11 +885,11 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n \t/* If storing a recognizable value save it for later recording.  */\n \tif ((map->num_sets < MAX_RECOG_OPERANDS)\n \t    && (CONSTANT_P (src)\n-\t\t|| (GET_CODE (src) == REG\n+\t\t|| (REG_P (src)\n \t\t    && (REGNO (src) == VIRTUAL_INCOMING_ARGS_REGNUM\n \t\t\t|| REGNO (src) == VIRTUAL_STACK_VARS_REGNUM))\n \t\t|| (GET_CODE (src) == PLUS\n-\t\t    && GET_CODE (XEXP (src, 0)) == REG\n+\t\t    && REG_P (XEXP (src, 0))\n \t\t    && (REGNO (XEXP (src, 0)) == VIRTUAL_INCOMING_ARGS_REGNUM\n \t\t\t|| REGNO (XEXP (src, 0)) == VIRTUAL_STACK_VARS_REGNUM)\n \t\t    && CONSTANT_P (XEXP (src, 1)))\n@@ -1062,9 +1062,9 @@ mark_stores (rtx dest, rtx x ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n   /* DEST is always the innermost thing set, except in the case of\n      SUBREGs of hard registers.  */\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     regno = REGNO (dest), mode = GET_MODE (dest);\n-  else if (GET_CODE (dest) == SUBREG && GET_CODE (SUBREG_REG (dest)) == REG)\n+  else if (GET_CODE (dest) == SUBREG && REG_P (SUBREG_REG (dest)))\n     {\n       regno = REGNO (SUBREG_REG (dest));\n       if (regno < FIRST_PSEUDO_REGISTER)\n@@ -1324,7 +1324,7 @@ allocate_initial_values (rtx *reg_equiv_memory_loc ATTRIBUTE_UNUSED)\n \t; /* Do nothing.  */\n       else if (GET_CODE (x) == MEM)\n \treg_equiv_memory_loc[regno] = x;\n-      else if (GET_CODE (x) == REG)\n+      else if (REG_P (x))\n \t{\n \t  reg_renumber[regno] = REGNO (x);\n \t  /* Poke the regno right into regno_reg_rtx"}, {"sha": "c69a4894b6316c60882d61b4343df248529c8e11", "filename": "gcc/jump.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1237,7 +1237,7 @@ delete_prior_computation (rtx note, rtx insn)\n \t\tdelete_computation (our_prev);\n \t    }\n \t  else if (GET_CODE (pat) == SET\n-\t\t   && GET_CODE (SET_DEST (pat)) == REG)\n+\t\t   && REG_P (SET_DEST (pat)))\n \t    {\n \t      int dest_regno = REGNO (SET_DEST (pat));\n \t      int dest_endregno\n@@ -1340,7 +1340,7 @@ delete_computation (rtx insn)\n \n       if (REG_NOTE_KIND (note) != REG_DEAD\n \t  /* Verify that the REG_NOTE is legitimate.  */\n-\t  || GET_CODE (XEXP (note, 0)) != REG)\n+\t  || !REG_P (XEXP (note, 0)))\n \tcontinue;\n \n       delete_prior_computation (note, insn);\n@@ -1815,9 +1815,9 @@ rtx_renumbered_equal_p (rtx x, rtx y)\n   if (x == y)\n     return 1;\n \n-  if ((code == REG || (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG))\n-      && (GET_CODE (y) == REG || (GET_CODE (y) == SUBREG\n-\t\t\t\t  && GET_CODE (SUBREG_REG (y)) == REG)))\n+  if ((code == REG || (code == SUBREG && REG_P (SUBREG_REG (x))))\n+      && (REG_P (y) || (GET_CODE (y) == SUBREG\n+\t\t\t\t  && REG_P (SUBREG_REG (y)))))\n     {\n       int reg_x = -1, reg_y = -1;\n       int byte_x = 0, byte_y = 0;\n@@ -1994,7 +1994,7 @@ rtx_renumbered_equal_p (rtx x, rtx y)\n int\n true_regnum (rtx x)\n {\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       if (REGNO (x) >= FIRST_PSEUDO_REGISTER && reg_renumber[REGNO (x)] >= 0)\n \treturn reg_renumber[REGNO (x)];"}, {"sha": "ce91d984c5ab3c54ae558f26aabbdbd22b447dc7", "filename": "gcc/lcm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -927,7 +927,7 @@ reg_dies (rtx reg, HARD_REG_SET live)\n {\n   int regno, nregs;\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   regno = REGNO (reg);\n@@ -948,7 +948,7 @@ reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *live)\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   regno = REGNO (reg);"}, {"sha": "e69fb2492b2e44dcb460d598962811ec03070ece", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -448,7 +448,7 @@ static void\n validate_equiv_mem_from_store (rtx dest, rtx set ATTRIBUTE_UNUSED,\n \t\t\t       void *data ATTRIBUTE_UNUSED)\n {\n-  if ((GET_CODE (dest) == REG\n+  if ((REG_P (dest)\n        && reg_overlap_mentioned_p (dest, equiv_mem))\n       || (GET_CODE (dest) == MEM\n \t  && true_dependence (dest, VOIDmode, equiv_mem, rtx_varies_p)))\n@@ -498,7 +498,7 @@ validate_equiv_mem (rtx start, rtx reg, rtx memref)\n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \tif ((REG_NOTE_KIND (note) == REG_INC\n \t     || REG_NOTE_KIND (note) == REG_DEAD)\n-\t    && GET_CODE (XEXP (note, 0)) == REG\n+\t    && REG_P (XEXP (note, 0))\n \t    && reg_overlap_mentioned_p (XEXP (note, 0), memref))\n \t  return 0;\n     }\n@@ -849,7 +849,7 @@ update_equiv_regs (void)\n \t     Equivalences to MEMs should be made in another pass, after the\n \t     reg_equiv[].replace information has been gathered.  */\n \n-\t  if (GET_CODE (dest) == MEM && GET_CODE (src) == REG\n+\t  if (MEM_P (dest) && REG_P (src)\n \t      && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n \t      && REG_BASIC_BLOCK (regno) >= 0\n \t      && REG_N_SETS (regno) == 1\n@@ -878,7 +878,7 @@ update_equiv_regs (void)\n \t     preferred class of a pseudo depends on all instructions that set\n \t     or use it.  */\n \n-\t  if (GET_CODE (dest) != REG\n+\t  if (!REG_P (dest)\n \t      || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n \t      || reg_equiv[regno].init_insns == const0_rtx\n \t      || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n@@ -1155,7 +1155,7 @@ no_equiv (rtx reg, rtx store ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n   int regno;\n   rtx list;\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n   regno = REGNO (reg);\n   list = reg_equiv[regno].init_insns;\n@@ -1308,14 +1308,14 @@ block_alloc (int b)\n \t\t  hard_reg = get_hard_reg_initial_reg (cfun, r1);\n \t\t  if (hard_reg != NULL_RTX)\n \t\t    {\n-\t\t      if (GET_CODE (hard_reg) == REG\n+\t\t      if (REG_P (hard_reg)\n \t\t\t  && IN_RANGE (REGNO (hard_reg),\n \t\t\t\t       0, FIRST_PSEUDO_REGISTER - 1)\n \t\t\t  && ! call_used_regs[REGNO (hard_reg)])\n \t\t\tcontinue;\n \t\t    }\n \n-\t\t  if (GET_CODE (r0) == REG || GET_CODE (r0) == SUBREG)\n+\t\t  if (REG_P (r0) || GET_CODE (r0) == SUBREG)\n \t\t    {\n \t\t      /* We have two priorities for hard register preferences.\n \t\t\t If we have a move insn or an insn whose first input\n@@ -1324,7 +1324,7 @@ block_alloc (int b)\n \t\t      int may_save_copy\n \t\t\t= (r1 == recog_data.operand[i] && must_match_0 >= 0);\n \n-\t\t      if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n+\t\t      if (REG_P (r1) || GET_CODE (r1) == SUBREG)\n \t\t\twin = combine_regs (r1, r0, may_save_copy,\n \t\t\t\t\t    insn_number, insn, 0);\n \t\t    }\n@@ -1350,7 +1350,7 @@ block_alloc (int b)\n \t  if (optimize\n \t      && GET_CODE (PATTERN (insn)) == CLOBBER\n \t      && (r0 = XEXP (PATTERN (insn), 0),\n-\t\t  GET_CODE (r0) == REG)\n+\t\t  REG_P (r0))\n \t      && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n \t      && XEXP (link, 0) != 0\n \t      && GET_CODE (XEXP (link, 0)) == INSN\n@@ -1359,21 +1359,21 @@ block_alloc (int b)\n \t      && (note = find_reg_note (XEXP (link, 0), REG_EQUAL,\n \t\t\t\t\tNULL_RTX)) != 0)\n \t    {\n-\t      if (r1 = XEXP (note, 0), GET_CODE (r1) == REG\n+\t      if (r1 = XEXP (note, 0), REG_P (r1)\n \t\t  /* Check that we have such a sequence.  */\n \t\t  && no_conflict_p (insn, r0, r1))\n \t\twin = combine_regs (r1, r0, 1, insn_number, insn, 1);\n \t      else if (GET_RTX_FORMAT (GET_CODE (XEXP (note, 0)))[0] == 'e'\n \t\t       && (r1 = XEXP (XEXP (note, 0), 0),\n-\t\t\t   GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n+\t\t\t   REG_P (r1) || GET_CODE (r1) == SUBREG)\n \t\t       && no_conflict_p (insn, r0, r1))\n \t\twin = combine_regs (r1, r0, 0, insn_number, insn, 1);\n \n \t      /* Here we care if the operation to be computed is\n \t\t commutative.  */\n \t      else if (COMMUTATIVE_P (XEXP (note, 0))\n \t\t       && (r1 = XEXP (XEXP (note, 0), 1),\n-\t\t\t   (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG))\n+\t\t\t   (REG_P (r1) || GET_CODE (r1) == SUBREG))\n \t\t       && no_conflict_p (insn, r0, r1))\n \t\twin = combine_regs (r1, r0, 0, insn_number, insn, 1);\n \n@@ -1400,7 +1400,7 @@ block_alloc (int b)\n \n \t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t    if (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t&& GET_CODE (XEXP (link, 0)) == REG\n+\t\t&& REG_P (XEXP (link, 0))\n \t\t&& combined_regno != (int) REGNO (XEXP (link, 0))\n \t\t&& (no_conflict_combined_regno != (int) REGNO (XEXP (link, 0))\n \t\t    || ! find_reg_note (insn, REG_NO_CONFLICT,\n@@ -1421,7 +1421,7 @@ block_alloc (int b)\n \n \t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t    if (REG_NOTE_KIND (link) == REG_UNUSED\n-\t\t&& GET_CODE (XEXP (link, 0)) == REG)\n+\t\t&& REG_P (XEXP (link, 0)))\n \t      wipe_dead_reg (XEXP (link, 0), 1);\n \n \t  /* If this is an insn that has a REG_RETVAL note pointing at a\n@@ -1753,7 +1753,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n     {\n       rtx subreg = SUBREG_REG (usedreg);\n \n-      if (GET_CODE (subreg) == REG)\n+      if (REG_P (subreg))\n \t{\n \t  if (GET_MODE_SIZE (GET_MODE (subreg)) > UNITS_PER_WORD)\n \t    may_save_copy = 0;\n@@ -1771,7 +1771,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n       usedreg = subreg;\n     }\n \n-  if (GET_CODE (usedreg) != REG)\n+  if (!REG_P (usedreg))\n     return 0;\n \n   ureg = REGNO (usedreg);\n@@ -1786,7 +1786,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n     {\n       rtx subreg = SUBREG_REG (setreg);\n \n-      if (GET_CODE (subreg) == REG)\n+      if (REG_P (subreg))\n \t{\n \t  if (GET_MODE_SIZE (GET_MODE (subreg)) > UNITS_PER_WORD)\n \t    may_save_copy = 0;\n@@ -1804,7 +1804,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n       setreg = subreg;\n     }\n \n-  if (GET_CODE (setreg) != REG)\n+  if (!REG_P (setreg))\n     return 0;\n \n   sreg = REGNO (setreg);\n@@ -1984,7 +1984,7 @@ reg_is_set (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n      a hard register.  These may actually not exist any more.  */\n \n   if (GET_CODE (reg) != SUBREG\n-      && GET_CODE (reg) != REG)\n+      && !REG_P (reg))\n     return;\n \n   /* Mark this register as being born.  If it is used in a CLOBBER, mark\n@@ -2060,7 +2060,7 @@ wipe_dead_reg (rtx reg, int output_p)\n \t{\n \t  rtx set = XVECEXP (PATTERN (this_insn), 0, i);\n \t  if (GET_CODE (set) == SET\n-\t      && GET_CODE (SET_DEST (set)) != REG\n+\t      && !REG_P (SET_DEST (set))\n \t      && !rtx_equal_p (reg, SET_DEST (set))\n \t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n \t    output_p = 1;\n@@ -2310,8 +2310,8 @@ no_conflict_p (rtx insn, rtx r0 ATTRIBUTE_UNUSED, rtx r1)\n      when we scan the insns that actually use it.  */\n \n   if (note == 0\n-      || (GET_CODE (r1) == REG && REGNO (r1) < FIRST_PSEUDO_REGISTER)\n-      || (GET_CODE (r1) == SUBREG && GET_CODE (SUBREG_REG (r1)) == REG\n+      || (REG_P (r1) && REGNO (r1) < FIRST_PSEUDO_REGISTER)\n+      || (GET_CODE (r1) == SUBREG && REG_P (SUBREG_REG (r1))\n \t  && REGNO (SUBREG_REG (r1)) < FIRST_PSEUDO_REGISTER))\n     return 0;\n "}, {"sha": "0093743c1051b1be48d5c9a2acebef14f6aeac4f", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1321,7 +1321,7 @@ simplify_using_assignment (rtx insn, rtx *expr, regset altered)\n   if (set)\n     {\n       lhs = SET_DEST (set);\n-      if (GET_CODE (lhs) != REG\n+      if (!REG_P (lhs)\n \t  || altered_reg_used (&lhs, altered))\n \tret = true;\n     }"}, {"sha": "fd0c0d6435447f02b5dc6170fe37c709b8671dea", "filename": "gcc/loop.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -772,7 +772,7 @@ scan_loop (struct loop *loop, int flags)\n \t    in_libcall++;\n \t  if (! in_libcall\n \t      && (set = single_set (p))\n-\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REG_P (SET_DEST (set))\n #ifdef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n \t      && SET_DEST (set) != pic_offset_table_rtx\n #endif\n@@ -877,7 +877,7 @@ scan_loop (struct loop *loop, int flags)\n \t      else if (insert_temp\n \t\t       && (optimize_size\n \t\t\t   || ! can_copy_p (GET_MODE (SET_SRC (set)))\n-\t\t\t   || GET_CODE (SET_SRC (set)) == REG\n+\t\t\t   || REG_P (SET_SRC (set))\n \t\t\t   || (CONSTANT_P (SET_SRC (set))\n \t\t\t       && LEGITIMATE_CONSTANT_P (SET_SRC (set)))))\n \t\t;\n@@ -928,7 +928,7 @@ scan_loop (struct loop *loop, int flags)\n \t\t      && ! side_effects_p (SET_SRC (set))\n \t\t      && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n \t\t      && (! SMALL_REGISTER_CLASSES\n-\t\t\t  || (! (GET_CODE (SET_SRC (set)) == REG\n+\t\t\t  || (! (REG_P (SET_SRC (set))\n \t\t\t\t && (REGNO (SET_SRC (set))\n \t\t\t\t     < FIRST_PSEUDO_REGISTER))))\n \t\t      /* This test is not redundant; SET_SRC (set) might be\n@@ -1542,7 +1542,7 @@ combine_movables (struct loop_movables *movables, struct loop_regs *regs)\n \t\t\t&& (GET_MODE_BITSIZE (GET_MODE (m->set_dest))\n \t\t\t    >= GET_MODE_BITSIZE (GET_MODE (m1->set_dest)))))\n \t\t   /* See if the source of M1 says it matches M.  */\n-\t\t   && ((GET_CODE (m1->set_src) == REG\n+\t\t   && ((REG_P (m1->set_src)\n \t\t\t&& matched_regs[REGNO (m1->set_src)])\n \t\t       || rtx_equal_for_loop_p (m->set_src, m1->set_src,\n \t\t\t\t\t\tmovables, regs))))\n@@ -1677,15 +1677,15 @@ rtx_equal_for_loop_p (rtx x, rtx y, struct loop_movables *movables,\n \n   /* If we have a register and a constant, they may sometimes be\n      equal.  */\n-  if (GET_CODE (x) == REG && regs->array[REGNO (x)].set_in_loop == -2\n+  if (REG_P (x) && regs->array[REGNO (x)].set_in_loop == -2\n       && CONSTANT_P (y))\n     {\n       for (m = movables->head; m; m = m->next)\n \tif (m->move_insn && m->regno == REGNO (x)\n \t    && rtx_equal_p (m->set_src, y))\n \t  return 1;\n     }\n-  else if (GET_CODE (y) == REG && regs->array[REGNO (y)].set_in_loop == -2\n+  else if (REG_P (y) && regs->array[REGNO (y)].set_in_loop == -2\n \t   && CONSTANT_P (x))\n     {\n       for (m = movables->head; m; m = m->next)\n@@ -2078,12 +2078,12 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t\t redundant stores that we have created.  */\n \t\t\t      if (GET_CODE (next) == CALL_INSN\n \t\t\t\t  && GET_CODE (body) == SET\n-\t\t\t\t  && GET_CODE (SET_DEST (body)) == REG\n+\t\t\t\t  && REG_P (SET_DEST (body))\n \t\t\t\t  && (n = find_reg_note (temp, REG_EQUAL,\n \t\t\t\t\t\t\t NULL_RTX)))\n \t\t\t\t{\n \t\t\t\t  fn_reg = SET_SRC (body);\n-\t\t\t\t  if (GET_CODE (fn_reg) != REG)\n+\t\t\t\t  if (!REG_P (fn_reg))\n \t\t\t\t    fn_reg = SET_DEST (body);\n \t\t\t\t  fn_address = XEXP (n, 0);\n \t\t\t\t  fn_address_insn = temp;\n@@ -3273,7 +3273,7 @@ note_set_pseudo_multiple_uses (rtx x, rtx y ATTRIBUTE_UNUSED, void *data)\n \t || GET_CODE (x) == SUBREG)\n     x = XEXP (x, 0);\n \n-  if (GET_CODE (x) != REG || REGNO (x) < FIRST_PSEUDO_REGISTER)\n+  if (!REG_P (x) || REGNO (x) < FIRST_PSEUDO_REGISTER)\n     return;\n \n   /* If we do not have usage information, or if we know the register\n@@ -3470,7 +3470,7 @@ consec_sets_invariant_p (const struct loop *loop, rtx reg, int n_sets,\n       this = 0;\n       if (code == INSN\n \t  && (set = single_set (p))\n-\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) == regno)\n \t{\n \t  this = loop_invariant_p (loop, SET_SRC (set));\n@@ -3525,7 +3525,7 @@ find_single_use_in_loop (struct loop_regs *regs, rtx insn, rtx x)\n \t in SET_DEST because if a register is partially modified, it won't\n \t show up as a potential movable so we don't care how USAGE is set\n \t for it.  */\n-      if (GET_CODE (SET_DEST (x)) != REG)\n+      if (!REG_P (SET_DEST (x)))\n \tfind_single_use_in_loop (regs, insn, SET_DEST (x));\n       find_single_use_in_loop (regs, insn, SET_SRC (x));\n     }\n@@ -3547,7 +3547,7 @@ find_single_use_in_loop (struct loop_regs *regs, rtx insn, rtx x)\n static void\n count_one_set (struct loop_regs *regs, rtx insn, rtx x, rtx *last_set)\n {\n-  if (GET_CODE (x) == CLOBBER && GET_CODE (XEXP (x, 0)) == REG)\n+  if (GET_CODE (x) == CLOBBER && REG_P (XEXP (x, 0)))\n     /* Don't move a reg that has an explicit clobber.\n        It's not worth the pain to try to do it correctly.  */\n     regs->array[REGNO (XEXP (x, 0))].may_not_optimize = 1;\n@@ -3560,7 +3560,7 @@ count_one_set (struct loop_regs *regs, rtx insn, rtx x, rtx *last_set)\n \t     || GET_CODE (dest) == SIGN_EXTRACT\n \t     || GET_CODE (dest) == STRICT_LOW_PART)\n \tdest = XEXP (dest, 0);\n-      if (GET_CODE (dest) == REG)\n+      if (REG_P (dest))\n \t{\n \t  int i;\n \t  int regno = REGNO (dest);\n@@ -4517,7 +4517,7 @@ loop_bivs_init_find (struct loop *loop)\n \t  && JUMP_LABEL (p) != 0\n \t  && next_real_insn (JUMP_LABEL (p)) == next_real_insn (loop->end)\n \t  && (test = get_condition_for_loop (loop, p)) != 0\n-\t  && GET_CODE (XEXP (test, 0)) == REG\n+\t  && REG_P (XEXP (test, 0))\n \t  && REGNO (XEXP (test, 0)) < max_reg_before_loop\n \t  && (bl = REG_IV_CLASS (ivs, REGNO (XEXP (test, 0)))) != 0\n \t  && valid_initial_value_p (XEXP (test, 1), p, call_seen, loop->start)\n@@ -4864,12 +4864,12 @@ loop_givs_rescan (struct loop *loop, struct iv_class *bl, rtx *reg_map)\n \t computational information.  If not, and this is a DEST_ADDR\n \t giv, at least we know that it's a pointer, though we don't know\n \t the alignment.  */\n-      if (GET_CODE (v->new_reg) == REG\n+      if (REG_P (v->new_reg)\n \t  && v->giv_type == DEST_REG\n \t  && REG_POINTER (v->dest_reg))\n \tmark_reg_pointer (v->new_reg,\n \t\t\t  REGNO_POINTER_ALIGN (REGNO (v->dest_reg)));\n-      else if (GET_CODE (v->new_reg) == REG\n+      else if (REG_P (v->new_reg)\n \t       && REG_POINTER (v->src_reg))\n \t{\n \t  unsigned int align = REGNO_POINTER_ALIGN (REGNO (v->src_reg));\n@@ -4881,8 +4881,8 @@ loop_givs_rescan (struct loop *loop, struct iv_class *bl, rtx *reg_map)\n \n \t  mark_reg_pointer (v->new_reg, align);\n \t}\n-      else if (GET_CODE (v->new_reg) == REG\n-\t       && GET_CODE (v->add_val) == REG\n+      else if (REG_P (v->new_reg)\n+\t       && REG_P (v->add_val)\n \t       && REG_POINTER (v->add_val))\n \t{\n \t  unsigned int align = REGNO_POINTER_ALIGN (REGNO (v->add_val));\n@@ -4893,7 +4893,7 @@ loop_givs_rescan (struct loop *loop, struct iv_class *bl, rtx *reg_map)\n \n \t  mark_reg_pointer (v->new_reg, align);\n \t}\n-      else if (GET_CODE (v->new_reg) == REG && v->giv_type == DEST_ADDR)\n+      else if (REG_P (v->new_reg) && v->giv_type == DEST_ADDR)\n \tmark_reg_pointer (v->new_reg, 0);\n \n       if (v->giv_type == DEST_ADDR)\n@@ -5374,7 +5374,7 @@ check_insn_for_bivs (struct loop *loop, rtx p, int not_every_iteration,\n \n   if (GET_CODE (p) == INSN\n       && (set = single_set (p))\n-      && GET_CODE (SET_DEST (set)) == REG)\n+      && REG_P (SET_DEST (set)))\n     {\n       dest_reg = SET_DEST (set);\n       if (REGNO (dest_reg) < max_reg_before_loop\n@@ -5415,7 +5415,7 @@ check_insn_for_givs (struct loop *loop, rtx p, int not_every_iteration,\n   /* Look for a general induction variable in a register.  */\n   if (GET_CODE (p) == INSN\n       && (set = single_set (p))\n-      && GET_CODE (SET_DEST (set)) == REG\n+      && REG_P (SET_DEST (set))\n       && ! regs->array[REGNO (SET_DEST (set))].may_not_optimize)\n     {\n       rtx src_reg;\n@@ -5498,7 +5498,7 @@ valid_initial_value_p (rtx x, rtx insn, int call_seen, rtx loop_start)\n \n   /* Only consider pseudos we know about initialized in insns whose luids\n      we know.  */\n-  if (GET_CODE (x) != REG\n+  if (!REG_P (x)\n       || REGNO (x) >= max_reg_before_loop)\n     return 0;\n \n@@ -6580,9 +6580,9 @@ simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n \n       /* Each argument must be either REG, PLUS, or MULT.  Convert REG to\n \t MULT to reduce cases.  */\n-      if (GET_CODE (arg0) == REG)\n+      if (REG_P (arg0))\n \targ0 = gen_rtx_MULT (mode, arg0, const1_rtx);\n-      if (GET_CODE (arg1) == REG)\n+      if (REG_P (arg1))\n \targ1 = gen_rtx_MULT (mode, arg1, const1_rtx);\n \n       /* Now have PLUS + PLUS, PLUS + MULT, MULT + PLUS, or MULT + MULT.\n@@ -6759,7 +6759,7 @@ simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n       if (*ext_val == NULL_RTX)\n \t{\n \t  arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);\n-\t  if (arg0 && *ext_val == NULL_RTX && GET_CODE (arg0) == REG)\n+\t  if (arg0 && *ext_val == NULL_RTX && REG_P (arg0))\n \t    {\n \t      *ext_val = gen_rtx_fmt_e (GET_CODE (x), mode, arg0);\n \t      return arg0;\n@@ -7038,7 +7038,7 @@ consec_sets_giv (const struct loop *loop, int first_benefit, rtx p,\n \n       if (code == INSN\n \t  && (set = single_set (p))\n-\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REG_P (SET_DEST (set))\n \t  && SET_DEST (set) == dest_reg\n \t  && (general_induction_var (loop, SET_SRC (set), &src_reg,\n \t\t\t\t     add_val, mult_val, ext_val, 0,\n@@ -7759,7 +7759,7 @@ loop_regs_update (const struct loop *loop ATTRIBUTE_UNUSED, rtx seq)\n     {\n       rtx set = single_set (insn);\n \n-      if (set && GET_CODE (SET_DEST (set)) == REG)\n+      if (set && REG_P (SET_DEST (set)))\n \trecord_base_value (REGNO (SET_DEST (set)), SET_SRC (set), 0);\n \n       insn = NEXT_INSN (insn);\n@@ -8144,7 +8144,7 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \t      {\n \t\trtx set = single_set (p);\n \n-\t\tif (set && GET_CODE (SET_DEST (set)) == REG\n+\t\tif (set && REG_P (SET_DEST (set))\n \t\t    && REGNO (SET_DEST (set)) == bl->regno)\n \t\t  /* An insn that sets the biv is okay.  */\n \t\t  ;\n@@ -8525,7 +8525,7 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \t\t    /* If this is a set of a GIV based on the reversed biv, any\n \t\t       REG_EQUAL notes should still be correct.  */\n \t\t    if (! set\n-\t\t\t|| GET_CODE (SET_DEST (set)) != REG\n+\t\t\t|| !REG_P (SET_DEST (set))\n \t\t\t|| (size_t) REGNO (SET_DEST (set)) >= ivs->n_regs\n \t\t\t|| REG_IV_TYPE (ivs, REGNO (SET_DEST (set))) != GENERAL_INDUCT\n \t\t\t|| REG_IV_INFO (ivs, REGNO (SET_DEST (set)))->src_reg != bl->biv->src_reg)\n@@ -8600,7 +8600,7 @@ maybe_eliminate_biv (const struct loop *loop, struct iv_class *bl,\n \t      rtx last = XEXP (note, 0);\n \t      rtx set = single_set (last);\n \n-\t      if (set && GET_CODE (SET_DEST (set)) == REG)\n+\t      if (set && REG_P (SET_DEST (set)))\n \t\t{\n \t\t  unsigned int regno = REGNO (SET_DEST (set));\n \n@@ -8794,7 +8794,7 @@ maybe_eliminate_biv_1 (const struct loop *loop, rtx x, rtx insn,\n \t\t&& (GET_CODE (v->add_val) == SYMBOL_REF\n \t\t    || GET_CODE (v->add_val) == LABEL_REF\n \t\t    || GET_CODE (v->add_val) == CONST\n-\t\t    || (GET_CODE (v->add_val) == REG\n+\t\t    || (REG_P (v->add_val)\n \t\t\t&& REG_POINTER (v->add_val))))\n \t      {\n \t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n@@ -8859,7 +8859,7 @@ maybe_eliminate_biv_1 (const struct loop *loop, rtx x, rtx insn,\n \t\t&& (GET_CODE (v->add_val) == SYMBOL_REF\n \t\t    || GET_CODE (v->add_val) == LABEL_REF\n \t\t    || GET_CODE (v->add_val) == CONST\n-\t\t    || (GET_CODE (v->add_val) == REG\n+\t\t    || (REG_P (v->add_val)\n \t\t\t&& REG_POINTER (v->add_val)))\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode)\n@@ -8948,7 +8948,7 @@ maybe_eliminate_biv_1 (const struct loop *loop, rtx x, rtx insn,\n \t\t  return 1;\n \t      }\n \t}\n-      else if (GET_CODE (arg) == REG || GET_CODE (arg) == MEM)\n+      else if (REG_P (arg) || GET_CODE (arg) == MEM)\n \t{\n \t  if (loop_invariant_p (loop, arg) == 1)\n \t    {\n@@ -9000,7 +9000,7 @@ maybe_eliminate_biv_1 (const struct loop *loop, rtx x, rtx insn,\n \n #if 0\n \t  /* Otherwise the reg compared with had better be a biv.  */\n-\t  if (GET_CODE (arg) != REG\n+\t  if (!REG_P (arg)\n \t      || REG_IV_TYPE (ivs, REGNO (arg)) != BASIC_INDUCT)\n \t    return 0;\n \n@@ -9102,7 +9102,7 @@ record_initial (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n   struct loop_ivs *ivs = (struct loop_ivs *) data;\n   struct iv_class *bl;\n \n-  if (GET_CODE (dest) != REG\n+  if (!REG_P (dest)\n       || REGNO (dest) >= ivs->n_regs\n       || REG_IV_TYPE (ivs, REGNO (dest)) != BASIC_INDUCT)\n     return;\n@@ -9131,7 +9131,7 @@ update_reg_last_use (rtx x, rtx insn)\n      and hence this insn will never be the last use of x.\n      ???? This comment is not correct.  See for example loop_givs_reduce.\n      This may insert an insn before another new insn.  */\n-  if (GET_CODE (x) == REG && REGNO (x) < max_reg_before_loop\n+  if (REG_P (x) && REGNO (x) < max_reg_before_loop\n       && INSN_UID (insn) < max_uid_for_loop\n       && REGNO_LAST_LUID (REGNO (x)) < INSN_LUID (insn))\n     {\n@@ -9239,7 +9239,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t  op0 = XEXP (op0, 0);\n \t  continue;\n \t}\n-      else if (GET_CODE (op0) != REG)\n+      else if (!REG_P (op0))\n \tbreak;\n \n       /* Go back to the previous insn.  Stop if it is not an INSN.  We also\n@@ -9655,7 +9655,7 @@ loop_regs_scan (const struct loop *loop, int extra_size)\n \t      rtx op, reg;\n \n \t      if (GET_CODE (op = XEXP (link, 0)) == USE\n-\t\t  && GET_CODE (reg = XEXP (op, 0)) == REG\n+\t\t  && REG_P (reg = XEXP (op, 0))\n \t\t  && rtx_varies_p (reg, 1))\n \t\tregs->array[REGNO (reg)].may_not_optimize = 1;\n \t    }\n@@ -9889,7 +9889,7 @@ load_mems (const struct loop *loop)\n \t      if (set\n \t\t  /* @@@ This test is _way_ too conservative.  */\n \t\t  && ! maybe_never\n-\t\t  && GET_CODE (SET_DEST (set)) == REG\n+\t\t  && REG_P (SET_DEST (set))\n \t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t\t  && REGNO (SET_DEST (set)) < last_max_reg\n \t\t  && regs->array[REGNO (SET_DEST (set))].n_times_set == 1\n@@ -9903,7 +9903,7 @@ load_mems (const struct loop *loop)\n \t\t to untangle things for the BIV detection code.  */\n \t      if (set\n \t\t  && ! maybe_never\n-\t\t  && GET_CODE (SET_SRC (set)) == REG\n+\t\t  && REG_P (SET_SRC (set))\n \t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n \t\t  && REGNO (SET_SRC (set)) < last_max_reg\n \t\t  && regs->array[REGNO (SET_SRC (set))].n_times_set == 1\n@@ -9954,7 +9954,7 @@ load_mems (const struct loop *loop)\n \t\t{\n \t\t  if (CONSTANT_P (equiv->loc))\n \t\t    const_equiv = equiv;\n-\t\t  else if (GET_CODE (equiv->loc) == REG\n+\t\t  else if (REG_P (equiv->loc)\n \t\t\t   /* Extending hard register lifetimes causes crash\n \t\t\t      on SRC targets.  Doing so on non-SRC is\n \t\t\t      probably also not good idea, since we most\n@@ -10098,7 +10098,7 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n       /* Is this the initializing insn?  */\n       set = single_set (insn);\n       if (set\n-\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) == regno)\n \t{\n \t  if (init_insn)\n@@ -10208,9 +10208,9 @@ try_swap_copy_prop (const struct loop *loop, rtx replacement,\n       /* Search for the insn that copies REGNO to NEW_REGNO?  */\n       if (INSN_P (insn)\n \t  && (set = single_set (insn))\n-\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) == new_regno\n-\t  && GET_CODE (SET_SRC (set)) == REG\n+\t  && REG_P (SET_SRC (set))\n \t  && REGNO (SET_SRC (set)) == regno)\n \tbreak;\n     }\n@@ -10228,7 +10228,7 @@ try_swap_copy_prop (const struct loop *loop, rtx replacement,\n \n       if (INSN_P (insn)\n \t  && (prev_set = single_set (prev_insn))\n-\t  && GET_CODE (SET_DEST (prev_set)) == REG\n+\t  && REG_P (SET_DEST (prev_set))\n \t  && REGNO (SET_DEST (prev_set)) == regno)\n \t{\n \t  /* We have:"}, {"sha": "b059c2f17954b3a37190cff68c6bd6c293c741ed", "filename": "gcc/optabs.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -729,9 +729,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n     {\n       commutative_op = 1;\n \n-      if (((target == 0 || GET_CODE (target) == REG)\n-\t   ? ((GET_CODE (op1) == REG\n-\t       && GET_CODE (op0) != REG)\n+      if (((target == 0 || REG_P (target))\n+\t   ? ((REG_P (op1)\n+\t       && !REG_P (op0))\n \t      || target == op1)\n \t   : rtx_equal_p (op1, target))\n \t  || GET_CODE (op0) == CONST_INT)\n@@ -1225,11 +1225,11 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       xtarget = gen_reg_rtx (mode);\n \n-      if (target == 0 || GET_CODE (target) != REG)\n+      if (target == 0 || !REG_P (target))\n \ttarget = xtarget;\n \n       /* Indicate for flow that the entire target reg is being set.  */\n-      if (GET_CODE (target) == REG)\n+      if (REG_P (target))\n \temit_insn (gen_rtx_CLOBBER (VOIDmode, xtarget));\n \n       /* Do the actual arithmetic.  */\n@@ -1388,7 +1388,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       /* If the target is the same as one of the inputs, don't use it.  This\n \t prevents problems with the REG_EQUAL note.  */\n       if (target == op0 || target == op1\n-\t  || (target != 0 && GET_CODE (target) != REG))\n+\t  || (target != 0 && !REG_P (target)))\n \ttarget = 0;\n \n       /* Multiply the two lower words to get a double-word product.\n@@ -1945,7 +1945,7 @@ expand_vector_binop (enum machine_mode mode, optab binoptab, rtx op0,\n \t     And storing with a SUBREG is only possible for the least\n \t     significant part, hence we can't do it for big endian\n \t     (unless we want to permute the evaluation order.  */\n-\t  if (GET_CODE (target) == REG\n+\t  if (REG_P (target)\n \t      && (BYTES_BIG_ENDIAN\n \t\t  ? subsize < UNITS_PER_WORD\n \t\t  : ((i * subsize) % UNITS_PER_WORD) != 0))\n@@ -2064,7 +2064,7 @@ expand_vector_unop (enum machine_mode mode, optab unoptab, rtx op0,\n \t And storing with a SUBREG is only possible for the least\n \t significant part, hence we can't do it for big endian\n \t (unless we want to permute the evaluation order.  */\n-      if (GET_CODE (target) == REG\n+      if (REG_P (target)\n \t  && (BYTES_BIG_ENDIAN\n \t      ?  subsize < UNITS_PER_WORD\n \t      : ((i * subsize) % UNITS_PER_WORD) != 0))\n@@ -2978,15 +2978,15 @@ expand_abs (enum machine_mode mode, rtx op0, rtx target,\n \n   /* It is safe to use the target if it is the same\n      as the source if this is also a pseudo register */\n-  if (op0 == target && GET_CODE (op0) == REG\n+  if (op0 == target && REG_P (op0)\n       && REGNO (op0) >= FIRST_PSEUDO_REGISTER)\n     safe = 1;\n \n   op1 = gen_label_rtx ();\n   if (target == 0 || ! safe\n       || GET_MODE (target) != mode\n       || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n-      || (GET_CODE (target) == REG\n+      || (REG_P (target)\n \t  && REGNO (target) < FIRST_PSEUDO_REGISTER))\n     target = gen_reg_rtx (mode);\n \n@@ -3288,7 +3288,7 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n {\n   rtx prev, next, first, last, insn;\n \n-  if (GET_CODE (target) != REG || reload_in_progress)\n+  if (!REG_P (target) || reload_in_progress)\n     return emit_insn (insns);\n   else\n     for (insn = insns; insn; insn = NEXT_INSN (insn))\n@@ -3354,11 +3354,11 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n       next = NEXT_INSN (insn);\n       add_insn (insn);\n \n-      if (op1 && GET_CODE (op1) == REG)\n+      if (op1 && REG_P (op1))\n \tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_NO_CONFLICT, op1,\n \t\t\t\t\t      REG_NOTES (insn));\n \n-      if (op0 && GET_CODE (op0) == REG)\n+      if (op0 && REG_P (op0))\n \tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_NO_CONFLICT, op0,\n \t\t\t\t\t      REG_NOTES (insn));\n     }\n@@ -3481,7 +3481,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n \n       next = NEXT_INSN (insn);\n \n-      if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n+      if (set != 0 && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t  && (insn == insns\n \t      || ((! INSN_P(insns)\n@@ -4685,7 +4685,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \n \t      /* Don't use TARGET if it isn't a register, is a hard register,\n \t\t or is the wrong mode.  */\n-\t      if (GET_CODE (target) != REG\n+\t      if (!REG_P (target)\n \t\t  || REGNO (target) < FIRST_PSEUDO_REGISTER\n \t\t  || GET_MODE (target) != fmode)\n \t\ttarget = gen_reg_rtx (fmode);\n@@ -4732,7 +4732,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t unsigned operand, do it in a pseudo-register.  */\n \n       if (GET_MODE (to) != fmode\n-\t  || GET_CODE (to) != REG || REGNO (to) < FIRST_PSEUDO_REGISTER)\n+\t  || !REG_P (to) || REGNO (to) < FIRST_PSEUDO_REGISTER)\n \ttarget = gen_reg_rtx (fmode);\n \n       /* Convert as signed integer to floating.  */"}, {"sha": "58a3735c0018c57dfa242f641442ed0db49f8c6f", "filename": "gcc/postreload.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -235,7 +235,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n   if (GET_CODE (src) == MEM\n       && GET_MODE_BITSIZE (GET_MODE (src)) < BITS_PER_WORD\n       && (extend_op = LOAD_EXTEND_OP (GET_MODE (src))) != NIL\n-      && GET_CODE (SET_DEST (set)) != REG)\n+      && !REG_P (SET_DEST (set)))\n     return 0;\n #endif\n \n@@ -246,7 +246,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n   /* If memory loads are cheaper than register copies, don't change them.  */\n   if (GET_CODE (src) == MEM)\n     old_cost = MEMORY_MOVE_COST (GET_MODE (src), dclass, 1);\n-  else if (GET_CODE (src) == REG)\n+  else if (REG_P (src))\n     old_cost = REGISTER_MOVE_COST (GET_MODE (src),\n \t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);\n   else\n@@ -287,7 +287,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n #endif\n \t  this_cost = rtx_cost (this_rtx, SET);\n \t}\n-      else if (GET_CODE (this_rtx) == REG)\n+      else if (REG_P (this_rtx))\n \t{\n #ifdef LOAD_EXTEND_OP\n \t  if (extend_op != NIL)\n@@ -308,8 +308,8 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \t tends to lead to smaller instructions on some machines.  */\n       if (this_cost < old_cost\n \t  || (this_cost == old_cost\n-\t      && GET_CODE (this_rtx) == REG\n-\t      && GET_CODE (SET_SRC (set)) != REG))\n+\t      && REG_P (this_rtx)\n+\t      && !REG_P (SET_SRC (set))))\n \t{\n #ifdef LOAD_EXTEND_OP\n \t  if (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) < BITS_PER_WORD\n@@ -426,14 +426,14 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n #ifdef CANNOT_CHANGE_MODE_CLASS\n \t  /* If the register cannot change mode to word_mode, it follows that\n \t     it cannot have been used in word_mode.  */\n-\t  else if (GET_CODE (SET_DEST (set)) == REG\n+\t  else if (REG_P (SET_DEST (set))\n \t\t   && CANNOT_CHANGE_MODE_CLASS (GET_MODE (SET_DEST (set)),\n \t\t\t\t\t\tword_mode,\n \t\t\t\t\t\tREGNO_REG_CLASS (REGNO (SET_DEST (set)))))\n \t    ; /* Continue ordinary processing.  */\n #endif\n \t  /* If this is a straight load, make the extension explicit.  */\n-\t  else if (GET_CODE (SET_DEST (set)) == REG\n+\t  else if (REG_P (SET_DEST (set))\n \t\t   && recog_data.n_operands == 2\n \t\t   && SET_SRC (set) == op\n \t\t   && SET_DEST (set) == recog_data.operand[1-i])\n@@ -460,7 +460,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \tcontinue;\n \n       for (l = v->locs; l; l = l->next)\n-\tif (GET_CODE (l->loc) == REG)\n+\tif (REG_P (l->loc))\n \t  SET_HARD_REG_BIT (equiv_regs[i], REGNO (l->loc));\n     }\n \n@@ -779,12 +779,12 @@ reload_combine (void)\n \t does not yet show whether REGY changes in this insn.  */\n       set = single_set (insn);\n       if (set != NULL_RTX\n-\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REG_P (SET_DEST (set))\n \t  && (hard_regno_nregs[REGNO (SET_DEST (set))]\n \t\t\t      [GET_MODE (SET_DEST (set))]\n \t      == 1)\n \t  && GET_CODE (SET_SRC (set)) == PLUS\n-\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == REG\n+\t  && REG_P (XEXP (SET_SRC (set), 1))\n \t  && rtx_equal_p (XEXP (SET_SRC (set), 0), SET_DEST (set))\n \t  && !rtx_equal_p (XEXP (SET_SRC (set), 1), SET_DEST (set))\n \t  && last_label_ruid < reg_state[REGNO (SET_DEST (set))].use_ruid)\n@@ -913,7 +913,7 @@ reload_combine (void)\n \t       link = XEXP (link, 1))\n \t    {\n \t      rtx usage_rtx = XEXP (XEXP (link, 0), 0);\n-\t      if (GET_CODE (usage_rtx) == REG)\n+\t      if (REG_P (usage_rtx))\n \t        {\n \t\t  unsigned int i;\n \t\t  unsigned int start_reg = REGNO (usage_rtx);\n@@ -954,7 +954,7 @@ reload_combine (void)\n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t{\n \t  if (REG_NOTE_KIND (note) == REG_INC\n-\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t      && REG_P (XEXP (note, 0)))\n \t    {\n \t      int regno = REGNO (XEXP (note, 0));\n \n@@ -986,7 +986,7 @@ reload_combine_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n \t\t\t\t   GET_MODE (dst));\n       dst = SUBREG_REG (dst);\n     }\n-  if (GET_CODE (dst) != REG)\n+  if (!REG_P (dst))\n     return;\n   regno += REGNO (dst);\n \n@@ -1031,7 +1031,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n   switch (code)\n     {\n     case SET:\n-      if (GET_CODE (SET_DEST (x)) == REG)\n+      if (REG_P (SET_DEST (x)))\n \t{\n \t  reload_combine_note_use (&SET_SRC (x), insn);\n \t  return;\n@@ -1040,7 +1040,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n \n     case USE:\n       /* If this is the USE of a return value, we can't change it.  */\n-      if (GET_CODE (XEXP (x, 0)) == REG && REG_FUNCTION_VALUE_P (XEXP (x, 0)))\n+      if (REG_P (XEXP (x, 0)) && REG_FUNCTION_VALUE_P (XEXP (x, 0)))\n \t{\n \t/* Mark the return register as used in an unknown fashion.  */\n \t  rtx reg = XEXP (x, 0);\n@@ -1054,7 +1054,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n       break;\n \n     case CLOBBER:\n-      if (GET_CODE (SET_DEST (x)) == REG)\n+      if (REG_P (SET_DEST (x)))\n \t{\n \t  /* No spurious CLOBBERs of pseudo registers may remain.  */\n \t  if (REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER)\n@@ -1065,7 +1065,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n \n     case PLUS:\n       /* We are interested in (plus (reg) (const_int)) .  */\n-      if (GET_CODE (XEXP (x, 0)) != REG\n+      if (!REG_P (XEXP (x, 0))\n \t  || GET_CODE (XEXP (x, 1)) != CONST_INT)\n \tbreak;\n       offset = XEXP (x, 1);\n@@ -1207,7 +1207,7 @@ reload_cse_move2add (rtx first)\n       /* For simplicity, we only perform this optimization on\n \t straightforward SETs.  */\n       if (GET_CODE (pat) == SET\n-\t  && GET_CODE (SET_DEST (pat)) == REG)\n+\t  && REG_P (SET_DEST (pat)))\n \t{\n \t  rtx reg = SET_DEST (pat);\n \t  int regno = REGNO (reg);\n@@ -1303,7 +1303,7 @@ reload_cse_move2add (rtx first)\n \t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT A)))\n \t\t\t\t  ...\n \t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */\n-\t      else if (GET_CODE (src) == REG\n+\t      else if (REG_P (src)\n \t\t       && reg_set_luid[regno] == reg_set_luid[REGNO (src)]\n \t\t       && reg_base_reg[regno] == reg_base_reg[REGNO (src)]\n \t\t       && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg),\n@@ -1363,7 +1363,7 @@ reload_cse_move2add (rtx first)\n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t{\n \t  if (REG_NOTE_KIND (note) == REG_INC\n-\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t      && REG_P (XEXP (note, 0)))\n \t    {\n \t      /* Reset the information about this register.  */\n \t      int regno = REGNO (XEXP (note, 0));\n@@ -1381,7 +1381,7 @@ reload_cse_move2add (rtx first)\n \n \t  if (cnd != NULL_RTX\n \t      && GET_CODE (cnd) == NE\n-\t      && GET_CODE (XEXP (cnd, 0)) == REG\n+\t      && REG_P (XEXP (cnd, 0))\n \t      /* The following two checks, which are also in\n \t\t move2add_note_store, are intended to reduce the\n \t\t number of calls to gen_rtx_SET to avoid memory\n@@ -1440,7 +1440,7 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n \treg_set_luid[REGNO (XEXP (dst, 0))] = 0;\n       return;\n     }\n-  if (GET_CODE (dst) != REG)\n+  if (!REG_P (dst))\n     return;\n \n   regno += REGNO (dst);\n@@ -1462,13 +1462,13 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n       switch (GET_CODE (src))\n \t{\n \tcase PLUS:\n-\t  if (GET_CODE (XEXP (src, 0)) == REG)\n+\t  if (REG_P (XEXP (src, 0)))\n \t    {\n \t      base_reg = XEXP (src, 0);\n \n \t      if (GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\toffset = INTVAL (XEXP (src, 1));\n-\t      else if (GET_CODE (XEXP (src, 1)) == REG\n+\t      else if (REG_P (XEXP (src, 1))\n \t\t       && (reg_set_luid[REGNO (XEXP (src, 1))]\n \t\t\t   > move2add_last_label_luid)\n \t\t       && (MODES_OK_FOR_MOVE2ADD"}, {"sha": "4f2223a2ef78b0d108b8fad935d8dd8988557d89", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -212,7 +212,7 @@ print_rtx (rtx in_rtx)\n \t   An exception is the third field of a NOTE, where it indicates\n \t   that the field has several different valid contents.  */\n       case '0':\n-\tif (i == 1 && GET_CODE (in_rtx) == REG)\n+\tif (i == 1 && REG_P (in_rtx))\n \t  {\n \t    if (REGNO (in_rtx) != ORIGINAL_REGNO (in_rtx))\n \t      fprintf (outfile, \" [%d]\", ORIGINAL_REGNO (in_rtx));\n@@ -395,10 +395,10 @@ print_rtx (rtx in_rtx)\n \t    const char *name;\n \n #ifndef GENERATOR_FILE\n-\t    if (GET_CODE (in_rtx) == REG && value < FIRST_PSEUDO_REGISTER)\n+\t    if (REG_P (in_rtx) && value < FIRST_PSEUDO_REGISTER)\n \t      fprintf (outfile, \" %d %s\", REGNO (in_rtx),\n \t\t       reg_names[REGNO (in_rtx)]);\n-\t    else if (GET_CODE (in_rtx) == REG\n+\t    else if (REG_P (in_rtx)\n \t\t     && value <= LAST_VIRTUAL_REGISTER)\n \t      {\n \t\tif (value == VIRTUAL_INCOMING_ARGS_REGNUM)\n@@ -423,7 +423,7 @@ print_rtx (rtx in_rtx)\n \t    else\n \t      fprintf (outfile, \" %d\", value);\n \n-\t    if (GET_CODE (in_rtx) == REG && REG_ATTRS (in_rtx))\n+\t    if (REG_P (in_rtx) && REG_ATTRS (in_rtx))\n \t      {\n \t\tfputs (\" [\", outfile);\n \t\tif (ORIGINAL_REGNO (in_rtx) != REGNO (in_rtx))"}, {"sha": "e9863462b107a0a3b3298591f1984451f71df863", "filename": "gcc/ra-build.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -259,13 +259,13 @@ copy_insn_p (rtx insn, rtx *source, rtx *target)\n      coalescing (the check for this is in remember_move() below).  */\n   while (GET_CODE (d) == STRICT_LOW_PART)\n     d = XEXP (d, 0);\n-  if (GET_CODE (d) != REG\n-      && (GET_CODE (d) != SUBREG || GET_CODE (SUBREG_REG (d)) != REG))\n+  if (!REG_P (d)\n+      && (GET_CODE (d) != SUBREG || !REG_P (SUBREG_REG (d))))\n     return 0;\n   while (GET_CODE (s) == STRICT_LOW_PART)\n     s = XEXP (s, 0);\n-  if (GET_CODE (s) != REG\n-      && (GET_CODE (s) != SUBREG || GET_CODE (SUBREG_REG (s)) != REG))\n+  if (!REG_P (s)\n+      && (GET_CODE (s) != SUBREG || !REG_P (SUBREG_REG (s))))\n     return 0;\n \n   s_regno = (unsigned) REGNO (GET_CODE (s) == SUBREG ? SUBREG_REG (s) : s);\n@@ -563,7 +563,7 @@ remember_move (rtx insn)\n \t Those would be difficult to coalesce (we would need to implement\n \t handling of all the subwebs in the allocator, including that such\n \t subwebs could be source and target of coalescing).  */\n-      if (GET_CODE (s) == REG && GET_CODE (d) == REG)\n+      if (REG_P (s) && REG_P (d))\n \t{\n \t  struct move *m = ra_calloc (sizeof (struct move));\n \t  struct move_list *ml;\n@@ -1204,7 +1204,7 @@ prune_hardregs_for_mode (HARD_REG_SET *s, enum machine_mode mode)\n static void\n init_one_web_common (struct web *web, rtx reg)\n {\n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     abort ();\n   /* web->id isn't initialized here.  */\n   web->regno = REGNO (reg);\n@@ -2476,7 +2476,7 @@ contains_pseudo (rtx x)\n   int i;\n   if (GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     {\n       if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n         return 1;\n@@ -2806,7 +2806,7 @@ handle_asm_insn (struct df *df, rtx insn)\n     for (i = 0; i < XVECLEN (pat, 0); i++)\n       {\n \trtx t = XVECEXP (pat, 0, i);\n-\tif (GET_CODE (t) == CLOBBER && GET_CODE (XEXP (t, 0)) == REG\n+\tif (GET_CODE (t) == CLOBBER && REG_P (XEXP (t, 0))\n \t    && REGNO (XEXP (t, 0)) < FIRST_PSEUDO_REGISTER)\n \t  SET_HARD_REG_BIT (clobbered, REGNO (XEXP (t, 0)));\n       }\n@@ -2831,7 +2831,7 @@ handle_asm_insn (struct df *df, rtx insn)\n \t     || GET_CODE (reg) == SIGN_EXTRACT\n \t     || GET_CODE (reg) == STRICT_LOW_PART)\n \treg = XEXP (reg, 0);\n-      if (GET_CODE (reg) != REG || REGNO (reg) < FIRST_PSEUDO_REGISTER)\n+      if (!REG_P (reg) || REGNO (reg) < FIRST_PSEUDO_REGISTER)\n \tcontinue;\n \n       /* Search the web corresponding to this operand.  We depend on"}, {"sha": "a5c4f0983f45f173b3c0b84addd6829e2041656d", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -271,7 +271,7 @@ ra_print_rtx_object (FILE *file, rtx x)\n \t       {\n \t\t rtx sub = SUBREG_REG (x);\n \t\t int ofs = SUBREG_BYTE (x);\n-\t\t if (GET_CODE (sub) == REG\n+\t\t if (REG_P (sub)\n \t\t     && REGNO (sub) < FIRST_PSEUDO_REGISTER)\n \t\t   {\n \t\t     int regno = REGNO (sub);\n@@ -802,7 +802,7 @@ dump_constraints (void)\n   if (!dump_file || (debug_new_regalloc & DUMP_CONSTRAINTS) == 0)\n     return;\n   for (i = FIRST_PSEUDO_REGISTER; i < ra_max_regno; i++)\n-    if (regno_reg_rtx[i] && GET_CODE (regno_reg_rtx[i]) == REG)\n+    if (regno_reg_rtx[i] && REG_P (regno_reg_rtx[i]))\n       REGNO (regno_reg_rtx[i])\n \t  = ra_reg_renumber[i] >= 0 ? ra_reg_renumber[i] : i;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -840,7 +840,7 @@ dump_constraints (void)\n \tra_debug_msg (DUMP_CONSTRAINTS, \"\\n\");\n       }\n   for (i = FIRST_PSEUDO_REGISTER; i < ra_max_regno; i++)\n-    if (regno_reg_rtx[i] && GET_CODE (regno_reg_rtx[i]) == REG)\n+    if (regno_reg_rtx[i] && REG_P (regno_reg_rtx[i]))\n       REGNO (regno_reg_rtx[i]) = i;\n }\n \n@@ -941,10 +941,11 @@ dump_static_insn_cost (FILE *file, const char *message, const char *prefix)\n \t      if (rtx_equal_p (src, dest))\n \t\tpcost = &selfcopy;\n \t      else if (GET_CODE (src) == GET_CODE (dest)\n-\t\t       && ((GET_CODE (src) == REG)\n+\t\t       && ((REG_P (src))\n \t\t\t   || (GET_CODE (src) == SUBREG\n-\t\t\t       && GET_CODE (SUBREG_REG (src)) == REG\n-\t\t\t       && GET_CODE (SUBREG_REG (dest)) == REG)))\n+\t\t\t       && REG_P (SUBREG_REG (src))\n+\t\t\t       && REG_P (SUBREG_REG (dest)))))\n+\t\t/* XXX is dest guaranteed to be a subreg? */\n \t\tpcost = &regcopy;\n \t      else\n \t\t{"}, {"sha": "5d64608d6ac89192847427bed265108aeeeea8cf", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -562,7 +562,7 @@ slots_overlap_p (rtx s1, rtx s2)\n   if (GET_CODE (s1) != GET_CODE (s2))\n     return 0;\n \n-  if (GET_CODE (s1) == REG && GET_CODE (s2) == REG)\n+  if (REG_P (s1) && REG_P (s2))\n     {\n       if (REGNO (s1) != REGNO (s2))\n \treturn 0;\n@@ -574,10 +574,10 @@ slots_overlap_p (rtx s1, rtx s2)\n     abort ();\n   s1 = XEXP (s1, 0);\n   s2 = XEXP (s2, 0);\n-  if (GET_CODE (s1) != PLUS || GET_CODE (XEXP (s1, 0)) != REG\n+  if (GET_CODE (s1) != PLUS || !REG_P (XEXP (s1, 0))\n       || GET_CODE (XEXP (s1, 1)) != CONST_INT)\n     return 1;\n-  if (GET_CODE (s2) != PLUS || GET_CODE (XEXP (s2, 0)) != REG\n+  if (GET_CODE (s2) != PLUS || !REG_P (XEXP (s2, 0))\n       || GET_CODE (XEXP (s2, 1)) != CONST_INT)\n     return 1;\n   base1 = XEXP (s1, 0);\n@@ -1877,7 +1877,7 @@ remove_suspicious_death_notes (void)\n \t    rtx note = *pnote;\n \t    if ((REG_NOTE_KIND (note) == REG_DEAD\n \t\t || REG_NOTE_KIND (note) == REG_UNUSED)\n-\t\t&& (GET_CODE (XEXP (note, 0)) == REG\n+\t\t&& (REG_P (XEXP (note, 0))\n \t\t    && bitmap_bit_p (regnos_coalesced_to_hardregs,\n \t\t\t\t     REGNO (XEXP (note, 0)))))\n \t      *pnote = XEXP (note, 1);"}, {"sha": "4fcb6eea428a5bffd9a0fdfe2b3d57ca02faaae1", "filename": "gcc/recog.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -466,7 +466,7 @@ validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object)\n      operands look similar.  */\n \n   if (x == from\n-      || (GET_CODE (x) == REG && GET_CODE (from) == REG\n+      || (REG_P (x) && REG_P (from)\n \t  && GET_MODE (x) == GET_MODE (from)\n \t  && REGNO (x) == REGNO (from))\n       || (GET_CODE (x) == GET_CODE (from) && GET_MODE (x) == GET_MODE (from)\n@@ -755,9 +755,9 @@ find_single_use_1 (rtx dest, rtx *loc)\n \t need just check the source.  */\n       if (GET_CODE (SET_DEST (x)) != CC0\n \t  && GET_CODE (SET_DEST (x)) != PC\n-\t  && GET_CODE (SET_DEST (x)) != REG\n+\t  && !REG_P (SET_DEST (x))\n \t  && ! (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t&& GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n+\t\t&& REG_P (SUBREG_REG (SET_DEST (x)))\n \t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n \t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n \t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n@@ -783,7 +783,7 @@ find_single_use_1 (rtx dest, rtx *loc)\n       if (fmt[i] == 'e')\n \t{\n \t  if (dest == XEXP (x, i)\n-\t      || (GET_CODE (dest) == REG && GET_CODE (XEXP (x, i)) == REG\n+\t      || (REG_P (dest) && REG_P (XEXP (x, i))\n \t\t  && REGNO (dest) == REGNO (XEXP (x, i))))\n \t    this_result = loc;\n \t  else\n@@ -802,8 +802,8 @@ find_single_use_1 (rtx dest, rtx *loc)\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n \t      if (XVECEXP (x, i, j) == dest\n-\t\t  || (GET_CODE (dest) == REG\n-\t\t      && GET_CODE (XVECEXP (x, i, j)) == REG\n+\t\t  || (REG_P (dest)\n+\t\t      && REG_P (XVECEXP (x, i, j))\n \t\t      && REGNO (XVECEXP (x, i, j)) == REGNO (dest)))\n \t\tthis_result = loc;\n \t      else\n@@ -860,7 +860,7 @@ find_single_use (rtx dest, rtx insn, rtx *ploc)\n     }\n #endif\n \n-  if (reload_completed || reload_in_progress || GET_CODE (dest) != REG)\n+  if (reload_completed || reload_in_progress || !REG_P (dest))\n     return 0;\n \n   for (next = next_nonnote_insn (insn);\n@@ -1043,7 +1043,7 @@ register_operand (rtx op, enum machine_mode mode)\n \treturn general_operand (op, mode);\n \n #ifdef CANNOT_CHANGE_MODE_CLASS\n-      if (GET_CODE (sub) == REG\n+      if (REG_P (sub)\n \t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n \t  && REG_CANNOT_CHANGE_MODE_P (REGNO (sub), GET_MODE (sub), mode)\n \t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_INT\n@@ -1067,7 +1067,7 @@ register_operand (rtx op, enum machine_mode mode)\n \n   /* We don't consider registers whose class is NO_REGS\n      to be a register operand.  */\n-  return (GET_CODE (op) == REG\n+  return (REG_P (op)\n \t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n }\n@@ -1090,7 +1090,7 @@ scratch_operand (rtx op, enum machine_mode mode)\n     return 0;\n \n   return (GET_CODE (op) == SCRATCH\n-\t  || (GET_CODE (op) == REG\n+\t  || (REG_P (op)\n \t      && REGNO (op) < FIRST_PSEUDO_REGISTER));\n }\n \n@@ -1209,7 +1209,7 @@ nonmemory_operand (rtx op, enum machine_mode mode)\n \n   /* We don't consider registers whose class is NO_REGS\n      to be a register operand.  */\n-  return (GET_CODE (op) == REG\n+  return (REG_P (op)\n \t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n }\n@@ -2303,7 +2303,7 @@ constrain_operands (int strict)\n \n \t  if (GET_CODE (op) == SUBREG)\n \t    {\n-\t      if (GET_CODE (SUBREG_REG (op)) == REG\n+\t      if (REG_P (SUBREG_REG (op))\n \t\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n \t\toffset = subreg_regno_offset (REGNO (SUBREG_REG (op)),\n \t\t\t\t\t      GET_MODE (SUBREG_REG (op)),\n@@ -2415,7 +2415,7 @@ constrain_operands (int strict)\n \t\t   but the hard reg is not in the class GENERAL_REGS.  */\n \t\tif (strict < 0\n \t\t    || GENERAL_REGS == ALL_REGS\n-\t\t    || GET_CODE (op) != REG\n+\t\t    || !REG_P (op)\n \t\t    || (reload_in_progress\n \t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\t    || reg_fits_class_p (op, GENERAL_REGS, offset, mode))\n@@ -2447,7 +2447,7 @@ constrain_operands (int strict)\n \t\telse if (strict < 0 && CONSTANT_P (op))\n \t\t  win = 1;\n \t\t/* During reload, accept a pseudo  */\n-\t\telse if (reload_in_progress && GET_CODE (op) == REG\n+\t\telse if (reload_in_progress && REG_P (op)\n \t\t\t && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\t  win = 1;\n \t\tbreak;\n@@ -2517,7 +2517,7 @@ constrain_operands (int strict)\n \t\t\t|| (strict < 0\n \t\t\t    && !(CONSTANT_P (op) || GET_CODE (op) == MEM))\n \t\t\t|| (reload_in_progress\n-\t\t\t    && !(GET_CODE (op) == REG\n+\t\t\t    && !(REG_P (op)\n \t\t\t\t && REGNO (op) >= FIRST_PSEUDO_REGISTER))))\n \t\t  win = 1;\n \t\tbreak;\n@@ -2529,7 +2529,7 @@ constrain_operands (int strict)\n \t\t    || (strict < 0\n \t\t\t&& (CONSTANT_P (op) || GET_CODE (op) == MEM))\n \t\t    /* During reload, accept a pseudo  */\n-\t\t    || (reload_in_progress && GET_CODE (op) == REG\n+\t\t    || (reload_in_progress && REG_P (op)\n \t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER))\n \t\t  win = 1;\n \t\tbreak;\n@@ -2544,10 +2544,10 @@ constrain_operands (int strict)\n \t\t    {\n \t\t      if (strict < 0\n \t\t\t  || (strict == 0\n-\t\t\t      && GET_CODE (op) == REG\n+\t\t\t      && REG_P (op)\n \t\t\t      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\t\t  || (strict == 0 && GET_CODE (op) == SCRATCH)\n-\t\t\t  || (GET_CODE (op) == REG\n+\t\t\t  || (REG_P (op)\n \t\t\t      && reg_fits_class_p (op, class, offset, mode)))\n \t\t        win = 1;\n \t\t    }\n@@ -2562,7 +2562,7 @@ constrain_operands (int strict)\n \t\t\t\t  into mem.  */\n \t\t\t       || (strict < 0 && CONSTANT_P (op))\n \t\t\t       /* During reload, accept a pseudo  */\n-\t\t\t       || (reload_in_progress && GET_CODE (op) == REG\n+\t\t\t       || (reload_in_progress && REG_P (op)\n \t\t\t\t   && REGNO (op) >= FIRST_PSEUDO_REGISTER)))\n \t\t    win = 1;\n \t\t  else if (EXTRA_ADDRESS_CONSTRAINT (c, p)\n@@ -2596,7 +2596,7 @@ constrain_operands (int strict)\n \t\t because we would often report failure when we have\n \t\t two memory operands, one of which was formerly a REG.  */\n \t      if (earlyclobber[eopno]\n-\t\t  && GET_CODE (recog_data.operand[eopno]) == REG)\n+\t\t  && REG_P (recog_data.operand[eopno]))\n \t\tfor (opno = 0; opno < recog_data.n_operands; opno++)\n \t\t  if ((GET_CODE (recog_data.operand[opno]) == MEM\n \t\t       || recog_data.operand_type[opno] != OP_OUT)"}, {"sha": "567256170a9c946232658afa2f07cfda17e994d4", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -628,7 +628,7 @@ check_asm_stack_operands (rtx insn)\n   /* Strip SUBREGs here to make the following code simpler.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n     if (GET_CODE (recog_data.operand[i]) == SUBREG\n-\t&& GET_CODE (SUBREG_REG (recog_data.operand[i])) == REG)\n+\t&& REG_P (SUBREG_REG (recog_data.operand[i])))\n       recog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n \n   /* Set up CLOBBER_REG.  */\n@@ -645,7 +645,7 @@ check_asm_stack_operands (rtx insn)\n \t    rtx clobber = XVECEXP (body, 0, i);\n \t    rtx reg = XEXP (clobber, 0);\n \n-\t    if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+\t    if (GET_CODE (reg) == SUBREG && REG_P (SUBREG_REG (reg)))\n \t      reg = SUBREG_REG (reg);\n \n \t    if (STACK_REG_P (reg))\n@@ -1008,17 +1008,17 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n       /* If the previous register stack push was from the reg we are to\n \t swap with, omit the swap.  */\n \n-      if (GET_CODE (i1dest) == REG && REGNO (i1dest) == FIRST_STACK_REG\n-\t  && GET_CODE (i1src) == REG\n+      if (REG_P (i1dest) && REGNO (i1dest) == FIRST_STACK_REG\n+\t  && REG_P (i1src)\n \t  && REGNO (i1src) == (unsigned) hard_regno - 1\n \t  && find_regno_note (i1, REG_DEAD, FIRST_STACK_REG) == NULL_RTX)\n \treturn;\n \n       /* If the previous insn wrote to the reg we are to swap with,\n \t omit the swap.  */\n \n-      if (GET_CODE (i1dest) == REG && REGNO (i1dest) == (unsigned) hard_regno\n-\t  && GET_CODE (i1src) == REG && REGNO (i1src) == FIRST_STACK_REG\n+      if (REG_P (i1dest) && REGNO (i1dest) == (unsigned) hard_regno\n+\t  && REG_P (i1src) && REGNO (i1src) == FIRST_STACK_REG\n \t  && find_regno_note (i1, REG_DEAD, FIRST_STACK_REG) == NULL_RTX)\n \treturn;\n     }\n@@ -1266,7 +1266,7 @@ swap_rtx_condition (rtx insn)\n   /* We're looking for a single set to cc0 or an HImode temporary.  */\n \n   if (GET_CODE (pat) == SET\n-      && GET_CODE (SET_DEST (pat)) == REG\n+      && REG_P (SET_DEST (pat))\n       && REGNO (SET_DEST (pat)) == FLAGS_REG)\n     {\n       insn = next_flags_user (insn);\n@@ -1530,7 +1530,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t/* See if this is a `movM' pattern, and handle elsewhere if so.  */\n \tif (STACK_REG_P (*src)\n \t    || (STACK_REG_P (*dest)\n-\t\t&& (GET_CODE (*src) == REG || GET_CODE (*src) == MEM\n+\t\t&& (REG_P (*src) || GET_CODE (*src) == MEM\n \t\t    || GET_CODE (*src) == CONST_DOUBLE)))\n \t  {\n \t    control_flow_insn_deleted |= move_for_stack_reg (insn, regstack, pat);\n@@ -2072,7 +2072,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n   /* Strip SUBREGs here to make the following code simpler.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n     if (GET_CODE (recog_data.operand[i]) == SUBREG\n-\t&& GET_CODE (SUBREG_REG (recog_data.operand[i])) == REG)\n+\t&& REG_P (SUBREG_REG (recog_data.operand[i])))\n       {\n \trecog_data.operand_loc[i] = & SUBREG_REG (recog_data.operand[i]);\n \trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n@@ -2093,7 +2093,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n       rtx reg = XEXP (note, 0);\n       rtx *loc = & XEXP (note, 0);\n \n-      if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+      if (GET_CODE (reg) == SUBREG && REG_P (SUBREG_REG (reg)))\n \t{\n \t  loc = & SUBREG_REG (reg);\n \t  reg = SUBREG_REG (reg);\n@@ -2126,7 +2126,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n \t    rtx reg = XEXP (clobber, 0);\n \t    rtx *loc = & XEXP (clobber, 0);\n \n-\t    if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+\t    if (GET_CODE (reg) == SUBREG && REG_P (SUBREG_REG (reg)))\n \t      {\n \t\tloc = & SUBREG_REG (reg);\n \t\treg = SUBREG_REG (reg);"}, {"sha": "a6bbec870ee17801067d1769751e12219f8c8aaf", "filename": "gcc/regclass.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1037,7 +1037,7 @@ scan_one_insn (rtx insn, int pass)\n      it represents a savings, rather than a cost, if the\n      parameter is stored in memory.  Record this fact.  */\n \n-  if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n+  if (set != 0 && REG_P (SET_DEST (set))\n       && GET_CODE (SET_SRC (set)) == MEM\n       && (note = find_reg_note (insn, REG_EQUIV,\n \t\t\t\tNULL_RTX)) != 0\n@@ -1071,7 +1071,7 @@ scan_one_insn (rtx insn, int pass)\n       && CONSTANT_P (recog_data.operand[1])\n       && ! rtx_equal_p (recog_data.operand[0], recog_data.operand[1])\n       && ! rtx_equal_p (recog_data.operand[0], recog_data.operand[2])\n-      && GET_CODE (recog_data.operand[0]) == REG\n+      && REG_P (recog_data.operand[0])\n       && MODES_TIEABLE_P (GET_MODE (recog_data.operand[0]),\n \t\t\t  recog_data.operand_mode[1]))\n     {\n@@ -1120,7 +1120,7 @@ scan_one_insn (rtx insn, int pass)\n      its register.  */\n \n   for (i = 0; i < recog_data.n_operands; i++)\n-    if (GET_CODE (recog_data.operand[i]) == REG\n+    if (REG_P (recog_data.operand[i])\n \t&& REGNO (recog_data.operand[i]) >= FIRST_PSEUDO_REGISTER)\n       {\n \tint regno = REGNO (recog_data.operand[i]);\n@@ -1422,7 +1422,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \n \t  if (*p == 0)\n \t    {\n-\t      if (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t      if (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\tmemset (&this_op_costs[i], 0, sizeof this_op_costs[i]);\n \n \t      continue;\n@@ -1445,7 +1445,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t      classes[i] = classes[j];\n \t      allows_mem[i] = allows_mem[j];\n \n-\t      if (GET_CODE (op) != REG || REGNO (op) < FIRST_PSEUDO_REGISTER)\n+\t      if (!REG_P (op) || REGNO (op) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  /* If this matches the other operand, we have no added\n \t\t     cost and we win.  */\n@@ -1459,7 +1459,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  else if (classes[j] != NO_REGS)\n \t\t    alt_cost += copy_cost (op, mode, classes[j], 1), win = 1;\n \t\t}\n-\t      else if (GET_CODE (ops[j]) != REG\n+\t      else if (!REG_P (ops[j])\n \t\t       || REGNO (ops[j]) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  /* This op is a pseudo but the one it matches is not.  */\n@@ -1702,7 +1702,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t     register preferencing.  If some register class is valid, compute\n \t     the costs of moving the pseudo into that class.  */\n \n-\t  if (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t  if (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t    {\n \t      if (classes[i] == NO_REGS)\n \t\t{\n@@ -1757,7 +1757,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t     the proper class, there is no cost for this alternative.  */\n \n \t  else if (win\n-\t\t   || (GET_CODE (op) == REG\n+\t\t   || (REG_P (op)\n \t\t       && reg_fits_class_p (op, classes[i], 0, GET_MODE (op))))\n \t    ;\n \n@@ -1789,7 +1789,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t about this alternative.  */\n \n       for (i = 0; i < n_ops; i++)\n-\tif (GET_CODE (ops[i]) == REG\n+\tif (REG_P (ops[i])\n \t    && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n \t    struct costs *pp = &op_costs[i], *qq = &this_op_costs[i];\n@@ -1820,7 +1820,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \n   if ((set = single_set (insn)) != 0\n       && ops[0] == SET_DEST (set) && ops[1] == SET_SRC (set)\n-      && GET_CODE (ops[0]) == REG && GET_CODE (ops[1]) == REG\n+      && REG_P (ops[0]) && REG_P (ops[1])\n       && find_regno_note (insn, REG_DEAD, REGNO (ops[1])))\n     for (i = 0; i <= 1; i++)\n       if (REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n@@ -1912,7 +1912,7 @@ copy_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n   if (GET_CODE (x) == MEM || class == NO_REGS)\n     return MEMORY_MOVE_COST (mode, class, to_p);\n \n-  else if (GET_CODE (x) == REG)\n+  else if (REG_P (x))\n     return move_cost[mode][(int) REGNO_REG_CLASS (REGNO (x))][(int) class];\n \n   else\n@@ -2074,7 +2074,7 @@ record_address_regs (rtx x, enum reg_class class, int scale)\n \t show it is being used in an INC_DEC context.  */\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-      if (GET_CODE (XEXP (x, 0)) == REG\n+      if (REG_P (XEXP (x, 0))\n \t  && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER)\n \tin_inc_dec[REGNO (XEXP (x, 0))] = 1;\n #endif\n@@ -2436,7 +2436,7 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n       if (GET_CODE (dest) == PARALLEL)\n \tmax_set_parallel = MAX (max_set_parallel, XVECLEN (dest, 0) - 1);\n \n-      if (GET_CODE (dest) == REG\n+      if (REG_P (dest)\n \t  && REGNO (dest) >= min_regno)\n \t{\n \t  REG_N_SETS (REGNO (dest))++;\n@@ -2455,7 +2455,7 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n \t variable since it should have already been set as a pointer based\n \t on the type.  */\n \n-      if (GET_CODE (SET_DEST (x)) == REG\n+      if (REG_P (SET_DEST (x))\n \t  && REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER\n \t  && REGNO (SET_DEST (x)) >= min_regno\n \t  /* If the destination pseudo is set more than once, then other\n@@ -2466,12 +2466,12 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n \t  && REG_N_SETS (REGNO (SET_DEST (x))) == 1\n \t  && ! REG_USERVAR_P (SET_DEST (x))\n \t  && ! REG_POINTER (SET_DEST (x))\n-\t  && ((GET_CODE (SET_SRC (x)) == REG\n+\t  && ((REG_P (SET_SRC (x))\n \t       && REG_POINTER (SET_SRC (x)))\n \t      || ((GET_CODE (SET_SRC (x)) == PLUS\n \t\t   || GET_CODE (SET_SRC (x)) == LO_SUM)\n \t\t  && GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n-\t\t  && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n+\t\t  && REG_P (XEXP (SET_SRC (x), 0))\n \t\t  && REG_POINTER (XEXP (SET_SRC (x), 0)))\n \t      || GET_CODE (SET_SRC (x)) == CONST\n \t      || GET_CODE (SET_SRC (x)) == SYMBOL_REF\n@@ -2493,7 +2493,7 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n \n       /* If this is setting a register from a register or from a simple\n \t conversion of a register, propagate REG_EXPR.  */\n-      if (GET_CODE (dest) == REG)\n+      if (REG_P (dest))\n \t{\n \t  rtx src = SET_SRC (x);\n "}, {"sha": "f309f2163fbed5a0b34f13aecbcf63f6e9d21a5e", "filename": "gcc/regmove.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -188,10 +188,10 @@ discover_flags_reg (void)\n \t scratch or something.  We only care about hard regs.\n \t Moreover we don't like the notion of subregs of hard regs.  */\n       if (GET_CODE (tmp) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (tmp)) == REG\n+\t  && REG_P (SUBREG_REG (tmp))\n \t  && REGNO (SUBREG_REG (tmp)) < FIRST_PSEUDO_REGISTER)\n \treturn pc_rtx;\n-      found = (GET_CODE (tmp) == REG && REGNO (tmp) < FIRST_PSEUDO_REGISTER);\n+      found = (REG_P (tmp) && REGNO (tmp) < FIRST_PSEUDO_REGISTER);\n \n       return (found ? tmp : NULL_RTX);\n     }\n@@ -334,7 +334,7 @@ replacement_quality (rtx reg)\n   int src_regno;\n \n   /* Bad if this isn't a register at all.  */\n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return 0;\n \n   /* If this register is not meant to get a hard register,\n@@ -752,9 +752,9 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n      parameter when there is no frame pointer that is not allocated a register.\n      For now, we just reject them, rather than incrementing the live length.  */\n \n-  if (GET_CODE (src) == REG\n+  if (REG_P (src)\n       && REG_LIVE_LENGTH (REGNO (src)) > 0\n-      && GET_CODE (dest) == REG\n+      && REG_P (dest)\n       && !RTX_UNCHANGING_P (dest)\n       && REG_LIVE_LENGTH (REGNO (dest)) > 0\n       && (set = single_set (insn)) != NULL_RTX\n@@ -865,7 +865,7 @@ reg_is_remote_constant_p (rtx reg, rtx insn, rtx first)\n \tcontinue;\n       s = single_set (XEXP (p, 0));\n       if (s != 0\n-\t  && GET_CODE (SET_DEST (s)) == REG\n+\t  && REG_P (SET_DEST (s))\n \t  && REGNO (SET_DEST (s)) == REGNO (reg))\n \t{\n \t  /* The register is set in the same basic block.  */\n@@ -881,7 +881,7 @@ reg_is_remote_constant_p (rtx reg, rtx insn, rtx first)\n \tcontinue;\n       s = single_set (p);\n       if (s != 0\n-\t  && GET_CODE (SET_DEST (s)) == REG\n+\t  && REG_P (SET_DEST (s))\n \t  && REGNO (SET_DEST (s)) == REGNO (reg))\n \t{\n \t  /* This is the instruction which sets REG.  If there is a\n@@ -1087,13 +1087,13 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t  if (flag_expensive_optimizations && ! pass\n \t      && (GET_CODE (SET_SRC (set)) == SIGN_EXTEND\n \t\t  || GET_CODE (SET_SRC (set)) == ZERO_EXTEND)\n-\t      && GET_CODE (XEXP (SET_SRC (set), 0)) == REG\n-\t      && GET_CODE (SET_DEST (set)) == REG)\n+\t      && REG_P (XEXP (SET_SRC (set), 0))\n+\t      && REG_P (SET_DEST (set)))\n \t    optimize_reg_copy_3 (insn, SET_DEST (set), SET_SRC (set));\n \n \t  if (flag_expensive_optimizations && ! pass\n-\t      && GET_CODE (SET_SRC (set)) == REG\n-\t      && GET_CODE (SET_DEST (set)) == REG)\n+\t      && REG_P (SET_SRC (set))\n+\t      && REG_P (SET_DEST (set)))\n \t    {\n \t      /* If this is a register-register copy where SRC is not dead,\n \t\t see if we can optimize it.  If this optimization succeeds,\n@@ -1142,7 +1142,7 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t      src = recog_data.operand[op_no];\n \t      dst = recog_data.operand[match_no];\n \n-\t      if (GET_CODE (src) != REG)\n+\t      if (!REG_P (src))\n \t\tcontinue;\n \n \t      src_subreg = src;\n@@ -1155,7 +1155,7 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t\t\t\t      src, SUBREG_BYTE (dst));\n \t\t  dst = SUBREG_REG (dst);\n \t\t}\n-\t      if (GET_CODE (dst) != REG\n+\t      if (!REG_P (dst)\n \t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n \t\tcontinue;\n \n@@ -1253,10 +1253,10 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t      dst = recog_data.operand[match_no];\n \t      src = recog_data.operand[op_no];\n \n-\t      if (GET_CODE (src) != REG)\n+\t      if (!REG_P (src))\n \t\tcontinue;\n \n-\t      if (GET_CODE (dst) != REG\n+\t      if (!REG_P (dst)\n \t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER\n \t\t  || REG_LIVE_LENGTH (REGNO (dst)) < 0\n \t\t  || RTX_UNCHANGING_P (dst)\n@@ -1779,7 +1779,7 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n \t\t\t hard register.  */\n \t\t      && ! (dst_note && ! REG_N_CALLS_CROSSED (REGNO (dst))\n \t\t\t    && single_set (p)\n-\t\t\t    && GET_CODE (SET_DEST (single_set (p))) == REG\n+\t\t\t    && REG_P (SET_DEST (single_set (p)))\n \t\t\t    && (REGNO (SET_DEST (single_set (p)))\n \t\t\t\t< FIRST_PSEUDO_REGISTER))\n \t\t      /* We may only emit an insn directly after P if we"}, {"sha": "0e276362449b636aef0b07dd5e7852392cbbfb2e", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -101,7 +101,7 @@ note_sets (rtx x, rtx set ATTRIBUTE_UNUSED, void *data)\n   HARD_REG_SET *pset = (HARD_REG_SET *) data;\n   unsigned int regno;\n   int nregs;\n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     return;\n   regno = REGNO (x);\n   nregs = hard_regno_nregs[regno][GET_MODE (x)];\n@@ -836,7 +836,7 @@ build_def_use (basic_block bb)\n \t\trtx *loc = recog_data.operand_loc[i];\n \t\trtx op = *loc;\n \n-\t\tif (GET_CODE (op) == REG\n+\t\tif (REG_P (op)\n \t\t    && REGNO (op) == ORIGINAL_REGNO (op)\n \t\t    && (recog_data.operand_type[i] == OP_IN\n \t\t\t|| recog_data.operand_type[i] == OP_INOUT))\n@@ -926,7 +926,7 @@ build_def_use (basic_block bb)\n \t\t    rtx op = *loc;\n \t\t    enum reg_class class = recog_op_alt[i][alt].class;\n \n-\t\t    if (GET_CODE (op) == REG\n+\t\t    if (REG_P (op)\n \t\t\t&& REGNO (op) == ORIGINAL_REGNO (op))\n \t\t      continue;\n \n@@ -1659,7 +1659,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t    continue;\n \n \t  /* Don't replace in asms intentionally referencing hard regs.  */\n-\t  if (is_asm && GET_CODE (recog_data.operand[i]) == REG\n+\t  if (is_asm && REG_P (recog_data.operand[i])\n \t      && (REGNO (recog_data.operand[i])\n \t\t  == ORIGINAL_REGNO (recog_data.operand[i])))\n \t    continue;"}, {"sha": "298db27cdaf61014af1d31a505bdd40bb3e1501f", "filename": "gcc/reload.c", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -211,8 +211,8 @@ static int output_reloadnum;\n \n   /* Compare two RTX's.  */\n #define MATCHES(x, y) \\\n- (x == y || (x != 0 && (GET_CODE (x) == REG\t\t\t\t\\\n-\t\t\t? GET_CODE (y) == REG && REGNO (x) == REGNO (y)\t\\\n+ (x == y || (x != 0 && (REG_P (x)\t\t\t\t\\\n+\t\t\t? REG_P (y) && REGNO (x) == REGNO (y)\t\\\n \t\t\t: rtx_equal_p (x, y) && ! side_effects_p (x))))\n \n   /* Indicates if two reloads purposes are for similar enough things that we\n@@ -332,7 +332,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n      a secondary reload is needed since whether or not a reload is needed\n      might be sensitive to the form of the MEM.  */\n \n-  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+  if (REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       && reg_equiv_mem[REGNO (x)] != 0)\n     x = reg_equiv_mem[REGNO (x)];\n \n@@ -771,10 +771,10 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n \t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n \t\t\t\t  true_regnum (rld[i].reg_rtx)))\n \t&& out == 0 && rld[i].out == 0 && rld[i].in != 0\n-\t&& ((GET_CODE (in) == REG\n+\t&& ((REG_P (in)\n \t     && GET_RTX_CLASS (GET_CODE (rld[i].in)) == RTX_AUTOINC\n \t     && MATCHES (XEXP (rld[i].in, 0), in))\n-\t    || (GET_CODE (rld[i].in) == REG\n+\t    || (REG_P (rld[i].in)\n \t\t&& GET_RTX_CLASS (GET_CODE (in)) == RTX_AUTOINC\n \t\t&& MATCHES (XEXP (in, 0), rld[i].in)))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n@@ -784,7 +784,7 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n       {\n \t/* Make sure reload_in ultimately has the increment,\n \t   not the plain register.  */\n-\tif (GET_CODE (in) == REG)\n+\tif (REG_P (in))\n \t  *p_in = rld[i].in;\n \treturn i;\n       }\n@@ -811,7 +811,7 @@ reload_inner_reg_of_subreg (rtx x, enum machine_mode mode, int output)\n \n   /* If INNER is not a hard register, then INNER will not need to\n      be reloaded.  */\n-  if (GET_CODE (inner) != REG\n+  if (!REG_P (inner)\n       || REGNO (inner) >= FIRST_PSEUDO_REGISTER)\n     return 0;\n \n@@ -855,7 +855,7 @@ can_reload_into (rtx in, int regno, enum machine_mode mode)\n      technically this is a non-optional input-output reload, but IN is\n      already a valid register, and has been chosen as the reload register.\n      Speed this up, since it trivially works.  */\n-  if (GET_CODE (in) == REG)\n+  if (REG_P (in))\n     return 1;\n \n   /* To test MEMs properly, we'd have to take into account all the reloads\n@@ -938,7 +938,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      it is not in a hard register, reload straight from the constant,\n      since we want to get rid of such pseudo registers.\n      Often this is done earlier, but not always in find_reloads_address.  */\n-  if (in != 0 && GET_CODE (in) == REG)\n+  if (in != 0 && REG_P (in))\n     {\n       int regno = REGNO (in);\n \n@@ -950,7 +950,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   /* Likewise for OUT.  Of course, OUT will never be equivalent to\n      an actual constant, but it might be equivalent to a memory location\n      (in the case of a parameter).  */\n-  if (out != 0 && GET_CODE (out) == REG)\n+  if (out != 0 && REG_P (out))\n     {\n       int regno = REGNO (out);\n \n@@ -1014,7 +1014,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       && (CONSTANT_P (SUBREG_REG (in))\n \t  || GET_CODE (SUBREG_REG (in)) == PLUS\n \t  || strict_low\n-\t  || (((GET_CODE (SUBREG_REG (in)) == REG\n+\t  || (((REG_P (SUBREG_REG (in))\n \t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n \t       || GET_CODE (SUBREG_REG (in)) == MEM)\n \t      && ((GET_MODE_SIZE (inmode)\n@@ -1036,7 +1036,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t\t   / UNITS_PER_WORD)))\n #endif\n \t\t  ))\n-\t  || (GET_CODE (SUBREG_REG (in)) == REG\n+\t  || (REG_P (SUBREG_REG (in))\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n \t\t is handled differently in the following statement.  */\n@@ -1057,7 +1057,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t  == NO_REGS))\n #endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-\t  || (GET_CODE (SUBREG_REG (in)) == REG\n+\t  || (REG_P (SUBREG_REG (in))\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      && REG_CANNOT_CHANGE_MODE_P\n \t      (REGNO (SUBREG_REG (in)), GET_MODE (SUBREG_REG (in)), inmode))\n@@ -1091,7 +1091,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n     {\n       enum reg_class in_class = class;\n \n-      if (GET_CODE (SUBREG_REG (in)) == REG)\n+      if (REG_P (SUBREG_REG (in)))\n \tin_class\n \t  = find_valid_class (inmode,\n \t\t\t      subreg_regno_offset (REGNO (SUBREG_REG (in)),\n@@ -1123,7 +1123,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n #endif\n       && (CONSTANT_P (SUBREG_REG (out))\n \t  || strict_low\n-\t  || (((GET_CODE (SUBREG_REG (out)) == REG\n+\t  || (((REG_P (SUBREG_REG (out))\n \t\t&& REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER)\n \t       || GET_CODE (SUBREG_REG (out)) == MEM)\n \t      && ((GET_MODE_SIZE (outmode)\n@@ -1136,7 +1136,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t\t   / UNITS_PER_WORD)))\n #endif\n \t\t  ))\n-\t  || (GET_CODE (SUBREG_REG (out)) == REG\n+\t  || (REG_P (SUBREG_REG (out))\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      && ((GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n \t\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n@@ -1154,7 +1154,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t  == NO_REGS))\n #endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-\t  || (GET_CODE (SUBREG_REG (out)) == REG\n+\t  || (REG_P (SUBREG_REG (out))\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      && REG_CANNOT_CHANGE_MODE_P (REGNO (SUBREG_REG (out)),\n \t\t\t\t\t   GET_MODE (SUBREG_REG (out)),\n@@ -1202,21 +1202,21 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n   /* If IN appears in OUT, we can't share any input-only reload for IN.  */\n   if (in != 0 && out != 0 && GET_CODE (out) == MEM\n-      && (GET_CODE (in) == REG || GET_CODE (in) == MEM)\n+      && (REG_P (in) || GET_CODE (in) == MEM)\n       && reg_overlap_mentioned_for_reload_p (in, XEXP (out, 0)))\n     dont_share = 1;\n \n   /* If IN is a SUBREG of a hard register, make a new REG.  This\n      simplifies some of the cases below.  */\n \n-  if (in != 0 && GET_CODE (in) == SUBREG && GET_CODE (SUBREG_REG (in)) == REG\n+  if (in != 0 && GET_CODE (in) == SUBREG && REG_P (SUBREG_REG (in))\n       && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n       && ! dont_remove_subreg)\n     in = gen_rtx_REG (GET_MODE (in), subreg_regno (in));\n \n   /* Similarly for OUT.  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n-      && GET_CODE (SUBREG_REG (out)) == REG\n+      && REG_P (SUBREG_REG (out))\n       && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n       && ! dont_remove_subreg)\n     out = gen_rtx_REG (GET_MODE (out), subreg_regno (out));\n@@ -1320,7 +1320,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n #ifdef SECONDARY_MEMORY_NEEDED\n       /* If a memory location is needed for the copy, make one.  */\n-      if (in != 0 && (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n+      if (in != 0 && (REG_P (in) || GET_CODE (in) == SUBREG)\n \t  && reg_or_subregno (in) < FIRST_PSEUDO_REGISTER\n \t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (reg_or_subregno (in)),\n \t\t\t\t      class, inmode))\n@@ -1350,7 +1350,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       n_reloads++;\n \n #ifdef SECONDARY_MEMORY_NEEDED\n-      if (out != 0 && (GET_CODE (out) == REG || GET_CODE (out) == SUBREG)\n+      if (out != 0 && (REG_P (out) || GET_CODE (out) == SUBREG)\n \t  && reg_or_subregno (out) < FIRST_PSEUDO_REGISTER\n \t  && SECONDARY_MEMORY_NEEDED (class,\n \t\t\t\t      REGNO_REG_CLASS (reg_or_subregno (out)),\n@@ -1494,7 +1494,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t The easiest way to tell the caller that is to give a phony\n \t value for the incoming operand (same as outgoing one).  */\n       if (rld[i].reg_rtx == out\n-\t  && (GET_CODE (in) == REG || CONSTANT_P (in))\n+\t  && (REG_P (in) || CONSTANT_P (in))\n \t  && 0 != find_equiv_reg (in, this_insn, 0, REGNO (out),\n \t\t\t\t  static_reload_reg_p, i, inmode))\n \trld[i].in = out;\n@@ -1523,7 +1523,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n       for (note = REG_NOTES (this_insn); note; note = XEXP (note, 1))\n \tif (REG_NOTE_KIND (note) == REG_DEAD\n-\t    && GET_CODE (XEXP (note, 0)) == REG\n+\t    && REG_P (XEXP (note, 0))\n \t    && (regno = REGNO (XEXP (note, 0))) < FIRST_PSEUDO_REGISTER\n \t    && reg_mentioned_p (XEXP (note, 0), in)\n \t    && ! refers_to_regno_for_reload_p (regno,\n@@ -1762,7 +1762,7 @@ combine_reloads (void)\n \t\t   If the same reload reg is used for both reg 69 and the\n \t\t   result to be stored in memory, then that result\n \t\t   will clobber the address of the memory ref.  */\n-\t\t&& ! (GET_CODE (rld[i].in) == REG\n+\t\t&& ! (REG_P (rld[i].in)\n \t\t      && reg_overlap_mentioned_for_reload_p (rld[i].in,\n \t\t\t\t\t\t\t     rld[output_reload].out))))\n \t&& ! reload_inner_reg_of_subreg (rld[i].in, rld[i].inmode,\n@@ -1831,7 +1831,7 @@ combine_reloads (void)\n      up can fully hold our output reload.  */\n   for (note = REG_NOTES (this_insn); note; note = XEXP (note, 1))\n     if (REG_NOTE_KIND (note) == REG_DEAD\n-\t&& GET_CODE (XEXP (note, 0)) == REG\n+\t&& REG_P (XEXP (note, 0))\n \t&& ! reg_overlap_mentioned_for_reload_p (XEXP (note, 0),\n \t\t\t\t\t\t rld[output_reload].out)\n \t&& REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n@@ -1903,7 +1903,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n   /* Find the inside of any subregs.  */\n   while (GET_CODE (out) == SUBREG)\n     {\n-      if (GET_CODE (SUBREG_REG (out)) == REG\n+      if (REG_P (SUBREG_REG (out))\n \t  && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER)\n \tout_offset += subreg_regno_offset (REGNO (SUBREG_REG (out)),\n \t\t\t\t\t   GET_MODE (SUBREG_REG (out)),\n@@ -1913,7 +1913,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n     }\n   while (GET_CODE (in) == SUBREG)\n     {\n-      if (GET_CODE (SUBREG_REG (in)) == REG\n+      if (REG_P (SUBREG_REG (in))\n \t  && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER)\n \tin_offset += subreg_regno_offset (REGNO (SUBREG_REG (in)),\n \t\t\t\t\t  GET_MODE (SUBREG_REG (in)),\n@@ -1927,7 +1927,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n   class = PREFERRED_RELOAD_CLASS (in, class);\n \n   /* See if OUT will do.  */\n-  if (GET_CODE (out) == REG\n+  if (REG_P (out)\n       && REGNO (out) < FIRST_PSEUDO_REGISTER)\n     {\n       unsigned int regno = REGNO (out) + out_offset;\n@@ -1960,7 +1960,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \n \t  if (i == nwords)\n \t    {\n-\t      if (GET_CODE (real_out) == REG)\n+\t      if (REG_P (real_out))\n \t\tvalue = real_out;\n \t      else\n \t\tvalue = gen_rtx_REG (outmode, regno);\n@@ -1977,7 +1977,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n      Also, the result can't go in IN if IN is used within OUT,\n      or if OUT is an earlyclobber and IN appears elsewhere in the insn.  */\n   if (hard_regs_live_known\n-      && GET_CODE (in) == REG\n+      && REG_P (in)\n       && REGNO (in) < FIRST_PSEUDO_REGISTER\n       && (value == 0\n \t  || find_reg_note (this_insn, REG_UNUSED, real_out))\n@@ -2015,7 +2015,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t\t dies here.  So don't bother copying value to it.  */\n \t      if (for_real >= 0 && value == real_out)\n \t\trld[for_real].out = 0;\n-\t      if (GET_CODE (real_in) == REG)\n+\t      if (REG_P (real_in))\n \t\tvalue = real_in;\n \t      else\n \t\tvalue = gen_rtx_REG (inmode, regno);\n@@ -2058,7 +2058,7 @@ hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)\n \n       while (GET_CODE (op0) == SUBREG)\n \top0 = SUBREG_REG (op0);\n-      if (GET_CODE (op0) == REG)\n+      if (REG_P (op0))\n \t{\n \t  unsigned int r = REGNO (op0);\n \n@@ -2119,9 +2119,9 @@ operands_match_p (rtx x, rtx y)\n \n   if (x == y)\n     return 1;\n-  if ((code == REG || (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG))\n-      && (GET_CODE (y) == REG || (GET_CODE (y) == SUBREG\n-\t\t\t\t  && GET_CODE (SUBREG_REG (y)) == REG)))\n+  if ((code == REG || (code == SUBREG && REG_P (SUBREG_REG (x))))\n+      && (REG_P (y) || (GET_CODE (y) == SUBREG\n+\t\t\t\t  && REG_P (SUBREG_REG (y)))))\n     {\n       int j;\n \n@@ -2358,7 +2358,7 @@ decompose (rtx x)\n       val.base = base;\n       return val;\n     }\n-  else if (GET_CODE (x) == REG)\n+  else if (REG_P (x))\n     {\n       val.reg_flag = 1;\n       val.start = true_regnum (x);\n@@ -2374,7 +2374,7 @@ decompose (rtx x)\n     }\n   else if (GET_CODE (x) == SUBREG)\n     {\n-      if (GET_CODE (SUBREG_REG (x)) != REG)\n+      if (!REG_P (SUBREG_REG (x)))\n \t/* This could be more precise, but it's good enough.  */\n \treturn decompose (SUBREG_REG (x));\n       val.reg_flag = 1;\n@@ -2562,9 +2562,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n      is cheap to move between them.  If it is not, there may not be an insn\n      to do the copy, so we may need a reload.  */\n   if (GET_CODE (body) == SET\n-      && GET_CODE (SET_DEST (body)) == REG\n+      && REG_P (SET_DEST (body))\n       && REGNO (SET_DEST (body)) < FIRST_PSEUDO_REGISTER\n-      && GET_CODE (SET_SRC (body)) == REG\n+      && REG_P (SET_SRC (body))\n       && REGNO (SET_SRC (body)) < FIRST_PSEUDO_REGISTER\n       && REGISTER_MOVE_COST (GET_MODE (SET_SRC (body)),\n \t\t\t     REGNO_REG_CLASS (REGNO (SET_SRC (body))),\n@@ -2762,7 +2762,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t  if (replace\n \t      && GET_CODE (op) == MEM\n-\t      && GET_CODE (reg) == REG\n+\t      && REG_P (reg)\n \t      && (GET_MODE_SIZE (GET_MODE (reg))\n \t\t  >= GET_MODE_SIZE (GET_MODE (op))))\n \t    set_unique_reg_note (emit_insn_before (gen_rtx_USE (VOIDmode, reg),\n@@ -2912,7 +2912,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t it is a hard reg.  This is because it is passed\n \t\t to reg_fits_class_p if it is a REG and all pseudos\n \t\t return 0 from that function.  */\n-\t      if (GET_CODE (SUBREG_REG (operand)) == REG\n+\t      if (REG_P (SUBREG_REG (operand))\n \t\t  && REGNO (SUBREG_REG (operand)) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  if (!subreg_offset_representable_p\n@@ -2956,7 +2956,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t     of a mem that is _not_ to be handled specially?  IMO\n \t\t     those should have been reduced to just a mem.  */\n \t\t  || ((GET_CODE (operand) == MEM\n-\t\t       || (GET_CODE (operand)== REG\n+\t\t       || (REG_P (operand)\n \t\t\t   && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n #ifndef WORD_REGISTER_OPERATIONS\n \t\t      && (((GET_MODE_BITSIZE (GET_MODE (operand))\n@@ -3126,7 +3126,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\tif (force_reload)\n \t\t  break;\n \t\tif (GET_CODE (operand) == MEM\n-\t\t    || (GET_CODE (operand) == REG\n+\t\t    || (REG_P (operand)\n \t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t&& reg_renumber[REGNO (operand)] < 0))\n \t\t  win = 1;\n@@ -3162,7 +3162,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t       after they themselves are reloaded.  This is important;\n \t\t       we don't want our own handling of unoffsettables\n \t\t       to override the handling of reg_equiv_address.  */\n-\t\t    && !(GET_CODE (XEXP (operand, 0)) == REG\n+\t\t    && !(REG_P (XEXP (operand, 0))\n \t\t\t && (ind_levels == 0\n \t\t\t     || reg_equiv_address[REGNO (XEXP (operand, 0))] != 0)))\n \t\t  win = 1;\n@@ -3181,7 +3181,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t /* A reloaded address is offsettable because it is now\n \t\t\t    just a simple register indirect.  */\n \t\t\t || address_reloaded[i]))\n-\t\t    || (GET_CODE (operand) == REG\n+\t\t    || (REG_P (operand)\n \t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t&& reg_renumber[REGNO (operand)] < 0\n \t\t\t/* If reg_equiv_address is nonzero, we will be\n@@ -3272,7 +3272,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t|| LEGITIMATE_PIC_OPERAND_P (operand))\n #endif\n \t\t    && (GENERAL_REGS == ALL_REGS\n-\t\t\t|| GET_CODE (operand) != REG\n+\t\t\t|| !REG_P (operand)\n \t\t\t|| (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t    && reg_renumber[REGNO (operand)] < 0)))\n \t\t  win = 1;\n@@ -3301,7 +3301,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t/* Likewise if the address will be reloaded because\n \t\t\t   reg_equiv_address is nonzero.  For reg_equiv_mem\n \t\t\t   we have to check.  */\n-\t\t        else if (GET_CODE (operand) == REG\n+\t\t        else if (REG_P (operand)\n \t\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t\t && reg_renumber[REGNO (operand)] < 0\n \t\t\t\t && ((reg_equiv_mem[REGNO (operand)] != 0\n@@ -3345,7 +3345,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\tif (GET_MODE (operand) == BLKmode)\n \t\t  break;\n \t\twinreg = 1;\n-\t\tif (GET_CODE (operand) == REG\n+\t\tif (REG_P (operand)\n \t\t    && reg_fits_class_p (operand, this_alternative[i],\n \t\t\t\t\t offset, GET_MODE (recog_data.operand[i])))\n \t\t  win = 1;\n@@ -3375,7 +3375,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      if (badop)\n \t\tbad = 1;\n \t      /* Alternative loses if it has no regs for a reg operand.  */\n-\t      if (GET_CODE (operand) == REG\n+\t      if (REG_P (operand)\n \t\t  && this_alternative[i] == (int) NO_REGS\n \t\t  && this_alternative_matches[i] < 0)\n \t\tbad = 1;\n@@ -3431,7 +3431,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t case where we are forcing a constant into memory and\n \t\t it will then win since we don't want to have a different\n \t\t alternative match then.  */\n-\t      if (! (GET_CODE (operand) == REG\n+\t      if (! (REG_P (operand)\n \t\t     && REGNO (operand) >= FIRST_PSEUDO_REGISTER)\n \t\t  && GET_CODE (operand) != SCRATCH\n \t\t  && ! (const_to_mem && constmemok))\n@@ -3530,7 +3530,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t  /* If the output is in a single-reg class,\n \t\t     it's costly to reload it, so reload the input instead.  */\n \t\t  if (reg_class_size[this_alternative[i]] == 1\n-\t\t      && (GET_CODE (recog_data.operand[j]) == REG\n+\t\t      && (REG_P (recog_data.operand[j])\n \t\t\t  || GET_CODE (recog_data.operand[j]) == SUBREG))\n \t\t    {\n \t\t      losers++;\n@@ -3908,7 +3908,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \twhile (GET_CODE (operand) == SUBREG)\n \t  operand = SUBREG_REG (operand);\n \tif ((GET_CODE (operand) == MEM\n-\t     || (GET_CODE (operand) == REG\n+\t     || (REG_P (operand)\n \t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n \t    /* If this is only for an output, the optional reload would not\n \t       actually cause us to use a register now, just note that\n@@ -3949,15 +3949,15 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t   inheritance will do the right thing.  */\n \telse if (replace\n \t\t && (GET_CODE (operand) == MEM\n-\t\t     || (GET_CODE (operand) == REG\n+\t\t     || (REG_P (operand)\n \t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t && reg_renumber [REGNO (operand)] < 0)))\n \t  {\n \t    operand = *recog_data.operand_loc[i];\n \n \t    while (GET_CODE (operand) == SUBREG)\n \t      operand = SUBREG_REG (operand);\n-\t    if (GET_CODE (operand) == REG)\n+\t    if (REG_P (operand))\n \t      {\n \t\tif (modified[i] != RELOAD_WRITE)\n \t\t  /* We mark the USE with QImode so that we recognize\n@@ -3985,7 +3985,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \twhile (GET_CODE (operand) == SUBREG)\n \t  operand = SUBREG_REG (operand);\n \tif ((GET_CODE (operand) == MEM\n-\t     || (GET_CODE (operand) == REG\n+\t     || (REG_P (operand)\n \t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n \t    && ((enum reg_class) goal_alternative[goal_alternative_matches[i]]\n \t\t!= NO_REGS))\n@@ -4060,7 +4060,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   for (i = 0; i < n_reloads; i++)\n     if (rld[i].reg_rtx == 0\n \t&& rld[i].in != 0\n-\t&& GET_CODE (rld[i].in) == REG\n+\t&& REG_P (rld[i].in)\n \t&& rld[i].out == 0)\n       {\n \trld[i].reg_rtx\n@@ -4365,7 +4365,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   for (i = 0; i < n_reloads; i++)\n     if (rld[i].when_needed == RELOAD_FOR_INPUT\n \t&& GET_CODE (PATTERN (insn)) == SET\n-\t&& GET_CODE (SET_DEST (PATTERN (insn))) == REG\n+\t&& REG_P (SET_DEST (PATTERN (insn)))\n \t&& SET_SRC (PATTERN (insn)) == rld[i].in)\n       {\n \trtx dest = SET_DEST (PATTERN (insn));\n@@ -4494,7 +4494,7 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n       return tem;\n     }\n \n-  if (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG)\n+  if (code == SUBREG && REG_P (SUBREG_REG (x)))\n     {\n       /* Check for SUBREG containing a REG that's equivalent to a constant.\n \t If the constant has a known value, truncate it right now.\n@@ -4658,7 +4658,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n      reload if not.  We first handle the cases where we need not reload\n      or where we must reload in a non-standard way.  */\n \n-  if (GET_CODE (ad) == REG)\n+  if (REG_P (ad))\n     {\n       regno = REGNO (ad);\n \n@@ -4692,9 +4692,9 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n \t      if (ind_levels > 0\n \t\t  && strict_memory_address_p (mode, tem)\n-\t\t  && (GET_CODE (XEXP (tem, 0)) == REG\n+\t\t  && (REG_P (XEXP (tem, 0))\n \t\t      || (GET_CODE (XEXP (tem, 0)) == PLUS\n-\t\t\t  && GET_CODE (XEXP (XEXP (tem, 0), 0)) == REG\n+\t\t\t  && REG_P (XEXP (XEXP (tem, 0), 0))\n \t\t\t  && CONSTANT_P (XEXP (XEXP (tem, 0), 1)))))\n \t\t{\n \t\t  /* TEM is not the same as what we'll be replacing the\n@@ -4747,7 +4747,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n       /* But first quickly dispose of a common case.  */\n       if (GET_CODE (ad) == PLUS\n \t  && GET_CODE (XEXP (ad, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (ad, 0)) == REG\n+\t  && REG_P (XEXP (ad, 0))\n \t  && reg_equiv_constant[REGNO (XEXP (ad, 0))] == 0)\n \treturn 0;\n \n@@ -4823,9 +4823,9 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n       if (ind_levels == 0\n \t  || (GET_CODE (XEXP (tem, 0)) == SYMBOL_REF && ! indirect_symref_ok)\n \t  || GET_CODE (XEXP (tem, 0)) == MEM\n-\t  || ! (GET_CODE (XEXP (tem, 0)) == REG\n+\t  || ! (REG_P (XEXP (tem, 0))\n \t\t|| (GET_CODE (XEXP (tem, 0)) == PLUS\n-\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 0)) == REG\n+\t\t    && REG_P (XEXP (XEXP (tem, 0), 0))\n \t\t    && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)))\n \t{\n \t  /* Must use TEM here, not AD, since it is the one that will\n@@ -4846,7 +4846,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n      targets (namely SH) we can also get too large displacements from\n      big-endian corrections.  */\n   else if (GET_CODE (ad) == PLUS\n-\t   && GET_CODE (XEXP (ad, 0)) == REG\n+\t   && REG_P (XEXP (ad, 0))\n \t   && REGNO (XEXP (ad, 0)) < FIRST_PSEUDO_REGISTER\n \t   && REG_MODE_OK_FOR_BASE_P (XEXP (ad, 0), mode)\n \t   && GET_CODE (XEXP (ad, 1)) == CONST_INT)\n@@ -4909,7 +4909,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n   else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n \t   && GET_CODE (XEXP (ad, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (ad, 0), 0)) == REG\n+\t   && REG_P (XEXP (XEXP (ad, 0), 0))\n \t   && REGNO (XEXP (XEXP (ad, 0), 0)) < FIRST_PSEUDO_REGISTER\n \t   && (REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 0), mode)\n \t       || XEXP (XEXP (ad, 0), 0) == frame_pointer_rtx\n@@ -4937,7 +4937,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n   else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n \t   && GET_CODE (XEXP (ad, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (ad, 0), 1)) == REG\n+\t   && REG_P (XEXP (XEXP (ad, 0), 1))\n \t   && REGNO (XEXP (XEXP (ad, 0), 1)) < FIRST_PSEUDO_REGISTER\n \t   && (REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 1), mode)\n \t       || XEXP (XEXP (ad, 0), 1) == frame_pointer_rtx\n@@ -5152,12 +5152,12 @@ subst_indexed_address (rtx addr)\n     {\n       /* Try to find a register to replace.  */\n       op0 = XEXP (addr, 0), op1 = XEXP (addr, 1), op2 = 0;\n-      if (GET_CODE (op0) == REG\n+      if (REG_P (op0)\n \t  && (regno = REGNO (op0)) >= FIRST_PSEUDO_REGISTER\n \t  && reg_renumber[regno] < 0\n \t  && reg_equiv_constant[regno] != 0)\n \top0 = reg_equiv_constant[regno];\n-      else if (GET_CODE (op1) == REG\n+      else if (REG_P (op1)\n \t       && (regno = REGNO (op1)) >= FIRST_PSEUDO_REGISTER\n \t       && reg_renumber[regno] < 0\n \t       && reg_equiv_constant[regno] != 0)\n@@ -5464,7 +5464,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n     case POST_DEC:\n     case PRE_INC:\n     case PRE_DEC:\n-      if (GET_CODE (XEXP (x, 0)) == REG)\n+      if (REG_P (XEXP (x, 0)))\n \t{\n \t  int regno = REGNO (XEXP (x, 0));\n \t  int value = 0;\n@@ -5699,7 +5699,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n       return 0;\n \n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (x)) == REG)\n+      if (REG_P (SUBREG_REG (x)))\n \t{\n \t  /* If this is a SUBREG of a hard register and the resulting register\n \t     is of the wrong class, reload the whole SUBREG.  This avoids\n@@ -5879,7 +5879,7 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t\treturn x;\n \t\t      base = XEXP (base, 0);\n \t\t    }\n-\t\t  if (GET_CODE (base) != REG\n+\t\t  if (!REG_P (base)\n \t\t      || (REGNO_POINTER_ALIGN (REGNO (base))\n \t\t\t  < outer_size * BITS_PER_UNIT))\n \t\t    return x;\n@@ -6101,7 +6101,7 @@ find_replacement (rtx *loc)\n \n \t     ??? Is it actually still ever a SUBREG?  If so, why?  */\n \n-\t  if (GET_CODE (reloadreg) == REG)\n+\t  if (REG_P (reloadreg))\n \t    return gen_rtx_REG (GET_MODE (*loc),\n \t\t\t\t(REGNO (reloadreg) +\n \t\t\t\t subreg_regno_offset (REGNO (SUBREG_REG (*loc)),\n@@ -6192,7 +6192,7 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n     case SUBREG:\n       /* If this is a SUBREG of a hard reg, we can see exactly which\n \t registers are being modified.  Otherwise, handle normally.  */\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n+      if (REG_P (SUBREG_REG (x))\n \t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n \t{\n \t  unsigned int inner_regno = subreg_regno (x);\n@@ -6212,14 +6212,14 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n \t     treat each word individually.  */\n \t  && ((GET_CODE (SET_DEST (x)) == SUBREG\n \t       && loc != &SUBREG_REG (SET_DEST (x))\n-\t       && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n+\t       && REG_P (SUBREG_REG (SET_DEST (x)))\n \t       && REGNO (SUBREG_REG (SET_DEST (x))) >= FIRST_PSEUDO_REGISTER\n \t       && refers_to_regno_for_reload_p (regno, endregno,\n \t\t\t\t\t\tSUBREG_REG (SET_DEST (x)),\n \t\t\t\t\t\tloc))\n \t      /* If the output is an earlyclobber operand, this is\n \t\t a conflict.  */\n-\t      || ((GET_CODE (SET_DEST (x)) != REG\n+\t      || ((!REG_P (SET_DEST (x))\n \t\t   || earlyclobber_operand_p (SET_DEST (x)))\n \t\t  && refers_to_regno_for_reload_p (regno, endregno,\n \t\t\t\t\t\t   SET_DEST (x), loc))))\n@@ -6295,7 +6295,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \t\t\t\t      SUBREG_BYTE (x),\n \t\t\t\t      GET_MODE (x));\n     }\n-  else if (GET_CODE (x) == REG)\n+  else if (REG_P (x))\n     {\n       regno = REGNO (x);\n \n@@ -6325,7 +6325,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \t into a RELOAD_OTHER on behalf of another RELOAD_OTHER.  */\n       while (GET_CODE (in) == MEM)\n \tin = XEXP (in, 0);\n-      if (GET_CODE (in) == REG)\n+      if (REG_P (in))\n \treturn 0;\n       else if (GET_CODE (in) == PLUS)\n \treturn (reg_overlap_mentioned_for_reload_p (x, XEXP (in, 0))\n@@ -6354,7 +6354,7 @@ refers_to_mem_for_reload_p (rtx x)\n   if (GET_CODE (x) == MEM)\n     return 1;\n \n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     return (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t    && reg_equiv_memory_loc[REGNO (x)]);\n \n@@ -6414,7 +6414,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \n   if (goal == 0)\n     regno = goalreg;\n-  else if (GET_CODE (goal) == REG)\n+  else if (REG_P (goal))\n     regno = REGNO (goal);\n   else if (GET_CODE (goal) == MEM)\n     {\n@@ -6510,7 +6510,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t      && ((rtx_equal_p (XEXP (tem, 0), goal)\n \t\t\t   && (valueno\n \t\t\t       = true_regnum (valtry = SET_DEST (pat))) >= 0)\n-\t\t\t  || (GET_CODE (SET_DEST (pat)) == REG\n+\t\t\t  || (REG_P (SET_DEST (pat))\n \t\t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n \t\t\t      && (GET_MODE_CLASS (GET_MODE (XEXP (tem, 0)))\n \t\t\t\t  == MODE_FLOAT)\n@@ -6525,7 +6525,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t\t      && (valueno = true_regnum (valtry)) >= 0)))\n \t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV,\n \t\t\t\t\t\t\t  NULL_RTX))\n-\t\t      && GET_CODE (SET_DEST (pat)) == REG\n+\t\t      && REG_P (SET_DEST (pat))\n \t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n \t\t      && (GET_MODE_CLASS (GET_MODE (XEXP (tem, 0)))\n \t\t\t  == MODE_FLOAT)\n@@ -6700,7 +6700,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n \t\tdest = XEXP (dest, 0);\n-\t      if (GET_CODE (dest) == REG)\n+\t      if (REG_P (dest))\n \t\t{\n \t\t  int xregno = REGNO (dest);\n \t\t  int xnregs;\n@@ -6744,7 +6744,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n \t\t\tdest = XEXP (dest, 0);\n-\t\t      if (GET_CODE (dest) == REG)\n+\t\t      if (REG_P (dest))\n \t\t\t{\n \t\t\t  int xregno = REGNO (dest);\n \t\t\t  int xnregs;\n@@ -6790,7 +6790,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t    {\n \t\t      rtx dest = SET_DEST (pat);\n \n-\t\t      if (GET_CODE (dest) == REG)\n+\t\t      if (REG_P (dest))\n \t\t\t{\n \t\t\t  int xregno = REGNO (dest);\n \t\t\t  int xnregs\n@@ -6828,7 +6828,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \n \t    for (link = REG_NOTES (p); link; link = XEXP (link, 1))\n \t      if (REG_NOTE_KIND (link) == REG_INC\n-\t\t  && GET_CODE (XEXP (link, 0)) == REG)\n+\t\t  && REG_P (XEXP (link, 0)))\n \t\t{\n \t\t  int incno = REGNO (XEXP (link, 0));\n \t\t  if (incno < regno + nregs && incno >= regno)\n@@ -6914,7 +6914,7 @@ regno_clobbered_p (unsigned int regno, rtx insn, enum machine_mode mode,\n \n   if ((GET_CODE (PATTERN (insn)) == CLOBBER\n        || (sets && GET_CODE (PATTERN (insn)) == SET))\n-      && GET_CODE (XEXP (PATTERN (insn), 0)) == REG)\n+      && REG_P (XEXP (PATTERN (insn), 0)))\n     {\n       unsigned int test = REGNO (XEXP (PATTERN (insn), 0));\n \n@@ -6930,7 +6930,7 @@ regno_clobbered_p (unsigned int regno, rtx insn, enum machine_mode mode,\n \t  rtx elt = XVECEXP (PATTERN (insn), 0, i);\n \t  if ((GET_CODE (elt) == CLOBBER\n \t       || (sets && GET_CODE (PATTERN (insn)) == SET))\n-\t      && GET_CODE (XEXP (elt, 0)) == REG)\n+\t      && REG_P (XEXP (elt, 0)))\n \t    {\n \t      unsigned int test = REGNO (XEXP (elt, 0));\n "}, {"sha": "ea01b688506bf2a1d4842edac00f025ea015ee38", "filename": "gcc/reload1.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -584,7 +584,7 @@ replace_pseudos_in (rtx *loc, enum machine_mode mem_mode, rtx usage)\n \t*loc = reg_equiv_mem[regno];\n       else if (reg_equiv_address[regno])\n \t*loc = gen_rtx_MEM (GET_MODE (x), reg_equiv_address[regno]);\n-      else if (GET_CODE (regno_reg_rtx[regno]) != REG\n+      else if (!REG_P (regno_reg_rtx[regno])\n \t       || REGNO (regno_reg_rtx[regno]) != regno)\n \t*loc = regno_reg_rtx[regno];\n       else\n@@ -730,7 +730,7 @@ reload (rtx first, int global)\n \t  && GET_MODE (insn) != VOIDmode)\n \tPUT_MODE (insn, VOIDmode);\n \n-      if (set != 0 && GET_CODE (SET_DEST (set)) == REG)\n+      if (set != 0 && REG_P (SET_DEST (set)))\n \t{\n \t  rtx note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \t  if (note\n@@ -804,7 +804,7 @@ reload (rtx first, int global)\n       /* If this insn is setting a MEM from a register equivalent to it,\n \t this is the equivalencing insn.  */\n       else if (set && GET_CODE (SET_DEST (set)) == MEM\n-\t       && GET_CODE (SET_SRC (set)) == REG\n+\t       && REG_P (SET_SRC (set))\n \t       && reg_equiv_memory_loc[REGNO (SET_SRC (set))]\n \t       && rtx_equal_p (SET_DEST (set),\n \t\t\t       reg_equiv_memory_loc[REGNO (SET_SRC (set))]))\n@@ -938,10 +938,10 @@ reload (rtx first, int global)\n \t\t\t\t\t XEXP (x, 0)))\n \t      reg_equiv_mem[i] = x, reg_equiv_address[i] = 0;\n \t    else if (CONSTANT_P (XEXP (x, 0))\n-\t\t     || (GET_CODE (XEXP (x, 0)) == REG\n+\t\t     || (REG_P (XEXP (x, 0))\n \t\t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER)\n \t\t     || (GET_CODE (XEXP (x, 0)) == PLUS\n-\t\t\t && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+\t\t\t && REG_P (XEXP (XEXP (x, 0), 0))\n \t\t\t && (REGNO (XEXP (XEXP (x, 0), 0))\n \t\t\t     < FIRST_PSEUDO_REGISTER)\n \t\t\t && CONSTANT_P (XEXP (XEXP (x, 0), 1))))\n@@ -1180,7 +1180,7 @@ reload (rtx first, int global)\n \t\t    || (GET_CODE (XEXP (XEXP (PATTERN (insn), 0), 0)) != SCRATCH\n \t\t\t&& XEXP (XEXP (PATTERN (insn), 0), 0)\n \t\t\t\t!= stack_pointer_rtx))\n-\t\t&& (GET_CODE (XEXP (PATTERN (insn), 0)) != REG\n+\t\t&& (!REG_P (XEXP (PATTERN (insn), 0))\n \t\t    || ! REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))))\n \t  {\n \t    delete_insn (insn);\n@@ -1454,7 +1454,7 @@ calculate_needs_all_insns (int global)\n \t  rtx set = single_set (insn);\n \n \t  /* Skip insns that only set an equivalence.  */\n-\t  if (set && GET_CODE (SET_DEST (set)) == REG\n+\t  if (set && REG_P (SET_DEST (set))\n \t      && reg_renumber[REGNO (SET_DEST (set))] < 0\n \t      && reg_equiv_constant[REGNO (SET_DEST (set))])\n \t    continue;\n@@ -1479,7 +1479,7 @@ calculate_needs_all_insns (int global)\n \t      rtx set = single_set (insn);\n \t      if (set\n \t\t  && SET_SRC (set) == SET_DEST (set)\n-\t\t  && GET_CODE (SET_SRC (set)) == REG\n+\t\t  && REG_P (SET_SRC (set))\n \t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  delete_insn (insn);\n@@ -1714,9 +1714,9 @@ find_reg (struct insn_chain *chain, int order)\n \t    }\n \t  if (! ok)\n \t    continue;\n-\t  if (rl->in && GET_CODE (rl->in) == REG && REGNO (rl->in) == regno)\n+\t  if (rl->in && REG_P (rl->in) && REGNO (rl->in) == regno)\n \t    this_cost--;\n-\t  if (rl->out && GET_CODE (rl->out) == REG && REGNO (rl->out) == regno)\n+\t  if (rl->out && REG_P (rl->out) && REGNO (rl->out) == regno)\n \t    this_cost--;\n \t  if (this_cost < best_cost\n \t      /* Among registers with equal cost, prefer caller-saved ones, or\n@@ -1905,7 +1905,7 @@ delete_dead_insn (rtx insn)\n   /* If the previous insn sets a register that dies in our insn, delete it\n      too.  */\n   if (prev && GET_CODE (PATTERN (prev)) == SET\n-      && (prev_dest = SET_DEST (PATTERN (prev)), GET_CODE (prev_dest) == REG)\n+      && (prev_dest = SET_DEST (PATTERN (prev)), REG_P (prev_dest))\n       && reg_mentioned_p (prev_dest, PATTERN (insn))\n       && find_regno_note (insn, REG_DEAD, REGNO (prev_dest))\n       && ! side_effects_p (SET_SRC (PATTERN (prev))))\n@@ -1934,7 +1934,7 @@ alter_reg (int i, int from_reg)\n \n   /* If the reg got changed to a MEM at rtl-generation time,\n      ignore it.  */\n-  if (GET_CODE (regno_reg_rtx[i]) != REG)\n+  if (!REG_P (regno_reg_rtx[i]))\n     return;\n \n   /* Modify the reg-rtx to contain the new hard reg\n@@ -2055,7 +2055,7 @@ alter_reg (int i, int from_reg)\n \t     any copies of it, since otherwise when the stack slot\n \t     is reused, nonoverlapping_memrefs_p might think they\n \t     cannot overlap.  */\n-\t  if (decl && GET_CODE (decl) == REG && REGNO (decl) == (unsigned) i)\n+\t  if (decl && REG_P (decl) && REGNO (decl) == (unsigned) i)\n \t    {\n \t      if (from_reg != -1 && spill_stack_slot[from_reg] == x)\n \t\tx = copy_rtx (x);\n@@ -2334,7 +2334,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n     case PLUS:\n       /* If this is the sum of an eliminable register and a constant, rework\n \t the sum.  */\n-      if (GET_CODE (XEXP (x, 0)) == REG\n+      if (REG_P (XEXP (x, 0))\n \t  && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n \t  && CONSTANT_P (XEXP (x, 1)))\n \t{\n@@ -2383,13 +2383,13 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t       didn't get a hard register but has a reg_equiv_constant,\n \t       we must replace the constant here since it may no longer\n \t       be in the position of any operand.  */\n-\t    if (GET_CODE (new0) == PLUS && GET_CODE (new1) == REG\n+\t    if (GET_CODE (new0) == PLUS && REG_P (new1)\n \t\t&& REGNO (new1) >= FIRST_PSEUDO_REGISTER\n \t\t&& reg_renumber[REGNO (new1)] < 0\n \t\t&& reg_equiv_constant != 0\n \t\t&& reg_equiv_constant[REGNO (new1)] != 0)\n \t      new1 = reg_equiv_constant[REGNO (new1)];\n-\t    else if (GET_CODE (new1) == PLUS && GET_CODE (new0) == REG\n+\t    else if (GET_CODE (new1) == PLUS && REG_P (new0)\n \t\t     && REGNO (new0) >= FIRST_PSEUDO_REGISTER\n \t\t     && reg_renumber[REGNO (new0)] < 0\n \t\t     && reg_equiv_constant[REGNO (new0)] != 0)\n@@ -2414,7 +2414,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t so that we have (plus (mult ..) ..).  This is needed in order\n \t to keep load-address insns valid.   This case is pathological.\n \t We ignore the possibility of overflow here.  */\n-      if (GET_CODE (XEXP (x, 0)) == REG\n+      if (REG_P (XEXP (x, 0))\n \t  && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n \t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n \tfor (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n@@ -2519,7 +2519,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t pseudo didn't get a hard reg, we must replace this with the\n \t eliminated version of the memory location because push_reload\n \t may do the replacement in certain circumstances.  */\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n+      if (REG_P (SUBREG_REG (x))\n \t  && (GET_MODE_SIZE (GET_MODE (x))\n \t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \t  && reg_equiv_memory_loc != 0\n@@ -2738,7 +2738,7 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n       return;\n \n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n+      if (REG_P (SUBREG_REG (x))\n \t  && (GET_MODE_SIZE (GET_MODE (x))\n \t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \t  && reg_equiv_memory_loc != 0\n@@ -2772,7 +2772,7 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n \n     case SET:\n       /* Check for setting a register that we know about.  */\n-      if (GET_CODE (SET_DEST (x)) == REG)\n+      if (REG_P (SET_DEST (x)))\n \t{\n \t  /* See if this is setting the replacement register for an\n \t     elimination.\n@@ -2910,7 +2910,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n       abort ();\n     }\n \n-  if (old_set != 0 && GET_CODE (SET_DEST (old_set)) == REG\n+  if (old_set != 0 && REG_P (SET_DEST (old_set))\n       && REGNO (SET_DEST (old_set)) < FIRST_PSEUDO_REGISTER)\n     {\n       /* Check for setting an eliminable register.  */\n@@ -3004,15 +3004,15 @@ eliminate_regs_in_insn (rtx insn, int replace)\n      currently support: a single set with the source or a REG_EQUAL\n      note being a PLUS of an eliminable register and a constant.  */\n   plus_src = 0;\n-  if (old_set && GET_CODE (SET_DEST (old_set)) == REG)\n+  if (old_set && REG_P (SET_DEST (old_set)))\n     {\n       /* First see if the source is of the form (plus (reg) CST).  */\n       if (GET_CODE (SET_SRC (old_set)) == PLUS\n-\t  && GET_CODE (XEXP (SET_SRC (old_set), 0)) == REG\n+\t  && REG_P (XEXP (SET_SRC (old_set), 0))\n \t  && GET_CODE (XEXP (SET_SRC (old_set), 1)) == CONST_INT\n \t  && REGNO (XEXP (SET_SRC (old_set), 0)) < FIRST_PSEUDO_REGISTER)\n \tplus_src = SET_SRC (old_set);\n-      else if (GET_CODE (SET_SRC (old_set)) == REG)\n+      else if (REG_P (SET_SRC (old_set)))\n \t{\n \t  /* Otherwise, see if we have a REG_EQUAL note of the form\n \t     (plus (reg) CST).  */\n@@ -3021,7 +3021,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t    {\n \t      if (REG_NOTE_KIND (links) == REG_EQUAL\n \t\t  && GET_CODE (XEXP (links, 0)) == PLUS\n-\t\t  && GET_CODE (XEXP (XEXP (links, 0), 0)) == REG\n+\t\t  && REG_P (XEXP (XEXP (links, 0), 0))\n \t\t  && GET_CODE (XEXP (XEXP (links, 0), 1)) == CONST_INT\n \t\t  && REGNO (XEXP (XEXP (links, 0), 0)) < FIRST_PSEUDO_REGISTER)\n \t\t{\n@@ -3110,7 +3110,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t{\n \t  /* Check for setting a register that we know about.  */\n \t  if (recog_data.operand_type[i] != OP_IN\n-\t      && GET_CODE (orig_operand[i]) == REG)\n+\t      && REG_P (orig_operand[i]))\n \t    {\n \t      /* If we are assigning to a register that can be eliminated, it\n \t\t must be as part of a PARALLEL, since the code above handles\n@@ -3133,7 +3133,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t/* If an output operand changed from a REG to a MEM and INSN is an\n \t   insn, write a CLOBBER insn.  */\n \t  if (recog_data.operand_type[i] != OP_IN\n-\t      && GET_CODE (orig_operand[i]) == REG\n+\t      && REG_P (orig_operand[i])\n \t      && GET_CODE (substed_operand[i]) == MEM\n \t      && replace)\n \t    emit_insn_after (gen_rtx_CLOBBER (VOIDmode, orig_operand[i]),\n@@ -3188,9 +3188,9 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t thing always?  */\n       if (! insn_is_asm\n \t  && old_set != 0\n-\t  && ((GET_CODE (SET_SRC (old_set)) == REG\n+\t  && ((REG_P (SET_SRC (old_set))\n \t       && (GET_CODE (new_body) != SET\n-\t\t   || GET_CODE (SET_SRC (new_body)) != REG))\n+\t\t   || !REG_P (SET_SRC (new_body))))\n \t      /* If this was a load from or store to memory, compare\n \t\t the MEM in recog_data.operand to the one in the insn.\n \t\t If they are not equal, then rerecognize the insn.  */\n@@ -3756,7 +3756,7 @@ scan_paradoxical_subregs (rtx x)\n       return;\n \n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n+      if (REG_P (SUBREG_REG (x))\n \t  && GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \treg_max_ref_width[REGNO (SUBREG_REG (x))]\n \t  = GET_MODE_SIZE (GET_MODE (x));\n@@ -4091,7 +4091,7 @@ forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n       x = SUBREG_REG (x);\n     }\n \n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     return;\n \n   regno = REGNO (x);\n@@ -4815,7 +4815,7 @@ reload_reg_free_for_value_p (int start_regno, int regno, int opnum,\n   for (i = 0; i < n_reloads; i++)\n     {\n       rtx reg = rld[i].reg_rtx;\n-      if (reg && GET_CODE (reg) == REG\n+      if (reg && REG_P (reg)\n \t  && ((unsigned) regno - true_regnum (reg)\n \t      <= hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] - (unsigned) 1)\n \t  && i != reloadnum)\n@@ -5402,18 +5402,18 @@ choose_reload_regs (struct insn_chain *chain)\n \n \t      if (rld[r].in == 0)\n \t\t;\n-\t      else if (GET_CODE (rld[r].in) == REG)\n+\t      else if (REG_P (rld[r].in))\n \t\t{\n \t\t  regno = REGNO (rld[r].in);\n \t\t  mode = GET_MODE (rld[r].in);\n \t\t}\n-\t      else if (GET_CODE (rld[r].in_reg) == REG)\n+\t      else if (REG_P (rld[r].in_reg))\n \t\t{\n \t\t  regno = REGNO (rld[r].in_reg);\n \t\t  mode = GET_MODE (rld[r].in_reg);\n \t\t}\n \t      else if (GET_CODE (rld[r].in_reg) == SUBREG\n-\t\t       && GET_CODE (SUBREG_REG (rld[r].in_reg)) == REG)\n+\t\t       && REG_P (SUBREG_REG (rld[r].in_reg)))\n \t\t{\n \t\t  byte = SUBREG_BYTE (rld[r].in_reg);\n \t\t  regno = REGNO (SUBREG_REG (rld[r].in_reg));\n@@ -5426,7 +5426,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t\t|| GET_CODE (rld[r].in_reg) == PRE_DEC\n \t\t\t|| GET_CODE (rld[r].in_reg) == POST_INC\n \t\t\t|| GET_CODE (rld[r].in_reg) == POST_DEC)\n-\t\t       && GET_CODE (XEXP (rld[r].in_reg, 0)) == REG)\n+\t\t       && REG_P (XEXP (rld[r].in_reg, 0)))\n \t\t{\n \t\t  regno = REGNO (XEXP (rld[r].in_reg, 0));\n \t\t  mode = GET_MODE (XEXP (rld[r].in_reg, 0));\n@@ -5438,7 +5438,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t Also, it takes much more hair to keep track of all the things\n \t\t that can invalidate an inherited reload of part of a pseudoreg.  */\n \t      else if (GET_CODE (rld[r].in) == SUBREG\n-\t\t       && GET_CODE (SUBREG_REG (rld[r].in)) == REG)\n+\t\t       && REG_P (SUBREG_REG (rld[r].in)))\n \t\tregno = subreg_regno (rld[r].in);\n #endif\n \n@@ -5597,7 +5597,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t      && rld[r].out == 0\n \t      && (CONSTANT_P (rld[r].in)\n \t\t  || GET_CODE (rld[r].in) == PLUS\n-\t\t  || GET_CODE (rld[r].in) == REG\n+\t\t  || REG_P (rld[r].in)\n \t\t  || GET_CODE (rld[r].in) == MEM)\n \t      && (rld[r].nregs == max_group_size\n \t\t  || ! reg_classes_intersect_p (rld[r].class, group_class)))\n@@ -5623,7 +5623,7 @@ choose_reload_regs (struct insn_chain *chain)\n \n \t      if (equiv != 0)\n \t\t{\n-\t\t  if (GET_CODE (equiv) == REG)\n+\t\t  if (REG_P (equiv))\n \t\t    regno = REGNO (equiv);\n \t\t  else if (GET_CODE (equiv) == SUBREG)\n \t\t    {\n@@ -5872,7 +5872,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t  if (reload_inherited[r] && rld[r].reg_rtx)\n \t    check_reg = rld[r].reg_rtx;\n \t  else if (reload_override_in[r]\n-\t\t   && (GET_CODE (reload_override_in[r]) == REG\n+\t\t   && (REG_P (reload_override_in[r])\n \t\t       || GET_CODE (reload_override_in[r]) == SUBREG))\n \t    check_reg = reload_override_in[r];\n \t  else\n@@ -5941,7 +5941,7 @@ choose_reload_regs (struct insn_chain *chain)\n       /* I is nonneg if this reload uses a register.\n \t If rld[r].reg_rtx is 0, this is an optional reload\n \t that we opted to ignore.  */\n-      if (rld[r].out_reg != 0 && GET_CODE (rld[r].out_reg) == REG\n+      if (rld[r].out_reg != 0 && REG_P (rld[r].out_reg)\n \t  && rld[r].reg_rtx != 0)\n \t{\n \t  int nregno = REGNO (rld[r].out_reg);\n@@ -6212,7 +6212,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \n   if (oldequiv == 0 && optimize\n       && (GET_CODE (old) == MEM\n-\t  || (GET_CODE (old) == REG\n+\t  || (REG_P (old)\n \t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t      && reg_renumber[REGNO (old)] < 0)))\n     oldequiv = find_equiv_reg (old, insn, ALL_REGS, -1, NULL, 0, mode);\n@@ -6257,14 +6257,14 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n      find the pseudo in RELOAD_IN_REG.  */\n   if (oldequiv == 0\n       && reload_override_in[j]\n-      && GET_CODE (rl->in_reg) == REG)\n+      && REG_P (rl->in_reg))\n     {\n       oldequiv = old;\n       old = rl->in_reg;\n     }\n   if (oldequiv == 0)\n     oldequiv = old;\n-  else if (GET_CODE (oldequiv) == REG)\n+  else if (REG_P (oldequiv))\n     oldequiv_reg = oldequiv;\n   else if (GET_CODE (oldequiv) == SUBREG)\n     oldequiv_reg = SUBREG_REG (oldequiv);\n@@ -6273,10 +6273,10 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n      with an output-reload, see if we can prove there was\n      actually no need to store the old value in it.  */\n \n-  if (optimize && GET_CODE (oldequiv) == REG\n+  if (optimize && REG_P (oldequiv)\n       && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n       && spill_reg_store[REGNO (oldequiv)]\n-      && GET_CODE (old) == REG\n+      && REG_P (old)\n       && (dead_or_set_p (insn, spill_reg_stored_to[REGNO (oldequiv)])\n \t  || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n \t\t\t  rl->out_reg)))\n@@ -6346,10 +6346,10 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \n       old = XEXP (rl->in_reg, 0);\n \n-      if (optimize && GET_CODE (oldequiv) == REG\n+      if (optimize && REG_P (oldequiv)\n \t  && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n \t  && spill_reg_store[REGNO (oldequiv)]\n-\t  && GET_CODE (old) == REG\n+\t  && REG_P (old)\n \t  && (dead_or_set_p (insn,\n \t\t\t     spill_reg_stored_to[REGNO (oldequiv)])\n \t      || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n@@ -6368,7 +6368,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n      insn, see if we can get rid of that pseudo-register entirely\n      by redirecting the previous insn into our reload register.  */\n \n-  else if (optimize && GET_CODE (old) == REG\n+  else if (optimize && REG_P (old)\n \t   && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t   && dead_or_set_p (insn, old)\n \t   /* This is unsafe if some other reload\n@@ -6402,7 +6402,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t a reload register, and its spill_reg_store entry will\n \t\t contain the previous destination.  This is now\n \t\t invalid.  */\n-\t      if (GET_CODE (SET_SRC (PATTERN (temp))) == REG\n+\t      if (REG_P (SET_SRC (PATTERN (temp)))\n \t\t  && REGNO (SET_SRC (PATTERN (temp))) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  spill_reg_store[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n@@ -6465,7 +6465,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n       tmp = oldequiv;\n       if (GET_CODE (tmp) == SUBREG)\n \ttmp = SUBREG_REG (tmp);\n-      if (GET_CODE (tmp) == REG\n+      if (REG_P (tmp)\n \t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n \t  && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n \t      || reg_equiv_constant[REGNO (tmp)] != 0))\n@@ -6481,7 +6481,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n       tmp = old;\n       if (GET_CODE (tmp) == SUBREG)\n \ttmp = SUBREG_REG (tmp);\n-      if (GET_CODE (tmp) == REG\n+      if (REG_P (tmp)\n \t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n \t  && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n \t      || reg_equiv_constant[REGNO (tmp)] != 0))\n@@ -6591,12 +6591,12 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n     {\n       rtx real_oldequiv = oldequiv;\n \n-      if ((GET_CODE (oldequiv) == REG\n+      if ((REG_P (oldequiv)\n \t   && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n \t   && (reg_equiv_memory_loc[REGNO (oldequiv)] != 0\n \t       || reg_equiv_constant[REGNO (oldequiv)] != 0))\n \t  || (GET_CODE (oldequiv) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (oldequiv)) == REG\n+\t      && REG_P (SUBREG_REG (oldequiv))\n \t      && (REGNO (SUBREG_REG (oldequiv))\n \t\t  >= FIRST_PSEUDO_REGISTER)\n \t      && ((reg_equiv_memory_loc\n@@ -6671,7 +6671,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n     {\n       rtx real_old = old;\n \n-      if (GET_CODE (old) == REG && REGNO (old) >= FIRST_PSEUDO_REGISTER\n+      if (REG_P (old) && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t  && reg_equiv_mem[REGNO (old)] != 0)\n \treal_old = reg_equiv_mem[REGNO (old)];\n \n@@ -6749,7 +6749,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n       /* Don't output the last reload if OLD is not the dest of\n \t INSN and is in the src and is clobbered by INSN.  */\n       if (! flag_expensive_optimizations\n-\t  || GET_CODE (old) != REG\n+\t  || !REG_P (old)\n \t  || !(set = single_set (insn))\n \t  || rtx_equal_p (old, SET_DEST (set))\n \t  || !reg_mentioned_p (old, SET_SRC (set))\n@@ -6871,7 +6871,7 @@ do_input_reload (struct insn_chain *chain, struct reload *rl, int j)\n   if (optimize\n       && (reload_inherited[j] || reload_override_in[j])\n       && rl->reg_rtx\n-      && GET_CODE (rl->reg_rtx) == REG\n+      && REG_P (rl->reg_rtx)\n       && spill_reg_store[REGNO (rl->reg_rtx)] != 0\n #if 0\n       /* There doesn't seem to be any reason to restrict this to pseudos\n@@ -6906,7 +6906,7 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n \n   if (pseudo\n       && optimize\n-      && GET_CODE (pseudo) == REG\n+      && REG_P (pseudo)\n       && ! rtx_equal_p (rl->in_reg, pseudo)\n       && REGNO (pseudo) >= FIRST_PSEUDO_REGISTER\n       && reg_last_reload_reg[REGNO (pseudo)])\n@@ -6933,15 +6933,15 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n   /* An output operand that dies right away does need a reload,\n      but need not be copied from it.  Show the new location in the\n      REG_UNUSED note.  */\n-  if ((GET_CODE (old) == REG || GET_CODE (old) == SCRATCH)\n+  if ((REG_P (old) || GET_CODE (old) == SCRATCH)\n       && (note = find_reg_note (insn, REG_UNUSED, old)) != 0)\n     {\n       XEXP (note, 0) = rl->reg_rtx;\n       return;\n     }\n   /* Likewise for a SUBREG of an operand that dies.  */\n   else if (GET_CODE (old) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (old)) == REG\n+\t   && REG_P (SUBREG_REG (old))\n \t   && 0 != (note = find_reg_note (insn, REG_UNUSED,\n \t\t\t\t\t  SUBREG_REG (old))))\n     {\n@@ -7095,7 +7095,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t  if (GET_CODE (reg) == SUBREG)\n \t    reg = SUBREG_REG (reg);\n \n-\t  if (GET_CODE (reg) == REG\n+\t  if (REG_P (reg)\n \t      && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n \t      && ! reg_has_output_reload[REGNO (reg)])\n \t    {\n@@ -7148,13 +7148,13 @@ emit_reload_insns (struct insn_chain *chain)\n \n \t      /* Maybe the spill reg contains a copy of reload_out.  */\n \t      if (rld[r].out != 0\n-\t\t  && (GET_CODE (rld[r].out) == REG\n+\t\t  && (REG_P (rld[r].out)\n #ifdef AUTO_INC_DEC\n \t\t      || ! rld[r].out_reg\n #endif\n-\t\t      || GET_CODE (rld[r].out_reg) == REG))\n+\t\t      || REG_P (rld[r].out_reg)))\n \t\t{\n-\t\t  rtx out = (GET_CODE (rld[r].out) == REG\n+\t\t  rtx out = (REG_P (rld[r].out)\n \t\t\t     ? rld[r].out\n \t\t\t     : rld[r].out_reg\n \t\t\t     ? rld[r].out_reg\n@@ -7206,10 +7206,10 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t the register being reloaded.  */\n \t      else if (rld[r].out_reg == 0\n \t\t       && rld[r].in != 0\n-\t\t       && ((GET_CODE (rld[r].in) == REG\n+\t\t       && ((REG_P (rld[r].in)\n \t\t\t    && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER\n \t\t\t    && ! reg_has_output_reload[REGNO (rld[r].in)])\n-\t\t\t   || (GET_CODE (rld[r].in_reg) == REG\n+\t\t\t   || (REG_P (rld[r].in_reg)\n \t\t\t       && ! reg_has_output_reload[REGNO (rld[r].in_reg)]))\n \t\t       && ! reg_set_p (rld[r].reg_rtx, PATTERN (insn)))\n \t\t{\n@@ -7218,10 +7218,10 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  rtx in;\n \t\t  bool piecemeal;\n \n-\t\t  if (GET_CODE (rld[r].in) == REG\n+\t\t  if (REG_P (rld[r].in)\n \t\t      && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER)\n \t\t    in = rld[r].in;\n-\t\t  else if (GET_CODE (rld[r].in_reg) == REG)\n+\t\t  else if (REG_P (rld[r].in_reg))\n \t\t    in = rld[r].in_reg;\n \t\t  else\n \t\t    in = XEXP (rld[r].in_reg, 0);\n@@ -7288,11 +7288,11 @@ emit_reload_insns (struct insn_chain *chain)\n \t But forget_old_reloads_1 won't get to see it, because\n \t it thinks only about the original insn.  So invalidate it here.  */\n       if (i < 0 && rld[r].out != 0\n-\t  && (GET_CODE (rld[r].out) == REG\n+\t  && (REG_P (rld[r].out)\n \t      || (GET_CODE (rld[r].out) == MEM\n-\t\t  && GET_CODE (rld[r].out_reg) == REG)))\n+\t\t  && REG_P (rld[r].out_reg))))\n \t{\n-\t  rtx out = (GET_CODE (rld[r].out) == REG\n+\t  rtx out = (REG_P (rld[r].out)\n \t\t     ? rld[r].out : rld[r].out_reg);\n \t  int nregno = REGNO (out);\n \t  if (nregno >= FIRST_PSEUDO_REGISTER)\n@@ -7329,7 +7329,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t}\n \t      else\n \t\tstore_insn = new_spill_reg_store[REGNO (src_reg)];\n-\t      if (src_reg && GET_CODE (src_reg) == REG\n+\t      if (src_reg && REG_P (src_reg)\n \t\t  && REGNO (src_reg) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  int src_regno = REGNO (src_reg);\n@@ -7430,10 +7430,10 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n      ??? At some point, this whole thing needs to be rethought.  */\n \n   if (GET_CODE (in) == PLUS\n-      && (GET_CODE (XEXP (in, 0)) == REG\n+      && (REG_P (XEXP (in, 0))\n \t  || GET_CODE (XEXP (in, 0)) == SUBREG\n \t  || GET_CODE (XEXP (in, 0)) == MEM)\n-      && (GET_CODE (XEXP (in, 1)) == REG\n+      && (REG_P (XEXP (in, 1))\n \t  || GET_CODE (XEXP (in, 1)) == SUBREG\n \t  || CONSTANT_P (XEXP (in, 1))\n \t  || GET_CODE (XEXP (in, 1)) == MEM))\n@@ -7464,7 +7464,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \t the case.  If the insn would be A = B + A, rearrange it so\n \t it will be A = A + B as constrain_operands expects.  */\n \n-      if (GET_CODE (XEXP (in, 1)) == REG\n+      if (REG_P (XEXP (in, 1))\n \t  && REGNO (out) == REGNO (XEXP (in, 1)))\n \ttem = op0, op0 = op1, op1 = tem;\n \n@@ -7504,7 +7504,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n       code = (int) add_optab->handlers[(int) GET_MODE (out)].insn_code;\n \n       if (CONSTANT_P (op1) || GET_CODE (op1) == MEM || GET_CODE (op1) == SUBREG\n-\t  || (GET_CODE (op1) == REG\n+\t  || (REG_P (op1)\n \t      && REGNO (op1) >= FIRST_PSEUDO_REGISTER)\n \t  || (code != CODE_FOR_nothing\n \t      && ! ((*insn_data[code].operand[2].predicate)\n@@ -7551,9 +7551,9 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \n #ifdef SECONDARY_MEMORY_NEEDED\n   /* If we need a memory location to do the move, do it that way.  */\n-  else if ((GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n+  else if ((REG_P (in) || GET_CODE (in) == SUBREG)\n \t   && reg_or_subregno (in) < FIRST_PSEUDO_REGISTER\n-\t   && (GET_CODE (out) == REG || GET_CODE (out) == SUBREG)\n+\t   && (REG_P (out) || GET_CODE (out) == SUBREG)\n \t   && reg_or_subregno (out) < FIRST_PSEUDO_REGISTER\n \t   && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (reg_or_subregno (in)),\n \t\t\t\t       REGNO_REG_CLASS (reg_or_subregno (out)),\n@@ -7855,7 +7855,7 @@ delete_address_reloads_1 (rtx dead_insn, rtx x, rtx current_insn)\n   if (! set)\n     return;\n   dst = SET_DEST (set);\n-  if (GET_CODE (dst) != REG\n+  if (!REG_P (dst)\n       || ! rtx_equal_p (dst, x))\n     return;\n   if (! reg_set_p (dst, PATTERN (dead_insn)))\n@@ -7943,7 +7943,7 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n      inc/dec operation.  If REG_LAST_RELOAD_REG were nonzero,\n      we could inc/dec that register as well (maybe even using it for\n      the source), but I'm not sure it's worth worrying about.  */\n-  if (GET_CODE (incloc) == REG)\n+  if (REG_P (incloc))\n     reg_last_reload_reg[REGNO (incloc)] = 0;\n \n   if (GET_CODE (value) == PRE_DEC || GET_CODE (value) == POST_DEC)"}, {"sha": "9b3c9fd6f2fe0b552ee2a51d5557a036b85f167b", "filename": "gcc/reorg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1924,7 +1924,7 @@ update_reg_dead_notes (rtx insn, rtx delayed_insn)\n \tnext = XEXP (link, 1);\n \n \tif (REG_NOTE_KIND (link) != REG_DEAD\n-\t    || GET_CODE (XEXP (link, 0)) != REG)\n+\t    || !REG_P (XEXP (link, 0)))\n \t  continue;\n \n \tif (reg_referenced_p (XEXP (link, 0), PATTERN (insn)))\n@@ -1957,7 +1957,7 @@ fix_reg_dead_note (rtx start_insn, rtx stop_insn)\n \tnext = XEXP (link, 1);\n \n \tif (REG_NOTE_KIND (link) != REG_DEAD\n-\t    || GET_CODE (XEXP (link, 0)) != REG)\n+\t    || !REG_P (XEXP (link, 0)))\n \t  continue;\n \n \tif (reg_set_p (XEXP (link, 0), PATTERN (start_insn)))\n@@ -1985,7 +1985,7 @@ update_reg_unused_notes (rtx insn, rtx redundant_insn)\n       next = XEXP (link, 1);\n \n       if (REG_NOTE_KIND (link) != REG_UNUSED\n-\t  || GET_CODE (XEXP (link, 0)) != REG)\n+\t  || !REG_P (XEXP (link, 0)))\n \tcontinue;\n \n       if (! find_regno_note (redundant_insn, REG_UNUSED,\n@@ -2764,8 +2764,8 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t destination.  Overlap may happen for larger-than-register-size modes.  */\n \n       if (GET_CODE (trial) == INSN && GET_CODE (pat) == SET\n-\t  && GET_CODE (SET_SRC (pat)) == REG\n-\t  && GET_CODE (SET_DEST (pat)) == REG\n+\t  && REG_P (SET_SRC (pat))\n+\t  && REG_P (SET_DEST (pat))\n \t  && !reg_overlap_mentioned_p (SET_DEST (pat), SET_SRC (pat)))\n \t{\n \t  rtx next = next_nonnote_insn (trial);"}, {"sha": "714e1ff1c92639d62fb7a1d3a40d9ba5e5674150", "filename": "gcc/resource.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -95,8 +95,8 @@ update_live_status (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n   int first_regno, last_regno;\n   int i;\n \n-  if (GET_CODE (dest) != REG\n-      && (GET_CODE (dest) != SUBREG || GET_CODE (SUBREG_REG (dest)) != REG))\n+  if (!REG_P (dest)\n+      && (GET_CODE (dest) != SUBREG || !REG_P (SUBREG_REG (dest))))\n     return;\n \n   if (GET_CODE (dest) == SUBREG)\n@@ -227,7 +227,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n       return;\n \n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (x)) != REG)\n+      if (!REG_P (SUBREG_REG (x)))\n \tmark_referenced_resources (SUBREG_REG (x), res, 0);\n       else\n \t{\n@@ -765,7 +765,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n     case SUBREG:\n       if (in_dest)\n \t{\n-\t  if (GET_CODE (SUBREG_REG (x)) != REG)\n+\t  if (!REG_P (SUBREG_REG (x)))\n \t    mark_set_resources (SUBREG_REG (x), res, in_dest, mark_type);\n \t  else\n \t    {\n@@ -1038,7 +1038,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t    {\n \t      for (link = REG_NOTES (real_insn); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t    && GET_CODE (XEXP (link, 0)) == REG\n+\t\t    && REG_P (XEXP (link, 0))\n \t\t    && REGNO (XEXP (link, 0)) < FIRST_PSEUDO_REGISTER)\n \t\t  {\n \t\t    unsigned int first_regno = REGNO (XEXP (link, 0));\n@@ -1057,7 +1057,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t\t These notes will always be accurate.  */\n \t      for (link = REG_NOTES (real_insn); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_UNUSED\n-\t\t    && GET_CODE (XEXP (link, 0)) == REG\n+\t\t    && REG_P (XEXP (link, 0))\n \t\t    && REGNO (XEXP (link, 0)) < FIRST_PSEUDO_REGISTER)\n \t\t  {\n \t\t    unsigned int first_regno = REGNO (XEXP (link, 0));"}, {"sha": "959b37b6bc71aaa734bee9fa99f28fd16d988728", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -487,7 +487,7 @@ get_jump_table_offset (rtx insn, rtx *earliest)\n     x = XEXP (x, 1);\n \n   /* Search backwards and locate the expression stored in X.  */\n-  for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+  for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n        old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n     ;\n \n@@ -505,7 +505,7 @@ get_jump_table_offset (rtx insn, rtx *earliest)\n \t  if (y == pc_rtx || y == pic_offset_table_rtx)\n \t    break;\n \n-\t  for (old_y = NULL_RTX; GET_CODE (y) == REG && y != old_y;\n+\t  for (old_y = NULL_RTX; REG_P (y) && y != old_y;\n \t       old_y = y, y = find_last_value (y, &old_insn, NULL_RTX, 0))\n \t    ;\n \n@@ -518,7 +518,7 @@ get_jump_table_offset (rtx insn, rtx *earliest)\n \n       x = XEXP (x, 1 - i);\n \n-      for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+      for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n \t   old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n \t;\n     }\n@@ -528,7 +528,7 @@ get_jump_table_offset (rtx insn, rtx *earliest)\n     {\n       x = XEXP (x, 0);\n \n-      for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+      for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n \t   old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n \t;\n     }\n@@ -540,7 +540,7 @@ get_jump_table_offset (rtx insn, rtx *earliest)\n   /* Strip off the MEM.  */\n   x = XEXP (x, 0);\n \n-  for (old_x = NULL_RTX; GET_CODE (x) == REG && x != old_x;\n+  for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n        old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n     ;\n \n@@ -557,7 +557,7 @@ get_jump_table_offset (rtx insn, rtx *earliest)\n       old_insn = insn;\n       y = XEXP (x, i);\n \n-      for (old_y = NULL_RTX; GET_CODE (y) == REG && y != old_y;\n+      for (old_y = NULL_RTX; REG_P (y) && y != old_y;\n \t   old_y = y, y = find_last_value (y, &old_insn, NULL_RTX, 0))\n \t;\n \n@@ -602,7 +602,7 @@ global_reg_mentioned_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n   switch (GET_CODE (x))\n     {\n     case SUBREG:\n-      if (GET_CODE (SUBREG_REG (x)) == REG)\n+      if (REG_P (SUBREG_REG (x)))\n \t{\n \t  if (REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER\n \t      && global_regs[subreg_regno (x)])\n@@ -747,7 +747,7 @@ reg_mentioned_p (rtx reg, rtx in)\n     {\n       /* Compare registers by number.  */\n     case REG:\n-      return GET_CODE (reg) == REG && REGNO (in) == REGNO (reg);\n+      return REG_P (reg) && REGNO (in) == REGNO (reg);\n \n       /* These codes have no constituent expressions\n \t and are unique.  */\n@@ -856,9 +856,9 @@ reg_referenced_p (rtx x, rtx body)\n \t it is mentioned in the destination.  */\n       if (GET_CODE (SET_DEST (body)) != CC0\n \t  && GET_CODE (SET_DEST (body)) != PC\n-\t  && GET_CODE (SET_DEST (body)) != REG\n+\t  && !REG_P (SET_DEST (body))\n \t  && ! (GET_CODE (SET_DEST (body)) == SUBREG\n-\t\t&& GET_CODE (SUBREG_REG (SET_DEST (body))) == REG\n+\t\t&& REG_P (SUBREG_REG (SET_DEST (body)))\n \t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (body))))\n \t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n \t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (body)))\n@@ -966,7 +966,7 @@ reg_set_p (rtx reg, rtx insn)\n \n \t\t ??? Unless we could ensure that the CALL_INSN_FUNCTION_USAGE\n \t\t information holds all clobbered registers.  */\n-\t      && ((GET_CODE (reg) == REG\n+\t      && ((REG_P (reg)\n \t\t   && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n \t\t  || GET_CODE (reg) == MEM\n \t\t  || find_reg_fusage (insn, CLOBBER, reg)))))\n@@ -1319,7 +1319,7 @@ set_noop_p (rtx set)\n       dst = SUBREG_REG (dst);\n     }\n \n-  return (GET_CODE (src) == REG && GET_CODE (dst) == REG\n+  return (REG_P (src) && REG_P (dst)\n \t  && REGNO (src) == REGNO (dst));\n }\n \f\n@@ -1399,7 +1399,7 @@ find_last_value (rtx x, rtx *pinsn, rtx valid_to, int allow_hwreg)\n \t\t || ! modified_between_p (src, PREV_INSN (p), valid_to))\n \t\t/* Reject hard registers because we don't usually want\n \t\t   to use them; we'd rather use a pseudo.  */\n-\t\t&& (! (GET_CODE (src) == REG\n+\t\t&& (! (REG_P (src)\n \t\t      && REGNO (src) < FIRST_PSEUDO_REGISTER) || allow_hwreg))\n \t      {\n \t\t*pinsn = p;\n@@ -1463,7 +1463,7 @@ refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n     case SUBREG:\n       /* If this is a SUBREG of a hard reg, we can see exactly which\n \t registers are being modified.  Otherwise, handle normally.  */\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n+      if (REG_P (SUBREG_REG (x))\n \t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n \t{\n \t  unsigned int inner_regno = subreg_regno (x);\n@@ -1483,11 +1483,11 @@ refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n \t     treat each word individually.  */\n \t  && ((GET_CODE (SET_DEST (x)) == SUBREG\n \t       && loc != &SUBREG_REG (SET_DEST (x))\n-\t       && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n+\t       && REG_P (SUBREG_REG (SET_DEST (x)))\n \t       && REGNO (SUBREG_REG (SET_DEST (x))) >= FIRST_PSEUDO_REGISTER\n \t       && refers_to_regno_p (regno, endregno,\n \t\t\t\t     SUBREG_REG (SET_DEST (x)), loc))\n-\t      || (GET_CODE (SET_DEST (x)) != REG\n+\t      || (!REG_P (SET_DEST (x))\n \t\t  && refers_to_regno_p (regno, endregno, SET_DEST (x), loc))))\n \treturn 1;\n \n@@ -1633,7 +1633,7 @@ note_stores (rtx x, void (*fun) (rtx, rtx, void *), void *data)\n       rtx dest = SET_DEST (x);\n \n       while ((GET_CODE (dest) == SUBREG\n-\t      && (GET_CODE (SUBREG_REG (dest)) != REG\n+\t      && (!REG_P (SUBREG_REG (dest))\n \t\t  || REGNO (SUBREG_REG (dest)) >= FIRST_PSEUDO_REGISTER))\n \t     || GET_CODE (dest) == ZERO_EXTRACT\n \t     || GET_CODE (dest) == SIGN_EXTRACT\n@@ -1768,7 +1768,7 @@ dead_or_set_p (rtx insn, rtx x)\n   if (GET_CODE (x) == CC0)\n     return 1;\n \n-  if (GET_CODE (x) != REG)\n+  if (!REG_P (x))\n     abort ();\n \n   regno = REGNO (x);\n@@ -1818,7 +1818,7 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n \t\t   + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \tdest = SUBREG_REG (dest);\n \n-      if (GET_CODE (dest) != REG)\n+      if (!REG_P (dest))\n \treturn 0;\n \n       regno = REGNO (dest);\n@@ -1849,7 +1849,7 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n \t\t\t   + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \t\tdest = SUBREG_REG (dest);\n \n-\t      if (GET_CODE (dest) != REG)\n+\t      if (!REG_P (dest))\n \t\tcontinue;\n \n \t      regno = REGNO (dest);\n@@ -1908,7 +1908,7 @@ find_regno_note (rtx insn, enum reg_note kind, unsigned int regno)\n     if (REG_NOTE_KIND (link) == kind\n \t/* Verify that it is a register, so that scratch and MEM won't cause a\n \t   problem here.  */\n-\t&& GET_CODE (XEXP (link, 0)) == REG\n+\t&& REG_P (XEXP (link, 0))\n \t&& REGNO (XEXP (link, 0)) <= regno\n \t&& ((REGNO (XEXP (link, 0))\n \t     + (REGNO (XEXP (link, 0)) >= FIRST_PSEUDO_REGISTER ? 1\n@@ -1954,7 +1954,7 @@ find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n   if (! datum)\n     abort ();\n \n-  if (GET_CODE (datum) != REG)\n+  if (!REG_P (datum))\n     {\n       rtx link;\n \n@@ -2008,7 +2008,7 @@ find_regno_fusage (rtx insn, enum rtx_code code, unsigned int regno)\n       rtx op, reg;\n \n       if (GET_CODE (op = XEXP (link, 0)) == code\n-\t  && GET_CODE (reg = XEXP (op, 0)) == REG\n+\t  && REG_P (reg = XEXP (op, 0))\n \t  && (regnote = REGNO (reg)) <= regno\n \t  && regnote + hard_regno_nregs[regnote][GET_MODE (reg)] > regno)\n \treturn 1;\n@@ -2632,7 +2632,7 @@ replace_regs (rtx x, rtx *reg_map, unsigned int nregs, int replace_dest)\n \n     case SUBREG:\n       /* Prevent making nested SUBREGs.  */\n-      if (GET_CODE (SUBREG_REG (x)) == REG && REGNO (SUBREG_REG (x)) < nregs\n+      if (REG_P (SUBREG_REG (x)) && REGNO (SUBREG_REG (x)) < nregs\n \t  && reg_map[REGNO (SUBREG_REG (x))] != 0\n \t  && GET_CODE (reg_map[REGNO (SUBREG_REG (x))]) == SUBREG)\n \t{\n@@ -2974,7 +2974,7 @@ regno_use_in (unsigned int regno, rtx x)\n   int i, j;\n   rtx tem;\n \n-  if (GET_CODE (x) == REG && REGNO (x) == regno)\n+  if (REG_P (x) && REGNO (x) == regno)\n     return x;\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n@@ -3401,7 +3401,7 @@ find_first_parameter_load (rtx call_insn, rtx boundary)\n   parm.nregs = 0;\n   for (p = CALL_INSN_FUNCTION_USAGE (call_insn); p; p = XEXP (p, 1))\n     if (GET_CODE (XEXP (p, 0)) == USE\n-\t&& GET_CODE (XEXP (XEXP (p, 0), 0)) == REG)\n+\t&& REG_P (XEXP (XEXP (p, 0), 0)))\n       {\n \tif (REGNO (XEXP (XEXP (p, 0), 0)) >= FIRST_PSEUDO_REGISTER)\n \t  abort ();\n@@ -3453,14 +3453,14 @@ keep_with_call_p (rtx insn)\n \n   if (INSN_P (insn) && (set = single_set (insn)) != NULL)\n     {\n-      if (GET_CODE (SET_DEST (set)) == REG\n+      if (REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) < FIRST_PSEUDO_REGISTER\n \t  && fixed_regs[REGNO (SET_DEST (set))]\n \t  && general_operand (SET_SRC (set), VOIDmode))\n \treturn true;\n-      if (GET_CODE (SET_SRC (set)) == REG\n+      if (REG_P (SET_SRC (set))\n \t  && FUNCTION_VALUE_REGNO_P (REGNO (SET_SRC (set)))\n-\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n \treturn true;\n       /* There may be a stack pop just after the call and before the store\n@@ -4224,7 +4224,7 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n \t   zero.  */\n \tif (POINTERS_EXTEND_UNSIGNED > 0 && GET_MODE (x) == Pmode\n \t    && (code == PLUS || code == MINUS)\n-\t    && GET_CODE (XEXP (x, 0)) == REG && REG_POINTER (XEXP (x, 0)))\n+\t    && REG_P (XEXP (x, 0)) && REG_POINTER (XEXP (x, 0)))\n \t  nonzero &= GET_MODE_MASK (ptr_mode);\n #endif\n       }\n@@ -4674,7 +4674,7 @@ num_sign_bit_copies1 (rtx x, enum machine_mode mode, rtx known_x,\n \t sign bit copies.  */\n       if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n \t  && (code == PLUS || code == MINUS)\n-\t  && GET_CODE (XEXP (x, 0)) == REG && REG_POINTER (XEXP (x, 0)))\n+\t  && REG_P (XEXP (x, 0)) && REG_POINTER (XEXP (x, 0)))\n \tresult = MAX ((int) (GET_MODE_BITSIZE (Pmode)\n \t\t\t     - GET_MODE_BITSIZE (ptr_mode) + 1),\n \t\t      result);"}, {"sha": "a32d1c06b4489975f83bd0a57072ec2bea539209", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -43,7 +43,7 @@ gen_lowpart_general (enum machine_mode mode, rtx x)\n \n   if (result)\n     return result;\n-  else if (GET_CODE (x) == REG)\n+  else if (REG_P (x))\n     {\n       /* Must be a hard reg that's not valid in MODE.  */\n       result = gen_lowpart_common (mode, copy_to_reg (x));"}, {"sha": "9c480d9a764d7a4978622faa12b603239a6e94d7", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -484,7 +484,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n       dest = XEXP (dest, 0);\n     }\n \n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     {\n       regno = REGNO (dest);\n \n@@ -1123,7 +1123,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n       tmp = SET_DEST (set);\n       if (GET_CODE (tmp) == SUBREG)\n \ttmp = SUBREG_REG (tmp);\n-      if (GET_CODE (tmp) == REG)\n+      if (REG_P (tmp))\n \tdest_regno = REGNO (tmp);\n       else\n \tgoto end_call_group;\n@@ -1133,11 +1133,11 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \ttmp = SUBREG_REG (tmp);\n       if ((GET_CODE (tmp) == PLUS\n \t   || GET_CODE (tmp) == MINUS)\n-\t  && GET_CODE (XEXP (tmp, 0)) == REG\n+\t  && REG_P (XEXP (tmp, 0))\n \t  && REGNO (XEXP (tmp, 0)) == STACK_POINTER_REGNUM\n \t  && dest_regno == STACK_POINTER_REGNUM)\n \tsrc_regno = STACK_POINTER_REGNUM;\n-      else if (GET_CODE (tmp) == REG)\n+      else if (REG_P (tmp))\n \tsrc_regno = REGNO (tmp);\n       else\n \tgoto end_call_group;\n@@ -1326,8 +1326,8 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \t  /* The sequence must start with a clobber of a register.  */\n \t  && GET_CODE (insn) == INSN\n \t  && GET_CODE (PATTERN (insn)) == CLOBBER\n-          && (r0 = XEXP (PATTERN (insn), 0), GET_CODE (r0) == REG)\n-\t  && GET_CODE (XEXP (PATTERN (insn), 0)) == REG\n+          && (r0 = XEXP (PATTERN (insn), 0), REG_P (r0))\n+\t  && REG_P (XEXP (PATTERN (insn), 0))\n \t  /* The CLOBBER must also have a REG_LIBCALL note attached.  */\n \t  && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n \t  && (end_seq = XEXP (link, 0)) != 0"}, {"sha": "14175776a4a1cdefb4a40f368d5cf58b2a48ee2b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1305,7 +1305,7 @@ check_live_1 (int src, rtx x)\n       return 0;\n     }\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return 1;\n \n   regno = REGNO (reg);\n@@ -1382,7 +1382,7 @@ update_live_1 (int src, rtx x)\n       return;\n     }\n \n-  if (GET_CODE (reg) != REG)\n+  if (!REG_P (reg))\n     return;\n \n   /* Global registers are always live, so the code below does not apply"}, {"sha": "b6049c2b617870887286f8bb05768baab0852bdf", "filename": "gcc/sdbout.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -790,7 +790,7 @@ sdbout_symbol (tree decl, int local)\n \t If DECL was from an inline function, then its rtl\n \t is not identically the rtl that was used in this\n \t particular compilation.  */\n-      if (GET_CODE (value) == REG)\n+      if (REG_P (value))\n \t{\n \t  regno = REGNO (value);\n \t  if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -800,7 +800,7 @@ sdbout_symbol (tree decl, int local)\n \t{\n \t  while (GET_CODE (value) == SUBREG)\n \t    value = SUBREG_REG (value);\n-\t  if (GET_CODE (value) == REG)\n+\t  if (REG_P (value))\n \t    {\n \t      if (REGNO (value) >= FIRST_PSEUDO_REGISTER)\n \t\treturn;\n@@ -868,7 +868,7 @@ sdbout_symbol (tree decl, int local)\n \t}\n       else if (GET_CODE (value) == MEM\n \t       && (GET_CODE (XEXP (value, 0)) == MEM\n-\t\t   || (GET_CODE (XEXP (value, 0)) == REG\n+\t\t   || (REG_P (XEXP (value, 0))\n \t\t       && REGNO (XEXP (value, 0)) != HARD_FRAME_POINTER_REGNUM\n \t\t       && REGNO (XEXP (value, 0)) != STACK_POINTER_REGNUM)))\n \t/* If the value is indirect by memory or by a register\n@@ -878,7 +878,7 @@ sdbout_symbol (tree decl, int local)\n \t   so all we can do is output the variable as a pointer.  */\n \t{\n \t  PUT_SDB_DEF (name);\n-\t  if (GET_CODE (XEXP (value, 0)) == REG)\n+\t  if (REG_P (XEXP (value, 0)))\n \t    {\n \t      PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (REGNO (XEXP (value, 0))));\n \t      PUT_SDB_SCL (C_REG);\n@@ -903,12 +903,12 @@ sdbout_symbol (tree decl, int local)\n \t}\n       else if (GET_CODE (value) == MEM\n \t       && ((GET_CODE (XEXP (value, 0)) == PLUS\n-\t\t    && GET_CODE (XEXP (XEXP (value, 0), 0)) == REG\n+\t\t    && REG_P (XEXP (XEXP (value, 0), 0))\n \t\t    && GET_CODE (XEXP (XEXP (value, 0), 1)) == CONST_INT)\n \t\t   /* This is for variables which are at offset zero from\n \t\t      the frame pointer.  This happens on the Alpha.\n \t\t      Non-frame pointer registers are excluded above.  */\n-\t\t   || (GET_CODE (XEXP (value, 0)) == REG)))\n+\t\t   || (REG_P (XEXP (value, 0)))))\n \t{\n \t  /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))\n \t     or (MEM (REG...)).  We want the value of that CONST_INT\n@@ -1291,7 +1291,7 @@ sdbout_parms (tree parms)\n \t    else\n \t      current_sym_value = 0;\n \n-\t    if (GET_CODE (DECL_RTL (parms)) == REG\n+\t    if (REG_P (DECL_RTL (parms))\n \t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n \t      type = DECL_ARG_TYPE (parms);\n \t    else\n@@ -1330,7 +1330,7 @@ sdbout_parms (tree parms)\n \t    PUT_SDB_TYPE (plain_type (type));\n \t    PUT_SDB_ENDEF;\n \t  }\n-\telse if (GET_CODE (DECL_RTL (parms)) == REG)\n+\telse if (REG_P (DECL_RTL (parms)))\n \t  {\n \t    rtx best_rtl;\n \t    /* Parm passed in registers and lives in registers or nowhere.  */\n@@ -1361,7 +1361,7 @@ sdbout_parms (tree parms)\n \t       in which case we want the value of that CONST_INT,\n \t       or (MEM (REG ...)) or (MEM (MEM ...)),\n \t       in which case we use a value of zero.  */\n-\t    if (GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG\n+\t    if (REG_P (XEXP (DECL_RTL (parms), 0))\n \t\t|| GET_CODE (XEXP (DECL_RTL (parms), 0)) == MEM)\n \t      current_sym_value = 0;\n \t    else\n@@ -1399,7 +1399,7 @@ sdbout_reg_parms (tree parms)\n \n \t/* Report parms that live in registers during the function\n \t   but were passed in memory.  */\n-\tif (GET_CODE (DECL_RTL (parms)) == REG\n+\tif (REG_P (DECL_RTL (parms))\n \t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER\n \t    && PARM_PASSED_IN_MEMORY (parms))\n \t  {"}, {"sha": "0b716a40a0edf8bf61227084303e37728934c857", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1065,7 +1065,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && mode == Pmode && GET_MODE (op) == ptr_mode\n \t      && (CONSTANT_P (op)\n \t\t  || (GET_CODE (op) == SUBREG\n-\t\t      && GET_CODE (SUBREG_REG (op)) == REG\n+\t\t      && REG_P (SUBREG_REG (op))\n \t\t      && REG_POINTER (SUBREG_REG (op))\n \t\t      && GET_MODE (SUBREG_REG (op)) == Pmode)))\n \t    return convert_memory_address (Pmode, op);\n@@ -1087,7 +1087,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && mode == Pmode && GET_MODE (op) == ptr_mode\n \t      && (CONSTANT_P (op)\n \t\t  || (GET_CODE (op) == SUBREG\n-\t\t      && GET_CODE (SUBREG_REG (op)) == REG\n+\t\t      && REG_P (SUBREG_REG (op))\n \t\t      && REG_POINTER (SUBREG_REG (op))\n \t\t      && GET_MODE (SUBREG_REG (op)) == Pmode)))\n \t    return convert_memory_address (Pmode, op);\n@@ -1619,7 +1619,7 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n #ifdef HAVE_cc0\n \t      if (GET_CODE (xop00) == CC0 && GET_CODE (xop10) == CC0)\n #else\n-\t      if (GET_CODE (xop00) == REG && GET_CODE (xop10) == REG\n+\t      if (REG_P (xop00) && REG_P (xop10)\n \t\t  && GET_MODE (xop00) == GET_MODE (xop10)\n \t\t  && REGNO (xop00) == REGNO (xop10)\n \t\t  && GET_MODE_CLASS (GET_MODE (xop00)) == MODE_CC\n@@ -2807,8 +2807,8 @@ simplify_const_relational_operation (enum rtx_code code,\n      signed comparisons for languages such as Java, so test flag_wrapv.  */\n \n   if (!flag_wrapv && INTEGRAL_MODE_P (mode) && trueop1 != const0_rtx\n-      && ! ((GET_CODE (op0) == REG || GET_CODE (trueop0) == CONST_INT)\n-\t    && (GET_CODE (op1) == REG || GET_CODE (trueop1) == CONST_INT))\n+      && ! ((REG_P (op0) || GET_CODE (trueop0) == CONST_INT)\n+\t    && (REG_P (op1) || GET_CODE (trueop1) == CONST_INT))\n       && 0 != (tem = simplify_binary_operation (MINUS, mode, op0, op1))\n       /* We cannot do this for == or != if tem is a nonzero address.  */\n       && ((code != EQ && code != NE) || ! nonzero_address_p (tem))"}, {"sha": "d860bc727d56fbfc6210de4f43a4d3b3bfcfb0ee", "filename": "gcc/stmt.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1467,7 +1467,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t  && (allows_mem\n \t      || is_inout\n \t      || (DECL_P (val)\n-\t\t  && GET_CODE (DECL_RTL (val)) == REG\n+\t\t  && REG_P (DECL_RTL (val))\n \t\t  && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type))))\n \tlang_hooks.mark_addressable (val);\n \n@@ -1529,8 +1529,8 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n       if ((TREE_CODE (val) == INDIRECT_REF\n \t   && allows_mem)\n \t  || (DECL_P (val)\n-\t      && (allows_mem || GET_CODE (DECL_RTL (val)) == REG)\n-\t      && ! (GET_CODE (DECL_RTL (val)) == REG\n+\t      && (allows_mem || REG_P (DECL_RTL (val)))\n+\t      && ! (REG_P (DECL_RTL (val))\n \t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n \t  || ! allows_reg\n \t  || is_inout)\n@@ -1639,7 +1639,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t\t  else\n \t\t    op = force_reg (TYPE_MODE (type), op);\n \t\t}\n-\t      if (GET_CODE (op) == REG\n+\t      if (REG_P (op)\n \t\t  || GET_CODE (op) == SUBREG\n \t\t  || GET_CODE (op) == ADDRESSOF\n \t\t  || GET_CODE (op) == CONCAT)\n@@ -2333,7 +2333,7 @@ expand_end_stmt_expr (tree t)\n       last_expr_alt_rtl = NULL_RTX;\n       last_expr_type = void_type_node;\n     }\n-  else if (GET_CODE (last_expr_value) != REG && ! CONSTANT_P (last_expr_value))\n+  else if (!REG_P (last_expr_value) && ! CONSTANT_P (last_expr_value))\n     /* Remove any possible QUEUED.  */\n     last_expr_value = protect_from_queue (last_expr_value, 0);\n \n@@ -2679,7 +2679,7 @@ expand_return (tree retval)\n \n   if (retval_rhs != 0\n       && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n-      && GET_CODE (result_rtl) == REG)\n+      && REG_P (result_rtl))\n     {\n       int i;\n       unsigned HOST_WIDE_INT bitpos, xbitpos;\n@@ -2791,7 +2791,7 @@ expand_return (tree retval)\n     }\n   else if (retval_rhs != 0\n \t   && !VOID_TYPE_P (TREE_TYPE (retval_rhs))\n-\t   && (GET_CODE (result_rtl) == REG\n+\t   && (REG_P (result_rtl)\n \t       || (GET_CODE (result_rtl) == PARALLEL)))\n     {\n       /* Calculate the return value into a temporary (usually a pseudo\n@@ -3320,7 +3320,7 @@ expand_decl (tree decl)\n       if (DECL_RTL_SET_P (decl))\n \t{\n \t  if (GET_CODE (DECL_RTL (decl)) != MEM\n-\t      || GET_CODE (XEXP (DECL_RTL (decl), 0)) != REG)\n+\t      || !REG_P (XEXP (DECL_RTL (decl), 0)))\n \t    abort ();\n \t  oldaddr = XEXP (DECL_RTL (decl), 0);\n \t}\n@@ -3656,7 +3656,7 @@ expand_anon_union_decl (tree decl, tree cleanup, tree decl_elts)\n \t  else\n \t    SET_DECL_RTL (decl_elt, adjust_address_nv (x, mode, 0));\n \t}\n-      else if (GET_CODE (x) == REG)\n+      else if (REG_P (x))\n \t{\n \t  if (mode == GET_MODE (x))\n \t    SET_DECL_RTL (decl_elt, x);"}, {"sha": "596ea7f56e226ff34221080d966b4866ddd3a30d", "filename": "gcc/unroll.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1460,7 +1460,7 @@ precondition_loop_p (const struct loop *loop, rtx *initial_value,\n      against max_reg_before_loop to make sure that the register is in\n      the range covered by loop_invariant_p.  If it isn't, then it is\n      most likely a biv/giv which by definition are not invariant.  */\n-  if ((GET_CODE (loop_info->final_value) == REG\n+  if ((REG_P (loop_info->final_value)\n        && REGNO (loop_info->final_value) >= max_reg_before_loop)\n       || (GET_CODE (loop_info->final_value) == PLUS\n \t  && REGNO (XEXP (loop_info->final_value, 0)) >= max_reg_before_loop)\n@@ -1651,7 +1651,7 @@ calculate_giv_inc (rtx pattern, rtx src_insn, unsigned int regno)\n \n   /* Check that the source register is the same as the register we expected\n      to see as the source.  If not, something is seriously wrong.  */\n-  if (GET_CODE (XEXP (SET_SRC (pattern), 0)) != REG\n+  if (!REG_P (XEXP (SET_SRC (pattern), 0))\n       || REGNO (XEXP (SET_SRC (pattern), 0)) != regno)\n     {\n       /* Some machines (e.g. the romp), may emit two add instructions for\n@@ -1792,7 +1792,7 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n \t     SET_DEST to a new register.  */\n \n \t  if ((set = single_set (insn))\n-\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REG_P (SET_DEST (set))\n \t      && addr_combined_regs[REGNO (SET_DEST (set))])\n \t    {\n \t      struct iv_class *bl;\n@@ -1840,7 +1840,7 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n \n \t\t\t/* tv->dest_reg will be either a bare register,\n \t\t\t   or else a register plus a constant.  */\n-\t\t\tif (GET_CODE (tv->dest_reg) == REG)\n+\t\t\tif (REG_P (tv->dest_reg))\n \t\t\t  dest_reg = tv->dest_reg;\n \t\t\telse\n \t\t\t  dest_reg = XEXP (tv->dest_reg, 0);\n@@ -1886,7 +1886,7 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n \t  dest_reg_was_split = 0;\n \n \t  if ((set = single_set (insn))\n-\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REG_P (SET_DEST (set))\n \t      && splittable_regs[REGNO (SET_DEST (set))])\n \t    {\n \t      unsigned int regno = REGNO (SET_DEST (set));\n@@ -2517,7 +2517,7 @@ find_splittable_regs (const struct loop *loop,\n \t PLUS, we don't know how to split it.  */\n       for (v = bl->biv; biv_splittable && v; v = v->next_iv)\n \tif ((tem = single_set (v->insn)) == 0\n-\t    || GET_CODE (SET_DEST (tem)) != REG\n+\t    || !REG_P (SET_DEST (tem))\n \t    || REGNO (SET_DEST (tem)) != bl->regno\n \t    || GET_CODE (SET_SRC (tem)) != PLUS)\n \t  biv_splittable = 0;\n@@ -2539,7 +2539,7 @@ find_splittable_regs (const struct loop *loop,\n \t\t register, or it isn't invariant, then we must create a new\n \t\t pseudo reg to hold the initial value of the biv.  */\n \n-\t      if (GET_CODE (bl->initial_value) == REG\n+\t      if (REG_P (bl->initial_value)\n \t\t  && (REGNO (bl->initial_value) == bl->regno\n \t\t      || REGNO (bl->initial_value) < FIRST_PSEUDO_REGISTER\n \t\t      || ! loop_invariant_p (loop, bl->initial_value)))\n@@ -2742,7 +2742,7 @@ find_splittable_givs (const struct loop *loop, struct iv_class *bl,\n \n \t  if (splittable_regs[bl->regno])\n \t    biv_initial_value = splittable_regs[bl->regno];\n-\t  else if (GET_CODE (bl->initial_value) != REG\n+\t  else if (!REG_P (bl->initial_value)\n \t\t   || (REGNO (bl->initial_value) != bl->regno\n \t\t       && REGNO (bl->initial_value) >= FIRST_PSEUDO_REGISTER))\n \t    biv_initial_value = bl->initial_value;\n@@ -2786,9 +2786,9 @@ find_splittable_givs (const struct loop *loop, struct iv_class *bl,\n \t\t is going before the loop start.  */\n \t      if (unroll_type == UNROLL_COMPLETELY\n \t\t  && GET_CODE (value) != CONST_INT\n-\t\t  && GET_CODE (value) != REG\n+\t\t  && !REG_P (value)\n \t\t  && (GET_CODE (value) != PLUS\n-\t\t      || GET_CODE (XEXP (value, 0)) != REG\n+\t\t      || !REG_P (XEXP (value, 0))\n \t\t      || GET_CODE (XEXP (value, 1)) != CONST_INT))\n \t\t{\n \t\t  rtx tem = gen_reg_rtx (v->mode);\n@@ -2827,7 +2827,7 @@ find_splittable_givs (const struct loop *loop, struct iv_class *bl,\n \t a splittable register.  Don't need to do anything for address givs\n \t where this may not be a register.  */\n \n-      if (GET_CODE (v->new_reg) == REG)\n+      if (REG_P (v->new_reg))\n \t{\n \t  int count = 1;\n \t  if (! v->ignore)\n@@ -2844,7 +2844,7 @@ find_splittable_givs (const struct loop *loop, struct iv_class *bl,\n \n \t  if (GET_CODE (v->dest_reg) == CONST_INT)\n \t    regnum = -1;\n-\t  else if (GET_CODE (v->dest_reg) != REG)\n+\t  else if (!REG_P (v->dest_reg))\n \t    regnum = REGNO (XEXP (v->dest_reg, 0));\n \t  else\n \t    regnum = REGNO (v->dest_reg);\n@@ -3211,8 +3211,8 @@ subtract_reg_term (rtx op, rtx reg)\n static rtx\n find_common_reg_term (rtx op0, rtx op1)\n {\n-  if ((GET_CODE (op0) == REG || GET_CODE (op0) == PLUS)\n-      && (GET_CODE (op1) == REG || GET_CODE (op1) == PLUS))\n+  if ((REG_P (op0) || GET_CODE (op0) == PLUS)\n+      && (REG_P (op1) || GET_CODE (op1) == PLUS))\n     {\n       rtx op00;\n       rtx op01;\n@@ -3358,7 +3358,7 @@ loop_iterations (struct loop *loop)\n   iteration_var = XEXP (comparison, 0);\n   comparison_value = XEXP (comparison, 1);\n \n-  if (GET_CODE (iteration_var) != REG)\n+  if (!REG_P (iteration_var))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -3420,7 +3420,7 @@ loop_iterations (struct loop *loop)\n   /* Try swapping the comparison to identify a suitable iv.  */\n   if (REG_IV_TYPE (ivs, REGNO (iteration_var)) != BASIC_INDUCT\n       && REG_IV_TYPE (ivs, REGNO (iteration_var)) != GENERAL_INDUCT\n-      && GET_CODE (comparison_value) == REG\n+      && REG_P (comparison_value)\n       && REGNO (comparison_value) < ivs->n_regs)\n     {\n       rtx temp = comparison_value;\n@@ -3568,7 +3568,7 @@ loop_iterations (struct loop *loop)\n      its value from the insns before the start of the loop.  */\n \n   final_value = comparison_value;\n-  if (GET_CODE (comparison_value) == REG\n+  if (REG_P (comparison_value)\n       && loop_invariant_p (loop, comparison_value))\n     {\n       final_value = loop_find_equiv_value (loop, comparison_value);\n@@ -3713,7 +3713,7 @@ loop_iterations (struct loop *loop)\n       /* If we have a REG, check to see if REG holds a constant value.  */\n       /* ??? Other RTL, such as (neg (reg)) is possible here, but it isn't\n \t clear if it is worthwhile to try to handle such RTL.  */\n-      if (GET_CODE (increment) == REG || GET_CODE (increment) == SUBREG)\n+      if (REG_P (increment) || GET_CODE (increment) == SUBREG)\n \tincrement = loop_find_equiv_value (loop, increment);\n \n       if (GET_CODE (increment) != CONST_INT)"}, {"sha": "c036baafd5ff789744cd3cf3c03ab30abf689878", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1099,8 +1099,8 @@ variable_union (void **slot, void *data)\n \t\t   node2 = dst->var_part[j].loc_chain; node && node2;\n \t\t   node = node->next, node2 = node2->next)\n \t\t{\n-\t\t  if (!((GET_CODE (node2->loc) == REG\n-\t\t\t && GET_CODE (node->loc) == REG\n+\t\t  if (!((REG_P (node2->loc)\n+\t\t\t && REG_P (node->loc)\n \t\t\t && REGNO (node2->loc) == REGNO (node->loc))\n \t\t\t|| rtx_equal_p (node2->loc, node->loc)))\n \t\t    break;\n@@ -1136,8 +1136,8 @@ variable_union (void **slot, void *data)\n \t      /* Find location from NODE.  */\n \t      for (jj = 0; jj < dst_l; jj++)\n \t\t{\n-\t\t  if ((GET_CODE (vui[jj].lc->loc) == REG\n-\t\t       && GET_CODE (node->loc) == REG\n+\t\t  if ((REG_P (vui[jj].lc->loc)\n+\t\t       && REG_P (node->loc)\n \t\t       && REGNO (vui[jj].lc->loc) == REGNO (node->loc))\n \t\t      || rtx_equal_p (vui[jj].lc->loc, node->loc))\n \t\t    {\n@@ -1246,7 +1246,7 @@ variable_part_different_p (variable_part *vp1, variable_part *vp2)\n     {\n       for (lc2 = vp2->loc_chain; lc2; lc2 = lc2->next)\n \t{\n-\t  if (GET_CODE (lc1->loc) == REG && GET_CODE (lc2->loc) == REG)\n+\t  if (REG_P (lc1->loc) && REG_P (lc2->loc))\n \t    {\n \t      if (REGNO (lc1->loc) == REGNO (lc2->loc))\n \t\tbreak;\n@@ -1282,8 +1282,8 @@ variable_different_p (variable var1, variable var2,\n \treturn true;\n       if (compare_current_location)\n \t{\n-\t  if (!((GET_CODE (var1->var_part[i].cur_loc) == REG\n-\t\t && GET_CODE (var2->var_part[i].cur_loc) == REG\n+\t  if (!((REG_P (var1->var_part[i].cur_loc)\n+\t\t && REG_P (var2->var_part[i].cur_loc)\n \t\t && (REGNO (var1->var_part[i].cur_loc)\n \t\t     == REGNO (var2->var_part[i].cur_loc)))\n \t\t|| rtx_equal_p (var1->var_part[i].cur_loc,\n@@ -1493,7 +1493,7 @@ count_uses (rtx *loc, void *insn)\n {\n   basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n \n-  if (GET_CODE (*loc) == REG)\n+  if (REG_P (*loc))\n     {\n #ifdef ENABLE_CHECKING\n \tif (REGNO (*loc) >= FIRST_PSEUDO_REGISTER)\n@@ -1534,7 +1534,7 @@ count_stores (rtx loc, rtx expr ATTRIBUTE_UNUSED, void *insn)\n static int\n add_uses (rtx *loc, void *insn)\n {\n-  if (GET_CODE (*loc) == REG)\n+  if (REG_P (*loc))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n@@ -1574,7 +1574,7 @@ add_uses_1 (rtx *x, void *insn)\n static void\n add_stores (rtx loc, rtx expr, void *insn)\n {\n-  if (GET_CODE (loc) == REG)\n+  if (REG_P (loc))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n@@ -1629,7 +1629,7 @@ compute_bb_dataflow (basic_block bb)\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n-\t      if (GET_CODE (loc) == REG)\n+\t      if (REG_P (loc))\n \t\tvar_reg_delete_and_set (out, loc);\n \t      else if (GET_CODE (loc) == MEM)\n \t\tvar_mem_delete_and_set (out, loc);\n@@ -1641,7 +1641,7 @@ compute_bb_dataflow (basic_block bb)\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n-\t      if (GET_CODE (loc) == REG)\n+\t      if (REG_P (loc))\n \t\tvar_reg_delete (out, loc);\n \t      else if (GET_CODE (loc) == MEM)\n \t\tvar_mem_delete (out, loc);\n@@ -1999,7 +1999,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \t  node = var->var_part[pos].loc_chain;\n \n \t  if (node\n-\t      && ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+\t      && ((REG_P (node->loc) && REG_P (loc)\n \t\t   && REGNO (node->loc) == REGNO (loc))\n \t\t  || rtx_equal_p (node->loc, loc)))\n \t    {\n@@ -2046,7 +2046,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n   for (node = var->var_part[pos].loc_chain; node; node = next)\n     {\n       next = node->next;\n-      if ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+      if ((REG_P (node->loc) && REG_P (loc)\n \t   && REGNO (node->loc) == REGNO (loc))\n \t  || rtx_equal_p (node->loc, loc))\n \t{\n@@ -2115,7 +2115,7 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t      for (node = var->var_part[pos].loc_chain; node;\n \t\t   node = node->next)\n \t\t{\n-\t\t  if ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+\t\t  if ((REG_P (node->loc) && REG_P (loc)\n \t\t       && REGNO (node->loc) == REGNO (loc))\n \t\t      || rtx_equal_p (node->loc, loc))\n \t\t    {\n@@ -2130,7 +2130,7 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t  for (node = *nextp; node; node = next)\n \t    {\n \t      next = node->next;\n-\t      if ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+\t      if ((REG_P (node->loc) && REG_P (loc)\n \t\t   && REGNO (node->loc) == REGNO (loc))\n \t\t  || rtx_equal_p (node->loc, loc))\n \t\t{\n@@ -2146,8 +2146,8 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t     we have to emit new location so add the variable to set\n \t     of changed variables.  */\n \t  if (var->var_part[pos].cur_loc\n-\t      && ((GET_CODE (loc) == REG\n-\t\t   && GET_CODE (var->var_part[pos].cur_loc) == REG\n+\t      && ((REG_P (loc)\n+\t\t   && REG_P (var->var_part[pos].cur_loc)\n \t\t   && REGNO (loc) == REGNO (var->var_part[pos].cur_loc))\n \t\t  || rtx_equal_p (loc, var->var_part[pos].cur_loc)))\n \t    {\n@@ -2375,7 +2375,7 @@ emit_notes_in_bb (basic_block bb)\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n-\t      if (GET_CODE (loc) == REG)\n+\t      if (REG_P (loc))\n \t\tvar_reg_delete_and_set (&set, loc);\n \t      else\n \t\tvar_mem_delete_and_set (&set, loc);\n@@ -2392,7 +2392,7 @@ emit_notes_in_bb (basic_block bb)\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n-\t      if (GET_CODE (loc) == REG)\n+\t      if (REG_P (loc))\n \t\tvar_reg_delete (&set, loc);\n \t      else\n \t\tvar_mem_delete (&set, loc);\n@@ -2463,7 +2463,7 @@ vt_emit_notes (void)\n static bool\n vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n {\n-  if (GET_CODE (rtl) == REG)\n+  if (REG_P (rtl))\n     {\n       if (REG_ATTRS (rtl))\n \t{\n@@ -2533,7 +2533,7 @@ vt_add_function_parameters (void)\n \tincoming = adjust_stack_reference (incoming, -stack_adjust);\n       out = &VTI (ENTRY_BLOCK_PTR)->out;\n \n-      if (GET_CODE (incoming) == REG)\n+      if (REG_P (incoming))\n \t{\n #ifdef ENABLE_CHECKING\n \t  if (REGNO (incoming) >= FIRST_PSEUDO_REGISTER)"}, {"sha": "42132f74b689ba3c5dbf6c96db02c930be3929a9", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8cfc6aa070047007c18468b54996c116e593642/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f8cfc6aa070047007c18468b54996c116e593642", "patch": "@@ -1378,7 +1378,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n     return;\n \n   /* Do nothing for global register variables.  */\n-  if (DECL_RTL_SET_P (decl) && GET_CODE (DECL_RTL (decl)) == REG)\n+  if (DECL_RTL_SET_P (decl) && REG_P (DECL_RTL (decl)))\n     {\n       TREE_ASM_WRITTEN (decl) = 1;\n       return;"}]}