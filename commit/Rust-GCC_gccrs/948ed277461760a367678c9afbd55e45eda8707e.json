{"sha": "948ed277461760a367678c9afbd55e45eda8707e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ4ZWQyNzc0NjE3NjBhMzY3Njc4YzlhZmJkNTVlNDVlZGE4NzA3ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T09:20:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T09:20:55Z"}, "message": "[multiple changes]\n\n2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (New_Overloaded_Entity): In GNATprove mode, a\n\tfunction wrapper may be a homonym of another local declaration.\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): In GNATprove mode,\n\tbuild function and operator wrappers after the actual subprogram\n\thas been resolved, and replace the standard renaming declaration\n\twith the declaration of wrapper.\n\t* sem_ch12.ads (Build_Function_Wrapper, Build_Operator_Wraooer):\n\tmake public for use elsewhere.\n\t* sem_ch12.adb (Build_Function_Wrapper, Build_Operator_Wraooer):\n\trewrite, now that actual is fully resolved when wrapper is\n\tconstructed.\n\n2015-01-06  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb: Revert previous change.\n\nFrom-SVN: r219232", "tree": {"sha": "3dc962ac940f650f3e5a5d2c4ced2e4f2e283136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dc962ac940f650f3e5a5d2c4ced2e4f2e283136"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/948ed277461760a367678c9afbd55e45eda8707e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948ed277461760a367678c9afbd55e45eda8707e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948ed277461760a367678c9afbd55e45eda8707e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948ed277461760a367678c9afbd55e45eda8707e/comments", "author": null, "committer": null, "parents": [{"sha": "a921e83c12b6b3ea5027113af94c2b105533ba14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a921e83c12b6b3ea5027113af94c2b105533ba14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a921e83c12b6b3ea5027113af94c2b105533ba14"}], "stats": {"total": 647, "additions": 296, "deletions": 351}, "files": [{"sha": "2685b585eb4829934e7e8fac6e5d510601dae56e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=948ed277461760a367678c9afbd55e45eda8707e", "patch": "@@ -1,3 +1,21 @@\n+2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (New_Overloaded_Entity): In GNATprove mode, a\n+\tfunction wrapper may be a homonym of another local declaration.\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): In GNATprove mode,\n+\tbuild function and operator wrappers after the actual subprogram\n+\thas been resolved, and replace the standard renaming declaration\n+\twith the declaration of wrapper.\n+\t* sem_ch12.ads (Build_Function_Wrapper, Build_Operator_Wraooer):\n+\tmake public for use elsewhere.\n+\t* sem_ch12.adb (Build_Function_Wrapper, Build_Operator_Wraooer):\n+\trewrite, now that actual is fully resolved when wrapper is\n+\tconstructed.\n+\n+2015-01-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb: Revert previous change.\n+\n 2015-01-06  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_util.adb: Change name Name_Table_Boolean to"}, {"sha": "99105e0ea4f1052aee2dc73522dfc9e975362279", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=948ed277461760a367678c9afbd55e45eda8707e", "patch": "@@ -1138,25 +1138,6 @@ package body Exp_Disp is\n          Operand_Typ := Base_Type (Corresponding_Record_Type (Operand_Typ));\n       end if;\n \n-      --  No displacement of the pointer to the object needed when the type of\n-      --  the operand is not an interface type and the interface is one of\n-      --  its parent types (since they share the primary dispatch table).\n-\n-      declare\n-         Opnd : Entity_Id := Operand_Typ;\n-\n-      begin\n-         if Is_Access_Type (Opnd) then\n-            Opnd := Designated_Type (Opnd);\n-         end if;\n-\n-         if not Is_Interface (Opnd)\n-           and then Is_Ancestor (Iface_Typ, Opnd, Use_Full_View => True)\n-         then\n-            return;\n-         end if;\n-      end;\n-\n       --  Evaluate if we can statically displace the pointer to the object\n \n       declare\n@@ -1196,6 +1177,11 @@ package body Exp_Disp is\n                        Prefix         => New_Occurrence_Of (Iface_Typ, Loc),\n                        Attribute_Name => Name_Tag))));\n             end if;\n+\n+            --  Just do a conversion ???\n+\n+            Rewrite (N, Unchecked_Convert_To (Etype (N), N));\n+            Analyze (N);\n          end if;\n \n          return;"}, {"sha": "905181d374f5c8c72b972be5d5e2619888c6d053", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 220, "deletions": 328, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=948ed277461760a367678c9afbd55e45eda8707e", "patch": "@@ -30,7 +30,6 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Disp; use Exp_Disp;\n-with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Freeze;   use Freeze;\n@@ -954,24 +953,6 @@ package body Sem_Ch12 is\n       --  In Ada 2005, indicates partial parameterization of a formal\n       --  package. As usual an other association must be last in the list.\n \n-      function Build_Function_Wrapper\n-        (Formal : Entity_Id;\n-         Actual : Entity_Id := Empty) return Node_Id;\n-      --  In GNATprove mode, create a wrapper function for actuals that are\n-      --  functions with any number of formal parameters, in order to propagate\n-      --  their contract to the renaming declarations generated for them.\n-      --  If the actual is absent, the formal has a default, and the name of\n-      --  the function is that of the formal.\n-\n-      function Build_Operator_Wrapper\n-        (Formal : Entity_Id;\n-         Actual : Entity_Id := Empty) return Node_Id;\n-      --  In GNATprove mode, create a wrapper function for actuals that are\n-      --  operators, in order to propagate their contract to the renaming\n-      --  declarations generated for them. If the actual is absent, this is\n-      --  a formal with a default, and the name of the operator is that of the\n-      --  formal.\n-\n       procedure Check_Overloaded_Formal_Subprogram (Formal : Entity_Id);\n       --  Apply RM 12.3 (9): if a formal subprogram is overloaded, the instance\n       --  cannot have a named association for it. AI05-0025 extends this rule\n@@ -1019,257 +1000,6 @@ package body Sem_Ch12 is\n       --  anonymous types, the presence a formal equality will introduce an\n       --  implicit declaration for the corresponding inequality.\n \n-      ----------------------------\n-      -- Build_Function_Wrapper --\n-      ----------------------------\n-\n-      function Build_Function_Wrapper\n-        (Formal : Entity_Id;\n-         Actual : Entity_Id := Empty) return Node_Id\n-      is\n-         Loc       : constant Source_Ptr := Sloc (I_Node);\n-         Actuals   : List_Id;\n-         Decl      : Node_Id;\n-         Func_Name : Node_Id;\n-         Func      : Entity_Id;\n-         Parm_Type : Node_Id;\n-         Profile   : List_Id := New_List;\n-         Spec      : Node_Id;\n-         Act_F     : Entity_Id;\n-         Form_F    : Entity_Id;\n-         New_F     : Entity_Id;\n-\n-      begin\n-         --  If there is no actual, the formal has a default and is retrieved\n-         --  by name. Otherwise the wrapper encloses a call to the actual.\n-\n-         if No (Actual) then\n-            Func_Name := Make_Identifier (Loc, Chars (Formal));\n-         else\n-            Func_Name := New_Occurrence_Of (Entity (Actual), Loc);\n-         end if;\n-\n-         Func := Make_Defining_Identifier (Loc, Chars (Formal));\n-         Set_Ekind (Func, E_Function);\n-         Set_Is_Generic_Actual_Subprogram (Func);\n-\n-         Actuals := New_List;\n-         Profile := New_List;\n-\n-         if Present (Actual) then\n-            Act_F := First_Formal (Entity (Actual));\n-         else\n-            Act_F := Empty;\n-         end if;\n-\n-         Form_F := First_Formal (Formal);\n-         while Present (Form_F) loop\n-\n-            --  Create new formal for profile of wrapper, and add a reference\n-            --  to it in the list of actuals for the enclosing call. The name\n-            --  must be that of the formal in the formal subprogram, because\n-            --  calls to it in the generic body may use named associations.\n-\n-            New_F := Make_Defining_Identifier (Loc, Chars (Form_F));\n-\n-            if No (Actual) then\n-\n-               --  If formal has a class-wide type rewrite as the corresponding\n-               --  attribute, because the class-wide type is not retrievable by\n-               --  visbility.\n-\n-               if Is_Class_Wide_Type (Etype (Form_F)) then\n-                  Parm_Type :=\n-                    Make_Attribute_Reference (Loc,\n-                      Attribute_Name => Name_Class,\n-                      Prefix         =>\n-                        Make_Identifier (Loc, Chars (Etype (Etype (Form_F)))));\n-\n-               else\n-                  Parm_Type :=\n-                    Make_Identifier (Loc,\n-                      Chars => Chars (First_Subtype (Etype (Form_F))));\n-               end if;\n-\n-            --  If actual is present, use the type of its own formal\n-\n-            else\n-               Parm_Type := New_Occurrence_Of (Etype (Act_F), Loc);\n-            end if;\n-\n-            Append_To (Profile,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => New_F,\n-                Parameter_Type      => Parm_Type));\n-\n-            Append_To (Actuals, New_Occurrence_Of (New_F, Loc));\n-            Next_Formal (Form_F);\n-\n-            if Present (Act_F) then\n-               Next_Formal (Act_F);\n-            end if;\n-         end loop;\n-\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => Func,\n-             Parameter_Specifications => Profile,\n-             Result_Definition        =>\n-               Make_Identifier (Loc, Chars (Etype (Formal))));\n-\n-         Decl :=\n-           Make_Expression_Function (Loc,\n-             Specification => Spec,\n-             Expression    =>\n-               Make_Function_Call (Loc,\n-                 Name                   => Func_Name,\n-                 Parameter_Associations => Actuals));\n-\n-         return Decl;\n-      end Build_Function_Wrapper;\n-\n-      ----------------------------\n-      -- Build_Operator_Wrapper --\n-      ----------------------------\n-\n-      function Build_Operator_Wrapper\n-        (Formal : Entity_Id;\n-         Actual : Entity_Id := Empty) return Node_Id\n-      is\n-         Loc       : constant Source_Ptr := Sloc (I_Node);\n-         Typ       : constant Entity_Id := Etype (Formal);\n-         Is_Binary : constant Boolean :=\n-                       Present (Next_Formal (First_Formal (Formal)));\n-\n-         Decl    : Node_Id;\n-         Expr    : Node_Id;\n-         F1, F2  : Entity_Id;\n-         Func    : Entity_Id;\n-         Op_Name : Name_Id;\n-         Spec    : Node_Id;\n-         L, R    : Node_Id;\n-\n-      begin\n-         if No (Actual) then\n-            Op_Name := Chars (Formal);\n-         else\n-            Op_Name := Chars (Actual);\n-         end if;\n-\n-         --  Create entities for wrapper function and its formals\n-\n-         F1 := Make_Temporary (Loc, 'A');\n-         F2 := Make_Temporary (Loc, 'B');\n-         L  := New_Occurrence_Of (F1, Loc);\n-         R  := New_Occurrence_Of (F2, Loc);\n-\n-         Func := Make_Defining_Identifier (Loc, Chars (Formal));\n-         Set_Ekind (Func, E_Function);\n-         Set_Is_Generic_Actual_Subprogram (Func);\n-\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => Func,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                  Defining_Identifier => F1,\n-                  Parameter_Type      =>\n-                    Make_Identifier (Loc,\n-                      Chars => Chars (Etype (First_Formal (Formal)))))),\n-             Result_Definition        => Make_Identifier (Loc, Chars (Typ)));\n-\n-         if Is_Binary then\n-            Append_To (Parameter_Specifications (Spec),\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier => F2,\n-                 Parameter_Type =>\n-                   Make_Identifier (Loc,\n-                     Chars (Etype (Next_Formal (First_Formal (Formal)))))));\n-         end if;\n-\n-         --  Build expression as a function call, or as an operator node\n-         --  that corresponds to the name of the actual, starting with binary\n-         --  operators.\n-\n-         if Present (Actual) and then Op_Name not in Any_Operator_Name then\n-            Expr :=\n-              Make_Function_Call (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of (Entity (Actual), Loc),\n-                Parameter_Associations => New_List (L));\n-\n-            if Is_Binary then\n-               Append_To (Parameter_Associations (Expr), R);\n-            end if;\n-\n-         --  Binary operators\n-\n-         elsif Is_Binary then\n-            if Op_Name = Name_Op_And then\n-               Expr := Make_Op_And      (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Or then\n-               Expr := Make_Op_Or       (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Xor then\n-               Expr := Make_Op_Xor      (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Eq then\n-               Expr := Make_Op_Eq       (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Ne then\n-               Expr := Make_Op_Ne       (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Le then\n-               Expr := Make_Op_Le       (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Gt then\n-               Expr := Make_Op_Gt       (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Ge then\n-               Expr := Make_Op_Ge       (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Lt then\n-               Expr := Make_Op_Lt       (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Add then\n-               Expr := Make_Op_Add      (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Subtract then\n-               Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Concat then\n-               Expr := Make_Op_Concat   (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Multiply then\n-               Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Divide then\n-               Expr := Make_Op_Divide   (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Mod then\n-               Expr := Make_Op_Mod      (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Rem then\n-               Expr := Make_Op_Rem      (Loc, Left_Opnd => L, Right_Opnd => R);\n-            elsif Op_Name = Name_Op_Expon then\n-               Expr := Make_Op_Expon    (Loc, Left_Opnd => L, Right_Opnd => R);\n-            end if;\n-\n-         --  Unary operators\n-\n-         else\n-            if Op_Name = Name_Op_Add then\n-               Expr := Make_Op_Plus  (Loc, Right_Opnd => L);\n-            elsif Op_Name = Name_Op_Subtract then\n-               Expr := Make_Op_Minus (Loc, Right_Opnd => L);\n-            elsif Op_Name = Name_Op_Abs then\n-               Expr := Make_Op_Abs   (Loc, Right_Opnd => L);\n-            elsif Op_Name = Name_Op_Not then\n-               Expr := Make_Op_Not   (Loc, Right_Opnd => L);\n-            end if;\n-         end if;\n-\n-         --  Propagate visible entity to operator node, either from a\n-         --  given actual or from a default.\n-\n-         if Is_Entity_Name (Actual) and then Nkind (Expr) in N_Op then\n-            Set_Entity (Expr, Entity (Actual));\n-         end if;\n-\n-         Decl :=\n-           Make_Expression_Function (Loc,\n-             Specification => Spec,\n-             Expression    => Expr);\n-\n-         return Decl;\n-      end Build_Operator_Wrapper;\n-\n       ----------------------------------------\n       -- Check_Overloaded_Formal_Subprogram --\n       ----------------------------------------\n@@ -1798,64 +1528,9 @@ package body Sem_Ch12 is\n                      end if;\n \n                   else\n-                     if GNATprove_Mode\n-                        and then Present\n-                           (Containing_Package_With_Ext_Axioms\n-                              (Defining_Entity (Analyzed_Formal)))\n-                       and then Ekind (Defining_Entity (Analyzed_Formal)) =\n-                                                                    E_Function\n-                       and then Expander_Active\n-                     then\n-                        --  If actual is an entity (function or operator),\n-                        --  and expander is active, build wrapper for it.\n-                        --  Note that wrappers play no role within a generic.\n-\n-                        if Present (Match) then\n-                           if Nkind (Match) = N_Operator_Symbol then\n-\n-                              --  If the name is a default, find its visible\n-                              --  entity at the point of instantiation.\n-\n-                              if Is_Entity_Name (Match)\n-                                and then No (Entity (Match))\n-                              then\n-                                 Find_Direct_Name (Match);\n-                              end if;\n-\n-                              Append_To\n-                                (Assoc,\n-                                 Build_Operator_Wrapper\n-                                   (Defining_Entity (Analyzed_Formal), Match));\n-\n-                           else\n-                              Append_To (Assoc,\n-                                 Build_Function_Wrapper\n-                                   (Defining_Entity (Analyzed_Formal), Match));\n-                           end if;\n-\n-                        --  Ditto if formal is an operator with a default.\n-\n-                        elsif Box_Present (Formal)\n-                           and then Nkind (Defining_Entity (Analyzed_Formal)) =\n-                                                    N_Defining_Operator_Symbol\n-                        then\n-                           Append_To (Assoc,\n-                             Build_Operator_Wrapper\n-                               (Defining_Entity (Analyzed_Formal)));\n-\n-                        --  Otherwise create renaming declaration.\n-\n-                        else\n-                           Append_To (Assoc,\n-                             Build_Function_Wrapper\n-                               (Defining_Entity (Analyzed_Formal)));\n-                        end if;\n-\n-                     else\n-                        Append_To (Assoc,\n-                          Instantiate_Formal_Subprogram\n-                            (Formal, Match, Analyzed_Formal));\n-                     end if;\n+                     Append_To (Assoc,\n+                       Instantiate_Formal_Subprogram\n+                         (Formal, Match, Analyzed_Formal));\n \n                      --  An instantiation is a freeze point for the actuals,\n                      --  unless this is a rewritten formal package.\n@@ -5445,6 +5120,223 @@ package body Sem_Ch12 is\n       end if;\n    end Get_Associated_Node;\n \n+   ----------------------------\n+   -- Build_Function_Wrapper --\n+   ----------------------------\n+\n+   function Build_Function_Wrapper\n+     (Formal : Entity_Id;\n+      Actual : Entity_Id) return Node_Id\n+   is\n+      Loc       : constant Source_Ptr := Sloc (Formal);\n+      Actuals   : List_Id;\n+      Decl      : Node_Id;\n+      Func_Name : Node_Id;\n+      Func      : Entity_Id;\n+      Parm_Type : Node_Id;\n+      Profile   : List_Id := New_List;\n+      Spec      : Node_Id;\n+      Act_F     : Entity_Id;\n+      Form_F    : Entity_Id;\n+      New_F     : Entity_Id;\n+\n+   begin\n+      Func_Name := New_Occurrence_Of (Actual, Loc);\n+\n+      Func := Make_Defining_Identifier (Loc, Chars (Formal));\n+      Set_Ekind (Func, E_Function);\n+      Set_Is_Generic_Actual_Subprogram (Func);\n+\n+      Actuals := New_List;\n+      Profile := New_List;\n+\n+      if Present (Actual) then\n+         Act_F := First_Formal (Actual);\n+      else\n+         Act_F := Empty;\n+      end if;\n+\n+      Form_F := First_Formal (Formal);\n+      while Present (Form_F) loop\n+\n+         --  Create new formal for profile of wrapper, and add a reference\n+         --  to it in the list of actuals for the enclosing call. The name\n+         --  must be that of the formal in the formal subprogram, because\n+         --  calls to it in the generic body may use named associations.\n+\n+         New_F := Make_Defining_Identifier (Loc, Chars (Form_F));\n+\n+         Parm_Type := New_Occurrence_Of (Etype (Act_F), Loc);\n+\n+         Append_To (Profile,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => New_F,\n+             Parameter_Type      => Parm_Type));\n+\n+         Append_To (Actuals, New_Occurrence_Of (New_F, Loc));\n+         Next_Formal (Form_F);\n+\n+         if Present (Act_F) then\n+            Next_Formal (Act_F);\n+         end if;\n+      end loop;\n+\n+      Spec :=\n+        Make_Function_Specification (Loc,\n+          Defining_Unit_Name       => Func,\n+          Parameter_Specifications => Profile,\n+          Result_Definition        =>\n+            Make_Identifier (Loc, Chars (Etype (Formal))));\n+\n+      Decl :=\n+        Make_Expression_Function (Loc,\n+          Specification => Spec,\n+          Expression    =>\n+            Make_Function_Call (Loc,\n+              Name                   => Func_Name,\n+              Parameter_Associations => Actuals));\n+\n+      return Decl;\n+   end Build_Function_Wrapper;\n+\n+   ----------------------------\n+   -- Build_Operator_Wrapper --\n+   ----------------------------\n+\n+   function Build_Operator_Wrapper\n+     (Formal : Entity_Id;\n+      Actual : Entity_Id) return Node_Id\n+   is\n+      Loc       : constant Source_Ptr := Sloc (Formal);\n+      Typ       : constant Entity_Id := Etype (Formal);\n+      Is_Binary : constant Boolean :=\n+                    Present (Next_Formal (First_Formal (Formal)));\n+\n+      Decl    : Node_Id;\n+      Expr    : Node_Id;\n+      F1, F2  : Entity_Id;\n+      Func    : Entity_Id;\n+      Op_Name : Name_Id;\n+      Spec    : Node_Id;\n+      L, R    : Node_Id;\n+\n+   begin\n+      Op_Name := Chars (Actual);\n+\n+      --  Create entities for wrapper function and its formals\n+\n+      F1 := Make_Temporary (Loc, 'A');\n+      F2 := Make_Temporary (Loc, 'B');\n+      L  := New_Occurrence_Of (F1, Loc);\n+      R  := New_Occurrence_Of (F2, Loc);\n+\n+      Func := Make_Defining_Identifier (Loc, Chars (Formal));\n+      Set_Ekind (Func, E_Function);\n+      Set_Is_Generic_Actual_Subprogram (Func);\n+\n+      Spec :=\n+        Make_Function_Specification (Loc,\n+          Defining_Unit_Name       => Func,\n+          Parameter_Specifications => New_List (\n+            Make_Parameter_Specification (Loc,\n+               Defining_Identifier => F1,\n+               Parameter_Type      =>\n+                 Make_Identifier (Loc,\n+                   Chars => Chars (Etype (First_Formal (Formal)))))),\n+          Result_Definition        => Make_Identifier (Loc, Chars (Typ)));\n+\n+      if Is_Binary then\n+         Append_To (Parameter_Specifications (Spec),\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier => F2,\n+              Parameter_Type      =>\n+                Make_Identifier (Loc,\n+                  Chars (Etype (Next_Formal (First_Formal (Formal)))))));\n+      end if;\n+\n+      --  Build expression as a function call, or as an operator node\n+      --  that corresponds to the name of the actual, starting with\n+      --  binary operators.\n+\n+      if Present (Actual) and then Op_Name not in Any_Operator_Name then\n+         Expr :=\n+           Make_Function_Call (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (Entity (Actual), Loc),\n+             Parameter_Associations => New_List (L));\n+\n+         if Is_Binary then\n+            Append_To (Parameter_Associations (Expr), R);\n+         end if;\n+\n+      --  Binary operators\n+\n+      elsif Is_Binary then\n+         if Op_Name = Name_Op_And then\n+            Expr := Make_Op_And      (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Or then\n+            Expr := Make_Op_Or       (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Xor then\n+            Expr := Make_Op_Xor      (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Eq then\n+            Expr := Make_Op_Eq       (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Ne then\n+            Expr := Make_Op_Ne       (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Le then\n+            Expr := Make_Op_Le       (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Gt then\n+            Expr := Make_Op_Gt       (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Ge then\n+            Expr := Make_Op_Ge       (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Lt then\n+            Expr := Make_Op_Lt       (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Add then\n+            Expr := Make_Op_Add      (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Subtract then\n+            Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Concat then\n+            Expr := Make_Op_Concat   (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Multiply then\n+            Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Divide then\n+            Expr := Make_Op_Divide   (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Mod then\n+            Expr := Make_Op_Mod      (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Rem then\n+            Expr := Make_Op_Rem      (Loc, Left_Opnd => L, Right_Opnd => R);\n+         elsif Op_Name = Name_Op_Expon then\n+            Expr := Make_Op_Expon    (Loc, Left_Opnd => L, Right_Opnd => R);\n+         end if;\n+\n+      --  Unary operators\n+\n+      else\n+         if Op_Name = Name_Op_Add then\n+            Expr := Make_Op_Plus  (Loc, Right_Opnd => L);\n+         elsif Op_Name = Name_Op_Subtract then\n+            Expr := Make_Op_Minus (Loc, Right_Opnd => L);\n+         elsif Op_Name = Name_Op_Abs then\n+            Expr := Make_Op_Abs   (Loc, Right_Opnd => L);\n+         elsif Op_Name = Name_Op_Not then\n+            Expr := Make_Op_Not   (Loc, Right_Opnd => L);\n+         end if;\n+      end if;\n+\n+      --  Propagate visible entity to operator node, either from a\n+      --  given actual or from a default.\n+\n+      if Is_Entity_Name (Actual) and then Nkind (Expr) in N_Op then\n+         Set_Entity (Expr, Entity (Actual));\n+      end if;\n+\n+      Decl :=\n+        Make_Expression_Function (Loc,\n+          Specification => Spec,\n+          Expression    => Expr);\n+\n+      return Decl;\n+   end Build_Operator_Wrapper;\n+\n    -------------------------------------------\n    -- Build_Instance_Compilation_Unit_Nodes --\n    -------------------------------------------"}, {"sha": "c29a0a7c187b3dcd012d49ed2fafe5258fc12f25", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=948ed277461760a367678c9afbd55e45eda8707e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,22 @@ package Sem_Ch12 is\n    procedure Analyze_Formal_Subprogram_Declaration      (N : Node_Id);\n    procedure Analyze_Formal_Package_Declaration         (N : Node_Id);\n \n+   function Build_Function_Wrapper\n+     (Formal : Entity_Id;\n+      Actual : Entity_Id) return Node_Id;\n+   --  In GNATprove mode, create a wrapper function for actuals that are\n+   --  functions with any number of formal parameters, in order to propagate\n+   --  their contract to the renaming declarations generated for them. This\n+   --  is called after the renaming declaration created for the formal in the\n+   --  instance has been analyzed, and the actual is known.\n+\n+   function Build_Operator_Wrapper\n+     (Formal : Entity_Id;\n+      Actual : Entity_Id) return Node_Id;\n+   --  In GNATprove mode, create a wrapper function for actuals that are\n+   --  operators, in order to propagate their contract to the renaming\n+   --  declarations generated for them.\n+\n    procedure Start_Generic;\n    --  Must be invoked before starting to process a generic spec or body\n "}, {"sha": "5794209e9d5c7d68bf22f5f2651a8c9d7cab3f7f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=948ed277461760a367678c9afbd55e45eda8707e", "patch": "@@ -9641,11 +9641,26 @@ package body Sem_Ch6 is\n                      --  in the formal part, because in a generic body the\n                      --  entity chain starts with the formals.\n \n-                     pragma Assert\n-                       (Present (Prev) or else Chars (E) = Name_Op_Concat);\n+                     --  In GNATprove mode, a wrapper for an operation with\n+                     --  axiomatization may be a homonym of another declaration\n+                     --  for an actual subprogram (needs refinement ???).\n+\n+                     if No (Prev) then\n+                        if In_Instance\n+                          and then GNATprove_Mode\n+                          and then\n+                            Nkind (Original_Node (Unit_Declaration_Node (S))) =\n+                                             N_Subprogram_Renaming_Declaration\n+                        then\n+                           return;\n+                        else\n+                           pragma Assert (Chars (E) = Name_Op_Concat);\n+                           null;\n+                        end if;\n+                     end if;\n \n                      --  E must be removed both from the entity_list of the\n-                     --  current scope, and from the visibility chain\n+                     --  current scope, and from the visibility chain.\n \n                      if Debug_Flag_E then\n                         Write_Str (\"Override implicit operation \");"}, {"sha": "cd008c134bc775477e4407feac668df945a5eea9", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948ed277461760a367678c9afbd55e45eda8707e/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=948ed277461760a367678c9afbd55e45eda8707e", "patch": "@@ -3451,6 +3451,24 @@ package body Sem_Ch8 is\n       Ada_Version := Save_AV;\n       Ada_Version_Pragma := Save_AVP;\n       Ada_Version_Explicit := Save_AV_Exp;\n+\n+      --  In GNATprove mode, the renamings of actual subprograms are replaced\n+      --  with wrapper functions that make it easier to propagate axioms to the\n+      --  points of call within an instance.\n+\n+      if Is_Actual\n+        and then GNATprove_Mode\n+        and then Present (Containing_Package_With_Ext_Axioms (Old_S))\n+        and then not Inside_A_Generic\n+      then\n+         if Ekind (Old_S) = E_Function then\n+            Rewrite (N, Build_Function_Wrapper (New_S, Old_S));\n+            Analyze (N);\n+         elsif Ekind (Old_S) = E_Operator then\n+            Rewrite (N, Build_Operator_Wrapper (New_S, Old_S));\n+            Analyze (N);\n+         end if;\n+      end if;\n    end Analyze_Subprogram_Renaming;\n \n    -------------------------"}]}