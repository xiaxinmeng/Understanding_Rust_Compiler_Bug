{"sha": "44fc0a5136eea2fb4eb7d46a8065ee518f6eb575", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmYzBhNTEzNmVlYTJmYjRlYjdkNDZhODA2NWVlNTE4ZjZlYjU3NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-09T12:23:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-09T12:23:22Z"}, "message": "genmatch.c (struct expr): Add force_single_use flag.\n\n2015-07-09  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (struct expr): Add force_single_use flag.\n\t(expr::expr): Add copy constructor.\n\t(capture_info::walk_match): Gather force_single_use captures.\n\t(expr::gen_transform): Use possibly NULLified sequence.\n\t(dt_simplify::gen): Apply single-use restrictions by NULLifying\n\tseq if any constrained expr is not single-use.\n\t(parser::parse_expr): Refactor to allow multiple flags.  Handle\n\t's' flag to force an expression have a single-use if the pattern\n\tsimplifies to more than one statement.\n\t* match.pd: Convert most single_use conditionals to :s flags.\n\nFrom-SVN: r225610", "tree": {"sha": "786e34083516679a8f0e676f714a27a7fad71cfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/786e34083516679a8f0e676f714a27a7fad71cfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d48ca70553f3884bff4827c98e1fd21f10bdc463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d48ca70553f3884bff4827c98e1fd21f10bdc463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d48ca70553f3884bff4827c98e1fd21f10bdc463"}], "stats": {"total": 203, "additions": 131, "deletions": 72}, "files": [{"sha": "8e05c427c45050e7df16063bb23f7541c3cf9f5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44fc0a5136eea2fb4eb7d46a8065ee518f6eb575", "patch": "@@ -1,3 +1,16 @@\n+2015-07-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (struct expr): Add force_single_use flag.\n+\t(expr::expr): Add copy constructor.\n+\t(capture_info::walk_match): Gather force_single_use captures.\n+\t(expr::gen_transform): Use possibly NULLified sequence.\n+\t(dt_simplify::gen): Apply single-use restrictions by NULLifying\n+\tseq if any constrained expr is not single-use.\n+\t(parser::parse_expr): Refactor to allow multiple flags.  Handle\n+\t's' flag to force an expression have a single-use if the pattern\n+\tsimplifies to more than one statement.\n+\t* match.pd: Convert most single_use conditionals to :s flags.\n+\n 2015-07-09  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/iamcu.h (ASM_OUTPUT_ALIGNED_BSS): New."}, {"sha": "15ce1f591bd8b8f191aaf2bb5cb21322d0242d06", "filename": "gcc/genmatch.c", "status": "modified", "additions": 103, "deletions": 50, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=44fc0a5136eea2fb4eb7d46a8065ee518f6eb575", "patch": "@@ -491,7 +491,11 @@ struct expr : public operand\n   expr (id_base *operation_, bool is_commutative_ = false)\n     : operand (OP_EXPR), operation (operation_),\n       ops (vNULL), expr_type (NULL), is_commutative (is_commutative_),\n-      is_generic (false) {}\n+      is_generic (false), force_single_use (false) {}\n+  expr (expr *e)\n+    : operand (OP_EXPR), operation (e->operation),\n+      ops (vNULL), expr_type (e->expr_type), is_commutative (e->is_commutative),\n+      is_generic (e->is_generic), force_single_use (e->force_single_use) {}\n   void append_op (operand *op) { ops.safe_push (op); }\n   /* The operator and its operands.  */\n   id_base *operation;\n@@ -503,6 +507,9 @@ struct expr : public operand\n   bool is_commutative;\n   /* Whether the expression is expected to be in GENERIC form.  */\n   bool is_generic;\n+  /* Whether pushing any stmt to the sequence should be conditional\n+     on this expression having a single-use.  */\n+  bool force_single_use;\n   virtual void gen_transform (FILE *f, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0, bool = true);\n@@ -747,7 +754,8 @@ commutate (operand *op)\n \n   for (unsigned i = 0; i < result.length (); ++i)\n     {\n-      expr *ne = new expr (e->operation);\n+      expr *ne = new expr (e);\n+      ne->is_commutative = false;\n       for (unsigned j = 0; j < result[i].length (); ++j)\n \tne->append_op (result[i][j]);\n       ret.safe_push (ne);\n@@ -758,7 +766,8 @@ commutate (operand *op)\n \n   for (unsigned i = 0; i < result.length (); ++i)\n     {\n-      expr *ne = new expr (e->operation);\n+      expr *ne = new expr (e);\n+      ne->is_commutative = false;\n       // result[i].length () is 2 since e->operation is binary\n       for (unsigned j = result[i].length (); j; --j)\n \tne->append_op (result[i][j-1]);\n@@ -809,14 +818,15 @@ lower_opt_convert (operand *o, enum tree_code oper,\n       if (strip)\n \treturn lower_opt_convert (e->ops[0], oper, to_oper, strip);\n \n-      expr *ne = new expr (to_oper == CONVERT_EXPR\n-\t\t\t   ? get_operator (\"CONVERT_EXPR\")\n-\t\t\t   : get_operator (\"VIEW_CONVERT_EXPR\"));\n+      expr *ne = new expr (e);\n+      ne->operation = (to_oper == CONVERT_EXPR\n+\t\t       ? get_operator (\"CONVERT_EXPR\")\n+\t\t       : get_operator (\"VIEW_CONVERT_EXPR\"));\n       ne->append_op (lower_opt_convert (e->ops[0], oper, to_oper, strip));\n       return ne;\n     }\n \n-  expr *ne = new expr (e->operation, e->is_commutative);\n+  expr *ne = new expr (e);\n   for (unsigned i = 0; i < e->ops.length (); ++i)\n     ne->append_op (lower_opt_convert (e->ops[i], oper, to_oper, strip));\n \n@@ -951,7 +961,7 @@ lower_cond (operand *o)\n \n   for (unsigned i = 0; i < result.length (); ++i)\n     {\n-      expr *ne = new expr (e->operation);\n+      expr *ne = new expr (e);\n       for (unsigned j = 0; j < result[i].length (); ++j)\n \tne->append_op (result[i][j]);\n       ro.safe_push (ne);\n@@ -968,13 +978,13 @@ lower_cond (operand *o)\n \t      || (is_a <expr *> (e->ops[0])\n \t\t  && as_a <expr *> (e->ops[0])->ops.length () == 2)))\n \t{\n-\t  expr *ne = new expr (e->operation);\n+\t  expr *ne = new expr (e);\n \t  for (unsigned j = 0; j < result[i].length (); ++j)\n \t    ne->append_op (result[i][j]);\n \t  if (capture *c = dyn_cast <capture *> (ne->ops[0]))\n \t    {\n \t      expr *ocmp = as_a <expr *> (c->what);\n-\t      expr *cmp = new expr (ocmp->operation);\n+\t      expr *cmp = new expr (ocmp);\n \t      for (unsigned j = 0; j < ocmp->ops.length (); ++j)\n \t\tcmp->append_op (ocmp->ops[j]);\n \t      cmp->is_generic = true;\n@@ -983,7 +993,7 @@ lower_cond (operand *o)\n \t  else\n \t    {\n \t      expr *ocmp = as_a <expr *> (ne->ops[0]);\n-\t      expr *cmp = new expr (ocmp->operation);\n+\t      expr *cmp = new expr (ocmp);\n \t      for (unsigned j = 0; j < ocmp->ops.length (); ++j)\n \t\tcmp->append_op (ocmp->ops[j]);\n \t      cmp->is_generic = true;\n@@ -1027,9 +1037,9 @@ replace_id (operand *o, user_id *id, id_base *with)\n     }\n   else if (expr *e = dyn_cast<expr *> (o))\n     {\n-      expr *ne = new expr (e->operation == id ? with : e->operation,\n-\t\t\t   e->is_commutative);\n-      ne->expr_type = e->expr_type;\n+      expr *ne = new expr (e);\n+      if (e->operation == id)\n+\tne->operation = with;\n       for (unsigned i = 0; i < e->ops.length (); ++i)\n \tne->append_op (replace_id (e->ops[i], id, with));\n       return ne;\n@@ -1513,6 +1523,7 @@ struct capture_info\n       bool expr_p;\n       bool cse_p;\n       bool force_no_side_effects_p;\n+      bool force_single_use;\n       bool cond_expr_cond_p;\n       unsigned long toplevel_msk;\n       int result_use_count;\n@@ -1566,10 +1577,12 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,\n       info[c->where].force_no_side_effects_p |= conditional_p;\n       info[c->where].cond_expr_cond_p |= cond_expr_cond_p;\n       /* Mark expr (non-leaf) captures and recurse.  */\n+      expr *e;\n       if (c->what\n-\t  && is_a <expr *> (c->what))\n+\t  && (e = dyn_cast <expr *> (c->what)))\n \t{\n \t  info[c->where].expr_p = true;\n+\t  info[c->where].force_single_use |= e->force_single_use;\n \t  walk_match (c->what, toplevel_arg, conditional_p, false);\n \t}\n     }\n@@ -1808,9 +1821,9 @@ expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \"ops%d[%u]%s\", depth, i,\n \t\t i == ops.length () - 1 ? \" };\\n\" : \", \");\n-      fprintf (f, \"  gimple_resimplify%d (seq, &tem_code, %s, tem_ops, valueize);\\n\",\n+      fprintf (f, \"  gimple_resimplify%d (lseq, &tem_code, %s, tem_ops, valueize);\\n\",\n \t       ops.length (), type);\n-      fprintf (f, \"  res = maybe_push_res_to_seq (tem_code, %s, tem_ops, seq);\\n\"\n+      fprintf (f, \"  res = maybe_push_res_to_seq (tem_code, %s, tem_ops, lseq);\\n\"\n \t       \"  if (!res) return false;\\n\", type);\n       if (*operation == CONVERT_EXPR)\n         fprintf (f, \"  }\\n\"\n@@ -2449,27 +2462,52 @@ dt_simplify::gen (FILE *f, bool gimple)\n      that cover cases we cannot handle.  */\n   capture_info cinfo (s);\n   expr *e;\n-  if (!gimple\n-      && s->result\n+  if (s->result\n       && !((e = dyn_cast <expr *> (s->result))\n \t   && is_a <predicate_id *> (e->operation)))\n     {\n-      for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n-\tif (cinfo.force_no_side_effects & (1 << i))\n-\t  fprintf (f, \"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\", i);\n-      for (int i = 0; i <= s->capture_max; ++i)\n-\tif (cinfo.info[i].cse_p)\n-\t  ;\n-\telse if (cinfo.info[i].force_no_side_effects_p\n-\t\t && (cinfo.info[i].toplevel_msk\n-\t\t     & cinfo.force_no_side_effects) == 0)\n-\t  fprintf (f, \"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n-\t\t   \"return NULL_TREE;\\n\", i);\n-\telse if ((cinfo.info[i].toplevel_msk\n-\t\t  & cinfo.force_no_side_effects) != 0)\n-\t  /* Mark capture as having no side-effects if we had to verify\n-\t     that via forced toplevel operand checks.  */\n-\t  cinfo.info[i].force_no_side_effects_p = true;\n+      if (!gimple)\n+\t{\n+\t  for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n+\t    if (cinfo.force_no_side_effects & (1 << i))\n+\t      fprintf (f, \"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\", i);\n+\t  for (int i = 0; i <= s->capture_max; ++i)\n+\t    if (cinfo.info[i].cse_p)\n+\t      ;\n+\t    else if (cinfo.info[i].force_no_side_effects_p\n+\t\t     && (cinfo.info[i].toplevel_msk\n+\t\t\t & cinfo.force_no_side_effects) == 0)\n+\t      fprintf (f, \"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n+\t\t       \"return NULL_TREE;\\n\", i);\n+\t    else if ((cinfo.info[i].toplevel_msk\n+\t\t      & cinfo.force_no_side_effects) != 0)\n+\t      /* Mark capture as having no side-effects if we had to verify\n+\t\t that via forced toplevel operand checks.  */\n+\t      cinfo.info[i].force_no_side_effects_p = true;\n+\t}\n+      if (gimple)\n+\t{\n+\t  /* Force single-use restriction by only allowing simple\n+\t     results via setting seq to NULL.  */\n+\t  fprintf (f, \"gimple_seq *lseq = seq;\\n\");\n+\t  bool first_p = true;\n+\t  for (int i = 0; i <= s->capture_max; ++i)\n+\t    if (cinfo.info[i].force_single_use)\n+\t      {\n+\t\tif (first_p)\n+\t\t  {\n+\t\t    fprintf (f, \"if (lseq\\n\"\n+\t\t\t     \"&& (\");\n+\t\t    first_p = false;\n+\t\t  }\n+\t\telse\n+\t\t  fprintf (f, \"\\n|| \");\n+\t\tfprintf (f, \"!single_use (captures[%d])\", i);\n+\t      }\n+\t  if (!first_p)\n+\t    fprintf (f, \"))\\n\"\n+\t\t     \"lseq = NULL;\\n\");\n+\t}\n     }\n \n   fprintf (f, \"if (dump_file && (dump_flags & TDF_DETAILS)) \"\n@@ -2524,7 +2562,7 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t  /* Re-fold the toplevel result.  It's basically an embedded\n \t     gimple_build w/o actually building the stmt.  */\n \t  if (!is_predicate)\n-\t    fprintf (f, \"gimple_resimplify%d (seq, res_code, type, \"\n+\t    fprintf (f, \"gimple_resimplify%d (lseq, res_code, type, \"\n \t\t     \"res_ops, valueize);\\n\", e->ops.length ());\n \t}\n       else if (result->type == operand::OP_CAPTURE\n@@ -3051,6 +3089,7 @@ parser::parse_expr ()\n   const cpp_token *token = peek ();\n   operand *op;\n   bool is_commutative = false;\n+  bool force_capture = false;\n   const char *expr_type = NULL;\n \n   if (token->type == CPP_COLON\n@@ -3062,22 +3101,25 @@ parser::parse_expr ()\n \t  && !(token->flags & PREV_WHITE))\n \t{\n \t  const char *s = get_ident ();\n-\t  if (s[0] == 'c' && !s[1])\n-\t    {\n-\t      if (!parsing_match_operand)\n-\t\tfatal_at (token,\n-\t\t\t  \"flag 'c' can only be used in match expression\");\n-\t      is_commutative = true;\n-\t    }\n-\t  else if (s[1] != '\\0')\n+\t  if (!parsing_match_operand)\n+\t    expr_type = s;\n+\t  else\n \t    {\n-\t      if (parsing_match_operand)\n-\t\tfatal_at (token, \"type can only be used in result expression\");\n-\t      expr_type = s;\n+\t      const char *sp = s;\n+\t      while (*sp)\n+\t\t{\n+\t\t  if (*sp == 'c')\n+\t\t    is_commutative = true;\n+\t\t  else if (*sp == 's')\n+\t\t    {\n+\t\t      e->force_single_use = true;\n+\t\t      force_capture = true;\n+\t\t    }\n+\t      \t  else\n+\t\t    fatal_at (token, \"flag %c not recognized\", *sp);\n+\t\t  sp++;\n+\t\t}\n \t    }\n-\t  else\n-\t    fatal_at (token, \"flag %s not recognized\", s);\n-\n \t  token = peek ();\n \t}\n       else\n@@ -3087,6 +3129,17 @@ parser::parse_expr ()\n   if (token->type == CPP_ATSIGN\n       && !(token->flags & PREV_WHITE))\n     op = parse_capture (e);\n+  else if (force_capture)\n+    {\n+      unsigned num = capture_ids->elements ();\n+      char id[8];\n+      bool existed;\n+      sprintf (id, \"__%u\", num);\n+      capture_ids->get_or_insert (xstrdup (id), &existed);\n+      if (existed)\n+\tfatal_at (token, \"reserved capture id '%s' already used\", id);\n+      op = new capture (num, e);\n+    }\n   else\n     op = e;\n   do"}, {"sha": "b28f107be90bb764298e2964dc6db3227eb3ff1d", "filename": "gcc/match.pd", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fc0a5136eea2fb4eb7d46a8065ee518f6eb575/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=44fc0a5136eea2fb4eb7d46a8065ee518f6eb575", "patch": "@@ -334,17 +334,15 @@ along with GCC; see the file COPYING3.  If not see\n \n /* x + (x & 1) -> (x + 1) & ~1 */\n (simplify\n- (plus:c @0 (bit_and@2 @0 integer_onep@1))\n- (if (single_use (@2))\n-  (bit_and (plus @0 @1) (bit_not @1))))\n+ (plus:c @0 (bit_and:s @0 integer_onep@1))\n+ (bit_and (plus @0 @1) (bit_not @1)))\n \n /* x & ~(x & y) -> x & ~y */\n /* x | ~(x | y) -> x | ~y  */\n (for bitop (bit_and bit_ior)\n  (simplify\n-  (bitop:c @0 (bit_not (bitop:c@2 @0 @1)))\n-   (if (single_use (@2))\n-    (bitop @0 (bit_not @1)))))\n+  (bitop:c @0 (bit_not (bitop:cs @0 @1)))\n+  (bitop @0 (bit_not @1))))\n \n /* (x | y) & ~x -> y & ~x */\n /* (x & y) | ~x -> y | ~x */\n@@ -633,17 +631,14 @@ along with GCC; see the file COPYING3.  If not see\n \n /* (x & ~m) | (y & m) -> ((x ^ y) & m) ^ x */\n (simplify\n-  (bit_ior:c (bit_and:c@3 @0 (bit_not @2)) (bit_and:c@4 @1 @2))\n-  (if (single_use (@3) && single_use (@4))\n-   (bit_xor (bit_and (bit_xor @0 @1) @2) @0)))\n+ (bit_ior:c (bit_and:cs @0 (bit_not @2)) (bit_and:cs @1 @2))\n+ (bit_xor (bit_and (bit_xor @0 @1) @2) @0))\n \n \n /* Associate (p +p off1) +p off2 as (p +p (off1 + off2)).  */\n (simplify\n-  (pointer_plus (pointer_plus@2 @0 @1) @3)\n-  (if (single_use (@2)\n-       || (TREE_CODE (@1) == INTEGER_CST && TREE_CODE (@3) == INTEGER_CST))\n-   (pointer_plus @0 (plus @1 @3))))\n+  (pointer_plus (pointer_plus:s @0 @1) @3)\n+  (pointer_plus @0 (plus @1 @3)))\n \n /* Pattern match\n      tem1 = (long) ptr1;\n@@ -913,7 +908,8 @@ along with GCC; see the file COPYING3.  If not see\n    if the new mask might be further optimized.  */\n (for shift (lshift rshift)\n  (simplify\n-  (bit_and (convert?@4 (shift@5 (convert1?@3 @0) INTEGER_CST@1)) INTEGER_CST@2)\n+  (bit_and (convert?:s@4 (shift:s@5 (convert1?@3 @0) INTEGER_CST@1))\n+           INTEGER_CST@2)\n    (if (tree_nop_conversion_p (TREE_TYPE (@4), TREE_TYPE (@5))\n \t&& TYPE_PRECISION (type) <= HOST_BITS_PER_WIDE_INT\n \t&& tree_fits_uhwi_p (@1)\n@@ -993,8 +989,7 @@ along with GCC; see the file COPYING3.  If not see\n \t (with\n \t  { tree newmaskt = build_int_cst_type (TREE_TYPE (@2), newmask); }\n \t  (if (!tree_int_cst_equal (newmaskt, @2))\n-\t   (if (shift_type != TREE_TYPE (@3)\n-\t\t&& single_use (@4) && single_use (@5))\n+\t   (if (shift_type != TREE_TYPE (@3))\n \t    (bit_and (convert (shift:shift_type (convert @3) @1)) { newmaskt; }))\n \t   (if (shift_type == TREE_TYPE (@3))\n \t    (bit_and @4 { newmaskt; }))))))))))))\n@@ -1733,7 +1728,7 @@ along with GCC; see the file COPYING3.  If not see\n    operation and convert the result to the desired type.  */\n (for op (plus minus)\n   (simplify\n-    (convert (op@4 (convert@2 @0) (convert@3 @1)))\n+    (convert (op:s (convert@2 @0) (convert@3 @1)))\n     (if (INTEGRAL_TYPE_P (type)\n \t /* We check for type compatibility between @0 and @1 below,\n \t    so there's no need to check that @1/@3 are integral types.  */\n@@ -1750,8 +1745,7 @@ along with GCC; see the file COPYING3.  If not see\n \t /* The inner conversion must be a widening conversion.  */\n \t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n \t && types_match (@0, @1)\n-\t && types_match (@0, type)\n-\t && single_use (@4))\n+\t && types_match (@0, type))\n       (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n \t(convert (op @0 @1)))\n       (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n@@ -1764,7 +1758,7 @@ along with GCC; see the file COPYING3.  If not see\n    arithmetic operation.  */\n (for op (minus plus)\n   (simplify\n-    (bit_and (op@5 (convert@2 @0) (convert@3 @1)) INTEGER_CST@4)\n+    (bit_and (op:s (convert@2 @0) (convert@3 @1)) INTEGER_CST@4)\n     (if (INTEGRAL_TYPE_P (type)\n \t /* We check for type compatibility between @0 and @1 below,\n \t    so there's no need to check that @1/@3 are integral types.  */\n@@ -1784,8 +1778,7 @@ along with GCC; see the file COPYING3.  If not see\n \t && (tree_int_cst_min_precision (@4, TYPE_SIGN (TREE_TYPE (@0)))\n \t     <= TYPE_PRECISION (TREE_TYPE (@0)))\n \t && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0))\n-\t     || tree_int_cst_sgn (@4) >= 0)\n-\t && single_use (@5))\n+\t     || tree_int_cst_sgn (@4) >= 0))\n       (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n \t(with { tree ntype = TREE_TYPE (@0); }\n \t  (convert (bit_and (op @0 @1) (convert:ntype @4)))))"}]}