{"sha": "b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5NjY1MWI3ZDI4MWJkMWJmMjI2ODhmNGRlMGNiYjc4YzFiZjhlNQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2019-03-10T16:20:06Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2019-03-10T16:20:06Z"}, "message": "Make SRA less strict with memcpy performing MEM_REFs\n\n2019-03-10  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/85762\n\tPR tree-optimization/87008\n\tPR tree-optimization/85459\n\t* tree-sra.c (contains_vce_or_bfcref_p): New parameter, set the bool\n\tit points to if there is a type changing MEM_REF.  Adjust all callers.\n\t(build_accesses_from_assign): Disable total scalarization if\n\tcontains_vce_or_bfcref_p returns true through the new parameter, for\n\tboth rhs and lhs.\n\n\ttestsuite/\n\t* g++.dg/tree-ssa/pr87008.C: New test.\n\t* gcc.dg/guality/pr54970.c: Xfail tests querying a[0] everywhere.\n\nFrom-SVN: r269556", "tree": {"sha": "8a9e5b2bc72dddda093b0e99bf113af636f6c757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a9e5b2bc72dddda093b0e99bf113af636f6c757"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f862706a22c2ce0b94390c5b6ecd3cb15a135d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f862706a22c2ce0b94390c5b6ecd3cb15a135d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f862706a22c2ce0b94390c5b6ecd3cb15a135d9"}], "stats": {"total": 78, "additions": 66, "deletions": 12}, "files": [{"sha": "d1e59d4886a2b8274dab270a128896310a20a6ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "patch": "@@ -1,3 +1,14 @@\n+2019-03-10  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/85762\n+\tPR tree-optimization/87008\n+\tPR tree-optimization/85459\n+\t* tree-sra.c (contains_vce_or_bfcref_p): New parameter, set the bool\n+\tit points to if there is a type changing MEM_REF.  Adjust all callers.\n+\t(build_accesses_from_assign): Disable total scalarization if\n+\tcontains_vce_or_bfcref_p returns true through the new parameter, for\n+\tboth rhs and lhs.\n+\n 2019-03-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/88568"}, {"sha": "b6d6f678ed4855bf2dbf974bc931684ca67eba3d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "patch": "@@ -1,3 +1,11 @@\n+2019-03-10  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/85762\n+\tPR tree-optimization/87008\n+\tPR tree-optimization/85459\n+\t* g++.dg/tree-ssa/pr87008.C: New test.\n+\t* gcc.dg/guality/pr54970.c: Xfail tests querying a[0] everywhere.\n+\n 2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/66089"}, {"sha": "eef521f9ad5a7f534890e32aa09a224556f97928", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr87008.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr87008.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr87008.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr87008.C?ref=b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+extern void dontcallthis();\n+\n+struct A { long a, b; };\n+struct B : A {};\n+template<class T>void cp(T&a,T const&b){a=b;}\n+long f(B x){\n+  B y; cp<A>(y,x);\n+  B z; cp<A>(z,x);\n+  if (y.a - z.a)\n+    dontcallthis ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"dontcallthis\" \"optimized\" } } */"}, {"sha": "2e0bc5784a9812e0c8d0846d558a215ba5eacd25", "filename": "gcc/testsuite/gcc.dg/guality/pr54970.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr54970.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr54970.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr54970.c?ref=b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "patch": "@@ -8,17 +8,17 @@\n int\n main ()\n {\n-  int a[] = { 1, 2, 3 };\t/* { dg-final { gdb-test .+4 \"a\\[0\\]\" \"1\" } } */\n+  int a[] = { 1, 2, 3 };\t/* { dg-final { gdb-test .+4 \"a\\[0\\]\" \"1\" { xfail { *-*-* } } } } */\n   int *p = a + 2;\t\t/* { dg-final { gdb-test .+3 \"a\\[1\\]\" \"2\" } } */\n   int *q = a + 1;\t\t/* { dg-final { gdb-test .+2 \"a\\[2\\]\" \"3\" } } */\n \t\t\t\t/* { dg-final { gdb-test .+1 \"*p\" \"3\" } } */\n   asm volatile (NOP);\t\t/* { dg-final { gdb-test . \"*q\" \"2\" } } */\n-  *p += 10;\t\t\t/* { dg-final { gdb-test .+4 \"a\\[0\\]\" \"1\" } } */\n+  *p += 10;\t\t\t/* { dg-final { gdb-test .+4 \"a\\[0\\]\" \"1\" { xfail { *-*-* } } } } */\n \t\t\t\t/* { dg-final { gdb-test .+3 \"a\\[1\\]\" \"2\" } } */\n \t\t\t\t/* { dg-final { gdb-test .+2 \"a\\[2\\]\" \"13\" } } */\n \t\t\t\t/* { dg-final { gdb-test .+1 \"*p\" \"13\" } } */\n   asm volatile (NOP);\t\t/* { dg-final { gdb-test . \"*q\" \"2\" } } */\n-  *q += 10;\t\t\t/* { dg-final { gdb-test .+4 \"a\\[0\\]\" \"1\" } } */\n+  *q += 10;\t\t\t/* { dg-final { gdb-test .+4 \"a\\[0\\]\" \"1\" { xfail { *-*-* } } } } */\n \t\t\t\t/* { dg-final { gdb-test .+3 \"a\\[1\\]\" \"12\" } } */\n \t\t\t\t/* { dg-final { gdb-test .+2 \"a\\[2\\]\" \"13\" } } */\n \t\t\t\t/* { dg-final { gdb-test .+1 \"*p\" \"13\" } } */"}, {"sha": "ca3858d5fc71a03587aaba806423ab88a0b30a39", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496651b7d281bd1bf22688f4de0cbb78c1bf8e5/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=b496651b7d281bd1bf22688f4de0cbb78c1bf8e5", "patch": "@@ -1150,29 +1150,36 @@ contains_view_convert_expr_p (const_tree ref)\n   return false;\n }\n \n-/* Return true if REF contains a VIEW_CONVERT_EXPR or a MEM_REF that performs\n-   type conversion or a COMPONENT_REF with a bit-field field declaration.  */\n+/* Return true if REF contains a VIEW_CONVERT_EXPR or a COMPONENT_REF with a\n+   bit-field field declaration.  If TYPE_CHANGING_P is non-NULL, set the bool\n+   it points to will be set if REF contains any of the above or a MEM_REF\n+   expression that effectively performs type conversion.  */\n \n static bool\n-contains_vce_or_bfcref_p (const_tree ref)\n+contains_vce_or_bfcref_p (const_tree ref, bool *type_changing_p = NULL)\n {\n   while (handled_component_p (ref))\n     {\n       if (TREE_CODE (ref) == VIEW_CONVERT_EXPR\n \t  || (TREE_CODE (ref) == COMPONENT_REF\n \t      && DECL_BIT_FIELD (TREE_OPERAND (ref, 1))))\n-\treturn true;\n+\t{\n+\t  if (type_changing_p)\n+\t    *type_changing_p = true;\n+\t  return true;\n+\t}\n       ref = TREE_OPERAND (ref, 0);\n     }\n \n-  if (TREE_CODE (ref) != MEM_REF\n+  if (!type_changing_p\n+      || TREE_CODE (ref) != MEM_REF\n       || TREE_CODE (TREE_OPERAND (ref, 0)) != ADDR_EXPR)\n     return false;\n \n   tree mem = TREE_OPERAND (TREE_OPERAND (ref, 0), 0);\n   if (TYPE_MAIN_VARIANT (TREE_TYPE (ref))\n       != TYPE_MAIN_VARIANT (TREE_TYPE (mem)))\n-    return true;\n+    *type_changing_p = true;\n \n   return false;\n }\n@@ -1368,15 +1375,26 @@ build_accesses_from_assign (gimple *stmt)\n       lacc->grp_assignment_write = 1;\n       if (storage_order_barrier_p (rhs))\n \tlacc->grp_unscalarizable_region = 1;\n+\n+      if (should_scalarize_away_bitmap && !is_gimple_reg_type (lacc->type))\n+\t{\n+\t  bool type_changing_p = false;\n+\t  contains_vce_or_bfcref_p (lhs, &type_changing_p);\n+\t  if (type_changing_p)\n+\t    bitmap_set_bit (cannot_scalarize_away_bitmap,\n+\t\t\t    DECL_UID (lacc->base));\n+\t}\n     }\n \n   if (racc)\n     {\n       racc->grp_assignment_read = 1;\n-      if (should_scalarize_away_bitmap && !gimple_has_volatile_ops (stmt)\n-\t  && !is_gimple_reg_type (racc->type))\n+      if (should_scalarize_away_bitmap && !is_gimple_reg_type (racc->type))\n \t{\n-\t  if (contains_vce_or_bfcref_p (rhs))\n+\t  bool type_changing_p = false;\n+\t  contains_vce_or_bfcref_p (rhs, &type_changing_p);\n+\n+\t  if (type_changing_p || gimple_has_volatile_ops (stmt))\n \t    bitmap_set_bit (cannot_scalarize_away_bitmap,\n \t\t\t    DECL_UID (racc->base));\n \t  else"}]}