{"sha": "80ec8b4cf19ac985c95e2a222d84e48324cb8994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBlYzhiNGNmMTlhYzk4NWM5NWUyYTIyMmQ4NGU0ODMyNGNiODk5NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-04-02T08:16:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-04-02T08:16:29Z"}, "message": "decl.c (gnat_to_gnu_entity): Defer finalizing types when updating the pointers to the designated type.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Defer\n\tfinalizing types when updating the pointers to the designated type.\n\t<all>: Finalize the deferred types even if we didn't defer processing\n\tof incomplete types in this invocation.\n\nFrom-SVN: r171879", "tree": {"sha": "009d51ccbabac0f0231c1ffd9e32674bb45832b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/009d51ccbabac0f0231c1ffd9e32674bb45832b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80ec8b4cf19ac985c95e2a222d84e48324cb8994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec8b4cf19ac985c95e2a222d84e48324cb8994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ec8b4cf19ac985c95e2a222d84e48324cb8994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec8b4cf19ac985c95e2a222d84e48324cb8994/comments", "author": null, "committer": null, "parents": [{"sha": "bb0ce33a0e35c7781d72dc59cc9dcadd3f550841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb0ce33a0e35c7781d72dc59cc9dcadd3f550841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb0ce33a0e35c7781d72dc59cc9dcadd3f550841"}], "stats": {"total": 102, "additions": 55, "deletions": 47}, "files": [{"sha": "e4928c4b4bbc34ae98cc8be1465c936b3b639928", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec8b4cf19ac985c95e2a222d84e48324cb8994/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec8b4cf19ac985c95e2a222d84e48324cb8994/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=80ec8b4cf19ac985c95e2a222d84e48324cb8994", "patch": "@@ -1,3 +1,10 @@\n+2011-04-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Defer\n+\tfinalizing types when updating the pointers to the designated type.\n+\t<all>: Finalize the deferred types even if we didn't defer processing\n+\tof incomplete types in this invocation.\n+\n 2011-04-01  Olivier Hainque  <hainque@adacore.com>\n             Nicolas Setton  <setton@adacore.com>\n             Eric Botcazou  <ebotcazou@adacore.com>\n@@ -8,27 +15,23 @@\n 2011-03-28  Kai Tietz  <ktietz@redhat.com>\n \n \t* gcc-interface/Makefile.in (SO_LIB): Handle multilib build for native\n-\twindows targets.\n-\t(EH_MECHANISM): Make sure we use gcc's exception mechanism for all\n-\tnative windows target.\n-\t* system-mingw.ads (System): Change ZCX_By_Default default to\n-\tTrue.\n+\tWindows targets.\n+\t(EH_MECHANISM): Use GCC exception mechanism for native Windows targets.\n+\t* system-mingw.ads (System): Change ZCX_By_Default default to True.\n \n-\t* raise-gcc.c (PERSONALITY_FUNCTION): Add prototype to\n-\tprevent warning.\n+\t* raise-gcc.c (PERSONALITY_FUNCTION): Add prototype.\n \n 2011-03-28  Tristan Gingold  <gingold@adacore.com>\n \n \tPR ada/44431\n-\t* gcc-interface/Make-lang.in (ada/b_gnat1.adb):  Replaces\n-\tada/b_gnat1.c. Use ada output of gnatbind.\n+\t* gcc-interface/Make-lang.in (ada/b_gnat1.adb): Replace ada/b_gnat1.c.\n+\tUse ada output of gnatbind.\n \t(ada/b_gnatb.adb): Ditto.\n \t(ada/b_gnat1.o, ada/b_gnatb.o): New rules.\n \t(ada.mostlyclean, ada.stage1)\n \t(ada.stage2, ada.stage3, ada.stage4, ada.stageprofile)\n \t(ada.stagefeedback): Adjust.\n-\n-\t* gcc-interface/Makefile.in (b_gnatl.adb): Replaces b_gnatl.c\n+\t* gcc-interface/Makefile.in (b_gnatl.adb): Replace b_gnatl.c.\n \tUse ada output of gnatbind.\n \t(b_gnatm.adb): Ditto.\n \t(b_gnatl.o, b_gnatm.o): New rules."}, {"sha": "1afa06c7ade26710b65113f9274f2f910b1dc560", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec8b4cf19ac985c95e2a222d84e48324cb8994/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec8b4cf19ac985c95e2a222d84e48324cb8994/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=80ec8b4cf19ac985c95e2a222d84e48324cb8994", "patch": "@@ -3769,8 +3769,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       along the way.  update_pointer_to is expected to properly take\n \t       care of those situations.  */\n \t    if (defer_incomplete_level == 0 && !is_from_limited_with)\n-\t      update_pointer_to (TYPE_MAIN_VARIANT (gnu_old_desig_type),\n-\t\t\t\t gnat_to_gnu_type (gnat_desig_equiv));\n+\t      {\n+\t\tdefer_finalize_level++;\n+\t\tupdate_pointer_to (TYPE_MAIN_VARIANT (gnu_old_desig_type),\n+\t\t\t\t   gnat_to_gnu_type (gnat_desig_equiv));\n+\t\tdefer_finalize_level--;\n+\t      }\n \t    else\n \t      {\n \t\tstruct incomplete *p = XNEW (struct incomplete);\n@@ -4968,49 +4972,50 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     }\n \n   /* If we deferred processing of incomplete types, re-enable it.  If there\n-     were no other disables and we have some to process, do so.  */\n-  if (this_deferred && --defer_incomplete_level == 0)\n+     were no other disables and we have deferred types to process, do so.  */\n+  if (this_deferred\n+      && --defer_incomplete_level == 0\n+      && defer_incomplete_list)\n     {\n-      if (defer_incomplete_list)\n-\t{\n-\t  struct incomplete *p, *next;\n+      struct incomplete *p, *next;\n \n-\t  /* We are back to level 0 for the deferring of incomplete types.\n-\t     But processing these incomplete types below may itself require\n-\t     deferring, so preserve what we have and restart from scratch.  */\n-\t  p = defer_incomplete_list;\n-\t  defer_incomplete_list = NULL;\n+      /* We are back to level 0 for the deferring of incomplete types.\n+\t But processing these incomplete types below may itself require\n+\t deferring, so preserve what we have and restart from scratch.  */\n+      p = defer_incomplete_list;\n+      defer_incomplete_list = NULL;\n \n-\t  /* For finalization, however, all types must be complete so we\n-\t     cannot do the same because deferred incomplete types may end up\n-\t     referencing each other.  Process them all recursively first.  */\n-\t  defer_finalize_level++;\n+      /* For finalization, however, all types must be complete so we\n+\t cannot do the same because deferred incomplete types may end up\n+\t referencing each other.  Process them all recursively first.  */\n+      defer_finalize_level++;\n \n-\t  for (; p; p = next)\n-\t    {\n-\t      next = p->next;\n-\n-\t      if (p->old_type)\n-\t\tupdate_pointer_to (TYPE_MAIN_VARIANT (p->old_type),\n-\t\t\t\t   gnat_to_gnu_type (p->full_type));\n-\t      free (p);\n-\t    }\n+      for (; p; p = next)\n+\t{\n+\t  next = p->next;\n \n-\t  defer_finalize_level--;\n+\t  if (p->old_type)\n+\t    update_pointer_to (TYPE_MAIN_VARIANT (p->old_type),\n+\t\t\t       gnat_to_gnu_type (p->full_type));\n+\t  free (p);\n \t}\n \n-      /* All the deferred incomplete types have been processed so we can\n-\t now proceed with the finalization of the deferred types.  */\n-      if (defer_finalize_level == 0 && defer_finalize_list)\n-\t{\n-\t  unsigned int i;\n-\t  tree t;\n+      defer_finalize_level--;\n+    }\n \n-\t  FOR_EACH_VEC_ELT (tree, defer_finalize_list, i, t)\n-\t    rest_of_type_decl_compilation_no_defer (t);\n+  /* If all the deferred incomplete types have been processed, we can proceed\n+     with the finalization of the deferred types.  */\n+  if (defer_incomplete_level == 0\n+      && defer_finalize_level == 0\n+      && defer_finalize_list)\n+    {\n+      unsigned int i;\n+      tree t;\n \n-\t  VEC_free (tree, heap, defer_finalize_list);\n-\t}\n+      FOR_EACH_VEC_ELT (tree, defer_finalize_list, i, t)\n+\trest_of_type_decl_compilation_no_defer (t);\n+\n+      VEC_free (tree, heap, defer_finalize_list);\n     }\n \n   /* If we are not defining this type, see if it's on one of the lists of"}]}