{"sha": "d5b7b3ae33022fb55255375d3ec9745217d95c96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDViN2IzYWUzMzAyMmZiNTUyNTUzNzVkM2VjOTc0NTIxN2Q5NWM5Ng==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2000-04-08T14:29:53Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-04-08T14:29:53Z"}, "message": "Merge changes from merged-arm-thumb-backend-branch onto trunk.\n\nFrom-SVN: r33028", "tree": {"sha": "afad7b23cc154d59312c2bb26dc3d4b1e0f165a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afad7b23cc154d59312c2bb26dc3d4b1e0f165a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5b7b3ae33022fb55255375d3ec9745217d95c96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b7b3ae33022fb55255375d3ec9745217d95c96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b7b3ae33022fb55255375d3ec9745217d95c96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b7b3ae33022fb55255375d3ec9745217d95c96/comments", "author": null, "committer": null, "parents": [{"sha": "002e89d374d492d212bab58c9efacc2e6a480d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002e89d374d492d212bab58c9efacc2e6a480d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002e89d374d492d212bab58c9efacc2e6a480d60"}], "stats": {"total": 17405, "additions": 8469, "deletions": 8936}, "files": [{"sha": "4bf2d76ed19e157a6ea5964af0a7dd719b4ed9ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,3 +1,400 @@\n+2000-04-08  Richard Earnshaw (rearnsha@arm.com)\n+\n+\tMerge changes from merged-arm-thumb-backend-branch onto trunk.\n+\n+\t2000-04-08  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* Merge trunk code from tag merged-arm-thumb-backend-merge_20000408\n+\tinto branch.\n+\n+\t* arm.md (nop): Use the standard RTL expression.  Don't code as a\n+\tdefine_expand.\n+\t(*arm_nop, *thumb_nop): Delete.\n+\n+\t* arm.c (const_ok_for_arm): Don't use ANSI extensions for defining\n+\tconstants.  Use casts instead.\n+\t(arm_gen_constant, arm_rtx_costs, arm_reload_in_hi, arm_reload_out_hi,\n+\toutput_multi_immediate, arm_poke_function_name): Likewise.\n+\t* arm.h (ARM_LEGITIIMIZE_RELOAD_ADDRESS, ARM_SIGN_EXTEND,\n+\tMASK_RETURN_ADDDR): Likewise.\n+\n+\t2000-03-31  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* Merge trunk code from tag merged-arm-thumb-backend-merge_20000325 \n+\tinto branch.\n+\t\n+\t* arm.md (eh_epilogue): New function.\n+\t* arm.h (struct machine_function): Move to here ...\n+\t* arm.c: ... from here.\n+\t(arm_output_epilogue): Support epilogues for __builtin_eh_return.\n+\t(thumb_exit): Extra parameter eh_ofs.  All callers changed.\n+\tHandle epilogues for __builtin_eh_return.  Make bit-fields unsigned.\n+\n+\t2000-03-30  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/semi.h (ASM_SPEC): Restore definition.\n+\t(SUBTARGET_EXTRA_ASM_SPEC): Define if not already defined.\n+\n+\t* config/arm/elf.h (ASM_SPEC): Restore definition.\n+\t(SUBTARGET_EXTRA_ASM_SPEC): Define if not already defined.\n+\n+\t* config/arm/arm.h (ASM_SPEC): Remove definition.\n+\t(SUBTARGET_EXTRA_ASM_SPEC): Remove definition.\n+\n+\t2000-03-26  Bernd Schmidt <bernds@cygnus.co.uk>\n+\n+\t* config/arm/arm.c: Disable -fschedule-insns for Thumb.\n+\n+\t2000-03-24  Nick Clifton  <nickc@cygnus.com>\n+\n+\tVarious formating tidyups, elimination of compile time\n+\twarnings and synchronisation with internal sources:\n+\t\n+\t* config/arm/arm-protos.h (assemble_align): Add prototype.\n+\t(gen_rotated_half_load): Rename to arm_gen_rotated_half_load.\n+\t(gen_comapre_reg): Rename to arm_gen_compare_reg.\n+\t(arm_return_addr_rtx): Rename to arm_return_addr.\n+\n+\t* config/arm/arm.c: Include except.h.\n+\tDefine shorter typenames for strict minipool_node and struct\n+\tminipool_fix.\n+\t(arm_return_in_memory): For WinCE return all structures <= 32 bits\n+\tin memory.\n+\t(gen_rotated_half_load): Rename to arm_gen_rotated_half_load.\n+\t(gen_comapre_reg): Rename to arm_gen_compare_reg.\n+\n+\t* config/arm/arm.h (SUBTARGET_EXTRA_ASM_SPEC): Define if not\n+\talready defined.\n+\t(ASM_SPEC): Define if not already defined.\n+\t(ASM_OUTPUT_DEF_FROM_DECLS): Define.\n+\n+\t* config/arm/arm.md: Rename references to gen_rotated_half_load to\n+\tarm_gen_rotated_half_load, and references to gen_comapre_reg to\n+\tarm_gen_compare_reg.\n+\t(indirect_jump):  Only accept register operands.\n+\t(load_indirect_jump): Keep this pattern since combine can generate\n+\tit.\n+\n+\t* config/arm/coff.h: Include aout.h.\n+\t(MULTILIB_DEFAULTS): Only define if not already defined.\n+\n+\t* config/arm/elf.h (ASM_OUTPUT_DEF_FROM_DECLS): Move definition\n+\tinto arm.h (so that COFF ports can support thumb based aliases).\n+\t(ASM_SPEC): Move definition into arm.h\n+\t\n+\t* config/arm/linux-elf.h (SUBTARGET_EXTRA_ASM_SPEC): Remove\n+\tredundant apcs spec.\n+\t(ASM_SPEC): Move definition to arm.h\n+\n+\t* config/arm/semi.h (ASM_SPEC): Move definition to arm.h\n+\n+\t* config/arm/unknown-elf.h (ASM_OUTPUT_SECTION_NAME): Add support\n+\tfor entries in the .bss section\n+\n+\t2000-03-23  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.h (THUMB_INITIAL_ELIMINATION_OFFSET): Pass 0\n+\tto thumb_far_jump_used_p.\n+\n+\t* config/arm/arm-protos.h (thumb_far_jump_used_p): Take a\n+\tsingle integer parameter.\n+\n+\t* config/arm/arm.c (struct machine_function): Add two new\n+\tfields, 'far_jump_used' and 'arg_pointer_live'.\n+\t(thumb_far_jump_used_p): Once the decision has been made that\n+\tfar jumps might be used, always return true.\n+\tIf being called from the initial elimination offset macro then\n+\tdo not bother to perform the test if the arg pointer is not\n+\tbeing used.\n+\t(thumb_unexpand_epilogue): Pass 1 to thumb_far_jump_used_p().\n+\t(output_thumb_prologue): Pass 1 to thumb_far_jump_used_p().\n+\n+\t2000-03-23  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.c (output_return_instruction): Handle more cases where we can\n+\treturn from a function with an ldr instruction.\n+\t(arm_output_epilogue): Likewise.\n+\n+\t* arm.c (thumb_expand_prologue): Don't clobber the frame pointer\n+\tif we need to push a large stack frame and there are no callee-saved\n+\tregisters.\n+\n+\t* arm.c (arm_debugger_arg_offset): An offset of 0 is also valid\n+\tin ARM code if the frame pointer has been eliminated.\n+\n+\t* arm.md (epilogue, *epilogue_insns, consttable_*, align_4): Renumber\n+\tunspec_volatile arguments to avoid duplicates.\n+\t(consttable_1, consttable_2): Fixes for big-endian mode.\n+\n+\t* arm.md (all ARM-mode load insns): Add neg_pool_range attribute\n+\tas appropriate.\n+\n+\tRe-write constant pool code.\n+\t* arm.c (minipool_node, minipool_fix): New types.\n+\t(minifix): Delete type.\n+\t(arm_add_minipool_constant): Delete.\n+\t(arm_compute_minipool_offsets, arm_find_barrier, \n+\tarm_find_minipool_constant, fixup_compare, sort_fixups): Likewise.\n+\t(get_jump_table_size): Now returns HOST_WIDE_INT.\n+\t(move_minipool_fix_forward_ref, add_minipool_forward_ref): New\n+\tfunctions.\n+\t(move_minipool_fix_backward_ref, add_minipool_backward_ref): Likewise.\n+\t(assign_minipool_offsets, arm_print_value): Likewise.\n+\t(dump_minipool): Rewrite.\n+\t(arm_barrier_cost): New function.\n+\t(create_fix_barrier): New function.\n+\t(push_minipool_barrier): New function.\n+\t(push_minipool_fix): Record additional information about the fixup \n+\trequired.\n+\t(note_invalid_constants): Remove push for (UNSPEC 3).  Don't\n+\tcheck the mode of what needs fixing.\n+\t(arm_reorg): Rewrite.\n+\n+\t2000-03-08  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.md (indirect_jump): Force constant addresses into\n+\ta register. \n+\n+\t2000-03-01  Bernd Schmidt <bernds@cygnus.co.uk>\n+\n+\t* config/arm/arm.md: Add splitter to turn SF moves into SI moves.\n+\n+\t2000-02-24  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.c (thumb_expand_prologue): Make sure that stack\n+\tadjust is word aligned.\n+\t(thumb_expand_epilogue): Make sure that stack adjust is word\n+\taligned.\n+\n+\t* config/arm/elf.h (ASM_FILE_START): Fix type of version string.\n+\t\n+\t2000-02-24  Bernd Schmidt <bernds@cygnus.com>\n+\n+\t* config/arm/arm.h (THUMB_GO_IF_LEGITIMATE_ADDRESS): Allow frame\n+\tpointer relative addresses.\n+\n+\t2000-02-10  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (find_barrier): Find the last barrier within the allowed \n+\trange.\n+\n+\t2000-02-09  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm-protos.h: Replace PROTO with PARAMS.\n+\n+\t2000-02-09  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/linux-elf.h (FUNCTION_PROFILER): Rename to\n+\tARM_FUNCTION_PROFILER. \n+\n+\t* config/arm/netbsd.h (FUNCTION_PROFILER): Rename to\n+\tARM_FUNCTION_PROFILER. \n+\n+\t* config/arm/linux-oldld.h: Imported from mainline sources.\n+\n+\t2000-02-07  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/lib1funcs.asm: Merge in thumb functions from\n+\tlib1thumb.asm.\n+\t\n+\t* config/arm/lib1thumb.asm: Delete.\n+\n+\t2000-02-04  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.c: Sychronised with current Red hat local\n+\tsources. \n+\t* config/arm/arm.h: Ditto.\n+\t* config/arm/arm-protos.h: Ditto.\n+\n+\t2000-02-02  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* arm.c (soft_df_operand): Reject SUBREGs containing a constant.\n+\n+\t* arm.c (arm_gen_movstrqi): Generate halfword stores rather than two\n+\tbyte stores.\n+\n+\t2000-02-02  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/thumb.c (thumb_exit): Additional fix for same bug.\n+\n+\t* config/arm/arm.md (epilogue): Fix rtl checking abort because\n+\t(return) was emited using an emit_insn() call. \n+\t\n+\t2000-01-31  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.c (output_thumb_prologue): Fix bug generating\n+\tthumb stack frame.\n+\t(thumb_exit): Move frame pointer back into hard frame pointer\n+\tregister if backtracing is being used.\n+\n+\t2000-01-13  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* Merge trunk code from tag merged-arm-thumb-backend-merge_20000113 \n+\tinto branch.\n+\n+\t1999-12-15  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* config/arm/arm.md (neg_pool_offset): Provide default for new\n+\tattribute.\n+\t(arm_movsi_insn): Add neg_pool_offset attribute.\n+\t* config/arm/arm.c (arm_find_barrier): Replace arg FIX with an\n+\trtx for the insn that starts the scan and an unsigned long for its\n+\taddress.  Add MIN_OFFSET and PINSERTED args.  All callers changed.\n+\tChange scan to ignore insns before MIN_OFFSET.  Store size of inserted\n+\tinstructions in *PINSERTED.\n+\t(struct minipool_fixup): Add MIN_ADDRESS elt.\n+\t(sort_fixups): Compute it.\n+\t(arm_reorg): Changes to support inserting pools before the insn to be\n+\tfixed up.\n+\n+\t1999-12-08  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* config/arm/elf.h (MULTILIB_DEFAULTS): Add \"marm\".\n+\t* config/arm/linux-elf.h (MULTILIB_DEFAULTS): Add \"marm\".\n+\t* config/arm/coff.h (MULTILIB_DEFAULTS): Add \"marm\".\n+\n+\tWed Nov  3 10:04:07 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/semi.h (TARGET_VERSION): Do not define if already\n+\tdefined.\n+\t(TARGET_DEFAULT): Do not define if already defined.\n+\n+\tTue Nov  2 10:37:25 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.md (anddi3): Allow disjoint source operands.\n+\t(iordi3): Allow disjoint source operands.\n+\t(xordi3): Allow disjoint source operands.\n+\t(negdi2): Permit construction for ARM and Thumb.\n+\t(arm_negdi2): Renamed version of old negdi2 pattern.\n+\t(thumb_negdi2): New pattern: Only permit non-overlapping\n+\tsource and destination.\n+\n+\tFri Oct 29 18:52:38 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.c (thumb_expand_prologue): Emit a USE of the\n+\tscratch low register so that it will not be deleted.\n+\n+\tFri Oct 29 15:23:48 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/pe.h (ARM_PE): Define.\n+\t\n+\t* config/arm/arm.c (arm_valid_machine_decl_attribute): Allow\n+\tinterfacearm attribute if this is a PE toolchain.\n+\t(output_return_instruction): Do not emit anything if the function\n+\thas the naked attribute set.\n+\t(is_called_in_ARM_mode): If the function has the interfacearm\n+\tattribute then return true.\n+\t(thumb_expand_prologue): Do not generate a prologue for naked\n+\tfunctions.\n+\t(thumb_expand_epilogue): Do not generate an epilogie for a naked\n+\tfunction.\n+\t(output_thumb_prologue): Do not bother if the function is naked.\n+\tStrip PE encoding from function name before emitting.\n+\n+\tThu Oct 28 11:05:13 1999  Richard Earnshaw <rearnsha@arm.com>\n+\n+\t* arm.md (pic_load_addr): Fix constraints.\n+\n+\t* arm.md (casesi_insn): Fix mis-applied patch.\n+\n+\t* arm.md (\"core\" function unit): Add rules for single- and\n+\tmulti-cycle insns.\n+\t(All TARGET_THUMB patterns): Add \"type\" attribute information\n+\twhere needed.\n+\t* arm.c (arm_adjust_cost): Reduce the cost of a data dependency if\n+\tthe following insn is a CALL.\n+\n+\t* arm.c (thumb_expand_epilogue): Add a use of the adjusted stack\n+\tpointer.\n+\t* arm.h (CONDITIONAL_REGISTER_USAGE): Nail down the \n+\tARM_HARD_FRAME_POINTER_REGNUM when TARGET_APCS_FRAME.\n+\t(FRAME_POINTER_REQUIRED): Only check TARGET_APCS_FRAME if TARGET_ARM.\n+\t\n+\tWed Oct 27 14:40:48 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/linux-gas.h: oops - this file was missed out when the\n+\tbranch was created...\n+\n+\tTue Oct 26 17:07:38 1999  Richard Earnshaw <rearnsha@arm.com>\n+\n+\t* thumb.c: Deleted.  Move contents to ...\n+\t* arm.c: ... here.\n+\t* t-arm-aout, t-arm-coff, t-arm-elf, t-linux, t-netbsd, t-semi: Remove\n+\trule for thumb.o\n+\t* configure.in (arm*-*-*): Remove thumb.o from extra_objs list.\n+\t* configure: Regen.\n+\n+\t* arm-protos.h: Use RTX_CODE and tidy up long lines.  Don't\n+\tdeclare a prototype for asm_output_align();\n+\n+\t* arm.c (thumb_condition_code): Delete.\n+\t(arm_print_operand): Always use arm_condition_code array.\n+\n+\t* arm.c (thumb_return_addr_rtx): Delete.\n+\t(arm_save_machine_status, arm_restore_machine_status): Delete.\n+\t(arm_init_machine_status, arm_mark_machine_status): New functions.\n+\t(arm_init_expanders): Update accordingly.\n+\t(arm_return_addr): Renamed from arm_return_addr_rtx.  Rewrite.\n+\t(thumb_expand_prologue): Delete code referencing thumb_return_addr_rtx.\n+\t* arm.h (RETURN_ADDR_RTX): Call arm_return_addr().\n+\t\n+\tTue Oct 26 13:24:16 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* configure.in : Fix arm-*-aout target to use new t-arm-aout\n+\tscript. \n+\t* config/arm/t-arm-aout: New file: Makefile script for arm-*-aout\n+\ttargets.\n+\n+\tTue Oct 26 11:27:12 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/thumb.c (output_thumb_prologue): Fix bug creating\n+\tstack backtrace structure.\n+\n+\t* config/arm/arm-protos.h: Add prototypes for functions defined in\n+\tarm/pe.h.\n+\t\n+\t* config/arm/arm.c (arm_override_options): Fix selection of \n+\tattributes of default processor.\n+\t\n+\t* config/arm/coff.h: Delete needless #include.\n+\t\n+\t* config/arm/pe.c: Delete unused code.\n+\t\n+\t* config/arm/pe.h (CPP_DEFINES): Delete\n+\t(SUBTARGET_CPP_SPEC): Define.\n+\t(ASM_DECLARE_FUNCTION_NAME): Use ARM_DECLARE_FUNCTION_NAME.\n+\t\n+\t* config/arm/t-pe: Add -DInhibit_libc to allof libgcc.a to build.\n+\n+\tMon Oct 25 15:42:09 1999  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.h (TARGET_APCS_FRAME): Renamed from TARGET_APCS -- all uses\n+\tupdated.\n+\t(CAN_DEBUG_WITHOUT_FP): Define.\n+\t(FIXED_REGISTERS): Make r11 call-saved.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(CONDITIONAL_REGISTER_USAGE): Fix r11 if TARGET_APCS_FRAME.\n+\t(FRAME_POINTER_REQUIRED): Correct logic for determining when a \n+\tframe-pointer is required.\n+\t(TARGET_DEFAULT): Make default setting include ARM_FLAG_APCS_FRAME.\n+\t* arm.c (arm_override_options): Warn about -mno-apcs-frame and -g\n+\tif the target normally needs a stack frame in non-leaf functions.\n+\t(use_return_insn): Correct logic for determining when a return\n+\tinstruction can be used.\n+\t(output_return_instruction): Handle the frame-pointer register as\n+\ta normal register when not TARGET_APCS_FRAME.\n+\t(arm_output_prologue): Likewise.\n+\t(arm_output_epilogue): Likewise.\n+\t(output_func_epilogue): Likewise.\n+\t(arm_expand_prologue): Likewise.\n+\t* netbsd.h semi.h (TARGET_DEFAULT): Add ARM_FLAG_APCS_FRAME.\n+\n+\t* arm.c (use_return_insn): No need to check floating point regs if\n+\tTARGET_SOFT_FLOAT.\n+\t(arm_find_minipool_constant): Correct typo; use GET_CODE to get\n+\tthe code of value stored in the minipool array.\n+\t(arm_add_minipool_constant): Likewise.\n+\n 2000-04-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* basic-block.h (conflict_graph_enum_fn): K&R fix."}, {"sha": "9dc1a041b2c748a03306ca38b2b0fc2ed8aeafe6", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for ARM with a.out\n-   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1995 - 1999 Free Software Foundation, Inc.\n    Contributed by Richard Earnshaw (rearnsha@armltd.co.uk).\n    \n This file is part of GNU CC.\n@@ -25,20 +25,24 @@ Boston, MA 02111-1307, USA.  */\n \n /* The text to go at the start of the assembler file */\n #ifndef ASM_FILE_START\n-#define ASM_FILE_START(STREAM)\t\t\t\t\t\t    \\\n-{\t\t\t\t\t\t\t\t\t    \\\n-  fprintf (STREAM,\"%srfp\\t.req\\t%sr9\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%ssl\\t.req\\t%sr10\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%sfp\\t.req\\t%sr11\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%sip\\t.req\\t%sr12\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%ssp\\t.req\\t%sr13\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%slr\\t.req\\t%sr14\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%spc\\t.req\\t%sr15\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+#define ASM_FILE_START(STREAM)\t\t    \\\n+{\t\t\t\t\t    \\\n+  asm_fprintf (STREAM,\"%Rrfp\\t.req\\t%Rr9\\n\"); \\\n+  asm_fprintf (STREAM,\"%Rsl\\t.req\\t%Rr10\\n\"); \\\n+  asm_fprintf (STREAM,\"%Rfp\\t.req\\t%Rr11\\n\"); \\\n+  asm_fprintf (STREAM,\"%Rip\\t.req\\t%Rr12\\n\"); \\\n+  asm_fprintf (STREAM,\"%Rsp\\t.req\\t%Rr13\\n\"); \\\n+  asm_fprintf (STREAM,\"%Rlr\\t.req\\t%Rr14\\n\"); \\\n+  asm_fprintf (STREAM,\"%Rpc\\t.req\\t%Rr15\\n\"); \\\n }\n #endif\n \n-#define ASM_APP_ON  \t\t\" \"\n-#define ASM_APP_OFF  \t\t\" \"\n+#ifndef ASM_APP_ON\n+#define ASM_APP_ON  \t\t\"\"\n+#endif\n+#ifndef ASM_APP_OFF\n+#define ASM_APP_OFF  \t\t\"\"\n+#endif\n \n /* Switch to the text or data segment.  */\n #define TEXT_SECTION_ASM_OP  \t\".text\"\n@@ -68,7 +72,7 @@ Boston, MA 02111-1307, USA.  */\n   \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n   \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n   \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n-  \"cc\", \"sfp\", \"afp\"\t\t\t\t   \\\n+  \"cc\", \"sfp\", \"afp\"\t\t   \t\t   \\\n }\n #endif\n \n@@ -185,16 +189,17 @@ Boston, MA 02111-1307, USA.  */\n    the riscix assembler doesn't understand (it also makes cross-assembling\n    less likely to fail). */\n \n-#define ASM_OUTPUT_LONG_DOUBLE(STREAM, VALUE)\t\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\t\\\n-      char dstr[30];\t\t\t\t\t\t\t\t\\\n-      long l[3];\t\t\t\t\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\t\\\n-      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\",\t\\\n-\t       l[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_LONG_DOUBLE(STREAM, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\t\t\\\n+      long l[3];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+      asm_fprintf (STREAM,\t\t\t\t\t\t\\\n+\t\t   \"\\t.long 0x%lx,0x%lx,0x%lx\\t%@ long double %s\\n\",\t\\\n+\t\t   l[0], l[1], l[2], dstr);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n #define ASM_OUTPUT_DOUBLE(STREAM, VALUE)\t\t\t\t\\\n@@ -204,8 +209,8 @@ Boston, MA 02111-1307, USA.  */\n       long l[2];\t\t\t\t\t\t\t\\\n       REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n       REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n-      fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n-\t       l[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n+      asm_fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%@ double %s\\n\", l[0],\\\n+\t           l[1], dstr);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -216,8 +221,8 @@ Boston, MA 02111-1307, USA.  */\n       long l;\t\t\t\t\t\t\t\\\n       REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\\\n       REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\\\n-      fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\\\n-\t       ASM_COMMENT_START, dstr);\t\t\t\\\n+      asm_fprintf (STREAM, \"\\t.word 0x%lx\\t%@ float %s\\n\", l,\t\\\n+\t           dstr);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -280,8 +285,8 @@ Boston, MA 02111-1307, USA.  */\n     {\t\t\t\t\t\t\t\\\n       fprintf (STREAM, \"\\t.comm\\t\");\t\t\t\\\n       assemble_name (STREAM, NAME);\t\t\t\\\n-      fprintf (STREAM, \", %d\\t%s %d\\n\", ROUNDED,\t\\\n-\t       ASM_COMMENT_START, SIZE);\t\t\\\n+      asm_fprintf (STREAM, \", %d\\t%@ %d\\n\", \t\t\\\n+\t           ROUNDED, SIZE);\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n #endif\n@@ -314,7 +319,7 @@ Boston, MA 02111-1307, USA.  */\n /* Output a #ident directive.  */\n #ifndef ASM_OUTPUT_IDENT\n #define ASM_OUTPUT_IDENT(STREAM,STRING)  \\\n-  fprintf (STREAM, \"%s - - - ident %s\\n\", ASM_COMMENT_START, STRING)\n+  asm_fprintf (STREAM, \"%@ - - - ident %s\\n\", STRING)\n #endif\n      \n /* The assembler's parentheses characters.  */\n@@ -328,4 +333,4 @@ Boston, MA 02111-1307, USA.  */\n /* This works for GAS and some other assemblers.  */\n #define SET_ASM_OP\t\t\".set\"\n \n-#include \"arm/arm.h\"\n+#include \"arm.h\""}, {"sha": "5b021248b3951be2919d20824d6020751b277751", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 158, "deletions": 124, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -20,142 +20,176 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern void   arm_expand_prologue\t\tPARAMS ((void));\n-extern void   arm_finalize_pic \t\t\tPARAMS ((void));\n-extern char * arm_output_epilogue\t\tPARAMS ((void));\n-extern void   arm_override_options \t\tPARAMS ((void));\n-extern void   arm_poke_function_name \t\tPARAMS ((FILE *, char *));\n-extern int    arm_process_pragma\t\tPARAMS ((int (*)(void), void (*) (int), char *));\n-extern int    arm_regno_class \t\t\tPARAMS ((int));\n-extern int    arm_volatile_func\t\t\tPARAMS ((void));\n-extern int    const_ok_for_arm\t\t\tPARAMS ((HOST_WIDE_INT));\n-extern void   output_arm_prologue\t\tPARAMS ((FILE *, int));\n-extern void   output_ascii_pseudo_op\t\tPARAMS ((FILE *, const unsigned char *, int));\n-extern void   output_func_epilogue\t\tPARAMS ((int));\n-extern void   output_func_prologue\t\tPARAMS ((FILE *, int));\n-extern int    use_return_insn\t\t\tPARAMS ((int));\n+extern void   arm_override_options\tPARAMS ((void));\n+extern int    use_return_insn\t\tPARAMS ((int));\n+extern int    arm_regno_class \t\tPARAMS ((int));\n+extern int    arm_process_pragma\tPARAMS ((int (*)(void), void (*) (int),\n+\t\t\t\t\t\tchar *));\n+extern void   arm_finalize_pic\t\tPARAMS ((void));\n+extern int    arm_volatile_func\t\tPARAMS ((void));\n+extern char * arm_output_epilogue\tPARAMS ((void));\n+extern void   output_func_epilogue\tPARAMS ((int));\n+extern void   arm_expand_prologue\tPARAMS ((void));\n+/* Used in arm.md, but defined in output.c.  */\n+extern void   assemble_align\t\tPARAMS ((int)); \n extern const char * arm_strip_name_encoding\tPARAMS ((const char *));\n-#if defined AOF_ASSEMBLER \n-extern void   aof_add_import\t\t\tPARAMS ((char *));\n-extern char * aof_data_section\t\t\tPARAMS ((void));\n-extern void   aof_delete_import\t\t\tPARAMS ((char *));\n-extern void   aof_dump_imports\t\t\tPARAMS ((FILE *));\n-extern void   aof_dump_pic_table\t\tPARAMS ((FILE *));\n-extern char * aof_text_section\t\t\tPARAMS ((void));\n-#endif /* AOF_ASSEMBLER */\n-/* Defined in pe.c */\n-extern int    arm_dllexport_name_p \t\tPARAMS ((const char *));\n-extern int    arm_dllimport_name_p \t\tPARAMS ((const char *));\n-\n-#define Mmode enum machine_mode\n \n #ifdef TREE_CODE\n-extern int    arm_comp_type_attributes\t\tPARAMS ((tree, tree));\n-extern int    arm_return_in_memory\t\tPARAMS ((tree));\n+extern int    arm_return_in_memory\tPARAMS ((tree));\n extern int    arm_valid_machine_decl_attribute\tPARAMS ((tree, tree, tree));\n-extern int    arm_valid_type_attribute_p \tPARAMS ((tree, tree, tree, tree));\n-/* Defined in pe.c */\n-extern int    arm_dllexport_p \t\t\tPARAMS ((tree));\n-extern int    arm_dllimport_p \t\t\tPARAMS ((tree));\n-extern void   arm_mark_dllexport \t\tPARAMS ((tree));\n-extern void   arm_mark_dllimport \t\tPARAMS ((tree));\n-extern void   arm_pe_encode_section_info \tPARAMS ((tree));\n-extern tree   arm_pe_merge_machine_decl_attributes PARAMS ((tree, tree));\n-extern void   arm_pe_unique_section \t\tPARAMS ((tree, int));\n-extern int    arm_pe_valid_machine_decl_attribute PARAMS ((tree, tree, tree, tree));\n+extern int    arm_comp_type_attributes\tPARAMS ((tree, tree));\n+extern int    arm_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n extern void   arm_set_default_type_attributes\tPARAMS ((tree));\n-extern void   arm_encode_call_attribute\t\tPARAMS ((tree, char));\n-extern int    arm_pe_return_in_memory\t\tPARAMS ((tree));\n+extern void   arm_encode_call_attribute\tPARAMS ((tree, char));\n #endif\n-\n #ifdef RTX_CODE\n-extern int    adjacent_mem_locations\t\tPARAMS ((rtx, rtx));\n-extern char * arithmetic_instr\t\t\tPARAMS ((rtx, int));\n-extern int    arm_adjust_cost\t\t\tPARAMS ((rtx, rtx, rtx, int));\n-extern RTX_CODE arm_canonicalize_comparison \tPARAMS ((RTX_CODE, rtx *));\n-extern int    arm_debugger_arg_offset\t\tPARAMS ((int, rtx));\n-extern void   arm_final_prescan_insn\t\tPARAMS ((rtx));\n-extern rtx    arm_gen_load_multiple\t\tPARAMS ((int, int, rtx, int, int, int, int, int));\n-extern int    arm_gen_movstrqi\t\t\tPARAMS ((rtx *));\n-extern rtx    arm_gen_store_multiple\t\tPARAMS ((int, int, rtx, int, int, int, int, int));\n-extern void   arm_print_operand\t\t\tPARAMS ((FILE *, rtx, int));\n-extern void   arm_reload_in_hi\t\t\tPARAMS ((rtx *));\n-extern void   arm_reload_out_hi\t\t\tPARAMS ((rtx *));\n-extern void   arm_reorg\t\t\t\tPARAMS ((rtx));\n-extern int    arm_rtx_costs\t\t\tPARAMS ((rtx, RTX_CODE));\n-extern Mmode  arm_select_cc_mode \t\tPARAMS ((RTX_CODE, rtx, rtx));\n+extern int    const_ok_for_arm\t\tPARAMS ((HOST_WIDE_INT));\n+extern int    arm_split_constant\tPARAMS ((RTX_CODE, enum machine_mode,\n+\t\t\t\t\t\tHOST_WIDE_INT, rtx, rtx, int));\n+extern RTX_CODE arm_canonicalize_comparison PARAMS ((RTX_CODE, rtx *));\n+extern int    legitimate_pic_operand_p\tPARAMS ((rtx));\n+extern rtx    legitimize_pic_address\tPARAMS ((rtx, enum machine_mode, rtx));\n+extern int    is_pic\t\t\tPARAMS ((rtx));\n+extern int    arm_rtx_costs\t\tPARAMS ((rtx, RTX_CODE, RTX_CODE));\n+extern int    arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n extern int    const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n-extern int    const_ok_for_arm\t\t\tPARAMS ((HOST_WIDE_INT));\n-extern char * emit_ldm_seq\t\t\tPARAMS ((rtx *, int));\n-extern char * emit_stm_seq\t\t\tPARAMS ((rtx *, int));\n-extern char * fp_immediate_constant\t\tPARAMS ((rtx));\n-extern rtx    gen_compare_reg\t\t\tPARAMS ((RTX_CODE, rtx, rtx));\n-extern rtx    gen_rotated_half_load\t\tPARAMS ((rtx));\n-extern int    is_pic\t\t\t\tPARAMS ((rtx));\n-extern int    label_mentioned_p \t\tPARAMS ((rtx));\n-extern int    legitimate_pic_operand_p\t\tPARAMS ((rtx));\n-extern int    load_multiple_sequence\t\tPARAMS ((rtx *, int, int *, int *, HOST_WIDE_INT *));\n-extern RTX_CODE minmax_code\t\t\tPARAMS ((rtx));\n extern int    neg_const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n-extern char * output_add_immediate\t\tPARAMS ((rtx *));\n-extern char * output_call\t\t\tPARAMS ((rtx *));\n-extern char * output_call_mem\t\t\tPARAMS ((rtx *));\n-extern char * output_mov_double_arm_from_fpu    PARAMS ((rtx *));\n-extern char * output_mov_double_fpu_from_arm    PARAMS ((rtx *));\n-extern char * output_mov_immediate\t\tPARAMS ((rtx *));\n-extern char * output_mov_long_double_arm_from_arm PARAMS ((rtx *));\n-extern char * output_mov_long_double_arm_from_fpu PARAMS ((rtx *));\n+\n+/* Predicates.  */\n+extern int    s_register_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    f_register_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    reg_or_int_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    arm_reload_memory_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    arm_rhs_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    arm_rhsm_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    arm_add_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    arm_not_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    offsettable_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int    alignable_memory_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    bad_signed_byte_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    fpu_rhs_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    fpu_add_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    power_of_two_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    nonimmediate_di_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    di_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    nonimmediate_soft_df_operand PARAMS ((rtx, enum machine_mode));\n+extern int    soft_df_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    index_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    const_shift_operand\tPARAMS ((rtx, enum machine_mode));\n+extern int    shiftable_operator\tPARAMS ((rtx, enum machine_mode));\n+extern int    shift_operator\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    equality_operator\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    minmax_operator\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    cc_register\t\tPARAMS ((rtx, enum machine_mode));\n+extern int    dominant_cc_register\tPARAMS ((rtx, enum machine_mode));\n+extern int    logical_binary_operator\tPARAMS ((rtx, enum machine_mode));\n+extern int    multi_register_push\tPARAMS ((rtx, enum machine_mode));\n+extern int    load_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n+extern int    store_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n+\n+extern int    symbol_mentioned_p\tPARAMS ((rtx));\n+extern int    label_mentioned_p\t\tPARAMS ((rtx));\n+extern RTX_CODE minmax_code\t\tPARAMS ((rtx));\n+extern int    adjacent_mem_locations\tPARAMS ((rtx, rtx));\n+extern int    load_multiple_sequence\tPARAMS ((rtx *, int, int *, int *,\n+\t\t\t\t\t\tHOST_WIDE_INT *));\n+extern char * emit_ldm_seq\t\tPARAMS ((rtx *, int));\n+extern int    store_multiple_sequence\tPARAMS ((rtx *, int, int *, int *,\n+\t\t\t\t\t\tHOST_WIDE_INT *));\n+extern char * emit_stm_seq\t\tPARAMS ((rtx *, int));\n+extern rtx    arm_gen_load_multiple\tPARAMS ((int, int, rtx, int, int, int,\n+\t\t\t\t\t\tint, int));\n+extern rtx    arm_gen_store_multiple\tPARAMS ((int, int, rtx, int, int, int,\n+\t\t\t\t\t\tint, int));\n+extern int    arm_gen_movstrqi\t\tPARAMS ((rtx *));\n+extern rtx    arm_gen_rotated_half_load\tPARAMS ((rtx));\n+extern enum machine_mode arm_select_cc_mode PARAMS ((RTX_CODE, rtx, rtx));\n+extern rtx    arm_gen_compare_reg\tPARAMS ((RTX_CODE, rtx, rtx));\n+extern void   arm_reload_in_hi\t\tPARAMS ((rtx *));\n+extern void   arm_reload_out_hi\t\tPARAMS ((rtx *));\n+extern void   arm_reorg\t\t\tPARAMS ((rtx));\n+extern char * fp_immediate_constant\tPARAMS ((rtx));\n+extern char * output_call\t\tPARAMS ((rtx *));\n+extern char * output_call_mem\t\tPARAMS ((rtx *));\n extern char * output_mov_long_double_fpu_from_arm PARAMS ((rtx *));\n-extern char * output_move_double\t\tPARAMS ((rtx *));\n-extern char * output_return_instruction\t\tPARAMS ((rtx, int, int));\n-extern int    store_multiple_sequence\t\tPARAMS ((rtx *, int, int *, int *, HOST_WIDE_INT *));\n-extern int    symbol_mentioned_p\t\tPARAMS ((rtx));\n-extern int    arm_is_longcall_p\t\t\tPARAMS ((rtx, int, int));\n+extern char * output_mov_long_double_arm_from_fpu PARAMS ((rtx *));\n+extern char * output_mov_long_double_arm_from_arm PARAMS ((rtx *));\n+extern char * output_mov_double_fpu_from_arm      PARAMS ((rtx *));\n+extern char * output_mov_double_arm_from_fpu      PARAMS ((rtx *));\n+extern char * output_move_double\tPARAMS ((rtx *));\n+extern char * output_mov_immediate\tPARAMS ((rtx *));\n+extern char * output_add_immediate\tPARAMS ((rtx *));\n+extern char * arithmetic_instr\t\tPARAMS ((rtx, int));\n+extern void   output_ascii_pseudo_op\tPARAMS ((FILE *, const unsigned char *, int));\n+extern char * output_return_instruction\tPARAMS ((rtx, int, int));\n+extern void   arm_poke_function_name\tPARAMS ((FILE *, char *));\n+extern void   output_arm_prologue\tPARAMS ((FILE *, int));\n+extern void   arm_print_operand\t\tPARAMS ((FILE *, rtx, int));\n+extern void   arm_final_prescan_insn\tPARAMS ((rtx));\n+extern int    arm_go_if_legitimate_address PARAMS ((enum machine_mode, rtx));\n+extern int    arm_debugger_arg_offset\tPARAMS ((int, rtx));\n+extern int    arm_is_longcall_p \tPARAMS ((rtx, int, int));\n+\n+#if defined TREE_CODE\n+extern rtx    arm_function_arg\t\tPARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t\tenum machine_mode, tree, int));\n+extern void   arm_init_cumulative_args\tPARAMS ((CUMULATIVE_ARGS *, tree, rtx,\n+\t\t\t\t\t\tint));\n+#endif\n+\n #if defined AOF_ASSEMBLER \n-extern rtx    aof_pic_entry\t\t\tPARAMS ((rtx));\n+extern rtx    aof_pic_entry\t\tPARAMS ((rtx));\n+extern void   aof_dump_pic_table\tPARAMS ((FILE *));\n+extern char * aof_text_section\t\tPARAMS ((void));\n+extern char * aof_data_section\t\tPARAMS ((void));\n+extern void   aof_add_import\t\tPARAMS ((char *));\n+extern void   aof_delete_import\t\tPARAMS ((char *));\n+extern void   aof_dump_imports\t\tPARAMS ((FILE *));\n #endif /* AOF_ASSEMBLER */\n \n-#ifdef HAVE_MACHINE_MODES\n-extern int    alignable_memory_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    arm_add_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern int    arm_go_if_legitimate_address \tPARAMS ((Mmode, rtx));\n-extern int    arm_not_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern int    arm_reload_memory_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    arm_rhs_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern int    arm_rhsm_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern Mmode  arm_select_cc_mode \t\tPARAMS ((RTX_CODE, rtx, rtx));\n-extern int    arm_split_constant\t\tPARAMS ((RTX_CODE, Mmode, HOST_WIDE_INT, rtx, rtx, int));\n-extern int    bad_signed_byte_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    cc_register\t\t\tPARAMS ((rtx, Mmode));\n-extern int    const_shift_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    di_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern int    dominant_cc_register\t\tPARAMS ((rtx, Mmode));\n-extern int    equality_operator\t\t\tPARAMS ((rtx, Mmode));\n-extern int    f_register_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    fpu_add_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern int    fpu_rhs_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern int    index_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern rtx    legitimize_pic_address\t\tPARAMS ((rtx, Mmode, rtx));\n-extern int    load_multiple_operation\t\tPARAMS ((rtx, Mmode));\n-extern int    logical_binary_operator\t\tPARAMS ((rtx, Mmode));\n-extern int    minmax_operator\t\t\tPARAMS ((rtx, Mmode));\n-extern int    multi_register_push\t\tPARAMS ((rtx, Mmode));\n-extern int    nonimmediate_di_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    nonimmediate_soft_df_operand \tPARAMS ((rtx, Mmode));\n-extern int    offsettable_memory_operand \tPARAMS ((rtx, Mmode));\n-extern int    power_of_two_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    reg_or_int_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    s_register_operand\t\tPARAMS ((rtx, Mmode));\n-extern int    shift_operator\t\t\tPARAMS ((rtx, Mmode));\n-extern int    shiftable_operator\t\tPARAMS ((rtx, Mmode));\n-extern int    soft_df_operand\t\t\tPARAMS ((rtx, Mmode));\n-extern int    store_multiple_operation\t\tPARAMS ((rtx, Mmode));\n-\n-#if defined TREE_CODE\n-extern rtx    arm_function_arg\t\t\tPARAMS ((CUMULATIVE_ARGS *, Mmode, tree, int));\n-extern void   arm_init_cumulative_args\t\tPARAMS ((CUMULATIVE_ARGS *, tree, rtx, int));\n-#endif /* TREE_CODE */\n-#endif /* HAVE_MACHINE_MODES */\n #endif /* RTX_CODE */\n \n-#undef Mmode\n+/* Thumb functions.  */\n+extern void   arm_init_expanders\tPARAMS ((void));\n+extern int    thumb_far_jump_used_p\tPARAMS ((int));\n+extern char * thumb_unexpanded_epilogue\tPARAMS ((void));\n+extern void   thumb_expand_prologue\tPARAMS ((void));\n+extern void   thumb_expand_epilogue\tPARAMS ((void));\n+#ifdef TREE_CODE\n+extern int    is_called_in_ARM_mode\tPARAMS ((tree));\n+#endif\n+#ifdef RTX_CODE\n+extern int    thumb_shiftable_const\tPARAMS ((unsigned HOST_WIDE_INT));\n+extern void   thumb_final_prescan_insn\tPARAMS ((rtx));\n+extern char * thumb_load_double_from_address\n+\t\t\t\t\tPARAMS ((rtx *));\n+extern void   output_thumb_prologue\tPARAMS ((FILE *));\n+extern char * thumb_output_move_mem_multiple\n+\t\t\t\t\tPARAMS ((int, rtx *));\n+extern void   thumb_expand_movstrqi\tPARAMS ((rtx *));\n+extern int    thumb_cmp_operand\t\tPARAMS ((rtx, enum machine_mode));\n+extern rtx *  thumb_legitimize_pic_address\n+\t\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx));\n+extern int    thumb_go_if_legitimate_address\n+\t\t\t\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx    arm_return_addr\t\tPARAMS ((int, rtx));\n+extern void   thumb_reload_out_hi\tPARAMS ((rtx *));\n+extern void   thumb_reload_in_hi\tPARAMS ((rtx *));\n+#endif\n+\n+/* Defined in pe.c.  */\n+extern int  arm_dllexport_name_p \tPARAMS ((char *));\n+extern int  arm_dllimport_name_p \tPARAMS ((char *));\n+\n+#ifdef TREE_CODE\n+extern int  arm_pe_valid_machine_decl_attribute\n+\t\t\t\t\tPARAMS ((tree, tree, tree, tree));\n+extern tree arm_pe_merge_machine_decl_attributes\n+\t\t\t\t\tPARAMS ((tree, tree));\n+extern void arm_pe_unique_section \tPARAMS ((tree, int));\n+extern void arm_pe_encode_section_info \tPARAMS ((tree));\n+extern int  arm_dllexport_p \t\tPARAMS ((tree));\n+extern int  arm_dllimport_p \t\tPARAMS ((tree));\n+extern void arm_mark_dllexport \t\tPARAMS ((tree));\n+extern void arm_mark_dllimport \t\tPARAMS ((tree));\n+#endif"}, {"sha": "3a4acd798468f6480a5038bfcc36d9b58d9a59a3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3019, "deletions": 457, "changes": 3476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96"}, {"sha": "268f1c58d7dbcbf85b60e63e72cf23ba2eb7b5b7", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1058, "deletions": 485, "changes": 1543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -51,16 +51,17 @@ Boston, MA 02111-1307, USA.  */\n /* Configure didn't specify.  */\n #define TARGET_CPU_generic\t0x8000\n \n-enum arm_cond_code\n+typedef enum arm_cond_code\n {\n   ARM_EQ = 0, ARM_NE, ARM_CS, ARM_CC, ARM_MI, ARM_PL, ARM_VS, ARM_VC,\n   ARM_HI, ARM_LS, ARM_GE, ARM_LT, ARM_GT, ARM_LE, ARM_AL, ARM_NV\n-};\n+}\n+arm_cc;\n \n-extern enum arm_cond_code arm_current_cc;\n+extern arm_cc arm_current_cc;\n extern char * arm_condition_codes[];\n \n-#define ARM_INVERSE_CONDITION_CODE(X)  ((enum arm_cond_code) (((int)X) ^ 1))\n+#define ARM_INVERSE_CONDITION_CODE(X)  ((arm_cc) (((int)X) ^ 1))\n \n extern int arm_target_label;\n extern int arm_ccfsm_state;\n@@ -72,7 +73,18 @@ extern int frame_pointer_needed;\n extern int target_flags;\n /* The floating point instruction architecture, can be 2 or 3 */\n extern const char * target_fp_name;\n-\n+/* Define the information needed to generate branch insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+extern struct rtx_def * arm_compare_op0;\n+extern struct rtx_def * arm_compare_op1;\n+/* The label of the current constant pool.  */\n+extern struct rtx_def * pool_vector_label;\n+/* Set to 1 when a return insn is output, this means that the epilogue\n+   is not needed. */\n+extern int return_used_this_function;\n+/* Nonzero if the prologue must setup `fp'.  */\n+extern int current_function_anonymous_args;\n \f\n /* Just in case configure has failed to define anything. */\n #ifndef TARGET_CPU_DEFAULT\n@@ -113,12 +125,14 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #endif\n \n #ifndef CPP_PREDEFINES\n-#define CPP_PREDEFINES  \"-Darm -Acpu(arm) -Amachine(arm)\"\n+#define CPP_PREDEFINES  \"-Acpu(arm) -Amachine(arm)\"\n #endif\n \n #define CPP_SPEC \"\\\n %(cpp_cpu_arch) %(cpp_apcs_pc) %(cpp_float) \\\n-%(cpp_endian) %(subtarget_cpp_spec)\"\n+%(cpp_endian) %(subtarget_cpp_spec) %(cpp_isa)\"\n+\n+#define CPP_ISA_SPEC \"%{mthumb:-Dthumb -D__thumb__} %{!mthumb:-Darm -D__arm__}\"\n \n /* Set the architecture define -- if -march= is set, then it overrides\n    the -mcpu= setting.  */\n@@ -156,6 +170,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{march=armv4:-D__ARM_ARCH_4__} \\\n %{march=armv4t:-D__ARM_ARCH_4T__} \\\n %{march=armv5:-D__ARM_ARCH_5__} \\\n+%{march=armv5t:-D__ARM_ARCH_5T__} \\\n+%{march=armv5e:-D__ARM_ARCH_5E__} \\\n+%{march=armv5te:-D__ARM_ARCH_5TE__} \\\n %{!march=*: \\\n  %{mcpu=arm2:-D__ARM_ARCH_2__} \\\n  %{mcpu=arm250:-D__ARM_ARCH_2__} \\\n@@ -212,12 +229,13 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{mbig-endian:\t\t\t\t\t\t\t\t\\\n   %{mlittle-endian:\t\t\t\t\t\t\t\\\n     %e-mbig-endian and -mlittle-endian may not be used together}\t\\\n-  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__}}\t\t\t\\\n+  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__} %{mthumb:-D__THUMBEB__}}\\\n+%{mlittle-endian:-D__ARMEL__ %{mthumb:-D__THUMBEL__}}\t\t\t\\\n %{!mlittle-endian:%{!mbig-endian:%(cpp_endian_default)}}\t\t\\\n \"\n \n-/* Default is little endian, which doesn't define anything. */\n-#define CPP_ENDIAN_DEFAULT_SPEC \"-D__ARMEL__\"\n+/* Default is little endian.  */\n+#define CPP_ENDIAN_DEFAULT_SPEC \"-D__ARMEL__ %{mthumb:-D__THUMBEL__}\"\n \n #define CC1_SPEC \"\"\n \n@@ -239,6 +257,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n   { \"cpp_float_default\",\tCPP_FLOAT_DEFAULT_SPEC },\t\\\n   { \"cpp_endian\",\t\tCPP_ENDIAN_SPEC },\t\t\\\n   { \"cpp_endian_default\",\tCPP_ENDIAN_DEFAULT_SPEC },\t\\\n+  { \"cpp_isa\",\t\t\tCPP_ISA_SPEC },\t\t\t\\\n   { \"subtarget_cpp_spec\",\tSUBTARGET_CPP_SPEC },           \\\n   SUBTARGET_EXTRA_SPECS\n \n@@ -319,8 +338,27 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \n /* Nonzero if all call instructions should be indirect.  */\n #define ARM_FLAG_LONG_CALLS\t(1 << 15)\n+  \n+/* Nonzero means that the target ISA is the THUMB, not the ARM.  */\n+#define ARM_FLAG_THUMB          (1 << 16)\n+\n+/* Set if a TPCS style stack frame should be generated, for non-leaf\n+   functions, even if they do not need one.  */\n+#define THUMB_FLAG_BACKTRACE\t(1 << 17)\n \n-#define TARGET_APCS\t\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n+/* Set if a TPCS style stack frame should be generated, for leaf\n+   functions, even if they do not need one.  */\n+#define THUMB_FLAG_LEAF_BACKTRACE    \t\t(1 << 18)\n+\n+/* Set if externally visible functions should assume that they\n+   might be called in ARM mode, from a non-thumb aware code.  */\n+#define THUMB_FLAG_CALLEE_SUPER_INTERWORKING\t(1 << 19)\n+\n+/* Set if calls via function pointers should assume that their\n+   destination is non-Thumb aware.  */\n+#define THUMB_FLAG_CALLER_SUPER_INTERWORKING\t(1 << 20)\n+\n+#define TARGET_APCS_FRAME\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n #define TARGET_POKE_FUNCTION_NAME\t(target_flags & ARM_FLAG_POKE)\n #define TARGET_FPE\t\t\t(target_flags & ARM_FLAG_FPE)\n #define TARGET_APCS_32\t\t\t(target_flags & ARM_FLAG_APCS_32)\n@@ -337,6 +375,14 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define TARGET_ABORT_NORETURN\t\t(target_flags & ARM_FLAG_ABORT_NORETURN)\n #define TARGET_SINGLE_PIC_BASE\t\t(target_flags & ARM_FLAG_SINGLE_PIC_BASE)\n #define TARGET_LONG_CALLS\t\t(target_flags & ARM_FLAG_LONG_CALLS)\n+#define TARGET_THUMB                    (target_flags & ARM_FLAG_THUMB)\n+#define TARGET_ARM                      (! TARGET_THUMB)\n+#define TARGET_EITHER\t\t\t1 /* (TARGET_ARM | TARGET_THUMB) */\n+#define TARGET_CALLEE_INTERWORKING\t(target_flags & THUMB_FLAG_CALLEE_SUPER_INTERWORKING)\n+#define TARGET_CALLER_INTERWORKING\t(target_flags & THUMB_FLAG_CALLER_SUPER_INTERWORKING)\n+#define TARGET_BACKTRACE\t        (leaf_function_p ()\t      \t\t\t\\\n+\t\t\t\t         ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE)\t\\\n+\t\t\t\t         : (target_flags & THUMB_FLAG_BACKTRACE))\n \n /* SUBTARGET_SWITCHES is used to add flags on a per-config basis.\n    Bit 31 is reserved.  See riscix.h.  */\n@@ -388,18 +434,36 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n   {\"no-thumb-interwork\",       -ARM_FLAG_INTERWORK, \"\" },\t\\\n   {\"abort-on-noreturn\",         ARM_FLAG_ABORT_NORETURN,\t\\\n      \"Generate a call to abort if a noreturn function returns\"},\\\n-  {\"no-abort-on-noreturn\",     -ARM_FLAG_ABORT_NORETURN, \"\"},\t\\\n+  {\"no-abort-on-noreturn\",     -ARM_FLAG_ABORT_NORETURN, \"\" },\t\\\n   {\"sched-prolog\",             -ARM_FLAG_NO_SCHED_PRO,\t\t\\\n      \"Do not move instructions into a function's prologue\" },\t\\\n   {\"no-sched-prolog\",           ARM_FLAG_NO_SCHED_PRO, \"\" },\t\\\n   {\"single-pic-base\",\t\tARM_FLAG_SINGLE_PIC_BASE,\t\\\n      \"Do not load the PIC register in function prologues\" },\t\\\n   {\"no-single-pic-base\",       -ARM_FLAG_SINGLE_PIC_BASE, \"\" },\t\\\n   {\"long-calls\",\t\tARM_FLAG_LONG_CALLS,\t\t\\\n-     \"Generate call insns as indirect calls, if necessary\"},\t\\\n-  {\"no-long-calls\",\t       -ARM_FLAG_LONG_CALLS, \"\"},\t\\\n-  SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n-  {\"\",\t\t\t\tTARGET_DEFAULT, \"\" }\t\t\\\n+     \"Generate call insns as indirect calls, if necessary\" },\t\\\n+  {\"no-long-calls\",\t       -ARM_FLAG_LONG_CALLS, \"\" },\t\\\n+  {\"thumb\",                     ARM_FLAG_THUMB,\t\t\t\\\n+     \"Compile for the Thumb not the ARM\" },\t\t\t\\\n+  {\"no-thumb\",                 -ARM_FLAG_THUMB, \"\" },\t\t\\\n+  {\"arm\",                      -ARM_FLAG_THUMB, \"\" },\t\t\\\n+  {\"tpcs-frame\",\t\t    THUMB_FLAG_BACKTRACE,\t\\\n+     \"Thumb: Generate (non-leaf) stack frames even if not needed\" },\t  \\\n+  {\"no-tpcs-frame\",                -THUMB_FLAG_BACKTRACE, \"\" },\t\t  \\\n+  {\"tpcs-leaf-frame\",\t  \t    THUMB_FLAG_LEAF_BACKTRACE,\t\t  \\\n+     \"Thumb: Generate (leaf) stack frames even if not needed\" },\t  \\\n+  {\"no-tpcs-leaf-frame\",           -THUMB_FLAG_LEAF_BACKTRACE, \"\" },\t  \\\n+  {\"callee-super-interworking\",\t    THUMB_FLAG_CALLEE_SUPER_INTERWORKING, \\\n+     \"Thumb: Assume non-static functions may be called from ARM code\" },  \\\n+  {\"no-callee-super-interworking\", -THUMB_FLAG_CALLEE_SUPER_INTERWORKING, \\\n+   \"\"},\t\t\t\t\t\t\t\t\t  \\\n+  {\"caller-super-interworking\",\t    THUMB_FLAG_CALLER_SUPER_INTERWORKING, \\\n+     \"Thumb: Assume function pointers may go to non-Thumb aware code\" },  \\\n+  {\"no-caller-super-interworking\", -THUMB_FLAG_CALLER_SUPER_INTERWORKING, \\\n+   \"\" },\t\t\t\t\t\t\t\t  \\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\t\t  \\\n+  {\"\",\t\t\t\tTARGET_DEFAULT, \"\" }\t\t\t  \\\n }\n \n #define TARGET_OPTIONS\t\t\t\t\t\t\\\n@@ -483,13 +547,12 @@ extern int arm_is_strong;\n extern int arm_is_6_or_7;\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT  0\n+#define TARGET_DEFAULT  (ARM_FLAG_APCS_FRAME)\n #endif\n \n /* The frame pointer register used in gcc has nothing to do with debugging;\n    that is controlled by the APCS-FRAME option.  */\n-/* Not fully implemented yet.  */\n-/* #define CAN_DEBUG_WITHOUT_FP 1 */\n+#define CAN_DEBUG_WITHOUT_FP\n \n #define TARGET_MEM_FUNCTIONS 1\n \n@@ -705,15 +768,12 @@ extern const char * structure_size_string;\n                      [|  saved f4 value     |]     three words\n   r0-r3 are not normally saved in a C function.  */\n \n-/* The number of hard registers is 16 ARM + 8 FPU + 1 CC + 1 SFP.  */\n-#define FIRST_PSEUDO_REGISTER  27\n-\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n #define FIXED_REGISTERS  \\\n {                        \\\n   0,0,0,0,0,0,0,0,\t \\\n-  0,0,0,1,0,1,0,1,\t \\\n+  0,0,0,0,0,1,0,1,\t \\\n   0,0,0,0,0,0,0,0,\t \\\n   1,1,1\t\t\t \\\n }\n@@ -729,7 +789,7 @@ extern const char * structure_size_string;\n #define CALL_USED_REGISTERS  \\\n {                            \\\n   1,1,1,1,0,0,0,0,\t     \\\n-  0,0,0,1,1,1,1,1,\t     \\\n+  0,0,0,0,1,1,1,1,\t     \\\n   1,1,1,1,0,0,0,0,\t     \\\n   1,1,1\t\t\t     \\\n }\n@@ -738,27 +798,33 @@ extern const char * structure_size_string;\n #define SUBTARGET_CONDITIONAL_REGISTER_USAGE\n #endif\n \n-#define CONDITIONAL_REGISTER_USAGE  \\\n-{\t\t\t\t\t\t\t\\\n-  if (TARGET_SOFT_FLOAT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\\\n-      for (regno = 16; regno < 24; ++regno)\t\t\\\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\\\n-    }\t\t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n-      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (TARGET_APCS_STACK)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fixed_regs[10]     = 1;\t\t\t\t\\\n-      call_used_regs[10] = 1;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\t        \\\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (TARGET_SOFT_FLOAT || TARGET_THUMB)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\\\n+      for (regno = FIRST_ARM_FP_REGNUM;\t\t\t\t\\\n+\t   regno <= LAST_ARM_FP_REGNUM; ++regno)\t\t\\\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n+      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (TARGET_APCS_STACK)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fixed_regs[10]     = 1;\t\t\t\t\t\\\n+      call_used_regs[10] = 1;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (TARGET_APCS_FRAME)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fixed_regs[ARM_HARD_FRAME_POINTER_REGNUM] = 1;\t\t\\\n+      call_used_regs[ARM_HARD_FRAME_POINTER_REGNUM] = 1;\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  SUBTARGET_CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n }\n-\n+    \n /* These are a couple of extensions to the formats accecpted\n    by asm_fprintf:\n      %@ prints out ASM_COMMENT_START\n@@ -773,6 +839,9 @@ extern const char * structure_size_string;\n     fputs (reg_names [va_arg (ARGS, int)], FILE);\t\\\n     break;\n \n+/* Round X up to the nearest word.  */\n+#define ROUND_UP(X) (((X) + 3) & ~3)\n+\n /* Convert fron bytes to ints.  */\n #define NUM_INTS(X) (((X) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n@@ -782,103 +851,141 @@ extern const char * structure_size_string;\n \n /* The number of (integer) registers required to hold a quantity of TYPE MODE.  */\n #define NUM_REGS2(MODE, TYPE)                   \\\n-  NUM_INTS ((MODE) == BLKmode ? int_size_in_bytes (TYPE) : GET_MODE_SIZE (MODE))\n+  NUM_INTS ((MODE) == BLKmode ? \t\t\\\n+  int_size_in_bytes (TYPE) : GET_MODE_SIZE (MODE))\n \n /* The number of (integer) argument register available.  */\n-#define NUM_ARG_REGS   4\n+#define NUM_ARG_REGS\t\t4\n \n /* Return the regiser number of the N'th (integer) argument.  */\n-#define ARG_REGISTER(N) (N - 1)\n+#define ARG_REGISTER(N) \t(N - 1)\n \n-/* The number of the last argument register.  */\n-#define LAST_ARG_REGNUM ARG_REGISTER (NUM_ARG_REGS)\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM\tARG_REGISTER (1)\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n \n-   On the ARM regs are UNITS_PER_WORD bits wide; FPU regs can hold any FP\n-   mode.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)  \t\\\n-  ((   REGNO >= 16\t\t\t\\\n-    && REGNO != FRAME_POINTER_REGNUM\t\\\n-    && REGNO != ARG_POINTER_REGNUM)\t\\\n-   ? 1 : NUM_REGS (MODE))\n+/* The number of the last argument register.  */\n+#define LAST_ARG_REGNUM \tARG_REGISTER (NUM_ARG_REGS)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   This is TRUE for ARM regs since they can hold anything, and TRUE for FPU\n-   regs holding FP.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)  \t\t\t\\\n-  ((GET_MODE_CLASS (MODE) == MODE_CC) ? (REGNO == CC_REGNUM) :\t\\\n-  ((REGNO) < 16 || REGNO == FRAME_POINTER_REGNUM\t\t\\\n-   || REGNO == ARG_POINTER_REGNUM\t\t\t\t\\\n-   || GET_MODE_CLASS (MODE) == MODE_FLOAT))\n+/* The number of the last \"lo\" register (thumb).  */\n+#define LAST_LO_REGNUM  \t 7\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)  \\\n-  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+/* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n+   as an invisible last argument (possible since varargs don't exist in\n+   Pascal), so the following is not true.  */\n+#define STATIC_CHAIN_REGNUM\t(TARGET_ARM ? 8 : 9)\n \n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n+/* Define this to be where the real frame pointer is if it is not possible to\n+   work out the offset between the frame pointer and the automatic variables\n+   until after register allocation has taken place.  FRAME_POINTER_REGNUM\n+   should point to a special register that we will make sure is eliminated.\n+\n+   For the Thumb we have another problem.  The TPCS defines the frame pointer\n+   as r11, and GCC belives that it is always possible to use the frame pointer\n+   as base register for addressing purposes.  (See comments in\n+   find_reloads_address()).  But - the Thumb does not allow high registers,\n+   including r11, to be used as base address registers.  Hence our problem.\n+\n+   The solution used here, and in the old thumb port is to use r7 instead of\n+   r11 as the hard frame pointer and to have special code to generate\n+   backtrace structures on the stack (if required to do so via a command line\n+   option) using r11.  This is the only 'user visable' use of r11 as a frame\n+   pointer.  */\n+#define ARM_HARD_FRAME_POINTER_REGNUM\t11\n+#define THUMB_HARD_FRAME_POINTER_REGNUM\t 7\n+#define HARD_FRAME_POINTER_REGNUM       (TARGET_ARM ? ARM_HARD_FRAME_POINTER_REGNUM : THUMB_HARD_FRAME_POINTER_REGNUM)\n+#define FP_REGNUM\t                HARD_FRAME_POINTER_REGNUM\n \n-/* Define this if the program counter is overloaded on a register.  */\n-#define PC_REGNUM\t\t15\n+/* Scratch register - used in all kinds of places, eg trampolines.  */\n+#define IP_REGNUM\t\t12\n \n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM\t13\n #define SP_REGNUM\t        STACK_POINTER_REGNUM\n \n+/* Register which holds return address from a subroutine call.  */\n+#define LR_REGNUM\t\t14\n+\n+/* Define this if the program counter is overloaded on a register.  */\n+#define PC_REGNUM\t\t15\n+\n+/* The number of the last ARM (integer) register.  */\n+#define LAST_ARM_REGNUM \t15\n+\n+/* ARM floating pointer registers.  */\n+#define FIRST_ARM_FP_REGNUM \t16\n+#define LAST_ARM_FP_REGNUM  \t23\n+\n+/* Internal, so that we don't need to refer to a raw number */\n+#define CC_REGNUM\t\t24\n+\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM\t25\n \n-/* Define this to be where the real frame pointer is if it is not possible to\n-   work out the offset between the frame pointer and the automatic variables\n-   until after register allocation has taken place.  FRAME_POINTER_REGNUM\n-   should point to a special register that we will make sure is eliminated. */\n-#define HARD_FRAME_POINTER_REGNUM 11\n-#define FP_REGNUM\t\tHARD_FRAME_POINTER_REGNUM\n-\n-/* Register which holds return address from a subroutine call.  */\n-#define LR_REGNUM\t\t14\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM\t26\n \n-/* Scratch register - used in all kinds of places, eg trampolines.  */\n-#define IP_REGNUM\t\t12\n+/* The number of hard registers is 16 ARM + 8 FPU + 1 CC + 1 SFP.  */\n+#define FIRST_PSEUDO_REGISTER\t27\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n    via the stack pointer) in functions that seem suitable.  \n    If we have to have a frame pointer we might as well make use of it.\n    APCS says that the frame pointer does not need to be pushed in leaf\n    functions, or simple tail call functions.  */\n-#define FRAME_POINTER_REQUIRED\t\t\\\n-  (current_function_has_nonlocal_label || (TARGET_APCS && !leaf_function_p ()))\n+#define FRAME_POINTER_REQUIRED\t\t\t\t\t\t\\\n+  (current_function_has_nonlocal_label\t\t\t\t\t\\\n+   || (TARGET_ARM && TARGET_APCS_FRAME && ! leaf_function_p ()))\n \n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM\t26\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n \n-/* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n-   as an invisible last argument (possible since varargs don't exist in\n-   Pascal), so the following is not true.  */\n-#define STATIC_CHAIN_REGNUM\t8\n+   On the ARM regs are UNITS_PER_WORD bits wide; FPU regs can hold any FP\n+   mode.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)  \t\\\n+  ((TARGET_ARM \t\t\t\t\\\n+    && REGNO >= FIRST_ARM_FP_REGNUM\t\\\n+    && REGNO != FRAME_POINTER_REGNUM\t\\\n+    && REGNO != ARG_POINTER_REGNUM)\t\\\n+   ? 1 : NUM_REGS (MODE))\n \n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM\t0\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   This is TRUE for ARM regs since they can hold anything, and TRUE for FPU\n+   regs holding FP.\n+   For the Thumb we only allow values bigger than SImode in registers 0 - 6,\n+   so that there is always a second lo register available to hold the upper\n+   part of the value.  Probably we ought to ensure that the register is the\n+   start of an even numbered register pair.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  (TARGET_ARM ?\t\t\t\t\t\t\t\t\\\n+   ((GET_MODE_CLASS (MODE) == MODE_CC) ? (REGNO == CC_REGNUM) :\t\t\\\n+    (   REGNO <= LAST_ARM_REGNUM\t\t\t\t\t\\\n+     || REGNO == FRAME_POINTER_REGNUM\t\t\t\t\t\\\n+     || REGNO == ARG_POINTER_REGNUM\t\t\t\t\t\\\n+     || GET_MODE_CLASS (MODE) == MODE_FLOAT))\t\t\t\t\\\n+   :\t\t\t\t\t\t\t\t\t\\\n+   ((GET_MODE_CLASS (MODE) == MODE_CC) ? (REGNO == CC_REGNUM) :\t\t\\\n+    (NUM_REGS (MODE) < 2 || REGNO < LAST_LO_REGNUM)))\n \n-/* Internal, so that we don't need to refer to a raw number */\n-#define CC_REGNUM\t\t24\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)  \\\n+  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n \n /* The order in which register should be allocated.  It is good to use ip\n    since no saving is required (though calls clobber it) and it never contains\n    function parameters.  It is quite good to use lr since other calls may\n    clobber it anyway.  Allocate r0 through r3 in reverse order since r3 is \n    least likely to contain a function parameter; in addition results are\n-   returned in r0.\n-   */\n+   returned in r0.  */\n #define REG_ALLOC_ORDER  \t    \\\n {                                   \\\n      3,  2,  1,  0, 12, 14,  4,  5, \\\n@@ -889,11 +996,17 @@ extern const char * structure_size_string;\n \f\n /* Register and constant classes.  */\n \n-/* Register classes: all ARM regs or all FPU regs---simple! */\n+/* Register classes: used to be simple, just all ARM regs or all FPU regs\n+   Now that the Thumb is involved it has become more compilcated.  */\n enum reg_class\n {\n   NO_REGS,\n   FPU_REGS,\n+  LO_REGS,\n+  STACK_REG,\n+  BASE_REGS,\n+  HI_REGS,\n+  CC_REG,\n   GENERAL_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n@@ -906,6 +1019,11 @@ enum reg_class\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n   \"FPU_REGS\",\t\t\\\n+  \"LO_REGS\",\t\t\\\n+  \"STACK_REG\",\t\t\\\n+  \"BASE_REGS\",\t\t\\\n+  \"HI_REGS\",\t\t\\\n+  \"CC_REG\",\t\t\\\n   \"GENERAL_REGS\",\t\\\n   \"ALL_REGS\",\t\t\\\n }\n@@ -917,28 +1035,43 @@ enum reg_class\n {\t\t\t\t\t\\\n   { 0x0000000 }, /* NO_REGS  */\t\t\\\n   { 0x0FF0000 }, /* FPU_REGS */\t\t\\\n+  { 0x00000FF }, /* LO_REGS */\t\t\\\n+  { 0x0002000 }, /* STACK_REG */\t\\\n+  { 0x00020FF }, /* BASE_REGS */\t\\\n+  { 0x000FF00 }, /* HI_REGS */\t\t\\\n+  { 0x1000000 }, /* CC_REG */\t\t\\\n   { 0x200FFFF }, /* GENERAL_REGS */\t\\\n   { 0x2FFFFFF }  /* ALL_REGS */\t\t\\\n }\n-\n+  \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n-#define REGNO_REG_CLASS(REGNO)  \t\t\t\\\n-  (((REGNO) < 16 || REGNO == FRAME_POINTER_REGNUM\t\\\n-    || REGNO == ARG_POINTER_REGNUM)\t\t\t\\\n-   ? GENERAL_REGS : (REGNO) == CC_REGNUM\t\t\\\n-   ? NO_REGS : FPU_REGS)\n+#define REGNO_REG_CLASS(REGNO)  arm_regno_class (REGNO)\n \n /* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS  GENERAL_REGS\n-#define BASE_REG_CLASS\tGENERAL_REGS\n+#define INDEX_REG_CLASS  (TARGET_THUMB ? LO_REGS : GENERAL_REGS)\n+#define BASE_REG_CLASS   (TARGET_THUMB ? BASE_REGS : GENERAL_REGS)\n+\n+/* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers. */\n+#define SMALL_REGISTER_CLASSES   TARGET_THUMB\n \n /* Get reg_class from a letter such as appears in the machine description.\n-   We only need constraint `f' for FPU_REGS (`r' == GENERAL_REGS).  */\n-#define REG_CLASS_FROM_LETTER(C)  \\\n-  ((C)=='f' ? FPU_REGS : NO_REGS)\n+   We only need constraint `f' for FPU_REGS (`r' == GENERAL_REGS) for the\n+   ARM, but several more letters for the Thumb.  */\n+#define REG_CLASS_FROM_LETTER(C)  \t\\\n+  (  (C) == 'f' ? FPU_REGS\t\t\\\n+   : (C) == 'l' ? (TARGET_ARM ? GENERAL_REGS : LO_REGS)\t\\\n+   : TARGET_ARM ? NO_REGS\t\t\\\n+   : (C) == 'h' ? HI_REGS\t\t\\\n+   : (C) == 'b' ? BASE_REGS\t\t\\\n+   : (C) == 'k' ? STACK_REG\t\t\\\n+   : (C) == 'c' ? CC_REG\t\t\\\n+   : NO_REGS)\n \n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -950,7 +1083,7 @@ enum reg_class\n \tK: ~value ok in rhs argument of data operand.\n \tL: -value ok in rhs argument of data operand. \n         M: 0..32, or a power of 2  (for shifts, or mult done by shift).  */\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t\\\n+#define CONST_OK_FOR_ARM_LETTER(VALUE, C)  \t\t\\\n   ((C) == 'I' ? const_ok_for_arm (VALUE) :\t\t\\\n    (C) == 'J' ? ((VALUE) < 4096 && (VALUE) > -4096) :\t\\\n    (C) == 'K' ? (const_ok_for_arm (~(VALUE))) :\t\t\\\n@@ -959,113 +1092,197 @@ enum reg_class\n \t\t || (((VALUE) & ((VALUE) - 1)) == 0))\t\\\n    : 0)\n \n+#define CONST_OK_FOR_THUMB_LETTER(VAL, C)\t\t\\\n+  ((C) == 'I' ? (unsigned HOST_WIDE_INT) (VAL) < 256 :\t\\\n+   (C) == 'J' ? (VAL) > -256 && (VAL) < 0 :\t\t\\\n+   (C) == 'K' ? thumb_shiftable_const (VAL) :\t\t\\\n+   (C) == 'L' ? (VAL) > -8 && (VAL) < 8\t:\t\t\\\n+   (C) == 'M' ? ((unsigned HOST_WIDE_INT) (VAL) < 1024\t\\\n+\t\t   && ((VAL) & 3) == 0) :\t\t\\\n+   (C) == 'N' ? ((unsigned HOST_WIDE_INT) (VAL) < 32) :\t\\\n+   (C) == 'O' ? ((VAL) >= -508 && (VAL) <= 508)\t\t\\\n+   : 0)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n+  (TARGET_ARM ?\t\t\t\t\t\t\t\t\\\n+   CONST_OK_FOR_ARM_LETTER (VALUE, C) : CONST_OK_FOR_THUMB_LETTER (VALUE, C))\n+     \n+/* Constant letter 'G' for the FPU immediate constants. \n+   'H' means the same constant negated.  */\n+#define CONST_DOUBLE_OK_FOR_ARM_LETTER(X, C)\t\t\t\\\n+    ((C) == 'G' ? const_double_rtx_ok_for_fpu (X) :\t\t\\\n+     (C) == 'H' ? neg_const_double_rtx_ok_for_fpu (X) : 0)\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(X, C)\t\t\t\\\n+  (TARGET_ARM ?\t\t\t\t\t\t\t\\\n+   CONST_DOUBLE_OK_FOR_ARM_LETTER (X, C) : 0)\n+\n /* For the ARM, `Q' means that this is a memory operand that is just\n    an offset from a register.  \n    `S' means any symbol that has the SYMBOL_REF_FLAG set or a CONSTANT_POOL\n    address.  This means that the symbol is in the text segment and can be\n    accessed without using a load. */\n \n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t    \\\n-  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t    \\\n-   : (C) == 'R' ? (GET_CODE (OP) == MEM\t\t\t\t\t    \\\n-\t\t   && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t    \\\n-\t\t   && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0)))\t\t    \\\n-   : (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP))\t\t    \\\n+#define EXTRA_CONSTRAINT_ARM(OP, C)\t\t\t\t\t    \\\n+  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG :    \\\n+   (C) == 'R' ? (GET_CODE (OP) == MEM\t\t\t\t\t    \\\n+\t\t && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t    \\\n+\t\t && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0))) :\t\t    \\\n+   (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP))\t\t    \\\n    : 0)\n \n-/* Constant letter 'G' for the FPU immediate constants. \n-   'H' means the same constant negated.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(X,C)\t\t\t\\\n-    ((C) == 'G' ? const_double_rtx_ok_for_fpu (X) \t\t\\\n-     : (C) == 'H' ? neg_const_double_rtx_ok_for_fpu (X) : 0)\n+#define EXTRA_CONSTRAINT_THUMB(X, C)\t\t\t\t\t\\\n+  ((C) == 'Q' ? (GET_CODE (X) == MEM\t\t\t\t\t\\\n+\t\t && GET_CODE (XEXP (X, 0)) == LABEL_REF) : 0)\n+\n+#define EXTRA_CONSTRAINT(X, C)\t\t\t\t\t\t\\\n+  (TARGET_ARM ?\t\t\t\t\t\t\t\t\\\n+   EXTRA_CONSTRAINT_ARM (X, C) : EXTRA_CONSTRAINT_THUMB (X, C))\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-#define PREFERRED_RELOAD_CLASS(X, CLASS)  (CLASS)\n+   In general this is just CLASS, but for the Thumb we prefer\n+   a LO_REGS class or a subset.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n+  (TARGET_ARM ? (CLASS) :\t\t\t\\\n+   ((CLASS) == BASE_REGS ? (CLASS) : LO_REGS))\n+\n+/* Must leave BASE_REGS reloads alone */\n+#define THUMB_SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n+  ((CLASS) != LO_REGS && (CLASS) != BASE_REGS\t\t\t\t\\\n+   ? ((true_regnum (X) == -1 ? LO_REGS\t\t\t\t\t\\\n+       : (true_regnum (X) + HARD_REGNO_NREGS (0, MODE) > 8) ? LO_REGS\t\\\n+       : NO_REGS)) \t\t\t\t\t\t\t\\\n+   : NO_REGS)\n+\n+#define THUMB_SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n+  ((CLASS) != LO_REGS\t\t\t\t \t\t\t\\\n+   ? ((true_regnum (X) == -1 ? LO_REGS\t\t\t\t\t\\\n+       : (true_regnum (X) + HARD_REGNO_NREGS (0, MODE) > 8) ? LO_REGS\t\\\n+       : NO_REGS)) \t\t\t\t\t\t\t\\\n+   : NO_REGS)\n \n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X)\t\t\\\n-  (((MODE) == HImode && ! arm_arch4 && true_regnum (X) == -1)\t\\\n-   ? GENERAL_REGS : NO_REGS)\n-\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n+  (TARGET_ARM ?\t\t\t\t\t\t\t\\\n+   (((MODE) == HImode && ! arm_arch4 && true_regnum (X) == -1)\t\\\n+    ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n+   : THUMB_SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X))\n+   \n /* If we need to load shorts byte-at-a-time, then we need a scratch. */\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)\t\t\\\n-  (((MODE) == HImode && ! arm_arch4 && TARGET_MMU_TRAPS\t\t\\\n-    && (GET_CODE (X) == MEM\t\t\t\t\t\\\n-\t|| ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n-\t    && true_regnum (X) == -1)))\t\t\t\t\\\n-   ? GENERAL_REGS : NO_REGS)\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n+  (TARGET_ARM ?\t\t\t\t\t\t\t\\\n+   (((MODE) == HImode && ! arm_arch4 && TARGET_MMU_TRAPS\t\\\n+     && (GET_CODE (X) == MEM\t\t\t\t\t\\\n+\t || ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n+\t     && true_regnum (X) == -1)))\t\t\t\\\n+    ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n+   : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X))\n \n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.\n \n    For the ARM, we wish to handle large displacements off a base\n    register by splitting the addend across a MOV and the mem insn.\n-   This can cut the number of reloads needed. */\n-#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\t\\\n-  do\t\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-\t  && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\\\n-\t  && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\t\\\n-\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\\\n-\t  HOST_WIDE_INT low, high;\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\t\\\n-\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t\t\\\n-\t    low = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t\t\\\n-\t  else if (MODE == SImode\t\t\t\t\t\t\\\n-\t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t\t\\\n-\t\t   || ((MODE == HImode || MODE == QImode) && ! arm_arch4))\t\\\n-\t    /* Need to be careful, -4096 is not a valid offset */\t\t\\\n-\t    low = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t\t\\\n-\t  else if ((MODE == HImode || MODE == QImode) && arm_arch4)\t\t\\\n-\t    /* Need to be careful, -256 is not a valid offset */\t\t\\\n-\t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t\t\\\n-\t  else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-\t\t   && TARGET_HARD_FLOAT)\t\t\t\t\t\\\n-\t    /* Need to be careful, -1024 is not a valid offset */\t\t\\\n-\t    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\t\\\n-\t  high = ((((val - low) & 0xffffffffUL) ^ 0x80000000UL) - 0x80000000UL);\\\n-\t  /* Check for overflow or zero */\t\t\t\t\t\\\n-\t  if (low == 0 || high == 0 || (high + low != val))\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\t\\\n-\t  /* Reload the high part into a base reg; leave the low part\t\t\\\n-\t     in the mem.  */\t\t\t\t\t\t\t\\\n-\t  X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\\\n-\t\t\t    gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\t\\\n-\t\t\t\t\t  GEN_INT (high)),\t\t\t\\\n-\t\t\t    GEN_INT (low));\t\t\t\t\t\\\n-\t  push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\t\\\n-\t\t       BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\t\\\n-\t\t       OPNUM, TYPE);\t\t\t\t\t\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\t\\\n+   This can cut the number of reloads needed.  */\n+#define ARM_LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND, WIN)\t   \\\n+  do\t\t\t\t\t\t\t\t\t   \\\n+    {\t\t\t\t\t\t\t\t\t   \\\n+      if (GET_CODE (X) == PLUS\t\t\t\t\t\t   \\\n+\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t   \\\n+\t  && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t   \\\n+\t  && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t   \\\n+\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t   \\\n+\t  HOST_WIDE_INT low, high;\t\t\t\t\t   \\\n+\t\t\t\t\t\t\t\t\t   \\\n+\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t   \\\n+\t    low = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t   \\\n+\t  else if (MODE == SImode\t\t\t\t\t   \\\n+\t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t   \\\n+\t\t   || ((MODE == HImode || MODE == QImode) && ! arm_arch4)) \\\n+\t    /* Need to be careful, -4096 is not a valid offset.  */\t   \\\n+\t    low = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t   \\\n+\t  else if ((MODE == HImode || MODE == QImode) && arm_arch4)\t   \\\n+\t    /* Need to be careful, -256 is not a valid offset.  */\t   \\\n+\t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t   \\\n+\t  else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t   \\\n+\t\t   && TARGET_HARD_FLOAT)\t\t\t\t   \\\n+\t    /* Need to be careful, -1024 is not a valid offset.  */\t   \\\n+\t    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t   \\\n+\t  else\t\t\t\t\t\t\t\t   \\\n+\t    break;\t\t\t\t\t\t\t   \\\n+\t\t\t\t\t\t\t\t\t   \\\n+\t  high = ((((val - low) & (unsigned long)0xffffffff)\t\t   \\\n+\t\t   ^ (unsigned long)0x80000000)\t\t\t\t   \\\n+\t\t  - (unsigned long)0x80000000);\t\t\t\t   \\\n+\t  /* Check for overflow or zero */\t\t\t\t   \\\n+\t  if (low == 0 || high == 0 || (high + low != val))\t\t   \\\n+\t    break;\t\t\t\t\t\t\t   \\\n+\t\t\t\t\t\t\t\t\t   \\\n+\t  /* Reload the high part into a base reg; leave the low part\t   \\\n+\t     in the mem.  */\t\t\t\t\t\t   \\\n+\t  X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t   \\\n+\t\t\t    gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t   \\\n+\t\t\t\t\t  GEN_INT (high)),\t\t   \\\n+\t\t\t    GEN_INT (low));\t\t\t\t   \\\n+\t  push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t   \\\n+\t\t       BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t   \\\n+\t\t       OPNUM, TYPE);\t\t\t\t\t   \\\n+\t  goto WIN;\t\t\t\t\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n   while (0)\n \n+/* ??? If an HImode FP+large_offset address is converted to an HImode\n+   SP+large_offset address, then reload won't know how to fix it.  It sees\n+   only that SP isn't valid for HImode, and so reloads the SP into an index\n+   register, but the resulting address is still invalid because the offset\n+   is too big.  We fix it here instead by reloading the entire address.  */\n+/* We could probably achieve better results by defining PROMOTE_MODE to help\n+   cope with the variances between the Thumb's signed and unsigned byte and\n+   halfword load instructions.  */\n+#define THUMB_LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+      && XEXP (X, 0) == stack_pointer_rtx\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+      && ! LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx orig_X = X;\t\t\t\t\t\t\t\\\n+      X = copy_rtx (X);\t\t\t\t\t\t\t\\\n+      push_reload (orig_X, NULL_RTX, &X, NULL_PTR,\t\t\t\\\n+\t\t   BASE_REG_CLASS,\t\t\t\t\t\\\n+\t\t   Pmode, VOIDmode, 0, 0, OPNUM, TYPE);\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)   \\\n+  if (TARGET_ARM)\t\t\t\t\t\t\t   \\\n+    ARM_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN); \\\n+  else\t\t\t\t\t\t\t\t\t   \\\n+    THUMB_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\n+  \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits while FPU regs can hold any FP mode */\n #define CLASS_MAX_NREGS(CLASS, MODE)  \\\n   ((CLASS) == FPU_REGS ? 1 : NUM_REGS (MODE))\n \n /* Moves between FPU_REGS and GENERAL_REGS are two memory insns.  */\n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)  \\\n-  ((((CLASS1) == FPU_REGS && (CLASS2) != FPU_REGS)\t\\\n-    || ((CLASS2) == FPU_REGS && (CLASS1) != FPU_REGS))\t\\\n-   ? 20 : 2)\n+#define REGISTER_MOVE_COST(FROM, TO)\t\t\t\\\n+  (TARGET_ARM ?\t\t\t\t\t\t\\\n+   ((FROM) == FPU_REGS && (TO) != FPU_REGS ? 20 :\t\\\n+    (FROM) != FPU_REGS && (TO) == FPU_REGS ? 20 : 2)\t\\\n+   :\t\t\t\t\t\t\t\\\n+   ((FROM) == HI_REGS || (TO) == HI_REGS) ? 4 : 2)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1087,16 +1304,17 @@ enum reg_class\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.  */\n-/* The push insns do not do this rounding implicitly.  So don't define this. */\n-/* #define PUSH_ROUNDING(NPUSHED)  (((NPUSHED) + 3) & ~3) */\n+/* The push insns do not do this rounding implicitly.\n+   So don't define this. */\n+/* #define PUSH_ROUNDING(NPUSHED)  ROUND_UP (NPUSHED) */\n \n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n    found in the variable current_function_outgoing_args_size.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL)  4\n+#define FIRST_PARM_OFFSET(FNDECL)  (TARGET_ARM ? 4 : 0)\n \n /* Value is the number of byte of arguments automatically\n    popped when returning from a subroutine call.\n@@ -1112,21 +1330,22 @@ enum reg_class\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE)  \\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT && TARGET_HARD_FLOAT \\\n-   ? gen_rtx_REG (MODE, 16) \\\n-   : gen_rtx_REG (MODE, 0))\n+  (TARGET_ARM && TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+   ? gen_rtx_REG (MODE, FIRST_ARM_FP_REGNUM) \\\n+   : gen_rtx_REG (MODE, ARG_REGISTER (1)))\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n   LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n \n /* 1 if N is a possible register number for a function value.\n    On the ARM, only r0 and f0 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n-  ((REGNO) == 0 || (((REGNO) == 16) && TARGET_HARD_FLOAT))\n+  ((REGNO) == ARG_REGISTER (1) \\\n+   || (TARGET_ARM && ((REGNO) == FIRST_ARM_FP_REGNUM) && TARGET_HARD_FLOAT))\n \n /* How large values are returned */\n /* A C expression which can inhibit the returning of certain function values\n@@ -1138,22 +1357,35 @@ enum reg_class\n    than a word, or if they contain elements offset from zero in the struct. */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n+/* Flags for the call/call_value rtl operations set up by function_arg.  */\n+#define CALL_NORMAL\t\t0x00000000\t/* No special processing.  */\n+#define CALL_LONG\t\t0x00000001\t/* Always call indirect.  */\n+#define CALL_SHORT\t\t0x00000002\t/* Never call indirect.  */\n+\n+/* A C structure for machine-specific, per-function data.  This is added\n+   to the cfun structure.  */\n+struct machine_function\n+{\n+  /* Records __builtin_return address.  */\n+  struct rtx_def *ra_rtx;\n+  /* Additionsl stack adjustment in __builtin_eh_throw.  */\n+  struct rtx_def *eh_epilogue_sp_ofs;\n+  /* Records if LR has to be saved for far jumps.  */\n+  int far_jump_used;\n+  /* Records if ARG_POINTER was ever live.  */\n+  int arg_pointer_live;\n+};\n+\n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the\n    type `int' suffices and can hold the number of bytes of argument so far.  */\n typedef struct\n {\n-  /* This is the number of argument registers scanned so far.  */\n+  /* This is the number of registers of arguments scanned so far.  */\n   int nregs;\n-  /* instructions on how to process this call.  */\n+  /* One of CALL_NORMAL, CALL_LONG or CALL_SHORT . */\n   int call_cookie;\n-}\n-CUMULATIVE_ARGS;\n-\n-/* Flags for the call_cookie field of CUMULATIVE_ARGS.  */\n-#define CALL_NORMAL\t\t0\t/* No special processing.  */\n-#define CALL_LONG\t\t1\t/* Always call indirect.  */\n-#define CALL_SHORT\t\t2\t/* Never call indirect.  */\n+} CUMULATIVE_ARGS;\n \n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n@@ -1224,8 +1456,15 @@ CUMULATIVE_ARGS;\n }\n \n /* Generate assembly output for the start of a function.  */\n-#define FUNCTION_PROLOGUE(STREAM, SIZE)  \\\n-  output_func_prologue ((STREAM), (SIZE))\n+#define FUNCTION_PROLOGUE(STREAM, SIZE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (TARGET_ARM)\t\t\t\t\\\n+        output_arm_prologue (STREAM, SIZE);\t\\\n+      else\t\t\t\t\t\\\n+\toutput_thumb_prologue (STREAM);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* If your target environment doesn't prefix user functions with an\n    underscore, you may wish to re-define this to prevent any conflicts.\n@@ -1250,20 +1489,33 @@ CUMULATIVE_ARGS;\n \n    The ``mov ip,lr'' seems like a good idea to stick with cc convention.\n    ``prof'' doesn't seem to mind about this!  */\n-#define FUNCTION_PROFILER(STREAM, LABELNO)  \t\t\\\n+#define ARM_FUNCTION_PROFILER(STREAM, LABELNO)  \t\\\n {\t\t\t\t\t\t\t\\\n   char temp[20];\t\t\t\t\t\\\n   rtx sym;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n   asm_fprintf (STREAM, \"\\tmov\\t%r, %r\\n\\tbl\\t\",\t\t\\\n-\t       IP_REGNUM, LR_REGNUM);\t\t\t\\\n+\t   IP_REGNUM, LR_REGNUM);\t\t\t\\\n   assemble_name (STREAM, ARM_MCOUNT_NAME);\t\t\\\n   fputc ('\\n', STREAM);\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (temp, \"LP\", LABELNO);\t\\\n   sym = gen_rtx (SYMBOL_REF, Pmode, temp);\t\t\\\n   ASM_OUTPUT_INT (STREAM, sym);\t\t\t\t\\\n }\n \n+#define THUMB_FUNCTION_PROFILER(STREAM, LABELNO)\t\\\n+{\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\tmov\\\\tip, lr\\n\");\t\t\t\\\n+  fprintf (STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\\\n+  fprintf (STREAM, \"\\t.word\\tLP%d\\n\", LABELNO);\t\t\\\n+}\n+\n+#define FUNCTION_PROFILER(STREAM, LABELNO)\t\t\\\n+  if (TARGET_ARM)\t\t\t\t\t\\\n+    ARM_FUNCTION_PROFILER (STREAM, LABELNO)\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    THUMB_FUNCTION_PROFILER (STREAM, LABELNO)\n+\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n@@ -1274,12 +1526,13 @@ CUMULATIVE_ARGS;\n #define EXIT_IGNORE_STACK 1\n \n /* Generate the assembly code for function exit. */\n-#define FUNCTION_EPILOGUE(STREAM, SIZE)  \\\n+#define FUNCTION_EPILOGUE(STREAM, SIZE)\t\\\n   output_func_epilogue (SIZE)\n \n /* Determine if the epilogue should be output as RTL.\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n-#define USE_RETURN_INSN(ISCOND) use_return_insn (ISCOND)\n+#define USE_RETURN_INSN(ISCOND)\t\t\t\t\\\n+  (TARGET_ARM ? use_return_insn (ISCOND) : 0)\n \n /* Definitions for register eliminations.\n \n@@ -1292,35 +1545,44 @@ CUMULATIVE_ARGS;\n    arg pointer register can often be eliminated in favor of the stack\n    pointer register.  Secondly, the pseudo frame pointer register can always\n    be eliminated; it is replaced with either the stack or the real frame\n-   pointer. */\n+   pointer.  Note we have to use {ARM|THUMB}_HARD_FRAME_POINTER_REGNUM\n+   because the defintion of HARD_FRAME_POINTER_REGNUM is not a constant.  */\n \n-#define ELIMINABLE_REGS\t\t\t\t\t\\\n-{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM      },\t\\\n- { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM },\t\\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM      },\t\\\n- { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM }}\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,        STACK_POINTER_REGNUM            },\\\n+ { ARG_POINTER_REGNUM,        FRAME_POINTER_REGNUM            },\\\n+ { ARG_POINTER_REGNUM,        ARM_HARD_FRAME_POINTER_REGNUM   },\\\n+ { ARG_POINTER_REGNUM,        THUMB_HARD_FRAME_POINTER_REGNUM },\\\n+ { FRAME_POINTER_REGNUM,      STACK_POINTER_REGNUM            },\\\n+ { FRAME_POINTER_REGNUM,      ARM_HARD_FRAME_POINTER_REGNUM   },\\\n+ { FRAME_POINTER_REGNUM,      THUMB_HARD_FRAME_POINTER_REGNUM }}\n \n-/* Given FROM and TO register numbers, say whether this elimination is allowed.\n-   Frame pointer elimination is automatically handled.\n+/* Given FROM and TO register numbers, say whether this elimination is\n+   allowed.  Frame pointer elimination is automatically handled.\n \n    All eliminations are permissible.  Note that ARG_POINTER_REGNUM and\n    HARD_FRAME_POINTER_REGNUM are in fact the same thing.  If we need a frame\n    pointer, we must eliminate FRAME_POINTER_REGNUM into\n-   HARD_FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM.  */\n-#define CAN_ELIMINATE(FROM, TO)\t\t\\\n-  (((TO) == STACK_POINTER_REGNUM && frame_pointer_needed) ? 0 : 1)\n-\n-/* Define the offset between two registers, one to be eliminated, and the other\n-   its replacement, at the start of a routine.  */\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+   HARD_FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM or\n+   ARG_POINTER_REGNUM.  */\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n+  (((TO) == FRAME_POINTER_REGNUM && (FROM) == ARG_POINTER_REGNUM) ? 0 :\t\\\n+   ((TO) == STACK_POINTER_REGNUM && frame_pointer_needed) ? 0 :\t\t\\\n+   ((TO) == ARM_HARD_FRAME_POINTER_REGNUM && TARGET_THUMB) ? 0 :\t\\\n+   ((TO) == THUMB_HARD_FRAME_POINTER_REGNUM && TARGET_ARM) ? 0 :\t\\\n+   1)\n+   \t\t\t\t\t\t\t\t \n+/* Define the offset between two registers, one to be eliminated, and the\n+   other its replacement, at the start of a routine.  */\n+#define ARM_INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   int volatile_func = arm_volatile_func ();\t\t\t\t\\\n   if ((FROM) == ARG_POINTER_REGNUM && (TO) == HARD_FRAME_POINTER_REGNUM)\\\n     (OFFSET) = 0;\t\t\t\t\t\t\t\\\n   else if ((FROM) == FRAME_POINTER_REGNUM\t\t\t\t\\\n \t   && (TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n     (OFFSET) = current_function_outgoing_args_size\t\t\t\\\n-\t\t+ ((get_frame_size () + 3) & ~3);\t\t\t\\\n+\t\t+ ROUND_UP (get_frame_size ());\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       int regno;\t\t\t\t\t\t\t\\\n@@ -1332,15 +1594,21 @@ CUMULATIVE_ARGS;\n           for (regno = 0; regno <= 10; regno++)\t\t\t\t\\\n \t    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n \t      saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n+\t  if (! TARGET_APCS_FRAME\t\t\t\t\t\\\n+\t      && ! frame_pointer_needed\t\t\t\t\t\\\n+\t      && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\t\t\\\n+\t      && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\t\t\\\n+\t    saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n \t  /* PIC register is a fixed reg, so call_used_regs set.  */\t\\\n \t  if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\t\\\n \t    saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n-          for (regno = 16; regno <=23; regno++)\t\t\t\t\\\n+          for (regno = FIRST_ARM_FP_REGNUM;\t\t\t\t\\\n+\t       regno <= LAST_ARM_FP_REGNUM; regno++)\t\t\t\\\n \t    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n \t      offset += 12;\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n       if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\\\n-\t(OFFSET) = -offset;\t\t\t\t\t\t\\\n+\t(OFFSET) = - offset;\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t   if (! frame_pointer_needed)\t\t\t\t\t\\\n@@ -1349,11 +1617,58 @@ CUMULATIVE_ARGS;\n \t       && (regs_ever_live[LR_REGNUM] || saved_hard_reg))\t\\\n \t     offset += 4;\t\t\t\t\t\t\\\n \t   offset += current_function_outgoing_args_size;\t\t\\\n-\t   (OFFSET) = ((get_frame_size () + 3) & ~3) + offset;\t\t\\\n+\t   (OFFSET) = ROUND_UP (get_frame_size ()) + offset;\t\t\\\n          }\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+/* Note:  This macro must match the code in thumb_function_prologue().  */\n+#define THUMB_INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  (OFFSET) = 0;\t\t\t\t\t\t\t\t\\\n+  if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int count_regs = 0;\t\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\t\\\n+      for (regno = 8; regno < 13; regno ++)\t\t\t\t\\\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n+\t  count_regs ++;\t\t\t\t\t\t\\\n+      if (count_regs)\t\t\t\t\t\t\t\\\n+\t(OFFSET) += 4 * count_regs;\t\t\t\t\t\\\n+      count_regs = 0;\t\t\t\t\t\t\t\\\n+      for (regno = 0; regno <= LAST_LO_REGNUM; regno ++)\t\t\\\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n+\t  count_regs ++;\t\t\t\t\t\t\\\n+      if (count_regs || ! leaf_function_p () || thumb_far_jump_used_p (0))\\\n+\t(OFFSET) += 4 * (count_regs + 1);\t\t\t\t\\\n+      if (TARGET_BACKTRACE)\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  if ((count_regs & 0xFF) == 0 && (regs_ever_live[3] != 0))\t\\\n+\t    (OFFSET) += 20;\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    (OFFSET) += 16;\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      (OFFSET) += current_function_outgoing_args_size;\t\t\t\\\n+      (OFFSET) += ROUND_UP (get_frame_size ());\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  if (TARGET_ARM)\t\t\t\t\t\t\t\\\n+    ARM_INITIAL_ELIMINATION_OFFSET (FROM, TO, OFFSET)\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    THUMB_INITIAL_ELIMINATION_OFFSET (FROM, TO, OFFSET)\n+     \n+/* Special case handling of the location of arguments passed on the stack.  */\n+#define DEBUGGER_ARG_OFFSET(value, addr) value ? value : arm_debugger_arg_offset (value, addr)\n+     \n+/* Initialize data used by insn expanders.  This is called from insn_emit,\n+   once for every function before code is generated.  */\n+#define INIT_EXPANDERS  arm_init_expanders ()\n+\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n \n@@ -1364,64 +1679,102 @@ CUMULATIVE_ARGS;\n \t   .word\tstatic chain value\n \t   .word\tfunction's address\n    ??? FIXME: When the trampoline returns, r8 will be clobbered.  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\tldr\\t%s%s, [%s%s, #0]\\n\",\t\t\t\\\n-\t   REGISTER_PREFIX, reg_names[STATIC_CHAIN_REGNUM],\t\\\n-\t   REGISTER_PREFIX, reg_names[PC_REGNUM]);\t\t\\\n-  fprintf ((FILE), \"\\tldr\\t%s%s, [%s%s, #0]\\n\",\t\t\t\\\n-\t   REGISTER_PREFIX, reg_names[PC_REGNUM],\t\t\\\n-\t   REGISTER_PREFIX, reg_names[PC_REGNUM]);\t\t\\\n-  ASM_OUTPUT_INT ((FILE), const0_rtx);\t\t\t\t\\\n-  ASM_OUTPUT_INT ((FILE), const0_rtx);\t\t\t\t\\\n+#define ARM_TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #0]\\n\",\t\t\\\n+\t       STATIC_CHAIN_REGNUM, PC_REGNUM);\t\t\\\n+  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #0]\\n\",\t\t\\\n+\t       PC_REGNUM, PC_REGNUM);\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n+}\n+\n+/* On the Thumb we always switch into ARM mode to execute the trampoline.\n+   Why - because it is easier.  This code will always be branched to via\n+   a BX instruction and since the compiler magically generates the address\n+   of the function the linker has no opportunity to ensure that the\n+   bottom bit is set.  Thus the processor will be in ARM mode when it\n+   reaches this code.  So we duplicate the ARM trampoline code and add\n+   a switch into Thumb mode as well.  */\n+#define THUMB_TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n+{\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.code 32\\n\");\t\t\\\n+  fprintf (FILE, \".Ltrampoline_start:\\n\");\t\\\n+  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #8]\\n\",\t\\\n+\t       STATIC_CHAIN_REGNUM, PC_REGNUM);\t\\\n+  asm_fprintf (FILE, \"\\tldr\\t%r, [%r, #8]\\n\",\t\\\n+\t       IP_REGNUM, PC_REGNUM);\t\t\\\n+  asm_fprintf (FILE, \"\\torr\\t%r, %r, #1\\n\",     \\\n+\t       IP_REGNUM, IP_REGNUM);     \t\\\n+  asm_fprintf (FILE, \"\\tbx\\t%r\\n\", IP_REGNUM);\t\\\n+  fprintf (FILE, \"\\t.word\\t0\\n\");\t\t\\\n+  fprintf (FILE, \"\\t.word\\t0\\n\");\t\t\\\n+  fprintf (FILE, \"\\t.code 16\\n\");\t\t\\\n }\n \n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n+  if (TARGET_ARM)\t\t\t\t\\\n+    ARM_TRAMPOLINE_TEMPLATE (FILE)\t\t\\\n+  else\t\t\t\t\t\t\\\n+    THUMB_TRAMPOLINE_TEMPLATE (FILE)\n+       \n /* Length in units of the trampoline for entering a nested function.  */\n-#define TRAMPOLINE_SIZE  16\n+#define TRAMPOLINE_SIZE  (TARGET_ARM ? 16 : 24)\n \n /* Alignment required for a trampoline in units.  */\n #define TRAMPOLINE_ALIGN  4\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 8)),\t\\\n-\t\t  (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 12)),\t\\\n-\t\t  (FNADDR));\t\t\t\t\t\t\\\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn\t\t\t\t\t\t\t\t\t\\\n+    (gen_rtx_MEM (SImode, plus_constant (TRAMP, TARGET_ARM ? 8 : 16)), CXT);\t\t\\\n+  emit_move_insn\t\t\t\t\t\t\t\t\t\\\n+    (gen_rtx_MEM (SImode, plus_constant (TRAMP, TARGET_ARM ? 12 : 20)),\tFNADDR);\t\\\n }\n \n \f\n /* Addressing modes, and classification of registers for them.  */\n-\n #define HAVE_POST_INCREMENT  1\n-#define HAVE_PRE_INCREMENT   1\n-#define HAVE_POST_DECREMENT  1\n-#define HAVE_PRE_DECREMENT   1\n+#define HAVE_PRE_INCREMENT   TARGET_ARM\n+#define HAVE_POST_DECREMENT  TARGET_ARM\n+#define HAVE_PRE_DECREMENT   TARGET_ARM\n \n /* Macros to check register numbers against specific register classes.  */\n \n /* These assume that REGNO is a hard or pseudo reg number.\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.\n-\n-   On the ARM, don't allow the pc to be used.  */\n-#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n-  ((REGNO) < 15 || (REGNO) == FRAME_POINTER_REGNUM\t\t\\\n-   || (REGNO) == ARG_POINTER_REGNUM\t\t\t\t\\\n-   || (unsigned) reg_renumber[(REGNO)] < 15\t\t\t\\\n-   || (unsigned) reg_renumber[(REGNO)] == FRAME_POINTER_REGNUM\t\\\n-   || (unsigned) reg_renumber[(REGNO)] == ARG_POINTER_REGNUM)\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-  REGNO_OK_FOR_BASE_P(REGNO)\n+   has been allocated, which happens in local-alloc.c. */\n+#define TEST_REGNO(R, TEST, VALUE) \\\n+  ((R TEST VALUE) || ((unsigned) reg_renumber[R] TEST VALUE))\n+\n+/*   On the ARM, don't allow the pc to be used.  */\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE)\t\t\t\\\n+  (TARGET_THUMB ?\t\t\t\t\t\t\\\n+    (    TEST_REGNO (REGNO, <=, LAST_LO_REGNUM)\t\t\t\\\n+      || (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n+\t  && TEST_REGNO (REGNO, ==, STACK_POINTER_REGNUM)))\t\\\n+   :(   \t\t\t\t\t\t\t\\\n+         TEST_REGNO (REGNO, <, PC_REGNUM)\t\t\t\\\n+      || TEST_REGNO (REGNO, ==, FRAME_POINTER_REGNUM)\t\t\\\n+      || TEST_REGNO (REGNO, ==, ARG_POINTER_REGNUM)))\n+\n+/* This is like REGNO_MODE_OF_FOR_BASE_P, except that in Thumb mode\n+   the stack pointer is always acceptable, hence the passing of SImode  */\n+#define REGNO_OK_FOR_BASE_P(REGNO) \t\\\n+  REGNO_MODE_OK_FOR_BASE_P (REGNO, SImode)\n+\n+/* We play tricks with REGNO_MODE_OK... here, so that for ARM the macros\n+   are the same, but for Thumb only registers 0 - 7 are OK.  */\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t\\\n+  REGNO_MODE_OK_FOR_BASE_P (REGNO, QImode)\n \n /* Maximum number of registers that can appear in a valid memory address.\n    Shifts in addresses can't be by a register. */\n-\n #define MAX_REGS_PER_ADDRESS 2\n \n /* Recognize any constant value that is a valid address.  */\n@@ -1430,15 +1783,14 @@ CUMULATIVE_ARGS;\n #ifdef AOF_ASSEMBLER\n \n #define CONSTANT_ADDRESS_P(X)\t\t\\\n-  (GET_CODE (X) == SYMBOL_REF\t\t\\\n-   && CONSTANT_POOL_ADDRESS_P (X))\n+  (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X))\n \n #else\n \n #define CONSTANT_ADDRESS_P(X)  \t\t\t\\\n   (GET_CODE (X) == SYMBOL_REF \t\t\t\\\n    && (CONSTANT_POOL_ADDRESS_P (X)\t\t\\\n-       || (optimize > 0 && SYMBOL_REF_FLAG (X))))\n+       || (TARGET_ARM && optimize > 0 && SYMBOL_REF_FLAG (X))))\n \n #endif /* AOF_ASSEMBLER */\n \n@@ -1447,11 +1799,19 @@ CUMULATIVE_ARGS;\n \n    On the ARM, allow any integer (invalid ones are removed later by insn\n    patterns), nice doubles and symbol_refs which refer to the function's\n-   constant pool XXX.  \n+   constant pool XXX.\n    \n    When generating pic allow anything.  */\n-#define LEGITIMATE_CONSTANT_P(X)\t(flag_pic || ! label_mentioned_p (X))\n-\f\n+#define ARM_LEGITIMATE_CONSTANT_P(X)\t(flag_pic || ! label_mentioned_p (X))\n+\n+#define THUMB_LEGITIMATE_CONSTANT_P(X)\t\\\n+ (   GET_CODE (X) == CONST_INT\t\t\\\n+  || GET_CODE (X) == CONST_DOUBLE\t\\\n+  || CONSTANT_ADDRESS_P (X))\n+\n+#define LEGITIMATE_CONSTANT_P(X)\t\\\n+  (TARGET_ARM ? ARM_LEGITIMATE_CONSTANT_P (X) : THUMB_LEGITIMATE_CONSTANT_P (X))\n+\n /* Special characters prefixed to function names\n    in order to encode attribute like information.\n    Note, '@' and '*' have already been taken.  */\n@@ -1475,7 +1835,6 @@ CUMULATIVE_ARGS;\n #define ARM_NAME_ENCODING_LENGTHS\t\t\\\n   case SHORT_CALL_FLAG_CHAR: return 1;\t\t\\\n   case LONG_CALL_FLAG_CHAR:  return 1;\t\t\\\n-  case '*':  return 1;\t\t\t\t\\\n   SUBTARGET_NAME_ENCODING_LENGTHS\t\t\n \n /* This has to be handled by a function because more than part of the\n@@ -1538,43 +1897,57 @@ CUMULATIVE_ARGS;\n    The symbol REG_OK_STRICT causes the latter definition to be used.  */\n #ifndef REG_OK_STRICT\n \n+#define REG_MODE_OK_FOR_BASE_P(X, MODE)\t   \t\\\n+  (TARGET_THUMB ?\t\t\t\t\\\n+    (   REGNO (X) <= LAST_LO_REGNUM\t\t\\\n+     || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+     || (GET_MODE_SIZE (MODE) >= 4\t\t\\\n+\t && (REGNO (X) == STACK_POINTER_REGNUM\t\\\n+\t      ||   (X) == hard_frame_pointer_rtx \\\n+\t      ||   (X) == arg_pointer_rtx)))\t\\\n+   :(\t\t\t\t\t\t\\\n+        REGNO (X) <= LAST_ARM_REGNUM\t\t\\\n+     || REGNO (X) >= FIRST_PSEUDO_REGISTER \t\\\n+     || REGNO (X) == FRAME_POINTER_REGNUM\t\\\n+     || REGNO (X) == ARG_POINTER_REGNUM))\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X)  \t\t\t\t\\\n-  (REGNO (X) < 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER \\\n-   || REGNO (X) == FRAME_POINTER_REGNUM || REGNO (X) == ARG_POINTER_REGNUM)\n+  REG_MODE_OK_FOR_BASE_P (X, SImode)  \n \n /* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n+   or if it is a pseudo reg.  On the Thumb, the stack pointer\n+   is not suitable.  */\n #define REG_OK_FOR_INDEX_P(X)  \\\n-  REG_OK_FOR_BASE_P(X)\n+  REG_MODE_OK_FOR_BASE_P (X, QImode)  \n \n-#define REG_OK_FOR_PRE_POST_P(X)  \t\t\t\\\n-  (REGNO (X) < 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n-   || REGNO (X) == FRAME_POINTER_REGNUM || REGNO (X) == ARG_POINTER_REGNUM)\n+/* Just like REG_OK_FOR_BASE_P except that we also allow the PC.  */\n+#define REG_OK_FOR_PRE_POST_P(X) \\\n+  (REG_OK_FOR_BASE_P (X) || REGNO(X) == PC_REGNUM)\n \n-#else\n+#else /* REG_OK_STRICT */\n \n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X)  REGNO_OK_FOR_INDEX_P (REGNO (X))\n \n-#define REG_OK_FOR_PRE_POST_P(X)  \t\t\t\t\t   \\\n-  (REGNO (X) < 16 || (unsigned) reg_renumber[REGNO (X)] < 16\t\t   \\\n-   || REGNO (X) == FRAME_POINTER_REGNUM || REGNO (X) == ARG_POINTER_REGNUM \\\n-   || (unsigned) reg_renumber[REGNO (X)] == FRAME_POINTER_REGNUM\t   \\\n-   || (unsigned) reg_renumber[REGNO (X)] == ARG_POINTER_REGNUM)\n+/* Just like REG_OK_FOR_BASE_P except that we also allow the PC.  */\n+#define REG_OK_FOR_PRE_POST_P(X) \\\n+  (REG_OK_FOR_BASE_P (X) || TEST_REGNO (REGNO (X), ==, PC_REGNUM))\n \n-#endif\n+#endif /* REG_OK_STRICT */\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address.\n \n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS. */\n+     \n+/* --------------------------------arm version----------------------------- */\n #define BASE_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n \n@@ -1640,7 +2013,7 @@ CUMULATIVE_ARGS;\n    INDEX+REG, REG-INDEX, and non floating SYMBOL_REF to the constant pool.\n    Allow REG-only and AUTINC-REG if handling TImode or HImode.  Other symbol\n    refs must be forced though a static cell to ensure addressability.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)  \t\t\t\\\n+#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)  \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n@@ -1669,8 +2042,8 @@ CUMULATIVE_ARGS;\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      rtx xop0 = XEXP(X,0);\t\t\t\t\t\t\\\n-      rtx xop1 = XEXP(X,1);\t\t\t\t\t\t\\\n+      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t\\\n+      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t\t\\\n \tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t\\\n@@ -1698,6 +2071,119 @@ CUMULATIVE_ARGS;\n \t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n }\n+     \n+/* ---------------------thumb version----------------------------------*/     \n+#define LEGITIMATE_OFFSET(MODE, VAL)\t\t\t\t\t\\\n+  (GET_MODE_SIZE (MODE) == 1 ? ((unsigned HOST_WIDE_INT) (VAL) < 32)\t\\\n+   : GET_MODE_SIZE (MODE) == 2 ? ((unsigned HOST_WIDE_INT) (VAL) < 64\t\\\n+\t \t\t\t  && ((VAL) & 1) == 0)\t\t\t\\\n+   : ((VAL) >= 0 && ((VAL) + GET_MODE_SIZE (MODE)) <= 128\t\t\\\n+      && ((VAL) & 3) == 0))\n+\n+/* The AP may be eliminated to either the SP or the FP, so we use the\n+   least common denominator, e.g. SImode, and offsets from 0 to 64.  */\n+\n+/* ??? Verify whether the above is the right approach.  */\n+\n+/* ??? Also, the FP may be eliminated to the SP, so perhaps that\n+   needs special handling also.  */\n+\n+/* ??? Look at how the mips16 port solves this problem.  It probably uses\n+   better ways to solve some of these problems.  */\n+\n+/* Although it is not incorrect, we don't accept QImode and HImode\n+   addresses based on the frame pointer or arg pointer until the reload pass starts.\n+   This is so that eliminating such addresses into stack based ones\n+   won't produce impossible code.  */\n+#define THUMB_GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+/* ??? Not clear if this is right.  Experiment.  */\t\t\t\\\n+  if (GET_MODE_SIZE (MODE) < 4\t\t\t\t\t\t\\\n+      && ! (reload_in_progress || reload_completed)\t\t\t\\\n+      && (   reg_mentioned_p (frame_pointer_rtx, X)\t\t\t\\\n+\t  || reg_mentioned_p (arg_pointer_rtx, X)\t\t\t\\\n+\t  || reg_mentioned_p (virtual_incoming_args_rtx, X)\t\t\\\n+\t  || reg_mentioned_p (virtual_outgoing_args_rtx, X)\t\t\\\n+\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, X)\t\t\\\n+\t  || reg_mentioned_p (virtual_stack_vars_rtx, X)))\t\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  /* Accept any base register.  SP only in SImode or larger.  */\t\\\n+  else if (GET_CODE (X) == REG && REG_MODE_OK_FOR_BASE_P (X, MODE))\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\t\\\n+  else if (GET_MODE_SIZE (MODE) >= 4 && CONSTANT_P (X)\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (X) && ! flag_pic)\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  /* This is PC relative data after MACHINE_DEPENDENT_REORG runs.  */\t\\\n+  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n+\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t\\\n+\t       || (GET_CODE (X) == CONST\t\t\t\t\\\n+\t\t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\\\n+\t\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF\t\\\n+\t\t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)))\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  /* Post-inc indexing only supported for SImode and larger.  */\t\\\n+  else if (GET_CODE (X) == POST_INC && GET_MODE_SIZE (MODE) >= 4\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* REG+REG address can be any two index registers.  */\t\t\\\n+      /* We disallow FRAME+REG addressing since we know that FRAME\t\\\n+\t will be replaced with STACK, and SP relative addressing only\t\\\n+\t permits SP+OFFSET.  */\t\t\t\t\t\t\\\n+      if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t  && XEXP (X, 0) != frame_pointer_rtx\t\t\t\t\\\n+\t  && XEXP (X, 1) != frame_pointer_rtx\t\t\t\t\\\n+\t  && XEXP (X, 0) != virtual_stack_vars_rtx\t\t\t\\\n+\t  && XEXP (X, 1) != virtual_stack_vars_rtx\t\t\t\\\n+\t  && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n+\t  && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      /* REG+const has 5-7 bit offset for non-SP registers.  */\t\t\\\n+      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t       && (REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\\\n+\t\t   || XEXP (X, 0) == arg_pointer_rtx)\t\t\t\\\n+\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t       && LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      /* REG+const has 10 bit offset for SP, but only SImode and\t\\\n+\t larger is supported.  */\t\t\t\t\t\\\n+      /* ??? Should probably check for DI/DFmode overflow here\t\t\\\n+\t just like GO_IF_LEGITIMATE_OFFSET does.  */\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t       && REGNO (XEXP (X, 0)) == STACK_POINTER_REGNUM\t\t\\\n+\t       && GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n+\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t       && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (X, 1))\t\\\n+\t\t   + GET_MODE_SIZE (MODE)) <= 1024\t\t\t\\\n+\t       && (INTVAL (XEXP (X, 1)) & 3) == 0)\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t       && REGNO (XEXP (X, 0)) == FRAME_POINTER_REGNUM\t\t\\\n+\t       && GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n+\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t       && (INTVAL (XEXP (X, 1)) & 3) == 0)\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n+\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n+\t   && ! (flag_pic\t\t\t\t\t\t\\\n+\t\t && symbol_mentioned_p (get_pool_constant (X))))\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* ------------------------------------------------------------------- */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\t\t\\\n+  if (TARGET_ARM)\t\t\t\t\t\t\t\\\n+    ARM_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)  \t\t\t\\\n+  else /* if (TARGET_THUMB) */\t\t\t\t\t\t\\\n+    THUMB_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)\t\n+/* ------------------------------------------------------------------- */\n \f\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n@@ -1715,7 +2201,7 @@ CUMULATIVE_ARGS;\n    On the ARM, try to convert [REG, #BIGCONST]\n    into ADD BASE, REG, #UPPERCONST and [BASE, #VALIDCONST],\n    where VALIDCONST == 0 in case of TImode.  */\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t \\\n+#define ARM_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t \\\n {\t\t\t\t\t\t\t\t\t \\\n   if (GET_CODE (X) == PLUS)\t\t\t\t\t\t \\\n     {\t\t\t\t\t\t\t\t\t \\\n@@ -1776,18 +2262,34 @@ CUMULATIVE_ARGS;\n     goto WIN;\t\t\t\t\t\t\t\t \\\n }\n \n+#define THUMB_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n+  if (flag_pic)\t\t\t\t\t\t\\\n+    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\t\t\n+     \n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n+  if (TARGET_ARM)\t\t\t\t\\\n+    ARM_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN)\t\\\n+  else\t\t\t\t\t\t\\\n+    THUMB_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN)\n+     \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+#define ARM_GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)  \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE(ADDR) == PRE_DEC || GET_CODE(ADDR) == POST_DEC\t\t\\\n-      || GET_CODE(ADDR) == PRE_INC || GET_CODE(ADDR) == POST_INC)\t\\\n+  if (   GET_CODE (ADDR) == PRE_DEC || GET_CODE (ADDR) == POST_DEC\t\\\n+      || GET_CODE (ADDR) == PRE_INC || GET_CODE (ADDR) == POST_INC)\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n }\n+\n+/* Nothing helpful to do for the Thumb */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\\\n+  if (TARGET_ARM)\t\t\t\t\t\\\n+    ARM_GO_IF_MODE_DEPENDENT_ADDRESS (ADDR, LABEL)  \t\t\t\n \f\n+\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n+#define CASE_VECTOR_MODE Pmode\n \n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n@@ -1823,8 +2325,9 @@ CUMULATIVE_ARGS;\n    be the code that says which one of the two operations is implicitly\n    done, NIL if none.  */\n #define LOAD_EXTEND_OP(MODE)\t\t\t\t\t\t\\\n-  ((arm_arch4 || (MODE) == QImode) ? ZERO_EXTEND\t\t\t\\\n-   : ((BYTES_BIG_ENDIAN && (MODE) == HImode) ? SIGN_EXTEND : NIL))\n+  (TARGET_THUMB ? ZERO_EXTEND :\t\t\t\t\t\t\\\n+   ((arm_arch4 || (MODE) == QImode) ? ZERO_EXTEND\t\t\t\\\n+    : ((BYTES_BIG_ENDIAN && (MODE) == HImode) ? SIGN_EXTEND : NIL)))\n \n /* Define this if zero-extension is slow (more than one real instruction).\n    On the ARM, it is more than one instruction only if not fetching from\n@@ -1834,6 +2337,8 @@ CUMULATIVE_ARGS;\n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS 0\n \n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n+     \n /* Immediate shift counts are truncated by the output routines (or was it\n    the assembler?).  Shift counts in a register are truncated by ARM.  Note\n    that the native compiler puts too large (> 32) immediate shift counts\n@@ -1846,7 +2351,7 @@ CUMULATIVE_ARGS;\n /* #define SHIFT_COUNT_TRUNCATED 1 */\n \n /* All integers have the same format so truncation is easy.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC)  1\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n \n /* Calling from registers is a massive pain.  */\n #define NO_FUNCTION_CSE 1\n@@ -1858,52 +2363,24 @@ CUMULATIVE_ARGS;\n #define Pmode  SImode\n #define FUNCTION_MODE  Pmode\n \n-/* The structure type of the machine dependent info field of insns\n-   No uses for this yet.  */\n-/* #define INSN_MACHINE_INFO  struct machine_info  */\n-\n-/* The relative costs of various types of constants.  Note that cse.c defines\n-   REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (const_ok_for_arm (INTVAL (RTX)))\t\t\t\\\n-      return (OUTER_CODE) == SET ? 2 : -1;\t    \t\t\\\n-    else if (OUTER_CODE == AND                  \t\t\\\n-             && const_ok_for_arm (~INTVAL (RTX)))\t\t\\\n-      return -1;\t                              \t\t\\\n-    else if ((OUTER_CODE == COMPARE             \t\t\\\n-              || OUTER_CODE == PLUS || OUTER_CODE == MINUS)     \\\n-             && const_ok_for_arm (-INTVAL (RTX)))\t\t\\\n-      return -1;\t                              \t\t\\\n-    else                                        \t\t\\\n-      return 5;\t\t                               \t\t\\\n-  case CONST: \t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 6;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    if (const_double_rtx_ok_for_fpu (RTX))\t\t\t\\\n-      return (OUTER_CODE) == SET ? 2 : -1;\t\t\t\\\n-    else if (((OUTER_CODE) == COMPARE || (OUTER_CODE) == PLUS)\t\\\n-\t     && neg_const_double_rtx_ok_for_fpu (RTX))\t\t\\\n-       return -1;\t\t\t\t\t\t\\\n-    return(7);\n-\n-#define ARM_FRAME_RTX(X)\t\t\t\t\\\n-  ((X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n+#define ARM_FRAME_RTX(X)\t\t\t\t\t\\\n+  (   (X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n    || (X) == arg_pointer_rtx)\n \n #define DEFAULT_RTX_COSTS(X, CODE, OUTER_CODE)\t\t\\\n-  return arm_rtx_costs (X, CODE);\n+  return arm_rtx_costs (X, CODE, OUTER_CODE);\n \n /* Moves to and from memory are quite expensive */\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN)  10\n-\n+#define MEMORY_MOVE_COST(M, CLASS, IN)\t\t\t\\\n+  (TARGET_ARM ? 10 :\t\t\t\t\t\\\n+   ((GET_MODE_SIZE (M) < 4 ? 8 : 2 * GET_MODE_SIZE (M))\t\\\n+    * (CLASS == LO_REGS ? 1 : 2)))\n+ \n /* All address computations that can be done are free, but rtx cost returns\n    the same for practically all of them.  So we weight the different types\n    of address here in the order (most pref first):\n    PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL. */\n-#define ADDRESS_COST(X)\t\t\t\t\t\t\t     \\\n+#define ARM_ADDRESS_COST(X)\t\t\t\t\t\t     \\\n   (10 - ((GET_CODE (X) == MEM || GET_CODE (X) == LABEL_REF\t\t     \\\n \t  || GET_CODE (X) == SYMBOL_REF)\t\t\t\t     \\\n \t ? 0\t\t\t\t\t\t\t\t     \\\n@@ -1918,10 +2395,20 @@ CUMULATIVE_ARGS;\n \t\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (X, 1))) == 'c') \\\n \t\t\t  ? 1 : 0))\t\t\t\t\t     \\\n \t\t: 4)))))\n-\n+\t \n+#define THUMB_ADDRESS_COST(X) \t\t\t\t\t\\\n+  ((GET_CODE (X) == REG \t\t\t\t\t\\\n+    || (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == CONST_INT))\t\t\\\n+   ? 1 : 2)\n+     \n+#define ADDRESS_COST(X) \\\n+     (TARGET_ARM ? ARM_ADDRESS_COST (X) : THUMB_ADDRESS_COST (X))\n+   \n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n-#define BRANCH_COST 4\n+#define BRANCH_COST \\\n+  (TARGET_ARM ? 4 : (optimize > 1 ? 1 : 0))\n \n /* A C statement to update the variable COST based on the relationship\n    between INSN that is dependent on DEP through dependence LINK.  */\n@@ -1987,25 +2474,25 @@ extern int making_const_table;\n    CC_Zmode should be used if only the Z flag is set correctly\n    CCmode should be used otherwise. */\n \n-#define EXTRA_CC_MODES\t\t\\\n-    CC(CC_NOOVmode,  \"CC_NOOV\")\t\\\n-    CC(CC_Zmode,     \"CC_Z\")\t\\\n-    CC(CC_SWPmode,   \"CC_SWP\")\t\\\n-    CC(CCFPmode,     \"CCFP\")\t\\\n-    CC(CCFPEmode,    \"CCFPE\")\t\\\n-    CC(CC_DNEmode,   \"CC_DNE\")\t\\\n-    CC(CC_DEQmode,   \"CC_DEQ\")\t\\\n-    CC(CC_DLEmode,   \"CC_DLE\")\t\\\n-    CC(CC_DLTmode,   \"CC_DLT\")\t\\\n-    CC(CC_DGEmode,   \"CC_DGE\")\t\\\n-    CC(CC_DGTmode,   \"CC_DGT\")\t\\\n-    CC(CC_DLEUmode,  \"CC_DLEU\")\t\\\n-    CC(CC_DLTUmode,  \"CC_DLTU\")\t\\\n-    CC(CC_DGEUmode,  \"CC_DGEU\")\t\\\n-    CC(CC_DGTUmode,  \"CC_DGTU\")\t\\\n-    CC(CC_Cmode,     \"CC_C\")\n-\n-#define SELECT_CC_MODE(OP,X,Y)  arm_select_cc_mode ((OP), (X), (Y))\n+#define EXTRA_CC_MODES \\\n+        CC(CC_NOOVmode, \"CC_NOOV\") \\\n+        CC(CC_Zmode, \"CC_Z\") \\\n+        CC(CC_SWPmode, \"CC_SWP\") \\\n+        CC(CCFPmode, \"CCFP\") \\\n+        CC(CCFPEmode, \"CCFPE\") \\\n+        CC(CC_DNEmode, \"CC_DNE\") \\\n+        CC(CC_DEQmode, \"CC_DEQ\") \\\n+        CC(CC_DLEmode, \"CC_DLE\") \\\n+        CC(CC_DLTmode, \"CC_DLT\") \\\n+        CC(CC_DGEmode, \"CC_DGE\") \\\n+        CC(CC_DGTmode, \"CC_DGT\") \\\n+        CC(CC_DLEUmode, \"CC_DLEU\") \\\n+        CC(CC_DLTUmode, \"CC_DLTU\") \\\n+        CC(CC_DGEUmode, \"CC_DGEU\") \\\n+        CC(CC_DGTUmode, \"CC_DGTU\") \\\n+        CC(CC_Cmode, \"CC_C\")\n+\n+#define SELECT_CC_MODE(OP, X, Y)  arm_select_cc_mode (OP, X, Y)\n \n #define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode)\n \n@@ -2025,49 +2512,17 @@ extern int making_const_table;\n \n #define STORE_FLAG_VALUE 1\n \n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-\n-extern struct rtx_def * arm_compare_op0;\n-extern struct rtx_def * arm_compare_op1;\n-\n-/* Define the codes that are matched by predicates in arm.c */\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"s_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"f_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"arm_add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"fpu_add_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n-  {\"arm_rhs_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"fpu_rhs_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n-  {\"arm_not_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"offsettable_memory_operand\", {MEM}},\t\t\t\t\\\n-  {\"bad_signed_byte_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"alignable_memory_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"shiftable_operator\", {PLUS, MINUS, AND, IOR, XOR}},\t\t\t\\\n-  {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\\n-  {\"shift_operator\", {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATERT, MULT}},\t\\\n-  {\"di_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}},\t\t\\\n-  {\"soft_df_operand\", {SUBREG, REG, CONST_DOUBLE, MEM}},\t\t\\\n-  {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n-  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n-  {\"equality_operator\", {EQ, NE}},\t\t\t\t\t\\\n-  {\"arm_rhsm_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n-  {\"const_shift_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"index_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"reg_or_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"multi_register_push\", {PARALLEL}},\t\t\t\t\t\\\n-  {\"cc_register\", {REG}},\t\t\t\t\t\t\\\n-  {\"logical_binary_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n-  {\"dominant_cc_register\", {REG}},\n-\n \f\n \n /* Gcc puts the pool in the wrong place for ARM, since we can only\n    load addresses a limited distance around the pc.  We do some\n    special munging to move the constant pool values to the correct\n    point in the code.  */\n-#define MACHINE_DEPENDENT_REORG(INSN)\tarm_reorg ((INSN))\n+#define MACHINE_DEPENDENT_REORG(INSN)\t\\\n+    arm_reorg (INSN);\t\t\t\\\n+\n+#undef  ASM_APP_OFF\n+#define ASM_APP_OFF (TARGET_THUMB ? \"\\t.code\\t16\\n\" : \"\")\n \n /* Output an internal label definition.  */\n #ifndef ASM_OUTPUT_INTERNAL_LABEL\n@@ -2089,20 +2544,67 @@ extern struct rtx_def * arm_compare_op1;\n #endif\n \n /* Output a push or a pop instruction (only used when profiling).  */\n-#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO) \\\n-  asm_fprintf (STREAM,\"\\tstmfd\\t%r!,{%r}\\n\", SP_REGNUM, REGNO)\n-\n-#define ASM_OUTPUT_REG_POP(STREAM, REGNO) \\\n-  asm_fprintf (STREAM,\"\\tldmfd\\t%r!,{%r}\\n\", SP_REGNUM, REGNO)\n+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)\t\t\\\n+  if (TARGET_ARM)\t\t\t\t\t\\\n+    asm_fprintf (STREAM,\"\\tstmfd\\t%r!,{%r}\\n\", \t\t\\\n+\t\t STACK_POINTER_REGNUM, REGNO);\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    asm_fprintf (STREAM, \"\\tpush {%r}\\n\", REGNO)\n+\n+\n+#define ASM_OUTPUT_REG_POP(STREAM, REGNO)\t\t\\\n+  if (TARGET_ARM)\t\t\t\t\t\\\n+    asm_fprintf (STREAM, \"\\tldmfd\\t%r!,{%r}\\n\",\t\t\\\n+                 STACK_POINTER_REGNUM, REGNO);\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    asm_fprintf (STREAM, \"\\tpop {%r}\\n\", REGNO)\n+\n+/* This is how to output a label which precedes a jumptable.  Since\n+   Thumb instructions are 2 bytes, we may need explicit alignment here.  */\n+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, JUMPTABLE)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (TARGET_THUMB)\t\t\t\t\t\t\\\n+        ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\\\n+      ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define ARM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) \t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n+      if (TARGET_THUMB) \t\t\t\t\\\n+        {\t\t\t\t\t\t\\\n+          if (is_called_in_ARM_mode (DECL))\t\t\\\n+            fprintf (STREAM, \"\\t.code 32\\n\") ;\t\t\\\n+          else\t\t\t\t\t\t\\\n+           fprintf (STREAM, \"\\t.thumb_func\\n\") ;\t\\\n+        }\t\t\t\t\t\t\\\n       if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n         arm_poke_function_name (STREAM, (char *) NAME);\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n+/* For aliases of functions we use .thumb_set instead.  */\n+#define ASM_OUTPUT_DEF_FROM_DECLS(FILE, DECL1, DECL2)\t\t\\\n+  do\t\t\t\t\t\t   \t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char * LABEL1 = XSTR (XEXP (DECL_RTL (decl), 0), 0);\t\\\n+      char * LABEL2 = IDENTIFIER_POINTER (DECL2);\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (TARGET_THUMB && TREE_CODE (DECL1) == FUNCTION_DECL)\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.thumb_set \");\t\t\t\\\n+\t  assemble_name (FILE, LABEL1);\t\t\t   \t\\\n+\t  fprintf (FILE, \",\");\t\t\t   \t\t\\\n+\t  assemble_name (FILE, LABEL2);\t\t   \t\t\\\n+\t  fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tASM_OUTPUT_DEF (FILE, LABEL1, LABEL2);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n /* Target characters.  */\n #define TARGET_BELL\t007\n #define TARGET_BS\t010\n@@ -2114,101 +2616,135 @@ extern struct rtx_def * arm_compare_op1;\n \f\n /* Only perform branch elimination (by making instructions conditional) if\n    we're optimising.  Otherwise it's of no use anyway.  */\n-#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)  \\\n-  if (optimize)\t\t\t\t\t    \\\n-    arm_final_prescan_insn (INSN)\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\\\n+  if (TARGET_ARM && optimize)\t\t\t\t\\\n+    arm_final_prescan_insn (INSN);\t\t\t\\\n+  else if (TARGET_THUMB)\t\t\t\t\\\n+    thumb_final_prescan_insn (INSN)\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n-  ((CODE) == '?' || (CODE) == '|' || (CODE) == '@')\n+  (CODE == '@' || CODE == '|'\t\t\t\\\n+   || (TARGET_ARM   && (CODE == '?'))\t\t\\\n+   || (TARGET_THUMB && (CODE == '_')))\n \n+     \n /* Output an operand of an instruction.  */\n #define PRINT_OPERAND(STREAM, X, CODE)  \\\n   arm_print_operand (STREAM, X, CODE)\n \n #define ARM_SIGN_EXTEND(x)  ((HOST_WIDE_INT)\t\t\\\n   (HOST_BITS_PER_WIDE_INT <= 32 ? (x)\t\t\t\\\n-   : (((x) & (unsigned HOST_WIDE_INT) 0xffffffffUL) |\t\\\n-      (((x) & (unsigned HOST_WIDE_INT) 0x80000000UL)\t\\\n+   : (((x) & (unsigned HOST_WIDE_INT) 0xffffffff) |\t\\\n+      (((x) & (unsigned HOST_WIDE_INT) 0x80000000)\t\\\n        ? ((~ (HOST_WIDE_INT) 0)\t\t\t\t\\\n-\t  & ~ (unsigned HOST_WIDE_INT) 0xffffffffUL)\t\\\n+\t  & ~ (unsigned HOST_WIDE_INT) 0xffffffff)\t\\\n        : 0))))\n \n /* Output the address of an operand.  */\n-#define PRINT_OPERAND_ADDRESS(STREAM,X)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-    int is_minus = GET_CODE (X) == MINUS;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-      asm_fprintf (STREAM, \"[%r, #0]\", REGNO (X));\t\t\t\\\n-    else if (GET_CODE (X) == PLUS || is_minus)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\trtx base = XEXP (X, 0);\t\t\t\t\t\t\\\n-\trtx index = XEXP (X, 1);\t\t\t\t\t\\\n-\tint base_reg;\t\t\t\t\t\t\t\\\n-\tHOST_WIDE_INT offset = 0;\t\t\t\t\t\\\n-\tif (GET_CODE (base) != REG)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    /* Ensure that BASE is a register (one of them must be). */\t\\\n-\t    rtx temp = base;\t\t\t\t\t\t\\\n-\t    base = index;\t\t\t\t\t\t\\\n-\t    index = temp;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbase_reg = REGNO (base);\t\t\t\t\t\\\n-\tswitch (GET_CODE (index))\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t  case CONST_INT:\t\t\t\t\t\t\\\n-\t    offset = INTVAL (index);\t\t\t\t\t\\\n-\t    if (is_minus)\t\t\t\t\t\t\\\n-\t      offset = -offset;\t\t\t\t\t\t\\\n-\t    asm_fprintf (STREAM, \"[%r, #%d]\", base_reg, offset);\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  case REG:\t\t\t\t\t\t\t\\\n-\t    asm_fprintf (STREAM, \"[%r, %s%r]\", base_reg,\t\t\\\n-\t\t         is_minus ? \"-\" : \"\", REGNO (index));\t\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  case MULT:\t\t\t\t\t\t\t\\\n-\t  case ASHIFTRT:\t\t\t\t\t\t\\\n-\t  case LSHIFTRT:\t\t\t\t\t\t\\\n-\t  case ASHIFT:\t\t\t\t\t\t\t\\\n-\t  case ROTATERT:\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    asm_fprintf (STREAM, \"[%r, %s%r\", base_reg,\t\t\t\\\n-\t\t         is_minus ? \"-\" : \"\", REGNO (XEXP (index, 0)));\t\\\n-\t    arm_print_operand (STREAM, index, 'S');\t\t\t\\\n-\t    fputs (\"]\", STREAM);\t\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t    \t\t\t\t\t\t\t\t\\\n-\t  default:\t\t\t\t\t\t\t\\\n-\t    abort();\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t        \t\\\n-  else if (GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_INC\t\t\\\n-\t   || GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_DEC)\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      extern int output_memory_reference_mode;\t\t\t\t\\\n-      \t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) != REG)\t\t\t\t\\\n-\tabort ();\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\t\\\n-\tasm_fprintf (STREAM, \"[%r, #%s%d]!\", \t\t\t\t\\\n-\t\t     REGNO (XEXP (X, 0)),\t\t\t\t\\\n-\t\t     GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\t\\\n-\t\t     GET_MODE_SIZE (output_memory_reference_mode));\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tasm_fprintf (STREAM, \"[%r], #%s%d\", \t\t\t\t\\\n-\t\t     REGNO (XEXP (X, 0)),\t\t\t\t\\\n-\t\t     GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\t\\\n-\t\t     GET_MODE_SIZE (output_memory_reference_mode));\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else output_addr_const (STREAM, X);\t\t\t\t\t\\\n+#define ARM_PRINT_OPERAND_ADDRESS(STREAM, X)  \t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+    int is_minus = GET_CODE (X) == MINUS;\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (X) == REG)\t\t\t\t\t\\\n+      asm_fprintf (STREAM, \"[%r, #0]\", REGNO (X));\t\t\\\n+    else if (GET_CODE (X) == PLUS || is_minus)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\trtx base = XEXP (X, 0);\t\t\t\t\t\\\n+\trtx index = XEXP (X, 1);\t\t\t\t\\\n+\tHOST_WIDE_INT offset = 0;\t\t\t\t\\\n+\tif (GET_CODE (base) != REG)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    /* Ensure that BASE is a register */ \t\t\\\n+            /* (one of them must be). */\t\t\t\\\n+\t    rtx temp = base;\t\t\t\t\t\\\n+\t    base = index;\t\t\t\t\t\\\n+\t    index = temp;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tswitch (GET_CODE (index))\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t  case CONST_INT:\t\t\t\t\t\\\n+\t    offset = INTVAL (index);\t\t\t\t\\\n+\t    if (is_minus)\t\t\t\t\t\\\n+\t      offset = -offset;\t\t\t\t\t\\\n+\t    asm_fprintf (STREAM, \"[%r, #%d]\", \t\t\t\\\n+\t\t         REGNO (base), offset);\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  case REG:\t\t\t\t\t\t\\\n+\t    asm_fprintf (STREAM, \"[%r, %s%r]\", \t\t\t\\\n+\t\t     REGNO (base), is_minus ? \"-\" : \"\",\t\t\\\n+\t\t     REGNO (index));\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  case MULT:\t\t\t\t\t\t\\\n+\t  case ASHIFTRT:\t\t\t\t\t\\\n+\t  case LSHIFTRT:\t\t\t\t\t\\\n+\t  case ASHIFT:\t\t\t\t\t\t\\\n+\t  case ROTATERT:\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    asm_fprintf (STREAM, \"[%r, %s%r\", \t\t\t\\\n+\t\t         REGNO (base), is_minus ? \"-\" : \"\", \t\\\n+                         REGNO (XEXP (index, 0)));\t\t\\\n+\t    arm_print_operand (STREAM, index, 'S');\t\t\\\n+\t    fputs (\"]\", STREAM);\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t    \t\t\t\t\t\t\t\\\n+\t  default:\t\t\t\t\t\t\\\n+\t    abort();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t        \\\n+  else if (   GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_INC\\\n+\t   || GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_DEC)\\\n+    {\t\t\t\t\t\t\t\t\\\n+      extern int output_memory_reference_mode;\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 0)) != REG)\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\\\n+\tasm_fprintf (STREAM, \"[%r, #%s%d]!\", \t\t\t\\\n+\t\t     REGNO (XEXP (X, 0)),\t\t\t\\\n+\t\t     GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\\\n+\t\t     GET_MODE_SIZE (output_memory_reference_mode));\\\n+      else\t\t\t\t\t\t\t\\\n+\tasm_fprintf (STREAM, \"[%r], #%s%d\", \t\t\t\\\n+\t\t     REGNO (XEXP (X, 0)),\t\t\t\\\n+\t\t     GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\\\n+\t\t     GET_MODE_SIZE (output_memory_reference_mode));\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else output_addr_const (STREAM, X);\t\t\t\t\\\n }\n \n+#define THUMB_PRINT_OPERAND_ADDRESS(STREAM, X)\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == REG)\t\t\t\t\\\n+    asm_fprintf (STREAM, \"[%r]\", REGNO (X));\t\t\\\n+  else if (GET_CODE (X) == POST_INC)\t\t\t\\\n+    asm_fprintf (STREAM, \"%r!\", REGNO (XEXP (X, 0)));\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\\\n+\tasm_fprintf (STREAM, \"[%r, #%d]\", \t\t\\\n+\t\t     REGNO (XEXP (X, 0)),\t\t\\\n+\t\t     (int) INTVAL (XEXP (X, 1)));\t\\\n+      else\t\t\t\t\t\t\\\n+\tasm_fprintf (STREAM, \"[%r, %r]\",\t\t\\\n+\t\t     REGNO (XEXP (X, 0)),\t\t\\\n+\t\t     REGNO (XEXP (X, 1)));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    output_addr_const (STREAM, X);\t\t\t\\\n+}\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM, X)\t\\\n+  if (TARGET_ARM)\t\t\t\t\\\n+    ARM_PRINT_OPERAND_ADDRESS (STREAM, X)\t\\\n+  else\t\t\t\t\t\t\\\n+    THUMB_PRINT_OPERAND_ADDRESS (STREAM, X)\n+     \n /* Handles PIC addr specially */\n-#define OUTPUT_INT_ADDR_CONST(STREAM,X) \t\t\t\t\\\n+#define OUTPUT_INT_ADDR_CONST(STREAM, X) \t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (flag_pic && GET_CODE (X) == CONST && is_pic (X))\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -2217,7 +2753,8 @@ extern struct rtx_def * arm_compare_op1;\n \toutput_addr_const (STREAM, XEXP (XEXP (XEXP (X, 0), 1), 0));\t\\\n \tfputs (\")\", STREAM);\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    else output_addr_const (STREAM, X);\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      output_addr_const (STREAM, X);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* Mark symbols as position independent.  We only do this in the\t\\\n       .text segment, not in the .data segment. */\t\t\t\\\n@@ -2269,10 +2806,12 @@ extern struct rtx_def * arm_compare_op1;\n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.  */\n \n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n-  ((COUNT == 0)\t\t\t\t\\\n-   ? gen_rtx_MEM (Pmode, plus_constant (FRAME, -4)) \\\n-   : NULL_RTX)\n+#define RETURN_ADDR_RTX(COUNT, FRAME) \\\n+  arm_return_addr (COUNT, FRAME)\n+\n+/* Mask of the bits in the PC that contain the real return address \n+   when running in 26-bit mode.  */\n+#define RETURN_ADDR_MASK26 (0x03fffffc)\n \n /* Pick up the return address upon entry to a procedure. Used for\n    dwarf2 unwind information.  This also enables the table driven\n@@ -2288,6 +2827,40 @@ extern struct rtx_def * arm_compare_op1;\n      in 26 bit mode, the condition codes must be masked out of the\t\\\n      return address.  This does not apply to ARM6 and later processors\t\\\n      when running in 32 bit mode.  */\t\t\t\t\t\\\n-  ((!TARGET_APCS_32) ? (GEN_INT (0x03fffffc)) : (GEN_INT (0xffffffff)))\n+  ((!TARGET_APCS_32) ? (GEN_INT (RETURN_ADDR_MASK26))\t\t\t\\\n+   : (GEN_INT ((unsigned long)0xffffffff)))\n+\n+\f\n+/* Define the codes that are matched by predicates in arm.c */\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  {\"s_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"f_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"arm_add_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"fpu_add_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"fpu_rhs_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"arm_rhs_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"arm_not_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"reg_or_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"index_operand\",      {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"thumb_cmp_operand\",  {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"offsettable_memory_operand\", {MEM}},\t\t\t\t\\\n+  {\"bad_signed_byte_operand\", {MEM}},\t\t\t\t\t\\\n+  {\"alignable_memory_operand\", {MEM}},\t\t\t\t\t\\\n+  {\"shiftable_operator\", {PLUS, MINUS, AND, IOR, XOR}},\t\t\t\\\n+  {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\\n+  {\"shift_operator\", {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATERT, MULT}},\t\\\n+  {\"di_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}},\t\t\\\n+  {\"nonimmediate_di_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+  {\"soft_df_operand\", {SUBREG, REG, CONST_DOUBLE, MEM}},\t\t\\\n+  {\"nonimmediate_soft_df_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+  {\"load_multiple_operation\",  {PARALLEL}},\t\t\t\t\\\n+  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n+  {\"equality_operator\", {EQ, NE}},\t\t\t\t\t\\\n+  {\"arm_rhsm_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n+  {\"const_shift_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"multi_register_push\", {PARALLEL}},\t\t\t\t\t\\\n+  {\"cc_register\", {REG}},\t\t\t\t\t\t\\\n+  {\"logical_binary_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n+  {\"dominant_cc_register\", {REG}},\n \n #endif /* __ARM_H__ */"}, {"sha": "e67f133fcef708007b895f811be44f92c6cb0de6", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2934, "deletions": 1370, "changes": 4304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96"}, {"sha": "a083be903acabaf42a72169ff8ed675fdc20731e", "filename": "gcc/config/arm/coff.h", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcoff.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,7 +1,7 @@\n-/* Definitions of target machine for GNU compiler,\n-   for ARM with COFF obj format.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n-   Contributed by Doug Evans (dje@cygnus.com).\n+/* Definitions of target machine for GNU compiler.\n+   For ARM with COFF object format.\n+   Copyright (C) 1995 - 1999 Free Software Foundation, Inc.\n+   Contributed by Doug Evans (devans@cygnus.com).\n    \n This file is part of GNU CC.\n \n@@ -20,8 +20,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include \"arm/semi.h\"\n-#include \"arm/aout.h\"\n+#include \"semi.h\"\n+#include \"aout.h\"\n \n /* Note - it is important that this definition matches the one in tcoff.h */\n #undef  USER_LABEL_PREFIX\n@@ -33,9 +33,12 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_VERSION fputs (\" (ARM/coff)\", stderr)\n \n #undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32)\n+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n \n-#define MULTILIB_DEFAULTS { \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n+#ifndef MULTILIB_DEFAULTS\n+#define MULTILIB_DEFAULTS \\\n+  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n+#endif\n \f\n /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n    is a valid machine specific attribute for DECL.\n@@ -70,16 +73,13 @@ Boston, MA 02111-1307, USA.  */\n       fprintf (STREAM, \"%s Generated by gcc %s for ARM/coff\\n\",\t\\\n \t       ASM_COMMENT_START, version_string);\t\t\\\n       fprintf (STREAM, ASM_APP_OFF);\t\t\t\t\\\n-      if (write_symbols == SDB_DEBUG)\t\t\t\t\\\n-\toutput_file_directive (STREAM, main_input_filename);\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* A C statement to output something to the assembler file to switch to section\n-   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+/* A C statement to output something to the assembler file to switch to\n+   section NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n    NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n    define this macro in such cases.  */\n-#undef  ASM_OUTPUT_SECTION_NAME\n #define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -130,36 +130,36 @@ Boston, MA 02111-1307, USA.  */\n #define SUBTARGET_EXTRA_SECTION_FUNCTIONS\n \n #define RDATA_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-rdata_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_rdata)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\t\\\n-      in_section = in_rdata;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+rdata_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rdata)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\\\n+      in_section = in_rdata;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n #define CTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-ctors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_ctors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_ctors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n #define DTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-dtors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_dtors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_dtors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \f\n /* Support the ctors/dtors sections for g++.  */\n@@ -198,6 +198,14 @@ dtors_section ()\t\t\t\t\t\t\t\\\n #undef DO_GLOBAL_CTORS_BODY\n #undef DO_GLOBAL_DTORS_BODY\n \n+/* If you don't define HAVE_ATEXIT, and the object file format/OS/whatever \n+   does not support constructors/destructors, then gcc implements destructors\n+   by defining its own exit function, which calls the destructors.  This gcc\n+   exit function overrides the C library's exit function, and this can cause\n+   all kinds of havoc if the C library has a non-trivial exit function.  You\n+   really don't want to use the exit function in libgcc2.c.  */\n+#define HAVE_ATEXIT\n+\n /* The ARM development system defines __main.  */\n #define NAME__MAIN  \"__gccmain\"\n #define SYMBOL__MAIN __gccmain"}, {"sha": "44ce91313767035d6305e0b7f683f4f2e3a2843d", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,6 +1,6 @@\n-/* Definitions of target machine for GNU compiler,\n-   for ARM with ELF obj format.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+/* Definitions of target machine for GNU compiler.\n+   For ARM with ELF obj format.\n+   Copyright (C) 1995 - 1999 Free Software Foundation, Inc.\n    Contributed by Philip Blundell <philb@gnu.org> and\n    Catherine Moore <clm@cygnus.com>\n    \n@@ -36,6 +36,22 @@ Boston, MA 02111-1307, USA.  */\n #define SUBTARGET_CPP_SPEC  \"-Darm_elf -D__ELF__\"\n #endif\n \n+#ifndef SUBTARGET_EXTRA_ASM_SPEC\n+#define SUBTARGET_EXTRA_ASM_SPEC\n+#endif\n+\n+#ifndef ASM_SPEC\n+#define ASM_SPEC \"\\\n+%{mbig-endian:-EB} \\\n+%{mcpu=*:-m%*} \\\n+%{march=*:-m%*} \\\n+%{mapcs-*:-mapcs-%*} \\\n+%{mapcs-float:-mfloat} \\\n+%{msoft-float:-mno-fpu} \\\n+%{mthumb-interwork:-mthumb-interwork} \\\n+\" SUBTARGET_EXTRA_ASM_SPEC\n+#endif\n+\n /* The following macro defines the format used to output the second\n    operand of the .type assembler directive.  Different svr4 assemblers\n    expect various different forms for this operand.  The one given here\n@@ -151,11 +167,6 @@ Boston, MA 02111-1307, USA.  */\n    Otherwise, the readonly data section is used.  */\n #define JUMP_TABLES_IN_TEXT_SECTION 1\n \n-#ifndef ASM_SPEC\n-#define ASM_SPEC \"%{mbig-endian:-EB} %{mcpu=*:-m%*} %{march=*:-m%*} \\\n- %{mapcs-*:-mapcs-%*} %{mthumb-interwork:-mthumb-interwork} %{mapcs-float:mfloat}\"\n-#endif\n-\n #ifndef LINK_SPEC\n #define LINK_SPEC \"%{mbig-endian:-EB} -X\"\n #endif\n@@ -166,11 +177,12 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32)\n+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n #endif\n \n #ifndef MULTILIB_DEFAULTS\n-#define MULTILIB_DEFAULTS { \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n+#define MULTILIB_DEFAULTS \\\n+  { \"marm\", \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\", \"fno-leading-underscore\" }\n #endif\n \n /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n@@ -275,30 +287,48 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n #ifndef CTORS_SECTION_FUNCTION\n-#define CTORS_SECTION_FUNCTION \t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-ctors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_ctors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define CTORS_SECTION_FUNCTION \t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_ctors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n #endif\n \n #ifndef DTORS_SECTION_FUNCTION\n-#define DTORS_SECTION_FUNCTION \t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-dtors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_dtors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define DTORS_SECTION_FUNCTION \t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_dtors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n #endif\n+\n+/* A C statement to output something to the assembler file to switch to\n+   section NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL\n+   or NULL_TREE.  */\n+#undef  ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)        \t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t  \t\\\n+      if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t  \t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"ax\\\",%%progbits\\n\", NAME);\t\\\n+      else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t  \t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"a\\\"\\n\", NAME);\t\t\\\n+      else if (! strncmp (NAME, \".bss\", 4))      \t\t\t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"aw\\\",%%nobits\\n\", NAME);\t\\\n+      else\t\t\t\t\t\t\t \t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"aw\\\"\\n\", NAME);\t  \t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Support the ctors/dtors sections for g++.  */\n #ifndef INT_ASM_OP\n@@ -367,4 +397,4 @@ dtors_section ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n-#include \"arm/aout.h\"\n+#include \"aout.h\""}, {"sha": "07f69b55785d8ee8b136d6dcb33a8dab29e42587", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 546, "deletions": 49, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,7 +1,7 @@\n @ libgcc1 routines for ARM cpu.\n @ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)\n \n-/* Copyright (C) 1995, 1996, 1998 Free Software Foundation, Inc.\n+/* Copyright (C) 1995, 1996, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -34,12 +34,12 @@ Boston, MA 02111-1307, USA.  */\n    the executable file might be covered by the GNU General Public License.  */\n \n #ifdef __APCS_26__\n-#define RET\tmovs\n-#define RETc(x)\tmov##x##s\n+#define RET\tmovs\tpc, lr\n+#define RETc(x)\tmov##x##s\tpc, lr\n #define RETCOND ^\n #else\n-#define RET\tmov\n-#define RETc(x)\tmov##x\n+#define RET\tmov\tpc, lr\n+#define RETc(x)\tmov##x\tpc, lr\n #define RETCOND\n #endif\n \n@@ -57,7 +57,11 @@ Boston, MA 02111-1307, USA.  */\n #define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n \n #ifdef __ELF__\n+#ifdef __thumb__\n+#define __PLT__  /* Not supported in thumb assembler (for now).  */\n+#else\n #define __PLT__ (PLT)\n+#endif\n #define TYPE(x) .type SYM(x),function\n #define SIZE(x) .size SYM(x), . - SYM(x)\n #else\n@@ -66,6 +70,28 @@ Boston, MA 02111-1307, USA.  */\n #define SIZE(x)\n #endif\n \n+#ifdef __thumb__\n+#define THUMB_FUNC .thumb_func\n+#define THUMB_CODE .force_thumb\n+#else\n+#define THUMB_FUNC\n+#define THUMB_CODE\n+#endif\n+\t\n+\t\n+.macro FUNC_START name\n+\t.text\n+\t.globl SYM (__\\name)\n+\tTYPE (__\\name)\n+\t.align 0\n+\tTHUMB_CODE\n+\tTHUMB_FUNC\n+SYM (__\\name):\n+.endm\n+\n+/* Used for Thumb code.  */\t\n+work\t\t.req\tr4\t@ XXXX is this safe ?\n+\n #ifdef L_udivsi3\n \n dividend\t.req\tr0\n@@ -77,12 +103,99 @@ sp\t\t.req\tr13\n lr\t\t.req\tr14\n pc\t\t.req\tr15\n \t\n-\t.text\n-\t.globl\tSYM (__udivsi3)\n-\tTYPE \t(__udivsi3)\n-\t.align\t0\n+ FUNC_START udivsi3\n+\n+#ifdef __thumb__\n \n-SYM (__udivsi3):\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tmov\tcurbit, #1\n+\tmov\tresult, #0\n+\t\n+\tpush\t{ work }\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\n+\t@ Load the constant 0x10000000 into our work register\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tbcs     Lbignum\n+\tcmp\tdivisor, dividend\n+\tbcs     Lbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit,  #4\n+\tb\tLoop1\n+\n+Lbignum:\n+\t@ Set work to 0x80000000\n+\tlsl\twork, #3\n+Loop2:\t\t\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, work\n+\tbcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tbcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit,  #1\n+\tb\tLoop2\n+\n+Loop3:\n+\t@ Test for possible subtractions, and note which bits\n+\t@ are done in the result.  On the final pass, this may subtract\n+\t@ too much from the dividend, but the result will be ok, since the\n+\t@ \"bit\" will have been shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tbcc     Over1\n+\tsub\tdividend, dividend, divisor\n+\torr\tresult, result, curbit\n+Over1:\t\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tbcc\tOver2\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #1\n+\torr\tresult, work\n+Over2:\t\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tbcc\tOver3\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #2\n+\torr\tresult, work\n+Over3:\t\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tbcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #3\n+\torr\tresult, work\n+Over4:\t\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tbeq\tLgot_result\n+\tlsr\tcurbit,  #4\t\t\t@ No, any more bits to do?\n+\tbeq\tLgot_result\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+Lgot_result:\n+\tmov\tr0, result\n+\tpop\t{ work }\n+\tRET\n+\n+Ldiv0:\n+\tpush\t{ lr }\n+\tbl\tSYM (__div0) __PLT__\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\n+#else /* arm version */\n+\t\n \tcmp\tdivisor, #0\n \tbeq\tLdiv0\n \tmov\tcurbit, #1\n@@ -132,15 +245,17 @@ Loop3:\n \tbne\tLoop3\n Lgot_result:\n \tmov\tr0, result\n-\tRET\tpc, lr\n+\tRET\t\n \n Ldiv0:\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ about as wrong as it could be\n \tldmia\tsp!, {pc}RETCOND\n \n-\tSIZE\t(__udivsi3)\n+#endif /* arm version */\n+\t\n+ SIZE\t(__udivsi3)\n \n #endif /* L_udivsi3 */\n \n@@ -155,17 +270,147 @@ sp\t\t.req\tr13\n lr\t\t.req\tr14\n pc\t\t.req\tr15\n \t\n-\t.text\n-\t.globl\tSYM (__umodsi3)\n-\tTYPE\t(__umodsi3)\n-\t.align 0\n+ FUNC_START umodsi3\n+\n+#ifdef __thumb__\n \n-SYM (__umodsi3):\n \tcmp\tdivisor, #0\n \tbeq\tLdiv0\n \tmov\tcurbit, #1\n \tcmp\tdividend, divisor\n-\tRETc(cc)\tpc, lr\n+\tbcs\tOver1\n+\tRET\t\n+\n+Over1:\t\n+\t@ Load the constant 0x10000000 into our work register\n+\tpush\t{ work }\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tbcs\tLbignum\n+\tcmp\tdivisor, dividend\n+\tbcs\tLbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit, #4\n+\tb\tLoop1\n+Lbignum:\n+\t@ Set work to 0x80000000\n+\tlsl\twork, #3\n+Loop2:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, work\n+\tbcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tbcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit, #1\n+\tb\tLoop2\n+Loop3:\n+\t@ Test for possible subtractions.  On the final pass, this may \n+\t@ subtract too much from the dividend, so keep track of which\n+\t@ subtractions are done, we can fix them up afterwards...\n+\tmov\toverdone, #0\n+\tcmp\tdividend, divisor\n+\tbcc\tOver2\n+\tsub\tdividend, dividend, divisor\n+Over2:\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tbcc\tOver3\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over3:\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tbcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over4:\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tbcc\tOver5\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over5:\n+\tmov\tip, curbit\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tbeq\tOver6\n+\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n+\tbeq\tOver6\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+Over6:\t\n+\t@ Any subtractions that we should not have done will be recorded in\n+\t@ the top three bits of \"overdone\".  Exactly which were not needed\n+\t@ are governed by the position of the bit, stored in ip.\n+\t@ If we terminated early, because dividend became zero,\n+\t@ then none of the below will match, since the bit in ip will not be\n+\t@ in the bottom nibble.\n+\n+\tmov\twork, #0xe\n+\tlsl\twork, #28\t\n+\tand\toverdone, work\n+\tbne\tOver7\n+\tpop\t{ work }\n+\tRET\t\t\t\t\t@ No fixups needed\n+Over7:\n+\tmov\tcurbit, ip\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver8\n+\tlsr\twork, divisor, #3\n+\tadd\tdividend, dividend, work\n+Over8:\n+\tmov\tcurbit, ip\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver9\n+\tlsr\twork, divisor, #2\n+\tadd\tdividend, dividend, work\n+Over9:\n+\tmov\tcurbit, ip\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver10\n+\tlsr\twork, divisor, #1\n+\tadd\tdividend, dividend, work\n+Over10:\n+\tpop\t{ work }\n+\tRET\t\n+Ldiv0:\n+\tpush\t{ lr }\n+\tbl\tSYM (__div0) __PLT__\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\n+#else  /* arm version */\n+\t\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tmov\tcurbit, #1\n+\tcmp\tdividend, divisor\n+\tRETc(cc)\n Loop1:\n \t@ Unless the divisor is very big, shift it up in multiples of\n \t@ four bits, since this is the amount of unwinding in the main\n@@ -215,22 +460,24 @@ Loop3:\n \t@ then none of the below will match, since the bit in ip will not be\n \t@ in the bottom nibble.\n \tands\toverdone, overdone, #0xe0000000\n-\tRETc(eq)\tpc, lr\t\t\t\t@ No fixups needed\n+\tRETc(eq)\t\t\t\t@ No fixups needed\n \ttst\toverdone, ip, ror #3\n \taddne\tdividend, dividend, divisor, lsr #3\n \ttst\toverdone, ip, ror #2\n \taddne\tdividend, dividend, divisor, lsr #2\n \ttst\toverdone, ip, ror #1\n \taddne\tdividend, dividend, divisor, lsr #1\n-\tRET\tpc, lr\n+\tRET\t\n \n Ldiv0:\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ about as wrong as it could be\n \tldmia\tsp!, {pc}RETCOND\n \n-\tSIZE\t(__umodsi3)\n+#endif /* arm version */\n+\t\n+ SIZE\t(__umodsi3)\n \n #endif /* L_umodsi3 */\n \n@@ -244,13 +491,114 @@ ip\t\t.req\tr12\n sp\t\t.req\tr13\n lr\t\t.req\tr14\n pc\t\t.req\tr15\n+\n+ FUNC_START divsi3\t\n+\n+#ifdef __thumb__\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n \t\n-\t.text\n-\t.globl\tSYM (__divsi3)\n-\tTYPE\t(__divsi3)\n-\t.align 0\n+\tpush\t{ work }\n+\tmov\twork, dividend\n+\teor\twork, divisor\t\t@ Save the sign of the result.\n+\tmov\tip, work\n+\tmov\tcurbit, #1\n+\tmov\tresult, #0\n+\tcmp\tdivisor, #0\n+\tbpl\tOver1\n+\tneg\tdivisor, divisor\t@ Loops below use unsigned.\n+Over1:\t\n+\tcmp\tdividend, #0\n+\tbpl\tOver2\n+\tneg\tdividend, dividend\n+Over2:\t\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tBcs\tLbignum\n+\tcmp\tdivisor, dividend\n+\tBcs\tLbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit, #4\n+\tb\tLoop1\n+\n+Lbignum:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tlsl\twork, #3\n+Loop2:\t\t\n+\tcmp\tdivisor, work\n+\tBcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tBcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit, #1\n+\tb\tLoop2\n+\n+Loop3:\n+\t@ Test for possible subtractions, and note which bits\n+\t@ are done in the result.  On the final pass, this may subtract\n+\t@ too much from the dividend, but the result will be ok, since the\n+\t@ \"bit\" will have been shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tBcc\tOver3\n+\tsub\tdividend, dividend, divisor\n+\torr\tresult, result, curbit\n+Over3:\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tBcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #1\n+\torr\tresult, work\n+Over4:\t\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tBcc\tOver5\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #2\n+\torr\tresult, result, work\n+Over5:\t\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tBcc\tOver6\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #3\n+\torr\tresult, result, work\n+Over6:\t\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tBeq\tLgot_result\n+\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n+\tBeq\tLgot_result\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+\t\n+Lgot_result:\n+\tmov\tr0, result\n+\tmov\twork, ip\n+\tcmp\twork, #0\n+\tBpl\tOver7\n+\tneg\tr0, r0\n+Over7:\n+\tpop\t{ work }\n+\tRET\t\n \n-SYM (__divsi3):\n+Ldiv0:\n+\tpush\t{ lr }\n+\tbl\tSYM (__div0) __PLT__\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\t\n+#else /* arm version */\n+\t\n \teor\tip, dividend, divisor\t\t@ Save the sign of the result.\n \tmov\tcurbit, #1\n \tmov\tresult, #0\n@@ -307,15 +655,17 @@ Lgot_result:\n \tmov\tr0, result\n \tcmp\tip, #0\n \trsbmi\tr0, r0, #0\n-\tRET\tpc, lr\n+\tRET\t\n \n Ldiv0:\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ about as wrong as it could be\n \tldmia\tsp!, {pc}RETCOND\n \n-\tSIZE\t(__divsi3)\n+#endif /* arm version */\n+\t\n+ SIZE\t(__divsi3)\n \n #endif /* L_divsi3 */\n \n@@ -330,12 +680,155 @@ sp\t\t.req\tr13\n lr\t\t.req\tr14\n pc\t\t.req\tr15\n \t\n-\t.text\n-\t.globl\tSYM (__modsi3)\n-\tTYPE\t(__modsi3)\n-\t.align 0\n+ FUNC_START modsi3\n+\n+#ifdef __thumb__\n \n-SYM (__modsi3):\n+\tmov\tcurbit, #1\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tBpl\tOver1\n+\tneg\tdivisor, divisor\t\t@ Loops below use unsigned.\n+Over1:\t\n+\tpush\t{ work }\n+\t@ Need to save the sign of the dividend, unfortunately, we need\n+\t@ ip later on.  Must do this after saving the original value of\n+\t@ the work register, because we will pop this value off first.\n+\tpush\t{ dividend }\n+\tcmp\tdividend, #0\n+\tBpl\tOver2\n+\tneg\tdividend, dividend\n+Over2:\t\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tbcs\tLbignum\n+\tcmp\tdivisor, dividend\n+\tbcs\tLbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit, #4\n+\tb\tLoop1\n+\n+Lbignum:\n+\t@ Set work to 0x80000000\n+\tlsl\twork, #3\n+Loop2:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, work\n+\tbcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tbcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit, #1\n+\tb\tLoop2\n+\n+Loop3:\n+\t@ Test for possible subtractions.  On the final pass, this may \n+\t@ subtract too much from the dividend, so keep track of which\n+\t@ subtractions are done, we can fix them up afterwards...\n+\tmov\toverdone, #0\n+\tcmp\tdividend, divisor\n+\tbcc\tOver3\n+\tsub\tdividend, dividend, divisor\n+Over3:\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tbcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over4:\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tbcc\tOver5\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over5:\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tbcc\tOver6\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over6:\n+\tmov\tip, curbit\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tbeq\tOver7\n+\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n+\tbeq\tOver7\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+\n+Over7:\t\n+\t@ Any subtractions that we should not have done will be recorded in\n+\t@ the top three bits of \"overdone\".  Exactly which were not needed\n+\t@ are governed by the position of the bit, stored in ip.\n+\t@ If we terminated early, because dividend became zero,\n+\t@ then none of the below will match, since the bit in ip will not be\n+\t@ in the bottom nibble.\n+\tmov\twork, #0xe\n+\tlsl\twork, #28\n+\tand\toverdone, work\n+\tbeq\tLgot_result\n+\t\n+\tmov\tcurbit, ip\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver8\n+\tlsr\twork, divisor, #3\n+\tadd\tdividend, dividend, work\n+Over8:\n+\tmov\tcurbit, ip\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver9\n+\tlsr\twork, divisor, #2\n+\tadd\tdividend, dividend, work\n+Over9:\n+\tmov\tcurbit, ip\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tLgot_result\n+\tlsr\twork, divisor, #1\n+\tadd\tdividend, dividend, work\n+Lgot_result:\n+\tpop\t{ work }\n+\tcmp\twork, #0\n+\tbpl\tOver10\n+\tneg\tdividend, dividend\n+Over10:\n+\tpop\t{ work }\n+\tRET\t\n+\n+Ldiv0:\n+\tpush    { lr }\n+\tbl\tSYM (__div0) __PLT__\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\n+#else /* arm version */\n+\t\n \tmov\tcurbit, #1\n \tcmp\tdivisor, #0\n \trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n@@ -408,27 +901,27 @@ Lgot_result:\n \tldr\tip, [sp], #4\n \tcmp\tip, #0\n \trsbmi\tdividend, dividend, #0\n-\tRET\tpc, lr\n+\tRET\t\n \n Ldiv0:\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ about as wrong as it could be\n \tldmia\tsp!, {pc}RETCOND\n \n-\tSIZE\t(__modsi3)\n+#endif /* arm version */\n+\t\n+ SIZE\t(__modsi3)\n \n #endif /* L_modsi3 */\n \n #ifdef L_dvmd_tls\n \n-\t.globl\tSYM (__div0)\n-\tTYPE\t(__div0)\n-\t.align 0\n-SYM (__div0):\n-\tRET\tpc, lr\n+ FUNC_START div0\t\n \n-\tSIZE\t(__div0)\n+\tRET\t\n+\n+ SIZE\t(__div0)\n \t\n #endif /* L_divmodsi_tools */\n \n@@ -439,10 +932,8 @@ SYM (__div0):\n \t\n #define SIGFPE\t8\t\t\t@ cant use <asm/signal.h> as it\n \t\t\t\t\t@ contains too much C rubbish\n-\t.globl\tSYM (__div0)\n-\tTYPE\t(__div0)\n-\t.align 0\n-SYM (__div0):\n+ FUNC_START div0\t\n+\n \tstmfd\tsp!, {r1, lr}\n \tswi\t__NR_getpid\n \tcmn\tr0, #1000\n@@ -451,15 +942,18 @@ SYM (__div0):\n \tswi\t__NR_kill\n \tldmfd\tsp!, {r1, pc}RETCOND\n \n-\tSIZE \t(__div0)\n+ SIZE \t(__div0)\n \t\n #endif /* L_dvmd_lnx */\n \n /* These next two sections are here despite the fact that they contain Thumb \n    assembler because their presence allows interworked code to be linked even\n    when the GCC library is this one.  */\n \t\t\n-#ifdef L_call_via_rX\n+/* Do not build the interworking functions when the target cpu\n+   is the arm v3 architecture.  (This is one of the multilib\n+   options).  */\n+#if defined L_call_via_rX && ! defined __ARM_ARCH_3__\n \n /* These labels & instructions are used by the Arm/Thumb interworking code. \n    The address of function to be called is loaded into a register and then \n@@ -499,8 +993,11 @@ SYM (_call_via_\\register):\n \n #endif /* L_call_via_rX */\n \n-#ifdef L_interwork_call_via_rX\n-\n+/* Do not build the interworking functions when the target cpu\n+   is the arm v3 architecture.  (This is one of the multilib\n+   options).  */\n+#if defined L_interwork_call_via_rX && ! defined __ARM_ARCH_3__\n+\t\n /* These labels & instructions are used by the Arm/Thumb interworking code,\n    when the target address is in an unknown instruction set.  The address \n    of function to be called is loaded into a register and then one of these"}, {"sha": "daf8361097b1be95fac026f7456505ef92f10bce", "filename": "gcc/config/arm/lib1thumb.asm", "status": "removed", "additions": 0, "deletions": 749, "changes": 749, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Flib1thumb.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Flib1thumb.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1thumb.asm?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,749 +0,0 @@\n-@ libgcc1 routines for ARM cpu.\n-@ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)\n-\n-/* Copyright (C) 1995, 1996, 1998 Free Software Foundation, Inc.\n-\n-This file is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file with other programs, and to distribute\n-those programs without any restriction coming from the use of this\n-file.  (The General Public License restrictions do apply in other\n-respects; for example, they cover modification of the file, and\n-distribution when not linked into another program.)\n-\n-This file is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* As a special exception, if you link this library with other files,\n-   some of which are compiled with GCC, to produce an executable,\n-   this library does not by itself cause the resulting executable\n-   to be covered by the GNU General Public License.\n-   This exception does not however invalidate any other reasons why\n-   the executable file might be covered by the GNU General Public License.  */\n-\n-\t.code\t 16\n-\t\n-#ifndef __USER_LABEL_PREFIX__\n-#error  __USER_LABEL_PREFIX__ not defined\n-#endif\n-\n-#ifdef __elf__\n-#define __PLT__ (PLT)\n-#define TYPE(x) .type SYM(x),function\n-#define SIZE(x) .size SYM(x), . - SYM(x)\n-#else\n-#define __PLT__\n-#define TYPE(x)\n-#define SIZE(x)\n-#endif\n-\n-#define RET\tmov\tpc, lr\n-\t\n-/* ANSI concatenation macros.  */\n-\n-#define CONCAT1(a, b) CONCAT2(a, b)\n-#define CONCAT2(a, b) a ## b\n-\n-/* Use the right prefix for global labels.  */\n-\n-#define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n-\n-work\t\t.req\tr4\t@ XXXX is this safe ?\n-\n-#ifdef L_udivsi3\n-\n-dividend\t.req\tr0\n-divisor\t\t.req\tr1\n-result\t\t.req\tr2\n-curbit\t\t.req\tr3\n-ip\t\t.req\tr12\n-sp\t\t.req\tr13\n-lr\t\t.req\tr14\n-pc\t\t.req\tr15\n-\t\n-\t.text\n-\t.globl\tSYM (__udivsi3)\n-\tTYPE \t(__udivsi3)\n-\t.align\t0\n-\t.thumb_func\n-SYM (__udivsi3):\n-\tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n-\t\n-\tpush\t{ work }\n-\tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\n-\t@ Load the constant 0x10000000 into our work register\n-\tmov\twork, #1\n-\tlsl\twork, #28\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, work\n-\tbcs     Lbignum\n-\tcmp\tdivisor, dividend\n-\tbcs     Lbignum\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit,  #4\n-\tb\tLoop1\n-\n-Lbignum:\n-\t@ Set work to 0x80000000\n-\tlsl\twork, #3\n-Loop2:\t\t\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, work\n-\tbcs\tLoop3\n-\tcmp\tdivisor, dividend\n-\tbcs\tLoop3\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit,  #1\n-\tb\tLoop2\n-\n-Loop3:\n-\t@ Test for possible subtractions, and note which bits\n-\t@ are done in the result.  On the final pass, this may subtract\n-\t@ too much from the dividend, but the result will be ok, since the\n-\t@ \"bit\" will have been shifted out at the bottom.\n-\tcmp\tdividend, divisor\n-\tbcc     Over1\n-\tsub\tdividend, dividend, divisor\n-\torr\tresult, result, curbit\n-Over1:\t\n-\tlsr\twork, divisor, #1\n-\tcmp\tdividend, work\n-\tbcc\tOver2\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #1\n-\torr\tresult, work\n-Over2:\t\n-\tlsr\twork, divisor, #2\n-\tcmp\tdividend, work\n-\tbcc\tOver3\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #2\n-\torr\tresult, work\n-Over3:\t\n-\tlsr\twork, divisor, #3\n-\tcmp\tdividend, work\n-\tbcc\tOver4\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #3\n-\torr\tresult, work\n-Over4:\t\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tbeq\tLgot_result\n-\tlsr\tcurbit,  #4\t\t\t@ No, any more bits to do?\n-\tbeq\tLgot_result\n-\tlsr\tdivisor, #4\n-\tb\tLoop3\n-Lgot_result:\n-\tmov\tr0, result\n-\tpop\t{ work }\n-\tRET\n-\n-Ldiv0:\n-\tpush\t{ lr }\n-\tbl\tSYM (__div0) __PLT__\n-\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n-\tpop\t{ pc }\n-\n-\tSIZE\t(__udivsi3)\n-\t\n-#endif /* L_udivsi3 */\n-\n-#ifdef L_umodsi3\n-\n-dividend\t.req\tr0\n-divisor\t\t.req\tr1\n-overdone\t.req\tr2\n-curbit\t\t.req\tr3\n-ip\t\t.req\tr12\n-sp\t\t.req\tr13\n-lr\t\t.req\tr14\n-pc\t\t.req\tr15\n-\t\n-\t.text\n-\t.globl\tSYM (__umodsi3)\n-\tTYPE\t(__umodsi3)\n-\t.align\t0\n-\t.thumb_func\n-SYM (__umodsi3):\n-\tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tmov\tcurbit, #1\n-\tcmp\tdividend, divisor\n-\tbcs\tOver1\n-\tRET\t\n-\n-Over1:\t\n-\t@ Load the constant 0x10000000 into our work register\n-\tpush\t{ work }\n-\tmov\twork, #1\n-\tlsl\twork, #28\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, work\n-\tbcs\tLbignum\n-\tcmp\tdivisor, dividend\n-\tbcs\tLbignum\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit, #4\n-\tb\tLoop1\n-\n-Lbignum:\n-\t@ Set work to 0x80000000\n-\tlsl\twork, #3\n-Loop2:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, work\n-\tbcs\tLoop3\n-\tcmp\tdivisor, dividend\n-\tbcs\tLoop3\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit, #1\n-\tb\tLoop2\n-\n-Loop3:\n-\t@ Test for possible subtractions.  On the final pass, this may \n-\t@ subtract too much from the dividend, so keep track of which\n-\t@ subtractions are done, we can fix them up afterwards...\n-\tmov\toverdone, #0\n-\tcmp\tdividend, divisor\n-\tbcc\tOver2\n-\tsub\tdividend, dividend, divisor\n-Over2:\n-\tlsr\twork, divisor, #1\n-\tcmp\tdividend, work\n-\tbcc\tOver3\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #1\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over3:\n-\tlsr\twork, divisor, #2\n-\tcmp\tdividend, work\n-\tbcc\tOver4\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #2\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over4:\n-\tlsr\twork, divisor, #3\n-\tcmp\tdividend, work\n-\tbcc\tOver5\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #3\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over5:\n-\tmov\tip, curbit\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tbeq\tOver6\n-\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n-\tbeq\tOver6\n-\tlsr\tdivisor, #4\n-\tb\tLoop3\n-\n-Over6:\t\n-\t@ Any subtractions that we should not have done will be recorded in\n-\t@ the top three bits of \"overdone\".  Exactly which were not needed\n-\t@ are governed by the position of the bit, stored in ip.\n-\t@ If we terminated early, because dividend became zero,\n-\t@ then none of the below will match, since the bit in ip will not be\n-\t@ in the bottom nibble.\n-\n-\tmov\twork, #0xe\n-\tlsl\twork, #28\t\n-\tand\toverdone, work\n-\tbne\tOver7\n-\tpop\t{ work }\n-\tRET\t\t\t\t\t@ No fixups needed\n-Over7:\n-\tmov\tcurbit, ip\n-\tmov\twork, #3\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tOver8\n-\tlsr\twork, divisor, #3\n-\tadd\tdividend, dividend, work\n-Over8:\n-\tmov\tcurbit, ip\n-\tmov\twork, #2\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tOver9\n-\tlsr\twork, divisor, #2\n-\tadd\tdividend, dividend, work\n-Over9:\n-\tmov\tcurbit, ip\n-\tmov\twork, #1\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tOver10\n-\tlsr\twork, divisor, #1\n-\tadd\tdividend, dividend, work\n-Over10:\n-\tpop\t{ work }\n-\tRET\t\n-\n-Ldiv0:\n-\tpush\t{ lr }\n-\tbl\tSYM (__div0) __PLT__\n-\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n-\tpop\t{ pc }\n-\n-\tSIZE\t(__umodsi3)\n-\t\n-#endif /* L_umodsi3 */\n-\n-#ifdef L_divsi3\n-\n-dividend\t.req\tr0\n-divisor\t\t.req\tr1\n-result\t\t.req\tr2\n-curbit\t\t.req\tr3\n-ip\t\t.req\tr12\n-sp\t\t.req\tr13\n-lr\t\t.req\tr14\n-pc\t\t.req\tr15\n-\t\n-\t.text\n-\t.globl\tSYM (__divsi3)\n-\tTYPE\t(__divsi3)\n-\t.align\t0\n-\t.thumb_func\n-SYM (__divsi3):\n-\tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\t\n-\tpush\t{ work }\n-\tmov\twork, dividend\n-\teor\twork, divisor\t\t@ Save the sign of the result.\n-\tmov\tip, work\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n-\tcmp\tdivisor, #0\n-\tbpl\tOver1\n-\tneg\tdivisor, divisor\t@ Loops below use unsigned.\n-Over1:\t\n-\tcmp\tdividend, #0\n-\tbpl\tOver2\n-\tneg\tdividend, dividend\n-Over2:\t\n-\tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\n-\tmov\twork, #1\n-\tlsl\twork, #28\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, work\n-\tBcs\tLbignum\n-\tcmp\tdivisor, dividend\n-\tBcs\tLbignum\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit, #4\n-\tb\tLoop1\n-\n-Lbignum:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tlsl\twork, #3\n-Loop2:\t\t\n-\tcmp\tdivisor, work\n-\tBcs\tLoop3\n-\tcmp\tdivisor, dividend\n-\tBcs\tLoop3\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit, #1\n-\tb\tLoop2\n-\n-Loop3:\n-\t@ Test for possible subtractions, and note which bits\n-\t@ are done in the result.  On the final pass, this may subtract\n-\t@ too much from the dividend, but the result will be ok, since the\n-\t@ \"bit\" will have been shifted out at the bottom.\n-\tcmp\tdividend, divisor\n-\tBcc\tOver3\n-\tsub\tdividend, dividend, divisor\n-\torr\tresult, result, curbit\n-Over3:\n-\tlsr\twork, divisor, #1\n-\tcmp\tdividend, work\n-\tBcc\tOver4\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #1\n-\torr\tresult, work\n-Over4:\t\n-\tlsr\twork, divisor, #2\n-\tcmp\tdividend, work\n-\tBcc\tOver5\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #2\n-\torr\tresult, result, work\n-Over5:\t\n-\tlsr\twork, divisor, #3\n-\tcmp\tdividend, work\n-\tBcc\tOver6\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #3\n-\torr\tresult, result, work\n-Over6:\t\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tBeq\tLgot_result\n-\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n-\tBeq\tLgot_result\n-\tlsr\tdivisor, #4\n-\tb\tLoop3\n-\t\n-Lgot_result:\n-\tmov\tr0, result\n-\tmov\twork, ip\n-\tcmp\twork, #0\n-\tBpl\tOver7\n-\tneg\tr0, r0\n-Over7:\n-\tpop\t{ work }\n-\tRET\t\n-\n-Ldiv0:\n-\tpush\t{ lr }\n-\tbl\tSYM (__div0) __PLT__\n-\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n-\tpop\t{ pc }\n-\n-\tSIZE\t(__divsi3)\n-\t\n-#endif /* L_divsi3 */\n-\n-#ifdef L_modsi3\n-\n-dividend\t.req\tr0\n-divisor\t\t.req\tr1\n-overdone\t.req\tr2\n-curbit\t\t.req\tr3\n-ip\t\t.req\tr12\n-sp\t\t.req\tr13\n-lr\t\t.req\tr14\n-pc\t\t.req\tr15\n-\t\n-\t.text\n-\t.globl\tSYM (__modsi3)\n-\tTYPE\t(__modsi3)\n-\t.align\t0\n-\t.thumb_func\n-SYM (__modsi3):\n-\tmov\tcurbit, #1\n-\tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tBpl\tOver1\n-\tneg\tdivisor, divisor\t\t@ Loops below use unsigned.\n-Over1:\t\n-\tpush\t{ work }\n-\t@ Need to save the sign of the dividend, unfortunately, we need\n-\t@ ip later on.  Must do this after saving the original value of\n-\t@ the work register, because we will pop this value off first.\n-\tpush\t{ dividend }\n-\tcmp\tdividend, #0\n-\tBpl\tOver2\n-\tneg\tdividend, dividend\n-Over2:\t\n-\tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\tmov\twork, #1\n-\tlsl\twork, #28\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, work\n-\tbcs\tLbignum\n-\tcmp\tdivisor, dividend\n-\tbcs\tLbignum\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit, #4\n-\tb\tLoop1\n-\n-Lbignum:\n-\t@ Set work to 0x80000000\n-\tlsl\twork, #3\n-Loop2:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, work\n-\tbcs\tLoop3\n-\tcmp\tdivisor, dividend\n-\tbcs\tLoop3\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit, #1\n-\tb\tLoop2\n-\n-Loop3:\n-\t@ Test for possible subtractions.  On the final pass, this may \n-\t@ subtract too much from the dividend, so keep track of which\n-\t@ subtractions are done, we can fix them up afterwards...\n-\tmov\toverdone, #0\n-\tcmp\tdividend, divisor\n-\tbcc\tOver3\n-\tsub\tdividend, dividend, divisor\n-Over3:\n-\tlsr\twork, divisor, #1\n-\tcmp\tdividend, work\n-\tbcc\tOver4\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #1\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over4:\n-\tlsr\twork, divisor, #2\n-\tcmp\tdividend, work\n-\tbcc\tOver5\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #2\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over5:\n-\tlsr\twork, divisor, #3\n-\tcmp\tdividend, work\n-\tbcc\tOver6\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #3\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over6:\n-\tmov\tip, curbit\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tbeq\tOver7\n-\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n-\tbeq\tOver7\n-\tlsr\tdivisor, #4\n-\tb\tLoop3\n-\n-Over7:\t\n-\t@ Any subtractions that we should not have done will be recorded in\n-\t@ the top three bits of \"overdone\".  Exactly which were not needed\n-\t@ are governed by the position of the bit, stored in ip.\n-\t@ If we terminated early, because dividend became zero,\n-\t@ then none of the below will match, since the bit in ip will not be\n-\t@ in the bottom nibble.\n-\tmov\twork, #0xe\n-\tlsl\twork, #28\n-\tand\toverdone, work\n-\tbeq\tLgot_result\n-\t\n-\tmov\tcurbit, ip\n-\tmov\twork, #3\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tOver8\n-\tlsr\twork, divisor, #3\n-\tadd\tdividend, dividend, work\n-Over8:\n-\tmov\tcurbit, ip\n-\tmov\twork, #2\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tOver9\n-\tlsr\twork, divisor, #2\n-\tadd\tdividend, dividend, work\n-Over9:\n-\tmov\tcurbit, ip\n-\tmov\twork, #1\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tLgot_result\n-\tlsr\twork, divisor, #1\n-\tadd\tdividend, dividend, work\n-Lgot_result:\n-\tpop\t{ work }\n-\tcmp\twork, #0\n-\tbpl\tOver10\n-\tneg\tdividend, dividend\n-Over10:\n-\tpop\t{ work }\n-\tRET\t\n-\n-Ldiv0:\n-\tpush    { lr }\n-\tbl\tSYM (__div0) __PLT__\n-\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n-\tpop\t{ pc }\n-\t\n-\tSIZE\t(__modsi3)\n-\t\t\n-#endif /* L_modsi3 */\n-\n-#ifdef L_dvmd_tls\n-\n-\t.globl\tSYM (__div0)\n-\tTYPE\t(__div0)\n-\t.align\t0\n-\t.thumb_func\n-SYM (__div0):\n-\tRET\t\n-\n-\tSIZE\t(__div0)\n-\t\n-#endif /* L_divmodsi_tools */\n-\n-\t\n-#ifdef L_call_via_rX\n-\n-/* These labels & instructions are used by the Arm/Thumb interworking code. \n-   The address of function to be called is loaded into a register and then \n-   one of these labels is called via a BL instruction.  This puts the \n-   return address into the link register with the bottom bit set, and the \n-   code here switches to the correct mode before executing the function.  */\n-\t\n-\t.text\n-\t.align 0\n-\n-.macro call_via register\n-\t.globl\tSYM (_call_via_\\register)\n-\tTYPE\t(_call_via_\\register)\n-\t.thumb_func\n-SYM (_call_via_\\register):\n-\tbx\t\\register\n-\tnop\n-\t\n-\tSIZE\t(_call_via_\\register)\n-.endm\n-\n-\tcall_via r0\n-\tcall_via r1\n-\tcall_via r2\n-\tcall_via r3\n-\tcall_via r4\n-\tcall_via r5\n-\tcall_via r6\n-\tcall_via r7\n-\tcall_via r8\n-\tcall_via r9\n-\tcall_via sl\n-\tcall_via fp\n-\tcall_via ip\n-\tcall_via sp\n-\tcall_via lr\n-\n-#endif /* L_call_via_rX */\n-\n-#ifdef L_interwork_call_via_rX\n-\n-/* These labels & instructions are used by the Arm/Thumb interworking code,\n-   when the target address is in an unknown instruction set.  The address \n-   of function to be called is loaded into a register and then one of these\n-   labels is called via a BL instruction.  This puts the return address \n-   into the link register with the bottom bit set, and the code here \n-   switches to the correct mode before executing the function.  Unfortunately\n-   the target code cannot be relied upon to return via a BX instruction, so\n-   instead we have to store the resturn address on the stack and allow the\n-   called function to return here instead.  Upon return we recover the real\n-   return address and use a BX to get back to Thumb mode.  */\n-\t\n-\t.text\n-\t.align 0\n-\n-\t.code 32\n-\t.globl _arm_return\n-_arm_return:\t\t\n-\tldmia \tr13!, {r12}\n-\tbx \tr12\n-\t\n-.macro interwork register\t\t\t\t\t\n-\t.code 16\n-\t\n-\t.globl\tSYM (_interwork_call_via_\\register)\n-\tTYPE\t(_interwork_call_via_\\register)\n-\t.thumb_func\n-SYM (_interwork_call_via_\\register):\n-\tbx \tpc\n-\tnop\n-\t\n-\t.code 32\n-\t.globl .Lchange_\\register\n-.Lchange_\\register:\n-\ttst\t\\register, #1\n-\tstmeqdb\tr13!, {lr}\n-\tadreq\tlr, _arm_return\n-\tbx\t\\register\n-\n-\tSIZE\t(_interwork_call_via_\\register)\n-.endm\n-\t\n-\tinterwork r0\n-\tinterwork r1\n-\tinterwork r2\n-\tinterwork r3\n-\tinterwork r4\n-\tinterwork r5\n-\tinterwork r6\n-\tinterwork r7\n-\tinterwork r8\n-\tinterwork r9\n-\tinterwork sl\n-\tinterwork fp\n-\tinterwork ip\n-\tinterwork sp\n-\n-\t/* The lr case has to be handled a little differently...*/\n-\t.code 16\n-\t.globl\tSYM (_interwork_call_via_lr)\n-\tTYPE\t(_interwork_call_via_lr)\n-\t.thumb_func\n-SYM (_interwork_call_via_lr):\n-\tbx \tpc\n-\tnop\n-\t\n-\t.code 32\n-\t.globl .Lchange_lr\n-.Lchange_lr:\n-\ttst\tlr, #1\n-\tstmeqdb\tr13!, {lr}\n-\tmov\tip, lr\n-\tadreq\tlr, _arm_return\n-\tbx\tip\n-\n-\tSIZE\t(_interwork_call_via_lr)\n-\t\n-#endif /* L_interwork_call_via_rX */\n-\n-\t"}, {"sha": "f357d67e4d113b31b591a0db5ea2dbc296b1b0e8", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -38,7 +38,7 @@ Boston, MA 02111-1307, USA.  */\n # define SUBTARGET_EXTRA_ASM_SPEC\t\\\n \t\" %{mapcs-26:-mapcs-26} %{!mapcs-26:-mapcs-32}\"\n # define MULTILIB_DEFAULTS \\\n-\t{ \"mlittle-endian\", \"mhard-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n+\t{ \"marm\", \"mlittle-endian\", \"mhard-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n # define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_32__\"\n #else\t/* default is APCS-26 */\n # define TARGET_DEFAULT (ARM_FLAG_MMU_TRAPS)\n@@ -52,7 +52,7 @@ Boston, MA 02111-1307, USA.  */\n # define SUBTARGET_EXTRA_ASM_SPEC\t\\\n \t\" %{mapcs-32:-mapcs-32} %{!mapcs-32:-mapcs-26}\"\n # define MULTILIB_DEFAULTS \\\n-\t{ \"mlittle-endian\", \"mhard-float\", \"mapcs-26\", \"mno-thumb-interwork\" }\n+\t{ \"marm\", \"mlittle-endian\", \"mhard-float\", \"mapcs-26\", \"mno-thumb-interwork\" }\n #endif\n \n /* This was defined in linux.h.  Define it here also. */\n@@ -103,13 +103,6 @@ Boston, MA 02111-1307, USA.  */\n    %{mbig-endian:-EB}\" \\\n    SUBTARGET_EXTRA_LINK_SPEC\n \n-#define ASM_SPEC \"%{mbig-endian:-EB} \\\n-   %{mcpu=*:-m%*} %{march=*:-m%*} \\\n-   %{mthumb-interwork:-mthumb-interwork} \\\n-   %{msoft-float:-mno-fpu} \\\n-   %{mapcs-float:-mfloat}\" \\\n-   SUBTARGET_EXTRA_ASM_SPEC\n-\n #undef  CPP_PREDEFINES\n #define CPP_PREDEFINES \\\n \"-Dunix -D__arm__ -Dlinux -D__ELF__ \\\n@@ -166,6 +159,8 @@ do {\t\t\t\t \t\t\t\t\\\n    definition in the target-specific file which includes this file.  */\n #define SUBTARGET_EXTRA_SECTION_FUNCTIONS\tCONST_SECTION_FUNCTION\n \n+extern void text_section ();\n+\n #define CONST_SECTION_ASM_OP\t\".section\\t.rodata\"\n \n #define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n@@ -302,8 +297,8 @@ const_section ()\t\t\t\t\t\t\t\\\n #define FP_DEFAULT FP_SOFT3\n \n /* Call the function profiler with a given profile label.  */\n-#undef  FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(STREAM, LABELNO)  \t\t\t\t\\\n+#undef  ARM_FUNCTION_PROFILER\n+#define ARM_FUNCTION_PROFILER(STREAM, LABELNO)  \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\tbl\\tmcount%s\\n\", NEED_PLT_RELOC ? \"(PLT)\" : \"\");\t\\\n }"}, {"sha": "dd730d864726195ea59621dc99a16f82b5eac446", "filename": "gcc/config/arm/linux-telf.h", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Flinux-telf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Flinux-telf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-telf.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,202 +0,0 @@\n-/* Definitions for Thumb running Linux-based GNU systems using ELF\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n-   Contributed by Philip Blundell <philb@gnu.org>\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define SUBTARGET_EXTRA_ASM_SPEC\t\\\n-\t\" %{fPIC:-k} %{fpic:-k}\"\n-\n-/* This was defined in linux.h.  Define it here also. */\n-#undef  DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS   1\n-\n-/* Handle #pragma weak and #pragma pack.  */\n-#define HANDLE_SYSV_PRAGMA\n-\n-/* Now we define the strings used to build the spec file.  */\n-#define LIB_SPEC \\\n-  \"%{shared: -lc} \\\n-   %{!shared: %{pthread:-lpthread} \\\n-\t%{profile:-lc_p} %{!profile: -lc}}\"\n-\n-/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add\n-   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which\n-   provides part of the support for getting C++ file-scope static\n-   object constructed before entering `main'. */\n-   \n-#define STARTFILE_SPEC \\\n-  \"%{!shared: \\\n-     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \\\n-\t\t       %{!p:%{profile:gcrt1.o%s} \\\n-\t\t\t %{!profile:crt1.o%s}}}} \\\n-   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}\"\n-\n-/* Provide a ENDFILE_SPEC appropriate for GNU/Linux.  Here we tack on\n-   the GNU/Linux magical crtend.o file (see crtstuff.c) which\n-   provides part of the support for getting C++ file-scope static\n-   object constructed before entering `main', followed by a normal\n-   GNU/Linux \"finalizer\" file, `crtn.o'.  */\n-\n-#define ENDFILE_SPEC \\\n-  \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s\"\n-\n-#define LINK_SPEC \"%{h*} %{version:-v} \\\n-   %{b} %{Wl,*:%*} \\\n-   %{static:-Bstatic} \\\n-   %{shared:-shared} \\\n-   %{symbolic:-Bsymbolic} \\\n-   %{rdynamic:-export-dynamic} \\\n-   %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2} \\\n-   -X -mno-fpu -p \\\n-   %{mbig-endian:-EB} \\\n-   -m armelf_linux\"\n-\n-#define CPP_PREDEFINES \\\n-  \"-Dunix -Dthumb -D__thumb -Dlinux \\\n--Asystem(unix) -Asystem(posix) -Acpu(arm) \\\n--Amachine(arm) -D__ELF__\"\n-\n-/* Allow #sccs in preprocessor.  */\n-#define SCCS_DIRECTIVE\n-\n-#define USER_LABEL_PREFIX \t\"\"\t/* For ELF the default is no underscores */\n-#define LOCAL_LABEL_PREFIX \t\".\"\n-\n-/* Attach a special .ident directive to the end of the file to identify\n-   the version of GCC which compiled this code.  */\n-#define IDENT_ASM_OP \t\".ident\"\n-\n-/* Output #ident as a .ident.  */\n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  fprintf (FILE, \"\\t%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n-  \n-#ifdef IDENTIFY_WITH_IDENT\n-#define ASM_IDENTIFY_GCC(FILE) /* nothing */\n-#define ASM_IDENTIFY_LANGUAGE(FILE)\t\t\t\\\n- fprintf (FILE, \"\\t%s \\\"GCC (%s) %s\\\"\\n\", IDENT_ASM_OP,\t\\\n-\t lang_identify (), version_string)\n-#else\n-#define ASM_FILE_END(FILE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t \t\t\t\\\n-      if (!flag_no_ident)\t\t\t\t\\\n-\tfprintf (FILE, \"\\t%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\\\n-\t\t IDENT_ASM_OP, version_string);\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-#endif\n-\n-/* Support const sections and the ctors and dtors sections for g++.\n-   Note that there appears to be two different ways to support const\n-   sections at the moment.  You can either #define the symbol\n-   READONLY_DATA_SECTION (giving it some code which switches to the\n-   readonly data section) or else you can #define the symbols\n-   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n-   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n-#define USE_CONST_SECTION\t1\n-\n-/* Support for Constructors and Destructors.  */\n-#define READONLY_DATA_SECTION() const_section ()\n-\n-/* A default list of other sections which we might be \"in\" at any given\n-   time.  For targets that use additional sections (e.g. .tdesc) you\n-   should override this definition in the target-specific file which\n-   includes this file.  */\n-#define SUBTARGET_EXTRA_SECTIONS in_const,\n-\n-/* A default list of extra section function definitions.  For targets\n-   that use additional sections (e.g. .tdesc) you should override this\n-   definition in the target-specific file which includes this file.  */\n-#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\tCONST_SECTION_FUNCTION\n-\n-#define CONST_SECTION_ASM_OP\t\".section\\t.rodata\"\n-\n-#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-const_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n-    text_section ();\t\t\t\t\t\t\t\\\n-  else if (in_section != in_const)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n-      in_section = in_const;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* A C statement or statements to switch to the appropriate\n-   section for output of DECL.  DECL is either a `VAR_DECL' node\n-   or a constant of some sort.  RELOC indicates whether forming\n-   the initial value of DECL requires link-time relocations.  */\n-#define SELECT_SECTION(DECL, RELOC)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! flag_writable_strings)\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n-\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n-\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n-\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n-\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    const_section ();\t\t\t\t\t\t\t\\\n-}\n-\n-/* A C statement or statements to switch to the appropriate\n-   section for output of RTX in mode MODE.  RTX is some kind\n-   of constant in RTL.  The argument MODE is redundant except\n-   in the case of a `const_int' rtx.  Currently, these always\n-   go into the const section.  */\n-#define SELECT_RTX_SECTION(MODE, RTX) const_section ()\n-\n-/* On svr4, we *do* have support for the .init and .fini sections, and we\n-   can put stuff in there to be executed before and after `main'.  We let\n-   crtstuff.c and other files know this by defining the following symbols.\n-   The definitions say how to change sections to the .init and .fini\n-   sections.  This is the same for all known svr4 assemblers.  */\n-#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n-#define FINI_SECTION_ASM_OP\t\".section\\t.fini\"\n-\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-#define ASM_WEAKEN_LABEL(FILE, NAME) \t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fputs (\"\\t.weak\\t\", FILE);\t\t\\\n-      assemble_name (FILE, NAME); \t\t\\\n-      fputc ('\\n', FILE);\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#include \"arm/telf.h\"\n-#include \"arm/linux-tgas.h\"\n-\n-/* Run-time Target Specification.  */\n-#undef TARGET_VERSION\n-#define TARGET_VERSION  fputs (\" (Thumb GNU/Linux)\", stderr);"}, {"sha": "5ca370a4021d34b0c1fea9ec8df6c6c79c93c851", "filename": "gcc/config/arm/linux-tgas.h", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Flinux-tgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Flinux-tgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-tgas.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,84 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Thumb Linux-based GNU systems version.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n-   Contributed by Russell King  <rmk92@ecs.soton.ac.uk>.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* We are using GAS, so stabs should work.  */\n-#ifndef DBX_DEBUGGING_INFO\n-#define DBX_DEBUGGING_INFO 1\n-#endif\n-\n-/* This is how we tell the assembler that a symbol is weak.\n-   GAS always supports weak symbols.  */\n-#define ASM_WEAKEN_LABEL(FILE, NAME) \t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fputs (\"\\t.weak\\t\", FILE);\t\t\\\n-      assemble_name (FILE, NAME); \t\t\\\n-      fputc ('\\n', FILE);\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is used in ASM_FILE_START */\n-#undef  ARM_OS_NAME\n-#define ARM_OS_NAME \"Linux\"\n-\n-/* Unsigned chars produces much better code than signed.  */\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-#undef  SUBTARGET_CPP_SPEC\n-#define SUBTARGET_CPP_SPEC  \"%{posix:-D_POSIX_SOURCE} %{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__}\"\n-\n-#undef  SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef  PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef  WCHAR_TYPE\n-#define WCHAR_TYPE \"long int\"\n-\n-#undef  WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE BITS_PER_WORD\n-\n-/* Emit code to set up a trampoline and synchronise the caches.  */\n-#undef  INITIALIZE_TRAMPOLINE\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 8)),\t\\\n-\t\t  CXT);\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)),\t\\\n-\t\t  FNADDR);\t\t\t\t\t\t\\\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n-\t\t     0, VOIDmode, 2, TRAMP, Pmode,\t\t\t\\\n-\t\t     plus_constant (TRAMP, TRAMPOLINE_SIZE), Pmode);\t\\\n-}\n-\n-#if 0\n-/* Clear the instruction cache from `beg' to `end'.  This makes an\n-   inline system call to SYS_cacheflush.  */\n-#define CLEAR_INSN_CACHE(BEG, END)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  register unsigned long _beg __asm (\"a1\") = (unsigned long) (BEG);\t\\\n-  register unsigned long _end __asm (\"a2\") = (unsigned long) (END);\t\\\n-  register unsigned long _flg __asm (\"a3\") = 0;\t\t\t\t\\\n-  __asm __volatile (\"swi 0x9f0002\");\t\t\t\t\t\\\n-}\n-#endif"}, {"sha": "d368f68d6291de14226447496d9a9ff6eab9ee32", "filename": "gcc/config/arm/netbsd.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -37,7 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6\n \n /* Default is to use APCS-32 mode.  */\n-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_SOFT_FLOAT)\n+#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_FRAME)\n \n #include \"arm/aout.h\"\n \n@@ -105,8 +105,8 @@ Boston, MA 02111-1307, USA.  */\n    compiling the profiling functions.  Since we break Acorn CC\n    compatibility below a little more won't hurt.  */\n \n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\t\t    \\\n+#undef  ARM_FUNCTION_PROFILER\n+#define ARM_FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\t\t    \\\n {\t\t\t\t\t\t\t\t\t    \\\n   fprintf(STREAM, \"\\tmov\\t%sip, %slr\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n   fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\t\t    \\"}, {"sha": "55b4668fc6a1fc78ef1ee50b05becbf22c5895d7", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 2, "deletions": 141, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -27,7 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n-#include \"arm-protos.h\"\n+#include \"tm_p.h\"\n \n extern int current_function_anonymous_args;\n \n@@ -59,6 +59,7 @@ arm_pe_valid_machine_decl_attribute (decl, attributes, attr, args)\n \n   if (is_attribute_p (\"dllexport\", attr))\n     return 1;\n+  \n   if (is_attribute_p (\"dllimport\", attr))\n     return 1;\n \n@@ -118,45 +119,6 @@ arm_pe_merge_machine_decl_attributes (old, new)\n   return a;\n }\n \f\n-#if 0\n-/* Check a type that has a virtual table, and see if any virtual methods are\n-   marked for import or export, and if so, arrange for the vtable to\n-   be imported or exported.  */\n-\n-static int\n-arm_check_vtable_importexport (type)\n-     tree type;\n-{\n-  tree methods = TYPE_METHODS (type);\n-  tree fndecl;\n-\n-  if (TREE_CODE (methods) == FUNCTION_DECL)\n-    fndecl = methods;\n-  else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n-    fndecl = TREE_VEC_ELT (methods, 0);\n-  else\n-    fndecl = TREE_VEC_ELT (methods, 1);\n-\n-  while (fndecl)\n-    {\n-      if (DECL_VIRTUAL_P (fndecl) || DECL_VINDEX (fndecl) != NULL_TREE)\n-\t{\n-\t  tree exp = lookup_attribute (\"dllimport\",\n-\t\t\t\t       DECL_MACHINE_ATTRIBUTES (fndecl));\n-\t  if (exp == 0)\n-\t    exp = lookup_attribute (\"dllexport\",\n-\t\t\t\t    DECL_MACHINE_ATTRIBUTES (fndecl));\n-\t  if (exp)\n-\t    return 1;\n-\t}\n-\n-      fndecl = TREE_CHAIN (fndecl);\n-    }\n-\n-  return 0;\n-}\n-#endif\n-\n /* Return non-zero if DECL is a dllexport'd object.  */\n \n tree current_class_type; /* FIXME */\n@@ -174,23 +136,6 @@ arm_dllexport_p (decl)\n   if (exp)\n     return 1;\n \n-#if 0 /* This was a hack to get vtable's exported or imported since only one\n-\t copy of them is ever output.  Disabled pending better solution.  */\n-  /* For C++, the vtables might have to be marked.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n-    {\n-      if (TREE_PUBLIC (decl)\n-\t  && DECL_EXTERNAL (decl) == 0\n-\t  && (DECL_CONTEXT (decl)\n-\t      ? arm_check_vtable_importexport (DECL_CONTEXT (decl))\n-\t      : current_class_type\n-\t      ? arm_check_vtable_importexport (current_class_type)\n-\t      : 0)\n-\t  )\n-\treturn 1;\n-    }\n-#endif\n-\n   return 0;\n }\n \n@@ -213,23 +158,6 @@ arm_dllimport_p (decl)\n   if (imp)\n     return 1;\n \n-#if 0 /* This was a hack to get vtable's exported or imported since only one\n-\t copy of them is ever output.  Disabled pending better solution.  */\n-  /* For C++, the vtables might have to be marked.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n-    {\n-      if (TREE_PUBLIC (decl)\n-\t  && DECL_EXTERNAL (decl)\n-\t  && (DECL_CONTEXT (decl)\n-\t      ? arm_check_vtable_importexport (DECL_CONTEXT (decl))\n-\t      : current_class_type\n-\t      ? arm_check_vtable_importexport (current_class_type)\n-\t      : 0)\n-\t  )\n-\treturn 1;\n-    }\n-#endif\n-\n   return 0;\n }\n \n@@ -437,70 +365,3 @@ arm_pe_unique_section (decl, reloc)\n \n   DECL_SECTION_NAME (decl) = build_string (len, string);\n }\n-\f\n-/* This is to better conform to the ARM PCS.\n-   Richard Earnshaw hasn't put this into FSF sources yet so it's here.  */\n-\n-int\n-arm_pe_return_in_memory (type)\n-     tree type;\n-{\n-  if (TREE_CODE (type) == RECORD_TYPE)\n-    {\n-      tree field;\n-      int num_fields = 0;\n-\n-      /* For a record containing just a single element, we can be a little\n-\t less restrictive.  */\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) == FIELD_DECL && ! TREE_STATIC (field))\n-\t    {\n-\t      if ((AGGREGATE_TYPE_P (TREE_TYPE (field))\n-\t\t   && RETURN_IN_MEMORY (TREE_TYPE (field)))\n-\t\t  || FLOAT_TYPE_P (TREE_TYPE (field)))\n-\t\treturn 1;\n-\t      num_fields++;\n-\t    }\n-\t}\n-\n-      if (num_fields == 1)\n-\treturn 0;\n-\t    \n-      /* For a struct, we can return in a register if every element was a\n-\t bit-field and it all fits in one word.  */\n-      for (field = TYPE_FIELDS (type); field;  field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) == FIELD_DECL\n-\t      && ! TREE_STATIC (field)\n-\t      && (! DECL_BIT_FIELD_TYPE (field)\n-\t\t  || (host_integerp (DECL_SIZE (field), 1)\n-\t\t      && host_integerp (bit_position (field), 1)\n-\t\t      && 32 < (int_bit_position (field)\n-\t\t\t       + tree_low_cst (DECL_SIZE (field), 1)))))\n-\t    return 1;\n-\t}\n-      return 0;\n-    }\n-  else if (TREE_CODE (type) == UNION_TYPE\n-\t   || TREE_CODE (type) == QUAL_UNION_TYPE)\n-    {\n-      tree field;\n-\n-      /* Unions can be returned in registers if every element is\n-\t integral, or can be returned in an integer register.  */\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) == FIELD_DECL\n-\t      && ! TREE_STATIC (field)\n-\t      && ((AGGREGATE_TYPE_P (TREE_TYPE (field))\n-\t\t   && RETURN_IN_MEMORY (TREE_TYPE (field)))\n-\t\t  || FLOAT_TYPE_P (TREE_TYPE (field))))\n-\t    return 1;\n-\t}\n-      return 0;\n-    }\n-  /* XXX Not sure what should be done for other aggregates, so put them in\n-     memory. */\n-  return 1;\n-}"}, {"sha": "d950abd32d1603cdba5677ef7987f9c6d3001ce3", "filename": "gcc/config/arm/pe.h", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -19,6 +19,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* Enable PE specific code.  */\n+#define ARM_PE\t\t1\n+\n #define ARM_PE_FLAG_CHAR '@'\n \n /* Ensure that @x. will be stripped from the function name.  */\n@@ -42,11 +45,9 @@ Boston, MA 02111-1307, USA.  */\n    say __declspec__, and passing args to it.  The problem with that approach\n    is that args are not accumulated: each new appearance would clobber any\n    existing args.  */\n-#undef  CPP_PREDEFINES\n-#define CPP_PREDEFINES \"\\\n--Darm -D__pe__ -Acpu(arm) -Amachine(arm) \\\n--D__declspec(x)=__attribute__((x)) \\\n-\"\n+#undef  SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC \"-D__pe__ -D__declspec(x)=__attribute__((x))\"\n+\n \n /* Experimental addition for pr 7885.\n    Ignore dllimport for functions.  */\n@@ -88,13 +89,6 @@ Boston, MA 02111-1307, USA.  */\n   1,1,1,1,0,0,0,0,\t\\\n   1,1,1\t\t\t\\\n }\n-\n-/* This is to better conform to the ARM PCS.\n-   Richard Earnshaw hasn't put this into FSF sources yet so it's here.  */\n-#undef  RETURN_IN_MEMORY\n-#define RETURN_IN_MEMORY(TYPE) \t\t\t\t\t\t\\\n-  ((TYPE_MODE ((TYPE)) == BLKmode && ! TYPE_NO_FORCE_BLK (TYPE))\t\\\n-   || (AGGREGATE_TYPE_P ((TYPE)) && arm_pe_return_in_memory ((TYPE))))\n \f\n /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n    is a valid machine specific attribute for DECL.\n@@ -121,13 +115,7 @@ Boston, MA 02111-1307, USA.  */\n    to handle vtables - the first pass won't do anything because\n    DECL_CONTEXT (DECL) will be 0 so arm_dll{ex,im}port_p will return 0.\n    It's also used to handle dllimport override semantics.  */\n-#if 0\n-#define REDO_SECTION_INFO_P(DECL) \\\n-((DECL_MACHINE_ATTRIBUTES (DECL) != NULL_TREE) \\\n- || (TREE_CODE (DECL) == VAR_DECL && DECL_VIRTUAL_P (DECL)))\n-#else\n #define REDO_SECTION_INFO_P(DECL) 1\n-#endif\n \n /* Define this macro if in some cases global symbols from one translation\n    unit may not be bound to undefined symbols in another translation unit\n@@ -180,24 +168,25 @@ Boston, MA 02111-1307, USA.  */\n /* Output a reference to a label.  */\n #undef  ASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n-  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, arm_strip_name_encoding (NAME))\n+  asm_fprintf (STREAM, \"%U%s\", arm_strip_name_encoding (NAME))\n \n /* Output a function definition label.  */\n #undef  ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)   \\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (arm_dllexport_name_p (NAME))\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  drectve_section ();\t\t\t\t\\\n-\t  fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\\\n-\t\t   arm_strip_name_encoding (NAME));\t\\\n-\t  function_section (DECL);\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n-\tarm_poke_function_name ((STREAM), (NAME));\t\\\n-      ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\\\n-    }\t\t\t\t\t\t\t\\\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)   \t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (arm_dllexport_name_p (NAME))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  drectve_section ();\t\t\t\t\t\\\n+\t  fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t\t   arm_strip_name_encoding (NAME));\t\t\\\n+\t  function_section (DECL);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      ARM_DECLARE_FUNCTION_NAME (STREAM, NAME, DECL);\t\t\\\n+      if (TARGET_THUMB)\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.code 16\\n\");\t\t\t\\\n+      ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n /* Output a common block.  */"}, {"sha": "081b4c18663f6271730dcdb5eecde52cef9ae50d", "filename": "gcc/config/arm/semi.h", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fsemi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fsemi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsemi.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -23,10 +23,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define LIB_SPEC \"-lc\"\n \n-#define CPP_PREDEFINES \\\n-    \"-Darm -D__semi__ -Acpu(arm) -Amachine(arm)\"\n-\n-#define ASM_SPEC \"%{mbig-endian:-EB}\"\n+#define SUBTARGET_CPP_SPEC \"-D__semi__\"\n \n #define LINK_SPEC \"%{mbig-endian:-EB} -X\"\n \n@@ -35,7 +32,23 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT ARM_FLAG_APCS_32\n+#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n+#endif\n+\n+#ifndef SUBTARGET_EXTRA_ASM_SPEC\n+#define SUBTARGET_EXTRA_ASM_SPEC\n+#endif\n+\n+#ifndef ASM_SPEC\n+#define ASM_SPEC \"\\\n+%{mbig-endian:-EB} \\\n+%{mcpu=*:-m%*} \\\n+%{march=*:-m%*} \\\n+%{mapcs-*:-mapcs-%*} \\\n+%{mapcs-float:-mfloat} \\\n+%{msoft-float:-mno-fpu} \\\n+%{mthumb-interwork:-mthumb-interwork} \\\n+\" SUBTARGET_EXTRA_ASM_SPEC\n #endif\n \n #include \"arm/aout.h\""}, {"sha": "39613109566d4cb698052209fa443d42f729cd58", "filename": "gcc/config/arm/strongarm-coff.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fstrongarm-coff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fstrongarm-coff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fstrongarm-coff.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -0,0 +1,31 @@\n+/* Definitions for StrongARM systems using COFF\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Contributed by Catherine Moore <clm@cygnus.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Run-time Target Specification.  */\n+#ifndef SUBTARGET_CPU_DEFAULT\n+#define SUBTARGET_CPU_DEFAULT \t\tTARGET_CPU_strongarm\n+#endif\n+\n+#include \"coff.h\"\n+\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION\tfputs (\" (StrongARM/COFF)\", stderr);\n+"}, {"sha": "79ba96113fffc587cba8c6d44ee34aa4bbc11e23", "filename": "gcc/config/arm/strongarm-elf.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fstrongarm-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fstrongarm-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fstrongarm-elf.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -0,0 +1,31 @@\n+/* Definitions for non-Linux based StrongARM systems using ELF\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Contributed by Catherine Moore <clm@cygnus.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Run-time Target Specification.  */\n+#ifndef TARGET_VERSION\n+#define TARGET_VERSION\tfputs (\" (StrongARM/ELF non-Linux)\", stderr);\n+#endif\n+\n+#ifndef SUBTARGET_CPU_DEFAULT\n+#define SUBTARGET_CPU_DEFAULT \t\tTARGET_CPU_strongarm\n+#endif\n+\n+#include \"unknown-elf.h\""}, {"sha": "811b2c2ae1ac4f53896605aa44483ededc7a9cba", "filename": "gcc/config/arm/t-arm-aout", "status": "renamed", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-arm-aout", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-arm-aout", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-aout?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,9 +1,6 @@\n-# Makefile fragment\n-# Copyright (c) 1998 Free Software Foundation\n-\n CROSS_LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC = arm/lib1thumb.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX  _interwork_call_via_rX\n \n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n@@ -24,13 +21,10 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#endif' >> dp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n \n-# Rule to build Psion specific GCC functions.\n-pe.o: $(srcdir)/config/arm/pe.c\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n-\n-# Avoid building a duplicate set of libraries for the default endian-ness.\n-MULTILIB_OPTIONS = mthumb-interwork\n-MULTILIB_DIRNAMES = interwork\n+# MULTILIB_OPTIONS  = mhard-float/msoft-float mapcs-32/mapcs-26 mno-thumb-interwork/mthumb-interwork arm/thumb\n+# MULTILIB_DIRNAMES = le be fpu soft 32bit 26bit normal interwork arm thumb\n+# MULTILIB_MATCHES  = \n+# MULTILIB_EXCEPTIONS = *mapcs-26/*mthumb-interwork* *mpacs-26/*mthumb*\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib", "previous_filename": "gcc/config/arm/t-pe-thumb"}, {"sha": "5422257eb3b3b8cdc8f683088a1e3291befc8780", "filename": "gcc/config/arm/t-arm-coff", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-arm-coff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-arm-coff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-coff?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,7 +1,6 @@\n CROSS_LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC = arm/lib1thumb.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n-# adddi3/subdi3 added to machine description\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func _call_via_rX _interwork_call_via_rX\n \n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n@@ -22,13 +21,15 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#endif' >> dp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n \n-# Avoid building a duplicate set of libraries for the default endian-ness.\n-MULTILIB_OPTIONS     = mlittle-endian/mbig-endian mno-thumb-interwork/mthumb-interwork fno-leading-underscore/fleading-underscore\n-MULTILIB_DIRNAMES    = le be normal interwork elf under\n-MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n+MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float/msoft-float marm/mthumb mno-thumb-interwork/mthumb-interwork\n+MULTILIB_DIRNAMES = le be fpu soft arm thumb normal interwork\n+MULTILIB_MATCHES  = \n EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n \n-TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc\n+# Currently there is a bug somwehere in GCC's alias analysis\n+# or scheduling code that is breaking _fpmul_parts in libgcc1.c.\n+# Disabling function inlining is a workaround for this problem.\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline", "previous_filename": "gcc/config/arm/t-thumb-elf"}, {"sha": "a576d6f32e651606f3c531ef99499bb0ef910496", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,6 +1,6 @@\n CROSS_LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC    = arm/lib1funcs.asm\n-LIB1ASMFUNCS  = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func _call_via_rX _interwork_call_via_rX\n \n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n@@ -67,7 +67,16 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n # LIBGCC               = stmp-multilib\n # INSTALL_LIBGCC       = install-multilib\n \n+MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+\n # If EXTRA_MULTILIB_PARTS is not defined above then define EXTRA_PARTS here\n-EXTRA_PARTS = crtbegin.o crtend.o\n+# EXTRA_PARTS = crtbegin.o crtend.o\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n \n-TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc\n+# Currently there is a bug somewhere in GCC's alias analysis\n+# or scheduling code that is breaking _fpmul_parts in libgcc1.c.\n+# Disabling function inlining is a workaround for this problem.\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "ba799d829ea249ee4dba5d8fe78ca79fe189af99", "filename": "gcc/config/arm/t-bare", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ft-bare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ft-bare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-bare?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,32 +0,0 @@\n-CROSS_LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC    = arm/lib1funcs.asm\n-LIB1ASMFUNCS  = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#ifndef __ARMEB__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\techo '#endif' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#ifndef __ARMEB__' > dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#endif' >> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-# Avoid building a duplicate set of libraries for the default endian-ness.\n-MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float\n-MULTILIB_DIRNAMES = le be fpu\n-MULTILIB_MATCHES  = \n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-"}, {"sha": "6c59cc9705bd0054ccc8423f4091aa30a89b780f", "filename": "gcc/config/arm/t-netbsd", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-netbsd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-netbsd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-netbsd?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -5,3 +5,5 @@ LIBGCC2_DEBUG_CFLAGS = -g0\n \n # Don't build enquire\n ENQUIRE=\n+\n+"}, {"sha": "7d71f5ccf7eba935cc89db928b9415fe89cb03d2", "filename": "gcc/config/arm/t-pe", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-pe?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -24,8 +24,9 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n pe.o: $(srcdir)/config/arm/pe.c\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n \n-MULTILIB_OPTIONS = mhard-float\n-MULTILIB_DIRNAMES = fpu\n+MULTILIB_OPTIONS = mhard-float mthumb\n+MULTILIB_DIRNAMES = fpu thumb\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc"}, {"sha": "228879396557dddf9f5c8e5ae1b3d76f63c8286e", "filename": "gcc/config/arm/t-semiaof", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-semiaof", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Ft-semiaof", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-semiaof?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -64,3 +64,4 @@ libgcc1-atest: libgcc1-test.o native $(GCC_PARTS) $(EXTRA_PARTS)\n \t@echo \"Testing libgcc1.  Ignore linker warning messages.\"\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) libgcc1-test.o -o libgcc1-test \\\n \t-v\n+"}, {"sha": "eb3e0111a8dfc729d6327c59f0592b0cff8647c2", "filename": "gcc/config/arm/t-thumb", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ft-thumb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ft-thumb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-thumb?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,32 +0,0 @@\n-CROSS_LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC = arm/lib1thumb.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n-# adddi3/subdi3 added to machine description\n-#LIB1ASMFUNCS = _adddi3 _subdi3 _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#ifndef __ARMEB__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\techo '#endif' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#ifndef __ARMEB__' > dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#endif' >> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-# Avoid building a duplicate set of libraries for the default endian-ness.\n-MULTILIB_OPTIONS = mlittle-endian/mbig-endian mno-thumb-interwork/mthumb-interwork\n-MULTILIB_DIRNAMES = le be normal interwork\n-MULTILIB_MATCHES = mbig-endian=mbe mlittle-endian=mle\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib"}, {"sha": "e028ac04c4eb5b34686cf7a6debb0d59cb1cf16c", "filename": "gcc/config/arm/t-thumb-linux", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ft-thumb-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ft-thumb-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-thumb-linux?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,42 +0,0 @@\n-# Just for these, we omit the frame pointer since it makes such a big\n-# difference.  It is then pointless adding debugging.\n-TARGET_LIBGCC2_CFLAGS = -fomit-frame-pointer -fPIC\n-LIBGCC2_DEBUG_CFLAGS = -g0\n-\n-# Don't build enquire\n-ENQUIRE=\n-\n-# Since libgcc1 is an assembler file, we can build it automatically for the\n-# cross-compiler.\n-CROSS_LIBGCC1 = libgcc1-asm.a\n-LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC = arm/lib1thumb.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3  _dvmd_tls _call_via_rX _interwork_call_via_rX\n-\n-MULTILIB_OPTIONS     = mlittle-endian/mbig-endian\n-MULTILIB_DIRNAMES    = le be\n-MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n-EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#ifndef __ARMEB__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\techo '#endif' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#ifndef __ARMEB__' > dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#endif' >> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-"}, {"sha": "37870022d1e5a3cc14921e68f77e5687561a2c6f", "filename": "gcc/config/arm/tcoff.h", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ftcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ftcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftcoff.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,187 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   for Thumb with COFF obj format.\n-   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.\n-   Derived from arm/coff.h originally by Doug Evans (dje@cygnus.com).\n-   \n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"arm/thumb.h\"\n-\f\n-/* Run-time Target Specification.  */\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fputs (\" (Thumb/coff)\", stderr)\n-\n-#define MULTILIB_DEFAULTS { \"mlittle-endian\" }\n-\f\n-/* Setting this to 32 produces more efficient code, but the value set in previous\n-   versions of this toolchain was 8, which produces more compact structures. The\n-   command line option -mstructure_size_boundary=<n> can be used to change this\n-   value.  */\n-#undef STRUCTURE_SIZE_BOUNDARY\n-#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary\n-\n-extern int arm_structure_size_boundary;\n-\f\n-/* This is COFF, but prefer stabs.  */\n-#define SDB_DEBUGGING_INFO\n-\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-#include \"dbxcoff.h\"\n-\f\n-#undef  LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX \".\"\n-\n-/* Note - it is important that this definition matches the one in coff.h */\n-#undef  USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* A C statement to output assembler commands which will identify the\n-   object file as having been compiled with GNU CC (or another GNU\n-   compiler).  */\n-#define ASM_IDENTIFY_GCC(STREAM)\t\t\t\t\\\n-     fprintf (STREAM, \"%sgcc2_compiled.:\\n\", LOCAL_LABEL_PREFIX )\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(STREAM) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  fprintf ((STREAM), \"%s Generated by gcc %s for Thumb/coff\\n\", \\\n-\t   ASM_COMMENT_START, version_string);\t                \\\n-  fprintf ((STREAM), ASM_APP_OFF);                              \\\n-} while (0)\n-\n-/* A C statement to output something to the assembler file to switch to section\n-   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n-   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n-   define this macro in such cases.  */\n-#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n-  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n-} while (0)\n-\f\n-/* Support the ctors/dtors and other sections.  */\n-\n-#undef INIT_SECTION_ASM_OP\n-\n-/* Define this macro if jump tables (for `tablejump' insns) should be\n-   output in the text section, along with the assembler instructions.\n-   Otherwise, the readonly data section is used.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-#undef READONLY_DATA_SECTION\n-#define READONLY_DATA_SECTION\trdata_section\n-#undef RDATA_SECTION_ASM_OP\n-#define RDATA_SECTION_ASM_OP\t\"\\t.section .rdata\"\n-\n-#undef CTORS_SECTION_ASM_OP\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section .ctors,\\\"x\\\"\"\n-#undef DTORS_SECTION_ASM_OP\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section .dtors,\\\"x\\\"\"\n-\n-/* A list of other sections which the compiler might be \"in\" at any\n-   given time.  */\n-\n-#undef EXTRA_SECTIONS\n-#define EXTRA_SECTIONS SUBTARGET_EXTRA_SECTIONS in_rdata, in_ctors, in_dtors\n-\n-#define SUBTARGET_EXTRA_SECTIONS\n-\n-/* A list of extra section function definitions.  */\n-\n-#undef EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS \\\n-  RDATA_SECTION_FUNCTION\t\\\n-  CTORS_SECTION_FUNCTION\t\\\n-  DTORS_SECTION_FUNCTION\t\\\n-  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-\n-#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-\n-#define RDATA_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-rdata_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_rdata)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\t\\\n-      in_section = in_rdata;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define CTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-ctors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_ctors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define DTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-dtors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_dtors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Support the ctors/dtors sections for g++.  */\n-\n-#define INT_ASM_OP \".word\"\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global constructors.  */\n-#undef ASM_OUTPUT_CONSTRUCTOR\n-#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  ctors_section ();\t\t\t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global destructors.  */\n-#undef ASM_OUTPUT_DESTRUCTOR\n-#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  dtors_section ();                   \t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);              \t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n-\n-/* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n-#define CTOR_LISTS_DEFINED_EXTERNALLY\n-\n-#undef DO_GLOBAL_CTORS_BODY\n-#undef DO_GLOBAL_DTORS_BODY\n-\n-/* The ARM development system defines __main.  */\n-#define NAME__MAIN \"__gccmain\"\n-#define SYMBOL__MAIN __gccmain"}, {"sha": "e1a5cb1be66e32ce04c23f15ba52662f042df6ef", "filename": "gcc/config/arm/telf.h", "status": "removed", "additions": 0, "deletions": 469, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ftelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ftelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftelf.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,469 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   for Thumb with ELF obj format.\n-   Copyright (C) 1995, 1996, 1999, 2000 Free Software Foundation, Inc.\n-   \n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define OBJECT_FORMAT_ELF\n-\n-#ifndef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dthumb -Dthumbelf -D__thumb -Acpu(arm) -Amachine(arm)\"\n-#endif\n-\n-#include \"arm/thumb.h\"\n-\f\n-/* Run-time Target Specification.  */\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION fputs (\" (Thumb/elf)\", stderr)\n-\n-#define MULTILIB_DEFAULTS { \"mlittle-endian\" }\n-\f\n-/* Setting this to 32 produces more efficient code, but the value set in previous\n-   versions of this toolchain was 8, which produces more compact structures. The\n-   command line option -mstructure_size_boundary=<n> can be used to change this\n-   value.  */\n-#undef  STRUCTURE_SIZE_BOUNDARY\n-#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary\n-\n-extern int arm_structure_size_boundary;\n-\f\n-/* Debug */\n-#define DWARF_DEBUGGING_INFO\n-#define DWARF2_DEBUGGING_INFO\n-#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-\n-/* Get the standard ELF stabs definitions.  */\n-#include \"dbxelf.h\"\n-\f\n-/* Note - it is important that these definitions match those in semi.h for the ARM port.  */\n-#undef  LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX \".\"\n-\n-\n-/* A C statement to output assembler commands which will identify the\n-   object file as having been compiled with GNU CC (or another GNU\n-   compiler).  */\n-#ifndef ASM_IDENTIFY_GCC\n-#define ASM_IDENTIFY_GCC(STREAM)\t\t\t\t\\\n-  fprintf (STREAM, \"%sgcc2_compiled.:\\n\", LOCAL_LABEL_PREFIX )\n-#endif\n-\n-#undef  ASM_FILE_START\n-#define ASM_FILE_START(STREAM)\t\t\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf ((STREAM), \"%s Generated by gcc %s for Thumb/elf\\n\",\t\\\n-\t       ASM_COMMENT_START, version_string);\t\t\t\\\n-      fprintf ((STREAM), ASM_APP_OFF);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* A C statement to output something to the assembler file to switch to section\n-   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n-   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n-   define this macro in such cases.  */\n-#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-        fprintf (STREAM, \"\\t.section %s,\\\"ax\\\",%%progbits\\n\", NAME);\t\\\n-      else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n-        fprintf (STREAM, \"\\t.section %s,\\\"a\\\"\\n\", NAME);\t\t\\\n-      else if (! strncmp (NAME, \".bss\", 4))      \t\t\t\\\n-        fprintf (STREAM, \"\\t.section %s,\\\"aw\\\",%%nobits\\n\", NAME); \t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        fprintf (STREAM, \"\\t.section %s,\\\"aw\\\"\\n\", NAME);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\f\n-/* Support the ctors/dtors and other sections.  */\n-\n-#undef INIT_SECTION_ASM_OP\n-\n-/* Define this macro if jump tables (for `tablejump' insns) should be\n-   output in the text section, along with the assembler instructions.\n-   Otherwise, the readonly data section is used.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-#undef  READONLY_DATA_SECTION\n-#define READONLY_DATA_SECTION\trdata_section\n-#undef  RDATA_SECTION_ASM_OP\n-#define RDATA_SECTION_ASM_OP\t\"\\t.section .rodata\"\n-\n-#undef  CTORS_SECTION_ASM_OP\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section .ctors,\\\"aw\\\"\"\n-#undef  DTORS_SECTION_ASM_OP\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section .dtors,\\\"aw\\\"\"\n-\n-#define USER_LABEL_PREFIX \"\"\n-\n-/* If defined, a C expression whose value is a string containing the\n-   assembler operation to identify the following data as\n-   uninitialized global data.  If not defined, and neither\n-   `ASM_OUTPUT_BSS' nor `ASM_OUTPUT_ALIGNED_BSS' are defined,\n-   uninitialized global data will be output in the data section if\n-   `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be\n-   used.  */\n-#ifndef BSS_SECTION_ASM_OP\n-#define BSS_SECTION_ASM_OP\t\".section\\t.bss\"\n-#endif\n-\n-/* Like `ASM_OUTPUT_BSS' except takes the required alignment as a\n-   separate, explicit argument.  If you define this macro, it is used\n-   in place of `ASM_OUTPUT_BSS', and gives you more flexibility in\n-   handling the required alignment of the variable.  The alignment is\n-   specified as the number of bits.\n-\n-   Try to use function `asm_output_aligned_bss' defined in file\n-   `varasm.c' when defining this macro. */\n-#ifndef ASM_OUTPUT_ALIGNED_BSS\n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n-  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n-#endif\n-\n-/* Don't know how to order these.  UNALIGNED_WORD_ASM_OP is in\n-   dwarf2.out. */ \n-#define UNALIGNED_WORD_ASM_OP \".4byte\"\n-\n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)\t\t\t\\\n- if (((ADDR)[0] == '.') && ((ADDR)[1] == 'L')) \t\t\t\\\n-   fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, (ADDR));\t\\\n- else                                                     \t\\\n-  fprintf ((FILE), \"\\t%s\\t%s\",\t\t\t\t\t\\\n-           UNALIGNED_WORD_ASM_OP, (ADDR))\n-\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_WORD_ASM_OP);\t\\\n-      output_addr_const ((FILE), (RTX));\t\t\t\\\n-      fputc ('\\n', (FILE));\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to equate one symbol to another symbol.  The syntax used is\n-   `SYM1=SYM2'.  Note that this is different from the way equates are done\n-   with most svr4 assemblers, where the syntax is `.set SYM1,SYM2'.  */\n-\n-#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t\");\t\t\t\\\n-      assemble_name (FILE, LABEL1);\t\t\\\n-      fprintf (FILE, \" = \");\t\t\t\\\n-      assemble_name (FILE, LABEL2);\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* For aliases of functions we use .thumb_set instead.  */\n-#define ASM_OUTPUT_DEF_FROM_DECLS(FILE,DECL1,DECL2)\t\t\\\n-  do\t\t\t\t\t\t   \t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      const char * LABEL1 = XSTR (XEXP (DECL_RTL (decl), 0), 0);\\\n-      const char * LABEL2 = IDENTIFIER_POINTER (DECL2);\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (TREE_CODE (DECL1) == FUNCTION_DECL)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\t.thumb_set \");\t\t\t\\\n-\t  assemble_name (FILE, LABEL1);\t\t\t   \t\\\n-\t  fprintf (FILE, \",\");\t\t\t   \t\t\\\n-\t  assemble_name (FILE, LABEL2);\t\t   \t\t\\\n-\t  fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tASM_OUTPUT_DEF (FILE, LABEL1, LABEL2);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* A list of other sections which the compiler might be \"in\" at any\n-   given time.  */\n-#undef  EXTRA_SECTIONS\n-#define EXTRA_SECTIONS SUBTARGET_EXTRA_SECTIONS in_rdata, in_ctors, in_dtors\n-\n-#ifndef SUBTARGET_EXTRA_SECTIONS\n-#define SUBTARGET_EXTRA_SECTIONS\n-#endif\n-\n-/* A list of extra section function definitions.  */\n-\n-#undef  EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS \\\n-  RDATA_SECTION_FUNCTION\t\\\n-  CTORS_SECTION_FUNCTION\t\\\n-  DTORS_SECTION_FUNCTION\t\\\n-  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-\n-#ifndef SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-#endif\n-\n-#define RDATA_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\\\n-rdata_section ()\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_rdata)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\\\n-      in_section = in_rdata;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define CTOR_LIST_BEGIN                                 \\\n-asm (CTORS_SECTION_ASM_OP);                             \\\n-func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) }\n-\n-#define CTOR_LIST_END                                   \\\n-asm (CTORS_SECTION_ASM_OP);                             \\\n-func_ptr __CTOR_END__[1] = { (func_ptr) 0 };\n-\n-#define DTOR_LIST_BEGIN                                 \\\n-asm (DTORS_SECTION_ASM_OP);                             \\\n-func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) }\n-\n-#define DTOR_LIST_END                                   \\\n-asm (DTORS_SECTION_ASM_OP);                             \\\n-func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n-\n-#define CTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\\\n-ctors_section ()\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\\\n-      in_section = in_ctors;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define DTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\\\n-dtors_section ()\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\\\n-      in_section = in_dtors;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Support the ctors/dtors sections for g++.  */\n-\n-#define INT_ASM_OP \".word\"\n-\n-#define INVOKE__main\n-\n-#undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC \"crtbegin%O%s crt0%O%s\"\n-\n-#undef  ENDFILE_SPEC\n-#define ENDFILE_SPEC \"crtend%O%s\"\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global constructors.  */\n-#undef  ASM_OUTPUT_CONSTRUCTOR\n-#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME)\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      ctors_section ();\t\t\t\t\\\n-      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-      assemble_name (STREAM, NAME);\t\t\\\n-      fprintf (STREAM, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global destructors.  */\n-#undef  ASM_OUTPUT_DESTRUCTOR\n-#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME)\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      dtors_section ();\t\t\t\t\\\n-      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-      assemble_name (STREAM, NAME);\t\t\\\n-      fprintf (STREAM, \"\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* The ARM development system defines __main.  */\n-#define NAME__MAIN \"__gccmain\"\n-#define SYMBOL__MAIN __gccmain\n-\n-#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n-#define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))\n-#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      int len;\t\t\t\t\t\t\t\\\n-      char * name, * string, * prefix;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (! DECL_ONE_ONLY (DECL))\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          prefix = \".\";\t\t\t\t\t\t\\\n-          if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-\t    prefix = \".text.\";\t\t\t\t\t\\\n-          else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n-\t    prefix = \".rodata.\";\t\t\t\t\\\n-          else\t\t\t\t\t\t\t\\\n-\t    prefix = \".data.\";\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      else if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-        prefix = \".gnu.linkonce.t.\";\t\t\t\t\\\n-      else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n-        prefix = \".gnu.linkonce.r.\";\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-        prefix = \".gnu.linkonce.d.\";\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      len = strlen (name) + strlen (prefix);\t\t\t\\\n-      string = alloca (len + 1);\t\t\t\t\\\n-      sprintf (string, \"%s%s\", prefix, name);\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-#ifndef ASM_WEAKEN_LABEL\n-#define ASM_WEAKEN_LABEL(FILE, NAME) \t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fputs (\"\\t.weak\\t\", FILE);\t\t\\\n-      assemble_name (FILE, NAME); \t\t\\\n-      fputc ('\\n', FILE);\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-#endif\n-\n-#ifndef TYPE_ASM_OP\n-\n-/* These macros generate the special .type and .size directives which\n-   are used to set the corresponding fields of the linker symbol table\n-   entries in an ELF object file under SVR4.  These macros also output\n-   the starting labels for the relevant functions/objects.  */\n-#define TYPE_ASM_OP     \".type\"\n-#define SIZE_ASM_OP     \".size\"\n-\n-/* The following macro defines the format used to output the second\n-   operand of the .type assembler directive.  Different svr4 assemblers\n-   expect various different forms for this operand.  The one given here\n-   is just a default.  You may need to override it in your machine-\n-   specific tm.h file (depending upon the particulars of your assembler).  */\n-#define TYPE_OPERAND_FMT\t\"%s\"\n-\n-/* Write the extra assembler code needed to declare a function's result.\n-   Most svr4 assemblers don't require any special declaration of the\n-   result value, but there are exceptions.  */\n-#ifndef ASM_DECLARE_RESULT\n-#define ASM_DECLARE_RESULT(FILE, RESULT)\n-#endif\n-\n-/* Write the extra assembler code needed to declare a function properly.\n-   Some svr4 assemblers need to also have something extra said about the\n-   function's return value.  We allow for that here.  */\n-#undef  ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\\\n-      assemble_name (FILE, NAME);\t\t\t\\\n-      putc (',', FILE);\t\t\t\t\t\\\n-      fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\\\n-      putc ('\\n', FILE);\t\t\t\t\\\n-      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\\\n-      if (! is_called_in_ARM_mode (decl))\t\t\\\n-        fprintf (FILE, \"\\t.thumb_func\\n\") ;\t\t\\\n-      else\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\t.code\\t32\\n\") ;\t\t\\\n-      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Write the extra assembler code needed to declare an object properly.  */\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\\\n-      assemble_name (FILE, NAME);\t\t\t\t\\\n-      putc (',', FILE);\t\t\t\t\t\t\\\n-      fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\\\n-      putc ('\\n', FILE);\t\t\t\t\t\\\n-      size_directive_output = 0;\t\t\t\t\\\n-      if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\\\n-        {\t\t\t\t\t\t\t\\\n-\t  size_directive_output = 1;\t\t\t\t\\\n-\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n-\t  assemble_name (FILE, NAME);\t\t\t\t\\\n-\t  putc (',', FILE);\t\t\t\t\t\\\n-\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\\\n-\t\t   int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n-\t  fputc ('\\n', FILE);\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output the size directive for a decl in rest_of_decl_compilation\n-   in the case where we did not do so before the initializer.\n-   Once we find the error_mark_node, we know that the value of\n-   size_directive_output was set\n-   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n-#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      const char * name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\\\n-      if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\\\n-          && ! AT_END && TOP_LEVEL\t\t\t\t\\\n-\t  && DECL_INITIAL (DECL) == error_mark_node\t\t\\\n-\t  && !size_directive_output)\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-\t  size_directive_output = 1;\t\t\t\t\\\n-\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n-\t  assemble_name (FILE, name);\t\t\t\t\\\n-\t  putc (',', FILE);\t\t\t\t\t\\\n-\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\\\n-\t\t  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n-\t fputc ('\\n', FILE);\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to declare the size of a function.  */\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (!flag_inhibit_size_directive)\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          char label[256];\t\t\t\t\t\\\n-\t  static int labelno;\t\t\t\t\t\\\n-\t  labelno ++;\t\t\t\t\t\t\\\n-\t  ASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\\\n-\t  ASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\\\n-\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n-\t  assemble_name (FILE, (FNAME));\t\t\t\\\n-          fprintf (FILE, \",\");\t\t\t\t\t\\\n-\t  assemble_name (FILE, label);\t\t\t\t\\\n-          fprintf (FILE, \"-\");\t\t\t\t\t\\\n-\t  assemble_name (FILE, (FNAME));\t\t\t\\\n-\t  putc ('\\n', FILE);\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#endif /* TYPE_ASM_OP */"}, {"sha": "79de0b6ca2dd554bbf9fdec9205d6e7b4b1ce155", "filename": "gcc/config/arm/thumb.c", "status": "removed", "additions": 0, "deletions": 2426, "changes": 2426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,2426 +0,0 @@\n-/* Output routines for GCC for ARM/Thumb\n-   Copyright (C) 1996, 2000 Cygnus Software Technologies Ltd\n-   The basis of this contribution was generated by\n-   \t\tRichard Earnshaw, Advanced RISC Machines Ltd\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"regs.h\"\n-#include \"output.h\"\n-#include \"insn-flags.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"thumb-protos.h\"\n-\n-\f\n-int current_function_anonymous_args = 0;\n-\n-/* Used to parse -mstructure_size_boundary command line option.  */\n-const char * structure_size_string = NULL;\n-int          arm_structure_size_boundary = 32; /* Used to be 8 */\n-\n-/* The register number to be used for the PIC offset register.  */\n-const char * thumb_pic_register_string = NULL;\n-int thumb_pic_register = 10;\n-\n-/* True if we are currently building a constant table. */\n-int making_const_table;\n-\n-\f\n-/* Predicates */\n-int\n-reload_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED ;\n-{\n-  int regno = true_regnum (op);\n-\n-  return (! CONSTANT_P (op)\n-\t  && (regno == -1\n-\t      || (GET_CODE (op) == REG\n-\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n-}\n-\n-/* Return nonzero if op is suitable for the RHS of a cmp instruction.  */\n-int\n-thumb_cmp_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && (unsigned HOST_WIDE_INT) (INTVAL (op)) < 256)\n-\t  || register_operand (op, mode));\n-}\n-\n-int\n-thumb_shiftable_const (val)\n-     HOST_WIDE_INT val;\n-{\n-  HOST_WIDE_INT mask = 0xff;\n-  int i;\n-\n-  for (i = 0; i < 25; i++)\n-    if ((val & (mask << i)) == val)\n-      return 1;\n-\n-  return 0;\n-}\n-\n-int\n-thumb_trivial_epilogue ()\n-{\n-  /* ??? If this function ever returns 1, we get a function without any\n-     epilogue at all.  It appears that the intent was to cause a \"return\"\n-     insn to be emitted, but that does not happen.  */\n-  return 0;\n-\n-#if 0\n-  if (get_frame_size () \n-      || current_function_outgoing_args_size\n-      || current_function_pretend_args_size)\n-    return 0;\n-\n-  for (regno = 8; regno < 13; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n-      return 0;\n-\n-  return 1;\n-#endif\n-}\n-\n-\f\n-/* Return TRUE if X references a SYMBOL_REF.  */\n-int\n-thumb_symbol_mentioned_p (x)\n-     rtx x;\n-{\n-  register const char * fmt;\n-  register int i;\n-\n-  if (GET_CODE (x) == SYMBOL_REF)\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (thumb_symbol_mentioned_p (XVECEXP (x, i, j)))\n-\t      return 1;\n-\t}\n-      else if (fmt[i] == 'e' && thumb_symbol_mentioned_p (XEXP (x, i)))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return TRUE if X references a LABEL_REF.  */\n-int\n-label_mentioned_p (x)\n-     rtx x;\n-{\n-  register const char * fmt;\n-  register int i;\n-\n-  if (GET_CODE (x) == LABEL_REF)\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (label_mentioned_p (XVECEXP (x, i, j)))\n-\t      return 1;\n-\t}\n-      else if (fmt[i] == 'e' && label_mentioned_p (XEXP (x, i)))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-rtx\n-legitimize_pic_address (orig, mode, reg)\n-     rtx orig;\n-     enum machine_mode mode;\n-     rtx reg;\n-{\n-  if (GET_CODE (orig) == SYMBOL_REF)\n-    {\n-      rtx pic_ref, address;\n-      rtx insn;\n-      int subregs = 0;\n-\n-      if (reg == 0)\n-\t{\n-\t  if (reload_in_progress || reload_completed)\n-\t    abort ();\n-\t  else\n-\t    reg = gen_reg_rtx (Pmode);\n-\n-\t  subregs = 1;\n-\t}\n-\n-#ifdef AOF_ASSEMBLER\n-      /* The AOF assembler can generate relocations for these directly, and\n-\t understands that the PIC register has to be added into the offset.\n-\t */\n-      insn = emit_insn (gen_pic_load_addr_based (reg, orig));\n-#else\n-      if (subregs)\n-\taddress = gen_reg_rtx (Pmode);\n-      else\n-\taddress = reg;\n-\n-      emit_insn (gen_pic_load_addr (address, orig));\n-\n-      pic_ref = gen_rtx_MEM (Pmode,\n-\t\t\t     gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n-\t\t\t\t\t   address));\n-      RTX_UNCHANGING_P (pic_ref) = 1;\n-      insn = emit_move_insn (reg, pic_ref);\n-#endif\n-      current_function_uses_pic_offset_table = 1;\n-      /* Put a REG_EQUAL note on this insn, so that it can be optimized\n-\t by loop.  */\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig,\n-\t\t\t\t\t    REG_NOTES (insn));\n-      return reg;\n-    }\n-  else if (GET_CODE (orig) == CONST)\n-    {\n-      rtx base, offset;\n-\n-      if (GET_CODE (XEXP (orig, 0)) == PLUS\n-\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n-\treturn orig;\n-\n-      if (reg == 0)\n-\t{\n-\t  if (reload_in_progress || reload_completed)\n-\t    abort ();\n-\t  else\n-\t    reg = gen_reg_rtx (Pmode);\n-\t}\n-\n-      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n-\t{\n-\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n-\t  offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t\t   base == reg ? 0 : reg);\n-\t}\n-      else\n-\tabort ();\n-\n-      if (GET_CODE (offset) == CONST_INT)\n-\t{\n-\t  /* The base register doesn't really matter, we only want to\n-\t     test the index for the appropriate mode.  */\n-\t  if (INDEX_REGISTER_RTX_P (offset) && GET_MODE_SIZE (mode) <= 4)\n-\t    goto win;\n-\n-\t  if (! reload_in_progress && ! reload_completed)\n-\t    offset = force_reg (Pmode, offset);\n-\t  else\n-\t    abort ();\n-\n-\twin:\n-\t  if (GET_CODE (offset) == CONST_INT)\n-\t    return plus_constant_for_output (base, INTVAL (offset));\n-\t}\n-\n-      if (GET_MODE_SIZE (mode) > 4)\n-\t{\n-\t  emit_insn (gen_addsi3 (reg, base, offset));\n-\t  return reg;\n-\t}\n-\n-      return gen_rtx_PLUS (Pmode, base, offset);\n-    }\n-  else if (GET_CODE (orig) == LABEL_REF)\n-    current_function_uses_pic_offset_table = 1;\n-\n-  return orig;\n-}\n-\n-static rtx pic_rtx;\n-\n-int\n-is_pic (x)\n-     rtx x;\n-{\n-  if (x == pic_rtx)\n-    return 1;\n-  return 0;\n-}\n-\n-void\n-thumb_finalize_pic ()\n-{\n-#ifndef AOF_ASSEMBLER\n-  rtx l1, pic_tmp, pic_tmp2, seq;\n-  rtx global_offset_table;\n-\n-  if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n-    return;\n-\n-  if (! flag_pic)\n-    abort ();\n-\n-  start_sequence ();\n-  l1 = gen_label_rtx ();\n-\n-  global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-  /* On the Thumb the PC register contains 'dot + 4' at the time of the\n-     addition.  XXX Is this true?  */\n-  pic_tmp = plus_constant (gen_rtx_LABEL_REF (Pmode, l1), 4);\n-  if (GOT_PCREL)\n-    pic_tmp2 = gen_rtx_CONST (VOIDmode,\n-\t\t\t    gen_rtx_PLUS (Pmode, global_offset_table, pc_rtx));\n-  else\n-    pic_tmp2 = gen_rtx_CONST (VOIDmode, global_offset_table);\n-\n-  pic_rtx = gen_rtx_CONST (Pmode, gen_rtx_MINUS (Pmode, pic_tmp2, pic_tmp));\n-  \n-  emit_insn (gen_pic_load_addr (pic_offset_table_rtx, pic_rtx));\n-  emit_insn (gen_pic_add_dot_plus_four (pic_offset_table_rtx, l1));\n-\n-  seq = gen_sequence ();\n-  end_sequence ();\n-  emit_insn_after (seq, get_insns ());\n-\n-  /* Need to emit this whether or not we obey regdecls,\n-     since setjmp/longjmp can cause life info to screw up.  */\n-  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n-#endif /* AOF_ASSEMBLER */\n-}\n-\n-\f\n-/* Routines for handling the constant pool */\n-/* This is unashamedly hacked from the version in sh.c, since the problem is\n-   extremely similar.  */\n-\n-/* Thumb instructions cannot load a large constant into a register,\n-   constants have to come from a pc relative load.  The reference of a pc\n-   relative load instruction must be less than 1k infront of the instruction.\n-   This means that we often have to dump a constant inside a function, and\n-   generate code to branch around it.\n- \n-   It is important to minimize this, since the branches will slow things\n-   down and make things bigger.\n- \n-   Worst case code looks like:\n- \n-\tldr\trn, L1\n-\tb\tL2\n-\talign\n-\tL1:   .long value\n-\tL2:\n-\t..\n- \n-\tldr\trn, L3\n-\tb\tL4\n-\talign\n-\tL3:   .long value\n-\tL4:\n-\t..\n- \n-   We fix this by performing a scan before scheduling, which notices which\n-   instructions need to have their operands fetched from the constant table\n-   and builds the table.\n- \n- \n-   The algorithm is:\n- \n-   scan, find an instruction which needs a pcrel move.  Look forward, find the\n-   last barrier which is within MAX_COUNT bytes of the requirement.\n-   If there isn't one, make one.  Process all the instructions between\n-   the find and the barrier.\n- \n-   In the above example, we can tell that L3 is within 1k of L1, so\n-   the first move can be shrunk from the 2 insn+constant sequence into\n-   just 1 insn, and the constant moved to L3 to make:\n- \n-\tldr\trn, L1\n-\t..\n-\tldr\trn, L3\n-\tb\tL4\n-\talign\n-\tL1:\t.long value\n-\tL3:\t.long value\n-\tL4:\n- \n-   Then the second move becomes the target for the shortening process.\n- \n- */\n- \n-typedef struct\n-{\n-  rtx value;\t\t\t/* Value in table */\n-  HOST_WIDE_INT next_offset;\n-  enum machine_mode mode;\t/* Mode of value */\n-} pool_node;\n-\n-/* The maximum number of constants that can fit into one pool, since\n-   the pc relative range is 0...1020 bytes and constants are at least 4\n-   bytes long */\n-\n-#define MAX_POOL_SIZE (1020/4)\n-static pool_node pool_vector[MAX_POOL_SIZE];\n-static int pool_size;\n-static rtx pool_vector_label;\n-\n-/* Add a constant to the pool and return its label.  */\n- \n-static HOST_WIDE_INT\n-add_constant (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n-{\n-  int i;\n-  HOST_WIDE_INT offset;\n-\n-  if (mode == SImode && GET_CODE (x) == MEM && CONSTANT_P (XEXP (x, 0))\n-      && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n-    x = get_pool_constant (XEXP (x, 0));\n-#ifndef AOF_ASSEMBLER\n-  else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == 3)\n-    x = XVECEXP (x, 0, 0);\n-#endif\n-\n-  /* First see if we've already got it */\n- \n-  for (i = 0; i < pool_size; i++)\n-    {\n-      if (x->code == pool_vector[i].value->code\n-          && mode == pool_vector[i].mode)\n-        {\n-          if (x->code == CODE_LABEL)\n-            {\n-              if (XINT (x, 3) != XINT (pool_vector[i].value, 3))\n-                continue;\n-            }\n-          if (rtx_equal_p (x, pool_vector[i].value))\n-            return pool_vector[i].next_offset - GET_MODE_SIZE (mode);\n-        }\n-    }\n- \n-  /* Need a new one */\n- \n-  pool_vector[pool_size].next_offset = GET_MODE_SIZE (mode);\n-  offset = 0;\n-  if (pool_size == 0)\n-    pool_vector_label = gen_label_rtx ();\n-  else\n-    pool_vector[pool_size].next_offset \n-      += (offset = pool_vector[pool_size - 1].next_offset);\n-\n-  pool_vector[pool_size].value = x;\n-  pool_vector[pool_size].mode = mode;\n-  pool_size++;\n-  return offset;\n-}\n- \n-/* Output the literal table */\n-                    \n-static void         \n-dump_table (scan)\n-     rtx scan;\n-{\n-  int i;\n-\n-  scan = emit_label_after (gen_label_rtx (), scan);\n-  scan = emit_insn_after (gen_align_4 (), scan);\n-  scan = emit_label_after (pool_vector_label, scan);\n-\n-  for (i = 0; i < pool_size; i++)\n-    {\n-      pool_node *p = pool_vector + i;\n-\n-      switch (GET_MODE_SIZE (p->mode))\n-\t{\n-\tcase 4:\n-\t  scan = emit_insn_after (gen_consttable_4 (p->value), scan);\n-\t  break;\n-\n-\tcase 8:\n-\t  scan = emit_insn_after (gen_consttable_8 (p->value), scan);\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t  break;\n-\t}\n-    }\n-\n-  scan = emit_insn_after (gen_consttable_end (), scan);\n-  scan = emit_barrier_after (scan);\n-  pool_size = 0;\n-}\n-\n-/* Non zero if the src operand needs to be fixed up */\n-static int\n-fixit (src, mode)\n-     rtx src;\n-     enum machine_mode mode;\n-{\n-#ifndef AOF_ASSEMBLER\n-  if (GET_CODE (src) == UNSPEC && XINT (src, 1) == 3)\n-    return 1;\n-#endif\n-  return ((CONSTANT_P (src)\n-\t   && (GET_CODE (src) != CONST_INT\n-\t       || ! (CONST_OK_FOR_LETTER_P (INTVAL (src), 'I')\n-\t\t     || CONST_OK_FOR_LETTER_P (INTVAL (src), 'J')\n-\t\t     || (mode != DImode\n-\t\t\t && CONST_OK_FOR_LETTER_P (INTVAL (src), 'K')))))\n-\t  || (mode == SImode && GET_CODE (src) == MEM\n-\t      && GET_CODE (XEXP (src, 0)) == SYMBOL_REF\n-\t      && CONSTANT_POOL_ADDRESS_P (XEXP (src, 0))));\n-}\n-\n-/* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.  */\n-#define MAX_COUNT_SI 1000\n- \n-static rtx\n-find_barrier (from)\n-     rtx from;\n-{\n-  int count = 0;\n-  rtx found_barrier = 0;\n-  rtx label;\n-\n-  while (from && count < MAX_COUNT_SI)\n-    {\n-      if (GET_CODE (from) == BARRIER)\n-\treturn from;\n-\n-      /* Count the length of this insn.  */\n-      if (GET_CODE (from) == INSN\n-\t  && GET_CODE (PATTERN (from)) == SET\n-\t  && CONSTANT_P (SET_SRC (PATTERN (from)))\n-\t  && CONSTANT_POOL_ADDRESS_P (SET_SRC (PATTERN (from))))\n-\tcount += 2;\n-      else\n-\tcount += get_attr_length (from);\n-\n-      from = NEXT_INSN (from);\n-    }\n-\n-  /* We didn't find a barrier in time to\n-     dump our stuff, so we'll make one.  */\n-  label = gen_label_rtx ();\n-  \n-  if (from)\n-    from = PREV_INSN (from);\n-  else\n-    from = get_last_insn ();\n-  \n-  /* Walk back to be just before any jump.  */\n-  while (GET_CODE (from) == JUMP_INSN\n-\t || GET_CODE (from) == NOTE\n-\t || GET_CODE (from) == CODE_LABEL)\n-    from = PREV_INSN (from);\n-\n-  from = emit_jump_insn_after (gen_jump (label), from);\n-  JUMP_LABEL (from) = label;\n-  found_barrier = emit_barrier_after (from);\n-  emit_label_after (label, found_barrier);\n-  \n-  return found_barrier;\n-}\n-\n-/* Non zero if the insn is a move instruction which needs to be fixed.  */\n-static int\n-broken_move (insn)\n-     rtx insn;\n-{\n-  if (!INSN_DELETED_P (insn)\n-      && GET_CODE (insn) == INSN\n-      && GET_CODE (PATTERN (insn)) == SET)\n-    {\n-      rtx pat = PATTERN (insn);\n-      rtx src = SET_SRC (pat);\n-      rtx dst = SET_DEST (pat);\n-      enum machine_mode mode = GET_MODE (dst);\n-      if (dst == pc_rtx)\n-\treturn 0;\n-      return fixit (src, mode);\n-    }\n-  return 0;\n-}\n-\n-/* Recursively search through all of the blocks in a function\n-   checking to see if any of the variables created in that\n-   function match the RTX called 'orig'.  If they do then\n-   replace them with the RTX called 'new'.  */\n-\n-static void\n-replace_symbols_in_block (tree block, rtx orig, rtx new)\n-{\n-  for (; block; block = BLOCK_CHAIN (block))\n-    {\n-      tree sym;\n-      \n-      if (! TREE_USED (block))\n-\tcontinue;\n-\n-      for (sym = BLOCK_VARS (block); sym; sym = TREE_CHAIN (sym))\n-\t{\n-\t  if (  (DECL_NAME (sym) == 0 && TREE_CODE (sym) != TYPE_DECL)\n-\t      || DECL_IGNORED_P (sym)\n-\t      || TREE_CODE (sym) != VAR_DECL\n-\t      || DECL_EXTERNAL (sym)\n-\t      || ! rtx_equal_p (DECL_RTL (sym), orig)\n-\t      )\n-\t    continue;\n-\n-\t  DECL_RTL (sym) = new;\n-\t}\n-      \n-      replace_symbols_in_block (BLOCK_SUBBLOCKS (block), orig, new);\n-    }\n-}\n-\n-void\n-thumb_reorg (first)\n-     rtx first;\n-{\n-  rtx insn;\n-  \n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (broken_move (insn))\n-\t{\n-\t  /* This is a broken move instruction, scan ahead looking for\n-\t     a barrier to stick the constant table behind.  */\n-\t  rtx scan;\n-\t  rtx barrier = find_barrier (insn);\n-\n-\t  /* Now find all the moves between the points and modify them.  */\n-\t  for (scan = insn; scan != barrier; scan = NEXT_INSN (scan))\n-\t    {\n-\t      if (broken_move (scan))\n-\t\t{\n-\t\t  /* This is a broken move instruction, add it to the pool.  */\n-\t\t  rtx pat = PATTERN (scan);\n-\t\t  rtx src = SET_SRC (pat);\n-\t\t  rtx dst = SET_DEST (pat);\n-\t\t  enum machine_mode mode = GET_MODE (dst);\n-\t\t  HOST_WIDE_INT offset;\n-\t\t  rtx newinsn;\n-\t\t  rtx newsrc;\n-\n-\t\t  /* If this is an HImode constant load, convert it into\n-\t\t     an SImode constant load.  Since the register is always\n-\t\t     32 bits this is safe.  We have to do this, since the\n-\t\t     load pc-relative instruction only does a 32-bit load.  */\n-\t\t  if (mode == HImode)\n-\t\t    {\n-\t\t      mode = SImode;\n-\t\t      if (GET_CODE (dst) != REG)\n-\t\t\tabort ();\n-\t\t      PUT_MODE (dst, SImode);\n-\t\t    }\n-\n-\t\t  offset = add_constant (src, mode);\n-\t\t  newsrc = gen_rtx (MEM, mode,\n-\t\t\t\t    plus_constant (gen_rtx (LABEL_REF,\n-\t\t\t\t\t\t\t    VOIDmode, \n-\t\t\t\t\t\t\t    pool_vector_label),\n-\t\t\t\t\t\t   offset));\n-\n-\t\t  /* Build a jump insn wrapper around the move instead\n-\t\t     of an ordinary insn, because we want to have room for\n-\t\t     the target label rtx in fld[7], which an ordinary\n-\t\t     insn doesn't have.  */\n-\t\t  newinsn = emit_jump_insn_after (gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t\t\t   dst, newsrc), scan);\n-\t\t  JUMP_LABEL (newinsn) = pool_vector_label;\n-\n-\t\t  /* But it's still an ordinary insn.  */\n-\t\t  PUT_CODE (newinsn, INSN);\n-\n-\t\t  /* If debugging information is going to be emitted\n-\t\t     then we must make sure that any refences to\n-\t\t     symbols which are removed by the above code are\n-\t\t     also removed in the descriptions of the\n-\t\t     function's variables.  Failure to do this means\n-\t\t     that the debugging information emitted could\n-\t\t     refer to symbols which are not emited by\n-\t\t     output_constant_pool() because\n-\t\t     mark_constant_pool() never sees them as being\n-\t\t     used.  */\n-\t\t  \n-\t\t  /* These are the tests used in\n-\t\t     output_constant_pool() to decide if the constant\n-\t\t     pool will be marked.  Only necessary if debugging\n-\t\t     info is being emitted.  Only necessary for\n-\t\t     references to memory whose address is given by a\n-\t\t     symbol.  */\n-\t\t  if (optimize > 0\n-\t\t      && flag_expensive_optimizations\n-\t\t      && write_symbols != NO_DEBUG\n-\t\t      && GET_CODE (src) == MEM\n-\t\t      && GET_CODE (XEXP (src, 0)) == SYMBOL_REF)\n-\t\t    replace_symbols_in_block\n-\t\t      (DECL_INITIAL (current_function_decl), src, newsrc);\n-\t\t  \n-\t\t  /* Kill old insn.  */\n-\t\t  delete_insn (scan);\n-\t\t  scan = newinsn;\n-\t\t}\n-\t    }\n-\t  \n-\t  dump_table (barrier);\n-\t}\n-    }\n-}\n-\n-\f\n-/* Routines for generating rtl.  */\n-void\n-thumb_expand_movstrqi (operands)\n-     rtx *operands;\n-{\n-  rtx out = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n-  rtx in = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n-  HOST_WIDE_INT len = INTVAL (operands[2]);\n-  HOST_WIDE_INT offset = 0;\n-\n-  while (len >= 12)\n-    {\n-      emit_insn (gen_movmem12b (out, in));\n-      len -= 12;\n-    }\n-  if (len >= 8)\n-    {\n-      emit_insn (gen_movmem8b (out, in));\n-      len -= 8;\n-    }\n-  if (len >= 4)\n-    {\n-      rtx reg = gen_reg_rtx (SImode);\n-      emit_insn (gen_movsi (reg, gen_rtx (MEM, SImode, in)));\n-      emit_insn (gen_movsi (gen_rtx (MEM, SImode, out), reg));\n-      len -= 4;\n-      offset += 4;\n-    }\n-  if (len >= 2)\n-    {\n-      rtx reg = gen_reg_rtx (HImode);\n-      emit_insn (gen_movhi (reg, gen_rtx (MEM, HImode, \n-\t\t\t\t\t  plus_constant (in, offset))));\n-      emit_insn (gen_movhi (gen_rtx (MEM, HImode, plus_constant (out, offset)),\n-\t\t\t    reg));\n-      len -= 2;\n-      offset += 2;\n-    }\n-  if (len)\n-    {\n-      rtx reg = gen_reg_rtx (QImode);\n-      emit_insn (gen_movqi (reg, gen_rtx (MEM, QImode,\n-\t\t\t\t\t  plus_constant (in, offset))));\n-      emit_insn (gen_movqi (gen_rtx (MEM, QImode, plus_constant (out, offset)),\n-\t\t\t    reg));\n-    }\n-}\n-\n-\f\n-/* Routines for reloading */\n-\n-void\n-thumb_reload_out_si (operands)\n-     rtx operands ATTRIBUTE_UNUSED;\n-{\n-  abort ();\n-}\n-\n-\f\n-#ifdef THUMB_PE\n-/* Return non-zero if FUNC is a naked function.  */\n-\n-static int\n-arm_naked_function_p (func)\n-     tree func;\n-{\n-  tree a;\n-\n-  if (TREE_CODE (func) != FUNCTION_DECL)\n-    abort ();\n-\n-  a = lookup_attribute (\"naked\", DECL_MACHINE_ATTRIBUTES (func));\n-  return a != NULL_TREE;\n-}\n-#endif\n-\n-/* Return non-zero if FUNC must be entered in ARM mode.  */\n-int\n-is_called_in_ARM_mode (func)\n-     tree func;\n-{\n-  if (TREE_CODE (func) != FUNCTION_DECL)\n-    abort ();\n-\n-  /* Ignore the problem about functions whoes address is taken.  */\n-  if (TARGET_CALLEE_INTERWORKING && TREE_PUBLIC (func))\n-    return TRUE;\n-\n-#ifdef THUMB_PE \n-  return lookup_attribute (\"interfacearm\", DECL_MACHINE_ATTRIBUTES (func)) != NULL_TREE;\n-#else\n-  return FALSE;\n-#endif\n-}\n-\n-\f\n-/* Routines for emitting code */\n-\n-void\n-thumb_final_prescan_insn (insn)\n-     rtx insn;\n-{\n-  extern int * insn_addresses;\n-\n-  if (flag_print_asm_name)\n-    fprintf (asm_out_file, \"%s 0x%04x\\n\", ASM_COMMENT_START,\n-\t     insn_addresses[INSN_UID (insn)]);\n-}\n-\n-\n-static void thumb_pushpop ( FILE *, int, int ); /* Forward declaration.  */\n-\n-#ifdef __GNUC__\n-inline\n-#endif\n-static int\n-number_of_first_bit_set (mask)\n-     int mask;\n-{\n-  int bit;\n-\n-  for (bit = 0;\n-       (mask & (1 << bit)) == 0;\n-       ++ bit)\n-    continue;\n-\n-  return bit;\n-}\n-\n-#define ARG_1_REGISTER   0\n-#define ARG_2_REGISTER   1\n-#define ARG_3_REGISTER   2\n-#define ARG_4_REGISTER   3\n-#define WORK_REGISTER    7\n-#define FRAME_POINTER\t11\n-#define IP_REGISTER\t12\n-#define STACK_POINTER\tSTACK_POINTER_REGNUM\n-#define LINK_REGISTER\t14\n-#define PROGRAM_COUNTER 15\n-\n-/* Generate code to return from a thumb function.  If\n-   'reg_containing_return_addr' is -1, then the return address is\n-   actually on the stack, at the stack pointer.  */\n-static void\n-thumb_exit (f, reg_containing_return_addr)\n-     FILE * f;\n-     int    reg_containing_return_addr;\n-{\n-  int regs_available_for_popping;\n-  int regs_to_pop;\n-  int pops_needed;\n-  int available;\n-  int required;\n-  int mode;\n-  int size;\n-  int restore_a4 = FALSE;\n-\n-  /* Compute the registers we need to pop.  */\n-  regs_to_pop = 0;\n-  pops_needed = 0;\n-  \n-  if (reg_containing_return_addr == -1)\n-    {\n-      regs_to_pop |= 1 << LINK_REGISTER;\n-      ++ pops_needed;\n-    }\n-\n-  if (TARGET_BACKTRACE)\n-    {\n-      /* Restore frame pointer and stack pointer.  */\n-      regs_to_pop |= (1 << FRAME_POINTER) | (1 << STACK_POINTER);\n-      pops_needed += 2;\n-    }\n-\n-  /* If there is nothing to pop then just emit the BX instruction and return.  */\n-  if (pops_needed == 0)\n-    {\n-      asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names [reg_containing_return_addr]);\n-\n-      return;\n-    }\n-\n-  /* Otherwise if we are not supporting interworking and we have not created\n-     a backtrace structure and the function was not entered in ARM mode then\n-     just pop the return address straight into the PC. */\n-  else if (   ! TARGET_THUMB_INTERWORK\n-\t   && ! TARGET_BACKTRACE\n-\t   && ! is_called_in_ARM_mode (current_function_decl))\n-    {\n-      asm_fprintf (f, \"\\tpop\\t{pc}\\n\" );\n-\n-      return;\n-    }\n-\n-  /* Find out how many of the (return) argument registers we can corrupt. */\n-  regs_available_for_popping = 0;\n-  \n-#ifdef RTX_CODE\n-  /* If we can deduce the registers used from the function's return value.\n-     This is more reliable that examining regs_ever_live[] because that\n-     will be set if the register is ever used in the function, not just if\n-     the register is used to hold a return value.  */\n-\n-  if (current_function_return_rtx != 0)\n-      mode = GET_MODE (current_function_return_rtx);\n-  else\n-#endif\n-      mode = DECL_MODE (DECL_RESULT (current_function_decl));\n-\n-  size = GET_MODE_SIZE (mode);\n-\n-  if (size == 0)\n-    {\n-      /* In a void function we can use any argument register.\n-\t In a function that returns a structure on the stack\n-\t we can use the second and third argument registers.  */\n-      if (mode == VOIDmode)\n-\tregs_available_for_popping =\n-\t    (1 << ARG_1_REGISTER)\n-\t  | (1 << ARG_2_REGISTER)\n-\t  | (1 << ARG_3_REGISTER);\n-      else\n-\tregs_available_for_popping =\n-\t    (1 << ARG_2_REGISTER)\n-\t  | (1 << ARG_3_REGISTER);\n-    }\n-  else if (size <= 4) regs_available_for_popping =\n-\t\t\t  (1 << ARG_2_REGISTER)\n-\t\t\t| (1 << ARG_3_REGISTER);\n-  else if (size <= 8) regs_available_for_popping =\n-\t\t\t(1 << ARG_3_REGISTER);\n-  \n-  /* Match registers to be popped with registers into which we pop them.  */\n-  for (available = regs_available_for_popping,\n-       required  = regs_to_pop;\n-       required != 0 && available != 0;\n-       available &= ~(available & - available),\n-       required  &= ~(required  & - required))\n-    -- pops_needed;\n-\n-  /* If we have any popping registers left over, remove them.  */\n-  if (available > 0)\n-    regs_available_for_popping &= ~ available;\n-  \n-  /* Otherwise if we need another popping register we can use\n-     the fourth argument register.  */\n-  else if (pops_needed)\n-    {\n-      /* If we have not found any free argument registers and\n-\t reg a4 contains the return address, we must move it.  */\n-      if (regs_available_for_popping == 0\n-\t  && reg_containing_return_addr == ARG_4_REGISTER)\n-\t{\n-\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t       reg_names [LINK_REGISTER], reg_names [ARG_4_REGISTER]);\n-\t  reg_containing_return_addr = LINK_REGISTER;\n-\t}\n-      else if (size > 12)\n-\t{\n-\t  /* Register a4 is being used to hold part of the return value,\n-\t     but we have dire need of a free, low register.  */\n-\t  restore_a4 = TRUE;\n-\t  \n-\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t       reg_names [IP_REGISTER], reg_names [ARG_4_REGISTER]);\n-\t}\n-      \n-      if (reg_containing_return_addr != ARG_4_REGISTER)\n-\t{\n-\t  /* The fourth argument register is available.  */\n-\t  regs_available_for_popping |= 1 << ARG_4_REGISTER;\n-\t  \n-\t  -- pops_needed;\n-\t}\n-    }\n-\n-  /* Pop as many registers as we can.  */\n-  thumb_pushpop (f, regs_available_for_popping, FALSE);\n-\n-  /* Process the registers we popped.  */\n-  if (reg_containing_return_addr == -1)\n-    {\n-      /* The return address was popped into the lowest numbered register.  */\n-      regs_to_pop &= ~ (1 << LINK_REGISTER);\n-      \n-      reg_containing_return_addr =\n-\tnumber_of_first_bit_set (regs_available_for_popping);\n-\n-      /* Remove this register for the mask of available registers, so that\n-         the return address will not be corrupted by futher pops.  */\n-      regs_available_for_popping &= ~ (1 << reg_containing_return_addr);\n-    }\n-\n-  /* If we popped other registers then handle them here.  */\n-  if (regs_available_for_popping)\n-    {\n-      int frame_pointer;\n-      \n-      /* Work out which register currently contains the frame pointer.  */\n-      frame_pointer = number_of_first_bit_set (regs_available_for_popping);\n-\n-      /* Move it into the correct place.  */\n-      asm_fprintf (f, \"\\tmov\\tfp, %s\\n\", reg_names [frame_pointer]);\n-\n-      /* (Temporarily) remove it from the mask of popped registers.  */\n-      regs_available_for_popping &= ~ (1 << frame_pointer);\n-      regs_to_pop &= ~ (1 << FRAME_POINTER);\n-      \n-      if (regs_available_for_popping)\n-\t{\n-\t  int stack_pointer;\n-\t  \n-\t  /* We popped the stack pointer as well, find the register that\n-\t     contains it.*/\n-\t  stack_pointer = number_of_first_bit_set (regs_available_for_popping);\n-\n-\t  /* Move it into the stack register.  */\n-\t  asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names [stack_pointer]);\n-\t  \n-\t  /* At this point we have popped all necessary registers, so\n-\t     do not worry about restoring regs_available_for_popping\n-\t     to its correct value:\n-\n-\t     assert (pops_needed == 0)\n-\t     assert (regs_available_for_popping == (1 << frame_pointer))\n-\t     assert (regs_to_pop == (1 << STACK_POINTER))  */\n-\t}\n-      else\n-\t{\n-\t  /* Since we have just move the popped value into the frame\n-\t     pointer, the popping register is available for reuse, and\n-\t     we know that we still have the stack pointer left to pop.  */\n-\t  regs_available_for_popping |= (1 << frame_pointer);\n-\t}\n-    }\n-  \n-  /* If we still have registers left on the stack, but we no longer have\n-     any registers into which we can pop them, then we must move the return\n-     address into the link register and make available the register that\n-     contained it.  */\n-  if (regs_available_for_popping == 0 && pops_needed > 0)\n-    {\n-      regs_available_for_popping |= 1 << reg_containing_return_addr;\n-      \n-      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t   reg_names [LINK_REGISTER],\n-\t\t   reg_names [reg_containing_return_addr]);\n-      \n-      reg_containing_return_addr = LINK_REGISTER;\n-    }\n-\n-  /* If we have registers left on the stack then pop some more.\n-     We know that at most we will want to pop FP and SP.  */\n-  if (pops_needed > 0)\n-    {\n-      int  popped_into;\n-      int  move_to;\n-      \n-      thumb_pushpop (f, regs_available_for_popping, FALSE);\n-\n-      /* We have popped either FP or SP.\n-\t Move whichever one it is into the correct register.  */\n-      popped_into = number_of_first_bit_set (regs_available_for_popping);\n-      move_to     = number_of_first_bit_set (regs_to_pop);\n-\n-      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t   reg_names [move_to], reg_names [popped_into]);\n-\n-      regs_to_pop &= ~ (1 << move_to);\n-\n-      -- pops_needed;\n-    }\n-  \n-  /* If we still have not popped everything then we must have only\n-     had one register available to us and we are now popping the SP.  */\n-  if (pops_needed > 0)\n-    {\n-      int  popped_into;\n-      \n-      thumb_pushpop (f, regs_available_for_popping, FALSE);\n-\n-      popped_into = number_of_first_bit_set (regs_available_for_popping);\n-\n-      asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names [popped_into]);\n-\n-      /*\n-\tassert (regs_to_pop == (1 << STACK_POINTER))\n-\tassert (pops_needed == 1)\n-      */\n-    }\n-\n-  /* If necessary restore the a4 register.  */\n-  if (restore_a4)\n-    {\n-      if (reg_containing_return_addr != LINK_REGISTER)\n-\t{\n-\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t       reg_names [LINK_REGISTER], reg_names [ARG_4_REGISTER]);\n-\t  reg_containing_return_addr = LINK_REGISTER;\n-\t}\n-    \n-      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t   reg_names [ARG_4_REGISTER], reg_names [IP_REGISTER]);\n-    }\n-  \n-  /* Return to caller.  */\n-  asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names [reg_containing_return_addr]);\n-}\n-\n-/* Emit code to push or pop registers to or from the stack.  */\n-static void\n-thumb_pushpop (f, mask, push)\n-     FILE * f;\n-     int mask;\n-     int push;\n-{\n-  int regno;\n-  int lo_mask = mask & 0xFF;\n-\n-  if (lo_mask == 0 && ! push && (mask & (1 << 15)))\n-    {\n-      /* Special case.  Do not generate a POP PC statement here, do it in\n-\t thumb_exit() */\n-      \n-      thumb_exit (f, -1);\n-      return;\n-    }\n-      \n-  asm_fprintf (f, \"\\t%s\\t{\", push ? \"push\" : \"pop\");\n-\n-  /* Look at the low registers first.  */\n-  \n-  for (regno = 0; regno < 8; regno ++, lo_mask >>= 1)\n-    {\n-      if (lo_mask & 1)\n-\t{\n-\t  asm_fprintf (f, reg_names[regno]);\n-\t  \n-\t  if ((lo_mask & ~1) != 0)\n-\t    asm_fprintf (f, \", \");\n-\t}\n-    }\n-  \n-  if (push && (mask & (1 << 14)))\n-    {\n-      /* Catch pushing the LR.  */\n-\n-      if (mask & 0xFF)\n-\tasm_fprintf (f, \", \");\n-      \n-      asm_fprintf (f, reg_names[14]);\n-    }\n-  else if (!push && (mask & (1 << 15)))\n-    {\n-      /* Catch popping the PC.  */\n-      \n-      if (TARGET_THUMB_INTERWORK || TARGET_BACKTRACE)\n-\t{\n-\t  /* The PC is never poped directly, instead\n-\t     it is popped into r3 and then BX is used. */\n-\t  \n-\t  asm_fprintf (f, \"}\\n\");\n-\n-\t  thumb_exit (f, -1);\n-\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  if (mask & 0xFF)\n-\t    asm_fprintf (f, \", \");\n-\t  \n-\t  asm_fprintf (f, reg_names[15]);\n-\t}\n-    }\n-       \n-  asm_fprintf (f, \"}\\n\");\n-}\n-\n-/* Returns non-zero if the current function contains a far jump */\n-\n-int\n-far_jump_used_p (void)\n-{\n-  rtx insn;\n-  \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == JUMP_INSN\n-\t  /* Ignore tablejump patterns.  */\n-\t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n-\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n-\t  && get_attr_far_jump (insn) == FAR_JUMP_YES)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-static int return_used_this_function = 0;\n-\n-char *\n-output_return ()\n-{\n-  int regno;\n-  int live_regs_mask = 0;\n-\n-#ifdef THUMB_PE\n-  /* If a function is naked, don't use the \"return\" insn.  */\n-  if (arm_naked_function_p (current_function_decl))\n-    return \"\";\n-#endif\n-\n-  return_used_this_function = 1;\n-\n-  for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n-      live_regs_mask |= 1 << regno;\n-\n-  if (live_regs_mask == 0)\n-    {\n-      if (leaf_function_p () && ! far_jump_used_p())\n-\t{\n-\t  thumb_exit (asm_out_file, 14);\t      \n-\t}\n-      else if (   TARGET_THUMB_INTERWORK\n-\t       || TARGET_BACKTRACE\n-\t       || is_called_in_ARM_mode (current_function_decl))\n-\t{\n-\t  thumb_exit (asm_out_file, -1);\n-\t}\n-      else\n-\tasm_fprintf (asm_out_file, \"\\tpop\\t{pc}\\n\");\n-    }\n-  else\n-    {\n-      asm_fprintf (asm_out_file,  \"\\tpop\\t{\");\n-      \n-      for (regno = 0; live_regs_mask; regno ++, live_regs_mask >>= 1)\n-\tif (live_regs_mask & 1)\n-\t  {\n-\t    asm_fprintf (asm_out_file, reg_names[regno]);\n-\t    if (live_regs_mask & ~1)\n-\t\tasm_fprintf (asm_out_file, \", \");\n-\t  }\n-\n-      if (   TARGET_THUMB_INTERWORK\n-\t  || TARGET_BACKTRACE\n-\t  || is_called_in_ARM_mode (current_function_decl))\n-\t{\n-\t  asm_fprintf (asm_out_file, \"}\\n\");\n-\t  thumb_exit (asm_out_file, -1);\n-\t}\n-      else\n-\tasm_fprintf (asm_out_file, \", pc}\\n\");\n-    }\n-  \n-  return \"\";\n-}\n-\n-void\n-thumb_function_prologue (f, frame_size)\n-     FILE * f;\n-     int frame_size ATTRIBUTE_UNUSED;\n-{\n-  int live_regs_mask = 0;\n-  int high_regs_pushed = 0;\n-  int store_arg_regs = 0;\n-  int regno;\n-\n-#ifdef THUMB_PE\n-  if (arm_naked_function_p (current_function_decl))\n-    return;\n-#endif\n-\n-  if (is_called_in_ARM_mode (current_function_decl))\n-    {\n-      const char * name;\n-      \n-      if (GET_CODE (DECL_RTL (current_function_decl)) != MEM)\n-\tabort();\n-      if (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0)) != SYMBOL_REF)\n-\tabort();\n-      name = XSTR  (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-      \n-      /* Generate code sequence to switch us into Thumb mode.  */\n-      /* The .code 32 directive has already been emitted by\n-\t ASM_DECLARE_FUNCITON_NAME */\n-      asm_fprintf (f, \"\\torr\\tr12, pc, #1\\n\");\n-      asm_fprintf (f, \"\\tbx\\tr12\\n\");\n-\n-      /* Generate a label, so that the debugger will notice the\n-\t change in instruction sets.  This label is also used by\n-\t the assembler to bypass the ARM code when this function\n-\t is called from a Thumb encoded function elsewhere in the\n-\t same file.  Hence the definition of STUB_NAME here must\n-\t agree with the definition in gas/config/tc-arm.c  */\n-      \n-#define STUB_NAME \".real_start_of\"\n-      \n-      asm_fprintf (f, \"\\t.code\\t16\\n\");\n-      \n-#ifdef THUMB_PE\n-      if (arm_dllexport_name_p (name))\n-        name = ARM_STRIP_NAME_ENCODING (name);\n-#endif        \n-\n-      asm_fprintf (f, \"\\t.globl %s%U%s\\n\", STUB_NAME, name);\n-      asm_fprintf (f, \"\\t.thumb_func\\n\");\n-      asm_fprintf (f, \"%s%U%s:\\n\", STUB_NAME, name);\n-    }\n-    \n-  if (current_function_anonymous_args && current_function_pretend_args_size)\n-    store_arg_regs = 1;\n-\n-  if (current_function_pretend_args_size)\n-    {\n-      if (store_arg_regs)\n-\t{\n-\t  asm_fprintf (f, \"\\tpush\\t{\");\n-\t  for (regno = 4 - current_function_pretend_args_size / 4 ; regno < 4;\n-\t       regno++)\n-\t    asm_fprintf (f, \"%s%s\", reg_names[regno], regno == 3 ? \"\" : \", \");\n-\t  asm_fprintf (f, \"}\\n\");\n-\t}\n-      else\n-\tasm_fprintf (f, \"\\tsub\\t%Rsp, %Rsp, #%d\\n\", \n-\t\t     current_function_pretend_args_size);\n-    }\n-\n-  for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n-      live_regs_mask |= 1 << regno;\n-\n-  if (live_regs_mask || ! leaf_function_p () || far_jump_used_p ())\n-    live_regs_mask |= 1 << 14;\n-\n-  if (TARGET_BACKTRACE)\n-    {\n-      const char * name;\n-      int    offset;\n-      int    work_register = 0;\n-      \n-      /* We have been asked to create a stack backtrace structure.\n-         The code looks like this:\n-\t \n-\t 0   .align 2\n-\t 0   func:\n-         0     sub   SP, #16         Reserve space for 4 registers.\n-\t 2     push  {R7}            Get a work register.\n-         4     add   R7, SP, #20     Get the stack pointer before the push.\n-         6     str   R7, [SP, #8]    Store the stack pointer (before reserving the space).\n-         8     mov   R7, PC          Get hold of the start of this code plus 12.\n-        10     str   R7, [SP, #16]   Store it.\n-        12     mov   R7, FP          Get hold of the current frame pointer.\n-        14     str   R7, [SP, #4]    Store it.\n-        16     mov   R7, LR          Get hold of the current return address.\n-        18     str   R7, [SP, #12]   Store it.\n-        20     add   R7, SP, #16     Point at the start of the backtrace structure.\n-        22     mov   FP, R7          Put this value into the frame pointer.  */\n-\n-      if ((live_regs_mask & 0xFF) == 0)\n-\t{\n-\t  /* See if the a4 register is free.  */\n-\n-\t  if (regs_ever_live [3] == 0)\n-\t    work_register = 3;\n-\t  else\t  /* We must push a register of our own */\n-\t    live_regs_mask |= (1 << 7);\n-\t}\n-\n-      if (work_register == 0)\n-\t{\n-\t  /* Select a register from the list that will be pushed to use as our work register. */\n-\n-\t  for (work_register = 8; work_register--;)\n-\t    if ((1 << work_register) & live_regs_mask)\n-\t      break;\n-\t}\n-      \n-      name = reg_names [work_register];\n-      \n-      asm_fprintf (f, \"\\tsub\\tsp, sp, #16\\t@ Create stack backtrace structure\\n\");\n-      \n-      if (live_regs_mask)\n-\tthumb_pushpop (f, live_regs_mask, 1);\n-      \n-      for (offset = 0, work_register = 1 << 15; work_register; work_register >>= 1)\n-\tif (work_register & live_regs_mask)\n-\t  offset += 4;\n-      \n-      asm_fprintf (f, \"\\tadd\\t%s, sp, #%d\\n\",\n-\t\t   name, offset + 16 + current_function_pretend_args_size);\n-      \n-      asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 4);\n-\n-      /* Make sure that the instruction fetching the PC is in the right place\n-\t to calculate \"start of backtrace creation code + 12\".  */\n-      \n-      if (live_regs_mask)\n-\t{\n-\t  asm_fprintf (f, \"\\tmov\\t%s, pc\\n\", name);\n-\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 12);\n-\t  asm_fprintf (f, \"\\tmov\\t%s, fp\\n\", name);\n-\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset);\n-\t}\n-      else\n-\t{\n-\t  asm_fprintf (f, \"\\tmov\\t%s, fp\\n\", name);\n-\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset);\n-\t  asm_fprintf (f, \"\\tmov\\t%s, pc\\n\", name);\n-\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 12);\n-\t}\n-      \n-      asm_fprintf (f, \"\\tmov\\t%s, lr\\n\", name);\n-      asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 8);\n-      asm_fprintf (f, \"\\tadd\\t%s, sp, #%d\\n\", name, offset + 12);\n-      asm_fprintf (f, \"\\tmov\\tfp, %s\\t\\t@ Backtrace structure created\\n\", name);\n-    }\n-  else if (live_regs_mask)\n-    thumb_pushpop (f, live_regs_mask, 1);\n-\n-  for (regno = 8; regno < 13; regno++)\n-    {\n-      if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t  && ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n-\thigh_regs_pushed++;\n-    }\n-\n-  if (high_regs_pushed)\n-    {\n-      int pushable_regs = 0;\n-      int mask = live_regs_mask & 0xff;\n-      int next_hi_reg;\n-\n-      for (next_hi_reg = 12; next_hi_reg > 7; next_hi_reg--)\n-\t{\n-\t  if (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg]\n-\t      && ! (TARGET_SINGLE_PIC_BASE && (next_hi_reg == thumb_pic_register)))\n-\t    break;\n-\t}\n-\n-      pushable_regs = mask;\n-\n-      if (pushable_regs == 0)\n-\t{\n-\t  /* desperation time -- this probably will never happen */\n-\t  if (regs_ever_live[3] || ! call_used_regs[3])\n-\t    asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[12], reg_names[3]);\n-\t  mask = 1 << 3;\n-\t}\n-\n-      while (high_regs_pushed > 0)\n-\t{\n-\t  for (regno = 7; regno >= 0; regno--)\n-\t    {\n-\t      if (mask & (1 << regno))\n-\t\t{\n-\t\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[regno],\n-\t\t\t       reg_names[next_hi_reg]);\n-\t\t  high_regs_pushed--;\n-\t\t  if (high_regs_pushed)\n-\t\t    for (next_hi_reg--; next_hi_reg > 7; next_hi_reg--)\n-\t\t      {\n-\t\t\tif (regs_ever_live[next_hi_reg]\n-\t\t\t    && ! call_used_regs[next_hi_reg]\n-\t\t\t    && ! (TARGET_SINGLE_PIC_BASE \n-\t\t\t\t  && (next_hi_reg == thumb_pic_register)))\n-\t\t\t  break;\n-\t\t      }\n-\t\t  else\n-\t\t    {\n-\t\t      mask &= ~ ((1 << regno) - 1);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  thumb_pushpop (f, mask, 1);\n-\t}\n-\n-      if (pushable_regs == 0 && (regs_ever_live[3] || ! call_used_regs[3]))\n-\t    asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[3], reg_names[12]);\n-    }\n-}\n-\n-/* Functions to save and restore thumb_return_addr_rtx.  */\n-static rtx thumb_return_addr_rtx = NULL_RTX;\n-\n-struct machine_function\n-{\n-  rtx ra_rtx;\n-};\n-\n-static void\n-thumb_save_machine_status (p)\n-     struct function * p;\n-{\n-  struct machine_function * machine =\n-    (struct machine_function *) xmalloc (sizeof (* machine));\n-\n-  p->machine = machine;\n-  machine->ra_rtx = thumb_return_addr_rtx;\n-}\n-\n-static void\n-thumb_restore_machine_status (p)\n-     struct function * p;\n-{\n-  struct machine_function * machine = p->machine;\n-\n-  thumb_return_addr_rtx = machine->ra_rtx;\n-\n-  free (machine);\n-  \n-  p->machine = (struct machine_function *) NULL;\n-}\n-\n-/* Return an RTX indicating where the return address to the\n-   calling function can be found.  */\n-rtx\n-thumb_return_addr (count)\n-     int count;\n-{\n-  if (count != 0)\n-    return NULL_RTX;\n-\n-  if (thumb_return_addr_rtx == NULL_RTX)\n-    {\n-      rtx init;\n-      \n-      thumb_return_addr_rtx = gen_reg_rtx (Pmode);\n-      \n-      init = gen_rtx_REG (Pmode, 14);\n-\n-      init = gen_rtx_SET (VOIDmode, thumb_return_addr_rtx, init);\n-\n-      /* Emit the insn to the prologue with the other argument copies.  */\n-      push_topmost_sequence ();\n-      emit_insn_after (init, get_insns ());\n-      pop_topmost_sequence ();\n-    }\n-\n-  return thumb_return_addr_rtx;\n-}\n-\n-/* Do anything needed before RTL is emitted for each function.  */\n-void\n-thumb_init_expanders ()\n-{\n-  thumb_return_addr_rtx = NULL_RTX;\n-\n-  /* Arrange to save and restore machine status around nested functions.  */\n-  save_machine_status    = thumb_save_machine_status;\n-  restore_machine_status = thumb_restore_machine_status;\n-}\n-\n-void\n-thumb_expand_prologue ()\n-{\n-  HOST_WIDE_INT amount = (get_frame_size ()\n-\t\t\t  + current_function_outgoing_args_size);\n-#ifdef THUMB_PE\n-  /* Naked functions don't have prologues.  */\n-  if (arm_naked_function_p (current_function_decl))\n-    return;\n-#endif\n-  \n-  if (amount)\n-    {\n-      if (amount < 512)\n-\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (- amount)));\n-      else\n-\t{\n-\t  int regno;\n-\t  rtx reg;\n-\t  \n-\t  /* The stack decrement is too big for an immediate value in a single\n-\t     insn.  In theory we could issue multiple subtracts, but after\n-\t     three of them it becomes more space efficient to place the full\n-\t     value in the constant pool and load into a register.  (Also the\n-\t     ARM debugger really likes to see only one stack decrement per\n-\t     function).  So instead we look for a scratch register into which\n-\t     we can load the decrement, and then we subtract this from the\n-\t     stack pointer.  Unfortunately on the thumb the only available\n-\t     scratch registers are the argument registers, and we cannot use\n-\t     these as they may hold arguments to the function.  Instead we\n-\t     attempt to locate a call preserved register which is used by this\n-\t     function.  If we can find one, then we know that it will have\n-\t     been pushed at the start of the prologue and so we can corrupt\n-\t     it now.  */\n-\t  for (regno = 4; regno < 8; regno++)\n-\t    if (regs_ever_live[regno]\n-\t\t&& ! call_used_regs[regno] /* Paranoia */\n-\t\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n-\t      break;\n-\n-\t  if (regno == 8) /* Very unlikely */\n-\t    {\n-\t      rtx spare = gen_rtx (REG, SImode, 12);\n-\n-\t      /* Choose an arbitary, non-argument low register.  */\n-\t      reg = gen_rtx (REG, SImode, 4);\n-\n-\t      /* Save it by copying it into a high, scratch register.  */\n-\t      emit_insn (gen_movsi (spare, reg));\n-\n-\t      /* Decrement the stack.  */\n-\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n-\t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t     reg));\n-\n-\t      /* Restore the low register's original value.  */\n-\t      emit_insn (gen_movsi (reg, spare));\n-\t      \n-\t      /* Emit a USE of the restored scratch register, so that flow\n-\t\t analysis will not consider the restore redundant.  The\n-\t\t register won't be used again in this function and isn't\n-\t\t restored by the epilogue.  */\n-\t      emit_insn (gen_rtx_USE (VOIDmode, reg));\n-\t    }\n-\t  else\n-\t    {\n-\t      reg = gen_rtx (REG, SImode, regno);\n-\n-\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n-\t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t     reg));\n-\t    }\n-\t}\n-    }\n-\n-  /* This should only happen with optimisation disabled.  Emit the copy\n-     *after* the stack adjust, as the unoptimised code will attempt to store\n-     local variables at positive offsets from the frame pointer.  */\n-  if (frame_pointer_needed)\n-    {\n-      if (current_function_outgoing_args_size)\n-\t{\n-\t  rtx offset = GEN_INT (current_function_outgoing_args_size);\n-\n-\t  if (current_function_outgoing_args_size < 1024)\n-\t    emit_insn (gen_addsi3 (frame_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   offset));\n-\t  else\n-\t    {\n-\t      emit_insn (gen_movsi (frame_pointer_rtx, offset));\n-\t      emit_insn (gen_addsi3 (frame_pointer_rtx, frame_pointer_rtx,\n-\t\t\t\t     stack_pointer_rtx));\n-\t    }\n-\t}\n-      else\n-\temit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n-    }\n-\n-  if (profile_flag || profile_block_flag)\n-    emit_insn (gen_blockage ());\n-}\n-\n-void\n-thumb_expand_epilogue ()\n-{\n-  HOST_WIDE_INT amount = (get_frame_size ()\n-\t\t\t  + current_function_outgoing_args_size);\n-#ifdef THUMB_PE\n-  /* Naked functions don't have epilogues.  */\n-  if (arm_naked_function_p (current_function_decl))\n-    return;\n-#endif\n-\n-  if (amount)\n-    {\n-      if (amount < 512)\n-\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (amount)));\n-      else\n-\t{\n-\t  rtx reg = gen_rtx (REG, SImode, 3); /* Always free in the epilogue */\n-\n-\t  emit_insn (gen_movsi (reg, GEN_INT (amount)));\n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));\n-\t}\n-    }\n-  \n-  /* Emit a USE (stack_pointer_rtx), so that\n-     the stack adjustment will not be deleted.  */\n-  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n-\n-  if (profile_flag || profile_block_flag)\n-    emit_insn (gen_blockage ());\n-}\n-\n-void\n-thumb_function_epilogue (f, frame_size)\n-     FILE * f ATTRIBUTE_UNUSED;\n-     int frame_size ATTRIBUTE_UNUSED;\n-{\n-  /* ??? Probably not safe to set this here, since it assumes that a\n-     function will be emitted as assembly immediately after we generate\n-     RTL for it.  This does not happen for inline functions.  */\n-  return_used_this_function = 0;\n-#if 0 /* TODO : comment not really needed */\n-  fprintf (f, \"%s THUMB Epilogue\\n\", ASM_COMMENT_START);\n-#endif\n-}\n-\n-/* The bits which aren't usefully expanded as rtl.  */\n-char *\n-thumb_unexpanded_epilogue ()\n-{\n-  int regno;\n-  int live_regs_mask = 0;\n-  int high_regs_pushed = 0;\n-  int leaf_function = leaf_function_p ();\n-  int had_to_push_lr;\n-\n-  if (return_used_this_function)\n-    return \"\";\n-\n-  for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n-      live_regs_mask |= 1 << regno;\n-\n-  for (regno = 8; regno < 13; regno++)\n-    {\n-      if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t  && ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n-\thigh_regs_pushed ++;\n-    }\n-\n-  /* The prolog may have pushed some high registers to use as\n-     work registers.  eg the testuite file:\n-     gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c\n-     compiles to produce:\n-\tpush\t{r4, r5, r6, r7, lr}\n-\tmov\tr7, r9\n-\tmov\tr6, r8\n-\tpush\t{r6, r7}\n-     as part of the prolog.  We have to undo that pushing here.  */\n-  \n-  if (high_regs_pushed)\n-    {\n-      int mask = live_regs_mask;\n-      int next_hi_reg;\n-      int size;\n-      int mode;\n-       \n-#ifdef RTX_CODE\n-      /* If we can deduce the registers used from the function's return value.\n-\t This is more reliable that examining regs_ever_live[] because that\n-\t will be set if the register is ever used in the function, not just if\n-\t the register is used to hold a return value.  */\n-\n-      if (current_function_return_rtx != 0)\n-\tmode = GET_MODE (current_function_return_rtx);\n-      else\n-#endif\n-\tmode = DECL_MODE (DECL_RESULT (current_function_decl));\n-\n-      size = GET_MODE_SIZE (mode);\n-\n-      /* Unless we are returning a type of size > 12 register r3 is available.  */\n-      if (size < 13)\n-\tmask |=  1 << 3;\n-\n-      if (mask == 0)\n-\t/* Oh dear!  We have no low registers into which we can pop high registers!  */\n-\tfatal (\"No low registers available for popping high registers\");\n-      \n-      for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n-\tif (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg]\n-\t    && ! (TARGET_SINGLE_PIC_BASE && (next_hi_reg == thumb_pic_register)))\n-\t  break;\n-\n-      while (high_regs_pushed)\n-\t{\n-\t  /* Find low register(s) into which the high register(s) can be popped.  */\n-\t  for (regno = 0; regno < 8; regno++)\n-\t    {\n-\t      if (mask & (1 << regno))\n-\t\thigh_regs_pushed--;\n-\t      if (high_regs_pushed == 0)\n-\t\tbreak;\n-\t    }\n-\n-\t  mask &= (2 << regno) - 1;\t/* A noop if regno == 8 */\n-\n-\t  /* Pop the values into the low register(s). */\n-\t  thumb_pushpop (asm_out_file, mask, 0);\n-\n-\t  /* Move the value(s) into the high registers.  */\n-\t  for (regno = 0; regno < 8; regno++)\n-\t    {\n-\t      if (mask & (1 << regno))\n-\t\t{\n-\t\t  asm_fprintf (asm_out_file, \"\\tmov\\t%s, %s\\n\", \n-\t\t\t       reg_names[next_hi_reg], reg_names[regno]);\n-\t\t  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)\n-\t\t    if (regs_ever_live[next_hi_reg] && \n-\t\t\t! call_used_regs[next_hi_reg]\n-\t\t\t&& ! (TARGET_SINGLE_PIC_BASE \n-\t\t\t      && (next_hi_reg == thumb_pic_register)))\n-\t\t      break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  had_to_push_lr = (live_regs_mask || ! leaf_function || far_jump_used_p());\n-  \n-  if (TARGET_BACKTRACE && ((live_regs_mask & 0xFF) == 0) && regs_ever_live[ ARG_4_REGISTER ] != 0)\n-    /* The stack backtrace structure creation code had to\n-       push R7 in order to get a work register, so we pop\n-       it now.   */\n-    live_regs_mask |= (1 << WORK_REGISTER);\n-  \n-  if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n-    {\n-      if (had_to_push_lr\n-\t  && ! is_called_in_ARM_mode (current_function_decl))\n-\tlive_regs_mask |= 1 << PROGRAM_COUNTER;\n-\n-      /* Either no argument registers were pushed or a backtrace\n-\t structure was created which includes an adjusted stack\n-\t pointer, so just pop everything.  */\n-      if (live_regs_mask)\n-\tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n-      \n-      /* We have either just popped the return address into the\n-\t PC or it is was kept in LR for the entire function or\n-\t it is still on the stack because we do not want to\n-\t return by doing a pop {pc}.  */\n-      if ((live_regs_mask & (1 << PROGRAM_COUNTER)) == 0)\n-\tthumb_exit (asm_out_file,\n-\t\t    (had_to_push_lr\n-\t\t     && is_called_in_ARM_mode (current_function_decl)) ?\n-\t\t    -1 : LINK_REGISTER);\n-    }\n-  else\n-    {\n-      /* Pop everything but the return address.  */\n-      live_regs_mask &= ~ (1 << PROGRAM_COUNTER);\n-      \n-      if (live_regs_mask)\n-\tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n-\n-      if (had_to_push_lr)\n-\t/* Get the return address into a temporary register.  */\n-\tthumb_pushpop (asm_out_file, 1 << ARG_4_REGISTER, 0);\n-      \n-      /* Remove the argument registers that were pushed onto the stack.  */\n-      asm_fprintf (asm_out_file, \"\\tadd\\t%s, %s, #%d\\n\",\n-\t\t   reg_names [STACK_POINTER],\n-\t\t   reg_names [STACK_POINTER],\n-\t\t   current_function_pretend_args_size);\n-      \n-      thumb_exit (asm_out_file, had_to_push_lr ? ARG_4_REGISTER : LINK_REGISTER);\n-    }\n-\n-  return \"\";\n-}\n-\n-/* Handle the case of a double word load into a low register from\n-   a computed memory address.  The computed address may involve a\n-   register which is overwritten by the load.  */\n-\n-char *\n-thumb_load_double_from_address (operands)\n-     rtx * operands;\n-{\n-  rtx addr;\n-  rtx base;\n-  rtx offset;\n-  rtx arg1;\n-  rtx arg2;\n-  \n-  if (GET_CODE (operands[0]) != REG)\n-    fatal (\"thumb_load_double_from_address: destination is not a register\");\n-  \n-  if (GET_CODE (operands[1]) != MEM)\n-    fatal (\"thumb_load_double_from_address: source is not a computed memory address\");\n-\n-  /* Get the memory address.  */\n-  \n-  addr = XEXP (operands[1], 0);\n-      \n-  /* Work out how the memory address is computed.  */\n-\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n-\n-      if (REGNO (operands[0]) == REGNO (addr))\n-\t{\n-\t  output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t  output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t  output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t}\n-      break;\n-      \n-    case CONST:\n-      /* Compute <address> + 4 for the high order load.  */\n-\t  \n-      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n-\t  \n-      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-      break;\n-\t  \n-    case PLUS:\n-      arg1   = XEXP (addr, 0);\n-      arg2   = XEXP (addr, 1);\n-\t    \n-      if (CONSTANT_P (arg1))\n-\tbase = arg2, offset = arg1;\n-      else\n-\tbase = arg1, offset = arg2;\n-  \n-      if (GET_CODE (base) != REG)\n-\tfatal (\"thumb_load_double_from_address: base is not a register\");\n-\n-      /* Catch the case of <address> = <reg> + <reg> */\n-  \n-      if (GET_CODE (offset) == REG)\n-\t{\n-\t  int reg_offset = REGNO (offset);\n-\t  int reg_base   = REGNO (base);\n-\t  int reg_dest   = REGNO (operands[0]);\n-\t  \n-\t  /* Add the base and offset registers together into the higher destination register.  */\n-\t  \n-\t  fprintf (asm_out_file, \"\\tadd\\t%s, %s, %s\\t\\t%s created by thumb_load_double_from_address\",\n-\t\t   reg_names[ reg_dest + 1 ],\n-\t\t   reg_names[ reg_base     ],\n-\t\t   reg_names[ reg_offset   ],\n-\t\t   ASM_COMMENT_START);\n-\t  \n-\t  /* Load the lower destination register from the address in the higher destination register.  */\n-\t  \n-\t  fprintf (asm_out_file, \"\\tldr\\t%s, [%s, #0]\\t\\t%s created by thumb_load_double_from_address\",\n-\t\t   reg_names[ reg_dest ],\n-\t\t   reg_names[ reg_dest + 1],\n-\t\t   ASM_COMMENT_START);\n-\t  \n-\t  /* Load the higher destination register from its own address plus 4.  */\n-\t  \n-\t  fprintf (asm_out_file, \"\\tldr\\t%s, [%s, #4]\\t\\t%s created by thumb_load_double_from_address\",\n-\t\t   reg_names[ reg_dest + 1 ],\n-\t\t   reg_names[ reg_dest + 1 ],\n-\t\t   ASM_COMMENT_START);\n-\t}\n-      else\n-\t{\n-\t  /* Compute <address> + 4 for the high order load.  */\n-\t  \n-\t  operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n-\t  \n-\t  /* If the computed address is held in the low order register\n-\t     then load the high order register first, otherwise always\n-\t     load the low order register first.  */\n-      \n-\t  if (REGNO (operands[0]) == REGNO (base))\n-\t    {\n-\t      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-\t    }\n-\t}\n-      break;\n-\n-    case LABEL_REF:\n-      /* With no registers to worry about we can just load the value directly.  */\n-      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n-\t  \n-      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n-      break;\n-      \n-    default:\n-      debug_rtx (operands[1]);\n-      fatal (\"thumb_load_double_from_address: Unhandled address calculation\");\n-      break;\n-    }\n-  \n-  return \"\";\n-}\n-\n-char *\n-output_move_mem_multiple (n, operands)\n-     int n;\n-     rtx *operands;\n-{\n-  rtx tmp;\n-\n-  switch (n)\n-    {\n-    case 2:\n-      if (REGNO (operands[2]) > REGNO (operands[3]))\n-\t{\n-\t  tmp = operands[2];\n-\t  operands[2] = operands[3];\n-\t  operands[3] = tmp;\n-\t}\n-      output_asm_insn (\"ldmia\\t%1!, {%2, %3}\", operands);\n-      output_asm_insn (\"stmia\\t%0!, {%2, %3}\", operands);\n-      break;\n-\n-    case 3:\n-      if (REGNO (operands[2]) > REGNO (operands[3]))\n-\t{\n-\t  tmp = operands[2];\n-\t  operands[2] = operands[3];\n-\t  operands[3] = tmp;\n-\t}\n-      if (REGNO (operands[3]) > REGNO (operands[4]))\n-\t{\n-\t  tmp = operands[3];\n-\t  operands[3] = operands[4];\n-\t  operands[4] = tmp;\n-\t}\n-      if (REGNO (operands[2]) > REGNO (operands[3]))\n-\t{\n-\t  tmp = operands[2];\n-\t  operands[2] = operands[3];\n-\t  operands[3] = tmp;\n-\t}\n-      output_asm_insn (\"ldmia\\t%1!, {%2, %3, %4}\", operands);\n-      output_asm_insn (\"stmia\\t%0!, {%2, %3, %4}\", operands);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  return \"\";\n-}\n-\n-  \n-int\n-thumb_epilogue_size ()\n-{\n-  return 42; /* The answer to .... */\n-}\n-\n-static char *conds[] =\n-{\n-  \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\", \n-  \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\"\n-};\n-\n-static char *\n-thumb_condition_code (x, invert)\n-     rtx x;\n-     int invert;\n-{\n-  int val;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case EQ: val = 0; break;\n-    case NE: val = 1; break;\n-    case GEU: val = 2; break;\n-    case LTU: val = 3; break;\n-    case GTU: val = 8; break;\n-    case LEU: val = 9; break;\n-    case GE: val = 10; break;\n-    case LT: val = 11; break;\n-    case GT: val = 12; break;\n-    case LE: val = 13; break;\n-    default:\n-      abort ();\n-    }\n-\n-  return conds[val ^ invert];\n-}\n-\n-void\n-thumb_print_operand (f, x, code)\n-     FILE *f;\n-     rtx x;\n-     int code;\n-{\n-  if (code)\n-    {\n-      switch (code)\n-\t{\n-\tcase '@':\n-\t  fputs (ASM_COMMENT_START, f);\n-\t  return;\n-\n-\tcase '|':\n-\t  /* fputs (REGISTER_PREFIX, f); */\n-\t  return;\n-\n-\tcase '_':\n-\t  fputs (user_label_prefix, f);\n-\t  return;\n-\t  \n-\tcase 'D':\n-\t  if (x)\n-\t    fputs (thumb_condition_code (x, 1), f);\n-\t  return;\n-\n-\tcase 'd':\n-\t  if (x)\n-\t    fputs (thumb_condition_code (x, 0), f);\n-\t  return;\n-\n-\t  /* An explanation of the 'Q', 'R' and 'H' register operands:\n-\t     \n-\t     In a pair of registers containing a DI or DF value the 'Q'\n-\t     operand returns the register number of the register containing\n-\t     the least signficant part of the value.  The 'R' operand returns\n-\t     the register number of the register containing the most\n-\t     significant part of the value.\n-\n-\t     The 'H' operand returns the higher of the two register numbers.\n-\t     On a run where WORDS_BIG_ENDIAN is true the 'H' operand is the\n-\t     same as the 'Q' operand, since the most signficant part of the\n-\t     value is held in the lower number register.  The reverse is true\n-\t     on systems where WORDS_BIG_ENDIAN is false.\n-\n-\t     The purpose of these operands is to distinguish between cases\n-\t     where the endian-ness of the values is important (for example\n-\t     when they are added together), and cases where the endian-ness\n-\t     is irrelevant, but the order of register operations is important.\n-\t     For example when loading a value from memory into a register\n-\t     pair, the endian-ness does not matter.  Provided that the value\n-\t     from the lower memory address is put into the lower numbered\n-\t     register, and the value from the higher address is put into the\n-\t     higher numbered register, the load will work regardless of whether\n-\t     the value being loaded is big-wordian or little-wordian.  The\n-\t     order of the two register loads can matter however, if the address\n-\t     of the memory location is actually held in one of the registers\n-\t     being overwritten by the load.  */\n-\tcase 'Q':\n-\t  if (REGNO (x) > 15)\n-\t    abort ();\n-\t  fputs (reg_names[REGNO (x) + (WORDS_BIG_ENDIAN ? 1 : 0)], f);\n-\t  return;\n-\t  \n-\tcase 'R':\n-\t  if (REGNO (x) > 15)\n-\t    abort ();\n-\t  fputs (reg_names[REGNO (x) + (WORDS_BIG_ENDIAN ? 0 : 1)], f);\n-\t  return;\n-\n-\tcase 'H':\n-\t  if (REGNO (x) > 15)\n-\t    abort ();\n-\t  fputs (reg_names[REGNO (x) + 1], f);\n-\t  return;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  if (GET_CODE (x) == REG)\n-    fputs (reg_names[REGNO (x)], f);\n-  else if (GET_CODE (x) == MEM)\n-    output_address (XEXP (x, 0));\n-  else if (GET_CODE (x) == CONST_INT)\n-    {\n-      fputc ('#', f);\n-      output_addr_const (f, x);\n-    }\n-  else\n-    abort ();\n-}\n-\n-#ifdef AOF_ASSEMBLER\n-int arm_text_section_count = 1;\n-\n-char *\n-aof_text_section (in_readonly)\n-     int in_readonly;\n-{\n-  static char buf[100];\n-  if (in_readonly)\n-    return \"\";\n-  sprintf (buf, \"\\tCODE16\\n\\tAREA |C$$code%d|, CODE, READONLY\",\n-\t   arm_text_section_count++);\n-  return buf;\n-}\n-\n-static int arm_data_section_count = 1;\n-\n-char *\n-aof_data_section ()\n-{\n-  static char buf[100];\n-  sprintf (buf, \"\\tAREA |C$$data%d|, DATA\", arm_data_section_count++);\n-  return buf;\n-}\n-\n-/* The AOF thumb assembler is religiously strict about declarations of\n-   imported and exported symbols, so that it is impossible to declare a\n-   function as imported near the begining of the file, and then to export\n-   it later on.  It is, however, possible to delay the decision until all \n-   the functions in the file have been compiled.  To get around this, we\n-   maintain a list of the imports and exports, and delete from it any that\n-   are subsequently defined.  At the end of compilation we spit the \n-   remainder of the list out before the END directive.  */\n-\n-struct import\n-{\n-  struct import *next;\n-  char *name;\n-};\n-\n-static struct import *imports_list = NULL;\n-\n-void\n-thumb_aof_add_import (name)\n-     char *name;\n-{\n-  struct import *new;\n-\n-  for (new = imports_list; new; new = new->next)\n-    if (new->name == name)\n-      return;\n-\n-  new = (struct import *) xmalloc (sizeof (struct import));\n-  new->next = imports_list;\n-  imports_list = new;\n-  new->name = name;\n-}\n-\n-void\n-thumb_aof_delete_import (name)\n-     char *name;\n-{\n-  struct import **old;\n-\n-  for (old = &imports_list; *old; old = & (*old)->next)\n-    {\n-      if ((*old)->name == name)\n-\t{\n-\t  *old = (*old)->next;\n-\t  return;\n-\t}\n-    }\n-}\n-\n-void\n-thumb_aof_dump_imports (f)\n-     FILE *f;\n-{\n-  while (imports_list)\n-    {\n-      fprintf (f, \"\\tIMPORT\\t\");\n-      assemble_name (f, imports_list->name);\n-      fputc ('\\n', f);\n-      imports_list = imports_list->next;\n-    }\n-}\n-#endif\n-\n-/* Decide whether a type should be returned in memory (true)\n-   or in a register (false).  This is called by the macro\n-   RETURN_IN_MEMORY.  */\n-\n-int\n-thumb_return_in_memory (type)\n-     tree type;\n-{\n-  if (! AGGREGATE_TYPE_P (type))\n-    {\n-      /* All simple types are returned in registers. */\n-\n-      return 0;\n-    }\n-  else if (int_size_in_bytes (type) > 4)\n-    {\n-      /* All structures/unions bigger than one word are returned in memory. */\n-      \n-      return 1;\n-    }\n-  else if (TREE_CODE (type) == RECORD_TYPE)\n-    {\n-      tree field;\n-\n-      /* For a struct the APCS says that we must return in a register if\n-\t every addressable element has an offset of zero.  For practical\n-\t purposes this means that the structure can have at most one non-\n-\t bit-field element and that this element must be the first one in\n-\t the structure.  */\n-\n-      /* Find the first field, ignoring non FIELD_DECL things which will\n-\t have been created by C++. */\n-      for (field = TYPE_FIELDS (type);\n-\t   field && TREE_CODE (field) != FIELD_DECL;\n-\t   field = TREE_CHAIN (field))\n-\tcontinue;\n-\n-      if (field == NULL)\n-\treturn 0; /* An empty structure.  Allowed by an extension to ANSI C. */\n-\n-      /* Now check the remaining fields, if any. */\n-      for (field = TREE_CHAIN (field); field;  field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\t  \n-\t  if (! DECL_BIT_FIELD_TYPE (field))\n-\t    return 1;\n-\t}\n-\n-      return 0;\n-    }\n-  else if (TREE_CODE (type) == UNION_TYPE)\n-    {\n-      tree field;\n-\n-      /* Unions can be returned in registers if every element is\n-\t integral, or can be returned in an integer register.  */\n-      \n-      for (field = TYPE_FIELDS (type);\n-\t   field;\n-\t   field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\t  \n-\t  if (RETURN_IN_MEMORY (TREE_TYPE (field)))\n-\t    return 1;\n-\t}\n-      \n-      return 0;\n-    }\n-  /* XXX Not sure what should be done for other aggregates, so put them in\n-     memory. */\n-  return 1;\n-}\n-\n-void\n-thumb_override_options ()\n-{\n-  if (structure_size_string != NULL)\n-    {\n-      int size = strtol (structure_size_string, NULL, 0);\n-      \n-      if (size == 8 || size == 32)\n-\tarm_structure_size_boundary = size;\n-      else\n-\twarning (\"Structure size boundary can only be set to 8 or 32\");\n-    }\n-\n-  if (thumb_pic_register_string != NULL)\n-    {\n-      int pic_register;\n-\n-      if (! flag_pic)\n-\twarning (\"-mpic-register= is useless without -fpic\");\n-\n-      pic_register = decode_reg_name (thumb_pic_register_string);\n-      \n-      /* Prevent the user from choosing an obviously stupid PIC register.  */\n-      if (pic_register < 0 || call_used_regs[pic_register]\n-\t  || pic_register == HARD_FRAME_POINTER_REGNUM\n-\t  || pic_register == STACK_POINTER_REGNUM\n-\t  || pic_register >= PC_REGNUM)\n-\terror (\"Unable to use '%s' for PIC register\", thumb_pic_register_string);\n-      else\n-\tthumb_pic_register = pic_register;\n-    }\n-}\n-\f\n-#ifdef THUMB_PE\n-/* Return nonzero if ATTR is a valid attribute for DECL.\n-   ATTRIBUTES are any existing attributes and ARGS are the arguments\n-   supplied with ATTR.\n-\n-   Supported attributes:\n-\n-   naked: don't output any prologue or epilogue code, the user is assumed\n-   to do the right thing.\n-\n-   interfacearm: Always assume that this function will be entered in ARM\n-   mode, not Thumb mode, and that the caller wishes to be returned to in\n-   ARM mode.  */\n-int\n-arm_valid_machine_decl_attribute (decl, attr, args)\n-     tree decl;\n-     tree attr;\n-     tree args;\n-{\n-  if (args != NULL_TREE)\n-    return 0;\n-  \n-  if (is_attribute_p (\"naked\", attr))\n-    if (TREE_CODE (decl) == FUNCTION_DECL)\n-      return 1;\n-  \n-  if (is_attribute_p (\"interfacearm\", attr))\n-    return TREE_CODE (decl) == FUNCTION_DECL;\n-  \n-  return 0;\n-}\n-#endif /* THUMB_PE */\n-"}, {"sha": "4837504a3cf9a5c62235e3ff64e9b5e912ed3162", "filename": "gcc/config/arm/thumb.h", "status": "removed", "additions": 0, "deletions": 1305, "changes": 1305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fthumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fthumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,1305 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for ARM/Thumb.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-   The basis of this contribution was generated by\n-   \t\tRichard Earnshaw, Advanced RISC Machines Ltd\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* ??? The files thumb.{c,h,md} are all seriously lacking comments.  */\n-\n-/* ??? The files thumb.{c,h,md} need to be reviewed by an experienced\n-   gcc hacker in their entirety.  */\n-\n-/* ??? The files thumb.{c,h,md} and tcoff.h are all separate from the arm\n-   files, which will lead to many maintenance problems.  These files are\n-   likely missing all bug fixes made to the arm port since they diverged.  */\n-\n-/* ??? Many patterns in the md file accept operands that will require a\n-   reload.  These should be eliminated if possible by tightening the\n-   predicates and/or constraints.  This will give faster/smaller code.  */\n-\n-/* ??? There is no pattern for the TST instuction.  Check for other unsupported\n-   instructions.  */\n-\n-/* Run Time Target Specifications */\n-#ifndef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dthumb -D__thumb -Acpu(arm) -Amachine(arm)\"\n-#endif\n-\n-#ifndef CPP_SPEC\n-#define CPP_SPEC \"\\\n-%{mbig-endian:-D__ARMEB__ -D__THUMBEB__} \\\n-%{mbe:-D__ARMEB__ -D__THUMBEB__} \\\n-%{!mbe: %{!mbig-endian:-D__ARMEL__ -D__THUMBEL__}} \\\n-\"\n-#endif\n-\n-#define ASM_SPEC \"-marm7tdmi %{mthumb-interwork:-mthumb-interwork} %{mbig-endian:-EB}\"\n-#ifndef LINK_SPEC\n-#define LINK_SPEC \"%{mbig-endian:-EB} -X\"\n-#endif\n-\n-#define TARGET_VERSION  fputs (\" (ARM/THUMB:generic)\", stderr);\n-\n-/* Nonzero if we should compile with BYTES_BIG_ENDIAN set to 1.  */\n-#define THUMB_FLAG_BIG_END      \t\t0x0001\n-#define THUMB_FLAG_BACKTRACE    \t\t0x0002\n-#define THUMB_FLAG_LEAF_BACKTRACE\t\t0x0004\n-#define ARM_FLAG_THUMB\t\t\t\t0x1000\t/* same as in arm.h */\n-#define THUMB_FLAG_SINGLE_PIC_BASE\t\t0x4000  /* same as in arm.h */\n-#define THUMB_FLAG_CALLEE_SUPER_INTERWORKING\t0x40000 \n-#define THUMB_FLAG_CALLER_SUPER_INTERWORKING\t0x80000 \n-\n-\n-/* Run-time compilation parameters selecting different hardware/software subsets.  */\n-extern int target_flags;\n-#define TARGET_DEFAULT          0 /* ARM_FLAG_THUMB */\n-#define TARGET_BIG_END          (target_flags & THUMB_FLAG_BIG_END)\n-#define TARGET_THUMB_INTERWORK\t(target_flags & ARM_FLAG_THUMB)\n-#define TARGET_BACKTRACE\t(leaf_function_p()\t\t\t      \\\n-\t\t\t\t ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE) \\\n-\t\t\t\t : (target_flags & THUMB_FLAG_BACKTRACE))\n-#define TARGET_SINGLE_PIC_BASE\t(target_flags & THUMB_FLAG_SINGLE_PIC_BASE)\n-\n-#ifndef GOT_PCREL\n-#define GOT_PCREL\t\t0\n-#endif\n-\n-#ifndef NEED_GOT_RELOC\n-#define NEED_GOT_RELOC\t\t1\n-#endif\n-\n-/* Set if externally visible functions should assume that they\n-   might be called in ARM mode, from a non-thumb aware code.  */\n-#define TARGET_CALLEE_INTERWORKING\t\\\n-     (target_flags & THUMB_FLAG_CALLEE_SUPER_INTERWORKING)\n-\n-/* Set if calls via function pointers should assume that their\n-   destination is non-Thumb aware.  */\n-#define TARGET_CALLER_INTERWORKING\t\\\n-     (target_flags & THUMB_FLAG_CALLER_SUPER_INTERWORKING)\n-\n-/* SUBTARGET_SWITCHES is used to add flags on a per-config basis. */\n-#ifndef SUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES\n-#endif\n-\n-#define TARGET_SWITCHES                                 \t\\\n-{                                                       \t\\\n-  {\"big-endian\",\t\t    THUMB_FLAG_BIG_END, \"\"},\t\\\n-  {\"little-endian\",\t           -THUMB_FLAG_BIG_END, \"\"},\t\\\n-  {\"thumb-interwork\",\t\t    ARM_FLAG_THUMB, \"\"},\t\\\n-  {\"no-thumb-interwork\",           -ARM_FLAG_THUMB, \"\"},\t\\\n-  {\"tpcs-frame\",\t\t    THUMB_FLAG_BACKTRACE, \"\"},\t\\\n-  {\"no-tpcs-frame\",                -THUMB_FLAG_BACKTRACE, \"\"},\t\\\n-  {\"tpcs-leaf-frame\",\t  \t    THUMB_FLAG_LEAF_BACKTRACE, \"\"},\t\\\n-  {\"no-tpcs-leaf-frame\",           -THUMB_FLAG_LEAF_BACKTRACE, \"\"},\t\\\n-  {\"callee-super-interworking\",\t    THUMB_FLAG_CALLEE_SUPER_INTERWORKING, \"\"}, \\\n-  {\"no-callee-super-interworking\", -THUMB_FLAG_CALLEE_SUPER_INTERWORKING, \"\"}, \\\n-  {\"caller-super-interworking\",\t    THUMB_FLAG_CALLER_SUPER_INTERWORKING, \"\"}, \\\n-  {\"no-caller-super-interworking\", -THUMB_FLAG_CALLER_SUPER_INTERWORKING, \"\"}, \\\n-  {\"single-pic-base\",\t\t    THUMB_FLAG_SINGLE_PIC_BASE,\t\\\n-     \"Do not load the PIC register in function prologues\" },\t\\\n-  {\"no-single-pic-base\",\t   -THUMB_FLAG_SINGLE_PIC_BASE, \"\"}, \\\n-  SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n-  {\"\",                          TARGET_DEFAULT, \"\"}         \t\\\n-}\n-\n-#define TARGET_OPTIONS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  { \"structure-size-boundary=\", & structure_size_string,        \\\n-      \"Specify the structure aligment: 8 or 32 bits\" }, \t\\\n-  { \"pic-register=\", & thumb_pic_register_string,\t\t\\\n-     \"Specify the register to be used for PIC addressing\" }\t\\\n-}\n-\n-#define REGISTER_PREFIX \"\"\n-\n-#define CAN_DEBUG_WITHOUT_FP 1\n-\f\n-#define ASM_APP_ON  \"\"\n-#define ASM_APP_OFF \"\\t.code\\t16\\n\"\n-\n-/* Output a gap.  In fact we fill it with nulls.  */\n-#define ASM_OUTPUT_SKIP(STREAM, NBYTES)  \\\n-  fprintf ((STREAM), \"\\t.space\\t%u\\n\", (NBYTES))\n-\n-/* This is how to output an assembler line that says to advance the\n-   location counter to a multiple of 2**LOG bytes.  Advancing to the\n-   nearest 1 byte boundary is redundant, and anyway the assembler would\n-   treat it as meaning \"advance to nearest 4 byte boundary\", which we do\n-   not want.  */\n-#define ASM_OUTPUT_ALIGN(STREAM,LOG)\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if ((LOG) > 0)\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\t.align\\t%d\\n\", LOG);\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output a common block */\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \t\t\\\n-  (fprintf ((STREAM), \"\\t.comm\\t\"), \t\t     \t\t\t\\\n-   assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n-   fprintf((STREAM), \", %d\\t%s %d\\n\", (ROUNDED), (ASM_COMMENT_START), (SIZE)))\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(STRING,PREFIX,NUM)        \\\n-  sprintf ((STRING), \"*%s%s%d\", (LOCAL_LABEL_PREFIX), (PREFIX), (NUM))\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-#define ASM_OUTPUT_INTERNAL_LABEL(STREAM,PREFIX,NUM)\t\t\t\\\n-  fprintf ((STREAM), \"%s%s%d:\\n\", (LOCAL_LABEL_PREFIX), (PREFIX), (NUM))\n-\n-/* This is how to output a label which precedes a jumptable.  Since\n-   instructions are 2 bytes, we need explicit alignment here.  */\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\t\\\n-    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n-  } while (0)\n-\n-/* This says how to define a local common symbol (ie, not visible to\n-   linker).  */\n-#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\t\t\\\n-  (fprintf((STREAM),\"\\n\\t.lcomm\\t\"),                                    \\\n-   assemble_name((STREAM),(NAME)),                                      \\\n-   fprintf((STREAM),\",%u\\n\",(SIZE)))\n-\n-/* Output a reference to a label.  */\n-#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n-  fprintf ((STREAM), \"%s%s\", user_label_prefix, (NAME))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(STREAM,VALUE)\t\t\t\t\t\\\n-  fprintf ((STREAM), \"\\t.byte\\t0x%x\\n\", (VALUE))\n-\n-#define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t\");\t\t\t\t\t\\\n-  OUTPUT_INT_ADDR_CONST (STREAM, (VALUE));\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_OUTPUT_SHORT(STREAM,VALUE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.short\\t\");\t\t\t\t\t\\\n-  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_OUTPUT_CHAR(STREAM,VALUE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.byte\\t\");\t\t\t\t\t\\\n-  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_OUTPUT_LONG_DOUBLE(STREAM,VALUE)\t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l[3];\t\t\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n-     fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\", \\\n-\t      l[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\\\n-   } while (0)\n-\n-#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l[2];\t\t\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n-     fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n-\t      l[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n-   } while (0)\n-\n-#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l;\t\t\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\t\\\n-     fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\t\\\n-\t      ASM_COMMENT_START, dstr);\t\t\t\t\t\\\n-   } while (0);\n-\n-/* Define results of standard character escape sequences.  */\n-#define TARGET_BELL\t007\n-#define TARGET_BS\t010\n-#define TARGET_TAB\t011\n-#define TARGET_NEWLINE\t012\n-#define TARGET_VT\t013\n-#define TARGET_FF\t014\n-#define TARGET_CR\t015\n-\n-/* This is how to output a string.  */\n-#define ASM_OUTPUT_ASCII(STREAM, STRING, LEN)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  register int i, c, len = (LEN), cur_pos = 17;\t\t\t\t\\\n-  register const unsigned char *string = (const unsigned char *)(STRING); \\\n-  fprintf ((STREAM), \"\\t.ascii\\t\\\"\");\t\t\t\t\t\\\n-  for (i = 0; i < len; i++)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      register int c = string[i];\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      switch (c)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\tcase '\\\"':\t\t\t\t\t\t\t\\\n-\tcase '\\\\':\t\t\t\t\t\t\t\\\n-\t  putc ('\\\\', (STREAM));\t\t\t\t\t\\\n-\t  putc (c, (STREAM));\t\t\t\t\t\t\\\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tcase TARGET_NEWLINE:\t\t\t\t\t\t\\\n-\t  fputs (\"\\\\n\", (STREAM));\t\t\t\t\t\\\n-\t  if (i+1 < len\t\t\t\t\t\t\t\\\n-\t      && (((c = string[i+1]) >= '\\040' && c <= '~')\t\t\\\n-\t\t  || c == TARGET_TAB))\t\t\t\t\t\\\n-\t    cur_pos = 32767;\t\t/* break right here */\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    cur_pos += 2;\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tcase TARGET_TAB:\t\t\t\t\t\t\\\n-\t  fputs (\"\\\\t\", (STREAM));\t\t\t\t\t\\\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tcase TARGET_FF:\t\t\t\t\t\t\t\\\n-\t  fputs (\"\\\\f\", (STREAM));\t\t\t\t\t\\\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tcase TARGET_BS:\t\t\t\t\t\t\t\\\n-\t  fputs (\"\\\\b\", (STREAM));\t\t\t\t\t\\\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tcase TARGET_CR:\t\t\t\t\t\t\t\\\n-\t  fputs (\"\\\\r\", (STREAM));\t\t\t\t\t\\\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tdefault:\t\t\t\t\t\t\t\\\n-\t  if (c >= ' ' && c < 0177)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      putc (c, (STREAM));\t\t\t\t\t\\\n-\t      cur_pos++;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      fprintf ((STREAM), \"\\\\%03o\", c);\t\t\t\t\\\n-\t      cur_pos += 4;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (cur_pos > 72 && i+1 < len)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  cur_pos = 17;\t\t\t\t\t\t\t\\\n-\t  fprintf ((STREAM), \"\\\"\\n\\t.ascii\\t\\\"\");\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((STREAM), \"\\\"\\n\");\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Output and Generation of Labels */\n-#define ASM_OUTPUT_LABEL(STREAM,NAME) \\\n-  (assemble_name ((STREAM), (NAME)),  \\\n-   fprintf ((STREAM), \":\\n\"))\n-\n-#define ASM_GLOBALIZE_LABEL(STREAM,NAME)      \\\n- (fprintf ((STREAM), \"\\t.globl\\t\"),           \\\n-  assemble_name ((STREAM), (NAME)),           \\\n-  fputc ('\\n', (STREAM)))\n-\n-/* Construct a private name.  */\n-#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n-  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n-   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n-\n-/* Switch to the text or data segment.  */\n-#define TEXT_SECTION_ASM_OP  \".text\"\n-#define DATA_SECTION_ASM_OP  \".data\"\n-#define BSS_SECTION_ASM_OP   \".bss\"\n-\n-/* The assembler's names for the registers.  */\n-#ifndef REGISTER_NAMES\n-#define REGISTER_NAMES  \\\n-{\t\t\t\t                   \\\n-  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n-  \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\", \"ap\"   \\\n-}\n-#endif\n-\n-#ifndef ADDITIONAL_REGISTER_NAMES\n-#define ADDITIONAL_REGISTER_NAMES\t\t\\\n-{\t\t\t\t\t\t\\\n-  {\"a1\", 0},\t\t\t\t\t\\\n-  {\"a2\", 1},\t\t\t\t\t\\\n-  {\"a3\", 2},\t\t\t\t\t\\\n-  {\"a4\", 3},\t\t\t\t\t\\\n-  {\"v1\", 4},\t\t\t\t\t\\\n-  {\"v2\", 5},\t\t\t\t\t\\\n-  {\"v3\", 6},\t\t\t\t\t\\\n-  {\"v4\", 7},\t\t\t\t\t\\\n-  {\"v5\", 8},\t\t\t\t\t\\\n-  {\"v6\", 9},\t\t\t\t\t\\\n-  {\"sb\", 9},\t\t\t\t\t\\\n-  {\"v7\", 10},\t\t\t\t\t\\\n-  {\"r10\", 10},\t/* sl */\t\t\t\\\n-  {\"r11\", 11},\t/* fp */\t\t\t\\\n-  {\"r12\", 12},\t/* ip */\t\t\t\\\n-  {\"r13\", 13},\t/* sp */\t\t\t\\\n-  {\"r14\", 14},\t/* lr */\t\t\t\\\n-  {\"r15\", 15}\t/* pc */\t\t\t\\\n-}\n-#endif\n-\n-/* The assembler's parentheses characters.  */\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n-#ifndef ASM_COMMENT_START\n-#define ASM_COMMENT_START \"@\"\n-#endif\n-\n-/* Output an element of a dispatch table.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n-   fprintf (STREAM, \"\\t.word\\t%sL%d\\n\", (LOCAL_LABEL_PREFIX), (VALUE))\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \\\n-   fprintf (STREAM, \"\\tb\\t%sL%d\\n\", (LOCAL_LABEL_PREFIX), (VALUE))\n-\f\n-/* Storage Layout */\n-\n-/* Define this is most significant bit is lowest numbered in\n-   instructions that operate on numbered bit-fields.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest\n-   numbered.  */\n-#define BYTES_BIG_ENDIAN (TARGET_BIG_END != 0)\n-\n-#define WORDS_BIG_ENDIAN (BYTES_BIG_ENDIAN)\n-\n-/* LIBGCC2_WORDS_BIG_ENDIAN has to be a constant, so we define this based\n-   on processor pre-defineds when compiling libgcc2.c.  */\n-#if defined(__THUMBEB__) && !defined(__THUMBEL__)\n-#define LIBGCC2_WORDS_BIG_ENDIAN 1\n-#else\n-#define LIBGCC2_WORDS_BIG_ENDIAN 0\n-#endif\n-\n-#define FLOAT_WORDS_BIG_ENDIAN 1\n-\n-#define BITS_PER_UNIT 8\n-#define BITS_PER_WORD 32\n-\n-#define UNITS_PER_WORD 4\n-\n-#define POINTER_SIZE 32\n-\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n-{\t\t\t\t\t\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-      && GET_MODE_SIZE (MODE) < 4)\t\t\\\n-    {\t\t\t\t\t\t\\\n-      (UNSIGNEDP) = 1;\t\t\t\t\\\n-      (MODE) = SImode;\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-}\n-\n-#define PARM_BOUNDARY 32\n-#define STACK_BOUNDARY 32\n-\n-#define FUNCTION_BOUNDARY 32\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST        \\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-#define STRUCTURE_SIZE_BOUNDARY 32\n-\n-/* Used when parsing command line option -mstructure_size_boundary.  */\n-extern const char * structure_size_string;\n-\n-#define STRICT_ALIGNMENT 1\n-\n-#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n-\n-\f\n-/* Layout of Source Language Data Types  */\n-\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-#define TARGET_BELL\t007\n-#define TARGET_BS\t010\n-#define TARGET_TAB\t011\n-#define TARGET_NEWLINE\t012\n-#define TARGET_VT\t013\n-#define TARGET_FF\t014\n-#define TARGET_CR\t015\n-\n-\f\n-/* Register Usage */\n-\n-/* Note there are 16 hard registers on the Thumb.  We invent a 17th register\n-   which is assigned to ARG_POINTER_REGNUM, but this is later removed by\n-   elimination passes in the compiler.  */\n-#define FIRST_PSEUDO_REGISTER 17\n-\n-/* ??? This is questionable.  */\n-#define FIXED_REGISTERS \\\n-{\t\t\t\\\n-  0,0,0,0,\t\t\\\n-  0,0,0,0,\t\t\\\n-  0,0,0,1,\t\t\\\n-  0,1,1,1,1\t\t\\\n-}\n-\n-/* ??? This is questionable.  */\n-#define CALL_USED_REGISTERS\t\\\n-{\t\t\t\t\\\n-  1,1,1,1,\t\t\t\\\n-  0,0,0,0,\t\t\t\\\n-  0,0,0,1,\t\t\t\\\n-  1,1,1,1,1\t\t\t\\\n-}\n-\n-#define HARD_REGNO_NREGS(REGNO,MODE)\t\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)\t\\\n-   / UNITS_PER_WORD)\n-\n-/* ??? Probably should only allow DImode/DFmode in even numbered registers.  */\n-#define HARD_REGNO_MODE_OK(REGNO,MODE) ((GET_MODE_SIZE (MODE) > UNITS_PER_WORD) ? (REGNO < 7) : 1)\n-\n-#define MODES_TIEABLE_P(MODE1,MODE2) 1\n-\n-/* The NOARG_LO_REGS class is the set of LO_REGS that are not used for passing\n-   arguments to functions.  These are the registers that are available for\n-   spilling during reload.  The code in reload1.c:init_reload() will detect this\n-   class and place it into 'reload_address_base_reg_class'.  */\n-\n-enum reg_class\n-{\n-  NO_REGS,\n-  NONARG_LO_REGS,\n-  LO_REGS,\n-  STACK_REG,\n-  BASE_REGS,\n-  HI_REGS,\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define GENERAL_REGS ALL_REGS\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-#define REG_CLASS_NAMES \\\n-{\t\t\t\\\n-  \"NO_REGS\",\t\t\\\n-  \"NONARG_LO_REGS\",\t\\\n-  \"LO_REGS\",\t\t\\\n-  \"STACK_REG\",\t\t\\\n-  \"BASE_REGS\",\t\t\\\n-  \"HI_REGS\",\t\t\\\n-  \"ALL_REGS\"\t\t\\\n-}\n-\n-#define REG_CLASS_CONTENTS\t\\\n-{\t\t\t\t\\\n-  { 0x00000 },\t\t\t\\\n-  { 0x000f0 },\t\t\t\\\n-  { 0x000ff },\t\t\t\\\n-  { 0x02000 },\t\t\t\\\n-  { 0x020ff },\t\t\t\\\n-  { 0x0ff00 },\t\t\t\\\n-  { 0x1ffff },\t\t\t\\\n-}\n-\n-#define REGNO_REG_CLASS(REGNO)\t\t\t\\\n- ((REGNO) == STACK_POINTER_REGNUM ? STACK_REG\t\\\n-  : (REGNO) < 8 ? ((REGNO) < 4 ? LO_REGS\t\\\n-\t\t   : NONARG_LO_REGS)\t\t\\\n-  : HI_REGS)\n-\n-#define BASE_REG_CLASS BASE_REGS\n-\n-#define INDEX_REG_CLASS LO_REGS\n-\n-/* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n-   registers explicitly used in the rtl to be used as spill registers\n-   but prevents the compiler from extending the lifetime of these\n-   registers. */\n-\n-#define SMALL_REGISTER_CLASSES 1\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'l' ? LO_REGS\t\t\\\n-   : (C) == 'h' ? HI_REGS\t\\\n-   : (C) == 'b' ? BASE_REGS\t\\\n-   : (C) == 'k' ? STACK_REG\t\\\n-   : NO_REGS)\n-\n-#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n-  ((REGNO) < 8\t\t\t\t\t\t\t\\\n-   || (REGNO) == STACK_POINTER_REGNUM\t\t\t\t\\\n-   || (unsigned) reg_renumber[REGNO] < 8\t\t\t\\\n-   || (unsigned) reg_renumber[REGNO] == STACK_POINTER_REGNUM)\n-\n-#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE)\t\t\t\\\n-  ((REGNO) < 8\t\t\t\t\t\t\t\\\n-   || (unsigned) reg_renumber[REGNO] < 8\t\t\t\\\n-   || (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n-       && ((REGNO) == STACK_POINTER_REGNUM\t\t\t\\\n-\t   || (unsigned) reg_renumber[REGNO] == STACK_POINTER_REGNUM)))\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\\\n-  ((REGNO) < 8\t\t\t\t\t\\\n-   || (unsigned) reg_renumber[REGNO] < 8)\n-\n-#define INDEX_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n-\n-/* ??? This looks suspiciously wrong.  */\n-/* We need to leave BASE_REGS reloads alone, in order to avoid caller_save\n-   lossage.  Caller_saves requests a BASE_REGS reload (caller_save_spill_class)\n-   and then later we verify that one was allocated.  If PREFERRED_RELOAD_CLASS\n-   says to allocate a LO_REGS spill instead, then this mismatch gives an\n-   abort.  Alternatively, this could be fixed by modifying BASE_REG_CLASS\n-   to be LO_REGS instead of BASE_REGS.  It is not clear what affect this\n-   change would have.  */\n-/* ??? This looks even more suspiciously wrong.  PREFERRED_RELOAD_CLASS\n-   must always return a strict subset of the input class.  Just blindly\n-   returning LO_REGS is safe only if the input class is a superset of LO_REGS,\n-   but there is no check for this.  Added another exception for NONARG_LO_REGS\n-   because it is not a superset of LO_REGS.  */\n-/* ??? We now use NONARG_LO_REGS for caller_save_spill_class, so the\n-   comments about BASE_REGS are now obsolete.  */\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n-  ((CLASS) == BASE_REGS || (CLASS) == NONARG_LO_REGS ? (CLASS)\t\\\n-   : LO_REGS)\n-/*\n-  ((CONSTANT_P ((X)) && GET_CODE ((X)) != CONST_INT\t\t\\\n-    && ! CONSTANT_POOL_ADDRESS_P((X))) ? NO_REGS\t\t\\\n-   : (GET_CODE ((X)) == CONST_INT\t\t\t\t\\\n-      && (unsigned HOST_WIDE_INT) INTVAL ((X)) > 255) ? NO_REGS\t\\\n-   : LO_REGS) */\n-\n-/* Must leave BASE_REGS and NONARG_LO_REGS reloads alone, see comment\n-   above.  */\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,X)\t\t\t\t\\\n-   ((CLASS) != LO_REGS && (CLASS) != BASE_REGS && (CLASS) != NONARG_LO_REGS \\\n-   ? ((true_regnum (X) == -1 ? LO_REGS\t\t\t\t\t\\\n-       : (true_regnum (X) + HARD_REGNO_NREGS (0, MODE) > 8) ? LO_REGS\t\\\n-       : NO_REGS)) \t\t\t\t\t\t\t\\\n-   : NO_REGS)\n-\n-#define CLASS_MAX_NREGS(CLASS,MODE) HARD_REGNO_NREGS(0,(MODE))\n-\n-int thumb_shiftable_const ();\n-\n-#define CONST_OK_FOR_LETTER_P(VAL,C)\t\t\t\t\\\n-  ((C) == 'I' ? (unsigned HOST_WIDE_INT) (VAL) < 256\t\t\\\n-   : (C) == 'J' ? (VAL) > -256 && (VAL) <= 0\t\t\t\\\n-   : (C) == 'K' ? thumb_shiftable_const (VAL)\t\t\t\\\n-   : (C) == 'L' ? (VAL) > -8 && (VAL) < 8\t\t\t\\\n-   : (C) == 'M' ? ((unsigned HOST_WIDE_INT) (VAL) < 1024\t\\\n-\t\t   && ((VAL) & 3) == 0)\t\t\t\t\\\n-   : (C) == 'N' ? ((unsigned HOST_WIDE_INT) (VAL) < 32)\t\t\\\n-   : (C) == 'O' ? ((VAL) >= -508 && (VAL) <= 508)\t\t\\\n-   : 0)\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VAL,C) 0\n-\n-#define EXTRA_CONSTRAINT(X,C)\t\t\t\t\t\t\\\n-  ((C) == 'Q' ? (GET_CODE (X) == MEM\t\t\t\t\t\\\n-\t\t && GET_CODE (XEXP (X, 0)) == LABEL_REF) : 0)\n-\f\n-/* Stack Layout and Calling Conventions */\n-\n-#define STACK_GROWS_DOWNWARD 1\n-\n-/* #define FRAME_GROWS_DOWNWARD 1 */\n-\n-/* #define ARGS_GROW_DOWNWARD 1 */\n-\n-#define STARTING_FRAME_OFFSET 0\n-\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Registers that address the stack frame */\n-\n-#define STACK_POINTER_REGNUM  13\t/* Defined by the TPCS.  */\n-\n-#define FRAME_POINTER_REGNUM  7\t\t/* TPCS defines this as 11 but it does not really mean it.  */\n-\n-#define ARG_POINTER_REGNUM    16\t/* A fake hard register that is eliminated later on.  */\n-\n-#define STATIC_CHAIN_REGNUM 9\n-\n-/* Define this if the program counter is overloaded on a register.  */\n-#define PC_REGNUM\t\t15\n-\n-#define FRAME_POINTER_REQUIRED 0\n-\n-#define ELIMINABLE_REGS\t\t\t\t\\\n-{{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n- {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-/* On the Thumb we always want to perform the eliminations as we\n-   actually only have one real register pointing to the stashed\n-   variables: the stack pointer, and we never use the frame pointer.  */\n-#define CAN_ELIMINATE(FROM,TO)  1\n-\n-/* Note:  This macro must match the code in thumb_function_prologue() in thumb.c.  */\n-#define INITIAL_ELIMINATION_OFFSET(FROM,TO,OFFSET)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  (OFFSET) = 0;\t\t\t\t\t\t\t\\\n-  if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      int count_regs = 0;\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\\\n-      (OFFSET) += get_frame_size (); \t\t\t\t\\\n-      for (regno = 8; regno < 13; regno++)\t\t\t\\\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-\t  count_regs++;\t\t\t\t\t\t\\\n-      if (count_regs)\t\t\t\t\t\t\\\n-\t(OFFSET) += 4 * count_regs;\t \t\t\t\\\n-      count_regs = 0;\t\t\t\t\t\t\\\n-      for (regno = 0; regno < 8; regno++)\t\t\t\\\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-\t  count_regs++;\t\t\t\t\t\t\\\n-      if (count_regs || ! leaf_function_p () || far_jump_used_p())\t\\\n-\t(OFFSET) += 4 * (count_regs + 1);\t\t\t\\\n-      if (TARGET_BACKTRACE) {\t\t\t\t\t\\\n-\tif ((count_regs & 0xFF) == 0 && (regs_ever_live[3] != 0))\t\\\n-\t  (OFFSET) += 20;\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  (OFFSET) += 16; }\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n-    (OFFSET) += current_function_outgoing_args_size;\t\t\\\n-}\n-\n-/* A C expression whose value is RTL representing the value of the return\n-   address for the frame COUNT steps up from the current frame.  */\n-\n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n-  thumb_return_addr (COUNT)\n-/* Passing Arguments on the stack */\n-\n-/* Initialize data used by insn expanders.  This is called from insn_emit,\n-   once for every function before code is generated.  */\n-#define INIT_EXPANDERS  thumb_init_expanders ()\n-\n-#define PROMOTE_PROTOTYPES 1\n-\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-#define FUNCTION_ARG(CUM,MODE,TYPE,NAMED)\t\t\t\t\\\n- ((NAMED) ? ((CUM) >= 16 ? 0 : gen_rtx (REG, (MODE), (CUM) / 4))\t\\\n-  : 0)\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM,MODE,TYPE,NAMED)\t\t\t\\\n- (((CUM) < 16 && (CUM) + (((MODE) == BLKmode)\t\t\t\t\\\n-\t\t\t  ? int_size_in_bytes (TYPE)\t\t\t\\\n-\t\t\t  : HARD_REGNO_NREGS (0, (MODE)) * 4) > 16)\t\\\n-  ? 4 - (CUM) / 4 : 0)\n-\n-#define CUMULATIVE_ARGS int\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)\t\t\\\n- ((CUM) = ((FNTYPE) && aggregate_value_p (TREE_TYPE (FNTYPE))) ? 4 : 0)\n-\n-#define FUNCTION_ARG_ADVANCE(CUM,MODE,TYPE,NAMED)\t\\\n- (CUM) += ((((MODE) == BLKmode)\t\t\t\t\\\n-\t    ? int_size_in_bytes (TYPE)\t\t\t\\\n-\t    : GET_MODE_SIZE (MODE)) + 3) & ~3\n-\n-#define FUNCTION_ARG_REGNO_P(REGNO)\t\\\n-  ((REGNO) >=0 && (REGNO) <= 3)\n-\n-#define FUNCTION_VALUE(VALTYPE,FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n-\n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, (MODE), 0)\n-\n-#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == 0)\n-\n-     /* How large values are returned */\n-/* A C expression which can inhibit the returning of certain function values\n-   in registers, based on the type of value. */\n-#define RETURN_IN_MEMORY(TYPE) thumb_return_in_memory (TYPE)\n-     \n-/* Define DEFAULT_PCC_STRUCT_RETURN to 1 if all structure and union return\n-   values must be in memory.  On the ARM, they need only do so if larger\n-   than a word, or if they contain elements offset from zero in the struct. */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-\n-#define STRUCT_VALUE_REGNUM 0\n-\n-#define FUNCTION_PROLOGUE(FILE,SIZE) thumb_function_prologue((FILE),(SIZE))\n-\n-#define FUNCTION_EPILOGUE(FILE,SIZE) thumb_function_epilogue((FILE),(SIZE))\n-\n-/* Generating code for profiling */\n-#define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  fprintf ((STREAM), \"\\tmov\\\\tip, lr\\n\");\t\t\\\n-  fprintf ((STREAM), \"\\tbl\\tmcount\\n\");\t\t\t\\\n-  fprintf ((STREAM), \"\\t.word\\tLP%d\\n\", (LABELNO));\t\\\n-}\n-\n-/* Implementing the Varargs Macros */\n-\n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  extern int current_function_anonymous_args;\t\t\t\t\\\n-  current_function_anonymous_args = 1;\t\t\t\t\t\\\n-  if ((CUM) < 16)\t\t\t\t\t\t\t\\\n-    (PRETEND_SIZE) = 16 - (CUM);\t\t\t\t\t\\\n-}\n-\n-/* Trampolines for nested functions */\n-\n-/* Output assembler code for a block containing the constant parts of\n-   a trampoline, leaving space for the variable parts.\n-\n-   On the Thumb we always switch into ARM mode to execute the trampoline.\n-   Why - because it is easier.  This code will always be branched to via\n-   a BX instruction and since the compiler magically generates the address\n-   of the function the linker has no opportunity to ensure that the\n-   bottom bit is set.  Thus the processor will be in ARM mode when it\n-   reaches this code.  So we duplicate the ARM trampoline code and add\n-   a switch into Thumb mode as well.\n-   \n-   On the ARM, (if r8 is the static chain regnum, and remembering that\n-   referencing pc adds an offset of 8) the trampoline looks like:\n-\t   ldr \t\tr8, [pc, #0]\n-\t   ldr\t\tpc, [pc]\n-\t   .word\tstatic chain value\n-\t   .word\tfunction's address\n-   ??? FIXME: When the trampoline returns, r8 will be clobbered.  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t.code 32\\n\");\t\t\t\t\\\n-  fprintf ((FILE), \".Ltrampoline_start:\\n\");\t\t\t\\\n-  fprintf ((FILE), \"\\tldr\\t%s, [%spc, #8]\\n\",\t\t\t\\\n-\t   reg_names[STATIC_CHAIN_REGNUM], REGISTER_PREFIX);\t\\\n-  fprintf ((FILE), \"\\tldr\\t%sip, [%spc, #8]\\n\",\t\t\t\\\n-\t   REGISTER_PREFIX, REGISTER_PREFIX);\t\t\t\\\n-  fprintf ((FILE), \"\\torr\\t%sip, %sip, #1\\n\",                   \\\n-\t   REGISTER_PREFIX, REGISTER_PREFIX);                   \\\n-  fprintf ((FILE), \"\\tbx\\t%sip\\n\", REGISTER_PREFIX);\t        \\\n-  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n-  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n-  fprintf ((FILE), \"\\t.code 16\\n\");\t\t\t\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-#define TRAMPOLINE_SIZE  24\n-\n-/* Alignment required for a trampoline in units.  */\n-#define TRAMPOLINE_ALIGN  4\n-\n-#define INITIALIZE_TRAMPOLINE(ADDR,FNADDR,CHAIN)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((ADDR), 16)),\t\\\n-\t\t  (CHAIN));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((ADDR), 20)),\t\\\n-\t\t  (FNADDR));\t\t\t\t\t\t\\\n-}\n-\n-\f\n-/* Position Independent Code.  */\n-/* We decide which register to use based on the compilation options and\n-   the assembler in use.  @@@ Actually, we don't currently for Thumb.  */\n-extern int thumb_pic_register;\n-\n-/* The register number of the register used to address a table of static\n-   data addresses in memory.  */\n-#define PIC_OFFSET_TABLE_REGNUM thumb_pic_register\n-\n-#define FINALIZE_PIC thumb_finalize_pic ()\n-\n-/* We can't directly access anything that contains a symbol,\n-   nor can we indirect via the constant pool.  */\n-#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n-\t(! thumb_symbol_mentioned_p (X)\t\t\t\t\\\n-\t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n-\t     || ! thumb_symbol_mentioned_p (get_pool_constant (X))))\n-\n-/* We need to know when we are making a constant pool; this determines\n-   whether data needs to be in the GOT or can be referenced via a GOT\n-   offset.  */\n-extern int making_const_table;\n-\n-#define CONDITIONAL_REGISTER_USAGE  \\\n-{\t\t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n-      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 0;\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-\f\n-/* Implicit Calls to Library Routines */\n-\n-#define TARGET_MEM_FUNCTIONS 1\n-\n-#define OVERRIDE_OPTIONS  thumb_override_options ()\n-\n-\f\n-/* Addressing Modes */\n-\n-#define HAVE_POST_INCREMENT 1\n-\n-#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\\\n- (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X))\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-#ifdef REG_OK_STRICT\n-\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n-#define REG_MODE_OK_FOR_BASE_P(X,MODE)\t\t\t\\\n-  REGNO_MODE_OK_FOR_BASE_P (REGNO (X), MODE)\n-\n-#else /* REG_OK_STRICT */\n-\n-#define REG_OK_FOR_BASE_P(X)\t\t\t\t\\\n- (REGNO (X) < 8 || REGNO (X) == STACK_POINTER_REGNUM\t\\\n-  || (X) == arg_pointer_rtx\t\t\t\t\\\n-  || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-#define REG_MODE_OK_FOR_BASE_P(X,MODE)\t\t\t\\\n- (REGNO (X) < 8\t\t\t\t\t\t\\\n-  || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\t\t\\\n-  || (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n-      && (REGNO (X) == STACK_POINTER_REGNUM\t\t\\\n-\t  || (X) == arg_pointer_rtx)))\n-\n-#define REG_OK_FOR_INDEX_P(X)\t\t\t\t\\\n- (REGNO (X) < 8\t\t\t\t\t\t\\\n-  || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-#endif /* REG_OK_STRICT */\n-\n-/* In a REG+REG address, both must be INDEX registers.  */\n-#define REG_OK_FOR_INDEXED_BASE_P(X) REG_OK_FOR_INDEX_P(X)\n-\n-#define LEGITIMATE_OFFSET(MODE,VAL)\t\t\t\t\\\n-(GET_MODE_SIZE (MODE) == 1 ? ((unsigned HOST_WIDE_INT) (VAL) < 32)\t\\\n- : GET_MODE_SIZE (MODE) == 2 ? ((unsigned HOST_WIDE_INT) (VAL) < 64\t\\\n-\t\t\t\t&& ((VAL) & 1) == 0)\t\t\t\\\n- : ((VAL) >= 0 && ((VAL) + GET_MODE_SIZE (MODE)) <= 128\t\t\t\\\n-    && ((VAL) & 3) == 0))\n-\n-/* The AP may be eliminated to either the SP or the FP, so we use the\n-   least common denominator, e.g. SImode, and offsets from 0 to 64.  */\n-\n-/* ??? Verify whether the above is the right approach.  */\n-\n-/* ??? Also, the FP may be eliminated to the SP, so perhaps that\n-   needs special handling also.  */\n-\n-/* ??? Look at how the mips16 port solves this problem.  It probably uses\n-   better ways to solve some of these problems.  */\n-\n-/* Although it is not incorrect, we don't accept QImode and HImode\n-   addresses based on the frame pointer or arg pointer until the reload pass starts.\n-   This is so that eliminating such addresses into stack based ones\n-   won't produce impossible code.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* ??? Not clear if this is right.  Experiment.  */\t\t\t\\\n-  if (GET_MODE_SIZE (MODE) < 4\t\t\t\t\t\t\\\n-      && ! (reload_in_progress || reload_completed)\t\t\t\\\n-      && (reg_mentioned_p (frame_pointer_rtx, X)\t\t\t\\\n-\t  || reg_mentioned_p (arg_pointer_rtx, X)\t\t\t\\\n-\t  || reg_mentioned_p (virtual_incoming_args_rtx, X)\t\t\\\n-\t  || reg_mentioned_p (virtual_outgoing_args_rtx, X)\t\t\\\n-\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, X)\t\t\\\n-\t  || reg_mentioned_p (virtual_stack_vars_rtx, X)))\t\t\\\n-    ;\t\t\t\t\t\t\t\t\t\\\n-  /* Accept any base register.  SP only in SImode or larger.  */\t\\\n-  else if (GET_CODE (X) == REG && REG_MODE_OK_FOR_BASE_P(X, MODE))\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\t\\\n-  else if (GET_MODE_SIZE (MODE) >= 4 && CONSTANT_P (X)\t\t\t\\\n-\t   && CONSTANT_POOL_ADDRESS_P (X) && ! flag_pic)\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  /* This is PC relative data after MACHINE_DEPENDENT_REORG runs.  */\t\\\n-  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n-\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t\\\n-\t       || (GET_CODE (X) == CONST\t\t\t\t\\\n-\t\t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)))\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  /* Post-inc indexing only supported for SImode and larger.  */\t\\\n-  else if (GET_CODE (X) == POST_INC && GET_MODE_SIZE (MODE) >= 4\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* REG+REG address can be any two index registers.  */\t\t\\\n-      /* ??? REG+REG addresses have been completely disabled before\t\\\n-\t reload completes, because we do not have enough available\t\\\n-\t reload registers.  We only have 3 guaranteed reload registers\t\\\n-\t (NONARG_LO_REGS - the frame pointer), but we need at least 4\t\\\n-\t to support REG+REG addresses.  We have left them enabled after\t\\\n-\t reload completes, in the hope that reload_cse_regs and related\t\\\n-\t routines will be able to create them after the fact.  It is\t\\\n-\t probably possible to support REG+REG addresses with additional\t\\\n-\t reload work, but I do not not have enough time to attempt such\t\\\n-\t a change at this time.  */\t\t\t\t\t\\\n-      /* ??? Normally checking the mode here is wrong, since it isn't\t\\\n-\t impossible to use REG+REG with DFmode.  However, the movdf\t\\\n-\t pattern requires offsettable addresses, and REG+REG is not\t\\\n-\t offsettable, so it must be rejected somehow.  Trying to use\t\\\n-\t 'o' fails, because offsettable_address_p does a QImode check.\t\\\n-\t QImode is not valid for stack addresses, and has a smaller\t\\\n-\t range for non-stack bases, and this causes valid addresses\t\\\n-\t to be rejected.  So we just eliminate REG+REG here by checking\t\\\n-\t the mode.  */\t\t\t\t\t\t\t\\\n-      /* We also disallow FRAME+REG addressing since we know that FRAME \\\n-\t will be replaced with STACK, and SP relative addressing only   \\\n-\t permits SP+OFFSET.  */\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n-\t  /* ??? See comment above.  */\t\t\t\t\t\\\n-\t  && reload_completed\t\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t  && XEXP (X, 0) != frame_pointer_rtx\t\t\t\t\\\n-\t  && XEXP (X, 1) != frame_pointer_rtx\t\t\t\t\\\n-\t  && XEXP (X, 0) != virtual_stack_vars_rtx\t\t\t\\\n-\t  && XEXP (X, 1) != virtual_stack_vars_rtx\t\t\t\\\n-\t  && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n-\t  && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      /* REG+const has 5-7 bit offset for non-SP registers.  */\t\t\\\n-      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t       && (REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\\\n-\t\t   || XEXP (X, 0) == arg_pointer_rtx)\t\t\t\\\n-\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t       && LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      /* REG+const has 10 bit offset for SP, but only SImode and\t\\\n-\t larger is supported.  */\t\t\t\t\t\\\n-      /* ??? Should probably check for DI/DFmode overflow here\t\t\\\n-\t just like GO_IF_LEGITIMATE_OFFSET does.  */\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t       && REGNO (XEXP (X, 0)) == STACK_POINTER_REGNUM\t\t\\\n-\t       && GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n-\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t       && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (X, 1))\t\\\n-\t\t   + GET_MODE_SIZE (MODE)) <= 1024\t\t\t\\\n-\t       && (INTVAL (XEXP (X, 1)) & 3) == 0)\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n-\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n-\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n-\t   && ! (flag_pic\t\t\t\t\t\t\\\n-\t\t && thumb_symbol_mentioned_p (get_pool_constant (X))))\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* ??? If an HImode FP+large_offset address is converted to an HImode\n-   SP+large_offset address, then reload won't know how to fix it.  It sees\n-   only that SP isn't valid for HImode, and so reloads the SP into an index\n-   register, but the resulting address is still invalid because the offset\n-   is too big.  We fix it here instead by reloading the entire address.  */\n-/* We could probably achieve better results by defining PROMOTE_MODE to help\n-   cope with the variances between the Thumb's signed and unsigned byte and\n-   halfword load instructions.  */\n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_MODE_SIZE (MODE) < 4\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-      && XEXP (X, 0) == stack_pointer_rtx\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-      && ! LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx orig_X = X;\t\t\t\t\t\t\t\\\n-      X = copy_rtx (X);\t\t\t\t\t\t\t\\\n-      push_reload (orig_X, NULL_RTX, &X, NULL_PTR,\t\t\t\\\n-\t\t   BASE_REG_CLASS,\t\t\t\t\t\\\n-\t\t   Pmode, VOIDmode, 0, 0, OPNUM, TYPE);\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-  \n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\n-extern struct rtx_def * legitimize_pic_address ();\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\t\t\t\\\n-    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\n-\n-#define LEGITIMATE_CONSTANT_P(X)\t\\\n- (GET_CODE (X) == CONST_INT\t\t\\\n-  || GET_CODE (X) == CONST_DOUBLE\t\\\n-  || CONSTANT_ADDRESS_P (X))\n-\n-\f\n-/* Condition Code Status */\n-\n-#define NOTICE_UPDATE_CC(EXP,INSN)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (get_attr_conds ((INSN)) != CONDS_UNCHANGED)\t\\\n-    CC_STATUS_INIT;\t\t\t\t\t\\\n-}\n-\n-\f\n-/* Describing Relative Costs of Operations */\n-\n-#define SLOW_BYTE_ACCESS 0\n-\n-#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n-\n-#define NO_FUNCTION_CSE 1\n-\n-#define NO_RECURSIVE_FUNCTION_CSE 1\n-\n-#define REGISTER_MOVE_COST(FROM,TO) \\\n-  (((FROM) == HI_REGS || (TO) == HI_REGS) ? 4 : 2)\n-\n-#define MEMORY_MOVE_COST(M,CLASS,IN) \\\n-     ((GET_MODE_SIZE(M) < 4 ? 8 : 2 * GET_MODE_SIZE(M)) * (CLASS == LO_REGS ? 1 : 2))\n-\n-/* This will allow better space optimization when compiling with -O */\n-#define BRANCH_COST (optimize > 1 ? 1 : 0)\n-\n-#define RTX_COSTS(X,CODE,OUTER)\t\t\t\t\t\\\n- case MULT:\t\t\t\t\t\t\t\\\n-   if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\\\n-       int cycles = 0;\t\t\t\t\t\t\\\n-       unsigned HOST_WIDE_INT i = INTVAL (XEXP (X, 1));\t\t\\\n-       while (i)\t\t\t\t\t\t\\\n-\t {\t\t\t\t\t\t\t\\\n-\t   i >>= 2;\t\t\t\t\t\t\\\n-\t   cycles++;\t\t\t\t\t\t\\\n-\t }\t\t\t\t\t\t\t\\\n-       return COSTS_N_INSNS (2) + cycles;\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\\\n-   return COSTS_N_INSNS (1) + 16;\t\t\t\t\\\n- case ASHIFT: case ASHIFTRT: case LSHIFTRT: case ROTATERT:\t\\\n- case PLUS: case MINUS: case COMPARE: case NEG: case NOT:\t\\\n-   return COSTS_N_INSNS (1);\t\t\t\t\t\\\n- case SET:\t\t\t\t\t\t\t\\\n-   return (COSTS_N_INSNS (1)\t\t\t\t\t\\\n-\t   + 4 * ((GET_CODE (SET_SRC (X)) == MEM)\t\t\\\n-\t\t  + GET_CODE (SET_DEST (X)) == MEM))\n-\n-#define CONST_COSTS(X,CODE,OUTER)\t\t\t\t\\\n- case CONST_INT:\t\t\t\t\t\t\\\n-   if ((OUTER) == SET)\t\t\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\\\n-       if ((unsigned HOST_WIDE_INT) INTVAL (X) < 256)\t\t\\\n-\t return 0;\t\t\t\t\t\t\\\n-       if (thumb_shiftable_const (INTVAL (X)))\t\t\t\\\n-\t return COSTS_N_INSNS (2);\t\t\t\t\\\n-       return COSTS_N_INSNS (3);\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\\\n-   else if (OUTER == PLUS\t\t\t\t\t\\\n-\t    && INTVAL (X) < 256 && INTVAL (X) > -256)\t\t\\\n-     return 0;\t\t\t\t\t\t\t\\\n-   else if (OUTER == COMPARE\t\t\t\t\t\\\n-\t    && (unsigned HOST_WIDE_INT) INTVAL (X) < 256)\t\\\n-     return 0;\t\t\t\t\t\t\t\\\n-   else if (OUTER == ASHIFT || OUTER == ASHIFTRT\t\t\\\n-\t    || OUTER == LSHIFTRT)\t\t\t\t\\\n-     return 0;\t\t\t\t\t\t\t\\\n-   return COSTS_N_INSNS (2);\t\t\t\t\t\\\n- case CONST:\t\t\t\t\t\t\t\\\n- case CONST_DOUBLE:\t\t\t\t\t\t\\\n- case LABEL_REF:\t\t\t\t\t\t\\\n- case SYMBOL_REF:\t\t\t\t\t\t\\\n-   return COSTS_N_INSNS(3);\n-\n-#define ADDRESS_COST(X) \t\t\t\t\t\\\n-  ((GET_CODE (X) == REG \t\t\t\t\t\\\n-    || (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == CONST_INT))\t\t\\\n-   ? 1 : 2)\n-\n-\f\n-/* Position Independent Code */\n-\n-extern const char * thumb_pic_register_string;\n-extern int thumb_pic_register;\n-\n-/* The register number of the register used to address a table of static\n-   data addresses in memory.  */\n-#define PIC_OFFSET_TABLE_REGNUM thumb_pic_register\n-\n-#define FINALIZE_PIC thumb_finalize_pic ()\n-\n-/* We can't directly access anything that contains a symbol,\n-   nor can we indirect via the constant pool.  */\n-#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n-\t(! thumb_symbol_mentioned_p (X)\t\t\t\t\\\n-\t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n-\t     || ! thumb_symbol_mentioned_p (get_pool_constant (X))))\n- \n-/* We need to know when we are making a constant pool; this determines\n-   whether data needs to be in the GOT or can be referenced via a GOT\n-   offset.  */\n-extern int making_const_table;\n-\n-\f\n-#define PRINT_OPERAND(STREAM,X,CODE) \\\n-  thumb_print_operand((STREAM), (X), (CODE))\n-\n-#define PRINT_OPERAND_ADDRESS(STREAM,X)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE ((X)) == REG)\t\t\t\t\t\\\n-    fprintf ((STREAM), \"[%s]\", reg_names[REGNO ((X))]);\t\t\\\n-  else if (GET_CODE ((X)) == POST_INC)\t\t\t\t\\\n-    fprintf ((STREAM), \"%s!\", reg_names[REGNO (XEXP (X, 0))]);\t\\\n-  else if (GET_CODE ((X)) == PLUS)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP ((X), 1)) == CONST_INT)\t\t\\\n-\tfprintf ((STREAM), \"[%s, #%d]\", \t\t\t\\\n-\t\t reg_names[REGNO (XEXP ((X), 0))],\t\t\\\n-\t\t (int) INTVAL (XEXP ((X), 1)));\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tfprintf ((STREAM), \"[%s, %s]\",\t\t\t\t\\\n-\t\t reg_names[REGNO (XEXP ((X), 0))],\t\t\\\n-\t\t reg_names[REGNO (XEXP ((X), 1))]);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    output_addr_const ((STREAM), (X));\t\t\t\t\\\n-}\n-\n-/* Handles PIC addr specially */\n-#define OUTPUT_INT_ADDR_CONST(STREAM,X) \\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (flag_pic && GET_CODE(X) == CONST && is_pic(X))\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\toutput_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 0), 0));\t\\\n-\tfputs(\" - (\", STREAM);\t\t\t\t\t\t\\\n-\toutput_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 1), 0));\t\\\n-\tfputs(\")\", STREAM);\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else output_addr_const(STREAM, X);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* Mark symbols as position independent.  We only do this in the\t\\\n-      .text segment, not in the .data segment. */\t\t\t\\\n-    if (NEED_GOT_RELOC && flag_pic && making_const_table &&\t\t\\\n-    \t(GET_CODE(X) == SYMBOL_REF || GET_CODE(X) == LABEL_REF))\t\\\n-     {\t\t\t\t\t\t\t\t\t\\\n-        if (GET_CODE(X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P(X))\t\\\n-          fprintf(STREAM, \"(GOTOFF)\");\t\t\t\t\t\\\n-        else if (GET_CODE (X) == LABEL_REF)\t\t\t\t\\\n-          fprintf(STREAM, \"(GOTOFF)\");\t\t\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-          fprintf(STREAM, \"(GOT)\");\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\t\\\n-  }\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '@' || ((CODE) == '_') || ((CODE) == '|'))\n-\n-/* Emit a special directive when defining a function name.\n-   This is used by the assembler to assit with interworking.  */\n-#define ASM_DECLARE_FUNCTION_NAME(file, name, decl)             \\\n-  if (! is_called_in_ARM_mode (decl))\t\t\t\\\n-    fprintf (file, \"\\t.thumb_func\\n\") ;\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    fprintf (file, \"\\t.code\\t32\\n\") ;\t\t\t\\\n-  ASM_OUTPUT_LABEL (file, name)\n-\n-#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)\t\t\t\\\n-  asm_fprintf ((STREAM), \"\\tpush {%R%s}\\n\", reg_names[(REGNO)])\n-\n-#define ASM_OUTPUT_REG_POP(STREAM,REGNO)\t\t\t\\\n-  asm_fprintf ((STREAM), \"\\tpop {%R%s}\\n\", reg_names[(REGNO)])\n-\n-#define FINAL_PRESCAN_INSN(INSN,OPVEC,NOPERANDS) \\\n-  thumb_final_prescan_insn (INSN)\n-\f\n-/* Controlling Debugging Information Format */\n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n-\n-/* Specific options for DBX Output */\n-\n-#define DEFAULT_GDB_EXTENSIONS 1\n-\n-\f\n-/* Cross Compilation and Floating Point */\n-\n-#define REAL_ARITHMETIC\n-\n-\f\n-/* Miscellaneous Parameters */\n-\n-#define PREDICATE_CODES \\\n-  {\"thumb_cmp_operand\", {SUBREG, REG, CONST_INT}},\n-\n-#define CASE_VECTOR_MODE Pmode\n-\n-#define WORD_REGISTER_OPERATIONS\n-\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n-\n-#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n-\n-#define MOVE_MAX 4\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC) 1\n-\n-#define STORE_FLAG_VALUE 1\n-\n-#define Pmode SImode\n-\n-#define FUNCTION_MODE SImode\n-\n-#define DOLLARS_IN_IDENTIFIERS 0\n-\n-#define NO_DOLLAR_IN_LABEL 1\n-\n-/* The literal pool needs to reside in the text area due to the\n-   limited PC addressing range: */\n-#define MACHINE_DEPENDENT_REORG(INSN) thumb_reorg (INSN)\n-\n-\f\n-/* Options specific to Thumb */\n-\n-/* True if a return instruction can be used in this function. */\n-#define USE_RETURN (reload_completed && thumb_trivial_epilogue ())\n-"}, {"sha": "c7f0683d8eedc3ae4134813dc791bdcc8a8a9905", "filename": "gcc/config/arm/tpe.h", "status": "removed", "additions": 0, "deletions": 425, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ftpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Ftpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftpe.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,425 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   for Thumb with PE object format.\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n-   Derived from arm/coff.h and arm/pe.h originally by Doug Evans (evans@cygnus.com).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"arm/thumb.h\"\n-\f\n-#define THUMB_PE 1\n-\n-/* Run-time Target Specification.  */\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION fputs (\" (Thumb/pe)\", stderr)\n-\f\n-/* Support the __declspec keyword by turning them into attributes.\n-   We currently only support: naked, dllimport, and dllexport.\n-   Note that the current way we do this may result in a collision with\n-   predefined attributes later on.  This can be solved by using one attribute,\n-   say __declspec__, and passing args to it.  The problem with that approach\n-   is that args are not accumulated: each new appearance would clobber any\n-   existing args.  */\n-#undef  CPP_PREDEFINES\n-#define CPP_PREDEFINES \"\\\n--Dthumb -D__thumb -D__pe__ -Acpu(arm) -Amachine(arm) \\\n--D__declspec(x)=__attribute__((x)) \\\n-\"\n-\n-/* Experimental addition for pr 7885.\n-   Ignore dllimport for functions.  */\n-#define ARM_FLAG_NOP_FUN_IMPORT\t\t0x20000\n-#define TARGET_NOP_FUN_DLLIMPORT (target_flags & ARM_FLAG_NOP_FUN_IMPORT)\n-\n-#undef  SUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES \\\n-{ \"nop-fun-dllimport\",\t\t  ARM_FLAG_NOP_FUN_IMPORT, \"Ignore dllimport attribute for functions\" }, \\\n-{ \"no-nop-fun-dllimport\",\t -ARM_FLAG_NOP_FUN_IMPORT, \"\" }, \n-\n-#undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT ARM_FLAG_NOP_FUN_IMPORT\n-\f\n-#undef  WCHAR_TYPE\n-#define WCHAR_TYPE \"short unsigned int\"\n-#undef  WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 16\n-\f\n-/* Setting this to 32 produces more efficient code, but the value set in previous\n-   versions of this toolchain was 8, which produces more compact structures. The\n-   command line option -mstructure_size_boundary=<n> can be used to change this\n-   value.  */\n-#undef  STRUCTURE_SIZE_BOUNDARY\n-#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary\n-\n-extern int arm_structure_size_boundary;\n-\f\n-/* This is COFF, but prefer stabs.  */\n-#define SDB_DEBUGGING_INFO\n-\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-#include \"dbxcoff.h\"\n-\f\n-/* Note - it is important that these definitions match those in semi.h for the ARM port.  */\n-#undef  LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX \".\"\n-\n-#undef  USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* A C statement to output assembler commands which will identify the\n-   object file as having been compiled with GNU CC (or another GNU\n-   compiler).  */\n-#define ASM_IDENTIFY_GCC(STREAM)\t\t\t\t\\\n-     fprintf (STREAM, \"%sgcc2_compiled.:\\n%s\", LOCAL_LABEL_PREFIX, ASM_APP_OFF )\n-\n-#undef  ASM_FILE_START\n-#define ASM_FILE_START(STREAM) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  fprintf ((STREAM), \"%s Generated by gcc %s for Thumb/coff\\n\", \\\n-\t   ASM_COMMENT_START, version_string);\t                \\\n-  fprintf ((STREAM), ASM_APP_OFF);                              \\\n-} while (0)\n-\n-/* A C statement to output something to the assembler file to switch to section\n-   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n-   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n-   define this macro in such cases.  */\n-#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n-  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n-} while (0)\n-\f\n-/* Support the ctors/dtors and other sections.  */\n-\n-#undef INIT_SECTION_ASM_OP\n-\n-/* Define this macro if jump tables (for `tablejump' insns) should be\n-   output in the text section, along with the assembler instructions.\n-   Otherwise, the readonly data section is used.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-#undef  READONLY_DATA_SECTION\n-#define READONLY_DATA_SECTION\trdata_section\n-#undef  RDATA_SECTION_ASM_OP\n-#define RDATA_SECTION_ASM_OP\t\"\\t.section .rdata\"\n-\n-#undef  CTORS_SECTION_ASM_OP\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section .ctors,\\\"x\\\"\"\n-#undef  DTORS_SECTION_ASM_OP\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section .dtors,\\\"x\\\"\"\n-\n-/* A list of other sections which the compiler might be \"in\" at any\n-   given time.  */\n-\n-#undef  EXTRA_SECTIONS\n-#define EXTRA_SECTIONS SUBTARGET_EXTRA_SECTIONS in_rdata, in_ctors, in_dtors\n-\n-#define SUBTARGET_EXTRA_SECTIONS\n-\n-/* A list of extra section function definitions.  */\n-\n-#undef  EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS \\\n-  RDATA_SECTION_FUNCTION\t\\\n-  CTORS_SECTION_FUNCTION\t\\\n-  DTORS_SECTION_FUNCTION\t\\\n-  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-\n-#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-\n-#define RDATA_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-rdata_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_rdata)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\t\\\n-      in_section = in_rdata;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define CTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-ctors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_ctors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define DTORS_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-dtors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_dtors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Support the ctors/dtors sections for g++.  */\n-\n-#define INT_ASM_OP \".word\"\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global constructors.  */\n-#undef  ASM_OUTPUT_CONSTRUCTOR\n-#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  ctors_section ();\t\t\t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global destructors.  */\n-#undef  ASM_OUTPUT_DESTRUCTOR\n-#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  dtors_section ();                   \t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);              \t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n-\n-/* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n-#define CTOR_LISTS_DEFINED_EXTERNALLY\n-\n-#undef DO_GLOBAL_CTORS_BODY\n-#undef DO_GLOBAL_DTORS_BODY\n-\n-/* The ARM development system defines __main.  */\n-#define NAME__MAIN \"__gccmain\"\n-#define SYMBOL__MAIN __gccmain\n-\f\n-/* This is to better conform to the ARM PCS.\n-   Richard Earnshaw hasn't put this into FSF sources yet so it's here.  */\n-#undef  RETURN_IN_MEMORY\n-#define RETURN_IN_MEMORY(TYPE) \t\t\t\t\t\t\\\n-  ((TYPE_MODE ((TYPE)) == BLKmode && ! TYPE_NO_FORCE_BLK (TYPE))\t\\\n-   || (AGGREGATE_TYPE_P ((TYPE)) && arm_pe_return_in_memory ((TYPE))))\n-extern int arm_pe_return_in_memory ();\n-\f\n-/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n-   is a valid machine specific attribute for DECL.\n-   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n-extern int arm_pe_valid_machine_decl_attribute ();\n-#undef  VALID_MACHINE_DECL_ATTRIBUTE\n-#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n-  arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n-\n-extern union tree_node * arm_pe_merge_machine_decl_attributes ();\n-#define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n-  arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n-\n-/* In addition to the stuff done in arm.h, we must mark dll symbols specially.\n-   Definitions of dllexport'd objects install some info in the .drectve\n-   section.  References to dllimport'd objects are fetched indirectly via\n-   __imp_.  If both are declared, dllexport overrides.\n-   This is also needed to implement one-only vtables: they go into their own\n-   section and we need to set DECL_SECTION_NAME so we do that here.\n-   Note that we can be called twice on the same decl.  */\n-extern void arm_pe_encode_section_info ();\n-#undef  ENCODE_SECTION_INFO\n-#define ENCODE_SECTION_INFO(DECL) \\\n-  arm_pe_encode_section_info (DECL)\n-\n-#define REDO_SECTION_INFO_P(DECL) 1\n-     \n-     /* Utility used only in this file.  */\n-#define ARM_STRIP_NAME_ENCODING(SYM_NAME) \\\n-((SYM_NAME) + ((SYM_NAME)[0] == '@' ? 3 : 0))\n-\n-/* Strip any text from SYM_NAME added by ENCODE_SECTION_INFO and store\n-   the result in VAR.  */\n-#undef  STRIP_NAME_ENCODING\n-#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n-(VAR) = ARM_STRIP_NAME_ENCODING (SYM_NAME)\n-\n-/* Define this macro if in some cases global symbols from one translation\n-   unit may not be bound to undefined symbols in another translation unit\n-   without user intervention.  For instance, under Microsoft Windows\n-   symbols must be explicitly imported from shared libraries (DLLs).  */\n-#define MULTIPLE_SYMBOL_SPACES\n-\n-#define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n-extern void arm_pe_unique_section ();\n-#define UNIQUE_SECTION(DECL,RELOC) arm_pe_unique_section (DECL, RELOC)\n-\n-#define SUPPORTS_ONE_ONLY 1\n-\n-/* A C statement to output something to the assembler file to switch to section\n-   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n-   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n-   define this macro in such cases.  */\n-#undef  ASM_OUTPUT_SECTION_NAME\n-#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n-  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n-  /* Functions may have been compiled at various levels of\t\\\n-     optimization so we can't use `same_size' here.  Instead,\t\\\n-     have the linker pick one.  */\t\t\t\t\\\n-  if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n-\t     TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n-\t     ? \"discard\" : \"same_size\");\t\t\t\\\n-} while (0)\n-\f\n-/* This outputs a lot of .req's to define alias for various registers.\n-   Let's try to avoid this.  */\n-#undef  ASM_FILE_START\n-#define ASM_FILE_START(STREAM) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"%s Generated by gcc %s for ARM/pe\\n\",\t\\\n-\t   ASM_COMMENT_START, version_string);\t\t\t\\\n-  output_file_directive ((STREAM), main_input_filename);\t\\\n-} while (0)\n-\n-/* Output a reference to a label.  */\n-#undef  ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n-fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, ARM_STRIP_NAME_ENCODING (NAME))\n-\n-/* Output a function definition label.  */\n-#undef  ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) \\\n-do {\t\t\t\t\t\t\t\\\n-  if (arm_dllexport_name_p (NAME))\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      drectve_section ();\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n-\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n-      function_section (DECL);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  if (! is_called_in_ARM_mode (decl))\t\t\t\\\n-    fprintf (STREAM, \"\\t.thumb_func\\n\") ;\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.code\\t32\\n\") ;\t\t\t\\\n-  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n-} while (0)\n-\n-/* Output a common block.  */\n-#undef  ASM_OUTPUT_COMMON\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED) \\\n-do {\t\t\t\t\t\t\t\\\n-  if (arm_dllexport_name_p (NAME))\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      drectve_section ();\t\t\t\t\\\n-      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n-\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  if (! arm_dllimport_name_p (NAME))\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\t\\\n-      assemble_name ((STREAM), (NAME));\t\t\t\\\n-      fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n-\t       (ROUNDED), ASM_COMMENT_START, (SIZE));\t\\\n-    }\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Output the label for an initialized variable.  */\n-#undef  ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \\\n-do {\t\t\t\t\t\t\t\\\n-  if (arm_dllexport_name_p (NAME))\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      enum in_section save_section = in_section;\t\\\n-      drectve_section ();\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n-\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n-      switch_to_section (save_section, (DECL));\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n-} while (0)\n-\f\n-/* Support the ctors/dtors and other sections.  */\n-\n-#define DRECTVE_SECTION_ASM_OP\t\"\\t.section .drectve\"\n-\n-/* A list of other sections which the compiler might be \"in\" at any\n-   given time.  */\n-\n-#undef  SUBTARGET_EXTRA_SECTIONS\n-#define SUBTARGET_EXTRA_SECTIONS in_drectve,\n-\n-/* A list of extra section function definitions.  */\n-\n-#undef  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n-#define SUBTARGET_EXTRA_SECTION_FUNCTIONS \\\n-  DRECTVE_SECTION_FUNCTION\t\\\n-  SWITCH_TO_SECTION_FUNCTION\n-\n-#define DRECTVE_SECTION_FUNCTION \\\n-void\t\t\t\t\t\t\t\t\t\\\n-drectve_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_drectve)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DRECTVE_SECTION_ASM_OP);\t\t\\\n-      in_section = in_drectve;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Switch to SECTION (an `enum in_section').\n-\n-   ??? This facility should be provided by GCC proper.\n-   The problem is that we want to temporarily switch sections in\n-   ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n-   afterwards.  */\n-#define SWITCH_TO_SECTION_FUNCTION \\\n-void \\\n-switch_to_section (section, decl) \\\n-     enum in_section section; \\\n-     tree decl; \\\n-{ \\\n-  switch (section) \\\n-    { \\\n-      case in_text: text_section (); break; \\\n-      case in_data: data_section (); break; \\\n-      case in_named: named_section (decl, NULL, 0); break; \\\n-      case in_rdata: rdata_section (); break; \\\n-      case in_ctors: ctors_section (); break; \\\n-      case in_dtors: dtors_section (); break; \\\n-      case in_drectve: drectve_section (); break; \\\n-      default: abort (); break; \\\n-    } \\\n-}\n-\n-\n-\f\n-extern int thumb_pe_valid_machine_decl_attribute ();\n-extern int arm_dllexport_p ();\n-extern int arm_dllimport_p ();\n-extern int arm_dllexport_name_p ();\n-extern int arm_dllimport_name_p ();\n-extern int arm_pe_return_in_memory ();"}, {"sha": "de2afdc6c9685f0da6e63611692ce96964ebacdc", "filename": "gcc/config/arm/uclinux-telf.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fuclinux-telf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fuclinux-telf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fuclinux-telf.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1,40 +0,0 @@\n-/* Definitions for Thumb running ucLinux using ELF\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n-   Contributed by Philip Blundell <pb@nexus.co.uk>\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"arm/linux-telf.h\"\n-\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION fputs (\" (Thumb/ELF ucLinux)\", stderr);\n-\n-#undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT (THUMB_FLAG_SINGLE_PIC_BASE)\n-\n-/* We don't want a PLT.  */\n-#undef  NEED_PLT_RELOC\n-#define NEED_PLT_RELOC 0\n-\n-/* On svr4, we *do* have support for the .init and .fini sections, and we\n-   can put stuff in there to be executed before and after `main'.  We let\n-   crtstuff.c and other files know this by defining the following symbols.\n-   The definitions say how to change sections to the .init and .fini\n-   sections.  This is the same for all known svr4 assemblers.  */\n-#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n-#define FINI_SECTION_ASM_OP\t\".section\\t.fini\""}, {"sha": "ba5d1edbb4beac977720672f3534d8e0f6f92065", "filename": "gcc/config/arm/unknown-elf.h", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Funknown-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Funknown-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funknown-elf.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -24,9 +24,17 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_VERSION\tfputs (\" (ARM/ELF non-Linux)\", stderr);\n #endif\n \n+/* If you don't define HAVE_ATEXIT, and the object file format/OS/whatever \n+   does not support constructors/destructors, then gcc implements destructors\n+   by defining its own exit function, which calls the destructors.  This gcc\n+   exit function overrides the C library's exit function, and this can cause\n+   all kinds of havoc if the C library has a non-trivial exit function.  You\n+   really don't want to use the exit function in libgcc2.c.  */\n+#define HAVE_ATEXIT\n+\n /* Default to using APCS-32 and software floating point.  */\n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32)\n+#define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32 | ARM_FLAG_APCS_FRAME)\n #endif\n \n /* Now we define the strings used to build the spec file.  */\n@@ -70,36 +78,36 @@ rdata_section ()\t\t\t\t\t\t\\\n }\n \n #define CTOR_LIST_BEGIN\t\t\t\t\t\\\n-asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n-func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) }\n+  asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n+  func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) }\n \n #define CTOR_LIST_END\t\t\t\t\t\\\n-asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n-func_ptr __CTOR_END__[1] = { (func_ptr) 0 };\n+  asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n+  func_ptr __CTOR_END__[1] = { (func_ptr) 0 };\n \n #define DTOR_LIST_BEGIN\t\t\t\t\t\\\n-asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n-func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) }\n+  asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n+  func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) }\n \n #define DTOR_LIST_END\t\t\t\t\t\\\n-asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n-func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n+  asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n+  func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n \n /* A C statement to output something to the assembler file to switch to section\n    NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n    NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n    define this macro in such cases.  */\n-#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)        \t\\\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t  \t\\\n-      if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t  \t\\\n-\tfprintf (STREAM, \"\\t.section %s,\\\"ax\\\",%%progbits\\n\", NAME);\t\\\n-      else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t  \t\\\n-\tfprintf (STREAM, \"\\t.section %s,\\\"a\\\"\\n\", NAME);\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+        fprintf (STREAM, \"\\t.section %s,\\\"ax\\\",@progbits\\n\", (NAME));\t\\\n+      else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+        fprintf (STREAM, \"\\t.section %s,\\\"a\\\"\\n\", (NAME));\t\t\\\n       else if (! strncmp (NAME, \".bss\", 4))      \t\t\t\\\n-\tfprintf (STREAM, \"\\t.section %s,\\\"aw\\\",%%nobits\\n\", NAME);\t\\\n-      else\t\t\t\t\t\t\t \t\\\n-\tfprintf (STREAM, \"\\t.section %s,\\\"aw\\\"\\n\", NAME);\t  \t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"aw\\\",@nobits\\n\", (NAME));\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        fprintf (STREAM, \"\\t.section %s,\\\"aw\\\"\\n\", (NAME));\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -108,14 +116,16 @@ func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n #define UNALIGNED_WORD_ASM_OP \".4byte\"\n \n #define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)                  \\\n-     fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, ADDR)\n+ fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, ADDR)\n \n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)                   \\\n-do {\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_WORD_ASM_OP);\t\t\\\n-  output_addr_const ((FILE), (RTX));\t\t\t\t\\\n-  fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_WORD_ASM_OP);\t\\\n+      output_addr_const ((FILE), (RTX));\t\t\t\\\n+      fputc ('\\n', (FILE));\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /* The ARM development system defines __main.  */\n@@ -127,20 +137,19 @@ do {\t\t\t\t\t\t\t\t\\\n   ((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL)\t\\\n    && DECL_SECTION_NAME (DECL) != NULL_TREE)\n \n-\n #define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n-     \n+\n #define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL) || flag_data_sections)\n-     \n+\n #define UNIQUE_SECTION(DECL, RELOC)\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       int len;\t\t\t\t\t\t\t\t\\\n       int sec;\t\t\t\t\t\t\t\t\\\n-      char *name;\t\t\t\t\t\t\t\\\n-      char *string;\t\t\t\t\t\t\t\\\n-      char *prefix;\t\t\t\t\t\t\t\\\n-      static char *prefixes[4][2] =\t\t\t\t\t\\\n+      const char * name;\t\t\t\t\t\t\\\n+      char * string;\t\t\t\t\t\t\t\\\n+      char * prefix;\t\t\t\t\t\t\t\\\n+      static char * prefixes[4][2] =\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \t{ \".text.\",   \".gnu.linkonce.t.\" },\t\t\t\t\\\n \t{ \".rodata.\", \".gnu.linkonce.r.\" },\t\t\t\t\\\n@@ -214,6 +223,6 @@ do {\t\t\t\t\t\t\t\t\\\n #ifndef SUBTARGET_CPU_DEFAULT\n #define SUBTARGET_CPU_DEFAULT \t\tTARGET_CPU_arm7tdmi\n #endif\n-     \n+\n /* Now get the routine arm-elf definitions.  */\n-#include \"arm/elf.h\"\n+#include \"elf.h\""}, {"sha": "3356ae2bc7d14a97e8574343b6eec3db240a24ab", "filename": "gcc/config/arm/xm-thumb.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fxm-thumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002e89d374d492d212bab58c9efacc2e6a480d60/gcc%2Fconfig%2Farm%2Fxm-thumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fxm-thumb.h?ref=002e89d374d492d212bab58c9efacc2e6a480d60", "patch": "@@ -1 +0,0 @@\n-#include <tm.h>"}, {"sha": "969317281ccf278e4857d9211b228fd0f01d3547", "filename": "gcc/configure", "status": "modified", "additions": 10, "deletions": 53, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -3452,11 +3452,11 @@ for machine in $build $host $target; do\n \t\t;;\n \tarm-*-coff* | armel-*-coff*)\n \t\ttm_file=arm/coff.h\n-\t\ttmake_file=arm/t-bare\n+\t\ttmake_file=arm/t-arm-coff\n \t\t;;\n \tarm-*-vxworks*)\n \t\ttm_file=arm/vxarm.h\n-\t\ttmake_file=arm/t-bare\n+\t\ttmake_file=arm/t-arm-coff\n \t\tthread_file='vxworks'\n \t\t;;\n \tarm-*-riscix1.[01]*)\t\t# Acorn RISC machine (early versions)\n@@ -3536,11 +3536,11 @@ for machine in $build $host $target; do\n \t\t;;\n \tarm*-*-aout)\n \t\ttm_file=arm/aout.h\n-\t\ttmake_file=arm/t-bare\n+\t\ttmake_file=arm/t-arm-aout\n \t\t;;\n         arm*-*-ecos-elf)\n \t\ttm_file=arm/ecos-elf.h\n-\t\ttmake_file=arm/t-elf\n+\t\ttmake_file=arm/t-arm-elf\n \t\t;; \n \tarm*-*-elf)\n \t\ttm_file=arm/unknown-elf.h\n@@ -6039,56 +6039,13 @@ for machine in $build $host $target; do\n #\t\t;;\n #\ttahoe-*-bsd*)\t\t\t# tahoe running BSD\n #\t\t;;\n-\tthumb-*-coff* | thumbel-*-coff*)\n-\t\ttm_file=arm/tcoff.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-elf* | thumbel-*-elf*)\n-\t\ttm_file=arm/telf.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb-elf\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-linux-gnu*)\n-\t\ttm_file=arm/linux-telf.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb-linux\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-uclinux*)\n-\t\ttm_file=arm/uclinux-telf.h\n-\t\tout_file=arm/thumb.c\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb-linux\n-\t\txm_file=arm/xm-thumb.h\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-wrs-vxworks)\n-\t\ttm_file=arm/tcoff.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb\n-\t\tthread_file='vxworks'\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-pe)\n-\t\ttm_file=arm/tpe.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-pe-thumb\n-\t\textra_objs=pe.o\n-\t\ttm_p_file=arm/thumb-protos.h\n+\tthumb*-*-*)\n+\t\t{ echo \"configure: error: \n+*** The Thumb targets have been depreciated.  The equivalent\n+*** ARM based toolchain can now generated Thumb instructions\n+*** when the -mthumb switch is given to the compiler.\" 1>&2; exit 1; }\n \t\t;;\n+\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)\n #\t\tcpu_type=gmicro"}, {"sha": "b9e147df2ad41ec04bb49614fbee228b574bd705", "filename": "gcc/configure.in", "status": "modified", "additions": 17, "deletions": 54, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -727,11 +727,11 @@ changequote([,])dnl\n \t\t;;\n \tarm-*-coff* | armel-*-coff*)\n \t\ttm_file=arm/coff.h\n-\t\ttmake_file=arm/t-bare\n+\t\ttmake_file=arm/t-arm-coff\n \t\t;;\n \tarm-*-vxworks*)\n \t\ttm_file=arm/vxarm.h\n-\t\ttmake_file=arm/t-bare\n+\t\ttmake_file=arm/t-arm-coff\n \t\tthread_file='vxworks'\n \t\t;;\n changequote(,)dnl\n@@ -813,11 +813,11 @@ changequote([,])dnl\n \t\t;;\n \tarm*-*-aout)\n \t\ttm_file=arm/aout.h\n-\t\ttmake_file=arm/t-bare\n+\t\ttmake_file=arm/t-arm-aout\n \t\t;;\n         arm*-*-ecos-elf)\n \t\ttm_file=arm/ecos-elf.h\n-\t\ttmake_file=arm/t-elf\n+\t\ttmake_file=arm/t-arm-elf\n \t\t;; \n \tarm*-*-elf)\n \t\ttm_file=arm/unknown-elf.h\n@@ -834,7 +834,7 @@ changequote([,])dnl\n \tarm-*-pe*)\n \t\ttm_file=arm/pe.h\n \t\ttmake_file=arm/t-pe\n-\t\textra_objs=pe.o\n+\t\textra_objs=\"pe.o\"\n \t\t;;\n \tavr-*-*)\n \t\t;;\n@@ -3125,6 +3125,12 @@ changequote([,])dnl\n \t\tif test x$host != x$target\n \t\tthen\n \t\t\ttmake_file=rs6000/t-xnewas\n+\t\telse\n+\t\t\ttmake_file=rs6000/t-newas\n+\t\tfi\n+\t\tif test \"$gnu_ld\" = yes\n+\t\tthen\n+\t\t\txmake_file=rs6000/x-aix41-gld\n \t\telse\n \t\t\ttmake_file=\"rs6000/t-newas rs6000/t-aix41\"\n \t\tfi\n@@ -3450,55 +3456,12 @@ changequote([,])dnl\n #\t\t;;\n #\ttahoe-*-bsd*)\t\t\t# tahoe running BSD\n #\t\t;;\n-\tthumb-*-coff* | thumbel-*-coff*)\n-\t\ttm_file=arm/tcoff.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-elf* | thumbel-*-elf*)\n-\t\ttm_file=arm/telf.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb-elf\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-linux-gnu*)\n-\t\ttm_file=arm/linux-telf.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb-linux\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-uclinux*)\n-\t\ttm_file=arm/uclinux-telf.h\n-\t\tout_file=arm/thumb.c\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb-linux\n-\t\txm_file=arm/xm-thumb.h\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-wrs-vxworks)\n-\t\ttm_file=arm/tcoff.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-thumb\n-\t\tthread_file='vxworks'\n-\t\ttm_p_file=arm/thumb-protos.h\n-\t\t;;\n-\tthumb-*-pe)\n-\t\ttm_file=arm/tpe.h\n-\t\tout_file=arm/thumb.c\n-\t\txm_file=arm/xm-thumb.h\n-\t\tmd_file=arm/thumb.md\n-\t\ttmake_file=arm/t-pe-thumb\n-\t\textra_objs=pe.o\n-\t\ttm_p_file=arm/thumb-protos.h\n+\n+\tthumb*-*-*)\n+\t\tAC_MSG_ERROR([\n+*** The Thumb targets have been depreciated.  The equivalent\n+*** ARM based toolchain can now generated Thumb instructions\n+*** when the -mthumb switch is given to the compiler.])\n \t\t;;\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)"}]}