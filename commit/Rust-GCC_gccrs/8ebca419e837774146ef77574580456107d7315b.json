{"sha": "8ebca419e837774146ef77574580456107d7315b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGViY2E0MTllODM3Nzc0MTQ2ZWY3NzU3NDU4MDQ1NjEwN2Q3MzE1Yg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2015-08-02T17:39:23Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2015-08-02T17:39:23Z"}, "message": "Improve -Wmisleading-indentation heuristics\n\ngcc/c-family/ChangeLog:\n\n\t* c-indentation.c (should_warn_for_misleading_indentation):\n\tImprove heuristics.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/Wmisleading-indentation.c: Add more tests.\n\nFrom-SVN: r226479", "tree": {"sha": "bb853556afc05d1d755f8887612038504e3c912d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb853556afc05d1d755f8887612038504e3c912d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ebca419e837774146ef77574580456107d7315b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ebca419e837774146ef77574580456107d7315b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ebca419e837774146ef77574580456107d7315b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ebca419e837774146ef77574580456107d7315b/comments", "author": null, "committer": null, "parents": [{"sha": "1a1e101ff50564a44dcd12522236f04caaa6dcab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1e101ff50564a44dcd12522236f04caaa6dcab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a1e101ff50564a44dcd12522236f04caaa6dcab"}], "stats": {"total": 342, "additions": 322, "deletions": 20}, "files": [{"sha": "02374d33f8279ccba7cf52871d9e00869f7b95c3", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ebca419e837774146ef77574580456107d7315b/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ebca419e837774146ef77574580456107d7315b/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=8ebca419e837774146ef77574580456107d7315b", "patch": "@@ -1,3 +1,8 @@\n+2015-08-02  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* c-indentation.c (should_warn_for_misleading_indentation):\n+\tImprove heuristics.\n+\n 2015-08-02  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \t* c-indentation.c (get_visual_column): Add parameter first_nws,"}, {"sha": "fdfe0a9341272d086fb68b85bbb41b2dd88a7108", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 147, "deletions": 20, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ebca419e837774146ef77574580456107d7315b/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ebca419e837774146ef77574580456107d7315b/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=8ebca419e837774146ef77574580456107d7315b", "patch": "@@ -182,6 +182,7 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n   location_t body_loc = body_tinfo.location;\n   location_t next_stmt_loc = next_tinfo.location;\n \n+  enum cpp_ttype body_type = body_tinfo.type;\n   enum cpp_ttype next_tok_type = next_tinfo.type;\n \n   /* Don't attempt to compare the indentation of BODY_LOC and NEXT_STMT_LOC\n@@ -227,12 +228,33 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n       || next_tinfo.keyword == RID_ELSE)\n     return false;\n \n+  /* Likewise, if the body of the guard is a compound statement then control\n+     flow is quite visually explicit regardless of the code's possibly poor\n+     indentation, e.g.\n+\n+     while (foo)  <- GUARD\n+       {          <- BODY\n+       bar ();\n+       }\n+       baz ();    <- NEXT\n+\n+    Things only get muddy when the body of the guard does not have\n+    braces, e.g.\n+\n+    if (foo)  <- GUARD\n+      bar (); <- BODY\n+      baz (); <- NEXT\n+  */\n+  if (body_type == CPP_OPEN_BRACE)\n+    return false;\n+\n   /* Don't warn here about spurious semicolons.  */\n   if (next_tok_type == CPP_SEMICOLON)\n     return false;\n \n   expanded_location body_exploc = expand_location (body_loc);\n   expanded_location next_stmt_exploc = expand_location (next_stmt_loc);\n+  expanded_location guard_exploc = expand_location (guard_loc);\n \n   /* They must be in the same file.  */\n   if (next_stmt_exploc.file != body_exploc.file)\n@@ -250,13 +272,20 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n        if (flag) foo (); bar ();\n                          ^ WARN HERE\n \n+\n+       if (flag) ; {\n+                   ^ WARN HERE\n+\n+       if (flag)\n+        ; {\n+          ^ WARN HERE\n+\n      Cases where we don't want to issue a warning:\n \n        various_code (); if (flag) foo (); bar (); more_code ();\n                                           ^ DON'T WARN HERE.  */\n   if (next_stmt_exploc.line == body_exploc.line)\n     {\n-      expanded_location guard_exploc = expand_location (guard_loc);\n       if (guard_exploc.file != body_exploc.file)\n \treturn true;\n       if (guard_exploc.line < body_exploc.line)\n@@ -304,44 +333,95 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t  bar ();\n \t  ^ DON'T WARN HERE\n \n-        if (flag) {\n-          foo ();\n-        } else\n-        {\n-          bar ();\n-        }\n-        baz ();\n-        ^ DON'T WARN HERE\n+\tif (flag)\n+\t  ;\n+\t  foo ();\n+\t  ^ DON'T WARN HERE\n   */\n   if (next_stmt_exploc.line > body_exploc.line)\n     {\n       /* Determine if GUARD_LOC and NEXT_STMT_LOC are aligned on the same\n \t \"visual column\"...  */\n       unsigned int next_stmt_vis_column;\n       unsigned int body_vis_column;\n+      unsigned int body_line_first_nws;\n       /* If we can't determine it, don't issue a warning.  This is sometimes\n \t the case for input files containing #line directives, and these\n \t are often for autogenerated sources (e.g. from .md files), where\n \t it's not clear that it's meaningful to look at indentation.  */\n       if (!get_visual_column (next_stmt_exploc, &next_stmt_vis_column))\n \treturn false;\n-      if (!get_visual_column (body_exploc, &body_vis_column))\n+      if (!get_visual_column (body_exploc,\n+\t\t\t      &body_vis_column,\n+\t\t\t      &body_line_first_nws))\n \treturn false;\n-      if (next_stmt_vis_column == body_vis_column)\n+      if ((body_type != CPP_SEMICOLON\n+\t   && next_stmt_vis_column == body_vis_column)\n+\t  /* As a special case handle the case where the body is a semicolon\n+\t     that may be hidden by a preceding comment, e.g.  */\n+\n+\t  // if (p)\n+\t  //   /* blah */;\n+\t  //   foo (1);\n+\n+\t  /*  by looking instead at the column of the first non-whitespace\n+\t      character on the body line.  */\n+\t  || (body_type == CPP_SEMICOLON\n+\t      && body_exploc.line > guard_exploc.line\n+\t      && body_line_first_nws != body_vis_column\n+\t      && next_stmt_vis_column == body_line_first_nws))\n \t{\n-\t  /* Don't warn if they aren't aligned on the same column\n-\t     as the guard itself (suggesting autogenerated code that\n-\t     doesn't bother indenting at all).  */\n-\t  expanded_location guard_exploc = expand_location (guard_loc);\n+          /* Don't warn if they are aligned on the same column\n+\t     as the guard itself (suggesting autogenerated code that doesn't\n+\t     bother indenting at all).  We consider the column of the first\n+\t     non-whitespace character on the guard line instead of the column\n+\t     of the actual guard token itself because it is more sensible.\n+\t     Consider:\n+\n+\t     if (p) {\n+\t     foo (1);\n+\t     } else     // GUARD\n+\t     foo (2);   // BODY\n+\t     foo (3);   // NEXT\n+\n+\t     and:\n+\n+\t     if (p)\n+\t       foo (1);\n+\t     } else       // GUARD\n+\t       foo (2);   // BODY\n+\t       foo (3);   // NEXT\n+\n+\t     If we just used the column of the guard token, we would warn on\n+\t     the first example and not warn on the second.  But we want the\n+\t     exact opposite to happen: to not warn on the first example (which\n+\t     is probably autogenerated) and to warn on the second (whose\n+\t     indentation is misleading).  Using the column of the first\n+\t     non-whitespace character on the guard line makes that\n+\t     happen.  */\n \t  unsigned int guard_vis_column;\n-\t  if (!get_visual_column (guard_exploc, &guard_vis_column))\n+\t  unsigned int guard_line_first_nws;\n+\t  if (!get_visual_column (guard_exploc,\n+\t\t\t\t  &guard_vis_column,\n+\t\t\t\t  &guard_line_first_nws))\n \t    return false;\n-\t  if (guard_vis_column == body_vis_column)\n+\n+\t  if (guard_line_first_nws == body_vis_column)\n \t    return false;\n \n-\t  /* PR 66220: Don't warn if the guarding statement is more\n-\t     indented than the next/body stmts.  */\n-\t  if (guard_vis_column > body_vis_column)\n+\t  /* We may have something like:\n+\n+\t     if (p)\n+\t       {\n+\t       foo (1);\n+\t       } else  // GUARD\n+\t     foo (2);  // BODY\n+\t     foo (3);  // NEXT\n+\n+\t     in which case the columns are not aligned but the code is not\n+\t     misleadingly indented.  If the column of the body is less than\n+\t     that of the guard line then don't warn.  */\n+\t  if (body_vis_column < guard_line_first_nws)\n \t    return false;\n \n \t  /* Don't warn if there is multiline preprocessor logic between\n@@ -352,6 +432,53 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t  /* Otherwise, they are visually aligned: issue a warning.  */\n \t  return true;\n \t}\n+\n+\t/* Also issue a warning for code having the form:\n+\n+\t   if (flag);\n+\t     foo ();\n+\n+\t   while (flag);\n+\t   {\n+\t     ...\n+\t   }\n+\n+\t   for (...);\n+\t     {\n+\t       ...\n+\t     }\n+\n+\t   if (flag)\n+\t     ;\n+\t   else if (flag);\n+\t     foo ();\n+\n+\t   where the semicolon at the end of each guard is most likely spurious.\n+\n+\t   But do not warn on:\n+\n+\t   for (..);\n+\t   foo ();\n+\n+\t   where the next statement is aligned with the guard.\n+\t*/\n+\tif (body_type == CPP_SEMICOLON)\n+\t  {\n+\t    if (body_exploc.line == guard_exploc.line)\n+\t      {\n+\t\tunsigned int guard_vis_column;\n+\t\tunsigned int guard_line_first_nws;\n+\t\tif (!get_visual_column (guard_exploc,\n+\t\t\t\t\t&guard_vis_column,\n+\t\t\t\t\t&guard_line_first_nws))\n+\t\t  return false;\n+\n+\t\tif (next_stmt_vis_column > guard_line_first_nws\n+\t\t    || (next_tok_type == CPP_OPEN_BRACE\n+\t\t\t&& next_stmt_vis_column == guard_vis_column))\n+\t\t  return true;\n+\t      }\n+\t  }\n     }\n \n   return false;"}, {"sha": "82aa654a8bc54fbec0f9460c768990d5ad96a028", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ebca419e837774146ef77574580456107d7315b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ebca419e837774146ef77574580456107d7315b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ebca419e837774146ef77574580456107d7315b", "patch": "@@ -1,3 +1,7 @@\n+2015-08-02  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* c-c++-common/Wmisleading-indentation.c: Add more tests.\n+\n 2015-08-01  Michael Collison  <michael.collison@linaro.org\n \t    Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n "}, {"sha": "0d6d8d2cc4eb87b5199c1f3949359db250716517", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation.c", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ebca419e837774146ef77574580456107d7315b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ebca419e837774146ef77574580456107d7315b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c?ref=8ebca419e837774146ef77574580456107d7315b", "patch": "@@ -691,3 +691,169 @@ fn_36 (void)\n \t}\n \tfoo(6); /* We shouldn't warn here.  */\n }\n+\n+/* The following function contain code whose indentation is misleading, thus\n+   we warn about it.  */\n+\n+void\n+fn_37 (void)\n+{\n+  int i;\n+\n+#define EMPTY\n+#define FOR_EACH(VAR, START, STOP) for (VAR = START; VAR < STOP; VAR++)\n+\n+  while (flagA); /* { dg-message \"3: ...this 'while' clause\" } */\n+    foo (0); /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagA)\n+    ;\n+  else if (flagA); /* { dg-message \"8: ...this 'if' clause\" } */\n+    foo (0); /* { dg-warning \"statement is indented as if\" } */\n+  while (flagA) /* { dg-message \"3: ...this 'while' clause\" } */\n+    /* blah */;\n+    foo (0); /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagA)\n+    ;\n+  else if (flagA) /* { dg-message \"8: ...this 'if' clause\" } */\n+    foo (1);\n+    foo (2); /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagA)\n+    foo (1);\n+  else if (flagA) /* { dg-message \"8: ...this 'if' clause\" } */\n+    foo (2);\n+    foo (3); /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagB) /* { dg-message \"3: ...this 'if' clause\" } */\n+    /* blah */;\n+    { /* { dg-warning \"statement is indented as if\" } */\n+      foo (0);\n+    }\n+\n+  if (flagB)\n+    ;\n+  else; foo (0); /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagC); foo (2); /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagA)\n+    ; /* blah */ { /* { dg-warning \"statement is indented as if\" } */\n+      foo (1);\n+    }\n+\n+  if (flagB) ; /* { dg-message \"3: ...this 'if' clause\" } */\n+    return; /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagB) EMPTY; /* { dg-message \"3: ...this 'if' clause\" } */\n+    foo (1); /* { dg-warning \"statement is indented as if\" } */\n+\n+  for (i = 0; i < 10; i++); /* { dg-message \"3: ...this 'for' clause\" } */\n+    foo (2); /* { dg-warning \"statement is indented as if\" } */\n+\n+  FOR_EACH (i, 0, 10);\n+    foo (2); /* { dg-warning \"statement is indented as if\" } */\n+\n+  FOR_EACH (i, 0, 10);\n+    { /* { dg-warning \"statement is indented as if\" } */\n+      foo (3);\n+    }\n+\n+  FOR_EACH (i, 0, 10);\n+  { /* { dg-warning \"statement is indented as if\" } */\n+    foo (3);\n+  }\n+\n+  while (i++); { /* { dg-warning \"statement is indented as if\" } */\n+    foo (3);\n+  }\n+\n+  if (i++); { /* { dg-warning \"statement is indented as if\" } */\n+    foo (3);\n+  }\n+\n+  if (flagA) {\n+    foo (1);\n+  } else /* { dg-message \"5: ...this 'else' clause\" } */\n+    if (flagB)\n+       foo (2);\n+    foo (3); /* { dg-warning \"statement is indented as if\" } */\n+\n+  if (flagA)\n+    foo (1);\n+  else if (flagB); /* { dg-message \"8: ...this 'if' clause\" } */\n+    foo (2); /* { dg-warning \"statement is indented as if\" } */\n+\n+#undef EMPTY\n+#undef FOR_EACH\n+}\n+\n+/* The following function contains code whose indentation is not great but not\n+   misleading, thus we don't warn.  */\n+\n+void\n+fn_38 (void)\n+{\n+  int i = 0;\n+\n+  while (flagA)\n+    ;\n+    foo (0);\n+\n+  if (flagB)\n+    ;\n+    {\n+      foo (0);\n+    }\n+\n+  while (flagC);\n+  foo (2);\n+\n+  if (flagA)\n+    while (flagC++);\n+  else\n+    foo (2);\n+\n+  if (i)\n+    while (i++ < 10000);\n+  foo (5);\n+\n+  if (i) while (i++ < 10000);\n+  foo (5);\n+\n+  if (flagA) {\n+    foo (1);\n+  } else\n+  if (flagB)\n+    foo (2);\n+  foo (3);\n+\n+  if (flagA)\n+    {\n+    foo (1);\n+    } else\n+  if (flagB)\n+    foo (2);\n+  foo (3);\n+}\n+\n+/* The following function contains good indentation which we definitely should\n+   not warn about.  */\n+\n+void\n+fn_39 (void)\n+{\n+  if (flagA)\n+    ;\n+  if (flagB)\n+    ;\n+\n+  if (flagA)\n+    if (flagB)\n+      foo (0);\n+    else\n+      foo (1);\n+  else\n+    foo (2);\n+}"}]}