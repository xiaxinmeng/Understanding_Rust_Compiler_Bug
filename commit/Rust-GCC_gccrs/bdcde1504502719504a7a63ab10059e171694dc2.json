{"sha": "bdcde1504502719504a7a63ab10059e171694dc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjZGUxNTA0NTAyNzE5NTA0YTdhNjNhYjEwMDU5ZTE3MTY5NGRjMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-08T12:17:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-08T13:08:10Z"}, "message": "tree-optimization/98544 - more permute optimization fixes\n\nPermute nodes are not transparent to the permute of their children.\nInstead we have to materialize child permutes always and in future\nmay treat permute nodes as the source of arbitrary permutes as\nwe can permute the lane permutation vector at will (as the target\nsupports in the end).\n\n2021-01-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/98544\n\t* tree-vect-slp.c (vect_optimize_slp): Always materialize\n\tpermutes at a permute node.\n\n\t* gcc.dg/vect/bb-slp-pr98544.c: New testcase.", "tree": {"sha": "5a143e25895b14de5fb6abf1c73e78b6ea3873a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a143e25895b14de5fb6abf1c73e78b6ea3873a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdcde1504502719504a7a63ab10059e171694dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcde1504502719504a7a63ab10059e171694dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdcde1504502719504a7a63ab10059e171694dc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcde1504502719504a7a63ab10059e171694dc2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b885264a48dcd71b7aeb26c0abeb91246724897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b885264a48dcd71b7aeb26c0abeb91246724897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b885264a48dcd71b7aeb26c0abeb91246724897"}], "stats": {"total": 66, "additions": 53, "deletions": 13}, "files": [{"sha": "756dc02ebad6557d3486881b93e82abd7f53fcaa", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr98544.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcde1504502719504a7a63ab10059e171694dc2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr98544.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcde1504502719504a7a63ab10059e171694dc2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr98544.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr98544.c?ref=bdcde1504502719504a7a63ab10059e171694dc2", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+\n+double a[2], b[2], c[2], d[2];\n+\n+void __attribute__((noipa))\n+foo()\n+{\n+  double a0 = a[0];\n+  double a1 = a[1];\n+  double b0 = b[0];\n+  double b1 = b[1];\n+  double c0 = c[0];\n+  double c1 = c[1];\n+  double tem1 = a1 - b1;\n+  double tem2 = a0 + b0;\n+  d[0] = tem1 * c1;\n+  d[1] = tem2 * c0;\n+}\n+\n+int main()\n+{\n+  a[0] = 1.;\n+  a[1] = 2.;\n+  b[0] = 3.;\n+  b[1] = 4.;\n+  c[0] = 2.;\n+  c[1] = 3.;\n+  foo ();\n+  if (d[0] != -6. || d[1] != 8.)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "e0f3539aa54e8a5165acdb75fd222bae628d3f33", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdcde1504502719504a7a63ab10059e171694dc2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdcde1504502719504a7a63ab10059e171694dc2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=bdcde1504502719504a7a63ab10059e171694dc2", "patch": "@@ -3029,19 +3029,27 @@ vect_optimize_slp (vec_info *vinfo)\n \n \t  /* Decide on permute materialization.  Look whether there's\n \t     a use (pred) edge that is permuted differently than us.\n-\t     In that case mark ourselves so the permutation is applied.  */\n-\t  bool all_preds_permuted = slpg->vertices[idx].pred != NULL;\n-\t  for (graph_edge *pred = slpg->vertices[idx].pred;\n-\t       pred; pred = pred->pred_next)\n-\t    {\n-\t      gcc_checking_assert (bitmap_bit_p (n_visited, pred->src));\n-\t      int pred_perm = n_perm[pred->src];\n-\t      if (!vect_slp_perms_eq (perms, perm, pred_perm))\n-\t\t{\n-\t\t  all_preds_permuted = false;\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t     In that case mark ourselves so the permutation is applied.\n+\t     For VEC_PERM_EXPRs the permutation doesn't carry along\n+\t     from children to parents so force materialization at the\n+\t     point of the VEC_PERM_EXPR.  In principle VEC_PERM_EXPRs\n+\t     are a source of an arbitrary permutation again, similar\n+\t     to constants/externals - that's something we do not yet\n+\t     optimally handle.  */\n+\t  bool all_preds_permuted = (SLP_TREE_CODE (node) != VEC_PERM_EXPR\n+\t\t\t\t     && slpg->vertices[idx].pred != NULL);\n+\t  if (all_preds_permuted)\n+\t    for (graph_edge *pred = slpg->vertices[idx].pred;\n+\t\t pred; pred = pred->pred_next)\n+\t      {\n+\t\tgcc_checking_assert (bitmap_bit_p (n_visited, pred->src));\n+\t\tint pred_perm = n_perm[pred->src];\n+\t\tif (!vect_slp_perms_eq (perms, perm, pred_perm))\n+\t\t  {\n+\t\t    all_preds_permuted = false;\n+\t\t    break;\n+\t\t  }\n+\t      }\n \t  if (!all_preds_permuted)\n \t    {\n \t      if (!bitmap_bit_p (n_materialize, idx))"}]}