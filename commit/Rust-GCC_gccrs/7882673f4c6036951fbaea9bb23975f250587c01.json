{"sha": "7882673f4c6036951fbaea9bb23975f250587c01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg4MjY3M2Y0YzYwMzY5NTFmYmFlYTliYjIzOTc1ZjI1MDU4N2MwMQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2011-08-05T14:09:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:09:33Z"}, "message": "a-fihema.ads, [...] (Finalization_Collection): Avoid heap allocation for Objects component.\n\n2011-08-05  Bob Duff  <duff@adacore.com>\n\n\t* a-fihema.ads, a-fihema.adb (Finalization_Collection): Avoid heap\n\tallocation for Objects component. This simplifies the code somewhat. It\n\tis also a little more efficient in the not-so-unusual case where there\n\tare no controlled objects allocated.\n\tMake Finalization_Started flag atomic.\n\t(Finalize): Avoid unnecessary detachment of items from the list.\n\t(pcol): Minor cleanup.\n\nFrom-SVN: r177439", "tree": {"sha": "95d9fe2f3f2d0672a147fa18ad64ca7c091f73fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95d9fe2f3f2d0672a147fa18ad64ca7c091f73fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7882673f4c6036951fbaea9bb23975f250587c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7882673f4c6036951fbaea9bb23975f250587c01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7882673f4c6036951fbaea9bb23975f250587c01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7882673f4c6036951fbaea9bb23975f250587c01/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d34cd27401917a9b85e7ad5ac2cbca62bbc458cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34cd27401917a9b85e7ad5ac2cbca62bbc458cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d34cd27401917a9b85e7ad5ac2cbca62bbc458cc"}], "stats": {"total": 139, "additions": 43, "deletions": 96}, "files": [{"sha": "162a81135d1000e0499b3682e02375071278720f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7882673f4c6036951fbaea9bb23975f250587c01/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7882673f4c6036951fbaea9bb23975f250587c01/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7882673f4c6036951fbaea9bb23975f250587c01", "patch": "@@ -1,3 +1,13 @@\n+2011-08-05  Bob Duff  <duff@adacore.com>\n+\n+\t* a-fihema.ads, a-fihema.adb (Finalization_Collection): Avoid heap\n+\tallocation for Objects component. This simplifies the code somewhat. It\n+\tis also a little more efficient in the not-so-unusual case where there\n+\tare no controlled objects allocated.\n+\tMake Finalization_Started flag atomic.\n+\t(Finalize): Avoid unnecessary detachment of items from the list.\n+\t(pcol): Minor cleanup.\n+\n 2011-08-05  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch12.adb (Analyze_Formal_Package_Declaration): reject a formal"}, {"sha": "0b1fc7a695dcd45366a6e0ce76c27f817152623a", "filename": "gcc/ada/a-fihema.adb", "status": "modified", "additions": 22, "deletions": 92, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7882673f4c6036951fbaea9bb23975f250587c01/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7882673f4c6036951fbaea9bb23975f250587c01/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=7882673f4c6036951fbaea9bb23975f250587c01", "patch": "@@ -31,7 +31,6 @@\n \n with Ada.Exceptions;          use Ada.Exceptions;\n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n \n with System;                  use System;\n with System.Address_Image;\n@@ -60,8 +59,6 @@ package body Ada.Finalization.Heap_Management is\n    procedure Detach (N : Node_Ptr);\n    --  Unhook a node from an arbitrary list\n \n-   procedure Free is new Ada.Unchecked_Deallocation (Node, Node_Ptr);\n-\n    ---------------------------\n    -- Add_Offset_To_Address --\n    ---------------------------\n@@ -117,7 +114,7 @@ package body Ada.Finalization.Heap_Management is\n             --  top of the allocated bits into a list header.\n \n             N_Ptr := Address_To_Node_Ptr (N_Addr);\n-            Attach (N_Ptr, Collection.Objects);\n+            Attach (N_Ptr, Collection.Objects'Unchecked_Access);\n \n             --  Move the address from Prev to the start of the object. This\n             --  operation effectively hides the list header.\n@@ -251,54 +248,10 @@ package body Ada.Finalization.Heap_Management is\n    overriding procedure Finalize\n      (Collection : in out Finalization_Collection)\n    is\n-      function Head (L : Node_Ptr) return Node_Ptr;\n-      --  Return the node that comes after the dummy head\n-\n-      function Is_Dummy_Head (N : Node_Ptr) return Boolean;\n-      --  Determine whether a node acts as a dummy head. Such nodes do not\n-      --  have an actual \"object\" attached to them and point to themselves.\n-\n-      function Is_Empty_List (L : Node_Ptr) return Boolean;\n-      --  Determine whether a list is empty\n-\n       function Node_Ptr_To_Address (N : Node_Ptr) return Address;\n       --  Not the reverse of Address_To_Node_Ptr. Return the address of the\n       --  object following the list header.\n \n-      ----------\n-      -- Head --\n-      ----------\n-\n-      function Head (L : Node_Ptr) return Node_Ptr is\n-      begin\n-         return L.Next;\n-      end Head;\n-\n-      -------------------\n-      -- Is_Dummy_Head --\n-      -------------------\n-\n-      function Is_Dummy_Head (N : Node_Ptr) return Boolean is\n-      begin\n-         --  To be a dummy head, the node must point to itself in both\n-         --  directions.\n-\n-         return\n-           N.Next /= null\n-             and then N.Next = N\n-             and then N.Prev /= null\n-             and then N.Prev = N;\n-      end Is_Dummy_Head;\n-\n-      -------------------\n-      -- Is_Empty_List --\n-      -------------------\n-\n-      function Is_Empty_List (L : Node_Ptr) return Boolean is\n-      begin\n-         return L = null or else Is_Dummy_Head (L);\n-      end Is_Empty_List;\n-\n       -------------------------\n       -- Node_Ptr_To_Address --\n       -------------------------\n@@ -308,9 +261,8 @@ package body Ada.Finalization.Heap_Management is\n          return N.all'Address + Header_Offset;\n       end Node_Ptr_To_Address;\n \n-      Curr_Ptr : Node_Ptr;\n+      Curr_Ptr : Node_Ptr := Collection.Objects.Next; -- skip dummy head\n       Ex_Occur : Exception_Occurrence;\n-      Next_Ptr : Node_Ptr;\n       Raised   : Boolean := False;\n \n    --  Start of processing for Finalize\n@@ -323,28 +275,11 @@ package body Ada.Finalization.Heap_Management is\n \n       Collection.Finalization_Started := True;\n \n-      while not Is_Empty_List (Collection.Objects) loop\n-\n-         --  Find the real head of the collection, skipping the dummy head\n-\n-         Curr_Ptr := Head (Collection.Objects);\n-\n-         --  If the dummy head is the only remaining node, all real objects\n-         --  have already been detached and finalized.\n-\n-         if Is_Dummy_Head (Curr_Ptr) then\n-            exit;\n-         end if;\n-\n-         --  Store the next node now since the detachment will destroy the\n-         --  reference to it.\n-\n-         Next_Ptr := Curr_Ptr.Next;\n-\n-         --  Remove the current node from the list\n-\n-         Detach (Curr_Ptr);\n+      --  Go through the Objects list, and finalize each one. There is no need\n+      --  to detach items from the list, because the whole collection is about\n+      --  to go away.\n \n+      while Curr_Ptr /= Collection.Objects'Unchecked_Access loop\n          --  ??? Kludge: Don't do anything until the proper place to set\n          --  primitive Finalize_Address has been determined.\n \n@@ -361,13 +296,9 @@ package body Ada.Finalization.Heap_Management is\n             end;\n          end if;\n \n-         Curr_Ptr := Next_Ptr;\n+         Curr_Ptr := Curr_Ptr.Next;\n       end loop;\n \n-      --  Deallocate the dummy head\n-\n-      Free (Collection.Objects);\n-\n       --  If the finalization of a particular node raised an exception, reraise\n       --  it after the remainder of the list has been finalized.\n \n@@ -384,19 +315,21 @@ package body Ada.Finalization.Heap_Management is\n      (Collection : in out Finalization_Collection)\n    is\n    begin\n-      Collection.Objects := new Node;\n-\n       --  The dummy head must point to itself in both directions\n \n-      Collection.Objects.Next := Collection.Objects;\n-      Collection.Objects.Prev := Collection.Objects;\n+      Collection.Objects.Next := Collection.Objects'Unchecked_Access;\n+      Collection.Objects.Prev := Collection.Objects'Unchecked_Access;\n    end Initialize;\n \n    ----------\n    -- pcol --\n    ----------\n \n    procedure pcol (Collection : Finalization_Collection) is\n+      Head      : constant Node_Ptr := Collection.Objects'Unrestricted_Access;\n+      --  \"Unrestricted\", because we're evilly getting access-to-variable of a\n+      --  constant!  OK for debugging code.\n+\n       Head_Seen : Boolean := False;\n       N_Ptr     : Node_Ptr;\n \n@@ -447,21 +380,18 @@ package body Ada.Finalization.Heap_Management is\n       --         - points to\n       --  (dummy head) - present if dummy head\n \n-      N_Ptr := Collection.Objects;\n+      N_Ptr := Head;\n \n-      while N_Ptr /= null loop\n+      while N_Ptr /= null loop -- Should never be null; we being defensive\n          Put_Line (\"V\");\n \n-         --  The current node is the head. If we have already traversed the\n-         --  chain, the head will be encountered again since the chain is\n-         --  circular.\n+         --  We see the head initially; we want to exit when we see the head a\n+         --  SECOND time.\n+\n+         if N_Ptr = Head then\n+            exit when Head_Seen;\n \n-         if N_Ptr = Collection.Objects then\n-            if Head_Seen then\n-               exit;\n-            else\n-               Head_Seen := True;\n-            end if;\n+            Head_Seen := True;\n          end if;\n \n          --  The current element is null. This should never happen since the\n@@ -488,7 +418,7 @@ package body Ada.Finalization.Heap_Management is\n \n          --  Detect the dummy head\n \n-         if N_Ptr = Collection.Objects then\n+         if N_Ptr = Head then\n             Put_Line (\" (dummy head)\");\n          else\n             Put_Line (\"\");"}, {"sha": "7e492ad80070e600b67d505aff84ef84a8d05d48", "filename": "gcc/ada/a-fihema.ads", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7882673f4c6036951fbaea9bb23975f250587c01/gcc%2Fada%2Fa-fihema.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7882673f4c6036951fbaea9bb23975f250587c01/gcc%2Fada%2Fa-fihema.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.ads?ref=7882673f4c6036951fbaea9bb23975f250587c01", "patch": "@@ -93,11 +93,11 @@ package Ada.Finalization.Heap_Management is\n    overriding procedure Finalize\n      (Collection : in out Finalization_Collection);\n    --  Traverse the objects of Collection, invoking Finalize_Address on each of\n-   --  them. In the end, the routine destroys its dummy head and tail.\n+   --  them.\n \n    overriding procedure Initialize\n      (Collection : in out Finalization_Collection);\n-   --  Create a new Collection by allocating a dummy head and tail\n+   --  Initialize the finalization list to empty\n \n    procedure Set_Finalize_Address_Ptr\n      (Collection : in out Finalization_Collection;\n@@ -117,6 +117,11 @@ private\n    pragma No_Strict_Aliasing (Node_Ptr);\n \n    type Node is record\n+      --  This should really be limited, but we can see the full view of\n+      --  Limited_Controlled, which NOT limited. If it were limited, we could\n+      --  default initialize here, and get rid of Initialize for\n+      --  Finalization_Collection.\n+\n       Prev : Node_Ptr;\n       Next : Node_Ptr;\n    end record;\n@@ -128,8 +133,10 @@ private\n       --  All objects and node headers are allocated on this underlying pool;\n       --  the collection is simply a wrapper around it.\n \n-      Objects : Node_Ptr;\n-      --  The head of a doubly linked list\n+      Objects : aliased Node;\n+      --  The head of a doubly linked list containing all allocated objects\n+      --  with controlled parts that still exist (Unchecked_Deallocation has\n+      --  not been done on them).\n \n       Finalize_Address : Finalize_Address_Ptr;\n       --  A reference to a routine that finalizes an object denoted by its"}]}