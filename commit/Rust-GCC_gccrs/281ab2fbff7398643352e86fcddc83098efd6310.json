{"sha": "281ab2fbff7398643352e86fcddc83098efd6310", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgxYWIyZmJmZjczOTg2NDMzNTJlODZmY2RkYzgzMDk4ZWZkNjMxMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-07-22T16:53:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-07-22T16:53:27Z"}, "message": "Change std::ceil2 to be undefined if the result can't be represented\n\n\t* include/std/bit (__ceil2): Make unrepresentable results undefined,\n\tas per P1355R2. Add debug assertion. Perform one left shift, not two,\n\tso that out of range values cause undefined behaviour. Ensure that\n\tshift will still be undefined if left operand is promoted.\n\t* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: Replace checks for\n\tunrepresentable values with checks that they are not core constant\n\texpressions.\n\t* testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc: New test.\n\nFrom-SVN: r273705", "tree": {"sha": "5e500b94f761c64dfe86debc7cf2745280099424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e500b94f761c64dfe86debc7cf2745280099424"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/281ab2fbff7398643352e86fcddc83098efd6310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281ab2fbff7398643352e86fcddc83098efd6310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/281ab2fbff7398643352e86fcddc83098efd6310", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281ab2fbff7398643352e86fcddc83098efd6310/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "462e6f9a932a44ca73715dc5c2960e5b332f63f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/462e6f9a932a44ca73715dc5c2960e5b332f63f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/462e6f9a932a44ca73715dc5c2960e5b332f63f7"}], "stats": {"total": 141, "additions": 132, "deletions": 9}, "files": [{"sha": "4d163357f5a0c1f6be92fe9b2dad8ccd006718f9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=281ab2fbff7398643352e86fcddc83098efd6310", "patch": "@@ -1,3 +1,14 @@\n+2019-07-22  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/bit (__ceil2): Make unrepresentable results undefined,\n+\tas per P1355R2. Add debug assertion. Perform one left shift, not two,\n+\tso that out of range values cause undefined behaviour. Ensure that\n+\tshift will still be undefined if left operand is promoted.\n+\t* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: Replace checks for\n+\tunrepresentable values with checks that they are not core constant\n+\texpressions.\n+\t* testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc: New test.\n+\n 2019-07-19  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/bits/stl_tempbuf.h (__detail::__return_temporary_buffer): Fix"}, {"sha": "d019b1ee6009d48e9493ba20b2fd9032ca6cc744", "filename": "libstdc++-v3/include/std/bit", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit?ref=281ab2fbff7398643352e86fcddc83098efd6310", "patch": "@@ -197,9 +197,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr auto _Nd = numeric_limits<_Tp>::digits;\n       if (__x == 0 || __x == 1)\n         return 1;\n-      const unsigned __n = _Nd - std::__countl_zero((_Tp)(__x - 1u));\n-      const _Tp __y_2 = (_Tp)1u << (__n - 1u);\n-      return __y_2 << 1u;\n+      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));\n+      // If the shift exponent equals _Nd then the correct result is not\n+      // representable as a value of _Tp, and so the result is undefined.\n+      // Want that undefined behaviour to be detected in constant expressions,\n+      // by UBSan, and by debug assertions.\n+#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n+      if (!__builtin_is_constant_evaluated())\n+\t__glibcxx_assert( __shift_exponent != numeric_limits<_Tp>::digits );\n+#endif\n+      using __promoted_type = decltype(__x << 1);\n+      if _GLIBCXX17_CONSTEXPR (!is_same<__promoted_type, _Tp>::value)\n+\t{\n+\t  // If __x undergoes integral promotion then shifting by _Nd is\n+\t  // not undefined. In order to make the shift undefined, so that\n+\t  // it is diagnosed in constant expressions and by UBsan, we also\n+\t  // need to \"promote\" the shift exponent to be too large for the\n+\t  // promoted type.\n+\t  const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;\n+\t  __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;\n+\t}\n+      return (_Tp)1u << __shift_exponent;\n     }\n \n   template<typename _Tp>"}, {"sha": "f870d4dcd744fb641a29729efab88a887cf069b3", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2.cc", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2.cc?ref=281ab2fbff7398643352e86fcddc83098efd6310", "patch": "@@ -20,6 +20,21 @@\n \n #include <bit>\n \n+template<typename T>\n+  constexpr T max = std::numeric_limits<T>::max();\n+// Largest representable power of two (i.e. has most significant bit set)\n+template<typename T>\n+  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);\n+\n+// Detect whether std::ceil2(N) is a constant expression.\n+template<auto N, typename = void>\n+  struct ceil2_valid\n+  : std::false_type { };\n+\n+template<auto N>\n+  struct ceil2_valid<N, std::void_t<char[(std::ceil2(N), 1)]>>\n+  : std::true_type { };\n+\n template<typename UInt>\n constexpr auto\n test(UInt x)\n@@ -55,13 +70,18 @@ test(UInt x)\n     static_assert( std::ceil2(UInt(3) << 64) == (UInt(4) << 64) );\n   }\n \n-  constexpr UInt msb = UInt(1) << (std::numeric_limits<UInt>::digits - 1);\n+  constexpr UInt msb = maxpow2<UInt>;\n+  static_assert( ceil2_valid<msb>() );\n   static_assert( std::ceil2( msb ) == msb );\n-  // Larger values cannot be represented so the return value is unspecified,\n-  // but must still be valid in constant expressions, i.e. not undefined.\n-  static_assert( std::ceil2( UInt(msb + 1) ) != 77 );\n-  static_assert( std::ceil2( UInt(msb + 2) ) != 77 );\n-  static_assert( std::ceil2( UInt(msb + 77) ) != 77 );\n+  static_assert( std::ceil2( UInt(msb - 1) ) == msb );\n+  static_assert( std::ceil2( UInt(msb - 2) ) == msb );\n+  static_assert( std::ceil2( UInt(msb - 3) ) == msb );\n+\n+  // P1355R2: not a constant expression if the result is not representable\n+  static_assert( !ceil2_valid<UInt(msb + 1)>() );\n+  static_assert( !ceil2_valid<max<UInt>>() );\n+  static_assert( !ceil2_valid<UInt(max<UInt> - 1)>() );\n+  static_assert( !ceil2_valid<UInt(max<UInt> - 2)>() );\n \n   return true;\n }"}, {"sha": "8e107065a92aa78dcfc2fbd1e5577491efe56bfc", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281ab2fbff7398643352e86fcddc83098efd6310/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2_neg.cc?ref=281ab2fbff7398643352e86fcddc83098efd6310", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -D_GLIBCXX_ASSERTIONS\" }\n+// { dg-do run { target c++2a } }\n+// { dg-xfail-run-if \"__glibcxx_assert in ceil2 should fail\" { *-*-* } }\n+\n+#include <bit>\n+\n+// P1355R2: not a constant expression if the result is not representable\n+\n+template<auto N, typename = void>\n+  struct ceil2_valid\n+  : std::false_type { };\n+\n+template<auto N>\n+  struct ceil2_valid<N, std::void_t<char[(std::ceil2(N), 1)]>>\n+  : std::true_type { };\n+\n+template<typename T>\n+  constexpr T max = std::numeric_limits<T>::max();\n+template<typename T>\n+  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);\n+\n+static_assert( ceil2_valid<maxpow2<unsigned char>>() );\n+static_assert( !ceil2_valid<maxpow2<unsigned char> + (unsigned char)1>() );\n+\n+static_assert( !ceil2_valid<max<unsigned char>>() );\n+static_assert( !ceil2_valid<max<unsigned char> - (unsigned char)1>() );\n+\n+static_assert( ceil2_valid<maxpow2<unsigned short>>() );\n+static_assert( !ceil2_valid<maxpow2<unsigned short> + (unsigned short)1>() );\n+static_assert( !ceil2_valid<max<unsigned short>>() );\n+static_assert( !ceil2_valid<max<unsigned short> - (unsigned short)1>() );\n+\n+static_assert( ceil2_valid<maxpow2<unsigned int>>() );\n+static_assert( !ceil2_valid<maxpow2<unsigned int> + 1u>() );\n+static_assert( !ceil2_valid<max<unsigned int>>() );\n+static_assert( !ceil2_valid<max<unsigned int> - 1u>() );\n+\n+static_assert( ceil2_valid<maxpow2<unsigned long>>() );\n+static_assert( !ceil2_valid<maxpow2<unsigned long> + 1ul>() );\n+static_assert( !ceil2_valid<max<unsigned long>>() );\n+static_assert( !ceil2_valid<max<unsigned long> - 1ul>() );\n+\n+static_assert( ceil2_valid<maxpow2<unsigned long long>>() );\n+static_assert( !ceil2_valid<maxpow2<unsigned long long> + 1ull>() );\n+static_assert( !ceil2_valid<max<unsigned long long>>() );\n+static_assert( !ceil2_valid<max<unsigned long long> - 1ull>() );\n+\n+void\n+test01()\n+{\n+  std::ceil2( maxpow2<unsigned> + 1u ); // should fail __glibcxx_assert\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}