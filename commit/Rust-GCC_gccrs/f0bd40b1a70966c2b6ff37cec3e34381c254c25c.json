{"sha": "f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBiZDQwYjFhNzA5NjZjMmI2ZmYzN2NlYzNlMzQzODFjMjU0YzI1Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-19T15:19:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-19T15:19:09Z"}, "message": "cfgloop.h (struct loop_iterator): C++-ify, add constructor and destructor and make fel_next a member function.\n\n2013-11-19  Richard Biener  <rguenther@suse.de>\n\n\t* cfgloop.h (struct loop_iterator): C++-ify, add constructor\n\tand destructor and make fel_next a member function.\n\t(fel_next): Transform into ...\n\t(loop_iterator::next): ... this.\n\t(fel_init): Transform into ...\n\t(loop_iterator::loop_iterator): ... this.\n\t(loop_iterator::~loop_iterator): New.\n\t(FOR_EACH_LOOP): Remove loop-iterator argument.\n\t(FOR_EACH_LOOP_BREAK): Remove no longer necessary macro.\n\t* cfgloop.c, cfgloopmanip.c, config/mn10300/mn10300.c,\n\tgraphite-clast-to-gimple.c, graphite-scop-detection.c,\n\tgraphite-sese-to-poly.c, ipa-inline-analysis.c, ipa-pure-const.c,\n\tloop-init.c, loop-invariant.c, loop-unroll.c, loop-unswitch.c,\n\tmodulo-sched.c, predict.c, sel-sched-ir.c, tree-cfg.c, tree-data-ref.c,\n\ttree-if-conv.c, tree-loop-distribution.c, tree-parloops.c,\n\ttree-predcom.c, tree-scalar-evolution.c, tree-ssa-dce.c,\n\ttree-ssa-loop-ch.c, tree-ssa-loop-im.c, tree-ssa-loop-ivcanon.c,\n\ttree-ssa-loop-ivopts.c, tree-ssa-loop-manip.c, tree-ssa-loop-niter.c,\n\ttree-ssa-loop-prefetch.c, tree-ssa-loop-unswitch.c,\n\ttree-ssa-threadupdate.c, tree-vectorizer.c, tree-vrp.c: Adjust\n\tuses of FOR_EACH_LOOP and remove loop_iterator variables.  Replace\n\tFOR_EACH_LOOP_BREAK with break.\n\nFrom-SVN: r205032", "tree": {"sha": "34623898ed17a6ada892874aaaea06c9394a310a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34623898ed17a6ada892874aaaea06c9394a310a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92495ff691accaf2a9e2163067fe1627a45e69b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92495ff691accaf2a9e2163067fe1627a45e69b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92495ff691accaf2a9e2163067fe1627a45e69b1"}], "stats": {"total": 263, "additions": 121, "deletions": 142}, "files": [{"sha": "7736e5d07bed9f76293285335b92ac84be076ce3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1,3 +1,28 @@\n+2013-11-19  Richard Biener  <rguenther@suse.de>\n+\n+\t* cfgloop.h (struct loop_iterator): C++-ify, add constructor\n+\tand destructor and make fel_next a member function.\n+\t(fel_next): Transform into ...\n+\t(loop_iterator::next): ... this.\n+\t(fel_init): Transform into ...\n+\t(loop_iterator::loop_iterator): ... this.\n+\t(loop_iterator::~loop_iterator): New.\n+\t(FOR_EACH_LOOP): Remove loop-iterator argument.\n+\t(FOR_EACH_LOOP_BREAK): Remove no longer necessary macro.\n+\t* cfgloop.c, cfgloopmanip.c, config/mn10300/mn10300.c,\n+\tgraphite-clast-to-gimple.c, graphite-scop-detection.c,\n+\tgraphite-sese-to-poly.c, ipa-inline-analysis.c, ipa-pure-const.c,\n+\tloop-init.c, loop-invariant.c, loop-unroll.c, loop-unswitch.c,\n+\tmodulo-sched.c, predict.c, sel-sched-ir.c, tree-cfg.c, tree-data-ref.c,\n+\ttree-if-conv.c, tree-loop-distribution.c, tree-parloops.c,\n+\ttree-predcom.c, tree-scalar-evolution.c, tree-ssa-dce.c,\n+\ttree-ssa-loop-ch.c, tree-ssa-loop-im.c, tree-ssa-loop-ivcanon.c,\n+\ttree-ssa-loop-ivopts.c, tree-ssa-loop-manip.c, tree-ssa-loop-niter.c,\n+\ttree-ssa-loop-prefetch.c, tree-ssa-loop-unswitch.c,\n+\ttree-ssa-threadupdate.c, tree-vectorizer.c, tree-vrp.c: Adjust\n+\tuses of FOR_EACH_LOOP and remove loop_iterator variables.  Replace\n+\tFOR_EACH_LOOP_BREAK with break.\n+\n 2013-11-19  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59164"}, {"sha": "a5eb4da3490b619b0e9e6f5d8255f500a52f5aa3", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -156,15 +156,14 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n void\n flow_loops_dump (FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *, int), int verbose)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n   if (!current_loops || ! file)\n     return;\n \n   fprintf (file, \";; %d loops found\\n\", number_of_loops (cfun));\n \n-  FOR_EACH_LOOP (li, loop, LI_INCLUDE_ROOT)\n+  FOR_EACH_LOOP (loop, LI_INCLUDE_ROOT)\n     {\n       flow_loop_dump (loop, file, loop_dump_aux, verbose);\n     }\n@@ -767,10 +766,9 @@ disambiguate_multiple_latches (struct loop *loop)\n void\n disambiguate_loops_with_multiple_latches (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       if (!loop->latch)\n \tdisambiguate_multiple_latches (loop);\n@@ -1327,7 +1325,6 @@ verify_loop_structure (void)\n   int err = 0;\n   edge e;\n   unsigned num = number_of_loops (cfun);\n-  loop_iterator li;\n   struct loop_exit *exit, *mexit;\n   bool dom_available = dom_info_available_p (CDI_DOMINATORS);\n   sbitmap visited;\n@@ -1369,7 +1366,7 @@ verify_loop_structure (void)\n   visited = sbitmap_alloc (last_basic_block);\n   bitmap_clear (visited);\n   bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       unsigned n;\n \n@@ -1416,7 +1413,7 @@ verify_loop_structure (void)\n   sbitmap_free (visited);\n \n   /* Check headers and latches.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       i = loop->num;\n       if (loop->header == NULL)\n@@ -1536,7 +1533,7 @@ verify_loop_structure (void)\n     }\n \n   /* Check the recorded loop exits.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       if (!loop->exits || loop->exits->e != NULL)\n \t{\n@@ -1630,7 +1627,7 @@ verify_loop_structure (void)\n \t  err = 1;\n \t}\n \n-      FOR_EACH_LOOP (li, loop, 0)\n+      FOR_EACH_LOOP (loop, 0)\n \t{\n \t  eloops = 0;\n \t  for (exit = loop->exits->next; exit->e; exit = exit->next)"}, {"sha": "68285a6d1b89d08d41ab5caa6e638c6c963ca01f", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -542,48 +542,52 @@ enum li_flags\n \n /* The iterator for loops.  */\n \n-typedef struct\n+struct loop_iterator\n {\n+  loop_iterator (loop_p *loop, unsigned flags);\n+  ~loop_iterator ();\n+\n+  inline loop_p next ();\n+\n   /* The list of loops to visit.  */\n   vec<int> to_visit;\n \n   /* The index of the actual loop.  */\n   unsigned idx;\n-} loop_iterator;\n+};\n \n-static inline void\n-fel_next (loop_iterator *li, loop_p *loop)\n+inline loop_p\n+loop_iterator::next ()\n {\n   int anum;\n \n-  while (li->to_visit.iterate (li->idx, &anum))\n+  while (this->to_visit.iterate (this->idx, &anum))\n     {\n-      li->idx++;\n-      *loop = get_loop (cfun, anum);\n-      if (*loop)\n-\treturn;\n+      this->idx++;\n+      loop_p loop = get_loop (cfun, anum);\n+      if (loop)\n+\treturn loop;\n     }\n \n-  li->to_visit.release ();\n-  *loop = NULL;\n+  return NULL;\n }\n \n-static inline void\n-fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n+inline\n+loop_iterator::loop_iterator (loop_p *loop, unsigned flags)\n {\n   struct loop *aloop;\n   unsigned i;\n   int mn;\n \n-  li->idx = 0;\n+  this->idx = 0;\n   if (!current_loops)\n     {\n-      li->to_visit.create (0);\n+      this->to_visit.create (0);\n       *loop = NULL;\n       return;\n     }\n \n-  li->to_visit.create (number_of_loops (cfun));\n+  this->to_visit.create (number_of_loops (cfun));\n   mn = (flags & LI_INCLUDE_ROOT) ? 0 : 1;\n \n   if (flags & LI_ONLY_INNERMOST)\n@@ -592,7 +596,7 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n \tif (aloop != NULL\n \t    && aloop->inner == NULL\n \t    && aloop->num >= mn)\n-\t  li->to_visit.quick_push (aloop->num);\n+\t  this->to_visit.quick_push (aloop->num);\n     }\n   else if (flags & LI_FROM_INNERMOST)\n     {\n@@ -605,7 +609,7 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n       while (1)\n \t{\n \t  if (aloop->num >= mn)\n-\t    li->to_visit.quick_push (aloop->num);\n+\t    this->to_visit.quick_push (aloop->num);\n \n \t  if (aloop->next)\n \t    {\n@@ -627,7 +631,7 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n       while (1)\n \t{\n \t  if (aloop->num >= mn)\n-\t    li->to_visit.quick_push (aloop->num);\n+\t    this->to_visit.quick_push (aloop->num);\n \n \t  if (aloop->inner != NULL)\n \t    aloop = aloop->inner;\n@@ -642,19 +646,19 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n \t}\n     }\n \n-  fel_next (li, loop);\n+  *loop = this->next ();\n }\n \n-#define FOR_EACH_LOOP(LI, LOOP, FLAGS) \\\n-  for (fel_init (&(LI), &(LOOP), FLAGS); \\\n-       (LOOP); \\\n-       fel_next (&(LI), &(LOOP)))\n+inline\n+loop_iterator::~loop_iterator ()\n+{\n+  this->to_visit.release ();\n+}\n \n-#define FOR_EACH_LOOP_BREAK(LI) \\\n-  { \\\n-    (LI).to_visit.release (); \\\n-    break; \\\n-  }\n+#define FOR_EACH_LOOP(LOOP, FLAGS) \\\n+  for (loop_iterator li(&(LOOP), FLAGS); \\\n+       (LOOP); \\\n+       (LOOP) = li.next ())\n \n /* The properties of the target.  */\n struct target_cfgloop {"}, {"sha": "714c7e1177f8468851bd519beb1e1fa932c269ae", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1585,13 +1585,12 @@ create_preheader (struct loop *loop, int flags)\n void\n create_preheaders (int flags)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n   if (!current_loops)\n     return;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     create_preheader (loop, flags);\n   loops_state_set (LOOPS_HAVE_PREHEADERS);\n }\n@@ -1601,11 +1600,10 @@ create_preheaders (int flags)\n void\n force_single_succ_latches (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   edge e;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       if (loop->latch != loop->header && single_succ_p (loop->latch))\n \tcontinue;"}, {"sha": "7304e8638c7dc8a7f1347cb796cb25b7054d9db1", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -3229,7 +3229,6 @@ mn10300_loop_contains_call_insn (loop_p loop)\n static void\n mn10300_scan_for_setlb_lcc (void)\n {\n-  loop_iterator liter;\n   loop_p loop;\n \n   DUMP (\"Looking for loops that can use the SETLB insn\", NULL_RTX);\n@@ -3244,7 +3243,7 @@ mn10300_scan_for_setlb_lcc (void)\n      if an inner loop is not suitable for use with the SETLB/Lcc insns, it may\n      be the case that its parent loop is suitable.  Thus we should check all\n      loops, but work from the innermost outwards.  */\n-  FOR_EACH_LOOP (liter, loop, LI_ONLY_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n       const char * reason = NULL;\n "}, {"sha": "a661dbbc91b101fa056151383894d453fafe5cce", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1718,10 +1718,9 @@ gloog (scop_p scop, bb_pbb_htab_type bb_pbb_mapping)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       loop_p loop;\n-      loop_iterator li;\n       int num_no_dependency = 0;\n \n-      FOR_EACH_LOOP (li, loop, 0)\n+      FOR_EACH_LOOP (loop, 0)\n \tif (loop->can_be_parallel)\n \t  num_no_dependency++;\n "}, {"sha": "001712673e756c8bfa71530729ae47ea8030a22d", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1375,14 +1375,13 @@ canonicalize_loop_closed_ssa (loop_p loop)\n static void\n canonicalize_loop_closed_ssa_form (void)\n {\n-  loop_iterator li;\n   loop_p loop;\n \n #ifdef ENABLE_CHECKING\n   verify_loop_closed_ssa (true);\n #endif\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     canonicalize_loop_closed_ssa (loop);\n \n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);"}, {"sha": "544ea93265e616b53330f27c6e63402dce9a3dc6", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"sese.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"expr.h\"\n \n #ifdef HAVE_cloog\n #include \"expr.h\"\n@@ -3064,12 +3065,11 @@ rewrite_commutative_reductions_out_of_ssa_loop (scop_p scop,\n static void\n rewrite_commutative_reductions_out_of_ssa (scop_p scop)\n {\n-  loop_iterator li;\n   loop_p loop;\n   bool changed = false;\n   sese region = SCOP_REGION (scop);\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     if (loop_in_sese_p (loop, region))\n       changed |= rewrite_commutative_reductions_out_of_ssa_loop (scop, loop);\n \n@@ -3091,12 +3091,11 @@ rewrite_commutative_reductions_out_of_ssa (scop_p scop)\n static bool\n scop_ivs_can_be_represented (scop_p scop)\n {\n-  loop_iterator li;\n   loop_p loop;\n   gimple_stmt_iterator psi;\n   bool result = true;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       if (!loop_in_sese_p (loop, SCOP_REGION (scop)))\n \tcontinue;\n@@ -3116,7 +3115,7 @@ scop_ivs_can_be_represented (scop_p scop)\n \t    }\n \t}\n       if (!result)\n-\tFOR_EACH_LOOP_BREAK (li);\n+\tbreak;\n     }\n \n   return result;"}, {"sha": "3cd335ffd7d018c5d3c5bdb21683d0097e936295", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -2601,14 +2601,13 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   if (!early && nonconstant_names.exists ())\n     {\n       struct loop *loop;\n-      loop_iterator li;\n       predicate loop_iterations = true_predicate ();\n       predicate loop_stride = true_predicate ();\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tflow_loops_dump (dump_file, NULL, 0);\n       scev_initialize ();\n-      FOR_EACH_LOOP (li, loop, 0)\n+      FOR_EACH_LOOP (loop, 0)\n \t{\n \t  vec<edge> exits;\n \t  edge ex;"}, {"sha": "9e5b1ab921ed7d9489349d58730ea41e1d6e15f9", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -791,17 +791,16 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t    }\n \t  else\n \t    {\n-\t      loop_iterator li;\n \t      struct loop *loop;\n \t      scev_initialize ();\n-\t      FOR_EACH_LOOP (li, loop, 0)\n+\t      FOR_EACH_LOOP (loop, 0)\n \t\tif (!finite_loop_p (loop))\n \t\t  {\n \t\t    if (dump_file)\n \t\t      fprintf (dump_file, \"    can not prove finiteness of \"\n \t\t\t       \"loop %i\\n\", loop->num);\n \t\t    l->looping =true;\n-\t\t    FOR_EACH_LOOP_BREAK (li);\n+\t\t    break;\n \t\t  }\n \t      scev_finalize ();\n \t    }"}, {"sha": "664b1ace4273baf86e731b954ef2f64289d5dcc5", "filename": "gcc/loop-init.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -135,7 +135,6 @@ loop_optimizer_init (unsigned flags)\n void\n loop_optimizer_finalize (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   basic_block bb;\n \n@@ -162,10 +161,8 @@ loop_optimizer_finalize (void)\n \n   gcc_assert (current_loops != NULL);\n \n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      free_simple_loop_desc (loop);\n-    }\n+  FOR_EACH_LOOP (loop, 0)\n+    free_simple_loop_desc (loop);\n \n   /* Clean up.  */\n   flow_loops_free (current_loops);\n@@ -199,7 +196,6 @@ fix_loop_structure (bitmap changed_bbs)\n {\n   basic_block bb;\n   int record_exits = 0;\n-  loop_iterator li;\n   struct loop *loop;\n   unsigned old_nloops, i;\n \n@@ -224,7 +220,7 @@ fix_loop_structure (bitmap changed_bbs)\n      loops, so that when we remove the loops, we know that the loops inside\n      are preserved, and do not waste time relinking loops that will be\n      removed later.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       /* Detect the case that the loop is no longer present even though\n          it wasn't marked for removal."}, {"sha": "efe2e7a9f16dd686eaad19aacf628a3fc5ee4bf9", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1815,9 +1815,8 @@ calculate_loop_reg_pressure (void)\n   basic_block bb;\n   rtx insn, link;\n   struct loop *loop, *parent;\n-  loop_iterator li;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     if (loop->aux == NULL)\n       {\n \tloop->aux = xcalloc (1, sizeof (struct loop_data));\n@@ -1884,7 +1883,7 @@ calculate_loop_reg_pressure (void)\n   bitmap_clear (&curr_regs_live);\n   if (flag_ira_region == IRA_REGION_MIXED\n       || flag_ira_region == IRA_REGION_ALL)\n-    FOR_EACH_LOOP (li, loop, 0)\n+    FOR_EACH_LOOP (loop, 0)\n       {\n \tEXECUTE_IF_SET_IN_BITMAP (&LOOP_DATA (loop)->regs_live, 0, j, bi)\n \t  if (! bitmap_bit_p (&LOOP_DATA (loop)->regs_ref, j))\n@@ -1898,7 +1897,7 @@ calculate_loop_reg_pressure (void)\n       }\n   if (dump_file == NULL)\n     return;\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       parent = loop_outer (loop);\n       fprintf (dump_file, \"\\n  Loop %d (parent %d, header bb%d, depth %d)\\n\",\n@@ -1933,7 +1932,6 @@ void\n move_loop_invariants (void)\n {\n   struct loop *loop;\n-  loop_iterator li;\n \n   if (flag_ira_loop_pressure)\n     {\n@@ -1945,7 +1943,7 @@ move_loop_invariants (void)\n     }\n   df_set_flags (DF_EQ_NOTES + DF_DEFER_INSN_RESCAN);\n   /* Process the loops, innermost first.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       curr_loop = loop;\n       /* move_single_loop_invariants for very large loops\n@@ -1954,7 +1952,7 @@ move_loop_invariants (void)\n \tmove_single_loop_invariants (loop);\n     }\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       free_loop_data (loop);\n     }"}, {"sha": "1240f7ce024f29c7630e724ca940c4b2a5fa63ef", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -269,7 +269,6 @@ unroll_and_peel_loops (int flags)\n {\n   struct loop *loop;\n   bool changed = false;\n-  loop_iterator li;\n \n   /* First perform complete loop peeling (it is almost surely a win,\n      and affects parameters for further decision a lot).  */\n@@ -279,7 +278,7 @@ unroll_and_peel_loops (int flags)\n   decide_unrolling_and_peeling (flags);\n \n   /* Scan the loops, inner ones first.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       /* And perform the appropriate transformations.  */\n       switch (loop->lpt_decision.decision)\n@@ -345,11 +344,10 @@ static void\n peel_loops_completely (int flags)\n {\n   struct loop *loop;\n-  loop_iterator li;\n   bool changed = false;\n \n   /* Scan the loops, the inner ones first.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       loop->lpt_decision.decision = LPT_NONE;\n       location_t locus = get_loop_location (loop);\n@@ -386,10 +384,9 @@ static void\n decide_unrolling_and_peeling (int flags)\n {\n   struct loop *loop;\n-  loop_iterator li;\n \n   /* Scan the loops, inner ones first.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       loop->lpt_decision.decision = LPT_NONE;\n       location_t locus = get_loop_location (loop);"}, {"sha": "671ec19b6d0662cef59c338ffd4b5559331ee501", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -138,13 +138,12 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n void\n unswitch_loops (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n \n   /* Go through inner loops (only original ones).  */\n \n-  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     changed |= unswitch_single_loop (loop, NULL_RTX, 0);\n \n   iv_analysis_done ();"}, {"sha": "1f2a014127b823805a889bdeda6b7f02ade769f6", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1351,7 +1351,6 @@ sms_schedule (void)\n   ddg_ptr *g_arr, g;\n   int * node_order;\n   int maxii, max_asap;\n-  loop_iterator li;\n   partial_schedule_ptr ps;\n   basic_block bb = NULL;\n   struct loop *loop;\n@@ -1395,7 +1394,7 @@ sms_schedule (void)\n \n   /* Build DDGs for all the relevant loops and hold them in G_ARR\n      indexed by the loop index.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       rtx head, tail;\n       rtx count_reg;\n@@ -1406,7 +1405,7 @@ sms_schedule (void)\n           if (dump_file)\n             fprintf (dump_file, \"SMS reached max limit... \\n\");\n \n-\t  FOR_EACH_LOOP_BREAK (li);\n+\t  break;\n         }\n \n       if (dump_file)\n@@ -1533,7 +1532,7 @@ sms_schedule (void)\n   }\n \n   /* We don't want to perform SMS on new loops - created by versioning.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       rtx head, tail;\n       rtx count_reg, count_init;"}, {"sha": "e22c96ce8c0f54271cea03e75106284261a43dca", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1514,12 +1514,11 @@ predict_extra_loop_exits (edge exit_edge)\n static void\n predict_loops (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       basic_block bb, *bbs;\n       unsigned j, n_exits;"}, {"sha": "579cf8d405609c94cdf3894d9f4cd53a63cc99cc", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -6201,11 +6201,10 @@ make_regions_from_the_rest (void)\n /* Free data structures used in pipelining of loops.  */\n void sel_finish_pipelining (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n   /* Release aux fields so we don't free them later by mistake.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     loop->aux = NULL;\n \n   loop_optimizer_finalize ();\n@@ -6227,11 +6226,10 @@ sel_find_rgns (void)\n   if (current_loops)\n     {\n       loop_p loop;\n-      loop_iterator li;\n \n-      FOR_EACH_LOOP (li, loop, (flag_sel_sched_pipelining_outer_loops\n-\t\t\t\t? LI_FROM_INNERMOST\n-\t\t\t\t: LI_ONLY_INNERMOST))\n+      FOR_EACH_LOOP (loop, (flag_sel_sched_pipelining_outer_loops\n+\t\t\t    ? LI_FROM_INNERMOST\n+\t\t\t    : LI_ONLY_INNERMOST))\n \tmake_regions_from_loop_nest (loop);\n     }\n "}, {"sha": "c30b113bc241666589ad3334376c73ec7117520d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -267,12 +267,11 @@ static void\n replace_loop_annotate ()\n {\n   struct loop *loop;\n-  loop_iterator li;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       gsi = gsi_last_bb (loop->header);\n       stmt = gsi_stmt (gsi);\n@@ -1640,9 +1639,8 @@ replace_uses_by (tree name, tree val)\n   if (current_loops)\n     {\n       struct loop *loop;\n-      loop_iterator li;\n \n-      FOR_EACH_LOOP (li, loop, 0)\n+      FOR_EACH_LOOP (loop, 0)\n \t{\n \t  substitute_in_loop_info (loop, name, val);\n \t}"}, {"sha": "217295834314041cbee3a1f291aa46f00cebed3f", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -4745,10 +4745,9 @@ analyze_all_data_dependences (struct loop *loop)\n void\n tree_check_data_deps (void)\n {\n-  loop_iterator li;\n   struct loop *loop_nest;\n \n-  FOR_EACH_LOOP (li, loop_nest, 0)\n+  FOR_EACH_LOOP (loop_nest, 0)\n     analyze_all_data_dependences (loop_nest);\n }\n "}, {"sha": "dd3925ad859cf7c6698695fd6dd38855489acfad", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1788,15 +1788,14 @@ tree_if_conversion (struct loop *loop)\n static unsigned int\n main_tree_if_conversion (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n   unsigned todo = 0;\n \n   if (number_of_loops (cfun) <= 1)\n     return 0;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     if (flag_tree_loop_if_convert == 1\n \t|| flag_tree_loop_if_convert_stores == 1\n \t|| flag_tree_loop_vectorize"}, {"sha": "0afa52aff1e749930f6269989a2e1810d93e38ee", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1661,7 +1661,6 @@ static unsigned int\n tree_loop_distribution (void)\n {\n   struct loop *loop;\n-  loop_iterator li;\n   bool changed = false;\n   basic_block bb;\n   control_dependences *cd = NULL;\n@@ -1677,7 +1676,7 @@ tree_loop_distribution (void)\n \n   /* We can at the moment only distribute non-nested loops, thus restrict\n      walking to innermost loops.  */\n-  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n       vec<gimple> work_list = vNULL;\n       basic_block *bbs;"}, {"sha": "d627c69f954bc2a29fbfd640fbd128bf946b6427", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1747,7 +1747,6 @@ static void\n gen_parallel_loop (struct loop *loop, reduction_info_table_type reduction_list,\n \t\t   unsigned n_threads, struct tree_niter_desc *niter)\n {\n-  loop_iterator li;\n   tree many_iterations_cond, type, nit;\n   tree arg_struct, new_arg_struct;\n   gimple_seq stmts;\n@@ -1902,7 +1901,7 @@ gen_parallel_loop (struct loop *loop, reduction_info_table_type reduction_list,\n \n   /* Free loop bound estimations that could contain references to\n      removed statements.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     free_numbers_of_iterations_estimates_loop (loop);\n \n   /* Expand the parallel constructs.  We do it directly here instead of running\n@@ -2143,7 +2142,6 @@ parallelize_loops (void)\n   bool changed = false;\n   struct loop *loop;\n   struct tree_niter_desc niter_desc;\n-  loop_iterator li;\n   reduction_info_table_type reduction_list;\n   struct obstack parloop_obstack;\n   HOST_WIDE_INT estimated;\n@@ -2159,7 +2157,7 @@ parallelize_loops (void)\n   reduction_list.create (10);\n   init_stmt_vec_info_vec ();\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       reduction_list.empty ();\n       if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "6d141842f1cec642bba843dbcc582984c7adaa37", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -2511,11 +2511,10 @@ tree_predictive_commoning (void)\n {\n   bool unrolled = false;\n   struct loop *loop;\n-  loop_iterator li;\n   unsigned ret = 0;\n \n   initialize_original_copy_tables ();\n-  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     if (optimize_loop_for_speed_p (loop))\n       {\n \tunrolled |= tree_predictive_commoning_loop (loop);"}, {"sha": "0c1f1dfbb1aedbb92f5f20218a8d7ce10d91b6d3", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -3103,16 +3103,14 @@ initialize_scalar_evolutions_analyzer (void)\n void\n scev_initialize (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n-\n   scalar_evolution_info = htab_create_ggc (100, hash_scev_info, eq_scev_info,\n \t\t\t\t\t   del_scev_info);\n \n   initialize_scalar_evolutions_analyzer ();\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       loop->nb_iterations = NULL_TREE;\n     }\n@@ -3144,15 +3142,14 @@ scev_reset_htab (void)\n void\n scev_reset (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n   scev_reset_htab ();\n \n   if (!current_loops)\n     return;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       loop->nb_iterations = NULL_TREE;\n     }\n@@ -3298,7 +3295,6 @@ scev_const_prop (void)\n   struct loop *loop, *ex_loop;\n   bitmap ssa_names_to_remove = NULL;\n   unsigned i;\n-  loop_iterator li;\n   gimple_stmt_iterator psi;\n \n   if (number_of_loops (cfun) <= 1)\n@@ -3360,7 +3356,7 @@ scev_const_prop (void)\n     }\n \n   /* Now the regular final value replacement.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       edge exit;\n       tree def, rslt, niter;"}, {"sha": "e07bd42932ff7a24857980e32dcfbe4736576e83", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -396,7 +396,6 @@ find_obviously_necessary_stmts (bool aggressive)\n   /* Prevent the empty possibly infinite loops from being removed.  */\n   if (aggressive)\n     {\n-      loop_iterator li;\n       struct loop *loop;\n       scev_initialize ();\n       if (mark_irreducible_loops ())\n@@ -414,7 +413,7 @@ find_obviously_necessary_stmts (bool aggressive)\n \t\t}\n \t  }\n \n-      FOR_EACH_LOOP (li, loop, 0)\n+      FOR_EACH_LOOP (loop, 0)\n \tif (!finite_loop_p (loop))\n \t  {\n \t    if (dump_file)"}, {"sha": "df45c286790e35692ece6fb3874fe35e887601b2", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -130,7 +130,6 @@ do_while_loop_p (struct loop *loop)\n static unsigned int\n copy_loop_headers (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   basic_block header;\n   edge exit, entry;\n@@ -150,7 +149,7 @@ copy_loop_headers (void)\n   copied_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   bbs_size = n_basic_blocks_for_fn (cfun);\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       /* Copy at most 20 insns.  */\n       int limit = 20;"}, {"sha": "6ea634c17819a4b88e5a53905e013b79faca1803", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1584,14 +1584,13 @@ analyze_memory_references (void)\n   gimple_stmt_iterator bsi;\n   basic_block bb, *bbs;\n   struct loop *loop, *outer;\n-  loop_iterator li;\n   unsigned i, n;\n \n   /* Initialize bb_loop_postorder with a mapping from loop->num to\n      its postorder index.  */\n   i = 0;\n   bb_loop_postorder = XNEWVEC (unsigned, number_of_loops (cfun));\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     bb_loop_postorder[loop->num] = i++;\n   /* Collect all basic-blocks in loops and sort them after their\n      loops postorder.  */\n@@ -1617,7 +1616,7 @@ analyze_memory_references (void)\n \n   /* Propagate the information about accessed memory references up\n      the loop hierarchy.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       /* Finalize the overall touched references (including subloops).  */\n       bitmap_ior_into (&memory_accesses.all_refs_stored_in_loop[loop->num],"}, {"sha": "0fdc5ab585f015549ada07739fedff36de34b523", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -983,7 +983,6 @@ canonicalize_loop_induction_variables (struct loop *loop,\n unsigned int\n canonicalize_induction_variables (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n   bool irred_invalidated = false;\n@@ -992,7 +991,7 @@ canonicalize_induction_variables (void)\n   free_numbers_of_iterations_estimates ();\n   estimate_numbers_of_iterations ();\n \n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       changed |= canonicalize_loop_induction_variables (loop,\n \t\t\t\t\t\t\ttrue, UL_SINGLE_ITER,"}, {"sha": "c20ffe692a965c32c099cf2868c66c4097e13ed1", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -6875,12 +6875,11 @@ tree_ssa_iv_optimize (void)\n {\n   struct loop *loop;\n   struct ivopts_data data;\n-  loop_iterator li;\n \n   tree_ssa_iv_optimize_init (&data);\n \n   /* Optimize the loops starting with the innermost ones.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tflow_loop_dump (loop, dump_file, NULL, 1);"}, {"sha": "246b66702dc9efccc11f4d571d833512efeda390", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -350,12 +350,11 @@ add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap *loop_exits)\n static void\n get_loops_exits (bitmap *loop_exits)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   unsigned j;\n   edge e;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       vec<edge> exit_edges = get_loop_exit_edges (loop);\n       loop_exits[loop->num] = BITMAP_ALLOC (&loop_renamer_obstack);"}, {"sha": "1e0dcd61e3137244af60526464dd928fcffada37", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -3586,14 +3586,13 @@ estimated_stmt_executions (struct loop *loop, double_int *nit)\n void\n estimate_numbers_of_iterations (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n   /* We don't want to issue signed overflow warnings while getting\n      loop iteration estimates.  */\n   fold_defer_overflow_warnings ();\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       estimate_numbers_of_iterations_loop (loop);\n     }\n@@ -3863,10 +3862,9 @@ free_numbers_of_iterations_estimates_loop (struct loop *loop)\n void\n free_numbers_of_iterations_estimates (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       free_numbers_of_iterations_estimates_loop (loop);\n     }"}, {"sha": "4e49d762442897eeecc213787f7ad8628b688068", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1930,7 +1930,6 @@ loop_prefetch_arrays (struct loop *loop)\n unsigned int\n tree_ssa_prefetch_arrays (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   bool unrolled = false;\n   int todo_flags = 0;\n@@ -1978,7 +1977,7 @@ tree_ssa_prefetch_arrays (void)\n      here.  */\n   gcc_assert ((PREFETCH_BLOCK & (PREFETCH_BLOCK - 1)) == 0);\n \n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Processing loop %d:\\n\", loop->num);"}, {"sha": "9f4d4926a559cd44ab0e25d9c16fbef95f537e79", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -83,13 +83,12 @@ static tree tree_may_unswitch_on (basic_block, struct loop *);\n unsigned int\n tree_ssa_unswitch_loops (void)\n {\n-  loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n   HOST_WIDE_INT iterations;\n \n   /* Go through inner loops (only original ones).  */\n-  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n         fprintf (dump_file, \";; Considering loop %d\\n\", loop->num);"}, {"sha": "afd7ac439727b1a154d54a06216fa4bfb4dda23f", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -1554,7 +1554,6 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   bitmap_iterator bi;\n   bitmap threaded_blocks;\n   struct loop *loop;\n-  loop_iterator li;\n \n   /* We must know about loops in order to preserve them.  */\n   gcc_assert (current_loops != NULL);\n@@ -1582,7 +1581,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   /* Then perform the threading through loop headers.  We start with the\n      innermost loop, so that the changes in cfg we perform won't affect\n      further threading.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       if (!loop->header\n \t  || !bitmap_bit_p (threaded_blocks, loop->header->index))"}, {"sha": "fea7086b6232884f014df134dca52eebb002eb99", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -324,7 +324,6 @@ vectorize_loops (void)\n   unsigned int i;\n   unsigned int num_vectorized_loops = 0;\n   unsigned int vect_loops_num;\n-  loop_iterator li;\n   struct loop *loop;\n   hash_table <simduid_to_vf> simduid_to_vf_htab;\n   hash_table <simd_array_to_simduid> simd_array_to_simduid_htab;\n@@ -349,7 +348,7 @@ vectorize_loops (void)\n   /* If some loop was duplicated, it gets bigger number\n      than all previously defined loops.  This fact allows us to run\n      only over initial loops skipping newly generated ones.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     if ((flag_tree_loop_vectorize && optimize_loop_nest_for_speed_p (loop))\n \t|| loop->force_vect)\n       {"}, {"sha": "4a24c668d57f25ce3767038b70c001040d255b76", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bd40b1a70966c2b6ff37cec3e34381c254c25c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f0bd40b1a70966c2b6ff37cec3e34381c254c25c", "patch": "@@ -5895,8 +5895,7 @@ find_assert_locations (void)\n      the order we compute liveness and insert asserts we otherwise\n      fail to insert asserts into the loop latch.  */\n   loop_p loop;\n-  loop_iterator li;\n-  FOR_EACH_LOOP (li, loop, 0)\n+  FOR_EACH_LOOP (loop, 0)\n     {\n       i = loop->latch->index;\n       unsigned int j = single_succ_edge (loop->latch)->dest_idx;"}]}