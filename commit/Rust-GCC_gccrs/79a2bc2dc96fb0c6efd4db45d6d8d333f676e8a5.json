{"sha": "79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhMmJjMmRjOTZmYjBjNmVmZDRkYjQ1ZDZkOGQzMzNmNjc2ZThhNQ==", "commit": {"author": {"name": "Evandro Menezes", "email": "evandro@gcc.gnu.org", "date": "2016-06-13T19:03:00Z"}, "committer": {"name": "Evandro Menezes", "email": "evandro@gcc.gnu.org", "date": "2016-06-13T19:03:00Z"}, "message": "[AArch64] Emit division using the Newton series\n\n2016-06-13  Evandro Menezes  <e.menezes@samsung.com>\n            Wilco Dijkstra  <Wilco.Dijkstra@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h\n\t(cpu_approx_modes): Add new member \"division\".\n\t(aarch64_emit_approx_div): Declare new function.\n\t* config/aarch64/aarch64.c\n\t(generic_approx_modes): New member \"division\".\n\t(exynosm1_approx_modes): Likewise.\n\t(xgene1_approx_modes): Likewise.\n\t(aarch64_emit_approx_div): Define new function.\n\t* config/aarch64/aarch64.md (\"div<mode>3\"): New expansion.\n\t* config/aarch64/aarch64-simd.md (\"div<mode>3\"): Likewise.\n\t* config/aarch64/aarch64.opt (-mlow-precision-div): Add new option.\n\t* doc/invoke.texi (-mlow-precision-div): Describe new option.\n\nFrom-SVN: r237397", "tree": {"sha": "eefb60605a5db6b76c231c4b58262f5996ed651f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eefb60605a5db6b76c231c4b58262f5996ed651f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/comments", "author": null, "committer": null, "parents": [{"sha": "98daafa0b3decfb3efa2f2427f7b6e13de660541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98daafa0b3decfb3efa2f2427f7b6e13de660541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98daafa0b3decfb3efa2f2427f7b6e13de660541"}], "stats": {"total": 144, "additions": 139, "deletions": 5}, "files": [{"sha": "3e0a0a37ec019a0db97961321ef3ade8e2a04ce2", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "patch": "@@ -192,6 +192,7 @@ struct cpu_branch_cost\n /* Allowed modes for approximations.  */\n struct cpu_approx_modes\n {\n+  const unsigned int division;\t\t/* Division.  */\n   const unsigned int sqrt;\t\t/* Square root.  */\n   const unsigned int recip_sqrt;\t/* Reciprocal square root.  */\n };\n@@ -303,6 +304,7 @@ int aarch64_branch_cost (bool, bool);\n enum aarch64_symbol_type aarch64_classify_symbolic_expression (rtx);\n bool aarch64_const_vec_all_same_int_p (rtx, HOST_WIDE_INT);\n bool aarch64_constant_address_p (rtx);\n+bool aarch64_emit_approx_div (rtx, rtx, rtx);\n bool aarch64_emit_approx_sqrt (rtx, rtx, bool);\n bool aarch64_expand_movmem (rtx *);\n bool aarch64_float_const_zero_rtx_p (rtx);"}, {"sha": "fd4b62e888691a51ae6db5d4797083f57c0fbad7", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "patch": "@@ -1500,7 +1500,19 @@\n   [(set_attr \"type\" \"neon_fp_mul_<Vetype><q>\")]\n )\n \n-(define_insn \"div<mode>3\"\n+(define_expand \"div<mode>3\"\n+ [(set (match_operand:VDQF 0 \"register_operand\")\n+       (div:VDQF (match_operand:VDQF 1 \"general_operand\")\n+\t\t (match_operand:VDQF 2 \"register_operand\")))]\n+ \"TARGET_SIMD\"\n+{\n+  if (aarch64_emit_approx_div (operands[0], operands[1], operands[2]))\n+    DONE;\n+\n+  operands[1] = force_reg (<MODE>mode, operands[1]);\n+})\n+\n+(define_insn \"*div<mode>3\"\n  [(set (match_operand:VDQF 0 \"register_operand\" \"=w\")\n        (div:VDQF (match_operand:VDQF 1 \"register_operand\" \"w\")\n \t\t (match_operand:VDQF 2 \"register_operand\" \"w\")))]"}, {"sha": "df7cb92d110dc5ad7e4e78c4f0edc54d7314b97d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "patch": "@@ -396,20 +396,23 @@ static const struct cpu_branch_cost cortexa57_branch_cost =\n /* Generic approximation modes.  */\n static const cpu_approx_modes generic_approx_modes =\n {\n+  AARCH64_APPROX_NONE,\t/* division  */\n   AARCH64_APPROX_NONE,\t/* sqrt  */\n   AARCH64_APPROX_NONE\t/* recip_sqrt  */\n };\n \n /* Approximation modes for Exynos M1.  */\n static const cpu_approx_modes exynosm1_approx_modes =\n {\n+  AARCH64_APPROX_NONE,\t/* division  */\n   AARCH64_APPROX_ALL,\t/* sqrt  */\n   AARCH64_APPROX_ALL\t/* recip_sqrt  */\n };\n \n /* Approximation modes for X-Gene 1.  */\n static const cpu_approx_modes xgene1_approx_modes =\n {\n+  AARCH64_APPROX_NONE,\t/* division  */\n   AARCH64_APPROX_NONE,\t/* sqrt  */\n   AARCH64_APPROX_ALL\t/* recip_sqrt  */\n };\n@@ -7488,6 +7491,95 @@ aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n   return true;\n }\n \n+typedef rtx (*recpe_type) (rtx, rtx);\n+\n+/* Select reciprocal initial estimate insn depending on machine mode.  */\n+\n+static recpe_type\n+get_recpe_type (machine_mode mode)\n+{\n+  switch (mode)\n+  {\n+    case SFmode:   return (gen_aarch64_frecpesf);\n+    case V2SFmode: return (gen_aarch64_frecpev2sf);\n+    case V4SFmode: return (gen_aarch64_frecpev4sf);\n+    case DFmode:   return (gen_aarch64_frecpedf);\n+    case V2DFmode: return (gen_aarch64_frecpev2df);\n+    default:       gcc_unreachable ();\n+  }\n+}\n+\n+typedef rtx (*recps_type) (rtx, rtx, rtx);\n+\n+/* Select reciprocal series step insn depending on machine mode.  */\n+\n+static recps_type\n+get_recps_type (machine_mode mode)\n+{\n+  switch (mode)\n+  {\n+    case SFmode:   return (gen_aarch64_frecpssf);\n+    case V2SFmode: return (gen_aarch64_frecpsv2sf);\n+    case V4SFmode: return (gen_aarch64_frecpsv4sf);\n+    case DFmode:   return (gen_aarch64_frecpsdf);\n+    case V2DFmode: return (gen_aarch64_frecpsv2df);\n+    default:       gcc_unreachable ();\n+  }\n+}\n+\n+/* Emit the instruction sequence to compute the approximation for the division\n+   of NUM by DEN in QUO and return whether the sequence was emitted or not.  */\n+\n+bool\n+aarch64_emit_approx_div (rtx quo, rtx num, rtx den)\n+{\n+  machine_mode mode = GET_MODE (quo);\n+  bool use_approx_division_p = (flag_mlow_precision_div\n+\t\t\t        || (aarch64_tune_params.approx_modes->division\n+\t\t\t\t    & AARCH64_APPROX_MODE (mode)));\n+\n+  if (!flag_finite_math_only\n+      || flag_trapping_math\n+      || !flag_unsafe_math_optimizations\n+      || optimize_function_for_size_p (cfun)\n+      || !use_approx_division_p)\n+    return false;\n+\n+  /* Estimate the approximate reciprocal.  */\n+  rtx xrcp = gen_reg_rtx (mode);\n+  emit_insn ((*get_recpe_type (mode)) (xrcp, den));\n+\n+  /* Iterate over the series twice for SF and thrice for DF.  */\n+  int iterations = (GET_MODE_INNER (mode) == DFmode) ? 3 : 2;\n+\n+  /* Optionally iterate over the series once less for faster performance,\n+     while sacrificing the accuracy.  */\n+  if (flag_mlow_precision_div)\n+    iterations--;\n+\n+  /* Iterate over the series to calculate the approximate reciprocal.  */\n+  rtx xtmp = gen_reg_rtx (mode);\n+  while (iterations--)\n+    {\n+      emit_insn ((*get_recps_type (mode)) (xtmp, xrcp, den));\n+\n+      if (iterations > 0)\n+\temit_set_insn (xrcp, gen_rtx_MULT (mode, xrcp, xtmp));\n+    }\n+\n+  if (num != CONST1_RTX (mode))\n+    {\n+      /* As the approximate reciprocal of DEN is already calculated, only\n+\t calculate the approximate division when NUM is not 1.0.  */\n+      rtx xnum = force_reg (mode, num);\n+      emit_set_insn (xrcp, gen_rtx_MULT (mode, xrcp, xnum));\n+    }\n+\n+  /* Finalize the approximation.  */\n+  emit_set_insn (quo, gen_rtx_MULT (mode, xrcp, xtmp));\n+  return true;\n+}\n+\n /* Return the number of instructions that can be issued per cycle.  */\n static int\n aarch64_sched_issue_rate (void)"}, {"sha": "704e8550065dc9191098293f2ac0ce72a7b3e2b5", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "patch": "@@ -4715,11 +4715,22 @@\n   [(set_attr \"type\" \"fmul<s>\")]\n )\n \n-(define_insn \"div<mode>3\"\n+(define_expand \"div<mode>3\"\n+ [(set (match_operand:GPF 0 \"register_operand\")\n+       (div:GPF (match_operand:GPF 1 \"general_operand\")\n+\t\t(match_operand:GPF 2 \"register_operand\")))]\n+ \"TARGET_SIMD\"\n+{\n+  if (aarch64_emit_approx_div (operands[0], operands[1], operands[2]))\n+    DONE;\n+\n+  operands[1] = force_reg (<MODE>mode, operands[1]);\n+})\n+\n+(define_insn \"*div<mode>3\"\n   [(set (match_operand:GPF 0 \"register_operand\" \"=w\")\n-        (div:GPF\n-         (match_operand:GPF 1 \"register_operand\" \"w\")\n-         (match_operand:GPF 2 \"register_operand\" \"w\")))]\n+        (div:GPF (match_operand:GPF 1 \"register_operand\" \"w\")\n+\t         (match_operand:GPF 2 \"register_operand\" \"w\")))]\n   \"TARGET_FLOAT\"\n   \"fdiv\\\\t%<s>0, %<s>1, %<s>2\"\n   [(set_attr \"type\" \"fdiv<s>\")]"}, {"sha": "bf6b47510e0535fd3a759bb284807e2fef9528cd", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "patch": "@@ -161,3 +161,9 @@ Enable the square root approximation.  Enabling this reduces\n precision of square root results to about 16 bits for\n single precision and to 32 bits for double precision.\n If enabled, it implies -mlow-precision-recip-sqrt.\n+\n+mlow-precision-div\n+Common Var(flag_mlow_precision_div) Optimization\n+Enable the division approximation.  Enabling this reduces\n+precision of division results to about 16 bits for\n+single precision and to 32 bits for double precision."}, {"sha": "223fd86ac95edb16231e45791207dcab22c4edfe", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "patch": "@@ -577,6 +577,7 @@ Objective-C and Objective-C++ Dialects}.\n -mfix-cortex-a53-843419  -mno-fix-cortex-a53-843419 @gol\n -mlow-precision-recip-sqrt -mno-low-precision-recip-sqrt@gol\n -mlow-precision-sqrt -mno-low-precision-sqrt@gol\n+-mlow-precision-div -mno-low-precision-div @gol\n -march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}}\n \n @emph{Adapteva Epiphany Options}\n@@ -13040,6 +13041,16 @@ precision of square root results to about 16 bits for\n single precision and to 32 bits for double precision.\n If enabled, it implies @option{-mlow-precision-recip-sqrt}.\n \n+@item -mlow-precision-div\n+@item -mno-low-precision-div\n+@opindex -mlow-precision-div\n+@opindex -mno-low-precision-div\n+Enable or disable the division approximation.\n+This option only has an effect if @option{-ffast-math} or\n+@option{-funsafe-math-optimizations} is used as well.  Enabling this reduces\n+precision of division results to about 16 bits for\n+single precision and to 32 bits for double precision.\n+\n @item -march=@var{name}\n @opindex march\n Specify the name of the target architecture and, optionally, one or"}]}