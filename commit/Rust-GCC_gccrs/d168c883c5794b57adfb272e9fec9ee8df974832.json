{"sha": "d168c883c5794b57adfb272e9fec9ee8df974832", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE2OGM4ODNjNTc5NGI1N2FkZmIyNzJlOWZlYzllZThkZjk3NDgzMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-24T16:05:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-24T16:05:09Z"}, "message": "trans-intrinsic.c (gfc_conv_intrinsic_minmax): Use VAR_P (x) instead of TREE_CODE (x) == VAR_DECL.\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmax): Use VAR_P (x)\n\tinstead of TREE_CODE (x) == VAR_DECL.\n\t* trans-expr.c (gfc_class_vptr_get, gfc_class_len_get,\n\tgfc_class_len_or_zero_get, gfc_get_vptr_from_expr,\n\tgfc_conv_string_length, conv_base_obj_fcn_val,\n\tgfc_conv_procedure_call, gfc_trans_assignment_1): Likewise.\n\t* trans-openmp.c (gfc_omp_predetermined_sharing,\n\tgfc_omp_disregard_value_expr, gfc_omp_private_debug_clause,\n\tgfc_trans_omp_atomic, gfc_trans_omp_do): Likewise.\n\t* trans-io.c (nml_get_addr_expr): Likewise.\n\t* trans-decl.c (gfc_finish_decl, gfc_build_qualified_array,\n\tgfc_get_symbol_decl, gfc_get_fake_result_decl,\n\tgfc_trans_deferred_vars, gfc_trans_use_stmts,\n\tgenerate_local_decl): Likewise.\n\t* trans-array.c (trans_array_constructor, trans_array_bound_check,\n\tbuild_class_array_ref, gfc_array_init_size,\n\tgfc_trans_auto_array_allocation, gfc_trans_g77_array,\n\tgfc_trans_dummy_array_bias, gfc_alloc_allocatable_for_assignment,\n\tgfc_trans_deferred_array): Likewise.\n\t* trans.c (gfc_build_array_ref): Likewise.  Use\n\tVAR_OR_FUNCTION_DECL_P (x) instead of TREE_CODE (x) == VAR_DECL\n\t|| TREE_CODE (x) == FUNCTION_DECL.\n\nFrom-SVN: r241482", "tree": {"sha": "68e4a8ee8e9689454c1003d8db8354c74f86e610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68e4a8ee8e9689454c1003d8db8354c74f86e610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d168c883c5794b57adfb272e9fec9ee8df974832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d168c883c5794b57adfb272e9fec9ee8df974832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d168c883c5794b57adfb272e9fec9ee8df974832", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d168c883c5794b57adfb272e9fec9ee8df974832/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4467029544b6d28433b81e91309d3b67c7cc4a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4467029544b6d28433b81e91309d3b67c7cc4a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4467029544b6d28433b81e91309d3b67c7cc4a7b"}], "stats": {"total": 150, "additions": 84, "deletions": 66}, "files": [{"sha": "5c47028555b8e8abe1b63ec08c56eaeccf8b0d07", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -1,3 +1,28 @@\n+2016-10-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmax): Use VAR_P (x)\n+\tinstead of TREE_CODE (x) == VAR_DECL.\n+\t* trans-expr.c (gfc_class_vptr_get, gfc_class_len_get,\n+\tgfc_class_len_or_zero_get, gfc_get_vptr_from_expr,\n+\tgfc_conv_string_length, conv_base_obj_fcn_val,\n+\tgfc_conv_procedure_call, gfc_trans_assignment_1): Likewise.\n+\t* trans-openmp.c (gfc_omp_predetermined_sharing,\n+\tgfc_omp_disregard_value_expr, gfc_omp_private_debug_clause,\n+\tgfc_trans_omp_atomic, gfc_trans_omp_do): Likewise.\n+\t* trans-io.c (nml_get_addr_expr): Likewise.\n+\t* trans-decl.c (gfc_finish_decl, gfc_build_qualified_array,\n+\tgfc_get_symbol_decl, gfc_get_fake_result_decl,\n+\tgfc_trans_deferred_vars, gfc_trans_use_stmts,\n+\tgenerate_local_decl): Likewise.\n+\t* trans-array.c (trans_array_constructor, trans_array_bound_check,\n+\tbuild_class_array_ref, gfc_array_init_size,\n+\tgfc_trans_auto_array_allocation, gfc_trans_g77_array,\n+\tgfc_trans_dummy_array_bias, gfc_alloc_allocatable_for_assignment,\n+\tgfc_trans_deferred_array): Likewise.\n+\t* trans.c (gfc_build_array_ref): Likewise.  Use\n+\tVAR_OR_FUNCTION_DECL_P (x) instead of TREE_CODE (x) == VAR_DECL\n+\t|| TREE_CODE (x) == FUNCTION_DECL.\n+\n 2016-10-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/77763"}, {"sha": "117349e0c639dc79680415cb6a95492c3e6dbbb6", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -2373,7 +2373,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t\t\t     offsetvar, gfc_index_one_node);\n       tmp = gfc_evaluate_now (tmp, &outer_loop->pre);\n       gfc_conv_descriptor_ubound_set (&loop->pre, desc, gfc_rank_cst[0], tmp);\n-      if (*loop_ubound0 && TREE_CODE (*loop_ubound0) == VAR_DECL)\n+      if (*loop_ubound0 && VAR_P (*loop_ubound0))\n \tgfc_add_modify (&outer_loop->pre, *loop_ubound0, tmp);\n       else\n \t*loop_ubound0 = tmp;\n@@ -2860,7 +2860,7 @@ trans_array_bound_check (gfc_se * se, gfc_ss *ss, tree index, int n,\n   name = ss->info->expr->symtree->n.sym->name;\n   gcc_assert (name != NULL);\n \n-  if (TREE_CODE (descriptor) == VAR_DECL)\n+  if (VAR_P (descriptor))\n     name = IDENTIFIER_POINTER (DECL_NAME (descriptor));\n \n   /* If upper bound is present, include both bounds in the error message.  */\n@@ -3104,7 +3104,7 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n \t      else\n \t\ttype = NULL_TREE;\n \t    }\n-\t  if (TREE_CODE (tmp) == VAR_DECL)\n+\t  if (VAR_P (tmp))\n \t    break;\n \t}\n \n@@ -5096,8 +5096,9 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n   /* Set the dtype before the alloc, because registration of coarrays needs\n      it initialized.  */\n-  if (expr->ts.type == BT_CHARACTER && expr->ts.deferred\n-      && TREE_CODE (expr->ts.u.cl->backend_decl) == VAR_DECL)\n+  if (expr->ts.type == BT_CHARACTER\n+      && expr->ts.deferred\n+      && VAR_P (expr->ts.u.cl->backend_decl))\n     {\n       type = gfc_typenode_for_spec (&expr->ts);\n       tmp = gfc_conv_descriptor_dtype (descriptor);\n@@ -5968,7 +5969,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym,\n   /* Don't actually allocate space for Cray Pointees.  */\n   if (sym->attr.cray_pointee)\n     {\n-      if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n+      if (VAR_P (GFC_TYPE_ARRAY_OFFSET (type)))\n \tgfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n       gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n@@ -6001,7 +6002,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym,\n     }\n \n   /* Set offset of the array.  */\n-  if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n+  if (VAR_P (GFC_TYPE_ARRAY_OFFSET (type)))\n     gfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n   /* Automatic arrays should not have initializers.  */\n@@ -6054,14 +6055,14 @@ gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)\n   gfc_start_block (&init);\n \n   if (sym->ts.type == BT_CHARACTER\n-      && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n+      && VAR_P (sym->ts.u.cl->backend_decl))\n     gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n   /* Evaluate the bounds of the array.  */\n   gfc_trans_array_bounds (type, sym, &offset, &init);\n \n   /* Set the offset.  */\n-  if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n+  if (VAR_P (GFC_TYPE_ARRAY_OFFSET (type)))\n     gfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n   /* Set the pointer itself if we aren't using the parameter directly.  */\n@@ -6160,7 +6161,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n   gfc_start_block (&init);\n \n   if (sym->ts.type == BT_CHARACTER\n-      && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n+      && VAR_P (sym->ts.u.cl->backend_decl))\n     gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n   checkparm = (as->type == AS_EXPLICIT\n@@ -6384,7 +6385,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n   gfc_trans_array_cobounds (type, &init, sym);\n \n   /* Set the offset.  */\n-  if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n+  if (VAR_P (GFC_TYPE_ARRAY_OFFSET (type)))\n     gfc_add_modify (&init, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n   gfc_trans_vla_type_sizes (sym, &init);\n@@ -8977,7 +8978,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   tmp = gfc_conv_descriptor_offset (desc);\n   gfc_add_modify (&fblock, tmp, offset);\n   if (linfo->saved_offset\n-      && TREE_CODE (linfo->saved_offset) == VAR_DECL)\n+      && VAR_P (linfo->saved_offset))\n     gfc_add_modify (&fblock, linfo->saved_offset, tmp);\n \n   /* Now set the deltas for the lhs.  */\n@@ -8988,8 +8989,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t     gfc_array_index_type, tmp,\n \t\t\t     loop->from[dim]);\n-      if (linfo->delta[dim]\n-\t  && TREE_CODE (linfo->delta[dim]) == VAR_DECL)\n+      if (linfo->delta[dim] && VAR_P (linfo->delta[dim]))\n \tgfc_add_modify (&fblock, linfo->delta[dim], tmp);\n     }\n \n@@ -8998,7 +8998,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n     {\n       if (expr2->ts.deferred)\n \t{\n-\t  if (TREE_CODE (expr2->ts.u.cl->backend_decl) == VAR_DECL)\n+\t  if (VAR_P (expr2->ts.u.cl->backend_decl))\n \t    tmp = expr2->ts.u.cl->backend_decl;\n \t  else\n \t    tmp = rss->info->string_length;\n@@ -9016,7 +9016,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t}\n \n       if (expr1->ts.u.cl->backend_decl\n-\t  && TREE_CODE (expr1->ts.u.cl->backend_decl) == VAR_DECL)\n+\t  && VAR_P (expr1->ts.u.cl->backend_decl))\n \tgfc_add_modify (&fblock, expr1->ts.u.cl->backend_decl, tmp);\n       else\n \tgfc_add_modify (&fblock, lss->info->string_length, tmp);\n@@ -9182,8 +9182,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   gfc_add_expr_to_block (&fblock, tmp);\n \n   /* Make sure that the scalarizer data pointer is updated.  */\n-  if (linfo->data\n-      && TREE_CODE (linfo->data) == VAR_DECL)\n+  if (linfo->data && VAR_P (linfo->data))\n     {\n       tmp = gfc_conv_descriptor_data_get (desc);\n       gfc_add_modify (&fblock, linfo->data, tmp);\n@@ -9227,8 +9226,8 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n   gfc_set_backend_locus (&sym->declared_at);\n   gfc_init_block (&init);\n \n-  gcc_assert (TREE_CODE (sym->backend_decl) == VAR_DECL\n-\t\t|| TREE_CODE (sym->backend_decl) == PARM_DECL);\n+  gcc_assert (VAR_P (sym->backend_decl)\n+\t      || TREE_CODE (sym->backend_decl) == PARM_DECL);\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.u.cl->backend_decl))"}, {"sha": "4f8ef17dda67b80473be15ae9fd6a26536db78ef", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -495,7 +495,7 @@ gfc_finish_decl (tree decl)\n   gcc_assert (TREE_CODE (decl) == PARM_DECL\n \t      || DECL_INITIAL (decl) == NULL_TREE);\n \n-  if (TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_P (decl))\n     return;\n \n   if (DECL_SIZE (decl) == NULL_TREE\n@@ -1020,7 +1020,7 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n \n   if (TYPE_NAME (type) != NULL_TREE\n       && GFC_TYPE_ARRAY_UBOUND (type, as->rank - 1) != NULL_TREE\n-      && TREE_CODE (GFC_TYPE_ARRAY_UBOUND (type, as->rank - 1)) == VAR_DECL)\n+      && VAR_P (GFC_TYPE_ARRAY_UBOUND (type, as->rank - 1)))\n     {\n       tree gtype = DECL_ORIGINAL_TYPE (TYPE_NAME (type));\n \n@@ -1050,17 +1050,21 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n \t     can be tracked by VTA.  Also set DECL_NAMELESS, so that\n \t     the artificial lbound.N or ubound.N DECL_NAME doesn't\n \t     end up in debug info.  */\n-\t  if (lbound && TREE_CODE (lbound) == VAR_DECL\n-\t      && DECL_ARTIFICIAL (lbound) && DECL_IGNORED_P (lbound))\n+\t  if (lbound\n+\t      && VAR_P (lbound)\n+\t      && DECL_ARTIFICIAL (lbound)\n+\t      && DECL_IGNORED_P (lbound))\n \t    {\n \t      if (DECL_NAME (lbound)\n \t\t  && strstr (IDENTIFIER_POINTER (DECL_NAME (lbound)),\n \t\t\t     \"lbound\") != 0)\n \t\tDECL_NAMELESS (lbound) = 1;\n \t      DECL_IGNORED_P (lbound) = 0;\n \t    }\n-\t  if (ubound && TREE_CODE (ubound) == VAR_DECL\n-\t      && DECL_ARTIFICIAL (ubound) && DECL_IGNORED_P (ubound))\n+\t  if (ubound\n+\t      && VAR_P (ubound)\n+\t      && DECL_ARTIFICIAL (ubound)\n+\t      && DECL_IGNORED_P (ubound))\n \t    {\n \t      if (DECL_NAME (ubound)\n \t\t  && strstr (IDENTIFIER_POINTER (DECL_NAME (ubound)),\n@@ -1514,8 +1518,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t    length = gfc_create_string_length (sym);\n \t  else\n \t    length = sym->ts.u.cl->backend_decl;\n-\t  if (TREE_CODE (length) == VAR_DECL\n-\t      && DECL_FILE_SCOPE_P (length))\n+\t  if (VAR_P (length) && DECL_FILE_SCOPE_P (length))\n \t    {\n \t      /* Add the string length to the same context as the symbol.  */\n \t      if (DECL_CONTEXT (sym->backend_decl) == current_function_decl)\n@@ -1630,7 +1633,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n     {\n       if (sym->attr.associate_var\n \t  && sym->ts.u.cl->backend_decl\n-\t  && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n+\t  && VAR_P (sym->ts.u.cl->backend_decl))\n \tlength = gfc_index_zero_node;\n       else\n \tlength = gfc_create_string_length (sym);\n@@ -2924,8 +2927,7 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n \tlength = gfc_create_string_length (sym);\n       else\n \tlength = sym->ts.u.cl->backend_decl;\n-      if (TREE_CODE (length) == VAR_DECL\n-\t  && DECL_CONTEXT (length) == NULL_TREE)\n+      if (VAR_P (length) && DECL_CONTEXT (length) == NULL_TREE)\n \tgfc_add_decl_to_function (length);\n     }\n \n@@ -4123,7 +4125,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n \t  /* An automatic character length, pointer array result.  */\n \t  if (proc_sym->ts.type == BT_CHARACTER\n-\t\t&& TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n+\t      && VAR_P (proc_sym->ts.u.cl->backend_decl))\n \t    {\n \t      tmp = NULL;\n \t      if (proc_sym->ts.deferred)\n@@ -4176,7 +4178,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n \t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n \t    }\n-\t  else if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n+\t  else if (VAR_P (proc_sym->ts.u.cl->backend_decl))\n \t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);\n \t}\n       else\n@@ -4843,8 +4845,7 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n \t\t  && strcmp (st->n.sym->module, use_stmt->module_name) == 0)\n \t\t{\n \t\t  gcc_assert (DECL_EXTERNAL (entry->namespace_decl)\n-\t\t\t      || (TREE_CODE (st->n.sym->backend_decl)\n-\t\t\t\t  != VAR_DECL));\n+\t\t\t      || !VAR_P (st->n.sym->backend_decl));\n \t\t  decl = copy_node (st->n.sym->backend_decl);\n \t\t  DECL_CONTEXT (decl) = entry->namespace_decl;\n \t\t  DECL_EXTERNAL (decl) = 1;\n@@ -5385,7 +5386,7 @@ generate_local_decl (gfc_symbol * sym)\n       if (sym->attr.dummy && !sym->attr.referenced\n \t    && sym->ts.type == BT_CHARACTER\n \t    && sym->ts.u.cl->backend_decl != NULL\n-\t    && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n+\t    && VAR_P (sym->ts.u.cl->backend_decl))\n \t{\n \t  sym->attr.referenced = 1;\n \t  gfc_get_symbol_decl (sym);"}, {"sha": "525bb67e73ae5438f4a6ebab7b3faa5987f187db", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -198,7 +198,7 @@ gfc_class_vptr_get (tree decl)\n   tree vptr;\n   /* For class arrays decl may be a temporary descriptor handle, the vptr is\n      then available through the saved descriptor.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_LANG_SPECIFIC (decl)\n+  if (VAR_P (decl) && DECL_LANG_SPECIFIC (decl)\n       && GFC_DECL_SAVED_DESCRIPTOR (decl))\n     decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n@@ -217,7 +217,7 @@ gfc_class_len_get (tree decl)\n   tree len;\n   /* For class arrays decl may be a temporary descriptor handle, the len is\n      then available through the saved descriptor.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_LANG_SPECIFIC (decl)\n+  if (VAR_P (decl) && DECL_LANG_SPECIFIC (decl)\n       && GFC_DECL_SAVED_DESCRIPTOR (decl))\n     decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n@@ -239,7 +239,7 @@ gfc_class_len_or_zero_get (tree decl)\n   tree len;\n   /* For class arrays decl may be a temporary descriptor handle, the vptr is\n      then available through the saved descriptor.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_LANG_SPECIFIC (decl)\n+  if (VAR_P (decl) && DECL_LANG_SPECIFIC (decl)\n       && GFC_DECL_SAVED_DESCRIPTOR (decl))\n     decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n@@ -485,8 +485,7 @@ gfc_get_vptr_from_expr (tree expr)\n \t  else\n \t    type = NULL_TREE;\n \t}\n-      if (TREE_CODE (tmp) == VAR_DECL\n-\t  || TREE_CODE (tmp) == PARM_DECL)\n+      if (VAR_P (tmp) || TREE_CODE (tmp) == PARM_DECL)\n \tbreak;\n     }\n \n@@ -2160,9 +2159,7 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n \n   gfc_init_se (&se, NULL);\n \n-  if (!cl->length\n-\t&& cl->backend_decl\n-\t&& TREE_CODE (cl->backend_decl) == VAR_DECL)\n+  if (!cl->length && cl->backend_decl && VAR_P (cl->backend_decl))\n     return;\n \n   /* If cl->length is NULL, use gfc_conv_expr to obtain the string length but\n@@ -3664,7 +3661,7 @@ conv_base_obj_fcn_val (gfc_se * se, tree base_object, gfc_expr * expr)\n   gfc_ref *ref;\n   tree var;\n \n-  if (TREE_CODE (base_object) != VAR_DECL)\n+  if (!VAR_P (base_object))\n     {\n       var = gfc_create_var (TREE_TYPE (base_object), NULL);\n       gfc_add_modify (&se->pre, var, base_object);\n@@ -5675,8 +5672,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    {\n \t      tmp = parmse.string_length;\n-\t      if (TREE_CODE (tmp) != VAR_DECL\n-\t\t  && TREE_CODE (tmp) != COMPONENT_REF)\n+\t      if (!VAR_P (tmp) && TREE_CODE (tmp) != COMPONENT_REF)\n \t\ttmp = gfc_evaluate_now (parmse.string_length, &se->pre);\n \t      parmse.string_length = gfc_build_addr_expr (NULL_TREE, tmp);\n \t    }\n@@ -6019,7 +6015,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (ts.type == BT_CHARACTER && ts.deferred)\n \t{\n \t  tmp = len;\n-\t  if (TREE_CODE (tmp) != VAR_DECL)\n+\t  if (!VAR_P (tmp))\n \t    tmp = gfc_evaluate_now (len, &se->pre);\n \t  TREE_STATIC (tmp) = 1;\n \t  gfc_add_modify (&se->pre, tmp,\n@@ -9692,7 +9688,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \n   /* Stabilize a string length for temporaries.  */\n   if (expr2->ts.type == BT_CHARACTER && !expr1->ts.deferred\n-      && !(TREE_CODE (rse.string_length) == VAR_DECL\n+      && !(VAR_P (rse.string_length)\n \t   || TREE_CODE (rse.string_length) == PARM_DECL\n \t   || TREE_CODE (rse.string_length) == INDIRECT_REF))\n     string_length = gfc_evaluate_now (rse.string_length, &rse.pre);"}, {"sha": "2911d642e32c459191aa4d7e38de8819d5f7e3b0", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -3653,7 +3653,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   if (TREE_TYPE (args[0]) != type)\n     args[0] = convert (type, args[0]);\n   /* Only evaluate the argument once.  */\n-  if (TREE_CODE (args[0]) != VAR_DECL && !TREE_CONSTANT (args[0]))\n+  if (!VAR_P (args[0]) && !TREE_CONSTANT (args[0]))\n     args[0] = gfc_evaluate_now (args[0], &se->pre);\n \n   mvar = gfc_create_var (type, \"M\");\n@@ -3677,7 +3677,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \tcond = NULL_TREE;\n \n \t/* Only evaluate the argument once.  */\n-\tif (TREE_CODE (val) != VAR_DECL && !TREE_CONSTANT (val))\n+\tif (!VAR_P (val) && !TREE_CONSTANT (val))\n \t  val = gfc_evaluate_now (val, &se->pre);\n       }\n "}, {"sha": "a355ee22df9b6027da6c106ce20a467a3f60ad6b", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -1573,10 +1573,10 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n   else\n     decl = c->backend_decl;\n \n-  gcc_assert (decl && ((TREE_CODE (decl) == FIELD_DECL\n-\t\t     || TREE_CODE (decl) == VAR_DECL\n-\t\t     || TREE_CODE (decl) == PARM_DECL)\n-\t\t     || TREE_CODE (decl) == COMPONENT_REF));\n+  gcc_assert (decl && (TREE_CODE (decl) == FIELD_DECL\n+\t\t       || VAR_P (decl)\n+\t\t       || TREE_CODE (decl) == PARM_DECL\n+\t\t       || TREE_CODE (decl) == COMPONENT_REF));\n \n   tmp = decl;\n "}, {"sha": "febff2554387ead30248814261b842c64152f3d4", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -143,9 +143,7 @@ gfc_omp_predetermined_sharing (tree decl)\n      variables at all (they can't be redefined), but they can nevertheless appear\n      in parallel/task regions and for default(none) purposes treat them as shared.\n      For vtables likely the same handling is desirable.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && TREE_READONLY (decl)\n-      && TREE_STATIC (decl))\n+  if (VAR_P (decl) && TREE_READONLY (decl) && TREE_STATIC (decl))\n     return OMP_CLAUSE_DEFAULT_SHARED;\n \n   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n@@ -1156,7 +1154,7 @@ gfc_omp_disregard_value_expr (tree decl, bool shared)\n       tree value = DECL_VALUE_EXPR (decl);\n \n       if (TREE_CODE (value) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_OPERAND (value, 0)) == VAR_DECL\n+\t  && VAR_P (TREE_OPERAND (value, 0))\n \t  && GFC_DECL_COMMON_OR_EQUIV (TREE_OPERAND (value, 0)))\n \t{\n \t  /* If variable in COMMON or EQUIVALENCE is privatized, return\n@@ -1192,7 +1190,7 @@ gfc_omp_private_debug_clause (tree decl, bool shared)\n       tree value = DECL_VALUE_EXPR (decl);\n \n       if (TREE_CODE (value) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_OPERAND (value, 0)) == VAR_DECL\n+\t  && VAR_P (TREE_OPERAND (value, 0))\n \t  && GFC_DECL_COMMON_OR_EQUIV (TREE_OPERAND (value, 0)))\n \treturn shared;\n     }\n@@ -3001,7 +2999,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n   lhsaddr = save_expr (lhsaddr);\n   if (TREE_CODE (lhsaddr) != SAVE_EXPR\n       && (TREE_CODE (lhsaddr) != ADDR_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (lhsaddr, 0)) != VAR_DECL))\n+\t  || !VAR_P (TREE_OPERAND (lhsaddr, 0))))\n     {\n       /* Make sure LHS is simple enough so that goa_lhs_expr_p can recognize\n \t it even after unsharing function body.  */\n@@ -3233,7 +3231,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n       dovar_decl = dovar;\n \n       /* Special case simple loops.  */\n-      if (TREE_CODE (dovar) == VAR_DECL)\n+      if (VAR_P (dovar))\n \t{\n \t  if (integer_onep (step))\n \t    simple = 1;"}, {"sha": "dc2f068768f007093637f3d2898b62c28f1ad93c", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d168c883c5794b57adfb272e9fec9ee8df974832/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=d168c883c5794b57adfb272e9fec9ee8df974832", "patch": "@@ -335,7 +335,7 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n      references.  */\n   if (type && TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_MAXVAL (TYPE_DOMAIN (type)) != NULL_TREE\n-      && (TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == VAR_DECL\n+      && (VAR_P (TYPE_MAXVAL (TYPE_DOMAIN (type)))\n \t  || TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == INDIRECT_REF)\n       && decl\n       && (TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == INDIRECT_REF\n@@ -356,9 +356,8 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n      subreference, use the span that is stored with the backend decl\n      and reference the element with pointer arithmetic.  */\n   if ((decl && (TREE_CODE (decl) == FIELD_DECL\n-\t\t|| TREE_CODE (decl) == VAR_DECL\n-\t\t|| TREE_CODE (decl) == PARM_DECL\n-\t\t|| TREE_CODE (decl) == FUNCTION_DECL)\n+\t\t|| VAR_OR_FUNCTION_DECL_P (decl)\n+\t\t|| TREE_CODE (decl) == PARM_DECL)\n        && ((GFC_DECL_SUBREF_ARRAY_P (decl)\n \t    && !integer_zerop (GFC_DECL_SPAN (decl)))\n \t   || GFC_DECL_CLASS (decl)"}]}