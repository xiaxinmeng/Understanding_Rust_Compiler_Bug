{"sha": "a2106317cd6673e110b347c70f21e25fbb23379e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxMDYzMTdjZDY2NzNlMTEwYjM0N2M3MGYyMWUyNWZiYjIzMzc5ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-11T09:32:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-11T09:32:19Z"}, "message": "widening_mul: Pattern recognize unsigned multiplication with overflow check [PR95852]\n\nThe following patch pattern recognizes some forms of multiplication followed\nby overflow check through division by one of the operands compared to the\nother one, with optional removal of guarding non-zero check for that operand\nif possible.  The patterns are replaced with effectively\n__builtin_mul_overflow or __builtin_mul_overflow_p.  The testcases cover 64\ndifferent forms of that.\n\n2021-01-11  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/95852\n\t* tree-ssa-math-opts.c (maybe_optimize_guarding_check): New function.\n\t(uaddsub_overflow_check_p): Renamed to ...\n\t(arith_overflow_check_p): ... this.  Handle also multiplication\n\twith overflow check.\n\t(match_uaddsub_overflow): Renamed to ...\n\t(match_arith_overflow): ... this.  Add cfg_changed argument.  Handle\n\talso multiplication with overflow check.  Adjust function comment.\n\t(math_opts_dom_walker::after_dom_children): Adjust callers.  Call\n\tmatch_arith_overflow also for MULT_EXPR.\n\n\t* gcc.target/i386/pr95852-1.c: New test.\n\t* gcc.target/i386/pr95852-2.c: New test.", "tree": {"sha": "a7f2fa222c89b85f8e86db28c9ab3fc906845719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7f2fa222c89b85f8e86db28c9ab3fc906845719"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2106317cd6673e110b347c70f21e25fbb23379e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2106317cd6673e110b347c70f21e25fbb23379e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2106317cd6673e110b347c70f21e25fbb23379e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2106317cd6673e110b347c70f21e25fbb23379e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64dc013853b5a414bfe70727010942e3f872c402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64dc013853b5a414bfe70727010942e3f872c402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64dc013853b5a414bfe70727010942e3f872c402"}], "stats": {"total": 841, "additions": 818, "deletions": 23}, "files": [{"sha": "a3f85ddabcbc75beba1a1a3cba98a21b267d1ca3", "filename": "gcc/testsuite/gcc.target/i386/pr95852-1.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2106317cd6673e110b347c70f21e25fbb23379e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2106317cd6673e110b347c70f21e25fbb23379e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-1.c?ref=a2106317cd6673e110b347c70f21e25fbb23379e", "patch": "@@ -0,0 +1,266 @@\n+/* PR tree-optimization/95852 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -masm=att\" } */\n+/* { dg-final { scan-tree-dump-times \" = \\.MUL_OVERFLOW \" 32 \"optimized\" } } */\n+/* { dg-final { scan-assembler-times \"\\tmull\\t\" 32 } } */\n+/* { dg-final { scan-assembler-times \"\\tseto\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tsetno\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tjn\\?o\\t\" 16 } } */\n+\n+unsigned fn (void);\n+\n+int\n+f1 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return x && (*res / x) != y;\n+}\n+\n+unsigned\n+f2 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (x && (r / x) != y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f3 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return !x || (*res / x) == y;\n+}\n+\n+unsigned\n+f4 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!x || (r / x) == y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f5 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return x && ((unsigned) *res / x) != (unsigned) y;\n+}\n+\n+int\n+f6 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (x && ((unsigned) r / x) != (unsigned) y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f7 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return !x || ((unsigned) *res / x) == (unsigned) y;\n+}\n+\n+int\n+f8 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!x || ((unsigned) r / x) == (unsigned) y)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f9 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return y && (*res / y) != x;\n+}\n+\n+unsigned\n+f10 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (y && (r / y) != x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f11 (unsigned x, unsigned y, unsigned *res)\n+{\n+  *res = x * y;\n+  return !y || (*res / y) == x;\n+}\n+\n+unsigned\n+f12 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!y || (r / y) == x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f13 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return y && ((unsigned) *res / y) != (unsigned) x;\n+}\n+\n+int\n+f14 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (y && ((unsigned) r / y) != (unsigned) x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f15 (int x, int y, int *res)\n+{\n+  *res = (unsigned) x * y;\n+  return !y || ((unsigned) *res / y) == (unsigned) x;\n+}\n+\n+int\n+f16 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!y || ((unsigned) r / y) == (unsigned) x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f17 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return x && (*res / x) != 35U;\n+}\n+\n+unsigned\n+f18 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (x && (r / x) != 35U)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f19 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return !x || (*res / x) == 35U;\n+}\n+\n+unsigned\n+f20 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (!x || (r / x) == 35U)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f21 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return x && ((unsigned) *res / x) != 35U;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (x && ((unsigned) r / x) != 35U)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f23 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return !x || ((unsigned) *res / x) == 35U;\n+}\n+\n+int\n+f24 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (!x || ((unsigned) r / x) == 35U)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f25 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return (*res / 35U) != x;\n+}\n+\n+unsigned\n+f26 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if ((r / 35U) != x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f27 (unsigned x, unsigned *res)\n+{\n+  *res = x * 35U;\n+  return !35U || (*res / 35U) == x;\n+}\n+\n+unsigned\n+f28 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if ((r / 35U) == x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f29 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return 35 && ((unsigned) *res / 35) != (unsigned) x;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (((unsigned) r / 35) != (unsigned) x)\n+    return fn ();\n+  return r;\n+}\n+\n+int\n+f31 (int x, int *res)\n+{\n+  *res = (unsigned) x * 35;\n+  return ((unsigned) *res / 35) == (unsigned) x;\n+}\n+\n+int\n+f32 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (((unsigned) r / 35) == (unsigned) x)\n+    return fn ();\n+  return r;\n+}"}, {"sha": "de85cecfe15e519744d3025d01ee343c3f4e1b8f", "filename": "gcc/testsuite/gcc.target/i386/pr95852-2.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2106317cd6673e110b347c70f21e25fbb23379e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2106317cd6673e110b347c70f21e25fbb23379e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95852-2.c?ref=a2106317cd6673e110b347c70f21e25fbb23379e", "patch": "@@ -0,0 +1,266 @@\n+/* PR tree-optimization/95852 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -masm=att\" } */\n+/* { dg-final { scan-tree-dump-times \" = \\.MUL_OVERFLOW \" 32 \"optimized\" } } */\n+/* { dg-final { scan-assembler-times \"\\tmull\\t\" 32 } } */\n+/* { dg-final { scan-assembler-times \"\\tseto\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tsetno\\t\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\tjn\\?o\\t\" 16 } } */\n+\n+unsigned fn (void);\n+\n+int\n+f1 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  return x && (r / x) != y;\n+}\n+\n+unsigned\n+f2 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (x && (r / x) != y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f3 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  return !x || (r / x) == y;\n+}\n+\n+unsigned\n+f4 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!x || (r / x) == y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f5 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return x && ((unsigned) r / x) != (unsigned) y;\n+}\n+\n+int\n+f6 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (x && ((unsigned) r / x) != (unsigned) y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f7 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return !x || ((unsigned) r / x) == (unsigned) y;\n+}\n+\n+int\n+f8 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!x || ((unsigned) r / x) == (unsigned) y)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f9 (unsigned x, unsigned y)\n+{\n+  unsigned r = x * y;\n+  return y && (r / y) != x;\n+}\n+\n+unsigned\n+f10 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (y && (r / y) != x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f11 (unsigned x, unsigned y)\n+{\n+  unsigned r = x * y;\n+  return !y || (r / y) == x;\n+}\n+\n+unsigned\n+f12 (unsigned x, unsigned y)\n+{\n+  unsigned int r = x * y;\n+  if (!y || (r / y) == x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f13 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return y && ((unsigned) r / y) != (unsigned) x;\n+}\n+\n+int\n+f14 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (y && ((unsigned) r / y) != (unsigned) x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f15 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  return !y || ((unsigned) r / y) == (unsigned) x;\n+}\n+\n+int\n+f16 (int x, int y)\n+{\n+  int r = (unsigned) x * y;\n+  if (!y || ((unsigned) r / y) == (unsigned) x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f17 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return x && (r / x) != 35U;\n+}\n+\n+unsigned\n+f18 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (x && (r / x) != 35U)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f19 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return !x || (r / x) == 35U;\n+}\n+\n+unsigned\n+f20 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if (!x || (r / x) == 35U)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f21 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return x && ((unsigned) r / x) != 35U;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (x && ((unsigned) r / x) != 35U)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f23 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return !x || ((unsigned) r / x) == 35U;\n+}\n+\n+int\n+f24 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (!x || ((unsigned) r / x) == 35U)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f25 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return (r / 35U) != x;\n+}\n+\n+unsigned\n+f26 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if ((r / 35U) != x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f27 (unsigned x)\n+{\n+  unsigned r = x * 35U;\n+  return !35U || (r / 35U) == x;\n+}\n+\n+unsigned\n+f28 (unsigned x)\n+{\n+  unsigned int r = x * 35U;\n+  if ((r / 35U) == x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f29 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return 35 && ((unsigned) r / 35) != (unsigned) x;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (((unsigned) r / 35) != (unsigned) x)\n+    return fn ();\n+  return 0;\n+}\n+\n+int\n+f31 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  return ((unsigned) r / 35) == (unsigned) x;\n+}\n+\n+int\n+f32 (int x)\n+{\n+  int r = (unsigned) x * 35;\n+  if (((unsigned) r / 35) == (unsigned) x)\n+    return fn ();\n+  return 0;\n+}"}, {"sha": "1f28679ef2e8fc79202d9c77dc2d1cc14b9236e0", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 286, "deletions": 23, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2106317cd6673e110b347c70f21e25fbb23379e/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2106317cd6673e110b347c70f21e25fbb23379e/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=a2106317cd6673e110b347c70f21e25fbb23379e", "patch": "@@ -3451,17 +3451,228 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n }\n \n \n-/* Helper function of match_uaddsub_overflow.  Return 1\n+/* Helper function of match_arith_overflow.  For MUL_OVERFLOW, if we have\n+   a check for non-zero like:\n+   _1 = x_4(D) * y_5(D);\n+   *res_7(D) = _1;\n+   if (x_4(D) != 0)\n+     goto <bb 3>; [50.00%]\n+   else\n+     goto <bb 4>; [50.00%]\n+\n+   <bb 3> [local count: 536870913]:\n+   _2 = _1 / x_4(D);\n+   _9 = _2 != y_5(D);\n+   _10 = (int) _9;\n+\n+   <bb 4> [local count: 1073741824]:\n+   # iftmp.0_3 = PHI <_10(3), 0(2)>\n+   then in addition to using .MUL_OVERFLOW (x_4(D), y_5(D)) we can also\n+   optimize the x_4(D) != 0 condition to 1.  */\n+\n+static void\n+maybe_optimize_guarding_check (gimple **mul_stmts, gimple *cond_stmt,\n+\t\t\t       gimple *div_stmt, bool *cfg_changed)\n+{\n+  basic_block bb = gimple_bb (cond_stmt);\n+  if (gimple_bb (div_stmt) != bb || !single_pred_p (bb))\n+    return;\n+  edge pred_edge = single_pred_edge (bb);\n+  basic_block pred_bb = pred_edge->src;\n+  if (EDGE_COUNT (pred_bb->succs) != 2)\n+    return;\n+  edge other_edge = EDGE_SUCC (pred_bb, EDGE_SUCC (pred_bb, 0) == pred_edge);\n+  edge other_succ_edge = NULL;\n+  if (gimple_code (cond_stmt) == GIMPLE_COND)\n+    {\n+      if (EDGE_COUNT (bb->succs) != 2)\n+\treturn;\n+      other_succ_edge = EDGE_SUCC (bb, 0);\n+      if (gimple_cond_code (cond_stmt) == NE_EXPR)\n+\t{\n+\t  if (other_succ_edge->flags & EDGE_TRUE_VALUE)\n+\t    other_succ_edge = EDGE_SUCC (bb, 1);\n+\t}\n+      else if (other_succ_edge->flags & EDGE_FALSE_VALUE)\n+\tother_succ_edge = EDGE_SUCC (bb, 0);\n+      if (other_edge->dest != other_succ_edge->dest)\n+\treturn;\n+    }\n+  else if (!single_succ_p (bb) || other_edge->dest != single_succ (bb))\n+    return;\n+  gimple *zero_cond = last_stmt (pred_bb);\n+  if (zero_cond == NULL\n+      || gimple_code (zero_cond) != GIMPLE_COND\n+      || (gimple_cond_code (zero_cond)\n+\t  != ((pred_edge->flags & EDGE_TRUE_VALUE) ? NE_EXPR : EQ_EXPR))\n+      || !integer_zerop (gimple_cond_rhs (zero_cond)))\n+    return;\n+  tree zero_cond_lhs = gimple_cond_lhs (zero_cond);\n+  if (TREE_CODE (zero_cond_lhs) != SSA_NAME)\n+    return;\n+  if (gimple_assign_rhs2 (div_stmt) != zero_cond_lhs)\n+    {\n+      /* Allow the divisor to be result of a same precision cast\n+\t from zero_cond_lhs.  */\n+      tree rhs2 = gimple_assign_rhs2 (div_stmt);\n+      if (TREE_CODE (rhs2) != SSA_NAME)\n+\treturn;\n+      gimple *g = SSA_NAME_DEF_STMT (rhs2);\n+      if (!gimple_assign_cast_p (g)\n+\t  || gimple_assign_rhs1 (g) != gimple_cond_lhs (zero_cond)\n+\t  || !INTEGRAL_TYPE_P (TREE_TYPE (zero_cond_lhs))\n+\t  || (TYPE_PRECISION (TREE_TYPE (zero_cond_lhs))\n+\t      != TYPE_PRECISION (TREE_TYPE (rhs2))))\n+\treturn;\n+    }\n+  gimple_stmt_iterator gsi = gsi_for_stmt (div_stmt);\n+  gsi_prev_nondebug (&gsi);\n+  if (!gsi_end_p (gsi))\n+    {\n+      /* If original mul_stmt has a single use, allow it in the same bb,\n+\t we are looking then just at __builtin_mul_overflow_p.\n+\t Though, in that case the original mul_stmt will be replaced\n+\t by .MUL_OVERFLOW, REALPART_EXPR and IMAGPART_EXPR stmts.  */\n+      for (int i = 2; i >= 0; --i)\n+\t{\n+\t  if (gsi_stmt (gsi) != mul_stmts[i])\n+\t    return;\n+\t  gsi_prev_nondebug (&gsi);\n+\t}\n+      /* Allow up to 2 extra casts.  Given the way we check PHIs,\n+\t nothing from this bb should be consumed by any other bb\n+\t anyway.  */\n+      for (int i = 0; i < 2 && !gsi_end_p (gsi); i++)\n+\t{\n+\t  gimple *g = gsi_stmt (gsi);\n+\t  if (!gimple_assign_cast_p (g))\n+\t    return;\n+\t  gsi_prev_nondebug (&gsi);\n+\t}\n+      if (!gsi_end_p (gsi))\n+\treturn;\n+    }\n+  gsi = gsi_for_stmt (div_stmt);\n+  gsi_next_nondebug (&gsi);\n+  if (gsi_stmt (gsi) != cond_stmt)\n+    return;\n+  if (gimple_code (cond_stmt) == GIMPLE_COND)\n+    {\n+      basic_block succ_bb = other_edge->dest;\n+      for (gphi_iterator gpi = gsi_start_phis (succ_bb); !gsi_end_p (gpi);\n+\t   gsi_next (&gpi))\n+\t{\n+\t  gphi *phi = gpi.phi ();\n+\t  tree v1 = gimple_phi_arg_def (phi, other_edge->dest_idx);\n+\t  tree v2 = gimple_phi_arg_def (phi, other_succ_edge->dest_idx);\n+\t  if (!operand_equal_p (v1, v2, 0))\n+\t    return;\n+\t}\n+    }\n+  else\n+    {\n+      tree lhs = gimple_assign_lhs (cond_stmt);\n+      if (!lhs || !INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n+\treturn;\n+      gsi_next_nondebug (&gsi);\n+      if (!gsi_end_p (gsi))\n+\t{\n+\t  if (gimple_assign_rhs_code (cond_stmt) == COND_EXPR)\n+\t    return;\n+\t  gimple *cast_stmt = gsi_stmt (gsi);\n+\t  if (!gimple_assign_cast_p (cast_stmt))\n+\t    return;\n+\t  tree new_lhs = gimple_assign_lhs (cast_stmt);\n+\t  gsi_next_nondebug (&gsi);\n+\t  if (!gsi_end_p (gsi)\n+\t      || !new_lhs\n+\t      || !INTEGRAL_TYPE_P (TREE_TYPE (new_lhs))\n+\t      || TYPE_PRECISION (TREE_TYPE (new_lhs)) <= 1)\n+\t    return;\n+\t  lhs = new_lhs;\n+\t}\n+      edge succ_edge = single_succ_edge (bb);\n+      basic_block succ_bb = succ_edge->dest;\n+      gsi = gsi_start_phis (succ_bb);\n+      if (gsi_end_p (gsi))\n+\treturn;\n+      gphi *phi = as_a <gphi *> (gsi_stmt (gsi));\n+      gsi_next (&gsi);\n+      if (!gsi_end_p (gsi))\n+\treturn;\n+      if (gimple_phi_arg_def (phi, succ_edge->dest_idx) != lhs)\n+\treturn;\n+      tree other_val = gimple_phi_arg_def (phi, other_edge->dest_idx);\n+      if (gimple_assign_rhs_code (cond_stmt) == COND_EXPR)\n+\t{\n+\t  tree cond = gimple_assign_rhs1 (cond_stmt);\n+\t  if (TREE_CODE (cond) == NE_EXPR)\n+\t    {\n+\t      if (!operand_equal_p (other_val,\n+\t\t\t\t    gimple_assign_rhs3 (cond_stmt), 0))\n+\t\treturn;\n+\t    }\n+\t  else if (!operand_equal_p (other_val,\n+\t\t\t\t     gimple_assign_rhs2 (cond_stmt), 0))\n+\t    return;\n+\t}\n+      else if (gimple_assign_rhs_code (cond_stmt) == NE_EXPR)\n+\t{\n+\t  if (!integer_zerop (other_val))\n+\t    return;\n+\t}\n+      else if (!integer_onep (other_val))\n+\treturn;\n+    }\n+  gcond *zero_gcond = as_a <gcond *> (zero_cond);\n+  if (pred_edge->flags & EDGE_TRUE_VALUE)\n+    gimple_cond_make_true (zero_gcond);\n+  else\n+    gimple_cond_make_false (zero_gcond);\n+  update_stmt (zero_cond);\n+  *cfg_changed = true;\n+}\n+\n+/* Helper function of match_arith_overflow.  Return 1\n    if USE_STMT is unsigned overflow check ovf != 0 for\n    STMT, -1 if USE_STMT is unsigned overflow check ovf == 0\n    and 0 otherwise.  */\n \n static int\n-uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt, tree maxval,\n-\t\t\t  tree *other)\n+arith_overflow_check_p (gimple *stmt, gimple *&use_stmt, tree maxval,\n+\t\t\ttree *other)\n {\n   enum tree_code ccode = ERROR_MARK;\n   tree crhs1 = NULL_TREE, crhs2 = NULL_TREE;\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  tree rhs2 = gimple_assign_rhs2 (stmt);\n+  tree multop = NULL_TREE, divlhs = NULL_TREE;\n+\n+  if (code == MULT_EXPR)\n+    {\n+      if (!is_gimple_assign (use_stmt))\n+\treturn 0;\n+      if (gimple_assign_rhs_code (use_stmt) != TRUNC_DIV_EXPR)\n+\treturn 0;\n+      if (gimple_assign_rhs1 (use_stmt) != lhs)\n+\treturn 0;\n+      if (gimple_assign_rhs2 (use_stmt) == rhs1)\n+\tmultop = rhs2;\n+      else if (operand_equal_p (gimple_assign_rhs2 (use_stmt), rhs2, 0))\n+\tmultop = rhs1;\n+      else\n+\treturn 0;\n+      if (stmt_ends_bb_p (use_stmt))\n+\treturn 0;\n+      divlhs = gimple_assign_lhs (use_stmt);\n+      if (!divlhs)\n+\treturn 0;\n+      use_operand_p use;\n+      if (!single_imm_use (divlhs, &use, &use_stmt))\n+\treturn 0;\n+    }\n   if (gimple_code (use_stmt) == GIMPLE_COND)\n     {\n       ccode = gimple_cond_code (use_stmt);\n@@ -3497,11 +3708,6 @@ uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt, tree maxval,\n   if (TREE_CODE_CLASS (ccode) != tcc_comparison)\n     return 0;\n \n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  tree lhs = gimple_assign_lhs (stmt);\n-  tree rhs1 = gimple_assign_rhs1 (stmt);\n-  tree rhs2 = gimple_assign_rhs2 (stmt);\n-\n   switch (ccode)\n     {\n     case GT_EXPR:\n@@ -3547,6 +3753,17 @@ uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt, tree maxval,\n \t  return ccode == LT_EXPR ? 1 : -1;\n \t}\n       break;\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      /* r = a * b; _1 = r / a; _1 == b\n+\t r = a * b; _1 = r / b; _1 == a\n+\t r = a * b; _1 = r / a; _1 != b\n+\t r = a * b; _1 = r / b; _1 != a.  */\n+      if (code == MULT_EXPR\n+\t  && ((crhs1 == divlhs && operand_equal_p (crhs2, multop, 0))\n+\t      || (crhs2 == divlhs && crhs1 == multop)))\n+\treturn ccode == NE_EXPR ? 1 : -1;\n+      break;\n     default:\n       break;\n     }\n@@ -3557,7 +3774,7 @@ uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt, tree maxval,\n    x = y - z;\n    if (x > y)\n    where there are other uses of x and replace it with\n-   _7 = SUB_OVERFLOW (y, z);\n+   _7 = .SUB_OVERFLOW (y, z);\n    x = REALPART_EXPR <_7>;\n    _8 = IMAGPART_EXPR <_7>;\n    if (_8)\n@@ -3571,23 +3788,44 @@ uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt, tree maxval,\n    where y and z have unsigned types with maximum max\n    and there are other uses of x and all of those cast x\n    back to that unsigned type and again replace it with\n-   _7 = ADD_OVERFLOW (y, z);\n+   _7 = .ADD_OVERFLOW (y, z);\n    _9 = REALPART_EXPR <_7>;\n-   _8 = IMAGPART_EXPR <_8>;\n+   _8 = IMAGPART_EXPR <_7>;\n    if (_8)\n    and replace (utype) x with _9.\n \n    Also recognize:\n    x = ~z;\n    if (y > x)\n    and replace it with\n-   _7 = ADD_OVERFLOW (y, z);\n-   _8 = IMAGPART_EXPR <_8>;\n-   if (_8)  */\n+   _7 = .ADD_OVERFLOW (y, z);\n+   _8 = IMAGPART_EXPR <_7>;\n+   if (_8)\n+\n+   And also recognize:\n+   z = x * y;\n+   if (x != 0)\n+     goto <bb 3>; [50.00%]\n+   else\n+     goto <bb 4>; [50.00%]\n+\n+   <bb 3> [local count: 536870913]:\n+   _2 = z / x;\n+   _9 = _2 != y;\n+   _10 = (int) _9;\n+\n+   <bb 4> [local count: 1073741824]:\n+   # iftmp.0_3 = PHI <_10(3), 0(2)>\n+   and replace it with\n+   _7 = .MUL_OVERFLOW (x, y);\n+   z = IMAGPART_EXPR <_7>;\n+   _8 = IMAGPART_EXPR <_7>;\n+   _9 = _8 != 0;\n+   iftmp.0_3 = (int) _9;  */\n \n static bool\n-match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n-\t\t\tenum tree_code code)\n+match_arith_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n+\t\t      enum tree_code code, bool *cfg_changed)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n   tree type = TREE_TYPE (lhs);\n@@ -3602,11 +3840,13 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \n   gcc_checking_assert (code == PLUS_EXPR\n \t\t       || code == MINUS_EXPR\n+\t\t       || code == MULT_EXPR\n \t\t       || code == BIT_NOT_EXPR);\n   if (!INTEGRAL_TYPE_P (type)\n       || !TYPE_UNSIGNED (type)\n       || has_zero_uses (lhs)\n       || (code != PLUS_EXPR\n+\t  && code != MULT_EXPR\n \t  && optab_handler (code == MINUS_EXPR ? usubv4_optab : uaddv4_optab,\n \t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing))\n     return false;\n@@ -3620,7 +3860,7 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \tcontinue;\n \n       tree other = NULL_TREE;\n-      if (uaddsub_overflow_check_p (stmt, use_stmt, NULL_TREE, &other))\n+      if (arith_overflow_check_p (stmt, use_stmt, NULL_TREE, &other))\n \t{\n \t  if (code == BIT_NOT_EXPR)\n \t    {\n@@ -3643,9 +3883,12 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \n   tree maxval = NULL_TREE;\n   if (!ovf_use_seen\n-      || (code == BIT_NOT_EXPR ? use_seen : !use_seen)\n+      || (code != MULT_EXPR && (code == BIT_NOT_EXPR ? use_seen : !use_seen))\n       || (code == PLUS_EXPR\n \t  && optab_handler (uaddv4_optab,\n+\t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing)\n+      || (code == MULT_EXPR\n+\t  && optab_handler (umulv4_optab,\n \t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing))\n     {\n       if (code != PLUS_EXPR)\n@@ -3704,7 +3947,7 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \t  if (is_gimple_debug (use_stmt))\n \t    continue;\n \n-\t  if (uaddsub_overflow_check_p (stmt, use_stmt, maxval, NULL))\n+\t  if (arith_overflow_check_p (stmt, use_stmt, maxval, NULL))\n \t    {\n \t      ovf_use_seen = true;\n \t      use_bb = gimple_bb (use_stmt);\n@@ -3824,13 +4067,16 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n     *gsi = gsi_for_stmt (cond_stmt);\n \n   tree ctype = build_complex_type (type);\n-  gcall *g = gimple_build_call_internal (code != MINUS_EXPR\n+  gcall *g = gimple_build_call_internal (code == MULT_EXPR\n+\t\t\t\t\t ? IFN_MUL_OVERFLOW\n+\t\t\t\t\t : code != MINUS_EXPR\n \t\t\t\t\t ? IFN_ADD_OVERFLOW : IFN_SUB_OVERFLOW,\n \t\t\t\t\t 2, rhs1, rhs2);\n   tree ctmp = make_ssa_name (ctype);\n   gimple_call_set_lhs (g, ctmp);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n   tree new_lhs = maxval ? make_ssa_name (type) : lhs;\n+  gimple *mul_stmts[3] = { NULL, NULL, NULL };\n   gassign *g2;\n   if (code != BIT_NOT_EXPR)\n     {\n@@ -3844,6 +4090,11 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \t}\n       else\n \tgsi_replace (gsi, g2, true);\n+      if (code == MULT_EXPR)\n+\t{\n+\t  mul_stmts[0] = g;\n+\t  mul_stmts[1] = g2;\n+\t}\n     }\n   tree ovf = make_ssa_name (type);\n   g2 = gimple_build_assign (ovf, IMAGPART_EXPR,\n@@ -3852,13 +4103,16 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n     gsi_insert_after (gsi, g2, GSI_NEW_STMT);\n   else\n     gsi_insert_before (gsi, g2, GSI_SAME_STMT);\n+  if (code == MULT_EXPR)\n+    mul_stmts[2] = g2;\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n     {\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      int ovf_use = uaddsub_overflow_check_p (stmt, use_stmt, maxval, NULL);\n+      gimple *orig_use_stmt = use_stmt;\n+      int ovf_use = arith_overflow_check_p (stmt, use_stmt, maxval, NULL);\n       if (ovf_use == 0)\n \t{\n \t  gcc_assert (code != BIT_NOT_EXPR);\n@@ -3901,6 +4155,14 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \t    }\n \t}\n       update_stmt (use_stmt);\n+      if (code == MULT_EXPR && use_stmt != orig_use_stmt)\n+\t{\n+\t  gimple_stmt_iterator gsi2 = gsi_for_stmt (orig_use_stmt);\n+\t  maybe_optimize_guarding_check (mul_stmts, use_stmt, orig_use_stmt,\n+\t\t\t\t\t cfg_changed);\n+\t  gsi_remove (&gsi2, true);\n+\t  release_ssa_name (gimple_assign_lhs (orig_use_stmt));\n+\t}\n     }\n   if (maxval)\n     {\n@@ -4238,16 +4500,17 @@ math_opts_dom_walker::after_dom_children (basic_block bb)\n \t\t  release_defs (stmt);\n \t\t  continue;\n \t\t}\n+\t      match_arith_overflow (&gsi, stmt, code, m_cfg_changed_p);\n \t      break;\n \n \t    case PLUS_EXPR:\n \t    case MINUS_EXPR:\n \t      if (!convert_plusminus_to_widen (&gsi, stmt, code))\n-\t\tmatch_uaddsub_overflow (&gsi, stmt, code);\n+\t\tmatch_arith_overflow (&gsi, stmt, code, m_cfg_changed_p);\n \t      break;\n \n \t    case BIT_NOT_EXPR:\n-\t      if (match_uaddsub_overflow (&gsi, stmt, code))\n+\t      if (match_arith_overflow (&gsi, stmt, code, m_cfg_changed_p))\n \t\tcontinue;\n \t      break;\n "}]}