{"sha": "64b1806b2d94fd325759761b64fb7507ca83d5d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRiMTgwNmIyZDk0ZmQzMjU3NTk3NjFiNjRmYjc1MDdjYTgzZDVkMg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-15T18:35:13Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-15T18:35:13Z"}, "message": "re PR fortran/54613 ([F08] Add FINDLOC plus support MAXLOC/MINLOC with KIND=/BACK=)\n\n2018-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* gfortran.h (gfc_check_f): Rename f4ml to f5ml.\n\t(gfc_logical_4_kind): New macro\n\t* intrinsic.h (gfc_simplify_minloc): Add a gfc_expr *argument.\n\t(gfc_simplify_maxloc): Likewise.\n\t(gfc_resolve_maxloc): Likewise.\n\t(gfc_resolve_minloc): Likewise.\n\t* check.c (gfc_check_minloc_maxloc): Add checking for \"back\"\n\targument; also raise error if it is used (for now). Add it\n\tif it isn't present.\n\t* intrinsic.c (add_sym_4ml): Rename to\n\t(add_sym_5ml), adjust for extra argument.\n\t(add_functions): Add \"back\" constant. Adjust maxloc and minloc\n\tfor back argument.\n\t* iresolve.c (gfc_resolve_maxloc): Add back argument. If back is\n\tnot of gfc_logical_4_kind, convert.\n\t(gfc_resolve_minloc): Likewise.\n\t* simplify.c (gfc_simplify_minloc): Add back argument.\n\t(gfc_simplify_maxloc): Likewise.\n\t* trans-intinsic.c (gfc_conv_intrinsic_minmaxloc): Rename last\n\targument to %VAL to ensure passing by value.\n\t(gfc_conv_intrinsic_function): Call gfc_conv_intrinsic_minmaxloc\n\talso for library calls.\n\n2018-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* m4/iparm.m4: Add back_arg macro if in minloc or maxloc.\n\t* m4/iforeach-s.m4: Add optional argument back with back_arg\n\tmacro. Improve m4 quoting. If HAVE_BACK_ARG is defined, assert\n\tthat back is non-true.\n\t* m4/iforeach.m4: Likewise.\n\t* m4/ifunction-s.m4: Likewise.\n\t* m4/ifunction.m4: Likewise.\n\t* m4/maxloc0.m4: Include assert.h\n\t* m4/minloc0.m4: Likewise.\n\t* m4/maxloc0s.m4: #define HAVE_BACK_ARG.\n\t* m4/minloc0s.m4: Likewise.\n\t* m4/maxloc1s.m4: Likewise.\n\t* m4/minloc1s.m4: Likewise.\n\t* m4/maxloc1.m4: Include assert.h, #define HAVE_BACK_ARG.\n\t* m4/minloc1.m4: Likewise.\n\t* m4/maxloc2s.m4: Add assert.h, add back_arg, assert that\n\tback is non-true.\n\t* m4/minloc2s.m4: Likewise.\n\t* generated/iall_i1.c: Regenerated.\n\t* generated/iall_i16.c: Regenerated.\n\t* generated/iall_i2.c: Regenerated.\n\t* generated/iall_i4.c: Regenerated.\n\t* generated/iall_i8.c: Regenerated.\n\t* generated/iany_i1.c: Regenerated.\n\t* generated/iany_i16.c: Regenerated.\n\t* generated/iany_i2.c: Regenerated.\n\t* generated/iany_i4.c: Regenerated.\n\t* generated/iany_i8.c: Regenerated.\n\t* generated/iparity_i1.c: Regenerated.\n\t* generated/iparity_i16.c: Regenerated.\n\t* generated/iparity_i2.c: Regenerated.\n\t* generated/iparity_i4.c: Regenerated.\n\t* generated/iparity_i8.c: Regenerated.\n\t* generated/maxloc0_16_i1.c: Regenerated.\n\t* generated/maxloc0_16_i16.c: Regenerated.\n\t* generated/maxloc0_16_i2.c: Regenerated.\n\t* generated/maxloc0_16_i4.c: Regenerated.\n\t* generated/maxloc0_16_i8.c: Regenerated.\n\t* generated/maxloc0_16_r10.c: Regenerated.\n\t* generated/maxloc0_16_r16.c: Regenerated.\n\t* generated/maxloc0_16_r4.c: Regenerated.\n\t* generated/maxloc0_16_r8.c: Regenerated.\n\t* generated/maxloc0_16_s1.c: Regenerated.\n\t* generated/maxloc0_16_s4.c: Regenerated.\n\t* generated/maxloc0_4_i1.c: Regenerated.\n\t* generated/maxloc0_4_i16.c: Regenerated.\n\t* generated/maxloc0_4_i2.c: Regenerated.\n\t* generated/maxloc0_4_i4.c: Regenerated.\n\t* generated/maxloc0_4_i8.c: Regenerated.\n\t* generated/maxloc0_4_r10.c: Regenerated.\n\t* generated/maxloc0_4_r16.c: Regenerated.\n\t* generated/maxloc0_4_r4.c: Regenerated.\n\t* generated/maxloc0_4_r8.c: Regenerated.\n\t* generated/maxloc0_4_s1.c: Regenerated.\n\t* generated/maxloc0_4_s4.c: Regenerated.\n\t* generated/maxloc0_8_i1.c: Regenerated.\n\t* generated/maxloc0_8_i16.c: Regenerated.\n\t* generated/maxloc0_8_i2.c: Regenerated.\n\t* generated/maxloc0_8_i4.c: Regenerated.\n\t* generated/maxloc0_8_i8.c: Regenerated.\n\t* generated/maxloc0_8_r10.c: Regenerated.\n\t* generated/maxloc0_8_r16.c: Regenerated.\n\t* generated/maxloc0_8_r4.c: Regenerated.\n\t* generated/maxloc0_8_r8.c: Regenerated.\n\t* generated/maxloc0_8_s1.c: Regenerated.\n\t* generated/maxloc0_8_s4.c: Regenerated.\n\t* generated/maxloc1_16_i1.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i2.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_16_s1.c: Regenerated.\n\t* generated/maxloc1_16_s4.c: Regenerated.\n\t* generated/maxloc1_4_i1.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i2.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_4_s1.c: Regenerated.\n\t* generated/maxloc1_4_s4.c: Regenerated.\n\t* generated/maxloc1_8_i1.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i2.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxloc1_8_s1.c: Regenerated.\n\t* generated/maxloc1_8_s4.c: Regenerated.\n\t* generated/maxval_i1.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i2.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc0_16_i1.c: Regenerated.\n\t* generated/minloc0_16_i16.c: Regenerated.\n\t* generated/minloc0_16_i2.c: Regenerated.\n\t* generated/minloc0_16_i4.c: Regenerated.\n\t* generated/minloc0_16_i8.c: Regenerated.\n\t* generated/minloc0_16_r10.c: Regenerated.\n\t* generated/minloc0_16_r16.c: Regenerated.\n\t* generated/minloc0_16_r4.c: Regenerated.\n\t* generated/minloc0_16_r8.c: Regenerated.\n\t* generated/minloc0_16_s1.c: Regenerated.\n\t* generated/minloc0_16_s4.c: Regenerated.\n\t* generated/minloc0_4_i1.c: Regenerated.\n\t* generated/minloc0_4_i16.c: Regenerated.\n\t* generated/minloc0_4_i2.c: Regenerated.\n\t* generated/minloc0_4_i4.c: Regenerated.\n\t* generated/minloc0_4_i8.c: Regenerated.\n\t* generated/minloc0_4_r10.c: Regenerated.\n\t* generated/minloc0_4_r16.c: Regenerated.\n\t* generated/minloc0_4_r4.c: Regenerated.\n\t* generated/minloc0_4_r8.c: Regenerated.\n\t* generated/minloc0_4_s1.c: Regenerated.\n\t* generated/minloc0_4_s4.c: Regenerated.\n\t* generated/minloc0_8_i1.c: Regenerated.\n\t* generated/minloc0_8_i16.c: Regenerated.\n\t* generated/minloc0_8_i2.c: Regenerated.\n\t* generated/minloc0_8_i4.c: Regenerated.\n\t* generated/minloc0_8_i8.c: Regenerated.\n\t* generated/minloc0_8_r10.c: Regenerated.\n\t* generated/minloc0_8_r16.c: Regenerated.\n\t* generated/minloc0_8_r4.c: Regenerated.\n\t* generated/minloc0_8_r8.c: Regenerated.\n\t* generated/minloc0_8_s1.c: Regenerated.\n\t* generated/minloc0_8_s4.c: Regenerated.\n\t* generated/minloc1_16_i1.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i2.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_16_s1.c: Regenerated.\n\t* generated/minloc1_16_s4.c: Regenerated.\n\t* generated/minloc1_4_i1.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i2.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_4_s1.c: Regenerated.\n\t* generated/minloc1_4_s4.c: Regenerated.\n\t* generated/minloc1_8_i1.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i2.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minloc1_8_s1.c: Regenerated.\n\t* generated/minloc1_8_s4.c: Regenerated.\n\t* generated/minval_i1.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i2.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/norm2_r10.c: Regenerated.\n\t* generated/norm2_r16.c: Regenerated.\n\t* generated/norm2_r4.c: Regenerated.\n\t* generated/norm2_r8.c: Regenerated.\n\t* generated/parity_l1.c: Regenerated.\n\t* generated/parity_l16.c: Regenerated.\n\t* generated/parity_l2.c: Regenerated.\n\t* generated/parity_l4.c: Regenerated.\n\t* generated/parity_l8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i1.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i2.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i1.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i2.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\n2018-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* gfortran.dg/minmaxloc_9.f90: New test.\n\t* gfortran.dg/minmaxloc_10.f90: New test.\n\t* gfortran.dg/minmaxloc_11.f90: New test.\n\nFrom-SVN: r256705", "tree": {"sha": "e14d0d04d69a89aa4bda7faa882d36121d76f08b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e14d0d04d69a89aa4bda7faa882d36121d76f08b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64b1806b2d94fd325759761b64fb7507ca83d5d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b1806b2d94fd325759761b64fb7507ca83d5d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b1806b2d94fd325759761b64fb7507ca83d5d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b1806b2d94fd325759761b64fb7507ca83d5d2/comments", "author": null, "committer": null, "parents": [{"sha": "650d669bb4a74cd2cc17d80b110d0f666d3f5bee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650d669bb4a74cd2cc17d80b110d0f666d3f5bee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/650d669bb4a74cd2cc17d80b110d0f666d3f5bee"}], "stats": {"total": 4777, "additions": 3713, "deletions": 1064}, "files": [{"sha": "453dc74ed66b33b9debe8e3ac3d11221bfc342f0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -1,3 +1,29 @@\n+2018-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* gfortran.h (gfc_check_f): Rename f4ml to f5ml.\n+\t(gfc_logical_4_kind): New macro\n+\t* intrinsic.h (gfc_simplify_minloc): Add a gfc_expr *argument.\n+\t(gfc_simplify_maxloc): Likewise.\n+\t(gfc_resolve_maxloc): Likewise.\n+\t(gfc_resolve_minloc): Likewise.\n+\t* check.c (gfc_check_minloc_maxloc): Add checking for \"back\"\n+\targument; also raise error if it is used (for now). Add it\n+\tif it isn't present.\n+\t* intrinsic.c (add_sym_4ml): Rename to\n+\t(add_sym_5ml), adjust for extra argument.\n+\t(add_functions): Add \"back\" constant. Adjust maxloc and minloc\n+\tfor back argument.\n+\t* iresolve.c (gfc_resolve_maxloc): Add back argument. If back is\n+\tnot of gfc_logical_4_kind, convert.\n+\t(gfc_resolve_minloc): Likewise.\n+\t* simplify.c (gfc_simplify_minloc): Add back argument.\n+\t(gfc_simplify_maxloc): Likewise.\n+\t* trans-intinsic.c (gfc_conv_intrinsic_minmaxloc): Rename last\n+\targument to %VAL to ensure passing by value.\n+\t(gfc_conv_intrinsic_function): Call gfc_conv_intrinsic_minmaxloc\n+\talso for library calls.\n+\n 2018-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/82007\n@@ -6,7 +32,7 @@\n \tformat string or format label is present.\n \t* trans-io.c (get_dtio_proc): Likewise. (transfer_expr): Fix\n \twhitespace.\n-\t\n+\n 2018-01-13  Thomas Koenig <tkoenig@gcc.gnu.org>\n \n \tPR fortran/83744"}, {"sha": "a2c8b520d80168a94ddc0ab4ed3761fb94dd8570", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -3265,12 +3265,13 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n \t DIM\tMASK\n \n    I.e. in the case of minloc(array,mask), mask will be in the second\n-   position of the argument list and we'll have to fix that up.  */\n+   position of the argument list and we'll have to fix that up.  Also,\n+   add the BACK argument if that isn't present.  */\n \n bool\n gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n {\n-  gfc_expr *a, *m, *d, *k;\n+  gfc_expr *a, *m, *d, *k, *b;\n \n   a = ap->expr;\n   if (!int_or_real_or_char_check_f2003 (a, 0) || !array_check (a, 0))\n@@ -3279,6 +3280,26 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n   d = ap->next->expr;\n   m = ap->next->next->expr;\n   k = ap->next->next->next->expr;\n+  b = ap->next->next->next->next->expr;\n+\n+  if (b)\n+    {\n+      if (!type_check (b, 4, BT_LOGICAL) || !scalar_check (b,4))\n+\treturn false;\n+\n+      /* TODO: Remove this once BACK is actually implemented.  */\n+      if (b->expr_type != EXPR_CONSTANT || b->value.logical != 0)\n+\t{\n+\t  gfc_error (\"BACK argument to %qs intrinsic not yet \"\n+\t\t     \"implemented\", gfc_current_intrinsic);\n+\t  return false;\n+\t}\n+    }\n+  else\n+    {\n+      b = gfc_get_logical_expr (gfc_default_logical_kind, NULL, 0);\n+      ap->next->next->next->next->expr = b;\n+    }\n \n   if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n       && ap->next->name == NULL)"}, {"sha": "6ddf450ad2edfa834a70e6185833a0f4b4261286", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -1999,7 +1999,7 @@ typedef union\n   bool (*f1m)(gfc_actual_arglist *);\n   bool (*f2)(struct gfc_expr *, struct gfc_expr *);\n   bool (*f3)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n-  bool (*f4ml)(gfc_actual_arglist *);\n+  bool (*f5ml)(gfc_actual_arglist *);\n   bool (*f3red)(gfc_actual_arglist *);\n   bool (*f4)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t    struct gfc_expr *);\n@@ -2915,6 +2915,8 @@ extern int gfc_size_kind;\n extern int gfc_numeric_storage_size;\n extern int gfc_character_storage_size;\n \n+#define gfc_logical_4_kind 4\n+\n /* symbol.c */\n void gfc_clear_new_implicit (void);\n bool gfc_add_new_implicit_range (int, int);"}, {"sha": "4844cee0c34660b37d309e38c1d8c8accd2ed9cb", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -687,29 +687,33 @@ add_sym_3 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n    might have to be reordered.  */\n \n static void\n-add_sym_4ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n+add_sym_5ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t     int kind, int standard,\n \t     bool (*check) (gfc_actual_arglist *),\n-\t     gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n-\t     void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t     gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t\t    gfc_expr *, gfc_expr *),\n+\t     void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t      gfc_expr *, gfc_expr *),\n \t     const char *a1, bt type1, int kind1, int optional1,\n \t     const char *a2, bt type2, int kind2, int optional2,\n \t     const char *a3, bt type3, int kind3, int optional3,\n-\t     const char *a4, bt type4, int kind4, int optional4)\n+\t     const char *a4, bt type4, int kind4, int optional4,\n+\t     const char *a5, bt type5, int kind5, int optional5)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n   gfc_resolve_f rf;\n \n-  cf.f4ml = check;\n-  sf.f4 = simplify;\n-  rf.f4 = resolve;\n+  cf.f5ml = check;\n+  sf.f5 = simplify;\n+  rf.f5 = resolve;\n \n   add_sym (name, id, cl, actual_ok, type, kind, standard, cf, sf, rf,\n \t   a1, type1, kind1, optional1, INTENT_IN,\n \t   a2, type2, kind2, optional2, INTENT_IN,\n \t   a3, type3, kind3, optional3, INTENT_IN,\n \t   a4, type4, kind4, optional4, INTENT_IN,\n+\t   a5, type5, kind5, optional5, INTENT_IN,\n \t   (void *) 0);\n }\n \n@@ -1242,7 +1246,7 @@ add_functions (void)\n     *num = \"number\", *tm = \"time\", *nm = \"name\", *md = \"mode\",\n     *vl = \"values\", *p1 = \"path1\", *p2 = \"path2\", *com = \"command\",\n     *ca = \"coarray\", *sub = \"sub\", *dist = \"distance\", *failed=\"failed\",\n-    *c_ptr_1 = \"c_ptr_1\", *c_ptr_2 = \"c_ptr_2\";\n+    *c_ptr_1 = \"c_ptr_1\", *c_ptr_2 = \"c_ptr_2\", *back = \"back\";\n \n   int di, dr, dd, dl, dc, dz, ii;\n \n@@ -2457,10 +2461,11 @@ add_functions (void)\n \n   make_generic (\"maxexponent\", GFC_ISYM_MAXEXPONENT, GFC_STD_F95);\n \n-  add_sym_4ml (\"maxloc\", GFC_ISYM_MAXLOC, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n+  add_sym_5ml (\"maxloc\", GFC_ISYM_MAXLOC, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n \t       gfc_check_minloc_maxloc, gfc_simplify_maxloc, gfc_resolve_maxloc,\n \t       ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n-\t       msk, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n+\t       msk, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL,\n+\t       back, BT_LOGICAL, dl, OPTIONAL);\n \n   make_generic (\"maxloc\", GFC_ISYM_MAXLOC, GFC_STD_F95);\n \n@@ -2533,11 +2538,12 @@ add_functions (void)\n \n   make_generic (\"minexponent\", GFC_ISYM_MINEXPONENT, GFC_STD_F95);\n \n-  add_sym_4ml (\"minloc\", GFC_ISYM_MINLOC, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n+  add_sym_5ml (\"minloc\", GFC_ISYM_MINLOC, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n \t       gfc_check_minloc_maxloc, gfc_simplify_minloc, gfc_resolve_minloc,\n \t       ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n-\t       msk, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n-\n+\t       msk, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL,\n+\t       back, BT_LOGICAL, dl, OPTIONAL);\n+\t       \n   make_generic (\"minloc\", GFC_ISYM_MINLOC, GFC_STD_F95);\n \n   add_sym_3red (\"minval\", GFC_ISYM_MINVAL, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n@@ -4500,7 +4506,7 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n   if (!do_ts29113_check (specific, *ap))\n     return false;\n \n-  if (specific->check.f4ml == gfc_check_minloc_maxloc)\n+  if (specific->check.f5ml == gfc_check_minloc_maxloc)\n     /* This is special because we might have to reorder the argument list.  */\n     t = gfc_check_minloc_maxloc (*ap);\n   else if (specific->check.f3red == gfc_check_minval_maxval)"}, {"sha": "7615dd1e6115a2ee9785aacfe51e68158a18a885", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -348,10 +348,12 @@ gfc_expr *gfc_simplify_maskr (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_min (gfc_expr *);\n-gfc_expr *gfc_simplify_minloc (gfc_expr*, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_minloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t       gfc_expr *);\n gfc_expr *gfc_simplify_minval (gfc_expr *, gfc_expr*, gfc_expr*);\n gfc_expr *gfc_simplify_max (gfc_expr *);\n-gfc_expr *gfc_simplify_maxloc (gfc_expr*, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_maxloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t       gfc_expr *);\n gfc_expr *gfc_simplify_maxval (gfc_expr *, gfc_expr*, gfc_expr*);\n gfc_expr *gfc_simplify_maxexponent (gfc_expr *);\n gfc_expr *gfc_simplify_minexponent (gfc_expr *);\n@@ -540,15 +542,15 @@ void gfc_resolve_logical (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_lstat (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_matmul (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_max (gfc_expr *, gfc_actual_arglist *);\n-void gfc_resolve_maxloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_maxloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_maxval (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_mclock (gfc_expr *);\n void gfc_resolve_mclock8 (gfc_expr *);\n void gfc_resolve_mask (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_merge (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_min (gfc_expr *, gfc_actual_arglist *);\n-void gfc_resolve_minloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_minloc (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_minval (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_mod (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_modulo (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "9a4e199d01e4d3d941014512c23913cf4341b137", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -1697,7 +1697,7 @@ gfc_resolve_max (gfc_expr *f, gfc_actual_arglist *args)\n \n void\n gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n-\t\t    gfc_expr *mask, gfc_expr *kind)\n+\t\t    gfc_expr *mask, gfc_expr *kind, gfc_expr *back)\n {\n   const char *name;\n   int i, j, idim;\n@@ -1781,6 +1781,15 @@ gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n       ts.kind = fkind;\n       gfc_convert_type_warn (f, &ts, 2, 0);\n     }\n+\n+  if (back->ts.kind != gfc_logical_4_kind)\n+    {\n+      gfc_typespec ts;\n+      gfc_clear_ts (&ts);\n+      ts.type = BT_LOGICAL;\n+      ts.kind = gfc_logical_4_kind;\n+      gfc_convert_type_warn (back, &ts, 2, 0);\n+    }\n }\n \n \n@@ -1907,7 +1916,7 @@ gfc_resolve_min (gfc_expr *f, gfc_actual_arglist *args)\n \n void\n gfc_resolve_minloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n-\t\t    gfc_expr *mask, gfc_expr *kind)\n+\t\t    gfc_expr *mask, gfc_expr *kind, gfc_expr *back)\n {\n   const char *name;\n   int i, j, idim;\n@@ -1986,6 +1995,15 @@ gfc_resolve_minloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n       ts.kind = fkind;\n       gfc_convert_type_warn (f, &ts, 2, 0);\n     }\n+\n+  if (back->ts.kind != gfc_logical_4_kind)\n+    {\n+      gfc_typespec ts;\n+      gfc_clear_ts (&ts);\n+      ts.type = BT_LOGICAL;\n+      ts.kind = gfc_logical_4_kind;\n+      gfc_convert_type_warn (back, &ts, 2, 0);\n+    }\n }\n \n "}, {"sha": "b7c6b02081f874caef7dbe15313bcd2dd6273305", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -5343,13 +5343,15 @@ gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n }\n \n gfc_expr *\n-gfc_simplify_minloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind)\n+gfc_simplify_minloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind,\n+\t\t     gfc_expr *back ATTRIBUTE_UNUSED)\n {\n   return gfc_simplify_minmaxloc (array, dim, mask, kind, -1);\n }\n \n gfc_expr *\n-gfc_simplify_maxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind)\n+gfc_simplify_maxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind,\n+\t\t     gfc_expr *back ATTRIBUTE_UNUSED)\n {\n   return gfc_simplify_minmaxloc (array, dim, mask, kind, 1);\n }"}, {"sha": "f4defb079b400d89444811e0c7153fe8497c1727", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -4562,36 +4562,42 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   tree pos;\n   int n;\n \n+  actual = expr->value.function.actual;\n+\n+  /* The last argument, BACK, is passed by value. Ensure that\n+     by setting its name to %VAL. */\n+  for (gfc_actual_arglist *a = actual; a; a = a->next)\n+    {\n+      if (a->next == NULL)\n+\ta->name = \"%VAL\";\n+    }\n+\n   if (se->ss)\n     {\n       gfc_conv_intrinsic_funcall (se, expr);\n       return;\n     }\n \n-  actual = expr->value.function.actual;\n   arrayexpr = actual->expr;\n \n   /* Special case for character maxloc.  Remove unneeded actual\n      arguments, then call a library function.  */\n   \n   if (arrayexpr->ts.type == BT_CHARACTER)\n     {\n-      gfc_actual_arglist *a2, *a3, *a4;\n-      a2 = actual->next;\n-      a3 = a2->next;\n-      a4 = a3->next;\n-      a4->next = NULL;\n-      if (a3->expr == NULL)\n-\t{\n-\t  actual->next = NULL;\n-\t  gfc_free_actual_arglist (a2);\n-\t}\n-      else\n+      gfc_actual_arglist *a, *b;\n+      a = actual;\n+      while (a->next)\n \t{\n-\t  actual->next = a3;  /* dim */\n-\t  a3->next = NULL;\n-\t  a2->next = a4;\n-\t  gfc_free_actual_arglist (a4);\n+\t  b = a->next;\n+\t  if (b->expr == NULL || strcmp (b->name, \"dim\") == 0)\n+\t    {\n+\t      a->next = b->next;\n+\t      b->next = NULL;\n+\t      gfc_free_actual_arglist (b);\n+\t    }\n+\t  else\n+\t    a = b;\n \t}\n       gfc_conv_intrinsic_funcall (se, expr);\n       return;\n@@ -8647,6 +8653,14 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \t      conv_generic_with_optional_char_arg (se, expr, 1, 3);\n \t      break;\n \n+\t    case GFC_ISYM_MINLOC:\n+\t      gfc_conv_intrinsic_minmaxloc (se, expr, LT_EXPR);\n+\t      break;\n+\t      \n+\t    case GFC_ISYM_MAXLOC:\n+\t      gfc_conv_intrinsic_minmaxloc (se, expr, GT_EXPR);\n+\t      break;\n+\n \t    default:\n \t      gfc_conv_intrinsic_funcall (se, expr);\n \t      break;"}, {"sha": "382ec746bd7dcb140105909bfb1fb1d9ffc37950", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -1,3 +1,10 @@\n+2018-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* gfortran.dg/minmaxloc_9.f90: New test.\n+\t* gfortran.dg/minmaxloc_10.f90: New test.\n+\t* gfortran.dg/minmaxloc_11.f90: New test.\n+\n 2018-01-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/83839"}, {"sha": "932a40be266245efd3832f81c325f441ea8bc9ed", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_10.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_10.f90?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -0,0 +1,118 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdefault-integer-8\" }\n+! Check max/minloc with eight-bytes logicals.\n+!\n+program test\n+  implicit none\n+  integer :: i(1), j(-1:1), res(1)\n+  logical, volatile :: m(3), m2(3)\n+  m = (/ .false., .false., .false. /)\n+  m2 = (/ .false., .true., .false. /)\n+  call check(1, 0, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=.FALSE.))\n+  call check(2, 0, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=m))\n+  call check(3, 2, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=m2))\n+  call check(4, 0, MAXLOC(i(1:0), DIM=1, MASK=.TRUE.))\n+  call check(5, 0, MAXLOC(i(1:0), DIM=1, MASK=.FALSE.))\n+  call check(6, 0, MAXLOC(i(1:0), DIM=1, MASK=m(1:0)))\n+  call check(7, 0, MAXLOC(i(1:0), DIM=1))\n+  call check(8, 0, MINLOC((/ 42, 23, 11 /), DIM=1, MASK=.FALSE.))\n+  call check(9, 0, MINLOC((/ 42, 23, 11 /), DIM=1, MASK=m))\n+  call check(10, 0, MINLOC(i(1:0), DIM=1, MASK=.FALSE.))\n+  call check(11,0, MINLOC(i(1:0), DIM=1, MASK=m(1:0)))\n+  call check(12,0, MINLOC(i(1:0), DIM=1, MASK=.TRUE.))\n+  call check(13,0, MINLOC(i(1:0), DIM=1))\n+\n+  j = (/ 1, 2, 1 /); call check(14, 2, MAXLOC(j, DIM=1))\n+  j = (/ 1, 2, 3 /); call check(15, 3, MAXLOC(j, DIM=1))\n+  j = (/ 3, 2, 1 /); call check(16, 1, MAXLOC(j, DIM=1))\n+  j = (/ 1, 2, 1 /); call check(17, 1, MINLOC(j, DIM=1))\n+  j = (/ 1, 2, 3 /); call check(18, 1, MINLOC(j, DIM=1))\n+  j = (/ 3, 2, 1 /); call check(19, 3, MINLOC(j, DIM=1))\n+\n+  j = (/ 1, 2, 1 /); call check(20, 2, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 3 /); call check(21, 3, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 3, 2, 1 /); call check(22, 1, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 1 /); call check(23, 1, MINLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 3 /); call check(24, 1, MINLOC(j, DIM=1,mask=.true.))\n+  j = (/ 3, 2, 1 /); call check(25, 3, MINLOC(j, DIM=1,mask=.true.))\n+\n+  j = (/ 1, 2, 1 /); call check(26, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 3 /); call check(27, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 3, 2, 1 /); call check(28, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 1 /); call check(29, 0, MINLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 3 /); call check(30, 0, MINLOC(j, DIM=1,mask=.false.))\n+  j = (/ 3, 2, 1 /); call check(31, 0, MINLOC(j, DIM=1,mask=.false.))\n+\n+  j = (/ 1, 2, 1 /); call check(32, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 3 /); call check(33, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 3, 2, 1 /); call check(34, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 1 /); call check(35, 0, MINLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 3 /); call check(36, 0, MINLOC(j, DIM=1,mask=m))\n+  j = (/ 3, 2, 1 /); call check(37, 0, MINLOC(j, DIM=1,mask=m))\n+\n+  j = (/ 1, 2, 1 /); call check(38, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 3 /); call check(39, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 3, 2, 1 /); call check(40, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 1 /); call check(41, 2, MINLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 3 /); call check(42, 2, MINLOC(j, DIM=1,mask=m2))\n+  j = (/ 3, 2, 1 /); call check(43, 2, MINLOC(j, DIM=1,mask=m2))\n+\n+! Check the library minloc and maxloc\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=.FALSE.); call check(44, 0,  res(1))\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=m); call check(45, 0,  res(1))\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=m2); call check(46, 2,  res(1))\n+  res = MAXLOC(i(1:0), MASK=.TRUE.); call check(47, 0,  res(1))\n+  res = MAXLOC(i(1:0), MASK=.FALSE.); call check(48, 0,  res(1))\n+  res = MAXLOC(i(1:0), MASK=m(1:0)); call check(49, 0,  res(1))\n+  res = MAXLOC(i(1:0)); call check(50, 0,  res(1))\n+  res = MINLOC((/ 42, 23, 11 /), MASK=.FALSE.); call check(51, 0, res(1))\n+  res = MINLOC((/ 42, 23, 11 /), MASK=m); call check(52, 0, res(1))\n+  res = MINLOC(i(1:0), MASK=.FALSE.); call check(53, 0, res(1))\n+  res = MINLOC(i(1:0), MASK=m(1:0)); call check(54,0, res(1))\n+  res = MINLOC(i(1:0), MASK=.TRUE.); call check(55,0, res(1))\n+  res = MINLOC(i(1:0)); call check(56,0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j); call check(57, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j); call check(58, 3,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j); call check(59, 1,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j); call check(60, 1, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j); call check(61, 1, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j); call check(62, 3, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=.true.); call check(63, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=.true.); call check(65, 3,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=.true.); call check(66, 1,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=.true.); call check(67, 1, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=.true.); call check(68, 1, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=.true.); call check(69, 3, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=.false.); call check(70, 0,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=.false.); call check(71, 0,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=.false.); call check(72, 0,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=.false.); call check(73, 0, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=.false.); call check(74, 0, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=.false.); call check(75, 0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=m); call check(76, 0,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=m); call check(77, 0,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=m); call check(78, 0,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=m); call check(79, 0, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=m); call check(80, 0, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=m);call check(81, 0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=m2); call check(82, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=m2); call check(83, 2,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=m2); call check(84, 2,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=m2); call check(85, 2, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=m2); call check(86, 2, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=m2); call check(87, 2, res(1))\n+\n+contains\n+subroutine check(n, i,j)\n+  integer, value, intent(in) :: i,j,n\n+  if(i /= j) then\n+     call abort()\n+!    print *, 'ERROR: Test',n,' expected ',i,' received ', j\n+  end if\n+end subroutine check\n+end program"}, {"sha": "1ab8eb11d73847ca04fcb0146eddb34d8094347e", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_11.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_11.f90?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do run }\n+program main\n+  character(len=3), dimension(2) :: a\n+  a(1) = 'aaa'\n+  a(2) = 'bbb'\n+  if (maxloc(a,dim=1) /= 2) call abort\n+  if (minloc(a,dim=1) /= 1) call abort\n+\n+end program main"}, {"sha": "badadac625c69a76488080c5a25f47e965f05f98", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_9.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_9.f90?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! Check for a few restrictions on the back argument to\n+! minloc and maxloc.\n+program main\n+  integer, dimension(3) :: a\n+  a = [1,2,3]\n+  print *,minloc(a,back=42) ! { dg-error \"must be LOGICAL\" }\n+  print *,minloc(a,back=[.true.,.false.]) ! { dg-error \"must be a scalar\" }\n+  print *,maxloc(a,back=42) ! { dg-error \"must be LOGICAL\" }\n+  print *,maxloc(a,back=[.true.,.false.]) ! { dg-error \"must be a scalar\" }\n+end program main"}, {"sha": "55b087f22ee3244308a104129b8a2ee016e6a5ae", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -1,3 +1,225 @@\n+2018-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* m4/iparm.m4: Add back_arg macro if in minloc or maxloc.\n+\t* m4/iforeach-s.m4: Add optional argument back with back_arg\n+\tmacro. Improve m4 quoting. If HAVE_BACK_ARG is defined, assert\n+\tthat back is non-true.\n+\t* m4/iforeach.m4: Likewise.\n+\t* m4/ifunction-s.m4: Likewise.\n+\t* m4/ifunction.m4: Likewise.\n+\t* m4/maxloc0.m4: Include assert.h\n+\t* m4/minloc0.m4: Likewise.\n+\t* m4/maxloc0s.m4: #define HAVE_BACK_ARG.\n+\t* m4/minloc0s.m4: Likewise.\n+\t* m4/maxloc1s.m4: Likewise.\n+\t* m4/minloc1s.m4: Likewise.\n+\t* m4/maxloc1.m4: Include assert.h, #define HAVE_BACK_ARG.\n+\t* m4/minloc1.m4: Likewise.\n+\t* m4/maxloc2s.m4: Add assert.h, add back_arg, assert that\n+\tback is non-true.\n+\t* m4/minloc2s.m4: Likewise.\n+\t* generated/iall_i1.c: Regenerated.\n+\t* generated/iall_i16.c: Regenerated.\n+\t* generated/iall_i2.c: Regenerated.\n+\t* generated/iall_i4.c: Regenerated.\n+\t* generated/iall_i8.c: Regenerated.\n+\t* generated/iany_i1.c: Regenerated.\n+\t* generated/iany_i16.c: Regenerated.\n+\t* generated/iany_i2.c: Regenerated.\n+\t* generated/iany_i4.c: Regenerated.\n+\t* generated/iany_i8.c: Regenerated.\n+\t* generated/iparity_i1.c: Regenerated.\n+\t* generated/iparity_i16.c: Regenerated.\n+\t* generated/iparity_i2.c: Regenerated.\n+\t* generated/iparity_i4.c: Regenerated.\n+\t* generated/iparity_i8.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Regenerated.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i2.c: Regenerated.\n+\t* generated/maxloc0_16_i4.c: Regenerated.\n+\t* generated/maxloc0_16_i8.c: Regenerated.\n+\t* generated/maxloc0_16_r10.c: Regenerated.\n+\t* generated/maxloc0_16_r16.c: Regenerated.\n+\t* generated/maxloc0_16_r4.c: Regenerated.\n+\t* generated/maxloc0_16_r8.c: Regenerated.\n+\t* generated/maxloc0_16_s1.c: Regenerated.\n+\t* generated/maxloc0_16_s4.c: Regenerated.\n+\t* generated/maxloc0_4_i1.c: Regenerated.\n+\t* generated/maxloc0_4_i16.c: Regenerated.\n+\t* generated/maxloc0_4_i2.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc0_4_r10.c: Regenerated.\n+\t* generated/maxloc0_4_r16.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/maxloc0_4_s1.c: Regenerated.\n+\t* generated/maxloc0_4_s4.c: Regenerated.\n+\t* generated/maxloc0_8_i1.c: Regenerated.\n+\t* generated/maxloc0_8_i16.c: Regenerated.\n+\t* generated/maxloc0_8_i2.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r10.c: Regenerated.\n+\t* generated/maxloc0_8_r16.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/maxloc0_8_s1.c: Regenerated.\n+\t* generated/maxloc0_8_s4.c: Regenerated.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_16_s1.c: Regenerated.\n+\t* generated/maxloc1_16_s4.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_4_s1.c: Regenerated.\n+\t* generated/maxloc1_4_s4.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxloc1_8_s1.c: Regenerated.\n+\t* generated/maxloc1_8_s4.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc0_16_i1.c: Regenerated.\n+\t* generated/minloc0_16_i16.c: Regenerated.\n+\t* generated/minloc0_16_i2.c: Regenerated.\n+\t* generated/minloc0_16_i4.c: Regenerated.\n+\t* generated/minloc0_16_i8.c: Regenerated.\n+\t* generated/minloc0_16_r10.c: Regenerated.\n+\t* generated/minloc0_16_r16.c: Regenerated.\n+\t* generated/minloc0_16_r4.c: Regenerated.\n+\t* generated/minloc0_16_r8.c: Regenerated.\n+\t* generated/minloc0_16_s1.c: Regenerated.\n+\t* generated/minloc0_16_s4.c: Regenerated.\n+\t* generated/minloc0_4_i1.c: Regenerated.\n+\t* generated/minloc0_4_i16.c: Regenerated.\n+\t* generated/minloc0_4_i2.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minloc0_4_r10.c: Regenerated.\n+\t* generated/minloc0_4_r16.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\t* generated/minloc0_4_s1.c: Regenerated.\n+\t* generated/minloc0_4_s4.c: Regenerated.\n+\t* generated/minloc0_8_i1.c: Regenerated.\n+\t* generated/minloc0_8_i16.c: Regenerated.\n+\t* generated/minloc0_8_i2.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/minloc0_8_r10.c: Regenerated.\n+\t* generated/minloc0_8_r16.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/minloc0_8_s1.c: Regenerated.\n+\t* generated/minloc0_8_s4.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_16_s1.c: Regenerated.\n+\t* generated/minloc1_16_s4.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_4_s1.c: Regenerated.\n+\t* generated/minloc1_4_s4.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minloc1_8_s1.c: Regenerated.\n+\t* generated/minloc1_8_s4.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/norm2_r10.c: Regenerated.\n+\t* generated/norm2_r16.c: Regenerated.\n+\t* generated/norm2_r4.c: Regenerated.\n+\t* generated/norm2_r8.c: Regenerated.\n+\t* generated/parity_l1.c: Regenerated.\n+\t* generated/parity_l16.c: Regenerated.\n+\t* generated/parity_l2.c: Regenerated.\n+\t* generated/parity_l4.c: Regenerated.\n+\t* generated/parity_l8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\n 2018-01-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/83811"}, {"sha": "a171ed210530f92a27fcce0b55edf938022d4564", "filename": "libgfortran/generated/iall_i1.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iall_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miall_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siall_i1 (gfc_array_i1 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iall_i1 (retarray, array, pdim, back);\n+#else\n       iall_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "80c89e828dd835658ae64caed13c1442fd2c8bc4", "filename": "libgfortran/generated/iall_i16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iall_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miall_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siall_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iall_i16 (retarray, array, pdim, back);\n+#else\n       iall_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "618b02479b27110e7a412ade4cba30929591c9ba", "filename": "libgfortran/generated/iall_i2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iall_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miall_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siall_i2 (gfc_array_i2 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iall_i2 (retarray, array, pdim, back);\n+#else\n       iall_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "808e073003d17335d35f9321beb65da0245cf73e", "filename": "libgfortran/generated/iall_i4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iall_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miall_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siall_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iall_i4 (retarray, array, pdim, back);\n+#else\n       iall_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "c487b6cacfb21142cc0d782c2842aba13467f8f5", "filename": "libgfortran/generated/iall_i8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiall_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iall_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miall_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siall_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iall_i8 (retarray, array, pdim, back);\n+#else\n       iall_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "0890eed633ab58099f233ffb7a7cf615bec598f1", "filename": "libgfortran/generated/iany_i1.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iany_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miany_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siany_i1 (gfc_array_i1 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iany_i1 (retarray, array, pdim, back);\n+#else\n       iany_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "126db338d3374bf231f99e8b9184353d1d55d2a7", "filename": "libgfortran/generated/iany_i16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iany_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miany_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siany_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iany_i16 (retarray, array, pdim, back);\n+#else\n       iany_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "3a26b2ced8422945a8dd4ecb36067aba5bba8d1d", "filename": "libgfortran/generated/iany_i2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iany_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miany_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siany_i2 (gfc_array_i2 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iany_i2 (retarray, array, pdim, back);\n+#else\n       iany_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "8b81d001be104679f9019f587ea219cb6477fba5", "filename": "libgfortran/generated/iany_i4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iany_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miany_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siany_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iany_i4 (retarray, array, pdim, back);\n+#else\n       iany_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9ffc9b6c89ae1d75072264d12f1477f4ea3363bd", "filename": "libgfortran/generated/iany_i8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiany_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iany_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miany_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siany_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iany_i8 (retarray, array, pdim, back);\n+#else\n       iany_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b4d4240291c7287c002c07902556a1dc8e577fc0", "filename": "libgfortran/generated/iparity_i1.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iparity_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miparity_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siparity_i1 (gfc_array_i1 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iparity_i1 (retarray, array, pdim, back);\n+#else\n       iparity_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "96cb108b0eed4a7d6885f027f92cd880d7797bfb", "filename": "libgfortran/generated/iparity_i16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iparity_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miparity_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siparity_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iparity_i16 (retarray, array, pdim, back);\n+#else\n       iparity_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b077f29c3811f93430a50d1f1ae41293d5bfbfc3", "filename": "libgfortran/generated/iparity_i2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iparity_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miparity_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siparity_i2 (gfc_array_i2 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iparity_i2 (retarray, array, pdim, back);\n+#else\n       iparity_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "1b5dfe0397aeaa61ea9926f31079cd5065915fcf", "filename": "libgfortran/generated/iparity_i4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iparity_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miparity_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siparity_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iparity_i4 (retarray, array, pdim, back);\n+#else\n       iparity_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "056a59bfaeaec633423a3e65b3d619812a8533ae", "filename": "libgfortran/generated/iparity_i8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fiparity_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ iparity_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ miparity_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ siparity_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      iparity_i8 (retarray, array, pdim, back);\n+#else\n       iparity_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "25398cc79892aacd7aba71a139ca8124e5ab3459", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array);\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_i1);\n \n void\n maxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array)\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_i1);\n \n void\n mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_i1);\n \n void\n smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_i1 (retarray, array);\n+      maxloc0_16_i1 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "3a4a7446274c8975c4f5a9d722cdff6148775958", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array);\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_i16);\n \n void\n maxloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array)\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_i16);\n \n void\n mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_i16);\n \n void\n smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_i16 (retarray, array);\n+      maxloc0_16_i16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "0ff8ca0b183ba81cf391b96357ac374891cf308c", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array);\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_i2);\n \n void\n maxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array)\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_i2);\n \n void\n mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_i2);\n \n void\n smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_i2 (retarray, array);\n+      maxloc0_16_i2 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "84cff67ea087252d595be140232f645a48bc5759", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array);\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_i4);\n \n void\n maxloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array)\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_i4);\n \n void\n mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_i4);\n \n void\n smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_i4 (retarray, array);\n+      maxloc0_16_i4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "e276295027b1713305894eb36d5d5a06dcdd04a3", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array);\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_i8);\n \n void\n maxloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array)\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_i8);\n \n void\n mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_i8);\n \n void\n smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_i8 (retarray, array);\n+      maxloc0_16_i8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "384487fadeb13f588ea3c9bda59d556fd639ba3e", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array);\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_r10);\n \n void\n maxloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array)\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_r10);\n \n void\n mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_r10);\n \n void\n smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_r10 (retarray, array);\n+      maxloc0_16_r10 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "10c7673f73c10f1b52ceff58489823b973073fa6", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array);\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_r16);\n \n void\n maxloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array)\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_r16);\n \n void\n mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_r16);\n \n void\n smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_r16 (retarray, array);\n+      maxloc0_16_r16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "b7aaa3d5cefd77ad43ea8c54a55e6286a856d137", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array);\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_r4);\n \n void\n maxloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array)\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_r4);\n \n void\n mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_r4);\n \n void\n smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_r4 (retarray, array);\n+      maxloc0_16_r4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "2ca3479d3f9ffe8e6e193e540c464055228fbaf0", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void maxloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array);\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_16_r8);\n \n void\n maxloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array)\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_16_r8);\n \n void\n mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_16_r8);\n \n void\n smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_16_r8 (retarray, array);\n+      maxloc0_16_r8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "a05d17893e3f03cca001272b1c83067bc1058333", "filename": "libgfortran/generated/maxloc0_16_s1.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void maxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(maxloc0_16_s1);\n \n void\n maxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ maxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ maxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_s1 (gfc_array_i16 * const restrict, \n-\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mmaxloc0_16_s1);\n \n void\n mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_s1 (gfc_array_i16 * const restrict, \n-\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(smaxloc0_16_s1);\n \n void\n smaxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ smaxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      maxloc0_16_s1 (retarray, array, back, len);\n+#else\n       maxloc0_16_s1 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "f6adf95c356e1f8fd2af8c990eeaf04974694bb9", "filename": "libgfortran/generated/maxloc0_16_s4.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void maxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(maxloc0_16_s4);\n \n void\n maxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ maxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ maxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_s4 (gfc_array_i16 * const restrict, \n-\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mmaxloc0_16_s4);\n \n void\n mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void smaxloc0_16_s4 (gfc_array_i16 * const restrict, \n-\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(smaxloc0_16_s4);\n \n void\n smaxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ smaxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      maxloc0_16_s4 (retarray, array, back, len);\n+#else\n       maxloc0_16_s4 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "dc31e1d4b6584a7b5712a69fbdff06e90f3ac75f", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array);\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_i1);\n \n void\n maxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array)\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_i1);\n \n void\n mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_i1);\n \n void\n smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_i1 (retarray, array);\n+      maxloc0_4_i1 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "f7226001282c9346f791ae5a0a8866cc6597b721", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array);\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_i16);\n \n void\n maxloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array)\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_i16);\n \n void\n mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_i16);\n \n void\n smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_i16 (retarray, array);\n+      maxloc0_4_i16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "f78e20ec405a0e6f38035484279c71a17bc2c742", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array);\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_i2);\n \n void\n maxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array)\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_i2);\n \n void\n mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_i2);\n \n void\n smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_i2 (retarray, array);\n+      maxloc0_4_i2 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "58c3cf1d4b48cad048822ac4ebe1d25d1cc1e08f", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array);\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_i4);\n \n void\n maxloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array)\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_i4);\n \n void\n mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_i4);\n \n void\n smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_i4 (retarray, array);\n+      maxloc0_4_i4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "ded9b5bcadea6b6e5d17e1b1ed2ae0698457e24b", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array);\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_i8);\n \n void\n maxloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array)\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_i8);\n \n void\n mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_i8);\n \n void\n smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_i8 (retarray, array);\n+      maxloc0_4_i8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "c64bd532380a61b0a77d1e49ac080801eae2869e", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array);\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_r10);\n \n void\n maxloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array)\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_r10);\n \n void\n mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_r10);\n \n void\n smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_r10 (retarray, array);\n+      maxloc0_4_r10 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "4fd46a3371bcd9eca7d2f31ad59eb839dbd2762d", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array);\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_r16);\n \n void\n maxloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array)\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_r16);\n \n void\n mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_r16);\n \n void\n smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_r16 (retarray, array);\n+      maxloc0_4_r16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "c168aee4d57e7c3a68f91682a27372d4174e0721", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array);\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_r4);\n \n void\n maxloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array)\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_r4);\n \n void\n mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_r4);\n \n void\n smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_r4 (retarray, array);\n+      maxloc0_4_r4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "655a6527304f56f62a7706ff596c1fe9e9075be5", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void maxloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array);\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_4_r8);\n \n void\n maxloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array)\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_4_r8);\n \n void\n mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_4_r8);\n \n void\n smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_4_r8 (retarray, array);\n+      maxloc0_4_r8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "b13a9b94146d709ca0e89b7197ba8a7a34aaf20c", "filename": "libgfortran/generated/maxloc0_4_s1.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void maxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(maxloc0_4_s1);\n \n void\n maxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ maxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ maxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_s1 (gfc_array_i4 * const restrict, \n-\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mmaxloc0_4_s1);\n \n void\n mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_s1 (gfc_array_i4 * const restrict, \n-\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(smaxloc0_4_s1);\n \n void\n smaxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ smaxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      maxloc0_4_s1 (retarray, array, back, len);\n+#else\n       maxloc0_4_s1 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "971e8680804af5d5d377364cd1808db0a12b3f5a", "filename": "libgfortran/generated/maxloc0_4_s4.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void maxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(maxloc0_4_s4);\n \n void\n maxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ maxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ maxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_s4 (gfc_array_i4 * const restrict, \n-\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mmaxloc0_4_s4);\n \n void\n mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void smaxloc0_4_s4 (gfc_array_i4 * const restrict, \n-\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(smaxloc0_4_s4);\n \n void\n smaxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ smaxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      maxloc0_4_s4 (retarray, array, back, len);\n+#else\n       maxloc0_4_s4 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "b86f0cb294670734c847d2eecd6927ce5c60c85c", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array);\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_i1);\n \n void\n maxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array)\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_i1);\n \n void\n mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_i1);\n \n void\n smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_i1 (retarray, array);\n+      maxloc0_8_i1 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "710d26097b6e6c100a441ecb5ba2bc7422e81d44", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array);\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_i16);\n \n void\n maxloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array)\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_i16);\n \n void\n mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_i16);\n \n void\n smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_i16 (retarray, array);\n+      maxloc0_8_i16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "e85fb07ab4bb4cec636172faa8223f56f93fb4bb", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array);\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_i2);\n \n void\n maxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array)\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_i2);\n \n void\n mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_i2);\n \n void\n smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_i2 (retarray, array);\n+      maxloc0_8_i2 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "bb6d51ee69aa48dcae018c4ead74059d5266bceb", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array);\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_i4);\n \n void\n maxloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array)\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_i4);\n \n void\n mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_i4);\n \n void\n smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_i4 (retarray, array);\n+      maxloc0_8_i4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "d6c6e850ed497d71b6c2dba50949b13bac702cb6", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array);\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_i8);\n \n void\n maxloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array)\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_i8);\n \n void\n mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_i8);\n \n void\n smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_i8 (retarray, array);\n+      maxloc0_8_i8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "333e57095fdc7f551b26bd25483c27938a2b5152", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array);\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_r10);\n \n void\n maxloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array)\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_r10);\n \n void\n mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_r10);\n \n void\n smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_r10 (retarray, array);\n+      maxloc0_8_r10 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "ebb3118864d29155931378d78cfc29e7edfa8b52", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array);\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_r16);\n \n void\n maxloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array)\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_r16);\n \n void\n mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_r16);\n \n void\n smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_r16 (retarray, array);\n+      maxloc0_8_r16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "afc46960059c26b5a843aff6539098f3db5b3b1e", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array);\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_r4);\n \n void\n maxloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array)\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_r4);\n \n void\n mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_r4);\n \n void\n smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_r4 (retarray, array);\n+      maxloc0_8_r4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "e6a2feffa97d692aacf38b1641e703df8feb4104", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void maxloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array);\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4);\n export_proto(maxloc0_8_r8);\n \n void\n maxloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array)\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mmaxloc0_8_r8);\n \n void\n mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(smaxloc0_8_r8);\n \n void\n smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      maxloc0_8_r8 (retarray, array);\n+      maxloc0_8_r8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "2e95fa35d1c56e0f095ff143a0359b743a460020", "filename": "libgfortran/generated/maxloc0_8_s1.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void maxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(maxloc0_8_s1);\n \n void\n maxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ maxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ maxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_s1 (gfc_array_i8 * const restrict, \n-\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mmaxloc0_8_s1);\n \n void\n mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_s1 (gfc_array_i8 * const restrict, \n-\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(smaxloc0_8_s1);\n \n void\n smaxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ smaxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      maxloc0_8_s1 (retarray, array, back, len);\n+#else\n       maxloc0_8_s1 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "5cc1f11fb852fd86172447a7d4c6a7fab8ac7e3a", "filename": "libgfortran/generated/maxloc0_8_s4.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void maxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(maxloc0_8_s4);\n \n void\n maxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ maxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ maxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_s4 (gfc_array_i8 * const restrict, \n-\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mmaxloc0_8_s4);\n \n void\n mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void smaxloc0_8_s4 (gfc_array_i8 * const restrict, \n-\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(smaxloc0_8_s4);\n \n void\n smaxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ smaxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      maxloc0_8_s4 (retarray, array, back, len);\n+#else\n       maxloc0_8_s4 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "ff2124d280322edafa1769dd270a12c7ffef970f", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+\tgfc_array_i1 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_i1);\n \n void\n maxloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_i1);\n \n void\n mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_i1);\n \n void\n smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_i1 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "2b0bd54ba8ac3e91186f8495e0f3454aec5e3af0", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+\tgfc_array_i16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_i16);\n \n void\n maxloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_i16);\n \n void\n mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_i16);\n \n void\n smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_i16 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "26c3f142b9f6837b1074574011b8b4aa097fc26f", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+\tgfc_array_i2 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_i2);\n \n void\n maxloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_i2);\n \n void\n mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_i2);\n \n void\n smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_i2 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "aedc22a1cfd9a02dd7d70f63a777dead45a15ef7", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+\tgfc_array_i4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_i4);\n \n void\n maxloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_i4);\n \n void\n mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_i4);\n \n void\n smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_i4 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "d08561d4aff1acdadf619510d63b5d97a0476150", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+\tgfc_array_i8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_i8);\n \n void\n maxloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_i8);\n \n void\n mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_i8);\n \n void\n smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_i8 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "a5929ee47e4851af246f44745d0e506d02c50c1e", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, const index_type * const restrict);\n+\tgfc_array_r10 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_r10);\n \n void\n maxloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_r10);\n \n void\n mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_r10);\n \n void\n smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_r10 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "09da74031d153f0fd8d9bc6208927e9e2e4c7468", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, const index_type * const restrict);\n+\tgfc_array_r16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_r16);\n \n void\n maxloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_r16);\n \n void\n mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_r16);\n \n void\n smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_r16 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "927830008e2e05415cc03a2da667c019c2e7e68e", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, const index_type * const restrict);\n+\tgfc_array_r4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_r4);\n \n void\n maxloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_r4);\n \n void\n mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_r4);\n \n void\n smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_r4 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "84c0c650641ac234bdfcfa92efae48721323372b", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, const index_type * const restrict);\n+\tgfc_array_r8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_16_r8);\n \n void\n maxloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_16_r8);\n \n void\n mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_16_r8);\n \n void\n smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_r8 (retarray, array, pdim, back);\n+#else\n       maxloc1_16_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "84b12f3e26ce63a1010771a3eb3f62314f2e3427", "filename": "libgfortran/generated/maxloc1_16_s1.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void maxloc1_16_s1 (gfc_array_i16 * const restrict, \n-\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_s1 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(maxloc1_16_s1);\n \n void\n maxloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ maxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ maxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_s1 (gfc_array_i16 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mmaxloc1_16_s1);\n \n void\n mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_s1 (gfc_array_i16 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc1_16_s1);\n \n void\n smaxloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ smaxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_s1 (retarray, array, pdim, back, string_len);\n+#else\n       maxloc1_16_s1 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "70696f2ac3f5765ab99639f5ebb83545f034255c", "filename": "libgfortran/generated/maxloc1_16_s4.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void maxloc1_16_s4 (gfc_array_i16 * const restrict, \n-\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_s4 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(maxloc1_16_s4);\n \n void\n maxloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ maxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ maxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_s4 (gfc_array_i16 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mmaxloc1_16_s4);\n \n void\n mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n extern void smaxloc1_16_s4 (gfc_array_i16 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc1_16_s4);\n \n void\n smaxloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ smaxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_s4 (retarray, array, pdim, back, string_len);\n+#else\n       maxloc1_16_s4 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "7fc1f88c2d9da1c40fd2ae7bd7d46cb2cba7dc48", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+\tgfc_array_i1 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_i1);\n \n void\n maxloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_i1);\n \n void\n mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_i1);\n \n void\n smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_i1 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "14b5e5578b8b11e7bcba910079f44237a25e97e2", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+\tgfc_array_i16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_i16);\n \n void\n maxloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_i16);\n \n void\n mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_i16);\n \n void\n smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_i16 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9d5a98ed341228f53fe6d8185e1dbf9d6615f76e", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+\tgfc_array_i2 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_i2);\n \n void\n maxloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_i2);\n \n void\n mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_i2);\n \n void\n smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_i2 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "23d702850f435208879e830f7af2b315ff7edba2", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+\tgfc_array_i4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_i4);\n \n void\n maxloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_i4);\n \n void\n mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_i4);\n \n void\n smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_i4 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "178a20aa2ff576d4ffc7fddeb59c6a58efd24ea7", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+\tgfc_array_i8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_i8);\n \n void\n maxloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_i8);\n \n void\n mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_i8);\n \n void\n smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_i8 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "f35961338bfcd38621ca6b14c364b6ae9539018c", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, const index_type * const restrict);\n+\tgfc_array_r10 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_r10);\n \n void\n maxloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_r10);\n \n void\n mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_r10);\n \n void\n smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_r10 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "a0f283e7cecf11310270e55ced18ef87daaa6840", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, const index_type * const restrict);\n+\tgfc_array_r16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_r16);\n \n void\n maxloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_r16);\n \n void\n mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_r16);\n \n void\n smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_r16 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "aeb4b8f106862bd19af89ba5b06f51b0dcfe3f3d", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, const index_type * const restrict);\n+\tgfc_array_r4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_r4);\n \n void\n maxloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_r4);\n \n void\n mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_r4);\n \n void\n smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_r4 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "43852049c9cd9a44b6fa8e11e9d110fb8008b55c", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, const index_type * const restrict);\n+\tgfc_array_r8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_4_r8);\n \n void\n maxloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_4_r8);\n \n void\n mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_4_r8);\n \n void\n smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_r8 (retarray, array, pdim, back);\n+#else\n       maxloc1_4_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b7b7d8cfe935e2b0a449ebad39d827d1010580fe", "filename": "libgfortran/generated/maxloc1_4_s1.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void maxloc1_4_s1 (gfc_array_i4 * const restrict, \n-\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_s1 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(maxloc1_4_s1);\n \n void\n maxloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ maxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ maxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_s1 (gfc_array_i4 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mmaxloc1_4_s1);\n \n void\n mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_s1 (gfc_array_i4 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc1_4_s1);\n \n void\n smaxloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ smaxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_s1 (retarray, array, pdim, back, string_len);\n+#else\n       maxloc1_4_s1 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "da7594993d19f4fd80611f0de0c7605b8152b4a9", "filename": "libgfortran/generated/maxloc1_4_s4.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void maxloc1_4_s4 (gfc_array_i4 * const restrict, \n-\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_s4 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(maxloc1_4_s4);\n \n void\n maxloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ maxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ maxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_s4 (gfc_array_i4 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mmaxloc1_4_s4);\n \n void\n mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n extern void smaxloc1_4_s4 (gfc_array_i4 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc1_4_s4);\n \n void\n smaxloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ smaxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_s4 (retarray, array, pdim, back, string_len);\n+#else\n       maxloc1_4_s4 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "fa5bc4aadfd347cb3afb3b76676898a2dc9350da", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+\tgfc_array_i1 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_i1);\n \n void\n maxloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_i1);\n \n void\n mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_i1);\n \n void\n smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_i1 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "2cf75312ece95e53d93b9047f518e48daa39d3d2", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+\tgfc_array_i16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_i16);\n \n void\n maxloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_i16);\n \n void\n mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_i16);\n \n void\n smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_i16 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "e32eafe2f057f1062323aa656528c0be003eef0e", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+\tgfc_array_i2 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_i2);\n \n void\n maxloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_i2);\n \n void\n mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_i2);\n \n void\n smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_i2 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "e348550787e8f7c221f634a1a9cca121db6d25d8", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+\tgfc_array_i4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_i4);\n \n void\n maxloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_i4);\n \n void\n mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_i4);\n \n void\n smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_i4 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "802b74d94612866eb44b58c5ecb550a768f040d1", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+\tgfc_array_i8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_i8);\n \n void\n maxloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_i8);\n \n void\n mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_i8);\n \n void\n smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_i8 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "bc5f1b1af2c0496fe8656d5d83db00ee68199bb1", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, const index_type * const restrict);\n+\tgfc_array_r10 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_r10);\n \n void\n maxloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_r10);\n \n void\n mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_r10);\n \n void\n smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_r10 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "54d12030c11345d6d50d3e54df6576be51043065", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, const index_type * const restrict);\n+\tgfc_array_r16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_r16);\n \n void\n maxloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_r16);\n \n void\n mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_r16);\n \n void\n smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_r16 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "5895585c403691b6ca5cec5c9d2c7c54a4c57849", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, const index_type * const restrict);\n+\tgfc_array_r4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_r4);\n \n void\n maxloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_r4);\n \n void\n mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_r4);\n \n void\n smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_r4 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "8c79dd46ab072cc3bff640e927ec0c0f998474fd", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void maxloc1_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, const index_type * const restrict);\n+\tgfc_array_r8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(maxloc1_8_r8);\n \n void\n maxloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mmaxloc1_8_r8);\n \n void\n mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(smaxloc1_8_r8);\n \n void\n smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_r8 (retarray, array, pdim, back);\n+#else\n       maxloc1_8_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "aab24491ba9ddc7768943553aff8a9a3f80d7c26", "filename": "libgfortran/generated/maxloc1_8_s1.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void maxloc1_8_s1 (gfc_array_i8 * const restrict, \n-\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_s1 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(maxloc1_8_s1);\n \n void\n maxloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ maxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ maxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_s1 (gfc_array_i8 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mmaxloc1_8_s1);\n \n void\n mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_s1 (gfc_array_i8 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc1_8_s1);\n \n void\n smaxloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ smaxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_s1 (retarray, array, pdim, back, string_len);\n+#else\n       maxloc1_8_s1 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "f02e2a545260f6496ee4e766a4c86e95ab1303ba", "filename": "libgfortran/generated/maxloc1_8_s4.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void maxloc1_8_s4 (gfc_array_i8 * const restrict, \n-\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_s4 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(maxloc1_8_s4);\n \n void\n maxloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ maxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ maxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_s4 (gfc_array_i8 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mmaxloc1_8_s4);\n \n void\n mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n extern void smaxloc1_8_s4 (gfc_array_i8 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc1_8_s4);\n \n void\n smaxloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ smaxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_s4 (retarray, array, pdim, back, string_len);\n+#else\n       maxloc1_8_s4 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "bfba7074bccb08d2c5851c4e0d6d746187d258c0", "filename": "libgfortran/generated/maxloc2_16_s1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n@@ -38,12 +39,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_16 maxloc2_16_s1 (gfc_array_s1 * const restrict,\n+extern GFC_INTEGER_16 maxloc2_16_s1 (gfc_array_s1 * const restrict, GFC_LOGICAL_4 back,\n        gfc_charlen_type);\n export_proto(maxloc2_16_s1);\n \n GFC_INTEGER_16\n-maxloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+maxloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -52,6 +53,7 @@ maxloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -74,12 +76,13 @@ maxloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_16 mmaxloc2_16_s1 (gfc_array_s1 * const restrict,\n-       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+       \t\t    \tgfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\tgfc_charlen_type);\n export_proto(mmaxloc2_16_s1);\n \n GFC_INTEGER_16\n mmaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n \t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n@@ -92,6 +95,7 @@ mmaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -141,15 +145,15 @@ mmaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n }\n \n extern GFC_INTEGER_16 smaxloc2_16_s1 (gfc_array_s1 * const restrict,\n-                               GFC_LOGICAL_4 *mask, gfc_charlen_type);\n+                               GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc2_16_s1);\n \n GFC_INTEGER_16\n smaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return maxloc2_16_s1 (array, len);\n+    return maxloc2_16_s1 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "cf1235e92c9bce349cd952080a9abdbdef7b3beb", "filename": "libgfortran/generated/maxloc2_16_s4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n@@ -38,12 +39,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_16 maxloc2_16_s4 (gfc_array_s4 * const restrict,\n+extern GFC_INTEGER_16 maxloc2_16_s4 (gfc_array_s4 * const restrict, GFC_LOGICAL_4 back,\n        gfc_charlen_type);\n export_proto(maxloc2_16_s4);\n \n GFC_INTEGER_16\n-maxloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+maxloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -52,6 +53,7 @@ maxloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -74,12 +76,13 @@ maxloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_16 mmaxloc2_16_s4 (gfc_array_s4 * const restrict,\n-       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+       \t\t    \tgfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\tgfc_charlen_type);\n export_proto(mmaxloc2_16_s4);\n \n GFC_INTEGER_16\n mmaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n \t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n@@ -92,6 +95,7 @@ mmaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -141,15 +145,15 @@ mmaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n }\n \n extern GFC_INTEGER_16 smaxloc2_16_s4 (gfc_array_s4 * const restrict,\n-                               GFC_LOGICAL_4 *mask, gfc_charlen_type);\n+                               GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc2_16_s4);\n \n GFC_INTEGER_16\n smaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return maxloc2_16_s4 (array, len);\n+    return maxloc2_16_s4 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "e88ecca6eb43a9ec18522032b4aecf59a82f5575", "filename": "libgfortran/generated/maxloc2_4_s1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n@@ -38,12 +39,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_4 maxloc2_4_s1 (gfc_array_s1 * const restrict,\n+extern GFC_INTEGER_4 maxloc2_4_s1 (gfc_array_s1 * const restrict, GFC_LOGICAL_4 back,\n        gfc_charlen_type);\n export_proto(maxloc2_4_s1);\n \n GFC_INTEGER_4\n-maxloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+maxloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -52,6 +53,7 @@ maxloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -74,12 +76,13 @@ maxloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_4 mmaxloc2_4_s1 (gfc_array_s1 * const restrict,\n-       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+       \t\t    \tgfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\tgfc_charlen_type);\n export_proto(mmaxloc2_4_s1);\n \n GFC_INTEGER_4\n mmaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n \t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n@@ -92,6 +95,7 @@ mmaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -141,15 +145,15 @@ mmaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n }\n \n extern GFC_INTEGER_4 smaxloc2_4_s1 (gfc_array_s1 * const restrict,\n-                               GFC_LOGICAL_4 *mask, gfc_charlen_type);\n+                               GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc2_4_s1);\n \n GFC_INTEGER_4\n smaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return maxloc2_4_s1 (array, len);\n+    return maxloc2_4_s1 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "adeba9321ec26bd411603f7443b3ab405322f4ec", "filename": "libgfortran/generated/maxloc2_4_s4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n@@ -38,12 +39,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_4 maxloc2_4_s4 (gfc_array_s4 * const restrict,\n+extern GFC_INTEGER_4 maxloc2_4_s4 (gfc_array_s4 * const restrict, GFC_LOGICAL_4 back,\n        gfc_charlen_type);\n export_proto(maxloc2_4_s4);\n \n GFC_INTEGER_4\n-maxloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+maxloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -52,6 +53,7 @@ maxloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -74,12 +76,13 @@ maxloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_4 mmaxloc2_4_s4 (gfc_array_s4 * const restrict,\n-       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+       \t\t    \tgfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\tgfc_charlen_type);\n export_proto(mmaxloc2_4_s4);\n \n GFC_INTEGER_4\n mmaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n \t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n@@ -92,6 +95,7 @@ mmaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -141,15 +145,15 @@ mmaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n }\n \n extern GFC_INTEGER_4 smaxloc2_4_s4 (gfc_array_s4 * const restrict,\n-                               GFC_LOGICAL_4 *mask, gfc_charlen_type);\n+                               GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc2_4_s4);\n \n GFC_INTEGER_4\n smaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return maxloc2_4_s4 (array, len);\n+    return maxloc2_4_s4 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "1a32e13949aa3864c8a9f5339d52f72b5f78e2fc", "filename": "libgfortran/generated/maxloc2_8_s1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n@@ -38,12 +39,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_8 maxloc2_8_s1 (gfc_array_s1 * const restrict,\n+extern GFC_INTEGER_8 maxloc2_8_s1 (gfc_array_s1 * const restrict, GFC_LOGICAL_4 back,\n        gfc_charlen_type);\n export_proto(maxloc2_8_s1);\n \n GFC_INTEGER_8\n-maxloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+maxloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -52,6 +53,7 @@ maxloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -74,12 +76,13 @@ maxloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_8 mmaxloc2_8_s1 (gfc_array_s1 * const restrict,\n-       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+       \t\t    \tgfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\tgfc_charlen_type);\n export_proto(mmaxloc2_8_s1);\n \n GFC_INTEGER_8\n mmaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n \t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n@@ -92,6 +95,7 @@ mmaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -141,15 +145,15 @@ mmaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n }\n \n extern GFC_INTEGER_8 smaxloc2_8_s1 (gfc_array_s1 * const restrict,\n-                               GFC_LOGICAL_4 *mask, gfc_charlen_type);\n+                               GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc2_8_s1);\n \n GFC_INTEGER_8\n smaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return maxloc2_8_s1 (array, len);\n+    return maxloc2_8_s1 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "ae22a51c52748b8d4ff245dc6b299a7d6fe88566", "filename": "libgfortran/generated/maxloc2_8_s4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n@@ -38,12 +39,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_8 maxloc2_8_s4 (gfc_array_s4 * const restrict,\n+extern GFC_INTEGER_8 maxloc2_8_s4 (gfc_array_s4 * const restrict, GFC_LOGICAL_4 back,\n        gfc_charlen_type);\n export_proto(maxloc2_8_s4);\n \n GFC_INTEGER_8\n-maxloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+maxloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -52,6 +53,7 @@ maxloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -74,12 +76,13 @@ maxloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_8 mmaxloc2_8_s4 (gfc_array_s4 * const restrict,\n-       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+       \t\t    \tgfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\tgfc_charlen_type);\n export_proto(mmaxloc2_8_s4);\n \n GFC_INTEGER_8\n mmaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n \t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n@@ -92,6 +95,7 @@ mmaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -141,15 +145,15 @@ mmaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n }\n \n extern GFC_INTEGER_8 smaxloc2_8_s4 (gfc_array_s4 * const restrict,\n-                               GFC_LOGICAL_4 *mask, gfc_charlen_type);\n+                               GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(smaxloc2_8_s4);\n \n GFC_INTEGER_8\n smaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return maxloc2_8_s4 (array, len);\n+    return maxloc2_8_s4 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "2c6b865d60a266a6bc293854c7bd093f89313a1c", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_i1 (retarray, array, pdim, back);\n+#else\n       maxval_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "060463601a75865d7064d5d2a615ea667f5c4274", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_i16 (retarray, array, pdim, back);\n+#else\n       maxval_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "bcd4343ae0847254281fe26ce30608a898242673", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_i2 (retarray, array, pdim, back);\n+#else\n       maxval_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "bef1c291c3544cbc8b48349b040c489ab5fa3d89", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_i4 (retarray, array, pdim, back);\n+#else\n       maxval_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "14deb70de4709cadeed9065935c5be0c0fe2f5b4", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_i8 (retarray, array, pdim, back);\n+#else\n       maxval_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "85d6d83b24ab89ea7e66cd9daac87b7e03fbbb9d", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_r10 (retarray, array, pdim, back);\n+#else\n       maxval_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "18ef36725a8d78fa09c0fe9acb78268076bc7071", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_r16 (retarray, array, pdim, back);\n+#else\n       maxval_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "862fe633c0c67690cbdb8960cce76a008a09f448", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_r4 (retarray, array, pdim, back);\n+#else\n       maxval_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9315483d39e19be8e820d72db1308cd6ea8cf206", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      maxval_r8 (retarray, array, pdim, back);\n+#else\n       maxval_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "88720df56f7f9e80fb34015a1c343b5985095b07", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array);\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_i1);\n \n void\n minloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array)\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_i1);\n \n void\n mminloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i1);\n \n void\n sminloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_i1 (retarray, array);\n+      minloc0_16_i1 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "4e2b6d0ca54b9ebfef2132ab7c796c6d4465b000", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array);\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_i16);\n \n void\n minloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array)\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_i16);\n \n void\n mminloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i16);\n \n void\n sminloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_i16 (retarray, array);\n+      minloc0_16_i16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "c9032c7a97031f8741d988d762f95f1a40f253f6", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array);\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_i2);\n \n void\n minloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array)\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_i2);\n \n void\n mminloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i2);\n \n void\n sminloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_i2 (retarray, array);\n+      minloc0_16_i2 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "a27405a3ff6016fd59c16cdad9a02a68e43134ec", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array);\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_i4);\n \n void\n minloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array)\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_i4);\n \n void\n mminloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i4);\n \n void\n sminloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_i4 (retarray, array);\n+      minloc0_16_i4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "6874f66ae56b266af1269da1c092defd5a19774b", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array);\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_i8);\n \n void\n minloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array)\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_i8);\n \n void\n mminloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i8);\n \n void\n sminloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_i8 (retarray, array);\n+      minloc0_16_i8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "ad97459d4437d3e392bbb6fcffdb1cb6047627e9", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array);\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_r10);\n \n void\n minloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array)\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_r10);\n \n void\n mminloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r10);\n \n void\n sminloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_r10 (retarray, array);\n+      minloc0_16_r10 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "f8245ed30597083c9b0b0403c37e6ce286e65843", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array);\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_r16);\n \n void\n minloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array)\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_r16);\n \n void\n mminloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r16);\n \n void\n sminloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_r16 (retarray, array);\n+      minloc0_16_r16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "ed41783dd5e6508b79be3dce948476ce265d2299", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array);\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_r4);\n \n void\n minloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array)\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_r4);\n \n void\n mminloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r4);\n \n void\n sminloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_r4 (retarray, array);\n+      minloc0_16_r4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "0799d4dfca8cfe8d7c389e2d442912726f235f78", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_16)\n \n \n extern void minloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array);\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_16_r8);\n \n void\n minloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array)\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_16_r8);\n \n void\n mminloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r8);\n \n void\n sminloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_16_r8 (retarray, array);\n+      minloc0_16_r8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "e566d749fb7cfeab8b29f7269712cf7c13eb140b", "filename": "libgfortran/generated/minloc0_16_s1.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void minloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(minloc0_16_s1);\n \n void\n minloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ minloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ minloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_s1 (gfc_array_i16 * const restrict, \n-\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mminloc0_16_s1);\n \n void\n mminloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mminloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mminloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_s1 (gfc_array_i16 * const restrict, \n-\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(sminloc0_16_s1);\n \n void\n sminloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ sminloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      minloc0_16_s1 (retarray, array, back, len);\n+#else\n       minloc0_16_s1 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "2a0b13c240f92a14ddcde5a0ee83f8f067fb8a0d", "filename": "libgfortran/generated/minloc0_16_s4.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void minloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(minloc0_16_s4);\n \n void\n minloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ minloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ minloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_s4 (gfc_array_i16 * const restrict, \n-\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mminloc0_16_s4);\n \n void\n mminloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mminloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mminloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void sminloc0_16_s4 (gfc_array_i16 * const restrict, \n-\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(sminloc0_16_s4);\n \n void\n sminloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ sminloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      minloc0_16_s4 (retarray, array, back, len);\n+#else\n       minloc0_16_s4 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "577c9ddf6553ba44de1bd17e12af60de9876de19", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array);\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_i1);\n \n void\n minloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array)\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_i1);\n \n void\n mminloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i1);\n \n void\n sminloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_i1 (retarray, array);\n+      minloc0_4_i1 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "48da69e39822231f39a026064bb2049903cb9cde", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array);\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_i16);\n \n void\n minloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array)\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_i16);\n \n void\n mminloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i16);\n \n void\n sminloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_i16 (retarray, array);\n+      minloc0_4_i16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "815ea85c22197fb739cb0f4eb9e310a95bbb8dc3", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array);\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_i2);\n \n void\n minloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array)\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_i2);\n \n void\n mminloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i2);\n \n void\n sminloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_i2 (retarray, array);\n+      minloc0_4_i2 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "36b0a58f250af6f7f97ea642c65de91dad4ed5f3", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array);\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_i4);\n \n void\n minloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array)\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_i4);\n \n void\n mminloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i4);\n \n void\n sminloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_i4 (retarray, array);\n+      minloc0_4_i4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "a66280cd0742355e55eeb81616e144b4b3795745", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array);\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_i8);\n \n void\n minloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array)\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_i8);\n \n void\n mminloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i8);\n \n void\n sminloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_i8 (retarray, array);\n+      minloc0_4_i8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "461ad0d477ba0b1cd3c9a00f753c494f176836a7", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array);\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_r10);\n \n void\n minloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array)\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_r10);\n \n void\n mminloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r10);\n \n void\n sminloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_r10 (retarray, array);\n+      minloc0_4_r10 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "27e6d1d6a423276e0e602635cb221377a485910f", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array);\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_r16);\n \n void\n minloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array)\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_r16);\n \n void\n mminloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r16);\n \n void\n sminloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_r16 (retarray, array);\n+      minloc0_4_r16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "1b85544a292f07530dc63134f42a4650f07c1c0a", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array);\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_r4);\n \n void\n minloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array)\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_r4);\n \n void\n mminloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r4);\n \n void\n sminloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_r4 (retarray, array);\n+      minloc0_4_r4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "7c6d6bfbec2b091810fd3f8aac05fe4ab3a8a167", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_4)\n \n \n extern void minloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array);\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_4_r8);\n \n void\n minloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array)\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_4_r8);\n \n void\n mminloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r8);\n \n void\n sminloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_4_r8 (retarray, array);\n+      minloc0_4_r8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "4d58df41b4f97ec08c26f797683a3b1f4f09cfcf", "filename": "libgfortran/generated/minloc0_4_s1.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void minloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(minloc0_4_s1);\n \n void\n minloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ minloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ minloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_s1 (gfc_array_i4 * const restrict, \n-\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mminloc0_4_s1);\n \n void\n mminloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mminloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mminloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_s1 (gfc_array_i4 * const restrict, \n-\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(sminloc0_4_s1);\n \n void\n sminloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ sminloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      minloc0_4_s1 (retarray, array, back, len);\n+#else\n       minloc0_4_s1 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "bea56c06b3d3662d3c94f8513167ee393bd140d4", "filename": "libgfortran/generated/minloc0_4_s4.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void minloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(minloc0_4_s4);\n \n void\n minloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ minloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ minloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_s4 (gfc_array_i4 * const restrict, \n-\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mminloc0_4_s4);\n \n void\n mminloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mminloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mminloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void sminloc0_4_s4 (gfc_array_i4 * const restrict, \n-\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(sminloc0_4_s4);\n \n void\n sminloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ sminloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      minloc0_4_s4 (retarray, array, back, len);\n+#else\n       minloc0_4_s4 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "b0bccc89b991466558621aec513ae21877065289", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array);\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_i1);\n \n void\n minloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i1 * const restrict array)\n+\tgfc_array_i1 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_i1);\n \n void\n mminloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i1);\n \n void\n sminloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_i1 (retarray, array);\n+      minloc0_8_i1 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "b4fb041b4a63bf462428aa86a7c1aa069c305e14", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array);\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_i16);\n \n void\n minloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i16 * const restrict array)\n+\tgfc_array_i16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_i16);\n \n void\n mminloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i16);\n \n void\n sminloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_i16 (retarray, array);\n+      minloc0_8_i16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "13b39040f053f488edbb3952b92900018686ef48", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array);\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_i2);\n \n void\n minloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i2 * const restrict array)\n+\tgfc_array_i2 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_i2);\n \n void\n mminloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i2);\n \n void\n sminloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_i2 (retarray, array);\n+      minloc0_8_i2 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "5d4dc06353e35eb792205aac35566dd5ee728686", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array);\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_i4);\n \n void\n minloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i4 * const restrict array)\n+\tgfc_array_i4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_i4);\n \n void\n mminloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i4);\n \n void\n sminloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_i4 (retarray, array);\n+      minloc0_8_i4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "d4cf9a4a977367a8ed60d2618cff7ddb7b44c3d4", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array);\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_i8);\n \n void\n minloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i8 * const restrict array)\n+\tgfc_array_i8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_i8);\n \n void\n mminloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i8);\n \n void\n sminloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_i8 (retarray, array);\n+      minloc0_8_i8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "c74fe0f6e8bd812f36ab5edb0e62451e761925e2", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array);\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_r10);\n \n void\n minloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r10 * const restrict array)\n+\tgfc_array_r10 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_r10);\n \n void\n mminloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r10);\n \n void\n sminloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_r10 (retarray, array);\n+      minloc0_8_r10 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "0ce3fd7b803d639bfe53ac6eff27fc862dbdfed9", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array);\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_r16);\n \n void\n minloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r16 * const restrict array)\n+\tgfc_array_r16 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_r16);\n \n void\n mminloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r16);\n \n void\n sminloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_r16 (retarray, array);\n+      minloc0_8_r16 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "66c5b74e40ada80b1e0d8454162eb766b0896e81", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array);\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_r4);\n \n void\n minloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r4 * const restrict array)\n+\tgfc_array_r4 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_r4);\n \n void\n mminloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r4);\n \n void\n sminloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_r4 (retarray, array);\n+      minloc0_8_r4 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "bd6b217f7f99817d70d3efc0238884ef465a2846", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,18 +24,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_8)\n \n \n extern void minloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array);\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4);\n export_proto(minloc0_8_r8);\n \n void\n minloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_r8 * const restrict array)\n+\tgfc_array_r8 * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -46,6 +47,7 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -167,13 +169,14 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(mminloc0_8_r8);\n \n void\n mminloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -187,6 +190,7 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -335,13 +339,13 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r8);\n \n void\n sminloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -350,7 +354,7 @@ sminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n-      minloc0_8_r8 (retarray, array);\n+      minloc0_8_r8 (retarray, array, back);\n       return;\n     }\n "}, {"sha": "dd9be96f3dc7403e99787fb7938143f231ab88a9", "filename": "libgfortran/generated/minloc0_8_s1.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void minloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(minloc0_8_s1);\n \n void\n minloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ minloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ minloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_s1 (gfc_array_i8 * const restrict, \n-\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mminloc0_8_s1);\n \n void\n mminloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mminloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mminloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_s1 (gfc_array_i8 * const restrict, \n-\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(sminloc0_8_s1);\n \n void\n sminloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ sminloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      minloc0_8_s1 (retarray, array, back, len);\n+#else\n       minloc0_8_s1 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "46d29ec0b88c505b151955e2cafd39a801075f67", "filename": "libgfortran/generated/minloc0_8_s4.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n {\n@@ -43,12 +45,12 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void minloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len);\n export_proto(minloc0_8_s4);\n \n void\n minloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -59,6 +61,10 @@ minloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -149,13 +155,15 @@ minloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_s4 (gfc_array_i8 * const restrict, \n-\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict , GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(mminloc0_8_s4);\n \n void\n mminloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -169,6 +177,9 @@ mminloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -282,13 +293,15 @@ mminloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void sminloc0_8_s4 (gfc_array_i8 * const restrict, \n-\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len);\n export_proto(sminloc0_8_s4);\n \n void\n sminloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n@@ -297,7 +310,11 @@ sminloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      minloc0_8_s4 (retarray, array, back, len);\n+#else\n       minloc0_8_s4 (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "20197c4ae0d24b2653817dd8d6099590103f15dc", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+\tgfc_array_i1 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_i1);\n \n void\n minloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_i1);\n \n void\n mminloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_i1);\n \n void\n sminloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_i1 (retarray, array, pdim, back);\n+#else\n       minloc1_16_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "fc718a894c6d43ecd037764e9ad0c46860320ee7", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+\tgfc_array_i16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_i16);\n \n void\n minloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_i16);\n \n void\n mminloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_i16);\n \n void\n sminloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_i16 (retarray, array, pdim, back);\n+#else\n       minloc1_16_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "e9352b1d7304ff6342b14c433bb1d908e439ef21", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+\tgfc_array_i2 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_i2);\n \n void\n minloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_i2);\n \n void\n mminloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_i2);\n \n void\n sminloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_i2 (retarray, array, pdim, back);\n+#else\n       minloc1_16_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9faa5b3947c39f05333ea45216ecae0eab08b0a7", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+\tgfc_array_i4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_i4);\n \n void\n minloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_i4);\n \n void\n mminloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_i4);\n \n void\n sminloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_i4 (retarray, array, pdim, back);\n+#else\n       minloc1_16_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "6ad4abedf04fd332fe4084ce0670747676bc489b", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+\tgfc_array_i8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_i8);\n \n void\n minloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_i8);\n \n void\n mminloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_i8);\n \n void\n sminloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_i8 (retarray, array, pdim, back);\n+#else\n       minloc1_16_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "930d077cdf9f144f13b4237e4b2d1f86ce1cb6f7", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, const index_type * const restrict);\n+\tgfc_array_r10 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_r10);\n \n void\n minloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_r10);\n \n void\n mminloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_r10);\n \n void\n sminloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_r10 (retarray, array, pdim, back);\n+#else\n       minloc1_16_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "2003d8ff9ac3ad2f036e73ccbe49f39f443c8910", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, const index_type * const restrict);\n+\tgfc_array_r16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_r16);\n \n void\n minloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_r16);\n \n void\n mminloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_r16);\n \n void\n sminloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_r16 (retarray, array, pdim, back);\n+#else\n       minloc1_16_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "7b9698342cbb258fabcca2ab61675ad77e6ec7fa", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, const index_type * const restrict);\n+\tgfc_array_r4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_r4);\n \n void\n minloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_r4);\n \n void\n mminloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_r4);\n \n void\n sminloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_r4 (retarray, array, pdim, back);\n+#else\n       minloc1_16_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "d6839157cb1441b7ce0d686bcda8f781e35d4ffd", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, const index_type * const restrict);\n+\tgfc_array_r8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_16_r8);\n \n void\n minloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_16_r8);\n \n void\n mminloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_16_r8);\n \n void\n sminloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_r8 (retarray, array, pdim, back);\n+#else\n       minloc1_16_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "898d124fdd35c7865bab69f1d8353c1c8475bb48", "filename": "libgfortran/generated/minloc1_16_s1.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void minloc1_16_s1 (gfc_array_i16 * const restrict, \n-\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_s1 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(minloc1_16_s1);\n \n void\n minloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ minloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ minloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_s1 (gfc_array_i16 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mminloc1_16_s1);\n \n void\n mminloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mminloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mminloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_s1 (gfc_array_i16 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc1_16_s1);\n \n void\n sminloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ sminloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_s1 (retarray, array, pdim, back, string_len);\n+#else\n       minloc1_16_s1 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "82eb258e00907c5ce44e2b4115ed711c41abe2ba", "filename": "libgfortran/generated/minloc1_16_s4.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void minloc1_16_s4 (gfc_array_i16 * const restrict, \n-\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_s4 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(minloc1_16_s4);\n \n void\n minloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ minloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ minloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_s4 (gfc_array_i16 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mminloc1_16_s4);\n \n void\n mminloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mminloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mminloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n extern void sminloc1_16_s4 (gfc_array_i16 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc1_16_s4);\n \n void\n sminloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ sminloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_s4 (retarray, array, pdim, back, string_len);\n+#else\n       minloc1_16_s4 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b36f2681fe4bf69db54bcdbe7512a44c9774f1c9", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+\tgfc_array_i1 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_i1);\n \n void\n minloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_i1);\n \n void\n mminloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_i1);\n \n void\n sminloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_i1 (retarray, array, pdim, back);\n+#else\n       minloc1_4_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b4454e1aca746ff0f1b3bcd207285a650847a988", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+\tgfc_array_i16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_i16);\n \n void\n minloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_i16);\n \n void\n mminloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_i16);\n \n void\n sminloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_i16 (retarray, array, pdim, back);\n+#else\n       minloc1_4_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "f8ab77ccded5e53684890aadb715e38d6a9430ba", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+\tgfc_array_i2 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_i2);\n \n void\n minloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_i2);\n \n void\n mminloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_i2);\n \n void\n sminloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_i2 (retarray, array, pdim, back);\n+#else\n       minloc1_4_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "6523d01fc9e0f4c070399754798166c16f25cc4e", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+\tgfc_array_i4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_i4);\n \n void\n minloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_i4);\n \n void\n mminloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_i4);\n \n void\n sminloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_i4 (retarray, array, pdim, back);\n+#else\n       minloc1_4_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "ab1b6bae8b34342c2881471aaf5b20abaddcd138", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+\tgfc_array_i8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_i8);\n \n void\n minloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_i8);\n \n void\n mminloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_i8);\n \n void\n sminloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_i8 (retarray, array, pdim, back);\n+#else\n       minloc1_4_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "a481ec459d3be66620f9b168207d7b0f4724e40c", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, const index_type * const restrict);\n+\tgfc_array_r10 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_r10);\n \n void\n minloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_r10);\n \n void\n mminloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_r10);\n \n void\n sminloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_r10 (retarray, array, pdim, back);\n+#else\n       minloc1_4_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "f5fcb666c599a1c8688d275d01427603c919ac01", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, const index_type * const restrict);\n+\tgfc_array_r16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_r16);\n \n void\n minloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_r16);\n \n void\n mminloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_r16);\n \n void\n sminloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_r16 (retarray, array, pdim, back);\n+#else\n       minloc1_4_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "212aa2541cb40f0a3df611a3ed6b6e5b2149585b", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, const index_type * const restrict);\n+\tgfc_array_r4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_r4);\n \n void\n minloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_r4);\n \n void\n mminloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_r4);\n \n void\n sminloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_r4 (retarray, array, pdim, back);\n+#else\n       minloc1_4_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "1fa41f2e084f95a22678abe01c3e9b4eb7b89456", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, const index_type * const restrict);\n+\tgfc_array_r8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_4_r8);\n \n void\n minloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_4_r8);\n \n void\n mminloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_4_r8);\n \n void\n sminloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_r8 (retarray, array, pdim, back);\n+#else\n       minloc1_4_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "1b7e5514cc87fc1c3891e9e7a793b6f89515a27b", "filename": "libgfortran/generated/minloc1_4_s1.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void minloc1_4_s1 (gfc_array_i4 * const restrict, \n-\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_s1 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(minloc1_4_s1);\n \n void\n minloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ minloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ minloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_s1 (gfc_array_i4 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mminloc1_4_s1);\n \n void\n mminloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mminloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mminloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_s1 (gfc_array_i4 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc1_4_s1);\n \n void\n sminloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ sminloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_s1 (retarray, array, pdim, back, string_len);\n+#else\n       minloc1_4_s1 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b3c6010efdae4b154639ead0be6d7cefce07c8ce", "filename": "libgfortran/generated/minloc1_4_s4.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void minloc1_4_s4 (gfc_array_i4 * const restrict, \n-\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_s4 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(minloc1_4_s4);\n \n void\n minloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ minloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ minloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_s4 (gfc_array_i4 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mminloc1_4_s4);\n \n void\n mminloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mminloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mminloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n extern void sminloc1_4_s4 (gfc_array_i4 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc1_4_s4);\n \n void\n sminloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ sminloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_s4 (retarray, array, pdim, back, string_len);\n+#else\n       minloc1_4_s4 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "66771b345231bbf366c9ad1d837176dfad60315a", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+\tgfc_array_i1 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_i1);\n \n void\n minloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_i1);\n \n void\n mminloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_i1);\n \n void\n sminloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_i1 (retarray, array, pdim, back);\n+#else\n       minloc1_8_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "8c7bc1908e2318b9e9e608daed151ab41914bae5", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+\tgfc_array_i16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_i16);\n \n void\n minloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_i16);\n \n void\n mminloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_i16);\n \n void\n sminloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_i16 (retarray, array, pdim, back);\n+#else\n       minloc1_8_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "e31acb53b72826cc550e7d07e34b7b90a7cd7bdd", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+\tgfc_array_i2 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_i2);\n \n void\n minloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_i2);\n \n void\n mminloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_i2);\n \n void\n sminloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_i2 (retarray, array, pdim, back);\n+#else\n       minloc1_8_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "4402bdd8ffe75b8f27743a8fc468018a22da40a3", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+\tgfc_array_i4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_i4);\n \n void\n minloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_i4);\n \n void\n mminloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_i4);\n \n void\n sminloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_i4 (retarray, array, pdim, back);\n+#else\n       minloc1_8_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "172cbb5d138a781d0355e04018117fecec0c45dc", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+\tgfc_array_i8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_i8);\n \n void\n minloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_i8);\n \n void\n mminloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_i8);\n \n void\n sminloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_i8 (retarray, array, pdim, back);\n+#else\n       minloc1_8_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "557e87616b61643f219cf0377863324fccaac342", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, const index_type * const restrict);\n+\tgfc_array_r10 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_r10);\n \n void\n minloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_r10);\n \n void\n mminloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_r10);\n \n void\n sminloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_r10 (retarray, array, pdim, back);\n+#else\n       minloc1_8_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "184dd1e098f3883156a915d3e5ffd9948fbc1a62", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, const index_type * const restrict);\n+\tgfc_array_r16 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_r16);\n \n void\n minloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_r16);\n \n void\n mminloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_r16);\n \n void\n sminloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_r16 (retarray, array, pdim, back);\n+#else\n       minloc1_8_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "fd81020925812a5a739c48a52d7012f3f7d74bbb", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, const index_type * const restrict);\n+\tgfc_array_r4 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_r4);\n \n void\n minloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_r4);\n \n void\n mminloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_r4);\n \n void\n sminloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_r4 (retarray, array, pdim, back);\n+#else\n       minloc1_8_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "fc0ff7c907691315a388299b2816bccdbe099315", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -24,19 +24,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n+#include <assert.h>\n \n \n #if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n \n extern void minloc1_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, const index_type * const restrict);\n+\tgfc_array_r8 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n export_proto(minloc1_8_r8);\n \n void\n minloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n-\tconst index_type * const restrict pdim)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -51,6 +54,10 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -214,14 +221,14 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n export_proto(mminloc1_8_r8);\n \n void\n mminloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -239,6 +246,9 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -433,14 +443,14 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n export_proto(sminloc1_8_r8);\n \n void\n sminloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -453,7 +463,11 @@ sminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_r8 (retarray, array, pdim, back);\n+#else\n       minloc1_8_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b5b4fd506746a04afa2b9ac2691f706319079db1", "filename": "libgfortran/generated/minloc1_8_s1.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n }\n \n extern void minloc1_8_s1 (gfc_array_i8 * const restrict, \n-\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_s1 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(minloc1_8_s1);\n \n void\n minloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ minloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ minloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_s1 (gfc_array_i8 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mminloc1_8_s1);\n \n void\n mminloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mminloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mminloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_s1 (gfc_array_i8 * const restrict, \n \tgfc_array_s1 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc1_8_s1);\n \n void\n sminloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ sminloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_s1 (retarray, array, pdim, back, string_len);\n+#else\n       minloc1_8_s1 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "4181630eca276e3383d3a6da4f8410a234c1445b", "filename": "libgfortran/generated/minloc1_8_s4.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -28,7 +28,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n+#define HAVE_BACK_ARG 1\n+\n #include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n@@ -40,14 +43,15 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n }\n \n extern void minloc1_8_s4 (gfc_array_i8 * const restrict, \n-\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_s4 * const restrict, const index_type * const restrict , GFC_LOGICAL_4 back,\n \tgfc_charlen_type);\n export_proto(minloc1_8_s4);\n \n void\n minloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -62,6 +66,10 @@ minloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -210,14 +218,15 @@ minloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_s4 (gfc_array_i8 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(mminloc1_8_s4);\n \n void\n mminloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -235,6 +244,9 @@ mminloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -411,14 +423,14 @@ mminloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n extern void sminloc1_8_s4 (gfc_array_i8 * const restrict, \n \tgfc_array_s4 * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc1_8_s4);\n \n void\n sminloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_s4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask , GFC_LOGICAL_4 back, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -431,7 +443,11 @@ sminloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_s4 (retarray, array, pdim, back, string_len);\n+#else\n       minloc1_8_s4 (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "3685603ecc27304f18ef126fe1b3e463df932a85", "filename": "libgfortran/generated/minloc2_16_s1.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n \n@@ -38,11 +39,13 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_16 minloc2_16_s1 (gfc_array_s1 * const restrict, gfc_charlen_type);\n+extern GFC_INTEGER_16 minloc2_16_s1 (gfc_array_s1 * const restrict, GFC_LOGICAL_4 back,\n+       gfc_charlen_type);\n export_proto(minloc2_16_s1);\n \n GFC_INTEGER_16\n-minloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+minloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n+\t\t\t\tgfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -51,6 +54,7 @@ minloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -73,12 +77,14 @@ minloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_16 mminloc2_16_s1 (gfc_array_s1 * const restrict,\n-                    gfc_array_l1 *const restrict mask, gfc_charlen_type);\n+                    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t    gfc_charlen_type);\n export_proto(mminloc2_16_s1);\n \n GFC_INTEGER_16\n mminloc2_16_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -90,6 +96,7 @@ mminloc2_16_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -139,15 +146,15 @@ mminloc2_16_s1 (gfc_array_s1 * const restrict array,\n }\n \n extern GFC_INTEGER_16 sminloc2_16_s1 (gfc_array_s1 * const restrict,\n-       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+       \t\t    \tGFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc2_16_s1);\n \n GFC_INTEGER_16\n sminloc2_16_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return minloc2_16_s1 (array, len);\n+    return minloc2_16_s1 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "256784fd8cef68aa7d009de257db55e754aeabe5", "filename": "libgfortran/generated/minloc2_16_s4.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n \n@@ -38,11 +39,13 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_16 minloc2_16_s4 (gfc_array_s4 * const restrict, gfc_charlen_type);\n+extern GFC_INTEGER_16 minloc2_16_s4 (gfc_array_s4 * const restrict, GFC_LOGICAL_4 back,\n+       gfc_charlen_type);\n export_proto(minloc2_16_s4);\n \n GFC_INTEGER_16\n-minloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+minloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n+\t\t\t\tgfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -51,6 +54,7 @@ minloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -73,12 +77,14 @@ minloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_16 mminloc2_16_s4 (gfc_array_s4 * const restrict,\n-                    gfc_array_l1 *const restrict mask, gfc_charlen_type);\n+                    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t    gfc_charlen_type);\n export_proto(mminloc2_16_s4);\n \n GFC_INTEGER_16\n mminloc2_16_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -90,6 +96,7 @@ mminloc2_16_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -139,15 +146,15 @@ mminloc2_16_s4 (gfc_array_s4 * const restrict array,\n }\n \n extern GFC_INTEGER_16 sminloc2_16_s4 (gfc_array_s4 * const restrict,\n-       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+       \t\t    \tGFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc2_16_s4);\n \n GFC_INTEGER_16\n sminloc2_16_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return minloc2_16_s4 (array, len);\n+    return minloc2_16_s4 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "1ba34d1712e2aab6908dfc9146eea8cde46adad0", "filename": "libgfortran/generated/minloc2_4_s1.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n \n@@ -38,11 +39,13 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_4 minloc2_4_s1 (gfc_array_s1 * const restrict, gfc_charlen_type);\n+extern GFC_INTEGER_4 minloc2_4_s1 (gfc_array_s1 * const restrict, GFC_LOGICAL_4 back,\n+       gfc_charlen_type);\n export_proto(minloc2_4_s1);\n \n GFC_INTEGER_4\n-minloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+minloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n+\t\t\t\tgfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -51,6 +54,7 @@ minloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -73,12 +77,14 @@ minloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_4 mminloc2_4_s1 (gfc_array_s1 * const restrict,\n-                    gfc_array_l1 *const restrict mask, gfc_charlen_type);\n+                    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t    gfc_charlen_type);\n export_proto(mminloc2_4_s1);\n \n GFC_INTEGER_4\n mminloc2_4_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -90,6 +96,7 @@ mminloc2_4_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -139,15 +146,15 @@ mminloc2_4_s1 (gfc_array_s1 * const restrict array,\n }\n \n extern GFC_INTEGER_4 sminloc2_4_s1 (gfc_array_s1 * const restrict,\n-       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+       \t\t    \tGFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc2_4_s1);\n \n GFC_INTEGER_4\n sminloc2_4_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return minloc2_4_s1 (array, len);\n+    return minloc2_4_s1 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "cd5053d71ff43a9486745669ec4db3641e408a7d", "filename": "libgfortran/generated/minloc2_4_s4.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n \n@@ -38,11 +39,13 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_4 minloc2_4_s4 (gfc_array_s4 * const restrict, gfc_charlen_type);\n+extern GFC_INTEGER_4 minloc2_4_s4 (gfc_array_s4 * const restrict, GFC_LOGICAL_4 back,\n+       gfc_charlen_type);\n export_proto(minloc2_4_s4);\n \n GFC_INTEGER_4\n-minloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+minloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n+\t\t\t\tgfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -51,6 +54,7 @@ minloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -73,12 +77,14 @@ minloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_4 mminloc2_4_s4 (gfc_array_s4 * const restrict,\n-                    gfc_array_l1 *const restrict mask, gfc_charlen_type);\n+                    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t    gfc_charlen_type);\n export_proto(mminloc2_4_s4);\n \n GFC_INTEGER_4\n mminloc2_4_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -90,6 +96,7 @@ mminloc2_4_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -139,15 +146,15 @@ mminloc2_4_s4 (gfc_array_s4 * const restrict array,\n }\n \n extern GFC_INTEGER_4 sminloc2_4_s4 (gfc_array_s4 * const restrict,\n-       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+       \t\t    \tGFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc2_4_s4);\n \n GFC_INTEGER_4\n sminloc2_4_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return minloc2_4_s4 (array, len);\n+    return minloc2_4_s4 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "5c73d89f8e750873f284d4d784ba9d15937a15de", "filename": "libgfortran/generated/minloc2_8_s1.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n \n@@ -38,11 +39,13 @@ compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_8 minloc2_8_s1 (gfc_array_s1 * const restrict, gfc_charlen_type);\n+extern GFC_INTEGER_8 minloc2_8_s1 (gfc_array_s1 * const restrict, GFC_LOGICAL_4 back,\n+       gfc_charlen_type);\n export_proto(minloc2_8_s1);\n \n GFC_INTEGER_8\n-minloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+minloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n+\t\t\t\tgfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -51,6 +54,7 @@ minloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -73,12 +77,14 @@ minloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_8 mminloc2_8_s1 (gfc_array_s1 * const restrict,\n-                    gfc_array_l1 *const restrict mask, gfc_charlen_type);\n+                    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t    gfc_charlen_type);\n export_proto(mminloc2_8_s1);\n \n GFC_INTEGER_8\n mminloc2_8_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -90,6 +96,7 @@ mminloc2_8_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -139,15 +146,15 @@ mminloc2_8_s1 (gfc_array_s1 * const restrict array,\n }\n \n extern GFC_INTEGER_8 sminloc2_8_s1 (gfc_array_s1 * const restrict,\n-       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+       \t\t    \tGFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc2_8_s1);\n \n GFC_INTEGER_8\n sminloc2_8_s1 (gfc_array_s1 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return minloc2_8_s1 (array, len);\n+    return minloc2_8_s1 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "9b40c9140cb563471966a26750917d4381ce1312", "filename": "libgfortran/generated/minloc2_8_s4.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n #if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n \n@@ -38,11 +39,13 @@ compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern GFC_INTEGER_8 minloc2_8_s4 (gfc_array_s4 * const restrict, gfc_charlen_type);\n+extern GFC_INTEGER_8 minloc2_8_s4 (gfc_array_s4 * const restrict, GFC_LOGICAL_4 back,\n+       gfc_charlen_type);\n export_proto(minloc2_8_s4);\n \n GFC_INTEGER_8\n-minloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+minloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n+\t\t\t\tgfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -51,6 +54,7 @@ minloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -73,12 +77,14 @@ minloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n }\n \n extern GFC_INTEGER_8 mminloc2_8_s4 (gfc_array_s4 * const restrict,\n-                    gfc_array_l1 *const restrict mask, gfc_charlen_type);\n+                    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back,\n+\t\t    gfc_charlen_type);\n export_proto(mminloc2_8_s4);\n \n GFC_INTEGER_8\n mminloc2_8_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\t\t\t\t gfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back,\n+\t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -90,6 +96,7 @@ mminloc2_8_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -139,15 +146,15 @@ mminloc2_8_s4 (gfc_array_s4 * const restrict array,\n }\n \n extern GFC_INTEGER_8 sminloc2_8_s4 (gfc_array_s4 * const restrict,\n-       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+       \t\t    \tGFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type);\n export_proto(sminloc2_8_s4);\n \n GFC_INTEGER_8\n sminloc2_8_s4 (gfc_array_s4 * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask, GFC_LOGICAL_4 back, gfc_charlen_type len)\n {\n   if (mask)\n-    return minloc2_8_s4 (array, len);\n+    return minloc2_8_s4 (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "7bb6f81b0e7241e8f927d435ead484821b2efc31", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_i1 (gfc_array_i1 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_i1 (retarray, array, pdim, back);\n+#else\n       minval_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b2608bc102dfde845a19e14c2c1026f37f5e917b", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_i16 (retarray, array, pdim, back);\n+#else\n       minval_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "6539ae10b6013563fe68fe23d22b938aa0bb11e2", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_i2 (gfc_array_i2 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_i2 (retarray, array, pdim, back);\n+#else\n       minval_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "e2c16d2e8dab6475aef634077ab270e952dc549d", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_i4 (retarray, array, pdim, back);\n+#else\n       minval_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9caafd97e04ceb2bf8fc55e784bb897528626bd9", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_i8 (retarray, array, pdim, back);\n+#else\n       minval_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "308f64b25b30f241881c1dc65b3ced5bd81c04a3", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_r10 (gfc_array_r10 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_r10 (retarray, array, pdim, back);\n+#else\n       minval_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "948aee092cf42c6ae6e9902221fefdcd960e1a29", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_r16 (gfc_array_r16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_r16 (retarray, array, pdim, back);\n+#else\n       minval_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b52a3e80f4dc59df0903f41d21dab6a5fc20cbb2", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_r4 (gfc_array_r4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_r4 (retarray, array, pdim, back);\n+#else\n       minval_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "34caf05fc0c68ef695cf7bc71f50df0222019240", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -232,6 +236,9 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -441,7 +448,11 @@ sminval_r8 (gfc_array_r8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      minval_r8 (retarray, array, pdim, back);\n+#else\n       minval_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "b6e5a4a51d300b64e3aaebe9b6bd5c9f018400fc", "filename": "libgfortran/generated/norm2_r10.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -54,6 +54,10 @@ norm2_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "32237dbd6d8c994dfeb59dad812fb70b81c0d152", "filename": "libgfortran/generated/norm2_r16.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -58,6 +58,10 @@ norm2_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "504d31306e9ba886e69bb39319d457031a554171", "filename": "libgfortran/generated/norm2_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -54,6 +54,10 @@ norm2_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "60e707f920685dd8ee8b917183d5a337200e608f", "filename": "libgfortran/generated/norm2_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fnorm2_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -54,6 +54,10 @@ norm2_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "292079942503b1bf83c847edbd42a2fb277bed5e", "filename": "libgfortran/generated/parity_l1.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ parity_l1 (gfc_array_l1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "c1ac0b26f051974ff03651acfe84f961b49a3854", "filename": "libgfortran/generated/parity_l16.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ parity_l16 (gfc_array_l16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "c588e721a6eadeb62ad9a83db6bbfb2358993e3b", "filename": "libgfortran/generated/parity_l2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ parity_l2 (gfc_array_l2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "0acb039c1af84c07922f681b3995cacca5723a44", "filename": "libgfortran/generated/parity_l4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ parity_l4 (gfc_array_l4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "84623dffe1b178df9fcdffdc852edebc4c0d196b", "filename": "libgfortran/generated/parity_l8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fparity_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ parity_l8 (gfc_array_l8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;"}, {"sha": "38e8251861e4ad6a114e54e4871d7aaae4793bc8", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_c10 (gfc_array_c10 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_c10 (retarray, array, pdim, back);\n+#else\n       product_c10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "d1c04ec9793ed6eafbffee38bc0c1072bba22264", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_c16 (gfc_array_c16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_c16 (retarray, array, pdim, back);\n+#else\n       product_c16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "d19cfaf6d895676c70a0500b1021a088aea49edc", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_c4 (gfc_array_c4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_c4 (retarray, array, pdim, back);\n+#else\n       product_c4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "ed1e12afba755d2b078c2838cf785a76d4776d1d", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_c8 (gfc_array_c8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_c8 (retarray, array, pdim, back);\n+#else\n       product_c8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "2e86e99e569d3b042e0530e19fb8183f856bfe57", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_i1 (gfc_array_i1 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_i1 (retarray, array, pdim, back);\n+#else\n       product_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "f23890ef740dccb3f98a6f457a26e856ffffe2cd", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_i16 (retarray, array, pdim, back);\n+#else\n       product_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "762e5486ac6b404aea04dba335f813f26f0d9138", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_i2 (gfc_array_i2 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_i2 (retarray, array, pdim, back);\n+#else\n       product_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "ecf047029d5c3d2e693eb284e05ae855827db63b", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_i4 (retarray, array, pdim, back);\n+#else\n       product_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "a9530ec6907706499ddeedb8a45d5fe8a31fc915", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_i8 (retarray, array, pdim, back);\n+#else\n       product_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "613ed18e9e40926dbc0e0401b5cd8c77e57b8026", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_r10 (gfc_array_r10 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_r10 (retarray, array, pdim, back);\n+#else\n       product_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9befd51edc4b326e85b9a5fd2365bc37940f1231", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_r16 (gfc_array_r16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_r16 (retarray, array, pdim, back);\n+#else\n       product_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "5e356ee8bfca03916a314a68ffdd7c14518c6a17", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_r4 (gfc_array_r4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_r4 (retarray, array, pdim, back);\n+#else\n       product_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "4e98cfa113ba5b6342276a10f5882860ff90c949", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ sproduct_r8 (gfc_array_r8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      product_r8 (retarray, array, pdim, back);\n+#else\n       product_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "6923594e01fcb0d474076370452f27c49b89f74c", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_c10 (gfc_array_c10 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_c10 (retarray, array, pdim, back);\n+#else\n       sum_c10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "4ed50d04dd816a3a6d25dca43928251f8e155f2e", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_c16 (gfc_array_c16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_c16 (retarray, array, pdim, back);\n+#else\n       sum_c16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9d5516a3b4a8d2e26cf8cabf91d2699c22b346a6", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_c4 (gfc_array_c4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_c4 (retarray, array, pdim, back);\n+#else\n       sum_c4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "84684cbcd2e209fc7ff5d4a713488b0a723622b3", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_c8 (gfc_array_c8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_c8 (retarray, array, pdim, back);\n+#else\n       sum_c8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "f4407028de57898a79cab8c10649ad8795ab1179", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_i1 (gfc_array_i1 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_i1 (retarray, array, pdim, back);\n+#else\n       sum_i1 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "570f8f2c4410ab0eff647c78e43923816e2ee105", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_i16 (gfc_array_i16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_i16 (retarray, array, pdim, back);\n+#else\n       sum_i16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "ea70d50888672398e2b50172f2c3133de733c5ee", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_i2 (gfc_array_i2 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_i2 (retarray, array, pdim, back);\n+#else\n       sum_i2 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "4915ec9feb44868393759a7ce7519d1f6fdece63", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_i4 (gfc_array_i4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_i4 (retarray, array, pdim, back);\n+#else\n       sum_i4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "53f6ec24fd4896bec671597caee14614cf7ecc16", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_i8 (gfc_array_i8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_i8 (retarray, array, pdim, back);\n+#else\n       sum_i8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9552ed84cc8858abd7d67df1e549984cf529e9b4", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_r10 (gfc_array_r10 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_r10 (retarray, array, pdim, back);\n+#else\n       sum_r10 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "6c8320691bfebc08b12dccc0ae4914c25d58a5c3", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_r16 (gfc_array_r16 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_r16 (retarray, array, pdim, back);\n+#else\n       sum_r16 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "1595336bf309cd39335084406663695a15855508", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_r4 (gfc_array_r4 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_r4 (retarray, array, pdim, back);\n+#else\n       sum_r4 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "7c8a186ce761bc81e9e4769b0e65591be1d084fb", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -51,6 +51,10 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -218,6 +222,9 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -399,7 +406,11 @@ ssum_r8 (gfc_array_r8 * const restrict retarray,\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      sum_r8 (retarray, array, pdim, back);\n+#else\n       sum_r8 (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "9711925ed9943df27a1d789de94ed7d2d8c14687", "filename": "libgfortran/m4/iforeach-s.m4", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fiforeach-s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fiforeach-s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach-s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -13,23 +13,27 @@ compare_fcn (const atype_name *a, const atype_name *b, gfc_charlen_type n)\n \n }\n \n-extern void name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, gfc_charlen_type len);\n-export_proto(name`'rtype_qual`_'atype_code);\n+extern void name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array'back_arg`, gfc_charlen_type len);\n+export_proto('name`'rtype_qual`_'atype_code);\n \n void\n-name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, gfc_charlen_type len)\n+name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array'back_arg`, gfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  const atype_name *base;\n+  const 'atype_name *base;\n   rtype_name * restrict dest;\n   index_type rank;\n   index_type n;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n+\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -112,27 +116,32 @@ define(FINISH_FOREACH_FUNCTION,\n }')dnl\n define(START_MASKED_FOREACH_FUNCTION,\n `\n-extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n-export_proto(`m'name`'rtype_qual`_'atype_code);\n+extern void `m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict, \n+\t'atype` * const restrict, gfc_array_l1 * const restrict 'back_arg`,\n+\tgfc_charlen_type len);\n+export_proto(m'name`'rtype_qual`_'atype_code`);\n \n void\n-`m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array,\n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array,\n+\tgfc_array_l1 * const restrict mask'back_arg`,\n+\tgfc_charlen_type len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type dstride;\n-  rtype_name *dest;\n+  'rtype_name *dest;\n   const atype_name *base;\n   GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -243,23 +252,29 @@ $2\n FINISH_MASKED_FOREACH_FUNCTION')dnl\n define(SCALAR_FOREACH_FUNCTION,\n `\n-extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n-export_proto(`s'name`'rtype_qual`_'atype_code);\n+extern void `s'name`'rtype_qual`_'atype_code` ('rtype` * const restrict, \n+\t'atype` * const restrict, GFC_LOGICAL_4 *'back_arg`,\n+\tgfc_charlen_type len);\n+export_proto(s'name`'rtype_qual`_'atype_code);\n \n void\n-`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array,\n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+`s'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array,\n+\tGFC_LOGICAL_4 * mask'back_arg`,\n+\tgfc_charlen_type len)\n {\n   index_type rank;\n   index_type dstride;\n   index_type n;\n-  rtype_name *dest;\n+  'rtype_name *dest;\n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG    \n+      name`'rtype_qual`_'atype_code (retarray, array, back, len);\n+#else\n       name`'rtype_qual`_'atype_code (retarray, array, len);\n+#endif\n       return;\n     }\n "}, {"sha": "e6365ccc3ef4316858e69a36942b975d783ecf81", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -5,12 +5,12 @@ dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n define(START_FOREACH_FUNCTION,\n `\n extern void name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array);\n+\tatype * const restrict array, GFC_LOGICAL_4);\n export_proto(name`'rtype_qual`_'atype_code);\n \n void\n name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array)\n+\tatype * const restrict array, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -21,6 +21,7 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -104,13 +105,14 @@ define(FINISH_FOREACH_FUNCTION,\n define(START_MASKED_FOREACH_FUNCTION,\n `\n extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, gfc_array_l1 * const restrict);\n+\tatype * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n export_proto(`m'name`'rtype_qual`_'atype_code);\n \n void\n `m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n \tatype * const restrict array,\n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -124,6 +126,7 @@ void\n   index_type n;\n   int mask_kind;\n \n+  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -235,13 +238,13 @@ FINISH_MASKED_FOREACH_FUNCTION')dnl\n define(SCALAR_FOREACH_FUNCTION,\n `\n extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, GFC_LOGICAL_4 *);\n+\tatype * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(`s'name`'rtype_qual`_'atype_code);\n \n void\n `s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n \tatype * const restrict array,\n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n {\n   index_type rank;\n   index_type dstride;\n@@ -250,7 +253,7 @@ void\n \n   if (*mask)\n     {\n-      name`'rtype_qual`_'atype_code (retarray, array);\n+      name`'rtype_qual`_'atype_code (retarray, array, back);\n       return;\n     }\n "}, {"sha": "9b4d96ab62246498dc7f26a6016c0cb383f24377", "filename": "libgfortran/m4/ifunction-s.m4", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fifunction-s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fifunction-s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction-s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -19,6 +19,7 @@ dnl You should not return or break from the inner loop of the implementation.\n dnl Care should also be taken to avoid using the names defined in iparm.m4\n define(START_ARRAY_FUNCTION,\n `#include <string.h>\n+#include <assert.h>\n \n static inline int\n compare_fcn (const atype_name *a, const atype_name *b, gfc_charlen_type n)\n@@ -29,21 +30,22 @@ compare_fcn (const atype_name *a, const atype_name *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern void name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, const index_type * const restrict,\n+extern void name`'rtype_qual`_'atype_code (rtype` * const restrict, \n+\t'atype` * const restrict, const index_type * const restrict 'back_arg`,\n \tgfc_charlen_type);\n-export_proto(name`'rtype_qual`_'atype_code);\n+export_proto('name`'rtype_qual`_'atype_code`);\n \n void\n-name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, \n-\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array, \n+\tconst index_type * const restrict pdim'back_arg`,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const atype_name * restrict base;\n+  const 'atype_name * restrict base;\n   rtype_name * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -52,6 +54,10 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -192,23 +198,24 @@ define(FINISH_ARRAY_FUNCTION,\n }')dnl\n define(START_MASKED_ARRAY_FUNCTION,\n `\n-extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict, gfc_charlen_type);\n-export_proto(`m'name`'rtype_qual`_'atype_code);\n+extern void `m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict, \n+\t'atype` * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict'back_arg`, gfc_charlen_type);\n+export_proto(m'name`'rtype_qual`_'atype_code`);\n \n void\n-`m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, \n+m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+\tgfc_array_l1 * const restrict mask'back_arg`,\n+\tgfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  rtype_name * restrict dest;\n+  'rtype_name * restrict dest;\n   const atype_name * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n@@ -219,6 +226,9 @@ void\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,29 +387,33 @@ define(FINISH_MASKED_ARRAY_FUNCTION,\n }')dnl\n define(SCALAR_ARRAY_FUNCTION,\n `\n-extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *, gfc_charlen_type);\n-export_proto(`s'name`'rtype_qual`_'atype_code);\n+extern void `s'name`'rtype_qual`_'atype_code` ('rtype` * const restrict, \n+\t'atype` * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *'back_arg`, gfc_charlen_type);\n+export_proto(s'name`'rtype_qual`_'atype_code`);\n \n void\n-`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, \n+s'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+\tGFC_LOGICAL_4 * mask 'back_arg`, gfc_charlen_type string_len)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  rtype_name * restrict dest;\n+  'rtype_name * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type dim;\n \n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      name`'rtype_qual`_'atype_code (retarray, array, pdim, back, string_len);\n+#else\n       name`'rtype_qual`_'atype_code (retarray, array, pdim, string_len);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "8df072da033fc3272a596380e772ce660d815389", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -20,19 +20,19 @@ dnl Care should also be taken to avoid using the names defined in iparm.m4\n define(START_ARRAY_FUNCTION,\n `\n extern void name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, const index_type * const restrict);\n-export_proto(name`'rtype_qual`_'atype_code);\n+\tatype` * const restrict, const 'index_type` * const restrict'back_arg`);\n+export_proto('name`'rtype_qual`_'atype_code);\n \n void\n-name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, \n-\tconst index_type * const restrict pdim)\n+name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array, \n+\tconst index_type * const restrict pdim'back_arg`)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const atype_name * restrict base;\n+  const 'atype_name * restrict base;\n   rtype_name * restrict dest;\n   index_type rank;\n   index_type n;\n@@ -41,6 +41,10 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n+#ifdef HAVE_BACK_ARG\n+  assert(back == 0);\n+#endif\n+\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -181,23 +185,23 @@ define(FINISH_ARRAY_FUNCTION,\n }')dnl\n define(START_MASKED_ARRAY_FUNCTION,\n `\n-extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, const index_type * const restrict,\n-\tgfc_array_l1 * const restrict);\n-export_proto(`m'name`'rtype_qual`_'atype_code);\n+extern void `m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict, \n+\t'atype` * const restrict, const 'index_type` * const restrict,\n+\tgfc_array_l1 * const restrict'back_arg`);\n+export_proto(m'name`'rtype_qual`_'atype_code`);\n \n void\n-`m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, \n+m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l1 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask'back_arg`)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n   index_type mstride[GFC_MAX_DIMENSIONS];\n-  rtype_name * restrict dest;\n+  'rtype_name * restrict dest;\n   const atype_name * restrict base;\n   const GFC_LOGICAL_1 * restrict mbase;\n   index_type rank;\n@@ -208,6 +212,9 @@ void\n   index_type mdelta;\n   int mask_kind;\n \n+#ifdef HAVE_BACK_ARG\n+  assert (back == 0);\n+#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -366,29 +373,33 @@ define(FINISH_MASKED_ARRAY_FUNCTION,\n }')dnl\n define(SCALAR_ARRAY_FUNCTION,\n `\n-extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, const index_type * const restrict,\n-\tGFC_LOGICAL_4 *);\n-export_proto(`s'name`'rtype_qual`_'atype_code);\n+extern void `s'name`'rtype_qual`_'atype_code` ('rtype` * const restrict, \n+\t'atype` * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *'back_arg`);\n+export_proto(s'name`'rtype_qual`_'atype_code);\n \n void\n-`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n-\tatype * const restrict array, \n+`s'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray, \n+\t'atype` * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tGFC_LOGICAL_4 * mask)\n+\tGFC_LOGICAL_4 * mask'back_arg`)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  rtype_name * restrict dest;\n+  'rtype_name * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type dim;\n \n \n   if (*mask)\n     {\n+#ifdef HAVE_BACK_ARG\n+      name`'rtype_qual`_'atype_code (retarray, array, pdim, back);\n+#else\n       name`'rtype_qual`_'atype_code (retarray, array, pdim);\n+#endif\n       return;\n     }\n   /* Make dim zero based to avoid confusion.  */"}, {"sha": "23f05ce443453cb55df1ca3ceafc3b8bc14a5fab", "filename": "libgfortran/m4/iparm.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fiparm.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fiparm.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparm.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -36,3 +36,5 @@ define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl\n define(`u_name',`regexp(upcase(name),`\\([A-Z]*\\)',`\\1')')dnl\n define(rtype_ccode,ifelse(rtype_letter,`i',rtype_kind,rtype_code))dnl\n define(initval,ifelse(index(name,`maxval'),0,0,index(name,`minval'),0,255))dnl\n+define(back_arg,ifelse(index(name,`maxloc'),0,``, GFC_LOGICAL_4 back'',dnl\n+index(name,`minloc'),0,``, GFC_LOGICAL_4 back''))dnl"}, {"sha": "98d898f86a7ea72d99d0ad55ecce534378634ebb", "filename": "libgfortran/m4/maxloc0.m4", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc0.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -23,7 +23,8 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-#include \"libgfortran.h\"'\n+#include \"libgfortran.h\"\n+#include <assert.h>'\n \n include(iparm.m4)dnl\n include(iforeach.m4)dnl"}, {"sha": "3c30a666feb3fe57fa62bddfb3452d383df6bf9f", "filename": "libgfortran/m4/maxloc0s.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc0s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -34,6 +34,8 @@ include(iforeach-s.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n \n+#define HAVE_BACK_ARG 1\n+\n FOREACH_FUNCTION(\n `  const atype_name *maxval;\n    maxval = base;'"}, {"sha": "324a699c0bb9d6b83907c1508ba4f0e92f850697", "filename": "libgfortran/m4/maxloc1.m4", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc1.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -23,13 +23,16 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-#include \"libgfortran.h\"'\n+#include \"libgfortran.h\"\n+#include <assert.h>'\n \n include(iparm.m4)dnl\n include(ifunction.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n \n+#define HAVE_BACK_ARG 1\n+\n ARRAY_FUNCTION(0,\n `\tatype_name maxval;\n #if defined ('atype_inf`)"}, {"sha": "23da4abf068980aa96433f1ae6743f55c4845ad6", "filename": "libgfortran/m4/maxloc1s.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc1s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -30,6 +30,8 @@ include(ifunction-s.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n \n+#define HAVE_BACK_ARG 1\n+\n ARRAY_FUNCTION(0,\n `\tconst atype_name *maxval;\n \tmaxval = base;"}, {"sha": "5138f696ec373426712048960abe5a29b1f5a90a", "filename": "libgfortran/m4/maxloc2s.m4", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc2s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fmaxloc2s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc2s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -25,7 +25,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"libgfortran.h\"\n #include <stdlib.h>\n-#include <string.h>'\n+#include <string.h>\n+#include <assert.h>'\n include(iparm.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)\n@@ -39,12 +40,12 @@ compare_fcn (const 'atype_name` *a, const 'atype_name` *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern 'rtype_name` 'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n+extern 'rtype_name` 'name`'rtype_qual`_'atype_code` ('atype` * const restrict'back_arg`,\n        gfc_charlen_type);\n export_proto('name`'rtype_qual`_'atype_code`);\n \n 'rtype_name`\n-'name`'rtype_qual`_'atype_code` ('atype` * const restrict array, gfc_charlen_type len)\n+'name`'rtype_qual`_'atype_code` ('atype` * const restrict array'back_arg`, gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -53,6 +54,7 @@ export_proto('name`'rtype_qual`_'atype_code`);\n   const 'atype_name` *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -75,12 +77,13 @@ export_proto('name`'rtype_qual`_'atype_code`);\n }\n \n extern 'rtype_name` m'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n-       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+       \t\t    \tgfc_array_l1 *const restrict mask'back_arg`,\n+\t\t\tgfc_charlen_type);\n export_proto(m'name`'rtype_qual`_'atype_code`);\n \n 'rtype_name`\n m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_array_l1 * const restrict mask'back_arg`,\n \t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n@@ -93,6 +96,7 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -142,15 +146,15 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n }\n \n extern 'rtype_name` s'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n-                               GFC_LOGICAL_4 *mask, gfc_charlen_type);\n+                               GFC_LOGICAL_4 *mask'back_arg`, gfc_charlen_type);\n export_proto(s'name`'rtype_qual`_'atype_code`);\n \n 'rtype_name`\n s'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask'back_arg`, gfc_charlen_type len)\n {\n   if (mask)\n-    return 'name`'rtype_qual`_'atype_code` (array, len);\n+    return 'name`'rtype_qual`_'atype_code` (array, len, back);\n   else\n     return 0;\n }"}, {"sha": "78c60d979eea1432e59e6742502e9a2f07b86ed4", "filename": "libgfortran/m4/minloc0.m4", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc0.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -23,7 +23,8 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-#include \"libgfortran.h\"'\n+#include \"libgfortran.h\"\n+#include <assert.h>'\n \n include(iparm.m4)dnl\n include(iforeach.m4)dnl"}, {"sha": "c4b9f461ac8871297f0eee464b1c7c9b274ed0bf", "filename": "libgfortran/m4/minloc0s.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc0s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -34,6 +34,8 @@ include(iforeach-s.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n \n+#define HAVE_BACK_ARG 1\n+\n FOREACH_FUNCTION(\n `  const atype_name *minval;\n    minval = base;'"}, {"sha": "ebf52f09d5f9bc9f49101694baa312043400f019", "filename": "libgfortran/m4/minloc1.m4", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc1.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -23,13 +23,16 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-#include \"libgfortran.h\"'\n+#include \"libgfortran.h\"\n+#include <assert.h>'\n \n include(iparm.m4)dnl\n include(ifunction.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n \n+#define HAVE_BACK_ARG 1\n+\n ARRAY_FUNCTION(0,\n `\tatype_name minval;\n #if defined ('atype_inf`)"}, {"sha": "6e46631ab8b1955d917e89fcec6edec8a77a4238", "filename": "libgfortran/m4/minloc1s.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc1s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -30,6 +30,8 @@ include(ifunction-s.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n \n+#define HAVE_BACK_ARG 1\n+\n ARRAY_FUNCTION(0,\n `\tconst atype_name *minval;\n \tminval = base;"}, {"sha": "2df71bb34b94940fb99bf6d0b1458c6658672ae9", "filename": "libgfortran/m4/minloc2s.m4", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc2s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b1806b2d94fd325759761b64fb7507ca83d5d2/libgfortran%2Fm4%2Fminloc2s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc2s.m4?ref=64b1806b2d94fd325759761b64fb7507ca83d5d2", "patch": "@@ -25,7 +25,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"libgfortran.h\"\n #include <stdlib.h>\n-#include <string.h>'\n+#include <string.h>\n+#include <assert.h>'\n include(iparm.m4)dnl\n \n `#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)\n@@ -39,11 +40,13 @@ compare_fcn (const 'atype_name` *a, const 'atype_name` *b, gfc_charlen_type n)\n     return memcmp_char4 (a, b, n);\n }\n \n-extern 'rtype_name` 'name`'rtype_qual`_'atype_code` ('atype` * const restrict, gfc_charlen_type);\n+extern 'rtype_name` 'name`'rtype_qual`_'atype_code` ('atype` * const restrict'back_arg`,\n+       gfc_charlen_type);\n export_proto('name`'rtype_qual`_'atype_code`);\n \n 'rtype_name`\n-'name`'rtype_qual`_'atype_code` ('atype` * const restrict array, gfc_charlen_type len)\n+'name`'rtype_qual`_'atype_code` ('atype` * const restrict array'back_arg`,\n+\t\t\t\tgfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -52,6 +55,7 @@ export_proto('name`'rtype_qual`_'atype_code`);\n   const 'atype_name` *maxval;\n   index_type i;\n \n+  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -74,12 +78,14 @@ export_proto('name`'rtype_qual`_'atype_code`);\n }\n \n extern 'rtype_name` m'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n-                    gfc_array_l1 *const restrict mask, gfc_charlen_type);\n+                    gfc_array_l1 *const restrict mask'back_arg`,\n+\t\t    gfc_charlen_type);\n export_proto(m'name`'rtype_qual`_'atype_code`);\n \n 'rtype_name`\n m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n-\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+\t\t\t\t gfc_array_l1 * const restrict mask'back_arg`,\n+\t\t\t\t gfc_charlen_type len)\n {\n   index_type ret;\n   index_type sstride;\n@@ -91,6 +97,7 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n+  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -140,15 +147,15 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n }\n \n extern 'rtype_name` s'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n-       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+       \t\t    \tGFC_LOGICAL_4 *mask'back_arg`, gfc_charlen_type);\n export_proto(s'name`'rtype_qual`_'atype_code`);\n \n 'rtype_name`\n s'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n-\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\t\t\t GFC_LOGICAL_4 *mask'back_arg`, gfc_charlen_type len)\n {\n   if (mask)\n-    return 'name`'rtype_qual`_'atype_code` (array, len);\n+    return 'name`'rtype_qual`_'atype_code` (array, len, back);\n   else\n     return 0;\n }"}]}