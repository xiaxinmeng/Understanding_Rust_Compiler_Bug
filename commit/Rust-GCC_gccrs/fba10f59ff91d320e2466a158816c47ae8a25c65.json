{"sha": "fba10f59ff91d320e2466a158816c47ae8a25c65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJhMTBmNTlmZjkxZDMyMGUyNDY2YTE1ODgxNmM0N2FlOGEyNWM2NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2007-05-08T06:50:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2007-05-08T06:50:32Z"}, "message": "cxxabi-internal.h: Remove, to be replaced by...\n\n        * libsupc++/cxxabi-internal.h: Remove, to be replaced by...\n        * libsupc++/cxxabi-forced.h: ...this new file.\n        * include/ext/vstring.tcc: Include cxxabi-forced.h instead.\n        * include/bits/istream.tcc: Likewise.\n        * include/bits/ostream.tcc: Likewise.\n        * include/bits/basic_string.tcc: Likewise.\n        * include/bits/ostream_insert.h: Likewise.\n        * include/bits/fstream.tcc: Likewise.\n        * include/std/bitset: Likewise.\n        * libsupc++/cxxabi.h: Restore previous contents.\n        * Makefile.am (headers): Add cxxabi-forced.h.\n        * Makefile.in: Regenerate.\n\nFrom-SVN: r124539", "tree": {"sha": "77b7f196ade1cff1541402dea2bac451bf77399c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77b7f196ade1cff1541402dea2bac451bf77399c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fba10f59ff91d320e2466a158816c47ae8a25c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba10f59ff91d320e2466a158816c47ae8a25c65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba10f59ff91d320e2466a158816c47ae8a25c65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba10f59ff91d320e2466a158816c47ae8a25c65/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ac97d816a6cbc700f4808223e21d6bdb50e4dd66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac97d816a6cbc700f4808223e21d6bdb50e4dd66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac97d816a6cbc700f4808223e21d6bdb50e4dd66"}], "stats": {"total": 1139, "additions": 570, "deletions": 569}, "files": [{"sha": "d5bb6afeda30a4121462cf667680b0d27cdea879", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -1,3 +1,18 @@\n+2007-05-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* libsupc++/cxxabi-internal.h: Remove, to be replaced by...\n+\t* libsupc++/cxxabi-forced.h: ...this new file.\n+\t* include/ext/vstring.tcc: Include cxxabi-forced.h instead.\n+\t* include/bits/istream.tcc: Likewise.\n+\t* include/bits/ostream.tcc: Likewise.\n+\t* include/bits/basic_string.tcc: Likewise.\n+\t* include/bits/ostream_insert.h: Likewise.\n+\t* include/bits/fstream.tcc: Likewise.\n+\t* include/std/bitset: Likewise.\n+\t* libsupc++/cxxabi.h: Restore previous contents.\n+\t* Makefile.am (headers): Add cxxabi-forced.h.\n+\t* Makefile.in: Regenerate.\n+\n 2007-05-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/util/testsuite_abi.cc: Add CXXABI_1.3.2."}, {"sha": "4613f4e53d4a6f9da55f164e62c04438788d15f0", "filename": "libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -1,6 +1,6 @@\n ## Linker script for GNU namespace versioning.\n ##\n-## Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+## Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n ##\n ## This file is part of the libstdc++ version 3 distribution.\n ##"}, {"sha": "062b02b598274de986791e53798cd84411157bea", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -46,7 +46,7 @@\n \n #pragma GCC system_header\n \n-#include <cxxabi-internal.h>\n+#include <cxxabi-forced.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "2653d6f65708a3b33e91cbd3ed2e08de722ebed3", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -1,6 +1,7 @@\n // File based streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,\n+// 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -42,7 +43,7 @@\n \n #pragma GCC system_header\n \n-#include <cxxabi-internal.h>\n+#include <cxxabi-forced.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "2e65b4847b96111fe5974db537c7036fff3a70cd", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -43,7 +43,7 @@\n \n #pragma GCC system_header\n \n-#include <cxxabi-internal.h>\n+#include <cxxabi-forced.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "06facc0360b055403dff2fb619e91eb0f4663ee8", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -43,7 +43,7 @@\n \n #pragma GCC system_header\n \n-#include <cxxabi-internal.h>\n+#include <cxxabi-forced.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "5f63263c297b5e268df92ad1b85bb8183b64433d", "filename": "libstdc++-v3/include/bits/ostream_insert.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream_insert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream_insert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream_insert.h?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -38,7 +38,7 @@\n #pragma GCC system_header\n \n #include <iosfwd>\n-#include <cxxabi-internal.h>\n+#include <cxxabi-forced.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "8d5b1b5e7752e86b33dcbe261db0bb91cb8177a4", "filename": "libstdc++-v3/include/ext/vstring.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -38,7 +38,7 @@\n \n #pragma GCC system_header\n \n-#include <cxxabi-internal.h>\n+#include <cxxabi-forced.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "61cad289b55d197290402a0bca4e8647972fb2e1", "filename": "libstdc++-v3/include/std/bitset", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -56,7 +56,7 @@\n #include <bits/functexcept.h>   // For invalid_argument, out_of_range,\n                                 // overflow_error\n #include <iosfwd>\n-#include <cxxabi-internal.h>\n+#include <cxxabi-forced.h>\n \n #define _GLIBCXX_BITSET_BITS_PER_WORD  (__CHAR_BIT__ * sizeof(unsigned long))\n #define _GLIBCXX_BITSET_WORDS(__n) \\"}, {"sha": "366efa27428083d99d1e238b369ff6402f9e2990", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -1,6 +1,6 @@\n ## Makefile for the GNU C++ Support library.\n ##\n-## Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005\n+## Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007\n ## Free Software Foundation, Inc.\n ##\n ## Process this file with automake to produce Makefile.in.\n@@ -33,7 +33,7 @@ noinst_LTLIBRARIES = libsupc++convenience.la\n \n \n headers = \\\n-\texception new typeinfo cxxabi.h exception_defines.h\n+\texception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h\n \n if GLIBCXX_HOSTED\n   c_sources = \\"}, {"sha": "85ae2006cde76adef15b025f2f77c40091886dd3", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -335,7 +335,7 @@ toolexeclib_LTLIBRARIES = libsupc++.la\n # 2) integrated libsupc++convenience.la that is to be a part of libstdc++.a\n noinst_LTLIBRARIES = libsupc++convenience.la\n headers = \\\n-\texception new typeinfo cxxabi.h exception_defines.h\n+\texception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h\n \n @GLIBCXX_HOSTED_TRUE@c_sources = \\\n @GLIBCXX_HOSTED_TRUE@\tcp-demangle.c "}, {"sha": "523ccba01a6a47d8c3af683e9dbdb5cf15c05140", "filename": "libstdc++-v3/libsupc++/cxxabi-forced.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-forced.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-forced.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-forced.h?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -0,0 +1,51 @@\n+// cxxabi.h subset for inclusion by other library headers -*- C++ -*-\n+  \n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CXXABI_FORCED_H\n+#define _CXXABI_FORCED_H 1\n+\n+#pragma GCC visibility push(default)\n+\n+#ifdef __cplusplus\n+namespace __cxxabiv1\n+{  \n+  // A magic placeholder class that can be caught by reference\n+  // to recognize forced unwinding.\n+  class __forced_unwind\n+  {\n+    virtual ~__forced_unwind() throw();\n+    virtual void __pure_dummy() = 0; // prevent catch by value\n+  };\n+}\n+#endif // __cplusplus\n+\n+#pragma GCC visibility pop\n+\n+#endif // __CXXABI_FORCED_H "}, {"sha": "dbe2e325fd5621f7a931693e1f748297cbc2ea31", "filename": "libstdc++-v3/libsupc++/cxxabi-internal.h", "status": "removed", "additions": 0, "deletions": 555, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac97d816a6cbc700f4808223e21d6bdb50e4dd66/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac97d816a6cbc700f4808223e21d6bdb50e4dd66/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-internal.h?ref=ac97d816a6cbc700f4808223e21d6bdb50e4dd66", "patch": "@@ -1,555 +0,0 @@\n-// new abi support -*- C++ -*-\n-  \n-// Copyright (C) 2000, 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of GCC.\n-//\n-// GCC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GCC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-// Boston, MA 02110-1301, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>\n- \n-/* This file declares the new abi entry points into the runtime. It is not\n-   normally necessary for user programs to include this header, or use the\n-   entry points directly. However, this header is available should that be\n-   needed.\n-   \n-   Some of the entry points are intended for both C and C++, thus this header\n-   is includable from both C and C++. Though the C++ specific parts are not\n-   available in C, naturally enough.  */\n-\n-/** @file cxxabi.h\n- *  The header provides an interface to the C++ ABI.\n- */\n-\n-#ifndef _CXXABI_INTERNAL_H\n-#define _CXXABI_INTERNAL_H 1\n-\n-#pragma GCC visibility push(default)\n-\n-#include <stddef.h>\n-#include <bits/cxxabi_tweaks.h>\n- \n-#ifdef __cplusplus\n-namespace __cxxabiv1\n-{  \n-  extern \"C\" \n-  {\n-#endif\n-\n-  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);\n-\n-  // Allocate array.\n-  void* \n-  __cxa_vec_new(size_t __element_count, size_t __element_size, \n-\t\tsize_t __padding_size, __cxa_cdtor_type constructor,\n-\t\t__cxa_cdtor_type destructor);\n-\n-  void*\n-  __cxa_vec_new2(size_t __element_count, size_t __element_size,\n-\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n-\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n-\t\t void (*__dealloc) (void*));\n-\n-  void*\n-  __cxa_vec_new3(size_t __element_count, size_t __element_size,\n-\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n-\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n-\t\t void (*__dealloc) (void*, size_t));\n-\n-  // Construct array.\n-  __cxa_vec_ctor_return_type\n-  __cxa_vec_ctor(void* __array_address, size_t __element_count,\n-\t\t size_t __element_size, __cxa_cdtor_type constructor,\n-\t\t __cxa_cdtor_type destructor);\n-\n-  __cxa_vec_ctor_return_type\n-  __cxa_vec_cctor(void* dest_array, void* src_array, size_t element_count, \n-\t\t  size_t element_size, \n-\t\t  __cxa_cdtor_return_type (*constructor) (void*, void*), \n-\t\t  __cxa_cdtor_type destructor);\n- \n-  // Destruct array.\n-  void \n-  __cxa_vec_dtor(void* __array_address, size_t __element_count,\n-\t\t size_t __element_size, __cxa_cdtor_type destructor);\n-  \n-  void \n-  __cxa_vec_cleanup(void* __array_address, size_t __element_count,\n-\t\t    size_t __element_size, __cxa_cdtor_type destructor);\n-  \n-  // Destruct and release array.\n-  void \n-  __cxa_vec_delete(void* __array_address, size_t __element_size,\n-\t\t   size_t __padding_size, __cxa_cdtor_type destructor);\n-\n-  void \n-  __cxa_vec_delete2(void* __array_address, size_t __element_size,\n-\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n-\t\t    void (*__dealloc) (void*));\n-                  \n-  void \n-  __cxa_vec_delete3(void* __array_address, size_t __element_size,\n-\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n-\t\t    void (*__dealloc) (void*, size_t));\n-\n-  int \n-  __cxa_guard_acquire(__guard*);\n-\n-  void \n-  __cxa_guard_release(__guard*);\n-\n-  void \n-  __cxa_guard_abort(__guard*);\n-\n-  // Pure virtual functions.\n-  void\n-  __cxa_pure_virtual(void);\n-\n-  // Exception handling.\n-  void\n-  __cxa_bad_cast();\n-\n-  void\n-  __cxa_bad_typeid();\n-\n-  // DSO destruction.\n-  int\n-  __cxa_atexit(void (*)(void*), void*, void*)\n-#ifdef __cplusplus\n-    throw ()\n-#endif\n-    ;\n-\n-  int\n-  __cxa_finalize(void*);\n-\n-  // Demangling routines. \n-  char*\n-  __cxa_demangle(const char* __mangled_name, char* __output_buffer,\n-\t\t size_t* __length, int* __status);\n-#ifdef __cplusplus\n-  }\n-} // namespace __cxxabiv1\n-#endif\n-\n-#ifdef __cplusplus\n-\n-#include <typeinfo>\n-\n-namespace __cxxabiv1\n-{\n-  // Type information for int, float etc.\n-  class __fundamental_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __fundamental_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__fundamental_type_info();\n-  };\n-\n-  // Type information for array objects.\n-  class __array_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __array_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__array_type_info();\n-  };\n-\n-  // Type information for functions (both member and non-member).\n-  class __function_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __function_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__function_type_info();\n-\n-  protected:\n-    // Implementation defined member function.\n-    virtual bool \n-    __is_function_p() const;\n-  };\n-\n-  // Type information for enumerations.\n-  class __enum_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __enum_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__enum_type_info();\n-  };\n-\n-  // Common type information for simple pointers and pointers to member.\n-  class __pbase_type_info : public std::type_info\n-  {\n-  public:\n-    unsigned int \t\t__flags; // Qualification of the target object.\n-    const std::type_info* \t__pointee; // Type of pointed to object.\n-\n-    explicit \n-    __pbase_type_info(const char* __n, int __quals, \n-\t\t      const std::type_info* __type)\n-    : std::type_info(__n), __flags(__quals), __pointee(__type)\n-    { }\n-    \n-    virtual \n-    ~__pbase_type_info();\n-\n-    // Implementation defined type.\n-    enum __masks \n-      {\n-\t__const_mask = 0x1,\n-\t__volatile_mask = 0x2,\n-\t__restrict_mask = 0x4,\n-\t__incomplete_mask = 0x8,\n-\t__incomplete_class_mask = 0x10\n-      };\n-\n-  protected:\n-    __pbase_type_info(const __pbase_type_info&);\n-\n-    __pbase_type_info&\n-    operator=(const __pbase_type_info&);\n-\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_catch(const std::type_info* __thr_type, void** __thr_obj, \n-\t       unsigned int __outer) const;\n-\n-    inline virtual bool \n-    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n-\t\t    unsigned __outer) const;\n-  };\n-\n-  // Type information for simple pointers.\n-  class __pointer_type_info : public __pbase_type_info\n-  {\n-  public:\n-    explicit \n-    __pointer_type_info(const char* __n, int __quals, \n-\t\t\tconst std::type_info* __type)\n-    : __pbase_type_info (__n, __quals, __type) { }\n-\n-\n-    virtual \n-    ~__pointer_type_info();\n-\n-  protected:\n-    // Implementation defined member functions.\n-    virtual bool \n-    __is_pointer_p() const;\n-\n-    virtual bool \n-    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj, \n-\t\t    unsigned __outer) const;\n-  };\n-\n-  class __class_type_info;\n-\n-  // Type information for a pointer to member variable.\n-  class __pointer_to_member_type_info : public __pbase_type_info\n-  {\n-  public:\n-    __class_type_info* __context;   // Class of the member.\n-\n-    explicit \n-    __pointer_to_member_type_info(const char* __n, int __quals,\n-\t\t\t\t  const std::type_info* __type, \n-\t\t\t\t  __class_type_info* __klass)\n-    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }\n-\n-    virtual \n-    ~__pointer_to_member_type_info();\n-\n-  protected:\n-    __pointer_to_member_type_info(const __pointer_to_member_type_info&);\n-\n-    __pointer_to_member_type_info&\n-    operator=(const __pointer_to_member_type_info&);\n-\n-    // Implementation defined member function.\n-    virtual bool \n-    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n-\t\t    unsigned __outer) const;\n-  };\n-\n-  // Helper class for __vmi_class_type.\n-  class __base_class_type_info\n-  {\n-  public:\n-    const __class_type_info* \t__base_type;  // Base class type.\n-    long \t\t\t__offset_flags;  // Offset and info.\n-\n-    enum __offset_flags_masks \n-      {\n-\t__virtual_mask = 0x1,\n-\t__public_mask = 0x2,\n-\t__hwm_bit = 2,\n-\t__offset_shift = 8          // Bits to shift offset.\n-      };\n-  \n-    // Implementation defined member functions.\n-    bool \n-    __is_virtual_p() const\n-    { return __offset_flags & __virtual_mask; }\n-\n-    bool \n-    __is_public_p() const\n-    { return __offset_flags & __public_mask; }\n-\n-    ptrdiff_t \n-    __offset() const\n-    { \n-      // This shift, being of a signed type, is implementation\n-      // defined. GCC implements such shifts as arithmetic, which is\n-      // what we want.\n-      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;\n-    }\n-  };\n-\n-  // Type information for a class.\n-  class __class_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __class_type_info (const char *__n) : type_info(__n) { }\n-\n-    virtual \n-    ~__class_type_info ();\n-\n-    // Implementation defined types.\n-    // The type sub_kind tells us about how a base object is contained\n-    // within a derived object. We often do this lazily, hence the\n-    // UNKNOWN value. At other times we may use NOT_CONTAINED to mean\n-    // not publicly contained.\n-    enum __sub_kind\n-      {\n-\t// We have no idea.\n-\t__unknown = 0, \n-\n-\t// Not contained within us (in some circumstances this might\n-\t// mean not contained publicly)\n-\t__not_contained, \n-\n-\t// Contained ambiguously.\n-\t__contained_ambig, \n-    \n-\t// Via a virtual path.\n-\t__contained_virtual_mask = __base_class_type_info::__virtual_mask, \n-\n-\t// Via a public path.\n-\t__contained_public_mask = __base_class_type_info::__public_mask,   \n-\n-\t// Contained within us.\n-\t__contained_mask = 1 << __base_class_type_info::__hwm_bit,\n-    \n-\t__contained_private = __contained_mask,\n-\t__contained_public = __contained_mask | __contained_public_mask\n-      };\n-\n-    struct __upcast_result;\n-    struct __dyncast_result;\n-\n-  protected:\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;\n-\n-    virtual bool \n-    __do_catch(const type_info* __thr_type, void** __thr_obj, \n-\t       unsigned __outer) const;\n-\n-  public:\n-    // Helper for upcast. See if DST is us, or one of our bases. \n-    // Return false if not found, true if found. \n-    virtual bool \n-    __do_upcast(const __class_type_info* __dst, const void* __obj,\n-\t\t__upcast_result& __restrict __result) const;\n-\n-    // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly\n-    // within OBJ_PTR. OBJ_PTR points to a base object of our type,\n-    // which is the destination type. SRC2DST indicates how SRC\n-    // objects might be contained within this type.  If SRC_PTR is one\n-    // of our SRC_TYPE bases, indicate the virtuality. Returns\n-    // not_contained for non containment or private containment.\n-    inline __sub_kind \n-    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n-\t\t      const __class_type_info* __src_type, \n-\t\t      const void* __src_ptr) const;\n-\n-    // Helper for dynamic cast. ACCESS_PATH gives the access from the\n-    // most derived object to this base. DST_TYPE indicates the\n-    // desired type we want. OBJ_PTR points to a base of our type\n-    // within the complete object. SRC_TYPE indicates the static type\n-    // started from and SRC_PTR points to that base within the most\n-    // derived object. Fill in RESULT with what we find. Return true\n-    // if we have located an ambiguous match.\n-    virtual bool \n-    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n-\t\t const __class_type_info* __dst_type, const void* __obj_ptr, \n-\t\t const __class_type_info* __src_type, const void* __src_ptr, \n-\t\t __dyncast_result& __result) const;\n-    \n-    // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE\n-    // bases are inherited by the type started from -- which is not\n-    // necessarily the current type. The current type will be a base\n-    // of the destination type.  OBJ_PTR points to the current base.\n-    virtual __sub_kind \n-    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n-\t\t\t const __class_type_info* __src_type,\n-\t\t\t const void* __src_ptr) const;\n-  };\n-\n-  // Type information for a class with a single non-virtual base.\n-  class __si_class_type_info : public __class_type_info\n-  {\n-  public:\n-    const __class_type_info* __base_type;\n-\n-    explicit \n-    __si_class_type_info(const char *__n, const __class_type_info *__base)\n-    : __class_type_info(__n), __base_type(__base) { }\n-\n-    virtual \n-    ~__si_class_type_info();\n-\n-  protected:\n-    __si_class_type_info(const __si_class_type_info&);\n-\n-    __si_class_type_info&\n-    operator=(const __si_class_type_info&);\n-\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n-\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n-\t\t const __class_type_info* __src_type, const void* __src_ptr,\n-\t\t __dyncast_result& __result) const;\n-\n-    virtual __sub_kind \n-    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n-\t\t\t const __class_type_info* __src_type,\n-\t\t\t const void* __sub_ptr) const;\n-\n-    virtual bool \n-    __do_upcast(const __class_type_info*__dst, const void*__obj,\n-\t\t__upcast_result& __restrict __result) const;\n-  };\n-\n-  // Type information for a class with multiple and/or virtual bases.\n-  class __vmi_class_type_info : public __class_type_info \n-  {\n-  public:\n-    unsigned int \t\t__flags;  // Details about the class hierarchy.\n-    unsigned int \t\t__base_count;  // Number of direct bases.\n-\n-    // The array of bases uses the trailing array struct hack so this\n-    // class is not constructable with a normal constructor. It is\n-    // internally generated by the compiler.\n-    __base_class_type_info \t__base_info[1];  // Array of bases.\n-\n-    explicit \n-    __vmi_class_type_info(const char* __n, int ___flags)\n-    : __class_type_info(__n), __flags(___flags), __base_count(0) { }\n-\n-    virtual \n-    ~__vmi_class_type_info();\n-\n-    // Implementation defined types.\n-    enum __flags_masks \n-      {\n-\t__non_diamond_repeat_mask = 0x1, // Distinct instance of repeated base.\n-\t__diamond_shaped_mask = 0x2, // Diamond shaped multiple inheritance.\n-\t__flags_unknown_mask = 0x10\n-      };\n-\n-  protected:\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n-\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n-\t\t const __class_type_info* __src_type, const void* __src_ptr,\n-\t\t __dyncast_result& __result) const;\n-\n-    virtual __sub_kind \n-    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr, \n-\t\t\t const __class_type_info* __src_type,\n-\t\t\t const void* __src_ptr) const;\n-    \n-    virtual bool \n-    __do_upcast(const __class_type_info* __dst, const void* __obj,\n-\t\t__upcast_result& __restrict __result) const;\n-  };\n-\n-  // Dynamic cast runtime.\n-  // src2dst has the following possible values\n-  //  >-1: src_type is a unique public non-virtual base of dst_type\n-  //       dst_ptr + src2dst == src_ptr\n-  //   -1: unspecified relationship\n-  //   -2: src_type is not a public base of dst_type\n-  //   -3: src_type is a multiple public non-virtual base of dst_type\n-  extern \"C\" void*\n-  __dynamic_cast(const void* __src_ptr, // Starting object.\n-\t\t const __class_type_info* __src_type, // Static type of object.\n-\t\t const __class_type_info* __dst_type, // Desired target type.\n-\t\t ptrdiff_t __src2dst); // How src and dst are related.\n-\n-\n-  // Returns the type_info for the currently handled exception [15.3/8], or\n-  // null if there is none.\n-  extern \"C\" std::type_info*\n-  __cxa_current_exception_type();\n-\n-  // A magic placeholder class that can be caught by reference\n-  // to recognize forced unwinding.\n-  class __forced_unwind\n-  {\n-    virtual ~__forced_unwind() throw();\n-    virtual void __pure() = 0; // prevent catch by value\n-  };\n-\n-  // A magic placeholder class that can be caught by reference\n-  // to recognize foreign exceptions.\n-  class __foreign_exception\n-  {\n-    virtual ~__foreign_exception() throw();\n-    virtual void __pure_virtual() = 0; // prevent catch by value\n-  };\n-\n-} // namespace __cxxabiv1\n-\n-#endif // __cplusplus\n-\n-#pragma GCC visibility pop\n-\n-#endif // __CXXABI_INTERNAL_H "}, {"sha": "7f0307834d358860d35ca6c80a4fad44a46edefc", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 491, "deletions": 2, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba10f59ff91d320e2466a158816c47ae8a25c65/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=fba10f59ff91d320e2466a158816c47ae8a25c65", "patch": "@@ -1,6 +1,6 @@\n // new abi support -*- C++ -*-\n   \n-// Copyright (C) 2000, 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2002, 2003, 2004, 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n //\n@@ -48,9 +48,498 @@\n \n #pragma GCC visibility push(default)\n \n-#include <cxxabi-internal.h>\n+#include <stddef.h>\n+#include <bits/cxxabi_tweaks.h>\n+#include <cxxabi-forced.h>\n  \n #ifdef __cplusplus\n+namespace __cxxabiv1\n+{  \n+  extern \"C\" \n+  {\n+#endif\n+\n+  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);\n+\n+  // Allocate array.\n+  void* \n+  __cxa_vec_new(size_t __element_count, size_t __element_size, \n+\t\tsize_t __padding_size, __cxa_cdtor_type constructor,\n+\t\t__cxa_cdtor_type destructor);\n+\n+  void*\n+  __cxa_vec_new2(size_t __element_count, size_t __element_size,\n+\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n+\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n+\t\t void (*__dealloc) (void*));\n+\n+  void*\n+  __cxa_vec_new3(size_t __element_count, size_t __element_size,\n+\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n+\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n+\t\t void (*__dealloc) (void*, size_t));\n+\n+  // Construct array.\n+  __cxa_vec_ctor_return_type\n+  __cxa_vec_ctor(void* __array_address, size_t __element_count,\n+\t\t size_t __element_size, __cxa_cdtor_type constructor,\n+\t\t __cxa_cdtor_type destructor);\n+\n+  __cxa_vec_ctor_return_type\n+  __cxa_vec_cctor(void* dest_array, void* src_array, size_t element_count, \n+\t\t  size_t element_size, \n+\t\t  __cxa_cdtor_return_type (*constructor) (void*, void*), \n+\t\t  __cxa_cdtor_type destructor);\n+ \n+  // Destruct array.\n+  void \n+  __cxa_vec_dtor(void* __array_address, size_t __element_count,\n+\t\t size_t __element_size, __cxa_cdtor_type destructor);\n+  \n+  void \n+  __cxa_vec_cleanup(void* __array_address, size_t __element_count,\n+\t\t    size_t __element_size, __cxa_cdtor_type destructor);\n+  \n+  // Destruct and release array.\n+  void \n+  __cxa_vec_delete(void* __array_address, size_t __element_size,\n+\t\t   size_t __padding_size, __cxa_cdtor_type destructor);\n+\n+  void \n+  __cxa_vec_delete2(void* __array_address, size_t __element_size,\n+\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n+\t\t    void (*__dealloc) (void*));\n+                  \n+  void \n+  __cxa_vec_delete3(void* __array_address, size_t __element_size,\n+\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n+\t\t    void (*__dealloc) (void*, size_t));\n+\n+  int \n+  __cxa_guard_acquire(__guard*);\n+\n+  void \n+  __cxa_guard_release(__guard*);\n+\n+  void \n+  __cxa_guard_abort(__guard*);\n+\n+  // Pure virtual functions.\n+  void\n+  __cxa_pure_virtual(void);\n+\n+  // Exception handling.\n+  void\n+  __cxa_bad_cast();\n+\n+  void\n+  __cxa_bad_typeid();\n+\n+  // DSO destruction.\n+  int\n+  __cxa_atexit(void (*)(void*), void*, void*)\n+#ifdef __cplusplus\n+    throw ()\n+#endif\n+    ;\n+\n+  int\n+  __cxa_finalize(void*);\n+\n+  // Demangling routines. \n+  char*\n+  __cxa_demangle(const char* __mangled_name, char* __output_buffer,\n+\t\t size_t* __length, int* __status);\n+#ifdef __cplusplus\n+  }\n+} // namespace __cxxabiv1\n+#endif\n+\n+#ifdef __cplusplus\n+\n+#include <typeinfo>\n+\n+namespace __cxxabiv1\n+{\n+  // Type information for int, float etc.\n+  class __fundamental_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __fundamental_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__fundamental_type_info();\n+  };\n+\n+  // Type information for array objects.\n+  class __array_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __array_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__array_type_info();\n+  };\n+\n+  // Type information for functions (both member and non-member).\n+  class __function_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __function_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__function_type_info();\n+\n+  protected:\n+    // Implementation defined member function.\n+    virtual bool \n+    __is_function_p() const;\n+  };\n+\n+  // Type information for enumerations.\n+  class __enum_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __enum_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__enum_type_info();\n+  };\n+\n+  // Common type information for simple pointers and pointers to member.\n+  class __pbase_type_info : public std::type_info\n+  {\n+  public:\n+    unsigned int \t\t__flags; // Qualification of the target object.\n+    const std::type_info* \t__pointee; // Type of pointed to object.\n+\n+    explicit \n+    __pbase_type_info(const char* __n, int __quals, \n+\t\t      const std::type_info* __type)\n+    : std::type_info(__n), __flags(__quals), __pointee(__type)\n+    { }\n+    \n+    virtual \n+    ~__pbase_type_info();\n+\n+    // Implementation defined type.\n+    enum __masks \n+      {\n+\t__const_mask = 0x1,\n+\t__volatile_mask = 0x2,\n+\t__restrict_mask = 0x4,\n+\t__incomplete_mask = 0x8,\n+\t__incomplete_class_mask = 0x10\n+      };\n+\n+  protected:\n+    __pbase_type_info(const __pbase_type_info&);\n+\n+    __pbase_type_info&\n+    operator=(const __pbase_type_info&);\n+\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_catch(const std::type_info* __thr_type, void** __thr_obj, \n+\t       unsigned int __outer) const;\n+\n+    inline virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n+\t\t    unsigned __outer) const;\n+  };\n+\n+  // Type information for simple pointers.\n+  class __pointer_type_info : public __pbase_type_info\n+  {\n+  public:\n+    explicit \n+    __pointer_type_info(const char* __n, int __quals, \n+\t\t\tconst std::type_info* __type)\n+    : __pbase_type_info (__n, __quals, __type) { }\n+\n+\n+    virtual \n+    ~__pointer_type_info();\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __is_pointer_p() const;\n+\n+    virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj, \n+\t\t    unsigned __outer) const;\n+  };\n+\n+  class __class_type_info;\n+\n+  // Type information for a pointer to member variable.\n+  class __pointer_to_member_type_info : public __pbase_type_info\n+  {\n+  public:\n+    __class_type_info* __context;   // Class of the member.\n+\n+    explicit \n+    __pointer_to_member_type_info(const char* __n, int __quals,\n+\t\t\t\t  const std::type_info* __type, \n+\t\t\t\t  __class_type_info* __klass)\n+    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }\n+\n+    virtual \n+    ~__pointer_to_member_type_info();\n+\n+  protected:\n+    __pointer_to_member_type_info(const __pointer_to_member_type_info&);\n+\n+    __pointer_to_member_type_info&\n+    operator=(const __pointer_to_member_type_info&);\n+\n+    // Implementation defined member function.\n+    virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n+\t\t    unsigned __outer) const;\n+  };\n+\n+  // Helper class for __vmi_class_type.\n+  class __base_class_type_info\n+  {\n+  public:\n+    const __class_type_info* \t__base_type;  // Base class type.\n+    long \t\t\t__offset_flags;  // Offset and info.\n+\n+    enum __offset_flags_masks \n+      {\n+\t__virtual_mask = 0x1,\n+\t__public_mask = 0x2,\n+\t__hwm_bit = 2,\n+\t__offset_shift = 8          // Bits to shift offset.\n+      };\n+  \n+    // Implementation defined member functions.\n+    bool \n+    __is_virtual_p() const\n+    { return __offset_flags & __virtual_mask; }\n+\n+    bool \n+    __is_public_p() const\n+    { return __offset_flags & __public_mask; }\n+\n+    ptrdiff_t \n+    __offset() const\n+    { \n+      // This shift, being of a signed type, is implementation\n+      // defined. GCC implements such shifts as arithmetic, which is\n+      // what we want.\n+      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;\n+    }\n+  };\n+\n+  // Type information for a class.\n+  class __class_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __class_type_info (const char *__n) : type_info(__n) { }\n+\n+    virtual \n+    ~__class_type_info ();\n+\n+    // Implementation defined types.\n+    // The type sub_kind tells us about how a base object is contained\n+    // within a derived object. We often do this lazily, hence the\n+    // UNKNOWN value. At other times we may use NOT_CONTAINED to mean\n+    // not publicly contained.\n+    enum __sub_kind\n+      {\n+\t// We have no idea.\n+\t__unknown = 0, \n+\n+\t// Not contained within us (in some circumstances this might\n+\t// mean not contained publicly)\n+\t__not_contained, \n+\n+\t// Contained ambiguously.\n+\t__contained_ambig, \n+    \n+\t// Via a virtual path.\n+\t__contained_virtual_mask = __base_class_type_info::__virtual_mask, \n+\n+\t// Via a public path.\n+\t__contained_public_mask = __base_class_type_info::__public_mask,   \n+\n+\t// Contained within us.\n+\t__contained_mask = 1 << __base_class_type_info::__hwm_bit,\n+    \n+\t__contained_private = __contained_mask,\n+\t__contained_public = __contained_mask | __contained_public_mask\n+      };\n+\n+    struct __upcast_result;\n+    struct __dyncast_result;\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;\n+\n+    virtual bool \n+    __do_catch(const type_info* __thr_type, void** __thr_obj, \n+\t       unsigned __outer) const;\n+\n+  public:\n+    // Helper for upcast. See if DST is us, or one of our bases. \n+    // Return false if not found, true if found. \n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst, const void* __obj,\n+\t\t__upcast_result& __restrict __result) const;\n+\n+    // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly\n+    // within OBJ_PTR. OBJ_PTR points to a base object of our type,\n+    // which is the destination type. SRC2DST indicates how SRC\n+    // objects might be contained within this type.  If SRC_PTR is one\n+    // of our SRC_TYPE bases, indicate the virtuality. Returns\n+    // not_contained for non containment or private containment.\n+    inline __sub_kind \n+    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t      const __class_type_info* __src_type, \n+\t\t      const void* __src_ptr) const;\n+\n+    // Helper for dynamic cast. ACCESS_PATH gives the access from the\n+    // most derived object to this base. DST_TYPE indicates the\n+    // desired type we want. OBJ_PTR points to a base of our type\n+    // within the complete object. SRC_TYPE indicates the static type\n+    // started from and SRC_PTR points to that base within the most\n+    // derived object. Fill in RESULT with what we find. Return true\n+    // if we have located an ambiguous match.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr, \n+\t\t const __class_type_info* __src_type, const void* __src_ptr, \n+\t\t __dyncast_result& __result) const;\n+    \n+    // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE\n+    // bases are inherited by the type started from -- which is not\n+    // necessarily the current type. The current type will be a base\n+    // of the destination type.  OBJ_PTR points to the current base.\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __src_ptr) const;\n+  };\n+\n+  // Type information for a class with a single non-virtual base.\n+  class __si_class_type_info : public __class_type_info\n+  {\n+  public:\n+    const __class_type_info* __base_type;\n+\n+    explicit \n+    __si_class_type_info(const char *__n, const __class_type_info *__base)\n+    : __class_type_info(__n), __base_type(__base) { }\n+\n+    virtual \n+    ~__si_class_type_info();\n+\n+  protected:\n+    __si_class_type_info(const __si_class_type_info&);\n+\n+    __si_class_type_info&\n+    operator=(const __si_class_type_info&);\n+\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n+\t\t const __class_type_info* __src_type, const void* __src_ptr,\n+\t\t __dyncast_result& __result) const;\n+\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __sub_ptr) const;\n+\n+    virtual bool \n+    __do_upcast(const __class_type_info*__dst, const void*__obj,\n+\t\t__upcast_result& __restrict __result) const;\n+  };\n+\n+  // Type information for a class with multiple and/or virtual bases.\n+  class __vmi_class_type_info : public __class_type_info \n+  {\n+  public:\n+    unsigned int \t\t__flags;  // Details about the class hierarchy.\n+    unsigned int \t\t__base_count;  // Number of direct bases.\n+\n+    // The array of bases uses the trailing array struct hack so this\n+    // class is not constructable with a normal constructor. It is\n+    // internally generated by the compiler.\n+    __base_class_type_info \t__base_info[1];  // Array of bases.\n+\n+    explicit \n+    __vmi_class_type_info(const char* __n, int ___flags)\n+    : __class_type_info(__n), __flags(___flags), __base_count(0) { }\n+\n+    virtual \n+    ~__vmi_class_type_info();\n+\n+    // Implementation defined types.\n+    enum __flags_masks \n+      {\n+\t__non_diamond_repeat_mask = 0x1, // Distinct instance of repeated base.\n+\t__diamond_shaped_mask = 0x2, // Diamond shaped multiple inheritance.\n+\t__flags_unknown_mask = 0x10\n+      };\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n+\t\t const __class_type_info* __src_type, const void* __src_ptr,\n+\t\t __dyncast_result& __result) const;\n+\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr, \n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __src_ptr) const;\n+    \n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst, const void* __obj,\n+\t\t__upcast_result& __restrict __result) const;\n+  };\n+\n+  // Dynamic cast runtime.\n+  // src2dst has the following possible values\n+  //  >-1: src_type is a unique public non-virtual base of dst_type\n+  //       dst_ptr + src2dst == src_ptr\n+  //   -1: unspecified relationship\n+  //   -2: src_type is not a public base of dst_type\n+  //   -3: src_type is a multiple public non-virtual base of dst_type\n+  extern \"C\" void*\n+  __dynamic_cast(const void* __src_ptr, // Starting object.\n+\t\t const __class_type_info* __src_type, // Static type of object.\n+\t\t const __class_type_info* __dst_type, // Desired target type.\n+\t\t ptrdiff_t __src2dst); // How src and dst are related.\n+\n+\n+  // Returns the type_info for the currently handled exception [15.3/8], or\n+  // null if there is none.\n+  extern \"C\" std::type_info*\n+  __cxa_current_exception_type();\n+\n+  // A magic placeholder class that can be caught by reference\n+  // to recognize foreign exceptions.\n+  class __foreign_exception\n+  {\n+    virtual ~__foreign_exception() throw();\n+    virtual void __pure_dummy() = 0; // prevent catch by value\n+  };\n+\n+} // namespace __cxxabiv1\n \n // User programs should use the alias `abi'. \n namespace abi = __cxxabiv1;"}]}