{"sha": "cf650568d8f0a1bfc5293447e45117e0623fa908", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y2NTA1NjhkOGYwYTFiZmM1MjkzNDQ3ZTQ1MTE3ZTA2MjNmYTkwOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-30T21:55:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-30T21:55:12Z"}, "message": "PR c++/91369 - Implement P0784R7: constexpr new\n\n\tPR c++/91369 - Implement P0784R7: constexpr new\n\t* constexpr.c (cxx_replaceable_global_alloc_fn): Don't return true\n\tfor placement new.\n\t(cxx_placement_new_fn, is_std_construct_at): New functions.\n\t(cxx_eval_call_expression): Allow placement new in std::construct_at.\n\t(potential_constant_expression_1): Likewise.\n\n\t* g++.dg/cpp2a/constexpr-new5.C: New test.\n\nFrom-SVN: r277649", "tree": {"sha": "5ff224ee73b02b90dfdffbaf911a43ff72bd31f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ff224ee73b02b90dfdffbaf911a43ff72bd31f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf650568d8f0a1bfc5293447e45117e0623fa908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf650568d8f0a1bfc5293447e45117e0623fa908", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf650568d8f0a1bfc5293447e45117e0623fa908", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf650568d8f0a1bfc5293447e45117e0623fa908/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97ccc60e0c8590e22488e909464fc591eb8b0534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97ccc60e0c8590e22488e909464fc591eb8b0534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97ccc60e0c8590e22488e909464fc591eb8b0534"}], "stats": {"total": 152, "additions": 150, "deletions": 2}, "files": [{"sha": "efb135e385d1fffb95e6b92671d2e8b6b758bd62", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cf650568d8f0a1bfc5293447e45117e0623fa908", "patch": "@@ -1,5 +1,12 @@\n 2019-10-30  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/91369 - Implement P0784R7: constexpr new\n+\t* constexpr.c (cxx_replaceable_global_alloc_fn): Don't return true\n+\tfor placement new.\n+\t(cxx_placement_new_fn, is_std_construct_at): New functions.\n+\t(cxx_eval_call_expression): Allow placement new in std::construct_at.\n+\t(potential_constant_expression_1): Likewise.\n+\n \t* typeck.c (decl_in_std_namespace_p): Return true also for decls\n \tin inline namespaces inside of std namespace.\n "}, {"sha": "75db0b3c72deaf6113ae43daafc8cce9f303c6e9", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=cf650568d8f0a1bfc5293447e45117e0623fa908", "patch": "@@ -1601,7 +1601,41 @@ cxx_replaceable_global_alloc_fn (tree fndecl)\n {\n   return (cxx_dialect >= cxx2a\n \t  && IDENTIFIER_NEWDEL_OP_P (DECL_NAME (fndecl))\n-\t  && CP_DECL_CONTEXT (fndecl) == global_namespace);\n+\t  && CP_DECL_CONTEXT (fndecl) == global_namespace\n+\t  && (DECL_IS_REPLACEABLE_OPERATOR_NEW_P (fndecl)\n+\t      || DECL_IS_OPERATOR_DELETE_P (fndecl)));\n+}\n+\n+/* Return true if FNDECL is a placement new function that should be\n+   useable during constant expression evaluation of std::construct_at.  */\n+\n+static inline bool\n+cxx_placement_new_fn (tree fndecl)\n+{\n+  if (cxx_dialect >= cxx2a\n+      && IDENTIFIER_NEW_OP_P (DECL_NAME (fndecl))\n+      && CP_DECL_CONTEXT (fndecl) == global_namespace\n+      && !DECL_IS_REPLACEABLE_OPERATOR_NEW_P (fndecl)\n+      && TREE_CODE (TREE_TYPE (fndecl)) == FUNCTION_TYPE)\n+    {\n+      tree first_arg = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n+      if (TREE_VALUE (first_arg) == ptr_type_node\n+\t  && TREE_CHAIN (first_arg) == void_list_node)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if FNDECL is std::construct_at.  */\n+\n+static inline bool\n+is_std_construct_at (tree fndecl)\n+{\n+  if (!decl_in_std_namespace_p (fndecl))\n+    return false;\n+\n+  tree name = DECL_NAME (fndecl);\n+  return name && id_equal (name, \"construct_at\");\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -1738,6 +1772,27 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      return t;\n \t    }\n \t}\n+      /* Allow placement new in std::construct_at, just return the second\n+\t argument.  */\n+      if (cxx_placement_new_fn (fun)\n+\t  && ctx->call\n+\t  && ctx->call->fundef\n+\t  && is_std_construct_at (ctx->call->fundef->decl))\n+\t{\n+\t  const int nargs = call_expr_nargs (t);\n+\t  tree arg1 = NULL_TREE;\n+\t  for (int i = 0; i < nargs; ++i)\n+\t    {\n+\t      tree arg = CALL_EXPR_ARG (t, i);\n+\t      arg = cxx_eval_constant_expression (ctx, arg, false,\n+\t\t\t\t\t\t  non_constant_p, overflow_p);\n+\t      VERIFY_CONSTANT (arg);\n+\t      if (i == 1)\n+\t\targ1 = arg;\n+\t    }\n+\t  gcc_assert (arg1);\n+\t  return arg1;\n+\t}\n       if (!ctx->quiet)\n \t{\n \t  if (!lambda_static_thunk_p (fun))\n@@ -6453,7 +6508,11 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t    && !fndecl_built_in_p (fun)\n \t\t    /* In C++2a, replaceable global allocation functions\n \t\t       are constant expressions.  */\n-\t\t    && !cxx_replaceable_global_alloc_fn (fun))\n+\t\t    && !cxx_replaceable_global_alloc_fn (fun)\n+\t\t    /* Allow placement new in std::construct_at.  */\n+\t\t    && (!cxx_placement_new_fn (fun)\n+\t\t\t|| current_function_decl == NULL_TREE\n+\t\t\t|| !is_std_construct_at (current_function_decl)))\n \t\t  {\n \t\t    if (flags & tf_error)\n \t\t      {"}, {"sha": "fe2c48acf5c6debbef6cf0f8342e57149bade254", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cf650568d8f0a1bfc5293447e45117e0623fa908", "patch": "@@ -1,5 +1,8 @@\n 2019-10-30  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/91369 - Implement P0784R7: constexpr new\n+\t* g++.dg/cpp2a/constexpr-new5.C: New test.\n+\n \t* g++.dg/cpp0x/Wpessimizing-move6.C: New test.\n \n 2019-10-30  Bernd Edlinger  <bernd.edlinger@hotmail.de>"}, {"sha": "b2b65f2ba8263f6d22224db8556246e8e283399e", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new5.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf650568d8f0a1bfc5293447e45117e0623fa908/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new5.C?ref=cf650568d8f0a1bfc5293447e45117e0623fa908", "patch": "@@ -0,0 +1,79 @@\n+// P0784R7\n+// { dg-do compile { target c++2a } }\n+\n+namespace std\n+{\n+  typedef __SIZE_TYPE__ size_t;\n+\n+  template <typename T>\n+  struct allocator\n+  {\n+    constexpr allocator () noexcept {}\n+\n+    constexpr T *allocate (size_t n)\n+    { return static_cast<T *> (::operator new (n * sizeof(T))); }\n+\n+    constexpr void\n+    deallocate (T *p, size_t n)\n+    { ::operator delete (p); }\n+  };\n+\n+  template <typename T, typename U = T &&>\n+  U __declval (int);\n+  template <typename T>\n+  T __declval (long);\n+  template <typename T>\n+  auto declval () noexcept -> decltype (__declval<T> (0));\n+\n+  template <typename T>\n+  struct remove_reference\n+  { typedef T type; };\n+  template <typename T>\n+  struct remove_reference<T &>\n+  { typedef T type; };\n+  template <typename T>\n+  struct remove_reference<T &&>\n+  { typedef T type; };\n+\n+  template <typename T>\n+  constexpr T &&\n+  forward (typename std::remove_reference<T>::type &t) noexcept\n+  { return static_cast<T&&> (t); }\n+\n+  template<typename T>\n+  constexpr T &&\n+  forward (typename std::remove_reference<T>::type &&t) noexcept\n+  { return static_cast<T&&> (t); }\n+\n+  template <typename T, typename... A>\n+  constexpr auto\n+  construct_at (T *l, A &&... a)\n+  noexcept (noexcept (::new ((void *) 0) T (std::declval<A> ()...)))\n+  -> decltype (::new ((void *) 0) T (std::declval<A> ()...))\n+  { return ::new ((void *) l) T (std::forward<A> (a)...); }\n+\n+  template <typename T>\n+  constexpr inline void\n+  destroy_at (T *l)\n+  { l->~T (); }\n+}\n+\n+inline void *operator new (std::size_t, void *p) noexcept\n+{ return p; }\n+\n+constexpr bool\n+foo ()\n+{\n+  std::allocator<int> a;\n+  auto p = a.allocate (2);\n+  std::construct_at (p, 1);\n+  std::construct_at (p + 1, 2);\n+  if (p[0] != 1 || p[1] != 2)\n+    throw 1;\n+  std::destroy_at (p);\n+  std::destroy_at (p + 1);\n+  a.deallocate (p, 2);\n+  return true;\n+}\n+\n+static_assert (foo ());"}]}