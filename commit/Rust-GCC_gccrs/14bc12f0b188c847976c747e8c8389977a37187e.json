{"sha": "14bc12f0b188c847976c747e8c8389977a37187e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiYzEyZjBiMTg4Yzg0Nzk3NmM3NDdlOGM4Mzg5OTc3YTM3MTg3ZQ==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2019-07-03T08:14:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-03T08:14:52Z"}, "message": "[Ada] SPARK pointer support extended to local borrowers and observers\n\nSPARK rules allow local borrowers and observers to be declared. During\ntheir lifetime, the access to the borrowed/observed object is\nrestricted.\n\nThere is no impact on compilation.\n\n2019-07-03  Yannick Moy  <moy@adacore.com>\n\ngcc/ada/\n\n\t* sem_spark.adb: Add support for locally borrowing and observing\n\ta path.\n\t(Get_Root_Object): Add parameter Through_Traversal to denote\n\twhen we are interesting in getting to the traversed parameter.\n\t(Is_Prefix_Or_Almost): New function to support detection of\n\tillegal access to borrowed or observed paths.\n\t(Check_Pragma): Add analysis of assertion pragmas.\n\nFrom-SVN: r272975", "tree": {"sha": "3b9fce1972cb7ee6c136b434de165e02967781dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b9fce1972cb7ee6c136b434de165e02967781dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14bc12f0b188c847976c747e8c8389977a37187e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14bc12f0b188c847976c747e8c8389977a37187e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14bc12f0b188c847976c747e8c8389977a37187e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14bc12f0b188c847976c747e8c8389977a37187e/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "558241c0f71b4171c471100631af79aa93c0a9e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558241c0f71b4171c471100631af79aa93c0a9e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/558241c0f71b4171c471100631af79aa93c0a9e7"}], "stats": {"total": 881, "additions": 706, "deletions": 175}, "files": [{"sha": "4ce8d74bb70bae505687032998359c6d16abb730", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc12f0b188c847976c747e8c8389977a37187e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc12f0b188c847976c747e8c8389977a37187e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=14bc12f0b188c847976c747e8c8389977a37187e", "patch": "@@ -1,3 +1,13 @@\n+2019-07-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_spark.adb: Add support for locally borrowing and observing\n+\ta path.\n+\t(Get_Root_Object): Add parameter Through_Traversal to denote\n+\twhen we are interesting in getting to the traversed parameter.\n+\t(Is_Prefix_Or_Almost): New function to support detection of\n+\tillegal access to borrowed or observed paths.\n+\t(Check_Pragma): Add analysis of assertion pragmas.\n+\n 2019-07-03  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Build_Predicate_Functions): In a generic context"}, {"sha": "ff99e6005283ceeafac7215c31d211c05c50a1c5", "filename": "gcc/ada/sem_spark.adb", "status": "modified", "additions": 696, "deletions": 175, "changes": 871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc12f0b188c847976c747e8c8389977a37187e/gcc%2Fada%2Fsem_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc12f0b188c847976c747e8c8389977a37187e/gcc%2Fada%2Fsem_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.adb?ref=14bc12f0b188c847976c747e8c8389977a37187e", "patch": "@@ -195,6 +195,18 @@ package body Sem_SPARK is\n       --  The type defining the hash table saving the environments at the entry\n       --  of each loop.\n \n+      package Variable_Maps is new Simple_HTable\n+        (Header_Num => Elaboration_Context_Index,\n+         Key        => Entity_Id,\n+         Element    => Node_Id,\n+         No_Element => Empty,\n+         Hash       => Elaboration_Context_Hash,\n+         Equal      => \"=\");\n+\n+      type Variable_Mapping is new Variable_Maps.Instance;\n+      --  Mapping from variables to nodes denoting paths that are observed or\n+      --  borrowed by the variable.\n+\n       --------------------\n       -- Simple Getters --\n       --------------------\n@@ -220,15 +232,15 @@ package body Sem_SPARK is\n          To   : in out Perm_Env);\n       --  Procedure to copy a permission environment\n \n-      procedure Move_Env\n-        (From : in out Perm_Env;\n-         To   : in out Perm_Env);\n+      procedure Move_Env (From, To : in out Perm_Env);\n       --  Procedure to move a permission environment. It frees To, moves From\n       --  in To and sets From to Nil.\n \n-      procedure Copy_Tree\n-        (From : Perm_Tree_Access;\n-         To   : Perm_Tree_Access);\n+      procedure Move_Variable_Mapping (From, To : in out Variable_Mapping);\n+      --  Move a variable mapping, freeing memory as needed and resetting the\n+      --  source mapping.\n+\n+      procedure Copy_Tree (From, To : Perm_Tree_Access);\n       --  Procedure to copy a permission tree\n \n       procedure Free_Env (PE : in out Perm_Env);\n@@ -301,7 +313,7 @@ package body Sem_SPARK is\n       -- Copy_Tree --\n       ---------------\n \n-      procedure Copy_Tree (From : Perm_Tree_Access; To : Perm_Tree_Access) is\n+      procedure Copy_Tree (From, To : Perm_Tree_Access) is\n       begin\n          --  Copy the direct components of the tree\n \n@@ -456,13 +468,24 @@ package body Sem_SPARK is\n       -- Move_Env --\n       --------------\n \n-      procedure Move_Env (From : in out Perm_Env; To : in out Perm_Env) is\n+      procedure Move_Env (From, To : in out Perm_Env) is\n       begin\n          Free_Env (To);\n          To   := From;\n          From := Perm_Env (Perm_Tree_Maps.Nil);\n       end Move_Env;\n \n+      ---------------------------\n+      -- Move_Variable_Mapping --\n+      ---------------------------\n+\n+      procedure Move_Variable_Mapping (From, To : in out Variable_Mapping) is\n+      begin\n+         Reset (To);\n+         To   := From;\n+         From := Variable_Mapping (Variable_Maps.Nil);\n+      end Move_Variable_Mapping;\n+\n       ----------------\n       -- Permission --\n       ----------------\n@@ -609,11 +632,14 @@ package body Sem_SPARK is\n \n    procedure Check_Parameter_Or_Global\n      (Expr       : Node_Id;\n-      Param_Mode : Formal_Kind;\n+      Typ        : Entity_Id;\n+      Kind       : Formal_Kind;\n       Subp       : Entity_Id;\n       Global_Var : Boolean);\n    --  Check the permission of every actual parameter or global\n \n+   procedure Check_Pragma (Prag : Node_Id);\n+\n    procedure Check_Source_Of_Borrow_Or_Observe\n      (Expr   : Node_Id;\n       Status : out Error_Status);\n@@ -640,14 +666,18 @@ package body Sem_SPARK is\n    --  subtree for that node. If the tree is folded, then it unrolls the tree\n    --  up to the appropriate level.\n \n-   function Get_Root_Object (Expr : Node_Id) return Entity_Id;\n+   function Get_Root_Object\n+     (Expr              : Node_Id;\n+      Through_Traversal : Boolean := True) return Entity_Id;\n    pragma Precondition (Is_Path_Expression (Expr));\n    --  Return the root of the path expression Expr, or Empty for an allocator,\n-   --  NULL, or a function call.\n+   --  NULL, or a function call. Through_Traversal is True if it should fo\n+   --  through calls to traversal functions.\n \n    generic\n       with procedure Handle_Parameter_Or_Global\n         (Expr       : Node_Id;\n+         Formal_Typ : Entity_Id;\n          Param_Mode : Formal_Kind;\n          Subp       : Entity_Id;\n          Global_Var : Boolean);\n@@ -676,8 +706,15 @@ package body Sem_SPARK is\n    function Is_Path_Expression (Expr : Node_Id) return Boolean;\n    --  Return whether Expr corresponds to a path\n \n+   function Is_Prefix_Or_Almost (Pref, Expr : Node_Id) return Boolean;\n+   --  Determine if the candidate Prefix is indeed a prefix of Expr, or almost\n+   --  a prefix, in the sense that they could still refer to overlapping memory\n+   --  locations.\n+\n    function Is_Traversal_Function (E : Entity_Id) return Boolean;\n \n+   function Is_Traversal_Function_Call (Expr : Node_Id) return Boolean;\n+\n    function Loop_Of_Exit (N : Node_Id) return Entity_Id;\n    --  A function that takes an exit statement node and returns the entity of\n    --  the loop that this statement is exiting from.\n@@ -718,7 +755,8 @@ package body Sem_SPARK is\n \n    procedure Return_Parameter_Or_Global\n      (Id         : Entity_Id;\n-      Mode       : Formal_Kind;\n+      Typ        : Entity_Id;\n+      Kind       : Formal_Kind;\n       Subp       : Entity_Id;\n       Global_Var : Boolean);\n    --  Auxiliary procedure to Return_Parameters and Return_Globals\n@@ -770,7 +808,8 @@ package body Sem_SPARK is\n \n    procedure Setup_Parameter_Or_Global\n      (Id         : Entity_Id;\n-      Param_Mode : Formal_Kind;\n+      Typ        : Entity_Id;\n+      Kind       : Formal_Kind;\n       Subp       : Entity_Id;\n       Global_Var : Boolean);\n    --  Auxiliary procedure to Setup_Parameters and Setup_Globals\n@@ -812,6 +851,12 @@ package body Sem_SPARK is\n    --  restrictive than the saved environment at the beginning of the loop, and\n    --  the permission environment after the loop is equal to the accumulator.\n \n+   Current_Borrowers : Variable_Mapping;\n+   --  Mapping from borrowers to the path borrowed\n+\n+   Current_Observers : Variable_Mapping;\n+   --  Mapping from observers to the path observed\n+\n    --------------------\n    -- Handle_Globals --\n    --------------------\n@@ -852,10 +897,12 @@ package body Sem_SPARK is\n                null;\n             else\n                Handle_Parameter_Or_Global (Expr       => Item,\n+                                           Formal_Typ => Etype (Item),\n                                            Param_Mode => Kind,\n                                            Subp       => Subp,\n                                            Global_Var => True);\n             end if;\n+\n             Next_Global (Item);\n          end loop;\n       end Handle_Globals_From_List;\n@@ -928,12 +975,105 @@ package body Sem_SPARK is\n    ----------------------\n \n    procedure Check_Assignment (Target : Node_Or_Entity_Id; Expr : Node_Id) is\n+\n+      --  Local subprograms\n+\n+      procedure Handle_Borrow\n+        (Var     : Entity_Id;\n+         Expr    : Node_Id;\n+         Is_Decl : Boolean);\n+      --  Update map of current borrowers\n+\n+      procedure Handle_Observe\n+        (Var     : Entity_Id;\n+         Expr    : Node_Id;\n+         Is_Decl : Boolean);\n+      --  Update map of current observers\n+\n+      -------------------\n+      -- Handle_Borrow --\n+      -------------------\n+\n+      procedure Handle_Borrow\n+        (Var     : Entity_Id;\n+         Expr    : Node_Id;\n+         Is_Decl : Boolean)\n+      is\n+         Borrowed : Node_Id;\n+\n+      begin\n+         if Is_Traversal_Function_Call (Expr) then\n+            Borrowed := First_Actual (Expr);\n+         else\n+            Borrowed := Expr;\n+         end if;\n+\n+         --  SPARK RM 3.10(8): If the type of the target is an anonymous\n+         --  access-to-variable type (an owning access type), the source shall\n+         --  be an owning access object [..] whose root object is the target\n+         --  object itself.\n+\n+         --  ??? In fact we could be slightly more permissive in allowing even\n+         --  a call to a traversal function of the right form.\n+\n+         if not Is_Decl\n+           and then (Is_Traversal_Function_Call (Expr)\n+                      or else Get_Root_Object (Borrowed) /= Var)\n+         then\n+            Error_Msg_NE\n+              (\"source of assignment must have & as root (SPARK RM 3.10(8)))\",\n+               Expr, Var);\n+            return;\n+         end if;\n+\n+         Set (Current_Borrowers, Var, Borrowed);\n+      end Handle_Borrow;\n+\n+      --------------------\n+      -- Handle_Observe --\n+      --------------------\n+\n+      procedure Handle_Observe\n+        (Var     : Entity_Id;\n+         Expr    : Node_Id;\n+         Is_Decl : Boolean)\n+      is\n+         Observed : Node_Id;\n+      begin\n+         if Is_Traversal_Function_Call (Expr) then\n+            Observed := First_Actual (Expr);\n+         else\n+            Observed := Expr;\n+         end if;\n+\n+         --  ??? We are currently using the same restriction for observers\n+         --  as for borrowers. To be seen if the SPARK RM current rule really\n+         --  allows more uses.\n+\n+         if not Is_Decl\n+           and then (Is_Traversal_Function_Call (Expr)\n+                      or else Get_Root_Object (Observed) /= Var)\n+         then\n+            Error_Msg_NE\n+              (\"source of assignment must have & as root (SPARK RM 3.10(8)))\",\n+               Expr, Var);\n+            return;\n+         end if;\n+\n+         Set (Current_Observers, Var, Observed);\n+      end Handle_Observe;\n+\n+      --  Local variables\n+\n       Target_Typ  : constant Node_Id := Etype (Target);\n+      Is_Decl     : constant Boolean := Nkind (Target) = N_Defining_Identifier;\n       Target_Root : Entity_Id;\n       Expr_Root   : Entity_Id;\n       Perm        : Perm_Kind;\n       Status      : Error_Status;\n \n+   --  Start of processing for Check_Assignment\n+\n    begin\n       Check_Type (Target_Typ);\n \n@@ -944,7 +1084,7 @@ package body Sem_SPARK is\n             return;\n          end if;\n \n-         if Nkind (Target) = N_Defining_Identifier then\n+         if Is_Decl then\n             Target_Root := Target;\n          else\n             Target_Root := Get_Root_Object (Target);\n@@ -956,8 +1096,7 @@ package body Sem_SPARK is\n          --  the target is a stand-alone object of an anonymous\n          --  access-to-object type\n \n-         pragma Assert\n-           (Ekind_In (Target_Root, E_Variable, E_Constant));\n+         pragma Assert (Present (Target_Root));\n \n          --  If the type of the target is an anonymous\n          --  access-to-constant type (an observing access type), the\n@@ -992,6 +1131,8 @@ package body Sem_SPARK is\n             --  name that is in the Unrestricted state, and whose root\n             --  object is the target object itself.\n \n+            Handle_Observe (Target_Root, Expr, Is_Decl);\n+\n          else\n             Perm := Get_Perm (Expr);\n \n@@ -1000,18 +1141,22 @@ package body Sem_SPARK is\n                return;\n             end if;\n \n-            if not Is_Entity_Name (Target) then\n-               Error_Msg_N\n-                 (\"target of borrow must be stand-alone variable\",\n-                  Target);\n-               return;\n+            if not Is_Decl then\n+               if not Is_Entity_Name (Target) then\n+                  Error_Msg_N\n+                    (\"target of borrow must be stand-alone variable\",\n+                     Target);\n+                  return;\n \n-            elsif Target_Root /= Expr_Root then\n-               Error_Msg_NE\n-                 (\"source of borrow must be variable &\",\n-                  Expr, Target);\n-               return;\n+               elsif Target_Root /= Expr_Root then\n+                  Error_Msg_NE\n+                    (\"source of borrow must be variable &\",\n+                     Expr, Target);\n+                  return;\n+               end if;\n             end if;\n+\n+            Handle_Borrow (Target_Root, Expr, Is_Decl);\n          end if;\n \n       elsif Is_Deep (Target_Typ) then\n@@ -1051,10 +1196,12 @@ package body Sem_SPARK is\n \n       procedure Check_Param (Formal : Entity_Id; Actual : Node_Id) is\n       begin\n-         Check_Parameter_Or_Global (Expr       => Actual,\n-                                    Param_Mode => Formal_Kind'(Ekind (Formal)),\n-                                    Subp       => Subp,\n-                                    Global_Var => False);\n+         Check_Parameter_Or_Global\n+           (Expr       => Actual,\n+            Typ        => Underlying_Type (Etype (Formal)),\n+            Kind       => Ekind (Formal),\n+            Subp       => Subp,\n+            Global_Var => False);\n       end Check_Param;\n \n       ------------------\n@@ -1096,11 +1243,14 @@ package body Sem_SPARK is\n    -------------------------\n \n    procedure Check_Callable_Body (Body_N : Node_Id) is\n-      Save_In_Elab : constant Boolean := Inside_Elaboration;\n-      Body_Id      : constant Entity_Id := Defining_Entity (Body_N);\n-      Spec_Id      : constant Entity_Id := Unique_Entity (Body_Id);\n-      Prag         : constant Node_Id := SPARK_Pragma (Body_Id);\n-      Saved_Env    : Perm_Env;\n+      Save_In_Elab    : constant Boolean := Inside_Elaboration;\n+      Body_Id         : constant Entity_Id := Defining_Entity (Body_N);\n+      Spec_Id         : constant Entity_Id := Unique_Entity (Body_Id);\n+      Prag            : constant Node_Id := SPARK_Pragma (Body_Id);\n+\n+      Saved_Env       : Perm_Env;\n+      Saved_Borrowers : Variable_Mapping;\n+      Saved_Observers : Variable_Mapping;\n \n    begin\n       --  Only SPARK bodies are analyzed\n@@ -1116,6 +1266,8 @@ package body Sem_SPARK is\n       --  Save environment and put a new one in place\n \n       Move_Env (Current_Perm_Env, Saved_Env);\n+      Move_Variable_Mapping (Current_Borrowers, Saved_Borrowers);\n+      Move_Variable_Mapping (Current_Observers, Saved_Observers);\n \n       --  Add formals and globals to the environment with adequate permissions\n \n@@ -1141,6 +1293,8 @@ package body Sem_SPARK is\n       --  Restore the saved environment and free the current one\n \n       Move_Env (Saved_Env, Current_Perm_Env);\n+      Move_Variable_Mapping (Saved_Borrowers, Current_Borrowers);\n+      Move_Variable_Mapping (Saved_Observers, Current_Observers);\n \n       Inside_Elaboration := Save_In_Elab;\n    end Check_Callable_Body;\n@@ -1532,12 +1686,17 @@ package body Sem_SPARK is\n                  Loop_Parameter_Specification (Expr);\n                For_Of_Spec : constant Node_Id :=\n                  Iterator_Specification (Expr);\n+               For_Of_Spec_Typ : Node_Id;\n+\n             begin\n                if Present (For_In_Spec) then\n                   Read_Expression (Discrete_Subtype_Definition (For_In_Spec));\n                else\n                   Read_Expression (Name (For_Of_Spec));\n-                  Read_Expression (Subtype_Indication (For_Of_Spec));\n+                  For_Of_Spec_Typ := Subtype_Indication (For_Of_Spec);\n+                  if Present (For_Of_Spec_Typ) then\n+                     Read_Expression (For_Of_Spec_Typ);\n+                  end if;\n                end if;\n \n                Read_Expression (Condition (Expr));\n@@ -2090,6 +2249,9 @@ package body Sem_SPARK is\n          when N_Handled_Sequence_Of_Statements =>\n             Check_List (Statements (N));\n \n+         when N_Pragma =>\n+            Check_Pragma (N);\n+\n          --  Ignored constructs for pointer checking\n \n          when N_Abstract_Subprogram_Declaration\n@@ -2120,7 +2282,6 @@ package body Sem_SPARK is\n             | N_Others_Choice\n             | N_Package_Instantiation\n             | N_Package_Renaming_Declaration\n-            | N_Pragma\n             | N_Procedure_Instantiation\n             | N_Record_Representation_Clause\n             | N_Subprogram_Declaration\n@@ -2222,15 +2383,26 @@ package body Sem_SPARK is\n \n    procedure Check_Parameter_Or_Global\n      (Expr       : Node_Id;\n-      Param_Mode : Formal_Kind;\n+      Typ        : Entity_Id;\n+      Kind       : Formal_Kind;\n       Subp       : Entity_Id;\n       Global_Var : Boolean)\n    is\n-      Typ  : constant Entity_Id := Underlying_Type (Etype (Expr));\n-      Mode : Checking_Mode;\n+      Mode   : Checking_Mode;\n+      Status : Error_Status;\n \n    begin\n-      case Param_Mode is\n+      if not Global_Var\n+        and then Is_Anonymous_Access_Type (Typ)\n+      then\n+         Check_Source_Of_Borrow_Or_Observe (Expr, Status);\n+\n+         if Status /= OK then\n+            return;\n+         end if;\n+      end if;\n+\n+      case Kind is\n          when E_In_Parameter =>\n \n             --  Inputs of functions have R permission only\n@@ -2281,6 +2453,66 @@ package body Sem_SPARK is\n \n    procedure Check_Globals (Subp : Entity_Id) renames Check_Globals_Inst;\n \n+   ------------------\n+   -- Check_Pragma --\n+   ------------------\n+\n+   procedure Check_Pragma (Prag : Node_Id) is\n+      Prag_Id : constant Pragma_Id := Get_Pragma_Id (Prag);\n+      Arg1    : constant Node_Id :=\n+        First (Pragma_Argument_Associations (Prag));\n+      Arg2    : Node_Id;\n+\n+   begin\n+      if Present (Arg1) then\n+         Arg2 := Next (Arg1);\n+      end if;\n+\n+      case Prag_Id is\n+         when Pragma_Check =>\n+            declare\n+               Expr : constant Node_Id := Expression (Arg2);\n+            begin\n+               Check_Expression (Expr, Read);\n+            end;\n+\n+         --  There is no need to check contracts, as these can only access\n+         --  inputs and outputs of the subprogram. Inputs are checked\n+         --  independently for R permission. Outputs are checked\n+         --  independently to have RW permission on exit.\n+\n+         when Pragma_Contract_Cases\n+            | Pragma_Postcondition\n+            | Pragma_Precondition\n+            | Pragma_Refined_Post\n+         =>\n+            null;\n+\n+         --  The same holds for the initial condition after package\n+         --  elaboration, for the different reason that library-level\n+         --  variables can only be left in RW state after elaboration.\n+\n+         when Pragma_Initial_Condition =>\n+            null;\n+\n+         --  These pragmas should have been rewritten and/or removed in\n+         --  GNATprove mode.\n+\n+         when Pragma_Assert\n+            | Pragma_Assert_And_Cut\n+            | Pragma_Assume\n+            | Pragma_Compile_Time_Error\n+            | Pragma_Compile_Time_Warning\n+            | Pragma_Debug\n+            | Pragma_Loop_Invariant\n+         =>\n+            raise Program_Error;\n+\n+         when others =>\n+            null;\n+      end case;\n+   end Check_Pragma;\n+\n    -------------------------\n    -- Check_Safe_Pointers --\n    -------------------------\n@@ -2366,8 +2598,15 @@ package body Sem_SPARK is\n      (Expr   : Node_Id;\n       Status : out Error_Status)\n    is\n-      Root : constant Entity_Id := Get_Root_Object (Expr);\n+      Root : Entity_Id;\n+\n    begin\n+      if Is_Path_Expression (Expr) then\n+         Root := Get_Root_Object (Expr);\n+      else\n+         Root := Empty;\n+      end if;\n+\n       Status := OK;\n \n       --  SPARK RM 3.10(3): If the target of an assignment operation is an\n@@ -2376,35 +2615,20 @@ package body Sem_SPARK is\n       --  stand-alone object, a part of a parameter, or a call to a traversal\n       --  function.\n \n-      if Present (Root) then\n-         if not Ekind_In (Root, E_Variable, E_Constant)\n-           and then Ekind (Root) not in Formal_Kind\n-         then\n+      if No (Root) then\n+         if Nkind (Expr) = N_Function_Call then\n+            Error_Msg_N\n+              (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n+            Error_Msg_N\n+              (\"\\function called must be a traversal function\", Expr);\n+         else\n             Error_Msg_N\n               (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n             Error_Msg_N\n               (\"\\expression must be part of stand-alone object or parameter\",\n                Expr);\n-            Status := Error;\n          end if;\n \n-      elsif Nkind (Expr) = N_Function_Call then\n-         declare\n-            Callee : constant Entity_Id := Get_Called_Entity (Expr);\n-         begin\n-            if No (Callee)\n-              or else not Is_Traversal_Function (Callee)\n-            then\n-               Error_Msg_N\n-                 (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n-               Error_Msg_N\n-                 (\"\\function called must be a traversal function\", Expr);\n-               Status := Error;\n-            end if;\n-         end;\n-\n-      else\n-         Error_Msg_N (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n          Status := Error;\n       end if;\n    end Check_Source_Of_Borrow_Or_Observe;\n@@ -2426,34 +2650,46 @@ package body Sem_SPARK is\n \n          when N_Assignment_Statement =>\n             declare\n-               Target     : constant Node_Id := Name (Stmt);\n-               Target_Typ : constant Entity_Id := Etype (Target);\n+               Target : constant Node_Id := Name (Stmt);\n             begin\n                Check_Assignment (Target => Target,\n                                  Expr   => Expression (Stmt));\n \n-               if Is_Deep (Target_Typ) then\n-                  Check_Expression (Target, Assign);\n+               --  ??? We need a rule that forbids targets of assignment for\n+               --  which the path is not known, for example when there is a\n+               --  function call involved (which includes calls to traversal\n+               --  functions). Otherwise there is no way to update the\n+               --  corresponding path permission.\n+\n+               if No (Get_Root_Object\n+                       (Target, Through_Traversal => False))\n+               then\n+                  Error_Msg_N (\"illegal target for assignment\", Target);\n+                  return;\n                end if;\n+\n+               Check_Expression (Target, Assign);\n             end;\n \n          when N_Block_Statement =>\n-            declare\n-               Saved_Env : Perm_Env;\n-            begin\n-               --  Save environment\n-\n-               Copy_Env (Current_Perm_Env, Saved_Env);\n-\n-               --  Analyze declarations and Handled_Statement_Sequences\n+            Check_List (Declarations (Stmt));\n+            Check_Node (Handled_Statement_Sequence (Stmt));\n \n-               Check_List (Declarations (Stmt));\n-               Check_Node (Handled_Statement_Sequence (Stmt));\n+            --  Remove local borrowers and observers\n \n-               --  Restore environment\n+            declare\n+               Decl : Node_Id := First (Declarations (Stmt));\n+               Var  : Entity_Id;\n+            begin\n+               while Present (Decl) loop\n+                  if Nkind (Decl) = N_Object_Declaration then\n+                     Var := Defining_Identifier (Decl);\n+                     Remove (Current_Borrowers, Var);\n+                     Remove (Current_Observers, Var);\n+                  end if;\n \n-               Free_Env (Current_Perm_Env);\n-               Copy_Env (Saved_Env, Current_Perm_Env);\n+                  Next (Decl);\n+               end loop;\n             end;\n \n          when N_Case_Statement =>\n@@ -2569,8 +2805,12 @@ package body Sem_SPARK is\n                         Check_Expression (Expr, Read);\n                      end if;\n \n-                     Return_Parameters (Subp);\n-                     Return_Globals (Subp);\n+                     if Ekind_In (Subp, E_Procedure, E_Entry)\n+                       and then not No_Return (Subp)\n+                     then\n+                        Return_Parameters (Subp);\n+                        Return_Globals (Subp);\n+                     end if;\n                   end;\n                end if;\n             end;\n@@ -2602,8 +2842,12 @@ package body Sem_SPARK is\n                   Perm_Error (Decl, Read_Write, Perm);\n                end if;\n \n-               Return_Parameters (Subp);\n-               Return_Globals (Subp);\n+               if Ekind_In (Subp, E_Procedure, E_Entry)\n+                 and then not No_Return (Subp)\n+               then\n+                  Return_Parameters (Subp);\n+                  Return_Globals (Subp);\n+               end if;\n             end;\n \n          --  On loop exit, merge the current permission environment with the\n@@ -2733,7 +2977,9 @@ package body Sem_SPARK is\n       case Type_Kind'(Ekind (Underlying_Type (Typ))) is\n          when Access_Kind =>\n             case Access_Kind'(Ekind (Typ)) is\n-               when E_Access_Type =>\n+               when E_Access_Type\n+                  | E_Anonymous_Access_Type\n+               =>\n                   null;\n                when E_Access_Subtype =>\n                   Check_Type (Base_Type (Typ));\n@@ -2748,8 +2994,6 @@ package body Sem_SPARK is\n                   Error_Msg_NE\n                     (\"access to subprogram type & not allowed in SPARK\",\n                      Typ, Typ);\n-               when E_Anonymous_Access_Type =>\n-                  Error_Msg_N (\"anonymous access type not yet supported\", Typ);\n             end case;\n \n          when E_Array_Type\n@@ -2814,9 +3058,22 @@ package body Sem_SPARK is\n             return Permission (C);\n          end;\n \n-      --  The expression is rooted in an object\n+      --  The expression is a call to a traversal function\n \n-      elsif Present (Get_Root_Object (N)) then\n+      elsif Is_Traversal_Function_Call (N) then\n+         declare\n+            Callee : constant Entity_Id := Get_Called_Entity (N);\n+         begin\n+            if Is_Access_Constant (Etype (Callee)) then\n+               return Read_Only;\n+            else\n+               return Read_Write;\n+            end if;\n+         end;\n+\n+      --  The expression is directly rooted in an object\n+\n+      elsif Present (Get_Root_Object (N, Through_Traversal => False)) then\n          declare\n             Tree_Or_Perm : constant Perm_Or_Tree := Get_Perm_Or_Tree (N);\n          begin\n@@ -2942,7 +3199,10 @@ package body Sem_SPARK is\n    -- Get_Root_Object --\n    ---------------------\n \n-   function Get_Root_Object (Expr : Node_Id) return Entity_Id is\n+   function Get_Root_Object\n+     (Expr              : Node_Id;\n+      Through_Traversal : Boolean := True) return Entity_Id\n+   is\n    begin\n       case Nkind (Expr) is\n          when N_Expanded_Name\n@@ -2955,21 +3215,33 @@ package body Sem_SPARK is\n             | N_Selected_Component\n             | N_Slice\n          =>\n-            return Get_Root_Object (Prefix (Expr));\n+            return Get_Root_Object (Prefix (Expr), Through_Traversal);\n \n-         --  There is no entity for an allocator, NULL or a function call\n+         --  There is no root object for an allocator or NULL\n \n          when N_Allocator\n             | N_Null\n-            | N_Function_Call\n          =>\n             return Empty;\n \n+         --  In the case of a call to a traversal function, the root object is\n+         --  the root of the traversed parameter. Otherwise there is no root\n+         --  object.\n+\n+         when N_Function_Call =>\n+            if Through_Traversal\n+              and then Is_Traversal_Function_Call (Expr)\n+            then\n+               return Get_Root_Object (First_Actual (Expr), Through_Traversal);\n+            else\n+               return Empty;\n+            end if;\n+\n          when N_Qualified_Expression\n             | N_Type_Conversion\n             | N_Unchecked_Type_Conversion\n          =>\n-            return Get_Root_Object (Expression (Expr));\n+            return Get_Root_Object (Expression (Expr), Through_Traversal);\n \n          when others =>\n             raise Program_Error;\n@@ -3171,6 +3443,119 @@ package body Sem_SPARK is\n       end case;\n    end Is_Path_Expression;\n \n+   -------------------------\n+   -- Is_Prefix_Or_Almost --\n+   -------------------------\n+\n+   function Is_Prefix_Or_Almost (Pref, Expr : Node_Id) return Boolean is\n+\n+      type Expr_Array is array (Positive range <>) of Node_Id;\n+      --  Sequence of expressions that make up a path\n+\n+      function Get_Expr_Array (Expr : Node_Id) return Expr_Array;\n+      pragma Precondition (Is_Path_Expression (Expr));\n+      --  Return the sequence of expressions that make up a path\n+\n+      --------------------\n+      -- Get_Expr_Array --\n+      --------------------\n+\n+      function Get_Expr_Array (Expr : Node_Id) return Expr_Array is\n+      begin\n+         case Nkind (Expr) is\n+            when N_Expanded_Name\n+               | N_Identifier\n+            =>\n+               return Expr_Array'(1 => Expr);\n+\n+            when N_Explicit_Dereference\n+               | N_Indexed_Component\n+               | N_Selected_Component\n+               | N_Slice\n+            =>\n+               return Get_Expr_Array (Prefix (Expr)) & Expr;\n+\n+            when N_Qualified_Expression\n+               | N_Type_Conversion\n+               | N_Unchecked_Type_Conversion\n+            =>\n+               return Get_Expr_Array (Expression (Expr));\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+      end Get_Expr_Array;\n+\n+      --  Local variables\n+\n+      Prefix_Path : constant Expr_Array := Get_Expr_Array (Pref);\n+      Expr_Path   : constant Expr_Array := Get_Expr_Array (Expr);\n+\n+      Prefix_Root : constant Node_Id := Prefix_Path (1);\n+      Expr_Root   : constant Node_Id := Expr_Path (1);\n+\n+      Common_Len  : constant Positive :=\n+        Positive'Min (Prefix_Path'Length, Expr_Path'Length);\n+\n+   --  Start of processing for Is_Prefix_Or_Almost\n+\n+   begin\n+      if Entity (Prefix_Root) /= Entity (Expr_Root) then\n+         return False;\n+      end if;\n+\n+      for J in 2 .. Common_Len loop\n+         declare\n+            Prefix_Elt : constant Node_Id := Prefix_Path (J);\n+            Expr_Elt   : constant Node_Id := Expr_Path (J);\n+         begin\n+            case Nkind (Prefix_Elt) is\n+               when N_Explicit_Dereference =>\n+                  if Nkind (Expr_Elt) /= N_Explicit_Dereference then\n+                     return False;\n+                  end if;\n+\n+               when N_Selected_Component =>\n+                  if Nkind (Expr_Elt) /= N_Selected_Component\n+                    or else Entity (Selector_Name (Prefix_Elt))\n+                         /= Entity (Selector_Name (Expr_Elt))\n+                  then\n+                     return False;\n+                  end if;\n+\n+               when N_Indexed_Component\n+                  | N_Slice\n+               =>\n+                  if not Nkind_In (Expr_Elt, N_Indexed_Component, N_Slice) then\n+                     return False;\n+                  end if;\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+         end;\n+      end loop;\n+\n+      --  If the expression path is longer than the prefix one, then at this\n+      --  point the prefix property holds.\n+\n+      if Expr_Path'Length > Prefix_Path'Length then\n+         return True;\n+\n+      --  Otherwise check if none of the remaining path elements in the\n+      --  candidate prefix involve a dereference.\n+\n+      else\n+         for J in Common_Len + 1 .. Prefix_Path'Length loop\n+            if Nkind (Prefix_Path (J)) = N_Explicit_Dereference then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end if;\n+   end Is_Prefix_Or_Almost;\n+\n    ---------------------------\n    -- Is_Traversal_Function --\n    ---------------------------\n@@ -3193,6 +3578,17 @@ package body Sem_SPARK is\n         and then Is_Access_Type (Etype (First_Formal (E)));\n    end Is_Traversal_Function;\n \n+   --------------------------------\n+   -- Is_Traversal_Function_Call --\n+   --------------------------------\n+\n+   function Is_Traversal_Function_Call (Expr : Node_Id) return Boolean is\n+   begin\n+      return Nkind (Expr) = N_Function_Call\n+        and then Present (Get_Called_Entity (Expr))\n+        and then Is_Traversal_Function (Get_Called_Entity (Expr));\n+   end Is_Traversal_Function_Call;\n+\n    ------------------\n    -- Loop_Of_Exit --\n    ------------------\n@@ -3588,10 +3984,93 @@ package body Sem_SPARK is\n    ------------------\n \n    procedure Process_Path (Expr : Node_Id; Mode : Checking_Mode) is\n+\n+      procedure Check_Not_Borrowed (Expr : Node_Id; Root : Entity_Id);\n+      --  Check expression Expr originating in Root was not borrowed\n+\n+      procedure Check_Not_Observed (Expr : Node_Id; Root : Entity_Id);\n+      --  Check expression Expr originating in Root was not observed\n+\n+      ------------------------\n+      -- Check_Not_Borrowed --\n+      ------------------------\n+\n+      procedure Check_Not_Borrowed (Expr : Node_Id; Root : Entity_Id) is\n+      begin\n+         --  An expression without root object cannot be borrowed\n+\n+         if No (Root) then\n+            return;\n+         end if;\n+\n+         --  Otherwise, try to match the expression with one of the borrowed\n+         --  expressions.\n+\n+         declare\n+            Key      : Variable_Maps.Key_Option :=\n+              Get_First_Key (Current_Borrowers);\n+            Var      : Entity_Id;\n+            Borrowed : Node_Id;\n+\n+         begin\n+            while Key.Present loop\n+               Var := Key.K;\n+               Borrowed := Get (Current_Borrowers, Var);\n+\n+               if Is_Prefix_Or_Almost (Pref => Borrowed, Expr => Expr) then\n+                  Error_Msg_Sloc := Sloc (Borrowed);\n+                  Error_Msg_N (\"expression was borrowed #\", Expr);\n+               end if;\n+\n+               Key := Get_Next_Key (Current_Borrowers);\n+            end loop;\n+         end;\n+      end Check_Not_Borrowed;\n+\n+      ------------------------\n+      -- Check_Not_Observed --\n+      ------------------------\n+\n+      procedure Check_Not_Observed (Expr : Node_Id; Root : Entity_Id) is\n+      begin\n+         --  An expression without root object cannot be observed\n+\n+         if No (Root) then\n+            return;\n+         end if;\n+\n+         --  Otherwise, try to match the expression with one of the observed\n+         --  expressions.\n+\n+         declare\n+            Key      : Variable_Maps.Key_Option :=\n+              Get_First_Key (Current_Observers);\n+            Var      : Entity_Id;\n+            Observed : Node_Id;\n+\n+         begin\n+            while Key.Present loop\n+               Var := Key.K;\n+               Observed := Get (Current_Observers, Var);\n+\n+               if Is_Prefix_Or_Almost (Pref => Observed, Expr => Expr) then\n+                  Error_Msg_Sloc := Sloc (Observed);\n+                  Error_Msg_N (\"expression was observed #\", Expr);\n+               end if;\n+\n+               Key := Get_Next_Key (Current_Observers);\n+            end loop;\n+         end;\n+      end Check_Not_Observed;\n+\n+      --  Local variables\n+\n       Expr_Type : constant Entity_Id := Etype (Expr);\n       Root      : Entity_Id := Get_Root_Object (Expr);\n       Perm      : Perm_Kind;\n \n+   --  Start of processing for Process_Path\n+\n    begin\n       --  Nothing to do if the root type is not deep, or the path is not rooted\n       --  in an object.\n@@ -3615,6 +4094,8 @@ package body Sem_SPARK is\n \n       Perm := Get_Perm (Expr);\n \n+      --  Check permissions\n+\n       case Mode is\n \n          when Read =>\n@@ -3665,25 +4146,6 @@ package body Sem_SPARK is\n                return;\n             end if;\n \n-            --  Do not update permission environment when handling calls\n-\n-            if Inside_Procedure_Call then\n-               return;\n-            end if;\n-\n-            --  SPARK RM 3.10(1): After a move operation, the state of the\n-            --  source object (if any) becomes Moved.\n-\n-            if Present (Get_Root_Object (Expr)) then\n-               declare\n-                  Tree : constant Perm_Tree_Access :=\n-                    Set_Perm_Prefixes (Expr, Write_Only);\n-               begin\n-                  pragma Assert (Tree /= null);\n-                  Set_Perm_Extensions_Move (Tree, Etype (Expr));\n-               end;\n-            end if;\n-\n          when Assign =>\n \n             --  No checking needed during elaboration\n@@ -3699,34 +4161,6 @@ package body Sem_SPARK is\n                return;\n             end if;\n \n-            --  Do not update permission environment when handling calls\n-\n-            if Inside_Procedure_Call then\n-               return;\n-            end if;\n-\n-            --  If there is no root object, or the tree has an array component,\n-            --  then the permissions do not get modified by the assignment.\n-\n-            if No (Get_Root_Object (Expr))\n-              or else Has_Array_Component (Expr)\n-            then\n-               return;\n-            end if;\n-\n-            --  Set permission RW for the path and its extensions\n-\n-            declare\n-               Tree : constant Perm_Tree_Access := Get_Perm_Tree (Expr);\n-            begin\n-               Tree.all.Tree.Permission := Read_Write;\n-               Set_Perm_Extensions (Tree, Read_Write);\n-\n-               --  Normalize the permission tree\n-\n-               Set_Perm_Prefixes_Assign (Expr);\n-            end;\n-\n          when Borrow =>\n \n             --  Forbidden during elaboration\n@@ -3746,21 +4180,6 @@ package body Sem_SPARK is\n                return;\n             end if;\n \n-            --  Do not update permission environment when handling calls\n-\n-            if Inside_Procedure_Call then\n-               return;\n-            end if;\n-\n-            --  Set permission NO for the path and its extensions\n-\n-            declare\n-               Tree : constant Perm_Tree_Access :=\n-                 Set_Perm_Prefixes (Expr, No_Access);\n-            begin\n-               Set_Perm_Extensions (Tree, No_Access);\n-            end;\n-\n          when Observe =>\n \n             --  Forbidden during elaboration\n@@ -3779,13 +4198,86 @@ package body Sem_SPARK is\n                Perm_Error (Expr, Read_Only, Perm);\n                return;\n             end if;\n+      end case;\n \n-            --  Do not update permission environment when handling calls\n+      --  Check path was not borrowed\n \n-            if Inside_Procedure_Call then\n+      Check_Not_Borrowed (Expr, Root);\n+\n+      --  For modes that require W permission, check path was not observed\n+\n+      case Mode is\n+         when Read | Observe =>\n+            null;\n+         when Assign | Move | Borrow =>\n+            Check_Not_Observed (Expr, Root);\n+      end case;\n+\n+      --  Do not update permission environment when handling calls\n+\n+      if Inside_Procedure_Call then\n+         return;\n+      end if;\n+\n+      --  Update the permissions\n+\n+      case Mode is\n+\n+         when Read =>\n+            null;\n+\n+         when Move =>\n+\n+            --  SPARK RM 3.10(1): After a move operation, the state of the\n+            --  source object (if any) becomes Moved.\n+\n+            if Present (Get_Root_Object (Expr)) then\n+               declare\n+                  Tree : constant Perm_Tree_Access :=\n+                    Set_Perm_Prefixes (Expr, Write_Only);\n+               begin\n+                  pragma Assert (Tree /= null);\n+                  Set_Perm_Extensions_Move (Tree, Etype (Expr));\n+               end;\n+            end if;\n+\n+         when Assign =>\n+\n+            --  If there is no root object, or the tree has an array component,\n+            --  then the permissions do not get modified by the assignment.\n+\n+            if No (Get_Root_Object (Expr))\n+              or else Has_Array_Component (Expr)\n+            then\n                return;\n             end if;\n \n+            --  Set permission RW for the path and its extensions\n+\n+            declare\n+               Tree : constant Perm_Tree_Access := Get_Perm_Tree (Expr);\n+            begin\n+               Tree.all.Tree.Permission := Read_Write;\n+               Set_Perm_Extensions (Tree, Read_Write);\n+\n+               --  Normalize the permission tree\n+\n+               Set_Perm_Prefixes_Assign (Expr);\n+            end;\n+\n+         when Borrow =>\n+\n+            --  Set permission NO for the path and its extensions\n+\n+            declare\n+               Tree : constant Perm_Tree_Access :=\n+                 Set_Perm_Prefixes (Expr, No_Access);\n+            begin\n+               Set_Perm_Extensions (Tree, No_Access);\n+            end;\n+\n+         when Observe =>\n+\n             --  Set permission R for the path and its extensions\n \n             declare\n@@ -3805,7 +4297,8 @@ package body Sem_SPARK is\n \n       procedure Return_Global\n         (Expr       : Node_Id;\n-         Param_Mode : Formal_Kind;\n+         Typ        : Entity_Id;\n+         Kind       : Formal_Kind;\n          Subp       : Entity_Id;\n          Global_Var : Boolean);\n       --  Proxy procedure to return globals, to adjust for the type of first\n@@ -3817,13 +4310,18 @@ package body Sem_SPARK is\n \n       procedure Return_Global\n         (Expr       : Node_Id;\n-         Param_Mode : Formal_Kind;\n+         Typ        : Entity_Id;\n+         Kind       : Formal_Kind;\n          Subp       : Entity_Id;\n          Global_Var : Boolean)\n       is\n       begin\n          Return_Parameter_Or_Global\n-           (Entity (Expr), Param_Mode, Subp, Global_Var);\n+           (Id         => Entity (Expr),\n+            Typ        => Typ,\n+            Kind       => Kind,\n+            Subp       => Subp,\n+            Global_Var => Global_Var);\n       end Return_Global;\n \n       procedure Return_Globals_Inst is new Handle_Globals (Return_Global);\n@@ -3840,18 +4338,18 @@ package body Sem_SPARK is\n \n    procedure Return_Parameter_Or_Global\n      (Id         : Entity_Id;\n-      Mode       : Formal_Kind;\n+      Typ        : Entity_Id;\n+      Kind       : Formal_Kind;\n       Subp       : Entity_Id;\n       Global_Var : Boolean)\n    is\n-      Typ  : constant Entity_Id := Underlying_Type (Etype (Id));\n    begin\n       --  Shallow parameters and globals need not be considered\n \n       if not Is_Deep (Typ) then\n          return;\n \n-      elsif Mode = E_In_Parameter then\n+      elsif Kind = E_In_Parameter then\n \n          --  Input global variables are observed only\n \n@@ -3897,7 +4395,12 @@ package body Sem_SPARK is\n    begin\n       Formal := First_Formal (Subp);\n       while Present (Formal) loop\n-         Return_Parameter_Or_Global (Formal, Ekind (Formal), Subp, False);\n+         Return_Parameter_Or_Global\n+           (Id         => Formal,\n+            Typ        => Underlying_Type (Etype (Formal)),\n+            Kind       => Ekind (Formal),\n+            Subp       => Subp,\n+            Global_Var => False);\n          Next_Formal (Formal);\n       end loop;\n    end Return_Parameters;\n@@ -4172,6 +4675,7 @@ package body Sem_SPARK is\n                      pragma Assert (Kind (C) = Entire_Object);\n \n                      D       : Perm_Tree_Access;\n+                     D_This  : Perm_Tree_Access;\n                      Comp    : Node_Id;\n                      P       : Perm_Kind;\n                      Child_P : constant Perm_Kind := Children_Permission (C);\n@@ -4198,14 +4702,21 @@ package body Sem_SPARK is\n                               Permission          => P,\n                               Children_Permission => Child_P));\n                         Perm_Tree_Maps.Set (Hashtbl, Comp, D);\n+\n+                        --  Store the tree to return for this component\n+\n+                        if Comp = Entity (Selector_Name (N)) then\n+                           D_This := D;\n+                        end if;\n+\n                         Next_Component_Or_Discriminant (Comp);\n                      end loop;\n \n                      C.all.Tree := (Kind         => Record_Component,\n                                     Is_Node_Deep => Is_Node_Deep (C),\n                                     Permission   => Permission (C),\n                                     Component    => Hashtbl);\n-                     return D;\n+                     return D_This;\n                   end;\n                end if;\n             end;\n@@ -4349,7 +4860,8 @@ package body Sem_SPARK is\n \n       procedure Setup_Global\n         (Expr       : Node_Id;\n-         Param_Mode : Formal_Kind;\n+         Typ        : Entity_Id;\n+         Kind       : Formal_Kind;\n          Subp       : Entity_Id;\n          Global_Var : Boolean);\n       --  Proxy procedure to set up globals, to adjust for the type of first\n@@ -4361,13 +4873,18 @@ package body Sem_SPARK is\n \n       procedure Setup_Global\n         (Expr       : Node_Id;\n-         Param_Mode : Formal_Kind;\n+         Typ        : Entity_Id;\n+         Kind       : Formal_Kind;\n          Subp       : Entity_Id;\n          Global_Var : Boolean)\n       is\n       begin\n          Setup_Parameter_Or_Global\n-           (Entity (Expr), Param_Mode, Subp, Global_Var);\n+           (Id         => Entity (Expr),\n+            Typ        => Typ,\n+            Kind       => Kind,\n+            Subp       => Subp,\n+            Global_Var => Global_Var);\n       end Setup_Global;\n \n       procedure Setup_Globals_Inst is new Handle_Globals (Setup_Global);\n@@ -4384,15 +4901,15 @@ package body Sem_SPARK is\n \n    procedure Setup_Parameter_Or_Global\n      (Id         : Entity_Id;\n-      Param_Mode : Formal_Kind;\n+      Typ        : Entity_Id;\n+      Kind       : Formal_Kind;\n       Subp       : Entity_Id;\n       Global_Var : Boolean)\n    is\n-      Typ  : constant Entity_Id := Underlying_Type (Etype (Id));\n       Perm : Perm_Kind_Option;\n \n    begin\n-      case Param_Mode is\n+      case Kind is\n          when E_In_Parameter =>\n \n             --  Shallow parameters and globals need not be considered\n@@ -4439,7 +4956,7 @@ package body Sem_SPARK is\n             --  Functions cannot have outputs in SPARK\n \n             elsif Ekind (Subp) = E_Function then\n-               if Param_Mode = E_Out_Parameter then\n+               if Kind = E_Out_Parameter then\n                   Error_Msg_N (\"function with OUT parameter is not \"\n                                & \"allowed in SPARK\", Id);\n                else\n@@ -4481,7 +4998,11 @@ package body Sem_SPARK is\n       Formal := First_Formal (Subp);\n       while Present (Formal) loop\n          Setup_Parameter_Or_Global\n-           (Formal, Ekind (Formal), Subp, Global_Var => False);\n+           (Id         => Formal,\n+            Typ        => Underlying_Type (Etype (Formal)),\n+            Kind       => Ekind (Formal),\n+            Subp       => Subp,\n+            Global_Var => False);\n          Next_Formal (Formal);\n       end loop;\n    end Setup_Parameters;"}]}