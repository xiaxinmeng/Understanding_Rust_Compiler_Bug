{"sha": "70ee703c479081ac2ea67eb67041551216e66783", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBlZTcwM2M0NzkwODFhYzJlYTY3ZWI2NzA0MTU1MTIxNmU2Njc4Mw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-07-10T09:50:23Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-09-14T15:56:10Z"}, "message": "coroutines: Make proxy vars for the function arg copies.\n\nThis adds top level proxy variables for the coroutine frame\ncopies of the original function args.  These are then available\nin the debugger to refer to the frame copies.  We rewrite the\nfunction body to use the copies, since the original parms will\nno longer be in scope when the coroutine is running.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (struct param_info): Add copy_var.\n\t(build_actor_fn): Use simplified param references.\n\t(register_param_uses): Likewise.\n\t(rewrite_param_uses): Likewise.\n\t(analyze_fn_parms): New function.\n\t(coro_rewrite_function_body): Add proxies for the fn\n\tparameters to the outer bind scope of the rewritten code.\n\t(morph_fn_to_coro): Use simplified version of param ref.", "tree": {"sha": "0514a9c1ec9c59b44d031d27199b213e4287153a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0514a9c1ec9c59b44d031d27199b213e4287153a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70ee703c479081ac2ea67eb67041551216e66783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ee703c479081ac2ea67eb67041551216e66783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70ee703c479081ac2ea67eb67041551216e66783", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ee703c479081ac2ea67eb67041551216e66783/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a"}], "stats": {"total": 251, "additions": 121, "deletions": 130}, "files": [{"sha": "d2cc2e73c8999fa6c7093ea43eeac0685bcd832a", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 121, "deletions": 130, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ee703c479081ac2ea67eb67041551216e66783/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ee703c479081ac2ea67eb67041551216e66783/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=70ee703c479081ac2ea67eb67041551216e66783", "patch": "@@ -1964,6 +1964,7 @@ transform_await_wrapper (tree *stmt, int *do_subtree, void *d)\n struct param_info\n {\n   tree field_id;     /* The name of the copy in the coroutine frame.  */\n+  tree copy_var;     /* The local var proxy for the frame copy.  */\n   vec<tree *> *body_uses; /* Worklist of uses, void if there are none.  */\n   tree frame_type;   /* The type used to represent this parm in the frame.  */\n   tree orig_type;    /* The original type of the parm (not as passed).  */\n@@ -2169,36 +2170,6 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   /* Declare the continuation handle.  */\n   add_decl_expr (continuation);\n \n-  /* Re-write param references in the body, no code should be generated\n-     here.  */\n-  if (DECL_ARGUMENTS (orig))\n-    {\n-      tree arg;\n-      for (arg = DECL_ARGUMENTS (orig); arg != NULL; arg = DECL_CHAIN (arg))\n-\t{\n-\t  bool existed;\n-\t  param_info &parm = param_uses->get_or_insert (arg, &existed);\n-\t  if (!parm.body_uses)\n-\t    continue; /* Wasn't used in the original function body.  */\n-\n-\t  tree fld_ref = lookup_member (coro_frame_type, parm.field_id,\n-\t\t\t\t\t/*protect=*/1, /*want_type=*/0,\n-\t\t\t\t\ttf_warning_or_error);\n-\t  tree fld_idx = build3_loc (loc, COMPONENT_REF, parm.frame_type,\n-\t\t\t\t     actor_frame, fld_ref, NULL_TREE);\n-\n-\t  /* We keep these in the frame as a regular pointer, so convert that\n-\t   back to the type expected.  */\n-\t  if (parm.pt_ref)\n-\t    fld_idx = build1_loc (loc, CONVERT_EXPR, TREE_TYPE (arg), fld_idx);\n-\n-\t  int i;\n-\t  tree *puse;\n-\t  FOR_EACH_VEC_ELT (*parm.body_uses, i, puse)\n-\t    *puse = fld_idx;\n-\t}\n-    }\n-\n   /* Re-write local vars, similarly.  */\n   local_vars_transform xform_vars_data\n     = {actor, actor_frame, coro_frame_type, loc, local_var_uses};\n@@ -3771,19 +3742,19 @@ struct param_frame_data\n   bool param_seen;\n };\n \n-/* A tree-walk callback that records the use of parameters (to allow for\n-   optimizations where handling unused parameters may be omitted).  */\n+/* A tree walk callback that rewrites each parm use to the local variable\n+   that represents its copy in the frame.  */\n \n static tree\n-register_param_uses (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n+rewrite_param_uses (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n {\n   param_frame_data *data = (param_frame_data *) d;\n \n   /* For lambda closure content, we have to look specifically.  */\n   if (TREE_CODE (*stmt) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (*stmt))\n     {\n       tree t = DECL_VALUE_EXPR (*stmt);\n-      return cp_walk_tree (&t, register_param_uses, d, NULL);\n+      return cp_walk_tree (&t, rewrite_param_uses, d, NULL);\n     }\n \n   if (TREE_CODE (*stmt) != PARM_DECL)\n@@ -3797,16 +3768,88 @@ register_param_uses (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n   param_info &parm = data->param_uses->get_or_insert (*stmt, &existed);\n   gcc_checking_assert (existed);\n \n-  if (!parm.body_uses)\n+  *stmt = parm.copy_var;\n+  return NULL_TREE;\n+}\n+\n+/* Build up a set of info that determines how each param copy will be\n+   handled.  */\n+\n+static hash_map<tree, param_info> *\n+analyze_fn_parms (tree orig)\n+{\n+  if (!DECL_ARGUMENTS (orig))\n+    return NULL;\n+\n+  hash_map<tree, param_info> *param_uses = new hash_map<tree, param_info>;\n+\n+  /* Build a hash map with an entry for each param.\n+     The key is the param tree.\n+     Then we have an entry for the frame field name.\n+     Then a cache for the field ref when we come to use it.\n+     Then a tree list of the uses.\n+     The second two entries start out empty - and only get populated\n+     when we see uses.  */\n+  bool lambda_p = LAMBDA_FUNCTION_P (orig);\n+\n+  unsigned no_name_parm = 0;\n+  for (tree arg = DECL_ARGUMENTS (orig); arg != NULL; arg = DECL_CHAIN (arg))\n     {\n-      vec_alloc (parm.body_uses, 4);\n-      parm.body_uses->quick_push (stmt);\n-      data->param_seen = true;\n+      bool existed;\n+      param_info &parm = param_uses->get_or_insert (arg, &existed);\n+      gcc_checking_assert (!existed);\n+      parm.body_uses = NULL;\n+      tree actual_type = TREE_TYPE (arg);\n+      actual_type = complete_type_or_else (actual_type, orig);\n+      if (actual_type == NULL_TREE)\n+\tactual_type = error_mark_node;\n+      parm.orig_type = actual_type;\n+      parm.by_ref = parm.pt_ref = parm.rv_ref =  false;\n+      if (TREE_CODE (actual_type) == REFERENCE_TYPE)\n+\t{\n+\t  /* If the user passes by reference, then we will save the\n+\t     pointer to the original.  As noted in\n+\t     [dcl.fct.def.coroutine] / 13, if the lifetime of the\n+\t     referenced item ends and then the coroutine is resumed,\n+\t     we have UB; well, the user asked for it.  */\n+\t  if (TYPE_REF_IS_RVALUE (actual_type))\n+\t\tparm.rv_ref = true;\n+\t  else\n+\t\tparm.pt_ref = true;\n+\t}\n+      else if (TYPE_REF_P (DECL_ARG_TYPE (arg)))\n+\tparm.by_ref = true;\n+\n+      parm.frame_type = actual_type;\n+\n+      parm.this_ptr = is_this_parameter (arg);\n+      parm.lambda_cobj = lambda_p && DECL_NAME (arg) == closure_identifier;\n+\n+      tree name = DECL_NAME (arg);\n+      if (!name)\n+\t{\n+\t  char *buf = xasprintf (\"_Coro_unnamed_parm_%d\", no_name_parm++);\n+\t  name = get_identifier (buf);\n+\t  free (buf);\n+\t}\n+      parm.field_id = name;\n+\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (parm.frame_type))\n+\t{\n+\t  char *buf = xasprintf (\"_Coro_%s_live\", IDENTIFIER_POINTER (name));\n+\t  parm.guard_var = build_lang_decl (VAR_DECL, get_identifier (buf),\n+\t\t\t\t\t    boolean_type_node);\n+\t  free (buf);\n+\t  DECL_ARTIFICIAL (parm.guard_var) = true;\n+\t  DECL_CONTEXT (parm.guard_var) = orig;\n+\t  DECL_INITIAL (parm.guard_var) = boolean_false_node;\n+\t  parm.trivial_dtor = false;\n+\t}\n+      else\n+\tparm.trivial_dtor = true;\n     }\n-  else\n-    parm.body_uses->safe_push (stmt);\n \n-  return NULL_TREE;\n+  return param_uses;\n }\n \n /* Small helper for the repetitive task of adding a new field to the coro\n@@ -3990,6 +4033,7 @@ coro_build_actor_or_destroy_function (tree orig, tree fn_type,\n \n static tree\n coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n+\t\t\t    hash_map<tree, param_info> *param_uses,\n \t\t\t    tree resume_fn_ptr_type,\n \t\t\t    tree& resume_idx_var, tree& fs_label)\n {\n@@ -4073,6 +4117,39 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n   var_list = var;\n   add_decl_expr (var);\n \n+  /* If we have function parms, then these will be copied to the coroutine\n+     frame.  Create a local (proxy) variable for each parm, since the original\n+     parms will be out of scope once the ramp has finished. The proxy vars will\n+     get DECL_VALUE_EXPRs pointing to the frame copies, so that we can interact\n+     with them in the debugger.  */\n+  if (param_uses)\n+    {\n+      gcc_checking_assert (DECL_ARGUMENTS (orig));\n+      /* Add a local var for each parm.  */\n+      for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n+\t   arg = DECL_CHAIN (arg))\n+\t{\n+\t  param_info *parm_i = param_uses->get (arg);\n+\t  gcc_checking_assert (parm_i);\n+\t  parm_i->copy_var\n+\t    = build_lang_decl (VAR_DECL, parm_i->field_id, TREE_TYPE (arg));\n+\t  DECL_SOURCE_LOCATION (parm_i->copy_var) = DECL_SOURCE_LOCATION (arg);\n+\t  DECL_CONTEXT (parm_i->copy_var) = orig;\n+\t  DECL_ARTIFICIAL (parm_i->copy_var) = true;\n+\t  DECL_CHAIN (parm_i->copy_var) = var_list;\n+\t  var_list = parm_i->copy_var;\n+\t  add_decl_expr (parm_i->copy_var);\n+      \t}\n+\n+      /* Now replace all uses of the parms in the function body with the proxy\n+\t vars.  We want to this to apply to every instance of param's use, so\n+\t don't include a 'visited' hash_set on the tree walk, however we will\n+\t arrange to visit each containing expression only once.  */\n+      hash_set<tree *> visited;\n+      param_frame_data param_data = {NULL, param_uses,\n+\t\t\t\t     &visited, fn_start, false};\n+      cp_walk_tree (&fnbody, rewrite_param_uses, &param_data, NULL);\n+    }\n \n   /* We create a resume index, this is initialized in the ramp.  */\n   resume_idx_var\n@@ -4343,7 +4420,9 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   tree resume_idx_var = NULL_TREE;\n   tree fs_label = NULL_TREE;\n-  fnbody = coro_rewrite_function_body (fn_start, fnbody, orig,\n+  hash_map<tree, param_info> *param_uses = analyze_fn_parms (orig);\n+\n+  fnbody = coro_rewrite_function_body (fn_start, fnbody, orig, param_uses,\n \t\t\t\t       act_des_fn_ptr,\n \t\t\t\t       resume_idx_var, fs_label);\n   /* Build our dummy coro frame layout.  */\n@@ -4352,94 +4431,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* The fields for the coro frame.  */\n   tree field_list = NULL_TREE;\n \n-  /* Now add in fields for function params (if there are any).\n-     We do not attempt elision of copies at this stage, we do analyze the\n-     uses and build worklists to replace those when the state machine is\n-     lowered.  */\n-\n-  hash_map<tree, param_info> *param_uses = NULL;\n-  if (DECL_ARGUMENTS (orig))\n-    {\n-      /* Build a hash map with an entry for each param.\n-\t  The key is the param tree.\n-\t  Then we have an entry for the frame field name.\n-\t  Then a cache for the field ref when we come to use it.\n-\t  Then a tree list of the uses.\n-\t  The second two entries start out empty - and only get populated\n-\t  when we see uses.  */\n-      param_uses = new hash_map<tree, param_info>;\n-      bool lambda_p = LAMBDA_FUNCTION_P (orig);\n-\n-      unsigned no_name_parm = 0;\n-      for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n-\t   arg = DECL_CHAIN (arg))\n-\t{\n-\t  bool existed;\n-\t  param_info &parm = param_uses->get_or_insert (arg, &existed);\n-\t  gcc_checking_assert (!existed);\n-\t  parm.body_uses = NULL;\n-\t  tree actual_type = TREE_TYPE (arg);\n-\t  actual_type = complete_type_or_else (actual_type, orig);\n-\t  if (actual_type == NULL_TREE)\n-\t    actual_type = error_mark_node;\n-\t  parm.orig_type = actual_type;\n-\t  parm.by_ref = parm.pt_ref = parm.rv_ref =  false;\n-\t  if (TREE_CODE (actual_type) == REFERENCE_TYPE)\n-\t    {\n-\t      /* If the user passes by reference, then we will save the\n-\t\t pointer to the original.  As noted in\n-\t\t [dcl.fct.def.coroutine] / 13, if the lifetime of the\n-\t\t referenced item ends and then the coroutine is resumed,\n-\t\t we have UB; well, the user asked for it.  */\n-\t      if (TYPE_REF_IS_RVALUE (actual_type))\n-\t\tparm.rv_ref = true;\n-\t      else\n-\t\tparm.pt_ref = true;\n-\t    }\n-\t  else if (TYPE_REF_P (DECL_ARG_TYPE (arg)))\n-\t    parm.by_ref = true;\n-\n-\t  parm.frame_type = actual_type;\n-\n-\t  parm.this_ptr = is_this_parameter (arg);\n-\t  parm.lambda_cobj = lambda_p && DECL_NAME (arg) == closure_identifier;\n-\n-\t  char *buf;\n-\t  if (DECL_NAME (arg))\n-\t    {\n-\t      tree pname = DECL_NAME (arg);\n-\t      buf = xasprintf (\"_P_%s\", IDENTIFIER_POINTER (pname));\n-\t    }\n-\t  else\n-\t    buf = xasprintf (\"_P_unnamed_%d\", no_name_parm++);\n-\n-\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (parm.frame_type))\n-\t    {\n-\t      char *gbuf = xasprintf (\"%s_live\", buf);\n-\t      parm.guard_var\n-\t\t= build_lang_decl (VAR_DECL, get_identifier (gbuf),\n-\t\t\t\t   boolean_type_node);\n-\t      free (gbuf);\n-\t      DECL_ARTIFICIAL (parm.guard_var) = true;\n-\t      DECL_INITIAL (parm.guard_var) = boolean_false_node;\n-\t      parm.trivial_dtor = false;\n-\t    }\n-\t  else\n-\t    parm.trivial_dtor = true;\n-\t  parm.field_id = coro_make_frame_entry\n-\t    (&field_list, buf, actual_type, DECL_SOURCE_LOCATION (arg));\n-\t  free (buf);\n-\t}\n-\n-      /* We want to record every instance of param's use, so don't include\n-\t a 'visited' hash_set on the tree walk, but only record a containing\n-\t expression once.  */\n-      hash_set<tree *> visited;\n-      param_frame_data param_data\n-\t= {&field_list, param_uses, &visited, fn_start, false};\n-      cp_walk_tree (&fnbody, register_param_uses, &param_data, NULL);\n-    }\n-\n   /* We need to know, and inspect, each suspend point in the function\n      in several places.  It's convenient to place this map out of line\n      since it's used from tree walk callbacks.  */"}]}