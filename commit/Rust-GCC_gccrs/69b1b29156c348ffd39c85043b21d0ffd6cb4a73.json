{"sha": "69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjliMWIyOTE1NmMzNDhmZmQzOWM4NTA0M2IyMWQwZmZkNmNiNGE3Mw==", "commit": {"author": {"name": "Rolf W. Rasmussen", "email": "rolfwr@ii.uib.no", "date": "2000-07-25T17:53:30Z"}, "committer": {"name": "Rolf Rasmussen", "email": "rolfwr@gcc.gnu.org", "date": "2000-07-25T17:53:30Z"}, "message": "ColorModel.java: New file...\n\n2000-07-23  Rolf W. Rasmussen  <rolfwr@ii.uib.no>\n\n\t* libjava/java/awt/image/ColorModel.java: New file, replaces the\n\tstub libjava/java/awt/ColorModel.java which was located in the\n\twrong package.\n\t* libjava/java/awt/image/ComponentColorModel.java: New file.\n\t* libjava/java/awt/image/ComponentSampleModel.java: New file.\n\t* libjava/java/awt/image/DataBuffer.java: New file.\n\t* libjava/java/awt/image/DataBufferByte.java: New file.\n\t* libjava/java/awt/image/DataBufferInt.java: New file.\n\t* libjava/java/awt/image/DataBufferUShort.java: New file.\n\t* libjava/java/awt/image/DirectColorModel.java: New file.\n\t* libjava/java/awt/image/PackedColorModel.java: New file.\n\t* libjava/java/awt/image/Raster.java: New file.\n\t* libjava/java/awt/image/SampleModel.java: New file.\n\t* libjava/java/awt/image/SinglePixelPackedSampleModel.java: New\n\tfile.\n\t* libjava/java/awt/image/IndexColorModel.java: New file.\n\t* libjava/java/awt/image/ImageConsumer.java: Removed import of\n\tjava.awt.ColorModel stub.\n\n\t* gnu/gcj/util/BitMaskExtent.java: New file, utility class.\n\t* gnu/gcj/util/Buffers.java: New file, utility class.\n\n\t* libjava/Makefile.am: Updated to include new files.\n\t* libjava/Makefile.in: Rebuilt.\n\nFrom-SVN: r35245", "tree": {"sha": "63ee8beca6a86986c9b97b7ab1cf2dced5a16fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63ee8beca6a86986c9b97b7ab1cf2dced5a16fb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/comments", "author": null, "committer": null, "parents": [{"sha": "4c31fe99c3f0d0c94771ec3ff8ee08840b7c553a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c31fe99c3f0d0c94771ec3ff8ee08840b7c553a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c31fe99c3f0d0c94771ec3ff8ee08840b7c553a"}], "stats": {"total": 4594, "additions": 4520, "deletions": 74}, "files": [{"sha": "08dd834c91c46466358bf0880b7c35a3759b669f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -1,3 +1,30 @@\n+2000-07-23  Rolf W. Rasmussen  <rolfwr@ii.uib.no>\n+\n+\t* libjava/java/awt/image/ColorModel.java: New file, replaces the\n+\tstub libjava/java/awt/ColorModel.java which was located in the\n+\twrong package.\n+\t* libjava/java/awt/image/ComponentColorModel.java: New file.\n+\t* libjava/java/awt/image/ComponentSampleModel.java: New file.\n+\t* libjava/java/awt/image/DataBuffer.java: New file.\n+\t* libjava/java/awt/image/DataBufferByte.java: New file.\n+\t* libjava/java/awt/image/DataBufferInt.java: New file.\n+\t* libjava/java/awt/image/DataBufferUShort.java: New file.\n+\t* libjava/java/awt/image/DirectColorModel.java: New file.\n+\t* libjava/java/awt/image/PackedColorModel.java: New file.\n+\t* libjava/java/awt/image/Raster.java: New file.\n+\t* libjava/java/awt/image/SampleModel.java: New file.\n+\t* libjava/java/awt/image/SinglePixelPackedSampleModel.java: New\n+\tfile.\n+\t* libjava/java/awt/image/IndexColorModel.java: New file.\n+\t* libjava/java/awt/image/ImageConsumer.java: Removed import of\n+\tjava.awt.ColorModel stub.\n+\n+\t* gnu/gcj/util/BitMaskExtent.java: New file, utility class.\n+\t* gnu/gcj/util/Buffers.java: New file, utility class.\n+\n+\t* libjava/Makefile.am: Updated to include new files.\n+\t* libjava/Makefile.in: Rebuilt.\n+\n 2000-07-23  Oskar Liljeblad <osk@hem.passagen.se>\n \n \t* java/io/StreamTokenizer.java: Merged with classpath."}, {"sha": "e558e1fcd2ffaeae5ba791f1fdda1338fdf4635e", "filename": "libjava/Makefile.am", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -486,6 +486,8 @@ gnu/gcj/convert/UnicodeToBytes.java\n special_java_source_files = java/lang/Class.java java/lang/Object.java\n \n awt_java_source_files =\t\\\n+gnu/gcj/awt/BitMaskExtent.java \\\n+gnu/gcj/awt/Buffers.java \\\n java/awt/AWTError.java \\\n java/awt/AWTEvent.java \\\n java/awt/AWTEventMulticaster.java \\\n@@ -495,7 +497,6 @@ java/awt/Adjustable.java \\\n java/awt/BorderLayout.java \\\n java/awt/CheckboxGroup.java \\\n java/awt/Color.java \\\n-java/awt/ColorModel.java \\\n java/awt/Component.java\t\\\n java/awt/ComponentOrientation.java \\\n java/awt/Container.java\t\\\n@@ -535,6 +536,9 @@ java/awt/TextComponent.java \\\n java/awt/Toolkit.java \\\n java/awt/Transparency.java \\\n java/awt/Window.java \\\n+java/awt/color/ColorSpace.java \\\n+java/awt/color/ICC_ColorSpace.java \\\n+java/awt/color/ICC_Profile.java \\\n java/awt/event/AWTEventListener.java \\\n java/awt/event/ActionEvent.java\t\\\n java/awt/event/ActionListener.java \\\n@@ -582,9 +586,23 @@ java/awt/geom/PathIterator.java\t\\\n java/awt/geom/Point2D.java \\\n java/awt/geom/Rectangle2D.java \\\n java/awt/geom/RectangularShape.java \\\n+java/awt/image/ColorModel.java \\\n+java/awt/image/ComponentColorModel.java \\\n+java/awt/image/ComponentSampleModel.java \\\n+java/awt/image/DataBuffer.java \\\n+java/awt/image/DataBufferByte.java \\\n+java/awt/image/DataBufferInt.java \\\n+java/awt/image/DataBufferUShort.java \\\n+java/awt/image/DirectColorModel.java \\\n java/awt/image/ImageConsumer.java \\\n java/awt/image/ImageObserver.java \\\n java/awt/image/ImageProducer.java \\\n+java/awt/image/IndexColorModel.java \\\n+java/awt/image/PackedColorModel.java \\\n+java/awt/image/Raster.java \\\n+java/awt/image/SampleModel.java \\\n+java/awt/image/SinglePixelPackedSampleModel.java \\\n+java/awt/image/WritableRaster.java \\\n java/awt/peer/ButtonPeer.java \\\n java/awt/peer/CanvasPeer.java \\\n java/awt/peer/CheckboxMenuItemPeer.java\t\\"}, {"sha": "87ceae1a44becca33c00c573ec332b9aaf9dcd7d", "filename": "libjava/Makefile.in", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -115,48 +115,31 @@ here = @here@\n libgcj_basedir = @libgcj_basedir@\n \n AUTOMAKE_OPTIONS = foreign no-installinfo\n-@TESTSUBDIR_TRUE@SUBDIRS = \\\n-@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = \\\n-@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n \n toolexeclib_LTLIBRARIES = libgcj.la\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.zip\n \n-@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.a\n-@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.c\n+@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = @NEEDS_DATA_START_TRUE@libgcjdata.a\n+@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = @NEEDS_DATA_START_TRUE@libgcjdata.c\n \n-@NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert gij\n+@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@GCJ = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@gcj\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@GCJ = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@$(target_alias)-gcj\n-@CANADIAN_FALSE@GCJ = \\\n-@CANADIAN_FALSE@$(expanded)/gcj$(EXEEXT) -B$(expanded)/\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n-@CANADIAN_FALSE@ZIP = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = \\\n-@CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n-@CANADIAN_FALSE@expanded = \\\n-@CANADIAN_FALSE@`cd $(MULTIBUILDTOP)../$(COMPPATH)/gcc && pwd`\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@GCJ = @CANADIAN_TRUE@@NULL_TARGET_TRUE@gcj\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@GCJ = @CANADIAN_TRUE@@NULL_TARGET_FALSE@$(target_alias)-gcj\n+@CANADIAN_FALSE@GCJ = @CANADIAN_FALSE@$(expanded)/gcj$(EXEEXT) -B$(expanded)/\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n+@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_FALSE@expanded = @CANADIAN_FALSE@`cd $(MULTIBUILDTOP)../$(COMPPATH)/gcc && pwd`\n \n GCJCOMPILE = CLASSPATH=$(here) $(LIBTOOL) --mode=compile $(GCJ) -fassume-compiled -L$(here) $(JC1FLAGS) -c\n GCJLINK = $(LIBTOOL) --mode=link $(GCJ) -L$(here) $(JC1FLAGS) $(LDFLAGS) -o $@\n@@ -170,10 +153,8 @@ WARNINGS = -W -Wall\n AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n \t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ $(WARNINGS) -D_GNU_SOURCE\n \n-@USING_GCC_TRUE@AM_CFLAGS = \\\n-@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = \\\n-@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n@@ -225,8 +206,7 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -282,6 +262,8 @@ gnu/gcj/convert/UnicodeToBytes.java\n special_java_source_files = java/lang/Class.java java/lang/Object.java\n \n awt_java_source_files = \\\n+gnu/gcj/awt/BitMaskExtent.java \\\n+gnu/gcj/awt/Buffers.java \\\n java/awt/AWTError.java \\\n java/awt/AWTEvent.java \\\n java/awt/AWTEventMulticaster.java \\\n@@ -291,7 +273,6 @@ java/awt/Adjustable.java \\\n java/awt/BorderLayout.java \\\n java/awt/CheckboxGroup.java \\\n java/awt/Color.java \\\n-java/awt/ColorModel.java \\\n java/awt/Component.java\t\\\n java/awt/ComponentOrientation.java \\\n java/awt/Container.java\t\\\n@@ -331,6 +312,9 @@ java/awt/TextComponent.java \\\n java/awt/Toolkit.java \\\n java/awt/Transparency.java \\\n java/awt/Window.java \\\n+java/awt/color/ColorSpace.java \\\n+java/awt/color/ICC_ColorSpace.java \\\n+java/awt/color/ICC_Profile.java \\\n java/awt/event/AWTEventListener.java \\\n java/awt/event/ActionEvent.java\t\\\n java/awt/event/ActionListener.java \\\n@@ -378,9 +362,23 @@ java/awt/geom/PathIterator.java\t\\\n java/awt/geom/Point2D.java \\\n java/awt/geom/Rectangle2D.java \\\n java/awt/geom/RectangularShape.java \\\n+java/awt/image/ColorModel.java \\\n+java/awt/image/ComponentColorModel.java \\\n+java/awt/image/ComponentSampleModel.java \\\n+java/awt/image/DataBuffer.java \\\n+java/awt/image/DataBufferByte.java \\\n+java/awt/image/DataBufferInt.java \\\n+java/awt/image/DataBufferUShort.java \\\n+java/awt/image/DirectColorModel.java \\\n java/awt/image/ImageConsumer.java \\\n java/awt/image/ImageObserver.java \\\n java/awt/image/ImageProducer.java \\\n+java/awt/image/IndexColorModel.java \\\n+java/awt/image/PackedColorModel.java \\\n+java/awt/image/Raster.java \\\n+java/awt/image/SampleModel.java \\\n+java/awt/image/SinglePixelPackedSampleModel.java \\\n+java/awt/image/WritableRaster.java \\\n java/awt/peer/ButtonPeer.java \\\n java/awt/peer/CanvasPeer.java \\\n java/awt/peer/CheckboxMenuItemPeer.java\t\\\n@@ -991,7 +989,8 @@ DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/$(srcdir)/$(CONVERT_DIR)/make-trie.P .deps/boehm.P \\\n .deps/defineclass.P .deps/exception.P .deps/gij.P \\\n-.deps/gnu/gcj/RawData.P .deps/gnu/gcj/convert/BytesToUnicode.P \\\n+.deps/gnu/gcj/RawData.P .deps/gnu/gcj/awt/BitMaskExtent.P \\\n+.deps/gnu/gcj/awt/Buffers.P .deps/gnu/gcj/convert/BytesToUnicode.P \\\n .deps/gnu/gcj/convert/Convert.P .deps/gnu/gcj/convert/Input_8859_1.P \\\n .deps/gnu/gcj/convert/Input_EUCJIS.P \\\n .deps/gnu/gcj/convert/Input_JavaSrc.P \\\n@@ -1050,14 +1049,13 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/AWTEventMulticaster.P .deps/java/awt/AWTException.P \\\n .deps/java/awt/ActiveEvent.P .deps/java/awt/Adjustable.P \\\n .deps/java/awt/BorderLayout.P .deps/java/awt/CheckboxGroup.P \\\n-.deps/java/awt/Color.P .deps/java/awt/ColorModel.P \\\n-.deps/java/awt/Component.P .deps/java/awt/ComponentOrientation.P \\\n-.deps/java/awt/Container.P .deps/java/awt/Cursor.P \\\n-.deps/java/awt/Dimension.P .deps/java/awt/Event.P \\\n-.deps/java/awt/EventDispatchThread.P .deps/java/awt/EventQueue.P \\\n-.deps/java/awt/Font.P .deps/java/awt/FontMetrics.P \\\n-.deps/java/awt/Frame.P .deps/java/awt/Graphics.P \\\n-.deps/java/awt/GraphicsConfiguration.P \\\n+.deps/java/awt/Color.P .deps/java/awt/Component.P \\\n+.deps/java/awt/ComponentOrientation.P .deps/java/awt/Container.P \\\n+.deps/java/awt/Cursor.P .deps/java/awt/Dimension.P \\\n+.deps/java/awt/Event.P .deps/java/awt/EventDispatchThread.P \\\n+.deps/java/awt/EventQueue.P .deps/java/awt/Font.P \\\n+.deps/java/awt/FontMetrics.P .deps/java/awt/Frame.P \\\n+.deps/java/awt/Graphics.P .deps/java/awt/GraphicsConfiguration.P \\\n .deps/java/awt/IllegalComponentStateException.P .deps/java/awt/Image.P \\\n .deps/java/awt/Insets.P .deps/java/awt/ItemSelectable.P \\\n .deps/java/awt/Label.P .deps/java/awt/LayoutManager.P \\\n@@ -1071,6 +1069,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/Shape.P .deps/java/awt/TextArea.P \\\n .deps/java/awt/TextComponent.P .deps/java/awt/Toolkit.P \\\n .deps/java/awt/Transparency.P .deps/java/awt/Window.P \\\n+.deps/java/awt/color/ColorSpace.P .deps/java/awt/color/ICC_ColorSpace.P \\\n+.deps/java/awt/color/ICC_Profile.P \\\n .deps/java/awt/event/AWTEventListener.P \\\n .deps/java/awt/event/ActionEvent.P \\\n .deps/java/awt/event/ActionListener.P \\\n@@ -1109,9 +1109,21 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/geom/PathIterator.P .deps/java/awt/geom/Point2D.P \\\n .deps/java/awt/geom/Rectangle2D.P \\\n .deps/java/awt/geom/RectangularShape.P \\\n+.deps/java/awt/image/ColorModel.P \\\n+.deps/java/awt/image/ComponentColorModel.P \\\n+.deps/java/awt/image/ComponentSampleModel.P \\\n+.deps/java/awt/image/DataBuffer.P .deps/java/awt/image/DataBufferByte.P \\\n+.deps/java/awt/image/DataBufferInt.P \\\n+.deps/java/awt/image/DataBufferUShort.P \\\n+.deps/java/awt/image/DirectColorModel.P \\\n .deps/java/awt/image/ImageConsumer.P \\\n .deps/java/awt/image/ImageObserver.P \\\n-.deps/java/awt/image/ImageProducer.P .deps/java/awt/peer/ButtonPeer.P \\\n+.deps/java/awt/image/ImageProducer.P \\\n+.deps/java/awt/image/IndexColorModel.P \\\n+.deps/java/awt/image/PackedColorModel.P .deps/java/awt/image/Raster.P \\\n+.deps/java/awt/image/SampleModel.P \\\n+.deps/java/awt/image/SinglePixelPackedSampleModel.P \\\n+.deps/java/awt/image/WritableRaster.P .deps/java/awt/peer/ButtonPeer.P \\\n .deps/java/awt/peer/CanvasPeer.P \\\n .deps/java/awt/peer/CheckboxMenuItemPeer.P \\\n .deps/java/awt/peer/CheckboxPeer.P .deps/java/awt/peer/ChoicePeer.P \\\n@@ -1751,7 +1763,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "2da39f86196548a8c0123115ec2b37251eea3f6e", "filename": "libjava/gnu/gcj/awt/BitMaskExtent.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fgnu%2Fgcj%2Fawt%2FBitMaskExtent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fgnu%2Fgcj%2Fawt%2FBitMaskExtent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fawt%2FBitMaskExtent.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,51 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.awt;\n+\n+/** \n+ * Simple transparent utility class that can be used to perform bit\n+ * mask extent calculations.\n+ */\n+public final class BitMaskExtent\n+{\n+  /** The number of the least significant bit of the bit mask extent. */\n+  public byte leastSignificantBit;\n+\n+  /** The number of bits in the bit mask extent. */\n+  public byte bitWidth;\n+  \n+  /**\n+   * Set the bit mask. This will calculate and set the leastSignificantBit\n+   * and bitWidth fields.\n+   *\n+   * @see #leastSignificantBit\n+   * @see #bitWidth\n+   */\n+  public void setMask(long mask)\n+  {\n+    leastSignificantBit = 0;\n+    bitWidth = 0;\n+    if (mask == 0) return;\n+    long shiftMask = mask;\n+    for (; (shiftMask&1) == 0; shiftMask >>>=1) leastSignificantBit++;\n+    for (; (shiftMask&1) != 0; shiftMask >>>=1) bitWidth++;\n+    \n+    if (shiftMask != 0)\n+      throw new IllegalArgumentException(\"mask must be continuous\");\n+  }\n+  \n+  /** \n+   * Calculate the bit mask based on the values of the\n+   * leastSignificantBit and bitWidth fields.\n+   */\n+  public long toMask()\n+  {\n+    return ((1<<bitWidth)-1) << leastSignificantBit;\n+  }  \n+}"}, {"sha": "d4ad3a84e24daa444b5fa94ed4ce391a64cb03d9", "filename": "libjava/gnu/gcj/awt/Buffers.java", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fgnu%2Fgcj%2Fawt%2FBuffers.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fgnu%2Fgcj%2Fawt%2FBuffers.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fawt%2FBuffers.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,168 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.awt;\n+\n+import java.awt.image.*;\n+\n+/** \n+ * Utility class for creating and accessing data buffers of arbitrary\n+ * data types.\n+ */\n+public final class Buffers\n+{\n+  /**\n+   * Create a data buffer of a particular type.\n+   *\n+   * @param dataType the desired data type of the buffer.\n+   * @param data an array containing data, or null\n+   * @param size the size of the data buffer bank\n+   */\n+  public static DataBuffer createBuffer(int dataType, Object data,\n+\t\t\t\t\tint size)\n+  {\n+    if (data == null) return createBuffer(dataType, size, 1);\n+\n+    return createBufferFromData(dataType, data, size);\n+  }\n+\n+\n+  /**\n+   * Create a data buffer of a particular type.\n+   *\n+   * @param dataType the desired data type of the buffer.\n+   * @param size the size of the data buffer bank\n+   */\n+  public static DataBuffer createBuffer(int dataType, int size) {\n+    return createBuffer(dataType, size, 1);\n+  }\n+\n+  /**\n+   * Create a data buffer of a particular type.\n+   *\n+   * @param dataType the desired data type of the buffer.\n+   * @param size the size of the data buffer bank\n+   * @param numBanks the number of banks the buffer should have\n+   */\n+  public static DataBuffer createBuffer(int dataType, int size, int numBanks)\n+  {\n+    switch (dataType)\n+      {\n+      case DataBuffer.TYPE_BYTE:\n+\treturn new DataBufferByte(size, numBanks);\n+      case DataBuffer.TYPE_USHORT:\n+\treturn new DataBufferUShort(size, numBanks);\n+      case DataBuffer.TYPE_INT:\n+\treturn new DataBufferInt(size, numBanks);\n+      default:\n+\tthrow new UnsupportedOperationException();\n+      }\n+  }\n+  \n+  /**\n+   * Create a data buffer of a particular type.\n+   *\n+   * @param dataType the desired data type of the buffer\n+   * @param data an array containing the data\n+   * @param size the size of the data buffer bank\n+   */\n+  public static DataBuffer createBufferFromData(int dataType, Object data,\n+\t\t\t\t\t\tint size)\n+  {\n+    switch (dataType)\n+      {\n+      case DataBuffer.TYPE_BYTE:\n+\treturn new DataBufferByte((byte[]) data, size);\n+      case DataBuffer.TYPE_USHORT:\n+\treturn new DataBufferUShort((short[]) data, size);\n+      case DataBuffer.TYPE_INT:\n+\treturn new DataBufferInt((int[]) data, size);\n+      default:\n+\tthrow new UnsupportedOperationException();\n+      }\n+  }\n+\n+  /** \n+   * Return the data array of a data buffer, regardless of the data\n+   * type.\n+   *\n+   * @return an array of primitive values. The actual array type\n+   * depends on the data type of the buffer.\n+   */\n+  public static Object getData(DataBuffer buffer)\n+  {\n+    if (buffer instanceof DataBufferByte)\n+      return ((DataBufferByte) buffer).getData();\n+    if (buffer instanceof DataBufferUShort)\n+      return ((DataBufferUShort) buffer).getData();\n+    if (buffer instanceof DataBufferInt)\n+      return ((DataBufferInt) buffer).getData();\n+    throw new ClassCastException(\"Unknown data buffer type\");\n+  }\n+\n+    \n+  /**\n+   * Copy data from array contained in data buffer, much like\n+   * System.arraycopy. Create a suitable destination array if the\n+   * given destination array is null.\n+   */\n+  public static Object getData(DataBuffer src, int srcOffset,\n+\t\t\t       Object dest,  int destOffset,\n+\t\t\t       int length)\n+  {\n+    Object from;\n+    if (src instanceof DataBufferByte)\n+      {\n+\tfrom = ((DataBufferByte) src).getData();\n+\tif (dest == null) dest = new byte[length+destOffset];\n+      }\n+    else if (src instanceof DataBufferUShort)\n+      {\n+\tfrom = ((DataBufferUShort) src).getData();\n+\tif (dest == null) dest = new short[length+destOffset];\n+      }\n+    else if (src instanceof DataBufferInt)\n+      {\n+\tfrom = ((DataBufferInt) src).getData();\n+\tif (dest == null) dest = new int[length+destOffset];\n+      }\n+    else\n+      {\n+\tthrow new ClassCastException(\"Unknown data buffer type\");\n+      }\n+    \n+    System.arraycopy(from, srcOffset, dest, destOffset, length);\n+    return dest;\n+  }\n+  \n+  /**\n+   * @param bits the width of a data element measured in bits\n+   *\n+   * @return the smallest data type that can store data elements of\n+   * the given number of bits, without any truncation.\n+   */\n+  public static int smallestAppropriateTransferType(int bits)\n+  {\n+    if (bits <= 8)\n+      {\n+\treturn DataBuffer.TYPE_BYTE;\n+      }\n+    else if (bits <= 16)\n+      {\n+\treturn DataBuffer.TYPE_USHORT;\n+      } \n+    else if (bits <= 32)\n+      {\n+\treturn DataBuffer.TYPE_INT;\n+      }\n+    else\n+      {\n+\treturn DataBuffer.TYPE_UNDEFINED;\n+      }\n+  }\n+}"}, {"sha": "0e58df1292c8faefac61029101d27a86b525d0ea", "filename": "libjava/java/awt/ColorModel.java", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c31fe99c3f0d0c94771ec3ff8ee08840b7c553a/libjava%2Fjava%2Fawt%2FColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c31fe99c3f0d0c94771ec3ff8ee08840b7c553a/libjava%2Fjava%2Fawt%2FColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FColorModel.java?ref=4c31fe99c3f0d0c94771ec3ff8ee08840b7c553a", "patch": "@@ -1,20 +0,0 @@\n-/* Copyright (C) 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package java.awt;\n-\n-/* Status: Just a placeholder. */\n-\n-public class ColorModel implements Transparency\n-{\n-  public int getTransparency()\n-  {\n-    // FIXME\n-    return 0;  \n-  }\n-}"}, {"sha": "e6e1251f780535749f2fa6431a4632bae180a520", "filename": "libjava/java/awt/color/ColorSpace.java", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fcolor%2FColorSpace.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fcolor%2FColorSpace.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fcolor%2FColorSpace.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,111 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.color;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public abstract class ColorSpace\n+{\n+  public static final int TYPE_XYZ   = 0;\n+  public static final int TYPE_Lab   = 1;\n+  public static final int TYPE_Luv   = 2;\n+  public static final int TYPE_YCbCr = 3;\n+  public static final int TYPE_Yxy   = 4;\n+  public static final int TYPE_RGB   = 5;\n+  public static final int TYPE_GRAY  = 6;\n+  public static final int TYPE_HSV   = 7;\n+  public static final int TYPE_HLS   = 8;\n+  public static final int TYPE_CMYK  = 9;\n+  // mysterious gap in the enumeration sequenece\n+  public static final int TYPE_CMY  = 11;\n+  public static final int TYPE_2CLR = 12;\n+  public static final int TYPE_3CLR = 13;\n+  public static final int TYPE_4CLR = 14;\n+  public static final int TYPE_5CLR = 15;\n+  public static final int TYPE_6CLR = 16;\n+  public static final int TYPE_7CLR = 17;\n+  public static final int TYPE_8CLR = 18;\n+  public static final int TYPE_9CLR = 19;\n+  public static final int TYPE_ACLR = 20;\n+  public static final int TYPE_BCLR = 21;\n+  public static final int TYPE_CCLR = 22;\n+  public static final int TYPE_DCLR = 23;\n+  public static final int TYPE_ECLR = 24;\n+  public static final int TYPE_FCLR = 25;\n+  \n+  public static final int CS_sRGB       = 1000;\n+  public static final int CS_CIEXYZ     = 1001;\n+  public static final int CS_PYCC       = 1002;\n+  public static final int CS_GRAY       = 1003;\n+  public static final int CS_LINEAR_RGB = 1004;\n+  \n+  private static final int CS_BASE  = CS_sRGB;\n+  private static final int CS_END   = CS_LINEAR_RGB+1;\n+  private static final int CS_COUNT = CS_END - CS_BASE;\n+  \n+  // Instances are lazily instantiated\n+  private static final ColorSpace[] INSTANCES = new ColorSpace[CS_COUNT];\n+\n+  private int type;\n+  private int numcomponents;\n+  protected ColorSpace(int type, int numcomponents)\n+  {\n+    this.type = type;\n+    this.numcomponents = numcomponents;\n+  }\n+\t\n+  public static ColorSpace getInstance(int colorspace)\n+  {\n+    if ((colorspace >= CS_BASE) && (colorspace < CS_END))\n+      {\n+\tint instanceIndex = colorspace - CS_BASE;\n+\tif (INSTANCES[instanceIndex] == null)\n+\t  {\n+\t    ICC_Profile profile = new ICC_Profile(colorspace);\n+\t    INSTANCES[instanceIndex] = new ICC_ColorSpace(profile);\n+\t  }\n+\treturn INSTANCES[instanceIndex];\n+      }\n+    throw new IllegalArgumentException(\"unknown/unsupported colorspace\");\n+  }\n+  \n+  public boolean isCS_sRGB()\n+  {\n+    return false;\n+  }\n+\n+  public abstract float[] toRGB(float[] colorvalue);\n+  \n+  public abstract float[] fromRGB(float[] rgbvalue);\n+  \n+  public abstract float[] toCIEXYZ(float[] colorvalue);\n+  \n+  public abstract float[] fromCIEXYZ(float[] colorvalue);\n+\n+  public int getType()\n+  {\n+    return type;\n+  }\n+\n+  public int getNumComponents()\n+  {\n+    return numcomponents;\n+  }\n+  \n+  public String getName(int idx)\n+  {\n+    return \"type \" + type;\n+  }\n+  \n+  public String toString()\n+  {\n+    return getClass().getName() + \"[type=\" + type + \"]\";\n+  }\n+}"}, {"sha": "90ff88c8bdcc07486cd3ae899e9e29a02acb4a8b", "filename": "libjava/java/awt/color/ICC_ColorSpace.java", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fcolor%2FICC_ColorSpace.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fcolor%2FICC_ColorSpace.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fcolor%2FICC_ColorSpace.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,53 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.color;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class ICC_ColorSpace extends ColorSpace\n+{\n+  private ICC_Profile profile;\n+\n+  public ICC_ColorSpace(ICC_Profile profile)\n+  {\n+    super(CS_sRGB, profile.getNumComponents());\n+    \n+    this.profile = profile;\n+  }\n+\n+  public ICC_Profile getProfile()\n+  {\n+    return profile;\n+  }\n+\n+  public float[] toRGB(float[] colorvalue)\n+  {\n+    // FIXME: Always assumes sRGB:\n+    return colorvalue;\n+  }\n+\n+  public float[] fromRGB(float[] rgbvalue)\n+  {\n+    // FIXME: Always assumes sRGB:\n+    return rgbvalue;\n+  }\n+\n+  public float[] toCIEXYZ(float[] colorvalue)\n+  {\n+    // FIXME: Not implemented\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public float[] fromCIEXYZ(float[] colorvalue)\n+  {\n+    // FIXME: Not implemented\n+    throw new UnsupportedOperationException();\n+  }\n+}"}, {"sha": "475aa559ba466c5ca73f530d177d657af1cf95b3", "filename": "libjava/java/awt/color/ICC_Profile.java", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fcolor%2FICC_Profile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fcolor%2FICC_Profile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fcolor%2FICC_Profile.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.color;\n+\n+// Currently just a stub.\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class ICC_Profile\n+{\n+  long profileID; // why long?\n+  \n+  ICC_Profile(long profileID)\n+  {\n+    this.profileID = profileID;\n+  }\n+\n+  public int getNumComponents()\n+  {\n+    switch (profileID)\n+      {\n+      case ColorSpace.CS_sRGB:\n+      case ColorSpace.CS_LINEAR_RGB:\n+      case ColorSpace.CS_CIEXYZ:\n+\treturn 3;\n+      case ColorSpace.CS_GRAY:\n+\treturn 1;\n+      case ColorSpace.CS_PYCC:    // have no clue about this one\n+      default:\n+\tthrow new UnsupportedOperationException(\"profile not implemented\");\n+      }\n+  }\n+}"}, {"sha": "ceee27847b38131d4366d4e7cec14a1a16168b6c", "filename": "libjava/java/awt/image/ColorModel.java", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FColorModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,575 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.Point;\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import gnu.gcj.awt.Buffers;\n+\n+/**\n+ * A color model operates with colors in several formats:\n+ *\n+ * <ul>\n+ * <li>normalized: component samples are in range [0.0, 1.0].</li>\n+ *\n+ * <li>color model pixel value: all the color component samples for a\n+ * sigle pixel packed/encoded in a way natural for the color\n+ * model.</li>\n+ *\n+ * <li>color model pixel int value: only makes sense if the natural\n+ * encoding of a single pixel can fit in a single int value.</li>\n+ *\n+ * <li>array of transferType containing a single pixel: the pixel is\n+ * encoded in the natural way of the color model, taking up as many\n+ * array elements as needed.</li>\n+ *\n+ * <li>sRGB pixel int value: a pixel in sRGB color space, encoded in\n+ * default 0xAARRGGBB format, assumed not alpha premultiplied.</li>\n+ * \n+ * <li>single [0, 255] scaled int samples from default sRGB color\n+ * space. These are always assumed to be alpha non-premultiplied.</li>\n+ *\n+ * <li>arrays of unnormalized component samples of single pixel: these\n+ * samples are scaled and multiplied according to the color model, but\n+ * is otherwise not packed or encoded. Each element of the array is one\n+ * seperate component sample. The color model only operate on the\n+ * components from one pixel at a time, but using offsets, allows\n+ * manipulation of arrays that contain the components of more than one\n+ * pixel.</li>\n+ *\n+ * </ul>\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+\n+public abstract class ColorModel implements Transparency\n+{\n+  protected int pixel_bits;\n+  protected int transferType;\n+\n+  private int[] bits;\n+  private ColorSpace cspace;\n+  private int transparency;\n+  private boolean hasAlpha;\n+  private boolean isAlphaPremultiplied;\n+    \n+  static int[] nArray(int value, int times)\n+  {\n+    int[] array = new int[times];\n+    java.util.Arrays.fill(array, value);\n+    return array;\n+  }\n+\n+  static byte[] nArray(byte value, int times)\n+  {\n+    byte[] array = new byte[times];\n+    java.util.Arrays.fill(array, value);\n+    return array;\n+  } \n+\n+  public ColorModel(int bits)\n+  {\n+    this(bits * 4, // total bits, sRGB, four channels\n+\t nArray(bits, 4), // bits for each channel\n+\t null, // FIXME: should be sRGB\n+\t true, // has alpha\n+\t false, // not premultiplied\n+\t TRANSLUCENT,\n+\t Buffers.smallestAppropriateTransferType(bits * 4));\n+  }\n+\n+  protected ColorModel(int pixel_bits, int[] bits, ColorSpace cspace,\n+\t\t       boolean hasAlpha, boolean isAlphaPremultiplied,\n+\t\t       int transparency, int transferType)\n+  {\n+    this.pixel_bits = pixel_bits;\n+    this.bits = bits;\n+    this.cspace = cspace;\n+    this.hasAlpha = hasAlpha;\n+    this.isAlphaPremultiplied = isAlphaPremultiplied;\n+    this.transparency = transparency;\n+    this.transferType = transferType;\n+  }\n+\n+  public static ColorModel getRGBdefault()\n+  {\n+    return new DirectColorModel(8, 0xff0000, 0xff00, 0xff, 0xff000000);\n+  }\n+\n+  public final boolean hasAlpha()\n+  {\n+    return hasAlpha;\n+  }\n+\n+  public final boolean isAlphaPremultiplied()\n+  {\n+    return isAlphaPremultiplied;\n+  }\n+\n+  public int getPixelSize()\n+  {\n+    return pixel_bits;\n+  }\n+    \n+  public int getComponentSize(int componentIdx)\n+  {\n+    return bits[componentIdx];\n+  }\n+    \n+  public int[] getComponentSize()\n+  {\n+    return bits;\n+  }\n+\n+  public int getTransparency()\n+  {\n+    return transparency;\n+  }\n+\n+  public int getNumComponents()\n+  {\n+    return getNumColorComponents() + (hasAlpha ? 1 : 0);\n+  }\n+\n+  public int getNumColorComponents()\n+  {\n+    return cspace.getNumComponents();\n+  }\n+\n+  /**\n+   * Converts pixel value to sRGB and extract red int sample scaled\n+   * to range [0, 255].\n+   *\n+   * @param pixel pixel value that will be interpreted according to\n+   * the color model, (assumed alpha premultiplied if color model says\n+   * so.)\n+   *\n+   * @return red sample scaled to range [0, 255], from default color\n+   * space sRGB, alpha non-premultiplied.\n+   */\n+  public abstract int getRed(int pixel);\n+\n+  /**\n+   * Converts pixel value to sRGB and extract green int sample\n+   * scaled to range [0, 255].\n+   *\n+   * @see #getRed(int)\n+   */\n+    public abstract int getGreen(int pixel);\n+    \n+  /**\n+   * Converts pixel value to sRGB and extract blue int sample\n+   * scaled to range [0, 255].\n+   *\n+   * @see #getRed(int)\n+   */\n+  public abstract int getBlue(int pixel);\n+\n+  /**\n+   * Extract alpha int sample from pixel value, scaled to [0, 255].\n+   *\n+   * @param pixel pixel value that will be interpreted according to\n+   * the color model.\n+   *\n+   * @return alpha sample, scaled to range [0, 255].\n+   */\n+  public abstract int getAlpha(int pixel);\n+\n+  /**\n+   * Converts a pixel int value of the color space of the color\n+   * model to a sRGB pixel int value.\n+   *\n+   * This method is typically overriden in subclasses to provide a\n+   * more efficient implementation.\n+   * \n+   * @param pixel pixel value that will be interpreted according to\n+   * the color model.\n+   *\n+   * @return a pixel in sRGB color space, encoded in default\n+   * 0xAARRGGBB format.  */\n+  public int getRGB(int pixel)\n+  {\n+    return \n+      ((getAlpha(pixel) & 0xff) << 24) |\n+      ((  getRed(pixel) & 0xff) << 16) |\n+      ((getGreen(pixel) & 0xff) <<  8) |\n+      (( getBlue(pixel) & 0xff) <<  0);\n+  }\n+  \n+\n+  /**\n+   * In this color model we know that the whole pixel value will\n+   * always be contained within the first element of the pixel\n+   * array.\n+   */\n+  final int getPixelFromArray(Object inData) {\n+    DataBuffer data =\n+      Buffers.createBufferFromData(transferType, inData, 1);\n+    Object da = Buffers.getData(data);\n+\n+    return data.getElem(0);\n+  }\n+\n+  /** \n+   * Converts pixel in the given array to sRGB and extract blue int\n+   * sample scaled to range [0-255].\n+   *\n+   * This method is typically overriden in subclasses to provide a\n+   * more efficient implementation.\n+   * \n+   * @param array of transferType containing a single pixel.  The\n+   * pixel should be encoded in the natural way of the color model.\n+   */\n+  public int getRed(Object inData)\n+  {\n+    return getRed(getPixelFromArray(inData));\n+  }\n+\n+  /**\n+   * @see #getRed(Object)\n+   */\n+  public int getGreen(Object inData)\n+  {\n+    return getGreen(getPixelFromArray(inData));\n+  }\n+\n+  /**\n+   * @see #getRed(Object)\n+   */\n+  public int getBlue(Object inData) {\n+    return getBlue(getPixelFromArray(inData));\n+  }\n+\n+  /**\n+   * @see #getRed(Object)\n+   */\n+  public int getAlpha(Object inData) {\n+    return getBlue(getPixelFromArray(inData));\n+  }\n+\n+  /**\n+   * Converts a pixel in the given array of the color space of the\n+   * color model to an sRGB pixel int value.\n+   *\n+   * <p>This method performs the inverse function of\n+   * <code>getDataElements(int rgb, Object pixel)</code>.\n+   * I.e. <code>(rgb == cm.getRGB(cm.getDataElements(rgb,\n+   * null)))</code>.\n+   *\n+   * @param inData array of transferType containing a single pixel. The\n+   * pixel should be encoded in the natural way of the color model.\n+   *\n+   * @return a pixel in sRGB color space, encoded in default\n+   * 0xAARRGGBB format.\n+   *\n+   * @see #getDataElements(int, Object)\n+   */\n+  public int getRGB(Object inData)\n+  {\n+    return \n+      ((getAlpha(inData) & 0xff) << 24) |\n+      ((  getRed(inData) & 0xff) << 16) |\n+      ((getGreen(inData) & 0xff) <<  8) |\n+      (( getBlue(inData) & 0xff) <<  0);\n+  }\n+\n+  /**\n+   * Converts an sRGB pixel int value to an array containing a\n+   * single pixel of the color space of the color model.\n+   * \n+   * <p>This method performs the inverse function of\n+   * <code>getRGB(Object inData)</code>.\n+   *\n+   * Outline of conversion process:\n+   *\n+   * <ol>\n+   *\n+   * <li>Convert rgb to normalized [0.0, 1.0] sRGB values.</li>\n+   *\n+   * <li>Convert to color space components using fromRGB in\n+   * ColorSpace.</li>\n+   *\n+   * <li>If color model has alpha and should be premultiplied,\n+   * multiply color space components with alpha value</li>\n+   *\n+   * <li>Scale the components to the correct number of bits.</li>\n+   *\n+   * <li>Arrange the components in the output array</li>\n+   * \n+   * </ol>\n+   *\n+   * @param rgb The color to be converted to dataElements.  A pixel\n+   * in sRGB color space, encoded in default 0xAARRGGBB format,\n+   * assumed not alpha premultiplied.\n+   *\n+   * @param pixel to avoid needless creation of arrays, an array to\n+   * use to return the pixel can be given. If null, a suitable array\n+   * will be created.\n+   *\n+   * @return An array of transferType values representing the color,\n+   * in the color model format. The color model defines whether the\n+   *  \n+   * @see #getRGB(Object)\n+   */\n+  public Object getDataElements(int rgb, Object pixel)\n+  {\n+    // FIXME: implement\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Fills an array with the unnormalized component samples from a\n+   * pixel value. I.e. decompose the pixel, but not perform any\n+   * color conversion. \n+   *\n+   * This method is typically overriden in subclasses to provide a\n+   * more efficient implementation.\n+   * \n+   * @param pixel pixel value encoded according to the color model.\n+   *\n+   * @return arrays of unnormalized component samples of single\n+   * pixel.  The scale and multiplication state of the samples are\n+   * according to the color model. Each component sample is stored\n+   * as a seperate element in the array.\n+   */\n+  public int[] getComponents(int pixel, int[] components, int offset) {\n+    // FIXME: implement\n+    throw new UnsupportedOperationException();\n+  }\n+  \n+  /**\n+   * Fills an array with the unnormalized component samples from an\n+   * array of transferType containing a single pixel. I.e. decompose\n+   * the pixel, but not perform any color conversion.\n+   *\n+   * This method is typically overriden in subclasses to provide a\n+   * more efficient implementation.\n+   *\n+   * @param array of transferType containing a single pixel.  The\n+   * pixel should be encoded in the natural way of the color model.\n+   * \n+   * @return arrays of unnormalized component samples of single\n+   * pixel.  The scale and multiplication state of the samples are\n+   * according to the color model. Each component sample is stored\n+   * as a seperate element in the array.\n+   */\n+  public int[] getComponents(Object pixel, int[] components, int offset)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Convert normalized components to unnormalized components.\n+   */\n+  public int[] getUnnormalizedComponents(float[] normComponents,\n+\t\t\t\t\t int normOffset,\n+\t\t\t\t\t int[] components,\n+\t\t\t\t\t int offset)\n+  {\n+    int numComponents = getNumComponents();\n+    if (components == null)\n+    {\n+      components = new int[offset + numComponents];\n+    }\n+    \n+    for (int i=0; i<numComponents; i++)\n+    {\n+      float in = normComponents[normOffset++];\n+      int out = (int) (in * ((2<<getComponentSize(i)) - 1));\n+      components[offset++] = out;\n+    }\n+    return components;\n+  }\n+\n+  /**\n+   * Convert unnormalized components to normalized components.\n+   */\n+  public float[] getNormalizedComponents(int[] components,\n+\t\t\t\t\t int offset,\n+\t\t\t\t\t float[] normComponents,\n+\t\t\t\t\t int normOffset)\n+  {\n+    int numComponents = getNumComponents();\n+    if (normComponents == null)\n+    {\n+      normComponents = new float[normOffset + numComponents];\n+    }\n+\n+    for (int i=0; i<numComponents; i++)\n+    {\n+      float in = components[offset++];\n+      float out = in / ((2<<getComponentSize(i)) - 1);\n+      normComponents[normOffset++] = out;\n+    }\n+    return normComponents;\n+  }\n+\n+  /**\n+   * Converts the unnormalized component samples from an array to a\n+   * pixel value. I.e. composes the pixel from component samples, but\n+   * does not perform any color conversion or scaling of the samples.\n+   * \n+   * This method performs the inverse function of\n+   * <code>getComponents(int pixel, int[] components,\n+   *\t\t\t       int offset)</code>. I.e.\n+   *\n+   * <code>(pixel == cm.getDataElement(cm.getComponents(pixel, null,\n+   * 0), 0))</code>.\n+   *\n+   * This method is typically overriden in subclasses to provide a\n+   * more efficient implementation.\n+   *\n+   * @param arrays of unnormalized component samples of single\n+   * pixel.  The scale and multiplication state of the samples are\n+   * according to the color model. Each component sample is stored\n+   * as a seperate element in the array.\n+   *\n+   * @return pixel value encoded according to the color model.\n+   */\n+  public int getDataElement(int[] components, int offset)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public Object getDataElements(int[] components, int offset, Object obj)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    if (!(obj instanceof ColorModel)) return false;\n+\n+    ColorModel o = (ColorModel) obj;\n+    return \n+      (pixel_bits == o.pixel_bits) &&\n+      (transferType == o.transferType) &&\n+      (transparency == o.transparency) &&\n+      (hasAlpha == o.hasAlpha) &&\n+      (isAlphaPremultiplied == isAlphaPremultiplied) &&\n+      (bits.equals(o.bits)) &&\n+      (cspace.equals(o.cspace));\n+  }\n+\n+  public final ColorSpace getColorSpace()\n+  {\n+    return cspace;\n+  }\n+\n+  // Typically overridden\n+  public ColorModel coerceData(WritableRaster raster,\n+\t\t\t       boolean isAlphaPremultiplied)\n+  {\n+    if (this.isAlphaPremultiplied == isAlphaPremultiplied)\n+      return this;\n+\n+    int w = raster.getWidth();\n+    int h = raster.getHeight();\n+    int x = raster.getMinX();\n+    int y = raster.getMinY();\n+    int size = w*h;\n+    int numColors = getNumColorComponents();\n+    int numComponents = getNumComponents();\n+    int alphaScale = (1<<getComponentSize(numColors)) - 1;\n+    double[] pixels = raster.getPixels(x, y, w, h, (double[]) null);\n+\n+    for (int i=0; i<size; i++)\n+      {\n+\tdouble alpha = pixels[i*numComponents+numColors]*alphaScale;\n+\tfor (int c=0; c<numColors; c++)\n+\t  {\n+\t    int offset = i*numComponents+c;\n+\t    if (isAlphaPremultiplied)\n+\t\tpixels[offset] = pixels[offset]/alpha;\n+\t    else\n+\t      pixels[offset] = pixels[offset]*alpha;\n+\t  }\n+      }\n+    \n+    raster.setPixels(0, 0, w, h, pixels);\n+\n+    // FIXME: what can we return?\n+    return null;\n+  }\n+    \n+  // Typically overridden\n+  public boolean isCompatibleRaster(Raster raster)\n+  {\n+    SampleModel sampleModel = raster.getSampleModel();\n+    return isCompatibleSampleModel(sampleModel);\n+  }\n+\n+  // Typically overridden\n+  public WritableRaster createCompatibleWritableRaster(int w, int h)\n+  {\n+    return new WritableRaster(createCompatibleSampleModel(w, h),\n+\t\t\t      new Point(0, 0));\n+  }\n+\n+  // Typically overridden\n+  public SampleModel createCompatibleSampleModel(int w, int h)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  // Typically overridden\n+  public boolean isCompatibleSampleModel(SampleModel sm)\n+  {\n+    return sm.getTransferType() == transferType;\n+  }\n+\n+  public void finalize() {\n+  }\n+\n+  /**\n+   * Subclasses must override this method if it is possible for the\n+   * color model to have an alpha channel.\n+   *\n+   * @return null, as per JDK 1.3 doc. Subclasses will only return\n+   * null if no alpha raster exists.\n+   */\n+  public WritableRaster getAlphaRaster(WritableRaster raster)\n+  {\n+    return null;\n+    \n+    /* It is a mystery to me why we couldn't use the following code...\n+       \n+       \n+       if (!hasAlpha()) return null;\n+       \n+       SampleModel sm = raster.getSampleModel();\n+       int[] alphaBand = { sm.getNumBands() - 1 };\n+       SampleModel alphaModel = sm.createSubsetSampleModel(alphaBand);\n+       DataBuffer buffer = raster.getDataBuffer();\n+       Point origin = new Point(0, 0);\n+       return Raster.createWritableRaster(alphaModel, buffer, origin);\n+       \n+\n+       ...here, and avoided overriding the method in subclasses,\n+       but the Sun docs state that this method always will return\n+       null, and that overriding is required. Oh, well.\n+    */\n+  }\n+\n+  String stringParam()\n+  {\n+    return \"pixel_bits=\" + pixel_bits +\n+      \", cspace=\" + cspace +\n+      \", transferType=\" + transferType +\n+      \", transparency=\" + transparency +\n+      \", hasAlpha=\" + hasAlpha +\n+      \", isAlphaPremultiplied=\" + isAlphaPremultiplied;\n+  }\n+\n+  public String toString()\n+  {\n+    return getClass().getName() + \"[\" + stringParam() + \"]\";\n+  }\n+}"}, {"sha": "deb40ff73b40f03f717eb7e6a7f8f0a17f88a859", "filename": "libjava/java/awt/image/ComponentColorModel.java", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FComponentColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FComponentColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FComponentColorModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,303 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.color.*;\n+import java.awt.Point;\n+import gnu.gcj.awt.Buffers;\n+\n+public class ComponentColorModel extends ColorModel\n+{\n+  private static int sum(int[] values)\n+  {\n+    int sum = 0;\n+    for (int i=0; i<values.length; i++)\n+      sum += values[i];\n+    return sum;\n+  }\n+\n+  public ComponentColorModel(ColorSpace colorSpace, int[] bits,\n+\t\t\t     boolean hasAlpha,\n+\t\t\t     boolean isAlphaPremultiplied,\n+\t\t\t     int transparency, int transferType)\n+  {\n+    super(sum(bits), bits, colorSpace, hasAlpha, isAlphaPremultiplied,\n+\t  transparency, transferType);\n+  }\n+\n+  public int getRed(int pixel)\n+  {\n+    if (getNumComponents()>1) throw new IllegalArgumentException();\n+    return (int) getRGBFloat(pixel)[0];\n+  }\n+\n+  public int getGreen(int pixel)\n+  {\n+    if (getNumComponents()>1) throw new IllegalArgumentException();\n+    return (int) getRGBFloat(pixel)[0];\n+  }\n+  \n+  public int getBlue(int pixel)\n+  {\n+    if (getNumComponents()>1) throw new IllegalArgumentException();\n+    return (int) getRGBFloat(pixel)[0];\n+  }\n+\n+  public int getAlpha(int pixel)\n+  {\n+    if (getNumComponents()>1) throw new IllegalArgumentException();\n+    int shift = 8 - getComponentSize(getNumColorComponents());\n+    if (shift >= 0) return pixel << shift;\n+    return pixel >> (-shift);\n+  }\n+   \n+  public int getRGB(int pixel)\n+  {\n+    float[] rgb = getRGBFloat(pixel);\n+    int ret = getRGB(rgb);\n+    if (hasAlpha()) ret |= getAlpha(pixel) << 24;\n+    return ret;\n+  }\n+\n+\n+  /* FIXME: Is the values returned from toRGB() in the [0.0, 1.0] or the\n+     [0.0, 256) range? \n+     \n+     we assume it is in the [0.0, 1.0] range along with the\n+     other color spaces. */\n+  \n+  /* Note, it's OK to pass a to large array to toRGB(). Extra\n+     elements are ignored. */\n+  \n+  private float[] getRGBFloat(int pixel)\n+  {\n+    float[] data = { pixel };\n+    return cspace.toRGB(data);\n+  }\n+\n+  private float[] getRGBFloat(Object inData)\n+  {\n+    DataBuffer buffer =\n+    Buffers.createBufferFromData(transferType, inData,\n+\t\t\t\t getNumComponents());\n+    int colors = getNumColorComponents();\n+    float[] data = new float[colors];\n+    \n+    // FIXME: unpremultiply data that is premultiplied\n+    for (int i=0; i<colors; i++)\n+      {\n+\tfloat maxValue = (1<<getComponentSize(i))-1;\n+\tdata[i] = buffer.getElemFloat(i)/maxValue; \n+      }\n+    float[] rgb = cspace.toRGB(data);\n+    return rgb;\n+  }\n+  \n+  public int getRed(Object inData)\n+  {\n+    return (int) getRGBFloat(inData)[0]*255;\n+  }\n+\n+  public int getGreen(Object inData)\n+  {\n+    return (int) getRGBFloat(inData)[1]*255;\n+  }\n+\n+  public int getBlue(Object inData)\n+  {\n+    return (int) getRGBFloat(inData)[2]*255;\n+  }\n+\n+  public int getAlpha(Object inData)\n+  {\n+    DataBuffer buffer =\n+      Buffers.createBufferFromData(transferType, inData,\n+\t\t\t\t   getNumComponents());\n+    int shift = 8 - getComponentSize(getNumColorComponents());\n+    int alpha = buffer.getElem(getNumColorComponents());\n+    if (shift >= 0) return alpha << shift;\n+    return alpha >> (-shift);\n+  }\n+\n+  private int getRGB(float[] rgb)\n+  {\n+    /* NOTE: We could cast to byte instead of int here. This would\n+       avoid bits spilling over from one bit field to\n+       another. But, if we assume that floats are in the [0.0,\n+       1.0] range, this will never happen anyway. */\n+    \n+    /* Remember to multiply BEFORE casting to int, otherwise, decimal\n+       point data will be lost. */\n+    int ret =\n+      (((int) (rgb[0]*255F)) << 16) |\n+      (((int) (rgb[1]*255F)) <<  8) |\n+      (((int) (rgb[2]*255F)) <<  0);\n+    return ret;\n+  }\n+\n+  /**\n+   * @param inData pixel data of transferType, as returned by the\n+   * getDataElements method in SampleModel.\n+   */\n+  public int getRGB(Object inData)\n+  {\n+    float[] rgb = getRGBFloat(inData);\n+    int ret = getRGB(rgb);\n+    if (hasAlpha()) ret |= getAlpha(inData) << 24;\n+    return ret;\n+  }\n+\n+  public Object getDataElements(int rgb, Object pixel)\n+  {\n+    // Convert rgb to [0.0, 1.0] sRGB values.\n+    float[] rgbFloats = {\n+      ((rgb >> 16)&0xff)/255.0F,\n+      ((rgb >>  8)&0xff)/255.0F,\n+      ((rgb >>  0)&0xff)/255.0F\n+    };\n+\n+    // Convert from rgb to color space components.\n+    float[] data = cspace.fromRGB(rgbFloats);\n+    DataBuffer buffer = Buffers.createBuffer(transferType, pixel,\n+\t\t\t\t\t     getNumComponents());\n+    int numColors = getNumColorComponents();\n+    \n+    if (hasAlpha())\n+      {\n+\tfloat alpha = ((rgb >> 24)&0xff)/255.0F;\n+\t\n+\t/* If color model has alpha and should be premultiplied, multiply\n+\t   color space components with alpha value. */\n+\tif (isAlphaPremultiplied()) {\n+\t  for (int i=0; i<numColors; i++)\n+\t    data[i] *= alpha;\n+\t}\n+\t// Scale the alpha sample to the correct number of bits.\n+\talpha *= (1<<(bits[numColors]-1));\n+\t// Arrange the alpha sample in the output array.\n+\tbuffer.setElemFloat(numColors, alpha);\n+      }\n+    for (int i=0; i<numColors; i++)\n+      {\n+\t// Scale the color samples to the correct number of bits.\n+\tfloat value = data[i]*(1<<(bits[i]-1));\n+\t// Arrange the color samples in the output array.\n+\tbuffer.setElemFloat(i, value);\n+      }\n+    return Buffers.getData(buffer);\n+  }\n+\n+  public int[] getComponents(int pixel, int[] components, int offset)\n+  {\n+    if (getNumComponents()>1) throw new IllegalArgumentException();\n+    if (components == null)\n+    components = new int[getNumComponents() + offset];\n+    components[offset] = pixel;\n+    return components;\n+  }\n+\n+  public int[] getComponents(Object pixel, int[] components, int offset)\n+  {\n+    DataBuffer buffer = Buffers.createBuffer(transferType, pixel,\n+\t\t\t\t\t     getNumComponents());\n+    int numComponents = getNumComponents();\n+\n+    if (components == null)\n+      components = new int[numComponents + offset];\n+\n+    for (int i=0; i<numComponents; i++)\n+      components[offset++] = buffer.getElem(i);\n+\n+    return components;\n+  }\n+\n+  public int getDataElement(int[] components, int offset)\n+  {\n+    if (getNumComponents()>1) throw new IllegalArgumentException();\n+    return components[offset];\n+  }\n+\n+  public Object getDataElements(int[] components, int offset, Object obj)\n+  {\n+    DataBuffer buffer = Buffers.createBuffer(transferType, obj,\n+\t\t\t\t\t     getNumComponents());\n+    int numComponents = getNumComponents();\n+\n+    for (int i=0; i<numComponents; i++)\n+      buffer.setElem(i, components[offset++]);\n+\n+    return Buffers.getData(buffer);\n+  }\n+\n+  public ColorModel coerceData(WritableRaster raster,\n+\t\t\t       boolean isAlphaPremultiplied) {\n+    if (this.isAlphaPremultiplied == isAlphaPremultiplied)\n+      return this;\n+\n+    /* TODO: provide better implementation based on the\n+       assumptions we can make due to the specific type of the\n+       color model. */\n+    super.coerceData(raster, isAlphaPremultiplied);\n+    \n+    return new ComponentColorModel(cspace, bits, hasAlpha(),\n+\t\t\t\t   isAlphaPremultiplied, // argument\n+\t\t\t\t   transparency, transferType);\n+  }\n+\n+  public boolean isCompatibleRaster(Raster raster)\n+  {\n+    return super.isCompatibleRaster(raster);\n+    // FIXME: Should we test something more here? (Why override?)\n+  }\n+\n+  public WritableRaster createCompatibleWritableRaster(int w, int h)\n+  {\n+    SampleModel sm = createCompatibleSampleModel(w, h);\n+    Point origin = new Point(0, 0);\n+    return Raster.createWritableRaster(sm, origin);\n+  }\n+\n+  public SampleModel createCompatibleSampleModel(int w, int h)\n+  {\n+    int pixelStride = getNumComponents();\n+    \n+    /* TODO: Maybe we don't need to create a new offset array each\n+       time, but rather use the same array every time. */\n+    int[] bandOffsets = new int[pixelStride];\n+    for (int i=0; i<pixelStride; i++) bandOffsets[i] = i;\n+    return new ComponentSampleModel(transferType, w, h,\n+\t\t\t\t    pixelStride, pixelStride*w,\n+\t\t\t\t    bandOffsets);\n+  }\n+\n+  public boolean isCompatibleSampleModel(SampleModel sm)\n+  {\n+    return \n+      (sm instanceof ComponentSampleModel) &&\n+      super.isCompatibleSampleModel(sm);\n+  }\n+\n+  public WritableRaster getAlphaRaster(WritableRaster raster)\n+  {\n+    if (!hasAlpha()) return null;\n+    \n+    SampleModel sm = raster.getSampleModel();\n+    int[] alphaBand = { sm.getNumBands() - 1 };\n+    SampleModel alphaModel = sm.createSubsetSampleModel(alphaBand);\n+    DataBuffer buffer = raster.getDataBuffer();\n+    Point origin = new Point(0, 0);\n+    return Raster.createWritableRaster(alphaModel, buffer, origin);\n+  }\n+    \n+  public boolean equals(Object obj)\n+  {\n+    if (!(obj instanceof ComponentColorModel)) return false;\n+    return super.equals(obj);\n+  }\n+}"}, {"sha": "f825d4878d2108a33b59dabe8f1103f73b3de76a", "filename": "libjava/java/awt/image/ComponentSampleModel.java", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FComponentSampleModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FComponentSampleModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FComponentSampleModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,435 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import gnu.gcj.awt.Buffers;\n+\n+/* FIXME: This class does not yet support data type TYPE_SHORT */\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class ComponentSampleModel extends SampleModel\n+{\n+  protected int[] bandOffsets;\n+  protected int[] bankIndices;\n+  \n+  // FIXME: Should we really shadow the numBands in the superclass?\n+  //protected int numBands;\n+  \n+  /** Used when creating data buffers. */\n+  protected int numBanks;\n+\n+  protected int scanlineStride;\n+  \n+  protected int pixelStride;\n+  \n+  private boolean tightPixelPacking = false;\n+  \n+  public ComponentSampleModel(int dataType,\n+\t\t\t      int w, int h,\n+\t\t\t      int pixelStride,\n+\t\t\t      int scanlineStride,\n+\t\t\t      int[] bandOffsets)\n+  {\n+    this(dataType, w, h, pixelStride, scanlineStride,\n+\t new int[bandOffsets.length], bandOffsets);\n+  }\n+    \n+  public ComponentSampleModel(int dataType,\n+\t\t\t      int w, int h,\n+\t\t\t      int pixelStride,\n+\t\t\t      int scanlineStride,\n+\t\t\t      int[] bankIndices,\n+\t\t\t      int[] bandOffsets)\n+  {\n+    super(dataType, w, h, bandOffsets.length);\n+    if ((pixelStride<0) || (scanlineStride<0) || \n+\t(bandOffsets.length<1) ||\n+\t(bandOffsets.length != bankIndices.length))\n+      throw new IllegalArgumentException();\n+    \n+    this.bandOffsets = bandOffsets;\n+    this.bankIndices = bankIndices;\n+\n+    for (int b=0; b<bankIndices.length; b++)\n+      this.numBanks = Math.max(this.numBanks, bankIndices[b]+1);\n+\n+    this.scanlineStride = scanlineStride;\n+    this.pixelStride = pixelStride;\n+\n+    // See if we can use some speedups\n+\n+    /* FIXME: May these checks should be reserved for the\n+       PixelInterleavedSampleModel? */\n+\t\n+    if (pixelStride == numBands)\n+      {\n+\ttightPixelPacking = true;\n+\tfor (int b=0; b<numBands; b++) {\n+\t  if ((bandOffsets[b] != b) || (bankIndices[b] !=0))\n+\t    {\n+\t      tightPixelPacking = false;\n+\t      break;\n+\t    }\n+\t}\n+      }\n+  }\t\t\n+\n+  public SampleModel createCompatibleSampleModel(int w, int h)\n+  {\n+    return new ComponentSampleModel(dataType, w, h, pixelStride,\n+\t\t\t\t    scanlineStride, bankIndices,\n+\t\t\t\t    bandOffsets);\n+  }\n+\n+  public SampleModel createSubsetSampleModel(int[] bands)\n+  {\n+    int numBands = bands.length;\n+    \n+    int[] bankIndices = new int[numBands];\n+    int[] bandOffsets = new int[numBands];\n+    for (int b=0; b<numBands; b++)\n+      {\n+\tbankIndices[b] = this.bankIndices[bands[b]];\n+\tbandOffsets[b] = this.bandOffsets[bands[b]];\n+      }\n+\n+    return new ComponentSampleModel(dataType, width, height, pixelStride,\n+\t\t\t\t    scanlineStride, bankIndices,\n+\t\t\t\t    bandOffsets);\n+  }\n+\n+  public DataBuffer createDataBuffer()\n+  {\n+    // Maybe this value should be precalculated in the constructor?\n+    int highestOffset = 0;\n+    for (int b=0; b<numBands; b++)\n+      {\n+\thighestOffset = Math.max(highestOffset, bandOffsets[b]);\n+      }\n+    int size = pixelStride*(width-1) + scanlineStride*(height-1) +\n+      highestOffset + 1;\n+    \n+    return Buffers.createBuffer(getDataType(), size, numBanks);\n+  }\n+\n+  public int getOffset(int x, int y)\n+  {\n+    return getOffset(x, y, 0);\n+  }\n+\n+  public int getOffset(int x, int y, int b)\n+  {\n+    return bandOffsets[b] + pixelStride*x + scanlineStride*y;\n+  }\n+\n+  public final int[] getSampleSize()\n+  {\n+    int size = DataBuffer.getDataTypeSize(getDataType());\n+    int[] sizes = new int[numBands];\n+\n+    java.util.Arrays.fill(sizes, size);\n+    return sizes;\n+  }\n+\n+  public final int getSampleSize(int band)\n+  {\n+    return DataBuffer.getDataTypeSize(getDataType());\n+  }\n+\n+  public final int[] getBankIndices()\n+  {\n+    return bankIndices;\n+  }\n+\n+  public final int[] getBandOffsets()\n+  {\n+    return bandOffsets;\n+  }\n+\n+  public final int getScanlineStride()\n+  {\n+    return scanlineStride;\n+  }\n+\n+  public final int getPixelStride()\n+  {\n+    return pixelStride;\n+  }\n+\n+  public final int getNumDataElements()\n+  {\n+    return numBands;\n+  }\n+\n+  public Object getDataElements(int x, int y, Object obj, DataBuffer data)\n+  {\n+    int xyOffset = pixelStride*x + scanlineStride*y;\n+    \n+    int[] totalBandDataOffsets = new int[numBands];\n+    \n+    /* Notice that band and bank offsets are different. Band offsets\n+       are managed by the sample model, and bank offsets are managed\n+       by the data buffer. Both must be accounted for. */\n+    \n+    /* FIXME: For single pixels, it is probably easier to simple\n+       call getElem instead of calculating the bank offset ourself.\n+       \n+       On the other hand, then we need to push the value through\n+       the int type returned by the getElem method.  */\n+    \n+    int[] bankOffsets = data.getOffsets();\n+    \n+    for (int b=0; b<numBands; b++)\n+      {\n+\ttotalBandDataOffsets[b] = \n+\t  bandOffsets[b]+bankOffsets[bankIndices[b]] + xyOffset;\n+      }\n+\t\n+    try\n+      {\n+\tswitch (getTransferType())\n+\t  {\n+\t  case DataBuffer.TYPE_BYTE:\n+\t    DataBufferByte inByte = (DataBufferByte) data;\n+\t    byte[] outByte = (byte[]) obj;\n+\t    if (outByte == null) outByte = new byte[numBands];\n+\t\t\n+\t    for (int b=0; b<numBands; b++)\n+\t      {\n+\t\tint dOffset = totalBandDataOffsets[b];\n+\t\toutByte[b] = inByte.getData(bankIndices[b])[dOffset];\n+\t      }\n+\t    return outByte;\n+\t\t\n+\t  case DataBuffer.TYPE_USHORT:\n+\t    DataBufferUShort inUShort = (DataBufferUShort) data;\n+\t    short[] outUShort = (short[]) obj;\n+\t    if (outUShort == null) outUShort = new short[numBands];\n+\t\t\n+\t    for (int b=0; b<numBands; b++)\n+\t      {\n+\t\tint dOffset = totalBandDataOffsets[b];\n+\t\toutUShort[b] = inUShort.getData(bankIndices[b])[dOffset];\n+\t      }\n+\t    return outUShort;\n+\n+\t  case DataBuffer.TYPE_INT:\n+\t    DataBufferInt inInt = (DataBufferInt) data;\n+\t    int[] outInt = (int[]) obj;\n+\t    if (outInt == null) outInt = new int[numBands];\n+\t\t\n+\t    for (int b=0; b<numBands; b++)\n+\t      {\n+\t\tint dOffset = totalBandDataOffsets[b];\n+\t\toutInt[b] = inInt.getData(bankIndices[b])[dOffset];\n+\t      }\n+\t    return outInt;\n+\t\t\n+\t    // FIXME: Fill in the other possible types.\n+\t  default:\n+\t      throw new IllegalStateException(\"unknown transfer type \" +\n+\t\t\t\t\t      getTransferType());\n+\t  }\n+      }\n+    catch (ArrayIndexOutOfBoundsException aioobe)\n+      {\n+\tString msg = \"While reading data elements, \" +\n+\t  \"x=\" + x + \", y=\" + y +\", \" + \", xyOffset=\" + xyOffset +\n+\t  \", data.getSize()=\" + data.getSize() + \": \" + aioobe;\n+\tthrow new ArrayIndexOutOfBoundsException(msg);\n+      }\n+  }\n+\n+  public Object getDataElements(int x, int y, int w, int h, Object obj,\n+\t\t\t\tDataBuffer data)\n+  {\n+    if (!tightPixelPacking)\n+      {\n+\treturn super.getDataElements(x, y, w, h, obj, data);\n+      }\n+\n+    // using get speedup\n+    \n+    // We can copy whole rows\n+    int rowSize = w*numBands;\n+    int dataSize = rowSize*h;\n+    \n+    DataBuffer transferBuffer =\n+      Buffers.createBuffer(getTransferType(), obj, dataSize);\n+    obj = Buffers.getData(transferBuffer);\n+\n+    int inOffset =\n+      pixelStride*x +\n+      scanlineStride*y +\n+      data.getOffset(); // Assumes only one band is used\n+\n+    /* We don't add band offsets since we assume that bands have\n+       offsets 0, 1, 2, ... */\n+\n+    // See if we can copy everything in one go\n+    if (scanlineStride == rowSize)\n+      {\n+\t// Collapse scan lines:\n+\trowSize *= h;\n+\t// We ignore scanlineStride since it won't be of any use\n+\th = 1;\n+      }\n+\n+    int outOffset = 0;\n+    Object inArray = Buffers.getData(data);\n+    for (int yd = 0; yd<h; yd++)\n+      {\n+\tSystem.arraycopy(inArray, inOffset, obj, outOffset, rowSize);\n+\tinOffset  += scanlineStride;\n+\toutOffset += rowSize;\n+      }\n+    return obj;\n+  }\n+\n+  public void setDataElements(int x, int y, int w, int h,\n+\t\t\t      Object obj, DataBuffer data)\n+  {\n+    if (!tightPixelPacking)\n+      {\n+\tsuper.setDataElements(x, y, w, h, obj, data);\n+\treturn;\n+      }\n+\n+    // using set speedup, we can copy whole rows\n+    int rowSize = w*numBands;\n+    int dataSize = rowSize*h;\n+    \n+    DataBuffer transferBuffer =\n+      Buffers.createBufferFromData(getTransferType(), obj, dataSize);\n+\n+    int[] bankOffsets = data.getOffsets();\n+\n+    int outOffset =\n+      pixelStride*x +\n+      scanlineStride*y +\n+      bankOffsets[0]; // same assuptions as in get...\n+\n+    // See if we can copy everything in one go\n+    if (scanlineStride == rowSize)\n+      {\n+\t// Collapse scan lines:\n+\tscanlineStride = rowSize *= h;\n+\th = 1;\n+      }\n+\n+    int inOffset = 0;\n+    Object outArray = Buffers.getData(data);\n+    for (int yd = 0; yd<h; yd++)\n+      {\n+\tSystem.arraycopy(obj, inOffset, outArray, outOffset, rowSize);\n+\toutOffset += scanlineStride;\n+\tinOffset  += rowSize;\n+      }\n+  }\n+\n+  public int[] getPixel(int x, int y, int[] iArray, DataBuffer data)\n+  {\n+    int offset = pixelStride*x + scanlineStride*y;\n+    if (iArray == null) iArray = new int[numBands];\n+    for (int b=0; b<numBands; b++)\n+      {\n+\tiArray[b] = data.getElem(bankIndices[b], offset+bandOffsets[b]);\n+      }\n+    return iArray;\n+  }\n+\n+  public int[] getPixels(int x, int y, int w, int h, int[] iArray,\n+\t\t\t DataBuffer data)\n+  {\n+    int offset = pixelStride*x + scanlineStride*y;\n+    if (iArray == null) iArray = new int[numBands*w*h];\n+    int outOffset = 0;\n+    for (y=0; y<h; y++)\n+      {\n+\tint lineOffset = offset;\n+\tfor (x=0; x<w; x++)\n+\t  {\n+\t    for (int b=0; b<numBands; b++)\n+\t      {\n+\t\tiArray[outOffset++] = \n+\t\t  data.getElem(bankIndices[b], lineOffset+bandOffsets[b]);\n+\t      }\n+\t    lineOffset += pixelStride;\n+\t  }\n+\toffset += scanlineStride;\n+      }\n+    return iArray;\n+  }\n+    \n+  public int getSample(int x, int y, int b, DataBuffer data)\n+  {\n+    return data.getElem(bankIndices[b], getOffset(x, y, b));\n+  }\n+\n+  public void setDataElements(int x, int y, Object obj, DataBuffer data)\n+  {\n+    int offset = pixelStride*x + scanlineStride*y;\n+    int[] totalBandDataOffsets = new int[numBands];\n+    int[] bankOffsets = data.getOffsets();\n+    for (int b=0; b<numBands; b++)\n+      totalBandDataOffsets[b] =\n+\tbandOffsets[b]+bankOffsets[bankIndices[b]] + offset;\n+\n+    switch (getTransferType())\n+      {\n+      case DataBuffer.TYPE_BYTE:\n+\t{\n+\t  DataBufferByte out = (DataBufferByte) data;\n+\t  byte[] in = (byte[]) obj;\n+\t  \n+\t  for (int b=0; b<numBands; b++)\n+\t    out.getData(bankIndices[b])[totalBandDataOffsets[b]] = in[b];\n+\t  \n+\t  return;\n+\t}\n+      case DataBuffer.TYPE_USHORT:\n+\t{\n+\t  DataBufferUShort out = (DataBufferUShort) data;\n+\t  short[] in = (short[]) obj;\n+\t  \n+\t  for (int b=0; b<numBands; b++)\n+\t    out.getData(bankIndices[b])[totalBandDataOffsets[b]] = in[b];\n+\t  \n+\t  return;\n+\t}\n+      case DataBuffer.TYPE_INT:\n+\t{\n+\t  DataBufferInt out = (DataBufferInt) data;\n+\t  int[] in = (int[]) obj;\n+\t  \n+\t  for (int b=0; b<numBands; b++)\n+\t    out.getData(bankIndices[b])[totalBandDataOffsets[b]] = in[b];\n+\t  \n+\t  return;\n+\t}\n+      default:\n+\tthrow new UnsupportedOperationException(\"transfer type not \" +\n+\t\t\t\t\t\t\"implemented\");\n+      }\n+  }\n+  \n+  public void setPixel(int x, int y, int[] iArray, DataBuffer data)\n+  {\n+    int offset = pixelStride*x + scanlineStride*y;\n+    for (int b=0; b<numBands; b++)\n+      data.setElem(bankIndices[b], offset+bandOffsets[b], iArray[b]);\n+  }\n+    \n+  public void setSample(int x, int y, int b, int s, DataBuffer data)\n+  {\n+    data.setElem(bankIndices[b], getOffset(x, y, b), s);\n+  }\n+}"}, {"sha": "b40dac122febc8b3a64397d4b25c7c0fb58467a0", "filename": "libjava/java/awt/image/DataBuffer.java", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FDataBuffer.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,177 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+/** \n+ * Class that manages arrays of data elements. A data buffer consists\n+ * of one or more banks.  A bank is a continuous region of data\n+ * elements.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public abstract class DataBuffer\n+{\n+  public static final int TYPE_BYTE      =  0;\n+  public static final int TYPE_USHORT    =  1;\n+  public static final int TYPE_SHORT     =  2;\n+  public static final int TYPE_INT       =  3;\n+  public static final int TYPE_FLOAT     =  4;\n+  public static final int TYPE_DOUBLE    =  5;\n+  public static final int TYPE_UNDEFINED = 32;\n+  \n+  /** The type of the data elements stored in the data buffer.  */\n+  protected int dataType;\n+  \n+  /** The number of banks in this buffer.  */\n+  protected int banks = 1;\n+  \n+  /** Offset into the default (0'th) bank). */\n+  protected int offset; // FIXME: Is offsets[0] always mirrored in offset?\n+  \n+  /** The size of the banks.  */\n+  protected int size;\n+  \n+  /** Offset into each bank.  */\n+  protected int[] offsets;\n+  \n+  protected DataBuffer(int dataType, int size)\n+  {\n+    this.dataType = dataType;\n+    this.size = size;\n+  }\n+\n+  protected DataBuffer(int dataType, int size, int numBanks) {\n+    this(dataType, size);\n+    banks = numBanks;\n+    offsets = new int[numBanks];\n+  }\n+\n+  protected DataBuffer(int dataType, int size, int numBanks, int offset) {\n+    this(dataType, size, numBanks);\n+    \n+    java.util.Arrays.fill(offsets, offset);          \n+    \n+    this.offset = offset;\n+  }\n+\n+  protected DataBuffer(int dataType, int size, int numBanks, int[] offsets) {\n+    this(dataType, size);\n+    if (numBanks != offsets.length) \n+      throw new ArrayIndexOutOfBoundsException();\n+    \n+    banks = numBanks;\n+    this.offsets = offsets;\n+    \n+    offset = offsets[0];\n+  }\n+  \n+  public static int getDataTypeSize(int dataType) {\n+    // Maybe this should be a lookup table instead.\n+    switch (dataType)\n+      {\n+      case TYPE_BYTE:\n+\treturn 8;\n+      case TYPE_USHORT:\n+      case TYPE_SHORT:\n+\treturn 16;\n+      case TYPE_INT:\n+      case TYPE_FLOAT:\n+\treturn 32;\n+      case TYPE_DOUBLE:\n+\treturn 64;\n+      default:\n+\tthrow new IllegalArgumentException();\n+      }\n+  }\n+\n+  public int getDataType()\n+  {\n+    return dataType;\n+  }\n+  \n+  public int getSize()\n+  {\n+    return size;\n+  }\n+  \n+  public int getOffset()\n+  {\n+    return offset;\n+  }\n+  \n+  public int[] getOffsets()\n+  {\n+    if (offsets == null)\n+    {\n+      // is this necessary?\n+      offsets = new int[1];\n+      offsets[0] = offset;\n+    }\n+    return offsets;\n+  }\n+\n+  public int getNumBanks()\n+  {\n+    return banks;\n+  }\n+\n+  public int getElem(int i)\n+  {\n+    return getElem(0, i);\n+  }\n+\n+  public abstract int getElem(int bank, int i);\n+  \n+  public void setElem(int i, int val)\n+  {\n+    setElem(0, i, val);\n+  }\n+\n+  public abstract void setElem(int bank, int i, int val);\n+  \n+  public float getElemFloat(int i)\n+  {\n+    return getElem(i);\n+  }\n+    \n+  public float getElemFloat(int bank, int i)\n+  {\n+    return getElem(bank, i);\n+  }\n+\n+  public void setElemFloat(int i, float val)\n+  {\n+    setElem(i, (int) val);\n+  }\n+\n+  public void setElemFloat(int bank, int i, float val)\n+  {\n+    setElem(bank, i, (int) val);\n+  }\n+\n+  public double getElemDouble(int i)\n+  {\n+    return getElem(i);\n+  }\n+    \n+  public double getElemDouble(int bank, int i)\n+  {\n+    return getElem(bank, i);\n+  }\n+\n+  public void setElemDouble(int i, double val)\n+  {\n+    setElem(i, (int) val);\n+  }\n+\n+  public void setElemDouble(int bank, int i, double val)\n+  {\n+    setElem(bank, i, (int) val);\n+  }\n+}"}, {"sha": "67b4f5fc2af08ba97e47d3fb70ac4109a182ff0f", "filename": "libjava/java/awt/image/DataBufferByte.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferByte.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferByte.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferByte.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,103 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+/* This is one of several classes that are nearly identical. Maybe we\n+   should have a central template and generate all these files. This\n+   is one of the cases where templates or macros would have been\n+   useful to have in Java.\n+\n+   This file has been created using search-replace. My only fear is\n+   that these classes will grow out-of-sync as of a result of changes\n+   that are not propagated to the other files. As always, mirroring\n+   code is a maintenance nightmare.  */\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class DataBufferByte extends DataBuffer\n+{\n+  private byte[] data;\n+  private byte[][] bankData;\n+  \n+  public DataBufferByte(int size)\n+  {\n+    super(TYPE_BYTE, size);\n+    data = new byte[size];\n+  }\n+\n+  public DataBufferByte(int size, int numBanks)\n+  {\n+    super(TYPE_BYTE, size, numBanks);\n+    bankData = new byte[numBanks][size];\n+    data = bankData[0];\n+  }\n+\n+  public DataBufferByte(byte[] dataArray, int size)\n+  {\n+    super(TYPE_BYTE, size);\n+    data = dataArray;\n+  }\n+    \n+  public DataBufferByte(byte[] dataArray, int size, int offset)\n+  {\n+    super(TYPE_BYTE, size, 1, offset);\n+    data = dataArray;\n+  }\n+\n+  public DataBufferByte(byte[][] dataArray, int size)\n+  {\n+    super(TYPE_BYTE, size, dataArray.length);\n+    bankData = dataArray;\n+    data = bankData[0];\n+  }\n+\n+  public DataBufferByte(byte[][] dataArray, int size, int[] offsets)\n+  {\n+    super(TYPE_BYTE, size, dataArray.length, offsets);\n+    bankData = dataArray;\n+    data = bankData[0];\n+  }\n+\n+  public byte[] getData()\n+  {\n+    return data;\n+  }\n+    \n+  public byte[] getData(int bank) \n+  {\n+    return bankData[bank];\n+  }\n+    \n+  public byte[][] getBankData()\n+  {\n+    return bankData;\n+  }\n+  \n+  public int getElem(int i)\n+  {\n+    return data[i+offset] & 0xff; // get unsigned byte as int\n+  }\n+  \n+  public int getElem(int bank, int i)\n+  {\n+    // get unsigned byte as int\n+    return bankData[bank][i+offsets[bank]] & 0xff;\n+  }\n+\n+  public void setElem(int i, int val)\n+  {\n+    data[i+offset] = (byte) val;\n+  }\n+\n+  public void setElem(int bank, int i, int val)\n+  {\n+    bankData[bank][i+offsets[bank]] = (byte) val;\n+  }\n+}"}, {"sha": "560fb9cf0f0901283f2c7e3e39ee5edf145de6be", "filename": "libjava/java/awt/image/DataBufferInt.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferInt.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferInt.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferInt.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,103 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+/* This is one of several classes that are nearly identical. Maybe we\n+   should have a central template and generate all these files. This\n+   is one of the cases where templates or macros would have been\n+   useful to have in Java.\n+\n+   This file has been created using search-replace. My only fear is\n+   that these classes will grow out-of-sync as of a result of changes\n+   that are not propagated to the other files. As always, mirroring\n+   code is a maintenance nightmare.  */\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class DataBufferInt extends DataBuffer\n+{\n+  private int[] data;\n+  private int[][] bankData;\n+  \n+  public DataBufferInt(int size)\n+  {\n+    super(TYPE_INT, size);\n+    data = new int[size];\n+  }\n+\n+  public DataBufferInt(int size, int numBanks)\n+  {\n+    super(TYPE_INT, size, numBanks);\n+    bankData = new int[numBanks][size];\n+    data = bankData[0];\n+  }\n+  \n+  public DataBufferInt(int[] dataArray, int size)\n+  {\n+    super(TYPE_INT, size);\n+    data = dataArray;\n+  }\n+    \n+  public DataBufferInt(int[] dataArray, int size, int offset)\n+  {\n+    super(TYPE_INT, size, 1, offset);\n+    data = dataArray;\n+  }\n+  \n+  public DataBufferInt(int[][] dataArray, int size)\n+  {\n+    super(TYPE_INT, size, dataArray.length);\n+    bankData = dataArray;\n+    data = bankData[0];\n+  }\n+  \n+  public DataBufferInt(int[][] dataArray, int size, int[] offsets)\n+  {\n+    super(TYPE_INT, size, dataArray.length, offsets);\n+    bankData = dataArray;\n+    data = bankData[0];\n+  }\n+\n+  public int[] getData()\n+  {\n+    return data;\n+  }\n+    \n+  public int[] getData(int bank)\n+  {\n+    return bankData[bank];\n+  }\n+  \n+  public int[][] getBankData()\n+  {\n+    return bankData;\n+  }\n+  \n+  public int getElem(int i)\n+  {\n+    return data[i+offset];\n+  }\n+\n+  public int getElem(int bank, int i)\n+  {\n+    // get unsigned int as int\n+    return bankData[bank][i+offsets[bank]];\n+  }\n+\n+  public void setElem(int i, int val)\n+  {\n+    data[i+offset] = (int) val;\n+  }\n+  \n+  public void setElem(int bank, int i, int val)\n+  {\n+    bankData[bank][i+offsets[bank]] = (int) val;\n+  }\n+}"}, {"sha": "7963c383019100af51734b662be3bdb42c39d8ea", "filename": "libjava/java/awt/image/DataBufferUShort.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferUShort.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferUShort.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FDataBufferUShort.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,103 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+/* This is one of several classes that are nearly identical. Maybe we\n+   should have a central template and generate all these files. This\n+   is one of the cases where templates or macros would have been\n+   useful to have in Java.\n+\n+   This file has been created using search-replace. My only fear is\n+   that these classes will grow out-of-sync as of a result of changes\n+   that are not propagated to the other files. As always, mirroring\n+   code is a maintenance nightmare.  */\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class DataBufferUShort extends DataBuffer\n+{\n+  private short[] data;\n+  private short[][] bankData;\n+  \n+  public DataBufferUShort(int size)\n+  {\n+    super(TYPE_USHORT, size);\n+    data = new short[size];\n+  }\n+\n+  public DataBufferUShort(int size, int numBanks)\n+  {\n+    super(TYPE_USHORT, size, numBanks);\n+    bankData = new short[numBanks][size];\n+    data = bankData[0];\n+  }\n+\n+  public DataBufferUShort(short[] dataArray, int size)\n+  {\n+    super(TYPE_USHORT, size);\n+    data = dataArray;\n+  }\n+    \n+  public DataBufferUShort(short[] dataArray, int size, int offset)\n+  {\n+    super(TYPE_USHORT, size, 1, offset);\n+    data = dataArray;\n+  }\n+\n+  public DataBufferUShort(short[][] dataArray, int size)\n+  {\n+    super(TYPE_USHORT, size, dataArray.length);\n+    bankData = dataArray;\n+    data = bankData[0];\n+  }\n+\n+  public DataBufferUShort(short[][] dataArray, int size, int[] offsets)\n+  {\n+    super(TYPE_USHORT, size, dataArray.length, offsets);\n+    bankData = dataArray;\n+    data = bankData[0];\n+  }\n+\n+  public short[] getData()\n+  {\n+    return data;\n+  }\n+    \n+  public short[] getData(int bank)\n+  {\n+    return bankData[bank];\n+  }\n+    \n+  public short[][] getBankData()\n+  {\n+    return bankData;\n+  }\n+  \n+  public int getElem(int i)\n+  {\n+    return data[i+offset] & 0xffff; // get unsigned short as int\n+  }\n+\n+  public int getElem(int bank, int i)\n+  {\n+    // get unsigned short as int\n+    return bankData[bank][i+offsets[bank]] & 0xffff;\n+  }\n+\n+  public void setElem(int i, int val)\n+  {\n+    data[i+offset] = (short) val;\n+  }\n+\n+  public void setElem(int bank, int i, int val)\n+  {\n+    bankData[bank][i+offsets[bank]] = (short) val;\n+  }\n+}"}, {"sha": "8e092d1a324d7d8738b8836d415f58d319a00164", "filename": "libjava/java/awt/image/DirectColorModel.java", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDirectColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FDirectColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FDirectColorModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,338 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.Point;\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import gnu.gcj.awt.Buffers;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class DirectColorModel extends PackedColorModel\n+{\n+  public DirectColorModel(int pixelBits, int rmask, int gmask, int bmask)\n+  {\n+    this(ColorSpace.getInstance(ColorSpace.CS_sRGB), pixelBits,\n+\t rmask, gmask, bmask, 0, \n+\t false, // not alpha premultiplied\n+\t Buffers.smallestAppropriateTransferType(pixelBits) // find type\n+\t );\n+  }\n+\n+  public DirectColorModel(int pixelBits,\n+\t\t\t  int rmask, int gmask, int bmask, int amask)\n+  {\n+    this(ColorSpace.getInstance(ColorSpace.CS_sRGB), pixelBits,\n+\t rmask, gmask, bmask, amask,\n+\t false, // not alpha premultiplied\n+\t Buffers.smallestAppropriateTransferType(pixelBits) // find type\n+\t );\n+  }\n+\n+  public DirectColorModel(ColorSpace cspace, int pixelBits,\n+\t\t\t  int rmask, int gmask, int bmask, int amask,\n+\t\t\t  boolean isAlphaPremultiplied,\n+\t\t\t  int transferType)\n+  {\n+    super(cspace, pixelBits,\n+\t  rmask, gmask, bmask, amask, isAlphaPremultiplied,\n+\t  ((amask == 0) ? Transparency.OPAQUE : Transparency.TRANSLUCENT),\n+\t  transferType);\n+  }\n+    \n+  public final int getRedMask()\n+  {\n+    return getMask(0);\n+  }\n+\n+  public final int getGreenMask()\n+  {\n+    return getMask(1);\n+  }\n+\n+  public final int getBlueMask()\n+  {\n+    return getMask(2);\n+  }\n+\n+  public final int getAlphaMask()\n+  {\n+    return hasAlpha() ? getMask(3) : 0;\n+  }\n+\n+  public final int getRed(int pixel)\n+  {\n+    return extractAndNormalizeSample(pixel, 0);\n+  }\n+\n+  public final int getGreen(int pixel)\n+  {\n+    return extractAndNormalizeSample(pixel, 1);\n+  }\n+  \n+  public final int getBlue(int pixel)\n+  {\n+    return extractAndNormalizeSample(pixel, 2);\n+  }\n+\n+  public final int getAlpha(int pixel)\n+  {\n+    if (!hasAlpha()) return 0;\n+    return extractAndScaleSample(pixel, 3);\n+  }\n+\n+  private final int extractAndNormalizeSample(int pixel, int component)\n+  {\n+    int value = extractAndScaleSample(pixel, component);\n+    if (hasAlpha() && isAlphaPremultiplied())\n+      value = value*255/getAlpha(pixel);\n+    return value;\n+  }\n+\n+  private final int extractAndScaleSample(int pixel, int component)\n+  {\n+    int field = pixel & getMask(component);\n+    int to8BitShift =\n+      8 - shifts[component] - getComponentSize(component);\n+    return (to8BitShift>0) ?\n+      (field << to8BitShift) :\n+      (field >>> (-to8BitShift));\n+  }\n+    \n+\n+  /* FIXME: The Sun docs show that this method is overridden, but I don't\n+     see any way to improve on the superclass implementation. */\n+  public final int getRGB(int pixel) \n+  {\n+    return super.getRGB(pixel);\n+  }\n+  \n+  public int getRed(Object inData)\n+  {\n+    return getRed(getPixelFromArray(inData));\n+  }\n+\n+  public int getGreen(Object inData)\n+  {\n+    return getGreen(getPixelFromArray(inData));\n+  }\n+\n+  public int getBlue(Object inData)\n+  {\n+    return getBlue(getPixelFromArray(inData));\n+  }\n+    \n+  public int getAlpha(Object inData)\n+  {\n+    return getAlpha(getPixelFromArray(inData));\n+  }\n+\n+  public int getRGB(Object inData)\n+  {\n+    return getRGB(getPixelFromArray(inData));\n+  }\n+    \n+  /**\n+   * Converts a normalized pixel int value in the sRGB color\n+   * space to an array containing a single pixel of the color space\n+   * of the color model.\n+   *\n+   * <p>This method performs the inverse function of\n+   * <code>getRGB(Object inData)</code>.\n+   *\n+   * @param rgb pixel as a normalized sRGB, 0xAARRGGBB value.\n+   *  \n+   * @param pixel to avoid needless creation of arrays, an array to\n+   * use to return the pixel can be given. If null, a suitable array\n+   * will be created.\n+   *\n+   * @return array of transferType containing a single pixel. The\n+   * pixel should be encoded in the natural way of the color model.\n+   *\n+   * @see #getRGB(Object)\n+   */\n+  public Object getDataElements(int rgb, Object pixel)\n+  {\n+    // FIXME: handle alpha multiply\n+    \n+    int pixelValue = 0;\n+    int a = 0;\n+    if (hasAlpha()) {\n+      a = (rgb >>> 24) & 0xff;\n+      pixelValue = valueToField(a, 3, 8);\n+    }\n+\t\n+    if (hasAlpha() && isAlphaPremultiplied())\n+      {\n+\tint r, g, b;\n+\t/* if r=0xff and a=0xff, then resulting\n+\t   value will be (r*a)>>>8 == 0xfe... This seems wrong.\n+\t   We should divide by 255 rather than shifting >>>8 after\n+\t   multiplying.\n+\t   \n+\t   Too bad, shifting is probably less expensive.\n+\t   r = ((rgb >>> 16) & 0xff)*a;\n+\t   g = ((rgb >>>  8) & 0xff)*a;\n+\t   b = ((rgb >>> 0) & 0xff)*a; */\n+\t/* The r, g, b values we calculate are 16 bit. This allows\n+\t   us to avoid discarding the lower 8 bits obtained if\n+\t   multiplying with the alpha band. */\n+\t\n+\t// using 16 bit values\n+\tr = ((rgb >>> 8) & 0xff00)*a/255;\n+\tg = ((rgb >>> 0) & 0xff00)*a/255;\n+\tb = ((rgb <<  8) & 0xff00)*a/255;\n+\tpixelValue |= \n+\t  valueToField(r, 0, 16) |  // Red\n+\t  valueToField(g, 1, 16) |  // Green\n+\t  valueToField(b, 2, 16);   // Blue\n+      }\n+    else\n+      {\n+\tint r, g, b;\n+\t// using 8 bit values\n+\tr = (rgb >>> 16) & 0xff;\n+\tg = (rgb >>>  8) & 0xff;\n+\tb = (rgb >>>  0) & 0xff;\n+\t\n+\tpixelValue |= \n+\t  valueToField(r, 0, 8) |  // Red\n+\t  valueToField(g, 1, 8) |  // Green\n+\t  valueToField(b, 2, 8);   // Blue\n+      }\n+    \n+    /* In this color model, the whole pixel fits in the first element\n+       of the array. */\n+    DataBuffer buffer = Buffers.createBuffer(transferType, pixel, 1);\n+    buffer.setElem(0, pixelValue);\n+    return Buffers.getData(buffer);\n+  }\n+    \n+  /**\n+   * Converts a value to the correct field bits based on the\n+   * information derived from the field masks.\n+   *\n+   * @param highBit the position of the most significant bit in the\n+   * val parameter.\n+   */\n+  private final int valueToField(int val, int component, int highBit)\n+  {\n+    int toFieldShift = \n+      getComponentSize(component) + shifts[component] - highBit;\n+    int ret = (toFieldShift>0) ?\n+      (val << toFieldShift) :\n+      (val >>> (-toFieldShift));\n+    return ret & getMask(component);\n+  }  \n+\n+  /**\n+   * Converts a 16 bit value to the correct field bits based on the\n+   * information derived from the field masks.\n+   */\n+  private final int value16ToField(int val, int component)\n+  {\n+    int toFieldShift = getComponentSize(component) + shifts[component] - 16;\n+    return (toFieldShift>0) ?\n+      (val << toFieldShift) :\n+      (val >>> (-toFieldShift));\n+  }\n+\n+  /**\n+   * Fills an array with the unnormalized component samples from a\n+   * pixel value. I.e. decompose the pixel, but not perform any\n+   * color conversion.\n+   */\n+  public final int[] getComponents(int pixel, int[] components, int offset)\n+  {\n+    int numComponents = getNumComponents();\n+    if (components == null) components = new int[offset + numComponents];\n+    \n+    for (int b=0; b<numComponents; b++)\n+      components[offset++] = (pixel&getMask(b)) >>> shifts[b];\n+\t\n+    return components;\n+  }\n+\n+  public final int[] getComponents(Object pixel, int[] components,\n+\t\t\t\t   int offset)\n+  {\n+    return getComponents(getPixelFromArray(pixel), components, offset);\n+  }\n+  \n+  public final WritableRaster createCompatibleWritableRaster(int w, int h)\n+  {\n+    SampleModel sm = createCompatibleSampleModel(w, h);\n+    Point origin = new Point(0, 0);\n+    return Raster.createWritableRaster(sm, origin);\t\n+  }\n+\n+  public int getDataElement(int[] components, int offset)\n+  {\n+    int numComponents = getNumComponents();\n+    int pixelValue = 0;\n+    \n+    for (int c=0; c<numComponents; c++)\n+      pixelValue |= (components[offset++] << shifts[c]) & getMask(c);\n+\n+    return pixelValue;\n+  }  \n+\n+  public Object getDataElements(int[] components, int offset, Object obj)\n+  {\n+    /* In this color model, the whole pixel fits in the first element\n+       of the array. */\n+    int pixelValue = getDataElement(components, offset);\n+\n+    DataBuffer buffer = Buffers.createBuffer(transferType, obj, 1);\n+    buffer.setElem(0, pixelValue);\n+    return Buffers.getData(buffer);\n+  }\n+    \n+  public ColorModel coerceData(WritableRaster raster,\n+\t\t\t       boolean isAlphaPremultiplied)\n+  {\n+    if (this.isAlphaPremultiplied == isAlphaPremultiplied)\n+      return this;\n+\t\n+    /* TODO: provide better implementation based on the\n+       assumptions we can make due to the specific type of the\n+       color model. */\n+    super.coerceData(raster, isAlphaPremultiplied);\n+\t\n+    return new ComponentColorModel(cspace, bits, hasAlpha(),\n+\t\t\t\t   isAlphaPremultiplied, // argument\n+\t\t\t\t   transparency, transferType);\n+  } \n+\n+  public boolean isCompatibleRaster(Raster raster)\n+  {\n+    /* FIXME: the Sun docs say this method is overridden here, \n+       but I don't see any way to improve upon the implementation\n+       in ColorModel. */\n+    return super.isCompatibleRaster(raster);\n+  }\n+\n+  String stringParam()\n+  {\n+    return super.stringParam() +\n+      \", redMask=\" + Integer.toHexString(getRedMask()) +\n+      \", greenMask=\" + Integer.toHexString(getGreenMask()) +\n+      \", blueMask=\" + Integer.toHexString(getBlueMask()) +\n+      \", alphaMask=\" + Integer.toHexString(getAlphaMask());\n+  }\n+\n+  public String toString()\n+  {\n+    /* FIXME: Again, docs say override, but how do we improve upon the\n+       superclass implementation? */\n+    return super.toString();\n+  }\n+}"}, {"sha": "26519cbe467bee9d13fa0d14301c80655ea6112f", "filename": "libjava/java/awt/image/ImageConsumer.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FImageConsumer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FImageConsumer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FImageConsumer.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -8,7 +8,6 @@\n \n package java.awt.image;\n import java.util.Hashtable;\n-import java.awt.ColorModel;\n \n public interface ImageConsumer\n {"}, {"sha": "e35fcd684b91cd3d8873784debcc28713cc739d7", "filename": "libjava/java/awt/image/IndexColorModel.java", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,355 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import gnu.gcj.awt.Buffers;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class IndexColorModel extends ColorModel\n+{\n+  private byte[] r;\n+  private byte[] g;\n+  private byte[] b;\n+  private byte[] a;\n+  private int[] argb;\n+  private byte[] cmap;\n+  private int start;\n+  private int transparent;\n+  private int size;\n+  \n+  public IndexColorModel(int bits, int size, byte[] r, byte[] g, byte[] b)\n+  {\n+    super(bits, nArray(bits, 3),\n+\t  ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+\t  false,  // no transparency\n+\t  false,  // no premultiplied\n+\t  Transparency.OPAQUE,\n+\t  Buffers.smallestAppropriateTransferType(bits));\n+    this.r = r;\n+    this.g = g;\n+    this.b = b;\n+    this.size = size;\n+  }\n+\n+  public IndexColorModel(int bits, int size, byte[] r, byte[] g, byte[] b,\n+\t\t\t int transparent)\n+  {\n+    super(bits, nArray(bits, 4), \n+\t  ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+\t  true,  // has transparency\n+\t  false,\n+\t  Transparency.BITMASK,\n+\t  Buffers.smallestAppropriateTransferType(bits));\n+    this.r = r;\n+    this.g = g;\n+    this.b = b;\n+    this.transparent = transparent;\n+    this.size = size;\n+  }\n+\n+  public IndexColorModel(int bits, int size, byte[] r, byte[] g, byte[] b,\n+\t\t\t byte[] a)\n+  {\n+    super(bits, nArray(bits, 4),\n+\t  ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+\t  true,  // has transparency\n+\t  false,\n+\t  Transparency.BITMASK,\n+\t  Buffers.smallestAppropriateTransferType(bits));\n+    this.r = r;\n+    this.g = g;\n+    this.b = b;\n+    this.a = a;\n+    this.size = size;\n+  }\n+\n+  public IndexColorModel(int bits, int size, byte[] cmap, int start,\n+\t\t\t boolean hasAlpha)\n+  {\n+    super(bits, nArray(bits, hasAlpha ? 4 : 3),\n+\t  ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+\t  hasAlpha,\n+\t  false,\n+\t  hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE,\n+\t  Buffers.smallestAppropriateTransferType(bits));\n+    this.cmap = cmap;\n+    this.start = start;\n+    this.size = size;\n+  }\n+\n+  public IndexColorModel(int bits, int size, byte[] cmap, int start,\n+\t\t\t boolean hasAlpha, int transparent,\n+\t\t\t int transferType)\n+  {\n+    super(bits, nArray(bits, hasAlpha ? 4 : 3),\n+\t  ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+\t  hasAlpha,\n+\t  false,\n+\t  hasAlpha ? \n+\t  Transparency.TRANSLUCENT :\n+\t  ((transparent < 0) ?\n+\t   Transparency.OPAQUE :\n+\t   Transparency.BITMASK),\n+\t  transferType);\n+    this.cmap = cmap;\n+    this.start = start;\n+    this.size = size;\n+  }\n+\n+  public final int getMapSize()\n+  {\n+    return size;\n+  }\n+  \n+  public final int getTransparentPixel()\n+  {\n+    return transparent;\n+  }\n+\n+  public final void getReds(byte r[])\n+  {\n+    if (this.r == null) calcRGBArrays();\n+    System.arraycopy(this.r, 0, r, 0, getMapSize());\n+  }\n+  \n+  public final void getGreens(byte g[])\n+  {\n+    if (this.g == null) calcRGBArrays();\n+    System.arraycopy(this.g, 0, g, 0, getMapSize());\n+  }\n+  \n+  public final void getBlues(byte b[])\n+  {\n+    if (this.b == null) calcRGBArrays();\n+    System.arraycopy(this.b, 0, b, 0, getMapSize());\n+  }\n+\n+  public final void getAlphas(byte a[])\n+  {\n+    if (this.a == null) calcAlphaArray();\n+    System.arraycopy(this.a, 0, a, 0, getMapSize());\n+  }\n+\n+  public final void getRGBs(int rgb[])\n+  {\n+    if (this.argb == null) calcARGBArray();\n+    System.arraycopy(this.argb, 0, rgb, 0, getMapSize());\n+  }\n+\n+  public int getRed(int pixel)\n+  {\n+    try\n+      {\n+\treturn r[pixel];\n+      }\n+    catch (NullPointerException npe)\n+      {\n+\tcalcRGBArrays();\n+\treturn r[pixel];\n+      }\n+  }\n+\n+  public int getGreen(int pixel)\n+  {\n+    try\n+      {\n+\treturn g[pixel];\n+      }\n+    catch (NullPointerException npe)\n+      {\n+\tcalcRGBArrays();\n+\treturn g[pixel];\n+      }\n+  }\n+\n+  public int getBlue(int pixel)\n+  {\n+    try\n+      {\n+\treturn b[pixel];\n+      }\n+    catch (NullPointerException npe)\n+      {\n+\tcalcRGBArrays();\n+\treturn b[pixel];\n+      }\n+  }\n+  \n+  public int getAlpha(int pixel)\n+  {\n+    try\n+      {\n+\treturn a[pixel];\n+      } \n+    catch (NullPointerException npe)\n+      {\n+\tcalcAlphaArray();\n+\treturn a[pixel];\n+      }\n+  }\n+\n+  private void calcRGBArrays() {\n+    int j=0;\n+    boolean hasAlpha = hasAlpha();\n+    r = new byte[size];\n+    g = new byte[size];\n+    b = new byte[size];\n+    if (hasAlpha) a = new byte[size];\n+    \n+    for (int i=0; i<size; i++)\n+      {\n+\tr[i] = cmap[j++];\n+\tg[i] = cmap[j++];\n+\tb[i] = cmap[j++];\n+\tif (hasAlpha()) a[i] = cmap[j++];\n+      }\n+  }\n+\n+  private void calcAlphaArray()\n+  {\n+    int transparency = getTransparency();\n+    switch (transparency)\n+      {\n+      case Transparency.OPAQUE:\n+      case Transparency.BITMASK:\n+\ta = nArray((byte) 255, size);\n+\tif (transparency == Transparency.BITMASK)\n+\t  a[transparent] = 0;\n+\tbreak;\n+      case Transparency.TRANSLUCENT:\n+\tcalcRGBArrays();\n+      }\n+  }\n+\n+  private void calcARGBArray()\n+  {\n+    int mapSize = getMapSize();\n+    argb = new int[mapSize];\n+    for (int p=0; p<mapSize; p++) argb[p] = getRGB(p);\n+  }\n+  \n+  public int getRed(Object inData)\n+  {\n+    return getRed(getPixelFromArray(inData));\n+  }\n+\n+  public int getGreen(Object inData)\n+  {\n+    return getGreen(getPixelFromArray(inData));\n+  }\n+\n+  public int getBlue(Object inData)\n+  {\n+    return getBlue(getPixelFromArray(inData));\n+  }\n+    \n+  public int getAlpha(Object inData)\n+  {\n+    return getAlpha(getPixelFromArray(inData));\n+  }\n+\n+  public int getRGB(Object inData)\n+  {\n+    return getRGB(getPixelFromArray(inData));\n+  }\n+\n+  public Object getDataElements(int rgb, Object pixel)\n+  {\n+    int av, rv, gv, bv;\n+    // using 8 bit values\n+    av = (rgb >>> 24) & 0xff;\n+    rv = (rgb >>> 16) & 0xff;\n+    gv = (rgb >>>  8) & 0xff;\n+    bv = (rgb >>>  0) & 0xff;\n+    \n+    int pixelValue = getPixelValue(av, rv, gv, bv);\n+\n+    /* In this color model, the whole pixel fits in the first element\n+       of the array. */\n+    DataBuffer buffer = Buffers.createBuffer(transferType, pixel, 1);\n+    buffer.setElem(0, pixelValue);\n+    return Buffers.getData(buffer);\n+  }\n+    \n+  private int getPixelValue(int av, int rv, int gv, int bv)\n+  {\n+    if (r == null) calcRGBArrays();\n+    if (a == null) calcAlphaArray();\n+    \n+    int minDAlpha = 1<<8;\n+    int minDRGB = (1<<8)*(1<<8)*3;\n+    int pixelValue = -1;\n+    for (int i=0; i<size; i++)\n+      {\n+\tint dAlpha = Math.abs(av-(a[i]&0xff));\n+\tif (dAlpha > minDAlpha) continue;\n+\tint dR = rv-(r[i]&0xff);\n+\tint dG = gv-(g[i]&0xff);\n+\tint dB = bv-(b[i]&0xff);\n+\tint dRGB = dR*dR + dG*dG + dB*dB;\n+\t\n+\tif (dRGB >= minDRGB) continue;\n+\t\n+\tpixelValue = i;\n+\tminDRGB = dRGB;\n+      }\n+    return pixelValue;\n+  }  \n+\n+  public int[] getComponents(int pixel, int[] components, int offset)\n+  {\n+    int numComponents = getNumComponents();\n+    if (components == null) components = new int[offset + numComponents];\n+    components[offset++] = (r[pixel]&0xff);\n+    components[offset++] = (g[pixel]&0xff);\n+    components[offset++] = (b[pixel]&0xff);\n+    if (hasAlpha()) components[offset++] = (a[pixel]&0xff);\n+    return components;\n+  }\n+\t\n+  public final int[] getComponents(Object pixel, int[] components,\n+\t\t\t\t   int offset)\n+  {\n+    return getComponents(getPixelFromArray(pixel), components, offset);\n+  }\n+  \n+  public int getDataElement(int[] components, int offset)\n+  {\n+    int r = components[offset++];\n+    int g = components[offset++];\n+    int b = components[offset++];\n+    int a = hasAlpha() ? components[offset++] : 255;\n+    \n+    return getPixelValue(a, r, g, b);\n+  }\n+  \n+  public Object getDataElements(int[] components, int offset, Object pixel)\n+  {\n+    int pixelValue = getDataElement(components, offset);\n+    \n+    /* In this color model, the whole pixel fits in the first element\n+       of the array. */\n+    DataBuffer buffer = Buffers.createBuffer(transferType, pixel, 1);\n+    buffer.setElem(0, pixelValue);\n+    return Buffers.getData(buffer);\n+  }\n+    \n+  public SampleModel createCompatibleSampleModel(int w, int h)\n+  {\n+    int[] bandOffsets = {0};\n+    return new ComponentSampleModel(transferType, w, h,\n+\t\t\t\t    1, // pixel stride\n+\t\t\t\t    w, // scanline stride\n+\t\t\t\t    bandOffsets);\n+  }\n+}"}, {"sha": "a72ae2d0efac31e405da70ffb4063206157161f7", "filename": "libjava/java/awt/image/PackedColorModel.java", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FPackedColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FPackedColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FPackedColorModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,162 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.Point;\n+import java.awt.color.ColorSpace;\n+import gnu.gcj.awt.BitMaskExtent;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public abstract class PackedColorModel extends ColorModel\n+{\n+  private int masks[];\n+  \n+  /* Package accessibility, the DirectColorModel needs this array */\n+  int shifts[];\n+\n+  public PackedColorModel(ColorSpace cspace, int pixelBits,\n+\t\t\t  int[] colorMaskArray, int alphaMask,\n+\t\t\t  boolean isAlphaPremultiplied,\n+\t\t\t  int transparency,\n+\t\t\t  int transferType)\n+  {\n+    super(pixelBits, calcBitsPerComponent(colorMaskArray, alphaMask),\n+\t  cspace, (alphaMask != 0), isAlphaPremultiplied, transparency,\n+\t  transferType);\n+    initMasks(colorMaskArray, alphaMask);\n+    if ((pixelBits<1) || (pixelBits>32)) {\n+      throw new IllegalArgumentException(\"pixels per bits must be \" +\n+\t\t\t\t\t \"in the range [1, 32]\");\n+    }\n+  }\n+    \n+  private static int[] calcBitsPerComponent(int[] colorMaskArray,\n+\t\t\t\t\t    int alphaMask)\n+  {\n+    int numComponents = colorMaskArray.length;\n+    if (alphaMask != 0) numComponents++;\n+    \n+    int[] bitsPerComponent = new int[numComponents];\n+    \n+    BitMaskExtent extent = new BitMaskExtent();\n+    for (int b=0; b<colorMaskArray.length; b++)\n+      {\n+\textent.setMask(colorMaskArray[b]);\n+\tbitsPerComponent[b] = extent.bitWidth;\n+      }\n+    if (alphaMask != 0)\n+      {\n+\textent.setMask(alphaMask);\n+\tbitsPerComponent[numComponents-1] = extent.bitWidth;\n+      }\n+    return bitsPerComponent;\n+  }\n+\n+  /** Initializes the masks.\n+   *\n+   * @return an array containing the number of bits per color\n+   * component.\n+   */\n+  private void initMasks(int[] colorMaskArray, int alphaMask)\n+  {\n+    int numComponents = colorMaskArray.length;\n+    if (alphaMask == 0)\n+      {\n+\tmasks = colorMaskArray;\n+      }\n+    else\n+      {\n+\tmasks = new int[numComponents+1];\n+\tSystem.arraycopy(colorMaskArray, 0,\n+\t\t\t masks, 0,\n+\t\t\t numComponents);\n+\tmasks[numComponents++] = alphaMask;\n+      }\n+\t\n+    shifts = new int[numComponents];\n+\t\n+    // Bit field handling have been moved to a utility class\n+    BitMaskExtent extent = new BitMaskExtent();\n+    for (int b=0; b<numComponents; b++)\n+      {\n+\textent.setMask(masks[b]);\n+\tshifts[b] = extent.leastSignificantBit;\n+      }\n+  }\n+    \n+  public PackedColorModel(ColorSpace cspace, int pixelBits,\n+\t\t\t  int rmask, int gmask, int bmask,\n+\t\t\t  int amask, boolean isAlphaPremultiplied,\n+\t\t\t  int transparency,\n+\t\t\t  int transferType)\n+  {\n+    this(cspace, pixelBits, makeColorMaskArray(rmask, gmask, bmask),\n+\t amask, isAlphaPremultiplied, transparency, transferType);\n+  }\n+    \n+  /* TODO: If there is a alpha mask, it is inefficient to create a\n+     color mask array that will be discarded when the alpha mask is\n+     appended. We should probably create a private constructor that\n+     takes a complete array of masks (color+alpha) as an\n+     argument. */\n+\n+  private static int[] makeColorMaskArray(int rmask, int gmask, int bmask)\n+  {\n+    int[] colorMaskArray = { rmask, gmask, bmask };\n+    return colorMaskArray;\n+  }   \n+\n+  public final int getMask(int index)\n+  {\n+    return masks[index];\n+  }\n+  \n+  public final int[] getMasks()\n+  {\n+    return masks;\n+  }\n+\n+  public SampleModel createCompatibleSampleModel(int w, int h)\n+  {\n+    return new SinglePixelPackedSampleModel(transferType, w, h, masks);\n+  }\n+    \n+  public boolean isCompatibleSampleModel(SampleModel sm)\n+  {\n+    if (!super.isCompatibleSampleModel(sm)) return false;\n+    if (!(sm instanceof SinglePixelPackedSampleModel)) return false;\n+    \n+    SinglePixelPackedSampleModel sppsm =\n+      (SinglePixelPackedSampleModel) sm;\n+    return java.util.Arrays.equals(sppsm.getBitMasks(), masks);\n+  }\n+\n+  public WritableRaster getAlphaRaster(WritableRaster raster) {\n+    if (!hasAlpha()) return null;\n+\t\n+    SampleModel sm = raster.getSampleModel();\n+    int[] alphaBand = { sm.getNumBands() - 1 };\n+    SampleModel alphaModel = sm.createSubsetSampleModel(alphaBand);\n+    DataBuffer buffer = raster.getDataBuffer();\n+    Point origin = new Point(0, 0);\n+    return Raster.createWritableRaster(alphaModel, buffer, origin);\n+  }\n+    \n+  public boolean equals(Object obj)\n+  {\n+    if (!super.equals(obj)) return false;\n+    if (!(obj instanceof PackedColorModel)) return false;\n+    \n+    PackedColorModel other = (PackedColorModel) obj;\n+    \n+    return java.util.Arrays.equals(masks, other.masks);\n+  }\n+}"}, {"sha": "46786d9e5e266d4d30294c972c038cd79ce1c66f", "filename": "libjava/java/awt/image/Raster.java", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FRaster.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FRaster.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FRaster.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,418 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.*;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class Raster\n+{\n+  protected SampleModel sampleModel;\n+  protected DataBuffer dataBuffer;\n+  protected int minX;\n+  protected int minY;\n+  protected int width;\n+  protected int height;\n+  protected int sampleModelTranslateX;\n+  protected int sampleModelTranslateY;\n+  protected int numBands;\n+  protected int numDataElements;\n+  protected Raster parent;\n+  \n+  protected Raster(SampleModel sampleModel, Point origin)\n+  {\n+    this(sampleModel, sampleModel.createDataBuffer(), origin);\n+  }\n+  \n+  protected Raster(SampleModel sampleModel, DataBuffer dataBuffer,\n+\t\t   Point origin)\n+  {\n+    this(sampleModel, dataBuffer,\n+\t new Rectangle(origin.x, origin.y,\n+\t\t       sampleModel.getWidth(), sampleModel.getHeight()),\n+\t origin, null);\n+  }\n+\n+  protected Raster(SampleModel sampleModel, DataBuffer dataBuffer,\n+\t\t   Rectangle aRegion,\n+\t\t   Point sampleModelTranslate, Raster parent)\n+  {\n+    this.sampleModel = sampleModel;\n+    this.dataBuffer = dataBuffer;\n+    this.minX = aRegion.x;\n+    this.minY = aRegion.y;\n+    this.width = aRegion.width;\n+    this.height = aRegion.height;\n+    this.sampleModelTranslateX = sampleModelTranslate.x;\n+    this.sampleModelTranslateY = sampleModelTranslate.y;\n+    this.numBands = sampleModel.getNumBands();\n+    this.numDataElements = sampleModel.getNumDataElements();\n+    this.parent = parent;\n+  }\n+    \n+  public static WritableRaster createInterleavedRaster(int dataType,\n+\t\t\t\t\t\t       int w, int h,\n+\t\t\t\t\t\t       int bands, \n+\t\t\t\t\t\t       Point location)\n+  {\n+    int[] bandOffsets = new int[bands];\n+    // TODO: Maybe not generate this every time.\n+    for (int b=0; b<bands; b++) bandOffsets[b] = b;\n+    \n+    int scanlineStride = bands*w;\n+    return createInterleavedRaster(dataType, w, h, scanlineStride, bands,\n+\t\t\t\t   bandOffsets, location);\n+  }\n+\n+  public static WritableRaster createInterleavedRaster(int dataType,\n+\t\t\t\t\t\t       int w, int h,\n+\t\t\t\t\t\t       int scanlineStride,\n+\t\t\t\t\t\t       int pixelStride,\n+\t\t\t\t\t\t       int[] bandOffsets,\n+\t\t\t\t\t\t       Point location)\n+  {\n+    SampleModel sm = new ComponentSampleModel(dataType,\n+\t\t\t\t\t      w, h,\n+\t\t\t\t\t      pixelStride,\n+\t\t\t\t\t      scanlineStride,\n+\t\t\t\t\t      bandOffsets);\n+    return createWritableRaster(sm, location);\n+  }\n+\n+  public static WritableRaster createBandedRaster(int dataType, \n+\t\t\t\t\t\t  int w, int h, int bands,\n+\t\t\t\t\t\t  Point location)\n+  {\n+    // FIXME: Implement;\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public static WritableRaster createBandedRaster(int dataType,\n+\t\t\t\t\t\t  int w, int h,\n+\t\t\t\t\t\t  int scanlineStride,\n+\t\t\t\t\t\t  int[] bankIndices,\n+\t\t\t\t\t\t  int[] bandOffsets,\n+\t\t\t\t\t\t  Point location)\n+  {\n+    // FIXME: Implement;\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public static WritableRaster createPackedRaster(int dataType,\n+\t\t\t\t\t\t  int w, int h,\n+\t\t\t\t\t\t  int[] bandMasks,\n+\t\t\t\t\t\t  Point location)\n+  {\n+    SampleModel sm = new SinglePixelPackedSampleModel(dataType,\n+\t\t\t\t\t\t      w, h,\n+\t\t\t\t\t\t      bandMasks);\n+    return createWritableRaster(sm, location);\n+  }\n+\n+  public static WritableRaster\n+  createInterleavedRaster(DataBuffer dataBuffer, int w, int h,\n+\t\t\t  int scanlineStride, int pixelStride,\n+\t\t\t  int[] bandOffsets, Point location)\n+  {\n+    SampleModel sm = new ComponentSampleModel(dataBuffer.getDataType(),\n+\t\t\t\t\t      w, h,\n+\t\t\t\t\t      scanlineStride,\n+\t\t\t\t\t      pixelStride,\n+\t\t\t\t\t      bandOffsets);\n+    return createWritableRaster(sm, dataBuffer, location);\n+  }\n+\n+  public static\n+  WritableRaster createBandedRaster(DataBuffer dataBuffer,\n+\t\t\t\t    int w, int h,\n+\t\t\t\t    int scanlineStride,\n+\t\t\t\t    int[] bankIndices,\n+\t\t\t\t    int[] bandOffsets,\n+\t\t\t\t    Point location)\n+  {\n+    // FIXME: Implement;\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public static WritableRaster\n+  createPackedRaster(DataBuffer dataBuffer,\n+\t\t     int w, int h,\n+\t\t     int scanlineStride,\n+\t\t     int[] bandMasks,\n+\t\t     Point location) {\n+    SampleModel sm =\n+      new SinglePixelPackedSampleModel(dataBuffer.getDataType(),\n+\t\t\t\t       w, h,\n+\t\t\t\t       scanlineStride,\n+\t\t\t\t       bandMasks);\n+    return createWritableRaster(sm, dataBuffer, location);\n+  }\n+    \n+  public static Raster createRaster(SampleModel sm, DataBuffer db,\n+\t\t\t\t    Point location)\n+  {\n+    return new Raster(sm, db, location);\n+  }\n+\n+  public static WritableRaster createWritableRaster(SampleModel sm,\n+\t\t\t\t\t\t    Point location)\n+  {\n+    return new WritableRaster(sm, location);\n+  }\n+\n+  public static WritableRaster createWritableRaster(SampleModel sm,\n+\t\t\t\t\t\t    DataBuffer db,\n+\t\t\t\t\t\t    Point location)\n+  {\n+    return new WritableRaster(sm, db, location);\n+  }\n+\n+  public Raster getParent()\n+  {\n+    return parent;\n+  }\n+\n+  public final int getSampleModelTranslateX()\n+  {\n+    return sampleModelTranslateX;\n+  }\n+\n+  public final int getSampleModelTranslateY()\n+  {\n+    return sampleModelTranslateY;\n+  }\n+\n+  public WritableRaster createCompatibleWritableRaster()\n+  {\n+    return new WritableRaster(getSampleModel(), new Point(minX, minY));\n+  }\n+\n+  public WritableRaster createCompatibleWritableRaster(int w, int h)\n+  {\n+    return createCompatibleWritableRaster(minX, minY, w, h);\n+  }\n+\n+  public WritableRaster createCompatibleWritableRaster(Rectangle rect)\n+  {\n+    return createCompatibleWritableRaster(rect.x, rect.y,\n+\t\t\t\t\t  rect.width, rect.height);\n+  }\n+\n+  public WritableRaster createCompatibleWritableRaster(int x, int y,\n+\t\t\t\t\t\t       int w, int h)\n+  {\n+    SampleModel sm = getSampleModel().createCompatibleSampleModel(w, h);\n+    return new WritableRaster(sm, sm.createDataBuffer(),\n+\t\t\t      new Point(x, y));\n+  }\n+\n+  public Raster createTranslatedChild(int childMinX, int childMinY) {\n+    int tcx = sampleModelTranslateX - minX + childMinX;\n+    int tcy = sampleModelTranslateY - minY + childMinY;\n+    \n+    return new Raster(sampleModel, dataBuffer,\n+\t\t      new Rectangle(childMinX, childMinY,\n+\t\t\t\t    width, height),\n+\t\t      new Point(tcx, tcy),\n+\t\t      this);\n+  }\n+\n+  public Raster createChild(int parentX, int parentY, int width,\n+\t\t\t    int height, int childMinX, int childMinY,\n+\t\t\t    int[] bandList)\n+  {\n+    /* FIXME: Throw RasterFormatException if child bounds extends\n+       beyond the bounds of this raster. */\n+\n+    SampleModel sm = (bandList == null) ?\n+      sampleModel :\n+      sampleModel.createSubsetSampleModel(bandList);\n+\n+    /*\n+        data origin\n+       /\n+      +-------------------------\n+      |\\. __ parent trans\n+      | \\`.  \n+      |  \\ `.    parent origin\n+      |   \\  `. /\n+      |   /\\   +-------- - -\n+      |trans\\ /<\\-- deltaTrans\n+      |child +-+-\\---- - - \n+      |     /|`|  \\__ parent [x, y]\n+      |child | |`. \\\n+      |origin| :  `.\\\n+      |      |    / `\\\n+      |      :   /    +\n+      | child [x, y] \n+\n+      parent_xy - parent_trans = child_xy - child_trans\n+\n+      child_trans = parent_trans + child_xy - parent_xy\n+    */\n+\n+    return new Raster(sm, dataBuffer,\n+\t\t      new Rectangle(childMinX, childMinY,\n+\t\t\t\t    width, height),\n+\t\t      new Point(sampleModelTranslateX+childMinX-parentX,\n+\t\t\t\tsampleModelTranslateY+childMinY-parentY),\n+\t\t      this);\n+  }\n+\n+  public Rectangle getBounds()\n+  {\n+    return new Rectangle(minX, minY, width, height);\n+  }\n+\n+  public final int getMinX()\n+  {\n+    return minX;\n+  }\n+\n+  public final int getMinY()\n+  {\n+    return minY;\n+  }\n+\n+  public final int getWidth()\n+  {\n+    return width;\n+  }\n+\n+  public final int getHeight()\n+  {\n+    return height;\n+  }\n+\n+  public final int getNumDataElements()\n+  {\n+    return numDataElements;\n+  }\n+    \n+  public final int getTransferType()\n+  {\n+    return sampleModel.getTransferType();\n+  }\n+\n+  public DataBuffer getDataBuffer()\n+  {\n+    return dataBuffer;\n+  }\n+\n+  public SampleModel getSampleModel()\n+  {\n+    return sampleModel;\n+  }\n+\n+  public Object getDataElements(int x, int y, Object outData)\n+  {\n+    return sampleModel.getDataElements(x-sampleModelTranslateX,\n+\t\t\t\t       y-sampleModelTranslateY,\n+\t\t\t\t       outData, dataBuffer);\n+  }\n+\n+  public Object getDataElements(int x, int y, int w, int h,\n+\t\t\t\tObject outData)\n+  {\n+    return sampleModel.getDataElements(x-sampleModelTranslateX,\n+\t\t\t\t       y-sampleModelTranslateY,\n+\t\t\t\t       w, h, outData, dataBuffer);\n+  }\n+\n+  public int[] getPixel(int x, int y, int[] iArray)\n+  {\n+    return sampleModel.getPixel(x-sampleModelTranslateX,\n+\t\t\t\ty-sampleModelTranslateY,\n+\t\t\t\tiArray, dataBuffer);\n+  }\n+\n+  public float[] getPixel(int x, int y, float[] fArray)\n+  {\n+    return sampleModel.getPixel(x-sampleModelTranslateX,\n+\t\t\t\ty-sampleModelTranslateY,\n+\t\t\t\tfArray, dataBuffer);\n+  }\n+\n+  public double[] getPixel(int x, int y, double[] dArray)\n+  {\n+    return sampleModel.getPixel(x-sampleModelTranslateX,\n+\t\t\t\ty-sampleModelTranslateY,\n+\t\t\t\tdArray, dataBuffer);\n+  }\n+\n+  public int[] getPixels(int x, int y, int w, int h, int[] iArray)\n+  {\n+    return sampleModel.getPixels(x-sampleModelTranslateX,\n+\t\t\t\t y-sampleModelTranslateY,\n+\t\t\t\t w, h, iArray, dataBuffer);\n+  }\n+\n+  public float[] getPixels(int x, int y, int w, int h,\n+\t\t\t   float[] fArray)\n+  {\n+    return sampleModel.getPixels(x-sampleModelTranslateX,\n+\t\t\t\t y-sampleModelTranslateY,\n+\t\t\t\t w, h, fArray, dataBuffer);\n+  }\n+\n+  public double[] getPixels(int x, int y, int w, int h,\n+\t\t\t    double[] dArray)\n+  {\n+    return sampleModel.getPixels(x-sampleModelTranslateX,\n+\t\t\t\t y-sampleModelTranslateY,\n+\t\t\t\t w, h, dArray, dataBuffer);\n+  }\n+\n+  public int getSample(int x, int y, int b)\n+  {\n+    return sampleModel.getSample(x-sampleModelTranslateX,\n+\t\t\t\t y-sampleModelTranslateY,\n+\t\t\t\t b, dataBuffer);\n+  }\n+\n+  public float getSampleFloat(int x, int y, int b)\n+  {\n+    return sampleModel.getSampleFloat(x-sampleModelTranslateX,\n+\t\t\t\t      y-sampleModelTranslateY,\n+\t\t\t\t      b, dataBuffer);\n+  }\n+\n+  public double getSampleDouble(int x, int y, int b)\n+  {\n+    return sampleModel.getSampleDouble(x-sampleModelTranslateX,\n+\t\t\t\t       y-sampleModelTranslateY,\n+\t\t\t\t       b, dataBuffer);\n+  }\n+\n+  public int[] getSamples(int x, int y, int w, int h, int b,\n+\t\t\t  int[] iArray)\n+  {\n+    return sampleModel.getSamples(x-sampleModelTranslateX,\n+\t\t\t\t  y-sampleModelTranslateY,\n+\t\t\t\t  w, h, b, iArray, dataBuffer);\n+  }\n+\n+  public float[] getSamples(int x, int y, int w, int h, int b,\n+\t\t\t    float[] fArray)\n+  {\n+    return sampleModel.getSamples(x-sampleModelTranslateX,\n+\t\t\t\t  y-sampleModelTranslateY,\n+\t\t\t\t  w, h, b, fArray, dataBuffer);\n+  }\n+\n+  public double[] getSamples(int x, int y, int w, int h, int b,\n+\t\t\t     double[] dArray)\n+  {\n+    return sampleModel.getSamples(x-sampleModelTranslateX,\n+\t\t\t\t  y-sampleModelTranslateY,\n+\t\t\t\t  w, h, b, dArray, dataBuffer);\n+  }\n+}"}, {"sha": "3368c83df928e2eadbaf1d3818a80e172d2fb962", "filename": "libjava/java/awt/image/SampleModel.java", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FSampleModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FSampleModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FSampleModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,436 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public abstract class SampleModel\n+{\n+  /** Width of image described. */\n+  protected int width;\n+  \n+  /** Height of image described. */\n+  protected int height;\n+  \n+  /** Number of bands in the image described. */\n+  protected int numBands;\n+\n+  /** \n+   * The DataBuffer type that is used to store the data of the image\n+   * described.\n+   */\n+  protected int dataType;\n+\n+  public SampleModel(int dataType, int w, int h, int numBands)\n+  {\n+    if ((w<=0) || (h<=0)) throw new IllegalArgumentException();\n+\t\n+    // FIXME: How can an int be greater than Integer.MAX_VALUE?\n+    // FIXME: How do we identify an unsupported data type?\n+\n+    this.dataType = dataType;\n+    this.width = w;\n+    this.height = h;\n+    this.numBands = numBands;  \n+  }\n+\n+  public final int getWidth()\n+  {\n+    return width;\n+  }\n+\n+  public final int getHeight()\n+  {\n+    return height;\n+  }\n+\n+  public final int getNumBands()\n+  {\n+    return numBands;\n+  }\n+    \n+  public abstract int getNumDataElements();\n+  \n+  public final int getDataType()\n+  {\n+    return dataType;\n+  }\n+\n+  public int getTransferType()\n+  {\n+    // FIXME: Is this a reasonable default implementation?\n+    return dataType;\n+  }\n+\n+  public int[] getPixel(int x, int y, int[] iArray, DataBuffer data)\n+  {\n+    if (iArray == null) iArray = new int[numBands];\n+    for (int b=0; b<numBands; b++) iArray[b] = getSample(x, y, b, data);\n+    return iArray;\n+  }\n+  \n+  /**\n+   *\n+   * This method is provided as a faster alternative to getPixel(),\n+   * that can be used when there is no need to decode the pixel into\n+   * seperate sample values.\n+   *\n+   * @param obj An array to return the pixel data in. If null, an\n+   * array of the right type and size will be created.\n+   *\n+   * @return A single pixel as an array object of a primitive type,\n+   * based on the transfer type. Eg. if transfer type is\n+   * DataBuffer.TYPE_USHORT, then a short[] object is returned.\n+   */\n+  public abstract Object getDataElements(int x, int y, Object obj,\n+\t\t\t\t\t DataBuffer data);\n+\n+    \n+  public Object getDataElements(int x, int y, int w, int h, Object obj,\n+\t\t\t\tDataBuffer data)\n+  {\n+    int size = w*h;\n+    int numDataElements = getNumDataElements();\n+    int dataSize = numDataElements*size;\n+    \n+    if (obj == null)\n+      {\n+\tswitch (getTransferType())\n+\t  {\n+\t  case DataBuffer.TYPE_BYTE:\n+\t    obj = new byte[dataSize];\n+\t    break;\n+\t  case DataBuffer.TYPE_USHORT:\n+\t    obj = new short[dataSize];\n+\t    break;\n+\t  case DataBuffer.TYPE_INT:\n+\t    obj = new int[dataSize];\n+\t    break;\n+\t  default:\n+\t    // Seems like the only sensible thing to do.\n+\t    throw new ClassCastException();\n+\t  }\n+      }\n+    Object pixelData = null;\n+    int outOffset = 0;\n+    for (int yy = y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx = x; xx<(x+w); xx++)\n+\t  {\n+\t    pixelData = getDataElements(xx, yy, pixelData, data);\n+\t    System.arraycopy(pixelData, 0, obj, outOffset,\n+\t\t\t     numDataElements);\n+\t    outOffset += numDataElements;\n+\t  }\n+      }\n+    return obj;\n+  }\n+\n+  public abstract void setDataElements(int x, int y, Object obj,\n+\t\t\t\t       DataBuffer data);\n+\n+  public void setDataElements(int x, int y, int w, int h,\n+\t\t\t      Object obj, DataBuffer data)\n+  {\n+    int size = w*h;\n+    int numDataElements = getNumDataElements();\n+    int dataSize = numDataElements*size;\n+    \n+    Object pixelData;\n+    switch (getTransferType())\n+      {\n+      case DataBuffer.TYPE_BYTE:\n+\tpixelData = new byte[numDataElements];\n+\tbreak;\n+      case DataBuffer.TYPE_USHORT:\n+\tpixelData = new short[numDataElements];\n+\tbreak;\n+      case DataBuffer.TYPE_INT:\n+\tpixelData = new int[numDataElements];\n+\tbreak;\n+      default:\n+\t// Seems like the only sensible thing to do.\n+\tthrow new ClassCastException();\n+      }\n+    int inOffset = 0;\n+\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    System.arraycopy(obj, inOffset, pixelData, 0,\n+\t\t\t     numDataElements);\n+\t    setDataElements(xx, yy, pixelData, data);\n+\t    inOffset += numDataElements;\n+\t  }\n+      }\n+  }\n+\n+  public float[] getPixel(int x, int y, float[] fArray, DataBuffer data)\n+  {\n+    if (fArray == null) fArray = new float[numBands];\n+    \n+    for (int b=0; b<numBands; b++)\n+      {\n+        fArray[0] = getSampleFloat(x, y, b, data);\n+      }\n+    return fArray;\n+  }\n+\n+  public double[] getPixel(int x, int y, double[] dArray, DataBuffer data) {\n+    if (dArray == null) dArray = new double[numBands];\n+    for (int b=0; b<numBands; b++)\n+      {\n+\tdArray[0] = getSampleDouble(x, y, b, data);\n+      }\n+    return dArray;\n+  }\n+\n+  /* FIXME: Should it return a banded or pixel interleaved array of\n+     samples? (Assume interleaved.) */\n+  public int[] getPixels(int x, int y, int w, int h, int[] iArray,\n+\t\t\t DataBuffer data)\n+  {\n+    int size = w*h;\n+    int outOffset = 0;\n+    int[] pixel = null;\n+    if (iArray == null) iArray = new int[w*h*numBands];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    getPixel(xx, yy, pixel, data);\n+\t    System.arraycopy(pixel, 0, iArray, outOffset, numBands);\n+\t    outOffset += numBands;\n+\t  }\n+      }\n+    return iArray;\n+  }\n+\n+  /* FIXME: Should it return a banded or pixel interleaved array of\n+     samples? (Assume interleaved.) */\n+  public float[] getPixels(int x, int y, int w, int h, float[] fArray,\n+\t\t\t   DataBuffer data)\n+  {\n+    int size = w*h;\n+    int outOffset = 0;\n+    float[] pixel = null;\n+    if (fArray == null) fArray = new float[w*h*numBands];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    getPixel(xx, yy, pixel, data);\n+\t    System.arraycopy(pixel, 0, fArray, outOffset, numBands);\n+\t    outOffset += numBands;\n+\t  }\n+      }\n+    return fArray;\n+  }\n+    \n+  /* FIXME: Should it return a banded or pixel interleaved array of\n+     samples? (Assume interleaved.) */\n+  public double[] getPixels(int x, int y, int w, int h, double[] dArray,\n+\t\t\t    DataBuffer data)\n+  {\n+    int size = w*h;\n+    int outOffset = 0;\n+    double[] pixel = null;\n+    if (dArray == null) dArray = new double[w*h*numBands];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    getPixel(xx, yy, pixel, data);\n+\t    System.arraycopy(pixel, 0, dArray, outOffset, numBands);\n+\t    outOffset += numBands;\n+\t  }\n+      }\n+    return dArray;\n+  }\n+\n+  public abstract int getSample(int x, int y, int b, DataBuffer data);\n+\n+  public float getSampleFloat(int x, int y, int b, DataBuffer data)\n+  {\n+    return getSample(x, y, b, data);\n+  }\n+\n+  public double getSampleDouble(int x, int y, int b, DataBuffer data)\n+  {\n+    return getSampleFloat(x, y, b, data);\n+  }\n+\n+  public int[] getSamples(int x, int y, int w, int h, int b,\n+\t\t\t  int[] iArray, DataBuffer data)\n+  {\n+    int size = w*h;\n+    int outOffset = 0;\n+    if (iArray == null) iArray = new int[size];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    iArray[outOffset++] = getSample(xx, yy, b, data);\n+\t  }\n+      }\n+    return iArray;\n+  }\n+\n+  public float[] getSamples(int x, int y, int w, int h, int b,\n+\t\t\t    float[] fArray, DataBuffer data)\n+  {\n+    int size = w*h;\n+    int outOffset = 0;\n+    if (fArray == null) fArray = new float[size];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    fArray[outOffset++] = getSampleFloat(xx, yy, b, data);\n+\t  }\n+      }\n+    return fArray;\n+  }\n+\n+  public double[] getSamples(int x, int y, int w, int h, int b,\n+\t\t\t     double[] dArray, DataBuffer data)\n+  {\n+    int size = w*h;\n+    int outOffset = 0;\n+    if (dArray == null) dArray = new double[size];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    dArray[outOffset++] = getSampleDouble(xx, yy, b, data);\n+\t  }\n+      }\n+    return dArray;\n+  }\n+  \n+  public void setPixel(int x, int y, int[] iArray, DataBuffer data)\n+  {\n+    for (int b=0; b<numBands; b++) setSample(x, y, b, iArray[b], data);\n+  }\n+\n+  public void setPixel(int x, int y, float[] fArray, DataBuffer data)\n+  {\n+    for (int b=0; b<numBands; b++) setSample(x, y, b, fArray[b], data);\n+  }\n+\n+  public void setPixel(int x, int y, double[] dArray, DataBuffer data)\n+  {\n+    for (int b=0; b<numBands; b++) setSample(x, y, b, dArray[b], data);\n+  }\n+\n+  public void setPixels(int x, int y, int w, int h, int[] iArray,\n+\t\t\tDataBuffer data)\n+  {\n+    int inOffset = 0;\n+    int[] pixel = new int[numBands];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    System.arraycopy(iArray, inOffset, pixel, 0, numBands);\n+\t    setPixel(xx, yy, pixel, data);\n+\t    inOffset += numBands;\n+\t  }\n+      }\n+  }\n+\n+  public void setPixels(int x, int y, int w, int h, float[] fArray,\n+\t\t\tDataBuffer data)\n+  {\n+    int inOffset = 0;\n+    float[] pixel = new float[numBands];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    System.arraycopy(fArray, inOffset, pixel, 0, numBands);\n+\t    setPixel(xx, yy, pixel, data);\n+\t    inOffset += numBands;\n+\t  }\n+      }\n+  }\n+\n+  public void setPixels(int x, int y, int w, int h, double[] dArray,\n+\t\t\tDataBuffer data)\n+  {\n+    int inOffset = 0;\n+    double[] pixel = new double[numBands];\n+    for (int yy=y; yy<(y+h); yy++)\n+      {\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  {\n+\t    System.arraycopy(dArray, inOffset, pixel, 0, numBands);\n+\t    setPixel(xx, yy, pixel, data);\n+\t    inOffset += numBands;\n+\t  }\n+      }\n+  }\n+\n+  public abstract void setSample(int x, int y, int b, int s,\n+\t\t\t\t DataBuffer data);\n+\n+  public void setSample(int x, int y, int b, float s,\n+\t\t\tDataBuffer data)\n+  {\n+    setSample(x, y, b, (int) s, data);\n+  }\n+\n+  public void setSample(int x, int y, int b, double s,\n+\t\t\tDataBuffer data)\n+  {\n+    setSample(x, y, b, (float) s, data);\n+  }\n+\n+  public void setSamples(int x, int y, int w, int h, int b,\n+\t\t\t int[] iArray, DataBuffer data)\n+  {\n+    int size = w*h;\n+    int inOffset = 0;\n+    for (int yy=y; yy<(y+h); yy++)\n+      for (int xx=x; xx<(x+w); xx++)\n+\tsetSample(xx, yy, b, iArray[inOffset++], data);\n+  }\n+\n+  public void setSamples(int x, int y, int w, int h, int b,\n+\t\t\t float[] fArray, DataBuffer data)\n+  {\n+    int size = w*h;\n+    int inOffset = 0;\n+    for (int yy=y; yy<(y+h); yy++)\n+      for (int xx=x; xx<(x+w); xx++)\n+\tsetSample(xx, yy, b, fArray[inOffset++], data);\n+\n+    }\n+\n+    public void setSamples(int x, int y, int w, int h, int b,\n+\t\t\t   double[] dArray, DataBuffer data) {\n+      int size = w*h;\n+      int inOffset = 0;\n+      for (int yy=y; yy<(y+h); yy++)\n+\tfor (int xx=x; xx<(x+w); xx++)\n+\t  setSample(xx, yy, b, dArray[inOffset++], data);\n+    }\n+\n+    public abstract SampleModel createCompatibleSampleModel(int w, int h);\n+\n+    public abstract SampleModel createSubsetSampleModel(int[] bands);\n+\n+    public abstract DataBuffer createDataBuffer();\n+\n+    public abstract int[] getSampleSize();\n+\n+    public abstract int getSampleSize(int band);\n+}"}, {"sha": "3baea049ba404c37a4f95b27ef0bd535cb0b8f72", "filename": "libjava/java/awt/image/SinglePixelPackedSampleModel.java", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,245 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import gnu.gcj.awt.BitMaskExtent;\n+import gnu.gcj.awt.Buffers;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class SinglePixelPackedSampleModel extends SampleModel\n+{\n+  private int scanlineStride;\n+  private int[] bitMasks;\n+  private int[] bitOffsets;\n+  private int[] sampleSize;;\n+  \n+  public SinglePixelPackedSampleModel(int dataType, int w, int h,\n+\t\t\t\t      int[] bitMasks)\n+  {\n+    this(dataType, w, h, w, bitMasks);\n+  }\n+\n+  public SinglePixelPackedSampleModel(int dataType, int w, int h,\n+\t\t\t\t      int scanlineStride, int[] bitMasks)\n+  {\n+    super(dataType, w, h, bitMasks.length);\n+    \n+    this.scanlineStride = scanlineStride;\n+    this.bitMasks = bitMasks;\n+    \n+    bitOffsets = new int[numBands];\n+    sampleSize = new int[numBands];\n+    \n+    BitMaskExtent extent = new BitMaskExtent();\n+    for (int b=0; b<numBands; b++)\n+      {\n+\textent.setMask(bitMasks[b]);\n+\tsampleSize[b] = extent.bitWidth;\n+\tbitOffsets[b] = extent.leastSignificantBit;\n+      }\n+  }\n+\n+  public int getNumDataElements()\n+  {\n+    return 1;\n+  }\n+\n+  public SampleModel createCompatibleSampleModel(int w, int h)\n+  {\n+    /* FIXME: We can avoid recalculation of bit offsets and sample\n+       sizes here by passing these from the current instance to a\n+       special private constructor. */\n+    return new SinglePixelPackedSampleModel(dataType, w, h, bitMasks);\n+  }\n+\n+  public DataBuffer createDataBuffer()\n+  {\n+    // Important: use scanlineStride here, not width!\n+    int size = scanlineStride*height;\n+    return Buffers.createBuffer(getDataType(), size);\n+  }\n+\n+  public int[] getSampleSize()\n+  {\n+    return sampleSize;\n+  }\n+  \n+  public int getSampleSize(int band)\n+  {\n+    return sampleSize[band];\n+  }\n+\n+  public int getOffset(int x, int y)\n+  {\n+    return scanlineStride*y + x;\n+  }\n+\n+  public int[] getBitOffsets()\n+  {\n+    return bitOffsets;\n+  }\n+\n+  public int[] getBitMasks()\n+  {\n+    return bitMasks;\n+  }\n+\n+  public int getScanlineStride()\n+  {\n+    return scanlineStride;\n+  }\n+\n+  public SampleModel createSubsetSampleModel(int[] bands)\n+  {\n+    // FIXME: Is this the right way to interpret bands?\n+    \n+    int numBands = bands.length;\n+    \n+    int[] bitMasks = new int[numBands];\n+\n+    for (int b=0; b<numBands; b++)\n+      bitMasks[b] = this.bitMasks[bands[b]];\n+\n+    return new SinglePixelPackedSampleModel(dataType, width, height,\n+\t\t\t\t\t    scanlineStride, bitMasks);\n+  }\n+\n+  public Object getDataElements(int x, int y, Object obj,\n+\t\t\t\tDataBuffer data)\n+  {\n+    int offset = scanlineStride*y + x + data.getOffset();\n+    \n+    return Buffers.getData(data, offset, obj,\n+\t\t\t   0, // destination offset,\n+\t\t\t   1  // length\n+\t\t\t   );\n+  }\n+\n+  public int[] getPixel(int x, int y, int[] iArray, DataBuffer data)\n+  {\n+    int offset = scanlineStride*y + x;\n+    if (iArray == null) iArray = new int[numBands];\n+    int samples = data.getElem(offset);\n+\n+    for (int b=0; b<numBands; b++)\n+      iArray[b] = (samples & bitMasks[b]) >>> bitOffsets[b];\n+\t\n+    return iArray;\n+  }\n+\n+  public int[] getPixels(int x, int y, int w, int h, int[] iArray,\n+\t\t\t DataBuffer data)\n+  {\n+    int offset = scanlineStride*y + x;\n+    if (iArray == null) iArray = new int[numBands*w*h];\n+    int outOffset = 0;\n+    for (y=0; y<h; y++)\n+      {\n+\tint lineOffset = offset;\n+\tfor (x=0; x<w; x++)\n+\t  {\n+\t    int samples = data.getElem(lineOffset++);\n+\t    for (int b=0; b<numBands; b++)\n+\t      iArray[outOffset++] = (samples & bitMasks[b]) >>> bitOffsets[b];\n+\t  }\n+\toffset += scanlineStride;\n+      }\n+    return iArray;\t\n+  }\n+\n+  public int getSample(int x, int y, int b, DataBuffer data)\n+  {\n+    int offset = scanlineStride*y + x;\n+    int samples = data.getElem(offset);\n+    return (samples & bitMasks[b]) >>> bitOffsets[b];\n+  }\n+\n+  public void setDataElements(int x, int y, Object obj, DataBuffer data)\n+  {\n+    int offset = scanlineStride*y + x + data.getOffset();\n+    \n+    int transferType = getTransferType();\n+    if (getTransferType() != data.getDataType())\n+      {\n+\tthrow new IllegalArgumentException(\"transfer type (\"+\n+\t\t\t\t\t   getTransferType()+\"), \"+\n+\t\t\t\t\t   \"does not match data \"+\n+\t\t\t\t\t   \"buffer type (\" +\n+\t\t\t\t\t   data.getDataType() +\n+\t\t\t\t\t   \").\");\n+      }\n+\n+    try\n+      {\n+\tswitch (transferType)\n+\t  {\n+\t  case DataBuffer.TYPE_BYTE:\n+\t    {\n+\t      DataBufferByte out = (DataBufferByte) data;\n+\t      byte[] in = (byte[]) obj;\n+\t      out.getData()[offset] = in[0];\n+\t      return;\n+\t    }\n+\t  case DataBuffer.TYPE_USHORT:\n+\t    {\n+\t      DataBufferUShort out = (DataBufferUShort) data;\n+\t      short[] in = (short[]) obj;\n+\t      out.getData()[offset] = in[0];\n+\t      return;\n+\t    }\n+\t  case DataBuffer.TYPE_INT:\n+\t    {\n+\t      DataBufferInt out = (DataBufferInt) data;\n+\t      int[] in = (int[]) obj;\n+\t      out.getData()[offset] = in[0];\n+\t      return;\n+\t    }\n+\t    // FIXME: Fill in the other possible types.\n+\t  default:\n+\t    throw new InternalError();\n+\t  }\n+      }\n+    catch (ArrayIndexOutOfBoundsException aioobe)\n+      {\n+\tString msg = \"While writing data elements\" +\n+\t  \", x=\"+x+\", y=\"+y+\n+\t  \", width=\"+width+\", height=\"+height+\n+\t  \", scanlineStride=\"+scanlineStride+\n+\t  \", offset=\"+offset+\n+\t  \", data.getSize()=\"+data.getSize()+\n+\t  \", data.getOffset()=\"+data.getOffset()+\n+\t  \": \" +\n+\t  aioobe;\n+\tthrow new ArrayIndexOutOfBoundsException(msg);\n+      }\n+    }\n+\n+  public void setPixel(int x, int y, int[] iArray, DataBuffer data)\n+  {\n+    int offset = scanlineStride*y + x;\n+    \n+    int samples = 0;\n+    for (int b=0; b<numBands; b++)\n+      samples |= (iArray[b] << bitOffsets[b]) & bitMasks[b];\n+\n+    data.setElem(offset, samples);\n+  }\n+\n+  public void setSample(int x, int y, int b, int s, DataBuffer data)\n+  {\n+    int offset = scanlineStride*y + x;\n+    int samples = data.getElem(offset);\n+    int bitMask = bitMasks[b];\n+    samples &= ~bitMask;\n+    samples |= (s << bitOffsets[b]) & bitMask;\n+    data.setElem(offset, samples);\n+  }\n+}"}, {"sha": "6667256b6f564970ec9c0036da09aa6e2fd5b57d", "filename": "libjava/java/awt/image/WritableRaster.java", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FWritableRaster.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b1b29156c348ffd39c85043b21d0ffd6cb4a73/libjava%2Fjava%2Fawt%2Fimage%2FWritableRaster.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FWritableRaster.java?ref=69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "patch": "@@ -0,0 +1,234 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.*;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class WritableRaster extends Raster\n+{\n+  protected WritableRaster(SampleModel sampleModel, Point origin) \n+  {\n+    this(sampleModel, sampleModel.createDataBuffer(), origin);\n+  }\n+  \n+  protected WritableRaster(SampleModel sampleModel,\n+\t\t\t   DataBuffer dataBuffer, Point origin)\n+  {\n+    this(sampleModel, dataBuffer,\n+\t new Rectangle(origin.x, origin.y,\n+\t\t       sampleModel.getWidth(), sampleModel.getHeight()),\n+\t origin,\n+\t null);\n+  }\n+\n+  protected WritableRaster(SampleModel sampleModel, \n+\t\t\t   DataBuffer dataBuffer,\n+\t\t\t   Rectangle aRegion,\n+\t\t\t   Point sampleModelTranslate,\n+\t\t\t   WritableRaster parent)\n+  {\n+    super(sampleModel, dataBuffer, aRegion, sampleModelTranslate,\n+\t  parent);\n+  }\n+\n+  public WritableRaster getWritableParent()\n+  {\n+    return (WritableRaster) getParent();\n+  }\n+  \n+  public WritableRaster createWritableTranslatedChild(int childMinX,\n+\t\t\t\t\t\t      int childMinY)\n+  {\n+    // This mirrors the code from the super class\n+    int tcx = sampleModelTranslateX - minX + childMinX;\n+    int tcy = sampleModelTranslateY - minY + childMinY;\n+    \n+    return new WritableRaster(sampleModel, dataBuffer,\n+\t\t\t      new Rectangle(childMinX, childMinY,\n+\t\t\t\t\t    width, height),\n+\t\t\t      new Point(tcx, tcy),\n+\t\t\t      this);\n+  }\n+\n+  public WritableRaster createWritableChild(int parentX,\n+\t\t\t\t\t    int parentY,\n+\t\t\t\t\t    int w, int h,\n+\t\t\t\t\t    int childMinX,\n+\t\t\t\t\t    int childMinY,\n+\t\t\t\t\t    int[] bandList)\n+  {\n+    // This mirrors the code from the super class\n+    \n+    // FIXME: Throw RasterFormatException if child bounds extends\n+    // beyond the bounds of this raster.\n+    \n+    SampleModel sm = (bandList == null) ?\n+      sampleModel :\n+      sampleModel.createSubsetSampleModel(bandList);\n+    \n+    return new\n+      WritableRaster(sm, dataBuffer,\n+\t\t     new Rectangle(childMinX, childMinY,\n+\t\t\t\t   w, h),\n+\t\t     new Point(sampleModelTranslateX+childMinX-parentX,\n+\t\t\t       sampleModelTranslateY+childMinY-parentY),\n+\t\t     this);\n+  }\n+\n+  public void setDataElements(int x, int y, Object inData)\n+  {\n+    sampleModel.setDataElements(x-sampleModelTranslateX,\n+\t\t\t\ty-sampleModelTranslateY,\n+\t\t\t\tinData, dataBuffer);\n+  }\n+\n+  public void setDataElements(int x, int y, Raster inRaster)\n+  {\n+    Object dataElements = getDataElements(0, 0,\n+\t\t\t\t\t  inRaster.getWidth(),\n+\t\t\t\t\t  inRaster.getHeight(),\n+\t\t\t\t\t  null);\n+    setDataElements(x, y, dataElements);\n+  }\n+\n+  public void setDataElements(int x, int y, int w, int h,\n+\t\t\t      Object inData)\n+  {\n+    sampleModel.setDataElements(x-sampleModelTranslateX,\n+\t\t\t\ty-sampleModelTranslateY,\n+\t\t\t\tw, h, inData, dataBuffer);\n+  }\n+\n+  public void setRect(Raster srcRaster)\n+  {\n+    setRect(srcRaster, 0, 0);\n+  }\n+\n+  public void setRect(Raster srcRaster, int dx, int dy) \n+  {\n+    Rectangle targetUnclipped = new Rectangle(srcRaster.getMinX()+dx,\n+\t\t\t\t\t      srcRaster.getMinY()+dy,\n+\t\t\t\t\t      srcRaster.getWidth(),\n+\t\t\t\t\t      srcRaster.getHeight());\n+\t\n+    Rectangle target = getBounds().intersection(targetUnclipped);\n+\n+    if (target.isEmpty()) return;\n+    \n+    int sx = target.x - dx;\n+    int sy = target.y - dy;\n+    \n+    // FIXME: Do tests on rasters and use get/set data instead.\n+    \n+    /* The JDK documentation seems to imply this implementation.\n+       (the trucation of higher bits), but an implementation using\n+       get/setDataElements would be more efficient. None of the\n+       implementations would do anything sensible when the sample\n+       models don't match.\n+       \n+       But this is probably not the place to consider such\n+       optimizations.*/\n+\n+    int[] pixels = srcRaster.getPixels(sx, sy,\n+\t\t\t\t       target.width, target.height,\n+\t\t\t\t       (int[]) null);\n+\n+    setPixels(target.x, target.y, target.width, target.height, pixels);\n+  }\n+\n+  public void setPixel(int x, int y, int[] iArray)\n+  {\n+    sampleModel.setPixel(x-sampleModelTranslateX,\n+\t\t\t y-sampleModelTranslateY,\n+\t\t\t iArray, dataBuffer);\n+  }\n+\n+  public void setPixel(int x, int y, float[] fArray)\n+  {\n+    sampleModel.setPixel(x-sampleModelTranslateX,\n+\t\t\t y-sampleModelTranslateY,\n+\t\t\t fArray, dataBuffer);\n+  }\n+\n+  public void setPixel(int x, int y, double[] dArray)\n+  {\n+    sampleModel.setPixel(x-sampleModelTranslateX,\n+\t\t\t y-sampleModelTranslateY,\n+\t\t\t dArray, dataBuffer);\n+  }\n+\n+  public void setPixels(int x, int y, int w, int h, int[] iArray)\n+  {\n+    sampleModel.setPixels(x-sampleModelTranslateX,\n+\t\t\t  y-sampleModelTranslateY,\n+\t\t\t  w, h, iArray, dataBuffer);\n+  }\n+\n+  public void setPixels(int x, int y, int w, int h, float[] fArray)\n+  {\n+    sampleModel.setPixels(x-sampleModelTranslateX,\n+\t\t\t  y-sampleModelTranslateY,\n+\t\t\t  w, h, fArray, dataBuffer);\n+  }\n+\n+  public void setPixels(int x, int y, int w, int h, double[] dArray)\n+  {\n+    sampleModel.setPixels(x-sampleModelTranslateX,\n+\t\t\t  y-sampleModelTranslateY,\n+\t\t\t  w, h, dArray, dataBuffer);\n+  }\n+\n+  public void setSample(int x, int y, int b, int s)\n+  {\n+    sampleModel.setSample(x-sampleModelTranslateX,\n+\t\t\t  y-sampleModelTranslateY,\n+\t\t\t  b, s, dataBuffer);\n+  }\n+\n+  public void setSample(int x, int y, int b, float s)\n+  {\n+    sampleModel.setSample(x-sampleModelTranslateX,\n+\t\t\t  y-sampleModelTranslateY,\n+\t\t\t  b, s, dataBuffer);\n+  }\n+\n+  public void setSample(int x, int y, int b, double s)\n+  {\n+    sampleModel.setSample(x-sampleModelTranslateX,\n+\t\t\t  y-sampleModelTranslateY,\n+\t\t\t  b, s, dataBuffer);\n+  }\n+\n+  public void setSamples(int x, int y, int w, int h, int b,\n+\t\t\t int[] iArray)\n+  {\n+    sampleModel.setSamples(x-sampleModelTranslateX,\n+\t\t\t   y-sampleModelTranslateY,\n+\t\t\t   w, h, b, iArray, dataBuffer);\n+  }\n+\n+  public void setSamples(int x, int y, int w, int h, int b,\n+\t\t\t float[] fArray)\n+  {\n+    sampleModel.setSamples(x-sampleModelTranslateX,\n+\t\t\t   y-sampleModelTranslateY,\n+\t\t\t   w, h, b, fArray, dataBuffer);\n+  }\n+\n+  public void setSamples(int x, int y, int w, int h, int b,\n+\t\t\t double[] dArray)\n+  {\n+    sampleModel.setSamples(x-sampleModelTranslateX,\n+\t\t\t   y-sampleModelTranslateY,\n+\t\t\t   w, h, b, dArray, dataBuffer);\n+  }\n+}"}]}