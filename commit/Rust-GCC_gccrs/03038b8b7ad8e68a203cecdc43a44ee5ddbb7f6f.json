{"sha": "03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMwMzhiOGI3YWQ4ZTY4YTIwM2NlY2RjNDNhNDRlZTVkZGJiN2Y2Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-08-03T07:39:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-08-03T07:39:12Z"}, "message": "genmatch.c (struct sinfo, [...]): New hash-map to record equivalent transforms.\n\n2015-08-03  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (struct sinfo, struct sinfo_hashmap_traits, sinfo_map_t):\n\tNew hash-map to record equivalent transforms.\n\t(dt_node::analyze): Populate the equivalent transforms hash-map.\n\t(dt_simplify::info): Add reference to hash-map entry.\n\t(dt_simplify::gen): If we have split out a function for the\n\ttransform, generate a call to it.\n\t(sinfo_hashmap_traits::hash): New function.\n\t(compare_op): New helper function for ...\n\t(sinfo_hashmap_traits::equal_keys): ... this new function.\n\t(decision_tree::gen): Split out common equivalent transforms\n\tinto functions.\n\nFrom-SVN: r226490", "tree": {"sha": "4200f65c79eb8b2ac1763c11afa220d75f6f2931", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4200f65c79eb8b2ac1763c11afa220d75f6f2931"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c099d40da9eff21eea0606b7eb37e316d71c762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c099d40da9eff21eea0606b7eb37e316d71c762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c099d40da9eff21eea0606b7eb37e316d71c762"}], "stats": {"total": 228, "additions": 222, "deletions": 6}, "files": [{"sha": "3a3012a89e5ad8054ec5b1fdbdaae8014757c430", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f", "patch": "@@ -1,3 +1,17 @@\n+2015-08-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (struct sinfo, struct sinfo_hashmap_traits, sinfo_map_t):\n+\tNew hash-map to record equivalent transforms.\n+\t(dt_node::analyze): Populate the equivalent transforms hash-map.\n+\t(dt_simplify::info): Add reference to hash-map entry.\n+\t(dt_simplify::gen): If we have split out a function for the\n+\ttransform, generate a call to it.\n+\t(sinfo_hashmap_traits::hash): New function.\n+\t(compare_op): New helper function for ...\n+\t(sinfo_hashmap_traits::equal_keys): ... this new function.\n+\t(decision_tree::gen): Split out common equivalent transforms\n+\tinto functions.\n+\n 2015-08-03  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-fold.c (fold_gimple_assign): Remove folding of"}, {"sha": "a1bc410c39b3b3e558ded5477d67a15527b1f43a", "filename": "gcc/genmatch.c", "status": "modified", "additions": 208, "deletions": 6, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=03038b8b7ad8e68a203cecdc43a44ee5ddbb7f6f", "patch": "@@ -1220,6 +1220,29 @@ lower (vec<simplify *>& simplifiers, bool gimple)\n    matching code.  It represents the 'match' expression of all\n    simplifies and has those as its leafs.  */\n \n+struct dt_simplify;\n+\n+/* A hash-map collecting semantically equivalent leafs in the decision\n+   tree for splitting out to separate functions.  */\n+struct sinfo\n+{\n+  dt_simplify *s;\n+\n+  const char *fname;\n+  unsigned cnt;\n+};\n+\n+struct sinfo_hashmap_traits : simple_hashmap_traits <pointer_hash <dt_simplify> >\n+{\n+  static inline hashval_t hash (const key_type &);\n+  static inline bool equal_keys (const key_type &, const key_type &);\n+  template <typename T> static inline void remove (T &) {}\n+};\n+\n+typedef hash_map<void * /* unused */, sinfo *, sinfo_hashmap_traits>\n+  sinfo_map_t;\n+\n+\n /* Decision tree base class, used for DT_TRUE and DT_NODE.  */\n \n struct dt_node\n@@ -1250,7 +1273,7 @@ struct dt_node\n \t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_operand *>,\n \t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_node *>);\n \n-  void analyze ();\n+  void analyze (sinfo_map_t &);\n };\n \n /* Generic decision tree node used for DT_OPERAND and DT_MATCH.  */\n@@ -1285,10 +1308,11 @@ struct dt_simplify : public dt_node\n   simplify *s;\n   unsigned pattern_no;\n   dt_operand **indexes;\n+  sinfo *info;\n \n   dt_simplify (simplify *s_, unsigned pattern_no_, dt_operand **indexes_)\n \t: dt_node (DT_SIMPLIFY), s (s_), pattern_no (pattern_no_),\n-\t  indexes (indexes_)  {}\n+\t  indexes (indexes_), info (NULL)  {}\n \n   void gen_1 (FILE *, int, bool, operand *);\n   void gen (FILE *f, int, bool);\n@@ -1303,6 +1327,16 @@ is_a_helper <dt_operand *>::test (dt_node *n)\n \t  || n->type == dt_node::DT_MATCH);\n }\n \n+template<>\n+template<>\n+inline bool\n+is_a_helper <dt_simplify *>::test (dt_node *n)\n+{\n+  return n->type == dt_node::DT_SIMPLIFY;\n+}\n+\n+\n+\n /* A container for the actual decision tree.  */\n \n struct decision_tree\n@@ -1455,21 +1489,35 @@ dt_node::append_simplify (simplify *s, unsigned pattern_no,\n /* Analyze the node and its children.  */\n \n void\n-dt_node::analyze ()\n+dt_node::analyze (sinfo_map_t &map)\n {\n   num_leafs = 0;\n   total_size = 1;\n   max_level = level;\n \n   if (type == DT_SIMPLIFY)\n     {\n+      /* Populate the map of equivalent simplifies.  */\n+      dt_simplify *s = as_a <dt_simplify *> (this);\n+      bool existed;\n+      sinfo *&si = map.get_or_insert (s, &existed);\n+      if (!existed)\n+\t{\n+\t  si = new sinfo;\n+\t  si->s = s;\n+\t  si->cnt = 1;\n+\t  si->fname = NULL;\n+\t}\n+      else\n+\tsi->cnt++;\n+      s->info = si;\n       num_leafs = 1;\n       return;\n     }\n \n   for (unsigned i = 0; i < kids.length (); ++i)\n     {\n-      kids[i]->analyze ();\n+      kids[i]->analyze (map);\n       num_leafs += kids[i]->num_leafs;\n       total_size += kids[i]->total_size;\n       max_level = MAX (max_level, kids[i]->max_level);\n@@ -2986,25 +3034,179 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t\t\ti, indexes[i]->get_name (opname));\n       }\n \n-  gen_1 (f, indent, gimple, s->result);\n+  /* If we have a split-out function for the actual transform, call it.  */\n+  if (info && info->fname)\n+    {\n+      if (gimple)\n+\t{\n+\t  fprintf_indent (f, indent, \"if (%s (res_code, res_ops, seq, \"\n+\t\t\t  \"valueize, type, captures))\\n\", info->fname);\n+\t  fprintf_indent (f, indent, \"  return true;\\n\");\n+\t}\n+      else\n+\t{\n+\t  fprintf_indent (f, indent, \"tree res = %s (loc, type\",\n+\t\t\t  info->fname);\n+\t  for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n+\t    fprintf (f, \", op%d\", i);\n+\t  fprintf (f, \", captures);\\n\");\n+\t  fprintf_indent (f, indent, \"if (res) return res;\\n\");\n+\t}\n+    }\n+  else\n+    gen_1 (f, indent, gimple, s->result);\n \n   indent -= 2;\n   fprintf_indent (f, indent, \"}\\n\");\n }\n \n+\n+/* Hash function for finding equivalent transforms.  */\n+\n+hashval_t\n+sinfo_hashmap_traits::hash (const key_type &v)\n+{\n+  /* Only bother to compare those originating from the same source pattern.  */\n+  return v->s->result->location;\n+}\n+\n+/* Compare function for finding equivalent transforms.  */\n+\n+static bool\n+compare_op (operand *o1, simplify *s1, operand *o2, simplify *s2)\n+{\n+  if (o1->type != o2->type)\n+    return false;\n+\n+  switch (o1->type)\n+    {\n+    case operand::OP_IF:\n+      {\n+\tif_expr *if1 = as_a <if_expr *> (o1);\n+\tif_expr *if2 = as_a <if_expr *> (o2);\n+\t/* ???  Properly compare c-exprs.  */\n+\tif (if1->cond != if2->cond)\n+\t  return false;\n+\tif (!compare_op (if1->trueexpr, s1, if2->trueexpr, s2))\n+\t  return false;\n+\tif (if1->falseexpr != if2->falseexpr\n+\t    || (if1->falseexpr\n+\t\t&& !compare_op (if1->falseexpr, s1, if2->falseexpr, s2)))\n+\t  return false;\n+\treturn true;\n+      }\n+    case operand::OP_WITH:\n+      {\n+\twith_expr *with1 = as_a <with_expr *> (o1);\n+\twith_expr *with2 = as_a <with_expr *> (o2);\n+\tif (with1->with != with2->with)\n+\t  return false;\n+\treturn compare_op (with1->subexpr, s1, with2->subexpr, s2);\n+      }\n+    default:;\n+    }\n+\n+  /* We've hit a result.  Time to compare capture-infos - this is required\n+     in addition to the conservative pointer-equivalency of the result IL.  */\n+  capture_info cinfo1 (s1, o1, true);\n+  capture_info cinfo2 (s2, o2, true);\n+\n+  if (cinfo1.force_no_side_effects != cinfo2.force_no_side_effects\n+      || cinfo1.info.length () != cinfo2.info.length ())\n+    return false;\n+\n+  for (unsigned i = 0; i < cinfo1.info.length (); ++i)\n+    {\n+      if (cinfo1.info[i].expr_p != cinfo2.info[i].expr_p\n+\t  || cinfo1.info[i].cse_p != cinfo2.info[i].cse_p\n+\t  || (cinfo1.info[i].force_no_side_effects_p\n+\t      != cinfo2.info[i].force_no_side_effects_p)\n+\t  || cinfo1.info[i].force_single_use != cinfo2.info[i].force_single_use\n+\t  || cinfo1.info[i].cond_expr_cond_p != cinfo2.info[i].cond_expr_cond_p\n+\t  /* toplevel_msk is an optimization */\n+\t  || cinfo1.info[i].result_use_count != cinfo2.info[i].result_use_count\n+\t  || cinfo1.info[i].same_as != cinfo2.info[i].same_as\n+\t  /* the pointer back to the capture is for diagnostics only */)\n+\treturn false;\n+    }\n+\n+  /* ???  Deep-compare the actual result.  */\n+  return o1 == o2;\n+}\n+\n+bool\n+sinfo_hashmap_traits::equal_keys (const key_type &v,\n+\t\t\t\t  const key_type &candidate)\n+{\n+  return compare_op (v->s->result, v->s, candidate->s->result, candidate->s);\n+}\n+\n+\n /* Main entry to generate code for matching GIMPLE IL off the decision\n    tree.  */\n \n void\n decision_tree::gen (FILE *f, bool gimple)\n {\n-  root->analyze ();\n+  sinfo_map_t si;\n+\n+  root->analyze (si);\n \n   fprintf (stderr, \"%s decision tree has %u leafs, maximum depth %u and \"\n \t   \"a total number of %u nodes\\n\",\n \t   gimple ? \"GIMPLE\" : \"GENERIC\", \n \t   root->num_leafs, root->max_level, root->total_size);\n \n+  /* First split out the transform part of equal leafs.  */\n+  unsigned rcnt = 0;\n+  unsigned fcnt = 1;\n+  for (sinfo_map_t::iterator iter = si.begin ();\n+       iter != si.end (); ++iter)\n+    {\n+      sinfo *s = (*iter).second;\n+      /* Do not split out single uses.  */\n+      if (s->cnt <= 1)\n+\tcontinue;\n+\n+      rcnt += s->cnt - 1;\n+      if (verbose >= 1)\n+\t{\n+\t  fprintf (stderr, \"found %u uses of\", s->cnt);\n+\t  output_line_directive (stderr, s->s->s->result->location);\n+\t}\n+\n+      /* Generate a split out function with the leaf transform code.  */\n+      s->fname = xasprintf (\"%s_simplify_%u\", gimple ? \"gimple\" : \"generic\",\n+\t\t\t    fcnt++);\n+      if (gimple)\n+\tfprintf (f, \"\\nstatic bool\\n\"\n+\t\t \"%s (code_helper *res_code, tree *res_ops,\\n\"\n+\t\t \"                 gimple_seq *seq, tree (*valueize)(tree) \"\n+\t\t \"ATTRIBUTE_UNUSED,\\n\"\n+\t\t \"                 tree ARG_UNUSED (type), tree *ARG_UNUSED \"\n+\t\t \"(captures))\\n\",\n+\t\t s->fname);\n+      else\n+\t{\n+\t  fprintf (f, \"\\nstatic tree\\n\"\n+\t\t   \"%s (location_t ARG_UNUSED (loc), tree ARG_UNUSED (type),\\n\",\n+\t\t   (*iter).second->fname);\n+\t  for (unsigned i = 0;\n+\t       i < as_a <expr *>(s->s->s->match)->ops.length (); ++i)\n+\t    fprintf (f, \" tree ARG_UNUSED (op%d),\", i);\n+\t  fprintf (f, \" tree *captures)\\n\");\n+\t}\n+\n+      fprintf (f, \"{\\n\");\n+      s->s->gen_1 (f, 2, gimple, s->s->s->result);\n+      if (gimple)\n+\tfprintf (f, \"  return false;\\n\");\n+      else\n+\tfprintf (f, \"  return NULL_TREE;\\n\");\n+      fprintf (f, \"}\\n\");\n+    }\n+  fprintf (stderr, \"removed %u duplicate tails\\n\", rcnt);\n+\n   for (unsigned n = 1; n <= 3; ++n)\n     {\n       /* First generate split-out functions.  */"}]}