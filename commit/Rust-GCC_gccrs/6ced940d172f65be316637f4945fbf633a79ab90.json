{"sha": "6ced940d172f65be316637f4945fbf633a79ab90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlZDk0MGQxNzJmNjViZTMxNjYzN2Y0OTQ1ZmJmNjMzYTc5YWI5MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-25T12:23:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-25T12:23:08Z"}, "message": "ipa-inline.c (recursive_inlining): Redirect to master clone before testing profitability.\n\n\n\t* ipa-inline.c (recursive_inlining): Redirect to master\n\tclone before testing profitability.\n\nFrom-SVN: r192807", "tree": {"sha": "91eceb61ba434564a9cddbd2a5c553eea6e3c4d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91eceb61ba434564a9cddbd2a5c553eea6e3c4d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ced940d172f65be316637f4945fbf633a79ab90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ced940d172f65be316637f4945fbf633a79ab90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ced940d172f65be316637f4945fbf633a79ab90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ced940d172f65be316637f4945fbf633a79ab90/comments", "author": null, "committer": null, "parents": [{"sha": "43a8f1a1c3fdd9b629d0495a44b417012d756f99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a8f1a1c3fdd9b629d0495a44b417012d756f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a8f1a1c3fdd9b629d0495a44b417012d756f99"}], "stats": {"total": 36, "additions": 30, "deletions": 6}, "files": [{"sha": "0b8655292a86c789f9edb7e90ac1cc0496f3221b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ced940d172f65be316637f4945fbf633a79ab90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ced940d172f65be316637f4945fbf633a79ab90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ced940d172f65be316637f4945fbf633a79ab90", "patch": "@@ -1,3 +1,8 @@\n+2012-10-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (recursive_inlining): Redirect to master\n+\tclone before testing profitability.\n+\n 2012-10-25  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/54902"}, {"sha": "3f9a800b55d7ce854da9197d494331204f20f366", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ced940d172f65be316637f4945fbf633a79ab90/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ced940d172f65be316637f4945fbf633a79ab90/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=6ced940d172f65be316637f4945fbf633a79ab90", "patch": "@@ -1190,14 +1190,28 @@ recursive_inlining (struct cgraph_edge *edge,\n     {\n       struct cgraph_edge *curr\n \t= (struct cgraph_edge *) fibheap_extract_min (heap);\n-      struct cgraph_node *cnode;\n-\n-      if (estimate_size_after_inlining (node, curr) > limit)\n-\tbreak;\n+      struct cgraph_node *cnode, *dest = curr->callee;\n \n       if (!can_inline_edge_p (curr, true))\n \tcontinue;\n \n+      /* MASTER_CLONE is produced in the case we already started modified\n+\t the function. Be sure to redirect edge to the original body before\n+\t estimating growths otherwise we will be seeing growths after inlining\n+\t the already modified body.  */\n+      if (master_clone)\n+\t{\n+          cgraph_redirect_edge_callee (curr, master_clone);\n+          reset_edge_growth_cache (curr);\n+\t}\n+\n+      if (estimate_size_after_inlining (node, curr) > limit)\n+\t{\n+\t  cgraph_redirect_edge_callee (curr, dest);\n+\t  reset_edge_growth_cache (curr);\n+\t  break;\n+\t}\n+\n       depth = 1;\n       for (cnode = curr->caller;\n \t   cnode->global.inlined_to; cnode = cnode->callers->caller)\n@@ -1206,7 +1220,11 @@ recursive_inlining (struct cgraph_edge *edge,\n           depth++;\n \n       if (!want_inline_self_recursive_call_p (curr, node, false, depth))\n-\tcontinue;\n+\t{\n+\t  cgraph_redirect_edge_callee (curr, dest);\n+\t  reset_edge_growth_cache (curr);\n+\t  continue;\n+\t}\n \n       if (dump_file)\n \t{\n@@ -1228,9 +1246,10 @@ recursive_inlining (struct cgraph_edge *edge,\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      clone_inlined_nodes (e, true, false, NULL);\n+          cgraph_redirect_edge_callee (curr, master_clone);\n+          reset_edge_growth_cache (curr);\n \t}\n \n-      cgraph_redirect_edge_callee (curr, master_clone);\n       inline_call (curr, false, new_edges, &overall_size, true);\n       lookup_recursive_calls (node, curr->callee, heap);\n       n++;"}]}