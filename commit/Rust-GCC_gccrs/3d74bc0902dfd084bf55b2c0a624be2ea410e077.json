{"sha": "3d74bc0902dfd084bf55b2c0a624be2ea410e077", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q3NGJjMDkwMmRmZDA4NGJmNTViMmMwYTYyNGJlMmVhNDEwZTA3Nw==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2003-10-11T05:02:29Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2003-10-11T05:02:29Z"}, "message": "m68k-protos.h (use_return_insn): Change return type from int to bool.\n\n\t* config/m68k/m68k-protos.h (use_return_insn): Change return type from\n\tint to bool.\n\t* config/m68k/m68k.c (struct m68k_frame): Add funcdef_no member.\n\t(current_frame): New global var.\n\t(m68k_compute_frame_layout): Cache computations in current_frame.\n\t(m68k_initial_elimination_offset): Use values from current_frame\n\tinstead of recomputing them.\n\t(use_return_insn): Likewise.\n\t(m68k_output_function_prologue): Likewise.\n\t(m68k_output_function_epilogue): Likewise.\n\t* config/m68k/m68k.h (TARGET_CPU_CPP_PREDEFINES): Fold __PIC__ handling\n\tinside the block for __pic__.\n\nFrom-SVN: r72330", "tree": {"sha": "1e56e8bbde0226d11efe57747ccbd9cffd47c46d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e56e8bbde0226d11efe57747ccbd9cffd47c46d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d74bc0902dfd084bf55b2c0a624be2ea410e077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d74bc0902dfd084bf55b2c0a624be2ea410e077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d74bc0902dfd084bf55b2c0a624be2ea410e077", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d74bc0902dfd084bf55b2c0a624be2ea410e077/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d"}], "stats": {"total": 348, "additions": 166, "deletions": 182}, "files": [{"sha": "6ec5b3dc86cc833dce1151ea7c1509dafacd7ef6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d74bc0902dfd084bf55b2c0a624be2ea410e077/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d74bc0902dfd084bf55b2c0a624be2ea410e077/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d74bc0902dfd084bf55b2c0a624be2ea410e077", "patch": "@@ -1,3 +1,18 @@\n+2003-10-11  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* config/m68k/m68k-protos.h (use_return_insn): Change return type from\n+\tint to bool.\n+\t* config/m68k/m68k.c (struct m68k_frame): Add funcdef_no member.\n+\t(current_frame): New global var.\n+\t(m68k_compute_frame_layout): Cache computations in current_frame.\n+\t(m68k_initial_elimination_offset): Use values from current_frame\n+\tinstead of recomputing them.\n+\t(use_return_insn): Likewise.\n+\t(m68k_output_function_prologue): Likewise.\n+\t(m68k_output_function_epilogue): Likewise.\n+\t* config/m68k/m68k.h (TARGET_CPU_CPP_PREDEFINES): Fold __PIC__ handling\n+\tinside the block for __pic__.\n+\n 2003-10-11  Peter Barada <peter@baradas.org>\n \t    Bernardo Innocenti  <bernie@develer.com>\n "}, {"sha": "44cb68fe0a4ec6da0c4ded910542503f34049c4f", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d74bc0902dfd084bf55b2c0a624be2ea410e077/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d74bc0902dfd084bf55b2c0a624be2ea410e077/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=3d74bc0902dfd084bf55b2c0a624be2ea410e077", "patch": "@@ -65,6 +65,6 @@ extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n #endif /* RTX_CODE */\n \n extern int flags_in_68881 (void);\n-extern int use_return_insn (void);\n+extern bool use_return_insn (void);\n extern void override_options (void);\n extern void init_68881_table (void);"}, {"sha": "b4169b0ff134ba8dcc1c0f482ffb76bf2ad674de", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 150, "deletions": 181, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d74bc0902dfd084bf55b2c0a624be2ea410e077/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d74bc0902dfd084bf55b2c0a624be2ea410e077/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=3d74bc0902dfd084bf55b2c0a624be2ea410e077", "patch": "@@ -41,27 +41,41 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"debug.h\"\n-\n-/* Needed for use_return_insn.  */\n #include \"flags.h\"\n \n /* Structure describing stack frame layout. */\n-struct m68k_frame {\n+struct m68k_frame\n+{\n+  /* Stack pointer to frame pointer offset.  */\n   HOST_WIDE_INT offset;\n+\n+  /* Offset of FPU registers.  */\n+  HOST_WIDE_INT foffset;\n+\n+  /* Frame size in bytes (rounded up).  */\n   HOST_WIDE_INT size;\n-  /* data and address register */\n+\n+  /* Data and address register.  */\n   int reg_no;\n   unsigned int reg_mask;\n   unsigned int reg_rev_mask;\n-  /* fpu registers */\n+\n+  /* FPU registers.  */\n   int fpu_no;\n   unsigned int fpu_mask;\n   unsigned int fpu_rev_mask;\n-  /* offsets relative to ARG_POINTER.  */\n+\n+  /* Offsets relative to ARG_POINTER.  */\n   HOST_WIDE_INT frame_pointer_offset;\n   HOST_WIDE_INT stack_pointer_offset;\n+\n+  /* Function which the above information refers to.  */\n+  int funcdef_no;\n };\n \n+/* Current frame information calculated by m68k_compute_frame_layout().  */\n+static struct m68k_frame current_frame;\n+\n /* This flag is used to communicate between movhi and ASM_OUTPUT_CASE_END,\n    if SGS_SWITCH_TABLE.  */\n int switch_table_difference_label_flag;\n@@ -83,7 +97,7 @@ static bool m68k_interrupt_function_p (tree func);\n static tree m68k_handle_fndecl_attribute (tree *node, tree name,\n \t\t\t\t\t  tree args, int flags,\n \t\t\t\t\t  bool *no_add_attrs);\n-static void m68k_compute_frame_layout (struct m68k_frame *frame);\n+static void m68k_compute_frame_layout (void);\n static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);\n static int const_int_cost (rtx);\n static bool m68k_rtx_costs (rtx, int, int, int *);\n@@ -314,13 +328,19 @@ m68k_handle_fndecl_attribute (tree *node, tree name,\n }\n \n static void\n-m68k_compute_frame_layout (struct m68k_frame *frame)\n+m68k_compute_frame_layout (void)\n {\n   int regno, saved;\n   unsigned int mask, rmask;\n   bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n \n-  frame->size = (get_frame_size () + 3) & -4;\n+  /* Only compute the frame once per function.\n+     Don't cache information until reload has been completed.  */\n+  if (current_frame.funcdef_no == current_function_funcdef_no\n+      && reload_completed)\n+    return;\n+\n+  current_frame.size = (get_frame_size () + 3) & -4;\n \n   mask = rmask = saved = 0;\n   for (regno = 0; regno < 16; regno++)\n@@ -330,45 +350,47 @@ m68k_compute_frame_layout (struct m68k_frame *frame)\n \trmask |= 1 << (15 - regno);\n \tsaved++;\n       }\n-  frame->offset = saved * 4;\n-  frame->reg_no = saved;\n-  frame->reg_mask = mask;\n-  frame->reg_rev_mask = rmask;\n+  current_frame.offset = saved * 4;\n+  current_frame.reg_no = saved;\n+  current_frame.reg_mask = mask;\n+  current_frame.reg_rev_mask = rmask;\n \n   if (TARGET_68881 /* || TARGET_CFV4E */)\n     {\n       mask = rmask = saved = 0;\n       for (regno = 16; regno < 24; regno++)\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\n+\tif (m68k_save_reg (regno, interrupt_handler))\n \t  {\n \t    mask |= 1 << (23 - regno);\n \t    rmask |= 1 << (regno - 16);\n \t    saved++;\n \t  }\n-      frame->offset += saved * 12 /* (TARGET_CFV4E ? 8 : 12) */;\n-      frame->fpu_no = saved;\n-      frame->fpu_mask = mask;\n-      frame->fpu_rev_mask = rmask;\n+      current_frame.foffset = saved * 12 /* (TARGET_CFV4E ? 8 : 12) */;\n+      current_frame.offset += current_frame.foffset;\n+      current_frame.fpu_no = saved;\n+      current_frame.fpu_mask = mask;\n+      current_frame.fpu_rev_mask = rmask;\n     }\n+\n+  /* Remember what function this frame refers to.  */\n+  current_frame.funcdef_no = current_function_funcdef_no;\n }\n \n HOST_WIDE_INT\n m68k_initial_elimination_offset (int from, int to)\n {\n-  struct m68k_frame frame;\n-\n   /* FIXME: The correct offset to compute here would appear to be\n        (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n      but for some obscure reason, this must be 0 to get correct code.  */\n   if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n     return 0;\n \n-  m68k_compute_frame_layout (&frame);\n+  m68k_compute_frame_layout ();\n \n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return frame.offset + frame.size + (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n+    return current_frame.offset + current_frame.size + (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n   else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return frame.offset + frame.size;\n+    return current_frame.offset + current_frame.size;\n \n   abort();\n }\n@@ -434,48 +456,38 @@ m68k_save_reg (unsigned int regno, bool interrupt_handler)\n    of the order for movem!  */\n \n static void\n-m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n+m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  register int regno;\n-  register int mask = 0;\n   int num_saved_regs = 0;\n-  HOST_WIDE_INT fsize = (size + 3) & -4;\n   HOST_WIDE_INT fsize_with_regs;\n   HOST_WIDE_INT cfa_offset = INCOMING_FRAME_SP_OFFSET;\n-  bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n-  \n+\n+  m68k_compute_frame_layout();\n+\n   /* If the stack limit is a symbol, we can check it here,\n      before actually allocating the space.  */\n   if (current_function_limit_stack\n       && GET_CODE (stack_limit_rtx) == SYMBOL_REF)\n     {\n #if defined (MOTOROLA)\n       asm_fprintf (stream, \"\\tcmp.l %I%s+%wd,%Rsp\\n\\ttrapcs\\n\",\n-\t\t   XSTR (stack_limit_rtx, 0), fsize + 4);\n+\t\t   XSTR (stack_limit_rtx, 0), current_frame.size + 4);\n #else\n       asm_fprintf (stream, \"\\tcmpl %I%s+%wd,%Rsp\\n\\ttrapcs\\n\",\n-\t\t   XSTR (stack_limit_rtx, 0), fsize + 4);\n+\t\t   XSTR (stack_limit_rtx, 0), current_frame.size + 4);\n #endif\n     }\n \n-  if (TARGET_COLDFIRE)\n-    {\n-      /* on Coldfire add register save into initial stack frame setup, if possible */\n-      for (regno = 0; regno < 16; regno++)\n-        if (m68k_save_reg (regno, interrupt_handler))\n-          num_saved_regs++;\n-\n-      if (num_saved_regs <= 2)\n-        num_saved_regs = 0;\n-    }\n-  else\n-      num_saved_regs = 0;\n+  /* on Coldfire add register save into initial stack frame setup, if possible */\n+  num_saved_regs = 0;\n+  if (TARGET_COLDFIRE && current_frame.reg_no > 2)\n+    num_saved_regs = current_frame.reg_no;\n \n-  fsize_with_regs = fsize + num_saved_regs * 4;\n+  fsize_with_regs = current_frame.size + num_saved_regs * 4;\n   \n   if (frame_pointer_needed)\n     {\n-      if (fsize == 0 && TARGET_68040)\n+      if (current_frame.size == 0 && TARGET_68040)\n \t{\n \t/* on the 68040, pea + move is faster than link.w 0 */\n #ifdef MOTOROLA\n@@ -528,7 +540,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t  cfa_offset += 4;\n \t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM, -cfa_offset);\n \t  dwarf2out_def_cfa (l, FRAME_POINTER_REGNUM, cfa_offset);\n-\t  cfa_offset += fsize;\n+\t  cfa_offset += current_frame.size;\n \t}\n     }\n   else if (fsize_with_regs) /* !frame_pointer_needed */\n@@ -599,51 +611,35 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t}\n       if (dwarf2out_do_frame ())\n \t{\n-\t  cfa_offset += fsize + 4;\n+\t  cfa_offset += current_frame.size + 4;\n \t  dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, cfa_offset);\n \t}\n     } /* !frame_pointer_needed */\n \n-  num_saved_regs = 0;\n-\n   if (TARGET_68881)\n     {\n-      for (regno = 16; regno < 24; regno++)\n-\tif (m68k_save_reg (regno, interrupt_handler))\n-\t  {\n-\t    mask |= 1 << (regno - 16);\n-\t    num_saved_regs++;\n-\t  }\n-      if ((mask & 0xff) != 0)\n+      if (current_frame.fpu_mask)\n \t{\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tfmovm %I0x%x,-(%Rsp)\\n\", mask & 0xff);\n+\t  asm_fprintf (stream, \"\\tfmovm %I0x%x,-(%Rsp)\\n\", current_frame.fpu_mask);\n #else\n-\t  asm_fprintf (stream, \"\\tfmovem %I0x%x,%Rsp@-\\n\", mask & 0xff);\n+\t  asm_fprintf (stream, \"\\tfmovem %I0x%x,%Rsp@-\\n\", current_frmae.fpu_mask);\n #endif\n \t  if (dwarf2out_do_frame ())\n \t    {\n \t      char *l = (char *) dwarf2out_cfi_label ();\n-\t      int n_regs;\n+\t      int n_regs, regno;\n \n-\t      cfa_offset += num_saved_regs * 12;\n+\t      cfa_offset += current_frame.fpu_no * 12;\n \t      if (! frame_pointer_needed)\n \t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n \t      for (regno = 16, n_regs = 0; regno < 24; regno++)\n-\t\tif (mask & (1 << (regno - 16)))\n+\t\tif (current_frame.fpu_mask & (1 << (regno - 16)))\n \t\t  dwarf2out_reg_save (l, regno,\n \t\t\t\t      -cfa_offset + n_regs++ * 12);\n \t    }\n \t}\n-      mask = 0;\n-      num_saved_regs = 0;\n     }\n-  for (regno = 0; regno < 16; regno++)\n-    if (m68k_save_reg (regno, interrupt_handler))\n-      {\n-        mask |= 1 << (15 - regno);\n-        num_saved_regs++;\n-      }\n \n   /* If the stack limit is not a symbol, check it here.  \n      This has the disadvantage that it may be too late...  */\n@@ -672,9 +668,8 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \n       int i;\n \n-      /* Undo the work from above.  */\n-      for (i = 0; i< 16; i++)\n-        if (mask & (1 << i))\n+      for (i = 0; i < 16; i++)\n+        if (current_frame.reg_rev_mask & (1 << i))\n \t  {\n \t    asm_fprintf (stream,\n #ifdef MOTOROLA\n@@ -694,49 +689,40 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t      }\n \t  }\n     }\n-  else if (mask)\n+  else if (current_frame.reg_rev_mask)\n     {\n       if (TARGET_COLDFIRE)\n \t{\n-\t  /* The coldfire does not support the predecrement form of the \n-\t     movml instruction, so we must adjust the stack pointer and\n-\t     then use the plain address register indirect mode.  We also\n-\t     have to invert the register save mask to use the new mode.\n-\n+\t  /* The ColdFire does not support the predecrement form of the \n+\t     MOVEM instruction, so we must adjust the stack pointer and\n+\t     then use the plain address register indirect mode.\n \t     The required register save space was combined earlier with\n-\t     the fsize amount.  Don't add it again.  */\n-\t     \n-\t  int newmask = 0;\n-\t  int i;\n-\n-\t  for (i = 0; i < 16; i++)\n-\t    if (mask & (1 << i))\n-\t\tnewmask |= (1 << (15-i));\n+\t     the fsize_with_regs amount.  */\n \n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tmovm.l %I0x%x,(%Rsp)\\n\", newmask);\n+\t  asm_fprintf (stream, \"\\tmovm.l %I0x%x,(%Rsp)\\n\", current_frame.reg_mask);\n #else\n-\t  asm_fprintf (stream, \"\\tmoveml %I0x%x,%Rsp@\\n\", newmask);\n+\t  asm_fprintf (stream, \"\\tmoveml %I0x%x,%Rsp@\\n\", current_frame.reg_mask);\n #endif\n \t}\n       else\n \t{\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tmovm.l %I0x%x,-(%Rsp)\\n\", mask);\n+\t  asm_fprintf (stream, \"\\tmovm.l %I0x%x,-(%Rsp)\\n\", current_frame.reg_mask);\n #else\n-\t  asm_fprintf (stream, \"\\tmoveml %I0x%x,%Rsp@-\\n\", mask);\n+\t  asm_fprintf (stream, \"\\tmoveml %I0x%x,%Rsp@-\\n\", current_frame.reg_mask);\n #endif\n \t}\n       if (dwarf2out_do_frame ())\n \t{\n \t  char *l = (char *) dwarf2out_cfi_label ();\n-\t  int n_regs;\n+\t  int n_regs, regno;\n \n-\t  cfa_offset += num_saved_regs * 4;\n+\t  cfa_offset += current_frame.reg_no * 4;\n \t  if (! frame_pointer_needed)\n \t    dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n \t  for (regno = 0, n_regs = 0; regno < 16; regno++)\n-\t    if (mask & (1 << (15 - regno)))\n+\t    if (current_frame.reg_mask & (1 << regno))\n \t      dwarf2out_reg_save (l, regno,\n \t\t\t\t  -cfa_offset + n_regs++ * 4);\n \t}\n@@ -770,22 +756,16 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \f\n /* Return true if this function's epilogue can be output as RTL.  */\n \n-int\n-use_return_insn ()\n+bool\n+use_return_insn (void)\n {\n-  int regno;\n-  bool interrupt_handler;\n-\n   if (!reload_completed || frame_pointer_needed || get_frame_size () != 0)\n-    return 0;\n-  \n-  interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (m68k_save_reg (regno, interrupt_handler))\n-      return 0;\n+    return false;\n \n-  return 1;\n+  /* We can output the epilogue as RTL only if no registers need to be\n+     restored.  */\n+  m68k_compute_frame_layout();\n+  return current_frame.reg_no ? false : true;\n }\n \n /* This function generates the assembly code for function exit,\n@@ -797,19 +777,15 @@ use_return_insn ()\n    omit stack adjustments before returning.  */\n \n static void\n-m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n+m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  register int regno;\n-  register int mask, fmask;\n-  register int nregs;\n-  HOST_WIDE_INT offset, foffset;\n-  HOST_WIDE_INT fsize = (size + 3) & -4;\n-  HOST_WIDE_INT fsize_with_regs;\n-  int big = 0;\n+  HOST_WIDE_INT fsize, fsize_with_regs;\n+  bool big = false;\n+  bool restore_from_sp = false;\n   rtx insn = get_last_insn ();\n-  int restore_from_sp = 0;\n-  bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n-  \n+\n+  m68k_compute_frame_layout();\n+\n   /* If the last insn was a BARRIER, we don't have to write any code.  */\n   if (GET_CODE (insn) == NOTE)\n     insn = prev_nonnote_insn (insn);\n@@ -824,25 +800,9 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n #ifdef FUNCTION_EXTRA_EPILOGUE\n   FUNCTION_EXTRA_EPILOGUE (stream, size);\n #endif\n-  nregs = 0;  fmask = 0;\n-  if (TARGET_68881)\n-    {\n-      for (regno = 16; regno < 24; regno++)\n-\tif (m68k_save_reg (regno, interrupt_handler))\n-\t  {\n-\t    nregs++;\n-\t    fmask |= 1 << (23 - regno);\n-\t  }\n-    }\n-  foffset = nregs * 12;\n-  nregs = 0;  mask = 0;\n-  for (regno = 0; regno < 16; regno++)\n-    if (m68k_save_reg (regno, interrupt_handler))\n-      {\n-        nregs++;\n-\tmask |= 1 << regno;\n-      }\n-  offset = foffset + nregs * 4;\n+\n+  fsize = current_frame.size;\n+\n   /* FIXME : leaf_function_p below is too strong.\n      What we really need to know there is if there could be pending\n      stack adjustment needed at that point.  */\n@@ -858,21 +818,23 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n      after restoring registers. When the frame pointer isn't used,\n      we can merge movem adjustment into frame unlinking\n      made immediately after it. */\n-  if (TARGET_COLDFIRE && restore_from_sp && (nregs > 2))\n-    fsize_with_regs += nregs * 4;\n+  if (TARGET_COLDFIRE && restore_from_sp && (current_frame.reg_no > 2))\n+    fsize_with_regs += current_frame.reg_no * 4;\n \n-  if (offset + fsize >= 0x8000\n+  if (current_frame.offset + fsize >= 0x8000\n       && ! restore_from_sp\n-      && (mask || fmask))\n+      && (current_frame.reg_mask || current_frame.fpu_mask))\n     {\n       /* Because the ColdFire doesn't support moveml with\n          complex address modes we make an extra correction here */\n       if (TARGET_COLDFIRE)\n         {\n #ifdef MOTOROLA\n-          asm_fprintf (stream, \"\\t%Omove.l %I%d,%Ra1\\n\", -fsize - offset);\n+          asm_fprintf (stream, \"\\t%Omove.l %I%d,%Ra1\\n\",\n+\t\t       -fsize - current_frame.offset);\n #else\n-          asm_fprintf (stream, \"\\tmovel %I%d,%Ra1\\n\", -fsize - offset);\n+          asm_fprintf (stream, \"\\tmovel %I%d,%Ra1\\n\",\n+\t\t       -fsize - current_frame.offset);\n #endif\n         }\n       else\n@@ -884,32 +846,32 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n #endif\n         }\n \n-      fsize = 0, big = 1;\n+      fsize = 0, big = true;\n     }\n-  if (nregs <= 2)\n+  if (current_frame.reg_no <= 2)\n     {\n       /* Restore each separately in the same order moveml does.\n          Using two movel instructions instead of a single moveml\n          is about 15% faster for the 68020 and 68030 at no expense\n          in code size.  */\n \n       int i;\n+      HOST_WIDE_INT offset = current_frame.offset + fsize;\n \n-      /* Undo the work from above.  */\n-      for (i = 0; i< 16; i++)\n-        if (mask & (1 << i))\n+      for (i = 0; i < 16; i++)\n+        if (current_frame.reg_mask & (1 << i))\n           {\n             if (big)\n \t      {\n #ifdef MOTOROLA\n \t\tasm_fprintf (stream, \"\\t%Omove.l -%wd(%s,%Ra1.l),%s\\n\",\n-\t\t\t     offset + fsize,\n+\t\t\t     offset,\n \t\t\t     reg_names[FRAME_POINTER_REGNUM],\n \t\t\t     reg_names[i]);\n #else\n \t\tasm_fprintf (stream, \"\\tmovel %s@(-%wd,%Ra1:l),%s\\n\",\n \t\t\t     reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t     offset + fsize, reg_names[i]);\n+\t\t\t     offset);\n #endif\n \t      }\n             else if (restore_from_sp)\n@@ -926,19 +888,20 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t      {\n #ifdef MOTOROLA\n \t\tasm_fprintf (stream, \"\\t%Omove.l -%wd(%s),%s\\n\",\n-\t\t\t     offset + fsize,\n+\t\t\t     offset,\n \t\t\t     reg_names[FRAME_POINTER_REGNUM],\n \t\t\t     reg_names[i]);\n #else\n \t\tasm_fprintf (stream, \"\\tmovel %s@(-%wd),%s\\n\",\n \t\t\t     reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t     offset + fsize, reg_names[i]);\n+\t\t\t     offset,\n+\t\t\t     reg_names[i]);\n #endif\n \t      }\n-            offset = offset - 4;\n+            offset -= 4;\n           }\n     }\n-  else if (mask)\n+  else if (current_frame.reg_mask)\n     {\n       /* The ColdFire requires special handling due to its limited moveml insn */\n       if (TARGET_COLDFIRE)\n@@ -947,31 +910,32 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n             {\n #ifdef MOTOROLA\n               asm_fprintf (stream, \"\\tadd.l %s,%Ra1\\n\", reg_names[FRAME_POINTER_REGNUM]);\n-              asm_fprintf (stream, \"\\tmovm.l (%Ra1),%I0x%x\\n\", mask);\n+              asm_fprintf (stream, \"\\tmovm.l (%Ra1),%I0x%x\\n\", current_frame.reg_mask);\n #else\n               asm_fprintf (stream, \"\\taddl %s,%Ra1\\n\", reg_names[FRAME_POINTER_REGNUM]);\n-              asm_fprintf (stream, \"\\tmoveml %Ra1@,%I0x%x\\n\", mask);\n+              asm_fprintf (stream, \"\\tmoveml %Ra1@,%I0x%x\\n\", current_frame.reg_mask);\n #endif\n \t     }\n \t   else if (restore_from_sp)\n \t     {\n #ifdef MOTOROLA\n-\t       asm_fprintf (stream, \"\\tmovm.l (%Rsp),%I0x%x\\n\", mask);\n+\t       asm_fprintf (stream, \"\\tmovm.l (%Rsp),%I0x%x\\n\", current_frame.reg_mask);\n #else\n-\t       asm_fprintf (stream, \"\\tmoveml %Rsp@,%I0x%x\\n\", mask);\n+\t       asm_fprintf (stream, \"\\tmoveml %Rsp@,%I0x%x\\n\", current_frame.reg_mask);\n #endif\n             }\n           else\n             {\n #ifdef MOTOROLA\n               asm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n-                           offset + fsize,\n+                           current_frame.offset + fsize,\n                            reg_names[FRAME_POINTER_REGNUM],\n-                           mask);\n+                           current_frame.reg_mask);\n #else\n               asm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n                            reg_names[FRAME_POINTER_REGNUM],\n-                           offset + fsize, mask);\n+                           offset + fsize,\n+\t\t\t   current_frame.reg_mask);\n #endif\n \t    }\n         }\n@@ -981,72 +945,80 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t    {\n #ifdef MOTOROLA\n \t      asm_fprintf (stream, \"\\tmovm.l -%wd(%s,%Ra1.l),%I0x%x\\n\",\n-\t\t\t   offset + fsize,\n+\t\t\t   current_frame.offset + fsize,\n \t\t\t   reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t   mask);\n+\t\t\t   current_frame.reg_mask);\n #else\n \t      asm_fprintf (stream, \"\\tmoveml %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n \t\t\t   reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t   offset + fsize, mask);\n+\t\t\t   current_frame.offset + fsize,\n+\t\t\t   current_frame.reg_mask);\n #endif\n \t    }\n \t  else if (restore_from_sp)\n \t    {\n #ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tmovm.l (%Rsp)+,%I0x%x\\n\", mask);\n+\t      asm_fprintf (stream, \"\\tmovm.l (%Rsp)+,%I0x%x\\n\",\n+\t\t\t   current_frame.reg_mask);\n #else\n-\t      asm_fprintf (stream, \"\\tmoveml %Rsp@+,%I0x%x\\n\", mask);\n+\t      asm_fprintf (stream, \"\\tmoveml %Rsp@+,%I0x%x\\n\",\n+\t\t\t   current_frame.reg_mask);\n #endif\n \t    }\n \t  else\n \t    {\n #ifdef MOTOROLA\n \t      asm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n-\t\t\t   offset + fsize,\n+\t\t\t   current_frame.offset + fsize,\n \t\t\t   reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t   mask);\n+\t\t\t   current_frame.reg_mask);\n #else\n \t      asm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n \t\t\t   reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t   offset + fsize, mask);\n+\t\t\t   current_frame.offset + fsize,\n+\t\t\t   current_frame.reg_mask);\n #endif\n \t    }\n \t}\n     }\n-  if (fmask)\n+  if (current_frame.fpu_rev_mask)\n     {\n       if (big)\n \t{\n #ifdef MOTOROLA\n \t  asm_fprintf (stream, \"\\tfmovm -%wd(%s,%Ra1.l),%I0x%x\\n\",\n-\t\t       foffset + fsize,\n+\t\t       current_frame.foffset + fsize,\n \t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       fmask);\n+\t\t       current_frame.fpu_rev_mask);\n #else\n \t  asm_fprintf (stream, \"\\tfmovem %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n \t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       foffset + fsize, fmask);\n+\t\t       current_frame.foffset + fsize,\n+\t\t       current_frame.fpu_rev_mask);\n #endif\n \t}\n       else if (restore_from_sp)\n \t{\n #ifdef MOTOROLA\n-\t  asm_fprintf (stream, \"\\tfmovm (%Rsp)+,%I0x%x\\n\", fmask);\n+\t  asm_fprintf (stream, \"\\tfmovm (%Rsp)+,%I0x%x\\n\",\n+\t\t       current_frame.fpu_rev_mask);\n #else\n-\t  asm_fprintf (stream, \"\\tfmovem %Rsp@+,%I0x%x\\n\", fmask);\n+\t  asm_fprintf (stream, \"\\tfmovem %Rsp@+,%I0x%x\\n\",\n+\t\t       current_frame.fpu_rev_mask);\n #endif\n \t}\n       else\n \t{\n #ifdef MOTOROLA\n \t  asm_fprintf (stream, \"\\tfmovm -%wd(%s),%I0x%x\\n\",\n-\t\t       foffset + fsize,\n+\t\t       current_frame.foffset + fsize,\n \t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       fmask);\n+\t\t       current_frame.fpu_mask);\n #else\n \t  asm_fprintf (stream, \"\\tfmovem %s@(-%wd),%I0x%x\\n\",\n \t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       foffset + fsize, fmask);\n+\t\t       current_frame.foffset + fsize,\n+\t\t       current_frame.fpu_rev_mask);\n #endif\n \t}\n     }\n@@ -1078,7 +1050,6 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t{\n \t  /* On the CPU32 it is faster to use two addqw instructions to\n \t     add a small integer (8 < N <= 16) to a register.  */\n-\t  /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n \t  asm_fprintf (stream, \"\\taddq.w %I8,%Rsp\\n\\taddq.w %I%wd,%Rsp\\n\",\n \t\t       fsize_with_regs - 8);\n@@ -1091,7 +1062,6 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t{\n \t  if (TARGET_68040)\n \t    { \n-\t      /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n \t      asm_fprintf (stream, \"\\tadd.w %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n@@ -1109,7 +1079,6 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t}\n       else\n \t{\n-\t/* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n \t  asm_fprintf (stream, \"\\tadd.l %I%wd,%Rsp\\n\", fsize_with_regs);\n #else\n@@ -1125,7 +1094,7 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n       asm_fprintf (stream, \"\\taddl %Ra0,%Rsp\\n\");\n #endif\n     }\n-  if (interrupt_handler)\n+  if (m68k_interrupt_function_p (current_function_decl))\n     fprintf (stream, \"\\trte\\n\");\n   else if (current_function_pops_args)\n     asm_fprintf (stream, \"\\trtd %I%d\\n\", current_function_pops_args);"}]}