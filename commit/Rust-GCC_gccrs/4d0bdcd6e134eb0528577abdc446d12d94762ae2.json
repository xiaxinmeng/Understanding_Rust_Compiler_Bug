{"sha": "4d0bdcd6e134eb0528577abdc446d12d94762ae2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQwYmRjZDZlMTM0ZWIwNTI4NTc3YWJkYzQ0NmQxMmQ5NDc2MmFlMg==", "commit": {"author": {"name": "Stefan Olsson", "email": "stefan@xapa.se", "date": "2004-02-18T01:21:10Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-02-18T01:21:10Z"}, "message": "mt_allocator.h: Removed the last pointer.\n\n\n2004-02-17  Stefan Olsson  <stefan@xapa.se>\n\n\t* include/ext/mt_allocator.h: Removed the last\n\tpointer. Deallocated blocks are now added to the front of\n\tfreelists as proposed by Felix Yen.  This gives roughly 10%\n\tperformance boost and saves some memory.\n\t* docs/html/ext/mt_allocator.html: Change due to that deallocated\n\tblocks now are added to the front of freelists. The reason to this\n\tapproach is also explained.\n\nFrom-SVN: r78009", "tree": {"sha": "4a754aed3c8e6917cd84c2b2fcf60a1c79ca3846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a754aed3c8e6917cd84c2b2fcf60a1c79ca3846"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d0bdcd6e134eb0528577abdc446d12d94762ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0bdcd6e134eb0528577abdc446d12d94762ae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d0bdcd6e134eb0528577abdc446d12d94762ae2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0bdcd6e134eb0528577abdc446d12d94762ae2/comments", "author": {"login": "xapasnon", "id": 43848043, "node_id": "MDQ6VXNlcjQzODQ4MDQz", "avatar_url": "https://avatars.githubusercontent.com/u/43848043?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xapasnon", "html_url": "https://github.com/xapasnon", "followers_url": "https://api.github.com/users/xapasnon/followers", "following_url": "https://api.github.com/users/xapasnon/following{/other_user}", "gists_url": "https://api.github.com/users/xapasnon/gists{/gist_id}", "starred_url": "https://api.github.com/users/xapasnon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xapasnon/subscriptions", "organizations_url": "https://api.github.com/users/xapasnon/orgs", "repos_url": "https://api.github.com/users/xapasnon/repos", "events_url": "https://api.github.com/users/xapasnon/events{/privacy}", "received_events_url": "https://api.github.com/users/xapasnon/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8b58e56c5d1247c6304caace64473ea278283de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b58e56c5d1247c6304caace64473ea278283de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8b58e56c5d1247c6304caace64473ea278283de"}], "stats": {"total": 122, "additions": 69, "deletions": 53}, "files": [{"sha": "c40c080d64fa574813b6d41a991972694074a679", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0bdcd6e134eb0528577abdc446d12d94762ae2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0bdcd6e134eb0528577abdc446d12d94762ae2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4d0bdcd6e134eb0528577abdc446d12d94762ae2", "patch": "@@ -1,3 +1,13 @@\n+2004-02-17  Stefan Olsson  <stefan@xapa.se>\n+\n+\t* include/ext/mt_allocator.h: Removed the last\n+\tpointer. Deallocated blocks are now added to the front of\n+\tfreelists as proposed by Felix Yen.  This gives roughly 10%\n+\tperformance boost and saves some memory.\n+\t* docs/html/ext/mt_allocator.html: Change due to that deallocated\n+\tblocks now are added to the front of freelists. The reason to this\n+\tapproach is also explained.\n+        \n 2004-02-17  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float,"}, {"sha": "e806395d9ad9aa983ba1af7849022309d0ab85ea", "filename": "libstdc++-v3/docs/html/ext/mt_allocator.html", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0bdcd6e134eb0528577abdc446d12d94762ae2/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fmt_allocator.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0bdcd6e134eb0528577abdc446d12d94762ae2/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fmt_allocator.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fmt_allocator.html?ref=4d0bdcd6e134eb0528577abdc446d12d94762ae2", "patch": "@@ -107,8 +107,6 @@ <h3 class=\"left\">\n       This holds the pointer to the first free block for each thread in this\n       bin. I.e., if we would like to know where the first free block of size 32\n       for thread number 3 is we would look this up by: _S_bin[ 5 ].first[ 3 ]\n-    - bin_record->last = See above, the only difference being that this points\n-      to the last record on the same freelist.\n \n     The above created block_record pointers members are now initialized to \n     their initial values. I.e. _S_bin[ n ].first[ n ] = NULL;\n@@ -196,9 +194,9 @@ <h3 class=\"left\">\n |                |  |\n +----------------+  |\n +----------------+  |\n-| next*          |<-+  (If next == NULL it's the last one on the list and\n-|                |      then the _S_bin[ 3 ].last[ 3 ] pointer points to\n-|                |      here as well)\n+| next*          |<-+  (If next == NULL it's the last one on the list)\n+|                |\n+|                |\n |                |\n +----------------+\n | thread_id = 3  |\n@@ -242,16 +240,21 @@ <h3 class=\"left\">\n system and build us a freelist within this memory. All requests for new memory\n is made in chunks of _S_chunk_size. Knowing the size of a block_record and \n the bytes that this bin stores we then calculate how many blocks we can create \n-within this chunk, build the list, remove the first block, update the pointers\n-(_S_bin[ bin ].first[ 0 ] and _S_bin[ bin ].last[ 0 ]) and return a pointer \n-to that blocks data. \n+within this chunk, build the list, remove the first block, update the pointer\n+(_S_bin[ bin ].first[ 0 ]) and return a pointer to that blocks data. \n </p>\n \n <p>\n Deallocation is equally simple; the pointer is casted back to a block_record\n-pointer, lookup which bin to use based on the size, add the block to the end \n-of the global freelist (with the next pointer set to NULL) and update the \n-pointers as needed (_S_bin[ bin ].first[ 0 ] and _S_bin[ bin ].last[ 0 ]).\n+pointer, lookup which bin to use based on the size, add the block to the front \n+of the global freelist and update the pointer as needed \n+(_S_bin[ bin ].first[ 0 ]).\n+</p>\n+\n+<p>\n+The decision to add deallocated blocks to the front of the freelist was made\n+after a set of performance measurements that showed that this is roughly 10%\n+faster than maintaining a set of \"last pointers\" as well.\n </p>\n \n <h3 class=\"left\">\n@@ -350,7 +353,7 @@ <h3 class=\"left\">\n \n <p>\n The basic process of a deallocation call is simple: always add the\n-block to the end of the current threads freelist and update the\n+block to the front of the current threads freelist and update the\n counters and pointers (as described earlier with the specific check of\n ownership that causes the used counter of the thread that originally\n allocated the block to be decreased instead of the current threads"}, {"sha": "ac66e3ddab5122cbb52f023da12f0daf14932630", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0bdcd6e134eb0528577abdc446d12d94762ae2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0bdcd6e134eb0528577abdc446d12d94762ae2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=4d0bdcd6e134eb0528577abdc446d12d94762ae2", "patch": "@@ -197,12 +197,11 @@ namespace __gnu_cxx\n       struct bin_record\n       {\n         /*\n-         * An \"array\" of pointers to the first/last free block for each\n-         * thread id. Memory to these \"arrays\" is allocated in _S_init()\n+         * An \"array\" of pointers to the first free block for each\n+         * thread id. Memory to this \"array\" is allocated in _S_init()\n          * for _S_max_threads + global pool 0.\n          */\n         block_record** volatile first;\n-        block_record** volatile last;\n \n         /*\n          * An \"array\" of counters used to keep track of the amount of blocks\n@@ -336,35 +335,40 @@ namespace __gnu_cxx\n \n                     block->next = NULL;\n                     block->thread_id = thread_id;\n-                    _S_bin[bin].last[thread_id] = block;\n                   }\n                 else\n                   {\n                     size_t global_count = 0;\n \n+                    block_record* tmp;\n+\n                     while( _S_bin[bin].first[0] != NULL &&\n                            global_count < block_count )\n                       {\n+                        tmp = _S_bin[bin].first[0]->next;\n+\n                         block = _S_bin[bin].first[0];\n \n                         if (_S_bin[bin].first[thread_id] == NULL)\n-                          _S_bin[bin].first[thread_id] = block;\n+                          {\n+                            _S_bin[bin].first[thread_id] = block;\n+                            block->next = NULL;\n+                          }\n                         else\n-                          _S_bin[bin].last[thread_id]->next = block;\n-\n-                        _S_bin[bin].last[thread_id] = block;\n+                          {\n+                            block->next = _S_bin[bin].first[thread_id];\n+                            _S_bin[bin].first[thread_id] = block;\n+                          }\n \n                         block->thread_id = thread_id;\n \n                         _S_bin[bin].free[thread_id]++;\n \n-                        _S_bin[bin].first[0] = _S_bin[bin].first[0]->next;\n+                        _S_bin[bin].first[0] = tmp;\n \n                         global_count++;\n                       }\n \n-                    block->next = NULL;\n-\n                     __gthread_mutex_unlock(_S_bin[bin].mutex);\n                   }\n \n@@ -404,7 +408,6 @@ namespace __gnu_cxx\n                   }\n \n                 block->next = NULL;\n-                _S_bin[bin].last[0] = block;\n \n                 block = _S_bin[bin].first[0];\n \n@@ -464,12 +467,6 @@ namespace __gnu_cxx\n         block_record* block = (block_record*)((char*)__p\n                                              - sizeof(block_record));\n \n-        /*\n-         * This block will always be at the back of a list and thus\n-         * we set its next pointer to NULL.\n-         */\n-        block->next = NULL;\n-\n #ifdef __GTHREADS\n         if (__gthread_active_p())\n           {\n@@ -491,25 +488,30 @@ namespace __gnu_cxx\n               {\n                 __gthread_mutex_lock(_S_bin[bin].mutex);\n \n+                block_record* tmp;\n+\n                 while (remove > 0)\n                   {\n+                    tmp = _S_bin[bin].first[thread_id]->next;\n+\n                     if (_S_bin[bin].first[0] == NULL)\n-                      _S_bin[bin].first[0] = _S_bin[bin].first[thread_id];\n+                      {\n+                        _S_bin[bin].first[0] = _S_bin[bin].first[thread_id];\n+                        _S_bin[bin].first[0]->next = NULL;\n+                      }\n                     else\n-                      _S_bin[bin].last[0]->next = _S_bin[bin].first[thread_id];\n-\n-                    _S_bin[bin].last[0] = _S_bin[bin].first[thread_id];\n+                      {\n+                        _S_bin[bin].first[thread_id]->next = _S_bin[bin].first[0];\n+                        _S_bin[bin].first[0] = _S_bin[bin].first[thread_id];\n+                      }\n \n-                    _S_bin[bin].first[thread_id] =\n-                      _S_bin[bin].first[thread_id]->next;\n+                    _S_bin[bin].first[thread_id] = tmp;\n \n                     _S_bin[bin].free[thread_id]--;\n \n                     remove--;\n                   }\n \n-                _S_bin[bin].last[0]->next = NULL;\n-\n                 __gthread_mutex_unlock(_S_bin[bin].mutex);\n               }\n \n@@ -518,11 +520,15 @@ namespace __gnu_cxx\n              * counters and owner id as needed\n              */\n             if (_S_bin[bin].first[thread_id] == NULL)\n-              _S_bin[bin].first[thread_id] = block;\n+              {\n+                _S_bin[bin].first[thread_id] = block;\n+                block->next = NULL;\n+              }\n             else\n-              _S_bin[bin].last[thread_id]->next = block;\n-\n-            _S_bin[bin].last[thread_id] = block;\n+              {\n+                block->next = _S_bin[bin].first[thread_id];\n+                _S_bin[bin].first[thread_id] = block;\n+              }\n \n             _S_bin[bin].free[thread_id]++;\n \n@@ -541,11 +547,15 @@ namespace __gnu_cxx\n              * Single threaded application - return to global pool\n              */\n             if (_S_bin[bin].first[0] == NULL)\n-              _S_bin[bin].first[0] = block;\n+              {\n+                _S_bin[bin].first[0] = block;\n+                block->next = NULL;\n+              }\n             else\n-              _S_bin[bin].last[0]->next = block;\n-\n-            _S_bin[bin].last[0] = block;\n+              {\n+                block->next = _S_bin[bin].first[0];\n+                _S_bin[bin].first[0] = block;\n+              }\n           }\n       }\n     };\n@@ -669,12 +679,6 @@ namespace __gnu_cxx\n           if (!_S_bin[bin].first)\n             std::__throw_bad_alloc();\n \n-          _S_bin[bin].last = static_cast<block_record**>(::operator \n-            new(sizeof(block_record*) * __n));\n-\n-          if (!_S_bin[bin].last)\n-            std::__throw_bad_alloc();\n-\n #ifdef __GTHREADS\n           if (__gthread_active_p())\n             {\n@@ -708,7 +712,6 @@ namespace __gnu_cxx\n           for (size_t thread = 0; thread < __n; thread++)\n             {\n               _S_bin[bin].first[thread] = NULL;\n-              _S_bin[bin].last[thread] = NULL;\n #ifdef __GTHREADS\n               if (__gthread_active_p())\n                 {"}]}