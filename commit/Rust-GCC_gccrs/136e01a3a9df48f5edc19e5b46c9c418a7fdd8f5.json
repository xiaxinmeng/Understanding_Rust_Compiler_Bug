{"sha": "136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM2ZTAxYTNhOWRmNDhmNWVkYzE5ZTViNDZjOWM0MThhN2ZkZDhmNQ==", "commit": {"author": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2010-01-14T11:07:39Z"}, "committer": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2010-01-14T11:07:39Z"}, "message": "re PR rtl-optimization/42389 (ICE in advance_state_on_fence with sel-schd for 175.vpr)\n\n        PR rtl-optimization/42389\n        * sel-sched.c (advance_one_cycle): Set FENCE_ISSUE_MORE\n        to can_issue_more.\n        (advance_state_on_fence): Likewise.\n        (sel_target_adjust_priority): Print debug output only when\n        sched_verbose >= 4, not 2.\n        (get_expr_cost): Do not issue all unique insns on the next cycle.\n        (fill_insns): Initialize can_issue_more from the value saved\n        with the fence.\n        * sel-sched-ir.c (flist_add): New parameter issue_more.\n        Init FENCE_ISSUE_MORE with it.\n        (merge_fences): Likewise.\n        (init_fences): Update call to flist_add.\n        (add_to_fences, add_clean_fence_to_fences)\n        (add_dirty_fence_to_fences): Likewise.\n        (move_fence_to_fences): Update call to merge_fences.\n        (invoke_reorder_hooks): Do not reset can_issue_more on insns from\n        sched groups.\n        * sel-sched-ir.h (struct _fence): New field issue_more.\n        (FENCE_ISSUE_MORE): New accessor macro.\n\nFrom-SVN: r155895", "tree": {"sha": "417364ab83b0b9a615900c90101e61adef6bf7cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/417364ab83b0b9a615900c90101e61adef6bf7cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/comments", "author": null, "committer": null, "parents": [{"sha": "762bffbac19855194ddcf644c332cee01be701be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/762bffbac19855194ddcf644c332cee01be701be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/762bffbac19855194ddcf644c332cee01be701be"}], "stats": {"total": 156, "additions": 142, "deletions": 14}, "files": [{"sha": "1f9b351d4b180896fc954c02567ae53fe528a1c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "patch": "@@ -1,3 +1,27 @@\n+2010-01-14  Andrey Belevantsev  <abel@ispras.ru>\n+\t    Alexander Monakov  <amonakov@ispras.ru>\n+\n+\tPR rtl-optimization/42389\n+\t* sel-sched.c (advance_one_cycle): Set FENCE_ISSUE_MORE\n+\tto can_issue_more.\n+\t(advance_state_on_fence): Likewise.\n+\t(sel_target_adjust_priority): Print debug output only when\n+\tsched_verbose >= 4, not 2.\n+\t(get_expr_cost): Do not issue all unique insns on the next cycle.\n+\t(fill_insns): Initialize can_issue_more from the value saved\n+\twith the fence.\n+\t* sel-sched-ir.c (flist_add): New parameter issue_more.\n+\tInit FENCE_ISSUE_MORE with it.\n+\t(merge_fences): Likewise.\n+\t(init_fences): Update call to flist_add.\n+\t(add_to_fences, add_clean_fence_to_fences)\n+\t(add_dirty_fence_to_fences): Likewise.\n+\t(move_fence_to_fences): Update call to merge_fences.\n+\t(invoke_reorder_hooks): Do not reset can_issue_more on insns from\n+\tsched groups.\n+\t* sel-sched-ir.h (struct _fence): New field issue_more.\n+\t(FENCE_ISSUE_MORE): New accessor macro.\n+\n 2010-01-14  Andrey Belevantsev  <abel@ispras.ru>\n \n \tPR rtl-optimization/42388"}, {"sha": "05df3340f520c0380c708c5a0529cfcae1821fd8", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "patch": "@@ -262,7 +262,7 @@ static void\n flist_add (flist_t *lp, insn_t insn, state_t state, deps_t dc, void *tc,\n            insn_t last_scheduled_insn, VEC(rtx,gc) *executing_insns,\n            int *ready_ticks, int ready_ticks_size, insn_t sched_next,\n-           int cycle, int cycle_issued_insns,\n+           int cycle, int cycle_issued_insns, int issue_more,\n            bool starts_cycle_p, bool after_stall_p)\n {\n   fence_t f;\n@@ -287,6 +287,7 @@ flist_add (flist_t *lp, insn_t insn, state_t state, deps_t dc, void *tc,\n   FENCE_TC (f) = tc;\n \n   FENCE_LAST_SCHEDULED_INSN (f) = last_scheduled_insn;\n+  FENCE_ISSUE_MORE (f) = issue_more;\n   FENCE_EXECUTING_INSNS (f) = executing_insns;\n   FENCE_READY_TICKS (f) = ready_ticks;\n   FENCE_READY_TICKS_SIZE (f) = ready_ticks_size;\n@@ -618,6 +619,7 @@ init_fences (insn_t old_fence)\n                  ready_ticks_size,\n                  NULL_RTX /* sched_next */,\n \t\t 1 /* cycle */, 0 /* cycle_issued_insns */,\n+\t\t issue_rate, /* issue_more */\n \t\t 1 /* starts_cycle_p */, 0 /* after_stall_p */);\n     }\n }\n@@ -629,14 +631,14 @@ init_fences (insn_t old_fence)\n    3) all other fields are set to corresponding constant values.\n \n    INSN, STATE, DC, TC, LAST_SCHEDULED_INSN, EXECUTING_INSNS,\n-   READY_TICKS, READY_TICKS_SIZE, SCHED_NEXT, CYCLE and AFTER_STALL_P\n-   are the corresponding fields of the second fence.  */\n+   READY_TICKS, READY_TICKS_SIZE, SCHED_NEXT, CYCLE, ISSUE_MORE\n+   and AFTER_STALL_P are the corresponding fields of the second fence.  */\n static void\n merge_fences (fence_t f, insn_t insn,\n \t      state_t state, deps_t dc, void *tc,\n               rtx last_scheduled_insn, VEC(rtx, gc) *executing_insns,\n               int *ready_ticks, int ready_ticks_size,\n-\t      rtx sched_next, int cycle, bool after_stall_p)\n+\t      rtx sched_next, int cycle, int issue_more, bool after_stall_p)\n {\n   insn_t last_scheduled_insn_old = FENCE_LAST_SCHEDULED_INSN (f);\n \n@@ -666,6 +668,7 @@ merge_fences (fence_t f, insn_t insn,\n         FENCE_CYCLE (f) = cycle;\n \n       FENCE_LAST_SCHEDULED_INSN (f) = NULL;\n+      FENCE_ISSUE_MORE (f) = issue_rate;\n       VEC_free (rtx, gc, executing_insns);\n       free (ready_ticks);\n       if (FENCE_EXECUTING_INSNS (f))\n@@ -697,6 +700,7 @@ merge_fences (fence_t f, insn_t insn,\n           delete_target_context (tc);\n \n           FENCE_LAST_SCHEDULED_INSN (f) = NULL;\n+\t  FENCE_ISSUE_MORE (f) = issue_rate;\n         }\n       else\n         if (candidate->src == BLOCK_FOR_INSN (last_scheduled_insn))\n@@ -713,6 +717,7 @@ merge_fences (fence_t f, insn_t insn,\n             FENCE_TC (f) = tc;\n \n             FENCE_LAST_SCHEDULED_INSN (f) = last_scheduled_insn;\n+\t    FENCE_ISSUE_MORE (f) = issue_more;\n           }\n         else\n           {\n@@ -799,7 +804,8 @@ add_to_fences (flist_tail_t new_fences, insn_t insn,\n                state_t state, deps_t dc, void *tc, rtx last_scheduled_insn,\n                VEC(rtx, gc) *executing_insns, int *ready_ticks,\n                int ready_ticks_size, rtx sched_next, int cycle,\n-               int cycle_issued_insns, bool starts_cycle_p, bool after_stall_p)\n+               int cycle_issued_insns, int issue_rate,\n+\t       bool starts_cycle_p, bool after_stall_p)\n {\n   fence_t f = flist_lookup (FLIST_TAIL_HEAD (new_fences), insn);\n \n@@ -808,7 +814,7 @@ add_to_fences (flist_tail_t new_fences, insn_t insn,\n       flist_add (FLIST_TAIL_TAILP (new_fences), insn, state, dc, tc,\n \t\t last_scheduled_insn, executing_insns, ready_ticks,\n                  ready_ticks_size, sched_next, cycle, cycle_issued_insns,\n-\t\t starts_cycle_p, after_stall_p);\n+\t\t issue_rate, starts_cycle_p, after_stall_p);\n \n       FLIST_TAIL_TAILP (new_fences)\n \t= &FLIST_NEXT (*FLIST_TAIL_TAILP (new_fences));\n@@ -817,7 +823,7 @@ add_to_fences (flist_tail_t new_fences, insn_t insn,\n     {\n       merge_fences (f, insn, state, dc, tc, last_scheduled_insn,\n                     executing_insns, ready_ticks, ready_ticks_size,\n-                    sched_next, cycle, after_stall_p);\n+                    sched_next, cycle, issue_rate, after_stall_p);\n     }\n }\n \n@@ -836,7 +842,7 @@ move_fence_to_fences (flist_t old_fences, flist_tail_t new_fences)\n       merge_fences (f, old->insn, old->state, old->dc, old->tc,\n                     old->last_scheduled_insn, old->executing_insns,\n                     old->ready_ticks, old->ready_ticks_size,\n-                    old->sched_next, old->cycle,\n+                    old->sched_next, old->cycle, old->issue_more,\n                     old->after_stall_p);\n     }\n   else\n@@ -862,7 +868,7 @@ add_clean_fence_to_fences (flist_tail_t new_fences, insn_t succ, fence_t fence)\n                  NULL_RTX, NULL,\n                  XCNEWVEC (int, ready_ticks_size), ready_ticks_size,\n                  NULL_RTX, FENCE_CYCLE (fence) + 1,\n-                 0, 1, FENCE_AFTER_STALL_P (fence));\n+                 0, issue_rate, 1, FENCE_AFTER_STALL_P (fence));\n }\n \n /* Add a new fence to NEW_FENCES list and initialize all of its data\n@@ -886,6 +892,7 @@ add_dirty_fence_to_fences (flist_tail_t new_fences, insn_t succ, fence_t fence)\n                  FENCE_SCHED_NEXT (fence),\n                  FENCE_CYCLE (fence),\n                  FENCE_ISSUED_INSNS (fence),\n+\t\t FENCE_ISSUE_MORE (fence),\n                  FENCE_STARTS_CYCLE_P (fence),\n                  FENCE_AFTER_STALL_P (fence));\n }"}, {"sha": "0d8b0fcb1ee8d3eddb4e28c0b2a703de64833d83", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "patch": "@@ -296,6 +296,9 @@ struct _fence\n   /* Insn, which has been scheduled last on this fence.  */\n   rtx last_scheduled_insn;\n \n+  /* The last value of can_issue_more variable on this fence.  */\n+  int issue_more;\n+\n   /* If non-NULL force the next scheduled insn to be SCHED_NEXT.  */\n   rtx sched_next;\n \n@@ -325,6 +328,7 @@ typedef struct _fence *fence_t;\n #define FENCE_DC(F) ((F)->dc)\n #define FENCE_TC(F) ((F)->tc)\n #define FENCE_LAST_SCHEDULED_INSN(F) ((F)->last_scheduled_insn)\n+#define FENCE_ISSUE_MORE(F) ((F)->issue_more)\n #define FENCE_EXECUTING_INSNS(F) ((F)->executing_insns)\n #define FENCE_READY_TICKS(F) ((F)->ready_ticks)\n #define FENCE_READY_TICKS_SIZE(F) ((F)->ready_ticks_size)"}, {"sha": "1b8f47187a92ede2d9efbbe930a033518708fbb3", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "patch": "@@ -588,6 +588,7 @@ advance_one_cycle (fence_t fence)\n   FENCE_ISSUED_INSNS (fence) = 0;\n   FENCE_STARTS_CYCLE_P (fence) = 1;\n   can_issue_more = issue_rate;\n+  FENCE_ISSUE_MORE (fence) = can_issue_more;\n \n   for (i = 0; VEC_iterate (rtx, FENCE_EXECUTING_INSNS (fence), i, insn); )\n     {\n@@ -3301,8 +3302,8 @@ sel_target_adjust_priority (expr_t expr)\n \n   gcc_assert (EXPR_PRIORITY_ADJ (expr) >= 0);\n \n-  if (sched_verbose >= 2)\n-    sel_print (\"sel_target_adjust_priority: insn %d,  %d +%d = %d.\\n\",\n+  if (sched_verbose >= 4)\n+    sel_print (\"sel_target_adjust_priority: insn %d,  %d+%d = %d.\\n\",\n \t       INSN_UID (EXPR_INSN_RTX (expr)), EXPR_PRIORITY (expr),\n \t       EXPR_PRIORITY_ADJ (expr), new_priority);\n \n@@ -4103,7 +4104,7 @@ invoke_reorder_hooks (fence_t fence)\n       ran_hook = true;\n     }\n   else\n-    issue_more = issue_rate;\n+    issue_more = FENCE_ISSUE_MORE (fence);\n \n   /* Ensure that ready list and vec_av_set are in line with each other,\n      i.e. vec_av_set[i] == ready_element (&ready, i).  */\n@@ -4294,8 +4295,6 @@ get_expr_cost (expr_t expr, fence_t fence)\n   if (recog_memoized (insn) < 0)\n     {\n       if (!FENCE_STARTS_CYCLE_P (fence)\n-          /* FIXME: Is this condition necessary?  */\n-          && VINSN_UNIQUE_P (EXPR_VINSN (expr))\n \t  && INSN_ASM_P (insn))\n \t/* This is asm insn which is tryed to be issued on the\n \t   cycle not first.  Issue it on the next cycle.  */\n@@ -5283,6 +5282,7 @@ advance_state_on_fence (fence_t fence, insn_t insn)\n     debug_state (FENCE_STATE (fence));\n   if (!DEBUG_INSN_P (insn))\n     FENCE_STARTS_CYCLE_P (fence) = 0;\n+  FENCE_ISSUE_MORE (fence) = can_issue_more;\n   return asm_p;\n }\n \n@@ -5480,6 +5480,7 @@ fill_insns (fence_t fence, int seqno, ilist_t **scheduled_insns_tailpp)\n   blist_add (&bnds, insn, NULL, FENCE_DC (fence));\n   bnds_tailp = &BLIST_NEXT (bnds);\n   set_target_context (FENCE_TC (fence));\n+  can_issue_more = FENCE_ISSUE_MORE (fence);\n   target_bb = INSN_BB (insn);\n \n   /* Do while we can add any operation to the current group.  */"}, {"sha": "d6f013e2b44538a79f319539b3d76a4bf6f2a663", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "patch": "@@ -1,3 +1,8 @@\n+2010-01-14  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\tPR rtl-optimization/42389\n+\t* gcc.dg/pr42389.c: New.\n+\n 2010-01-14  Alexander Monakov  <amonakov@ispras.ru>\n \n \tPR rtl-optimization/42388"}, {"sha": "c398012f2b41e04b95d8e23f432171a75796a38b", "filename": "gcc/testsuite/gcc.dg/pr42389.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42389.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42389.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42389.c?ref=136e01a3a9df48f5edc19e5b46c9c418a7fdd8f5", "patch": "@@ -0,0 +1,87 @@\n+/* { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -fselective-scheduling -fsel-sched-pipelining -fsched-pressure\" } */\n+\n+struct s_linked_f_pointer\n+{\n+  struct s_linked_f_pointer *next;\n+  float *fptr;\n+};\n+struct s_trace\n+{\n+  int index;\n+};\n+struct s_rr_cost\n+{\n+  float base_cost;\n+  float acc_cost;\n+};\n+extern int num_nets;\n+extern struct s_trace **trace_head;\n+extern struct s_rr_cost *rr_cost;\n+struct s_rr_route\n+{\n+  float cost;\n+};\n+static int heap_tail;\n+extern struct s_linked_f_pointer *rr_modified_head;\n+extern struct s_rr_route *rr_route;\n+\n+void\n+empty_heap (void)\n+{\n+  heap_tail = 1;\n+}\n+\n+void\n+reset_path_costs (void)\n+{\n+  struct s_linked_f_pointer *mod_ptr;\n+  if (rr_modified_head != ((void *) 0))\n+    {\n+      mod_ptr = rr_modified_head;\n+      while (mod_ptr->next != ((void *) 0))\n+\t{\n+\t  *(mod_ptr->fptr) = 1.e30;\n+\t  mod_ptr = mod_ptr->next;\n+\t}\n+      rr_modified_head = ((void *) 0);\n+    }\n+}\n+\n+static void\n+route_net (int inet)\n+{\n+  int i;\n+  for (i = 1; i < inet; i++)\n+    reset_path_costs ();\n+  empty_heap ();\n+  reset_path_costs ();\n+}\n+\n+void\n+pathfinder_update_one_cost (int inet, float pres_fac, float acc_fac)\n+{\n+  struct s_trace *tptr;\n+  int inode = 0;\n+\n+  tptr = trace_head[inet];\n+  inode = tptr->index;\n+  rr_route[inode].cost = rr_cost[inode].base_cost + rr_cost[inode].acc_cost;\n+}\n+\n+int\n+try_route (int n, float x, float y)\n+{\n+  int inet, itry;\n+  float pres_fac;\n+  for (itry = 1; itry <= n; itry++)\n+    {\n+      for (inet = 0; inet < num_nets; inet++)\n+\t{\n+\t  route_net (inet);\n+\t  pathfinder_update_one_cost (inet, pres_fac, x);\n+\t}\n+      pres_fac *= y;\n+    }\n+}\n+"}]}