{"sha": "3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhODA4M2ZjOTA2MmVmNWM2ZjJlOTdiNTYzY2UyZThiM2Y3YThjNg==", "commit": {"author": {"name": "Jonathan Larmour", "email": "jlarmour@redhat.co.uk", "date": "2000-02-16T07:54:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-02-16T07:54:53Z"}, "message": "Jonathan Larmour  <jlarmour@redhat.co.uk>:\n\nAdd new __GNUC_PATCHLEVEL__ define.\n\nFrom-SVN: r32004", "tree": {"sha": "f50c2625d7ae54acdbe802acaad3b0628f04ef06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f50c2625d7ae54acdbe802acaad3b0628f04ef06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/comments", "author": null, "committer": null, "parents": [{"sha": "ba96c72d6baddf4dec4515c6f7fa57716440913b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba96c72d6baddf4dec4515c6f7fa57716440913b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba96c72d6baddf4dec4515c6f7fa57716440913b"}], "stats": {"total": 550, "additions": 282, "deletions": 268}, "files": [{"sha": "62d5ec7678808f94fa1a28fdbf06ba9232c8b3ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -1,3 +1,14 @@\n+2000-02-15  Jonathan Larmour  <jlarmour@redhat.co.uk>\n+\n+\t* gcc.c (default_compilers): Add new __GNUC_PATCHLEVEL__ define\n+\tto default cpp spec.\n+\t(do_spec_1): Add support for %v3 spec used by __GNUC_PATCHLEVEL__.\n+\t* cpp.texi: Document __GNUC_PATCHLEVEL__.\n+\t* cpp.1: Likewise.\n+\n+\t* objc/lang-specs.h: Add new __GNUC_PATCHLEVEL__ define to\n+\tdefault spec.\n+\n 2000-02-15  Denis Chertykov  <denisc@overta.ru>\n \n \t* configure.in: Add support for avr target.\n@@ -32,7 +43,7 @@ Tue Feb 15 23:22:26 2000  Andrew Haley  <aph@cygnus.com>\n \t* config/sh/sh.h: Correct comment about macros.\n \n Tue Feb 15 22:30:36 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n-                          Andrew MacLeod  <amacleod@cygnus.com>\n+\t                  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* Makefile.in (lcm.o): Depend on insn-attr.h.\n \t* basic-block.h (optimize_mode_switching): Declare.\n@@ -127,7 +138,7 @@ Tue Feb 15 22:30:36 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \tto import the frames themselves.\n \n Mon Feb 14 13:31:01 2000  Stan Cox  <scox@cygnus.com>\n-                          Jason Eckhardt  <jle@cygnus.com>\n+\t                  Jason Eckhardt  <jle@cygnus.com>\n \n \t* basic_block.h: Added prototype for reorder_basic_blocks.\n \t* toplev.c: Changes to add -freorder-blocks and graph dump after\n@@ -226,28 +237,28 @@ Sat Feb 12 01:44:26 MET 2000  Jan Hubicka  <jh@suse.cz>\n \ttwo types have compatable, arm specific, attributes.\n \n \t* config/arm/arm.h (CUMULATIVE_ARGS): Redefine to be a\n-        structure.\n+\tstructure.\n \t(FUNCTION_ARG): Redefine to call arm_function_arg.\n \t(FUNCTION_ARG_PARTIAL_NREGS): Redefine to use correct\n-        structure field.\n+\tstructure field.\n \t(INIT_CUMULATIVE_ARGS): Redefine to call\n-        arm_init_cumulative_args.\n+\tarm_init_cumulative_args.\n \t(FUNCTION_ARG_ADVANCE): Redefine to use correct structure\n-        field. \n+\tfield. \n \t(SETUP_INCOMING_VARARGS): Redefine to use correct structure \n-        field. \n+\tfield. \n \t(ARM_MARK_NEARBY_FUNCTION): New macro: Mark already compiled\n-        functions.\n+\tfunctions.\n \t(ENCODE_SECTION): Add call to ARM_MARK_NEARBY_FUNCTION.\n \t(VALID_MACHINE_TYPE_ATTRIBUTE): Define.\n \t(COMP_TYPE_ATTRIBUTES): Define.\n \n \t* config/arm/arm.md (call): Call arm_is_long_call_p to decide\n-        if a long call is needed.\n+\tif a long call is needed.\n \t(call_value): Call arm_is_long_call_p to decide if a long call\n-        is needed.\n+\tis needed.\n \t(call_symbol): Call arm_is_long_call_p to decide if a long call\n-        is needed.\n+\tis needed.\n \n \t* config/arm/arm-protos.h: Add prototype for arm_is_long_call_p.\n "}, {"sha": "896b7c645754c2c85ec8dc7313744048ff6e3509", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -1,3 +1,7 @@\n+2000-02-15  Jonathan Larmour  <jlarmour@redhat.co.uk>\n+\n+\t* lang-specs.h: Add new __GNUC_PATCHLEVEL__ define to default spec.\n+\n 2000-02-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* grant.c: Don't declare `version_string'."}, {"sha": "1b377f57aeb09c8a4fbfbbd4aa0f7b4c5eb70251", "filename": "gcc/ch/lang-specs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fch%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fch%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flang-specs.h?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -26,7 +26,7 @@ Boston, MA 02111-1307, USA.  */\n   {\"@chill\",\n      {\"cpp -lang-chill %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU CHILL does not support -C without using -E}}\\\n-        %{!no-gcc:-D__GNUCHILL__=%v1 -D__GNUC_MINOR__=%v2}\\\n+        %{!no-gcc:-D__GNUCHILL__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n         %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\\\n         %{traditional-cpp:-traditional} %{!undef:%{!ansi:%p} %P} %{trigraphs}\\\n \t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\\"}, {"sha": "3c0254d720a7197b49ffaffb3519af84a2fb54df", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -1,3 +1,7 @@\n+2000-02-15  Jonathan Larmour  <jlarmour@redhat.co.uk>\n+\n+\t* lang-specs.h: Add new __GNUC_PATCHLEVEL__ define to default spec.\n+\n 2000-01-16  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* decl2.c (lang_decode_option): Enable automatic line wrapping."}, {"sha": "630641cc6df104b850a72187f8a69b77295e1b83", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -33,8 +33,8 @@ Boston, MA 02111-1307, USA.  */\n      \"%{E|M|MM:cpp -lang-c++ %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU C++ does not support -C without using -E}}\\\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-\t%{!no-gcc:-D__GNUC__=%v1 -D__GNUG__=%v1 -D__GNUC_MINOR__=%v2}\\\n-\t-D__cplusplus\\\n+\t%{!no-gcc:-D__GNUC__=%v1 -D__GNUG__=%v1 -D__GNUC_MINOR__=%v2\\\n+\t-D__GNUC_PATCHLEVEL__=%v3} -D__cplusplus\\\n \t%{ansi:-trigraphs -D__STRICT_ANSI__} %{!undef:%{!ansi:%p} %P}\\\n \t%{!fno-exceptions:-D__EXCEPTIONS}\\\n         %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}} %{trigraphs}\\\n@@ -46,7 +46,8 @@ Boston, MA 02111-1307, USA.  */\n                             -lang-c++ %{nostdinc*} %{C} %{A*} %{I*} %{P} %{$} %I\\\n                             %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n                             %{!no-gcc:-D__GNUC__=%v1 -D__GNUG__=%v1\\\n-                            -D__GNUC_MINOR__=%v2} -D__cplusplus\\\n+                            -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n+                            -D__cplusplus\\\n                             %{ansi:-trigraphs -D__STRICT_ANSI__} %{!undef:%{!ansi:%p} %P}\\\n                             %{!fno-exceptions:-D__EXCEPTIONS}\\\n \t\t\t    %{fnew-abi:-D__GXX_ABI_VERSION=100}\\\n@@ -68,8 +69,8 @@ Boston, MA 02111-1307, USA.  */\n    {\"cpp -lang-c++ %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU C++ does not support -C without using -E}}\\\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-\t%{!no-gcc:-D__GNUC__=%v1 -D__GNUG__=%v1 -D__GNUC_MINOR__=%v2}\\\n-\t-D__cplusplus\\\n+\t%{!no-gcc:-D__GNUC__=%v1 -D__GNUG__=%v1 -D__GNUC_MINOR__=%v2\\\n+\t-D__GNUC_PATCHLEVEL__=%v3} -D__cplusplus\\\n \t%{ansi:-trigraphs -D__STRICT_ANSI__} %{!undef:%{!ansi:%p} %P}\\\n \t%{!fno-exceptions:-D__EXCEPTIONS}\\\n \t%{fnew-abi:-D__GXX_ABI_VERSION=100}\\"}, {"sha": "2f65cf3f009ff6fe5603b8f922f87410f669b9b7", "filename": "gcc/cpp.1", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcpp.1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcpp.1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.1?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -401,9 +401,9 @@ wins.\n .Ip \"\\fB\\-undef\\fR\" 4\n Do not predefine any nonstandard macros.\n .Ip \"\\fB\\-gcc\\fR\" 4\n-Define the macros \\fI_\\|_GNUC_\\|_\\fR and \\fI_\\|_GNUC_MINOR_\\|_\\fR.  These are\n-defined automatically when you use \\fBgcc \\-E\\fR; you can turn them off\n-in that case with \\fB\\-no-gcc\\fR.\n+Define the macros \\fI_\\|_GNUC_\\|_\\fR, \\fI_\\|_GNUC_MINOR_\\|_\\fR and\n+\\fI_\\|_GNUC_PATCHLEVEL_\\|_\\fR.  These are defined automatically when you\n+use \\fBgcc \\-E\\fR; you can turn them off in that case with \\fB\\-no-gcc\\fR.\n .Ip \"\\fB\\-A \\fIpredicate\\fR(\\fIanswer\\fR)\\fR\" 4\n Make an assertion with the predicate \\fIpredicate\\fR and answer\n \\fIanswer\\fR.  "}, {"sha": "f7a0dc9a659482b1cdcf9612418d6cb1b203c7d0", "filename": "gcc/cpp.texi", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -978,9 +978,16 @@ The macro contains the minor version number of the compiler.  This can\n be used to work around differences between different releases of the\n compiler (for example, if gcc 2.6.3 is known to support a feature, you\n can test for @code{__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6)}).\n-The last number, @samp{3} in the\n-example above, denotes the bugfix level of the compiler; no macro\n-contains this value.\n+\n+@item __GNUC_PATCHLEVEL__\n+@findex __GNUC_PATCHLEVEL__\n+This macro contains the patch level of the compiler.  This can be\n+used to work around differences between different patch level releases\n+of the compiler (for example, if gcc 2.6.2 is known to contain a bug,\n+whereas gcc 2.6.3 contains a fix, and you have code which can workaround\n+ths problem depending on whether the bug is fixed or not, you can test for\n+@code{__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 6) || \n+(__GNUC__ == 2 && __GNUC_MINOR__ == 6 && __GNUC_PATCHLEVEL__ > 3)}).\n \n @item __GNUG__\n @findex __GNUG__\n@@ -2870,9 +2877,9 @@ Do not predefine any nonstandard macros.\n \n @item -gcc\n @findex -gcc\n-Define the macros @var{__GNUC__} and @var{__GNUC_MINOR__}.  These are\n-defined automatically when you use @samp{gcc -E}; you can turn them off\n-in that case with @samp{-no-gcc}.\n+Define the macros @var{__GNUC__}, @var{__GNUC_MINOR__} and\n+@var{__GNUC_PATCHLEVEL__}. These are defined automatically when you use\n+@samp{gcc -E}; you can turn them off in that case with @samp{-no-gcc}.\n \n @item -A @var{predicate}(@var{answer})\n @findex -A"}, {"sha": "a3fdb9bfd69b37ab9abd016f76b04b968bd0d6dc", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -1,3 +1,7 @@\n+2000-02-15  Jonathan Larmour  <jlarmour@redhat.co.uk>\n+\n+\t* lang-specs.h: Add new __GNUC_PATCHLEVEL__ define to default spec.\n+\n Tue Feb 15 11:14:17 2000  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* g77spec.c: Don't declare `version_string'."}, {"sha": "4ee032003c18e9d02200af3df2ad9bbb9d5fc495", "filename": "gcc/f/lang-specs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Ff%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Ff%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flang-specs.h?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -38,7 +38,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    {\"cpp -lang-fortran %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU C does not support -C without using -E}}\\\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-\t%{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2}\\\n+\t%{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n \t%{ansi:-trigraphs -$ -D__STRICT_ANSI__}\\\n \t%{!undef:%P} -D_LANGUAGE_FORTRAN %{trigraphs} \\\n \t%c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}} -traditional\\\n@@ -88,7 +88,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    {\"cpp -lang-fortran %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %{$} %I \\\n       %{C:%{!E:%eGNU C does not support -C without using -E}} \\\n       %{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG} \\\n-      %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2} \\\n+      %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3} \\\n       %{ansi:-trigraphs -$ -D__STRICT_ANSI__} \\\n       %{!undef:%P} -D_LANGUAGE_FORTRAN %{trigraphs} \\\n       %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}} -traditional \\"}, {"sha": "6c4c95348146a12641cf5b18a1dcd463127b90de", "filename": "gcc/flow.c", "status": "modified", "additions": 192, "deletions": 230, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -274,12 +274,6 @@ varray_type basic_block_for_insn;\n \n static rtx label_value_list;\n \n-/* INSN_VOLATILE (insn) is 1 if the insn refers to anything volatile.  */\n-\n-#define INSN_VOLATILE(INSN) bitmap_bit_p (uid_volatile, INSN_UID (INSN))\n-#define SET_INSN_VOLATILE(INSN) bitmap_set_bit (uid_volatile, INSN_UID (INSN))\n-static bitmap uid_volatile;\n-\n /* Forward declarations */\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static rtx find_basic_blocks_1\t\tPARAMS ((rtx));\n@@ -316,11 +310,11 @@ static void verify_wide_reg\t\tPARAMS ((int, rtx, rtx));\n static void verify_local_live_at_start\tPARAMS ((regset, basic_block));\n static int set_noop_p\t\t\tPARAMS ((rtx));\n static int noop_move_p\t\t\tPARAMS ((rtx));\n-static void notice_stack_pointer_modification PARAMS ((rtx, rtx, void *));\n-static void record_volatile_insns\tPARAMS ((rtx));\n+static void delete_noop_moves\t\tPARAMS ((rtx));\n+static void notice_stack_pointer_modification_1 PARAMS ((rtx, rtx, void *));\n+static void notice_stack_pointer_modification PARAMS ((rtx));\n static void mark_reg\t\t\tPARAMS ((rtx, void *));\n static void mark_regs_live_at_end\tPARAMS ((regset));\n-static void life_analysis_1\t\tPARAMS ((rtx, int, int));\n static void calculate_global_regs_live\tPARAMS ((sbitmap, sbitmap, int));\n static void propagate_block\t\tPARAMS ((basic_block, regset,\n \t\t\t\t\t\t regset, int));\n@@ -2460,27 +2454,25 @@ life_analysis (f, nregs, file, remove_dead_code)\n      FILE *file;\n      int remove_dead_code;\n {\n+  register int i;\n #ifdef ELIMINABLE_REGS\n-  register size_t i;\n   static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n #endif\n   int flags;\n-\n+  sbitmap all_blocks;\n+ \n   /* Record which registers will be eliminated.  We use this in\n      mark_used_regs.  */\n \n   CLEAR_HARD_REG_SET (elim_reg_set);\n \n #ifdef ELIMINABLE_REGS\n-  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+  for (i = 0; i < (int) (sizeof eliminables / sizeof eliminables[0]); i++)\n     SET_HARD_REG_BIT (elim_reg_set, eliminables[i].from);\n #else\n   SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n #endif\n \n-  /* Allocate a bitmap to be filled in by record_volatile_insns.  */\n-  uid_volatile = BITMAP_XMALLOC ();\n-\n   /* We want alias analysis information for local dead store elimination.  */\n   init_alias_analysis ();\n \n@@ -2492,17 +2484,53 @@ life_analysis (f, nregs, file, remove_dead_code)\n       if (! remove_dead_code)\n \tflags &= ~(PROP_SCAN_DEAD_CODE | PROP_KILL_DEAD_CODE);\n     }\n-  life_analysis_1 (f, nregs, flags);\n \n+  /* The post-reload life analysis have (on a global basis) the same\n+     registers live as was computed by reload itself.  elimination\n+     Otherwise offsets and such may be incorrect.\n+\n+     Reload will make some registers as live even though they do not\n+     appear in the rtl.  */\n+  if (reload_completed)\n+    flags &= ~PROP_REG_INFO;\n+\n+  max_regno = nregs;\n+\n+  /* Always remove no-op moves.  Do this before other processing so\n+     that we don't have to keep re-scanning them.  */\n+  delete_noop_moves (f);\n+\n+  /* Some targets can emit simpler epilogues if they know that sp was\n+     not ever modified during the function.  After reload, of course,\n+     we've already emitted the epilogue so there's no sense searching.  */\n   if (! reload_completed)\n-    mark_constant_function ();\n+    notice_stack_pointer_modification (f);\n+    \n+  /* Allocate and zero out data structures that will record the\n+     data from lifetime analysis.  */\n+  allocate_reg_life_data ();\n+  allocate_bb_life_data ();\n+  reg_next_use = (rtx *) xcalloc (nregs, sizeof (rtx));\n+  all_blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_ones (all_blocks);\n+\n+  /* Find the set of registers live on function exit.  */\n+  mark_regs_live_at_end (EXIT_BLOCK_PTR->global_live_at_start);\n+\n+  /* \"Update\" life info from zero.  It'd be nice to begin the\n+     relaxation with just the exit and noreturn blocks, but that set\n+     is not immediately handy.  */\n+  update_life_info (all_blocks, UPDATE_LIFE_GLOBAL, flags);\n \n+  /* Clean up.  */\n+  sbitmap_free (all_blocks);\n+  free (reg_next_use);\n+  reg_next_use = NULL;\n   end_alias_analysis ();\n \n   if (file)\n     dump_flow_info (file);\n \n-  BITMAP_XFREE (uid_volatile);\n   free_basic_block_vars (1);\n }\n \n@@ -2581,7 +2609,7 @@ verify_local_live_at_start (new_live_at_start, bb)\n     }\n }\n \n-/* Updates death notes starting with the basic blocks set in BLOCKS.\n+/* Updates life information starting with the basic blocks set in BLOCKS.\n    \n    If LOCAL_ONLY, such as after splitting or peepholeing, we are only\n    expecting local modifications to basic blocks.  If we find extra\n@@ -2596,8 +2624,8 @@ verify_local_live_at_start (new_live_at_start, bb)\n \n    BLOCK_FOR_INSN is assumed to be correct.\n \n-   ??? PROP_FLAGS should not contain PROP_LOG_LINKS.  Need to set up\n-   reg_next_use for that.  Including PROP_REG_INFO does not refresh\n+   PROP_FLAGS should not contain PROP_LOG_LINKS unless the caller sets\n+   up reg_next_use.  Including PROP_REG_INFO does not properly refresh\n    regs_ever_live unless the caller resets it to zero.  */\n \n void\n@@ -2634,6 +2662,35 @@ update_life_info (blocks, extent, prop_flags)\n     });\n \n   FREE_REG_SET (tmp);\n+\n+  if (prop_flags & PROP_REG_INFO)\n+    {\n+      /* The only pseudos that are live at the beginning of the function\n+\t are those that were not set anywhere in the function.  local-alloc\n+\t doesn't know how to handle these correctly, so mark them as not\n+\t local to any one basic block.  */\n+      EXECUTE_IF_SET_IN_REG_SET (ENTRY_BLOCK_PTR->global_live_at_end,\n+\t\t\t\t FIRST_PSEUDO_REGISTER, i,\n+\t\t\t\t { REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; });\n+\n+      /* We have a problem with any pseudoreg that lives across the setjmp. \n+\t ANSI says that if a user variable does not change in value between\n+\t the setjmp and the longjmp, then the longjmp preserves it.  This\n+\t includes longjmp from a place where the pseudo appears dead.\n+\t (In principle, the value still exists if it is in scope.)\n+\t If the pseudo goes in a hard reg, some other value may occupy\n+\t that hard reg where this pseudo is dead, thus clobbering the pseudo.\n+\t Conclusion: such a pseudo must not go in a hard reg.  */\n+      EXECUTE_IF_SET_IN_REG_SET (regs_live_at_setjmp,\n+\t\t\t\t FIRST_PSEUDO_REGISTER, i,\n+\t\t\t\t {\n+\t\t\t\t   if (regno_reg_rtx[i] != 0)\n+\t\t\t\t     {\n+\t\t\t\t       REG_LIVE_LENGTH (i) = -1;\n+\t\t\t\t       REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+\t\t\t\t     }\n+\t\t\t\t });\n+    }\n }\n \n /* Free the variables allocated by find_basic_blocks.\n@@ -2670,18 +2727,17 @@ set_noop_p (set)\n {\n   rtx src = SET_SRC (set);\n   rtx dst = SET_DEST (set);\n-  if (GET_CODE (src) == REG && GET_CODE (dst) == REG\n-      && REGNO (src) == REGNO (dst))\n-    return 1;\n-  if (GET_CODE (src) != SUBREG || GET_CODE (dst) != SUBREG\n-      || SUBREG_WORD (src) != SUBREG_WORD (dst))\n-    return 0;\n-  src = SUBREG_REG (src);\n-  dst = SUBREG_REG (dst);\n-  if (GET_CODE (src) == REG && GET_CODE (dst) == REG\n-      && REGNO (src) == REGNO (dst))\n-    return 1;\n-  return 0;\n+\n+  if (GET_CODE (src) == SUBREG && GET_CODE (dst) == SUBREG)\n+    {\n+      if (SUBREG_WORD (src) != SUBREG_WORD (dst))\n+\treturn 0;\n+      src = SUBREG_REG (src);\n+      dst = SUBREG_REG (dst);\n+    }\n+\n+  return (GET_CODE (src) == REG && GET_CODE (dst) == REG\n+\t  && REGNO (src) == REGNO (dst));\n }\n \n /* Return nonzero if an insn consists only of SETs, each of which only sets a\n@@ -2721,8 +2777,29 @@ noop_move_p (insn)\n   return 0;\n }\n \n+/* Delete any insns that copy a register to itself.  */\n+\n+static void\n+delete_noop_moves (f)\n+     rtx f;\n+{\n+  rtx insn;\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == INSN && noop_move_p (insn))\n+\t{\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t}\n+    }\n+}\n+\n+/* Determine if the stack pointer is constant over the life of the function.\n+   Only useful before prologues have been emitted.  */\n+\n static void\n-notice_stack_pointer_modification (x, pat, data)\n+notice_stack_pointer_modification_1 (x, pat, data)\n      rtx x;\n      rtx pat ATTRIBUTE_UNUSED;\n      void *data ATTRIBUTE_UNUSED;\n@@ -2740,57 +2817,28 @@ notice_stack_pointer_modification (x, pat, data)\n     current_function_sp_is_unchanging = 0;\n }\n \n-/* Record which insns refer to any volatile memory\n-   or for any reason can't be deleted just because they are dead stores.\n-   Also, delete any insns that copy a register to itself.\n-   And see if the stack pointer is modified.  */\n static void\n-record_volatile_insns (f)\n+notice_stack_pointer_modification (f)\n      rtx f;\n {\n   rtx insn;\n+\n+  /* Assume that the stack pointer is unchanging if alloca hasn't\n+     been used.  */\n+  current_function_sp_is_unchanging = !current_function_calls_alloca;\n+  if (! current_function_sp_is_unchanging)\n+    return;\n+\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n-      enum rtx_code code1 = GET_CODE (insn);\n-      if (code1 == CALL_INSN)\n-\tSET_INSN_VOLATILE (insn);\n-      else if (code1 == INSN || code1 == JUMP_INSN)\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n-\t  if (GET_CODE (PATTERN (insn)) != USE\n-\t      && volatile_refs_p (PATTERN (insn)))\n-\t    SET_INSN_VOLATILE (insn);\n-\n-\t  /* A SET that makes space on the stack cannot be dead.\n-\t     (Such SETs occur only for allocating variable-size data,\n-\t     so they will always have a PLUS or MINUS according to the\n-\t     direction of stack growth.)\n-\t     Even if this function never uses this stack pointer value,\n-\t     signal handlers do!  */\n-\t  else if (code1 == INSN && GET_CODE (PATTERN (insn)) == SET\n-\t\t   && SET_DEST (PATTERN (insn)) == stack_pointer_rtx\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == MINUS\n-#else\n-\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == PLUS\n-#endif\n-\t\t   && XEXP (SET_SRC (PATTERN (insn)), 0) == stack_pointer_rtx)\n-\t    SET_INSN_VOLATILE (insn);\n-\n-\t  /* Delete (in effect) any obvious no-op moves.  */\n-\t  else if (noop_move_p (insn))\n-\t    {\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t    }\n+\t  /* Check if insn modifies the stack pointer.  */\n+\t  note_stores (PATTERN (insn), notice_stack_pointer_modification_1,\n+\t\t       NULL);\n+\t  if (! current_function_sp_is_unchanging)\n+\t    return;\n \t}\n-\n-      /* Check if insn modifies the stack pointer.  */\n-      if ( current_function_sp_is_unchanging\n-\t   && GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\tnote_stores (PATTERN (insn),\n-\t\t     notice_stack_pointer_modification,\n-\t\t     NULL);\n     }\n }\n \n@@ -2882,117 +2930,6 @@ mark_regs_live_at_end (set)\n   diddle_return_value (mark_reg, set);\n }\n \n-/* Determine which registers are live at the start of each\n-   basic block of the function whose first insn is F.\n-   NREGS is the number of registers used in F.\n-   We allocate the vector basic_block_live_at_start\n-   and the regsets that it points to, and fill them with the data.\n-   regset_size and regset_bytes are also set here.  */\n-\n-static void\n-life_analysis_1 (f, nregs, flags)\n-     rtx f;\n-     int nregs;\n-     int flags;\n-{\n-  char save_regs_ever_live[FIRST_PSEUDO_REGISTER];\n-  register int i;\n-\n-  max_regno = nregs;\n-\n-  /* Allocate and zero out many data structures\n-     that will record the data from lifetime analysis.  */\n-\n-  allocate_reg_life_data ();\n-  allocate_bb_life_data ();\n-\n-  reg_next_use = (rtx *) xcalloc (nregs, sizeof (rtx));\n-\n-  /* Assume that the stack pointer is unchanging if alloca hasn't been used.\n-     This will be cleared by record_volatile_insns if it encounters an insn\n-     which modifies the stack pointer.  */\n-  current_function_sp_is_unchanging = !current_function_calls_alloca;\n-  record_volatile_insns (f);\n-\n-  /* Find the set of registers live on function exit.  Do this before\n-     zeroing regs_ever_live, as we use that data post-reload.  */\n-  mark_regs_live_at_end (EXIT_BLOCK_PTR->global_live_at_start);\n-\n-  /* The post-reload life analysis have (on a global basis) the same\n-     registers live as was computed by reload itself.  elimination\n-     Otherwise offsets and such may be incorrect.\n-\n-     Reload will make some registers as live even though they do not\n-     appear in the rtl.  */\n-  if (reload_completed)\n-    memcpy (save_regs_ever_live, regs_ever_live, sizeof (regs_ever_live));\n-  memset (regs_ever_live, 0, sizeof regs_ever_live);\n-\n-  /* Compute register life at block boundaries.  It'd be nice to \n-     begin with just the exit and noreturn blocks, but that set \n-     is not immediately handy.  */\n-  {\n-    sbitmap blocks;\n-    blocks = sbitmap_alloc (n_basic_blocks);\n-    sbitmap_ones (blocks);\n-    calculate_global_regs_live (blocks, blocks, flags & PROP_SCAN_DEAD_CODE);\n-    sbitmap_free (blocks);\n-  }\n-\n-  /* The only pseudos that are live at the beginning of the function are\n-     those that were not set anywhere in the function.  local-alloc doesn't\n-     know how to handle these correctly, so mark them as not local to any\n-     one basic block.  */\n-\n-  EXECUTE_IF_SET_IN_REG_SET (ENTRY_BLOCK_PTR->global_live_at_end,\n-\t\t\t     FIRST_PSEUDO_REGISTER, i,\n-\t\t\t     { REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; });\n-\n-  /* Now the life information is accurate.  Make one more pass over each\n-     basic block to delete dead stores, create autoincrement addressing\n-     and record how many times each register is used, is set, or dies.  */\n-  {\n-    regset tmp;\n-    tmp = ALLOCA_REG_SET ();\n-\n-    for (i = n_basic_blocks - 1; i >= 0; --i)\n-      {\n-        basic_block bb = BASIC_BLOCK (i);\n-\n-\tCOPY_REG_SET (tmp, bb->global_live_at_end);\n-\tpropagate_block (bb, tmp, (regset) NULL, flags);\n-      }\n-\n-    FREE_REG_SET (tmp);\n-  }\n-\n-  /* We have a problem with any pseudoreg that lives across the setjmp. \n-     ANSI says that if a user variable does not change in value between\n-     the setjmp and the longjmp, then the longjmp preserves it.  This\n-     includes longjmp from a place where the pseudo appears dead.\n-     (In principle, the value still exists if it is in scope.)\n-     If the pseudo goes in a hard reg, some other value may occupy\n-     that hard reg where this pseudo is dead, thus clobbering the pseudo.\n-     Conclusion: such a pseudo must not go in a hard reg.  */\n-  EXECUTE_IF_SET_IN_REG_SET (regs_live_at_setjmp,\n-\t\t\t     FIRST_PSEUDO_REGISTER, i,\n-\t\t\t     {\n-\t\t\t       if (regno_reg_rtx[i] != 0)\n-\t\t\t\t {\n-\t\t\t\t   REG_LIVE_LENGTH (i) = -1;\n-\t\t\t\t   REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n-\t\t\t\t }\n-\t\t\t     });\n-\n-  /* Restore regs_ever_live that was provided by reload.  */\n-  if (reload_completed)\n-    memcpy (regs_ever_live, save_regs_ever_live, sizeof (regs_ever_live));\n-\n-  /* Clean up.  */\n-  free (reg_next_use);\n-  reg_next_use = NULL;\n-}\n-\n /* Propagate global life info around the graph of basic blocks.  Begin\n    considering blocks with their corresponding bit set in BLOCKS_IN. \n    BLOCKS_OUT is set for every block that was changed.  */\n@@ -3289,11 +3226,8 @@ propagate_block (bb, old, significant, flags)\n \n \t  if (flags & PROP_SCAN_DEAD_CODE)\n \t    {\n-\t      insn_is_dead = (insn_dead_p (PATTERN (insn), old, 0,\n-\t\t\t\t\t   REG_NOTES (insn))\n-\t                      /* Don't delete something that refers to\n-\t\t\t\t volatile storage!  */\n-\t                      && ! INSN_VOLATILE (insn));\n+\t      insn_is_dead = insn_dead_p (PATTERN (insn), old, 0,\n+\t\t\t\t\t  REG_NOTES (insn));\n \t      libcall_is_dead = (insn_is_dead && note != 0\n \t                         && libcall_dead_p (PATTERN (insn), old,\n \t\t\t\t\t\t    note, insn));\n@@ -3576,18 +3510,29 @@ insn_dead_p (x, needed, call_ok, notes)\n     {\n       rtx r = SET_DEST (x);\n \n-      /* A SET that is a subroutine call cannot be dead.  */\n-      if (! call_ok && GET_CODE (SET_SRC (x)) == CALL)\n-\treturn 0;\n-\n #ifdef HAVE_cc0\n       if (GET_CODE (r) == CC0)\n \treturn ! cc0_live;\n #endif\n       \n-      if (GET_CODE (r) == MEM && ! MEM_VOLATILE_P (r))\n+      /* A SET that is a subroutine call cannot be dead.  */\n+      if (GET_CODE (SET_SRC (x)) == CALL)\n+\t{\n+\t  if (! call_ok)\n+\t    return 0;\n+\t}\n+\n+      /* Don't eliminate loads from volatile memory or volatile asms.  */\n+      else if (volatile_refs_p (SET_SRC (x)))\n+\treturn 0;\n+\n+      if (GET_CODE (r) == MEM)\n \t{\n \t  rtx temp;\n+\n+\t  if (MEM_VOLATILE_P (r))\n+\t    return 0;\n+\n \t  /* Walk the set of memory locations we are currently tracking\n \t     and see if one is an identical match to this memory location.\n \t     If so, this memory write is dead (remember, we're walking\n@@ -3600,52 +3545,68 @@ insn_dead_p (x, needed, call_ok, notes)\n \t      temp = XEXP (temp, 1);\n \t    }\n \t}\n+      else\n+\t{\n+\t  while (GET_CODE (r) == SUBREG\n+\t\t || GET_CODE (r) == STRICT_LOW_PART\n+\t\t || GET_CODE (r) == ZERO_EXTRACT)\n+\t    r = XEXP (r, 0);\n \n-      while (GET_CODE (r) == SUBREG || GET_CODE (r) == STRICT_LOW_PART\n-\t     || GET_CODE (r) == ZERO_EXTRACT)\n-\tr = XEXP (r, 0);\n+\t  if (GET_CODE (r) == REG)\n+\t    {\n+\t      int regno = REGNO (r);\n \n-      if (GET_CODE (r) == REG)\n-\t{\n-\t  int regno = REGNO (r);\n+\t      /* Obvious.  */\n+\t      if (REGNO_REG_SET_P (needed, regno))\n+\t\treturn 0;\n+\n+\t      /* If this is a hard register, verify that subsequent\n+\t\t words are not needed.  */\n+\t      if (regno < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  int n = HARD_REGNO_NREGS (regno, GET_MODE (r));\n+\n+\t\t  while (--n > 0)\n+\t\t    if (REGNO_REG_SET_P (needed, regno+n))\n+\t\t      return 0;\n+\t\t}\n+\n+\t      /* Don't delete insns to set global regs.  */\n+\t      if (regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n+\t\treturn 0;\n+\n+\t      /* Make sure insns to set the stack pointer aren't deleted.  */\n+\t      if (regno == STACK_POINTER_REGNUM)\n+\t\treturn 0;\n \n-\t  /* Don't delete insns to set global regs.  */\n-\t  if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n-\t      /* Make sure insns to set frame pointer aren't deleted.  */\n-\t      || (regno == FRAME_POINTER_REGNUM\n+\t      /* Make sure insns to set the frame pointer aren't deleted.  */\n+\t      if (regno == FRAME_POINTER_REGNUM\n \t\t  && (! reload_completed || frame_pointer_needed))\n+\t\treturn 0;\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t      || (regno == HARD_FRAME_POINTER_REGNUM\n+\t      if (regno == HARD_FRAME_POINTER_REGNUM\n \t\t  && (! reload_completed || frame_pointer_needed))\n+\t\treturn 0;\n #endif\n+\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n \t      /* Make sure insns to set arg pointer are never deleted\n-\t\t (if the arg pointer isn't fixed, there will be a USE for\n-\t\t it, so we can treat it normally).  */\n-\t      || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+\t\t (if the arg pointer isn't fixed, there will be a USE\n+\t\t for it, so we can treat it normally).  */\n+\t      if (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+\t\treturn 0;\n #endif\n-\t      || REGNO_REG_SET_P (needed, regno))\n-\t    return 0;\n \n-\t  /* If this is a hard register, verify that subsequent words are\n-\t     not needed.  */\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      int n = HARD_REGNO_NREGS (regno, GET_MODE (r));\n-\n-\t      while (--n > 0)\n-\t\tif (REGNO_REG_SET_P (needed, regno+n))\n-\t\t  return 0;\n+\t      /* Otherwise, the set is dead.  */\n+\t      return 1;\n \t    }\n-\n-\t  return 1;\n \t}\n     }\n \n-  /* If performing several activities,\n-     insn is dead if each activity is individually dead.\n-     Also, CLOBBERs and USEs can be ignored; a CLOBBER or USE\n-     that's inside a PARALLEL doesn't make the insn worth keeping.  */\n+  /* If performing several activities, insn is dead if each activity\n+     is individually dead.  Also, CLOBBERs and USEs can be ignored; a\n+     CLOBBER or USE that's inside a PARALLEL doesn't make the insn\n+     worth keeping.  */\n   else if (code == PARALLEL)\n     {\n       int i = XVECLEN (x, 0);\n@@ -4451,7 +4412,8 @@ mark_used_regs (needed, live, x, flags, insn)\n \t\t   it was allocated to the pseudos.  If the register will not\n \t\t   be eliminated, reload will set it live at that point.  */\n \n-\t\tif (! TEST_HARD_REG_BIT (elim_reg_set, regno))\n+\t\tif ((flags & PROP_REG_INFO)\n+\t\t    && ! TEST_HARD_REG_BIT (elim_reg_set, regno))\n \t\t  regs_ever_live[regno] = 1;\n \t\treturn;\n \t      }"}, {"sha": "24a7d2cb694003a0fcc52ab5d60194c1e29ff54c", "filename": "gcc/gcc.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -327,9 +327,11 @@ or with constant text in a single argument.\n  %Y\tOutput the accumulated assembler options specified by compilations.\n  %Z\tOutput the accumulated preprocessor options specified by compilations.\n  %v1\tSubstitute the major version number of GCC.\n-\t(For version 2.5.n, this is 2.)\n+\t(For version 2.5.3, this is 2.)\n  %v2\tSubstitute the minor version number of GCC.\n-\t(For version 2.5.n, this is 5.)\n+\t(For version 2.5.3, this is 5.)\n+ %v3\tSubstitute the patch level number of GCC.\n+\t(For version 2.5.3, this is 3.)\n  %a     process ASM_SPEC as a spec.\n         This allows config.h to specify part of the spec for running as.\n  %A\tprocess ASM_FINAL_SPEC as a spec.  A capital A is actually\n@@ -614,7 +616,7 @@ static struct compiler default_compilers[] =\n \t%{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU C does not support -C without using -E}}\\\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2}\\\n+        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n \t%{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\\\n         %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}}\\\n \t%{ffast-math:-D__FAST_MATH__}\\\n@@ -628,7 +630,7 @@ static struct compiler default_compilers[] =\n                   %{std*} %{nostdinc*} %{A*} %{I*} %I\\\n                   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*} %{a*}\\\n                   %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-                  %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2}\\\n+                  %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n \t\t  %{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\\\n                   %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}}\\\n \t\t  %{ffast-math:-D__FAST_MATH__}\\\n@@ -651,7 +653,7 @@ static struct compiler default_compilers[] =\n \t%{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU C does not support -C without using -E}}\\\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2}\\\n+        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n \t%{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\\\n         %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}}\\\n \t%{ffast-math:-D__FAST_MATH__}\\\n@@ -679,7 +681,7 @@ static struct compiler default_compilers[] =\n \t%{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU C does not support -C without using -E}}\\\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2}\\\n+        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n \t%{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\\\n         %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}}\\\n \t%{ffast-math:-D__FAST_MATH__}\\\n@@ -696,7 +698,7 @@ static struct compiler default_compilers[] =\n     cpp %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %{$} %I\\\n \t%{C:%{!E:%eGNU C does not support -C without using -E}}\\\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n-        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2}\\\n+        %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n \t%{!undef:%{!std=*:%p}%{std=gnu*:%p} %P} %{trigraphs}\\\n         %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}}\\\n \t%{ffast-math:-D__FAST_MATH__}\\\n@@ -4497,6 +4499,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      int c1 = *p++;  /* Select first or second version number.  */\n \t      char *v = compiler_version;\n \t      char *q;\n+\t      static const char zeroc = '0';\n \n \t      /* The format of the version string is\n \t\t ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */\n@@ -4508,7 +4511,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\tabort ();\n \n \t      /* If desired, advance to second version number.  */\n-\t      if (c1 == '2')\n+\t      if (c1 >= '2')\n \t\t{\n \t\t  /* Set V after the first period.  */\n \t\t  while (ISDIGIT (*v))\n@@ -4518,15 +4521,32 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t  v++;\n \t\t}\n \n+\t      /* If desired, advance to third version number.\n+                 But don't complain if it's not present */\n+\t      if (c1 == '3')\n+\t\t{\n+\t\t  /* Set V after the second period.  */\n+\t\t  while (ISDIGIT (*v))\n+\t\t    v++;\n+\t\t  if ((*v != 0) && (*v != ' ') && (*v != '.') && (*v != '-'))\n+\t\t    abort ();\n+                  if (*v != 0)\n+                      v++;\n+\t\t}\n+\n \t      /* Set Q at the next period or at the end.  */\n \t      q = v;\n \t      while (ISDIGIT (*q))\n \t\tq++;\n \t      if (*q != 0 && *q != ' ' && *q != '.' && *q != '-')\n \t\tabort ();\n \n-\t      /* Put that part into the command.  */\n-\t      obstack_grow (&obstack, v, q - v);\n+              if (q > v)\n+\t        /* Put that part into the command.  */\n+\t        obstack_grow (&obstack, v, q - v);\n+              else\n+                /* Default to \"0\" */\n+                obstack_grow (&obstack, &zeroc, 1);\n \t      arg_going = 1;\n \t    }\n \t    break;"}, {"sha": "ebdd2125993c9002249f85673ac896ba4e67319d", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3ea8083fc9062ef5c6f2e97b563ce2e8b3f7a8c6", "patch": "@@ -3237,6 +3237,7 @@ rest_of_compilation (decl)\n        if (optimize)\n \t calculate_loop_depth (rtl_dump_file);\n        life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n+       mark_constant_function ();\n      });\n \n   if (warn_uninitialized || extra_warnings)"}]}