{"sha": "33973fa754de1f95d459bfca66c0d80deec36537", "node_id": "C_kwDOANBUbNoAKDMzOTczZmE3NTRkZTFmOTVkNDU5YmZjYTY2YzBkODBkZWVjMzY1Mzc", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:24Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:24Z"}, "message": "gimple-match: Add a gimple_extract_op function\n\ncode_helper and gimple_match_op seem like generally useful ways\nof summing up a gimple_assign or gimple_call (or gimple_cond).\nThis patch adds a gimple_extract_op function that can be used\nfor that.\n\ngcc/\n\t* gimple-match.h (code_helper): Add functions for querying whether\n\tthe code represents an internal_fn or a built_in_function.\n\tProvide explicit conversion operators for both cases.\n\t(gimple_extract_op): Declare.\n\t* gimple-match-head.c (gimple_extract): New function, extracted from...\n\t(gimple_simplify): ...here.\n\t(gimple_extract_op): New function.", "tree": {"sha": "babdf829fa3b7a95f2e444ae0418240d4dc06727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/babdf829fa3b7a95f2e444ae0418240d4dc06727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33973fa754de1f95d459bfca66c0d80deec36537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33973fa754de1f95d459bfca66c0d80deec36537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33973fa754de1f95d459bfca66c0d80deec36537", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33973fa754de1f95d459bfca66c0d80deec36537/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd"}], "stats": {"total": 245, "additions": 135, "deletions": 110}, "files": [{"sha": "15053d1189efc677a4a191e33c6392f971236d2d", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 108, "deletions": 110, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33973fa754de1f95d459bfca66c0d80deec36537/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33973fa754de1f95d459bfca66c0d80deec36537/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=33973fa754de1f95d459bfca66c0d80deec36537", "patch": "@@ -890,12 +890,20 @@ try_conditional_simplification (internal_fn ifn, gimple_match_op *res_op,\n   return true;\n }\n \n-/* The main STMT based simplification entry.  It is used by the fold_stmt\n-   and the fold_stmt_to_constant APIs.  */\n+/* Common subroutine of gimple_extract_op and gimple_simplify.  Try to\n+   describe STMT in RES_OP, returning true on success.  Before recording\n+   an operand, call:\n \n-bool\n-gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n-\t\t tree (*valueize)(tree), tree (*top_valueize)(tree))\n+   - VALUEIZE_CONDITION for a COND_EXPR condition\n+   - VALUEIZE_OP for every other top-level operand\n+\n+   Both routines take a tree argument and returns a tree.  */\n+\n+template<typename ValueizeOp, typename ValueizeCondition>\n+inline bool\n+gimple_extract (gimple *stmt, gimple_match_op *res_op,\n+\t\tValueizeOp valueize_op,\n+\t\tValueizeCondition valueize_condition)\n {\n   switch (gimple_code (stmt))\n     {\n@@ -911,100 +919,50 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t\t|| code == VIEW_CONVERT_EXPR)\n \t      {\n \t\ttree op0 = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n-\t\tbool valueized = false;\n-\t\top0 = do_valueize (op0, top_valueize, valueized);\n-\t\tres_op->set_op (code, type, op0);\n-\t\treturn (gimple_resimplify1 (seq, res_op, valueize)\n-\t\t\t|| valueized);\n+\t\tres_op->set_op (code, type, valueize_op (op0));\n+\t\treturn true;\n \t      }\n \t    else if (code == BIT_FIELD_REF)\n \t      {\n \t\ttree rhs1 = gimple_assign_rhs1 (stmt);\n-\t\ttree op0 = TREE_OPERAND (rhs1, 0);\n-\t\tbool valueized = false;\n-\t\top0 = do_valueize (op0, top_valueize, valueized);\n+\t\ttree op0 = valueize_op (TREE_OPERAND (rhs1, 0));\n \t\tres_op->set_op (code, type, op0,\n \t\t\t\tTREE_OPERAND (rhs1, 1),\n \t\t\t\tTREE_OPERAND (rhs1, 2),\n \t\t\t\tREF_REVERSE_STORAGE_ORDER (rhs1));\n-\t\tif (res_op->reverse)\n-\t\t  return valueized;\n-\t\treturn (gimple_resimplify3 (seq, res_op, valueize)\n-\t\t\t|| valueized);\n+\t\treturn true;\n \t      }\n-\t    else if (code == SSA_NAME\n-\t\t     && top_valueize)\n+\t    else if (code == SSA_NAME)\n \t      {\n \t\ttree op0 = gimple_assign_rhs1 (stmt);\n-\t\ttree valueized = top_valueize (op0);\n-\t\tif (!valueized || op0 == valueized)\n-\t\t  return false;\n-\t\tres_op->set_op (TREE_CODE (op0), type, valueized);\n+\t\tres_op->set_op (TREE_CODE (op0), type, valueize_op (op0));\n \t\treturn true;\n \t      }\n \t    break;\n \t  case GIMPLE_UNARY_RHS:\n \t    {\n \t      tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t      bool valueized = false;\n-\t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n-\t      res_op->set_op (code, type, rhs1);\n-\t      return (gimple_resimplify1 (seq, res_op, valueize)\n-\t\t      || valueized);\n+\t      res_op->set_op (code, type, valueize_op (rhs1));\n+\t      return true;\n \t    }\n \t  case GIMPLE_BINARY_RHS:\n \t    {\n-\t      tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t      tree rhs2 = gimple_assign_rhs2 (stmt);\n-\t      bool valueized = false;\n-\t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n-\t      rhs2 = do_valueize (rhs2, top_valueize, valueized);\n+\t      tree rhs1 = valueize_op (gimple_assign_rhs1 (stmt));\n+\t      tree rhs2 = valueize_op (gimple_assign_rhs2 (stmt));\n \t      res_op->set_op (code, type, rhs1, rhs2);\n-\t      return (gimple_resimplify2 (seq, res_op, valueize)\n-\t\t      || valueized);\n+\t      return true;\n \t    }\n \t  case GIMPLE_TERNARY_RHS:\n \t    {\n-\t      bool valueized = false;\n \t      tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t      /* If this is a COND_EXPR first try to simplify an\n-\t\t embedded GENERIC condition.  */\n-\t      if (code == COND_EXPR)\n-\t\t{\n-\t\t  if (COMPARISON_CLASS_P (rhs1))\n-\t\t    {\n-\t\t      tree lhs = TREE_OPERAND (rhs1, 0);\n-\t\t      tree rhs = TREE_OPERAND (rhs1, 1);\n-\t\t      lhs = do_valueize (lhs, top_valueize, valueized);\n-\t\t      rhs = do_valueize (rhs, top_valueize, valueized);\n-\t\t      gimple_match_op res_op2 (res_op->cond, TREE_CODE (rhs1),\n-\t\t\t\t\t       TREE_TYPE (rhs1), lhs, rhs);\n-\t\t      if ((gimple_resimplify2 (seq, &res_op2, valueize)\n-\t\t\t   || valueized)\n-\t\t\t  && res_op2.code.is_tree_code ())\n-\t\t\t{\n-\t\t\t  valueized = true;\n-\t\t\t  if (TREE_CODE_CLASS ((enum tree_code) res_op2.code)\n-\t\t\t      == tcc_comparison)\n-\t\t\t    rhs1 = build2 (res_op2.code, TREE_TYPE (rhs1),\n-\t\t\t\t\t   res_op2.ops[0], res_op2.ops[1]);\n-\t\t\t  else if (res_op2.code == SSA_NAME\n-\t\t\t\t   || res_op2.code == INTEGER_CST\n-\t\t\t\t   || res_op2.code == VECTOR_CST)\n-\t\t\t    rhs1 = res_op2.ops[0];\n-\t\t\t  else\n-\t\t\t    valueized = false;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      tree rhs2 = gimple_assign_rhs2 (stmt);\n-\t      tree rhs3 = gimple_assign_rhs3 (stmt);\n-\t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n-\t      rhs2 = do_valueize (rhs2, top_valueize, valueized);\n-\t      rhs3 = do_valueize (rhs3, top_valueize, valueized);\n+\t      if (code == COND_EXPR && COMPARISON_CLASS_P (rhs1))\n+\t\trhs1 = valueize_condition (rhs1);\n+\t      else\n+\t\trhs1 = valueize_op (rhs1);\n+\t      tree rhs2 = valueize_op (gimple_assign_rhs2 (stmt));\n+\t      tree rhs3 = valueize_op (gimple_assign_rhs3 (stmt));\n \t      res_op->set_op (code, type, rhs1, rhs2, rhs3);\n-\t      return (gimple_resimplify3 (seq, res_op, valueize)\n-\t\t      || valueized);\n+\t      return true;\n \t    }\n \t  default:\n \t    gcc_unreachable ();\n@@ -1018,7 +976,6 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t  && gimple_call_num_args (stmt) >= 1\n \t  && gimple_call_num_args (stmt) <= 5)\n \t{\n-\t  bool valueized = false;\n \t  combined_fn cfn;\n \t  if (gimple_call_internal_p (stmt))\n \t    cfn = as_combined_fn (gimple_call_internal_fn (stmt));\n@@ -1028,7 +985,7 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t      if (!fn)\n \t\treturn false;\n \n-\t      fn = do_valueize (fn, top_valueize, valueized);\n+\t      fn = valueize_op (fn);\n \t      if (TREE_CODE (fn) != ADDR_EXPR\n \t\t  || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL)\n \t\treturn false;\n@@ -1044,47 +1001,17 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t  unsigned int num_args = gimple_call_num_args (stmt);\n \t  res_op->set_op (cfn, TREE_TYPE (gimple_call_lhs (stmt)), num_args);\n \t  for (unsigned i = 0; i < num_args; ++i)\n-\t    {\n-\t      tree arg = gimple_call_arg (stmt, i);\n-\t      res_op->ops[i] = do_valueize (arg, top_valueize, valueized);\n-\t    }\n-\t  if (internal_fn_p (cfn)\n-\t      && try_conditional_simplification (as_internal_fn (cfn),\n-\t\t\t\t\t\t res_op, seq, valueize))\n-\t    return true;\n-\t  switch (num_args)\n-\t    {\n-\t    case 1:\n-\t      return (gimple_resimplify1 (seq, res_op, valueize)\n-\t\t      || valueized);\n-\t    case 2:\n-\t      return (gimple_resimplify2 (seq, res_op, valueize)\n-\t\t      || valueized);\n-\t    case 3:\n-\t      return (gimple_resimplify3 (seq, res_op, valueize)\n-\t\t      || valueized);\n-\t    case 4:\n-\t      return (gimple_resimplify4 (seq, res_op, valueize)\n-\t\t      || valueized);\n-\t    case 5:\n-\t      return (gimple_resimplify5 (seq, res_op, valueize)\n-\t\t      || valueized);\n-\t    default:\n-\t     gcc_unreachable ();\n-\t    }\n+\t    res_op->ops[i] = valueize_op (gimple_call_arg (stmt, i));\n+\t  return true;\n \t}\n       break;\n \n     case GIMPLE_COND:\n       {\n-\ttree lhs = gimple_cond_lhs (stmt);\n-\ttree rhs = gimple_cond_rhs (stmt);\n-\tbool valueized = false;\n-\tlhs = do_valueize (lhs, top_valueize, valueized);\n-\trhs = do_valueize (rhs, top_valueize, valueized);\n+\ttree lhs = valueize_op (gimple_cond_lhs (stmt));\n+\ttree rhs = valueize_op (gimple_cond_rhs (stmt));\n \tres_op->set_op (gimple_cond_code (stmt), boolean_type_node, lhs, rhs);\n-\treturn (gimple_resimplify2 (seq, res_op, valueize)\n-\t\t|| valueized);\n+\treturn true;\n       }\n \n     default:\n@@ -1094,6 +1021,77 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n   return false;\n }\n \n+/* Try to describe STMT in RES_OP, returning true on success.\n+   For GIMPLE_CONDs, describe the condition that is being tested.\n+   For GIMPLE_ASSIGNs, describe the rhs of the assignment.\n+   For GIMPLE_CALLs, describe the call.  */\n+\n+bool\n+gimple_extract_op (gimple *stmt, gimple_match_op *res_op)\n+{\n+  auto nop = [](tree op) { return op; };\n+  return gimple_extract (stmt, res_op, nop, nop);\n+}\n+\n+/* The main STMT based simplification entry.  It is used by the fold_stmt\n+   and the fold_stmt_to_constant APIs.  */\n+\n+bool\n+gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n+\t\t tree (*valueize)(tree), tree (*top_valueize)(tree))\n+{\n+  bool valueized = false;\n+  auto valueize_op = [&](tree op)\n+    {\n+      return do_valueize (op, top_valueize, valueized);\n+    };\n+  auto valueize_condition = [&](tree op) -> tree\n+    {\n+      bool cond_valueized = false;\n+      tree lhs = do_valueize (TREE_OPERAND (op, 0), top_valueize,\n+\t\t\t      cond_valueized);\n+      tree rhs = do_valueize (TREE_OPERAND (op, 1), top_valueize,\n+\t\t\t      cond_valueized);\n+      gimple_match_op res_op2 (res_op->cond, TREE_CODE (op),\n+\t\t\t       TREE_TYPE (op), lhs, rhs);\n+      if ((gimple_resimplify2 (seq, &res_op2, valueize)\n+\t   || cond_valueized)\n+\t  && res_op2.code.is_tree_code ())\n+\t{\n+\t  if (TREE_CODE_CLASS ((tree_code) res_op2.code) == tcc_comparison)\n+\t    {\n+\t      valueized = true;\n+\t      return build2 (res_op2.code, TREE_TYPE (op),\n+\t\t\t     res_op2.ops[0], res_op2.ops[1]);\n+\t    }\n+\t  else if (res_op2.code == SSA_NAME\n+\t\t   || res_op2.code == INTEGER_CST\n+\t\t   || res_op2.code == VECTOR_CST)\n+\t    {\n+\t      valueized = true;\n+\t      return res_op2.ops[0];\n+\t    }\n+\t}\n+      return valueize_op (op);\n+    };\n+\n+  if (!gimple_extract (stmt, res_op, valueize_op, valueize_condition))\n+    return false;\n+\n+  if (res_op->code.is_internal_fn ())\n+    {\n+      internal_fn ifn = internal_fn (res_op->code);\n+      if (try_conditional_simplification (ifn, res_op, seq, valueize))\n+\treturn true;\n+    }\n+\n+  if (!res_op->reverse\n+      && res_op->num_ops\n+      && res_op->resimplify (seq, valueize))\n+    return true;\n+\n+  return valueized;\n+}\n \n /* Helper for the autogenerated code, valueize OP.  */\n "}, {"sha": "8abeafebb00cf6d4a463bac063bd88c089526fd7", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33973fa754de1f95d459bfca66c0d80deec36537/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33973fa754de1f95d459bfca66c0d80deec36537/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=33973fa754de1f95d459bfca66c0d80deec36537", "patch": "@@ -33,13 +33,39 @@ class code_helper\n   code_helper (combined_fn fn) : rep (-(int) fn) {}\n   operator tree_code () const { return (tree_code) rep; }\n   operator combined_fn () const { return (combined_fn) -rep; }\n+  explicit operator internal_fn () const;\n+  explicit operator built_in_function () const;\n   bool is_tree_code () const { return rep > 0; }\n   bool is_fn_code () const { return rep < 0; }\n+  bool is_internal_fn () const;\n+  bool is_builtin_fn () const;\n   int get_rep () const { return rep; }\n private:\n   int rep;\n };\n \n+inline code_helper::operator internal_fn () const\n+{\n+  return as_internal_fn (combined_fn (*this));\n+}\n+\n+inline code_helper::operator built_in_function () const\n+{\n+  return as_builtin_fn (combined_fn (*this));\n+}\n+\n+inline bool\n+code_helper::is_internal_fn () const\n+{\n+  return is_fn_code () && internal_fn_p (combined_fn (*this));\n+}\n+\n+inline bool\n+code_helper::is_builtin_fn () const\n+{\n+  return is_fn_code () && builtin_fn_p (combined_fn (*this));\n+}\n+\n /* Represents the condition under which an operation should happen,\n    and the value to use otherwise.  The condition applies elementwise\n    (as for VEC_COND_EXPR) if the values are vectors.  */\n@@ -333,6 +359,7 @@ gimple_simplified_result_is_gimple_val (const gimple_match_op *op)\n \n extern tree (*mprts_hook) (gimple_match_op *);\n \n+bool gimple_extract_op (gimple *, gimple_match_op *);\n bool gimple_simplify (gimple *, gimple_match_op *, gimple_seq *,\n \t\t      tree (*)(tree), tree (*)(tree));\n tree maybe_push_res_to_seq (gimple_match_op *, gimple_seq *,"}]}