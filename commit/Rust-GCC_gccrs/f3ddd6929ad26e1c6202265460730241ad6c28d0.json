{"sha": "f3ddd6929ad26e1c6202265460730241ad6c28d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNkZGQ2OTI5YWQyNmUxYzYyMDIyNjU0NjA3MzAyNDFhZDZjMjhkMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-11-12T15:52:26Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:52:26Z"}, "message": "Implement protection of stack variables\n\nThis patch implements the protection of stack variables.\n\nIt lays out stack variables as well as the different red zones,\nemits some prologue code to populate the shadow memory as to poison\n(mark as non-accessible) the regions of the red zones and mark the\nregions of stack variables as accessible, and emit some epilogue code\nto un-poison (mark as accessible) the regions of red zones right\nbefore the function exits.\n\n\t* Makefile.in (asan.o): Depend on $(EXPR_H) $(OPTABS_H).\n\t(cfgexpand.o): Depend on asan.h.\n\t* asan.c: Include expr.h and optabs.h.\n\t(asan_shadow_set): New variable.\n\t(asan_shadow_cst, asan_emit_stack_protection): New functions.\n\t(asan_init_shadow_ptr_types): Initialize also asan_shadow_set.\n\t* cfgexpand.c: Include asan.h.  Define HOST_WIDE_INT heap vector.\n\t(partition_stack_vars): If i is large alignment and j small\n\talignment or vice versa, break out of the loop instead of continue,\n\tand put the test earlier.  If flag_asan, break out of the loop\n\tif for small alignment size is different.\n\t(struct stack_vars_data): New type.\n\t(expand_stack_vars): Add DATA argument.  Change PRED type to\n\tfunction taking size_t argument instead of tree.  Adjust pred\n\tcalls.  Fill DATA in and add needed padding in between variables\n\tif -faddress-sanitizer.\n\t(defer_stack_allocation): Defer everything for flag_asan.\n\t(stack_protect_decl_phase_1, stack_protect_decl_phase_2): Take\n\tsize_t index into stack_vars array instead of the decl directly.\n\t(asan_decl_phase_3): New function.\n\t(expand_used_vars): Return var destruction sequence.  Adjust\n\texpand_stack_vars calls, add another one for flag_asan.  Call\n\tasan_emit_stack_protection if expand_stack_vars added anything\n\tto the vectors.\n\t(expand_gimple_basic_block): Add disable_tail_calls argument.\n\t(gimple_expand_cfg): Pass true to it if expand_used_vars returned\n\tnon-NULL.  Emit the sequence returned by expand_used_vars after\n\treturn_label.\n\t* asan.h (asan_emit_stack_protection): New prototype.\n\t(asan_shadow_set): New decl.\n\t(ASAN_RED_ZONE_SIZE, ASAN_STACK_MAGIC_LEFT, ASAN_STACK_MAGIC_MIDDLE,\n\tASAN_STACK_MAGIC_RIGHT, ASAN_STACK_FRAME_MAGIC): Define.\n\t(asan_protect_stack_decl): New inline.\n\t* toplev.c (process_options): Also disable -faddress-sanitizer on\n\t!FRAME_GROWS_DOWNWARDS targets.\n\nFrom-SVN: r193436", "tree": {"sha": "199bfa081ada2d767c47988ded788ff71b17e44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/199bfa081ada2d767c47988ded788ff71b17e44d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3ddd6929ad26e1c6202265460730241ad6c28d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ddd6929ad26e1c6202265460730241ad6c28d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3ddd6929ad26e1c6202265460730241ad6c28d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ddd6929ad26e1c6202265460730241ad6c28d0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dfb9e332a5ceefd6770c028d9a937ab869116cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb9e332a5ceefd6770c028d9a937ab869116cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb9e332a5ceefd6770c028d9a937ab869116cba"}], "stats": {"total": 548, "additions": 514, "deletions": 34}, "files": [{"sha": "0d8e5cc1109e27bada215984c2d9e7103934342e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3ddd6929ad26e1c6202265460730241ad6c28d0", "patch": "@@ -1,3 +1,41 @@\n+2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* Makefile.in (asan.o): Depend on $(EXPR_H) $(OPTABS_H).\n+\t(cfgexpand.o): Depend on asan.h.\n+\t* asan.c: Include expr.h and optabs.h.\n+\t(asan_shadow_set): New variable.\n+\t(asan_shadow_cst, asan_emit_stack_protection): New functions.\n+\t(asan_init_shadow_ptr_types): Initialize also asan_shadow_set.\n+\t* cfgexpand.c: Include asan.h.  Define HOST_WIDE_INT heap vector.\n+\t(partition_stack_vars): If i is large alignment and j small\n+\talignment or vice versa, break out of the loop instead of continue,\n+\tand put the test earlier.  If flag_asan, break out of the loop\n+\tif for small alignment size is different.\n+\t(struct stack_vars_data): New type.\n+\t(expand_stack_vars): Add DATA argument.  Change PRED type to\n+\tfunction taking size_t argument instead of tree.  Adjust pred\n+\tcalls.  Fill DATA in and add needed padding in between variables\n+\tif -faddress-sanitizer.\n+\t(defer_stack_allocation): Defer everything for flag_asan.\n+\t(stack_protect_decl_phase_1, stack_protect_decl_phase_2): Take\n+\tsize_t index into stack_vars array instead of the decl directly.\n+\t(asan_decl_phase_3): New function.\n+\t(expand_used_vars): Return var destruction sequence.  Adjust\n+\texpand_stack_vars calls, add another one for flag_asan.  Call\n+\tasan_emit_stack_protection if expand_stack_vars added anything\n+\tto the vectors.\n+\t(expand_gimple_basic_block): Add disable_tail_calls argument.\n+\t(gimple_expand_cfg): Pass true to it if expand_used_vars returned\n+\tnon-NULL.  Emit the sequence returned by expand_used_vars after\n+\treturn_label.\n+\t* asan.h (asan_emit_stack_protection): New prototype.\n+\t(asan_shadow_set): New decl.\n+\t(ASAN_RED_ZONE_SIZE, ASAN_STACK_MAGIC_LEFT, ASAN_STACK_MAGIC_MIDDLE,\n+\tASAN_STACK_MAGIC_RIGHT, ASAN_STACK_FRAME_MAGIC): Define.\n+\t(asan_protect_stack_decl): New inline.\n+\t* toplev.c (process_options): Also disable -faddress-sanitizer on\n+\t!FRAME_GROWS_DOWNWARDS targets.\n+\n 2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* asan.c (build_check_stmt): Rename join_bb variable to else_bb."}, {"sha": "7a0b07414727336d68ffe3bbb88eccc1d5d7bd58", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f3ddd6929ad26e1c6202265460730241ad6c28d0", "patch": "@@ -2211,7 +2211,7 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n asan.o : asan.c asan.h $(CONFIG_H) $(SYSTEM_H) $(GIMPLE_H) \\\n    output.h coretypes.h $(GIMPLE_PRETTY_PRINT_H) \\\n    tree-iterator.h $(TREE_FLOW_H) $(TREE_PASS_H) \\\n-   $(TARGET_H)\n+   $(TARGET_H) $(EXPR_H) $(OPTABS_H)\n tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n@@ -3082,7 +3082,7 @@ cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(DIAGNOSTIC_H) toplev.h $(DIAGNOSTIC_CORE_H) $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H) \\\n    value-prof.h $(TREE_INLINE_H) $(TARGET_H) $(SSAEXPAND_H) $(REGS_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) $(BITMAP_H) sbitmap.h \\\n-   $(INSN_ATTR_H) $(CFGLOOP_H)\n+   $(INSN_ATTR_H) $(CFGLOOP_H) asan.h\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    $(FUNCTION_H) $(EXCEPT_H) $(TM_P_H) $(INSN_ATTR_H) \\"}, {"sha": "b9f27443f5220a281cad57a061735266d750a545", "filename": "gcc/asan.c", "status": "modified", "additions": 297, "deletions": 9, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=f3ddd6929ad26e1c6202265460730241ad6c28d0", "patch": "@@ -29,6 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"gimple-pretty-print.h\"\n #include \"target.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n \n /*\n  AddressSanitizer finds out-of-bounds and use-after-free bugs \n@@ -58,17 +60,303 @@ along with GCC; see the file COPYING3.  If not see\n  Read more:\n  http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n \n- Future work:\n- The current implementation supports only detection of out-of-bounds and\n- use-after-free bugs in heap.\n- In order to support out-of-bounds for stack and globals we will need\n- to create redzones for stack and global object and poison them.\n-*/\n+ The current implementation supports detection of out-of-bounds and\n+ use-after-free in the heap, on the stack and for global variables.\n+\n+ [Protection of stack variables]\n+\n+ To understand how detection of out-of-bounds and use-after-free works\n+ for stack variables, lets look at this example on x86_64 where the\n+ stack grows downward:\n+\n+     int\n+     foo ()\n+     {\n+       char a[23] = {0};\n+       int b[2] = {0};\n+\n+       a[5] = 1;\n+       b[1] = 2;\n+\n+       return a[5] + b[1];\n+     }\n+\n+ For this function, the stack protected by asan will be organized as\n+ follows, from the top of the stack to the bottom:\n+\n+ Slot 1/ [red zone of 32 bytes called 'RIGHT RedZone']\n+\n+ Slot 2/ [8 bytes of red zone, that adds up to the space of 'a' to make\n+\t  the next slot be 32 bytes aligned; this one is called Partial\n+\t  Redzone; this 32 bytes alignment is an asan constraint]\n+\n+ Slot 3/ [24 bytes for variable 'a']\n+\n+ Slot 4/ [red zone of 32 bytes called 'Middle RedZone']\n+\n+ Slot 5/ [24 bytes of Partial Red Zone (similar to slot 2]\n+\n+ Slot 6/ [8 bytes for variable 'b']\n+\n+ Slot 7/ [32 bytes of Red Zone at the bottom of the stack, called 'LEFT\n+\t  RedZone']\n+\n+ The 32 bytes of LEFT red zone at the bottom of the stack can be\n+ decomposed as such:\n+\n+     1/ The first 8 bytes contain a magical asan number that is always\n+     0x41B58AB3.\n+\n+     2/ The following 8 bytes contains a pointer to a string (to be\n+     parsed at runtime by the runtime asan library), which format is\n+     the following:\n+\n+      \"<function-name> <space> <num-of-variables-on-the-stack>\n+      (<32-bytes-aligned-offset-in-bytes-of-variable> <space>\n+      <length-of-var-in-bytes> ){n} \"\n+\n+\twhere '(...){n}' means the content inside the parenthesis occurs 'n'\n+\ttimes, with 'n' being the number of variables on the stack.\n+\n+      3/ The following 16 bytes of the red zone have no particular\n+      format.\n+\n+ The shadow memory for that stack layout is going to look like this:\n+\n+     - content of shadow memory 8 bytes for slot 7: 0xF1F1F1F1.\n+       The F1 byte pattern is a magic number called\n+       ASAN_STACK_MAGIC_LEFT and is a way for the runtime to know that\n+       the memory for that shadow byte is part of a the LEFT red zone\n+       intended to seat at the bottom of the variables on the stack.\n+\n+     - content of shadow memory 8 bytes for slots 6 and 5:\n+       0xF4F4F400.  The F4 byte pattern is a magic number\n+       called ASAN_STACK_MAGIC_PARTIAL.  It flags the fact that the\n+       memory region for this shadow byte is a PARTIAL red zone\n+       intended to pad a variable A, so that the slot following\n+       {A,padding} is 32 bytes aligned.\n+\n+       Note that the fact that the least significant byte of this\n+       shadow memory content is 00 means that 8 bytes of its\n+       corresponding memory (which corresponds to the memory of\n+       variable 'b') is addressable.\n+\n+     - content of shadow memory 8 bytes for slot 4: 0xF2F2F2F2.\n+       The F2 byte pattern is a magic number called\n+       ASAN_STACK_MAGIC_MIDDLE.  It flags the fact that the memory\n+       region for this shadow byte is a MIDDLE red zone intended to\n+       seat between two 32 aligned slots of {variable,padding}.\n+\n+     - content of shadow memory 8 bytes for slot 3 and 2:\n+       0xFFFFFFFFF4000000.  This represents is the concatenation of\n+       variable 'a' and the partial red zone following it, like what we\n+       had for variable 'b'.  The least significant 3 bytes being 00\n+       means that the 3 bytes of variable 'a' are addressable.\n+\n+     - content of shadow memory 8 bytes for slot 1: 0xFFFFFFFFF3F3F3F3.\n+       The F3 byte pattern is a magic number called\n+       ASAN_STACK_MAGIC_RIGHT.  It flags the fact that the memory\n+       region for this shadow byte is a RIGHT red zone intended to seat\n+       at the top of the variables of the stack.\n+\n+ Note that the real variable layout is done in expand_used_vars in\n+ cfgexpand.c.  As far as Address Sanitizer is concerned, it lays out\n+ stack variables as well as the different red zones, emits some\n+ prologue code to populate the shadow memory as to poison (mark as\n+ non-accessible) the regions of the red zones and mark the regions of\n+ stack variables as accessible, and emit some epilogue code to\n+ un-poison (mark as accessible) the regions of red zones right before\n+ the function exits.  */\n+\n+alias_set_type asan_shadow_set = -1;\n \n /* Pointer types to 1 resp. 2 byte integers in shadow memory.  A separate\n    alias set is used for all shadow memory accesses.  */\n static GTY(()) tree shadow_ptr_types[2];\n \n+/* Return a CONST_INT representing 4 subsequent shadow memory bytes.  */\n+\n+static rtx\n+asan_shadow_cst (unsigned char shadow_bytes[4])\n+{\n+  int i;\n+  unsigned HOST_WIDE_INT val = 0;\n+  gcc_assert (WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN);\n+  for (i = 0; i < 4; i++)\n+    val |= (unsigned HOST_WIDE_INT) shadow_bytes[BYTES_BIG_ENDIAN ? 3 - i : i]\n+\t   << (BITS_PER_UNIT * i);\n+  return GEN_INT (trunc_int_for_mode (val, SImode));\n+}\n+\n+/* Insert code to protect stack vars.  The prologue sequence should be emitted\n+   directly, epilogue sequence returned.  BASE is the register holding the\n+   stack base, against which OFFSETS array offsets are relative to, OFFSETS\n+   array contains pairs of offsets in reverse order, always the end offset\n+   of some gap that needs protection followed by starting offset,\n+   and DECLS is an array of representative decls for each var partition.\n+   LENGTH is the length of the OFFSETS array, DECLS array is LENGTH / 2 - 1\n+   elements long (OFFSETS include gap before the first variable as well\n+   as gaps after each stack variable).  */\n+\n+rtx\n+asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n+\t\t\t    int length)\n+{\n+  rtx shadow_base, shadow_mem, ret, mem;\n+  unsigned char shadow_bytes[4];\n+  HOST_WIDE_INT base_offset = offsets[length - 1], offset, prev_offset;\n+  HOST_WIDE_INT last_offset, last_size;\n+  int l;\n+  unsigned char cur_shadow_byte = ASAN_STACK_MAGIC_LEFT;\n+  static pretty_printer pp;\n+  static bool pp_initialized;\n+  const char *buf;\n+  size_t len;\n+  tree str_cst;\n+\n+  /* First of all, prepare the description string.  */\n+  if (!pp_initialized)\n+    {\n+      pp_construct (&pp, /* prefix */NULL, /* line-width */0);\n+      pp_initialized = true;\n+    }\n+  pp_clear_output_area (&pp);\n+  if (DECL_NAME (current_function_decl))\n+    pp_base_tree_identifier (&pp, DECL_NAME (current_function_decl));\n+  else\n+    pp_string (&pp, \"<unknown>\");\n+  pp_space (&pp);\n+  pp_decimal_int (&pp, length / 2 - 1);\n+  pp_space (&pp);\n+  for (l = length - 2; l; l -= 2)\n+    {\n+      tree decl = decls[l / 2 - 1];\n+      pp_wide_integer (&pp, offsets[l] - base_offset);\n+      pp_space (&pp);\n+      pp_wide_integer (&pp, offsets[l - 1] - offsets[l]);\n+      pp_space (&pp);\n+      if (DECL_P (decl) && DECL_NAME (decl))\n+\t{\n+\t  pp_decimal_int (&pp, IDENTIFIER_LENGTH (DECL_NAME (decl)));\n+\t  pp_space (&pp);\n+\t  pp_base_tree_identifier (&pp, DECL_NAME (decl));\n+\t}\n+      else\n+\tpp_string (&pp, \"9 <unknown>\");\n+      pp_space (&pp);\n+    }\n+  buf = pp_base_formatted_text (&pp);\n+  len = strlen (buf);\n+  str_cst = build_string (len + 1, buf);\n+  TREE_TYPE (str_cst)\n+    = build_array_type (char_type_node, build_index_type (size_int (len)));\n+  TREE_READONLY (str_cst) = 1;\n+  TREE_STATIC (str_cst) = 1;\n+  str_cst = build1 (ADDR_EXPR, build_pointer_type (char_type_node), str_cst);\n+\n+  /* Emit the prologue sequence.  */\n+  base = expand_binop (Pmode, add_optab, base, GEN_INT (base_offset),\n+\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n+  mem = gen_rtx_MEM (ptr_mode, base);\n+  emit_move_insn (mem, GEN_INT (ASAN_STACK_FRAME_MAGIC));\n+  mem = adjust_address (mem, VOIDmode, GET_MODE_SIZE (ptr_mode));\n+  emit_move_insn (mem, expand_normal (str_cst));\n+  shadow_base = expand_binop (Pmode, lshr_optab, base,\n+\t\t\t      GEN_INT (ASAN_SHADOW_SHIFT),\n+\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+  shadow_base = expand_binop (Pmode, add_optab, shadow_base,\n+\t\t\t      GEN_INT (targetm.asan_shadow_offset ()),\n+\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+  gcc_assert (asan_shadow_set != -1\n+\t      && (ASAN_RED_ZONE_SIZE >> ASAN_SHADOW_SHIFT) == 4);\n+  shadow_mem = gen_rtx_MEM (SImode, shadow_base);\n+  set_mem_alias_set (shadow_mem, asan_shadow_set);\n+  prev_offset = base_offset;\n+  for (l = length; l; l -= 2)\n+    {\n+      if (l == 2)\n+\tcur_shadow_byte = ASAN_STACK_MAGIC_RIGHT;\n+      offset = offsets[l - 1];\n+      if ((offset - base_offset) & (ASAN_RED_ZONE_SIZE - 1))\n+\t{\n+\t  int i;\n+\t  HOST_WIDE_INT aoff\n+\t    = base_offset + ((offset - base_offset)\n+\t\t\t     & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1));\n+\t  shadow_mem = adjust_address (shadow_mem, VOIDmode,\n+\t\t\t\t       (aoff - prev_offset)\n+\t\t\t\t       >> ASAN_SHADOW_SHIFT);\n+\t  prev_offset = aoff;\n+\t  for (i = 0; i < 4; i++, aoff += (1 << ASAN_SHADOW_SHIFT))\n+\t    if (aoff < offset)\n+\t      {\n+\t\tif (aoff < offset - (1 << ASAN_SHADOW_SHIFT) + 1)\n+\t\t  shadow_bytes[i] = 0;\n+\t\telse\n+\t\t  shadow_bytes[i] = offset - aoff;\n+\t      }\n+\t    else\n+\t      shadow_bytes[i] = ASAN_STACK_MAGIC_PARTIAL;\n+\t  emit_move_insn (shadow_mem, asan_shadow_cst (shadow_bytes));\n+\t  offset = aoff;\n+\t}\n+      while (offset <= offsets[l - 2] - ASAN_RED_ZONE_SIZE)\n+\t{\n+\t  shadow_mem = adjust_address (shadow_mem, VOIDmode,\n+\t\t\t\t       (offset - prev_offset)\n+\t\t\t\t       >> ASAN_SHADOW_SHIFT);\n+\t  prev_offset = offset;\n+\t  memset (shadow_bytes, cur_shadow_byte, 4);\n+\t  emit_move_insn (shadow_mem, asan_shadow_cst (shadow_bytes));\n+\t  offset += ASAN_RED_ZONE_SIZE;\n+\t}\n+      cur_shadow_byte = ASAN_STACK_MAGIC_MIDDLE;\n+    }\n+  do_pending_stack_adjust ();\n+\n+  /* Construct epilogue sequence.  */\n+  start_sequence ();\n+\n+  shadow_mem = gen_rtx_MEM (BLKmode, shadow_base);\n+  set_mem_alias_set (shadow_mem, asan_shadow_set);\n+  prev_offset = base_offset;\n+  last_offset = base_offset;\n+  last_size = 0;\n+  for (l = length; l; l -= 2)\n+    {\n+      offset = base_offset + ((offsets[l - 1] - base_offset)\n+\t\t\t     & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1));\n+      if (last_offset + last_size != offset)\n+\t{\n+\t  shadow_mem = adjust_address (shadow_mem, VOIDmode,\n+\t\t\t\t       (last_offset - prev_offset)\n+\t\t\t\t       >> ASAN_SHADOW_SHIFT);\n+\t  prev_offset = last_offset;\n+\t  clear_storage (shadow_mem, GEN_INT (last_size >> ASAN_SHADOW_SHIFT),\n+\t\t\t BLOCK_OP_NORMAL);\n+\t  last_offset = offset;\n+\t  last_size = 0;\n+\t}\n+      last_size += base_offset + ((offsets[l - 2] - base_offset)\n+\t\t\t\t  & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1))\n+\t\t   - offset;\n+    }\n+  if (last_size)\n+    {\n+      shadow_mem = adjust_address (shadow_mem, VOIDmode,\n+\t\t\t\t   (last_offset - prev_offset)\n+\t\t\t\t   >> ASAN_SHADOW_SHIFT);\n+      clear_storage (shadow_mem, GEN_INT (last_size >> ASAN_SHADOW_SHIFT),\n+\t\t     BLOCK_OP_NORMAL);\n+    }\n+\n+  do_pending_stack_adjust ();\n+\n+  ret = get_insns ();\n+  end_sequence ();\n+  return ret;\n+}\n+\n /* Construct a function tree for __asan_report_{load,store}{1,2,4,8,16}.\n    IS_STORE is either 1 (for a store) or 0 (for a load).\n    SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n@@ -389,12 +677,12 @@ asan_finish_file (void)\n static void\n asan_init_shadow_ptr_types (void)\n {\n-  alias_set_type set = new_alias_set ();\n+  asan_shadow_set = new_alias_set ();\n   shadow_ptr_types[0] = build_distinct_type_copy (signed_char_type_node);\n-  TYPE_ALIAS_SET (shadow_ptr_types[0]) = set;\n+  TYPE_ALIAS_SET (shadow_ptr_types[0]) = asan_shadow_set;\n   shadow_ptr_types[0] = build_pointer_type (shadow_ptr_types[0]);\n   shadow_ptr_types[1] = build_distinct_type_copy (short_integer_type_node);\n-  TYPE_ALIAS_SET (shadow_ptr_types[1]) = set;\n+  TYPE_ALIAS_SET (shadow_ptr_types[1]) = asan_shadow_set;\n   shadow_ptr_types[1] = build_pointer_type (shadow_ptr_types[1]);\n }\n "}, {"sha": "6f0edbf27b26810f3064cd2a896a525a1575eeaa", "filename": "gcc/asan.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=f3ddd6929ad26e1c6202265460730241ad6c28d0", "patch": "@@ -21,10 +21,39 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef TREE_ASAN\n #define TREE_ASAN\n \n-extern void asan_finish_file(void);\n+extern void asan_finish_file (void);\n+extern rtx asan_emit_stack_protection (rtx, HOST_WIDE_INT *, tree *, int);\n+\n+/* Alias set for accessing the shadow memory.  */\n+extern alias_set_type asan_shadow_set;\n \n /* Shadow memory is found at\n    (address >> ASAN_SHADOW_SHIFT) + targetm.asan_shadow_offset ().  */\n #define ASAN_SHADOW_SHIFT\t3\n \n+/* Red zone size, stack and global variables are padded by ASAN_RED_ZONE_SIZE\n+   up to 2 * ASAN_RED_ZONE_SIZE - 1 bytes.  */\n+#define ASAN_RED_ZONE_SIZE\t32\n+\n+/* Shadow memory values for stack protection.  Left is below protected vars,\n+   the first pointer in stack corresponding to that offset contains\n+   ASAN_STACK_FRAME_MAGIC word, the second pointer to a string describing\n+   the frame.  Middle is for padding in between variables, right is\n+   above the last protected variable and partial immediately after variables\n+   up to ASAN_RED_ZONE_SIZE alignment.  */\n+#define ASAN_STACK_MAGIC_LEFT\t\t0xf1\n+#define ASAN_STACK_MAGIC_MIDDLE\t\t0xf2\n+#define ASAN_STACK_MAGIC_RIGHT\t\t0xf3\n+#define ASAN_STACK_MAGIC_PARTIAL\t0xf4\n+\n+#define ASAN_STACK_FRAME_MAGIC\t0x41b58ab3\n+\n+/* Return true if DECL should be guarded on the stack.  */\n+\n+static inline bool\n+asan_protect_stack_decl (tree decl)\n+{\n+  return DECL_P (decl) && !DECL_ARTIFICIAL (decl);\n+}\n+\n #endif /* TREE_ASAN */"}, {"sha": "2c17ec127a410684c943d356c125c3d5260f1612", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 144, "deletions": 21, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f3ddd6929ad26e1c6202265460730241ad6c28d0", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"regs.h\" /* For reg_renumber.  */\n #include \"insn-attr.h\" /* For INSN_SCHEDULING.  */\n+#include \"asan.h\"\n \n /* This variable holds information helping the rewriting of SSA trees\n    into RTL.  */\n@@ -736,6 +737,7 @@ partition_stack_vars (void)\n     {\n       size_t i = stack_vars_sorted[si];\n       unsigned int ialign = stack_vars[i].alignb;\n+      HOST_WIDE_INT isize = stack_vars[i].size;\n \n       /* Ignore objects that aren't partition representatives. If we\n          see a var that is not a partition representative, it must\n@@ -747,19 +749,28 @@ partition_stack_vars (void)\n \t{\n \t  size_t j = stack_vars_sorted[sj];\n \t  unsigned int jalign = stack_vars[j].alignb;\n+\t  HOST_WIDE_INT jsize = stack_vars[j].size;\n \n \t  /* Ignore objects that aren't partition representatives.  */\n \t  if (stack_vars[j].representative != j)\n \t    continue;\n \n-\t  /* Ignore conflicting objects.  */\n-\t  if (stack_var_conflict_p (i, j))\n-\t    continue;\n-\n \t  /* Do not mix objects of \"small\" (supported) alignment\n \t     and \"large\" (unsupported) alignment.  */\n \t  if ((ialign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t      != (jalign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT))\n+\t    break;\n+\n+\t  /* For Address Sanitizer do not mix objects with different\n+\t     sizes, as the shorter vars wouldn't be adequately protected.\n+\t     Don't do that for \"large\" (unsupported) alignment objects,\n+\t     those aren't protected anyway.  */\n+\t  if (flag_asan && isize != jsize\n+\t      && ialign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n+\t    break;\n+\n+\t  /* Ignore conflicting objects.  */\n+\t  if (stack_var_conflict_p (i, j))\n \t    continue;\n \n \t  /* UNION the objects, placing J at OFFSET.  */\n@@ -837,12 +848,26 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n   set_rtl (decl, x);\n }\n \n+DEF_VEC_I(HOST_WIDE_INT);\n+DEF_VEC_ALLOC_I(HOST_WIDE_INT,heap);\n+\n+struct stack_vars_data\n+{\n+  /* Vector of offset pairs, always end of some padding followed\n+     by start of the padding that needs Address Sanitizer protection.\n+     The vector is in reversed, highest offset pairs come first.  */\n+  VEC(HOST_WIDE_INT, heap) *asan_vec;\n+\n+  /* Vector of partition representative decls in between the paddings.  */\n+  VEC(tree, heap) *asan_decl_vec;\n+};\n+\n /* A subroutine of expand_used_vars.  Give each partition representative\n    a unique location within the stack frame.  Update each partition member\n    with that location.  */\n \n static void\n-expand_stack_vars (bool (*pred) (tree))\n+expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n {\n   size_t si, i, j, n = stack_vars_num;\n   HOST_WIDE_INT large_size = 0, large_alloc = 0;\n@@ -913,13 +938,45 @@ expand_stack_vars (bool (*pred) (tree))\n \n       /* Check the predicate to see whether this variable should be\n \t allocated in this pass.  */\n-      if (pred && !pred (decl))\n+      if (pred && !pred (i))\n \tcontinue;\n \n       alignb = stack_vars[i].alignb;\n       if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t{\n-\t  offset = alloc_stack_frame_space (stack_vars[i].size, alignb);\n+\t  if (flag_asan && pred)\n+\t    {\n+\t      HOST_WIDE_INT prev_offset = frame_offset;\n+\t      tree repr_decl = NULL_TREE;\n+\n+\t      offset\n+\t\t= alloc_stack_frame_space (stack_vars[i].size\n+\t\t\t\t\t   + ASAN_RED_ZONE_SIZE,\n+\t\t\t\t\t   MAX (alignb, ASAN_RED_ZONE_SIZE));\n+\t      VEC_safe_push (HOST_WIDE_INT, heap, data->asan_vec,\n+\t\t\t     prev_offset);\n+\t      VEC_safe_push (HOST_WIDE_INT, heap, data->asan_vec,\n+\t\t\t     offset + stack_vars[i].size);\n+\t      /* Find best representative of the partition.\n+\t\t Prefer those with DECL_NAME, even better\n+\t\t satisfying asan_protect_stack_decl predicate.  */\n+\t      for (j = i; j != EOC; j = stack_vars[j].next)\n+\t\tif (asan_protect_stack_decl (stack_vars[j].decl)\n+\t\t    && DECL_NAME (stack_vars[j].decl))\n+\t\t  {\n+\t\t    repr_decl = stack_vars[j].decl;\n+\t\t    break;\n+\t\t  }\n+\t\telse if (repr_decl == NULL_TREE\n+\t\t\t && DECL_P (stack_vars[j].decl)\n+\t\t\t && DECL_NAME (stack_vars[j].decl))\n+\t\t  repr_decl = stack_vars[j].decl;\n+\t      if (repr_decl == NULL_TREE)\n+\t\trepr_decl = stack_vars[i].decl;\n+\t      VEC_safe_push (tree, heap, data->asan_decl_vec, repr_decl);\n+\t    }\n+\t  else\n+\t    offset = alloc_stack_frame_space (stack_vars[i].size, alignb);\n \t  base = virtual_stack_vars_rtx;\n \t  base_align = crtl->max_used_stack_slot_alignment;\n \t}\n@@ -1057,8 +1114,9 @@ static bool\n defer_stack_allocation (tree var, bool toplevel)\n {\n   /* If stack protection is enabled, *all* stack variables must be deferred,\n-     so that we can re-order the strings to the top of the frame.  */\n-  if (flag_stack_protect)\n+     so that we can re-order the strings to the top of the frame.\n+     Similarly for Address Sanitizer.  */\n+  if (flag_stack_protect || flag_asan)\n     return true;\n \n   /* We handle \"large\" alignment via dynamic allocation.  We want to handle\n@@ -1329,15 +1387,31 @@ stack_protect_decl_phase (tree decl)\n    as callbacks for expand_stack_vars.  */\n \n static bool\n-stack_protect_decl_phase_1 (tree decl)\n+stack_protect_decl_phase_1 (size_t i)\n+{\n+  return stack_protect_decl_phase (stack_vars[i].decl) == 1;\n+}\n+\n+static bool\n+stack_protect_decl_phase_2 (size_t i)\n {\n-  return stack_protect_decl_phase (decl) == 1;\n+  return stack_protect_decl_phase (stack_vars[i].decl) == 2;\n }\n \n+/* And helper function that checks for asan phase (with stack protector\n+   it is phase 3).  This is used as callback for expand_stack_vars.\n+   Returns true if any of the vars in the partition need to be protected.  */\n+\n static bool\n-stack_protect_decl_phase_2 (tree decl)\n+asan_decl_phase_3 (size_t i)\n {\n-  return stack_protect_decl_phase (decl) == 2;\n+  while (i != EOC)\n+    {\n+      if (asan_protect_stack_decl (stack_vars[i].decl))\n+\treturn true;\n+      i = stack_vars[i].next;\n+    }\n+  return false;\n }\n \n /* Ensure that variables in different stack protection phases conflict\n@@ -1448,11 +1522,12 @@ estimated_stack_frame_size (struct cgraph_node *node)\n \n /* Expand all variables used in the function.  */\n \n-static void\n+static rtx\n expand_used_vars (void)\n {\n   tree var, outer_block = DECL_INITIAL (current_function_decl);\n   VEC(tree,heap) *maybe_local_decls = NULL;\n+  rtx var_end_seq = NULL_RTX;\n   struct pointer_map_t *ssa_name_decls;\n   unsigned i;\n   unsigned len;\n@@ -1603,6 +1678,11 @@ expand_used_vars (void)\n   /* Assign rtl to each variable based on these partitions.  */\n   if (stack_vars_num > 0)\n     {\n+      struct stack_vars_data data;\n+\n+      data.asan_vec = NULL;\n+      data.asan_decl_vec = NULL;\n+\n       /* Reorder decls to be protected by iterating over the variables\n \t array multiple times, and allocating out of each phase in turn.  */\n       /* ??? We could probably integrate this into the qsort we did\n@@ -1611,14 +1691,41 @@ expand_used_vars (void)\n       if (has_protected_decls)\n \t{\n \t  /* Phase 1 contains only character arrays.  */\n-\t  expand_stack_vars (stack_protect_decl_phase_1);\n+\t  expand_stack_vars (stack_protect_decl_phase_1, &data);\n \n \t  /* Phase 2 contains other kinds of arrays.  */\n \t  if (flag_stack_protect == 2)\n-\t    expand_stack_vars (stack_protect_decl_phase_2);\n+\t    expand_stack_vars (stack_protect_decl_phase_2, &data);\n \t}\n \n-      expand_stack_vars (NULL);\n+      if (flag_asan)\n+\t/* Phase 3, any partitions that need asan protection\n+\t   in addition to phase 1 and 2.  */\n+\texpand_stack_vars (asan_decl_phase_3, &data);\n+\n+      if (!VEC_empty (HOST_WIDE_INT, data.asan_vec))\n+\t{\n+\t  HOST_WIDE_INT prev_offset = frame_offset;\n+\t  HOST_WIDE_INT offset\n+\t    = alloc_stack_frame_space (ASAN_RED_ZONE_SIZE,\n+\t\t\t\t       ASAN_RED_ZONE_SIZE);\n+\t  VEC_safe_push (HOST_WIDE_INT, heap, data.asan_vec, prev_offset);\n+\t  VEC_safe_push (HOST_WIDE_INT, heap, data.asan_vec, offset);\n+\n+\t  var_end_seq\n+\t    = asan_emit_stack_protection (virtual_stack_vars_rtx,\n+\t\t\t\t\t  VEC_address (HOST_WIDE_INT,\n+\t\t\t\t\t\t       data.asan_vec),\n+\t\t\t\t\t  VEC_address (tree,\n+\t\t\t\t\t\t       data.asan_decl_vec),\n+\t\t\t\t\t  VEC_length (HOST_WIDE_INT,\n+\t\t\t\t\t\t      data.asan_vec));\n+\t}\n+\n+      expand_stack_vars (NULL, &data);\n+\n+      VEC_free (HOST_WIDE_INT, heap, data.asan_vec);\n+      VEC_free (tree, heap, data.asan_decl_vec);\n     }\n \n   fini_vars_expansion ();\n@@ -1645,6 +1752,8 @@ expand_used_vars (void)\n \tframe_offset += align - 1;\n       frame_offset &= -align;\n     }\n+\n+  return var_end_seq;\n }\n \n \n@@ -3661,7 +3770,7 @@ expand_debug_locations (void)\n /* Expand basic block BB from GIMPLE trees to RTL.  */\n \n static basic_block\n-expand_gimple_basic_block (basic_block bb)\n+expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n {\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts;\n@@ -3949,6 +4058,11 @@ expand_gimple_basic_block (basic_block bb)\n \t}\n       else\n \t{\n+\t  if (is_gimple_call (stmt)\n+\t      && gimple_call_tail_p (stmt)\n+\t      && disable_tail_calls)\n+\t    gimple_call_set_tail (stmt, false);\n+\n \t  if (is_gimple_call (stmt) && gimple_call_tail_p (stmt))\n \t    {\n \t      bool can_fallthru;\n@@ -4308,7 +4422,7 @@ gimple_expand_cfg (void)\n   sbitmap blocks;\n   edge_iterator ei;\n   edge e;\n-  rtx var_seq;\n+  rtx var_seq, var_ret_seq;\n   unsigned i;\n \n   timevar_push (TV_OUT_OF_SSA);\n@@ -4368,7 +4482,7 @@ gimple_expand_cfg (void)\n   timevar_push (TV_VAR_EXPAND);\n   start_sequence ();\n \n-  expand_used_vars ();\n+  var_ret_seq = expand_used_vars ();\n \n   var_seq = get_insns ();\n   end_sequence ();\n@@ -4494,7 +4608,7 @@ gimple_expand_cfg (void)\n \n   lab_rtx_for_bb = pointer_map_create ();\n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n-    bb = expand_gimple_basic_block (bb);\n+    bb = expand_gimple_basic_block (bb, var_ret_seq != NULL_RTX);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     expand_debug_locations ();\n@@ -4522,6 +4636,15 @@ gimple_expand_cfg (void)\n   construct_exit_block ();\n   insn_locations_finalize ();\n \n+  if (var_ret_seq)\n+    {\n+      rtx after = return_label;\n+      rtx next = NEXT_INSN (after);\n+      if (next && NOTE_INSN_BASIC_BLOCK_P (next))\n+\tafter = next;\n+      emit_insn_after (var_ret_seq, after);\n+    }\n+\n   /* Zap the tree EH table.  */\n   set_eh_throw_stmt_table (cfun, NULL);\n "}, {"sha": "8911ca3e24175d635ca739a07aa8f103557faf28", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ddd6929ad26e1c6202265460730241ad6c28d0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f3ddd6929ad26e1c6202265460730241ad6c28d0", "patch": "@@ -1542,7 +1542,9 @@ process_options (void)\n     }\n \n   /* Address Sanitizer needs porting to each target architecture.  */\n-  if (flag_asan && targetm.asan_shadow_offset == NULL)\n+  if (flag_asan\n+      && (targetm.asan_shadow_offset == NULL\n+\t  || !FRAME_GROWS_DOWNWARD))\n     {\n       warning (0, \"-faddress-sanitizer not supported for this target\");\n       flag_asan = 0;"}]}