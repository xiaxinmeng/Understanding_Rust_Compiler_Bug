{"sha": "b1d7b1c00e10e3550b2b1bfc91168679463e457f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFkN2IxYzAwZTEwZTM1NTBiMmIxYmZjOTExNjg2Nzk0NjNlNDU3Zg==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-05-25T13:15:04Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-05-25T13:15:04Z"}, "message": "re PR c++/31431 (ICE with invalid parameter pack)\n\n2007-05-25  Douglas Gregor <doug.gregor@gmail.com>\n\n\tPR c++/31431\n\tPR c++/31432\n\tPR c++/31434\n\tPR c++/31435\n\tPR c++/31437\n\tPR c++/31438\n\tPR c++/31442\n\tPR c++/31443\n\tPR c++/31444\n\tPR c++/31445\n\t* error.c (dump_type): Dump TYPE_ARGUMENT_PACK nodes.\n\t* cp-tree.h (check_for_bare_parameter_packs): Returns bool.\n\t* pt.c (check_for_bare_parameter_packs): Return bool indicated\n\twhether everything was okay. Fix indentation.\n\t(push_template_decl_real): Check for bare parameter packs in\n\tfunction parameters; where errors occur, mark the parameter types\n\twith ERROR_MARK_NODEs to avert ICEs.\n\t(coerce_template_parameter_pack): New.\n\t(coerce_template_parms): Moved parameter pack coercion into\n\tcoerce_template_parameter_pack, and permit it anywhere in the\n\ttemplate parameter list (not just at the end). Parameter and\n\targument indices can vary (somewhat) separately now, so add\n\tPARM_IDX and ARG_IDX.\n\t(fn_type_unification): Don't set an argument pack as incomplete if\n\tno argument pack was deduced.\n\t(type_unification_real): If a type parameter is a parameter pack\n\tand has not otherwise been deduced, it will be deduced to an empty\n\tparameter pack.\n\t(more_specialized_fn): Use the actual lengths of the argument\n\tlists when comparing against expansions.\n\t* semantics.c (finish_member_declaration): If a field's type has\n\tbare parameter packs, error and set its type to ERROR_MARK_NODE.\n\t\n2007-05-25  Douglas Gregor <doug.gregor@gmail.com>\n\n\tPR c++/31431\n\tPR c++/31432\n\tPR c++/31434\n\tPR c++/31435\n\tPR c++/31437\n\tPR c++/31438\n\tPR c++/31442\n\tPR c++/31443\n\tPR c++/31444\n\tPR c++/31445\n\t* g++.dg/cpp0x/pr31431.C: New.\n\t* g++.dg/cpp0x/pr31437.C: New.\n\t* g++.dg/cpp0x/pr31442.C: New.\n\t* g++.dg/cpp0x/pr31444.C: New.\n\t* g++.dg/cpp0x/pr31431-2.C: New.\n\t* g++.dg/cpp0x/pr31432.C: New.\n\t* g++.dg/cpp0x/pr31434.C: New.\n\t* g++.dg/cpp0x/pr31438.C: New.\n\t* g++.dg/cpp0x/pr31443.C: New.\n\t* g++.dg/cpp0x/pr31445.C: New.\n\t* g++.dg/cpp0x/variadic-crash1.C: New.\n\nFrom-SVN: r125062", "tree": {"sha": "626e35a9a9d851c0a1a037eb6349540dc9831f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/626e35a9a9d851c0a1a037eb6349540dc9831f0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1d7b1c00e10e3550b2b1bfc91168679463e457f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d7b1c00e10e3550b2b1bfc91168679463e457f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1d7b1c00e10e3550b2b1bfc91168679463e457f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d7b1c00e10e3550b2b1bfc91168679463e457f/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77315816df628ed27788142071b54e0f31752313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77315816df628ed27788142071b54e0f31752313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77315816df628ed27788142071b54e0f31752313"}], "stats": {"total": 668, "additions": 510, "deletions": 158}, "files": [{"sha": "f2c6b6a671c9dc791e0a833b626052ce60625f26", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -1,3 +1,38 @@\n+2007-05-25  Douglas Gregor <doug.gregor@gmail.com>\n+\n+\tPR c++/31431\n+\tPR c++/31432\n+\tPR c++/31434\n+\tPR c++/31435\n+\tPR c++/31437\n+\tPR c++/31438\n+\tPR c++/31442\n+\tPR c++/31443\n+\tPR c++/31444\n+\tPR c++/31445\n+\t* error.c (dump_type): Dump TYPE_ARGUMENT_PACK nodes.\n+\t* cp-tree.h (check_for_bare_parameter_packs): Returns bool.\n+\t* pt.c (check_for_bare_parameter_packs): Return bool indicated\n+\twhether everything was okay. Fix indentation.\n+\t(push_template_decl_real): Check for bare parameter packs in\n+\tfunction parameters; where errors occur, mark the parameter types\n+\twith ERROR_MARK_NODEs to avert ICEs.\n+\t(coerce_template_parameter_pack): New.\n+\t(coerce_template_parms): Moved parameter pack coercion into\n+\tcoerce_template_parameter_pack, and permit it anywhere in the\n+\ttemplate parameter list (not just at the end). Parameter and\n+\targument indices can vary (somewhat) separately now, so add\n+\tPARM_IDX and ARG_IDX.\n+\t(fn_type_unification): Don't set an argument pack as incomplete if\n+\tno argument pack was deduced.\n+\t(type_unification_real): If a type parameter is a parameter pack\n+\tand has not otherwise been deduced, it will be deduced to an empty\n+\tparameter pack.\n+\t(more_specialized_fn): Use the actual lengths of the argument\n+\tlists when comparing against expansions.\n+\t* semantics.c (finish_member_declaration): If a field's type has\n+\tbare parameter packs, error and set its type to ERROR_MARK_NODE.\n+\n 2007-05-24  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/27067"}, {"sha": "413b2241ed68f6613e35f190f1e6e0c75f7057c9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -4393,7 +4393,7 @@ extern bool uses_parameter_packs                (tree);\n extern bool template_parameter_pack_p           (tree);\n extern bool template_parms_variadic_p           (tree);\n extern tree make_pack_expansion                 (tree);\n-extern void check_for_bare_parameter_packs      (tree);\n+extern bool check_for_bare_parameter_packs      (tree);\n extern int template_class_depth\t\t\t(tree);\n extern int is_specialization_of\t\t\t(tree, tree);\n extern bool is_specialization_of_friend\t\t(tree, tree);"}, {"sha": "fcc7b08946ebb128ec2fa5295601b837d94d6710", "filename": "gcc/cp/error.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -395,6 +395,19 @@ dump_type (tree t, int flags)\n       pp_cxx_identifier (cxx_pp, \"...\");\n       break;\n \n+    case TYPE_ARGUMENT_PACK:\n+      {\n+        tree args = ARGUMENT_PACK_ARGS (t);\n+        int i;\n+        for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+          {\n+            if (i)\n+              pp_separate_with_comma (cxx_pp);\n+            dump_type (TREE_VEC_ELT (args, i), flags);\n+          }\n+      }\n+      break;\n+\n     default:\n       pp_unsupported_tree (cxx_pp, t);\n       /* Fall through to error.  */"}, {"sha": "584e6cfa611aed51e683cba45b5813034a0f9204", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 271, "deletions": 157, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -2599,15 +2599,18 @@ make_pack_expansion (tree arg)\n    where \"args\" is a parameter pack. check_for_bare_parameter_packs\n    should not be called for the subexpressions args, h(args),\n    g(h(args)), or f(g(h(args))), because we would produce erroneous\n-   error messages.  */\n-void \n+   error messages. \n+\n+   Returns TRUE if there were no bare parameter packs, returns FALSE\n+   (and emits an error) if there were bare parameter packs.*/\n+bool \n check_for_bare_parameter_packs (tree t)\n {\n   tree parameter_packs = NULL_TREE;\n   struct find_parameter_pack_data ppd;\n \n   if (!processing_template_decl || !t || t == error_mark_node)\n-    return;\n+    return true;\n \n   if (TREE_CODE (t) == TYPE_DECL)\n     t = TREE_TYPE (t);\n@@ -2617,25 +2620,30 @@ check_for_bare_parameter_packs (tree t)\n   walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);\n   pointer_set_destroy (ppd.visited);\n \n-  if (parameter_packs) {\n-    error (\"parameter packs not expanded with `...':\");\n-    while (parameter_packs)\n-      {\n-        tree pack = TREE_VALUE (parameter_packs);\n-        tree name = NULL_TREE;\n-\n-        if (TREE_CODE (pack) == TEMPLATE_TYPE_PARM\n-            || TREE_CODE (pack) == TEMPLATE_TEMPLATE_PARM)\n-          name = TYPE_NAME (pack);\n-\telse if (TREE_CODE (pack) == TEMPLATE_PARM_INDEX)\n-\t  name = DECL_NAME (TEMPLATE_PARM_DECL (pack));\n-        else\n-          name = DECL_NAME (pack);\n-        inform (\"        %qD\", name);\n-\n-        parameter_packs = TREE_CHAIN (parameter_packs);\n-      }\n-  }\n+  if (parameter_packs) \n+    {\n+      error (\"parameter packs not expanded with `...':\");\n+      while (parameter_packs)\n+        {\n+          tree pack = TREE_VALUE (parameter_packs);\n+          tree name = NULL_TREE;\n+\n+          if (TREE_CODE (pack) == TEMPLATE_TYPE_PARM\n+              || TREE_CODE (pack) == TEMPLATE_TEMPLATE_PARM)\n+            name = TYPE_NAME (pack);\n+          else if (TREE_CODE (pack) == TEMPLATE_PARM_INDEX)\n+            name = DECL_NAME (TEMPLATE_PARM_DECL (pack));\n+          else\n+            name = DECL_NAME (pack);\n+          inform (\"        %qD\", name);\n+\n+          parameter_packs = TREE_CHAIN (parameter_packs);\n+        }\n+\n+      return false;\n+    }\n+\n+  return true;\n }\n \n /* Expand any parameter packs that occur in the template arguments in\n@@ -3376,7 +3384,7 @@ process_partial_specialization (tree decl)\n \n   DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)\n     = tree_cons (specargs, inner_parms,\n-\t\t DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n+                 DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n   TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n   return decl;\n }\n@@ -3692,7 +3700,38 @@ push_template_decl_real (tree decl, bool is_friend)\n \n   /* Ensure that there are no parameter packs in the type of this\n      declaration that have not been expanded.  */\n-  check_for_bare_parameter_packs (TREE_TYPE (decl));\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      /* Check each of the arguments individually to see if there are\n+         any bare parameter packs.  */\n+      tree type = TREE_TYPE (decl);\n+      tree arg = DECL_ARGUMENTS (decl);\n+      tree argtype = TYPE_ARG_TYPES (type);\n+\n+      while (arg && argtype)\n+        {\n+          if (!FUNCTION_PARAMETER_PACK_P (arg)\n+              && !check_for_bare_parameter_packs (TREE_TYPE (arg)))\n+            {\n+            /* This is a PARM_DECL that contains unexpanded parameter\n+               packs. We have already complained about this in the\n+               check_for_bare_parameter_packs call, so just replace\n+               these types with ERROR_MARK_NODE.  */\n+              TREE_TYPE (arg) = error_mark_node;\n+              TREE_VALUE (argtype) = error_mark_node;\n+            }\n+\n+          arg = TREE_CHAIN (arg);\n+          argtype = TREE_CHAIN (argtype);\n+        }\n+\n+      /* Check for bare parameter packs in the return type and the\n+         exception specifiers.  */\n+      check_for_bare_parameter_packs (TREE_TYPE (type));\n+      check_for_bare_parameter_packs (TYPE_RAISES_EXCEPTIONS (type));\n+    }\n+  else\n+    check_for_bare_parameter_packs (TREE_TYPE (decl));\n \n   if (is_partial)\n     return process_partial_specialization (decl);\n@@ -4740,6 +4779,121 @@ convert_template_argument (tree parm,\n   return val;\n }\n \n+/* Coerces the remaining template arguments in INNER_ARGS (from\n+   ARG_IDX to the end) into the parameter pack at PARM_IDX in PARMS.\n+   Returns the coerced argument pack. PARM_IDX is the position of this\n+   parameter in the template parameter list. ARGS is the original\n+   template argument list.  */\n+static tree\n+coerce_template_parameter_pack (tree parms,\n+                                int parm_idx,\n+                                tree args,\n+                                tree inner_args,\n+                                int arg_idx,\n+                                tree new_args,\n+                                int* lost,\n+                                tree in_decl,\n+                                tsubst_flags_t complain)\n+{\n+  tree parm = TREE_VEC_ELT (parms, parm_idx);\n+  int nargs = inner_args ? NUM_TMPL_ARGS (inner_args) : 0;\n+  tree packed_args;\n+  tree argument_pack;\n+  tree packed_types = NULL_TREE;\n+\n+  if (arg_idx > nargs)\n+    arg_idx = nargs;\n+\n+  packed_args = make_tree_vec (nargs - arg_idx);\n+\n+  if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL\n+      && uses_parameter_packs (TREE_TYPE (TREE_VALUE (parm))))\n+    {\n+      /* When the template parameter is a non-type template\n+         parameter pack whose type uses parameter packs, we need\n+         to look at each of the template arguments\n+         separately. Build a vector of the types for these\n+         non-type template parameters in PACKED_TYPES.  */\n+      tree expansion \n+        = make_pack_expansion (TREE_TYPE (TREE_VALUE (parm)));\n+      packed_types = tsubst_pack_expansion (expansion, args,\n+                                            complain, in_decl);\n+\n+      if (packed_types == error_mark_node)\n+        return error_mark_node;\n+\n+      /* Check that we have the right number of arguments.  */\n+      if (arg_idx < nargs\n+          && !PACK_EXPANSION_P (TREE_VEC_ELT (inner_args, arg_idx))\n+          && nargs - arg_idx != TREE_VEC_LENGTH (packed_types))\n+        {\n+          int needed_parms \n+            = TREE_VEC_LENGTH (parms) - 1 + TREE_VEC_LENGTH (packed_types);\n+          error (\"wrong number of template arguments (%d, should be %d)\",\n+                 nargs, needed_parms);\n+          return error_mark_node;\n+        }\n+\n+      /* If we aren't able to check the actual arguments now\n+         (because they haven't been expanded yet), we can at least\n+         verify that all of the types used for the non-type\n+         template parameter pack are, in fact, valid for non-type\n+         template parameters.  */\n+      if (arg_idx < nargs \n+          && PACK_EXPANSION_P (TREE_VEC_ELT (inner_args, arg_idx)))\n+        {\n+          int j, len = TREE_VEC_LENGTH (packed_types);\n+          for (j = 0; j < len; ++j)\n+            {\n+              tree t = TREE_VEC_ELT (packed_types, j);\n+              if (invalid_nontype_parm_type_p (t, complain))\n+                return error_mark_node;\n+            }\n+        }\n+    }\n+\n+  /* Convert the remaining arguments, which will be a part of the\n+     parameter pack \"parm\".  */\n+  for (; arg_idx < nargs; ++arg_idx)\n+    {\n+      tree arg = TREE_VEC_ELT (inner_args, arg_idx);\n+      tree actual_parm = TREE_VALUE (parm);\n+\n+      if (packed_types && !PACK_EXPANSION_P (arg))\n+        {\n+          /* When we have a vector of types (corresponding to the\n+             non-type template parameter pack that uses parameter\n+             packs in its type, as mention above), and the\n+             argument is not an expansion (which expands to a\n+             currently unknown number of arguments), clone the\n+             parm and give it the next type in PACKED_TYPES.  */\n+          actual_parm = copy_node (actual_parm);\n+          TREE_TYPE (actual_parm) = \n+            TREE_VEC_ELT (packed_types, arg_idx - parm_idx);\n+        }\n+\n+      arg = convert_template_argument (actual_parm, \n+                                       arg, new_args, complain, parm_idx,\n+                                       in_decl);\n+      if (arg == error_mark_node)\n+        (*lost)++;\n+      TREE_VEC_ELT (packed_args, arg_idx - parm_idx) = arg; \n+    }\n+\n+  if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL\n+      || TREE_CODE (TREE_VALUE (parm)) == TEMPLATE_DECL)\n+    argument_pack = make_node (TYPE_ARGUMENT_PACK);\n+  else\n+    {\n+      argument_pack = make_node (NONTYPE_ARGUMENT_PACK);\n+      TREE_TYPE (argument_pack) = TREE_TYPE (TREE_VALUE (parm));\n+      TREE_CONSTANT (argument_pack) = 1;\n+    }\n+\n+  SET_ARGUMENT_PACK_ARGS (argument_pack, packed_args);\n+  return argument_pack;\n+}\n+\n /* Convert all template arguments to their appropriate types, and\n    return a vector containing the innermost resulting template\n    arguments.  If any error occurs, return error_mark_node. Error and\n@@ -4760,7 +4914,7 @@ coerce_template_parms (tree parms,\n \t\t       bool require_all_args,\n \t\t       bool use_default_args)\n {\n-  int nparms, nargs, i, lost = 0;\n+  int nparms, nargs, parm_idx, arg_idx, lost = 0;\n   tree inner_args;\n   tree new_args;\n   tree new_inner_args;\n@@ -4770,14 +4924,25 @@ coerce_template_parms (tree parms,\n      variadic template parameter list. Since it's an int, we can also\n      subtract it from nparms to get the number of non-variadic\n      parameters.  */\n-  int variadic_p = template_parms_variadic_p (parms) ? 1 : 0;\n+  int variadic_p = 0;\n \n   inner_args \n     = expand_template_argument_pack (INNERMOST_TEMPLATE_ARGS (args));\n \n   nargs = inner_args ? NUM_TMPL_ARGS (inner_args) : 0;\n   nparms = TREE_VEC_LENGTH (parms);\n \n+  /* Determine if there are any parameter packs.  */\n+  for (parm_idx = 0; parm_idx < nparms; ++parm_idx)\n+    {\n+      tree tparm = TREE_VALUE (TREE_VEC_ELT (parms, parm_idx));\n+      if (template_parameter_pack_p (tparm))\n+        {\n+          variadic_p = 1;\n+          break;\n+        }\n+    }\n+\n   if ((nargs > nparms - variadic_p && !variadic_p)\n       || (nargs < nparms - variadic_p\n \t  && require_all_args\n@@ -4810,164 +4975,88 @@ coerce_template_parms (tree parms,\n   skip_evaluation = false;\n   new_inner_args = make_tree_vec (nparms);\n   new_args = add_outermost_template_args (args, new_inner_args);\n-  for (i = 0; i < nparms - variadic_p; i++)\n+  for (parm_idx = 0, arg_idx = 0; parm_idx < nparms; parm_idx++, arg_idx++)\n     {\n       tree arg;\n       tree parm;\n \n       /* Get the Ith template parameter.  */\n-      parm = TREE_VEC_ELT (parms, i);\n+      parm = TREE_VEC_ELT (parms, parm_idx);\n  \n       if (parm == error_mark_node)\n       {\n-        TREE_VEC_ELT (new_inner_args, i) = error_mark_node;\n+        TREE_VEC_ELT (new_inner_args, arg_idx) = error_mark_node;\n         continue;\n       }\n \n-      /* Calculate the Ith argument.  */\n-      if (i < nargs)\n+      /* Calculate the next argument.  */\n+      if (template_parameter_pack_p (TREE_VALUE (parm)))\n         {\n-          arg = TREE_VEC_ELT (inner_args, i);\n-        \n-          if (PACK_EXPANSION_P (arg))\n+          /* All remaining arguments will be placed in the\n+             template parameter pack PARM.  */\n+          arg = coerce_template_parameter_pack (parms, parm_idx, args, \n+                                                inner_args, arg_idx,\n+                                                new_args, &lost,\n+                                                in_decl, complain);\n+          \n+          /* Store this argument.  */\n+          if (arg == error_mark_node)\n+            lost++;\n+          TREE_VEC_ELT (new_inner_args, parm_idx) = arg;\n+\n+          /* We are done with all of the arguments.  */\n+          arg_idx = nargs;\n+\n+          continue;\n+        }\n+      else if (arg_idx < nargs)\n+        {\n+          arg = TREE_VEC_ELT (inner_args, arg_idx);\n+\n+          if (arg && PACK_EXPANSION_P (arg))\n             {\n-              /* If ARG is a pack expansion, then PARM must be\n-                 a template parameter pack. We can't expand into a\n+              /* If ARG is a pack expansion, but PARM is not a\n+                 template parameter pack (if it were, we would have\n+                 handled it above), we're trying to expand into a\n                  fixed-length argument list.  */\n-              tree actual_parm = TREE_VALUE (parm);\n-              bool parm_is_parameter_pack \n-\t\t= template_parameter_pack_p (actual_parm);\n-\n-              if (!parm_is_parameter_pack)\n-                {\n-                  if (TREE_CODE (arg) == EXPR_PACK_EXPANSION)\n-                    error (\"cannot expand %<%E%> into a fixed-length \"\n-                           \"argument list\", arg);\n-                  else\n-                    error (\"cannot expand %<%T%> into a fixed-length \"\n-                           \"argument list\", arg);\n-                }\n+              if (TREE_CODE (arg) == EXPR_PACK_EXPANSION)\n+                error (\"cannot expand %<%E%> into a fixed-length \"\n+                       \"argument list\", arg);\n+              else\n+                error (\"cannot expand %<%T%> into a fixed-length \"\n+                       \"argument list\", arg);\n             }\n         }\n       else if (require_all_args)\n-\t/* There must be a default arg in this case.  */\n-\targ = tsubst_template_arg (TREE_PURPOSE (parm), new_args,\n-\t\t\t\t   complain, in_decl);\n+        /* There must be a default arg in this case.  */\n+        arg = tsubst_template_arg (TREE_PURPOSE (parm), new_args,\n+                                   complain, in_decl);\n       else\n \tbreak;\n \n-      gcc_assert (arg);\n       if (arg == error_mark_node)\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"template argument %d is invalid\", i + 1);\n-\t}\n+\t    error (\"template argument %d is invalid\", arg_idx + 1);\n+\t}\n+      else if (!arg)\n+        /* This only occurs if there was an error in the template\n+           parameter list itself (which we would already have\n+           reported) that we are trying to recover from, e.g., a class\n+           template with a parameter list such as\n+           template<typename..., typename>.  */\n+        return error_mark_node;\n       else\n \targ = convert_template_argument (TREE_VALUE (parm),\n-\t\t\t\t\t arg, new_args, complain, i,\n-\t\t\t\t\t in_decl);\n+\t\t\t\t\t arg, new_args, complain, \n+                                         parm_idx, in_decl);\n \n       if (arg == error_mark_node)\n \tlost++;\n-      TREE_VEC_ELT (new_inner_args, i) = arg;\n+      TREE_VEC_ELT (new_inner_args, arg_idx) = arg;\n     }\n   skip_evaluation = saved_skip_evaluation;\n \n-  if (variadic_p)\n-    {\n-      int expected_len = nargs - nparms + 1;\n-      tree parm = TREE_VEC_ELT (parms, nparms - 1);\n-      tree packed_args;\n-      tree argument_pack;\n-      tree packed_types = NULL_TREE;\n-      \n-      packed_args = make_tree_vec (expected_len >= 0 ? expected_len : 0);\n-\n-      if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL\n-\t  && uses_parameter_packs (TREE_TYPE (TREE_VALUE (parm))))\n-\t{\n-\t  /* When the template parameter is a non-type template\n-\t     parameter pack whose type uses parameter packs, we need\n-\t     to look at each of the template arguments\n-\t     separately. Build a vector of the types for these\n-\t     non-type template parameters in PACKED_TYPES.  */\n-\t  tree expansion \n-\t    = make_pack_expansion (TREE_TYPE (TREE_VALUE (parm)));\n-\t  packed_types = tsubst_pack_expansion (expansion, args,\n-\t\t\t\t\t\tcomplain, in_decl);\n-\n-\t  if (packed_types == error_mark_node)\n-\t    return error_mark_node;\n-\n-\t  /* Check that we have the right number of arguments.  */\n-\t  if (i < nargs\n-\t      && !PACK_EXPANSION_P (TREE_VEC_ELT (inner_args, i))\n-\t      && nargs - i != TREE_VEC_LENGTH (packed_types))\n-\t    {\n-\t      error (\"wrong number of template arguments (%d, should be %d)\",\n-\t\t     nargs, nparms - 1 + TREE_VEC_LENGTH (packed_types));\n-\t      return error_mark_node;\n-\t    }\n-\n-\t  /* If we aren't able to check the actual arguments now\n-\t     (because they haven't been expanded yet), we can at least\n-\t     verify that all of the types used for the non-type\n-\t     template parameter pack are, in fact, valid for non-type\n-\t     template parameters.  */\n-\t  if (i < nargs && PACK_EXPANSION_P (TREE_VEC_ELT (inner_args, i)))\n-\t    {\n-\t      int j, len = TREE_VEC_LENGTH (packed_types);\n-\t      for (j = 0; j < len; ++j)\n-\t\t{\n-\t\t  tree t = TREE_VEC_ELT (packed_types, j);\n-\t\t  if (invalid_nontype_parm_type_p (t, complain))\n-\t\t    return error_mark_node;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Convert the remaining arguments, which will be a part of the\n-         parameter pack \"parm\".  */\n-      for (; i < nargs; ++i)\n-        {\n-          tree arg = TREE_VEC_ELT (inner_args, i);\n-\t  tree actual_parm = TREE_VALUE (parm);\n-\n-\t  if (packed_types && !PACK_EXPANSION_P (arg))\n-\t    {\n-\t      /* When we have a vector of types (corresponding to the\n-\t\t non-type template parameter pack that uses parameter\n-\t\t packs in its type, as mention above), and the\n-\t\t argument is not an expansion (which expands to a\n-\t\t currently unknown number of arguments), clone the\n-\t\t parm and give it the next type in PACKED_TYPES.  */\n-\t      actual_parm = copy_node (actual_parm);\n-\t      TREE_TYPE (actual_parm) = \n-\t\tTREE_VEC_ELT (packed_types, i - nparms + 1);\n-\t    }\n-\n-          arg = convert_template_argument (actual_parm, \n-                                           arg, new_args, complain, i,\n-                                           in_decl);\n-          if (arg == error_mark_node)\n-            lost++;\n-          TREE_VEC_ELT (packed_args, i - nparms + 1) = arg; \n-        }\n-\n-      if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL\n-          || TREE_CODE (TREE_VALUE (parm)) == TEMPLATE_DECL)\n-          argument_pack = make_node (TYPE_ARGUMENT_PACK);\n-      else\n-        {\n-          argument_pack = make_node (NONTYPE_ARGUMENT_PACK);\n-          TREE_TYPE (argument_pack) = TREE_TYPE (TREE_VALUE (parm));\n-          TREE_CONSTANT (argument_pack) = 1;\n-        }\n-\n-      SET_ARGUMENT_PACK_ARGS (argument_pack, packed_args);\n-      TREE_VEC_ELT (new_inner_args, nparms - 1) = argument_pack;\n-    }\n-\n   if (lost)\n     return error_mark_node;\n \n@@ -11055,8 +11144,12 @@ fn_type_unification (tree fn,\n               /* Mark the argument pack as \"incomplete\". We could\n                  still deduce more arguments during unification.  */\n               targ = TMPL_ARG (converted_args, level, idx);\n-              ARGUMENT_PACK_INCOMPLETE_P(targ) = 1;\n-              ARGUMENT_PACK_EXPLICIT_ARGS (targ) = ARGUMENT_PACK_ARGS (targ);\n+              if (targ)\n+                {\n+                  ARGUMENT_PACK_INCOMPLETE_P(targ) = 1;\n+                  ARGUMENT_PACK_EXPLICIT_ARGS (targ) \n+                    = ARGUMENT_PACK_ARGS (targ);\n+                }\n \n               /* We have some incomplete argument packs.  */\n               incomplete_argument_packs_p = true;\n@@ -11425,6 +11518,27 @@ type_unification_real (tree tparms,\n                 }\n             }\n \n+          /* If the type parameter is a parameter pack, then it will\n+             be deduced to an empty parameter pack.  */\n+          if (template_parameter_pack_p (tparm))\n+            {\n+              tree arg;\n+\n+              if (TREE_CODE (tparm) == TEMPLATE_PARM_INDEX)\n+                {\n+                  arg = make_node (NONTYPE_ARGUMENT_PACK);\n+                  TREE_TYPE (arg)  = TREE_TYPE (TEMPLATE_PARM_DECL (tparm));\n+                  TREE_CONSTANT (arg) = 1;\n+                }\n+              else\n+                arg = make_node (TYPE_ARGUMENT_PACK);\n+\n+              SET_ARGUMENT_PACK_ARGS (arg, make_tree_vec (0));\n+\n+              TREE_VEC_ELT (targs, i) = arg;\n+              continue;\n+            }\n+\n \t  return 2;\n \t}\n \n@@ -12889,7 +13003,7 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n \n       if (TREE_CODE (arg1) == TYPE_PACK_EXPANSION)\n         {\n-          int i, len2 = len + 1;\n+          int i, len2 = list_length (args2);\n           tree parmvec = make_tree_vec (1);\n           tree argvec = make_tree_vec (len2);\n           tree ta = args2;\n@@ -12913,7 +13027,7 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n         }\n       else if (TREE_CODE (arg2) == TYPE_PACK_EXPANSION)\n         {\n-          int i, len1 = len + 1;\n+          int i, len1 = list_length (args1);\n           tree parmvec = make_tree_vec (1);\n           tree argvec = make_tree_vec (len1);\n           tree ta = args1;"}, {"sha": "827f532ac7d184b7314fa0ea1d0c997b940aac10", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -2283,6 +2283,11 @@ finish_member_declaration (tree decl)\n   /* Mark the DECL as a member of the current class.  */\n   DECL_CONTEXT (decl) = current_class_type;\n \n+  /* Check for bare parameter packs in the member variable declaration.  */\n+  if (TREE_CODE (decl) == FIELD_DECL\n+      && !check_for_bare_parameter_packs (TREE_TYPE (decl)))\n+    TREE_TYPE (decl) == error_mark_node;\n+\n   /* [dcl.link]\n \n      A C language linkage is ignored for the names of class members"}, {"sha": "474be38c16ee78afc75a2f2fcee564bffe0ec19e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -1,3 +1,27 @@\n+2007-05-25  Douglas Gregor <doug.gregor@gmail.com>\n+\n+\tPR c++/31431\n+\tPR c++/31432\n+\tPR c++/31434\n+\tPR c++/31435\n+\tPR c++/31437\n+\tPR c++/31438\n+\tPR c++/31442\n+\tPR c++/31443\n+\tPR c++/31444\n+\tPR c++/31445\n+\t* g++.dg/cpp0x/pr31431.C: New.\n+\t* g++.dg/cpp0x/pr31437.C: New.\n+\t* g++.dg/cpp0x/pr31442.C: New.\n+\t* g++.dg/cpp0x/pr31444.C: New.\n+\t* g++.dg/cpp0x/pr31431-2.C: New.\n+\t* g++.dg/cpp0x/pr31432.C: New.\n+\t* g++.dg/cpp0x/pr31434.C: New.\n+\t* g++.dg/cpp0x/pr31438.C: New.\n+\t* g++.dg/cpp0x/pr31443.C: New.\n+\t* g++.dg/cpp0x/pr31445.C: New.\n+\t* g++.dg/cpp0x/variadic-crash1.C: New.\n+\n 2007-05-25  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gcc.target/arm/long-calls-1.c: New test."}, {"sha": "2f74e38ca3bc6f950caa9eddf064f8be6fa3eba3", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31431-2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431-2.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template<typename, typename..., typename> void foo();\n+\n+void bar()\n+{\n+  foo<int>(); // { dg-error \"no matching function\" }\n+}"}, {"sha": "061dab0a601b81210cbf555653a1c3e6de344cc5", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31431.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template<typename..., typename> void foo();\n+\n+void bar()\n+{\n+  foo<int>(); // { dg-error \"no matching function\" }\n+}"}, {"sha": "cb8826e5957208cb799979ec04b3f392054471c6", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31432.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31432.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31432.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31432.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template<typename..., typename> struct A // { dg-error \"parameter pack\" }\n+{\n+ static int i;\n+};\n+\n+A<int, int> a; // { dg-error \"invalid type\" }\n+A<char,int> b; // { dg-error \"invalid type\" }"}, {"sha": "a785ae934a626534b60f3a974ea49bb1b354cd9b", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31434.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31434.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31434.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31434.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template<typename... T> int foo(const T&) // { dg-error \"not expanded with|T\" }\n+{\n+ union { T t; }; // { dg-error \"not expanded with|T\" }\n+ return t;\n+}\n+\n+void bar()\n+{\n+  foo(0); // { dg-error \"no matching\" }\n+}"}, {"sha": "0e1a888138bcb4dde6bbece74606671f42dffd26", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31437.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31437.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31437.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31437.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template <typename... T> struct A\n+{ // { dg-error \"candidates|A\" }\n+  A(T* p) {  // { dg-error \"parameter packs|T\" }\n+   (A<T...>*)(p); \n+  }\n+};\n+\n+A<int> a(0); // { dg-error \"no matching\" }"}, {"sha": "3a125634ffb08112bb2ceb9999a6f57197be6c94", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31438.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31438.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31438.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31438.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename> struct A; // { dg-error \"candidates\" }\n+template<typename T, typename... U> struct A<T(U)> // { dg-error \"parameter packs|U\" }\n+{ // { dg-error \"parameter packs|U\" }\n+ template<typename X> A(X); // { dg-error \"parameter packs|U\" }\n+};\n+\n+A<void(int)> a(0); // { dg-error \"no matching\" }"}, {"sha": "050e2999566aae59eaebfc3b132b4bd941b7c181", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31442.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31442.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31442.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31442.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template<typename... T, T = 0> struct A {}; // { dg-error \"parameter packs|T|the end\" }\n+\n+struct B\n+{\n+  template <template <typename...> class C> B(C<int>);\n+};\n+\n+B b = A<int>();"}, {"sha": "1eb9d318de0065445010f9a7b94119370a030156", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31443.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31443.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31443.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31443.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<int, typename... T> struct A\n+{\n+  template<int N> void foo(A<N,T>); // { dg-error \"parameter packs|T\" }\n+};\n+\n+void bar()\n+{\n+  A<0,int>().foo(A<0,int>()); // { dg-error \"no member named\" }\n+}"}, {"sha": "b1f86fe7a7ed33546507e6f6355c590285cc9abf", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31444.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31444.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31444.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31444.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template<typename... T> struct A\n+{\n+  template<int> void foo(A<T>); // { dg-error \"not expanded|T\" }\n+};\n+\n+void bar()\n+{\n+  A<int>().foo<0>(A<int>()); // { dg-error \"no member named\" }\n+};"}, {"sha": "025cb9606c3bb808ab304ba443f5727f945ddd6a", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31445.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31445.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31445.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31445.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options \"-std=gnu++0x\" }\n+template <typename... T> struct A\n+{\n+  void foo(T...); // { dg-error \"candidates\" }\n+  A(T... t) { foo(t); } // { dg-error \"parameter packs|t|no matching\" }\n+};\n+\n+A<int> a(0);"}, {"sha": "f26aee2a91fb813776b96989e20b56ced2f98b76", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-crash1.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-crash1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d7b1c00e10e3550b2b1bfc91168679463e457f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-crash1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-crash1.C?ref=b1d7b1c00e10e3550b2b1bfc91168679463e457f", "patch": "@@ -0,0 +1,72 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#define ONE\n+#define TWO\n+#define THREE\n+\n+struct Something {};\n+Something ___;\n+\n+template <class F>\n+struct Trial\n+{\n+ F f;\n+public:\n+ Trial() : f() {}\n+ Trial( const F& ff ) : f(ff) { }\n+ template <typename... Args>\n+ struct Sig { typedef int ResultType; };\n+\n+ template <typename... Args>\n+ struct Sig<Something,Args...> { typedef int ResultType;  };\n+\n+#ifdef ONE\n+\n+template <typename... Args>\n+typename Sig<Something,Args...>::ResultType operator()(const Something& s, const Args&... args) const\n+{\n+ return f(args...);\n+}\n+#endif\n+#ifdef TWO\n+template <typename... Args>\n+typename Sig<Args...>::ResultType operator()(const Args&... args) const\n+{\n+ return f(args...);\n+}\n+#endif\n+};\n+\n+struct Internal\n+{\n+\n+template <typename... Args>\n+struct Sig { typedef int ResultType; };\n+\n+template <typename... Args>\n+struct Sig<Something,Args...> { typedef int ResultType;  };\n+\n+template <typename... Args>\n+int operator()(const Args&... args) const\n+{\n+ int n = sizeof...(Args);\n+ return n;\n+}\n+\n+ static Trial<Internal>& full() { static Trial<Internal> f; return f; }\n+};\n+\n+static Trial<Internal>& internal = Internal::full();\n+\n+int main()\n+{\n+ int n = 0;\n+#ifdef ONE\n+ n = internal(___,1,2);\n+#endif\n+#ifdef THREE\n+ n = internal(___,1,2,3);\n+ n = internal(___,1,2,3,4);\n+#endif\n+ return 0;\n+}"}]}