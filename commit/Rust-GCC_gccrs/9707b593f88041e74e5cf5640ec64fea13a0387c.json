{"sha": "9707b593f88041e74e5cf5640ec64fea13a0387c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcwN2I1OTNmODgwNDFlNzRlNWNmNTY0MGVjNjRmZWExM2EwMzg3Yw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-04-14T17:26:04Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-04-14T17:26:39Z"}, "message": "ipa-sra: Fix treatment of internal functions (PR 94434)\n\nIPA-SRA can segfault when processing a call to an internal function\nbecause such calls do not have corresponding call graphs and should be\ntreated like memory accesses anyway, which what the patch below does.\n\nThe patch makes an attempt to differentiate between reads and writes,\nalthough for things passed by value it does not make any difference.\nIt treats all arguments of functions denoted with internal_store_fn_p\nas written to, even though in practice only some are, but for IPA-SRA\npurposes, actions needed to be taken when processing a read are also\nalways performed when analyzing a write, so the code is just slightly\npessimistic.  But not as pessimistic as bailing out on any internal\ncall immediately.\n\nI have LTO bootstrapped and tested the patch on x86_64-linux and\nnormally bootstrapped and tested it on aarch64-linux, although one\nwhich is not SVE capable.  I would appreciate testing on such machine\ntoo - as well as a small testcase that would follow all relevant\nconventions in gcc.target/aarch64/sve.\n\n2020-04-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/94434\n\t* ipa-sra.c: Include internal-fn.h.\n\t(enum isra_scan_context): Update comment.\n\t(scan_function): Treat calls to internal_functions like loads or stores.", "tree": {"sha": "1642b3088f3e1327f239571eac927f38f861eda6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1642b3088f3e1327f239571eac927f38f861eda6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9707b593f88041e74e5cf5640ec64fea13a0387c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9707b593f88041e74e5cf5640ec64fea13a0387c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9707b593f88041e74e5cf5640ec64fea13a0387c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9707b593f88041e74e5cf5640ec64fea13a0387c/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b256222910cfa4a9b2b477dff8954e51fdc36bb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b256222910cfa4a9b2b477dff8954e51fdc36bb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b256222910cfa4a9b2b477dff8954e51fdc36bb9"}], "stats": {"total": 33, "additions": 27, "deletions": 6}, "files": [{"sha": "483bd85f65c33b42aae467ed3e9e5bb5fdc6dbf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9707b593f88041e74e5cf5640ec64fea13a0387c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9707b593f88041e74e5cf5640ec64fea13a0387c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9707b593f88041e74e5cf5640ec64fea13a0387c", "patch": "@@ -1,3 +1,10 @@\n+2020-04-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/94434\n+\t* ipa-sra.c: Include internal-fn.h.\n+\t(enum isra_scan_context): Update comment.\n+\t(scan_function): Treat calls to internal_functions like loads or stores.\n+\n 2020-04-14  Yang Yang <yangyang305@huawei.com>\n \n \tPR tree-optimization/94574"}, {"sha": "7c922e40a4e70f69962f02e16f195a91b5ce62ca", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9707b593f88041e74e5cf5640ec64fea13a0387c/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9707b593f88041e74e5cf5640ec64fea13a0387c/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=9707b593f88041e74e5cf5640ec64fea13a0387c", "patch": "@@ -83,7 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"cfganal.h\"\n #include \"tree-streamer.h\"\n-\n+#include \"internal-fn.h\"\n \n /* Bits used to track size of an aggregate in bytes interprocedurally.  */\n #define ISRA_ARG_SIZE_LIMIT_BITS 16\n@@ -1281,7 +1281,9 @@ allocate_access (gensum_param_desc *desc,\n }\n \n /* In what context scan_expr_access has been called, whether it deals with a\n-   load, a function argument, or a store.  */\n+   load, a function argument, or a store.  Please note that in rare\n+   circumstances when it is not clear if the access is a load or store,\n+   ISRA_CTX_STORE is used too.  */\n \n enum isra_scan_context {ISRA_CTX_LOAD, ISRA_CTX_ARG, ISRA_CTX_STORE};\n \n@@ -1870,15 +1872,27 @@ scan_function (cgraph_node *node, struct function *fun)\n \t    case GIMPLE_CALL:\n \t      {\n \t\tunsigned argument_count = gimple_call_num_args (stmt);\n-\t\tscan_call_info call_info;\n-\t\tcall_info.cs = node->get_edge (stmt);\n-\t\tcall_info.argument_count = argument_count;\n+\t\tisra_scan_context ctx = ISRA_CTX_ARG;\n+\t\tscan_call_info call_info, *call_info_p = &call_info;\n+\t\tif (gimple_call_internal_p (stmt))\n+\t\t  {\n+\t\t    call_info_p = NULL;\n+\t\t    ctx = ISRA_CTX_LOAD;\n+\t\t    internal_fn ifn = gimple_call_internal_fn (stmt);\n+\t\t    if (internal_store_fn_p (ifn))\n+\t\t      ctx = ISRA_CTX_STORE;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    call_info.cs = node->get_edge (stmt);\n+\t\t    call_info.argument_count = argument_count;\n+\t\t  }\n \n \t\tfor (unsigned i = 0; i < argument_count; i++)\n \t\t  {\n \t\t    call_info.arg_idx = i;\n \t\t    scan_expr_access (gimple_call_arg (stmt, i), stmt,\n-\t\t\t\t      ISRA_CTX_ARG, bb, &call_info);\n+\t\t\t\t      ctx, bb, call_info_p);\n \t\t  }\n \n \t\ttree lhs = gimple_call_lhs (stmt);"}]}