{"sha": "20dc7361944d6be4ed902115251a55cf1e7d0ba4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkYzczNjE5NDRkNmJlNGVkOTAyMTE1MjUxYTU1Y2YxZTdkMGJhNA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1999-01-25T11:23:01Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1999-01-25T11:23:01Z"}, "message": "cpplib.c: Don't include signal.h, sys/times.h, or sys/resource.h.\n\n1999-01-25 14:10 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n\t* cpplib.c: Don't include signal.h, sys/times.h, or\n\tsys/resource.h. Don't declare localtime.\n\t(macroexpand): Handle special symbols here.\n\t(push_macro_expansion): Chop off the trailing '@ ' if possible\n\there.\n\t(cpp_get_token): Don't do either of the above two things here.\n\tMove `string' label just after case '\"' so that wide strings\n\tdon't crash the preprocessor.\n\nFrom-SVN: r24858", "tree": {"sha": "f37a33d0c40430d2ef31f690d6ad0420c73a079d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f37a33d0c40430d2ef31f690d6ad0420c73a079d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20dc7361944d6be4ed902115251a55cf1e7d0ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dc7361944d6be4ed902115251a55cf1e7d0ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20dc7361944d6be4ed902115251a55cf1e7d0ba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dc7361944d6be4ed902115251a55cf1e7d0ba4/comments", "author": null, "committer": null, "parents": [{"sha": "1b18747f2eb6c9aec887707c3d1bda47a28e304a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b18747f2eb6c9aec887707c3d1bda47a28e304a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b18747f2eb6c9aec887707c3d1bda47a28e304a"}], "stats": {"total": 101, "additions": 46, "deletions": 55}, "files": [{"sha": "67142f6a608038ab9e54dfb850da1c5f41fe0d24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc7361944d6be4ed902115251a55cf1e7d0ba4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc7361944d6be4ed902115251a55cf1e7d0ba4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20dc7361944d6be4ed902115251a55cf1e7d0ba4", "patch": "@@ -1,3 +1,14 @@\n+1999-01-25 14:10 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+\t* cpplib.c: Don't include signal.h, sys/times.h, or\n+\tsys/resource.h. Don't declare localtime.\n+\t(macroexpand): Handle special symbols here.\n+\t(push_macro_expansion): Chop off the trailing '@ ' if possible\n+\there.\n+\t(cpp_get_token): Don't do either of the above two things here.\n+\tMove `string' label just after case '\"' so that wide strings\n+\tdon't crash the preprocessor.\n+\n Sun Jan 24 20:13:45 1999  David Edelsohn  <edelsohn@mhpcc.edu>\n \n \t* rs6000.md (left shift + set cr patterns): Add missing '#' to"}, {"sha": "8aa20c418e280db6324852f42c76ca55df42a56a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 35, "deletions": 55, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc7361944d6be4ed902115251a55cf1e7d0ba4/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc7361944d6be4ed902115251a55cf1e7d0ba4/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=20dc7361944d6be4ed902115251a55cf1e7d0ba4", "patch": "@@ -25,16 +25,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define STDC_VALUE 1\n #endif\n \n-#include <signal.h>\n-\n-#ifdef HAVE_SYS_TIMES_H\n-#include <sys/times.h>\n-#endif\n-\n-#ifdef HAVE_SYS_RESOURCE_H\n-# include <sys/resource.h>\n-#endif\n-\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"output.h\"\n@@ -170,10 +160,7 @@ enum file_change_code {same_file, enter_file, leave_file};\n /* External declarations.  */\n \n extern HOST_WIDE_INT cpp_parse_expr PARAMS ((cpp_reader *));\n-\n extern char *version_string;\n-extern struct tm *localtime ();\n-\f\n \n /* #include \"file\" looks in source file dir, then stack.  */\n /* #include <file> just looks in the stack.  */\n@@ -2380,7 +2367,7 @@ macroexpand (pfile, hp)\n      HASHNODE *hp;\n {\n   int nargs;\n-  DEFINITION *defn = hp->value.defn;\n+  DEFINITION *defn;\n   register U_CHAR *xbuf;\n   long start_line, start_column;\n   int xbuf_len;\n@@ -2403,10 +2390,23 @@ macroexpand (pfile, hp)\n     dump_single_macro (hp, pcp_outfile);\n #endif\n \n-  pfile->output_escapes++;\n   cpp_buf_line_and_col (cpp_file_buffer (pfile), &start_line, &start_column);\n \n+  /* Check for and handle special symbols. */\n+  if (hp->type != T_MACRO)\n+    {\n+      special_symbol (hp, pfile);\n+      xbuf_len = CPP_WRITTEN (pfile) - old_written;\n+      xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      bcopy (CPP_PWRITTEN (pfile), xbuf, xbuf_len + 1);\n+      push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n+      return;\n+    }\n+\n+  defn = hp->value.defn;\n   nargs = defn->nargs;\n+  pfile->output_escapes++;\n \n   if (nargs >= 0)\n     {\n@@ -2830,6 +2830,19 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n       && (is_idchar[xbuf[2]] || xbuf[2] == '(' || xbuf[2] == '\\''\n \t  || xbuf[2] == '\\\"'))\n     mbuf->cur += 2;\n+\n+  /* Likewise, avoid the extra space at the end of the macro expansion\n+     if this is safe.  (We can do a better job here since we can know\n+     what the next char will be.) */\n+  if (xbuf_len >= 3\n+      && mbuf->rlimit[-2] == '@'\n+      && mbuf->rlimit[-1] == ' ')\n+    {\n+      int c1 = mbuf->rlimit[-3];\n+      int c2 = CPP_BUF_PEEK (CPP_PREV_BUFFER (CPP_BUFFER (pfile)));\n+      if (c2 == EOF || ! unsafe_chars (c1, c2))\n+\tmbuf->rlimit -= 2;\n+    }\n }\n \f\n /* Like cpp_get_token, except that it does not read past end-of-line.\n@@ -4145,12 +4158,12 @@ cpp_get_token (pfile)\n \n \tcase '\\\"':\n \tcase '\\'':\n+\tstring:\n \t  /* A single quoted string is treated like a double -- some\n \t     programs (e.g., troff) are perverse this way */\n \t  cpp_buf_line_and_col (cpp_file_buffer (pfile),\n \t\t\t\t&start_line, &start_column);\n \t  old_written = CPP_WRITTEN (pfile);\n-\tstring:\n \t  CPP_PUTC (pfile, c);\n \t  while (1)\n \t    {\n@@ -4163,11 +4176,7 @@ cpp_get_token (pfile)\n \t\t\t boundary.  This can happen naturally if -traditional.\n \t\t\t Otherwise, only -D can make a macro with an unmatched\n \t\t\t quote.  */\n-\t\t\tcpp_buffer *next_buf\n-\t\t\t    = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n-\t\t\t(*CPP_BUFFER (pfile)->cleanup)\n-\t\t\t    (CPP_BUFFER (pfile), pfile);\n-\t\t\tCPP_BUFFER (pfile) = next_buf;\n+\t\t\tcpp_pop_buffer (pfile);\n \t\t\tcontinue;\n \t\t    }\n \t\t  if (!CPP_TRADITIONAL (pfile))\n@@ -4558,40 +4567,11 @@ cpp_get_token (pfile)\n \t      if (!is_macro_call)\n \t\treturn CPP_NAME;\n \t    }\n-\t    /* This is now known to be a macro call.  */\n-\n-\t    /* it might not actually be a macro.  */\n-\t    if (hp->type != T_MACRO) {\n-\t      int xbuf_len;  U_CHAR *xbuf;\n-\t      CPP_SET_WRITTEN (pfile, before_name_written);\n-\t      special_symbol (hp, pfile);\n-\t      xbuf_len = CPP_WRITTEN (pfile) - before_name_written;\n-\t      xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n-\t      CPP_SET_WRITTEN (pfile, before_name_written);\n-\t      bcopy (CPP_PWRITTEN (pfile), xbuf, xbuf_len + 1);\n-\t      push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n-\t    }\n-\t    else\n-\t      {\n-\t\t/* Expand the macro, reading arguments as needed,\n-\t\t   and push the expansion on the input stack.  */\n-\t\tmacroexpand (pfile, hp);\n-\t\tCPP_SET_WRITTEN (pfile, before_name_written);\n-\t      }\n-\n-\t    /* An extra \"@ \" is added to the end of a macro expansion\n-\t       to prevent accidental token pasting.  We prefer to avoid\n-\t       unneeded extra spaces (for the sake of cpp-using tools like\n-\t       imake).  Here we remove the space if it is safe to do so.  */\n-\t    if (pfile->buffer->rlimit - pfile->buffer->cur >= 3\n-\t\t&& pfile->buffer->rlimit[-2] == '@'\n-\t\t&& pfile->buffer->rlimit[-1] == ' ')\n-\t      {\n-\t\tint c1 = pfile->buffer->rlimit[-3];\n-\t\tint c2 = CPP_BUF_PEEK (CPP_PREV_BUFFER (CPP_BUFFER (pfile)));\n-\t\tif (c2 == EOF || ! unsafe_chars (c1, c2))\n-\t\t  pfile->buffer->rlimit -= 2;\n-\t      }\n+\t    /* This is now known to be a macro call.\n+\t       Expand the macro, reading arguments as needed,\n+\t       and push the expansion on the input stack.  */\n+\t    macroexpand (pfile, hp);\n+\t    CPP_SET_WRITTEN (pfile, before_name_written);\n \t  }\n \t  goto get_next;\n "}]}