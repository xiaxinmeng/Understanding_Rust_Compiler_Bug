{"sha": "91d84fadf41ff75390c74646305773f09d7ce153", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFkODRmYWRmNDFmZjc1MzkwYzc0NjQ2MzA1NzczZjA5ZDdjZTE1Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-29T01:13:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-29T01:13:53Z"}, "message": "flow.c (add_to_mem_set_list): New function.\n\n        * flow.c (add_to_mem_set_list): New function.\n        (init_propagate_block_info): Use it.\n        (mark_set_1): Likewise.\n        (insn_dead_p): Canonicalize memory address for dead store\n        comparison.  Allow wider mode stores to kill narrower mode stores.\n        (invalidate_mems_from_autoinc): Use invalidate_mems_from_set.\n        (invalidate_mems_from_set): Don't handle MEMs.\n\nFrom-SVN: r44441", "tree": {"sha": "93cb29635dac9e135fa5e9d2c1464c0b024938bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93cb29635dac9e135fa5e9d2c1464c0b024938bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91d84fadf41ff75390c74646305773f09d7ce153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d84fadf41ff75390c74646305773f09d7ce153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d84fadf41ff75390c74646305773f09d7ce153", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d84fadf41ff75390c74646305773f09d7ce153/comments", "author": null, "committer": null, "parents": [{"sha": "0a02170ffd8463b17026d8e5e5eb7c3708923d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a02170ffd8463b17026d8e5e5eb7c3708923d14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a02170ffd8463b17026d8e5e5eb7c3708923d14"}], "stats": {"total": 146, "additions": 76, "deletions": 70}, "files": [{"sha": "42d3f44744f0a635a55de27c24b8ec679c9ee56b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d84fadf41ff75390c74646305773f09d7ce153/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d84fadf41ff75390c74646305773f09d7ce153/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91d84fadf41ff75390c74646305773f09d7ce153", "patch": "@@ -1,3 +1,13 @@\n+2001-07-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* flow.c (add_to_mem_set_list): New function.\n+\t(init_propagate_block_info): Use it.\n+\t(mark_set_1): Likewise.\n+\t(insn_dead_p): Canonicalize memory address for dead store\n+\tcomparison.  Allow wider mode stores to kill narrower mode stores.\n+\t(invalidate_mems_from_autoinc): Use invalidate_mems_from_set.\n+\t(invalidate_mems_from_set): Don't handle MEMs.\n+\n 2001-07-28  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.h: Fix formatting."}, {"sha": "7cdaedc3af9ab5a2857b358f7aecb39bb1b4db84", "filename": "gcc/flow.c", "status": "modified", "additions": 66, "deletions": 70, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d84fadf41ff75390c74646305773f09d7ce153/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d84fadf41ff75390c74646305773f09d7ce153/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=91d84fadf41ff75390c74646305773f09d7ce153", "patch": "@@ -449,6 +449,8 @@ static void print_rtl_and_abort_fcn\tPARAMS ((const char *, int,\n \t\t\t\t\t\t const char *))\n \t\t\t\t\tATTRIBUTE_NORETURN;\n \n+static void add_to_mem_set_list\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t rtx));\n static void invalidate_mems_from_autoinc PARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t  rtx));\n static void invalidate_mems_from_set\tPARAMS ((struct propagate_block_info *,\n@@ -1797,8 +1799,7 @@ try_redirect_by_replacing_jump (e, target)\n    When emmiting jump to redirect an fallthru edge, it should always\n    appear after the LOOP_BEG notes, as loop optimizer expect loop to\n    eighter start by fallthru edge or jump following the LOOP_BEG note\n-   jumping to the loop exit test.\n- */\n+   jumping to the loop exit test.  */\n rtx\n last_loop_beg_note (insn)\n      rtx insn;\n@@ -5441,23 +5442,7 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n \t\t|| (GET_CODE (XEXP (canon_mem, 0)) == PLUS\n \t\t    && XEXP (XEXP (canon_mem, 0), 0) == frame_pointer_rtx\n \t\t    && GET_CODE (XEXP (XEXP (canon_mem, 0), 1)) == CONST_INT))\n-\t      {\n-#ifdef AUTO_INC_DEC\n-\t\t/* Store a copy of mem, otherwise the address may be scrogged\n-\t\t   by find_auto_inc.  This matters because insn_dead_p uses\n-\t\t   an rtx_equal_p check to determine if two addresses are\n-\t\t   the same.  This works before find_auto_inc, but fails\n-\t\t   after find_auto_inc, causing discrepencies between the\n-\t\t   set of live registers calculated during the\n-\t\t   calculate_global_regs_live phase and what actually exists\n-\t\t   after flow completes, leading to aborts.  */\n-\t\tif (flags & PROP_AUTOINC)\n-\t\t  mem = shallow_copy_rtx (mem);\n-#endif\n-\t\tpbi->mem_set_list = alloc_EXPR_LIST (0, mem, pbi->mem_set_list);\n-\t\tif (++pbi->mem_set_list_len >= MAX_MEM_SET_LIST_LEN)\n-\t\t  break;\n-\t      }\n+\t      add_to_mem_set_list (pbi, canon_mem);\n \t  }\n     }\n \n@@ -5614,11 +5599,13 @@ insn_dead_p (pbi, x, call_ok, notes)\n \n       if (GET_CODE (r) == MEM)\n \t{\n-\t  rtx temp;\n+\t  rtx temp, canon_r;\n \n-\t  if (MEM_VOLATILE_P (r))\n+\t  if (MEM_VOLATILE_P (r) || GET_MODE (r) == BLKmode)\n \t    return 0;\n \n+\t  canon_r = canon_rtx (r);\n+\n \t  /* Walk the set of memory locations we are currently tracking\n \t     and see if one is an identical match to this memory location.\n \t     If so, this memory write is dead (remember, we're walking\n@@ -5630,8 +5617,11 @@ insn_dead_p (pbi, x, call_ok, notes)\n \t      {\n \t\trtx mem = XEXP (temp, 0);\n \n-\t\tif (rtx_equal_p (mem, r))\n+\t\tif (rtx_equal_p (XEXP (canon_r, 0), XEXP (mem, 0))\n+\t\t    && (GET_MODE_SIZE (GET_MODE (canon_r))\n+\t\t\t<= GET_MODE_SIZE (GET_MODE (mem))))\n \t\t  return 1;\n+\n #ifdef AUTO_INC_DEC\n \t\t/* Check if memory reference matches an auto increment. Only\n \t\t   post increment/decrement or modify are valid.  */\n@@ -5837,6 +5827,53 @@ regno_clobbered_at_setjmp (regno)\n \t  && REGNO_REG_SET_P (regs_live_at_setjmp, regno));\n }\n \f\n+/* Add MEM to PBI->MEM_SET_LIST.  MEM should be canonical.  Respect the\n+   maximal list size; look for overlaps in mode and select the largest.  */\n+static void\n+add_to_mem_set_list (pbi, mem)\n+     struct propagate_block_info *pbi;\n+     rtx mem;\n+{\n+  rtx i;\n+\n+  /* We don't know how large a BLKmode store is, so we must not\n+     take them into consideration.  */\n+  if (GET_MODE (mem) == BLKmode)\n+    return;\n+\n+  for (i = pbi->mem_set_list; i ; i = XEXP (i, 1))\n+    {\n+      rtx e = XEXP (i, 0);\n+      if (rtx_equal_p (XEXP (mem, 0), XEXP (e, 0)))\n+\t{\n+\t  if (GET_MODE_SIZE (GET_MODE (mem)) > GET_MODE_SIZE (GET_MODE (e)))\n+\t    {\n+#ifdef AUTO_INC_DEC\n+\t      /* If we must store a copy of the mem, we can just modify\n+\t\t the mode of the stored copy.  */\n+\t      if (pbi->flags & PROP_AUTOINC)\n+\t        PUT_MODE (e, GET_MODE (mem));\n+\t      else\n+#endif\n+\t        XEXP (i, 0) = mem;\n+\t    }\n+\t  return;\n+\t}\n+    }\n+\n+  if (pbi->mem_set_list_len < MAX_MEM_SET_LIST_LEN)\n+    {\n+#ifdef AUTO_INC_DEC\n+      /* Store a copy of mem, otherwise the address may be\n+\t scrogged by find_auto_inc.  */\n+      if (pbi->flags & PROP_AUTOINC)\n+\tmem = shallow_copy_rtx (mem);\n+#endif\n+      pbi->mem_set_list = alloc_EXPR_LIST (0, mem, pbi->mem_set_list);\n+      pbi->mem_set_list_len++;\n+    }\n+}\n+\n /* INSN references memory, possibly using autoincrement addressing modes.\n    Find any entries on the mem_set_list that need to be invalidated due\n    to an address change.  */\n@@ -5848,36 +5885,11 @@ invalidate_mems_from_autoinc (pbi, insn)\n {\n   rtx note = REG_NOTES (insn);\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-    {\n-      if (REG_NOTE_KIND (note) == REG_INC)\n-\t{\n-\t  rtx temp = pbi->mem_set_list;\n-\t  rtx prev = NULL_RTX;\n-\t  rtx next;\n-\n-\t  while (temp)\n-\t    {\n-\t      next = XEXP (temp, 1);\n-\t      if (reg_overlap_mentioned_p (XEXP (note, 0), XEXP (temp, 0)))\n-\t\t{\n-\t\t  /* Splice temp out of list.  */\n-\t\t  if (prev)\n-\t\t    XEXP (prev, 1) = next;\n-\t\t  else\n-\t\t    pbi->mem_set_list = next;\n-\t\t  free_EXPR_LIST_node (temp);\n-\t\t  pbi->mem_set_list_len--;\n-\t\t}\n-\t      else\n-\t\tprev = temp;\n-\t      temp = next;\n-\t    }\n-\t}\n-    }\n+    if (REG_NOTE_KIND (note) == REG_INC)\n+      invalidate_mems_from_set (pbi, XEXP (note, 0));\n }\n \n-/* EXP is either a MEM or a REG.  Remove any dependant entries\n-   from pbi->mem_set_list.  */\n+/* EXP is a REG.  Remove any dependant entries from pbi->mem_set_list.  */\n \n static void\n invalidate_mems_from_set (pbi, exp)\n@@ -5891,10 +5903,7 @@ invalidate_mems_from_set (pbi, exp)\n   while (temp)\n     {\n       next = XEXP (temp, 1);\n-      if ((GET_CODE (exp) == MEM\n-\t   && output_dependence (XEXP (temp, 0), exp))\n-\t  || (GET_CODE (exp) == REG\n-\t      && reg_overlap_mentioned_p (exp, XEXP (temp, 0))))\n+      if (reg_overlap_mentioned_p (exp, XEXP (temp, 0)))\n \t{\n \t  /* Splice this entry out of the list.  */\n \t  if (prev)\n@@ -6091,7 +6100,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n      If this set is a REG, then it kills any MEMs which use the reg.  */\n   if (optimize && (flags & PROP_SCAN_DEAD_CODE))\n     {\n-      if (GET_CODE (reg) == MEM || GET_CODE (reg) == REG)\n+      if (GET_CODE (reg) == REG)\n \tinvalidate_mems_from_set (pbi, reg);\n \n       /* If the memory reference had embedded side effects (autoincrement\n@@ -6100,27 +6109,14 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n       if (insn && GET_CODE (reg) == MEM)\n \tinvalidate_mems_from_autoinc (pbi, insn);\n \n-      if (pbi->mem_set_list_len < MAX_MEM_SET_LIST_LEN\n-\t  && GET_CODE (reg) == MEM && ! side_effects_p (reg)\n+      if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n \t  /* ??? With more effort we could track conditional memory life.  */\n \t  && ! cond\n-\t  /* We do not know the size of a BLKmode store, so we do not track\n-\t     them for redundant store elimination.  */\n-\t  && GET_MODE (reg) != BLKmode\n \t  /* There are no REG_INC notes for SP, so we can't assume we'll see\n \t     everything that invalidates it.  To be safe, don't eliminate any\n \t     stores though SP; none of them should be redundant anyway.  */\n \t  && ! reg_mentioned_p (stack_pointer_rtx, reg))\n-\t{\n-#ifdef AUTO_INC_DEC\n-\t  /* Store a copy of mem, otherwise the address may be\n-\t     scrogged by find_auto_inc.  */\n-\t  if (flags & PROP_AUTOINC)\n-\t    reg = shallow_copy_rtx (reg);\n-#endif\n-\t  pbi->mem_set_list = alloc_EXPR_LIST (0, reg, pbi->mem_set_list);\n-\t  pbi->mem_set_list_len++;\n-\t}\n+        add_to_mem_set_list (pbi, canon_rtx (reg));\n     }\n \n   if (GET_CODE (reg) == REG"}]}