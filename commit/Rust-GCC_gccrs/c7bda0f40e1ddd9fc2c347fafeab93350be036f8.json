{"sha": "c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiZGEwZjQwZTFkZGQ5ZmMyYzM0N2ZhZmVhYjkzMzUwYmUwMzZmOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:16:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:16:14Z"}, "message": "poly_int: vectorizable_call\n\nThis patch makes vectorizable_call handle variable-length vectors.\nThe only substantial change is to use build_index_vector for\nIFN_GOMP_SIMD_LANE; this makes no functional difference for\nfixed-length vectors.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-stmts.c (vectorizable_call): Treat the number of\n\tvectors as polynomial.  Use build_index_vector for\n\tIFN_GOMP_SIMD_LANE.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256137", "tree": {"sha": "7516a622c4b68d05b3807f30526c3f42782b6b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7516a622c4b68d05b3807f30526c3f42782b6b9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bda0f40e1ddd9fc2c347fafeab93350be036f8/comments", "author": null, "committer": null, "parents": [{"sha": "4d694b27c3697f7eef16a17eb926076bf836575a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d694b27c3697f7eef16a17eb926076bf836575a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d694b27c3697f7eef16a17eb926076bf836575a"}], "stats": {"total": 24, "additions": 14, "deletions": 10}, "files": [{"sha": "9aded12aadcdacbdf65a42f6f28d592094aa550f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bda0f40e1ddd9fc2c347fafeab93350be036f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bda0f40e1ddd9fc2c347fafeab93350be036f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "patch": "@@ -1,3 +1,11 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-stmts.c (vectorizable_call): Treat the number of\n+\tvectors as polynomial.  Use build_index_vector for\n+\tIFN_GOMP_SIMD_LANE.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "210632b51dbd4efb76815ce4e84c29c466036d61", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bda0f40e1ddd9fc2c347fafeab93350be036f8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bda0f40e1ddd9fc2c347fafeab93350be036f8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "patch": "@@ -2650,8 +2650,8 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (gs), prev_stmt_info;\n   tree vectype_out, vectype_in;\n-  int nunits_in;\n-  int nunits_out;\n+  poly_uint64 nunits_in;\n+  poly_uint64 nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n@@ -2771,11 +2771,11 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   /* FORNOW */\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n-  if (nunits_in == nunits_out / 2)\n+  if (known_eq (nunits_in * 2, nunits_out))\n     modifier = NARROW;\n-  else if (nunits_out == nunits_in)\n+  else if (known_eq (nunits_out, nunits_in))\n     modifier = NONE;\n-  else if (nunits_out == nunits_in / 2)\n+  else if (known_eq (nunits_out * 2, nunits_in))\n     modifier = WIDEN;\n   else\n     return false;\n@@ -2974,11 +2974,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  if (gimple_call_internal_p (stmt)\n \t      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n \t    {\n-\t      tree_vector_builder v (vectype_out, 1, 3);\n-\t      for (int k = 0; k < 3; ++k)\n-\t\tv.quick_push (build_int_cst (unsigned_type_node,\n-\t\t\t\t\t     j * nunits_out + k));\n-\t      tree cst = v.build ();\n+\t      tree cst = build_index_vector (vectype_out, j * nunits_out, 1);\n \t      tree new_var\n \t\t= vect_get_new_ssa_name (vectype_out, vect_simple_var, \"cst_\");\n \t      gimple *init_stmt = gimple_build_assign (new_var, cst);"}]}