{"sha": "89d9bab0aa00d6968621ec5db2ca36862ed6a64c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkOWJhYjBhYTAwZDY5Njg2MjFlYzVkYjJjYTM2ODYyZWQ2YTY0Yw==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2020-04-17T20:56:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-17T08:14:21Z"}, "message": "[Ada] Nested subprograms in protected subprograms improperly handled in GNAT-LLVM\n\n2020-06-17  Gary Dismukes  <dismukes@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch9.adb (Build_Protected_Subp_Specification): Add ???\n\tcomment about the flag Has_Nested_Subprogram not being set here.\n\t(Expand_N_Protected_Body): If the original body for a protected\n\tsubprogram has the flag Has_Nested_Subprogram set, then set that\n\tflag on the new unprotected subprogram body that's created for\n\tit, and reset the Scope fields of its top level declarations,\n\twhich have been effectively taken from the original protected\n\tsubprogram body. Add ??? comment about unclear testing of\n\tCorresponding_Spec.", "tree": {"sha": "ef4721513d82a4d583f079c6a4850ee45ab4f0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef4721513d82a4d583f079c6a4850ee45ab4f0bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d9bab0aa00d6968621ec5db2ca36862ed6a64c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d9bab0aa00d6968621ec5db2ca36862ed6a64c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d9bab0aa00d6968621ec5db2ca36862ed6a64c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d9bab0aa00d6968621ec5db2ca36862ed6a64c/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8afbdb8a64c8f269bdda336ee8150d86b42beb04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afbdb8a64c8f269bdda336ee8150d86b42beb04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8afbdb8a64c8f269bdda336ee8150d86b42beb04"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "0b06ce50a03b21c03b1c3bb8e7e3d2a5aef814f2", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9bab0aa00d6968621ec5db2ca36862ed6a64c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9bab0aa00d6968621ec5db2ca36862ed6a64c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=89d9bab0aa00d6968621ec5db2ca36862ed6a64c", "patch": "@@ -3933,6 +3933,13 @@ package body Exp_Ch9 is\n \n       Set_Is_Eliminated (New_Id, Is_Eliminated (Def_Id));\n \n+      --  It seems we should set Has_Nested_Subprogram here, but instead we\n+      --  currently set it in Expand_N_Protected_Body, because the entity\n+      --  created here isn't the one that Corresponding_Spec of the body\n+      --  will later be set to, and that's the entity where it's needed. ???\n+\n+      Set_Has_Nested_Subprogram (New_Id, Has_Nested_Subprogram (Def_Id));\n+\n       if Nkind (Specification (Decl)) = N_Procedure_Specification then\n          New_Spec :=\n            Make_Procedure_Specification (Loc,\n@@ -8716,10 +8723,32 @@ package body Exp_Ch9 is\n                   Current_Node := New_Op_Body;\n                   Analyze (New_Op_Body);\n \n+                  --  When the original protected body has nested subprograms,\n+                  --  the new body also has them, so set the flag accordingly\n+                  --  and reset the scopes of the top-level nested subprograms\n+                  --  and other declaration entities so that they now refer to\n+                  --  the new body's entity. (It would preferable to do this\n+                  --  within Build_Protected_Sub_Specification, which is called\n+                  --  from Build_Unprotected_Subprogram_Body, but the needed\n+                  --  subprogram entity isn't available via Corresponding_Spec\n+                  --  until after the above Analyze call.)\n+\n+                  if Has_Nested_Subprogram (Corresponding_Spec (Op_Body)) then\n+                     Set_Has_Nested_Subprogram\n+                       (Corresponding_Spec (New_Op_Body));\n+\n+                     Reset_Scopes_To\n+                       (New_Op_Body, Corresponding_Spec (New_Op_Body));\n+                  end if;\n+\n                   --  Build the corresponding protected operation. This is\n                   --  needed only if this is a public or private operation of\n                   --  the type.\n \n+                  --  Why do we need to test for Corresponding_Spec being\n+                  --  present here when it's assumed to be set further above\n+                  --  in the Is_Eliminated test???\n+\n                   if Present (Corresponding_Spec (Op_Body)) then\n                      Op_Decl :=\n                        Unit_Declaration_Node (Corresponding_Spec (Op_Body));"}]}